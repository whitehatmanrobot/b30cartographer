ge the clipboard
// Syncronize this, so no other thread's AV while
// checking the clipboard content
// store 1 for write, 0 for read
static  LONG    g_ClipOpened = 0;

/*++
 *  Function:
 *      SCClipbaord
 *  Description:
 *      Called by smclient, when clipboard command is interpreted
 *      when eClipOp is COPY_TO_CLIPBOARD it copies the lpszFileName to
 *      the clipboard. If eClipOp is PASTE_FROM_CLIPBOARD it
 *      checks the clipboard content against the content of lpszFileName
 *  Arguments:
 *      pCI         - connection context
 *      eClipOp     - clipboard operation. Possible values:
 *                    COPY_TO_CLIPBOARD and PASTE_FROM_CLIPBOARD
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR  
SMCAPI
SCClipboard(
    PCONNECTINFO pCI, const CLIPBOARDOPS eClipOp, LPCSTR lpszFileName)
{
    LPCSTR  rv = NULL;
    INT     hFile = -1;
    LONG    clplength = 0;
    UINT    uiFormat = 0;
    PBYTE   ghClipData = NULL;
    HGLOBAL hNewData = NULL;
    PBYTE   pClipData = NULL;
    BOOL    bClipboardOpen = FALSE;
    BOOL    bFreeClipHandle = TRUE;

    LONG    prevOp = 1;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->bConsole)
    {
        rv = _SCConsClipboard( pCI, eClipOp, lpszFileName );
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (lpszFileName == NULL || !(*lpszFileName))
    {
        // No filename specified, work like an empty clipboard is requested
        if (eClipOp == COPY_TO_CLIPBOARD)
        {
#ifdef  _RCLX
            if (pCI->RClxMode)
            {
                if (!RClx_SendClipboard((PRCLXCONTEXT)(pCI->hClient),
                        NULL, 0, 0))
                    rv = ERR_COPY_CLIPBOARD;
            } else {
#endif  // _RCLX
                if (!Clp_EmptyClipboard())
                    rv = ERR_COPY_CLIPBOARD;
#ifdef  _RCLX
            }
#endif  // _RCLX
        } else if (eClipOp == PASTE_FROM_CLIPBOARD)
        {
#ifdef  _RCLX
            if (pCI->RClxMode)
            {
                if (!RClx_SendClipboardRequest((PRCLXCONTEXT)(pCI->hClient), 0))
                {
                    rv = ERR_PASTE_CLIPBOARD;
                    goto exitpt;
                }
                if (_Wait4ClipboardTimeout(pCI, pCI->pConfigInfo->WAIT4STR_TIMEOUT))
                {
                    rv = ERR_PASTE_CLIPBOARD;
                    goto exitpt;
                }

                // We do not expect to receive clipboard data
                // just format ID
                if (!pCI->uiClipboardFormat)
                // if the format is 0, then there's no clipboard
                    rv = NULL;
                else
                    rv = ERR_PASTE_CLIPBOARD_DIFFERENT_SIZE;
            } else {
#endif  // _RCLX
                if (Clp_CheckEmptyClipboard())
                    rv = NULL;
                else
                    rv = ERR_PASTE_CLIPBOARD_DIFFERENT_SIZE;
#ifdef  _RCLX
            }
#endif  // _RCLX
        } else {
            TRACE((ERROR_MESSAGE, "SCClipboard: Invalid filename\n"));
            rv = ERR_INVALID_PARAM;
        }
        goto exitpt;
    }

    if (eClipOp == COPY_TO_CLIPBOARD)
    {
        // Open the file for reading
        hFile = _open(lpszFileName, _O_RDONLY|_O_BINARY);
        if (hFile == -1)
        {
            TRACE((ERROR_MESSAGE,
                   "Error opening file: %s. errno=%d\n", lpszFileName, errno));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        // Get the clipboard length (in the file)
        clplength = _filelength(hFile) - sizeof(uiFormat);
        // Get the format
        if (_read(hFile, &uiFormat, sizeof(uiFormat)) != sizeof(uiFormat))
        {
            TRACE((ERROR_MESSAGE,
                   "Error reading from file. errno=%d\n", errno));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        ghClipData = (PBYTE) GlobalAlloc(GMEM_MOVEABLE|GMEM_DDESHARE, clplength);
        if (!ghClipData)
        {
            TRACE((ERROR_MESSAGE,
                   "Can't allocate %d bytes\n", clplength));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        pClipData = (PBYTE) GlobalLock( ghClipData );
        if (!pClipData)
        {
            TRACE((ERROR_MESSAGE,
                   "Can't lock handle 0x%x\n", ghClipData));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        if (_read(hFile, pClipData, clplength) != clplength)
        {
            TRACE((ERROR_MESSAGE,
                   "Error reading from file. errno=%d\n", errno));
            rv = ERR_COPY_CLIPBOARD;
            goto exitpt;
        }

        GlobalUnlock(ghClipData);

#ifdef  _RCLX
        if (pCI->RClxMode)
        // RCLX mode, send the data to the client's machine
        {
            if (!(pClipData = (PBYTE) GlobalLock(ghClipData)))
            {
                rv = ERR_COPY_CLIPBOARD;
                goto exitpt;
            }

            if (!RClx_SendClipboard((PRCLXCONTEXT)(pCI->hClient), 
                                    pClipData, clplength, uiFormat))
            {
                rv = ERR_COPY_CLIPBOARD;
                goto exitpt;
            }
        } else {
#endif  // _RCLX
        // Local mode, change the clipboard on this machine
            if ((prevOp = InterlockedExchange(&g_ClipOpened, 1)))
            {
                rv = ERR_CLIPBOARD_LOCKED;
                goto exitpt;
            }

            if (!OpenClipboard(NULL))
            {
                TRACE((ERROR_MESSAGE,
                       "Can't open the clipboard. GetLastError=%d\n",
                       GetLastError()));
                rv = ERR_COPY_CLIPBOARD;
                goto exitpt;
            }

            bClipboardOpen = TRUE;

            // Empty the clipboard, so we'll have only one entry
            EmptyClipboard();

            if (!Clp_SetClipboardData(uiFormat, ghClipData, clplength, &bFreeClipHandle))
            {
                TRACE((ERROR_MESSAGE,
                       "SetClipboardData failed. GetLastError=%d\n", 
                       GetLastError()));
                rv = ERR_COPY_CLIPBOARD;
                goto exitpt;
            }
#ifdef  _RCLX
        }
#endif  // _RCLX

    } else if (eClipOp == PASTE_FROM_CLIPBOARD)
    {
        INT nClipDataSize;

        // Open the file for reading
        hFile = _open(lpszFileName, _O_RDONLY|_O_BINARY);
        if (hFile == -1)
        {
            TRACE((ERROR_MESSAGE,
                   "Error opening file: %s. errno=%d\n", lpszFileName, errno));
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }

        // Get the clipboard length (in the file)
        clplength = _filelength(hFile) - sizeof(uiFormat);
        // Get the format
        if (_read(hFile, &uiFormat, sizeof(uiFormat)) != sizeof(uiFormat))
        {
            TRACE((ERROR_MESSAGE,
                   "Error reading from file. errno=%d\n", errno));
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }

        //
        // TODO: For now, set nClipDataSize to avoid warning, but later
        // verify usage is safe.
        //

        nClipDataSize = 0;
#ifdef  _RCLX
        // This piece retrieves the clipboard
        if (pCI->RClxMode)
        // Send request for a clipboard
        {
            if (!RClx_SendClipboardRequest((PRCLXCONTEXT)(pCI->hClient), uiFormat))
            {
                rv = ERR_PASTE_CLIPBOARD;
                goto exitpt;
            }
            if (_Wait4ClipboardTimeout(pCI, pCI->pConfigInfo->WAIT4STR_TIMEOUT))
            {
                rv = ERR_PASTE_CLIPBOARD;
                goto exitpt;
            }

            ghClipData = (PBYTE) pCI->ghClipboard;
            // Get the clipboard size
            nClipDataSize = pCI->nClipboardSize;
        } else {
#endif  // _RCLX
        // retrieve the local clipboard
            if ((prevOp = InterlockedExchange(&g_ClipOpened, 1)))
            {
                rv = ERR_CLIPBOARD_LOCKED;
                goto exitpt;
            }

            if (!OpenClipboard(NULL))
            {
                TRACE((ERROR_MESSAGE,
                       "Can't open the clipboard. GetLastError=%d\n",
                       GetLastError()));
                rv = ERR_PASTE_CLIPBOARD;
                goto exitpt;
            }

            bClipboardOpen = TRUE;

            // Retrieve the data
            ghClipData = (PBYTE) GetClipboardData(uiFormat);
            if (ghClipData)
            {
                Clp_GetClipboardData(uiFormat, 
                                     ghClipData, 
                                     &nClipDataSize, 
                                     &hNewData);
                bFreeClipHandle = FALSE;
            } 

            if (hNewData)
                ghClipData = (PBYTE) hNewData;
#ifdef  _RCLX
        }
#endif  // _RCLX

        if (!ghClipData)
        {
            TRACE((ERROR_MESSAGE,
                   "Can't get clipboard data (empty clipboard ?). GetLastError=%d\n",
                   GetLastError()));
            rv = ERR_PASTE_CLIPBOARD_EMPTY;
            goto exitpt;
        }

        if (!nClipDataSize)
            TRACE((WARNING_MESSAGE, "Clipboard is empty.\n"));

        pClipData = (PBYTE) GlobalLock(ghClipData);
        if (!pClipData)
        {
            TRACE((ERROR_MESSAGE,
                   "Can't lock global mem. GetLastError=%d\n", 
                   GetLastError()));
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }

#ifdef  _RCLX
        // Check if the client is on Win16 platform
        // and the clipboard is paragraph aligned
        // the file size is just bellow this size
        if (pCI->RClxMode && 
            (strstr(pCI->szClientType, "WIN16") != NULL) &&
            ((nClipDataSize % 16) == 0) &&
            ((nClipDataSize - clplength) < 16) &&
            (nClipDataSize != 0))
        {
            // if so, then cut the clipboard size with the difference
            nClipDataSize = clplength;
        }
        else 
#endif  // _RCLX
        if (nClipDataSize != clplength)
        {
            TRACE((INFO_MESSAGE, "Different length: file=%d, clipbrd=%d\n",
                    clplength, nClipDataSize));
            rv = ERR_PASTE_CLIPBOARD_DIFFERENT_SIZE;
            goto exitpt;
        }

        // compare the data
        {
            BYTE    pBuff[1024];
            PBYTE   pClp = pClipData;
            UINT    nBytes;
            BOOL    bEqu = TRUE;
            
            while (bEqu &&
                   (nBytes = _read(hFile, pBuff, sizeof(pBuff))) && 
                   nBytes != -1)
            {
                if (memcmp(pBuff, pClp, nBytes))
                    bEqu = FALSE;

                pClp += nBytes;
            }

            if (!bEqu)
            {
                TRACE((INFO_MESSAGE, "Clipboard and file are not equal\n"));
                rv = ERR_PASTE_CLIPBOARD_NOT_EQUAL;
            }
        }

    } else
        rv = ERR_UNKNOWN_CLIPBOARD_OP;

exitpt:
    // Do the cleanup

    // Release the clipboard handle
    if (pClipData)
        GlobalUnlock(ghClipData);

#ifdef  _RCLX
    // free any clipboard received in RCLX mode
    if (pCI->RClxMode && pCI->ghClipboard)
    {
        GlobalFree(pCI->ghClipboard);
        pCI->ghClipboard = NULL;
    }
    else 
#endif  // _RCLX
    if (ghClipData && eClipOp == COPY_TO_CLIPBOARD && bFreeClipHandle)
        GlobalFree(ghClipData);

    if (hNewData)
        GlobalFree(hNewData);

    // Close the file
    if (hFile != -1)
        _close(hFile);

    // Close the clipboard
    if (bClipboardOpen)
        CloseClipboard();
    if (!prevOp)
        InterlockedExchange(&g_ClipOpened, 0);

    return rv;
}

/*++
 *  Function:
 *      SCSaveClipboard
 *  Description:
 *      Save the clipboard in file (szFileName) with
 *      format specified in szFormatName
 *  Arguments:
 *      pCI         - connection context
 *      szFormatName- format name
 *      szFileName  - the name of the file to save to
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !perlext
 --*/
PROTOCOLAPI
LPCSTR 
SMCAPI
SCSaveClipboard(
    PCONNECTINFO pCI,
    LPCSTR szFormatName,
    LPCSTR szFileName)
{
    LPCSTR  rv = ERR_SAVE_CLIPBOARD;
    BOOL    bClipboardOpen = FALSE;
    UINT    nFormatID = 0;
    HGLOBAL ghClipData = NULL;
    HGLOBAL hNewData = NULL;
    INT     nClipDataSize;
    CHAR    *pClipData = NULL;
    INT     hFile = -1;

    LONG    prevOp = 1;

    // ++++++ First go thru parameter check
    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (szFormatName == NULL || !(*szFormatName))
    {
        TRACE((ERROR_MESSAGE, "SCClipboard: Invalid format name\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (szFileName == NULL || !(*szFileName))
    {
        TRACE((ERROR_MESSAGE, "SCClipboard: Invalid filename\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }
    // ------ End of parameter check
    //

#ifdef  _RCLX
    if (pCI->RClxMode)
    {
        nFormatID = _GetKnownClipboardFormatIDByName(szFormatName);
        if (!nFormatID)
        {
            TRACE((ERROR_MESSAGE, "Can't get the clipboard format ID: %s.\n", szFormatName));
            goto exitpt;
        }

        // Send request for a clipboard
        if (!RClx_SendClipboardRequest((PRCLXCONTEXT)(pCI->hClient), nFormatID))
        {
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }
        if (_Wait4ClipboardTimeout(pCI, pCI->pConfigInfo->WAIT4STR_TIMEOUT))
        {
            rv = ERR_PASTE_CLIPBOARD;
            goto exitpt;
        }

        ghClipData = pCI->ghClipboard;
        // Get the clipboard size
        nClipDataSize = pCI->nClipboardSize;

        if (!ghClipData || !nClipDataSize)
        {
            TRACE((WARNING_MESSAGE, "Clipboard is empty.\n"));
            goto exitpt;
        }
    } else {
#endif  // _RCLX
        // local mode
        // Open the clipboard

        if ((prevOp = InterlockedExchange(&g_ClipOpened, 1)))
        {
            rv = ERR_CLIPBOARD_LOCKED;
            goto exitpt;
        }

        if (!OpenClipboard(NULL))
        {
            TRACE((ERROR_MESSAGE, "Can't open the clipboard. GetLastError=%d\n",
                    GetLastError()));
            goto exitpt;
        }

        bClipboardOpen = TRUE;

        nFormatID = Clp_GetClipboardFormat(szFormatName);

        if (!nFormatID)
        {
            TRACE((ERROR_MESSAGE, "Can't get the clipboard format: %s.\n", szFormatName));
            goto exitpt;
        }

        TRACE((INFO_MESSAGE, "Format ID: %d(0x%X)\n", nFormatID, nFormatID));

        // Retrieve the data
        ghClipData = GetClipboardData(nFormatID);
        if (!ghClipData)
        {
            TRACE((ERROR_MESSAGE, "Can't get clipboard data. GetLastError=%d\n", GetLastError()));
            goto exitpt;
        }

        Clp_GetClipboardData(nFormatID, ghClipData, &nClipDataSize, &hNewData);
        if (hNewData)
            ghClipData = hNewData;

        if (!nClipDataSize)
        {
            TRACE((WARNING_MESSAGE, "Clipboard is empty.\n"));
            goto exitpt;
        }
#ifdef  _RCLX
    }
#endif  // _RCLX

    pClipData = (char *) GlobalLock(ghClipData);
    if (!pClipData)
    {
        TRACE((ERROR_MESSAGE, "Can't lock global mem. GetLastError=%d\n", GetLastError()));
        goto exitpt;
    }

    // Open the destination file
    hFile = _open(szFileName, 
                  _O_RDWR|_O_CREAT|_O_BINARY|_O_TRUNC, 
                  _S_IREAD|_S_IWRITE);
    if (hFile == -1)
    {
        TRACE((ERROR_MESSAGE, "Can't open a file: %s\n", szFileName));
        goto exitpt;
    }

    // First write the format type
    if (_write(hFile, &nFormatID, sizeof(nFormatID)) != sizeof(nFormatID))
    {
        TRACE((ERROR_MESSAGE, "_write failed. errno=%d\n", errno));
        goto exitpt;
    }

    if (_write(hFile, pClipData, nClipDataSize) != (INT)nClipDataSize)
    {
        TRACE((ERROR_MESSAGE, "_write failed. errno=%d\n", errno));
        goto exitpt;
    }

    TRACE((INFO_MESSAGE, "File written successfully. %d bytes written\n", nClipDataSize));

    rv = NULL;
exitpt:
    // Do the cleanup

    // Close the file
    if (hFile != -1)
        _close(hFile);

    // Release the clipboard handle
    if (pClipData)
        GlobalUnlock(ghClipData);

    if (hNewData)
        GlobalFree(hNewData);

    // Close the clipboard
    if (bClipboardOpen)
        CloseClipboard();
    if (!prevOp)
        InterlockedExchange(&g_ClipOpened, 0);

#ifdef  _RCLX
    // free any clipboard received in RCLX mode
    if (pCI && pCI->RClxMode && pCI->ghClipboard)
    {
        GlobalFree(pCI->ghClipboard);
        pCI->ghClipboard = NULL;
    }
#endif  // _RCLX

    return rv;
}

/*++
 *  Function:
 *      SCSenddata
 *  Description:
 *      Called by smclient, when senddata command is interpreted
 *      Sends an window message to the client
 *  Arguments:
 *      pCI         - connection context
 *      uiMessage   - the massage Id
 *      wParam      - word param of the message
 *      lParam      - long param of the message
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR  
SMCAPI
SCSenddata(
    PCONNECTINFO pCI,
    const UINT uiMessage,
    const WPARAM wParam,
    const LPARAM lParam)
{
    UINT msg = uiMessage;
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->bConsole)
    {
        rv = _SCConsSenddata( pCI, uiMessage, wParam, lParam );
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

//    TRACE((ALIVE_MESSAGE, "Senddata: uMsg=%x wParam=%x lParam=%x\n",
//        uiMessage, wParam, lParam));

    // Determines whether it will
    // send the message to local window
    // or thru RCLX
#ifdef  _RCLX
    if (!pCI->RClxMode)
    {
#endif  // _RCLX
// Obsolete, a client registry setting "Allow Background Input" asserts
// that the client will accept the message
//    SetFocus(pCI->hInput);
//    SendMessageA(pCI->hInput, WM_SETFOCUS, 0, 0);

        SendMessageA(pCI->hInput, msg, wParam, lParam);
#ifdef  _RCLX
    } else {
    // RClxMode
        ASSERT(pCI->lProcessId != INVALID_SOCKET);
        ASSERT(pCI->hClient);

        if (!RClx_SendMessage((PRCLXCONTEXT)(pCI->hClient),
                              msg, wParam, lParam))
        {
            TRACE((WARNING_MESSAGE,
                   "Can't send message thru RCLX\n"));
        }
    }
#endif  // _RCLX

exitpt:
    return rv;
}

PROTOCOLAPI
LPCSTR
SMCAPI
SCClientTerminate(PCONNECTINFO pCI)
{
    LPCSTR rv = ERR_CLIENTTERMINATE_FAIL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

#ifdef  _RCLX
    if (!(pCI->RClxMode))
    {
#endif  // _RCLX
        if (!TerminateProcess(pCI->hProcess, 1))
        {
            TRACE((WARNING_MESSAGE,
                   "Can't kill process #%p. GetLastError=%d\n",
                   pCI->lProcessId, GetLastError()));
            goto exitpt;
        }
#ifdef  _RCLX
    } else {
        TRACE((WARNING_MESSAGE, 
                "ClientTerminate is not supported in RCLX mode yet\n"));
        TRACE((WARNING_MESSAGE, "Using disconnect\n"));
    }
#endif  // _RCLX

    rv = SCDisconnect(pCI);

exitpt:
    return rv;

}

/*++
 *  Function:
 *      SCGetSessionId
 *  Description:
 *      Called by smclient, returns the session ID. 0 is invalid, not logged on
 *      yet
 *  Arguments:
 *      pCI         - connection context
 *  Return value:
 *      session id, 0 is invlid value, -1 is returned on NT4 clients
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
UINT
SMCAPI
SCGetSessionId(PCONNECTINFO pCI)
{
    UINT    rv = 0;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        goto exitpt;
    }

    if (pCI->dead)
    {
        goto exitpt;
    }

    rv = pCI->uiSessionId;

exitpt:

    return rv;
}

/*++
 *  Function:
 *      SCCheck
 *  Description:
 *      Called by smclient, when check command is interpreted
 *  Arguments:
 *      pCI         - connection context
 *      lpszCommand - command name
 *      lpszParam   - command parameter
 *  Return value:
 *      Error message. NULL on success. Exceptions are GetDisconnectReason and
 *      GetWait4MultipleStrResult
 *  Called by:
 *      !smclient
 --*/
PROTOCOLAPI
LPCSTR 
SMCAPI
SCCheck(PCONNECTINFO pCI, LPCSTR lpszCommand, LPCWSTR lpszParam)
{
    LPCSTR rv = ERR_INVALID_COMMAND;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->bConsole)
    {
        rv = _SCConsCheck( pCI, lpszCommand, lpszParam );
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (     !_stricmp(lpszCommand, "Wait4Str"))
        rv = Wait4Str(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "Wait4Disconnect"))
        rv = Wait4Disconnect(pCI);
    else if (!_stricmp(lpszCommand, "RegisterChat"))
        rv = RegisterChat(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "UnregisterChat"))
        rv = UnregisterChat(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "GetDisconnectReason"))
        rv = GetDisconnectReason(pCI);
    else if (!_stricmp(lpszCommand, "Wait4StrTimeout"))
        rv = Wait4StrTimeout(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "Wait4MultipleStr"))
        rv = Wait4MultipleStr(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "Wait4MultipleStrTimeout"))
        rv = Wait4MultipleStrTimeout(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "GetWait4MultipleStrResult"))
        rv = GetWait4MultipleStrResult(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "SwitchToProcess"))
        rv = SCSwitchToProcess(pCI, lpszParam);
    else if (!_stricmp(lpszCommand, "SetClientTopmost"))
        rv = SCSetClientTopmost(pCI, lpszParam);
    else if (!_strnicmp(lpszCommand, "call:", 5))
        rv = SCCallDll(pCI, lpszCommand + 5, lpszParam);
    /* **New** */
    else if (!_stricmp(lpszCommand, "DoUntil" ))
        rv = SCDoUntil( pCI, lpszParam );

exitpt:
    return rv;
}

/*
 *  Extensions and help functions
 */

/*++
 *  Function:
 *      Wait4Disconnect
 *  Description:
 *      Waits until the client is disconnected
 *  Arguments:
 *      pCI -   connection context
 *  Return value:
 *      Error message. NULL on success
 *  Called by:
 *      SCCheck, SCLogoff
 --*/
LPCSTR Wait4Disconnect(PCONNECTINFO pCI)
{
    WAIT4STRING Wait;
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    memset(&Wait, 0, sizeof(Wait));
    Wait.evWait = CreateEvent(NULL,     //security
                             TRUE,     //manual
                             FALSE,    //initial state
                             NULL);    //name

    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WAIT_DISC;

    rv = _WaitSomething(pCI, &Wait, pCI->pConfigInfo->WAIT4STR_TIMEOUT);
    if (!rv)
    {
        TRACE(( INFO_MESSAGE, "Client is disconnected\n"));
    }

    CloseHandle(Wait.evWait);
exitpt:
    return rv;
}

/*++
 *  Function:
 *      Wait4Connect
 *  Description:
 *      Waits until the client is connect
 *  Arguments:
 *      pCI - connection context
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCOnnect
 --*/
LPCSTR Wait4Connect(PCONNECTINFO pCI)
{
    return (_Wait4ConnectTimeout(pCI, pCI->pConfigInfo->CONNECT_TIMEOUT));
}

/*++
 *  Function:
 *      _Wait4ConnectTimeout
 *  Description:
 *      Waits until the client is connect
 *  Arguments:
 *      pCI - connection context
 *      dwTimeout - timeout value
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCConnect
 --*/
LPCSTR _Wait4ConnectTimeout(PCONNECTINFO pCI, DWORD dwTimeout)
{
    WAIT4STRING Wait;
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    memset(&Wait, 0, sizeof(Wait));
    Wait.evWait = CreateEvent(NULL,     //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WAIT_CONN;

    rv = _WaitSomething(pCI, &Wait, dwTimeout);
    if (!rv)
    {
        TRACE(( INFO_MESSAGE, "Client is connected\n"));
    }

    CloseHandle(Wait.evWait);
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _Wait4ClipboardTimeout
 *  Description:
 *      Waits until clipboard response is received from RCLX module
 *  Arguments:
 *      pCI - connection context
 *      dwTimeout - timeout value
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCClipboard
 --*/
LPCSTR _Wait4ClipboardTimeout(PCONNECTINFO pCI, DWORD dwTimeout)
{
#ifdef _RCLX
    WAIT4STRING Wait;
#endif
    LPCSTR  rv = NULL;

#ifndef _RCLX
    UNREFERENCED_PARAMETER(dwTimeout);
#endif

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

#ifdef  _RCLX
    if (!(pCI->RClxMode))
#endif  // _RCLX
    {
        TRACE((WARNING_MESSAGE, "WaitForClipboard: Not in RCLX mode\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

#ifdef  _RCLX
    memset(&Wait, 0, sizeof(Wait));
    Wait.evWait = CreateEvent(NULL,     //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WAIT_CLIPBOARD;

    rv = _WaitSomething(pCI, &Wait, dwTimeout);
    if (!rv)
    {
        TRACE(( INFO_MESSAGE, "Clipboard received\n"));
    }

    CloseHandle(Wait.evWait);
#endif  // _RCLX
exitpt:
    return rv;
}

/*++
 *  Function:
 *      GetDisconnectReason
 *  Description:
 *      Retrieves, if possible, the client error box
 *  Arguments:
 *      pCI - connection context
 *  Return value:
 *      The error box message. NULL if not available
 *  Called by:
 *      SCCheck
 --*/
LPCSTR  GetDisconnectReason(PCONNECTINFO pCI)
{
    HWND hDiscBox;
    LPCSTR  rv = NULL;
    HWND hWnd, hwndTop, hwndNext;
    CHAR classname[128];
    CHAR caption[256];

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (strlen(pCI->szDiscReason))
    {
        rv = pCI->szDiscReason;
        goto exitpt;
    }

    hDiscBox = _FindTopWindow(NULL, pCI->pConfigInfo->strDisconnectDialogBox, pCI->lProcessId);

    if (!hDiscBox)
    {
        rv = ERR_NORMAL_EXIT;
        goto exitpt;
    } else {
        TRACE((INFO_MESSAGE, "Found hDiscBox=0x%x", hDiscBox));
    }

    pCI->szDiscReason[0] = 0;
    hWnd = NULL;

    hwndTop = GetWindow(hDiscBox, GW_CHILD);
    if (!hwndTop)
    {
        TRACE((INFO_MESSAGE, "GetWindow failed. hwnd=0x%x\n", hDiscBox));
        goto exitpt;
    }

    hwndNext = hwndTop;
    do {
        hWnd = hwndNext;
        if (!GetClassNameA(hWnd, classname, sizeof(classname)))
        {
            TRACE((INFO_MESSAGE, "GetClassName failed. hwnd=0x%x\n", hWnd));
            goto nextwindow;
        }
        if (!GetWindowTextA(hWnd, caption, sizeof(caption)))
        {
            TRACE((INFO_MESSAGE, "GetWindowText failed. hwnd=0x%x\n"));
            goto nextwindow;
        }

        if (!strcmp(classname, STATIC_CLASS) && 
             strlen(classname) < 
             sizeof(pCI->szDiscReason) - strlen(pCI->szDiscReason) - 3)
        {
            strcat(pCI->szDiscReason, caption);
            strcat(pCI->szDiscReason, "\n");
        }
nextwindow:
        hwndNext = GetNextWindow(hWnd, GW_HWNDNEXT);
    } while (hWnd && hwndNext != hwndTop);

    rv = (LPCSTR)pCI->szDiscReason;

exitpt:
    return rv;
}

/*++
 *  Function:
 *      Wait4Str
 *  Description:
 *      Waits for a specific string to come from clients feedback
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited string
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
LPCSTR Wait4Str(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    return _Wait4Str(pCI, lpszParam, pCI->pConfigInfo->WAIT4STR_TIMEOUT, WAIT_STRING);
}

/*++
 *  Function:
 *      Wait4StrTimeout
 *  Description:
 *      Waits for a specific string to come from clients feedback
 *      The timeout is different than default and is specified in
 *      lpszParam argument, like:
 *      waited_string<->timeout_value
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited string and timeout
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
LPCSTR Wait4StrTimeout(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    WCHAR waitstr[MAX_STRING_LENGTH];
    WCHAR *sep = wcsstr(lpszParam, CHAT_SEPARATOR);
    DWORD dwTimeout;
    LPCSTR rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (!sep)
    {
        TRACE((WARNING_MESSAGE, 
               "Wait4StrTiemout: No timeout value. Default applying\n"));
        rv = Wait4Str(pCI, lpszParam);
    } else {
        LONG_PTR len = sep - lpszParam;

        if (len > sizeof(waitstr) - 1)
            len = sizeof(waitstr) - 1;

        wcsncpy(waitstr, lpszParam, len);
        waitstr[len] = 0;
        sep += wcslen(CHAT_SEPARATOR);
        dwTimeout = _wtoi(sep);

        if (!dwTimeout)
        {
            TRACE((WARNING_MESSAGE, 
                   "Wait4StrTiemout: No timeout value(%s). Default applying\n",
                   sep));
            dwTimeout = pCI->pConfigInfo->WAIT4STR_TIMEOUT;
        }

        rv = _Wait4Str(pCI, waitstr, dwTimeout, WAIT_STRING);
    }
    
exitpt:
    return rv;
}

/*++
 *  Function:
 *      Wait4MultipleStr
 *  Description:
 *      Same as Wait4Str, but waits for several strings at once
 *      the strings are separated by '|' character
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited strings
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
LPCSTR  Wait4MultipleStr(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
     return _Wait4Str(pCI, lpszParam, pCI->pConfigInfo->WAIT4STR_TIMEOUT, WAIT_MSTRINGS);
}

/*++
 *  Function:
 *      Wait4MultipleStrTimeout
 *  Description:
 *      Combination between Wait4StrTimeout and Wait4MultipleStr
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited strings and timeout value. Example
 *                  - "string1|string2|...|stringN<->5000"
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
LPCSTR  Wait4MultipleStrTimeout(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    WCHAR waitstr[MAX_STRING_LENGTH];
    WCHAR  *sep = wcsstr(lpszParam, CHAT_SEPARATOR);
    DWORD dwTimeout;
    LPCSTR rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    pCI->nWait4MultipleStrResult = 0;
    pCI->szWait4MultipleStrResult[0] = 0;

    if (!sep)
    {
        TRACE((WARNING_MESSAGE, 
               "Wait4MultipleStrTiemout: No timeout value. Default applying"));
        rv = Wait4MultipleStr(pCI, lpszParam);
    } else {
        LONG_PTR len = sep - lpszParam;

        if (len > sizeof(waitstr) - 1)
            len = sizeof(waitstr) - 1;

        wcsncpy(waitstr, lpszParam, len);
        waitstr[len] = 0;
        sep += wcslen(CHAT_SEPARATOR);
        dwTimeout = _wtoi(sep);

        if (!dwTimeout)
        {
            TRACE((WARNING_MESSAGE, 
                   "Wait4StrTiemout: No timeout value. Default applying"));
            dwTimeout = pCI->pConfigInfo->WAIT4STR_TIMEOUT;
        }

        rv = _Wait4Str(pCI, waitstr, dwTimeout, WAIT_MSTRINGS);
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      GetWait4MultipleStrResult
 *  Description:
 *      Retrieves the result from last Wait4MultipleStr call
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - unused
 *  Return value:
 *      The string, NULL on error
 *  Called by:
 *      SCCheck
 --*/
LPCSTR  GetWait4MultipleStrResult(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    LPCSTR  rv = NULL;

    UNREFERENCED_PARAMETER(lpszParam);

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (*pCI->szWait4MultipleStrResult)
        rv = (LPCSTR)pCI->szWait4MultipleStrResult;
    else
        rv = NULL;

exitpt:
    return rv;
}

LPCSTR
SMCAPI
SCGetFeedbackStringA(
    PCONNECTINFO pCI,
    LPSTR        szBuff,
    UINT         maxBuffChars
)
{
    LPWSTR szwBuff;
    LPCSTR rv;

    __try {
        szwBuff = (LPWSTR) _alloca(( maxBuffChars ) * sizeof( WCHAR ));
    } __except( EXCEPTION_EXECUTE_HANDLER )
    {
        szwBuff = NULL;
    }

    if ( NULL == szBuff )
    {
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }

    rv = SCGetFeedbackString( pCI, szwBuff, maxBuffChars );
    if ( NULL == rv )
    {
        WideCharToMultiByte(
            CP_UTF8,
            0,
            szwBuff,
            -1,
            szBuff,
            maxBuffChars,
            NULL,
            NULL );
    }

exitpt:
    return rv;
}

LPCSTR
SMCAPI
SCGetFeedbackString(
    PCONNECTINFO pCI, 
    LPWSTR       szBuff,
    UINT         maxBuffChars
    )
{
    LPCSTR rv = NULL;
    INT    nFBpos, nFBsize ;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }
    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if ( NULL == szBuff )
    {
        TRACE((WARNING_MESSAGE, "SCGetFeedbackString, szBuff is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (!maxBuffChars)
    {
        TRACE((WARNING_MESSAGE, "SCGetFeedbackString, maxBuffChars is zero\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }


    // Grab the buffer pointers
    EnterCriticalSection(g_lpcsGuardWaitQueue);
    nFBpos = pCI->nFBend + FEEDBACK_SIZE - pCI->nFBsize;
    nFBsize = pCI->nFBsize;
    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    nFBpos %= FEEDBACK_SIZE;

    *szBuff = 0;

    if (!nFBsize)
    // Empty buffer, wait for feedback to receive
    {
        rv = _Wait4Str(pCI, L"", pCI->pConfigInfo->WAIT4STR_TIMEOUT, WAIT_STRING);
    }
    if (!rv)
    // Pickup from buffer
    {
        EnterCriticalSection(g_lpcsGuardWaitQueue);

        // Adjust the buffer pointers
        pCI->nFBsize    =   pCI->nFBend + FEEDBACK_SIZE - nFBpos - 1;
        pCI->nFBsize    %=  FEEDBACK_SIZE;

        _snwprintf( szBuff, maxBuffChars, L"%s", pCI->Feedback[nFBpos] );

        LeaveCriticalSection(g_lpcsGuardWaitQueue);
    }

exitpt:
    return rv;
}

VOID
SMCAPI
SCFreeMem(
    PVOID   pMem
    )
{
    if ( NULL != pMem )
        free( pMem );
}

/*++
 *  Function:
 *      SCGetFeedback
 *  Description:
 *      Copies the last received strings to an user buffer
 *  Arguments:
 *      pCI     - connection context
 *      pszBufs - pointer to the strings, don't forget to 'SCFreeMem' this buffer
 *      pnFBCount - number of strings in *pszBuffs
 *      pnFBMaxStrLen - for now MAX_STRING_LENGTH
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
LPCSTR
SMCAPI
SCGetFeedback(
    CONNECTINFO  *pCI,
    LPWSTR       *pszBufs,
    UINT         *pnFBCount,
    UINT         *pnFBMaxStrLen
    )
{
    LPWSTR szBufPtr;
    LPWSTR szBufs = NULL;
    LPCSTR rv = NULL;
    INT    nFBpos;
    INT    nFBindex;
    BOOL   bCSAcquired = FALSE;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }
    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (NULL == pszBufs || NULL == pnFBCount || NULL == pnFBMaxStrLen)
    {
        TRACE((WARNING_MESSAGE, "SCGetFeedbackStrings, szBufs is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    EnterCriticalSection(g_lpcsGuardWaitQueue);
    bCSAcquired = TRUE;

    if (0 == pCI->nFBsize)
    {
        TRACE((WARNING_MESSAGE, "No strings available\n"));
        rv = ERR_NODATA;
        goto exitpt;
    }

    szBufs = (LPWSTR)malloc(MAX_STRING_LENGTH * pCI->nFBsize * sizeof(WCHAR));
    if(!szBufs)
    {
        TRACE((WARNING_MESSAGE, "Could not allocate buffer array\n"));
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }

    // prepare the loop
    nFBpos = pCI->nFBend;
    szBufPtr = szBufs;
    nFBindex = 0;
    do
    {
        if(0 == nFBpos)
            nFBpos = FEEDBACK_SIZE - 1;
        else
            nFBpos --;
        wcscpy(szBufPtr, pCI->Feedback[nFBpos]);
        szBufPtr += MAX_STRING_LENGTH;
        //
        // loop until we have gathered all the strings
        //
        nFBindex++;
    } while(nFBindex < pCI->nFBsize);

    // return back info of strings
    *pnFBCount = pCI->nFBsize;
    *pnFBMaxStrLen = MAX_STRING_LENGTH;

exitpt:
    if ( NULL != rv )
    {
        if ( NULL != szBufs )
            free( szBufs );
            szBufs = NULL;
    }
    if ( bCSAcquired )
        LeaveCriticalSection(g_lpcsGuardWaitQueue);

    if ( NULL != pszBufs )
        *pszBufs = szBufs;

    return rv;
}

/*++
 *  Function:
 *      SCCallDll
 *  Description:
 *      Calls an exported dll function
 *  Arguments:
 *      pCI             - connection context
 *      lpszDllExport   - dll name and function in form:
 *                        dllname!ExportedFunction
 *                        the function prototype is:
 *                        LPCSTR lpfnFunction( PVOID pCI, LPWCSTR lpszParam )
 *      lpszParam       - parameter passed to the function
 *  Return value:
 *      the value returned from the call
 *  Called by:
 *      SCCheck
 --*/
LPCSTR
SMCAPI
SCCallDll(
    PCONNECTINFO pCI, 
    LPCSTR       lpszDllExport, 
    LPCWSTR      lpszParam
    )
{
    LPCSTR  rv = NULL;
    PFNSMCDLLIMPORT lpfnImport;
    CHAR    lpszDllName[ MAX_STRING_LENGTH ];
    LPSTR   lpszImportName;
    LPSTR   lpszBang;
    HINSTANCE   hLib = NULL;
    DWORD   dwDllNameLen;

    if ( NULL == lpszDllExport )
    {
        TRACE((ERROR_MESSAGE, "SCCallDll: DllExport is NULL\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if ( NULL == lpszParam )
    {
        TRACE((ERROR_MESSAGE, "SCCallDll: Param is NULL\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    //
    //  split the dll and import names
    //
    lpszBang = strchr( lpszDllExport, '!' );
    if ( NULL == lpszBang )
    {
        TRACE((ERROR_MESSAGE, "SCCallDll: invalid import name (no !)\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    dwDllNameLen = PtrToLong((PVOID)( lpszBang - lpszDllExport ));

    if ( 0 == dwDllNameLen )
    {
        TRACE((ERROR_MESSAGE, "SCCallDll: dll name is empty string\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    //  copy the dll name
    //
    strncpy( lpszDllName, lpszDllExport, dwDllNameLen );
    lpszDllName[ dwDllNameLen ] = 0;

    //  the function name is lpszBang + 1
    //
    lpszImportName = lpszBang + 1;

    TRACE((ALIVE_MESSAGE, "SCCallDll: calling %s!%s(%S)\n",
            lpszDllName, lpszImportName, lpszParam ));

    hLib = LoadLibraryA( lpszDllName );
    if ( NULL == hLib )
    {
        TRACE((ERROR_MESSAGE, "SCCallDll: can't load %s library: %d\n",
            lpszDllName,
            GetLastError()));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    lpfnImport = (PFNSMCDLLIMPORT)GetProcAddress( hLib, lpszImportName );
    if ( NULL == lpfnImport )
    {
        TRACE((ERROR_MESSAGE, "SCCallDll: can't get the import proc address "
                "of %s. GetLastError=%d\n",
                lpszImportName,
                GetLastError()));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    __try {
        rv = lpfnImport( pCI, lpszParam );
    } 
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        TRACE((ERROR_MESSAGE, "SCCallDll: exception 0x%x\n",
                GetExceptionCode()));
        rv = ERR_UNKNOWNEXCEPTION;
    }

exitpt:

    if ( NULL != hLib )
        FreeLibrary( hLib );

    return rv;
}

/*++
 *  Function:
 *      SCDoUntil
 *  Description:
 *      Sends keystrokes every 10 seconds until string is received
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - parameter in the form of send_text<->wait_for_this_string
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
LPCSTR
SMCAPI
SCDoUntil(
    PCONNECTINFO pCI,
    LPCWSTR      lpszParam
    )
{
    LPCSTR  rv = NULL;
    DWORD   timeout;
    LPWSTR  szSendStr, szSepStr, szWaitStr;
    DWORD   dwlen;

    if ( NULL == lpszParam )
    {
        TRACE((ERROR_MESSAGE, "SCDoUntil: Param is NULL\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    //
    //  extract the parameters
    //
    szSepStr = wcsstr( lpszParam, CHAT_SEPARATOR );
    if ( NULL == szSepStr )
    {
        TRACE((ERROR_MESSAGE, "SCDoUntil: missing wait string\n" ));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    szWaitStr = szSepStr + wcslen( CHAT_SEPARATOR );
    if ( 0 == szWaitStr[0] )
    {
        TRACE((ERROR_MESSAGE, "SCDoUntil: wait string is empty\n" ));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    dwlen = ((DWORD)PtrToLong( (PBYTE)(((PBYTE)szSepStr) - ((PBYTE)lpszParam)) )) / sizeof( WCHAR );
    __try {
        szSendStr = (LPWSTR) _alloca( (dwlen + 1) * sizeof( WCHAR ) );

    } __except( EXCEPTION_EXECUTE_HANDLER )
    {
        szSendStr = NULL;
    }
    if ( NULL == szSendStr )
    {
        TRACE((ERROR_MESSAGE, "SCDoUntil: _alloca failed\n" ));
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }

    wcsncpy( szSendStr, lpszParam, dwlen );
    szSendStr[dwlen] = 0;

    timeout = 0;
    while( timeout < pCI->pConfigInfo->WAIT4STR_TIMEOUT )
    {
        if ( pCI->dead )
        {
            rv = ERR_CLIENT_IS_DEAD;
            break;
        }

        SCSendtextAsMsgs( pCI, szSendStr );
        rv = _Wait4Str( pCI, szWaitStr, 3000, WAIT_MSTRINGS );
        if ( NULL == rv )
            break;

        timeout += 3000;
    }
exitpt:
    return rv;
}

#ifdef  _RCLX
/*++
 *  Function:
 *      _SendRClxData
 *  Description:
 *      Sends request for data to the client
 *  Arguments:
 *      pCI         - connection context
 *      pRClxData   - data to send
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCGetClientScreen
 --*/
LPCSTR
_SendRClxData(PCONNECTINFO pCI, PRCLXDATA pRClxData)
{
    LPCSTR  rv = NULL;
    PRCLXCONTEXT pRClxCtx;
    RCLXREQPROLOG   Request;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!(pCI->RClxMode))
    {
        TRACE((WARNING_MESSAGE, "_SendRClxData: Not in RCLX mode\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    pRClxCtx = (PRCLXCONTEXT)pCI->hClient;
    if (!pRClxCtx || pRClxCtx->hSocket == INVALID_SOCKET)
    {
        TRACE((ERROR_MESSAGE, "Not connected yet, RCLX context is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!pRClxData)
    {
        TRACE((ERROR_MESSAGE, "_SendRClxData: Data block is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    Request.ReqType = REQ_DATA;
    Request.ReqSize = pRClxData->uiSize + sizeof(*pRClxData);
    if (!RClx_SendBuffer(pRClxCtx->hSocket, &Request, sizeof(Request)))
    {
        rv = ERR_CLIENT_DISCONNECTED;
        goto exitpt;
    }

    if (!RClx_SendBuffer(pRClxCtx->hSocket, pRClxData, Request.ReqSize))
    {
        rv = ERR_CLIENT_DISCONNECTED;
        goto exitpt;
    }

exitpt:
    return rv;
}
#endif  // _RCLX

#ifdef  _RCLX
/*++
 *  Function:
 *      _Wait4RClxData
 *  Description:
 *      Waits for data response from RCLX client
 *  Arguments:
 *      pCI         - connection context
 *      dwTimeout   - timeout value
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCGetClientScreen
 --*/
LPCSTR
_Wait4RClxDataTimeout(PCONNECTINFO pCI, DWORD dwTimeout)
{
    WAIT4STRING Wait;
    LPCSTR  rv = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!(pCI->RClxMode))
    {
        TRACE((WARNING_MESSAGE, "_Wait4RClxData: Not in RCLX mode\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    memset(&Wait, 0, sizeof(Wait));
    Wait.evWait = CreateEvent(NULL,     //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WAIT_DATA;

    rv = _WaitSomething(pCI, &Wait, dwTimeout);
    if (!rv)
    {
        TRACE(( INFO_MESSAGE, "RCLX data received\n"));
    }

    CloseHandle(Wait.evWait);
exitpt:
    return rv;
}
#endif  // _RCLX

/*++
 *  Function:
 *      _Wait4Str
 *  Description:
 *      Waits for string(s) with specified timeout
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited string(s)
 *      dwTimeout   - timeout value
 *      WaitType    - WAIT_STRING ot WAIT_MSTRING
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCStart, Wait4Str, Wait4StrTimeout, Wait4MultipleStr
 *      Wait4MultipleStrTimeout, GetFeedbackString
 --*/
LPCSTR _Wait4Str(PCONNECTINFO pCI, 
                 LPCWSTR lpszParam, 
                 DWORD dwTimeout, 
                 WAITTYPE WaitType)
{
    WAIT4STRING Wait;
    INT_PTR parlen;
//    int i;
    LPCSTR rv = NULL;

    ASSERT(pCI);

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    memset(&Wait, 0, sizeof(Wait));

    // Check the parameter
    parlen = wcslen(lpszParam);

    // Copy the string
    if (parlen > sizeof(Wait.waitstr)/sizeof(WCHAR)-1) 
        parlen = sizeof(Wait.waitstr)/sizeof(WCHAR)-1;

    wcsncpy(Wait.waitstr, lpszParam, parlen);
    Wait.waitstr[parlen] = 0;
    Wait.strsize = parlen;

    // Convert delimiters to 0s
    if (WaitType == WAIT_MSTRINGS)
    {
        WCHAR *p = Wait.waitstr;

        while((p = wcschr(p, WAIT_STR_DELIMITER)))
        {
            *p = 0;
            p++;
        }
    }

    Wait.evWait = CreateEvent(NULL,     //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    if (!Wait.evWait) {
        TRACE((ERROR_MESSAGE, "Couldn't create event\n"));
        goto exitpt;
    }
    Wait.lProcessId = pCI->lProcessId;
    Wait.pOwner = pCI;
    Wait.WaitType = WaitType;

    TRACE(( INFO_MESSAGE, "Expecting string: %S\n", Wait.waitstr));
    rv = _WaitSomething(pCI, &Wait, dwTimeout);
    TRACE(( INFO_MESSAGE, "String %S received\n", Wait.waitstr));

    if (!rv && pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
    }

    CloseHandle(Wait.evWait);
exitpt:
    return rv; 
}

/*++
 *  Function:
 *      _WaitSomething
 *  Description:
 *      Wait for some event: string, connect or disconnect
 *      Meanwhile checks for chat sequences
 *  Arguments:
 *      pCI     -   connection context
 *      pWait   -   the event function waits for
 *      dwTimeout - timeout value
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      Wait4Connect, Wait4Disconnect, _Wait4Str
 --*/
LPCSTR 
_WaitSomething(PCONNECTINFO pCI, PWAIT4STRING pWait, DWORD dwTimeout)
{
    BOOL    bDone = FALSE;
    LPCSTR  rv = NULL;
    DWORD   waitres;

    ASSERT(pCI || pWait);

    _AddToWaitQueue(pCI, pWait);
    pCI->evWait4Str = pWait->evWait;

    do {
        waitres = WaitForMultipleObjects(
                pCI->nChatNum+1,
                &pCI->evWait4Str,
                FALSE,
                dwTimeout
            );
        if ( waitres <= pCI->nChatNum + WAIT_OBJECT_0)
        {
            if (waitres == WAIT_OBJECT_0)
            {
                bDone = TRUE;
            } else {
                PWAIT4STRING pNWait;

                ASSERT((unsigned)pCI->nChatNum >= waitres - WAIT_OBJECT_0);

                // Here we must send response messages
                waitres -= WAIT_OBJECT_0 + 1;
                ResetEvent(pCI->aevChatSeq[waitres]);
                pNWait = _RetrieveFromWaitQByEvent(pCI->aevChatSeq[waitres]);

                ASSERT(pNWait);
                ASSERT(wcslen(pNWait->respstr));
                TRACE((INFO_MESSAGE, 
                       "Recieved : [%d]%S\n", 
                        pNWait->strsize, 
                        pNWait->waitstr ));
                SCSendtextAsMsgs(pCI, (LPCWSTR)pNWait->respstr);
            }
        } else {
            if (*(pWait->waitstr))
            {
                TRACE((WARNING_MESSAGE, 
                       "Wait for \"%S\" failed: TIMEOUT\n", 
                       pWait->waitstr));
            } else {
                TRACE((WARNING_MESSAGE, "Wait failed: TIMEOUT\n"));
            }
            rv = ERR_WAIT_FAIL_TIMEOUT;
            bDone = TRUE;
        }
    } while(!bDone);

    pCI->evWait4Str = NULL;

    _RemoveFromWaitQueue(pWait);

    if (!rv && pCI->dead)
        rv = ERR_CLIENT_IS_DEAD;

    return rv;
}

/*++
 *  Function:
 *      RegisterChat
 *  Description:
 *      This regiters a wait4str <-> sendtext pair
 *      so when we receive a specific string we will send a proper messages
 *      lpszParam is kind of: XXXXXX<->YYYYYY
 *      XXXXX is the waited string, YYYYY is the respond
 *      These command could be nested up to: MAX_WAITING_EVENTS
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - parameter, example:
 *                    "Connect to existing Windows NT session<->\n" 
 *                  - hit enter when this string is received
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck, _Login
 --*/
LPCSTR RegisterChat(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    PWAIT4STRING pWait;
    INT_PTR parlen;
//    int i;
    INT_PTR resplen;
    LPCSTR rv = NULL;
    LPCWSTR  resp;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!lpszParam)
    {
        TRACE((WARNING_MESSAGE, "Parameter is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (pCI->nChatNum >= MAX_WAITING_EVENTS)
    {
        TRACE(( WARNING_MESSAGE, "RegisterChat: too much waiting strings\n" ));
        goto exitpt;
    }

    // Split the parameter
    resp = wcsstr(lpszParam, CHAT_SEPARATOR);
    // Check the strings
    if (!resp)
    {
        TRACE(( WARNING_MESSAGE, "RegisterChat: invalid parameter\n" ));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    parlen = wcslen(lpszParam) - wcslen(resp);
    resp += wcslen(CHAT_SEPARATOR);

    if (!parlen)
    {
        TRACE((WARNING_MESSAGE, "RegisterChat empty parameter\n"));
        goto exitpt;
    }

    resplen = wcslen(resp);
    if (!resplen)
    {
        TRACE((WARNING_MESSAGE, "RegisterChat: empty respond string\n" ));
        goto exitpt;
    }

    // Allocate the WAIT4STRING structure
    pWait = (PWAIT4STRING)malloc(sizeof(*pWait));
    if (!pWait)
    {
        TRACE((WARNING_MESSAGE, 
               "RegisterChat: can't allocate %d bytes\n", 
               sizeof(*pWait) ));
        goto exitpt;
    }
    memset(pWait, 0, sizeof(*pWait));

    // Copy the waited string
    if (parlen > sizeof(pWait->waitstr)/sizeof(WCHAR)-1)
        parlen = sizeof(pWait->waitstr)/sizeof(WCHAR)-1;

    wcsncpy(pWait->waitstr, lpszParam, parlen);
    pWait->waitstr[parlen] = 0;
    pWait->strsize = parlen;

    // Copy the respond string
    if (resplen > sizeof(pWait->respstr)-1)
        resplen = sizeof(pWait->respstr)-1;

    wcsncpy(pWait->respstr, resp, resplen);
    pWait->respstr[resplen] = 0;
    pWait->respsize = resplen;

    pWait->evWait = CreateEvent(NULL,   //security
                              TRUE,     //manual
                              FALSE,    //initial state
                              NULL);    //name

    if (!pWait->evWait) {
        TRACE((ERROR_MESSAGE, "Couldn't create event\n"));
        free (pWait);
        goto exitpt;
    }
    pWait->lProcessId  = pCI->lProcessId;
    pWait->pOwner       = pCI;
    pWait->WaitType     = WAIT_STRING;

    // _AddToWaitQNoCheck(pCI, pWait);
    _AddToWaitQueue(pCI, pWait);

    // Add to connection info array
    pCI->aevChatSeq[pCI->nChatNum] = pWait->evWait;
    pCI->nChatNum++;

exitpt:
    return rv;
}

// Remove a WAIT4STRING from waiting Q
// Param is the waited string
/*++
 *  Function:
 *      UnregisterChat
 *  Description:
 *      Deallocates and removes from waiting Q everithing
 *      from RegisterChat function
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - waited string
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck, _Login
 --*/
LPCSTR UnregisterChat(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
    PWAIT4STRING    pWait;
    LPCSTR      rv = NULL;
    int         i;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!lpszParam)
    {
        TRACE((WARNING_MESSAGE, "Parameter is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    pWait = _RemoveFromWaitQIndirect(pCI, lpszParam);
    if (!pWait)
    {
        TRACE((WARNING_MESSAGE, 
               "UnregisterChat: can't find waiting string: %S\n", 
               lpszParam ));
        goto exitpt;
    }

    i = 0;
    while (i < pCI->nChatNum && pCI->aevChatSeq[i] != pWait->evWait)
        i++;

    ASSERT(i < pCI->nChatNum);

    memmove(pCI->aevChatSeq+i,
                pCI->aevChatSeq+i+1, 
                (pCI->nChatNum-i-1)*sizeof(pCI->aevChatSeq[0]));
    pCI->nChatNum--;

    CloseHandle(pWait->evWait);

    free(pWait);

exitpt:
    return rv;
}

/*
 *  Returns TRUE if the client is dead
 */
PROTOCOLAPI
BOOL    
SMCAPI
SCIsDead(PCONNECTINFO pCI)
{
    if (!pCI)
        return TRUE;

    return  pCI->dead;
}

/*++
 *  Function:
 *      _CloseConnectInfo
 *  Description:
 *      Clean all resources for this connection. Close the client
 *  Arguments:
 *      pCI     - connection context
 *  Called by:
 *      SCDisconnect
 --*/
VOID 
_CloseConnectInfo(PCONNECTINFO pCI)
{
#ifdef  _RCLX
    PRCLXDATACHAIN pRClxDataChain, pNext;
#endif  // _RCLX

    ASSERT(pCI);

    _FlushFromWaitQ(pCI);

    // Close All handles
    EnterCriticalSection(g_lpcsGuardWaitQueue);

/*    // not needed, the handle is already closed
    if (pCI->evWait4Str)
    {
        CloseHandle(pCI->evWait4Str);
        pCI->evWait4Str = NULL;
    }
*/

    // Chat events are already closed by FlushFromWaitQ
    // no need to close them

    pCI->nChatNum = 0;

#ifdef  _RCLX
    if (!pCI->RClxMode)
    {
#endif  // _RCLX
    // The client was local, so we have handles opened
        if (pCI->hProcess)
            CloseHandle(pCI->hProcess);

        if (pCI->hThread)
            CloseHandle(pCI->hThread);

        pCI->hProcess = pCI->hThread =NULL;
#ifdef  _RCLX
    } else {
    // Hmmm, RCLX mode. Then disconnect the socket

        if (pCI->hClient)
            RClx_EndRecv((PRCLXCONTEXT)(pCI->hClient));

        pCI->hClient = NULL;    // Clean the pointer
    }

    // Clear the clipboard handle (if any)
    if (pCI->ghClipboard)
    {
        GlobalFree(pCI->ghClipboard);
        pCI->ghClipboard = NULL;
    }

    // clear any recevied RCLX data
    pRClxDataChain = pCI->pRClxDataChain;
    while(pRClxDataChain)
    {
        pNext = pRClxDataChain->pNext;
        free(pRClxDataChain);
        pRClxDataChain = pNext;
    }
#endif  // _RCLX

    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    if (
#ifdef  _RCLX
    !pCI->RClxMode && 
#endif  // _RCLX
        NULL != pCI->pConfigInfo &&
        pCI->pConfigInfo->UseRegistry )
    {
        _DeleteClientRegistry(pCI);
    }

    if ( NULL != pCI->pConfigInfo )
    {
        free(pCI->pConfigInfo);
        pCI->pConfigInfo = NULL;
    }
    free(pCI);
    pCI = NULL;
}

/*++
 *  Function:
 *      _Login
 *  Description:
 *      Emulate login procedure
 *  Arguments:
 *      pCI             - connection context
 *      lpszServerName
 *      lpszUserName    - user name
 *      lpszPassword    - password
 *      lpszDomain      - domain name
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCConnect
 --*/
LPCSTR
_Login(PCONNECTINFO pCI, 
       LPCWSTR lpszServerName,
       LPCWSTR lpszUserName,
       LPCWSTR lpszPassword,
       LPCWSTR lpszDomain)
{
    LPCSTR waitres;
    LPCSTR rv = NULL;
    WCHAR  szBuff[MAX_STRING_LENGTH];
#define _LOGON_RETRYS   5
    INT    nLogonRetrys = _LOGON_RETRYS;
    UINT   nLogonWaitTime;
    INT nFBSize;
    INT nFBEnd;

    ASSERT(pCI);

    szBuff[MAX_STRING_LENGTH - 1] = 0;

    //
    // If a smartcard is being used, wait for the smartcard UI, dismiss it,
    // then wait for the non-smartcard UI.
    //

    if (_IsSmartcardActive())
    {
        waitres = Wait4Str(pCI, pCI->pConfigInfo->strSmartcard);
        if (!waitres)
        {
            SCSendtextAsMsgs(pCI, pCI->pConfigInfo->strSmartcard_Act);
            waitres = Wait4Str(pCI, pCI->pConfigInfo->strNoSmartcard);
        }

        if (waitres)
        {
            TRACE((WARNING_MESSAGE, "Login failed (smartcard)"));
            rv = waitres;
            goto exitpt;
        }
    }

    //
    // Look for a logon string, which will indicate the current state of the
    // logon desktop, and try to get to the logon window.
    //

retry_logon:
    _snwprintf(szBuff, MAX_STRING_LENGTH - 1, L"%s|%s|%s",
            pCI->pConfigInfo->strWinlogon, pCI->pConfigInfo->strPriorWinlogon, 
            pCI->pConfigInfo->strLogonDisabled);

    waitres = Wait4MultipleStr(pCI, szBuff); 
    if (!waitres)
    {

        //
        // Prior Winlogon: send the string to begin the logon.
        //

        if (pCI->nWait4MultipleStrResult == 1)
        {
            SCSendtextAsMsgs(pCI, pCI->pConfigInfo->strPriorWinlogon_Act);
            waitres = Wait4Str(pCI, pCI->pConfigInfo->strWinlogon);
        }

        //
        // Dismiss logon-disabled pop-up.
        //

        else if (pCI->nWait4MultipleStrResult == 2)
        {
            SCSendtextAsMsgs(pCI, L"\\n");
            waitres = Wait4Str(pCI, pCI->pConfigInfo->strWinlogon);
        }
    }

    if (waitres) 
    {
        TRACE((WARNING_MESSAGE, "Login failed"));
        rv = waitres;
        goto exitpt;
    }

    ConstructLogonString( 
        lpszServerName, 
        lpszUserName, 
        lpszPassword, 
        lpszDomain, 
        szBuff, 
        MAX_STRING_LENGTH,
        pCI->pConfigInfo
    );

    if ( 0 != szBuff[0] )
    {
        SCSendtextAsMsgs( pCI, szBuff );
    } else {
        //
        // do the default login

    // Hit Alt+U to go to user name field
        if ( _LOGON_RETRYS != nLogonRetrys )
        {
            SCSendtextAsMsgs(pCI, pCI->pConfigInfo->strWinlogon_Act);

            SCSendtextAsMsgs(pCI, lpszUserName);
    // Hit <Tab> key
            Sleep(300);
            SCSendtextAsMsgs(pCI, L"\\t");
        }

        Sleep(700);
        SCSendtextAsMsgs(pCI, lpszPassword);

        if ( _LOGON_RETRYS != nLogonRetrys )
        {
    // Hit <Tab> key
            Sleep(300);
            SCSendtextAsMsgs(pCI, L"\\t");

            SCSendtextAsMsgs(pCI, lpszDomain);
            Sleep(300);
        }
    }

    // Retry logon in case of
    // 1. Winlogon is on background
    // 2. Wrong username/password/domain
    // 3. Other

// Hit <Enter>
    SCSendtextAsMsgs(pCI, L"\\n");

    if ( !pCI->pConfigInfo->LoginWait )
        goto exitpt;

    nLogonWaitTime = 0;
    _snwprintf(szBuff, MAX_STRING_LENGTH - 1, L"%s|%s<->1000",
            pCI->pConfigInfo->strLogonErrorMessage, pCI->pConfigInfo->strSessionListDlg );

    while (!pCI->dead && !pCI->uiSessionId && nLogonWaitTime < pCI->pConfigInfo->CONNECT_TIMEOUT)
    {
        nFBSize = pCI->nFBsize;
        nFBEnd  = pCI->nFBend;
        //
        //  check if session list dialog is present
        //
        if ( pCI->pConfigInfo->strSessionListDlg[0] )
        {
            waitres = Wait4MultipleStrTimeout(pCI, szBuff);
            if (!waitres)
            {
                TRACE((INFO_MESSAGE, "Session list dialog is present\n" ));
                //
                //  restore buffer
                //
                pCI->nFBsize = nFBSize;
                pCI->nFBend = nFBEnd;
                Sleep( 1000 );
                SCSendtextAsMsgs(pCI, L"\\n");
                Sleep( 1000 );
            }
        }

        // Sleep with wait otherwise the chat won't work
        // i.e. this is a hack
        waitres = _Wait4Str(pCI, pCI->pConfigInfo->strLogonErrorMessage, 1000, WAIT_STRING);
        if (!waitres)
        // Error message received
        {
            //
            //  restore buffer
            //
            pCI->nFBsize = nFBSize;
            pCI->nFBend = nFBEnd;
            Sleep(1000);
            SCSendtextAsMsgs(pCI, L"\\n");
            Sleep(1000);
            break;
        }
        nLogonWaitTime += 1000;
    }

    if (!pCI->dead && !pCI->uiSessionId)
    {
        TRACE((WARNING_MESSAGE, "Logon sequence failed. Retrying (%d)",
                nLogonRetrys));
        if (nLogonRetrys--)
            goto retry_logon;
    }

    if (!pCI->uiSessionId)
    {
    // Send Enter, just in case we are not logged yet
        SCSendtextAsMsgs(pCI, L"\\n");
        rv = ERR_CANTLOGON;
    }

exitpt:
    return rv;
}

WPARAM _GetVirtualKey(INT scancode)
{
    if (scancode == 29)     // L Control
        return VK_CONTROL;
    else if (scancode == 42)     // L Shift
        return VK_SHIFT;
    else if (scancode == 56)     // L Alt
        return VK_MENU;
    else
        return MapVirtualKeyA(scancode, 3);
}

/*++
 *  Function:
 *      SCSendtextAsMsgs
 *  Description:
 *      Converts a string to WM_KEYUP/KEYDOWN messages
 *      And sends them thru client window
 *  Arguments:
 *      pCI         - connection context
 *      lpszString  - the string to be send
 *                    it can contain the following escape character:
 *  \n - Enter, \t - Tab, \^ - Esc, \& - Alt switch up/down
 *  \XXX - scancode XXX is down, \*XXX - scancode XXX is up
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCLogoff, SCStart, _WaitSomething, _Login
 --*/
PROTOCOLAPI
LPCSTR 
SMCAPI
SCSendtextAsMsgs(PCONNECTINFO pCI, LPCWSTR lpszString)
{
    LPCSTR  rv = NULL;
    INT     scancode = 0;
    WPARAM  vkKey;
    BOOL    bShiftDown = FALSE;
    BOOL    bAltKey = FALSE;
    BOOL    bCtrlKey = FALSE;
    UINT    uiMsg;
    LPARAM  lParam;
    DWORD   dwShiftDown = (ISWIN9X())?SHIFT_DOWN9X:SHIFT_DOWN;

#define _SEND_KEY(_c_, _m_, _v_, _l_)    {/*Sleep(40); */SCSenddata(_c_, _m_, _v_, _l_);}

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!lpszString)
    {
        TRACE((ERROR_MESSAGE, "NULL pointer passed to SCSendtextAsMsgs"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    TRACE(( INFO_MESSAGE, "Sending: \"%S\"\n", lpszString));
/*
    // Send KEYUP for the shift(s)
    // CapsLock ???!!!
    _SEND_KEY(pCI, WM_KEYUP, VK_SHIFT,
            WM_KEY_LPARAM(1, 0x2A, 0, 0, 1, 1));
    // Ctrl key
    _SEND_KEY(pCI, WM_KEYUP, VK_CONTROL,
            WM_KEY_LPARAM(1, 0x1D, 0, 0, 1, 1));
    // Alt key
    _SEND_KEY(pCI, WM_SYSKEYUP, VK_MENU,
            WM_KEY_LPARAM(1, 0x38, 0, 0, 1, 1));
*/
    for (;*lpszString; lpszString++)
    {
        if ( pCI->pConfigInfo &&
             pCI->pConfigInfo->bUnicode )
        {
            if ((*lpszString != '\\' && 1 == (rand() & 1) ) ||  // add randomness and...
                 *lpszString > 0x80             // send as unicode if non ascii
                )
            {
                //
                //  send unicode character
                //

                uiMsg = (!bAltKey || bCtrlKey)?WM_KEYDOWN:WM_SYSKEYDOWN;
                _SEND_KEY( pCI, uiMsg, VK_PACKET, (*lpszString << 16) );
                uiMsg = (!bAltKey || bCtrlKey)?WM_KEYUP:WM_SYSKEYUP;
                _SEND_KEY( pCI, uiMsg, VK_PACKET, (*lpszString << 16) );

                continue;
            }
        }

      if (*lpszString != '\\') {
try_again:
        if ((scancode = OemKeyScan(*lpszString)) == 0xffffffff)
        {
            rv = ERR_INVALID_SCANCODE_IN_XLAT;
            goto exitpt;
        }

    // Check the Shift key state
        if ((scancode & dwShiftDown) && !bShiftDown)
        {
                uiMsg = (bAltKey)?WM_SYSKEYDOWN:WM_KEYDOWN;
                _SEND_KEY(pCI, uiMsg, VK_SHIFT,
                        WM_KEY_LPARAM(1, 0x2A, 0, (bAltKey)?1:0, 0, 0));
                bShiftDown = TRUE;
        } 
        else if (!(scancode & dwShiftDown) && bShiftDown)
        {
                uiMsg = (bAltKey)?WM_SYSKEYUP:WM_KEYUP;
                _SEND_KEY(pCI, uiMsg, VK_SHIFT,
                        WM_KEY_LPARAM(1, 0x2A, 0, (bAltKey)?1:0, 1, 1));
                bShiftDown = FALSE;
        }
      } else {
        // Non printable symbols
        lpszString++;
        switch(*lpszString)
        {
        case 'n': scancode = 0x1C; break;   // Enter
        case 't': scancode = 0x0F; break;   // Tab
        case '^': scancode = 0x01; break;   // Esc
        case 'p': Sleep(100);      continue; break;   // Sleep for 0.1 sec
        case 'P': Sleep(1000);     continue; break;   // Sleep for 1 sec
        case 'x': SCSendMouseClick(pCI, pCI->xRes/2, pCI->yRes/2); continue; break;
        case '&': 
            // Alt key
            if (bAltKey)
            {
              _SEND_KEY(pCI, WM_KEYUP, VK_MENU,
                WM_KEY_LPARAM(1, 0x38, 0, 0, 1, 1));
            } else {
              _SEND_KEY(pCI, WM_SYSKEYDOWN, VK_MENU,
                WM_KEY_LPARAM(1, 0x38, 0, 1, 0, 0));
            }
            bAltKey = !bAltKey;
            continue;
        case '*':
            lpszString ++;
            if (isdigit(*lpszString))
            {
                INT exten;

                scancode = _wtoi(lpszString);
                TRACE((INFO_MESSAGE, "Scancode: %d UP\n", scancode));

                vkKey = _GetVirtualKey(scancode);

                uiMsg = (!bAltKey || bCtrlKey)?WM_KEYUP:WM_SYSKEYUP;

                if (vkKey == VK_MENU)
                    bAltKey = FALSE;
                else if (vkKey == VK_CONTROL)
                    bCtrlKey = FALSE;
                else if (vkKey == VK_SHIFT)
                    bShiftDown = FALSE;

                exten = (_IsExtendedScanCode(scancode))?1:0;
                lParam = WM_KEY_LPARAM(1, scancode, exten, (bAltKey)?1:0, 1, 1);
                if (uiMsg == WM_KEYUP)
                {
                    TRACE((INFO_MESSAGE, "WM_KEYUP, 0x%x, 0x%x\n", vkKey, lParam));
                } else {
                    TRACE((INFO_MESSAGE, "WM_SYSKEYUP, 0x%x, 0x%x\n", vkKey, lParam));
                }

                _SEND_KEY(pCI, uiMsg, vkKey, lParam);


                while(isdigit(lpszString[1]))
                    lpszString++;
            } else {
                lpszString--;
            }
            continue;
            break;
        case 0: continue;
        default: 
            if (isdigit(*lpszString))
            {
                INT exten;

                scancode = _wtoi(lpszString);
                TRACE((INFO_MESSAGE, "Scancode: %d DOWN\n", scancode));
                vkKey = _GetVirtualKey(scancode);

                if (vkKey == VK_MENU)
                    bAltKey = TRUE;
                else if (vkKey == VK_CONTROL)
                    bCtrlKey = TRUE;
                else if (vkKey == VK_SHIFT)
                    bShiftDown = TRUE;

                uiMsg = (!bAltKey || bCtrlKey)?WM_KEYDOWN:WM_SYSKEYDOWN;

                exten = (_IsExtendedScanCode(scancode))?1:0;
                lParam = WM_KEY_LPARAM(1, scancode, exten, (bAltKey)?1:0, 0, 0);

                if (uiMsg == WM_KEYDOWN)
                {
                    TRACE((INFO_MESSAGE, "WM_KEYDOWN, 0x%x, 0x%x\n", vkKey, lParam));
                } else {
                    TRACE((INFO_MESSAGE, "WM_SYSKEYDOWN, 0x%x, 0x%x\n", vkKey, lParam));
                }

                _SEND_KEY(pCI, uiMsg, vkKey, lParam);

                while(isdigit(lpszString[1]))
                    lpszString++;

                continue;
            } 
            goto try_again;
      }       
    
    }
    vkKey = MapVirtualKeyA(scancode, 3);
    // Remove flag fields
        scancode &= 0xff;

        uiMsg = (!bAltKey || bCtrlKey)?WM_KEYDOWN:WM_SYSKEYDOWN;
    // Send the scancode
        _SEND_KEY(pCI, uiMsg, vkKey, 
                        WM_KEY_LPARAM(1, scancode, 0, (bAltKey)?1:0, 0, 0));
        uiMsg = (!bAltKey || bCtrlKey)?WM_KEYUP:WM_SYSKEYUP;
        _SEND_KEY(pCI, uiMsg, vkKey,
                        WM_KEY_LPARAM(1, scancode, 0, (bAltKey)?1:0, 1, 1));
    }

    // And Alt key
    if (bAltKey)
        _SEND_KEY(pCI, WM_KEYUP, VK_MENU,
            WM_KEY_LPARAM(1, 0x38, 0, 0, 1, 1));

    // Shift up
    if (bShiftDown)
        _SEND_KEY(pCI, WM_KEYUP, VK_LSHIFT,
            WM_KEY_LPARAM(1, 0x2A, 0, 0, 1, 1));

    // Ctrl key
    if (bCtrlKey)
        _SEND_KEY(pCI, WM_KEYUP, VK_CONTROL,
            WM_KEY_LPARAM(1, 0x1D, 0, 0, 1, 1));
#undef   _SEND_KEY
exitpt:
    return rv;
}

/*++
 *  Function:
 *      SwitchToProcess
 *  Description:
 *      Use Alt+Tab to switch to a particular process that is already running
 *  Arguments:
 *      pCI         - connection context
 *      lpszParam   - the text in the alt-tab box that uniquely identifies the
 *                    process we should stop at (i.e., end up switching to)
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
PROTOCOLAPI
LPCSTR  
SMCAPI
SCSwitchToProcess(PCONNECTINFO pCI, LPCWSTR lpszParam)
{
#define ALT_TAB_WAIT_TIMEOUT 1000
#define MAX_APPS             20

    LPCSTR  rv = NULL;
    LPCSTR  waitres = NULL;
    INT     retrys = MAX_APPS;

//    WCHAR *wszCurrTask = 0;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }


    // Wait and look for the string, before we do any switching.  This makes
    // sure we don't hit the string even before we hit alt-tab, and then
    // end up switching to the wrong process

    while (_Wait4Str(pCI, lpszParam, ALT_TAB_WAIT_TIMEOUT/5, WAIT_STRING) == 0)
        ;

    // Press alt down
    SCSenddata(pCI, WM_KEYDOWN, 18, 540540929);

    // Now loop through the list of applications (assuming there is one),
    // stopping at our desired app.
    do {
        SCSenddata(pCI, WM_KEYDOWN, 9, 983041);
        SCSenddata(pCI, WM_KEYUP, 9, -1072758783);


        waitres = _Wait4Str(pCI, lpszParam, ALT_TAB_WAIT_TIMEOUT, WAIT_STRING);

        retrys --;
    } while (waitres && retrys);

    SCSenddata(pCI, WM_KEYUP, 18, -1070071807);
    
    rv = waitres;

exitpt:    
    return rv;
}

/*++
 *  Function:
 *      SCSetClientTopmost
 *  Description:
 *      Swithces the focus to this client
 *  Arguments:
 *      pCI     - connection context
 *      lpszParam
 *              - "0" will remote the WS_EX_TOPMOST style
 *              - "non_zero" will set it as topmost window
 *  Return value:
 *      Error message, NULL on success
 *  Called by:
 *      SCCheck
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSetClientTopmost(
        PCONNECTINFO pCI,
        LPCWSTR     lpszParam
    )
{
    LPCSTR rv = NULL;
    BOOL   bTop = FALSE;
    HWND   hClient;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }
    
#ifdef  _RCLX
    if (pCI->RClxMode)
    {
        TRACE((ERROR_MESSAGE, "SetClientOnFocus not supported in RCLX mode\n"));
        rv = ERR_NOTSUPPORTED;
        goto exitpt;
    }
#endif  // _RCLX

    hClient = _FindTopWindow(pCI->pConfigInfo->strMainWindowClass,
                                  NULL,
                                  pCI->lProcessId);
    if (!hClient)
    {
        TRACE((WARNING_MESSAGE, "Client's window handle is null\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (lpszParam)
        bTop = (_wtoi(lpszParam) != 0);
    else
        bTop = 0;

    if (!SetWindowPos(hClient,
                    (bTop)?HWND_TOPMOST:HWND_NOTOPMOST,
                    0,0,0,0,
                    SWP_NOMOVE | SWP_NOSIZE))
    {
        TRACE(( ERROR_MESSAGE, "SetWindowPos failed=%d\n",
                GetLastError()));
    }

    ShowWindow(hClient, SW_SHOWNORMAL);

    if (bTop)
    {
        TRACE((INFO_MESSAGE, "Client is SET as topmost window\n"));
    } else {
        TRACE((INFO_MESSAGE, "Client is RESET as topmost window\n"));
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _SendMouseClick
 *  Description:
 *      Sends a messages for a mouse click
 *  Arguments:
 *      pCI     - connection context
 *      xPos    - mouse position
 *      yPos
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSendMouseClick(
        PCONNECTINFO pCI, 
        UINT xPos,
        UINT yPos)
{
    LPCSTR rv;

    rv = SCSenddata(pCI, WM_LBUTTONDOWN, 0, xPos + (yPos << 16));
    if (!rv)
        SCSenddata(pCI, WM_LBUTTONUP, 0, xPos + (yPos << 16));

    return rv;
}

#ifdef  _RCLX
/*++
 *  Function:
 *      SCSaveClientScreen
 *  Description:
 *      Saves in a file rectangle of the client's receive screen buffer
 *      ( aka shadow bitmap)
 *  Arguments:
 *      pCI     - connection context
 *      left, top, right, bottom - rectangle coordinates
 *                if all == -1 get's the whole screen
 *      szFileName - file to record      
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSaveClientScreen(
        PCONNECTINFO pCI,
        INT left,
        INT top,
        INT right,
        INT bottom,
        LPCSTR szFileName)
{
    LPCSTR  rv = NULL;
    PVOID   pDIB = NULL;
    UINT    uiSize = 0;

    if (!szFileName)
    {
        TRACE((WARNING_MESSAGE, "SCSaveClientScreen: szFileName is NULL\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    // leave the rest of param checking to SCGetClientScreen
    rv = SCGetClientScreen(pCI, left, top, right, bottom, &uiSize, &pDIB);
    if (rv)
        goto exitpt;

    if (!pDIB || !uiSize)
    {
        TRACE((ERROR_MESSAGE, "SCSaveClientScreen: failed, no data\n"));
        rv = ERR_NODATA;
        goto exitpt;
    }

    if (!SaveDIB(pDIB, szFileName))
    {
        TRACE((ERROR_MESSAGE, "SCSaveClientScreen: save failed\n"));
        rv = ERR_NODATA;
        goto exitpt;
    }

exitpt:

    if (pDIB)
        free(pDIB);

    return rv;
}

/*++
 *  Function:
 *      SCGetClientScreen
 *  Description:
 *      Gets rectangle of the client's receive screen buffer
 *      ( aka shadow bitmap)
 *  Arguments:
 *      pCI     - connection context
 *      left, top, right, bottom - rectangle coordinates
 *                if all == -1 get's the whole screen
 *      ppDIB   - pointer to the received DIB
 *      puiSize - size of allocated data in ppDIB
 *
 *          !!!!! DON'T FORGET to free() THAT MEMORY !!!!!
 *
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      SCSaveClientScreen
 *      * * * EXPORTED * * * 
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCGetClientScreen(
        PCONNECTINFO pCI,
        INT left,
        INT top,
        INT right,
        INT bottom,
        UINT  *puiSize,
        PVOID *ppDIB)
{
    LPCSTR rv;
    PRCLXDATA  pRClxData;
    PREQBITMAP pReqBitmap;
    PRCLXDATACHAIN pIter, pPrev, pNext;
    PRCLXDATACHAIN pRClxDataChain = NULL;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (!pCI->RClxMode)
    {
        TRACE((WARNING_MESSAGE, "SCGetClientScreen is not supported in non-RCLX mode\n"));
        rv = ERR_NOTSUPPORTED;
        goto exitpt;
    }

    if (!ppDIB || !puiSize)
    {
        TRACE((WARNING_MESSAGE, "ppDIB and/or puiSize parameter is NULL\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    // Remove all recieved DATA_BITMAP from the recieve buffer
    EnterCriticalSection(g_lpcsGuardWaitQueue);
    {
        pIter = pCI->pRClxDataChain;
        pPrev = NULL;

        while (pIter)
        {
            pNext = pIter->pNext;

            if (pIter->RClxData.uiType == DATA_BITMAP)
            {
                // dispose this entry
                if (pPrev)
                    pPrev->pNext = pIter->pNext;
                else
                    pCI->pRClxDataChain = pIter->pNext;

                if (!pIter->pNext)
                    pCI->pRClxLastDataChain = pPrev;

                free(pIter);
            } else
                pPrev = pIter;

            pIter = pNext;
        }
    }
    LeaveCriticalSection(g_lpcsGuardWaitQueue);

    __try {
        pRClxData = (PRCLXDATA) alloca(sizeof(*pRClxData) + sizeof(*pReqBitmap));
    } __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pRClxData = NULL;
    }
    if ( NULL == pRClxData )
    {
        goto exitpt;
    }

    pRClxData->uiType = DATA_BITMAP;
    pRClxData->uiSize = sizeof(*pReqBitmap);
    pReqBitmap = (PREQBITMAP)pRClxData->Data;
    pReqBitmap->left   = left;
    pReqBitmap->top    = top;
    pReqBitmap->right  = right;
    pReqBitmap->bottom = bottom;

    TRACE((INFO_MESSAGE, "Getting client's DIB (%d, %d, %d, %d)\n", left, top, right, bottom));
    rv = _SendRClxData(pCI, pRClxData);

    if (rv)
        goto exitpt;

    do {
        rv = _Wait4RClxDataTimeout(pCI, pCI->pConfigInfo->WAIT4STR_TIMEOUT);
            if (rv)
            goto exitpt;

        if (!pCI->pRClxDataChain)
        {
            TRACE((ERROR_MESSAGE, "RClxData is not received\n"));
            rv = ERR_WAIT_FAIL_TIMEOUT;
            goto exitpt;
        }

        EnterCriticalSection(g_lpcsGuardWaitQueue);
        // Get any received DATA_BITMAP
        {
            pIter = pCI->pRClxDataChain;
            pPrev = NULL;

            while (pIter)
            {
                pNext = pIter->pNext;

                if (pIter->RClxData.uiType == DATA_BITMAP)
                {
                    // dispose this entry from the chain
                    if (pPrev)
                        pPrev->pNext = pIter->pNext;
                    else
                        pCI->pRClxDataChain = pIter->pNext;

                    if (!pIter->pNext)
                        pCI->pRClxLastDataChain = pPrev;

                    goto entry_is_found;
                } else
                    pPrev = pIter;

                pIter = pNext;
            }
    
entry_is_found:
            pRClxDataChain = (pIter && pIter->RClxData.uiType == DATA_BITMAP)?
                                pIter:NULL;
        }
        LeaveCriticalSection(g_lpcsGuardWaitQueue);
    } while (!pRClxDataChain && !pCI->dead);

    if (!pRClxDataChain)
    {
        TRACE((WARNING_MESSAGE, "SCGetClientScreen: client died\n"));
        goto exitpt;
    }

    *ppDIB = malloc(pRClxDataChain->RClxData.uiSize);
    if (!(*ppDIB))
    {
        TRACE((WARNING_MESSAGE, "Can't allocate %d bytes\n", 
                pRClxDataChain->RClxData.uiSize));
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }

    memcpy(*ppDIB, 
            pRClxDataChain->RClxData.Data, 
            pRClxDataChain->RClxData.uiSize);
    *puiSize = pRClxDataChain->RClxData.uiSize;

exitpt:

    if (pRClxDataChain)
        free(pRClxDataChain);

    return rv;
}

/*++
 *  Function:
 *      SCSendVCData
 *  Description:
 *      Sends data to a virtual channel
 *  Arguments:
 *      pCI     - connection context
 *      szVCName    - the virtual channel name
 *      pData       - data
 *      uiSize      - data size
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCSendVCData(
        PCONNECTINFO pCI,
        LPCSTR       szVCName,
        PVOID        pData,
        UINT         uiSize
        )
{
    LPCSTR     rv;
    PRCLXDATA  pRClxData = NULL;
    CHAR       *szName2Send;
    PVOID      pData2Send;
    UINT       uiPacketSize;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (!pCI->RClxMode)
    {
        TRACE((WARNING_MESSAGE, "SCSendVCData is not supported in non-RCLXmode\n"));
        rv = ERR_NOTSUPPORTED;
        goto exitpt;
    }

    if (!pData || !uiSize)
    {
        TRACE((WARNING_MESSAGE, "pData and/or uiSize parameter are NULL\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (strlen(szVCName) > MAX_VCNAME_LEN - 1)
    {
        TRACE((WARNING_MESSAGE, "channel name too long\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    uiPacketSize = sizeof(*pRClxData) + MAX_VCNAME_LEN + uiSize;

    pRClxData = (PRCLXDATA) malloc(uiPacketSize);
    if (!pRClxData)
    {
        TRACE((ERROR_MESSAGE, "SCSendVCData: can't allocate %d bytes\n", 
                uiPacketSize));
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }

    pRClxData->uiType = DATA_VC;
    pRClxData->uiSize = uiPacketSize - sizeof(*pRClxData);
    
    szName2Send = (CHAR *)pRClxData->Data;
    strcpy(szName2Send, szVCName);

    pData2Send  = szName2Send + MAX_VCNAME_LEN;
    memcpy(pData2Send, pData, uiSize);

    rv = _SendRClxData(pCI, pRClxData);

exitpt:
    if (pRClxData)
        free(pRClxData);

    return rv;
}

/*++
 *  Function:
 *      SCRecvVCData
 *  Description:
 *      Receives data from virtual channel
 *  Arguments:
 *      pCI     - connection context
 *      szVCName    - the virtual channel name
 *      ppData      - data pointer
 *
 *          !!!!! DON'T FORGET to free() THAT MEMORY !!!!!
 *
 *      puiSize     - pointer to the data size
 *  Return value:
 *      error string if fails, NULL on success
 *  Called by:
 *      * * * EXPORTED * * *
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCRecvVCData(
        PCONNECTINFO pCI,
        LPCSTR       szVCName,
        PVOID        pData,
        UINT         uiBlockSize,
        UINT         *puiBytesRead
        )
{
    LPCSTR      rv;
    LPSTR       szRecvVCName;
    PVOID       pChanData;
    PRCLXDATACHAIN pIter, pPrev, pNext;
    PRCLXDATACHAIN pRClxDataChain = NULL;
    UINT        uiBytesRead = 0;
    BOOL        bBlockFree = FALSE;

    if (!pCI)
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (pCI->dead)
    {
        rv = ERR_CLIENT_IS_DEAD;
        goto exitpt;
    }

    if (!pCI->RClxMode)
    {
        TRACE((WARNING_MESSAGE, "SCRecvVCData is not supported in non-RCLXmode\n"));
        rv = ERR_NOTSUPPORTED;
        goto exitpt;
    }

    if (!pData || !uiBlockSize || !puiBytesRead)
    {
        TRACE((WARNING_MESSAGE, "Invalid parameters\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    if (strlen(szVCName) > MAX_VCNAME_LEN - 1)
    {
        TRACE((WARNING_MESSAGE, "channel name too long\n"));
        rv = ERR_INVALID_PARAM;
        goto exitpt;
    }

    // Extract data entry from this channel
    do {
        if (!pCI->pRClxDataChain)
        {
            rv = _Wait4RClxDataTimeout(pCI, pCI->pConfigInfo->WAIT4STR_TIMEOUT);
            if (rv)
                goto exitpt;
        }
        EnterCriticalSection(g_lpcsGuardWaitQueue);

        // Search for data from this channel
        {
            pIter = pCI->pRClxDataChain;
            pPrev = NULL;

            while (pIter)
            {
                pNext = pIter->pNext;

                if (pIter->RClxData.uiType == DATA_VC &&
                    !_stricmp((LPCSTR) pIter->RClxData.Data, szVCName))
                {

                    if (pIter->RClxData.uiSize - pIter->uiOffset - MAX_VCNAME_LEN <= uiBlockSize)
                    {
                        // will read the whole block
                        // dispose this entry
                        if (pPrev)
                            pPrev->pNext = pIter->pNext;
                        else
                            pCI->pRClxDataChain = pIter->pNext;

                        if (!pIter->pNext)
                            pCI->pRClxLastDataChain = pPrev;

                        bBlockFree = TRUE;
                    }

                    goto entry_is_found;
                } else
                    pPrev = pIter;

                pIter = pNext;
            }
entry_is_found:

            pRClxDataChain = (pIter && pIter->RClxData.uiType == DATA_VC)?
                                pIter:NULL;
        }
        LeaveCriticalSection(g_lpcsGuardWaitQueue);
    } while (!pRClxDataChain && !pCI->dead);


    ASSERT(pRClxDataChain->RClxData.uiType == DATA_VC);

    szRecvVCName = (LPSTR) pRClxDataChain->RClxData.Data;
    if (_stricmp(szRecvVCName, szVCName))
    {
        TRACE((ERROR_MESSAGE, "SCRecvVCData: received from different channel: %s\n", szRecvVCName));
        ASSERT(0);
    }

    pChanData = (BYTE *)(pRClxDataChain->RClxData.Data) + 
                pRClxDataChain->uiOffset + MAX_VCNAME_LEN;
    uiBytesRead = pRClxDataChain->RClxData.uiSize - 
                  pRClxDataChain->uiOffset - MAX_VCNAME_LEN;
    if (uiBytesRead > uiBlockSize)
        uiBytesRead = uiBlockSize;
        

    memcpy(pData, pChanData, uiBytesRead);

    pRClxDataChain->uiOffset += uiBytesRead;

    rv = NULL;

exitpt:

    if (pRClxDataChain && bBlockFree)
    {
        ASSERT(pRClxDataChain->uiOffset + MAX_VCNAME_LEN == pRClxDataChain->RClxData.uiSize);
        free(pRClxDataChain);
    }

    if (puiBytesRead)
    {
        *puiBytesRead = uiBytesRead;
        TRACE((INFO_MESSAGE, "SCRecvVCData: %d bytes read\n", uiBytesRead));
    }

    return rv;
}
#endif  // _RCLX

/*++
 *  Function:
 *      _EnumWindowsProc
 *  Description:
 *      Used to find a specific window
 *  Arguments:
 *      hWnd    - current enumerated window handle
 *      lParam  - pointer to SEARCHWND passed from
 *                _FindTopWindow
 *  Return value:
 *      TRUE on success but window is not found
 *      FALSE if the window is found
 *  Called by:
 *      _FindTopWindow thru EnumWindows
 --*/
BOOL CALLBACK _EnumWindowsProc( HWND hWnd, LPARAM lParam )
{
    TCHAR    classname[128];
    TCHAR    caption[128];
    BOOL    rv = TRUE;
    DWORD   dwProcessId;
    LONG_PTR lProcessId;
    PSEARCHWND pSearch = (PSEARCHWND)lParam;

    if (pSearch->szClassName && 
//        !GetClassNameWrp(hWnd, classname, sizeof(classname)/sizeof(classname[0])))
        !GetClassNameW(hWnd, classname, sizeof(classname)/sizeof(classname[0])))
    {
        goto exitpt;
    }

    if (pSearch->szCaption && 
//        !GetWindowTextWrp(hWnd, caption, sizeof(caption)/sizeof(caption[0])))
        !GetWindowTextW(hWnd, caption, sizeof(caption)/sizeof(caption[0])))
    {
        goto exitpt;
    }

    GetWindowThreadProcessId(hWnd, &dwProcessId);
    lProcessId = dwProcessId;
    if (
        (!pSearch->szClassName || !         // Check for classname
#ifdef  UNICODE
        wcscmp
#else
        strcmp
#endif
            (classname, pSearch->szClassName)) 
    &&
        (!pSearch->szCaption || !
#ifdef  UNICODE
        wcscmp
#else
        strcmp
#endif
            (caption, pSearch->szCaption))
    &&
        lProcessId == pSearch->lProcessId)
    {
        ((PSEARCHWND)lParam)->hWnd = hWnd;
        rv = FALSE;
    }

exitpt:
    return rv;
}

/*++
 *  Function:
 *      _FindTopWindow
 *  Description:
 *      Find specific window by classname and/or caption and/or process Id
 *  Arguments:
 *      classname   - class name to search for, NULL ignore
 *      caption     - caption to search for, NULL ignore
 *      dwProcessId - process Id, 0 ignore
 *  Return value:
 *      window handle found, NULL otherwise
 *  Called by:
 *      SCConnect, SCDisconnect, GetDisconnectResult
 --*/
HWND _FindTopWindow(LPTSTR classname, LPTSTR caption, LONG_PTR lProcessId)
{
    SEARCHWND search;

    search.szClassName = classname;
    search.szCaption = caption;
    search.hWnd = NULL;
    search.lProcessId = lProcessId;

    EnumWindows(_EnumWindowsProc, (LPARAM)&search);

    return search.hWnd;
}

/*++
 *  Function:
 *      _FindWindow
 *  Description:
 *      Find child window by caption and/or classname
 *  Arguments:
 *      hwndParent      - the parent window handle
 *      srchcaption     - caption to search for, NULL - ignore
 *      srchclass       - class name to search for, NULL - ignore
 *  Return value:
 *      window handle found, NULL otherwise
 *  Called by:
 *      SCConnect
 --*/
HWND _FindWindow(HWND hwndParent, LPTSTR srchcaption, LPTSTR srchclass)
{
    HWND hWnd, hwndTop, hwndNext;
    BOOL bFound;
    TCHAR classname[128];
    TCHAR caption[128];

    hWnd = NULL;

    hwndTop = GetWindow(hwndParent, GW_CHILD);
    if (!hwndTop) 
    {
        TRACE((INFO_MESSAGE, "GetWindow failed. hwnd=0x%x\n", hwndParent));
        goto exiterr;
    }

    bFound = FALSE;
    hwndNext = hwndTop;
    do {
        hWnd = hwndNext;
//        if (srchclass && !GetClassNameWrp(hWnd, classname, sizeof(classname)))
        if (srchclass && !GetClassNameW(hWnd, classname, sizeof(classname)/sizeof(classname[0])))
        {
            TRACE((INFO_MESSAGE, "GetClassName failed. hwnd=0x%x\n"));
            goto nextwindow;
        }
        if (srchcaption && 
//            !GetWindowTextWrp(hWnd, caption, sizeof(caption)/sizeof(classname[0])))
            !GetWindowTextW(hWnd, caption, sizeof(caption)/sizeof(classname[0])/sizeof(classname[0])))
        {
            TRACE((INFO_MESSAGE, "GetWindowText failed. hwnd=0x%x\n"));
            goto nextwindow;
        }

        if (
            (!srchclass || !
#ifdef  UNICODE
            wcscmp
#else
            strcmp
#endif
                (classname, srchclass))
        &&
            (!srchcaption || !
#ifdef  UNICODE
            wcscmp
#else
            strcmp
#endif
                (caption, srchcaption))
        )
            bFound = TRUE;
        else {
            //
            // search recursively
            //
            HWND hSubWnd = _FindWindow( hWnd, srchcaption, srchclass);
            if ( NULL != hSubWnd )
            {
                bFound = TRUE;
                hWnd = hSubWnd;
                goto exitpt;
            }
        }
nextwindow:
        hwndNext = GetNextWindow(hWnd, GW_HWNDNEXT);
    } while (hWnd && hwndNext != hwndTop && !bFound);

exitpt:
    if (!bFound) goto exiterr;

    return hWnd;
exiterr:
    return NULL;
}

BOOL
_IsExtendedScanCode(INT scancode)
{
    static BYTE extscans[] = \
        {28, 29, 53, 55, 56, 71, 72, 73, 75, 77, 79, 80, 81, 82, 83, 87, 88};
    INT idx;

    for (idx = 0; idx < sizeof(extscans); idx++)
    {
        if (scancode == (INT)extscans[idx])
            return TRUE;
    }
    return FALSE;
}

PROTOCOLAPI
BOOL
SMCAPI
SCOpenClipboard(HWND hwnd)
{
    return OpenClipboard(hwnd);
}

PROTOCOLAPI
BOOL 
SMCAPI
SCCloseClipboard(VOID)
{
    return CloseClipboard();
}

PROTOCOLAPI
LPCSTR
SMCAPI
SCDetach(
    PCONNECTINFO pCI
    )
{
    LPCSTR rv = NULL;

    if ( NULL == pCI )
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        rv = ERR_NULL_CONNECTINFO;
        goto exitpt;
    }

    if (!_RemoveFromClientQ(pCI))
    {
        TRACE(( WARNING_MESSAGE,
                "Couldn't find CONNECTINFO in the queue\n" ));
    }
    _CloseConnectInfo( pCI );

exitpt:
    return rv;
}

/*++
 *  Function:
 *      SCAttach
 *  Description:
 *          Attach CONNECTINFO to a client window, assuming that the client
 *      is already started
 *      it uses a special cookie to identify the client in the future
 *          It is recommended to call SCDetach instead of SCLogoff or SCDisconnect
 *  Arguments:
 *      hClient     - handle to a container window
 *          the function will find the client window in the child windows
 *      lClientCookie - This value is used to identify the client
 *          in normal SCConnect function the client's process id is used
 *          here any value could be used, but the client has to be notified for
 *          it
 *      ppCI        - the function returns non-NULL connection structure on
 *          success
 *  Return value:
 *      SC error message
 *  Called by:
 *      exported
 --*/
PROTOCOLAPI
LPCSTR
SMCAPI
SCAttach( 
    HWND hClient, 
    LONG_PTR lClientCookie, 
    PCONNECTINFO *ppCI 
    )
{
    LPCSTR rv = NULL;
    PCONNECTINFO pCI = NULL;
    HWND    hContainer = NULL;
    HWND    hInput = NULL;
    HWND    hOutput = NULL;
    UINT    trys;

    pCI = (PCONNECTINFO) malloc( sizeof( *pCI ));
    if ( NULL == pCI )
    {
        TRACE(( ERROR_MESSAGE, "SCAttach: failed to allocate memory\n" ));
        rv = ERR_ALLOCATING_MEMORY;
        goto exitpt;
    }

    ZeroMemory( pCI, sizeof( *pCI ));
    //
    //  get all the windows we need
    //
    trys = 240;     // 2 min
    do {
        hContainer = _FindWindow(hClient, NULL, NAME_CONTAINERCLASS);
        hInput = _FindWindow(hContainer, NULL, NAME_INPUT);
        hOutput = _FindWindow(hContainer, NULL, NAME_OUTPUT);
        if (!hContainer || !hInput || !hOutput)
        {
            TRACE((INFO_MESSAGE, "Can't get child windows. Retry"));
            Sleep(500);
            trys--;
        }
    } while ((!hContainer || !hInput || !hOutput) && trys);

    if (!trys)
    {
        TRACE((WARNING_MESSAGE, "Can't find child windows"));
        rv = ERR_CONNECTING;
        goto exitpt;
    }

    TRACE((INFO_MESSAGE, "hClient   = 0x%x\n", hClient));
    TRACE((INFO_MESSAGE, "hContainer= 0x%x\n", hContainer));
    TRACE((INFO_MESSAGE, "hInput    = 0x%x\n", hInput));
    TRACE((INFO_MESSAGE, "hOutput   = 0x%x\n", hOutput));
    TRACE((INFO_MESSAGE, "ClientCookie= 0x%x\n", lClientCookie ));


    pCI->hClient        = hClient;
    pCI->hContainer     = hContainer;
    pCI->hInput         = hInput;
    pCI->hOutput        = hOutput;
    pCI->lProcessId     = lClientCookie;

    *ppCI = pCI;

    _AddToClientQ(*ppCI);
    //
    //  success !!!
    //

exitpt:
    if ( NULL != rv && NULL != pCI )
    {
        SCDetach( pCI );
        *ppCI = NULL;
    }

    return rv;
}

/*++
 *  Function:
 *      _IsSmartcardActive
 *  Description:
 *      Determine whether or not to look for the smartcard UI.
 *  Arguments:
 *      None.
 *  Return value:
 *      TRUE if the smartcard UI is expected, FALSE otherwise.
 *  Called by:
 *      _Login
 *  Author:
 *      Based on code from Sermet Iskin (sermeti) 15-Jan-2002
 *      Alex Stephens (alexstep) 20-Jan-2002
 --*/
BOOL
_IsSmartcardActive(
    VOID
    )
{

    SCARDCONTEXT hCtx;
    LPCTSTR mszRdrs;
    LPCTSTR szRdr;
    DWORD cchRdrs;
    DWORD dwRet;
    DWORD cRdrs;
    SCARD_READERSTATE rgStateArr[MAXIMUM_SMARTCARD_READERS];
    DWORD dwIndex;
    BOOL fSuccess;

    //
    // Windows releases earlier than XP (NT 5.1/2600) do not support
    // smartcards, so return if running on such.
    //

    if (!ISSMARTCARDAWARE())
    {
        TRACE((INFO_MESSAGE, "OS does not support smartcards.\n"));
        return FALSE;
    }

    //
    // Load the smartcard library, which will set the appropriate function
    // pointers. It is loaded only once, and remains loaded until the process
    // exits.
    //

    dwRet = _LoadSmartcardLibrary();
    if (dwRet != ERROR_SUCCESS)
    {
        TRACE((ERROR_MESSAGE,
               "Unable to load smartcard library (error %#x).\n",
                dwRet));
        return FALSE;
    }
    ASSERT(g_hSmartcardLibrary != NULL);

    //
    // Get an scard context. If this fails, the service might not be running.
    //

    ASSERT(g_pfnSCardEstablishContext != NULL);
    dwRet = g_pfnSCardEstablishContext(SCARD_SCOPE_SYSTEM,
                                       NULL,
                                       NULL,
                                       &hCtx);
    switch (dwRet)
    {

        //
        // Got scard context.
        //

    case SCARD_S_SUCCESS:
        TRACE((INFO_MESSAGE, "Smartcard context established.\n"));
        break;

        //
        // The smartcard service is not running, so there will be no
        // smartcard UI.
        //

    case SCARD_E_NO_SERVICE:
        TRACE((INFO_MESSAGE, "Smartcard service not running.\n"));
        return FALSE;
        break;

        //
        // The call has failed.
        //

    default:
        TRACE((ERROR_MESSAGE,
               "Unable to establish smartcard context (error %#x).\n",
                dwRet));
        return FALSE;
        break;
    }
    ASSERT(hCtx != 0);

    //
    // Always release the smartcard context.
    //

    fSuccess = FALSE;
    try
    {

        //
        // Get the list of the readers, using an auto-allocated buffer.
        //

        mszRdrs = NULL;
        cchRdrs = SCARD_AUTOALLOCATE;
        ASSERT(g_pfnSCardListReaders != NULL);
        dwRet = g_pfnSCardListReaders(hCtx,
                                      NULL,
                                      (LPTSTR)&mszRdrs,
                                      &cchRdrs);
        switch (dwRet)
        {

            //
            // Readers are present.
            //

        case SCARD_S_SUCCESS:
            ASSERT(cchRdrs != 0 &&
                   mszRdrs != NULL &&
                   *mszRdrs != TEXT('\0'));
            TRACE((INFO_MESSAGE, "Smartcard readers are present.\n"));
            break;

            //
            // No readers are present, so there will be no smartcard UI.
            //

        case SCARD_E_NO_READERS_AVAILABLE:
            TRACE((INFO_MESSAGE, "No smartcard readers are present.\n"));
            leave;
            break;

            //
            // The call has failed.
            //

        default:
            TRACE((ERROR_MESSAGE,
                   "Unable to get smartcard-reader list (error %#x).\n",
                    dwRet));
            leave;
            break;
        }

        //
        // Always free the reader-list buffer, which is allocated by the
        // smartcard code.
        //

        try
        {

            //
            // Count the number of readers.
            //

            ZeroMemory(rgStateArr, sizeof(rgStateArr));
            for (szRdr = _FirstString(mszRdrs), cRdrs = 0;
                 szRdr != NULL;
                 szRdr = _NextString(szRdr))
            {
                rgStateArr[cRdrs].szReader = szRdr;
                rgStateArr[cRdrs].dwCurrentState = SCARD_STATE_UNAWARE;
                cRdrs += 1;
            }

            //
            // Query for reader states.
            //

            ASSERT(g_pfnSCardGetStatusChange != NULL);
            dwRet = g_pfnSCardGetStatusChange(hCtx, 0, rgStateArr, cRdrs);
            if (dwRet != SCARD_S_SUCCESS)
            {
                TRACE((
                    ERROR_MESSAGE,
                    "Unable to query smartcard-reader states (error %#x).\n",
                    dwRet));
                leave;
            }

            //
            // Check each reader for a card. If one is found, the smartcard
            // UI must be handled.
            //

            for (dwIndex = 0; dwIndex < cRdrs; dwIndex += 1)
            {
                if (rgStateArr[dwIndex].dwEventState & SCARD_STATE_PRESENT)
                {
                    TRACE((INFO_MESSAGE, "Smartcard present.\n"));
                    fSuccess = TRUE;
                    leave;
                }
            }

            //
            // No smartcards were found, so there will be no smartcard UI.
            //

            TRACE((INFO_MESSAGE, "No smartcards are present.\n"));
        }

        //
        // Free reader strings.
        //

        finally
        {
            ASSERT(g_pfnSCardFreeMemory != NULL);
            ASSERT(hCtx != 0);
            ASSERT(mszRdrs != NULL);
            g_pfnSCardFreeMemory(hCtx, mszRdrs);
            mszRdrs = NULL;
        }
    }

    //
    // Release smartcard context.
    //

    finally
    {
        ASSERT(g_pfnSCardReleaseContext != NULL);
        ASSERT(hCtx != 0);
        g_pfnSCardReleaseContext(hCtx);
        hCtx = 0;
    }

    return fSuccess;
}

/*++
 *  Function:
 *      _LoadSmartcardLibrary
 *  Description:
 *      This routine loads the smartcard library.
 *  Arguments:
 *      None.
 *  Return value:
 *      ERROR_SUCCESS if successful, an appropriate Win32 error code
 *      otherwise.
 *  Called by:
 *      _IsSmartcardActive
 *  Author:
 *      Alex Stephens (alexstep) 20-Jan-2002
 --*/
DWORD
_LoadSmartcardLibrary(
    VOID
    )
{

    HANDLE hSmartcardLibrary;
    HANDLE hPreviousSmartcardLibrary;

    //
    // If the smartcard library has already been loaded, succeed.
    //

    if (g_hSmartcardLibrary != NULL &&
        g_pfnSCardEstablishContext != NULL &&
        g_pfnSCardListReaders != NULL &&
        g_pfnSCardGetStatusChange != NULL &&
        g_pfnSCardFreeMemory != NULL &&
        g_pfnSCardReleaseContext != NULL)
    {
        return ERROR_SUCCESS;
    }

    //
    // Load the library.
    //

    hSmartcardLibrary = LoadLibrary(SMARTCARD_LIBRARY);
    if (hSmartcardLibrary == NULL)
    {
        TRACE((ERROR_MESSAGE, "Unable to load smardcard library.\n"));
        return GetLastError();
    }

    //
    // Save the library handle to the global pointer. If it has already been
    // set, decrement the reference count.
    //

    hPreviousSmartcardLibrary =
        InterlockedExchangePointer(&g_hSmartcardLibrary,
                                   hSmartcardLibrary);
    if (hPreviousSmartcardLibrary != NULL)
    {
        RTL_VERIFY(FreeLibrary(hSmartcardLibrary));
    }

    //
    // Get the addresses of the smartcard routines.
    //

    return _GetSmartcardRoutines();
}

/*++
 *  Function:
 *      _GetSmartcardRoutines
 *  Description:
 *      This routine sets the global function pointers used to call the
 *      smartcard routines.
 *  Arguments:
 *      None.
 *  Return value:
 *      ERROR_SUCCESS if successful, an appropriate Win32 error code
 *      otherwise.
 *  Called by:
 *      _LoadSmartcardLibrary
 *  Author:
 *      Alex Stephens (alexstep) 20-Jan-2002
 --*/
DWORD
_GetSmartcardRoutines(
    VOID
    )
{

    FARPROC pfnSCardEstablishContext;
    FARPROC pfnSCardListReaders;
    FARPROC pfnSCardGetStatusChange;
    FARPROC pfnSCardFreeMemory;
    FARPROC pfnSCardReleaseContext;

    //
    // If the smartcard pointers have already been set, succeed.
    //

    ASSERT(g_hSmartcardLibrary != NULL);
    if (g_pfnSCardEstablishContext != NULL &&
        g_pfnSCardListReaders != NULL &&
        g_pfnSCardGetStatusChange != NULL &&
        g_pfnSCardFreeMemory != NULL &&
        g_pfnSCardReleaseContext != NULL)
    {
        return ERROR_SUCCESS;
    }

    //
    // Get the address of each routine.
    //

    pfnSCardEstablishContext = GetProcAddress(g_hSmartcardLibrary,
                                              SCARDESTABLISHCONTEXT);
    if (pfnSCardEstablishContext == NULL)
    {
        TRACE((ERROR_MESSAGE,
               "Unable to get SCardEstablishContext address.\n"));
        return GetLastError();
    }

    pfnSCardListReaders = GetProcAddress(g_hSmartcardLibrary,
                                         SCARDLISTREADERS);
    if (pfnSCardListReaders == NULL)
    {
        TRACE((ERROR_MESSAGE, "Unable to get SCardListReaders address.\n"));
        return GetLastError();
    }

    pfnSCardGetStatusChange = GetProcAddress(g_hSmartcardLibrary,
                                             SCARDGETSTATUSCHANGE);
    if (pfnSCardGetStatusChange == NULL)
    {
        TRACE((ERROR_MESSAGE,
               "Unable to get SCardGetStatusChange address.\n"));
        return GetLastError();
    }

    pfnSCardFreeMemory = GetProcAddress(g_hSmartcardLibrary,
                                        SCARDFREEMEMORY);
    if (pfnSCardFreeMemory == NULL)
    {
        TRACE((ERROR_MESSAGE, "Unable to get SCardFreeMemory address.\n"));
        return GetLastError();
    }

    pfnSCardReleaseContext = GetProcAddress(g_hSmartcardLibrary,
                                            SCARDRELEASECONTEXT);
    if (pfnSCardReleaseContext == NULL)
    {
        TRACE((ERROR_MESSAGE,
              "Unable to get SCardReleaseContext address.\n"));
        return GetLastError();
    }

    //
    // Fill in any the global pointers. It would be better to
    // compare/exchange, but Windows 95 lacks the necessary APIs.
    //

    InterlockedExchangePointer((PVOID *)&g_pfnSCardEstablishContext,
                               pfnSCardEstablishContext);
    ASSERT(g_pfnSCardEstablishContext != NULL);

    InterlockedExchangePointer((PVOID *)&g_pfnSCardListReaders,
                               pfnSCardListReaders);
    ASSERT(g_pfnSCardListReaders != NULL);

    InterlockedExchangePointer((PVOID *)&g_pfnSCardGetStatusChange,
                               pfnSCardGetStatusChange);
    ASSERT(g_pfnSCardGetStatusChange != NULL);

    InterlockedExchangePointer((PVOID *)&g_pfnSCardFreeMemory,
                               pfnSCardFreeMemory);
    ASSERT(g_pfnSCardFreeMemory != NULL);

    InterlockedExchangePointer((PVOID *)&g_pfnSCardReleaseContext,
                               pfnSCardReleaseContext);
    ASSERT(g_pfnSCardReleaseContext != NULL);

    return ERROR_SUCCESS;
}

/*++
 *  Function:
 *      _FirstString
 *  Description:
 *      This routine returns a pointer to the first string in a multistring,
 *      or NULL if there aren't any.
 *  Arguments:
 *      szMultiString - This supplies the address of the current position
 *          within a Multi-string structure.
 *  Return value:
 *      The address of the first null-terminated string in the structure, or
 *      NULL if there are no strings.
 *  Called by:
 *      _IsSmartcardActive
 *  Author:
 *      Doug Barlow (dbarlow) 11/25/1996
 *      Alex Stephens (alexstep) 20-Jan-2002
 --*/
LPCTSTR
_FirstString(
    IN LPCTSTR szMultiString
    )
{

    //
    // If the multi-string is NULL, or is empty, there is no first string.
    //

    if (szMultiString == NULL || *szMultiString == TEXT('\0'))
    {
        return NULL;
    }

    return szMultiString;
}

/*++
 *  Function:
 *      _NextString
 *  Description:
 *      In some cases, the Smartcard API returns multiple strings, separated
 *      by Null characters, and terminated by two null characters in a row.
 *      This routine simplifies access to such structures.  Given the current
 *      string in a multi-string structure, it returns the next string, or
 *      NULL if no other strings follow the current string.
 *  Arguments:
 *      szMultiString - This supplies the address of the current position
 *          within a Multi-string structure.
 *  Return value:
 *      The address of the next Null-terminated string in the structure, or
 *      NULL if no more strings follow.
 *  Called by:
 *      _IsSmartcardActive
 *  Author:
 *      Doug Barlow (dbarlow) 8/12/1996
 *      Alex Stephens (alexstep) 20-Jan-2002
 --*/
LPCTSTR
_NextString(
    IN LPCTSTR szMultiString
    )
{

    DWORD_PTR dwLength;
    LPCTSTR szNext;

    //
    // If the multi-string is NULL, or is empty, there is no next string.
    //

    if (szMultiString == NULL || *szMultiString == TEXT('\0'))
    {
        return NULL;
    }

    //
    // Get the length of the current string.
    //

    dwLength = _tcslen(szMultiString);
    ASSERT(dwLength != 0);

    //
    // Skip the current string, including the terminating NULL, and check to
    // see if there is a next string.
    //

    szNext = szMultiString + dwLength + 1;
    if (*szNext == TEXT('\0'))
    {
        return NULL;
    }

    return szNext;
}

/*++
 *  Function:
 *      _SendRunHotkey
 *  Description:
 *      This routine sends the Windows hotkey used to open the shell's Run
 *      window.
 *      Note: Keyboard hooks must be enabled for this to work!
 *  Arguments:
 *      pCI - Supplies the connection context.
 *      bFallBack - Supplies a value indicating whether or not to fall back
 *          to Ctrl+Esc and R if the keyboard hook is disabled.
 *  Return value:
 *      None.
 *  Called by:
 *      SCLogoff
 *      SCStart
 *  Author:
 *      Alex Stephens (alexstep) 15-Jan-2002
 --*/
VOID
_SendRunHotkey(
    IN CONST PCONNECTINFO pCI,
    IN BOOL bFallBack
    )
{
    ASSERT(pCI != NULL);

    //
    // Send Win+R if the keyboard hook is enabled.
    //

    if (pCI->pConfigInfo->KeyboardHook == TCLIENT_KEYBOARD_HOOK_ALWAYS)
    {
        TRACE((INFO_MESSAGE, "Sending Win+R hotkey.\n"));
        SCSenddata(pCI, WM_KEYDOWN, 0x0000005B, 0x015B0001);
        SCSenddata(pCI, WM_KEYDOWN, 0x00000052, 0x00130001);
        SCSenddata(pCI, WM_CHAR, 0x00000072, 0x00130001);
        SCSenddata(pCI, WM_KEYUP, 0x00000052, 0x80130001);
        SCSenddata(pCI, WM_KEYUP, 0x0000005B, 0x815B0001);
    }

    //
    // If the keyboard hook is not enabled, either fail or try Ctrl+Esc and
    // the Run key.
    //

    else
    {
        if (bFallBack)
        {
            TRACE((INFO_MESSAGE, "Sending Ctrl+Esc and Run key.\n"));
            SCSenddata(pCI, WM_KEYDOWN, 0x00000011, 0x001D0001);
            SCSenddata(pCI, WM_KEYDOWN, 0x0000001B, 0x00010001);
            SCSenddata(pCI, WM_KEYUP, 0x0000001B, 0xC0010001);
            SCSenddata(pCI, WM_KEYUP, 0x00000011, 0xC01D0001);
            SCSendtextAsMsgs(pCI, pCI->pConfigInfo->strStartRun_Act);
        }
        else
        {
            TRACE((WARNING_MESSAGE,
                   "Keyboard hook disabled! Cannot send Win+R!\n"));
        }
    }
}

/*++
 *  Function:
 *      SCClientHandle
 *  Description:
 *      Get client window
 *  Arguments:
 *      pCI - connection context
 *  Return value:
 *      window handle found, NULL otherwise
 *  Called by:
 *
 --*/
PROTOCOLAPI
HWND
SMCAPI
SCGetClientWindowHandle(
    PCONNECTINFO pCI
    )
{
    HWND hWnd;

    hWnd = NULL;

    if ( NULL == pCI )
    {
        TRACE((WARNING_MESSAGE, "Connection info is null\n"));
        goto exitpt;
    }

    hWnd = pCI->hClient;
    if (!hWnd)
    {
        TRACE((ERROR_MESSAGE, "SCGetClientHandle failed\n"));
        goto exitpt;
    }

exitpt:
    return hWnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\tclient.h ===
/*++
 *  File name:
 *      tclient.h
 *  Contents:
 *      Common definitions for tclient.dll
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 --*/

#ifndef _TCLIENT_H

#define _TCLIENT_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef OS_WIN32
#define OS_WIN32
#endif

#include    "feedback.h"
#include    "clntdata.h"

extern OSVERSIONINFOEXW g_OsInfo;

//
// OSVERSION macros...
//
#define ISNT()              (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
#define ISWIN9X()           (g_OsInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS)
#define ISWIN95_GOLDEN()    (ISWIN95() && LOWORD(g_OsInfo.dwBuildNumber) <= 1000)
#define ISWIN95_OSR2()      (ISWIN95() && LOWORD(g_OsInfo.dwBuildNumber) > 1000)
#define ISMEMPHIS()         (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==10)
#define ISATLEASTWIN98()    (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion>=10)
#define ISWIN95()           (ISWIN9X() && !ISATLEASTWIN98())
#define ISMILLENNIUM()      (ISWIN9X() && g_OsInfo.dwMajorVersion==4 && g_OsInfo.dwMinorVersion==90)
#define BUILDNUMBER()       (g_OsInfo.dwBuildNumber)

//
// The smartcard subsystem requires Windows NT 4.0 SP3 or higher on the NT
// side, and Windows 95 OSR2 or higher on the 9x side.
//

#define ISSMARTCARDAWARE()  (ISNT() && (g_OsInfo.dwMajorVersion >= 5 || \
                                        g_OsInfo.dwMajorVersion == 4 && \
                                        g_OsInfo.wServicePackMajor >= 3) || \
                             ISATLEASTWIN98() || \
                             ISWIN95_OSR2())

// Error messages
#define ERR_START_MENU_NOT_APPEARED     "Start menu not appeared"
#define ERR_COULDNT_OPEN_PROGRAM        "Couldn't open a program"
#define ERR_INVALID_SCANCODE_IN_XLAT    "Invalid scancode in Xlat table"
#define ERR_WAIT_FAIL_TIMEOUT           "Wait failed: TIMEOUT"
#define ERR_INVALID_PARAM               "Invalid parameter"
#define ERR_NULL_CONNECTINFO            "ConnectInfo structure is NULL"
#define ERR_CLIENT_IS_DEAD              "Client is dead, sorry"
#define ERR_ALLOCATING_MEMORY           "Couldn't allocate memory"
#define ERR_CREATING_PROCESS            "Couldn't start process"
#define ERR_CREATING_THREAD             "Can't create thread"
#define ERR_INVALID_COMMAND             "Check: Invalid command"
#define ERR_ALREADY_DISCONNECTED        "No Info. Disconnect command" \
                                        " was executed"
#define ERR_CONNECTING                  "Can't connect"
#define ERR_CANTLOGON                   "Can't logon"
#define ERR_NORMAL_EXIT                 "Client exit normaly"
#define ERR_UNKNOWN_CLIPBOARD_OP        "Unknown clipboard operation"
#define ERR_COPY_CLIPBOARD              "Error copying to the clipboard"
#define ERR_PASTE_CLIPBOARD             "Error pasting from the clipboard"
#define ERR_PASTE_CLIPBOARD_EMPTY       "The clipboard is empty"
#define ERR_PASTE_CLIPBOARD_DIFFERENT_SIZE "Check clipboard: DIFFERENT SIZE"
#define ERR_PASTE_CLIPBOARD_NOT_EQUAL   "Check clipboard: NOT EQUAL"
#define ERR_SAVE_CLIPBOARD              "Save clipboard FAILED"
#define ERR_CLIPBOARD_LOCKED            "Clipboard is locked for writing " \
                                        "by another thread"
#define ERR_CLIENTTERMINATE_FAIL        "Client termination FAILED"
#define ERR_NOTSUPPORTED                "Call is not supported in this mode"
#define ERR_CLIENT_DISCONNECTED         "Client is disconnected"
#define ERR_NODATA                      "The call failed, data is missing"
#define ERR_LANGUAGE_NOT_FOUND          "The language of the remote machine could not be found"
#define ERR_UNKNOWNEXCEPTION            "Unknown exception generated"
#define ERR_CANTLOADLIB                 "Can't load dll"
#define ERR_CANTGETPROCADDRESS          "Can't get enrty address"
#define ERR_CONSOLE_GENERIC             "Generic error in console dll"

// scancode modifier(s)
#define     SHIFT_DOWN		0x10000
#define     SHIFT_DOWN9X	0x20000

// Look for WM_KEYUP or WM_KEYDOWN
#define WM_KEY_LPARAM(repeat, scan, exten, context, prev, trans) \
    (repeat + ((scan & 0xff) << 16) + ((exten & 1) << 24) +\
    ((context & 1) << 29) + ((prev & 1) << 30) + ((trans & 1) << 31))

extern VOID _TClientAssert(BOOL bCond,
                           LPCSTR filename,
                           INT line,
                           LPCSTR expression,
                           BOOL bBreak);

//
// Define assertion macros. Note that these are defined on both free and
// checked builds. Checked-only versions might be preferable, if nothing is
// broken by such a change.
//

#ifndef ASSERT
#define ASSERT( exp ) \
    ((!(exp)) ? \
        (_TClientAssert(FALSE, __FILE__, __LINE__, #exp, TRUE),FALSE) : \
        TRUE)
#endif  // !ASSERT

#ifndef RTL_SOFT_ASSERT
#define RTL_SOFT_ASSERT( _exp ) \
    ((!(_exp)) ? \
        (_TClientAssert(FALSE, __FILE__, __LINE__, #_exp, FALSE),FALSE) : \
        TRUE)
#endif  // !RTL_SOFT_ASSERT

//
// Define verification macros. These are checked-only macros.
//

#ifndef RTL_VERIFY
#if DBG
#define RTL_VERIFY ASSERT
#else
#define RTL_VERIFY(exp) ((exp) ? TRUE : FALSE)
#endif // DBG
#endif // !RTL_VERIFY

#ifndef RTL_SOFT_VERIFY
#if DBG
#define RTL_SOFT_VERIFY RTL_SOFT_ASSERT
#else
#define RTL_SOFT_VERIFY RTL_VERIFY
#endif // DBG
#endif // !RTL_SOFT_VERIFY

//
// Define tracing macros.
//

#ifndef TRACE
#define TRACE(_x_)  if (g_pfnPrintMessage) {\
                        g_pfnPrintMessage(ALIVE_MESSAGE, "Worker:%d ", GetCurrentThreadId());\
                        g_pfnPrintMessage _x_; }
#endif  // !TRACE

//
// Define NT list manipulation routines (included manually for 9x
// compatibility).
//


//
//  VOID
//  InitializeListHead32(
//      PLIST_ENTRY32 ListHead
//      );
//

#define InitializeListHead32(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = PtrToUlong((ListHead)))

#if !defined(MIDL_PASS) && !defined(SORTPP_PASS)


VOID
FORCEINLINE
InitializeListHead(
    IN PLIST_ENTRY ListHead
    )
{
    ListHead->Flink = ListHead->Blink = ListHead;
}

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))



BOOLEAN
FORCEINLINE
RemoveEntryList(
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Flink;

    Flink = Entry->Flink;
    Blink = Entry->Blink;
    Blink->Flink = Flink;
    Flink->Blink = Blink;
    return (BOOLEAN)(Flink == Blink);
}

PLIST_ENTRY
FORCEINLINE
RemoveHeadList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Flink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Flink;
    Flink = Entry->Flink;
    ListHead->Flink = Flink;
    Flink->Blink = ListHead;
    return Entry;
}



PLIST_ENTRY
FORCEINLINE
RemoveTailList(
    IN PLIST_ENTRY ListHead
    )
{
    PLIST_ENTRY Blink;
    PLIST_ENTRY Entry;

    Entry = ListHead->Blink;
    Blink = Entry->Blink;
    ListHead->Blink = Blink;
    Blink->Flink = ListHead;
    return Entry;
}


VOID
FORCEINLINE
InsertTailList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Blink;

    Blink = ListHead->Blink;
    Entry->Flink = ListHead;
    Entry->Blink = Blink;
    Blink->Flink = Entry;
    ListHead->Blink = Entry;
}


VOID
FORCEINLINE
InsertHeadList(
    IN PLIST_ENTRY ListHead,
    IN PLIST_ENTRY Entry
    )
{
    PLIST_ENTRY Flink;

    Flink = ListHead->Flink;
    Entry->Flink = Flink;
    Entry->Blink = ListHead;
    Flink->Blink = Entry;
    ListHead->Flink = Entry;
}


//
//
//  PSINGLE_LIST_ENTRY
//  PopEntryList(
//      PSINGLE_LIST_ENTRY ListHead
//      );
//

#define PopEntryList(ListHead) \
    (ListHead)->Next;\
    {\
        PSINGLE_LIST_ENTRY FirstEntry;\
        FirstEntry = (ListHead)->Next;\
        if (FirstEntry != NULL) {     \
            (ListHead)->Next = FirstEntry->Next;\
        }                             \
    }


//
//  VOID
//  PushEntryList(
//      PSINGLE_LIST_ENTRY ListHead,
//      PSINGLE_LIST_ENTRY Entry
//      );
//

#define PushEntryList(ListHead,Entry) \
    (Entry)->Next = (ListHead)->Next; \
    (ListHead)->Next = (Entry)

#endif // !MIDL_PASS

//
// End of list manipulation routines.
//

#define REG_FORMAT          L"smclient_%X_%X"    
                            // Registry key used to start the client
                            // Sort of: smclient_0xProcId_0xThreadId

#ifdef  OS_WIN16
#define SMCLIENT_INI        "\\smclient.ini"        // Our ini file
#define TCLIENT_INI_SECTION "tclient"               // Our section in ini file
#else
#define SMCLIENT_INI        L"smclient.ini"
#define TCLIENT_INI_SECTION L"tclient"
#endif

#define CHAT_SEPARATOR      L"<->"              // Separates wait<->repsonse 
                                                // in chat sequence
#define WAIT_STR_DELIMITER  '|'                 // Deleimiter in Wait for 
                                                // multiple strings

#define MAX_WAITING_EVENTS  16
#define MAX_STRING_LENGTH   128
#define FEEDBACK_SIZE       32

#define WAITINPUTIDLE           180000  // 3 min

//
// Keyboard-hook setting (see newclient\inc\autreg.h).
//

#define TCLIENT_KEYBOARD_HOOK_NEVER         0
#define TCLIENT_KEYBOARD_HOOK_ALWAYS        1
#define TCLIENT_KEYBOARD_HOOK_FULLSCREEN    2

#ifdef  _RCLX
typedef struct _RCLXDATACHAIN {
    UINT    uiOffset;
    struct  _RCLXDATACHAIN *pNext;
    RCLXDATA RClxData;
} RCLXDATACHAIN, *PRCLXDATACHAIN;
#endif  // _RCLX

typedef struct _CONNECTINFO {                   // Connection context
    HWND    hClient;                            // Main HWND of the client
                                                // or in RCLX mode
                                                // context structure
    HWND    hContainer;                         // Client's child windows
    HWND    hInput;
    HWND    hOutput;
    HANDLE  hProcess;                           // Client's process handle
    LONG_PTR lProcessId;                        // Client's process Id
                                                // or in RCLX mode, socket
    HANDLE  hThread;                            // Clients first thread
    DWORD   dwThreadId;                         // --"--
                                                // In RCLX mode this contains
                                                // our ThreadID
    DWORD   OwnerThreadId;                      // thread id of the owner of
                                                // this structure
    BOOL    dead;                               // TRUE if the client is dead
    BOOL    bConnectionFailed;
    UINT    xRes;                               // client's resolution
    UINT    yRes;

#ifdef  _RCLX
    BOOL    RClxMode;                           // TRUE if this thread is
                                                // in RCLX mode
                                                // the client is on remote
                                                // machine
#endif  // _RCLX
    HANDLE  evWait4Str;                         // "Wait for something"
                                                // event handle
    HANDLE  aevChatSeq[MAX_WAITING_EVENTS];     // Event on chat sequences
    INT     nChatNum;                           // Number of chat sequences
    WCHAR   Feedback[FEEDBACK_SIZE][MAX_STRING_LENGTH]; 
                                                // Feedback buffer
    INT     nFBsize, nFBend;                    // Pointer within feedback 
                                                // buffer
    CHAR    szDiscReason[MAX_STRING_LENGTH*2];  // Explains disconnect reason
    CHAR    szWait4MultipleStrResult[MAX_STRING_LENGTH];    
                                                // Result of 
                                                // Wait4MultipleStr:string
    INT     nWait4MultipleStrResult;            // Result of 
                                                // Wait4MultipleStr:ID[0-n]
#ifdef  _RCLX
    HGLOBAL ghClipboard;                        // handle to received clipboard
    UINT    uiClipboardFormat;                  // received clipboard format
    UINT    nClipboardSize;                     // recevied clipboard size
    BOOL    bRClxClipboardReceived;             // Flag the clipbrd is received
    CHAR    szClientType[MAX_STRING_LENGTH];    // in RCLX mode identifys the 
#endif  // _RCLX
                                                // client machine and platform
    UINT    uiSessionId;
#ifdef  _RCLX
    BOOL    bWillCallAgain;                     // TRUE if FEED_WILLCALLAGAIN
                                                // is received in RCLX mode
    PRCLXDATACHAIN pRClxDataChain;              // data receved from RCLX
    PRCLXDATACHAIN pRClxLastDataChain;          // BITMAPs, Virtual Channels
#endif  // _RCLX

    BOOL    bConsole;                           // TRUE if resolution is -1,-1
                                                // or TSFLAG_CONSOLE is spec
    PVOID   pCIConsole;                         // extensions context
    HANDLE  hConsoleExtension;                  // extens. lib handle
    struct  _CONFIGINFO *pConfigInfo;
    struct  _CONNECTINFO *pNext;                // Next structure in the queue
} CONNECTINFO, *PCONNECTINFO;

typedef enum {
    WAIT_STRING,        // Wait for unicode string from the client
    WAIT_DISC,          // Wait for disconnected event
    WAIT_CONN,          // Wait for conneted event
    WAIT_MSTRINGS,      // Wait for multiple strings
    WAIT_CLIPBOARD,     // Wait for clipboard data
    WAIT_DATA           // Wait for data block (RCLX mode responces)
}   WAITTYPE; 
                                                // Different event types
                                                // on which we wait

typedef struct _WAIT4STRING {
    HANDLE          evWait;                     // Wait for event
    PCONNECTINFO    pOwner;                     // Context of the owner
    LONG_PTR        lProcessId;                // Clients ID
    WAITTYPE        WaitType;                   // Event type
    DWORD_PTR       strsize;                    // String length (WAIT_STRING, 
                                                // WAIT_MSTRING)
    WCHAR           waitstr[MAX_STRING_LENGTH]; // String we are waiting for
    DWORD_PTR       respsize;                   // Length of responf
    WCHAR           respstr[MAX_STRING_LENGTH]; // Respond string 
                                                // (in chat sequences)
    struct _WAIT4STRING *pNext;                 // Next in the queue
} WAIT4STRING, *PWAIT4STRING;

typedef struct _CONFIGINFO {

    UINT WAIT4STR_TIMEOUT;             // default is 10 min,
                                       // some events are waited
                                       // 1/4 of that time
                                       // This value can be changed from
                                       // smclient.ini [tclient]
                                       // timeout=XXX seconds
    UINT CONNECT_TIMEOUT;              // Default is 35 seconds
                                       // This value can be changed from
                                       // smclient.ini [tclient]
                                       // contimeout=XXX seconds
    WCHAR    strStartRun[MAX_STRING_LENGTH];
    WCHAR    strStartRun_Act[MAX_STRING_LENGTH];
    WCHAR    strRunBox[MAX_STRING_LENGTH];
    WCHAR    strWinlogon[MAX_STRING_LENGTH];
    WCHAR    strWinlogon_Act[MAX_STRING_LENGTH];
    WCHAR    strPriorWinlogon[MAX_STRING_LENGTH];
    WCHAR    strPriorWinlogon_Act[MAX_STRING_LENGTH];
    WCHAR    strNoSmartcard[MAX_STRING_LENGTH];
    WCHAR    strSmartcard[MAX_STRING_LENGTH];
    WCHAR    strSmartcard_Act[MAX_STRING_LENGTH];
    WCHAR    strNTSecurity[MAX_STRING_LENGTH];
    WCHAR    strNTSecurity_Act[MAX_STRING_LENGTH];
    WCHAR    strSureLogoff[MAX_STRING_LENGTH];
    WCHAR    strStartLogoff[MAX_STRING_LENGTH];
    WCHAR    strSureLogoffAct[MAX_STRING_LENGTH];
    WCHAR    strLogonErrorMessage[MAX_STRING_LENGTH];
    WCHAR    strLogonDisabled[MAX_STRING_LENGTH];
    WCHAR    strLogonFmt[MAX_STRING_LENGTH];        // logon string
    WCHAR    strSessionListDlg[MAX_STRING_LENGTH];

    WCHAR    strClientCaption[MAX_STRING_LENGTH];
    WCHAR    strDisconnectDialogBox[MAX_STRING_LENGTH];
    WCHAR    strYesNoShutdown[MAX_STRING_LENGTH];
    WCHAR    strClientImg[MAX_STRING_LENGTH];
    WCHAR    strDebugger[MAX_STRING_LENGTH];
    WCHAR    strMainWindowClass[MAX_STRING_LENGTH];
    WCHAR    strCmdLineFmt[4 * MAX_STRING_LENGTH];
    WCHAR    strConsoleExtension[MAX_STRING_LENGTH];

    INT      ConnectionFlags;
    INT      Autologon;
    INT      UseRegistry;
    INT      LoginWait;
    INT      bTranslateStrings;
    BOOL     bUnicode;
    INT      KeyboardHook;
} CONFIGINFO, *PCONFIGINFO;

//
// Allocation-list structure.
//

typedef struct _ALLOCATION {
    LIST_ENTRY AllocationListEntry;
    PVOID Address;
} ALLOCATION, *PALLOCATION;

VOID _FillConfigInfo(PCONFIGINFO pConfigInfo); // LPSTR szData);

VOID LoadSmClientFile(WCHAR *szIniFileName, DWORD dwIniFileNameLen, LPSTR szLang);

#ifdef __cplusplus
}
#endif

#endif /* _TCLIENT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\apihandl.h ===
//
// apihandl.h
//
// Defines the internal structure used to hold
// information regarding a TCLIENT connection.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#ifndef INC_APIHANDL_H
#define INC_APIHANDL_H

#include <windows.h>
#include <crtdbg.h>
#include <protocol.h>
#include <extraexp.h>

typedef void *CONNECTION;


// Handle data type
typedef struct
{
    CONNECTION SCConnection;
    DWORD BuildNumber;
    CHAR WaitStr[MAX_PATH];
    BOOL IsAltDown;
    BOOL IsShiftDown;
    BOOL IsCtrlDown;
    LPARAM lParam;
    DWORD DelayPerChar;
    DWORD WordsPerMinute;
    HANDLE PauseEvent;
    DWORD Latency;
} TSAPIHANDLE;


// These macros allow to easily switch between
// the TCLIENT SCConnection handle and a TCLIENT2
// Connection handle.

// TCLIENT2 -> TCLIENT
#define SCCONN(TSHandle)    (((TSAPIHANDLE *)TSHandle)->SCConnection)

// TCLIENT -> TCLIENT2
#define TSHNDL(SCConn)      ((HANDLE)(&SCConn))


TSAPIHANDLE *T2CreateHandle(void);
void T2DestroyHandle(HANDLE Connection);
void T2WaitForPauseInput(HANDLE Connection);
void T2WaitForLatency(HANDLE Connection);


#endif // INC_APIHANDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\tclientaxobj.h ===
/*++
 *  File name:
 *      tclientaxobj.h
 *  Contents:
 *      This module contains the header for the CTClientApi class.
 *
 *      Copyright (C) 2002 Microsoft Corp.
 --*/

#include "resource.h"
#include <atlctl.h>

#include "gdata.h"

//
// VOID
// SaveError (
//     IN PCSTR Error,
//     IN DWORD TlsIndex,
//     OUT HRESULT *Result
//     );
//

#define SaveError(Error, TlsIndex, Result)                                  \
{                                                                           \
                                                                            \
    /*                                                                      \
     * Set the result code. The presence of an error string indicates       \
     * failure.                                                             \
     */                                                                     \
                                                                            \
    *(Result) = (Error) == NULL ? S_OK : E_FAIL;                            \
                                                                            \
    /*                                                                      \
     * Update the current thread's error string. If a TLS index could not   \
     * be allocated for the current instance, error strings cannot be used. \
     */                                                                     \
                                                                            \
    if ((TlsIndex) != TLS_OUT_OF_INDEXES)                                   \
    {                                                                       \
                                                                            \
        /*                                                                  \
         / If a TLS index was allocated, setting the value should not fail. \
         */                                                                 \
                                                                            \
        if (!RTL_VERIFY(TlsSetValue((TlsIndex), (PVOID)(Error))))           \
        {                                                                   \
            *(Result) = HRESULT_FROM_WIN32(GetLastError());                 \
        }                                                                   \
    }                                                                       \
}                                                                           \

//
// CTClientApi class.
//

class CTClientApi :
    public CComObjectRoot,
    public CComCoClass<CTClientApi, &CLSID_CTClient>,
    public CComControl<CTClientApi>,
    public IDispatchImpl<ITClientApi, &IID_ITClientApi, &LIBID_TCLIENTAXLib>,
    public IPersistStreamInitImpl<CTClientApi>,
    public IPersistStorageImpl<CTClientApi>,
    public IOleControlImpl<CTClientApi>,
    public IOleObjectImpl<CTClientApi>,
    public IOleInPlaceActiveObjectImpl<CTClientApi>,
    public IOleInPlaceObjectWindowlessImpl<CTClientApi>,
    public IViewObjectExImpl<CTClientApi> //,
//    public IObjectSafetyImpl<CTClientApi, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:
    CTClientApi(
        ) :
        m_pCI(NULL)
    {

        //
        // Allocate the index for per-thread errors. If the allocation
        // fails, error strings will not be available.
        //

        m_dwErrorIndex = TlsAlloc();

        //
        // Initialize the allocation lists.
        //

#if 0

        InitializeListHead(&m_HeapAllocations);
        InitializeListHead(&m_SysStringAllocations);
        InitializeListHead(&m_TClientAllocations);

#endif

        //
        // Initialize the global printing routine. It would be preferable to
        // set it only if it is currently empty, but Windows 95 compatibility
        // is required, and therefore InterlockedCompareExchange would have
        // to be dynamically loaded with LoadLibrary.
        //

        InterlockedExchangePointer((PVOID *)&g_pfnPrintMessage,
                                   CTClientApi::PrintMessage);
    }
    ~CTClientApi(
        )
    {

#if 0

        PLIST_ENTRY pNextEntry;
        PALLOCATION pAllocation;

#endif

        //
        // If a connection exists, disconnect it.
        //

        if (m_pCI != NULL)
        {
            RTL_VERIFY(SCDisconnect(m_pCI) == NULL);
            m_pCI = NULL;
        }

        //
        // TODO: The lists aren't used at present, but if they are going to
        // be used, an access count and rundown flag should be used to
        // protect the following code.
        //

#if 0

        //
        // Free any heap allocations.
        //

        while (!IsListEmpty(&m_HeapAllocations))
        {

            //
            // Remove the entry from the list, free the allocated memory,
            // then free the allocation structure.
            //

            pNextEntry = RemoveHeadList(&m_HeapAllocations);
            ASSERT(pNextEntry != NULL);
            pAllocation = CONTAINING_RECORD(pNextEntry,
                                            ALLOCATION,
                                            AllocationListEntry);
            ASSERT(pAllocation != NULL && pAllocation->Address != NULL);
            RTL_VERIFY(HeapFree(GetProcessHeap(), 0, pAllocation->Address));
            RTL_VERIFY(HeapFree(GetProcessHeap(), 0, pAllocation));
        }

        //
        // Free any COM strings that will not be freed by the caller.
        //

        while (!IsListEmpty(&m_SysStringAllocations))
        {

            //
            // Remove the entry from the list, free the allocated memory,
            // then free the allocation structure.
            //

            pNextEntry = RemoveHeadList(&m_SysStringAllocations);
            ASSERT(pNextEntry != NULL);
            pAllocation = CONTAINING_RECORD(pNextEntry,
                                            ALLOCATION,
                                            AllocationListEntry);
            ASSERT(pAllocation != NULL && pAllocation->Address != NULL);
            SysFreeString((BSTR)pAllocation->Address);
            RTL_VERIFY(HeapFree(GetProcessHeap(), 0, pAllocation));
        }

        //
        // Free any TClient-allocated memory.
        //

        while (!IsListEmpty(&m_TClientAllocations))
        {

            //
            // Remove the entry from the list, free the allocated memory,
            // then free the allocation structure.
            //

            pNextEntry = RemoveHeadList(&m_TClientAllocations);
            ASSERT(pNextEntry != NULL);
            pAllocation = CONTAINING_RECORD(pNextEntry,
                                            ALLOCATION,
                                            AllocationListEntry);
            ASSERT(pAllocation != NULL && pAllocation->Address != NULL);
            SCFreeMem(pAllocation->Address);
            RTL_VERIFY(HeapFree(GetProcessHeap(), 0, pAllocation));
        }

#endif

        //
        // If an error index was allocated, free it.
        //

        if (m_dwErrorIndex != TLS_OUT_OF_INDEXES)
        {
            RTL_VERIFY(TlsFree(m_dwErrorIndex));
        }
    }

    //
    // Define message map which may be enabled later, if GUI support is added
    // (e.g. for logging).
    //

#if 0

BEGIN_MSG_MAP(CTClientApi)
    MESSAGE_HANDLER(WM_PAINT, OnPaint)
    MESSAGE_HANDLER(WM_CREATE, OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
    MESSAGE_HANDLER(WM_LBUTTONDOWN, OnLButtonDown)
    MESSAGE_HANDLER(WM_LBUTTONUP, OnLButtonUp)
    MESSAGE_HANDLER(WM_MOUSEMOVE, OnMouseMove)
    MESSAGE_HANDLER(WM_TIMER, OnTimer)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBackground)
END_MSG_MAP()

#endif // 0

    //
    // Define COM map.
    //

BEGIN_COM_MAP(CTClientApi)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ITClientApi)
//    COM_INTERFACE_ENTRY(IObjectSafety)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IViewObject2, IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL(IViewObjectEx)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL_IID(IID_IOleInPlaceObject, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY_IMPL(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY_IMPL(IOleControl)
    COM_INTERFACE_ENTRY_IMPL(IOleObject)
    COM_INTERFACE_ENTRY_IMPL(IPersistStorage)
    COM_INTERFACE_ENTRY_IMPL(IPersistStreamInit)
END_COM_MAP()

    //
    // Define connection-point map.
    //

BEGIN_CONNECTION_POINT_MAP(CTClientApi)
END_CONNECTION_POINT_MAP()

    //
    // Define property map.
    //

BEGIN_PROP_MAP(CTClientApi)
END_PROPERTY_MAP()

    //
    // COM declarations.
    //

//DECLARE_NOT_AGGREGATABLE(CTClientApi)
DECLARE_GET_CONTROLLING_UNKNOWN()
//DECLARE_CONTROL_INFO(CLSID_CTClient)
DECLARE_REGISTRY_RESOURCEID(IDR_TClient)

protected:

    //
    // Define connection information and error index.
    //

    PCONNECTINFO m_pCI;
    DWORD m_dwErrorIndex;

    //
    // The following lists are used to track allocations from the process and
    // CRT heaps. The SysXxxString routines use the CRT heap, which is also
    // used for the TClient allocations. General allocations use the process
    // heap.
    //
    // Note: These lists are not currently used.
    //

#if 0

    LIST_ENTRY m_HeapAllocations;
    LIST_ENTRY m_SysStringAllocations;
    LIST_ENTRY m_TClientAllocations;

#endif

//
// ITClientApi interface.
//

public:

    //
    // Declare message handlers which may be enabled later.
    //

#if 0

    HRESULT
    OnDraw (
        ATL_DRAWINFO& di
        );

    LRESULT
    OnCreate (
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL& bHandled
        );

    LRESULT
    OnDestroy (
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL& bHandled
        );

    LRESULT
    OnLButtonDown (
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL& bHandled
        );

    LRESULT
    OnLButtonUp (
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL& bHandled
        );

    LRESULT
    OnMouseMove (
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL& bHandled
        );

    LRESULT
    OnSize (
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL& bHandled
        )
    {
        UNREFERENCED_PARAMETER(uMsg);
        UNREFERENCED_PARAMETER(wParam);
        UNREFERENCED_PARAMETER(lParam);
        UNREFERENCED_PARAMETER(bHandled);
        return 0;
    }

    LRESULT
    OnEraseBackground (
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL& bHandled
        )
    {
        UNREFERENCED_PARAMETER(uMsg);
        UNREFERENCED_PARAMETER(wParam);
        UNREFERENCED_PARAMETER(lParam);
        UNREFERENCED_PARAMETER(bHandled);
        return 0;
    }

    LRESULT
    OnTimer (
        UINT uMsg,
        WPARAM wParam,
        LPARAM lParam,
        BOOL& bHandled
        )
    {
        UNREFERENCED_PARAMETER(uMsg);
        UNREFERENCED_PARAMETER(wParam);
        UNREFERENCED_PARAMETER(lParam);
        UNREFERENCED_PARAMETER(bHandled);
        return 0;
    }

#endif // 0

    STDMETHODIMP
    get_Error (
        OUT BSTR *Message
        )
    {

        PSTR szError;
        BSTR bstrError;
        HRESULT hrResult;

        USES_CONVERSION;
        ATLTRACE(_T("ITClientApi::get_Error\n"));

        //
        // Get the current thread's error string. If a TLS index could not be
        // allocated, an error string cannot be returned.
        //

        if (m_dwErrorIndex != TLS_OUT_OF_INDEXES)
        {
            szError = (PSTR)TlsGetValue(m_dwErrorIndex);
        }
        else
        {
            szError = NULL;
        }

        //
        // If the error string is NULL or empty, use NULL.
        //

        if (szError == NULL || *szError == '\0')
        {
            bstrError = NULL;
        }

        //
        // Convert the current error string to a BSTR. This will allocate
        // from the CRT heap, and the storage must be freed by the caller,
        // using SysFreeString.
        //

        else
        {
            bstrError = A2BSTR(szError);
            if (bstrError == NULL)
            {
                return E_OUTOFMEMORY;
            }
        }

        //
        // Copy the address of the error string to the message pointer.
        //

        hrResult = E_FAIL;
        _try
        {
            _try
            {
                *Message = bstrError;
                hrResult = S_OK;
            }

            //
            // If the message pointer is invalid, set an appropriate return
            // value.
            //

            _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                     EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
            {
                hrResult = E_POINTER;
            }
        }

        //
        // If the message pointer could not be set, the BSTR will not be
        // returned, so free it.
        //

        _finally
        {
            if (FAILED(hrResult))
            {
                ASSERT(bstrError != NULL);
                SysFreeString(bstrError);
            }
        }

        return hrResult;
    }
 
    STDMETHODIMP
    SaveClipboard (
        IN BSTR FormatName,
        IN BSTR FileName
        );

    STDMETHODIMP
    IsDead (
        OUT BOOL *Dead
        );

    STDMETHODIMP
    SendTextAsMessages (
        IN BSTR Text
        );

    STDMETHODIMP
    Connect2 (
        IN BSTR ServerName,
        IN BSTR UserName,
        IN BSTR Password,
        IN BSTR Domain,
        IN BSTR Shell,
        IN ULONG XResolution,
        IN ULONG YResolution,
        IN ULONG ConnectionFlags,
        IN ULONG ColorDepth,
        IN ULONG AudioOptions
        );

    STDMETHODIMP
    GetFeedbackString (
        OUT BSTR *FeedbackString
        );

    STDMETHODIMP
    GetFeedback (
        OUT SAFEARRAY **Feedback
        );

    STDMETHODIMP
    ClientTerminate (
        VOID
        );

    STDMETHODIMP
    Check (
        IN BSTR Command,
        IN BSTR Parameter
        );

    STDMETHODIMP
    Clipboard (
        IN ULONG Command,
        IN BSTR FileName
        );

    STDMETHODIMP
    Connect (
        IN BSTR ServerName,
        IN BSTR UserName,
        IN BSTR Password,
        IN BSTR Domain,
        IN ULONG XResolution,
        IN ULONG YResolution
        );

    STDMETHODIMP
    Disconnect (
        VOID
        );

    STDMETHODIMP
    Logoff (
        VOID
        );

    STDMETHODIMP
    SendData (
        IN UINT Message,
        IN UINT_PTR WParameter,
        IN LONG_PTR LParameter
        );

    STDMETHODIMP
    Start (
        IN BSTR AppName
        );

    STDMETHODIMP
    SwitchToProcess (
        IN BSTR WindowTitle
        );

    STDMETHODIMP
    SendMouseClick (
        IN ULONG XPosition,
        IN ULONG YPosition
        );

    STDMETHODIMP
    GetSessionId (
        OUT ULONG *SessionId
        );

    STDMETHODIMP
    CloseClipboard (
        VOID
        );

    STDMETHODIMP
    OpenClipboard (
        IN HWND Window
        );

    STDMETHODIMP
    SetClientTopmost (
        IN BOOL Enable
        );

    STDMETHODIMP
    Attach (
        IN HWND Window,
        IN LONG_PTR Cookie
        );

    STDMETHODIMP
    Detach (
        VOID
        );

    STDMETHODIMP
    GetIni (
        OUT ITClientIni **Ini
        );

    STDMETHODIMP
    GetClientWindowHandle (
        OUT HWND *Window
        );

    //
    // Utility routines.
    //

    static
    VOID
    CTClientApi::PrintMessage (
        MESSAGETYPE MessageType,
        LPCSTR Format,
        ...
        );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\apihandl.c ===
//
// apihandl.c
//
// This file contains functions used for handle allocation
// and handle state control (the Pause state) on the
// TCLIENT2 connection handle.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#include "apihandl.h"
#include "connlist.h"


// T2CreateHandle
//
// Create an internal handle, it does this simply by allocating
// the memory, having it zero'd, and adding it to the linked list.
// It also creates the "Pause" event for the handle, so it can
// be used for pausing the handle.
//
// Returns a pointer to the new handle if successful.  Otherwise,
// NULL is returned.

TSAPIHANDLE *T2CreateHandle(void)
{
    // Allocate
    TSAPIHANDLE *Handle = HeapAlloc(GetProcessHeap(),
        HEAP_ZERO_MEMORY, sizeof (TSAPIHANDLE));
    if (Handle == NULL)
        return NULL;

    // Initialize the pause event
    Handle->PauseEvent = CreateEvent(NULL, TRUE, TRUE, NULL);

    // Add it to the linked list
    if (T2ConnList_AddHandle((HANDLE)Handle, 0, 0) == FALSE)
    {
        HeapFree(GetProcessHeap(), 0, Handle);
        return NULL;
    }
    return Handle;
}


// T2DestroyHandle
//
// It does this by first removing it from the global linked list.
// Then it Closes the "Pause" event, and frees the memory object.
// Finally, if a timer was associated with it for idle-callback,
// it is halted.
//
// No return value.

void T2DestroyHandle(HANDLE Connection)
{
    UINT_PTR TimerId = 0;

    // Remove from the linked list
    T2ConnList_GetData(Connection, &TimerId, NULL);
    T2ConnList_RemoveHandle(Connection);

    // Enter the exception clause, we are again in a freaky place.
    __try {

        // Kill the pause event
        CloseHandle(((TSAPIHANDLE *)Connection)->PauseEvent);

        // Deallocate
        HeapFree(GetProcessHeap(), 0, Connection);
        if (TimerId != -1 && TimerId != 0)
            KillTimer(NULL, TimerId);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        // No failure indication, if we got here the handle is hosed or
        // non-existant anyway.
        _ASSERT(FALSE);

        return;
    }
}


// T2WaitForPauseInput
//
// This function only returns when the "Pause" event is in signaled mode.
// Therefore, to pause a handle, set its handle to non-signaled.
//
// No return value.

void T2WaitForPauseInput(HANDLE Connection)
{
    // Use exception handling because the handle may be invalid
    __try
    {
        WaitForSingleObject(((TSAPIHANDLE *)Connection)->PauseEvent,
                INFINITE);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _ASSERT(FALSE);

        return;
    }
}


// T2WaitForLatency
//
// This function simply waits for the handles latency before returning.
//
// No return value.

void T2WaitForLatency(HANDLE Connection)
{
    // Use exception handling because the handle may be invalid
    __try
    {
        Sleep(((TSAPIHANDLE *)Connection)->Latency);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        _ASSERT(FALSE);

        return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\tclientaxobj.cpp ===
/*++
 *  File name:
 *      tclientaxobj.cpp
 *  Contents:
 *      This module implements a scriptable COM interface to the TClient
 *      APIs.
 *
 *      Copyright (C) 2002 Microsoft Corp.
 --*/

#include "stdafx.h"

#define PROTOCOLAPI

#include <malloc.h>
#include <stdio.h>
#include "tclient.h"
#include <protocol.h>
#include <extraexp.h>
#include "tclientax.h"
#include "tclientaxobj.h"

#define LOG_BUFFER_SIZE 2048
#define LOG_PREFIX "TClientApi: "

//
// Define Boolean values for Visual Basic.
//

#define VB_TRUE ((BOOL)-1)
#define VB_FALSE ((BOOL)0)

//
// Define stubs for certain message handlers which may be enabled later, if
// GUI support is added (e.g. for logging).
//

#if 0

/*++
 *  Function:
 *      CTClientApi::
 *  Description:
 *      This routine...
 *  Arguments:
 *      ... - ...
 *  Return value:
 *      ...
 *  Called by:
 *      ...
 *  Author:
 *      ...
 --*/
LRESULT
CTClientApi::OnCreate (
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& bHandled
    )
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);
    return 0;
}

/*++
 *  Function:
 *      CTClientApi::
 *  Description:
 *      This routine...
 *  Arguments:
 *      ... - ...
 *  Return value:
 *      ...
 *  Called by:
 *      ...
 *  Author:
 *      ...
 --*/
LRESULT
CTClientApi::OnDestroy (
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& bHandled
    )
{
    UNREFERENCED_PARAMETER(bHandled);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(uMsg);
    return 0;
}

/*++
 *  Function:
 *      CTClientApi::
 *  Description:
 *      This routine...
 *  Arguments:
 *      ... - ...
 *  Return value:
 *      ...
 *  Called by:
 *      ...
 *  Author:
 *      ...
 --*/
LRESULT
CTClientApi::OnLButtonDown (
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& bHandled
    )
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);
    return 0;
}

/*++
 *  Function:
 *      CTClientApi::
 *  Description:
 *      This routine...
 *  Arguments:
 *      ... - ...
 *  Return value:
 *      ...
 *  Called by:
 *      ...
 *  Author:
 *      ...
 --*/
LRESULT
CTClientApi::OnLButtonUp (
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& bHandled
    )
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);
    return 0;
}

/*++
 *  Function:
 *      CTClientApi::
 *  Description:
 *      This routine...
 *  Arguments:
 *      ... - ...
 *  Return value:
 *      ...
 *  Called by:
 *      ...
 *  Author:
 *      ...
 --*/
LRESULT
CTClientApi::OnMouseMove (
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    BOOL& bHandled
    )
{
    UNREFERENCED_PARAMETER(uMsg);
    UNREFERENCED_PARAMETER(wParam);
    UNREFERENCED_PARAMETER(lParam);
    UNREFERENCED_PARAMETER(bHandled);
    return 0;
}

/*++
 *  Function:
 *      CTClientApi::
 *  Description:
 *      This routine...
 *  Arguments:
 *      ... - ...
 *  Return value:
 *      ...
 *  Called by:
 *      ...
 *  Author:
 *      ...
 --*/
HRESULT
CTClientApi::OnDraw(
    ATL_DRAWINFO& di
    )
{
    UNREFERENCED_PARAMETER(di);
    return S_OK;
}

#endif // 0

//
// Define scriptable interfaces to TClient APIs.
//
// In the initial version, the COM interfaces will not do any argument
// validation, since they merely wrap the APIs, which must also validate.
// This is equally true for synchronization of threads, therefore the COM
// interfaces will not add any additional synchronisation code, with the
// exception of the Error property.
//

/*++
 *  Function:
 *      CTClientApi::SaveClipboard
 *  Description:
 *      This routine provides a scriptable interface to SCSaveClipboard.
 *  Arguments:
 *      FormatName - Supplies the name of the clipboard format to use.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::SaveClipboard (
    IN BSTR FormatName,
    IN BSTR FileName
    )
{

    PCSTR szFormatName;
    PCSTR szFileName;
    PCSTR szError;
    HRESULT hrResult;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::SaveClipboard\n"));

    //
    // Convert the OLE strings to ANSI strings for TClient. This will
    // allocate on the stack.
    //

    _try
    {
        szFormatName = OLE2A(FormatName);
        szFileName = OLE2A(FileName);
    }
    _except ((GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ||
              GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        switch (GetExceptionCode())
        {
        case EXCEPTION_STACK_OVERFLOW:
            _resetstkoflw();
            return HRESULT_FROM_WIN32(ERROR_STACK_OVERFLOW);
            break;
        case EXCEPTION_ACCESS_VIOLATION:
            return E_POINTER;
            break;
        default:
            DebugBreak();
            return E_FAIL;
            break;
        }
    }

    //
    // Call the API and return the result.
    //

    ASSERT(m_pCI != NULL);
    ASSERT(szFormatName != NULL);
    ASSERT(szFileName != NULL);
    szError = SCSaveClipboard(m_pCI, szFormatName, szFileName);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::IsDead
 *  Description:
 *      This routine provides a scriptable interface to SCIsDead.
 *  Arguments:
 *      Dead - Returns the current state of the client: TRUE if it is dead,
 *          FALSE otherwise.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::IsDead (
    OUT BOOL *Dead
    )
{

    BOOL fDead;

    ATLTRACE(_T("ITClientApi::IsDead\n"));

    //
    // Check to see if the connection is dead, and return the result.
    //

    RTL_SOFT_ASSERT(m_pCI != NULL);
    fDead = SCIsDead(m_pCI);

    _try
    {
        *Dead = fDead ? VB_TRUE : VB_FALSE;
    }
    _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return E_POINTER;
    }

    return S_OK;
}

/*++
 *  Function:
 *      CTClientApi::SendTextAsMessages
 *  Description:
 *      This routine provides a scriptable interface to SCSendtextAsMsgs.
 *  Arguments:
 *      Text - Supplies a text string to send to the client.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::SendTextAsMessages (
    IN BSTR Text
    )
{

    PCWSTR szText;
    PCSTR szError;
    HRESULT hrResult;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::SendTextAsMessages\n"));

    //
    // Convert the OLE string to a Unicode string for TClient. OLE strings
    // are already Unicode, so this will not allocate any storage.
    //

    _try
    {
        szText = OLE2W(Text);
    }
    _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return E_POINTER;
    }

    //
    // Call the API and return the result.
    //

    ASSERT(m_pCI != NULL);
    ASSERT(szText != NULL);
    szError = SCSendtextAsMsgs(m_pCI, szText);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::Connect2
 *  Description:
 *      This routine provides a scriptable interface to SCConnectEx.
 *  Arguments:
 *      ServerName - Supplies the name of the server to connect to.
 *      UserName - Supples the name of the user to log on with.
 *      Password - Supplied the user password.
 *      Domain - Supples the domain to which the user belongs.
 *      Shell - Supplies the name of the executable with which the shell
 *          process will be created.
 *      XResolution - Supplies the horizontal resolution to use for the
 *          session.
 *      YResolution - Supplies the vertical resolution to use for the
 *          session.
 *      ConnectionFlags Supplies the connection flags.
 *      ColorDepth - Supplies the color depth to use for the session.
 *      AudioOptions - Supplies the audio options.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::Connect2 (
    IN BSTR ServerName,
    IN BSTR UserName,
    IN BSTR Password,
    IN BSTR Domain,
    IN BSTR Shell,
    IN ULONG XResolution,
    IN ULONG YResolution,
    IN ULONG ConnectionFlags,
    IN ULONG ColorDepth,
    IN ULONG AudioOptions
    )
{

    PCWSTR szServerName;
    PCWSTR szUserName;
    PCWSTR szPassword;
    PCWSTR szDomain;
    PCWSTR szShell;
    PCSTR szError;
    HRESULT hrResult;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::Connect2\n"));

    //
    // Convert the OLE strings to Unicode strings for TClient. OLE strings
    // are already Unicode, so this will not allocate any storage.
    //

    _try
    {
        szServerName = OLE2W(ServerName);
        szUserName = OLE2W(UserName);
        szPassword = OLE2W(Password);
        szDomain = OLE2W(Domain);
        szShell = OLE2W(Shell);
    }
    _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return E_POINTER;
    }

    //
    // Call the API and return the result.
    //

    ASSERT(m_pCI == NULL);
    RTL_SOFT_ASSERT(szServerName != NULL);
    RTL_SOFT_ASSERT(szUserName != NULL);
    RTL_SOFT_ASSERT(szPassword != NULL);
    RTL_SOFT_ASSERT(szDomain != NULL);
    RTL_SOFT_ASSERT(szShell != NULL);
    szError = SCConnectEx(szServerName,
                          szUserName,
                          szPassword,
                          szDomain,
                          szShell,
                          XResolution,
                          YResolution,
                          ConnectionFlags,
                          ColorDepth,
                          AudioOptions,
                          &m_pCI);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::GetFeedbackString
 *  Description:
 *      This routine provides a scriptable interface to SCGetFeedbackString.
 *  Arguments:
 *      FeedbackString - Returns the latest feedback string to the caller.
 *          The underlying storage must be freed by the caller with
 *          SysFreeString.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::GetFeedbackString (
    OUT BSTR *FeedbackString
    )
{

    PCSTR szError;
    WCHAR szBuffer[MAX_STRING_LENGTH + 1];
    HRESULT hrResult;
    BSTR bstrFeedback;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::GetFeedbackString\n"));

    //
    // Get the feedback string and add a terminator.
    //

    ASSERT(m_pCI != NULL);
    szError = SCGetFeedbackString(m_pCI,
                                  szBuffer,
                                  sizeof(szBuffer) / sizeof(*szBuffer) - 1);
    szBuffer[sizeof(szBuffer) / sizeof(*szBuffer) - 1] = L'\0';
    SaveError(szError, m_dwErrorIndex, &hrResult);
    if (szError != NULL)
    {
        return hrResult;
    }

    //
    // If the feedback string is empty, use NULL.
    //

    if (*szBuffer == '\0')
    {
        bstrFeedback = NULL;
    }

    //
    // Convert the feedback string to a BSTR. This will allocate from the CRT
    // heap, and the storage must be freed by the caller, using
    // SysFreeString.
    //

    else
    {
        bstrFeedback = W2BSTR(szBuffer);
        if (bstrFeedback == NULL)
        {
            return E_OUTOFMEMORY;
        }
    }

    //
    // Set the output parameter. If the supplied argument is invalid, the
    // BSTR will not be returned, so free it.
    //

    hrResult = E_FAIL;
    _try
    {
        _try
        {
            *FeedbackString = bstrFeedback;
            hrResult = S_OK;
        }
        _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            hrResult = E_POINTER;
        }
    }
    _finally
    {
        if (FAILED(hrResult))
        {
            ASSERT(bstrFeedback != NULL);
            SysFreeString(bstrFeedback);
        }
    }

    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::GetFeedback
 *  Description:
 *      This routine provides a scriptable interface to SCGetFeedback.
 *  Arguments:
 *      FeedbackString - Returns the feedback strings to the caller. The
 *          underlying storage must be freed by the caller with
 *          SafeArrayDestroy.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::GetFeedback (
    OUT SAFEARRAY **Feedback
    )
{

    PCSTR szError;
    PWSTR pStrings;
    UINT nCount;
    UINT nMaxStringLength;
    HRESULT hrResult;
    SAFEARRAY *pArray;
    LONG lIndex;
    BSTR bstrCurrentString;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::GetFeedback\n"));

    //
    // Clear the output argument.
    //

    _try
    {
        *Feedback = NULL;
    }
    _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return E_POINTER;
    }

    //
    // Get the feedback strings.
    //

    ASSERT(m_pCI != NULL);
    szError = SCGetFeedback(m_pCI, &pStrings, &nCount, &nMaxStringLength);
    if (szError != NULL)
    {
        SaveError(szError, m_dwErrorIndex, &hrResult);
        return hrResult;
    }

    //
    // Always free the feedback strings.
    //

    hrResult = E_FAIL;
    pArray = NULL;
    _try
    {

        //
        // Allocate a safe-array of BSTRs, large enough to hold the feedback
        // strings. The storage must be freed by the caller with
        // SafeArrayDestroy.
        //

        ASSERT(nCount > 0);
        pArray = SafeArrayCreateVectorEx(VT_BSTR, 0, nCount, NULL);
        if (pArray == NULL)
        {
            hrResult = HRESULT_FROM_WIN32(GetLastError());
            _leave;
        }

        //
        // Always destroy the safe-array on failure.
        //

        _try
        {

            //
            // Copy each string to the array.
            //

            for (lIndex = 0; lIndex < (LONG)nCount; lIndex += 1)
            {

                //
                // Convert the current string to a BSTR. This will allocate
                // storage on the CRT heap, which must be freed with
                // SysFreeString before the next loop iteration.
                //

                bstrCurrentString = W2BSTR(pStrings + lIndex);
                if (bstrCurrentString == NULL)
                {
                    hrResult = E_OUTOFMEMORY;
                    _leave;
                }
                _try
                {

                    //
                    // Add the current string to the array. This will
                    // allocate storage with SysAllocString and copy the
                    // current string to it. The allocated storage will be
                    // freed when the safe-array is destroyed.
                    //

                    hrResult = SafeArrayPutElement(pArray,
                                                   &lIndex,
                                                   (PVOID)bstrCurrentString);
                }

                //
                // Free the current string.
                //

                _finally
                {
                    ASSERT(bstrCurrentString != NULL);
                    SysFreeString(bstrCurrentString);
                }
            }
            ASSERT(lIndex == (LONG)nCount);
        }

        //
        // If an error occurred, free the array.
        //

        _finally
        {
            if (FAILED(hrResult))
            {
                ASSERT(pArray != NULL);
                RTL_VERIFY(SUCCEEDED(SafeArrayDestroy(pArray)));
            }
        }
    }

    //
    // Free the storage allocated by SCGetFeedback.
    //

    _finally
    {
        ASSERT(pStrings != NULL);
        SCFreeMem((PVOID)pStrings);
    }

    //
    // If the array was successfully allocated and filled in, set the output
    // argument. The caller is responsible for freeing the underlying
    // storage.
    //

    if (SUCCEEDED(hrResult))
    {
        ASSERT(pArray != NULL);
        _try
        {
            *Feedback = pArray;
        }
        _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
                 EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
        {
            DebugBreak();
            RTL_VERIFY(SUCCEEDED(SafeArrayDestroy(pArray)));
            return E_POINTER;
        }
    }

    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::ClientTerminate
 *  Description:
 *      This routine provides a scriptable interface to SCClientTerminate.
 *  Arguments:
 *      None.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::ClientTerminate (
    VOID
    )
{

    PCSTR szError;
    HRESULT hrResult;

    ATLTRACE(_T("ITClientApi::ClientTerminate\n"));

    ASSERT(m_pCI != NULL);
    szError = SCClientTerminate(m_pCI);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::Check
 *  Description:
 *      This routine provides a scriptable interface to SCCheck.
 *  Arguments:
 *      Command - Supplies the SmClient Check command to execute.
 *      Parameter - Supplies the argument to the Check command.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::Check (
    IN BSTR Command,
    IN BSTR Parameter
    )
{

    PCSTR szCommand;
    PCWSTR szParameter;
    PCSTR szError;
    HRESULT hrResult;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::Check\n"));

    //
    // Convert the OLE strings to ANSI and Unicode strings for TClient. This
    // will allocate storage for the ANSI string on the stack.
    //

    if ( Command == NULL || Parameter == NULL) {
        return E_INVALIDARG;
    }

    _try
    {
        szCommand = OLE2A(Command);
        szParameter = OLE2W(Parameter);
    }
    _except ((GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ||
              GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        switch (GetExceptionCode())
        {
        case EXCEPTION_STACK_OVERFLOW:
            _resetstkoflw();
            return HRESULT_FROM_WIN32(ERROR_STACK_OVERFLOW);
            break;
        case EXCEPTION_ACCESS_VIOLATION:
            return E_POINTER;
            break;
        default:
            DebugBreak();
            return E_FAIL;
            break;
        }
    }

    //
    // Call the API and return the result.
    //

    ASSERT(m_pCI != NULL);
    szError = SCCheck(m_pCI, szCommand, szParameter);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::Clipboard
 *  Description:
 *      This routine provides a scriptable interface to SCClipboard.
 *  Arguments:
 *      Command - Supplies the clipboard command to execute.
 *      FileName - Supplies the clipboard-data file on which to operate.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::Clipboard (
    IN ULONG Command,
    IN BSTR FileName
    )
{

    CLIPBOARDOPS eCommand;
    PCSTR szFileName;
    PCSTR szError;
    HRESULT hrResult;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::Clipboard\n"));

    //
    // Convert the OLE string to an ANSI string for TClient. This will
    // allocate on the stack.
    //

    _try
    {
        szFileName = OLE2A(FileName);
    }
    _except ((GetExceptionCode() == EXCEPTION_STACK_OVERFLOW ||
              GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION) ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        switch (GetExceptionCode())
        {
        case EXCEPTION_STACK_OVERFLOW:
            _resetstkoflw();
            return HRESULT_FROM_WIN32(ERROR_STACK_OVERFLOW);
            break;
        case EXCEPTION_ACCESS_VIOLATION:
            return E_POINTER;
            break;
        default:
            DebugBreak();
            return E_FAIL;
            break;
        }
    }

    //
    // Convert the command to a clipboard operation.
    //

    switch (Command)
    {
    case COPY_TO_CLIPBOARD:
        eCommand = COPY_TO_CLIPBOARD;
        break;
    case PASTE_FROM_CLIPBOARD:
        eCommand = PASTE_FROM_CLIPBOARD;
        break;
    default:
        return E_INVALIDARG;
        break;
    }

    //
    // Call the API and return the result.
    //

    ASSERT(m_pCI != NULL);
    szError = SCClipboard(m_pCI, eCommand, szFileName);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::Connect
 *  Description:
 *      This routine provides a scriptable interface to SCConnect.
 *  Arguments:
 *      ServerName - Supplies the name of the server to connect to.
 *      UserName - Supples the name of the user to log on with.
 *      Password - Supplied the user password.
 *      Domain - Supples the domain to which the user belongs.
 *      XResolution - Supplies the horizontal resolution to use for the
 *          session.
 *      YResolution - Supplies the vertical resolution to use for the
 *          session.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::Connect (
    IN BSTR ServerName,
    IN BSTR UserName,
    IN BSTR Password,
    IN BSTR Domain,
    IN ULONG XResolution,
    IN ULONG YResolution
    )
{

    PCWSTR szServerName;
    PCWSTR szUserName;
    PCWSTR szPassword;
    PCWSTR szDomain;
    PCSTR szError;
    HRESULT hrResult;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::Connect\n"));

    //
    // Convert the OLE strings to Unicode strings for TClient. OLE strings
    // are already Unicode, so this will not allocate any storage.
    //

    _try
    {
        szServerName = OLE2W(ServerName);
        szUserName = OLE2W(UserName);
        szPassword = OLE2W(Password);
        szDomain = OLE2W(Domain);
    }
    _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return E_POINTER;
    }

    //
    // Call the API and return the result.
    //

    ASSERT(m_pCI == NULL);
    RTL_SOFT_ASSERT(szServerName != NULL);
    RTL_SOFT_ASSERT(szUserName != NULL);
    RTL_SOFT_ASSERT(szPassword != NULL);
    RTL_SOFT_ASSERT(szDomain != NULL);
    szError = SCConnect(szServerName,
                        szUserName,
                        szPassword,
                        szDomain,
                        XResolution,
                        YResolution,
                        (PVOID *)&m_pCI);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::Disconnect
 *  Description:
 *      This routine provides a scriptable interface to SCDisconnect.
 *  Arguments:
 *      None.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::Disconnect (
    VOID
    )
{

    PCSTR szError;
    HRESULT hrResult;

    //
    // Disconnecting frees the storage used for the connection information.
    //

    ATLTRACE(_T("ITClientApi::Disconnect\n"));

    RTL_SOFT_ASSERT(m_pCI != NULL);
    szError = SCDisconnect(m_pCI);
    if (szError == NULL)
    {
        m_pCI = NULL;
    }
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::Logoff
 *  Description:
 *      This routine provides a scriptable interface to SCLogoff.
 *  Arguments:
 *      None.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::Logoff (
    VOID
    )
{

    PCSTR szError;
    HRESULT hrResult;

    //
    // Logging off frees the storage used for the connection information.
    //

    ATLTRACE(_T("ITClientApi::Logoff\n"));

    RTL_SOFT_ASSERT(m_pCI != NULL);
    szError = SCLogoff(m_pCI);
    if (szError == NULL)
    {
        m_pCI = NULL;
    }
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::SendData
 *  Description:
 *      This routine provides a scriptable interface to SCSendData.
 *  Arguments:
 *      Message - Supplies the window message to send.
 *      WParameter - Supplies the message's W parameter.
 *      LParameter - Supplies the message's L parameter.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::SendData (
    IN UINT Message,
    IN UINT_PTR WParameter,
    IN LONG_PTR LParameter
    )
{

    PCSTR szError;
    HRESULT hrResult;

    ATLTRACE(_T("ITClientApi::SendData\n"));

    ASSERT(m_pCI != NULL);
    szError = SCSenddata(m_pCI, Message, WParameter, LParameter);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::Start
 *  Description:
 *      This routine provides a scriptable interface to SCStart.
 *  Arguments:
 *      AppName - Supplies the name of the executable to start.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::Start (
    IN BSTR AppName
    )
{

    PCWSTR szAppName;
    PCSTR szError;
    HRESULT hrResult;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::Start\n"));

    //
    // Convert the OLE string to a Unicode string for TClient. OLE strings
    // are already Unicode, so this will not allocate any storage.
    //

    _try
    {
        szAppName = OLE2W(AppName);
    }
    _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return E_POINTER;
    }

    //
    // Call the API and return the result.
    //

    ASSERT(m_pCI != NULL);
    ASSERT(szAppName != NULL);
    szError = SCStart(m_pCI, szAppName);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::SwitchToProcess
 *  Description:
 *      This routine provides a scriptable interface to SCSwitchToProcess.
 *  Arguments:
 *      WindowTitle - Supplies the title of the top-level window belonging to
 *          the process to which the caller would like to switch.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::SwitchToProcess (
    IN BSTR WindowTitle
    )
{

    PCWSTR szWindowTitle;
    PCSTR szError;
    HRESULT hrResult;

    USES_CONVERSION;
    ATLTRACE(_T("ITClientApi::SwitchToProcess\n"));

    //
    // Convert the OLE string to a Unicode string for TClient. OLE strings
    // are already Unicode, so this will not allocate any storage.
    //

    _try
    {
        szWindowTitle = OLE2W(WindowTitle);
    }
    _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return E_POINTER;
    }

    //
    // Call the API and return the result.
    //

    ASSERT(m_pCI != NULL);
    ASSERT(szWindowTitle != NULL);
    szError = SCSwitchToProcess(m_pCI, szWindowTitle);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::SendMouseClick
 *  Description:
 *      This routine provides a scriptable interface to SCSendMouseClick.
 *  Arguments:
 *      XPosition - Supplies the horizontal position of the mouse click.
 *      YPosition - Supplies the vertical position of the mouse click.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::SendMouseClick (
    IN ULONG XPosition,
    IN ULONG YPosition
    )
{

    PCSTR szError;
    HRESULT hrResult;

    ATLTRACE(_T("ITClientApi::SendMouseClick\n"));

    ASSERT(m_pCI != NULL);
    szError = SCSendMouseClick(m_pCI, XPosition, YPosition);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::GetSessionId
 *  Description:
 *      This routine provides a scriptable interface to SCGetSessionId.
 *  Arguments:
 *      SessionId - Returns the ID of the session associated with the current
 *          RDP client.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::GetSessionId (
    OUT ULONG *SessionId
    )
{

    UINT uiSessionId;

    ATLTRACE(_T("ITClientApi::GetSessionId\n"));

    //
    // Get the session ID and return it.
    //

    ASSERT(m_pCI != NULL);
    uiSessionId = SCGetSessionId(m_pCI);

    _try
    {
        *SessionId = uiSessionId;
    }
    _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return E_POINTER;
    }

    return S_OK;
}

/*++
 *  Function:
 *      CTClientApi::CloseClipboard
 *  Description:
 *      This routine provides a scriptable interface to SCCloseClipboard.
 *  Arguments:
 *      None.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::CloseClipboard (
    VOID
    )
{
    ATLTRACE(_T("ITClientApi::CloseClipboard\n"));
    return SCCloseClipboard() ? S_OK : E_FAIL;
}

/*++
 *  Function:
 *      CTClientApi::OpenClipboard
 *  Description:
 *      This routine provides a scriptable interface to SCOpenClipboard.
 *  Arguments:
 *      Window - Supplies the window with which the clipboard will be
 *          associated.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::OpenClipboard (
    IN HWND Window
    )
{
    ATLTRACE(_T("ITClientApi::OpenClipboard\n"));
    return SCOpenClipboard(Window) ? S_OK : E_FAIL;
}

/*++
 *  Function:
 *      CTClientApi::SetClientTopmost
 *  Description:
 *      This routine provides a scriptable interface to SCSetClientTopmost.
 *  Arguments:
 *      Enable - Supplies a Boolean value indicating whether the top-level
 *          attribute will be set (true) or removed (false).
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::SetClientTopmost (
    IN BOOL Enable
    )
{

    PCWSTR szEnable;
    PCSTR szError;
    HRESULT hrResult;

    ATLTRACE(_T("ITClientApi::SetClientTopmost\n"));

    //
    // Convert the enable value to a Unicode string.
    //

    szEnable = Enable ? L"1" : L"0";

    //
    // Call the API and return the result.
    //

    ASSERT(m_pCI != NULL);
    szError = SCSetClientTopmost(m_pCI, szEnable);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::Attach
 *  Description:
 *      This routine provides a scriptable interface to SCAttach
 *  Arguments:
 *      Window - Supplies a handle identifying the client window to which
 *          TClient will attach.
 *      Cookie - Supplies a cookie with which the client will be identified.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::Attach (
    IN HWND Window,
    IN LONG_PTR Cookie
    )
{

    PCSTR szError;
    HRESULT hrResult;

    ATLTRACE(_T("ITClientApi::Attach\n"));

    //
    // If a client is already attached, detach it. This will free all
    // resources associated with the connection.
    //

    if (m_pCI != NULL)
    {
        szError = SCDetach(m_pCI);
        SaveError(szError, m_dwErrorIndex, &hrResult);
        if (szError != NULL)
        {
            return hrResult;
        }
        m_pCI = NULL;
    }

    szError = SCAttach(Window, Cookie, &m_pCI);
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::Detach
 *  Description:
 *      This routine provides a scriptable interface to SCDetach.
 *  Arguments:
 *      None.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::Detach (
    VOID
    )
{

    PCSTR szError;
    HRESULT hrResult;

    ATLTRACE(_T("ITClientApi::Detach\n"));

    szError = SCDetach(m_pCI);
    if (szError == NULL)
    {
        m_pCI = NULL;
    }
    SaveError(szError, m_dwErrorIndex, &hrResult);
    return hrResult;
}

/*++
 *  Function:
 *      CTClientApi::GetIni
 *  Description:
 *      This routine provides scriptable access to the SmClient INI settings.
 *  Arguments:
 *      Ini - Returns the ITClientIni interface, which provides access to the
 *          SmClient INI settings.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::GetIni (
    OUT ITClientIni **Ini
    )
{
    ATLTRACE(_T("ITClientApi::GetIni\n"));
    UNREFERENCED_PARAMETER(Ini);
    return E_NOTIMPL;
}

/*++
 *  Function:
 *      CTClientApi::GetClientWindowHandle
 *  Description:
 *      This routine provides a scriptable interface to
 *          SCGetClientWindowHandle.
 *  Arguments:
 *      Window - Returns the client-window handle.
 *  Return value:
 *      S_OK if successful, an appropriate HRESULT otherwise.
 *  Called by:
 *      Exported via COM.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
STDMETHODIMP
CTClientApi::GetClientWindowHandle (
    OUT HWND *Window
    )
{

    HWND hWindow;

    ATLTRACE(_T("ITClientApi::GetClientWindowHandle\n"));

    //
    // Get the window handle and return it.
    //

    ASSERT(m_pCI != NULL);
    hWindow = SCGetClientWindowHandle(m_pCI);

    _try
    {
        *Window = hWindow;
    }
    _except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ?
             EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH)
    {
        return E_POINTER;
    }

    return S_OK;
}

//
// Define utility routines.
//

/*++
 *  Function:
 *      CTClientApi::PrintMessage
 *  Description:
 *      This routine prints a message to the standard output and to the
 *      debugger.
 *  Arguments:
 *      MessageType - Supplies the message category, e.g. error, warning,
 *          etc.
 *  Return value:
 *      None.
 *  Called by:
 *      Various routines.
 *  Author:
 *      Alex Stephens (alexstep) 24-Jan-2002
 --*/
VOID
CTClientApi::PrintMessage (
    MESSAGETYPE MessageType,
    PCSTR Format,
    ...
    )
{

    CHAR szBuffer[LOG_BUFFER_SIZE];
    CHAR szDbgBuffer[LOG_BUFFER_SIZE +
                     sizeof(LOG_PREFIX) / sizeof(*LOG_PREFIX)];
    va_list arglist;

    ATLTRACE(_T("CTClientApi::PrintMessage\n"));

    UNREFERENCED_PARAMETER(MessageType);

    //
    // Construct the output string.
    //

    va_start(arglist, Format);
    _vsnprintf(szBuffer, LOG_BUFFER_SIZE - 1, Format, arglist);
    szBuffer[LOG_BUFFER_SIZE - 1] = '\0';
    va_end (arglist);

    //
    // Print the message to the output console.
    //

    printf( "%s", szBuffer);

    //
    // Print the message to the debugger window.
    //

    sprintf(szDbgBuffer, LOG_PREFIX "%s", szBuffer);
    szDbgBuffer[LOG_BUFFER_SIZE +
                sizeof(LOG_PREFIX) / sizeof(*LOG_PREFIX) -
                1] = '\0';
    OutputDebugStringA(szDbgBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient\lib\tclient.cpp ===
/*++
 *  File name:
 *      tclient.c
 *  Contents:
 *      Initialization code. Global feedback thread
 *
 *      Copyright (C) 1998-1999 Microsoft Corp.
 *
 --*/
#include "stdafx.h"

#include <windows.h>
#include <stdio.h>
#include <malloc.h>
#include <process.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <direct.h>
#include <winsock.h>
#include <tchar.h>

#define WIDE2ANSI(_p_, _s_)  \
  if ( NULL != _s_ ) \
  { \
    size_t len = wcslen( _s_ ) + 1; \
    size_t wlen = sizeof(wchar_t) * len; \
    char *wc = (char *)_alloca( wlen ); \
\
    WideCharToMultiByte( \
        CP_UTF8, 0, _s_, -1, wc, (int)wlen, NULL, NULL \
    ); \
    _p_ = wc; \
  } else { \
    _p_ = NULL; \
  }
    

#include "tclient.h"
#define PROTOCOLAPI __declspec(dllexport)
#include "protocol.h"
#include "queues.h"
#include "bmpcache.h"
#include "extraexp.h"
#include "scfuncs.h"

//
// COM support.
//

#include "resource.h"
#include "initguid.h"
#include "tclientax.h"
#include "tclientaxobj.h"
#include <atlwin.cpp>
#include <atlctl.cpp>

#define IID_DEFINED
#include "tclientax_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CTClient, CTClientApi)
END_OBJECT_MAP()

//
// Use C linkage for global data.
//

extern "C" {

/*
 *  stolen from tssec.h
 */
VOID
_stdcall
TSRNG_Initialize(
    VOID
    );

BOOL
_stdcall
TSRNG_GenerateRandomBits(
    LPBYTE pbRandomKey,
    DWORD dwRandomKeyLen
    );

BOOL
_stdcall
EncryptDecryptLocalData50(
    LPBYTE pbData,
    DWORD dwDataLen,
    LPBYTE pbSalt,
    DWORD dwSaltLen
    );

/*
 *  Internal functions definitions
 */
BOOL    _RegisterWindow(VOID);
LRESULT CALLBACK _FeedbackWndProc( HWND , UINT, WPARAM, LPARAM);
BOOL    _CreateFeedbackThread(VOID);
VOID    _DestroyFeedbackThread(VOID);
VOID    _CleanStuff(VOID);

/*
 * Global data
 */
OSVERSIONINFOEXW g_OsInfo;
HWND 		     g_hWindow 	    = NULL; // Window handle for the feedback thread
HINSTANCE 	     g_hInstance 	= NULL; // Dll instance
PWAIT4STRING	 g_pWaitQHead 	= NULL; // Linked list for waited events
PFNPRINTMESSAGE  g_pfnPrintMessage= NULL;// Trace function (from smclient)
PCONNECTINFO     g_pClientQHead  = NULL; // LL of all threads
HANDLE           g_hThread       = NULL; // Feedback Thread handle

LPCRITICAL_SECTION	g_lpcsGuardWaitQueue = NULL;
                                        // Guards the access to all 
                                        // global variables

// Some strings we are expecting and response actions
// Those are used in SCConnect, _Logon and SCStart
CHAR  g_strConsoleExtension[ MAX_STRING_LENGTH ];
                                               // Ferit's extension for the
                                               // console

// Low Speed option
// Cache Bitmaps on disc option
// by default, client will not run
// in full screen
INT g_ConnectionFlags = TSFLAG_COMPRESSION|TSFLAG_BITMAPCACHE|TSFLAG_DRIVES|TSFLAG_PORTS;

//  Apply translation so the english strings are human readable
//  when language packs are installed
//
INT g_bTranslateStrings = 0;

/*++
 *  Function:   
 *      InitDone
 *
 *  Description:    
 *      Initialize/delete global data. Create/destroy
 *      feedback thread
 *
 *  Arguments:
 *      hDllInst - Instance to the DLL
 *      bInit    - TRUE if initialize
 *
 *  Return value:
 *      TRUE if succeeds
 *
 --*/
int InitDone(HINSTANCE hDllInst, int bInit)
{
    int rv = TRUE;

    if (bInit)
    {
        WCHAR szMyLibName[_MAX_PATH];

        //
        // Initialize the COM module.
        //

        _Module.Init(ObjectMap, hDllInst);

        g_lpcsGuardWaitQueue = (LPCRITICAL_SECTION) malloc(sizeof(*g_lpcsGuardWaitQueue));
        if (!g_lpcsGuardWaitQueue)
        {
            rv = FALSE;
            goto exitpt;
        }

        // Overreference the library
        // The reason for that is beacuse an internal thread is created.
        // When the library trys to unload it can't kill that thread
        // and wait for its handle to get signaled, because
        // the thread itself wants to go to DllEntry and this
        // causes a deadlock. The best solution is to overreference the
        // handle so the library is unload at the end of the process
        if (!GetModuleFileNameW(hDllInst,
                                szMyLibName,
                                sizeof(szMyLibName) / sizeof(*szMyLibName)))
        {
            TRACE((ERROR_MESSAGE, "Can't overref the dll. Exit.\n"));
            free(g_lpcsGuardWaitQueue);
            rv = FALSE;
            goto exitpt;
        }
        else {
            szMyLibName[SIZEOF_ARRAY(szMyLibName) - 1] = 0;
        }

        if (!LoadLibraryW(szMyLibName))
        {
            TRACE((ERROR_MESSAGE, "Can't overref the dll. Exit.\n"));
            free(g_lpcsGuardWaitQueue);
            rv = FALSE;
            goto exitpt;
        }

		// get the OS info
        ZeroMemory(&g_OsInfo, sizeof(g_OsInfo));
		g_OsInfo.dwOSVersionInfoSize = sizeof(g_OsInfo);
		if (!GetVersionExW((LPOSVERSIONINFOW)&g_OsInfo))
		{

            //
            // Windows 9x does not support OSVERSIONINFOEX, so retry with
            // OSVERSIONINFO.
            //

            ZeroMemory(&g_OsInfo, sizeof(g_OsInfo));
            g_OsInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOW);
            if (!GetVersionExW((LPOSVERSIONINFOW)&g_OsInfo))
            {
                TRACE((ERROR_MESSAGE, "GetVersionEx failed.Exit\n"));
                free(g_lpcsGuardWaitQueue);
                rv = FALSE;
                goto exitpt;
            }
		}

        g_hInstance = hDllInst;
        InitializeCriticalSection(g_lpcsGuardWaitQueue);
        InitCache();
        if (_RegisterWindow())              // If failed to register the window,
            _CreateFeedbackThread();        // means the feedback thread will 
                                            // not work
    } else
    {
        if (g_pWaitQHead || g_pClientQHead)
        {
            TRACE((ERROR_MESSAGE, 
                   "The Library unload is unclean. Will try to fix this\n"));
            _CleanStuff();
        }
        _DestroyFeedbackThread();
        DeleteCache();
        if (g_lpcsGuardWaitQueue)
        {
            DeleteCriticalSection(g_lpcsGuardWaitQueue);
            free(g_lpcsGuardWaitQueue);
        }
        g_lpcsGuardWaitQueue = NULL;
        g_hInstance = NULL;
        g_pfnPrintMessage = NULL;

        //
        // Terminate the COM module.
        //

        _Module.Term();

    }
exitpt:
    return rv;
}

#if 0

VOID
_ConvertAnsiToUnicode( LPWSTR wszDst, LPWSTR wszSrc )
{
#define _TOHEX(_d_) ((_d_ <= '9' && _d_ >= '0')?_d_ - '0':       \
                     (_d_ <= 'f' && _d_ >= 'a')?_d_ - 'a' + 10:  \
                     (_d_ <= 'F' && _d_ >= 'F')?_d_ - 'A' + 10:0)

    while( wszSrc[0] && wszSrc[1] && wszSrc[2] && wszSrc[3] )
    {
        *wszDst = (WCHAR)((_TOHEX(wszSrc[0]) << 4) + _TOHEX(wszSrc[1]) +
                  (((_TOHEX(wszSrc[2]) << 4) + _TOHEX(wszSrc[3])) << 8)); 
        wszDst ++;
        wszSrc += 4;
    }
    *wszDst = 0;
#undef  _TOHEX
}

/*
 *
 *  Wrappers for GetPrivateProfileW, on Win95 there's no UNICODE veriosn
 *  of this function
 *
 */
DWORD
_WrpGetPrivateProfileStringW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    LPCWSTR lpDefault,
    LPWSTR  lpReturnedString,
    DWORD   nSize,
    LPCWSTR lpFileName)
{
    DWORD   rv = 0;
    CHAR    szAppName[MAX_STRING_LENGTH];
    CHAR    szKeyName[MAX_STRING_LENGTH];
    CHAR    szDefault[MAX_STRING_LENGTH];
    CHAR    szReturnedString[MAX_STRING_LENGTH];
    CHAR   szReturnedStringNonExp[MAX_STRING_LENGTH];
    CHAR   szFileName[MAX_STRING_LENGTH];
    LPWSTR  szwReturnedString = NULL;

    ASSERT( 0 != nSize );

    if ( nSize < wcslen( lpDefault ))
        wcsncpy( lpReturnedString, lpDefault, nSize - 1 );
    else
        wcscpy( lpReturnedString, lpDefault );

    __try {
        szwReturnedString = (LPWSTR) alloca(( nSize + 1 ) * sizeof( WCHAR ));
    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        szwReturnedString = NULL;
    }

    if ( !szwReturnedString )
        goto exitpt;

	if (ISNT())
	{
		rv = GetPrivateProfileStringW(
			lpAppName,
			lpKeyName,
			lpDefault,
			szwReturnedString,
			nSize,
			lpFileName);

		if (rv)
		{
			goto exitpt;
		}
	}

    // Call the ANSI version
    _snprintf(szAppName, MAX_STRING_LENGTH, "%S", lpAppName);
    _snprintf(szKeyName, MAX_STRING_LENGTH, "%S", lpKeyName);
    _snprintf(szFileName, MAX_STRING_LENGTH, "%S", lpFileName);
    _snprintf(szDefault, MAX_STRING_LENGTH, "%S", lpDefault);

    rv = GetPrivateProfileStringA(
            szAppName,
            szKeyName,
            szDefault,
            szReturnedStringNonExp,
            sizeof(szReturnedString),
            szFileName);
	
    ExpandEnvironmentStringsA(
            szReturnedStringNonExp,
            szReturnedString,
            sizeof(szReturnedString)
        );

    _snwprintf(lpReturnedString, nSize, L"%S", szReturnedString);
    lpReturnedStrig[ nSize - 1 ] = 0;

exitpt:

    if ( NULL != szwReturnedString )
    {
        //  expand the string
        //
        ExpandEnvironmentStringsW( 
                szwReturnedString,
                lpReturnedString,
                nSize
        );
    }

    if ( L'\\' == lpReturnedString[0] &&
         L'U'  == towupper(lpReturnedString[1]))
        _ConvertAnsiToUnicode( lpReturnedString, lpReturnedString + 2 );

    return rv;
}

UINT
_WrpGetPrivateProfileIntW(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT   nDefault,
    LPCWSTR lpFileName)
{
    UINT    rv = (UINT)-1;
    CHAR    szAppName[MAX_STRING_LENGTH];
    CHAR    szKeyName[MAX_STRING_LENGTH];
    CHAR    szFileName[MAX_STRING_LENGTH];

    rv = GetPrivateProfileIntW(
        lpAppName,
        lpKeyName,
        nDefault,
        lpFileName);

    if (rv != (UINT)-1 && rv)
        goto exitpt;

// Call the ANSI version
    _snprintf(szAppName, MAX_STRING_LENGTH, "%S", lpAppName);
    _snprintf(szKeyName, MAX_STRING_LENGTH, "%S", lpKeyName);
    _snprintf(szFileName, MAX_STRING_LENGTH, "%S", lpFileName);

    rv = GetPrivateProfileIntA(
            szAppName,
            szKeyName,
            nDefault,
            szFileName);

exitpt:
    return rv;
}

LONG RegCreateKeyExWrp(
  HKEY hkey,
  LPCWSTR lpSubKey,
  DWORD Reserved,
  LPWSTR lpClass,
  DWORD dwOptions,
  REGSAM samDesired,
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
  PHKEY phkResult,
  PDWORD lpdwDisposition
)
{
    LONG rv;

    if (!ISWIN9X())
    {
        return RegCreateKeyExW( hkey, lpSubKey, Reserved, 
                                lpClass, dwOptions, samDesired, 
                                lpSecurityAttributes,
                                phkResult,
                                lpdwDisposition );
    }


    __try {
        CHAR *lpSubKeyA;
        CHAR *lpClassA;

        WIDE2ANSI( lpSubKeyA, lpSubKey );
        WIDE2ANSI( lpClassA, lpClass );
        rv = RegCreateKeyExA( hkey, lpSubKeyA, Reserved,
                         lpClassA, dwOptions, samDesired,
                         lpSecurityAttributes,
                         phkResult,
                         lpdwDisposition );
    } __except( (GetExceptionCode() == STATUS_STACK_OVERFLOW)? 
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH  )
    {
        rv = ERROR_STACK_OVERFLOW;
    }

    return rv;
}

LONG
RegSetValueExWrp(
    HKEY hkey,
    LPCWSTR lpValueName,
    DWORD reserved,
    DWORD dwType,
    CONST BYTE *lpData,
    DWORD cbData
    )
{
    LONG rv;

    if (!ISWIN9X())
    {
        return RegSetValueEx(
                hkey, lpValueName, reserved, dwType, lpData, cbData );
    }

    __try {
        CHAR *lpValueNameA;
        CHAR *lpDataA;

        WIDE2ANSI( lpValueNameA, lpValueName );
        if ( REG_SZ == dwType )
        {
            WIDE2ANSI( lpDataA, ((LPCWSTR)lpData) );
            lpData = (CONST BYTE *)lpDataA;
            cbData = (DWORD)strlen( lpDataA );
        }

        rv = RegSetValueExA( hkey, lpValueNameA, reserved, dwType, lpData, cbData );

    } __except( (GetExceptionCode() == STATUS_STACK_OVERFLOW) ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH  )
    {
        rv = ERROR_STACK_OVERFLOW;
    }

    return rv;

}

LONG RegQueryValueExWrp(
    HKEY hKey,            // handle to key
    LPCWSTR lpValueName,  // value name
    PDWORD lpReserved,   // reserved
    PDWORD lpType,       // type buffer
    PBYTE lpData,        // data buffer
    PDWORD lpcbData      // size of data buffer
    )
{
    LONG rv;

    if (!ISWIN9X())
    {
        return RegQueryValueEx( hKey, lpValueName, lpReserved, lpType, lpData, lpcbData );
    }

    __try {
        CHAR *lpValueNameA;

        WIDE2ANSI( lpValueNameA, lpValueName );
        rv = RegQueryValueExA( hKey, lpValueNameA, lpReserved, lpType, lpData, lpcbData );
    } __except( (GetExceptionCode() == STATUS_STACK_OVERFLOW) ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH  )
    {
        rv = ERROR_STACK_OVERFLOW;
    }

    return rv;

}

LONG
RegDeleteKeyWrp(
    HKEY hkey,
    LPCWSTR lpSubKey
    )
{
    LONG rv;

    if ( !ISWIN9X() )
    {
        return RegDeleteKeyW( hkey, lpSubKey );
    }

    __try {
        CHAR *lpSubKeyA;
        WIDE2ANSI( lpSubKeyA, lpSubKey );
        rv = RegDeleteKeyA( hkey, lpSubKeyA );
    } __except( (GetExceptionCode() == STATUS_STACK_OVERFLOW) ?
                EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH  )
    {
        rv = ERROR_STACK_OVERFLOW;
    }

    return rv;

}

INT
GetClassNameWrp(
    HWND hwnd,
    LPWSTR szName,
    INT max
    )
{
    LPSTR szNameA;
    INT maxA;
    INT rv;

    if ( !ISWIN9X() )
    {
        return GetClassNameW( hwnd, szName,max );
    }

    maxA = max / sizeof( WCHAR );
    __try {
        szNameA = (LPSTR)_alloca( maxA );
    } __except( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError( ERROR_STACK_OVERFLOW );
        rv = 0;
        goto exitpt;
    }

    rv = GetClassNameA( hwnd, szNameA, maxA );
    MultiByteToWideChar( CP_UTF8, 0, szNameA, maxA, szName, max );

exitpt:
    return rv;
}

INT
GetWindowTextWrp(
    HWND hwnd,
    LPWSTR szText,
    INT max
    )
{
    LPSTR szTextA;
    INT maxA;
    INT rv;

    if ( !ISWIN9X() )
    {
        return GetWindowTextW( hwnd, szText ,max );
    }

    maxA = max / sizeof( WCHAR );
    __try {
        szTextA = (LPSTR)_alloca( maxA );
    } __except( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError( ERROR_STACK_OVERFLOW );
        rv = 0;
        goto exitpt;
    }

    rv = GetClassNameA( hwnd, szTextA, maxA );
    MultiByteToWideChar( CP_UTF8, 0, szTextA, maxA, szText, max );

exitpt:
    return rv;
}

#endif // 0    

/*++
 *  Function:
 *      ConstructLogonString
 *
 *  Description:
 *      Constructs the client command line. The format is taken from
 *      the INI file, supports the following parameters:
 *          %srv%   - destination server
 *          %usr%   - username
 *          %psw%   - password
 *          %dom%   - domain
 *
 *  Arguments:
 *
 *  Return value:
 *      none
 *
 --*/
VOID
ConstructLogonString(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    LPWSTR   szLine,
    DWORD    dwSize,
    PCONFIGINFO pConfig
    )
{
    DWORD_PTR dwFmtSize;
    LPWSTR  szFmt;

    //
    //  fix the parameters
    //
    if ( NULL == lpszServerName )
        lpszServerName = L"";
    if ( NULL == lpszUserName )
        lpszUserName   = L"";
    if ( NULL == lpszPassword )
        lpszPassword   = L"";
    if ( NULL == lpszDomain )
        lpszDomain     = L"";

    if ( dwSize < 1 )
        return;

    if ( NULL == pConfig )
        return;

    szFmt = pConfig->strLogonFmt;
    dwFmtSize = wcslen( szFmt );

    for( ; 0 != dwFmtSize && dwSize > 1 ; )
    {
        //
        //  optimize the code path
        //
        if ( L'%' != *szFmt )
            goto copy_char;

        if ( dwFmtSize >= 5 )
        {
            INT iNewLen;

            if          ( !_wcsnicmp( szFmt, L"%srv%", 5 ))
            {
                iNewLen = _snwprintf( szLine, dwSize,
                           L"%s", lpszServerName );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szLine += iNewLen;
                dwSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%usr%", 5 ))
            {
                iNewLen = _snwprintf( szLine, dwSize,
                           L"%s", lpszUserName );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szLine += iNewLen;
                dwSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%psw%", 5 ))
            {
                iNewLen = _snwprintf( szLine, dwSize,
                           L"%s", lpszPassword );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szLine += iNewLen;
                dwSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%dom%", 5 ))
            {
                iNewLen = _snwprintf( szLine, dwSize,
                           L"%s", lpszDomain );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szLine += iNewLen;
                dwSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else {
                goto copy_char;
            }

            continue;
        }

copy_char:
        *szLine = *szFmt;
        szLine ++;
        szFmt         ++;
        dwSize --;
        dwFmtSize     --;
    }

    *szLine = 0;
}


/*++
 *  Function:
 *      ConstructCmdLine
 *
 *  Description:
 *      Constructs the client command line. The format is taken from
 *      the INI file, supports the following parameters:
 *          %img%   - the client's image
 *          %srv%   - destination server
 *          %usr%   - username
 *          %psw%   - password
 *          %dom%   - domain
 *          %hrs%   - horizontal resolution
 *          %vrs%   - vertical resolution
 *          %wnd%   - tclient's window handle, for accepting feedback
 *          %reg%   - registry referrence
 *          %app%   - starting app
 *          %cwd%   - (UNSUPPORTED) working directory for the app
 *			%con%   - /console if TSFLAG_RCONSOLE is defined
 *          
 *  Arguments:
 *
 *  Return value:
 *      none
 *
 --*/
VOID
ConstructCmdLine(
    LPCWSTR  lpszServerName,
    LPCWSTR  lpszUserName,
    LPCWSTR  lpszPassword,
    LPCWSTR  lpszDomain,
    LPCWSTR  lpszShell,
    IN const int xRes,
    IN const int yRes,
	IN const int ConnectionFlags,
    LPWSTR   szCommandLine,
    DWORD    dwCmdLineSize,
    PCONFIGINFO pConfig
    )
{
    DWORD_PTR dwFmtSize;
    LPWSTR  szFmt;

    //
    //  fix the parameters
    //
    if ( NULL == lpszServerName )
        lpszServerName = L"";
    if ( NULL == lpszUserName )
        lpszUserName   = L"";
    if ( NULL == lpszPassword )
        lpszPassword   = L"";
    if ( NULL == lpszDomain )
        lpszDomain     = L"";
    if ( NULL == lpszShell )
        lpszShell      = L"";

    if ( dwCmdLineSize < 1 )
        return;

    if ( NULL == pConfig )
        return;

    szFmt = pConfig->strCmdLineFmt;
    dwFmtSize = wcslen( szFmt );

    for( ; 0 != dwFmtSize && dwCmdLineSize > 1 ; )
    {
        //
        //  optimize the code path
        //
        if ( L'%' != *szFmt )
            goto copy_char;

        if ( dwFmtSize >= 5 )
        {
            INT iNewLen;

            if          ( !_wcsnicmp( szFmt, L"%img%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
                           L"%s", pConfig->strClientImg );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;                
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%srv%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
                           L"%s", lpszServerName );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%usr%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
                           L"%s", lpszUserName );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%psw%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
                           L"%s", lpszPassword );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%dom%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
                           L"%s", lpszDomain );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;

            } else if   ( !_wcsnicmp( szFmt, L"%hrs%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
                           L"%d", xRes );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%vrs%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
                           L"%d", yRes );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%con%", 5 ))
            {
                if (ConnectionFlags & TSFLAG_RCONSOLE)
				{
					iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
							   L"-console" );
                if ( iNewLen < 0 )
                {
                    break;
                }
				} else
				{
					iNewLen = 0;
				}
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%wnd%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
#ifdef  _WIN64
                           L"%I64d", 
#else   // !_WIN64
                           L"%d",
#endif  // !_WIN64
                           (LONG_PTR)g_hWindow );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%reg%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
                            REG_FORMAT,
                            GetCurrentProcessId(), GetCurrentThreadId());
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else if   ( !_wcsnicmp( szFmt, L"%app%", 5 ))
            {
                iNewLen = _snwprintf( szCommandLine, dwCmdLineSize,
                           L"%s", lpszShell );
                if ( iNewLen < 0 )
                {
                    break;
                }
                szCommandLine += iNewLen;
                dwCmdLineSize -= iNewLen;
                szFmt     += 5;
                dwFmtSize -= 5;
            } else {
                goto copy_char;
            }

            continue;
        }

copy_char:
        *szCommandLine = *szFmt;
        szCommandLine ++;
        szFmt         ++;
        dwCmdLineSize --;
        dwFmtSize     --;           
    }

    *szCommandLine = 0;
}

/*++
 *  Function:
 *      _FeedbackWndProc
 *  Description:
 *      Window proc wich dispatches messages containing feedback
 *      The messages are usualy sent by RDP clients
 *
 --*/
LRESULT CALLBACK _FeedbackWndProc( HWND hwnd,
                                   UINT uiMessage,
                                   WPARAM wParam,
                                   LPARAM lParam)
{
//    HANDLE hMapF = NULL;

    switch (uiMessage)
    {
    case WM_FB_TEXTOUT: 
        _TextOutReceived((DWORD)wParam, (HANDLE)lParam);
        break;
    case WM_FB_GLYPHOUT:
        _GlyphReceived((DWORD)wParam, (HANDLE)lParam);
        break;
    case WM_FB_DISCONNECT:
        _SetClientDead(lParam);
        _CheckForWorkerWaitingDisconnect(lParam);
        _CancelWaitingWorker(lParam);
        break;
    case WM_FB_CONNECT:
        _CheckForWorkerWaitingConnect((HWND)wParam, lParam);
        break;
    case WM_FB_LOGON:
        TRACE((INFO_MESSAGE, "LOGON event, session ID=%d\n",
               wParam));
        _SetSessionID(lParam, (UINT)wParam);
        break;
        break;
    case WM_FB_ACCEPTME:
        return (_CheckIsAcceptable(lParam, FALSE) != NULL);
    case WM_FB_REPLACEPID:
        return (_ReplaceProcessId( wParam, lParam ));
#ifdef  _RCLX
    case WM_WSOCK:          // Windows socket messages
        RClx_DispatchWSockEvent((SOCKET)wParam, lParam);
        break;
#endif  // _RCLX
    case WM_DESTROY:
        PostQuitMessage(0);
        break;
    default:
        return DefWindowProcA(hwnd, uiMessage, wParam, lParam);
    }

    return 0;
}

/*++
 *  Function:
 *      _RegisterWindow
 *  Description:
 *      Resgisters window class for the feedback dispatcher
 *  Arguments:
 *      none
 *  Return value:
 *      TRUE on success
 *
 --*/
BOOL _RegisterWindow(VOID)
{
    WNDCLASSA   wc;
    BOOL        rv = FALSE;
//    DWORD       dwLastErr;

    memset(&wc, 0, sizeof(wc));

    wc.lpfnWndProc      = _FeedbackWndProc;
    wc.hInstance        = g_hInstance;
    wc.lpszClassName    = _TSTNAMEOFCLAS;

    if (!RegisterClassA (&wc) && 
        GetLastError() && 
        GetLastError() != ERROR_CLASS_ALREADY_EXISTS)
    {
        TRACE((ERROR_MESSAGE, 
              "Can't register class. GetLastError=%d\n", 
              GetLastError()));
        goto exitpt;
    }

    rv = TRUE;
exitpt:
    return rv;
}

/*++
 *  Function:
 *      _GoFeedback
 *  Description:
 *      Main function for the feedback thread. The thread is created for the
 *      lifetime of the DLL
 *  Arguments:
 *      lpParam is unused
 *  Return value:
 *      Thread exit code
 --*/
DWORD WINAPI _GoFeedback(LPVOID lpParam)
{
    MSG         msg;

    UNREFERENCED_PARAMETER(lpParam);

    g_hWindow = CreateWindowA(
                       _TSTNAMEOFCLAS,
                       NULL,         // Window name
                       0,            // dwStyle
                       0,            // x
                       0,            // y
                       0,            // nWidth
                       0,            // nHeight
                       NULL,         // hWndParent
                       NULL,         // hMenu
                       g_hInstance,
                       NULL);        // lpParam

    if (!g_hWindow)
    {
        TRACE((ERROR_MESSAGE, "No feedback window handle"));
        goto exitpt;
    } else {

#ifdef  _RCLX
        if (!RClx_Init())
            TRACE((ERROR_MESSAGE, "Can't initialize RCLX\n"));
#endif  // _RCLX

        while (GetMessageA (&msg, NULL, 0, 0) && msg.message != WM_FB_END)
        {
            DispatchMessageA (&msg);
        }

#ifdef  _RCLX
        RClx_Done();
#endif  // _RCLX
    }

    TRACE((INFO_MESSAGE, "Window/Thread destroyed\n"));
    FreeLibraryAndExitThread(g_hInstance, 0); 
exitpt:
    return 1;
    
}

VOID
SetAllowBackgroundInput(
    VOID
    )
{
    DWORD ResId;
    LONG  sysrc;
    HKEY  key;
    DWORD disposition;

    ResId = 1;

//    sysrc = RegCreateKeyExWrp(HKEY_CURRENT_USER,
    sysrc = RegCreateKeyExW(HKEY_CURRENT_USER,
                           REG_BASE,
                           0,                   /* reserved             */
                           NULL,                /* class                */
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,                /* security attributes  */
                           &key,
                           &disposition);

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegCreateKeyEx failed, sysrc = %d\n", sysrc));
        goto exitpt;
    }

//    sysrc = RegSetValueExWrp(key,
    sysrc = RegSetValueExW(key,
                    ALLOW_BACKGROUND_INPUT,
                    0,
                    REG_DWORD,
                    (LPBYTE)&ResId,
                    sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    RegCloseKey(key);

exitpt:
    ;
}


/*
 *  Disables prompting the user for redirected drives and ports (may be even more stuff)
 *
 */
BOOL
_DisablePrompting(
    LPCWSTR szServerName,
    INT     ConnectionFlags
    )
{
    BOOL rv = FALSE;
    LONG rc;
    HKEY hKey = NULL;
    DWORD dwType, dwSize, dwData, dwDisp;
    DWORD dwPromptFlags = 0;

    if ( ConnectionFlags & TSFLAG_DRIVES )
    {
        dwPromptFlags |= 1;
    }

    if ( ConnectionFlags & TSFLAG_PORTS )
    {
        dwPromptFlags |= 2;
    }

    if ( 0 == dwPromptFlags )
    {
        rv = TRUE;
        goto exitpt;
    }

//    rc = RegCreateKeyExWrp( 
    rc = RegCreateKeyExW( 
            HKEY_CURRENT_USER,
            REG_BASE L"\\LocalDevices",
            0,              // options
            NULL,           // class
            REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS,
            NULL,           // security
            &hKey,
            &dwDisp
        );
    if ( ERROR_SUCCESS != rc )
    {
        TRACE(( WARNING_MESSAGE, "RegOpenKeyEx failed (%d).Can't disable user prompt\n", rc ));
        goto exitpt;
    }

    dwSize = sizeof( dwData );
//    rc = RegQueryValueExWrp(
    rc = RegQueryValueExW(
            hKey,
            szServerName,
            NULL,           // reserved
            &dwType,
            (LPBYTE)&dwData,
            &dwSize
        );

    if ( ERROR_SUCCESS != rc ||
         REG_DWORD != dwType )
    {
        dwData = 0;
    }

    dwData |= dwPromptFlags;

//    rc = RegSetValueExWrp(
    rc = RegSetValueExW(
            hKey,
            szServerName,
            0,
            REG_DWORD,
            (LPBYTE)&dwData,
            sizeof( dwData )
        );

    if ( ERROR_SUCCESS != rc )
    {
        TRACE(( WARNING_MESSAGE, "RegSetValueEx failed (%d). Can't disable user prompt\n", rc ));
    }

    rv = TRUE;

exitpt:
    if ( NULL != hKey )
    {
        RegCloseKey( hKey );
    }

    return rv;
}
    
/*++
 *  Function:
 *      _SetClientRegistry
 *  Description:
 *      Sets the registry prior running RDP client
 *      The format of the key is: smclient_PID_TID
 *      PID is the process ID and TID is the thread ID
 *      This key is deleated after the client disconnects
 *  Arguments:
 *      lpszServerName  - server to which the client will connect
 *      xRes, yRes      - clients resolution
 *      bLowSpeed       - low speed (compression) option
 *      bCacheBitmaps   - cache the bitmaps to the disc option
 *      bFullScreen     - the client will be in full screen mode
 *      ...             - ...
 *      KeyboardHook    - keyboard hook mode
 *  Called by:
 *      SCConnect
 --*/
VOID 
_SetClientRegistry(
    LPCWSTR lpszServerName, 
    LPCWSTR lpszShell,
    LPCWSTR lpszUsername,
    LPCWSTR lpszPassword,
    LPCWSTR lpszDomain,
    INT xRes, 
    INT yRes,
    INT Bpp,
    INT AudioOpts,
    PCONNECTINFO *ppCI,
    INT ConnectionFlags,
    INT KeyboardHook)
{
//    const   CHAR   *pData;
//    CHAR    szServer[MAX_STRING_LENGTH];
//    register int i;
    LONG    sysrc;
    HKEY    key;
    DWORD   disposition;
    DWORD_PTR dataSize;
    DWORD   ResId;
    WCHAR   lpszRegistryEntry[4*MAX_STRING_LENGTH];
//    RECT    rcDesktop = {0, 0, 0, 0};
//    INT     desktopX, desktopY;

    _snwprintf(lpszRegistryEntry, sizeof(lpszRegistryEntry)/sizeof( lpszRegistryEntry[0] ),
              L"%s\\" REG_FORMAT, 
               REG_BASE, GetCurrentProcessId(), GetCurrentThreadId());

    lpszRegistryEntry[ sizeof(lpszRegistryEntry)/sizeof( lpszRegistryEntry[0] ) - 1 ] = 0;

#if 0
    // Get desktop size
    GetWindowRect(GetDesktopWindow(), &rcDesktop);
    desktopX = rcDesktop.right;
    desktopY = rcDesktop.bottom;

    // Adjust the resolution
    if (desktopX < xRes || desktopY < yRes)
    {
        xRes = desktopX;
        yRes = desktopY;
    }
#endif

    dataSize = ( wcslen(lpszServerName) + 1 ) * sizeof( WCHAR );

    // Before starting ducati client set registry with server name

//    sysrc = RegCreateKeyExWrp(HKEY_CURRENT_USER,
    sysrc = RegCreateKeyExW(HKEY_CURRENT_USER,
                           lpszRegistryEntry,
                           0,                   /* reserved             */
                           NULL,                /* class                */
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,                /* security attributes  */
                           &key,
                           &disposition);

    if (sysrc != ERROR_SUCCESS) 
    {
        TRACE((WARNING_MESSAGE, "RegCreateKeyEx failed, sysrc = %d\n", sysrc));
        goto exitpt;
    }

//    sysrc = RegSetValueExWrp(key,
    sysrc = RegSetValueExW(key,
                L"MRU0",
                0,      // reserved
                REG_SZ,
                (LPBYTE)lpszServerName,
                (DWORD)dataSize);

    if (sysrc != ERROR_SUCCESS) 
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    // Set alternative shell (if specified
    if (lpszShell)
    {
//        sysrc = RegSetValueExWrp(key,
        sysrc = RegSetValueExW(key,
                TEXT("Alternate Shell 50"),
                0,      // reserved
                REG_BINARY,
                (LPBYTE)lpszShell,
                (DWORD)(wcslen(lpszShell) * sizeof(*lpszShell)));

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
        }
    }

    //  set user name
    //
    if (lpszUsername)
    {
//        sysrc = RegSetValueExWrp(key,
        sysrc = RegSetValueExW(key,
                TEXT("UserName 50"),
                0,      // reserved
                REG_BINARY,
                (LPBYTE)lpszUsername,
                (DWORD)(wcslen(lpszUsername) * sizeof(*lpszUsername)));

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
        }
    }
    //  domain
    //
    if (lpszDomain)
    {
        WCHAR szBuff[MAX_STRING_LENGTH];
        //
        //  convert lpszDomain to lower case only
        //  to force UpdateSessionPDU to be send from the server
        //
        wcsncpy( szBuff, lpszDomain, MAX_STRING_LENGTH - 1 );
        _wcslwr( szBuff );

//        sysrc = RegSetValueExWrp(key,
        sysrc = RegSetValueExW(key,
                TEXT("Domain 50"),
                0,      // reserved
                REG_BINARY,
                (LPBYTE)szBuff,
                (DWORD)(wcslen(lpszDomain) * sizeof(*lpszDomain)));

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
        }
    }

    // Set the resolution
         if (xRes >= 1600 && yRes >= 1200)  ResId = 4;
    else if (xRes >= 1280 && yRes >= 1024)  ResId = 3;
    else if (xRes >= 1024 && yRes >= 768)   ResId = 2;
    else if (xRes >= 800  && yRes >= 600)   ResId = 1;
    else                                    ResId = 0; // 640x480

//    sysrc = RegSetValueExWrp(key,
    sysrc = RegSetValueExW(key,
                L"Desktop Size ID",
                0,
                REG_DWORD,
                (LPBYTE)&ResId,
                sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    ResId = 1;
//    sysrc = RegSetValueExWrp(key,
    sysrc = RegSetValueExW(key,
                L"Auto Connect",
                0,      // reserved
                REG_DWORD,
                (LPBYTE)&ResId,
                sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    if ( (*ppCI)->pConfigInfo->Autologon )
    {
        WCHAR   szEncPwd[127];
        UINT    cb;
        BYTE    Salt[20];

        //  password
        //
        if ( NULL == lpszPassword )
            goto skip_pwd;

        TSRNG_Initialize();
        TSRNG_GenerateRandomBits( Salt, sizeof( Salt ));
        wcsncpy( szEncPwd, lpszPassword, sizeof( szEncPwd ) / sizeof( szEncPwd[0]) - 1 );   // BUGBUG: AV?
        szEncPwd[ sizeof( szEncPwd ) / sizeof( szEncPwd[0] ) - 1 ] = 0;
        cb = sizeof(szEncPwd);
        EncryptDecryptLocalData50( (LPBYTE)szEncPwd, cb,
                                   Salt, sizeof( Salt ));

//        sysrc = RegSetValueExWrp(key,
        sysrc = RegSetValueExW(key,
                L"Salt 50",
                0,      // reserved
                REG_BINARY,
                (LPBYTE)Salt,
                sizeof( Salt ));

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n",
                  sysrc));
        }

//        sysrc = RegSetValueExWrp(key,
        sysrc = RegSetValueExW(key,
                L"Password 50",
                0,      // reserved
                REG_BINARY,
                (LPBYTE)szEncPwd,
                cb);

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", 
                  sysrc));
        }

skip_pwd:

        ResId = 1;
//        sysrc = RegSetValueExWrp(key,
        sysrc = RegSetValueExW(key,
                L"AutoLogon 50",
                0,      // reserved
                REG_DWORD,
                (LPBYTE)&ResId,
                sizeof(ResId));
    }

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    ResId = (ConnectionFlags & TSFLAG_BITMAPCACHE)?1:0;
//    sysrc = RegSetValueExWrp(key,
    sysrc = RegSetValueExW(key,
                L"BitmapCachePersistEnable",
                0,      // reserved
                REG_DWORD,
                (LPBYTE)&ResId,
                sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    ResId = (ConnectionFlags & TSFLAG_COMPRESSION)?1:0;
//    sysrc = RegSetValueExWrp(key,
    sysrc = RegSetValueExW(key,
                L"Compression",
                0,      // reserved
                REG_DWORD,
                (LPBYTE)&ResId,
                sizeof(ResId));

    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegSetValue failed, status = %d\n", sysrc));
    }

    if (ConnectionFlags & TSFLAG_FULLSCREEN)
    {
        ResId = 2;
//        sysrc = RegSetValueExWrp(key,
        sysrc = RegSetValueExW(key,
                    L"Screen Mode ID",
                    0,      // reserved
                    REG_DWORD,
                    (LPBYTE)&ResId,
                    sizeof(ResId));

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE, 
                   "RegSetValue failed, status = %d\n", sysrc));
        }
    }

    if (ConnectionFlags & TSFLAG_DRIVES)
    {
        ResId = 1;
//        sysrc = RegSetValueExWrp(key,
        sysrc = RegSetValueExW(key,
                    L"RedirectDrives",
                    0,      // reserved
                    REG_DWORD,
                    (LPBYTE)&ResId,
                    sizeof(ResId));

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE,
                   "RegSetValue failed, status = %d\n", sysrc));
        }

    }

    if (ConnectionFlags & TSFLAG_PORTS)
    {
        ResId = 1;
//        sysrc = RegSetValueExWrp(key,
        sysrc = RegSetValueExW(key,
                    L"RedirectComPorts",
                    0,      // reserved
                    REG_DWORD,
                    (LPBYTE)&ResId,
                    sizeof(ResId));

        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE,
                   "RegSetValue failed, status = %d\n", sysrc));
        }
    }

    _DisablePrompting( lpszServerName, ConnectionFlags );

    if ( 0 != Bpp )
    {
        DWORD dw = Bpp;

//        sysrc = RegSetValueExWrp( 
        sysrc = RegSetValueExW( 
                        key,
                        L"Session Bpp",
                        0,
                        REG_DWORD,
                        (LPBYTE)&dw,
                        sizeof( dw ));
        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE,
                   "RegSetValue failed, status = %d\n", sysrc));
        }
    }

    if ( 0 != AudioOpts )
    {
        DWORD dw = AudioOpts;

//        sysrc = RegSetValueExWrp(
        sysrc = RegSetValueExW(
                        key,
                        L"AudioMode",
                        0,
                        REG_DWORD,
                        (LPBYTE)&dw,
                        sizeof( dw ));
        if (sysrc != ERROR_SUCCESS)
        {
            TRACE((WARNING_MESSAGE,
                   "RegSetValue failed, status = %d\n", sysrc));
        }
    }

    //
    // Set the keyboard-hook mode.
    //

//    sysrc = RegSetValueExWrp(
    sysrc = RegSetValueExW(
                    key,
                    L"KeyboardHook",
                    0,
                    REG_DWORD,
                    (LPBYTE)&KeyboardHook,
                    sizeof(KeyboardHook));
    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE,
               "RegSetValue failed, status = %d\n", sysrc));
    }

    RegCloseKey(key);

exitpt:
    ;
}

/*++
 *  Function:
 *      _DeleteClientRegistry
 *  Description:
 *      Deletes the key set by _SetClientRegistry
 *  Called by:
 *      SCDisconnect
 --*/
VOID _DeleteClientRegistry(PCONNECTINFO pCI)
{
    WCHAR   lpszRegistryEntry[4*MAX_STRING_LENGTH];
    LONG    sysrc;

    _snwprintf(lpszRegistryEntry, sizeof(lpszRegistryEntry)/sizeof(lpszRegistryEntry[0]),
             L"%s\\" REG_FORMAT,
              REG_BASE, GetCurrentProcessId(), pCI->OwnerThreadId);

    lpszRegistryEntry[ sizeof(lpszRegistryEntry)/sizeof(lpszRegistryEntry[0]) -1 ] = 0;
//    sysrc = RegDeleteKeyWrp(HKEY_CURRENT_USER, lpszRegistryEntry);
    sysrc = RegDeleteKeyW(HKEY_CURRENT_USER, lpszRegistryEntry);
    if (sysrc != ERROR_SUCCESS)
    {
        TRACE((WARNING_MESSAGE, "RegDeleteKey failed, status = %d\n", sysrc));
    }
}

/*++
 *  Function:
 *      _CreateFeedbackThread
 *  Description:
 *      Creates the feedback thread
 *  Called by: 
 *      InitDone
 --*/
BOOL _CreateFeedbackThread(VOID)
{
    BOOL rv = TRUE;
    // Register feedback window class
//    WNDCLASS    wc;
    UINT dwThreadId;
//    UINT dwLastErr;

    g_hThread = (HANDLE)
            _beginthreadex
                (NULL, 
                 0, 
                 (unsigned (__stdcall *)(void*))_GoFeedback, 
                 NULL, 
                 0, 
                 &dwThreadId);

    if (!g_hThread) {
        TRACE((ERROR_MESSAGE, "Couldn't create thread\n"));
        rv = FALSE;
    }
    return rv;
}

/*++
 *  Function:
 *      _DestroyFeedbackThread
 *  Description:
 *      Destroys the thread created by _CreateFeedbackThread
 *  Called by:  
 *      InitDone
 --*/
VOID _DestroyFeedbackThread(VOID)
{

    if (g_hThread)
    {
//        DWORD dwWait;
//        CHAR  szMyLibName[_MAX_PATH];

        // Closing feedback thread

        PostMessageA(g_hWindow, WM_FB_END, 0, 0);
        TRACE((INFO_MESSAGE, "Closing DLL thread\n"));

        // Dedstroy the window
        DestroyWindow(g_hWindow);

        // CloseHandle(g_hThread);
        g_hThread = NULL;
    }
}

/*++
 *  Function:
 *      _CleanStuff
 *  Description:
 *      Cleans the global queues. Closes any resources
 *  Called by:
 *      InitDone
 --*/
VOID _CleanStuff(VOID)
{

    // Thread safe, bacause is executed from DllEntry

    while (g_pClientQHead)
    {
        TRACE((WARNING_MESSAGE, "Cleaning connection info: 0x%x\n", 
               g_pClientQHead));
        SCDisconnect(g_pClientQHead);
    }
#if 0
    if (g_pClientQHead)
    {
        PCONNECTINFO pNext, pIter = g_pClientQHead;
        while (pIter)
        {
            int nEv;
            DWORD wres;

            TRACE((WARNING_MESSAGE, "Cleaning connection info: 0x%x\n", pIter));
            // Clear Events
            if (pIter->evWait4Str)
            {
                CloseHandle(pIter->evWait4Str);
                pIter->evWait4Str = NULL;
            }

            for (nEv = 0; nEv < pIter->nChatNum; nEv ++)
                CloseHandle(pIter->aevChatSeq[nEv]);

            pIter->nChatNum = 0;

            // Clear Processes
            do {
                SendMessageA(pIter->hClient, WM_CLOSE, 0, 0);
            } while((wres = WaitForSingleObject(pIter->hProcess, pCI->pConfigInfo->WAIT4STR_TIMEOUT/4) == WAIT_TIMEOUT));

            if (wres == WAIT_TIMEOUT)
            {
                TRACE((WARNING_MESSAGE, 
                       "Can't close process. WaitForSingleObject timeouts\n"));
                TRACE((WARNING_MESSAGE, 
                      "Process #%d will be killed\n", 
                      pIter->dwProcessId ));
                if (!TerminateProcess(pIter->hProcess, 1))
                {
                    TRACE((WARNING_MESSAGE, 
                           "Can't kill process #%d. GetLastError=%d\n", 
                            pIter->dwProcessId, GetLastError()));
                }
            }

            TRACE((WARNING_MESSAGE, "Closing process\n"));

            if (pIter->hProcess)
                CloseHandle(pIter->hProcess);
            if (pIter->hThread)
                CloseHandle(pIter->hThread);

            pIter->hProcess = pIter->hThread = NULL;

            // Free the structures
            pNext = pIter->pNext;
            free(pNext);
            pIter = pNext;
        }
    }

#endif // 0
}

VOID _TClientAssert(BOOL bCond,
                    LPCSTR filename,
                    INT line,
                    LPCSTR expression,
                    BOOL bBreak)
{
    if (!bCond)
    {
        TRACE((ERROR_MESSAGE,
               "ASSERT (%s) %s line: %d\n",
               expression,
               filename,
               line));
        if (bBreak)
        {
            DebugBreak(); 
        }
    }
}

/*++
 *  Function:
 *      LoadSmClientFile
 *  Description:
 *      Loads the appropriate SMCLIENT.INI 
 *  Called by:
 *      _FillConfigInfo
 --*/

VOID LoadSmClientFile(WCHAR *szIniFileName, DWORD dwIniFileNameLen, LPSTR szLang)
{
     WCHAR wszLang[4];
     // Construct INI path
	 *szIniFileName = 0;
	if(!_wgetcwd (
	   szIniFileName,
	   (int)(dwIniFileNameLen - wcslen(SMCLIENT_INI) - 8))
	  )
	{		
		 TRACE((ERROR_MESSAGE, "Current directory length too long.\n"));
	}
	if ( 0 == *szIniFileName )
	{
		CHAR szaIniFileName[_MAX_PATH];
	
		TRACE((WARNING_MESSAGE, "Reading ASCII working dir\n"));
	
        DWORD_PTR dwINILen = wcslen(SMCLIENT_INI);

		if (!_getcwd (
            szaIniFileName,
			(int)(sizeof(szaIniFileName) - dwINILen - 8))
		   )
		{
			 TRACE((ERROR_MESSAGE, "Current directory length too long.\n"));
		} 
		else 
		{
			_snwprintf(szIniFileName, dwIniFileNameLen, L"%S", szaIniFileName );
            szIniFileName[ dwIniFileNameLen - 1 ] = 0;
		}
        if ( wcslen( szIniFileName ) > dwIniFileNameLen - wcslen(SMCLIENT_INI) - strlen(szLang) - 2 )
        {
            TRACE(( ERROR_MESSAGE, "Current directory length too long.\n"));
            szIniFileName[0] = 0;
            return;
        }
	}
	// add '\' at the end if there isn't one
	if (szIniFileName[wcslen(szIniFileName)-1]!=L'\\')
	{
		 wcscat(szIniFileName, L"\\");
	}

        printf("Loading the smclient file \n");
    wcscat(szIniFileName, SMCLIENT_INI);

    if( strcmp( szLang, "0409") )
    {
        wcscat(szIniFileName, L".");
        MultiByteToWideChar( CP_ACP, 0, szLang, -1, wszLang, sizeof(wszLang)/sizeof(wszLang[0]) );
	    wcscat(szIniFileName, wszLang);
    }
    
    ; //return VOID

}

/*++
 *  Function:
 *      _FillConfigInfo
 *
 *  Description:
 *      Reads smclient.ini, section [tclient], variable "timeout"
 *      Also read some other values
 *  Arguments:
 *      PCONFIGINFO
 *  Return value:
 *      none
 *
 --*/
VOID _FillConfigInfo(PCONFIGINFO pConfigInfo) // LPSTR szLang)
{
    UINT nNew;
    WCHAR szIniFileName[_MAX_PATH];
//    WCHAR szBuff[ 4 * MAX_STRING_LENGTH ];
    WCHAR szBuffDef[MAX_STRING_LENGTH];
    BOOL  bFlag;
    DWORD dwIniFileNameLen = _MAX_PATH;

    /* Initializing variables here */
    pConfigInfo->CONNECT_TIMEOUT    =  35000;
    pConfigInfo->ConnectionFlags    =  TSFLAG_COMPRESSION|TSFLAG_BITMAPCACHE;
    pConfigInfo->Autologon          =  0;
    pConfigInfo->UseRegistry        =  1;
    pConfigInfo->LoginWait          =  1;
    pConfigInfo->bTranslateStrings  =  0;
    pConfigInfo->bUnicode           =  0;
    pConfigInfo->KeyboardHook       =  TCLIENT_KEYBOARD_HOOK_FULLSCREEN;


     //
     // Clear the configuration info and the INI-file name.
     //

     ZeroMemory(pConfigInfo, sizeof(*pConfigInfo));
     ZeroMemory(szIniFileName, sizeof(szIniFileName));

    // LoadSmClientFile(szIniFileName, _MAX_PATH, szLang); 
    
    if(!_wgetcwd (
            szIniFileName,
            (int)(dwIniFileNameLen - wcslen(SMCLIENT_INI) - 1))
            )
    {
        TRACE((ERROR_MESSAGE, "Current directory length too long.\n"));
    }

    if ( 0 == *szIniFileName )
	{
		CHAR szaIniFileName[_MAX_PATH];
	
		TRACE((WARNING_MESSAGE, "Reading ASCII working dir\n"));
	
        DWORD_PTR dwINILen = wcslen(SMCLIENT_INI);
		if (!_getcwd (
			szaIniFileName,
			(int)(sizeof(szaIniFileName) - dwINILen - 1))
		)
		{
			 TRACE((ERROR_MESSAGE, "Current directory length too long.\n"));
		}
		else
		{
			 _snwprintf(szIniFileName, dwIniFileNameLen, L"%S", szaIniFileName );
            szIniFileName[ dwIniFileNameLen - 1 ] = 0;
		}
		//if ( wcslen( szIniFileName ) > dwIniFileNameLen - wcslen(SMCLIENT_INI) - strlen(szLang) - 2 )
		if ( wcslen( szIniFileName ) > dwIniFileNameLen - wcslen(SMCLIENT_INI) - 2 )
		{
			 TRACE(( ERROR_MESSAGE, "Current directory length too long.\n"));

			 szIniFileName[0] = 0;
			 return;
		}
	}
	// add '\' at the end if there isn't one
	if (szIniFileName[wcslen(szIniFileName)-1]!=L'\\')
	{
		 wcscat(szIniFileName, L"\\");
	}

    wcscat(szIniFileName, SMCLIENT_INI);

//    nNew = _WrpGetPrivateProfileIntW(
    nNew = GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"timeout",
            600,
            szIniFileName);

    if (nNew)
    {
        pConfigInfo->WAIT4STR_TIMEOUT = nNew * 1000;
        TRACE((INFO_MESSAGE, "New timeout: %d seconds\n", nNew));
    }

//    nNew = _WrpGetPrivateProfileIntW(
    nNew = GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"contimeout",
            35,
            szIniFileName);

    if (nNew)
    {
        pConfigInfo->CONNECT_TIMEOUT = nNew * 1000;
        TRACE((INFO_MESSAGE, "New timeout: %d seconds\n", nNew));
    }

    pConfigInfo->Autologon =
//        _WrpGetPrivateProfileIntW(
        GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"Autologon",
            0,
            szIniFileName);

    pConfigInfo->UseRegistry =
//        _WrpGetPrivateProfileIntW(
        GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"UseRegistry",
            1,
            szIniFileName);

    pConfigInfo->LoginWait =
//        _WrpGetPrivateProfileIntW(
        GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"LoginWait",
            1,
            szIniFileName);

    pConfigInfo->bTranslateStrings =
//        _WrpGetPrivateProfileIntW(
        GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"TranslateStrings",
            0,
            szIniFileName);

    pConfigInfo->bUnicode =
//        _WrpGetPrivateProfileIntW(
        GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"Unicode",
            0,
            szIniFileName);

    pConfigInfo->KeyboardHook =
//        _WrpGetPrivateProfileIntW(
        GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"KeyboardHook",
            0,
            szIniFileName);

    pConfigInfo->ConnectionFlags = 0;
    bFlag =
//        _WrpGetPrivateProfileIntW(
        GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"LowSpeed",
            0,
            szIniFileName);
    if (bFlag)
        pConfigInfo->ConnectionFlags |=TSFLAG_COMPRESSION;

    bFlag =
//        _WrpGetPrivateProfileIntW(
        GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"PersistentCache",
            0,
            szIniFileName);
    if (bFlag)
        pConfigInfo->ConnectionFlags |=TSFLAG_BITMAPCACHE;

    bFlag =
//        _WrpGetPrivateProfileIntW(
        GetPrivateProfileIntW(
            TCLIENT_INI_SECTION,
            L"FullScreen",
            0,
            szIniFileName);
    if (bFlag)
        pConfigInfo->ConnectionFlags |=TSFLAG_FULLSCREEN;

    // read the strings
//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"StartRun",
           RUN_MENU,
           pConfigInfo->strStartRun,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"StartLogoff",
           START_LOGOFF,
           pConfigInfo->strStartLogoff,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"StartRunAct",
           RUN_ACT,
           pConfigInfo->strStartRun_Act,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"RunBox",
           RUN_BOX,
           pConfigInfo->strRunBox,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"WinLogon",
           WINLOGON_USERNAME,
           pConfigInfo->strWinlogon,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"WinLogonAct",
           WINLOGON_ACT,
           pConfigInfo->strWinlogon_Act,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"PriorWinLogon",
           PRIOR_WINLOGON,
           pConfigInfo->strPriorWinlogon,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"PriorWinLogonAct",
           PRIOR_WINLOGON_ACT,
           pConfigInfo->strPriorWinlogon_Act,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"NoSmartcard",
           NO_SMARTCARD_UI,
           pConfigInfo->strNoSmartcard,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"Smartcard",
           SMARTCARD_UI,
           pConfigInfo->strSmartcard,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"SmartcardAct",
           SMARTCARD_UI_ACT,
           pConfigInfo->strSmartcard_Act,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
            TCLIENT_INI_SECTION,
            L"LoginString",
            L"",
            pConfigInfo->strLogonFmt,
            MAX_STRING_LENGTH,
            szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"NTSecurity",
           WINDOWS_NT_SECURITY,
           pConfigInfo->strNTSecurity,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"NTSecurityAct",
           WINDOWS_NT_SECURITY_ACT,
           pConfigInfo->strNTSecurity_Act,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"SureLogoff",
           ARE_YOU_SURE,
           pConfigInfo->strSureLogoff,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"SureLogoffAct",
           SURE_LOGOFF_ACT,
           pConfigInfo->strSureLogoffAct,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"LogonErrorMessage",
           LOGON_ERROR_MESSAGE,
           pConfigInfo->strLogonErrorMessage,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"LogonDisabled",
           LOGON_DISABLED_MESSAGE,
           pConfigInfo->strLogonDisabled,
           MAX_STRING_LENGTH,
           szIniFileName);

    _snwprintf(szBuffDef, sizeof(szBuffDef) / sizeof( WCHAR ) , L"%S", CLIENT_CAPTION);
    szBuffDef[MAX_STRING_LENGTH - 1] = 0;

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"UIClientCaption",
           szBuffDef,
           pConfigInfo->strClientCaption,
           MAX_STRING_LENGTH,
           szIniFileName);

    _snwprintf(szBuffDef, sizeof(szBuffDef) / sizeof( WCHAR ), L"%S", DISCONNECT_DIALOG_BOX);
    szBuffDef[MAX_STRING_LENGTH - 1] = 0;
//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"UIDisconnectDialogBox",
           szBuffDef,
           pConfigInfo->strDisconnectDialogBox,
           MAX_STRING_LENGTH,
           szIniFileName);

    _snwprintf(szBuffDef, sizeof(szBuffDef) / sizeof( WCHAR ), L"%S", YES_NO_SHUTDOWN);
    szBuffDef[MAX_STRING_LENGTH - 1] = 0;
//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"UIYesNoDisconnect",
           szBuffDef,
           pConfigInfo->strYesNoShutdown,
           MAX_STRING_LENGTH,
           szIniFileName);

    _snwprintf(szBuffDef, sizeof(szBuffDef) / sizeof( WCHAR ), L"%S", CLIENT_EXE);
    szBuffDef[MAX_STRING_LENGTH - 1] = 0;
//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"ClientImage",
           szBuffDef,
           pConfigInfo->strClientImg,
           MAX_STRING_LENGTH,
           szIniFileName);

    szBuffDef[0] = 0;
//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"ClientDebugger",
           szBuffDef,
           pConfigInfo->strDebugger,
           MAX_STRING_LENGTH,
           szIniFileName);

    _snwprintf(szBuffDef, sizeof(szBuffDef) / sizeof( WCHAR ), L"%s", NAME_MAINCLASS);
    szBuffDef[MAX_STRING_LENGTH - 1] = 0;
//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"UIMainWindowClass",
           szBuffDef,
           pConfigInfo->strMainWindowClass,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"ClientCmdLine",
           L"",
           pConfigInfo->strCmdLineFmt,
           4 * MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
           TCLIENT_INI_SECTION,
           L"ConsoleExtension",
           L"",
           pConfigInfo->strConsoleExtension,
           MAX_STRING_LENGTH,
           szIniFileName);

//    _WrpGetPrivateProfileStringW(
    GetPrivateProfileStringW(
            TCLIENT_INI_SECTION,
            L"sessionlist",
            L"",
            pConfigInfo->strSessionListDlg,
            MAX_STRING_LENGTH,
            szIniFileName);

}

/*++
 *  Function:
 *      DllCanUnloadNow
 *
 *  Description:
 *      Used to determine whether the DLL can be unloaded by OLE
 *  Arguments:
 *      None.
 *  Return value:
 *      ...
 *
 --*/
STDAPI
DllCanUnloadNow(
    VOID
    )
{
    return _Module.GetLockCount() == 0 ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////

/*++
 *  Function:
 *      DllGetClassObject
 *
 *  Description:
 *      Returns a class factory to create an object of the requested type.
 *  Arguments:
 *      rclsid - ...
 *      riid - ...
 *      ppv - ...
 *  Return value:
 *      ...
 *
 --*/
STDAPI
DllGetClassObject(
    IN REFCLSID rclsid,
    IN REFIID riid,
    OUT LPVOID* ppv
    )
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/*++
 *  Function:
 *      DllRegisterServer
 *
 *  Description:
 *      DllRegisterServer - Adds entries to the system registry
 *  Arguments:
 *      None.
 *  Return value:
 *      ...
 *
 --*/
STDAPI
DllRegisterServer(
    VOID
    )
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/*++
 *  Function:
 *      DllUnregisterServer
 *
 *  Description:
 *      DllUnregisterServer - Removes entries from the system registry
 *  Arguments:
 *      None.
 *  Return value:
 *      ...
 *
 --*/
STDAPI
DllUnregisterServer(
    VOID
    )
{
    _Module.UnregisterServer();
    return S_OK;
}

} // extern "C"

#ifdef _M_IA64

//$WIN64: Don't know why _WndProcThunkProc isn't defined 

extern "C" LRESULT CALLBACK _WndProcThunkProc(HWND, UINT, WPARAM, LPARAM)
{
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\connlist.c ===
//
// connlist.c
//
// Handles a linked list which will keep track of all the TCLIENT2 handles.
//
// Why is this needed?
//
// I am using SetTimer() callbacks to keep track of idled scripts.
// The problem is, there is no way for me to tell exactly which
// handle executed which timer.  The only way to do this is to keep
// a list of all the handles, and their associated timer id.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//
// 03-08-2001 - Fixed bug regarding last node on list not being cleaned.


#include "connlist.h"


// Linked handle list
typedef struct _ConnList
{
    struct _ConnList *Next;
    struct _ConnList *Prev;
    HANDLE Handle;
    UINT_PTR TimerId;
    DWORD msStartTime;
} ConnList;

// This is the global variable, representing the head of the list
ConnList *Head = NULL;


// This queue is used to prevent two threads from messing
// with the list at the same time
CRITICAL_SECTION ListQueue;


// Indicates the number of items in the list
DWORD ItemCount;
DWORD AccessCount;


// Internal function prototypes
void T2ConnList_EnterQueue(void);
void T2ConnList_LeaveQueue(void);


// T2ConnList_EnterQueue
//
// A "safe" critical section - no critical section needed.
//
// No return value.

void T2ConnList_EnterQueue(void)
{
    if (ItemCount == 0 && AccessCount == 0)
        InitializeCriticalSection(&ListQueue);

    ++AccessCount;

    EnterCriticalSection(&ListQueue);
}


// T2ConnList_LeaveQueue
//
// A "safe" critical section - critical section automatically
// deletes itself when no longer needed.
//
// No return value.

void T2ConnList_LeaveQueue(void)
{
    LeaveCriticalSection(&ListQueue);

    --AccessCount;

    if (ItemCount == 0 && AccessCount == 0)
        DeleteCriticalSection(&ListQueue);
}


// T2ConnList_AddHandle
//
// Adds a new handle to the connection list.  Additionally
// this will also set the TimerId and msStartTime properties
// for the new entry.
//
// Returns TRUE if the handle was successfully added.
// FALSE otherwise.

BOOL T2ConnList_AddHandle(HANDLE Handle, UINT_PTR TimerId, DWORD msStartTime)
{
    ConnList *Node;

    // Sanity check
    if (Handle == NULL || Handle == INVALID_HANDLE_VALUE)
        return FALSE;

    // Get access to the list
    T2ConnList_EnterQueue();

    Node = Head;

    // Loop through each item, ensuring the item does not already exist
    for (; Node != NULL && Node->Handle != Handle; Node = Node->Next);

    // If we didn't reach the end of the list, it already exists
    if (Node != NULL) {

        // Simply modify the parameters instead of adding it
        Node->TimerId = TimerId;
        Node->msStartTime = msStartTime;

        // Release access from the list
        T2ConnList_LeaveQueue();

        return TRUE;
    }

    // It doesn't exist, allocate a new node for the handle
    Node = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof (ConnList));

    if (Node == NULL) {

        // Allocation failed, release access from the list
        T2ConnList_LeaveQueue();

        return FALSE;
    }

    // Begin adding it to the list by setting the new node at the head
    if (Head != NULL)
        Head->Prev = Node;

    Node->Next = Head;
    Head = Node;

    // Record the parameters
    Node->Handle = Handle;
    Node->TimerId = TimerId;
    Node->msStartTime = msStartTime;

    // Increment the number of handles in the list
    ++ItemCount;

    // Release access from the list and return
    T2ConnList_LeaveQueue();

    return TRUE;
}


// T2ConnList_RemoveHandle
//
// Removes a handle from the list if it exists.
//
// No return value.

void T2ConnList_RemoveHandle(HANDLE Handle)
{
    ConnList *Node;

    // Sanity check
    if (Handle == NULL || Handle == INVALID_HANDLE_VALUE)
        return;

    // Gain access to the list
    T2ConnList_EnterQueue();

    Node = Head;

    // First find the handle in the list
    for (; Node != NULL && Node->Handle != Handle; Node = Node->Next);

    // If the Node pointer is NULL, then the handle didn't exist
    if (Node == NULL) {

        // Just release access from the list, and return
        T2ConnList_LeaveQueue();

        return;
    }

    // Handle found, now unlink it from the list
    if (Node->Next != NULL)
        Node->Next->Prev = Node->Prev;

    if (Node->Prev != NULL)
        Node->Prev->Next = Node->Next;

    // Costin and Hammad's Fix!! Yay!!
    if (Node == Head)
        Head = Node->Next;

    // Free the handle itself
    HeapFree(GetProcessHeap(), 0, Node);

    // Decrement the handle count in the list
    --ItemCount;

    // Release access from the list
    T2ConnList_LeaveQueue();
}


// T2ConnList_GetData
//
// Gets any non-null pointer parameters for the specified
// handle from the list.
//
// Returns TRUE if the handle was found, FALSE otherwise.

BOOL T2ConnList_GetData(HANDLE Handle, UINT_PTR *TimerId, DWORD *msStartTime)
{
    ConnList *Node;

    // Gain access to the list
    T2ConnList_EnterQueue();

    Node = Head;

    // First find the handle in the list
    for (; Node != NULL && Node->Handle != Handle; Node = Node->Next);

    // If the Node pointer is NULL, then the handle didn't exist
    if (Node == NULL) {

        // Just release access from the list, and return an error
        T2ConnList_LeaveQueue();

        return FALSE;
    }

    // Simply enter in the parameters
    if (TimerId != NULL)
        *TimerId = Node->TimerId;

    if (msStartTime != NULL)
        *msStartTime = Node->msStartTime;

    // Release access from the list, and return success
    T2ConnList_LeaveQueue();

    return TRUE;
}


// T2ConnList_SetData
//
// Sets/changes all of the handle's parameters.
//
// Returns TRUE if the handle was found, FALSE otherwise.

BOOL T2ConnList_SetData(HANDLE Handle, UINT_PTR TimerId, DWORD msStartTime)
{
    ConnList *Node;

    // Gain access to the list
    T2ConnList_EnterQueue();

    Node = Head;

    // First find the handle in the list
    for (; Node != NULL && Node->Handle != Handle; Node = Node->Next);

    // If the Node pointer is NULL, then the handle didn't exist
    if (Node == NULL) {

        // Just release access from the list, and return an error
        T2ConnList_LeaveQueue();

        return FALSE;
    }

    // Change the parameters
    Node->TimerId = TimerId;
    Node->msStartTime = msStartTime;

    // Release access from the list, and return success
    T2ConnList_LeaveQueue();

    return TRUE;
}


// T2ConnList_SetTimerId
//
// Sets the timer id parameter of the specified handle.
//
// Returns TRUE on success and FALSE on failure.

BOOL T2ConnList_SetTimerId(HANDLE Handle, UINT_PTR TimerId)
{
    ConnList *Node;

    // Gain access to the list
    T2ConnList_EnterQueue();

    Node = Head;

    // First find the handle in the list
    for (; Node != NULL && Node->Handle != Handle; Node = Node->Next);

    // If the Node pointer is NULL, then the handle didn't exist
    if (Node == NULL) {

        // Just release access from the list, and return an error
        T2ConnList_LeaveQueue();

        return FALSE;
    }

    // Change it
    Node->TimerId = TimerId;

    // Release access from the list, and return success
    T2ConnList_LeaveQueue();

    return TRUE;
}


// T2ConnList_SetStartTime
//
// Sets the start time parameter of the specified handle.
//
// Returns TRUE on success and FALSE on failure.

BOOL T2ConnList_SetStartTime(HANDLE Handle, DWORD msStartTime)
{
    ConnList *Node;

    // Gain access to the list
    T2ConnList_EnterQueue();

    Node = Head;

    // First find the handle in the list
    for (; Node != NULL && Node->Handle != Handle; Node = Node->Next);

    // If the Node pointer is NULL, then the handle didn't exist
    if (Node == NULL) {

        // Just release access from the list, and return an error
        T2ConnList_LeaveQueue();

        return FALSE;
    }

    // Change it
    Node->msStartTime = msStartTime;

    // Release access from the list, and return success
    T2ConnList_LeaveQueue();

    return TRUE;
}


// T2ConnList_FindHandleByTimerId
//
// Finds the first handle with the specified matching timer id.
//
// Returns the handle on success, or NULL if a handle
// with the specified timer id did not existed.

HANDLE T2ConnList_FindHandleByTimerId(UINT_PTR TimerId)
{
    HANDLE Handle;
    ConnList *Node;

    // Gain access to the list
    T2ConnList_EnterQueue();

    Node = Head;

    // Find the first matching timer in the list
    for (; Node != NULL && Node->TimerId != TimerId; Node = Node->Next);

    // If the Node pointer is NULL, then a handle didn't exist
    if (Node == NULL) {

        // Just release access from the list, and return an error
        T2ConnList_LeaveQueue();

        return NULL;
    }

    // Found a handle, record it
    Handle = Node->Handle;

    // Release access from the list and return our found handle
    T2ConnList_LeaveQueue();

    return Handle;
}


// T2ConnList_FindHandleByStartTime
//
// Finds the first handle with the specified matching start time.
//
// Returns the handle on success, or NULL if a handle
// with the specified start time did not exist.

HANDLE T2ConnList_FindHandleByStartTime(DWORD msStartTime)
{
    HANDLE Handle;
    ConnList *Node;

    // Gain access to the list
    T2ConnList_EnterQueue();

    Node = Head;

    // Find the first matching start time in the list
    for (; Node != NULL && Node->msStartTime != msStartTime;
            Node = Node->Next);

    // If the Node pointer is NULL, then a handle didn't exist
    if (Node == NULL) {

        // Just release access from the list, and return an error
        T2ConnList_LeaveQueue();

        return NULL;
    }

    // Found a handle, record it
    Handle = Node->Handle;

    // Release access from the list and return our found handle
    T2ConnList_LeaveQueue();

    return Handle;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\connlist.h ===
//
// connlist.h
//
// Defines an internal API used to manage a linked list
// containing all the TCLIENT2 connection handles and timer data.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#ifndef INC_CONNLIST_H
#define INC_CONNLIST_H


#include <windows.h>
#include <crtdbg.h>


BOOL T2ConnList_AddHandle(HANDLE Handle, UINT_PTR TimerId, DWORD msStartTime);
void T2ConnList_RemoveHandle(HANDLE Handle);
BOOL T2ConnList_GetData(HANDLE Handle, UINT_PTR *TimerId, DWORD *msStartTime);
BOOL T2ConnList_SetData(HANDLE Handle, UINT_PTR TimerId, DWORD msStartTime);
BOOL T2ConnList_SetTimerId(HANDLE Handle, UINT_PTR TimerId);
BOOL T2ConnList_SetStartTime(HANDLE Handle, DWORD msStartTime);
HANDLE T2ConnList_FindHandleByTimerId(UINT_PTR TimerId);
HANDLE T2ConnList_FindHandleByStartTime(DWORD msStartTime);


#endif // INC_CONNLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\tclnthlp.h ===
//
// tclnthlp.h
//
// Defines headers for tclient2.c helper functions.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#ifndef INC_TCLNTHLP_H
#define INC_TCLNTHLP_H


#include <windows.h>
#include <crtdbg.h>
#include "apihandl.h"


// In tclient.dll, this is the seperator for multiple strings
#define CHAT_SEPARATOR          L"<->"
#define WAIT_STR_DELIMITER      L'|'
#define WAIT_STRING_TIMEOUT     0x7FFFFFFF // INT_MAX


LPCSTR T2SetBuildNumber(TSAPIHANDLE *T2Handle);
ULONG_PTR T2CopyStringWithoutSpaces(LPWSTR Dest, LPCWSTR Source);
void T2AddTimeoutToString(LPWSTR Buffer, UINT Timeout);
ULONG_PTR T2MakeMultipleString(LPWSTR Buffer, LPCWSTR *Strings);


#endif // INC_TCLNTHLP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\key.c ===
//
// key.c
//
// Handles all keyboard input messages sent to the server.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//


#include "apihandl.h"
#include "tclient2.h"


// Average number of characters per word
#define AVG_CHARS_PER_WORD      6


// Max WPM before setting delay to 0
#define MAX_WORDS_PER_MIN       1000


// This macro calculates the delay between each character
// (in milliseconds) according to the specified WPM
#define CALC_DELAY_BETWEEN_CHARS(WPM) \
        (60000 / (WPM * AVG_CHARS_PER_WORD))

// This constant simply defines the default delay
// between each character according to the default
// words per minute specified in TCLIENT2.H
static const UINT DEFAULT_DELAY_BETWEEN_CHARS =
        CALC_DELAY_BETWEEN_CHARS(T2_DEFAULT_WORDS_PER_MIN);


//
//   The Foucher Formula
// (Defining MS. Per Char)
//
//         60000
//       ---------
//       WPM * CPW
//


// Internal Helper Function Prototypes
static LPARAM KeyGenParam(UINT Message, BOOL IsAltDown, int vKeyCode);

static BOOL KeyCharToVirt(WCHAR KeyChar, int *vKeyCode,
        BOOL *RequiresShift);

static BOOL KeyVirtToChar(int vKeyCode, WCHAR *KeyChar);

static LPCSTR KeySendVirtMessage(HANDLE Connection, UINT Message,
    int vKeyCode);

static LPCSTR KeySendCharMessage(HANDLE Connection, UINT Message,
    WCHAR KeyChar);


// Macros to quick return the specified keystate
#define ISALTDOWN       ((TSAPIHANDLE *)Connection)->IsAltDown
#define ISSHIFTDOWN     ((TSAPIHANDLE *)Connection)->IsShiftDown
#define ISCTRLDOWN      ((TSAPIHANDLE *)Connection)->IsCtrlDown


/*

R - Specifies the repeat count for the current message. The value is
        the number of times the keystroke is autorepeated as a result
        of the user holding down the key. If the keystroke is held long
        enough, multiple messages are sent. However, the repeat count
        is not cumulative. This value is always 1 for WM_SYSKEYUP and
        WM_KEYUP.

S - Specifies the scan code. The value depends on the original
        equipment manufacturer (OEM).

E - Specifies whether the key is an extended key, such as the
        right-hand ALT and CTRL keys that appear on an enhanced 101- or
        102-key keyboard. The value is 1 if it is an extended key;
        otherwise, it is 0.

X - Reserved; do not use.

C - Specifies the context code. The value is always 0 for a
        WM_KEYDOWN and WM_KEYUP message or if the message is posted to
        the active window because no window has the keyboard focus.
        For WM_SYSKEYDOWN and WM_SYSKEYUP, the value is 1 if the ALT
        key is down while the message is activated.

P - Specifies the previous key state. The value is 1 if the key is down
        before the message is sent, or it is zero if the key is up.
        The value is always 1 for a WM_KEYUP or WM_SYSKEYUP message.

T - Specifies the transition state. The value is always 0 for a
        WM_KEYDOWN or WM_SYSKEYDOWN message, and 1 for a
        WM_KEYUP or a WM_SYSKEYUP message.

TPCXXXXESSSSSSSSRRRRRRRRRRRRRRRR
10987654321098765432109876543210
 |         |         |         |
30        20        10         0

*/


// KeyGenParam
//
// Based on the specified information, this generates
// a valid LPARAM as documented by Windows keyboard
// messages.  Quick documentation is provided above.
//
// Returns the generated LPARAM, no failure code.

static LPARAM KeyGenParam(
    UINT Message,
    BOOL IsAltDown,
    int vKeyCode)
{
    // Set the repeat count for all key messages (1)
    DWORD Param = 0x00000001; // Set zBit 0-15 (WORD) as value 1

    // Next set the OEM Scan code for the virtual key code
    DWORD ScanCode = (DWORD)((BYTE)MapVirtualKey((UINT)vKeyCode, 0));
    if (ScanCode != 0)
        Param |= (ScanCode << 16); // Set zBits 16-23

    // Set the extended flag for extended keys
    switch (vKeyCode) {

        // Add more keys here
        case VK_DELETE:
        case VK_LWIN:
        case VK_RWIN:
            Param |= 0x01000000;
            break;
    }
    // Is the ALT Key down for SYS_ messages?
    if (IsAltDown)
        Param |= 0x20000000; // Enable zBit 29

    // Set the previous key and transition state
    if (Message == WM_SYSKEYUP || Message == WM_KEYUP)
        Param |= 0xC0000000; // Enable zBit 30 and 31

    // Convert the DWORD to an LPARAM and return
    return (LPARAM)Param;
}


// KeyCharToVirt
//
// Maps the specified character to a virtual key code.
// This will also specify whether or not shift is required for
// the virtual key code have the same effect.  For example:
// the letter 'K'.  Sending VK_K is not enough shift must be
// down to get the capital 'K'.
//
// Returns TRUE of the data has been successfully
// translated, FALSE otherwise.  If FALSE, pointers have
// been unmodified.

static BOOL KeyCharToVirt(
    WCHAR KeyChar,
    int *vKeyCode,
    BOOL *RequiresShift)
{
    // Get the key data
    SHORT ScanData = VkKeyScanW(KeyChar);

    // Check Success/Failure of API call
    if (LOBYTE(ScanData) == -1 && HIBYTE(ScanData) == -1)
        return FALSE;

    // Set the data
    if (vKeyCode != NULL)
        *vKeyCode = LOBYTE(ScanData);

    if (RequiresShift != NULL)
        *RequiresShift = (HIBYTE(ScanData) & 0x01);

    return TRUE;
}


// KeyVirtToChar
//
// Translates the specified virtual key code into a character.
// There are some virtual key codes that do not have
// character representations, such as the arrow keys.  In this
// case, the function fails.
//
// Returns TRUE if the virtual key code was successfully
// translated, FALSE otherwise.  If FALSE, the KeyChar
// pointer has not been modified.

static BOOL KeyVirtToChar(
    int vKeyCode,
    WCHAR *KeyChar)
{
    // Use Win32 API to map, two is the value used for
    // vKey->Char, no type is defined for easier
    // readability there :-(  [as of Jan 2001]
    UINT Result = MapVirtualKeyW((UINT)vKeyCode, 2);

    if (Result == 0)
        return FALSE;

    // Set the data
    if (KeyChar != NULL)
        *KeyChar = (WCHAR)Result;

    return TRUE;
}


// KeySendVirtMessage
//
// This routine corrects and sends a key message to the server.
// WM_SYSKEY messages are converted over to WM_KEY messages so
// that they can be transferred over the wire correctly - they
// still work though.  An LPARAM is automatically generated.
// Support is only implemented for the messages:
// WM_KEYDOWN and WM_KEYUP (and the SYS versions).
//
// The return value is a string specifying an error if one
// occured, otherwise the process was successful and NULL
// is returned.

static LPCSTR KeySendVirtMessage(
    HANDLE Connection,
    UINT Message,
    int vKeyCode)
{
    // Wait until the user unpauses the script (if paused)
    T2WaitForPauseInput(Connection);

    // Filter out invalid messages, and convert SYS messages
    switch (Message) {

        case WM_SYSKEYDOWN:
        case WM_KEYDOWN:

            Message = WM_KEYDOWN;
            break;

        case WM_SYSKEYUP:
        case WM_KEYUP:

            Message = WM_KEYUP;
            break;

        default:

            return "Unsupported keyboard message";
    }

    // Trigger specific actions for special virtual key codes
    switch (vKeyCode) {

        // CTRL Key message
        case VK_CONTROL:
        case VK_LCONTROL:
        case VK_RCONTROL: {

            switch (Message) {

                case WM_KEYDOWN:

                    // Flag CTRL as down
                    if (ISCTRLDOWN == TRUE)
                        return NULL;
                    ISCTRLDOWN = TRUE;
                    break;

                case WM_KEYUP:

                    // Flag CTRL as up
                    if (ISCTRLDOWN == FALSE)
                        return NULL;
                    ISCTRLDOWN = FALSE;
                    break;
            }
        }
        // SHIFT Key message
        case VK_SHIFT:
        case VK_LSHIFT:
        case VK_RSHIFT: {

            switch (Message) {

                case WM_KEYDOWN:

                    // Flag SHIFT as down
                    if (ISSHIFTDOWN == TRUE)
                        return NULL;
                    ISSHIFTDOWN = TRUE;
                    break;

                case WM_KEYUP:

                    // Flag SHIFT as up
                    if (ISSHIFTDOWN == FALSE)
                        return NULL;
                    ISSHIFTDOWN = FALSE;
                    break;
            }
            break;
        }
        // ALT Key message
        case VK_MENU:
        case VK_LMENU:
        case VK_RMENU: {

            switch (Message) {

                case WM_KEYDOWN:

                    // Flag ALT as down
                    if (ISALTDOWN == TRUE)
                        return NULL;
                    ISALTDOWN = TRUE;
                    break;

                case WM_KEYUP:

                    // Flag ALT as up
                    if (ISALTDOWN == FALSE)
                        return NULL;
                    ISALTDOWN = FALSE;
                    break;
            }
            break;
        }
    }
    // Send the message over the wire
    return T2SendData(Connection, Message, (WPARAM)vKeyCode,
            KeyGenParam(Message, ISALTDOWN, vKeyCode));
}


// KeySendCharMessage
//
// This routine automatically translates a charater into its
// virtual key code counterpart and passes the code onto the
// KeySendVirtMessage.  Shift reliant characters will NOT
// have the SHIFT key automatically be sent over as well,
// because this would be more difficult to manage the shift key
// locally.
//
// Only WM_KEYDOWN and WM_KEYUP messages (and their SYS versions)
// are supported. Unsupported keyboard messages will cause the
// routine to fail.
//
// The return value is a string specifying an error if one
// occured, otherwise the process was successful and NULL
// is returned.

static LPCSTR KeySendCharMessage(HANDLE Connection, UINT Message,
        WCHAR KeyChar)
{
    // Wait until the user unpauses the script (if paused)
    T2WaitForPauseInput(Connection);

    // Only the following messages are supported
    if (Message == WM_KEYDOWN || Message == WM_KEYUP ||
            Message == WM_SYSKEYDOWN || Message == WM_SYSKEYUP) {

        int vKeyCode = 0;

        // Translate the character to a virtual key code
        if (KeyCharToVirt(KeyChar, &vKeyCode, NULL) == FALSE)
            return "Failed to map character to a virtual key code";

        // Submit the virtual key code
        return KeySendVirtMessage(Connection, Message, vKeyCode);
    }
    // WM_CHAR and WM_SYSCHAR is not used over this tclient connection
    return "Unsupported keyboard message";
}


// T2SetDefaultWPM
//
// Every TCLIENT connection has it's own special properties, and this
// includes the "Words Per Minute" property.  The property represents
// the default speed in which TCLIENT is to type text to the server.
// The scripter can override this by using the optional parameter
// after TypeText() to indicate the temporary words per minute.
//
// This routine sets the default words per minute as described above.
//
// The return value is NULL if successful, otherwise a string
// describing the error.

TSAPI LPCSTR T2SetDefaultWPM(HANDLE Connection, DWORD WordsPerMinute)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Not a valid connection";

    // If WPM is set to 0, use the default
    if (WordsPerMinute == 0) {

        WordsPerMinute = T2_DEFAULT_WORDS_PER_MIN;
        ((TSAPIHANDLE *)Connection)->DelayPerChar =
                DEFAULT_DELAY_BETWEEN_CHARS;
    }

    // If WPM is suggested to be insanely high, set the delay to
    // 0 instead of trying to calculate it
    else if (WordsPerMinute > MAX_WORDS_PER_MIN)
        ((TSAPIHANDLE *)Connection)->DelayPerChar = 0;

    // Otherwise, calculate the words per minute into
    // the delay value used in Sleep() calls
    else
        ((TSAPIHANDLE *)Connection)->DelayPerChar =
                CALC_DELAY_BETWEEN_CHARS(WordsPerMinute);

    // Record the words per minute if the user wants this value back
    ((TSAPIHANDLE *)Connection)->WordsPerMinute = WordsPerMinute;

    return NULL;
}


// T2GetDefaultWPM
//
// Every TCLIENT connection has it's own special properties, and this
// includes the "Words Per Minute" property.  The property represents
// the default speed in which TCLIENT is to type text to the server.
// The scripter can override this by using the optional parameter
// after TypeText() to indicate the temporary words per minute.
//
// This routine retrieves the current default words per minute
// as described above.
//
// The return value is NULL if successful, otherwise a string
// describing the error.

TSAPI LPCSTR T2GetDefaultWPM(HANDLE Connection, DWORD *WordsPerMinute)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Not a valid connection";

    __try {

        // Attempt to set a value at the specified pointer
        *WordsPerMinute = ((TSAPIHANDLE *)Connection)->WordsPerMinute;
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        _ASSERT(FALSE);

        // Nope, it failed.
        return "Invalid WordsPerMinute pointer";
    }

    return NULL;
}


//
// Keyboard Routines
//
// These functions are used to make keyboard handling easier.
// They come in two flavors, character version, and
// virtual keycode version.  The virtual keycode functions
// are prefixed with a "V" after the T2 to indicate so.
//


// T2KeyAlt
//
// Allows for easy ability to do an ALT + Key combonation.
// For example, ALT-F in a typical Windows application will
// open up the File menu.
//
// Returns NULL if successful, otherwise a string describing
// the failure.


// Character Version
TSAPI LPCSTR T2KeyAlt(HANDLE Connection, WCHAR KeyChar)
{
    // Don't validate the connection handle here,
    // it is done within T2KeyDown, and no reason
    // two double check it.

    // First press the ALT key
    LPCSTR Result = T2VKeyDown(Connection, VK_MENU);
    if (Result != NULL)
        return Result;

    // Be realistic
    T2WaitForLatency(Connection);

    // Next press and release the specified custom key
    Result = T2KeyPress(Connection, KeyChar);

    // Be realistic
    T2WaitForLatency(Connection);

    // Finally, let up on the ALT key
    T2VKeyUp(Connection, VK_MENU);

    return Result;
}


// Virtual Key Code Version
TSAPI LPCSTR T2VKeyAlt(HANDLE Connection, INT vKeyCode)
{
    // Don't validate the connection handle here,
    // it is done within T2VKeyDown, and no reason
    // two double check it.

    // First press the ALT key
    LPCSTR Result = T2VKeyDown(Connection, VK_MENU);
    if (Result != NULL)
        return Result;

    // Be realistic
    T2WaitForLatency(Connection);

    // Next press and release the specified custom key
    Result = T2VKeyPress(Connection, vKeyCode);

    // Be realistic
    T2WaitForLatency(Connection);

    // Finally, let up on the ALT key
    T2VKeyUp(Connection, VK_MENU);

    return Result;
}


// T2KeyCtrl
//
// Allows for easy ability to do a CTRL + Key combonation.
// For example, CTRL-C in a typical Windows application will
// copy a selected item to the clipboard.
//
// Returns NULL if successful, otherwise a string describing
// the failure.


// Character Version
TSAPI LPCSTR T2KeyCtrl(HANDLE Connection, WCHAR KeyChar)
{
    // Don't validate the connection handle here,
    // it is done within T2KeyDown, and no reason
    // two double check it.

    // First press the CTRL key
    LPCSTR Result = T2VKeyDown(Connection, VK_CONTROL);
    if (Result != NULL)
        return Result;

    // Be realistic
    T2WaitForLatency(Connection);

    // Next press and release the specified custom key
    Result = T2KeyPress(Connection, KeyChar);

    // Be realistic
    T2WaitForLatency(Connection);

    // Finally, let up on the CTRL key
    T2VKeyUp(Connection, VK_CONTROL);

    return Result;
}


// Virtual Key Code Version
TSAPI LPCSTR T2VKeyCtrl(HANDLE Connection, INT vKeyCode)
{
    // Don't validate the connection handle here,
    // it is done within T2VKeyDown, and no reason
    // two double check it.

    // First press the CTRL key
    LPCSTR Result = T2VKeyDown(Connection, VK_CONTROL);
    if (Result != NULL)
        return Result;

    // Be realistic
    T2WaitForLatency(Connection);

    // Next press and release the specified custom key
    Result = T2VKeyPress(Connection, vKeyCode);

    // Be realistic
    T2WaitForLatency(Connection);

    // Finally, let up on the CTRL key
    T2VKeyUp(Connection, VK_CONTROL);

    return Result;
}


// T2KeyDown
//
// Presses and a key down, and holds it down until
// T2KeyUp is called.  This is useful for holding down SHIFT
// to type several letters in caps, etc.  NOTE: For character
// versions of this function, SHIFT will NOT automatically be
// pressed.  If you do a T2KeyDown(hCon, L'T'), a lowercase
// key may be the output!  You will need to manually press the
// SHIFT key using T2VKeyDown(hCon, VK_SHIFT).  Remember,
// these are low level calls.  TypeText() on the other hand,
// will automatically press/release SHIFT as needed.
//
// Returns NULL if successful, otherwise a string describing
// the failure.


// Character Version
TSAPI LPCSTR T2KeyDown(HANDLE Connection, WCHAR KeyChar)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Not a valid connection";

    // Simply send the WM_KEYDOWN message over the wire
    return KeySendCharMessage(Connection, WM_KEYDOWN, KeyChar);
}


// Virtual Key Code Version
TSAPI LPCSTR T2VKeyDown(HANDLE Connection, INT vKeyCode)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Not a valid connection";

    // Simply send the WM_KEYDOWN message over the wire
    return KeySendVirtMessage(Connection, WM_KEYDOWN, vKeyCode);
}


// T2KeyPress
//
// Presses and releases a key.  NOTE: For character
// versions of this function, SHIFT will NOT automatically be
// pressed.  If you do a T2KeyDown(hCon, L'T'), a lowercase
// key may be the output!  You will need to manually press the
// SHIFT key using T2VKeyDown(hCon, VK_SHIFT).  Remember,
// these are low level calls.  TypeText() on the other hand,
// will automatically press/release SHIFT as needed.
//
// Returns NULL if successful, otherwise a string describing
// the failure.


// Character Version
TSAPI LPCSTR T2KeyPress(HANDLE Connection, WCHAR KeyChar)
{
    // Don't validate the connection handle here,
    // it is done within T2VKeyDown, and no reason
    // two double check it.

    // First press the key
    LPCSTR Result = T2KeyDown(Connection, KeyChar);
    if (Result != NULL)
        return Result;

    // Be realistic
    T2WaitForLatency(Connection);

    // Then release it
    return T2KeyUp(Connection, KeyChar);
}


// Virtual Key Code Version
TSAPI LPCSTR T2VKeyPress(HANDLE Connection, INT vKeyCode)
{
    // Don't validate the connection handle here,
    // it is done within T2VKeyDown, and no reason
    // two double check it.

    // First press the key
    LPCSTR Result = T2VKeyDown(Connection, vKeyCode);
    if (Result != NULL)
        return Result;

    // Be realistic
    T2WaitForLatency(Connection);

    // Then release it
    return T2VKeyUp(Connection, vKeyCode);
}


// T2KeyUp
//
// Releases a key that has been pressed by the T2KeyDown
// function.  If the key is not down, behavior is undefined.
//
// Returns NULL if successful, otherwise a string describing
// the failure.


// Character Version
TSAPI LPCSTR T2KeyUp(HANDLE Connection, WCHAR KeyChar)
{
    // Simply send the WM_KEYUP message over the wire
    return KeySendCharMessage(Connection, WM_KEYUP, KeyChar);
}


// Virtual Key Code Version
TSAPI LPCSTR T2VKeyUp(HANDLE Connection, INT vKeyCode)
{
    // Simply send the WM_KEYUP message over the wire
    return KeySendVirtMessage(Connection, WM_KEYUP, vKeyCode);
}


// T2TypeText
//
// This handy function enumerates each character specified in the text
// and sends the required key messages over the wire to end up with
// the proper result.  The shift key is automatically pressed/depressed
// as needed for capital letters and acts as real user action.
// Additionally, the speed of typed text is indicated by the
// (optional) WordsPerMinute parameter.  If WordsPerMinute is 0 (zero),
// the default WordsPerMinute for the handle is used.
//
// Returns NULL if successful, otherwise a string describing
// the failure.

TSAPI LPCSTR T2TypeText(HANDLE Connection, LPCWSTR Text, UINT WordsPerMin)
{
    LPCSTR Result = NULL;
    int vKeyCode = 0;
    BOOL RequiresShift = FALSE;
    UINT DelayBetweenChars;
    BOOL ShiftToggler;

    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Not a valid connection";

    // First get the default delay between each character
    DelayBetweenChars = ((TSAPIHANDLE *)Connection)->DelayPerChar;

    // Get the current state of the shift key
    ShiftToggler = ISSHIFTDOWN;

    // If specified, use the custom WordsPerMinute
    if (WordsPerMin > 0)
        DelayBetweenChars = CALC_DELAY_BETWEEN_CHARS(WordsPerMin);

    // Enter the exception clause in case we have some bad
    // Text pointer, and we attempt to continue forever...
    __try {

        // Loop between each character until a null character is hit
        for (; *Text != 0; ++Text) {

            // First get the key code associated with the current character
            if (KeyCharToVirt(*Text, &vKeyCode, &RequiresShift) == FALSE) {

                // This should never happen, but Roseanne is still being
                // aired on channel 11, so you never know...
                _ASSERT(FALSE);

                return "Failed to map a character to a virtual key code";
            }

            // Press shift if we need
            if (RequiresShift == TRUE && ShiftToggler == FALSE)
                Result = KeySendVirtMessage(Connection, WM_KEYDOWN, VK_SHIFT);

            // Release shift if we need
            else if (RequiresShift == FALSE && ShiftToggler == TRUE)
                Result = KeySendVirtMessage(Connection, WM_KEYUP, VK_SHIFT);

            // Set the current shift state now
            ShiftToggler = RequiresShift;

            // We are not using T2VKeyPress() here because we need want
            // to prevent as many performance hits as possible, and in this
            // case we would be checking the Connection handle over and
            // over, in addition to making and new stacks etc,
            // which is quite pointless.

            // Press the current key down
            Result = KeySendVirtMessage(Connection, WM_KEYDOWN, vKeyCode);
            if (Result != NULL)
                return Result;

            // Release the current key
            Result = KeySendVirtMessage(Connection, WM_KEYUP, vKeyCode);
            if (Result != NULL)
                return Result;

            // Note we are not releasing shift if it is down, this is because
            // the next key may be caps as well, and normal users don't
            // press and release shift for each character (assuming they
            // didn't use the caps key...)

            // Delay for the specified amount of time to get accurate
            // count for WordsPerMinute
            Sleep(DelayBetweenChars);
        }

        // We are done going through all the text.  If we still have
        // shift down, release it at this point.
        if (ShiftToggler == TRUE)
            return KeySendVirtMessage(Connection, WM_KEYUP, VK_SHIFT);
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        // Uhm, shouldn't happen?
        _ASSERT(FALSE);

        return "Exception occured";
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\idletimr.h ===
//
// idletimr.h
//
// This file contains an API used to monitor idle clients.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//

#ifndef INC_IDLETIMR_H
#define INC_IDLETIMR_H


#include <windows.h>
#include <crtdbg.h>
#include <sctypes.h>
#include <tclient2.h>


// Initial wait time before reporting idle
#define WAIT_TIME       30000   // 30 seconds

// Wait time each step after an idle is found before reporting again
#define WAIT_TIME_STEP  10000   // 10 seconds


BOOL T2CreateTimerThread(PFNPRINTMESSAGE PrintMessage,
        PFNIDLEMESSAGE IdleCallback);
BOOL T2DestroyTimerThread(void);
void T2StartTimer(HANDLE Connection, LPCWSTR Label);
void T2StopTimer(HANDLE Connection);


#endif // INC_IDLETIMR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\tclnthlp.c ===
//
// tclnthlp.c
//
// There are some routines used within tclient2.c that were either
// used multiple times or deserved its own function name.  These
// "Helper" functions are defined here.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//

#include <stdlib.h>

#include "tclnthlp.h"
#include "tclient2.h"


// T2SetBuildNumber
//
// Attempts to get the build number of a server we are
// logging onto.  We accomplish this by getting the TCLIENT.DLL
// feedback buffer immediately, and enumerating all lines
// for specific text along with the build number.
//
// Returns NULL on success, or a string explaining the error
// on failure.

LPCSTR T2SetBuildNumber(TSAPIHANDLE *T2Handle)
{
    // Build the stack
    UINT BuildIndex = 0;
    WCHAR BuildNum[10] = { 0 };
    LPWSTR Buffers = NULL;
    LPWSTR BufPtr = NULL;
    LPWSTR TrigPtr = NULL;
    UINT TrigIndex = 0;
    UINT Index = 0;
    UINT Count = 0;
    UINT MaxStrLen = 0;
    LPCSTR Result = NULL;

    // This is the trigger list - it contains a list of strings
    // which exists on the same line as build numbers.
    WCHAR *Triggers[] = {

        L"Fortestingpurposesonly",
        L"Evaluationcopy",
        L""
    };

    // Get the feed back buffer so we can enumerate it
    Result = T2GetFeedback((HANDLE)T2Handle, &Buffers, &Count, &MaxStrLen);
    if (Result != NULL)
        return Result;

    // Loop through each string
    for (BufPtr = Buffers, Index = 0; Index < Count;
            BufPtr += MaxStrLen, ++Index) {

        // Loop through all the trigger substrings
        for (TrigIndex = 0; *(Triggers[TrigIndex]) != L'\0'; ++TrigIndex) {

            // Does this trigger exist in the current buffer string?
            TrigPtr = wcsstr(BufPtr, Triggers[TrigIndex]);

            if (TrigPtr != NULL) {

                // Find the first number after the trigger
                while (*TrigPtr != L'\0' && iswdigit(*TrigPtr) == FALSE)
                        ++TrigPtr;

                // Make sure we found a digit
                if (*TrigPtr != L'\0') {

                    // Begin recording this string
                    for (BuildIndex = 0; BuildIndex < SIZEOF_ARRAY(BuildNum) - 1;
                            ++BuildIndex) {

                        // Record numbers until... we reach a non-number!
                        if (iswdigit(*TrigPtr) == FALSE)
                            break;

                        BuildNum[BuildIndex] = *TrigPtr++;
                    }

                    // Convert it to a number
                    T2Handle->BuildNumber = wcstoul(BuildNum, NULL, 10);

                    // Free the memory on TCLIENT and return success!
                    SCFreeMem(Buffers);

                    return NULL;
                }
            }
        }
    }
    // Could not find any build number
    SCFreeMem(Buffers);

    return "A build number is not stored on the current feedback buffer";
}


// T2CopyStringWithoutSpaces
//
// This is a wide-character version of strcpy.. but additionally,
// this will NOT copy spaces from the source to the destination.
// This makes it fit for comparing with clxtshar strings.
//
// Returns the number of characters copied to the destination
// (including the null terminator).

ULONG_PTR T2CopyStringWithoutSpaces(LPWSTR Dest, LPCWSTR Source)
{
    // Create temporary pointers
    LPWSTR SourcePtr = (LPWSTR)Source;
    LPWSTR DestPtr = (LPWSTR)Dest;

    // Sanity check the strings
    if (Dest == NULL || Source == NULL)
        return 0;

    // Loop the string
    do {

        // If the character is not a space, copy it over to the new buffer
        if (*SourcePtr != L' ')
            *DestPtr++ = *SourcePtr;

    } while(*SourcePtr++ != L'\0');

    // Return the number of characters
    return DestPtr - Dest;
}


// T2AddTimeoutToString
//
// This is a very specific function - all it does is take the specified
// timeout and copy it to the string buffer.  However the number is prefixed
// by CHAT_SEPARATOR, meaning this allows to easily append timeouts
// to a string.  For example:
//
// "This string times out in 1 second<->1000"
//
// The buffer in which you would pass in is a pointer directly after the
// word second.  Note: this function does write a null terminator.
//
// No return value.

void T2AddTimeoutToString(LPWSTR Buffer, UINT Timeout)
{
    // Simply copy the chat sperator
    wcscpy(Buffer, CHAT_SEPARATOR);

    // Increment our pointer
    Buffer += wcslen(Buffer);

    // And now copy our number to the buffer
    _itow((int)Timeout, Buffer, 10);
}


// T2MakeMultipleString
//
// This takes an array of pointers to a string and copies them over
// to a buffer which is compatible with TCLIENT.DLL format strings.
// To indicate the end of an array, the last pointer must be NULL or
// point to an empty string.  An array can look like this:
//
//  WCHAR *StrArray = {
//      "Str1",
//      "Str2",
//      NULL
//  };
//
// The function will then write the following string to Buffer:
//
// "Str1|Str2"
//
// Note: you MUST be sure Buffer has enough space yourself!
//
// The function returns the number of characters written to Buffer,
// including the NULL terminator.

ULONG_PTR T2MakeMultipleString(LPWSTR Buffer, LPCWSTR *Strings)
{
    LPWSTR BufferPtr = Buffer;
    UINT Index = 0;

    // Sanity check
    if (Buffer == NULL || Strings == NULL)
        return 0;

    // Loop through the Strings array until NULL is hit
    for (; Strings[Index] != NULL && Strings[Index][0] != L'\0'; ++Index) {

        // Only write the delimeter for strings after the first string
        if (BufferPtr > Buffer)

            // Write the TCLIENT delimeter
            *BufferPtr++ = WAIT_STR_DELIMITER;

        // Use our handy function to now copy the string without spaces
        // after the delimiter location.
        BufferPtr += T2CopyStringWithoutSpaces(BufferPtr, Strings[Index]);

        // We are decrementing here because T2CopyStringWithoutSpaces
        // returns the count including the null terminator and
        // we may write over the terminator.
        --BufferPtr;
    }

    // This check is to make sure any strings were copied at all
    if (Buffer == BufferPtr)
        return 0;

    // Ensure a null terminator is written
    *(++BufferPtr) = L'\0';

    // We are bit
    return BufferPtr - Buffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\cert.c ===
//+----------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        cert.c
//
// Contents:    Centralized server certificate management
//
// History:     02-09-00    RobLeit  Created
//
//-----------------------------------------------------------------------------
#include <windows.h>
#include "license.h"
#include "lscsp.h"

///////////////////////////////////////////////////////////////////////////////
LICENSE_STATUS
TLSGetTSCertificate(
    CERT_TYPE       CertType,
    LPBYTE          *ppbCertificate,
    LPDWORD         pcbCertificate)
{
    LICENSE_STATUS  Status;
    DWORD           dwSize;
    LSCSPINFO       CspData;

    if( CERT_TYPE_PROPRIETORY == CertType )
    {
        CspData = LsCspInfo_Certificate;
    }
    else if( CERT_TYPE_X509 == CertType )
    {
        CspData = LsCspInfo_X509Certificate;
    }
    else
    {
        return( LICENSE_STATUS_NO_CERTIFICATE );
    }

    Status = LsCsp_GetServerData( CspData, NULL, &dwSize );

    if( LICENSE_STATUS_OK != Status )
    {
        return( Status );
    }

    if( 0 == dwSize )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *ppbCertificate = LocalAlloc( LMEM_ZEROINIT, dwSize );

    if( NULL == *ppbCertificate )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }
    
    Status = LsCsp_GetServerData( CspData, *ppbCertificate, &dwSize );

    if( LICENSE_STATUS_OK != Status )
    {
        LocalFree( *ppbCertificate );
        return( Status );
    }

    *pcbCertificate = dwSize;

    return( LICENSE_STATUS_OK );
}

LICENSE_STATUS
TLSFreeTSCertificate(
    LPBYTE          pbCertificate)
{
    if (NULL != pbCertificate)
    {
        LocalFree(pbCertificate);

        return LICENSE_STATUS_OK;
    }
    else
    {
        return LICENSE_STATUS_INVALID_INPUT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\idletimr.c ===
//
// idletimr.c
//
// This file contains an internal handling process for monitoring
// idled "wait for text" threads, and dispatching callback messages
// to the front-end application regarding the current state.  This is
// very helpful when debugging scripts, by seeing exactly what
// the script is waiting on.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//

#include <limits.h>
#include <stdlib.h>

#include "idletimr.h"
#include "connlist.h"
#include "apihandl.h"


// These are the internal messages used for the thread message queue
// to indicate what action to take.
#define WM_SETTIMER     WM_USER + 1
#define WM_KILLTIMER    WM_USER + 2


// Internal helper function prototypes
DWORD WINAPI T2WaitTimerThread(LPVOID lpParameter);
void CALLBACK T2WaitTimerProc(HWND Window,
        UINT Message, UINT_PTR TimerId, DWORD TimePassed);


// These are the callback routines
PFNPRINTMESSAGE pfnPrintMessage = NULL;
PFNIDLEMESSAGE pfnIdleCallback = NULL;


// Timer and thread data, only one queue thread is needed
// for all handles in the current process.
HANDLE ThreadHandle = NULL;
DWORD ThreadId = 0;
BOOL ThreadIsOn = FALSE;
BOOL ThreadIsStopping = FALSE;


// CreateTimerThread
//
// Initializes the thread message queue required for monitoring timers.
//
// Returns true if the thread was successfully created, FALSE otherwise.

BOOL T2CreateTimerThread(PFNPRINTMESSAGE PrintMessage,
        PFNIDLEMESSAGE IdleCallback)
{
    // Return TRUE if the thread is already created...
    if (ThreadIsOn == TRUE)
        return TRUE;

    // Indicate the thread is on (for multithreaded apps)
    ThreadIsOn = TRUE;

    // Record the callback functions
    pfnPrintMessage = PrintMessage;
    pfnIdleCallback = IdleCallback;

    // Initialize thread creation
    ThreadHandle = CreateThread(NULL, 0,
            T2WaitTimerThread, NULL, 0, &ThreadId);

    // Check if we did OK
    if (ThreadHandle == NULL)
    {
        // We failed, reset all the global variables
        ThreadHandle = NULL;
        ThreadId = 0;
        pfnPrintMessage = NULL;
        pfnIdleCallback = NULL;

        // Turn the thread off and return failure
        ThreadIsOn = FALSE;

        return FALSE;
    }

    return TRUE;
}


// DestroyTimerThread
//
// Destroys the thread created by CreateTimerThread.
//
// Returns TRUE on success, FALSE on failure.

BOOL T2DestroyTimerThread(void)
{
    // Record the current thread handle locally because
    // the global value could possibly be changed.
    HANDLE LocalThreadHandle = ThreadHandle;

    // If the thread is already stopped, return success
    if (ThreadIsOn == FALSE)
        return TRUE;

    // If the thread is already trying to stop, return failure
    if (ThreadIsStopping == TRUE)
        return FALSE;

    // Indicate the thread is now trying to stop
    ThreadIsStopping = TRUE;

    // First send the thread a quit message
    PostThreadMessage(ThreadId, WM_QUIT, 0, 0);

    // Wait for the thread (5 seconds)
    if (WaitForSingleObject(LocalThreadHandle, 5000) == WAIT_TIMEOUT) {

        // Why is our idle timer waiting??
        _ASSERT(FALSE);

        // No more waiting, we now use brute force
        TerminateThread(LocalThreadHandle, -1);
    }

    // Close the thread handle
    CloseHandle(LocalThreadHandle);

    // Clear out all the global variables
    ThreadHandle = NULL;
    ThreadId = 0;
    pfnPrintMessage = NULL;
    pfnIdleCallback = NULL;

    // And of course, release the thread switches
    ThreadIsOn = FALSE;
    ThreadIsStopping = FALSE;

    return TRUE;
}


// StartTimer
//
// Call this before going into a wait state for the thread on
// "wait for text".  This will record the current time, and start
// a timer which will execute in exactly WAIT_TIME milliseconds.
// When this occurs, the callback routines are notified.
//
// No return value.

void T2StartTimer(HANDLE Connection, LPCWSTR Label)
{
    TSAPIHANDLE *Handle = (TSAPIHANDLE *)Connection;

    // Make sure the message queue is on first
    if (ThreadIsOn == FALSE || ThreadIsStopping == TRUE)
        return;

    // Record the label for this timer
    if (Label == NULL)
        *(Handle->WaitStr) = '\0';
    else
        wcstombs(Handle->WaitStr, Label, MAX_PATH);

    // Post a message to the thread regarding a new timer for the handle.
    PostThreadMessage(ThreadId, WM_SETTIMER, WAIT_TIME, (LPARAM)Connection);
}


// StopTimer
//
// Call this after text is received in a "wait for text" thread state.
// It will stop the timer created by StartTimer preventing further
// messages with the recorded label.
//
// No return value.

void T2StopTimer(HANDLE Connection)
{
    // Make sure the message queue is on first
    if (ThreadIsOn == FALSE || ThreadIsStopping == TRUE)
        return;

    // Post a message to the thread to tell it to stop the timer
    PostThreadMessage(ThreadId, WM_KILLTIMER, 0, (LPARAM)Connection);
}


// WaitTimerProc
//
// When a timer exceeds it maximum time, this function is called.
// This will stop the timer, and start it back up for an additionaly
// interval of WAIT_TIME_STEP.  This is after it sends the notifications
// back to the user callback functions.
//
// This function is a valid format for use as a callback function in
// use with the SetTimer Win32 API function.
//
// No return value.

/* This recieves notifications when a timer actually elapses */
void CALLBACK T2WaitTimerProc(HWND Window, UINT Message,
        UINT_PTR TimerId, DWORD TickCount)
{
    DWORD IdleSecs = 0;
    DWORD TimeStarted = 0;

    // First get the the handle for the specified timer id
    HANDLE Connection = T2ConnList_FindHandleByTimerId(TimerId);

    // Stop the current running timer
    KillTimer(NULL, TimerId);

    // Do a sanity check to make sure we have a handle for this timer
    if (Connection == NULL) {

        _ASSERT(FALSE);

        return;
    }

    // Clear the time id parameter in the linked list
    T2ConnList_SetTimerId(Connection, 0);

    // Get the time this timer began
    T2ConnList_GetData(Connection, NULL, &TimeStarted);

    // Calculate number of seconds this timer has been running
    // (from its millisecond value)
    IdleSecs = (TickCount - TimeStarted) / 1000;

    // Call the PrintMessage callback function first
    if (pfnPrintMessage != NULL)
        pfnPrintMessage(IDLE_MESSAGE, "(Idle %u Secs) %s [%X]\n",
                IdleSecs, ((TSAPIHANDLE *)Connection)->WaitStr, Connection);

    // Secondly call the IdleCallback callback function
    if (pfnIdleCallback != NULL)
        pfnIdleCallback(Connection,
                ((TSAPIHANDLE *)Connection)->WaitStr, IdleSecs);

    // Reestablish a new timer with WAIT_TIME STEP to do this process again
    TimerId = SetTimer(NULL, 0, WAIT_TIME_STEP, T2WaitTimerProc);

    // Record the new timer id
    T2ConnList_SetTimerId(Connection, TimerId);
}


// WaitTimerThread
//
// This is a valid thread message queue.  It is created using the
// CreateTimerThread function, and killed using the DestroyTimerThread
// function.  It is more-or-less a worker thread to create SetTimer
// callback functions which cannot be used in the main thread because
// if the thread goes into wait state, SetTimer callbacks will not be
// called.  When you need to add/remove a thread, use the following
// thread posting form:
//
// UINT Message     = WM_SETTIMER or WM_KILLTIMER
// WPARAM wParam    = Initial wait time (usually WAIT_TIME)
// LPARAM lParam    = (HANDLE)Connection
//
// The return value is always 0.

DWORD WINAPI T2WaitTimerThread(LPVOID lpParameter)
{
    UINT_PTR TimerId;
    MSG Message;
    UINT WaitTime;

    // This is the message queue function for the thread
    while(GetMessage(&Message, NULL, 0, 0) > 0)
    {
        TimerId = 0;

        // SetTimer uses a UINT timeout value, while a WPARAM is a
        // pointer-sized value.

        WaitTime = Message.wParam > UINT_MAX ? UINT_MAX :
                                               (UINT)Message.wParam;

        // Enumerate the retreived message
        switch(Message.message)
        {
            // Create a new timer for a specified handle
            case WM_SETTIMER:

                // Create the timer and record its new timer id
                TimerId = SetTimer(NULL, 0, WaitTime, T2WaitTimerProc);
                T2ConnList_SetData((HANDLE)(Message.lParam),
                        TimerId, GetTickCount());
                break;

            // Stop a running timer for the specified handle
            case WM_KILLTIMER:

                // Get the timer id for the handle
                T2ConnList_GetData((HANDLE)(Message.lParam), &TimerId, NULL);

                // Validate and clear the timer if valid
                if (TimerId != 0 && TimerId != -1)
                    KillTimer(NULL, TimerId);

                // Clear the linked last data for the handle
                T2ConnList_SetData((HANDLE)Message.lParam, 0, 0);
                break;

            // Indicates a timer has elapsed its time, call the
            // procedure that handles these messages.
            case WM_TIMER:
                T2WaitTimerProc(NULL, WM_TIMER, WaitTime, GetTickCount());
                break;
        }
    }
    // Clear out the thread values
    ThreadHandle = NULL;
    ThreadId = 0;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\capplan\tclient2\tclient2.c ===
//
// tclient2.c
//
// This contains many wrappers for TCLIENT with some new features to
// make the API easier to use.
//
// Copyright (C) 2001 Microsoft Corporation
//
// Author: a-devjen (Devin Jenson)
//

#include <windows.h>
#include <protocol.h>
#include <extraexp.h>
#include <tclient2.h>
#include "connlist.h"
#include "apihandl.h"
#include "idletimr.h"
#include "tclnthlp.h"


// T2Check
//
// This is a wrapper for TCLIENT's SCCheck function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2Check(HANDLE Connection, LPCSTR Command, LPCWSTR Param)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Do the TCLIENT action
    return SCCheck(SCCONN(Connection), Command, Param);
}


// T2ClientTerminate
//
// This is a wrapper for TCLIENT's SCClientTerminate function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2ClientTerminate(HANDLE Connection)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Do the TCLIENT action
    return SCClientTerminate(SCCONN(Connection));
}


// T2Clipboard
//
// This is a wrapper for TCLIENT's SCClipboard function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2Clipboard(HANDLE Connection, INT ClipOp, LPCSTR FileName)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Do the TCLIENT action
    return SCClipboard(SCCONN(Connection), ClipOp, FileName);
}


// T2CloseClipboard
//
// This is a wrapper for TCLIENT's T2CloseClipboard function.
//
// Returns TRUE on success and FALSE on failure.

TSAPI BOOL T2CloseClipboard(VOID)
{
    return SCCloseClipboard();
}


// T2Connect
//
// This is a wrapper for TCLIENT's SCConnect function.  It does some
// additional stuff however - it allocates a handle local to
// TCLIENT2, sets default data such as Words Per Minute, and even
// attempts to get the build number immediately after the connection.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2Connect(LPCWSTR Server, LPCWSTR User,
        LPCWSTR Pass, LPCWSTR Domain,
        INT xRes, INT yRes, HANDLE *Connection)
{
    __try {

        LPCSTR Result = NULL;

        // Create a new connection handle
        TSAPIHANDLE *T2Handle = T2CreateHandle();

        if (T2Handle == NULL)
            return "Could not allocate an API handle";

        // Connect
        Result = SCConnect(Server, User, Pass, Domain,
            xRes, yRes, &(T2Handle->SCConnection));

        if (Result != NULL) {

            // Connection failed, destroy handle and return
            T2DestroyHandle((HANDLE)T2Handle);

            return Result;
        }

        // Attempt to retrieve the build number
        T2SetBuildNumber(T2Handle);

        // Set the default words per minute
        T2SetDefaultWPM(Connection, T2_DEFAULT_WORDS_PER_MIN);

        // Set the default latency
        T2SetLatency(Connection, T2_DEFAULT_LATENCY);

        // Give the user the handle
        *Connection = (HANDLE)T2Handle;
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        _ASSERT(FALSE);

        return "Connection error";
    }

    return NULL;
}


// T2ConnectEx
//
// This is a wrapper for TCLIENT's SCConnectEx function.  It does some
// additional stuff however - it allocates a handle local to
// TCLIENT2, sets default data such as Words Per Minute, and even
// attempts to get the build number immediately after the connection.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2ConnectEx(LPCWSTR Server, LPCWSTR User, LPCWSTR Pass,
        LPCWSTR Domain, LPCWSTR Shell, INT xRes, INT yRes,
        INT Flags, INT BPP, INT AudioFlags, HANDLE *Connection)
{
    __try {

        LPCSTR Result = NULL;

        // Create a new connection handle
        TSAPIHANDLE *T2Handle = T2CreateHandle();

        if (T2Handle == NULL)
            return "Could not allocate an API handle";

        // Connect
        Result = SCConnectEx(Server, User, Pass, Domain, Shell, xRes,
            yRes, Flags, BPP, AudioFlags, &(T2Handle->SCConnection));

        if (Result != NULL) {

            // Connection failed, destroy handle and return
            T2DestroyHandle((HANDLE)T2Handle);
            return Result;
        }

        // Attempt to retrieve the build number
        T2SetBuildNumber(T2Handle);

        // Set the default words per minute
        T2SetDefaultWPM(Connection, T2_DEFAULT_WORDS_PER_MIN);

        // Set the default latency
        T2SetLatency(Connection, T2_DEFAULT_LATENCY);

        *Connection = (HANDLE)T2Handle;
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        _ASSERT(FALSE);

        return "Connection error";
    }

    return NULL;
}


// T2Disconnect
//
// This is a wrapper for TCLIENT's SCDisconnect function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2Disconnect(HANDLE Connection)
{
    LPCSTR Result = NULL;

    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Do the TCLIENT action
    Result = SCDisconnect(SCCONN(Connection));

    // If we got here (regardless if SCDisconnect failed or not)
    // we have an allocated object that needs to be freed.
    T2DestroyHandle(Connection);

    // Return the result of the TCLIENT action
    return Result;
}


// T2FreeMem
//
// This is a wrapper for TCLIENT's SCFreeMem function.
//
// No return value.

TSAPI VOID T2FreeMem(PVOID Mem)
{
    SCFreeMem(Mem);
}


// T2GetBuildNumber
//
// This sets the DWORD to the build number that was (if) detected
// upon connection. If the build number was not detected, 0 (zero)
// will be the value.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2GetBuildNumber(HANDLE Connection, DWORD *BuildNumber)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    __try {

        // Attempt to set a value at the specified pointer
        *BuildNumber = ((TSAPIHANDLE *)Connection)->BuildNumber;
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        // Nope, it failed.
        _ASSERT(FALSE);

        return "Invalid BuildNumber pointer";
    }

    return NULL;
}


// T2GetFeedback
//
// This is a wrapper for TCLIENT's SCGetFeedback function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2GetFeedback(HANDLE Connection, LPWSTR *Buffers, UINT *Count, UINT *MaxStrLen)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Do the TCLIENT action
    return SCGetFeedback(((TSAPIHANDLE *)Connection)->SCConnection,
            Buffers, Count, MaxStrLen);
}


// T2GetParam
//
// This will get the value pointed to by lParam
// the "user-defined" value set using T2SetParam.  It can
// be used for callbacks and other application purposes.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2GetParam(HANDLE Connection, LPARAM *lParam)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    __try {

        // Attempt to set a value at the specified pointer
        *lParam = ((TSAPIHANDLE *)Connection)->lParam;
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        // Nope, it failed.
        _ASSERT(FALSE);

        return "Invalid lParam pointer";
    }

    return NULL;
}


// T2GetLatency
//
// On multi-input commands, such as "T2KeyAlt" which presses
// several keys to accomplish its goal, a latency value is used
// to slow the presses down so ALT-F is not pressed so fast
// it becomes unrealistic.  The default value is T2_DEFAULT_LATENCY
// or you can retrieve its current value using this function.
// To change the value, use the T2SetLatency function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2GetLatency(HANDLE Connection, DWORD *Latency)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    __try {

        // Attempt to set a value at the specified pointer
        *Latency = ((TSAPIHANDLE *)Connection)->Latency;
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        // Nope, it failed.
        _ASSERT(FALSE);

        return "Invalid Latency pointer";
    }

    return NULL;
}


// T2GetSessionId
//
// This is a wrapper for TCLIENT's SCGetSessionId function.
//
// Returns the session id on success, or 0 on failure.

TSAPI UINT T2GetSessionId(HANDLE Connection)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return 0;

    // Do the TCLIENT action
    return SCGetSessionId(SCCONN(Connection));
}


// T2Init
//
// This is a wrapper for TCLIENT's SCInit function.  However this
// function does an additional internal item:  Record the callback
// routines.
//
// No return value.

TSAPI VOID T2Init(SCINITDATA *InitData, PFNIDLEMESSAGE IdleCallback)
{
    __try {

        // If we have a valid structure, grab its data to wrap it
        if (InitData != NULL)

            // Create the timer which will monitor idles in the script
            T2CreateTimerThread(InitData->pfnPrintMessage, IdleCallback);

        // Initialize TCLIENT
        SCInit(InitData);
    }

    __except (EXCEPTION_EXECUTE_HANDLER) {

        _ASSERT(FALSE);

        return;
    }
}


// T2IsDead
//
// This is a wrapper for TCLIENT's SCIsDead function.
//
// Returns TRUE if the connection is invalid, or does not
// contain a valid connection.  Otherwise FALSE is returned.

TSAPI BOOL T2IsDead(HANDLE Connection)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return TRUE;

    // Do the TCLIENT action
    return SCIsDead(SCCONN(Connection));
}


// T2IsHandle
//
// This function checks a handle for validity.
//
// Returns TRUE if the connection handle is a valid handle.
// This differs to T2IsDead by it only verifies the memory
// location, it does not check the connection status.

TSAPI BOOL T2IsHandle(HANDLE Connection)
{
    TSAPIHANDLE *APIHandle = (TSAPIHANDLE *)Connection;

    // Use exception handling in case memory has been freed
    __try
    {
        // Simply reference the first and last members for validity
        if (APIHandle->SCConnection == NULL &&
                APIHandle->Latency == 0)
            return FALSE;
    }

    // If we tried to reference an invalid pointer, we will get here
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        return FALSE;
    }

    // Everything worked ok, tell the user
    return TRUE;
}


// T2Logoff
//
// This is a wrapper for TCLIENT's SCLogoff function.  Additionally, if
// the logoff completed successfully, the connection handle is destroyed.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2Logoff(HANDLE Connection)
{
    LPCSTR Result;

    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Do the TCLIENT action
    Result = SCLogoff(SCCONN(Connection));

    // If the logoff completed, release and destroy the handle.
    if (Result == NULL)
        T2DestroyHandle(Connection);

    return Result;
}


// T2OpenClipboard
//
// This is a wrapper for TCLIENT's SCOpenClipboard function.
//
// Returns TRUE if the operation completed successfully,
// otherwise FALSE is returned.

TSAPI BOOL T2OpenClipboard(HWND Window)
{
    return SCOpenClipboard(Window);
}


// T2PauseInput
//
// This routine sets or unsets an event which makes all
// "input" functions pause or unpause.  This can only be used
// in multithreaded applications.  When "Enable" is TRUE,
// the function will pause all input - meaning all keyboard
// messages will not return until T2PauseInput is called again
// with "Enable" as FALSE.  This allows the opportunity to
// pause a script during execution without losing its place.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2PauseInput(HANDLE Connection, BOOL Enable)
{
    TSAPIHANDLE *Handle;

    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Cast the HANDLE over to an internal structure
    Handle = (TSAPIHANDLE *)Connection;

    // Validate the event handle
    if (Handle->PauseEvent == NULL) {

        _ASSERT(FALSE);

        return "Invalid pause event handle";
    }

    // Disable Pause
    if (Enable == FALSE)
        SetEvent(Handle->PauseEvent);

    // Enable Pause
    else
        ResetEvent(Handle->PauseEvent);

    // Success
    return NULL;
}


// T2SaveClipboard
//
// This is a wrapper for TCLIENT's SCSaveClipboard function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2SaveClipboard(HANDLE Connection,
        LPCSTR FormatName, LPCSTR FileName)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Do the TCLIENT action
    return SCSaveClipboard(SCCONN(Connection), FormatName, FileName);
}


// T2SendData
//
// This is a wrapper for TCLIENT's SCSenddata function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2SendData(HANDLE Connection,
    UINT Message, WPARAM wParam, LPARAM lParam)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // This is an input call, ensure we are not paused first
    T2WaitForPauseInput(Connection);

    // Do the TCLIENT action
    return SCSenddata(SCCONN(Connection), Message, wParam, lParam);
}


// T2SendMouseClick
//
// This is a wrapper for TCLIENT's SCSendMouseClick function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2SendMouseClick(HANDLE Connection, UINT xPos, UINT yPos)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // This is an input call, ensure we are not paused first
    T2WaitForPauseInput(Connection);

    // Do the TCLIENT action
    return SCSendMouseClick(SCCONN(Connection), xPos, yPos);
}


// T2SendText
//
// This is a wrapper for TCLIENT's SCSendtextAsMsgs function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2SendText(HANDLE Connection, LPCWSTR String)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // This is an input call, ensure we are not paused first
    T2WaitForPauseInput(Connection);

    // Do the TCLIENT action
    return SCSendtextAsMsgs(SCCONN(Connection), String);
}


// T2SetClientTopmost
//
// This is a wrapper for TCLIENT's SCSetClientTopmost function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2SetClientTopmost(HANDLE Connection, LPCWSTR Param)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Do the TCLIENT action
    return SCSetClientTopmost(SCCONN(Connection), Param);
}


// T2SetParam
//
// This changes the user-defined parameter for the specified
// connection which can be retrieved using the T2GetParam function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2SetParam(HANDLE Connection, LPARAM lParam)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Set the parameter
    ((TSAPIHANDLE *)Connection)->lParam = lParam;

    return NULL;
}


// T2SetLatency
//
// On multi-input commands, such as "T2KeyAlt" which presses
// several keys to accomplish its goal, a latency value is used
// to slow the presses down so ALT-F is not pressed so fast
// it becomes unrealistic.  The default value is T2_DEFAULT_LATENCY
// and you can use this function to change its value.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2SetLatency(HANDLE Connection, DWORD Latency)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Set the latency
    ((TSAPIHANDLE *)Connection)->Latency = Latency;

    return NULL;
}


// T2Start
//
// This is a wrapper for TCLIENT's SCStart function.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2Start(HANDLE Connection, LPCWSTR AppName)
{
    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // This is an input call, ensure we are not paused first
    T2WaitForPauseInput(Connection);

    // Do the TCLIENT action
    return SCStart(SCCONN(Connection), AppName);
}


// T2SwitchToProcess
//
// This is a wrapper for TCLIENT's SCSwitchToProcess function.
// The TCLIENT2 extension to this function is that it ignores spaces,
// the old version you HAD to pass in "MyComputer" instead of
// "My Computer" to have it work.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2SwitchToProcess(HANDLE Connection, LPCWSTR Param)
{
    WCHAR CompatibleStr[1024] = { 0 };

    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // This is an input call, ensure we are not paused first
    T2WaitForPauseInput(Connection);

    // Copy the string (without spaces) to a temporary buffer
    if (T2CopyStringWithoutSpaces(CompatibleStr, Param) == 0)
        return "Invalid process name";

    // Do the TCLIENT action
    return SCSwitchToProcess(SCCONN(Connection), CompatibleStr);
}


// T2WaitForText
//
// This is a wrapper for TCLIENT's SCSwitchToProcess function.
// The TCLIENT2 extension to this function is that it ignores spaces,
// the old version you HAD to pass in "MyComputer" instead of
// "My Computer" to have it work.
//
// Note: The Timeout value is in milliseconds.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2WaitForText(HANDLE Connection, LPCWSTR String, INT Timeout)
{
    LPCSTR Result;
    WCHAR CompatibleStr[1024];
    WCHAR *CStrPtr = CompatibleStr;

    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Sanity checks always come first
    if (String == NULL || *String == 0)
        return "No text to wait for";

    // If timeout is infinite, convert that value over to TCLIENT terms.
    if (Timeout == T2INFINITE)
        Timeout = WAIT_STRING_TIMEOUT;

    // Now copy the string without spaces over to our stack buffer.
    CStrPtr += (T2CopyStringWithoutSpaces(CompatibleStr, String) - 1);

    // At the end of the new buffer, append the TCLIENT compatible version
    // of a timeout indicator.
    T2AddTimeoutToString(CStrPtr, Timeout);

    // Begin a timer for our callback routines to indicate idles
    T2StartTimer(Connection, String);

    // Now wait for the string
    Result = T2Check(Connection, "Wait4StrTimeout", CompatibleStr);

    // Wait4StrTimeout returned, so the text was either found or the
    // function failed.. in any case, stop the timer.
    T2StopTimer(Connection);

    // Return the result back to the user
    return Result;
}


// T2WaitForMultiple
//
// Like T2WaitForText, this function waits for a string.  What is different
// about this function is that it will wait for any number of strings.
// For example, if you pass in the strings "My Computer" and "Recycle Bin",
// the function will return when EITHER has been found - NOT BOTH.  The
// only way to indicate "return only when both has been found" is to call
// T2WaitForText multiple times.
//
// The Strings parameter is an array of pointers to a string, and the last
// pointer must point to a NULL value or an empty string.  Example:
//
//  WCHAR *StrArray = {
//      "Str1",
//      "Str2",
//      NULL
//  };
//
// Note: The Timeout value is in milliseconds.
//
// Returns NULL on success, or a string explaining the error
// on failure.

TSAPI LPCSTR T2WaitForMultiple(HANDLE Connection,
        LPCWSTR *Strings, INT Timeout)
{
    LPCSTR Result;
    WCHAR CompatibleStr[1024] = { 0 };
    WCHAR *CStrPtr = CompatibleStr;

    // Validate the handle
    if (T2IsHandle(Connection) == FALSE)
        return "Invalid connection handle";

    // Sanity checks always come first
    if (Strings == NULL || *Strings == NULL)
        return "No text to wait for";

    // If timeout is infinite, convert that value over to TCLIENT terms.
    if (Timeout == T2INFINITE)
        Timeout = WAIT_STRING_TIMEOUT;

    // Next step is to convert our nice string array to a TCLIENT
    // version of "multiple strings".
    CStrPtr += (T2MakeMultipleString(CompatibleStr, Strings) - 1);

    // Validate our result by checking the first character
    if (*CompatibleStr == L'\0')
        return "No text to wait for";

    // At the end of the new buffer, append the TCLIENT compatible version
    // of a timeout indicator.
    T2AddTimeoutToString(CStrPtr, Timeout);

    // Begin a timer for our callback routines to indicate idles
    T2StartTimer(Connection, *Strings);

    // Now wait for the string
    Result = T2Check(Connection, "Wait4MultipleStrTimeout", CompatibleStr);

    // Wait4StrTimeout returned, so the text was either found or the
    // function failed.. in any case, stop the timer.
    T2StopTimer(Connection);

    // Return the result back to the user
    return Result;
}


// If the DLL is unloaded unsafely, this closes some handles.
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
    // Only call during an "unload"
    if (fdwReason == DLL_PROCESS_DETACH)

        T2DestroyTimerThread();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\csp.c ===
/*++

File name:      

    csp.c

Description:    
    
    Contains routines to support cryptographic routines for termserv

Copyright:

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1991-1998
    All rights reserved

History:

    Frederick Chong( FredCh )   07/29/98    Added functions to install
                                            X509 certificate.
   
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntlsa.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <tchar.h>
#include <stdio.h>

#include "license.h"
#include "cryptkey.h"
#include "lscsp.h"
#include "tlsapip.h"
#include "certutil.h"
#include "hydrakey.h"
#include "tssec.h"

//
// Only include RNG functions from tssec
//
#define NO_INCLUDE_LICENSING 1
#include <tssec.h>


#include <md5.h>
#include <sha.h>
#include <rsa.h>

#include <secdbg.h>
#include "global.h"

#ifdef OS_WIN16
#include <string.h>
#endif // OS_WIN16

#include "licecert.h"

#define LS_DISCOVERY_TIMEOUT (1*1000)

//-----------------------------------------------------------------------------
//
// Internal Functions
//
//-----------------------------------------------------------------------------

NTSTATUS
OpenPolicy(
    LPWSTR      ServerName,
    DWORD       DesiredAccess,
    PLSA_HANDLE PolicyHandle );

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String );

LICENSE_STATUS
GenerateRsaKeyPair(
    LPBYTE *     ppbPublicKey,
    LPDWORD      pcbPublicKey,
    LPBYTE *     ppbPrivateKey,
    LPDWORD      pcbPrivateKey,
    DWORD        dwKeyLen );

LICENSE_STATUS
Bsafe2CapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo,
    LPBYTE                  pbBsafePubKey,
    DWORD                   cbBsafePubKey );

VOID
FreeCapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo );

LICENSE_STATUS
RequestCertificate(     
    TLS_HANDLE              hServer,
    PCERT_PUBLIC_KEY_INFO   pPubKeyInfo,
    LPBYTE *                ppbCertificate,
    LPDWORD                 pcbCertificate,
    HWID *                  pHwid );

LICENSE_STATUS
GetSubjectRdn(
    LPTSTR   * ppSubjectRdn );

LICENSE_STATUS
GenerateMachineHWID(
    PHWID    pHwid );


LICENSE_STATUS
ReloadCSPCertificateAndData();

LICENSE_STATUS
CreateProprietaryKeyAndCert(
    PBYTE *ppbPrivateKey,
    DWORD *pcbPrivateKey,
    PBYTE *ppbServerCert,
    DWORD *pcbServerCert);

BOOL IsSystemService();

/*++

Function:

    LsCsp_DecryptEnvelopedData

Routine Description:

    Decrypt the client random that is encrypted by the server public key.

Arguments:

    dwCertType - The type of certificate that is used in the encryption.

    pbEnvelopedData - pointer to a buffer where the encrypted random key is
    passed in.

    cbEnvelopedDataLen - length of the random key passed in/out.

    pbData - pointer to a buffer where the decrypted data returned.

    pcbDataLen - pointer a DWORD location where the length of the above
    buffer is passed in and the length of the decrypted data is returned.

Return Value:

    TRUE - if the key is decrypted successfully.
    FALSE - otherwise.

--*/

BOOL
LsCsp_DecryptEnvelopedData(
    CERT_TYPE   CertType,
    LPBYTE      pbEnvelopedData,
    DWORD       cbEnvelopedDataLen,
    LPBYTE      pbData,
    LPDWORD     pcbDataLen
    )
{
    LPBSAFE_PRV_KEY pSrvPrivateKey = NULL;
    BOOL    bResult = TRUE;

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    //
    // determine the correct private key to use for the decryption operation
    //

    if( CERT_TYPE_PROPRIETORY == CertType )
    {        
        pSrvPrivateKey = (LPBSAFE_PRV_KEY)csp_abServerPrivateKey;
    }
    else if( CERT_TYPE_X509 == CertType )
    {
        if( csp_abX509CertPrivateKey == NULL )
        {
            if( ReloadCSPCertificateAndData() != LICENSE_STATUS_OK )
            {
                ASSERT( FALSE );
            }
        }

        pSrvPrivateKey = (LPBSAFE_PRV_KEY)csp_abX509CertPrivateKey;
    }
    else
    {
        bResult = FALSE;
        goto ded_done;
    }
    
    if( NULL == pSrvPrivateKey )
    {
        bResult = FALSE;
        goto ded_done;
    }

    //
    // check to see the output buffer length pointer is valid.
    //

    if( pcbDataLen == NULL ) {
        bResult = FALSE;
        goto ded_done;
    }

    //
    // check to see the output buffer is valid and its length is sufficient.
    //

    if( (pbData == NULL) || (*pcbDataLen < pSrvPrivateKey->keylen) ) {
        *pcbDataLen = pSrvPrivateKey->keylen;
        bResult = FALSE;
        goto ded_done;
    }

    //
    // encrypted data length should be equal to server private key length.
    //

    if( cbEnvelopedDataLen != pSrvPrivateKey->keylen ) {
        *pcbDataLen = 0;
        bResult = FALSE;
        goto ded_done;
    }

    ASSERT( pbData != NULL );

    //
    // init the output buffer.
    //

    memset( pbData, 0x0, (UINT)pSrvPrivateKey->keylen );

    if( !BSafeDecPrivate(
            pSrvPrivateKey,
            pbEnvelopedData,
            pbData) ) {
        *pcbDataLen = 0;
        bResult = FALSE;
        goto ded_done;
    }

    //
    // successfully decrypted the client random.
    // set the encrypted data length before returning.
    //

    *pcbDataLen = pSrvPrivateKey->keylen;

ded_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 

    return( bResult );
}


BOOL
LsCsp_EncryptEnvelopedData(
    LPBYTE  pbData,
    DWORD   cbDataLen,
    LPBYTE  pbEnvelopedData,
    LPDWORD pcbEnvelopedDataLen
    )
{
    return FALSE;
}


/*++

Function:

    LsCsp_DumpBinaryData

Description:

    Display the binary data in the given buffer at the debugger output screen

Arguments:

    pBuffer - Buffer containing the binary data to be displayed.
    uLen - Length of th binary data

Return:

    Nothing.

--*/

#if DBG
#ifdef DUMP
VOID LsCsp_DumpBinaryData( PBYTE pBuffer, ULONG uLen )
{
    UNALIGNED CHAR  *p = (UNALIGNED CHAR *)pBuffer;
    CHAR     c;
    DWORD    dw;
    UINT     i = 0;

    DbgPrint("{\n  ");
    while( i < uLen ) {
        c = *p;
        dw = (DWORD)(c);
        DbgPrint( "0x%02X, ", dw & 0xFF );
        i++;
        p++;
        if ((i % 8) == 0)
            DbgPrint( "\n  " );
    }
    DbgPrint( "\n}\n" );
}
#endif
#endif


/*++

Function:

    LsCsp_GetBinaryData

Description:

    Retrieve binary data from the registry

Arguments:

    hKey - Handle to the registry key
    szValue - The registry value to read
    ppBuffer - Return pointer to the binary data
    pdwBufferLen - The length of the binary data.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_GetBinaryData( 
    HKEY        hKey, 
    LPTSTR      szValue, 
    LPBYTE *    ppBuffer, 
    LPDWORD     pdwBufferLen )
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    DWORD   dwType;
    DWORD   cbBuffer;
    LPBYTE  lpBuffer;

    ASSERT( ppBuffer != NULL );
    ASSERT( pdwBufferLen != NULL );
    ASSERT( szValue != NULL );
    ASSERT( hKey != NULL );

    *ppBuffer = NULL;
    cbBuffer = 0;

    if ( RegQueryValueEx(
                hKey,
                szValue,
                0,
                &dwType,
                (LPBYTE)NULL,
                &cbBuffer) != ERROR_SUCCESS ||
        dwType != REG_BINARY ||
        cbBuffer == 0 )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto gbd_done;
    }
    lpBuffer = (LPBYTE)LocalAlloc( LPTR, cbBuffer );
    if (lpBuffer == NULL) {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto gbd_done;
    }
    if ( RegQueryValueEx(
                hKey,
                szValue,
                0,
                &dwType,
                (LPBYTE)lpBuffer,
                &cbBuffer) != ERROR_SUCCESS ||
         dwType != REG_BINARY)
    {
        LocalFree( lpBuffer );
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto gbd_done;
    }

    *ppBuffer = lpBuffer;
    *pdwBufferLen = cbBuffer;

gbd_done:

    return( Status );
}


/*++

Function:

    LsCsp_Initialize

Description:

    Initialize this library.

Arguments:

    Nothing.

Return:

    A LICENSE_STATUS return code.

--*/


LICENSE_STATUS
LsCsp_Initialize( void )
{
    DWORD   Status = LICENSE_STATUS_OK;
    DWORD   dwResult, dwDisp;

    if( InterlockedIncrement( &csp_InitCount ) > 1 )
    {
        //
        // already initialized
        //

        return( LICENSE_STATUS_OK );
    }

    //
    // Create a global mutex for sync.
    //
    csp_hMutex = CreateMutex(
                            NULL,
                            FALSE,
                            NULL
                        );

    if(NULL == csp_hMutex)
    {

#if DBG
    DbgPrint("LSCSP: CreateMutex() failed with error code %d\n", GetLastError());
#endif

        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    //
    // initialize the Hydra Server Root Public key.
    //
    csp_pRootPublicKey = (LPBSAFE_PUB_KEY)csp_abPublicKeyModulus;
    csp_pRootPublicKey->magic = RSA1;
    csp_pRootPublicKey->keylen = 0x48;
    csp_pRootPublicKey->bitlen = 0x0200;
    csp_pRootPublicKey->datalen = 0x3f;
    csp_pRootPublicKey->pubexp = 0xc0887b5b;

#if DBG
#ifdef DUMP
    DbgPrint("Data0\n");
    LsCsp_DumpBinaryData( (LPBYTE)csp_pRootPublicKey, 92 );
#endif
#endif

    //
    // Initialize the proprietory certificate with the built in certificate
    //

    if( !LsCsp_UseBuiltInCert() )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto ErrorExit;
    }

    //
    // Unpack and Validate the certificate
    //
    try {
        if (!UnpackServerCert(
                     csp_abServerCertificate,
                     csp_dwServerCertificateLen,
                     &csp_hscData )) {
            Status = LICENSE_STATUS_INVALID_CERTIFICATE;
            goto ErrorExit;
        }
        if (!ValidateServerCert( &csp_hscData )) {
            Status = LICENSE_STATUS_INVALID_CERTIFICATE;
        }
    } except( EXCEPTION_EXECUTE_HANDLER ) {
#if DBG
    DbgPrint("LSCSP: LsCsp_Initialize bad cert data!\n");
#endif
        Status = LICENSE_STATUS_INVALID_CERTIFICATE;
    }

    Status = ReloadCSPCertificateAndData();

    if (LICENSE_STATUS_NO_CERTIFICATE == Status)
    {
        //
        // No X509 certificate.  Not a failure, as the discovery 
        // thread will soon install it.
        //

        Status = LICENSE_STATUS_OK;
    }
    else if(LICENSE_STATUS_OUT_OF_MEMORY == Status)
    {
        //
        // out of memory at initialization time, 
        // this is critical error
        //
        goto ErrorExit;
    }

    //
    // Let initalization go thru if it can retrieve 
    // private key from LSA, this is OK since we will try to install
    // certificate again in LsCsp_InstallX509Certificate()
    //
    Status = LICENSE_STATUS_OK;
    goto i_done;

ErrorExit:

    LsCsp_Exit();

i_done:

    return( Status );
}


/*++

Function:

    LsCsp_Exit

Description:

    Free all resources used by this library.

Arguments:

    Nothing.

Return:

    A LICENSE_STATUS return code.

--*/

VOID LsCsp_Exit( void )
{
    if( InterlockedDecrement( &csp_InitCount ) > 0 )
    {
        //
        // someone is still using it.
        //

        return;
    }

    if ( csp_abServerPrivateKey)
    {
        LocalFree( csp_abServerPrivateKey );
    }
    csp_abServerPrivateKey = NULL;

    if ( csp_abServerCertificate )
    {
        LocalFree( csp_abServerCertificate );
    }
    csp_abServerCertificate = NULL;

    if( csp_abServerX509Cert )
    {
        LocalFree( csp_abServerX509Cert );
    }
    csp_abServerX509Cert = NULL;

    if( csp_abX509CertPrivateKey )
    {
        LocalFree( csp_abX509CertPrivateKey );
    }
    csp_abX509CertPrivateKey = NULL;

    if( csp_abX509CertID )
    {
        LocalFree( csp_abX509CertID );
    }
    csp_abX509CertID = NULL;

    if( csp_hMutex )
    {
        CloseHandle( csp_hMutex );
    }
    csp_hMutex = NULL;

    return;
}


/*++

Function:

   LsCsp_GetServerData

Routine Description:

   This function makes and return the microsoft terminal server certificate
   blob of data.

Arguments:

   dwInfoDesired - What type of information to return.

   pBlob - pointer to a location where the certificate blob data
   pointer is returned.

   pdwServerCertLen - pointer to a location where the length of the above data
   is returned.

Return Value:

   Windows Error Code.

--*/

LICENSE_STATUS
LsCsp_GetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    LPDWORD     pdwBlobLen
    )
{
    LICENSE_STATUS Status = LICENSE_STATUS_OK;
    DWORD  dwDataLen;
    LPBYTE pbData;

    ASSERT( pdwBlobLen != NULL );

    if ((Info == LsCspInfo_PrivateKey) || (Info == LsCspInfo_X509CertPrivateKey))
    {
        if (!IsSystemService())
        {
            return LICENSE_STATUS_NO_PRIVATE_KEY;
        }
    }

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    switch (Info) {
    case LsCspInfo_Certificate:

        if( NULL == csp_abServerCertificate )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
            goto gsd_done;
        }

        pbData = csp_abServerCertificate;
        dwDataLen = csp_dwServerCertificateLen;
        break;

    case LsCspInfo_X509Certificate:

        //
        // We may not have an X509 certificate if the hydra server has not
        // requested one from the license server
        //

        if( NULL == csp_abServerX509Cert )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
            goto gsd_done;
        }

        pbData = csp_abServerX509Cert;
        dwDataLen = csp_dwServerX509CertLen;
        break;

    case LsCspInfo_X509CertID:

        //
        // we will not have a certificate ID if the X509 certificate is not present
        //

        if( NULL == csp_abX509CertID )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
            goto gsd_done;
        }

        pbData = csp_abX509CertID;
        dwDataLen = csp_dwX509CertIDLen;
        break;

    case LsCspInfo_PublicKey:
        pbData = csp_hscData.PublicKeyData.pBlob;
        dwDataLen = csp_hscData.PublicKeyData.wBlobLen;
        break;

    case LsCspInfo_PrivateKey:
        if( NULL == csp_abServerPrivateKey )
        {
            Status = LICENSE_STATUS_NO_PRIVATE_KEY;
            goto gsd_done;
        }

        pbData = csp_abServerPrivateKey;
        dwDataLen = csp_dwServerPrivateKeyLen;
        break;

    case LsCspInfo_X509CertPrivateKey:
        
        //
        // The X509 certificate private key may not have been created.
        //

        if( NULL == csp_abX509CertPrivateKey )
        {
            Status = LICENSE_STATUS_NO_PRIVATE_KEY;
            goto gsd_done;
        }

        pbData = csp_abX509CertPrivateKey;
        dwDataLen = csp_dwX509CertPrivateKeyLen;
        break;

    default:
        Status = LICENSE_STATUS_INVALID_INPUT;
        goto gsd_done;
    }

    if (pBlob != NULL) {
        if (*pdwBlobLen < dwDataLen) {
            *pdwBlobLen = dwDataLen;
            Status = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        } else {
            memcpy(pBlob, pbData, dwDataLen);
            *pdwBlobLen = dwDataLen;
        }
    } else {
        *pdwBlobLen = dwDataLen;
    }

gsd_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    return( Status );
}

/*++

Function:

    LsCsp_ReadProprietaryDataFromStorage

Description:

    Read proprietary public/private info from registry/LSA secret
    
Arguments:

    None.
    
Return:

    LICENSE_STATUS
        
--*/

LICENSE_STATUS
LsCsp_ReadProprietaryDataFromStorage(PBYTE *ppbCert,
                                     DWORD *pcbCert,
                                     PBYTE *ppbPrivateKey,
                                     DWORD *pcbPrivateKey)
{
    LICENSE_STATUS Status;
    HKEY hKey = NULL;
    DWORD dwDisp;

    *ppbCert = *ppbPrivateKey = NULL;
    *pcbCert = *pcbPrivateKey = 0;

    //
    // Open the Registry
    //

    if( RegCreateKeyEx(
                       HKEY_LOCAL_MACHINE,
                       TEXT( HYDRA_CERT_REG_KEY ),
                       0,
                       NULL,
                       REG_OPTION_NON_VOLATILE,
                       KEY_READ,
                       NULL,
                       &hKey,
                       &dwDisp ) != ERROR_SUCCESS )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto done;
    }

    if ( RegQueryValueEx(
                         hKey,
                         TEXT( HYDRA_CERTIFICATE_VALUE ),
                         NULL,  // lpReserved
                         NULL,  // lpType
                         NULL,  // lpData
                         pcbCert) != ERROR_SUCCESS )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto done;
    }

    Status = LsCsp_RetrieveSecret(PRIVATE_KEY_NAME,
                                  NULL, // pbKey
                                  pcbPrivateKey);

    if (LICENSE_STATUS_OK != Status)
    {
        goto done;
    }

    *ppbCert = ( LPBYTE )LocalAlloc(LPTR,*pcbCert);

    if (NULL == *ppbCert)
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto done;
    }

    *ppbPrivateKey = ( LPBYTE )LocalAlloc(LPTR,*pcbPrivateKey);
    if (NULL == *ppbPrivateKey)
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto done;
    }

    if ( RegQueryValueEx(
                         hKey,
                         TEXT( HYDRA_CERTIFICATE_VALUE ),
                         NULL,  // lpReserved
                         NULL,  // lpType
                         *ppbCert,
                         pcbCert) != ERROR_SUCCESS )
    {
        Status = LICENSE_STATUS_NO_CERTIFICATE;
        goto done;
    }

    Status = LsCsp_RetrieveSecret(PRIVATE_KEY_NAME,
                                  *ppbPrivateKey,
                                  pcbPrivateKey);

done:
    if (NULL != hKey)
        RegCloseKey(hKey);

    if (Status != LICENSE_STATUS_OK)
    {
        if (NULL != *ppbCert)
        {
            LocalFree(*ppbCert);
            *ppbCert = NULL;
            *pcbCert = 0;
        }

        if (NULL != *ppbPrivateKey)
        {
            LocalFree(*ppbPrivateKey);
            *ppbPrivateKey = NULL;
            *pcbPrivateKey = 0;
        }
    }

    return Status;
}


/*++

Function:

    LsCsp_UseBuiltInCert

Description:

    Initialize the global variables with hardcoded certificate.
    
Arguments:

    None.
    
Return:

    TRUE if the initialization is successful.
        
--*/

BOOL
LsCsp_UseBuiltInCert( void )
{
    LICENSE_STATUS Status;

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    //
    // Step 1, cleanup and initialization that happened
    //
    if (csp_abServerPrivateKey)
    {
        LocalFree( csp_abServerPrivateKey );
        csp_abServerPrivateKey = NULL;
    }

    if (csp_abServerCertificate)
    {
        LocalFree( csp_abServerCertificate );
        csp_abServerCertificate = NULL;
    }

    //
    // Step 2, check for stored key and certificate
    //
    Status = LsCsp_ReadProprietaryDataFromStorage(&csp_abServerCertificate, &csp_dwServerCertificateLen,&csp_abServerPrivateKey, &csp_dwServerPrivateKeyLen);

    if (LICENSE_STATUS_OK != Status)
    {
        PBYTE pbPrivateKey, pbCertificate;
        DWORD cbPrivateKey, cbCertificate;

        //
        // Step 3, if no stored info found, generate new info and store it
        //
        
        Status = CreateProprietaryKeyAndCert(&pbPrivateKey,&cbPrivateKey,&pbCertificate,&cbCertificate);
        
        if (LICENSE_STATUS_OK == Status)
        {
            LsCsp_SetServerData(LsCspInfo_PrivateKey,pbPrivateKey,cbPrivateKey);

            LsCsp_SetServerData(LsCspInfo_Certificate,pbCertificate,cbCertificate);
        }
    }

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 
        
    return( Status == LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_InstallX509Certificate

Routine Description:

   This function generates a private/public key pair and then finds a 
   license server to issue an X509 certificate for the public key.
   It then stores the private key and certificate.

Arguments:

   None.

Return Value:

   LSCSP return code.

--*/


LICENSE_STATUS
LsCsp_InstallX509Certificate(LPVOID lpParam)
{
    DWORD
        cbPubKey,
        cbPrivKey,
        cbCertificate;
    LICENSE_STATUS
        Status;
    LPBYTE
        pbPubKey = NULL,
        pbPrivKey = NULL,
        pbCertificate = NULL;
    CERT_PUBLIC_KEY_INFO   
        CapiPubKeyInfo;
    HWID
        Hwid;
    TLS_HANDLE
        hServer;

    //
    // before we go through the trouble of generating private and public
    // keys, check if the license server is available.
    //

    hServer = TLSConnectToAnyLsServer(LS_DISCOVERY_TIMEOUT);
    if (NULL == hServer)
    {
        return( LICENSE_STATUS_NO_LICENSE_SERVER );
    }

    memset(&CapiPubKeyInfo, 0, sizeof(CapiPubKeyInfo));

    //
    // acquire exclusive access
    //

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

    //
    // Try to reload the certificate again, some other thread might have
    // install the certificate already.
    //

    Status = ReloadCSPCertificateAndData();
    if( LICENSE_STATUS_OK == Status )
    {
        goto done;
    }

    //
    // Generate a private/public key pair
    //

    Status = GenerateRsaKeyPair( 
                        &pbPubKey, 
                        &cbPubKey, 
                        &pbPrivKey, 
                        &cbPrivKey, 
                        RSA_KEY_LEN );
    
    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot generate RSA keypair\n" );
#endif

        goto done;
    }

    //
    // convert the Bsafe public key into a CAPI public key
    //

    Status = Bsafe2CapiPubKey( &CapiPubKeyInfo, pbPubKey, cbPubKey );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot convert Bsafe Key to CAPI key\n" );
#endif
        goto done;
    }

    //
    // generate a new hardware ID
    //

    Status = GenerateMachineHWID( &Hwid );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot generate certificate ID\n" );
#endif
        goto done;
    }

    //
    // sends the certificate request to the license server
    //

    Status = RequestCertificate( hServer, &CapiPubKeyInfo, &pbCertificate, &cbCertificate, &Hwid );

    TLSDisconnectFromServer( hServer );
    hServer = NULL;

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: error requesting terminal server certificate: %x\n", Status );
#endif
        goto done;
    }

    //
    // store the certificate identifier
    //
    
    Status = LsCsp_SetServerData( 
                        LsCspInfo_X509CertID, 
                        ( LPBYTE )&Hwid, 
                        sizeof( Hwid ) );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server certificate ID : %d\n", Status );
#endif
        goto done;
    }
 
    //
    // Stores the certificate and resets the global variable pointing
    // to the X509 certificate.
    //

    Status = LsCsp_SetServerData( 
                        LsCspInfo_X509Certificate, 
                        pbCertificate, 
                        cbCertificate );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server certificate : %d\n", Status );
#endif
        goto done;
    }

    //
    // Stores the private key and resets the global variable pointing to the
    // private key.
    //

    Status = LsCsp_SetServerData(
                        LsCspInfo_X509CertPrivateKey,
                        pbPrivKey,
                        cbPrivKey );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server private key %d\n", Status );
#endif
        goto done;
    }

    //
    // Store the public key so we can verify at startup time
    //
    
    Status = LsCsp_StoreSecret(
                        X509_CERT_PUBLIC_KEY_NAME,
                        pbPubKey,
                        cbPubKey
                    );

    if( LICENSE_STATUS_OK != Status )
    {
#if DBG
        DbgPrint( "LSCSP: LsCsp_InstallX509Certificate: cannot store terminal server public key : %d\n", Status );
#endif
    }


done:

    if (NULL != hServer)
    {
        TLSDisconnectFromServer( hServer );
        hServer = NULL;
    }

    //
    // release exclusive access
    //

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    if( pbCertificate )
    {
        LocalFree(pbCertificate);
    }

    if( pbPrivKey )
    {
        LocalFree( pbPrivKey );
    }

    if( pbPubKey )
    {
        LocalFree( pbPubKey );
    }

    FreeCapiPubKey( &CapiPubKeyInfo );

    return( Status );
}


/*++

Function:

    RequestCertificate

Routine Description:

    Request a certificate from the license server

Arguments:

    hServer - handle to license server
    pPubKeyInfo - The public key info to be included in the certificate
    ppbCertificate - The new certificate
    pcbCertificate - size of the certificate
    pHwid - The hardware ID that is used to identify the certificate

Return:

    LICENSE_STATUS return code

--*/

LICENSE_STATUS
RequestCertificate(     
    TLS_HANDLE              hServer,
    PCERT_PUBLIC_KEY_INFO   pPubKeyInfo,
    LPBYTE *                ppbCertificate,
    LPDWORD                 pcbCertificate,
    HWID *                  pHwid )
{
    LSHydraCertRequest
        CertRequest;
    LICENSE_STATUS
        Status;
    DWORD
        dwRpcCode,
        dwResult,
        cbChallengeData;
    LPBYTE
        pbChallengeData = NULL;

    if( ( NULL == ppbCertificate ) || 
        ( NULL == hServer ) || 
        ( NULL == pPubKeyInfo ) || 
        ( NULL == pcbCertificate ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    *ppbCertificate = NULL;
    *pcbCertificate = 0;

    memset( &CertRequest, 0, sizeof( CertRequest ) );

    CertRequest.dwHydraVersion = 0x00050000;
    
    LsCsp_EncryptHwid( pHwid, NULL, &CertRequest.cbEncryptedHwid );

    CertRequest.pbEncryptedHwid = LocalAlloc( LPTR, CertRequest.cbEncryptedHwid );

    if( NULL == CertRequest.pbEncryptedHwid )
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    Status = LsCsp_EncryptHwid( 
                    pHwid, 
                    CertRequest.pbEncryptedHwid, 
                    &CertRequest.cbEncryptedHwid );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }
    
    //
    // get the subject RDN
    //

    Status = GetSubjectRdn( &CertRequest.szSubjectRdn );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    CertRequest.SubjectPublicKeyInfo = pPubKeyInfo;

    //
    // request an X509 certificate from the license server
    //

    dwRpcCode = TLSRequestTermServCert(hServer,
                                       &CertRequest,
                                       &cbChallengeData,
                                       &pbChallengeData,
                                       &dwResult );

    if( ( RPC_S_OK != dwRpcCode ) || ( LSERVER_S_SUCCESS != dwResult ) )
    {
        Status = LICENSE_STATUS_CERTIFICATE_REQUEST_ERROR;
        goto done;
    }

    dwRpcCode = TLSRetrieveTermServCert(
                            hServer,
                            cbChallengeData,
                            pbChallengeData,
                            pcbCertificate,
                            ppbCertificate,
                            &dwResult );


    if( ( RPC_S_OK != dwRpcCode ) || ( LSERVER_ERROR_BASE <= dwResult ) )
    {

        Status = LICENSE_STATUS_CERTIFICATE_REQUEST_ERROR;
    }

done:

    if( CertRequest.pbEncryptedHwid )
    {
        LocalFree( CertRequest.pbEncryptedHwid );
    }

    if( CertRequest.szSubjectRdn )
    {
        LocalFree( CertRequest.szSubjectRdn );
    }

    if( pbChallengeData )
    {
        LocalFree( pbChallengeData );
    }

    return( Status );
}


/*++

Function:

    GetSubjectRdn

Routine Description:

    Construct the subject RDN for a certificate request

Argument:

    ppSubjectRdn - Return pointer to the subject RDN

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code.

--*/

LICENSE_STATUS
GetSubjectRdn(
    LPTSTR   * ppSubjectRdn )
{
    TCHAR
        ComputerName[ MAX_COMPUTERNAME_LENGTH + 1 ];
    DWORD
        RdnLen = 0,
        ComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;

    //
    // use the computer name uas the common name
    //

    GetComputerName( ComputerName, &ComputerNameLen );

    RdnLen += wcslen( TEXT( RDN_COMMON_NAME ) );
    RdnLen += ComputerNameLen + 1;
    RdnLen = RdnLen * sizeof( TCHAR );

    *ppSubjectRdn = LocalAlloc( LPTR, RdnLen );

    if( NULL == *ppSubjectRdn )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    wsprintf( *ppSubjectRdn, L"%s%s", TEXT( RDN_COMMON_NAME ), ComputerName );
    
    return( LICENSE_STATUS_OK );
}


/*++

Function:

    GenerateMachineHWID

Routine Description:

    Generate a hardware ID for this machine

Arguments:

    pHwid - Return value of the HWID

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code

--*/

LICENSE_STATUS
GenerateMachineHWID(
    PHWID    pHwid )    
{
    
    OSVERSIONINFO 
        osvInfo;
    DWORD
        cbCertId;
    LPBYTE
        pbCertId = NULL;

    if( NULL == pHwid )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // Create the HWID
    //

    memset( &osvInfo, 0, sizeof( OSVERSIONINFO ) );
    osvInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &osvInfo );

    pHwid->dwPlatformID = osvInfo.dwPlatformId;

    if (TSRNG_GenerateRandomBits( (LPBYTE) &( pHwid->Data1 ), sizeof(DWORD))
        && TSRNG_GenerateRandomBits( (LPBYTE) &( pHwid->Data2 ), sizeof(DWORD))
        && TSRNG_GenerateRandomBits( (LPBYTE) &( pHwid->Data3 ), sizeof(DWORD))
        && TSRNG_GenerateRandomBits( (LPBYTE) &( pHwid->Data4 ), sizeof(DWORD))
        )
    {
        return( LICENSE_STATUS_OK );
    }
    else
    {
        return ( LICENSE_STATUS_UNSPECIFIED_ERROR );
    }
}


/*++

Function:

    LsCsp_EncryptHwid

Routine Description:

    Encrypt the given hardward ID using the secret key shared by terminal
    and license servers.
    
Arguments:

    pHwid - The Hardware ID
    pbEncryptedHwid - The encrypted HWID
    pcbEncryptedHwid - Length of the encrypted HWID

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code otherwise.

--*/

LICENSE_STATUS
LsCsp_EncryptHwid(
    PHWID       pHwid,
    LPBYTE      pbEncryptedHwid,
    LPDWORD     pcbEncryptedHwid )
{
    LICENSE_STATUS
        Status;
    LPBYTE 
        pbSecretKey = NULL;
    DWORD
        cbSecretKey = 0;

    if( NULL == pcbEncryptedHwid )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    if( ( NULL == pbEncryptedHwid ) || 
        ( sizeof( HWID ) > *pcbEncryptedHwid ) )
    {
        *pcbEncryptedHwid = sizeof( HWID );
        return( LICENSE_STATUS_INSUFFICIENT_BUFFER );
    }

    LicenseGetSecretKey( &cbSecretKey, NULL );

    pbSecretKey = LocalAlloc( LPTR, cbSecretKey );

    if( NULL == pbSecretKey )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    //
    // Get the secret key used for encrypting the HWID
    //

    Status = LicenseGetSecretKey( &cbSecretKey, pbSecretKey );

    if( LICENSE_STATUS_OK != Status )
    {
        goto done;
    }

    Status = LicenseEncryptHwid(
                    pHwid,
                    pcbEncryptedHwid,
                    pbEncryptedHwid,
                    cbSecretKey,
                    pbSecretKey );

done:

    if( pbSecretKey )
    {
        LocalFree( pbSecretKey );
    }

    return( Status );

}


/*++

Function:

    LsCsp_DecryptHwid

Routine Description:

    Decrypt the given hardware ID

Arguments:

    pHwid - The decrypted hardware ID
    pbEncryptedHwid - The encrypted hardware ID
    cbEncryptedHwid - Length of the encrypted hardware ID

Return:

    LICENSE_STATUS_OK if successful or a LICENSE_STATUS error code.

--*/

LICENSE_STATUS
LsCsp_DecryptHwid(
    PHWID       pHwid,
    LPBYTE      pbEncryptedHwid,
    LPDWORD     pcbEncryptedHwid )
{
    return( LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_StoreSecret

Description:

    Use LSA to store a secret private key.

Arguments:

    ptszKeyName - Name used to identify the secret private key.
    pbKey - Points to the secret private key.
    cbKey - Length of the private key.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_StoreSecret(
    PTCHAR  ptszKeyName,
    BYTE *  pbKey,
    DWORD   cbKey )
{
    LSA_HANDLE 
        PolicyHandle;
    UNICODE_STRING 
        SecretKeyName;
    UNICODE_STRING 
        SecretData;
    DWORD 
        Status;
    
    if( ( NULL == ptszKeyName ) || ( 0xffff < cbKey) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //
    
    InitLsaString( &SecretKeyName, ptszKeyName );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( NULL, POLICY_CREATE_SECRET, &PolicyHandle );

    if( ERROR_SUCCESS != Status )
    {
        return ( LICENSE_STATUS_CANNOT_OPEN_SECRET_STORE );
    }

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                &SecretData
                );

    LsaClose( PolicyHandle );

    Status = LsaNtStatusToWinError( Status );

    if( ERROR_SUCCESS != Status )
    {
        return( LICENSE_STATUS_CANNOT_STORE_SECRET );
    }
    
    return( LICENSE_STATUS_OK );
}


/*++

Function:

    LsCsp_RetrieveSecret

Description:

    Retrieve the secret private key that is stored by LSA.

Arguments:

    ptszKeyName - The name used to identify the secret private key.
    ppbKey - Return value of the private key
    pcbKey - Length of the private key.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_RetrieveSecret(
    PTCHAR      ptszKeyName,
    PBYTE       pbKey,
    DWORD *     pcbKey )
{
    LSA_HANDLE 
        PolicyHandle;
    UNICODE_STRING 
        SecretKeyName;
    UNICODE_STRING * 
        pSecretData = NULL;
    DWORD 
        Status;
    LICENSE_STATUS
        LicenseStatus = LICENSE_STATUS_OK;

    if( ( NULL == ptszKeyName ) || ( NULL == pcbKey ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString( &SecretKeyName, ptszKeyName );

    Status = OpenPolicy( NULL, POLICY_GET_PRIVATE_INFORMATION, &PolicyHandle );

    if( ERROR_SUCCESS != Status )
    {
#if DBG
        DbgPrint( "LSCSP: cannot open LSA policy handle: %x\n", Status );
#endif
        return( LICENSE_STATUS_CANNOT_OPEN_SECRET_STORE );
    }

    Status = LsaNtStatusToWinError( LsaRetrievePrivateData(
                                            PolicyHandle,
                                            &SecretKeyName,
                                            &pSecretData ) );

    LsaClose( PolicyHandle );

    if (( ERROR_SUCCESS != Status ) || (NULL == pSecretData) || (pSecretData->Length == 0))
    {
#if DBG
        DbgPrint( "LSCSP: cannot retrieve LSA data: %x\n", Status );
#endif
        return( LICENSE_STATUS_CANNOT_RETRIEVE_SECRET );
    }

    if( NULL == pbKey )
    {
        *pcbKey = pSecretData->Length;
    }
    else
    {
        if( pSecretData->Length > *pcbKey )
        {
            LicenseStatus = LICENSE_STATUS_INSUFFICIENT_BUFFER;
        }
        else
        {
            CopyMemory( pbKey, pSecretData->Buffer, pSecretData->Length );
        }

        *pcbKey = pSecretData->Length;
    }

    SecureZeroMemory( pSecretData->Buffer, pSecretData->Length );
    LsaFreeMemory( pSecretData );

    return( LicenseStatus );
}


/*++

Function:

    OpenPolicy

Description:

    Obtain an LSA policy handle used to perform subsequent LSA operations.

Arguments:

    ServerName - The server which the handle should be obtained from.
    DesiredAccess - The access given to the handle
    PolicyHandle - The policy handle

Return:

    A Win32 return code.

--*/

NTSTATUS
OpenPolicy(
    LPWSTR ServerName,
    DWORD DesiredAccess,
    PLSA_HANDLE PolicyHandle )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //
 
    SecureZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName ) 
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString(&ServerString, ServerName);
        Server = &ServerString;

    } 
    else 
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //
    
    return( LsaNtStatusToWinError( LsaOpenPolicy(
                                            Server,
                                            &ObjectAttributes,
                                            DesiredAccess,
                                            PolicyHandle ) ) );
}


/*++

Function:

    InitLsaString

Description:

    Initialize a UNICODE string to LSA UNICODE string format.

Arguments:

    LsaString - the LSA UNICODE string.
    String - UNICODE string

Return:

    Nothing.

--*/

void
InitLsaString(
    PLSA_UNICODE_STRING LsaString,
    LPWSTR String )
{
    DWORD StringLength;

    if( NULL == String ) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) StringLength * sizeof( WCHAR );
    LsaString->MaximumLength=( USHORT )( StringLength + 1 ) * sizeof( WCHAR );
}


/*++

Function:

    LsCsp_SetServerData

Description:

    Saves the specified data.

Arguments:

    Info - The data type of the data to be saved.
    pBlob - Points to the data to be saved.
    dwBlobLen - Length of the data to be saved.

Return:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_SetServerData(
    LSCSPINFO   Info,
    LPBYTE      pBlob,
    DWORD       dwBlobLen )
{
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;
    DWORD
        dwResult,
        dwDisp,
        * pdwCspDataLen;
    LPTSTR
        lpRegValue;
    PWCHAR
        pwszKeyName;
    LPBYTE *
        ppCspData;
    HKEY
        hKey = NULL;

    ASSERT( dwBlobLen != 0 );
    ASSERT( pBlob != NULL );

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);

        
    switch (Info) {

    case LsCspInfo_Certificate:

        //
        // set proprietory certificate data
        //

        lpRegValue = TEXT( HYDRA_CERTIFICATE_VALUE );
        ppCspData = &csp_abServerCertificate;
        pdwCspDataLen = &csp_dwServerCertificateLen;

        break;

    case LsCspInfo_X509Certificate:

        //
        // set X509 certificate data
        //

        lpRegValue = TEXT( HYDRA_X509_CERTIFICATE );
        ppCspData = &csp_abServerX509Cert;
        pdwCspDataLen = &csp_dwServerX509CertLen;

        break;
    
    case LsCspInfo_PrivateKey:

        //
        // set the private key that corresponds to the proprietory certificate
        //

        pwszKeyName = PRIVATE_KEY_NAME;
        ppCspData = &csp_abServerPrivateKey;
        pdwCspDataLen = &csp_dwServerPrivateKeyLen;

        break;

    case LsCspInfo_X509CertPrivateKey:

        //
        // set private key that corresponds to the X509 certificate
        //

        pwszKeyName = X509_CERT_PRIVATE_KEY_NAME;
        ppCspData = &csp_abX509CertPrivateKey;
        pdwCspDataLen = &csp_dwX509CertPrivateKeyLen;

        break;

    case LsCspInfo_X509CertID:

        //
        // Set the X509 certificate ID
        //

        lpRegValue = TEXT( HYDRA_X509_CERT_ID );
        ppCspData = &csp_abX509CertID;
        pdwCspDataLen = &csp_dwX509CertIDLen;

        break;

    default:

        Status = LICENSE_STATUS_INVALID_INPUT;
        goto i_done;
    }

    if( ( LsCspInfo_X509CertPrivateKey == Info ) ||
        ( LsCspInfo_PrivateKey == Info ) )
    {
        //
        // store secret key information
        //

        dwResult = LsCsp_StoreSecret( pwszKeyName, pBlob, dwBlobLen );

        if( ERROR_SUCCESS != dwResult )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }                   
    }
    else
    {
        //
        // Open the Registry
        //

        if( RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT( HYDRA_CERT_REG_KEY ),
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE,
                    NULL,
                    &hKey,
                    &dwDisp ) != ERROR_SUCCESS )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }

        //
        // Sets the value in the registry
        //

        if( ERROR_SUCCESS != RegSetValueEx(
                                    hKey,
                                    lpRegValue,
                                    0,      
                                    REG_BINARY,
                                    pBlob,
                                    dwBlobLen ) )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }
    }
    
    //
    // reset the global data with the new data that we have just set
    //

    if ( *ppCspData )
    {
        LocalFree( *ppCspData );
    }
    
    *ppCspData = ( LPBYTE )LocalAlloc( LPTR, dwBlobLen );

    if( NULL == *ppCspData )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto i_done;
    }

    memcpy( *ppCspData, pBlob, dwBlobLen );
    *pdwCspDataLen = dwBlobLen;
    
i_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return( Status );
}


/*++

Function:

    LsCsp_NukeServerData

Description:

    Permanently deletes the specified server data.

Arguments:

    Info - The type of data to nuke.

Returns:

    A LICENSE_STATUS return code.

--*/

LICENSE_STATUS
LsCsp_NukeServerData(
    LSCSPINFO   Info )
{
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK; 
    LPTSTR
        lpRegValue;
    PWCHAR
        pwszKeyName;
    HKEY
        hKey = NULL;
    LPBYTE *
        ppCspData;
    DWORD * 
        pdwCspDataLen;
    DWORD
        dwResult;

    ACQUIRE_EXCLUSIVE_ACCESS(csp_hMutex);


    switch (Info) {

    case LsCspInfo_X509Certificate:

        //
        // delete X509 certificate data
        //

        lpRegValue = TEXT( HYDRA_X509_CERTIFICATE );
        ppCspData = &csp_abServerX509Cert;
        pdwCspDataLen = &csp_dwServerX509CertLen;

        break;
    
    case LsCspInfo_X509CertPrivateKey:

        //
        // delete the private key that corresponds to the X509 certificate
        //

        pwszKeyName = X509_CERT_PRIVATE_KEY_NAME;
        ppCspData = &csp_abX509CertPrivateKey;
        pdwCspDataLen = &csp_dwX509CertPrivateKeyLen;

        break;

    case LsCspInfo_X509CertID:

        //
        // delete the X509 certificate ID
        //

        lpRegValue = TEXT( HYDRA_X509_CERT_ID );
        ppCspData = &csp_abX509CertID;
        pdwCspDataLen = &csp_dwX509CertIDLen;

        break;

    default:

        Status = LICENSE_STATUS_INVALID_INPUT;
        goto i_done;        
    }

    if( (LsCspInfo_X509CertPrivateKey == Info ) ||
        ( LsCspInfo_PrivateKey == Info ) )
    {
        //
        // delete secret info stored by LSA
        //

        dwResult = LsCsp_StoreSecret( pwszKeyName, NULL, 0 );

        if( ERROR_SUCCESS != dwResult )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }                   
    }
    else
    {
        //
        // Delete the data kept in the registry
        //

        if( RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    TEXT( HYDRA_CERT_REG_KEY ),
                    0,
                    KEY_WRITE,
                    &hKey ) != ERROR_SUCCESS )
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }

        //
        // Delete the value in the registry
        //

        if( ERROR_SUCCESS != RegDeleteValue( hKey, lpRegValue ) )  
        {
            Status = LICENSE_STATUS_WRITE_STORE_ERROR;
            goto i_done;
        }
    }

    if ( *ppCspData )
    {
        //
        // free the memory allocated for the global variable.
        //

        LocalFree( *ppCspData );
        *ppCspData = NULL;
        *pdwCspDataLen = 0;
    }
    
i_done:

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex ); 


    if( hKey )
    {
        RegCloseKey( hKey );
    }

    return( Status );
}


/*++

Function:

    GenerateKeyPair

Routine Description:

   This function generates a private/public key pair.

Arguments:

   ppbPublicKey - Return pointer to public Key
   pcbPublicKey - Size of public key
   ppbPrivateKey - Return pointer to private key
   pcbPrivateKey - size of private key
   dwKeyLen - Desired key length

Return Value:

   LICENSE_STATUS return code.

--*/

LICENSE_STATUS
GenerateRsaKeyPair(
    LPBYTE *     ppbPublicKey,
    LPDWORD      pcbPublicKey,
    LPBYTE *     ppbPrivateKey,
    LPDWORD      pcbPrivateKey,
    DWORD        dwKeyLen )
{
    DWORD
        dwBits = dwKeyLen;
    LICENSE_STATUS
        Status = LICENSE_STATUS_OK;

    *ppbPublicKey = NULL;
    *ppbPrivateKey = NULL;

    //
    // find out the size of the private and public key sizes and allocate
    // memory for them.
    //

    dwBits = BSafeComputeKeySizes( pcbPublicKey, pcbPrivateKey, &dwBits );

    *ppbPrivateKey = ( LPBYTE )LocalAlloc( LPTR, *pcbPrivateKey );

    if( NULL == *ppbPrivateKey )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    *ppbPublicKey = ( LPBYTE )LocalAlloc( LPTR, *pcbPublicKey );

    if( NULL == *ppbPublicKey )
    {
        Status = LICENSE_STATUS_OUT_OF_MEMORY;
        goto ErrorExit;
    }

    //
    // generate the private/public key pair
    //

    if( !BSafeMakeKeyPair( ( LPBSAFE_PUB_KEY )*ppbPublicKey,
                           ( LPBSAFE_PRV_KEY )*ppbPrivateKey,
                           dwKeyLen) )
    {
        Status = LICENSE_STATUS_CANNOT_MAKE_KEY_PAIR;
        goto ErrorExit;
    }

    return( Status ); 

ErrorExit:

    if( *ppbPublicKey )
    {
        LocalFree( *ppbPublicKey );
        *pcbPublicKey = 0;
        *ppbPublicKey = NULL;
    }

    if( *ppbPrivateKey )
    {
        LocalFree( *ppbPrivateKey );
        *pcbPrivateKey = 0;
        *ppbPrivateKey = NULL;
    }

    return( Status );
}


/*++

Function:

    Bsafe2CapiPubKey

Routine Description:

    Converts a Bsafe public key to a CAPI public key info structure

Arguments:

    pCapiPubKeyInfo - Pointer to the CAPI public key info structure
    pbBsafePubKey - Pointer to the Bsafe public key
    cbBsafePubKey - size of the Bsafe public key


Returns:

    LICENSE_STATUS return code.

--*/

LICENSE_STATUS
Bsafe2CapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo,
    LPBYTE                  pbBsafeKey,
    DWORD                   cbBsafeKey )
{
    PUBLICKEYSTRUC *
        pCapiPublicKey;
    RSAPUBKEY *
        pRsaPublicKey;
    LPBSAFE_PUB_KEY
        pBsafePubKey = ( LPBSAFE_PUB_KEY )pbBsafeKey;
    LPBYTE
        pbKeyMem = NULL,
        pbEncodedPubKey = NULL;
    DWORD
        cbKeyMem,
        dwError,
        cbEncodedPubKey = 0;
    LICENSE_STATUS
        Status;
    
    if( ( NULL == pbBsafeKey ) || ( 0 == cbBsafeKey ) )
    {
        return( LICENSE_STATUS_INVALID_INPUT );
    }

    cbKeyMem = sizeof( PUBLICKEYSTRUC ) + sizeof( RSAPUBKEY ) + pBsafePubKey->keylen;
    pbKeyMem = ( LPBYTE )LocalAlloc( LPTR, cbKeyMem );

    if( NULL == pbKeyMem )
    {
        return( LICENSE_STATUS_OUT_OF_MEMORY );
    }

    //
    // convert the Bsafe public key to a crypto API public key structure.  
    // Note: make this a key exchange public key
    //

    pCapiPublicKey = ( PUBLICKEYSTRUC * )pbKeyMem;

    pCapiPublicKey->bType = PUBLICKEYBLOB;
    pCapiPublicKey->bVersion = CAPI_MAX_VERSION;
    pCapiPublicKey->reserved = 0;
    pCapiPublicKey->aiKeyAlg = CALG_RSA_KEYX;

    pRsaPublicKey = ( RSAPUBKEY * )( pbKeyMem + sizeof( PUBLICKEYSTRUC ) );
    
    pRsaPublicKey->magic = RSA1;
    pRsaPublicKey->bitlen = pBsafePubKey->bitlen;
    pRsaPublicKey->pubexp = pBsafePubKey->pubexp;

    memcpy( pbKeyMem + sizeof( PUBLICKEYSTRUC ) + sizeof( RSAPUBKEY ), 
            pbBsafeKey + sizeof( BSAFE_PUB_KEY ), 
            pBsafePubKey->keylen );

    //
    // encode the public key structure
    //

    __try
    {
        if( CryptEncodeObject( X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB , pbKeyMem, 
                               NULL, &cbEncodedPubKey ) )
        {
            pbEncodedPubKey = ( LPBYTE )LocalAlloc( LPTR, cbEncodedPubKey );

            if( NULL == pbEncodedPubKey )
            {
                Status = LICENSE_STATUS_OUT_OF_MEMORY;
                goto done;
            }

            memset( pbEncodedPubKey, 0, cbEncodedPubKey );

            if( !CryptEncodeObject( X509_ASN_ENCODING, RSA_CSP_PUBLICKEYBLOB , pbKeyMem, 
                                    pbEncodedPubKey, &cbEncodedPubKey ) )
            {
                Status = LICENSE_STATUS_ASN_ERROR;
                goto done;
            }    
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        DWORD dwExceptionCode = GetExceptionCode();

#if DBG
        DbgPrint( "LICECSP:  cannot encode server key pair: 0x%x\n", dwExceptionCode );
#endif
        Status = LICENSE_STATUS_ASN_ERROR;
        goto done;
    }

    //
    // now we can initialize the CAPI public key info structure
    //

    memset( pCapiPubKeyInfo, 0, sizeof( CERT_PUBLIC_KEY_INFO ) );
    
    pCapiPubKeyInfo->Algorithm.pszObjId = szOID_RSA_MD5RSA;
    pCapiPubKeyInfo->Algorithm.Parameters.cbData = 0;
    pCapiPubKeyInfo->Algorithm.Parameters.pbData = NULL;

    pCapiPubKeyInfo->PublicKey.cbData = cbEncodedPubKey;
    pCapiPubKeyInfo->PublicKey.pbData = pbEncodedPubKey;

    Status = LICENSE_STATUS_OK;

done:

    if( pbKeyMem )
    {
        LocalFree( pbKeyMem );
    }

    return( Status );
}


/*++

Function:

    FreeCapiPubKey

Routine Description:

    Free the memory in a capi pub key structure

Arguments:

    pCapiPubKeyInfo - Pointer to the CAPI public key info structure

Returns:

    Windows return code.

--*/

VOID
FreeCapiPubKey(
    PCERT_PUBLIC_KEY_INFO   pCapiPubKeyInfo )
{
    if( pCapiPubKeyInfo->Algorithm.Parameters.pbData )
    {
        LocalFree( pCapiPubKeyInfo->Algorithm.Parameters.pbData );
        pCapiPubKeyInfo->Algorithm.Parameters.pbData = NULL;
    }

    if( pCapiPubKeyInfo->PublicKey.pbData )
    {
        LocalFree( pCapiPubKeyInfo->PublicKey.pbData );
        pCapiPubKeyInfo->PublicKey.pbData = NULL;
    }

    return;
}

//////////////////////////////////////////////////////////////////

DWORD
VerifyTermServCertificate(
    DWORD cbCertLen,
    PBYTE pbCert,
    DWORD cbPrivateKeyLen,
    PBYTE pbPrivateKey
    )
/*++

Function :
    
    VerifyTermServCertificate

Routine Description:

    Verify TermSrv's X509 Certificate issued License Server, caller
    must protect this call with critical section or mutex.

Arguments:

    cbCertLen : size of TermSrv certificate.
    pbCertLen : Pointer to TermSrv certificate to be verify.
    cbPrivateKeyLen : Size of TermSrv private key.
    pbPrivateKey : pointer to TermSrv private key.

Returns:

    TRUE/FALSE

--*/
{
    LICENSE_STATUS dwStatus = LICENSE_STATUS_OK;
    PBYTE pbPublicKeyInLsa = NULL;
    DWORD cbPublicKeyInLsa = 0;

    PBYTE pbPublicKeyInCert = NULL;
    DWORD cbPublicKeyInCert = 0;
    DWORD pfDates;

    CERT_PUBLIC_KEY_INFO CapiPubKeyInfoLsa;
    CERT_PUBLIC_KEY_INFO CapiPubKeyInfoCert;


    if(0 == cbCertLen || NULL == pbCert || 0 == cbPrivateKeyLen || NULL == pbPrivateKey)
    {
        ASSERT( 0 != cbCertLen && NULL != pbCert && 0 != cbPrivateKeyLen && NULL != pbPrivateKey );
        return LICENSE_STATUS_INVALID_INPUT;
    }

    //
    // try except here is to prevent memory leak
    //
    __try {

        memset(&CapiPubKeyInfoLsa, 0, sizeof(CapiPubKeyInfoLsa));
        memset(&CapiPubKeyInfoCert, 0, sizeof(CapiPubKeyInfoCert));


        // 
        // Load the public key from LSA
        //
    
        dwStatus = LsCsp_RetrieveSecret(
                                X509_CERT_PUBLIC_KEY_NAME,
                                NULL,
                                &cbPublicKeyInLsa
                            );

        if( LICENSE_STATUS_OK != dwStatus || 0 == cbPublicKeyInLsa )
        {

            #if DBG
            DbgPrint( "LSCSP: VerifyTermServCertificate() No public key...\n" );
            #endif

            dwStatus = LICENSE_STATUS_CANNOT_RETRIEVE_SECRET;
            goto cleanup;
        }

        // allocate memory
        pbPublicKeyInLsa = (PBYTE)LocalAlloc(LPTR, cbPublicKeyInLsa);
        if(NULL == pbPublicKeyInLsa)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
            goto cleanup;
        }

        dwStatus = LsCsp_RetrieveSecret(
                                X509_CERT_PUBLIC_KEY_NAME,
                                pbPublicKeyInLsa,
                                &cbPublicKeyInLsa
                            );

        if( LICENSE_STATUS_OK != dwStatus || 0 == cbPublicKeyInLsa )
        {
            dwStatus = LICENSE_STATUS_CANNOT_RETRIEVE_SECRET;
            goto cleanup;
        }


        //
        // Verify certificate and compare public key
        //

        //
        // Try to avoid calling VerifyCertChain() twice.
        //
        cbPublicKeyInCert = 1024;
        pbPublicKeyInCert = (PBYTE)LocalAlloc(LPTR, cbPublicKeyInCert);
        if(NULL == pbPublicKeyInCert)
        {
            dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
            goto cleanup;
        }

        pfDates = CERT_DATE_DONT_VALIDATE;
        dwStatus = VerifyCertChain(
                                pbCert,
                                cbCertLen,
                                pbPublicKeyInCert,
                                &cbPublicKeyInCert,
                                &pfDates
                            );

        if(LICENSE_STATUS_OK != dwStatus && LICENSE_STATUS_INSUFFICIENT_BUFFER != dwStatus)   
        {

            #if DBG
            DbgPrint( "LSCSP: VerifyCertChain() failed with error code %d\n", dwStatus );
            #endif

            goto cleanup;
        }

        if( dwStatus == LICENSE_STATUS_INSUFFICIENT_BUFFER )
        {
            if( NULL != pbPublicKeyInCert )
            {
                LocalFree(pbPublicKeyInCert);
            }

            pbPublicKeyInCert = (PBYTE)LocalAlloc(LPTR, cbPublicKeyInCert);
            if(NULL == pbPublicKeyInCert)
            {
                dwStatus = LICENSE_STATUS_OUT_OF_MEMORY;
                goto cleanup;
            }

            pfDates = CERT_DATE_DONT_VALIDATE;
            dwStatus = VerifyCertChain(
                                    pbCert,
                                    cbCertLen,
                                    pbPublicKeyInCert,
                                    &cbPublicKeyInCert,
                                    &pfDates
                                );

            if(LICENSE_STATUS_OK != dwStatus)
            {
                goto cleanup;
            }
        }

        dwStatus = Bsafe2CapiPubKey(
                                &CapiPubKeyInfoCert, 
                                pbPublicKeyInCert, 
                                cbPublicKeyInCert 
                            );  

        if(LICENSE_STATUS_OK != dwStatus)
        {
            #if DBG
            DbgPrint( 
                    "LSCSP: Bsafe2CapiPubKey() on public key in certificate failed with %d\n", 
                    dwStatus
                );
            #endif

            goto cleanup;
        }

        dwStatus = Bsafe2CapiPubKey(
                                &CapiPubKeyInfoLsa, 
                                pbPublicKeyInLsa, 
                                cbPublicKeyInLsa 
                            );  

        if(LICENSE_STATUS_OK != dwStatus)
        {
            #if DBG
            DbgPrint( 
                    "LSCSP: Bsafe2CapiPubKey() on public key in LSA failed with %d\n", 
                    dwStatus
                );
            #endif

            goto cleanup;
        }


        //
        // compare public key
        //
        if( CapiPubKeyInfoCert.PublicKey.cbData != CapiPubKeyInfoLsa.PublicKey.cbData )
        {

            #if DBG
            DbgPrint( 
                    "LSCSP: public key length mismatched %d %d\n", 
                    CapiPubKeyInfoCert.PublicKey.cbData, 
                    CapiPubKeyInfoLsa.PublicKey.cbData 
                );
            #endif

            dwStatus = LICENSE_STATUS_INVALID_CERTIFICATE;
        }
        else if( memcmp(
                        CapiPubKeyInfoCert.PublicKey.pbData, 
                        CapiPubKeyInfoLsa.PublicKey.pbData, 
                        CapiPubKeyInfoLsa.PublicKey.cbData
                    ) != 0 )
        {

            #if DBG
            DbgPrint( "LSCSP: public mismatched\n" );
            #endif

            dwStatus = LICENSE_STATUS_INVALID_CERTIFICATE;
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER ) {
        dwStatus = LICENSE_STATUS_INVALID_INPUT;
    }

cleanup:

    FreeCapiPubKey( &CapiPubKeyInfoCert );
    FreeCapiPubKey( &CapiPubKeyInfoLsa );

    if( NULL != pbPublicKeyInLsa )
    {
        LocalFree( pbPublicKeyInLsa );
    }

    if( NULL != pbPublicKeyInCert )
    {
        LocalFree( pbPublicKeyInCert );
    }

    return dwStatus;
}

//////////////////////////////////////////////////////////////////

LICENSE_STATUS
ReloadCSPCertificateAndData()
{
    BOOL bSuccess;

    DWORD Status = LICENSE_STATUS_OK;
    LPBYTE i_csp_abServerX509Cert = NULL;
    DWORD  i_csp_dwServerX509CertLen = 0;
    
    DWORD i_csp_dwX509CertPrivateKeyLen = 0;
    LPBYTE i_csp_abX509CertPrivateKey = NULL;

    LPBYTE i_csp_abX509CertID = NULL;
    DWORD i_csp_dwX509CertIDLen = 0;

    HKEY    hKey = NULL;
    DWORD   dwResult, dwDisp;


    //
    // Acquire exclusive access
    //
    ACQUIRE_EXCLUSIVE_ACCESS( csp_hMutex );

    //
    // Prevent re-loading of same certificate/private key
    //
    if( NULL == csp_abServerX509Cert || 0 == csp_dwServerX509CertLen ||
        NULL == csp_abX509CertPrivateKey || 0 == csp_dwX509CertPrivateKeyLen || 
        NULL == csp_abX509CertID || 0 == csp_dwX509CertIDLen )
    {

        //
        // Open the Registry
        //
        if( RegCreateKeyEx(
                        HKEY_LOCAL_MACHINE,
                        TEXT( HYDRA_CERT_REG_KEY ),
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_READ | KEY_WRITE,
                        NULL,
                        &hKey,
                        &dwDisp ) != ERROR_SUCCESS )
        {
            Status = LICENSE_STATUS_NO_CERTIFICATE;
        }
        else
        {
            __try {

                //
                // Get the X509 certificate from the registry. 
                //

                Status = LsCsp_GetBinaryData( 
                                    hKey,
                                    TEXT( HYDRA_X509_CERTIFICATE ),
                                    &i_csp_abServerX509Cert,
                                    &i_csp_dwServerX509CertLen 
                                );

                if( LICENSE_STATUS_OK == Status && 0 != i_csp_dwServerX509CertLen )
                {
                    //
                    // Get the corresponding private key from the store.
                    // It is not OK if we have the X509 certificate but not the
                    // private key that goes with it.
                    //

                    Status = LsCsp_RetrieveSecret( 
                                            X509_CERT_PRIVATE_KEY_NAME, 
                                            NULL,
                                            &i_csp_dwX509CertPrivateKeyLen 
                                        );

                    if( LICENSE_STATUS_OK == Status )
                    {
                        i_csp_abX509CertPrivateKey = LocalAlloc( LPTR, i_csp_dwX509CertPrivateKeyLen );

                        if( NULL != i_csp_abX509CertPrivateKey )
                        {
                            Status = LsCsp_RetrieveSecret( 
                                                    X509_CERT_PRIVATE_KEY_NAME, 
                                                    i_csp_abX509CertPrivateKey,
                                                    &i_csp_dwX509CertPrivateKeyLen 
                                                );

                            if(LICENSE_STATUS_OK == Status)
                            {
                                //
                                // Get the certificate ID for the X509 certificate
                                //

                                Status = LsCsp_GetBinaryData(
                                                    hKey,
                                                    TEXT( HYDRA_X509_CERT_ID ),
                                                    &i_csp_abX509CertID,
                                                    &i_csp_dwX509CertIDLen 
                                                );
                            }
                        }
                        else // memory allocate 
                        {
                            Status = LICENSE_STATUS_OUT_OF_MEMORY;
                        }
                    }
                }
                else
                {
                    Status = LICENSE_STATUS_NO_CERTIFICATE;
                }

            }
            __except( EXCEPTION_EXECUTE_HANDLER ) {
                Status = LICENSE_STATUS_INVALID_INPUT;
            }
        }


        //
        // verify our certificate
        //
        if(LICENSE_STATUS_OK == Status)
        {
            Status = VerifyTermServCertificate(
                                        i_csp_dwServerX509CertLen, 
                                        i_csp_abServerX509Cert, 
                                        i_csp_dwX509CertPrivateKeyLen, 
                                        i_csp_abX509CertPrivateKey
                                    );

            if( LICENSE_STATUS_OK != Status )
            {
                //
                // Deleting the X509 certificate is enough.
                //
                RegDeleteValue( hKey, TEXT( HYDRA_X509_CERTIFICATE ) );
            }
        }
            
        if(LICENSE_STATUS_OK != Status)
        {
            if( NULL != i_csp_abServerX509Cert )
            {
                LocalFree( i_csp_abServerX509Cert );
            }
       
            if( NULL != i_csp_abX509CertPrivateKey )
            {
                LocalFree( i_csp_abX509CertPrivateKey );
            }

            if( NULL != i_csp_abX509CertID )
            {
                LocalFree( i_csp_abX509CertID );
            }
        }
        else 
        {
            csp_abServerX509Cert = i_csp_abServerX509Cert;
            csp_dwServerX509CertLen = i_csp_dwServerX509CertLen;

            csp_dwX509CertPrivateKeyLen = i_csp_dwX509CertPrivateKeyLen;
            csp_abX509CertPrivateKey = i_csp_abX509CertPrivateKey;

            csp_abX509CertID = i_csp_abX509CertID;
            csp_dwX509CertIDLen = i_csp_dwX509CertIDLen;
        }
    }

    RELEASE_EXCLUSIVE_ACCESS( csp_hMutex );

    if (hKey)
    {
        RegCloseKey(hKey);
    }

    return Status;
}

LICENSE_STATUS
CreateProprietaryKeyAndCert(
    PBYTE *ppbPrivateKey,
    DWORD *pcbPrivateKey,
    PBYTE *ppbServerCert,
    DWORD *pcbServerCert
    )
{
#define     MD5RSA      0x01;
#define     RSAKEY      0x01;

    LPBSAFE_PRV_KEY		PRV;
    Hydra_Server_Cert   Cert;
    DWORD               KeyLen = 512;
    DWORD               bits, j;
    DWORD               dwPubSize, dwPrivSize;
    BYTE                *kPublic;
    BYTE                *kPrivate;
    MD5_CTX             HashState;
    PBYTE               pbData, pbTemp = NULL;
    DWORD               dwTemp = 0;
    BYTE                pbHash[0x48];
    BYTE                Output[0x48];
    unsigned char prvmodulus[] =
    {
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
        0x3d, 0x3a, 0x5e, 0xbd,
        0x72, 0x43, 0x3e, 0xc9, 0x4d, 0xbb, 0xc1, 0x1e,
        0x4a, 0xba, 0x5f, 0xcb, 0x3e, 0x88, 0x20, 0x87,
        0xef, 0xf5, 0xc1, 0xe2, 0xd7, 0xb7, 0x6b, 0x9a,
        0xf2, 0x52, 0x45, 0x95, 0xce, 0x63, 0x65, 0x6b,
        0x58, 0x3a, 0xfe, 0xef, 0x7c, 0xe7, 0xbf, 0xfe,
        0x3d, 0xf6, 0x5c, 0x7d, 0x6c, 0x5e, 0x06, 0x09,
        0x1a, 0xf5, 0x61, 0xbb, 0x20, 0x93, 0x09, 0x5f,
        0x05, 0x6d, 0xea, 0x87, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x3f, 0xbd, 0x29, 0x20,
        0x57, 0xd2, 0x3b, 0xf1, 0x07, 0xfa, 0xdf, 0xc1,
        0x16, 0x31, 0xe4, 0x95, 0xea, 0xc1, 0x2a, 0x46,
        0x2b, 0xad, 0x88, 0x57, 0x55, 0xf0, 0x57, 0x58,
        0xc6, 0x6f, 0x95, 0xeb, 0x00, 0x00, 0x00, 0x00,
        0x83, 0xdd, 0x9d, 0xd0, 0x03, 0xb1, 0x5a, 0x9b,
        0x9e, 0xb4, 0x63, 0x02, 0x43, 0x3e, 0xdf, 0xb0,
        0x52, 0x83, 0x5f, 0x6a, 0x03, 0xe7, 0xd6, 0x78,
        0x45, 0x83, 0x6a, 0x5b, 0xc4, 0xcb, 0xb1, 0x93,
        0x00, 0x00, 0x00, 0x00, 0x65, 0x9d, 0x43, 0xe8,
        0x48, 0x17, 0xcd, 0x29, 0x7e, 0xb9, 0x26, 0x5c,
        0x79, 0x66, 0x58, 0x61, 0x72, 0x86, 0x6a, 0xa3,
        0x63, 0xad, 0x63, 0xb8, 0xe1, 0x80, 0x4c, 0x0f,
        0x36, 0x7d, 0xd9, 0xa6, 0x00, 0x00, 0x00, 0x00,
        0x75, 0x3f, 0xef, 0x5a, 0x01, 0x5f, 0xf6, 0x0e,
        0xd7, 0xcd, 0x59, 0x1c, 0xc6, 0xec, 0xde, 0xf3,
        0x5a, 0x03, 0x09, 0xff, 0xf5, 0x23, 0xcc, 0x90,
        0x27, 0x1d, 0xaa, 0x29, 0x60, 0xde, 0x05, 0x6e,
        0x00, 0x00, 0x00, 0x00, 0xc0, 0x17, 0x0e, 0x57,
        0xf8, 0x9e, 0xd9, 0x5c, 0xf5, 0xb9, 0x3a, 0xfc,
        0x0e, 0xe2, 0x33, 0x27, 0x59, 0x1d, 0xd0, 0x97,
        0x4a, 0xb1, 0xb1, 0x1f, 0xc3, 0x37, 0xd1, 0xd6,
        0xe6, 0x9b, 0x35, 0xab, 0x00, 0x00, 0x00, 0x00,
        0x87, 0xa7, 0x19, 0x32, 0xda, 0x11, 0x87, 0x55,
        0x58, 0x00, 0x16, 0x16, 0x25, 0x65, 0x68, 0xf8,
        0x24, 0x3e, 0xe6, 0xfa, 0xe9, 0x67, 0x49, 0x94,
        0xcf, 0x92, 0xcc, 0x33, 0x99, 0xe8, 0x08, 0x60,
        0x17, 0x9a, 0x12, 0x9f, 0x24, 0xdd, 0xb1, 0x24,
        0x99, 0xc7, 0x3a, 0xb8, 0x0a, 0x7b, 0x0d, 0xdd,
        0x35, 0x07, 0x79, 0x17, 0x0b, 0x51, 0x9b, 0xb3,
        0xc7, 0x10, 0x01, 0x13, 0xe7, 0x3f, 0xf3, 0x5f,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00
    };

    PRV = (LPBSAFE_PRV_KEY)prvmodulus;
    PRV->magic = RSA2;
    PRV->keylen = 0x48;
    PRV->bitlen = 0x0200;
    PRV->datalen = 0x3f;
    PRV->pubexp = 0xc0887b5b;

    Cert.dwVersion = 0x01;
    Cert.dwSigAlgID = MD5RSA;
    Cert.dwKeyAlgID = RSAKEY;

    bits = KeyLen;

    if (!BSafeComputeKeySizes(&dwPubSize, &dwPrivSize, &bits))
    {
        return LICENSE_STATUS_INVALID_INPUT;
    }

    if ((kPrivate = (BYTE *)LocalAlloc(LPTR,dwPrivSize)) == NULL)
    {
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    if ((kPublic = (BYTE *)LocalAlloc(LPTR,dwPubSize)) == NULL)
    {
        LocalFree(kPrivate);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    if (!BSafeMakeKeyPair((LPBSAFE_PUB_KEY)kPublic,
                          (LPBSAFE_PRV_KEY)kPrivate,
                          KeyLen))
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    // make proprietary format cert

    Cert.PublicKeyData.wBlobType = BB_RSA_KEY_BLOB;
    Cert.PublicKeyData.wBlobLen = (WORD)dwPubSize;
    if( NULL == (Cert.PublicKeyData.pBlob = (PBYTE)LocalAlloc(LPTR,dwPubSize) ) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    memcpy(Cert.PublicKeyData.pBlob, kPublic, dwPubSize);

    dwTemp = 3*sizeof(DWORD) + 2*sizeof(WORD) + dwPubSize;
    if( NULL == (pbData = (PBYTE)LocalAlloc(LPTR,dwTemp)) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        LocalFree(Cert.PublicKeyData.pBlob);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pbTemp = pbData;
    memcpy(pbTemp, &Cert.dwVersion, sizeof(DWORD));
    pbTemp += sizeof(DWORD);
    memcpy(pbTemp, &Cert.dwSigAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

	memcpy(pbTemp, &Cert.dwKeyAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

    memcpy(pbTemp, &Cert.PublicKeyData.wBlobType, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, &Cert.PublicKeyData.wBlobLen, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, Cert.PublicKeyData.pBlob, Cert.PublicKeyData.wBlobLen);
    pbTemp += Cert.PublicKeyData.wBlobLen;

    // sign the cert

    MD5Init(&HashState);
    MD5Update(&HashState, pbData, dwTemp);
    MD5Final(&HashState);
	
    LocalFree(pbData);

	memset(pbHash, 0x00, 0x48);
	memset(pbHash, 0xff, 0x40);

    pbHash[0x40-1] = 0;
    pbHash[0x40-2] = 1;
    pbHash[16] = 0;
    memcpy(pbHash, HashState.digest, 16);

    BSafeDecPrivate(PRV, pbHash, Output);

	Cert.SignatureBlob.wBlobType = BB_RSA_SIGNATURE_BLOB;
    Cert.SignatureBlob.wBlobLen = 0x48;
    if( NULL == (Cert.SignatureBlob.pBlob = (PBYTE)LocalAlloc(LPTR,Cert.SignatureBlob.wBlobLen)) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        LocalFree(Cert.PublicKeyData.pBlob);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    memcpy(Cert.SignatureBlob.pBlob, Output, Cert.SignatureBlob.wBlobLen);

    // Pack the Hydra_Server_Cert

    dwTemp = 3*sizeof(DWORD) + 4*sizeof(WORD) + dwPubSize + 0x48;

	if( NULL == (pbData = (PBYTE)LocalAlloc(LPTR,dwTemp)) )
    {
        LocalFree(kPrivate);
        LocalFree(kPublic);
        LocalFree(Cert.PublicKeyData.pBlob);
        return LICENSE_STATUS_OUT_OF_MEMORY;
    }

    pbTemp = pbData;
    memcpy(pbTemp, &Cert.dwVersion, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

    memcpy(pbTemp, &Cert.dwSigAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);
    memcpy(pbTemp, &Cert.dwKeyAlgID, sizeof(DWORD));
    pbTemp += sizeof(DWORD);

	memcpy(pbTemp, &Cert.PublicKeyData.wBlobType, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, &Cert.PublicKeyData.wBlobLen, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, Cert.PublicKeyData.pBlob, Cert.PublicKeyData.wBlobLen);
    pbTemp += Cert.PublicKeyData.wBlobLen;

    memcpy(pbTemp, &Cert.SignatureBlob.wBlobType, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, &Cert.SignatureBlob.wBlobLen, sizeof(WORD));
    pbTemp += sizeof(WORD);

    memcpy(pbTemp, Cert.SignatureBlob.pBlob, Cert.SignatureBlob.wBlobLen);

    *ppbPrivateKey = kPrivate;
    *pcbPrivateKey = dwPrivSize;

    *ppbServerCert = pbData;
    *pcbServerCert = dwTemp;

    LocalFree(kPublic);

    return LICENSE_STATUS_OK;
}

//***************************************************************************
//
//  IsSystemService
//
//  returns TRUE if we are running as local system
//
//***************************************************************************

BOOL IsSystemService()
{
    BOOL bOK = FALSE;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Construct the local system SID
	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    SID    LocalSystemSid = { SID_REVISION,
                              1,
                              SECURITY_NT_AUTHORITY,
                              SECURITY_LOCAL_SYSTEM_RID };

    if ( !CheckTokenMembership ( NULL, &LocalSystemSid, &bOK ) )
    {
        bOK = FALSE;
    }

	return bOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\global.c ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    glodata.c

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <ntlsa.h>
#include <windows.h>
#include <winbase.h>
#include <winerror.h>

#include <tchar.h>
#include <stdio.h>

#include "license.h"
#include "cryptkey.h"
#include "lscsp.h"
#include "tlsapip.h"
#include "certutil.h"
#include "hydrakey.h"

#include <md5.h>
#include <sha.h>
#include <rsa.h>

#include <secdbg.h>
#include "global.h"

#ifdef OS_WIN16
#include <string.h>
#endif // OS_WIN16

//
// global data definitions.
//


BYTE csp_abPublicKeyModulus[92] = HYDRA_ROOT_PUBLIC_KEY;

LPBSAFE_PUB_KEY csp_pRootPublicKey = NULL;
LPBYTE          csp_abServerCertificate = NULL;
DWORD           csp_dwServerCertificateLen = 0;
LPBYTE          csp_abServerX509Cert = NULL;
DWORD           csp_dwServerX509CertLen = 0;
LPBYTE          csp_abX509CertID = NULL;
DWORD           csp_dwX509CertIDLen = 0;

HANDLE          csp_hMutex = NULL;

LONG            csp_InitCount = 0;

Hydra_Server_Cert   csp_hscData;
HINSTANCE       g_hinst;

LPBYTE          csp_abServerPrivateKey = NULL;
DWORD           csp_dwServerPrivateKeyLen = 0;
LPBYTE          csp_abX509CertPrivateKey = NULL;
DWORD           csp_dwX509CertPrivateKeyLen = 0;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\efind.cpp ===
/*
**	Copyright (c) 1998 Microsoft Corporation
**	All Rights Reserved
**
**
*/
#include <windows.h>
#include <objbase.h>
#include <winbase.h>
#include <wchar.h>

// Required by SSPI.H
#define SECURITY_WIN32
#include <sspi.h>

#include <dsgetdc.h>
#include <ntdsapi.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include <activeds.h>
#include "lscommon.h"
#include "tlsrpc.h"
#include "tlsapi.h"
#include "tlsapip.h"

#define CWSTR_SIZE(x)       (sizeof(x) - (sizeof(WCHAR) * 2))
#define DWSTR_SIZE(x)       ((wcslen(x) + 1) * sizeof(WCHAR))

#define LICENSE_SETTINGS                L"TS-Enterprise-License-Server"
#define LICENSE_SETTINGS_FORMAT         L"LDAP://CN=%ws,CN=%ws,CN=%ws,%ws"
#define LICENSE_SETTINGS_SIZE           CWSTR_SIZE(LICENSE_SETTINGS)
#define LICENSE_SETTINGS_FORMAT_SIZE    CWSTR_SIZE(LICENSE_SETTINGS_FORMAT)
#define SITES               L"sites"
#define SITES_SIZE          CWSTR_SIZE(SITES)
#define CONFIG_CNTNR        L"ConfigurationNamingContext"
#define CONFIG_CNTNR_FORMAT L"LDAP://CN=%ws,%ws"
#define CONFIG_CNTNR_FORMAT_SIZE    CWSTR_SIZE(CONFIG_CNTNR_FORMAT)
#define ROOT_DSE_PATH       L"LDAP://RootDSE"
#define ADS_PATH            L"ADsPath"
#define SEARCH_FILTER       L"(CN=TS-Enterprise-LicenseServer)"
#define DNS_MACHINE_NAME    L"dNSHostName"
#define IS_DELETED          L"isDeleted"
#define SITE_SERVER         L"siteServer"

extern "C" {
   VOID LogMsg(
	           PWCHAR msgFormat, 
	           ...
	           );
}

HRESULT GetLicenseServersFromReg(LPWSTR wszRegKey, LPWSTR *ppwszServerNames,DWORD *pcServers, LPWSTR **prgwszServers);

HRESULT
WriteLicenseServersToReg(LPWSTR wszRegKey, LPWSTR pwszServerNames,DWORD cchServers);

extern BOOL g_fInDomain;
static BOOL g_bLog;

extern "C" DWORD WINAPI 
TLSDisconnect( 
    TLS_HANDLE* pphContext
);

//
// Pre-fill the ADSI cache with only the attribute we want, then get it
// Only use if exactly one attribute is needed
//

HRESULT
GetWithGetInfoEx(
                 IADs *pADs,
                 LPWSTR wszAttribute,
                 VARIANT *pvar
                 )
{
    HRESULT hr;

    hr = ADsBuildVarArrayStr( &wszAttribute, 1, pvar );
    if( SUCCEEDED( hr ) )
    {
        hr = pADs->GetInfoEx( *pvar, 0L );
        if(SUCCEEDED(hr))
        {
            hr = VariantClear( pvar );
            if(SUCCEEDED(hr))
            {        
                BSTR bstrval = SysAllocString(wszAttribute);
                if(NULL == bstrval)
                    return E_OUTOFMEMORY;
         
                hr = pADs->Get( bstrval, pvar );            

                SysFreeString(bstrval);            
            }
        }
    }

    return hr;
}

//
// Pre-fill the ADSI cache with only the attributes we want, then get them
// Only use if exactly two attributes are needed
//

HRESULT
GetWithGetInfoEx2(
                 IADs *pADs,
                 LPWSTR wszAttribute1,
                 LPWSTR wszAttribute2,
                 VARIANT *pvar1,
                 VARIANT *pvar2,
                 HRESULT *phr2
                 )
{
    HRESULT hr;
    LPWSTR rgwszAttributes[] = {wszAttribute1,wszAttribute2};

    hr = ADsBuildVarArrayStr( rgwszAttributes, 2, pvar1 );
    if( SUCCEEDED( hr ) )
    {
        hr = pADs->GetInfoEx( *pvar1, 0L );
        if (SUCCEEDED(hr))
        {
            hr = VariantClear( pvar1 );

            if(SUCCEEDED(hr))
            {
                BSTR bstrval1 = SysAllocString(wszAttribute1);
                if(NULL == bstrval1)
                    return E_OUTOFMEMORY;

                BSTR bstrval2 = SysAllocString(wszAttribute2);
                if( NULL == bstrval2)
                {
                    SysFreeString(bstrval1);
                    return E_OUTOFMEMORY;
                }
                
                hr = pADs->Get( bstrval1, pvar1 );

                if (SUCCEEDED(hr))
                {
                    *phr2 = pADs->Get( bstrval2, pvar2 );
                }
            
                SysFreeString(bstrval1);
                SysFreeString(bstrval2);        
            }
        }
    }

    return hr;
}

HRESULT
GetExWithGetInfoEx(
                   IADs *pADs,
                   LPWSTR wszAttribute,
                   VARIANT *pvar
                   )
{
    HRESULT hr;

    hr = ADsBuildVarArrayStr( &wszAttribute, 1, pvar );
    if( SUCCEEDED( hr ) )
    {
        hr = pADs->GetInfoEx( *pvar, 0L );
        if(SUCCEEDED(hr))
        {
            hr = VariantClear( pvar );
            if(SUCCEEDED(hr))
            {
                BSTR bstrval = SysAllocString(wszAttribute);
                if(NULL == bstrval)
                    return E_OUTOFMEMORY;
                
                hr = pADs->GetEx( bstrval, pvar );                

                SysFreeString(bstrval);
            }
        }
    }

    return hr;
}

HRESULT GetLicenseSettingsObject(VARIANT *pvar,
                                 LPWSTR *ppwszLicenseSettings,
                                 LPWSTR *ppwszSiteName,
                                 IADs **ppADs)
{
    HRESULT          hr;
    DWORD            dwErr = 0;
    LPWSTR           pwszConfigContainer;
    IADs *           pADs = NULL;
    IDirectorySearch *pADsSearch = NULL;
    ADS_SEARCH_HANDLE hSearch = NULL;
    ADS_SEARCH_COLUMN Column;
    LPWSTR           pwszAdsPath = ADS_PATH;
    LPWSTR           pwszSitesPath = NULL;
    BOOL             fInDomain;

    if (g_fInDomain == -1)
    {
        dwErr = TLSInDomain(&fInDomain,NULL);
        if (dwErr != NO_ERROR)
            return HRESULT_FROM_WIN32(dwErr);
    } else
    {
        fInDomain = g_fInDomain;
    }

    if (!fInDomain)
    {
        return HRESULT_FROM_WIN32(ERROR_NO_SUCH_DOMAIN);
    }

    VariantInit(pvar);
    
    //
    // Obtain the path to the configuration container.
    //

    hr = ADsGetObject(ROOT_DSE_PATH, IID_IADs, (void **)&pADs);

    if (FAILED(hr)) {
       if(g_bLog)
          LogMsg(L"ADsGetObject ROOT_DSE_PATH failed 0x%lx\n",hr);
        goto CleanExit;
    }

    BSTR bstrval = SysAllocString(CONFIG_CNTNR);
    if(NULL == bstrval)
    {
        hr = E_OUTOFMEMORY;
        goto CleanExit;
    }
    hr = pADs->Get(bstrval, pvar);
    SysFreeString(bstrval);

    if (FAILED(hr)) {
       if(g_bLog)
          LogMsg(L"Get CONFIG_CNTNR failed 0x%lx\n",hr);
        goto CleanExit;
    }

    if (V_VT(pvar) != VT_BSTR) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
       if(g_bLog)
          LogMsg(L"bad variant 0x%lx\n",hr);
        goto CleanExit;
    }

    pwszConfigContainer = pvar->bstrVal;  // For sake of readability.

    //
    // Get the site name, if possible
    //

    dwErr = DsGetSiteName(NULL, ppwszSiteName);

    if (dwErr == 0)
    {
        //
        // Build the X.500 path to the LicenseSettings object.
        //

        *ppwszLicenseSettings =
            (LPWSTR)LocalAlloc(
                               LPTR,
                               LICENSE_SETTINGS_FORMAT_SIZE
                               + LICENSE_SETTINGS_SIZE
                               + DWSTR_SIZE(*ppwszSiteName)
                               + SITES_SIZE
                               + DWSTR_SIZE(pwszConfigContainer)
                               + sizeof(TCHAR));

        if (*ppwszLicenseSettings == NULL) {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        swprintf(*ppwszLicenseSettings,
                 LICENSE_SETTINGS_FORMAT,
                 LICENSE_SETTINGS,
                 *ppwszSiteName,
                 SITES,
                 pwszConfigContainer);
        
        hr = ADsGetObject(*ppwszLicenseSettings, IID_IADs, (void **)ppADs);

        if (SUCCEEDED(hr))
        {
            // return this object
            goto CleanExit;
        }
    } 

    //
    // None in our site (or we don't know our site)
    // Search all sites in GC, take first one
    //

    pwszSitesPath =
        (LPWSTR)LocalAlloc(
                           LPTR,
                           CONFIG_CNTNR_FORMAT_SIZE
                               + SITES_SIZE
                               + DWSTR_SIZE(pwszConfigContainer)
                               + sizeof(TCHAR));

        if (pwszSitesPath == NULL) {
            hr = E_OUTOFMEMORY;
            goto CleanExit;
        }

        swprintf(pwszSitesPath,
                 CONFIG_CNTNR_FORMAT,
                 SITES,
                 pwszConfigContainer);

    hr = ADsGetObject(pwszSitesPath,
                      IID_IDirectorySearch,
                      (void **)&pADsSearch);
    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"ADsGetObject ConfigContainer (%s) failed 0x%lx\n",pwszConfigContainer,hr);
        goto CleanExit;
    }

    hr = pADsSearch->ExecuteSearch(SEARCH_FILTER,&pwszAdsPath,1,&hSearch);
    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"ExecuteSearch failed 0x%lx\n",hr);
        goto CleanExit;
    }

    hr = pADsSearch->GetNextRow(hSearch);

    if (hr == S_ADS_NOMORE_ROWS)
        hr = E_ADS_PROPERTY_NOT_SET;

    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"GetNextRow failed 0x%lx\n",hr);
        goto CleanExit;
    }

    hr = pADsSearch->GetColumn(hSearch,pwszAdsPath,&Column);
    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"GetColumn (%ws) failed 0x%lx\n",pwszAdsPath,hr);
        goto CleanExit;
    }

    hr = ADsGetObject(Column.pADsValues->CaseIgnoreString,
                      IID_IADs,
                      (void **)ppADs);

    pADsSearch->FreeColumn(&Column);

CleanExit:
    if (NULL != pADs) {
        pADs->Release();
    }

    if (NULL != pADsSearch) {
        if (hSearch != NULL) {
            pADsSearch->CloseSearchHandle(hSearch);
        }

        pADsSearch->Release();
    }

    if (NULL != pwszSitesPath)
    {
        LocalFree(pwszSitesPath);
    }

    return hr;
}

HRESULT
GetRandomServer(IADs *pADs,
                VARIANT *pvar
                )
{
    HRESULT          hr;
    VARIANT          var;
    SAFEARRAY        *psaServers;
    LONG             lLower, lUpper, lPos;

    VariantInit(&var);

    hr = GetExWithGetInfoEx(pADs,SITE_SERVER,&var);
    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"GetEx (%ws) failed 0x%lx\n",LICENSE_SETTINGS,hr);
        goto CleanExit;
    }

    psaServers = V_ARRAY(&var);
    if (NULL == psaServers)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
       if(g_bLog)
          LogMsg(L"GetEx no array failed 0x%lx\n",hr);
        goto CleanExit;
    }

    hr= SafeArrayGetLBound( psaServers, 1, &lLower );
    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"SafeArrayGetLBound failed 0x%lx\n",hr);
        goto CleanExit;
    }

    hr= SafeArrayGetUBound( psaServers, 1, &lUpper );
    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"SafeArrayGetUBound failed 0x%lx\n",hr);
        goto CleanExit;
    }

    srand(GetTickCount());

    lPos = (rand() % (lUpper - lLower + 1)) + lLower;

    hr = SafeArrayGetElement( psaServers, &lPos, pvar );
       if(g_bLog)
          LogMsg(L"SafeArrayGetElement (%d) failed? 0x%lx\n",lPos,hr);

CleanExit:
    VariantClear(&var);

    return hr;
}

HRESULT
GetAllServers(IADs *pADs,
              VARIANT *pvar
              )
{
    HRESULT          hr;

    hr = GetExWithGetInfoEx(pADs,SITE_SERVER,pvar);
    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"GetEx (%ws) failed 0x%lx\n",LICENSE_SETTINGS,hr);
    }

    return hr;
}

HRESULT
DnToFqdn(LPWSTR pwszDN, LPWSTR pwszFqdn)
{
    LPWSTR           pwszBindPath;
    HRESULT          hr, hr2;
    IADs *           pADs2        = NULL;
    VARIANT          var2;
    VARIANT          var3;

    VariantInit(&var2);
    VariantInit(&var3);

    //
    // Bind to the computer object referenced by the Site-Server property.
    //

    // LDAP:// + pwszDN + 1
    pwszBindPath = (LPWSTR) LocalAlloc(LPTR,
                              (wcslen(pwszDN) + 8) * sizeof(WCHAR));

    if (pwszBindPath == NULL) {
        hr = E_OUTOFMEMORY;
       if(g_bLog)
          LogMsg(L"LocalAlloc failed 0x%lx\n",hr);
        goto CleanExit;
    }

    wsprintf(pwszBindPath, L"LDAP://%ws", pwszDN);

    hr = ADsOpenObject(pwszBindPath,
                       NULL,
                       NULL,
                       ADS_SERVER_BIND,
                       IID_IADs,
                       (void **)&pADs2);

    LocalFree(pwszBindPath);

    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"ADsOpenObject failed 0x%lx\n",hr);
        goto CleanExit;
    }

    //
    // Fetch the Machine-DNS-Name property.
    //

    hr = GetWithGetInfoEx2(pADs2,DNS_MACHINE_NAME, IS_DELETED, &var3, &var2, &hr2);

    if (FAILED(hr)) {
       if(g_bLog)
          LogMsg(L"Get failed 0x%lx\n",hr);
        goto CleanExit;
    }

    if (SUCCEEDED(hr2))
    {
        hr = VariantChangeType(&var2,&var2,0,VT_BOOL);
        
        if (FAILED(hr)) {
           if(g_bLog)
              LogMsg(L"VariantChangeType failed 0x%lx\n",hr);

            goto CleanExit;
        }

        if (V_BOOL(&var2))
        {
            // object has been deleted - pretend it isn't set
            hr = E_ADS_PROPERTY_NOT_SET;
            if(g_bLog)
               LogMsg(L"Object deleted\n");
            goto CleanExit;
        }
    }

    if (V_VT(&var3) != VT_BSTR) {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        if(g_bLog)
           LogMsg(L"Get bad data 0x%lx\n",hr);
        goto CleanExit;
    }

    wcscpy(pwszFqdn,V_BSTR(&var3));

CleanExit:
    VariantClear(&var2);
    VariantClear(&var3);

    if (NULL != pADs2) {
        pADs2->Release();
    }

    return hr;
}

//
// First call with fUseReg TRUE; if the returned server doesn't work
// call again with fUseReg FALSE
//

extern "C"
HRESULT
FindEnterpriseServer(TLS_HANDLE *phBinding)
{
    HRESULT             hr;
    LPWSTR              *rgwszServers = NULL;
    LPWSTR              pwszServerNames = NULL;
    DWORD               entriesread, i;

    if (phBinding == NULL)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto CleanExit;
    }

    *phBinding = NULL;

    hr = GetLicenseServersFromReg(ENTERPRISE_SERVER_MULTI,&pwszServerNames,&entriesread,&rgwszServers);
    if (FAILED(hr))
    {
        goto CleanExit;
    }

    for (i = 0; i < entriesread; i++)
    {
        TLS_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;
        DWORD dwVersion;

        if(!(pContext = TLSConnectToLsServer(rgwszServers[i])))
        {
            break;
        }

        rpcStatus = TLSGetVersion(pContext,&dwVersion);
        if (rpcStatus != RPC_S_OK)
        {
            TLSDisconnect(&pContext);
            continue;
        }

        //
        // No Beta <--> RTM server.
        //
        //
        // TLSIsBetaNTServer() returns TRUE if eval NT
        // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
        //
        if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
        {
            continue;
        }

        if (!(dwVersion & TLS_VERSION_ENTERPRISE_BIT))
        {
            TLSDisconnect(&pContext);
            continue;
        }

        *phBinding = pContext;
        break;
    }

CleanExit:
    if (pwszServerNames)
        LocalFree(pwszServerNames);

    if (rgwszServers)
        LocalFree(rgwszServers);

    return hr;
}

extern "C"
HRESULT
GetAllEnterpriseServers(WCHAR ***ppszServers, DWORD *pdwCount)
{
    LPWSTR           pwszSiteName = NULL;
    IADs *           pADs         = NULL;
    VARIANT          var;
    VARIANT          var2;
    LPWSTR           pwszLicenseSettings = NULL;
    HRESULT          hr;
    VARIANT HUGEP    *pvar = NULL;
    LONG             lLower, lUpper;
    int              i;
    LPWSTR           pwszRegServers = NULL;
    LPWSTR           pwszRegServersTmp;
    DWORD            cchServer, cchServers;
    int              cServers = 0;

    if (ppszServers != NULL)
        *ppszServers = NULL;

	// We're going to use ADSI,  so initialize COM.  We don't
	// care about OLE 1.0 so disable OLE 1 DDE

	hr = CoInitialize(NULL);
    
    if (FAILED(hr))
    {
        return hr;
    }

    VariantInit(&var);
    VariantInit(&var2);
    
    LogMsg(L"\n----------Trying Enterprise License Server Discovery----------\n");
    hr = GetLicenseSettingsObject(&var,
                                  &pwszLicenseSettings,
                                  &pwszSiteName,
                                  &pADs);


    if (FAILED(hr)) {
       if(g_bLog)
          LogMsg(L"GetLicenseSettingsObject failed 0x%lx\n",hr);
        goto CleanExit;
    }

    hr = GetAllServers(pADs,&var2);

    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"GetAllServers failed 0x%lx\n",hr);
        WriteLicenseServersToReg(ENTERPRISE_SERVER_MULTI,NULL,0);
        goto CleanExit;
    }

    hr = SafeArrayGetLBound( V_ARRAY(&var2), 1, &lLower );
    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"SafeArrayGetLBound failed 0x%lx\n",hr);
        goto CleanExit;
    }

    hr = SafeArrayGetUBound( V_ARRAY(&var2), 1, &lUpper );
    if (FAILED(hr))
    {
       if(g_bLog)
          LogMsg(L"SafeArrayGetUBound failed 0x%lx\n",hr);
        goto CleanExit;
    }

    // Get a pointer to the elements of the safearray.
    hr = SafeArrayAccessData(V_ARRAY(&var2), (void HUGEP* FAR*)&pvar);

    if (FAILED(hr)) {
        goto CleanExit;
    }

    if (ppszServers != NULL) {
        *ppszServers = (WCHAR * *) LocalAlloc(LPTR,(lUpper-lLower+1) * sizeof(WCHAR *));

        if (*ppszServers == NULL) {
            hr = E_OUTOFMEMORY;
            if(g_bLog)
              LogMsg(L"LocalAlloc failed 0x%lx\n",hr);
            goto CleanExit;
        }
    }

    pwszRegServers = (LPWSTR) LocalAlloc(LPTR,2*sizeof(WCHAR));
    if (NULL == pwszRegServers)
    {
       if(g_bLog)
          LogMsg(L"Out of memory\n");
        hr = E_OUTOFMEMORY;
        
        goto CleanExit;
    }

    cchServers = 2;
    pwszRegServers[0] = pwszRegServers[1] = L'\0';

    for (i = 0; i < lUpper-lLower+1; i++)
    {
        WCHAR *szServer = (WCHAR *) LocalAlloc(LPTR,MAX_PATH*2);

        if (szServer == NULL) {
            hr = E_OUTOFMEMORY;
            if(g_bLog)
               LogMsg(L"LocalAlloc failed 0x%lx\n",hr);

            if (ppszServers != NULL) {
                for (int j = 0; j < cServers; j++)
                {
                    LocalFree((*ppszServers)[j]);
                }
                LocalFree(*ppszServers);
            }

            goto CleanExit;
        }

        hr = DnToFqdn(V_BSTR(pvar+cServers),szServer);

        if (FAILED(hr))
        {
           if(g_bLog)
              LogMsg(L"DnToFqdn failed 0x%lx\n",hr);

            LocalFree(szServer);

            continue;
        }

        cchServer = wcslen(szServer);

        pwszRegServersTmp = (LPWSTR) LocalReAlloc(pwszRegServers,(cchServers+cchServer+1)*sizeof(TCHAR),LHND);
        if (NULL == pwszRegServersTmp)
        {
           if(g_bLog)
              LogMsg(L"LocalReAlloc failed 0x%lx\n",hr);
            hr = E_OUTOFMEMORY;

            if (ppszServers != NULL) {
                for (int j = 0; j < cServers; j++)
                {
                    LocalFree((*ppszServers)[j]);
                }
                LocalFree(*ppszServers);
            }
            LocalFree(szServer);

            goto CleanExit;
        }
                    
        pwszRegServers = pwszRegServersTmp;
                    
        if (cchServers == 2)
        {
            wcscpy(pwszRegServers,szServer);
                        
            cchServers += cchServer;
        } else
        {
            wcscpy(pwszRegServers+cchServers-1,szServer);
                        
            cchServers += cchServer + 1;
                        
        }
        pwszRegServers[cchServers-1] = L'\0';

        if (ppszServers != NULL)
        {
            (*ppszServers)[cServers] = szServer;
        }

        cServers++;
    }

    if (pdwCount != NULL)
        *pdwCount = cServers;

    WriteLicenseServersToReg(ENTERPRISE_SERVER_MULTI,pwszRegServers,cchServers);

CleanExit:
    VariantClear(&var);
    VariantClear(&var2);

    if (pwszSiteName != NULL) {         // Allocated from DsGetSiteName
        NetApiBufferFree(pwszSiteName);
    }

    if (pwszLicenseSettings != NULL) {
        LocalFree(pwszLicenseSettings);
    }

    if (pvar != NULL) {
        SafeArrayUnaccessData(V_ARRAY(&var2));
    }

    if (NULL != pADs) {
        pADs->Release();
    }

    if (pwszRegServers) {
        LocalFree(pwszRegServers);
    }

    CoUninitialize();

    if ((ppszServers != NULL) && (FAILED(hr)))
        *ppszServers = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\global.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    global.h

Abstract:

    Global data definitions for tshare security.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_H_
#define _GLOBAL_H_

//-----------------------------------------------------------------------------
//
// global data definitions.
//
//-----------------------------------------------------------------------------

#define CSP_MUTEX_NAME  L"Global\\LSCSPMUTEX658fe2e8"


extern LPBSAFE_PUB_KEY csp_pRootPublicKey;

extern BYTE csp_abPublicKeyModulus[92];

extern LPBYTE csp_abServerCertificate;
extern DWORD  csp_dwServerCertificateLen;

extern LPBYTE csp_abServerX509Cert;
extern DWORD  csp_dwServerX509CertLen;

extern LPBYTE csp_abServerPrivateKey;
extern DWORD  csp_dwServerPrivateKeyLen;

extern LPBYTE csp_abX509CertPrivateKey;
extern DWORD  csp_dwX509CertPrivateKeyLen;

extern LPBYTE csp_abX509CertID;
extern DWORD  csp_dwX509CertIDLen;

extern Hydra_Server_Cert    csp_hscData;

extern HINSTANCE g_hinst;

extern HANDLE csp_hMutex;

extern LONG csp_InitCount;

//-----------------------------------------------------------------------------
// 
// Crypto-related  definitions
//
//-----------------------------------------------------------------------------

#define RSA_KEY_LEN             512
#define CAPI_MAX_VERSION        2

#define RDN_COMMON_NAME         "cn="

//-----------------------------------------------------------------------------
//
// Macros
//
//-----------------------------------------------------------------------------

#define ACQUIRE_EXCLUSIVE_ACCESS( x )  \
if( x ) \
{ \
    WaitForSingleObject(x, INFINITE); \
}

#define RELEASE_EXCLUSIVE_ACCESS( x ) \
if( x ) \
{ \
    ReleaseMutex(x); \
}

#endif // _GLOBAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\secdbg.h ===
/*++

Copyright (c) 1994-1998  Microsoft Corporation

Module Name:

    secdbg.h

Abstract:

    Debug macro definition file.

Author:

    Madan Appiah (madana)  24-Jan-1998

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _SECDBG_H_
#define _SECDBG_H_

//
// assert macros.
//

#ifndef OS_WIN16

NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    DWORD LineNumber,
    PCHAR Message
    );

#define RTLASSERT( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define RTLASSERTMSG( msg, exp)
//        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else // OS_WIN16

#define RTLASSERT( msg, exp)
#define RTLASSERTMSG( msg, exp)

#endif // OS_WIN16


#if DBG

#undef ASSERT
#undef ASSERTMSG

#define ASSERT( exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \


#define ASSERTMSG( msg, exp ) \
    if (!(exp)) { \
        RTLASSERT( msg, exp); \
    } \

#else

#ifndef ASSERT
#define ASSERT( exp )
#endif

#ifndef ASSERTMSG
#define ASSERTMSG( msg, exp )
#endif

#endif // DBG

#endif // _SECDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\logfile.h ===
/*++

	File:	 logfile.h
	Purpose: Contains logfile prototypes
	

--*/

#ifndef LOGFILE_H
#define LOGFILE_H

#include <windows.h>
#include <string.h>
#include <stdio.h>
#include <setupapi.h>
#include <time.h>
#include <stdlib.h>

//
//	Global variable declarations
//
FILE *g_fpTempFile;

WCHAR g_szTmpFilename[MAX_PATH];

//
//	Prototypes.
//
BOOL OpenLog(VOID /*IN PWCHAR szLogFileName, IN PWCHAR szDirectoryName, IN PWCHAR szOverWrite*/);
VOID LogMsg (IN PWCHAR szMessage,...);
BOOL LogDiagnosisFile( IN LPTSTR );
VOID CloseLog(VOID);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\logfile.c ===
#include "logfile.h"


/*++
Routine Description:
	
	This function will open a temporary logfile in the %temp% directory

Return:
	BOOL TRUE if this completed successfully.

--*/
BOOL OpenLog(VOID)
{
	WCHAR	szTempPath[MAX_PATH];
	WCHAR	sztimeClock[128];
	WCHAR	sztimeDate[128];

	ExpandEnvironmentStrings(L"%temp%", szTempPath, MAX_PATH);

	//
	//	g_fpTempFile should be global to main program
	
	wsprintf(g_szTmpFilename, L"%s\\LsviewTemp.log", szTempPath);

	g_fpTempFile = _wfopen(g_szTmpFilename,L"w+");

	if( g_fpTempFile==NULL )
		return FALSE;

	_wstrtime(sztimeClock);
	_wstrdate(sztimeDate);
	wsprintf(szTempPath, L"\n**********Log file generated on: %s %s**********\n", sztimeDate, sztimeClock); 
	fwprintf(g_fpTempFile, szTempPath);

	return TRUE;
}


/*++
Routine Description:
	
	This function will act like printf except it sends its output
	to the file opened with OpenLog. 
	
Arguments:
	The text and formatting necessary as printf would take.
	
Return:
	NONE.

--*/
VOID LogMsg (IN PWCHAR szMessage,...)
{
    va_list vaArgs;
	va_start ( vaArgs, szMessage );
	vfwprintf ( g_fpTempFile, szMessage, vaArgs );
	va_end   ( vaArgs );
    fflush   ( g_fpTempFile );
}

/*++
Routine Description:
	
	This function will move the temporary logfile to the path specified in parameter szFileName
	
Arguments:
	szFileName : Filename to move the temp logfile to
	
Return:
	BOOL TRUE if this completed successfully.
--*/
BOOL LogDiagnosisFile( LPTSTR szFileName )
{
   BOOL bMoveSuccess = FALSE;
	
   if( szFileName == NULL )
	   return FALSE;

   CloseLog();

   bMoveSuccess = MoveFileEx( g_szTmpFilename, szFileName, 
	                          MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING | MOVEFILE_WRITE_THROUGH );
   if( bMoveSuccess == FALSE )
   {
	   WCHAR szTmp[MAX_PATH];
	   wsprintf(szTmp, L"Failed to move temp diagnosis file %s to %s. Reason %d", g_szTmpFilename, szFileName, GetLastError());
	   OutputDebugString(szTmp);
   }

   OpenLog();

   return bMoveSuccess;
}

/*++
Routine Description:
	
	This function will close the logfile.
	
Arguments:
	NONE
	
Return:
	NONE.
--*/
VOID CloseLog(VOID)
{
    fclose( g_fpTempFile );
	g_fpTempFile = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\tlsrpc-c.c ===
#include <tlsrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by tslsview.rc
//
#define IDS_STR_COL1                    1
#define IDS_STR_COL2                    2
#define IDS_STR_COL3                    3
#define IDS_TYPE_ENT                    4
#define IDS_TYPE_DOMAIN                 5
#define IDS_TRAYSTOP                    6
#define IDS_TRAYGREEN                   7
#define IDS_TIP                         8
#define IDS_TITLE                       9
#define IDS_BUBBLE                      10
#define IDS_TRAYFILE                    11
#define IDS_FILTER                      12
#define IDS_YELLOW                      13
#define IDS_ERROR_QS                    14
#define IDS_EXTENSION                   15

#define IDI_TSLSVIEW                    50
#define IDC_ICON_STOP                   51
#define IDC_ICON_GO                     52
#define IDC_ICON_CAUTION                53
#define IDC_ICON_NONE                   54

#define IDM_MINIMIZE                    70
#define IDM_RESTORE                     71
#define IDM_EXIT                        72
#define IDR_TRAYMENU                    73

#define IDD_CDEXT                       90
#define IDC_CHECK1                      91
#define IDC_CHECK2                      92
#define ID_EDT_NUM                      93
#define IDC_SPIN1                       94


#define IDC_STATIC                      -1

#define IDD_LSVIEW                      101
#define IDR_MENU_LSVIEW                 102
#define IDC_LSVIEW_LIST                 1000
#define ID_FILE_CREATELOGFILE           40001
#define ID_FILE_EXIT                    40002
#define ID_HELP_ABOUT                   40003


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40004
#define _APS_NEXT_CONTROL_VALUE         1001
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
#define AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
// C RunTime Header Files
#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <commctrl.h>
#include <dlgs.h>
#include "resource.h"
#include <stdlib.h>

#include<commdlg.h>
#include <license.h>
#include <tlsapi.h>
#include <tlsapip.h>

//////////////////////////////////////////////////////////////////////////////
typedef struct __ServerEnumData {
    DWORD dwNumServer;
    long dwDone;
    HWND hList;
} ServerEnumData;

typedef struct _list
{
    LPTSTR pszMachineName;
    LPTSTR pszTimeFormat;
    LPTSTR pszType;
    _list *pNext;
} LIST , *PLIST;

typedef struct _DataObject
{
    BOOL bIsChecked;
	BOOL bIsDiagnosisChecked;
    BOOL bNotifyOnce;
    DWORD dwTimeInterval;
    WCHAR wchFileName[ MAX_PATH ];
} DATAOBJECT , *PDATAOBJECT;


#define SIZEOF( x ) sizeof( x ) / sizeof( x[0] )
#ifdef DBG
#define ODS OutputDebugString

#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[80]; \
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }


#else

#define ODS
#define DBGMSG
#endif



// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A9DB83DB_A9FD_11D0_BFD1_444553540000__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	tslsview.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\g_cache.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  g_cache.c                                  **
**                                             **
**  Glyph cache dialog - TSREG                 **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"

HWND g_hwndGlyphCacheDlg;

///////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK GlyphCache(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr;
    static UINT nGlyphBuffer;
    static HWND hwndSlider[NUMBER_OF_SLIDERS];
    static HWND hwndSliderEditBuddy[NUMBER_OF_SLIDERS];
    static HWND hwndComboTextFrag;
    static TCHAR lpszRegPath[MAX_PATH];
    TCHAR lpszBuffer[5];
    HWND hwndCtl;
    int i, nKeyVal;
    int nPos;
    LPHELPINFO lphi;

    //
    // get a pointer to the NMHDR struct for apply button
    //
    lpnmhdr = ((LPNMHDR)lParam);

    switch (nMsg) {

        case WM_VSCROLL:

            hwndCtl = (HWND) (lParam);
            i = (int)GetWindowLongPtr(hwndCtl, GWLP_USERDATA);
            DisplayControlValue(hwndSlider, hwndSliderEditBuddy, i);
            break;

        case WM_INITDIALOG:

            g_hwndGlyphCacheDlg = hDlg;

            LoadString (g_hInst, IDS_REG_PATH,
                lpszRegPath, sizeof (lpszRegPath));

            hwndComboTextFrag = GetDlgItem(hDlg, IDC_CBO_TXT_FRAG);
            InitMiscControls( hDlg, hwndComboTextFrag);

            for (i = 0; i < NUMBER_OF_SLIDERS; i++) {

                //
                // get handles to slider contrls and static edit boxes
                //
                hwndSlider[i] = GetDlgItem(hDlg, (IDC_SLIDER1 + i));
                hwndSliderEditBuddy[i] = GetDlgItem(hDlg, (IDC_STATIC1 + i));

                //
                // save the index of the control
                //
                SetWindowLongPtr(hwndSlider[i], GWLP_USERDATA, i);

                SendMessage(hwndSlider[i], TBM_SETRANGE, FALSE,
                        (LPARAM) MAKELONG(1, 8));

                //
                // get value from registry and check it
                //
                nGlyphBuffer = GetRegKeyValue(i + GLYPHCACHEBASE);
                if ( (nGlyphBuffer) < MIN_GLYPH_CACHE_SIZE ||
                    (nGlyphBuffer > MAX_GLYPH_CACHE_SIZE) ) {

                    nGlyphBuffer =
                            g_KeyInfo[i + GLYPHCACHEBASE].DefaultKeyValue;
                }
                //
                // set the current key value
                //
                g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue =
                        nGlyphBuffer;
                _itot( nGlyphBuffer, (lpszBuffer), 10);
                //
                // display the value in the static edit control
                //
                SetWindowText(hwndSliderEditBuddy[i], lpszBuffer);
                //
                // position the thumb on the slider control
                //
                nGlyphBuffer = g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue;

#ifdef _X86_    // EXECUTE ASSEMBLER CODE ONLY IF X86 PROCESSOR
                // BSF: Bit Scan Forward -
                // Scans the value contained in the EAX regiseter
                // for the first significant (1) bit.
                // This function returns the location of the first
                // significant bit.  The function is used in this
                // application as a base 2 logarythm.  The location
                // of the bit is determined, stored in the nPos
                // variable, and nPos is used to set the slider
                // control. ie. If the register value is 4, nPos
                // is set to 2 (00000100).  10 minus 2 (position 8
                // on the slider control) represents the value 4.
                __asm
                {
                    BSF  EAX, nGlyphBuffer
                    MOV  nPos, EAX
                }
                nPos = 10 - nPos;
                SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, (LPARAM)nPos);

#else

               switch (nGlyphBuffer) {
                   case 4:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 8);
                       break;
                   case 8:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 7);
                       break;
                   case 16:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 6);
                       break;
                   case 32:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 5);
                       break;
                   case 64:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 4);
                       break;
                   case 128:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 3);
                       break;
                   case 256:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 2);
                       break;
                   case 512:
                       SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 1);
                       break;
               }
#endif


            } // end for loop
            break;


       case WM_NOTIFY:

            //
            // save settings on OK button
            //
            switch (lpnmhdr->code) {

                case PSN_HELP:
                    lphi = (LPHELPINFO) lParam;

                    WinHelp(lphi->hItemHandle,
                        g_lpszPath, HELP_CONTENTS, lphi->iCtrlId);
                    break;

                case PSN_APPLY:


                    for (i = 0; i < NUMBER_OF_SLIDERS; i++) {
                        if ( (g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue ==
                                g_KeyInfo[i+GLYPHCACHEBASE].DefaultKeyValue) ||
                                (g_KeyInfo[i+GLYPHCACHEBASE].CurrentKeyValue ==
                                 0)) {
                            DeleteRegKey(i + GLYPHCACHEBASE, lpszRegPath);
                        } else {
                            SetRegKey(i + GLYPHCACHEBASE, lpszRegPath);
                        }
                    } // ** end for loop

                    if (g_KeyInfo[GLYPHINDEX].CurrentKeyValue ==
                            g_KeyInfo[GLYPHINDEX].DefaultKeyValue) {
                        DeleteRegKey(GLYPHINDEX, lpszRegPath);
                    } else {
                        SetRegKey(GLYPHINDEX, lpszRegPath);
                    }

                    if (g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue ==
                            g_KeyInfo[TEXTFRAGINDEX].DefaultKeyValue) {
                        DeleteRegKey(TEXTFRAGINDEX, lpszRegPath);
                    } else {
                        SetRegKey(TEXTFRAGINDEX, lpszRegPath);
                    }
                }
                break;

        case WM_HELP:

            lphi = (LPHELPINFO) lParam;

            WinHelp(lphi->hItemHandle,
                    g_lpszPath, HELP_CONTEXTPOPUP, lphi->iCtrlId);
            break;


        case WM_COMMAND:

            switch  LOWORD (wParam) {

                case IDC_RADIO_NONE:
                    g_KeyInfo[GLYPHINDEX].CurrentKeyValue = NONE;
                    break;

                case IDC_RADIO_PARTIAL:
                    g_KeyInfo[GLYPHINDEX].CurrentKeyValue = PARTIAL;
                    break;

                case IDC_RADIO_FULL:
                    g_KeyInfo[GLYPHINDEX].CurrentKeyValue = FULL;
                    break;

                case IDC_GLYPH_BTN_RESTORE:

                    CheckDlgButton(hDlg, IDC_RADIO_FULL, TRUE);
                    CheckDlgButton(hDlg, IDC_RADIO_PARTIAL, FALSE);
                    CheckDlgButton(hDlg, IDC_RADIO_NONE, FALSE);

                    _itot(g_KeyInfo[TEXTFRAGINDEX].DefaultKeyValue,
                            lpszBuffer, 10);
                    SendMessage(hwndComboTextFrag, CB_SELECTSTRING, -1,
                            (LPARAM)(LPCSTR) lpszBuffer);
                    g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue =
                    g_KeyInfo[TEXTFRAGINDEX].DefaultKeyValue;

                    g_KeyInfo[GLYPHINDEX].CurrentKeyValue =
                            g_KeyInfo[GLYPHINDEX].DefaultKeyValue;

                    for (i = 0; i < NUMBER_OF_SLIDERS; i++) {

                        g_KeyInfo[i+GLYPHCACHEBASE].CurrentKeyValue =
                                g_KeyInfo[i+GLYPHCACHEBASE].DefaultKeyValue;

                        _itot(g_KeyInfo[i + GLYPHCACHEBASE].DefaultKeyValue,
                                (lpszBuffer), 10);

                        //
                        // display the value in the static edit control
                        //
                        SetWindowText(hwndSliderEditBuddy[i], lpszBuffer);
                        //
                        // position the thumb on the slider control
                        //
                        nGlyphBuffer = g_KeyInfo[i +
                        GLYPHCACHEBASE].DefaultKeyValue;

#ifdef _X86_            // EXECUTE ASSEMBLER CODE ONLY IF X86 PROCESSOR
                        // BSF: Bit Scan Forward -
                        // Scans the value contained in the EAX regiseter
                        // for the first significant (1) bit.
                        // This function returns the location of the first
                        // significant bit.  The function is used in this
                        // application as a base 2 logarythm.  The location
                        // of the bit is determined, stored in the nPos
                        // variable, and nPos is used to set the slider
                        // control. ie. If the register value is 4, nPos
                        // is set to 2 (00000100).  10 minus 2 (position 8
                        // on the slider control) represents the value 4.
                        __asm
                        {
                            BSF  EAX, nGlyphBuffer
                            MOV  nPos, EAX
                        }
                        nPos = 10 - nPos;
                        SendMessage(hwndSlider[i], TBM_SETPOS, TRUE,
                                (LPARAM)nPos);

#else

                       switch (nGlyphBuffer) {
                           case 4:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 8);
                               break;
                           case 8:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 7);
                               break;
                           case 16:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 6);
                               break;
                           case 32:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 5);
                               break;
                           case 64:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 4);
                               break;
                           case 128:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 3);
                               break;
                           case 256:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 2);
                               break;
                           case 512:
                               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 1);
                               break;
               }
#endif

                    }
                    break;
            }

            switch  HIWORD (wParam) {

                case CBN_EDITUPDATE:

                    //
                    // capture typed text
                    //
                    GetWindowText(hwndComboTextFrag, lpszBuffer, 5);
                    nKeyVal = _ttoi(lpszBuffer);
                    g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue = nKeyVal;
                    break;

                case CBN_KILLFOCUS:

                    //
                    // save value when control looses focus
                    //
                    GetWindowText(hwndComboTextFrag, lpszBuffer, 5);
                    nKeyVal = _ttoi(lpszBuffer);
                    g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue = nKeyVal;
                    break;
            }
    }
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
//
//  Returns the integer value related to the coresponding cell.
///////////////////////////////////////////////////////////////////////////////

int GetCellSize(int nPos, int i)
{
    if (nPos >= 1 && nPos <= NUM_SLIDER_STOPS) {
        return g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue =
                       (1 << ((NUM_SLIDER_STOPS + 2) - nPos));
    } else {
        return 0;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
//  Display the slider control value in it's corresponding static edit box.
///////////////////////////////////////////////////////////////////////////////

void DisplayControlValue(HWND hwndSlider[], HWND hwndSliderEditBuddy[],  int i)

{
    int nPos;
    TCHAR lpszBuffer[5];

    nPos = (int) SendMessage(hwndSlider[i], TBM_GETPOS, 0,0);
    _itot(GetCellSize(nPos, i), lpszBuffer, 10);
    SetWindowText(hwndSliderEditBuddy[i], lpszBuffer);
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\tlsapi.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsapi.cpp
//
// Contents:    
//
// History:     12-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <wincrypt.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <rpc.h>
#include <ntsecapi.h>
#include <lmcons.h>
#include <lmserver.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <ntdsapi.h>
#include <dsrole.h>
#include <lmjoin.h>
#include <winldap.h>
#include <winsock2.h>
#include <dsgetdc.h>
//
// Only include RNG functions from tssec
//
#define NO_INCLUDE_LICENSING 1
#include <tssec.h>

#include "lscommon.h"
#include "tlsrpc.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "lscsp.h"
#include "license.h"

static BOOL g_bLog = 1;

extern "C" {
   VOID LogMsg(
	           PWCHAR msgFormat, 
	           ...
	           );
}

extern "C" DWORD WINAPI 
TLSConnect( 
    handle_t binding,
    TLS_HANDLE *pphContext
);

extern "C" DWORD WINAPI 
TLSDisconnect( 
    TLS_HANDLE* pphContext
);

extern "C" BOOL
IsSystemService();

#include <lmcons.h>         // Netxxx API includes
#include <lmserver.h>
#include <lmerr.h>
#include <lmapibuf.h>

#define DISCOVERY_INTERVAL (60 * 60 * 1000)

static HANDLE g_hCachingThreadExit = NULL;
static HANDLE g_hImmediateDiscovery = NULL;
static HANDLE g_hDiscoverySoon = NULL;

static BOOL g_fOffSiteLicenseServer = FALSE;

static PSEC_WINNT_AUTH_IDENTITY g_pRpcIdentity = NULL;

#define REG_DOMAIN_SERVER_MULTI L"DomainLicenseServerMulti"

#define TERMINAL_SERVICE_PARAM_DISCOVERY  "SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters\\LicenseServers"

// 2 second timeout
#define SERVER_NP_TIMEOUT (2 * 1000)

#define INSTALL_CERT_DELAY (5 * 1000)

BOOL g_fInDomain = -1;

LONG lLibUsage = 0;

typedef struct {
    TLS_HANDLE *hBinding;
    DWORD dwTimeout;            // In milliseconds - INFINITE for none
    LARGE_INTEGER timeInitial;  // As returned by QueryPerformanceCounter
} LS_ENUM_PARAM, *PLS_ENUM_PARAM;

void * MIDL_user_allocate(size_t size)
{
    return(HeapAlloc(GetProcessHeap(), 0, size));
}

void MIDL_user_free( void *pointer)
{
    HeapFree(GetProcessHeap(), 0, pointer);
}


//
//  FUNCTIONS: StartTime()
//             EndTime()
//
//  USAGE:
//      StartTime();
//        // Do some work.
//      mseconds = EndTime();
//
//  RETURN VALUE:
//      Milliseconds between StartTime() and EndTime() calls.

LARGE_INTEGER TimeT;

void StartTimeT(void)
{
    QueryPerformanceCounter(&TimeT);
}

ULONG EndTimeT()
{
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liFreq;

    QueryPerformanceCounter(&liDiff);

    liDiff.QuadPart -= TimeT.QuadPart;
    liDiff.QuadPart *= 1000; // Adjust to milliseconds, shouldn't overflow...

    (void)QueryPerformanceFrequency(&liFreq);

    return ((ULONG)(liDiff.QuadPart / liFreq.QuadPart));
}

//+------------------------------------------------------------------------
// Function:   ConnectToLsServer()
//
// Description:
//
//      Binding to sepecific hydra license server
//
// Arguments:
//
//      szLsServer - Hydra License Server name
//
// Return Value:
//
//      RPC binding handle or NULL if error, use GetLastError() to retrieve
//      error.
//-------------------------------------------------------------------------
static TLS_HANDLE WINAPI
ConnectLsServer( 
        LPTSTR szLsServer, 
        LPTSTR szProtocol, 
        LPTSTR szEndPoint, 
        DWORD dwAuthLevel )
{
    LPTSTR           szBindingString;
    RPC_BINDING_HANDLE hBinding=NULL;
    RPC_STATUS       status;
    TLS_HANDLE       pContext=NULL;
    BOOL             fSuccess;
    HKEY             hKey = NULL;
    DWORD            dwType;
    DWORD            cbData;
    DWORD            dwErr;
    DWORD            dwNumRetries = 1;    // default to one retry
    LPWSTR           pszServerPrincipalName = NULL;

    if(g_bLog)
	{
        if (NULL != szLsServer)
          LogMsg(L"\nSERVER=%s\n",szLsServer);
	}

    //
    // If this isn't local
    //
    if ((NULL != szLsServer) && (NULL != szEndPoint))
    {
        TCHAR szPipeName[MAX_PATH+1];

        if (lstrlen(szLsServer) > ((sizeof(szPipeName) / sizeof(TCHAR)) - 26))
        {
            if(g_bLog)
               LogMsg(L"Server name too long\n");
            return NULL;
        }

        //
        // First check if license server named pipe exists
        //
        wsprintf(szPipeName,TEXT("\\\\%s\\pipe\\%s"),szLsServer,TEXT(SZSERVICENAME));

        if(g_bLog)
           StartTimeT();

        fSuccess = WaitNamedPipe(szPipeName,SERVER_NP_TIMEOUT);

        dwErr = GetLastError();

        if(g_bLog)
		{
           ULONG ulTime = EndTimeT();
           LogMsg(L"WaitNamedPipe time == %lu\n",ulTime);
		}

        if (!fSuccess)
        {
           if(g_bLog)
              LogMsg(L"WaitNamedPipe (%s) failed 0x%x\n",szPipeName,dwErr);
            return NULL;
        }
    }
    else if(g_bLog)
        LogMsg(L"Not trying WaitNamedPipe on local machine\n");


    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                         0,
                         KEY_READ,
                         &hKey);

    if (dwErr == ERROR_SUCCESS)
    {
        cbData = sizeof(dwNumRetries);
        dwErr = RegQueryValueEx(hKey,
                            L"NumRetries",
                            NULL,
                            &dwType,
                            (PBYTE)&dwNumRetries,
                            &cbData);

        RegCloseKey(hKey);

    }

    status = RpcStringBindingCompose(0,
                                     szProtocol,
                                     szLsServer,
                                     szEndPoint,
                                     0,
                                     &szBindingString);

    if(status!=RPC_S_OK)
    {
       if(g_bLog)
          LogMsg(L"RpcStringBindingCompose failed 0x%x\n",status);
       return NULL;
    }

    status=RpcBindingFromStringBinding( szBindingString, &hBinding);
    RpcStringFree( &szBindingString );
    if(status != RPC_S_OK)
    {
       if(g_bLog)
          LogMsg(L"RpcBindingFromStringBinding failed 0x%x\n",status);
        return NULL;
    }

    status = RpcMgmtSetComTimeout(hBinding,RPC_C_BINDING_MIN_TIMEOUT);
    if (status != RPC_S_OK)
    {
       if(g_bLog)
          LogMsg(L"RpcMgmtSetComTimeout failed 0x%x\n",status);
        return NULL;
    }
    
    BOOL fRetry = TRUE;

    //
    // Find the principle name
    //
    status = RpcMgmtInqServerPrincName(hBinding,
                                        RPC_C_AUTHN_GSS_NEGOTIATE,
                                        &pszServerPrincipalName);

    if(status == RPC_S_OK)
    {
    
        status=RpcBindingSetAuthInfo(hBinding,
                                     pszServerPrincipalName,
                                     dwAuthLevel,
                                     RPC_C_AUTHN_GSS_NEGOTIATE,
                                     g_pRpcIdentity,
                                     0);

        RpcStringFree(&pszServerPrincipalName);
    }
    else
        goto Label;
        
    if(status == RPC_S_OK)
    {
retry:

        // Obtain context handle from server
        status = TLSConnect( hBinding, &pContext );

        if(status != ERROR_SUCCESS)
        {
            pContext = NULL;

            if( status == RPC_S_UNKNOWN_AUTHN_SERVICE || status == ERROR_ACCESS_DENIED && fRetry) 
            {
Label:
                fRetry = FALSE;
               //Try again with no security set
               status = RpcBindingSetAuthInfo(hBinding,
                                         0,
                                         dwAuthLevel,
                                         RPC_C_AUTHN_WINNT,
                                         g_pRpcIdentity,
                                         0);
               if(status == RPC_S_OK)
               {
                   // Obtain context handle from server
                   status = TLSConnect( hBinding, &pContext );
               }

            }


            if((status == RPC_S_CALL_FAILED)  || (status == RPC_S_CALL_FAILED_DNE))
            {
                //
                // Workaround for an RPC problem where the first RPC after
                // the LS starts, fails
                //

                if (dwNumRetries > 0)
                {
                    dwNumRetries--;
                    
                    goto retry;
                }
            }
        }
    }    

    //
    // Memory leak
    //
    if(hBinding != NULL)
    {
        RpcBindingFree(&hBinding);
    }

    SetLastError((status == RPC_S_OK) ? ERROR_SUCCESS : status);
    return pContext;
}

//+------------------------------------------------------------------------
// Function:   BindAnyServer()
//
// Description:
//
//          Call back routine for TLSConnectToAnyLsServer()
//
// Arguments:
//
//          See EnumerateTlsServer()
//
// Return Value:
//
//          Always TRUE to terminate server enumeration
//-------------------------------------------------------------------------
static BOOL 
BindAnyServer(
    TLS_HANDLE hRpcBinding, 
    LPCTSTR pszServerName,
    HANDLE dwUserData
    )
/*++

++*/
{
    
    PLS_ENUM_PARAM pParam = (PLS_ENUM_PARAM) dwUserData;
    TLS_HANDLE* hBinding = pParam->hBinding; 
    RPC_STATUS rpcStatus;
    HKEY hKey = NULL;
    DWORD dwBuffer = 0;
    DWORD cbBuffer = sizeof (DWORD);
    DWORD dwErrCode = 0;


    // Skip Windows 2000 License servers
        
    
    if (hRpcBinding != NULL)
    {        
        DWORD dwSupportFlags = 0;

        dwErrCode = TLSGetSupportFlags(
                hRpcBinding,
                &dwSupportFlags
        );

	    if ((dwErrCode == RPC_S_OK) && !(dwSupportFlags & SUPPORT_WHISTLER_CAL))
        {                    
            return FALSE;
        }            	                

        // If the call fails => Windows 2000 LS
        else if(dwErrCode != RPC_S_OK)
        {
            return FALSE;
        }

        *hBinding=hRpcBinding;

        return TRUE;
    }                         

    if (pParam->dwTimeout != INFINITE)
    {
        LARGE_INTEGER timeDiff;
        LARGE_INTEGER timeFreq;

        *hBinding=hRpcBinding;

        QueryPerformanceCounter(&timeDiff);

        timeDiff.QuadPart -= pParam->timeInitial.QuadPart;
        timeDiff.QuadPart *= 1000; // Adjust to milliseconds, shouldn't overflow

        (void)QueryPerformanceFrequency(&timeFreq);

        if (((ULONG)(timeDiff.QuadPart / timeFreq.QuadPart)) > pParam->dwTimeout)
        {
           if(g_bLog)
              LogMsg(L"BindAnyServer timed out\n");
            return TRUE;
        }
    }

    return FALSE;
}    

void
RandomizeArray(LPWSTR *rgwszServers, DWORD cServers)
{
    DWORD i;
    LPWSTR wszServerTmp;
    int val;

    if (cServers < 2)
        return;

    srand(GetTickCount());

    for (i = 0; i < cServers; i++)
    {
        val = rand() % (cServers - i);

        if (val == 0)
            continue;

        //
        // Swap # i with # (val+i)
        //
        wszServerTmp = rgwszServers[i];
        rgwszServers[i] = rgwszServers[val+i];
        rgwszServers[val+i] = wszServerTmp;
    }
}

HRESULT
GetLicenseServersFromReg(LPWSTR wszRegKey, LPWSTR *ppwszServerNames,DWORD *pcServers, LPWSTR **prgwszServers)
{
    HRESULT          hr = S_OK;
    HKEY             hKey = NULL;
    DWORD            dwType;
    DWORD            cbData = 0;
    LPWSTR           szServers=NULL, pchServer;
    DWORD            dwErr;
    DWORD            i,val;
    DWORD            iLocalComputer = (DWORD)(-1);
    WCHAR            szLocalComputerName[MAXCOMPUTERNAMELENGTH+1] = L"";
    DWORD            cbLocalComputerName=MAXCOMPUTERNAMELENGTH+1;

    *ppwszServerNames = NULL;
    *prgwszServers = NULL;

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                         0,
                         KEY_READ,
                         &hKey);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    dwErr = RegQueryValueEx(hKey,
                            wszRegKey,
                            NULL,
                            &dwType,
                            NULL,
                            &cbData);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    if ((dwType != REG_MULTI_SZ) || (cbData < (2 * sizeof(WCHAR))))
    {
        hr = E_FAIL;
        goto CleanErr;
    }

    szServers = (LPWSTR) LocalAlloc(LPTR,cbData);
    if (NULL == szServers)
    {
        hr = E_OUTOFMEMORY;
        goto CleanErr;
    }

    dwErr = RegQueryValueEx(hKey,
                            wszRegKey,
                            NULL,
                            &dwType,
                            (PBYTE)szServers,
                            &cbData);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    for (i = 0, pchServer = szServers; (pchServer != NULL) && (*pchServer != L'\0'); pchServer = wcschr(pchServer,L'\0')+1, i++)
        ;

    if (i == 0)
    {
        hr = E_FAIL;
        goto CleanErr;
    }

    *pcServers = i;

    *prgwszServers = (LPWSTR *)LocalAlloc(LPTR,sizeof(LPWSTR) * (*pcServers));
    if (*prgwszServers == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto CleanErr;
    }

    // Don't treat error from this function as fatal
    GetComputerName(szLocalComputerName, &cbLocalComputerName);

    for (i = 0, pchServer = szServers; (i < (*pcServers)) && (pchServer != NULL) && (*pchServer != L'\0'); pchServer = wcschr(pchServer,L'\0')+1, i++) {

        (*prgwszServers)[i] = pchServer;

        if ((iLocalComputer == (DWORD)(-1)) && (wcscmp(pchServer,szLocalComputerName) == 0))
        {
            iLocalComputer = i;
        }
    }

    //
    // Put local computer at head of list
    //
    if (iLocalComputer != (DWORD)(-1))
    {
        if (iLocalComputer != 0)
        {
            //
            // Swap # iLocalComputer with # 0
            //
            pchServer = (*prgwszServers)[iLocalComputer];
            (*prgwszServers)[iLocalComputer] = (*prgwszServers)[0];
            (*prgwszServers)[0] = pchServer;
        }

        RandomizeArray((*prgwszServers)+1,(*pcServers) - 1);
    }
    else
    {
        RandomizeArray((*prgwszServers),*pcServers);
    }

    *ppwszServerNames = szServers;

CleanErr:
    if (FAILED(hr))
    {
        if (NULL != szServers)
        {
            LocalFree(szServers);
        }

        if (NULL != *prgwszServers)
        {
            LocalFree(*prgwszServers);
        }
    }

    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return hr;
}

HRESULT
WriteLicenseServersToReg(LPWSTR wszRegKey, LPWSTR pwszServerNames,DWORD cchServers)
{
    HRESULT          hr = S_OK;
    HKEY             hKey = NULL;
    DWORD            dwType = REG_MULTI_SZ;
    DWORD            dwErr;
    DWORD            dwDisp;

    //
    // Delete the value
    //

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                         0,
                         KEY_WRITE,
                         &hKey);
    if (dwErr == ERROR_SUCCESS)
    {
        RegDeleteValue(hKey,wszRegKey);       
    }

    if ((pwszServerNames == NULL) || (cchServers < 2))
    {
        hr = S_OK;
        goto CleanErr;
    }

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
        hKey = NULL;
    }

    dwErr = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT(LSERVER_DISCOVERY_PARAMETER_KEY),
                           0,
                           TEXT(""),
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hKey,
                           &dwDisp);
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }

    dwErr = RegSetValueEx(hKey,
                          wszRegKey,
                          0,
                          dwType,
                          (CONST BYTE *)pwszServerNames,
                          cchServers*sizeof(WCHAR));
    if (dwErr != ERROR_SUCCESS)
    {
        hr = HRESULT_FROM_WIN32(dwErr);
        goto CleanErr;
    }


CleanErr:
    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return hr;
}

//
// Free pszDomain using NetApiBufferFree
//

DWORD WINAPI
TLSInDomain(BOOL *pfInDomain, LPWSTR *pszDomain)
{
    NET_API_STATUS dwErr;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
    PDOMAIN_CONTROLLER_INFO pdcInfo = NULL;

    if (pfInDomain == NULL)
    {
        return ERROR_INVALID_PARAMETER;
    }

    *pfInDomain = FALSE;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(NULL,
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if ((dwErr != NO_ERROR) || (pDomainInfo == NULL))
    {
        return dwErr;
    }

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            DsRoleFreeMemory(pDomainInfo);

            if (NULL != pszDomain)
            {
                NETSETUP_JOIN_STATUS BufferType;

                dwErr = NetGetJoinInformation(NULL,pszDomain,&BufferType);
            }

            return dwErr;
            break;      // just in case
    }

    DsRoleFreeMemory(pDomainInfo);


    dwErr = DsGetDcName(NULL,   // Computer Name
                        NULL,   // Domain Name
                        NULL,   // Domain GUID
                        NULL,   // Site Name
                        DS_DIRECTORY_SERVICE_PREFERRED,
                        &pdcInfo);

    if ((dwErr != NO_ERROR) || (pdcInfo == NULL))
    {
        if (dwErr == ERROR_NO_SUCH_DOMAIN)
        {
            *pfInDomain = FALSE;
            return NO_ERROR;
        }
        else
        {
            if (pdcInfo == NULL)
                dwErr = ERROR_INTERNAL_ERROR;
            return dwErr;
        }
    }

    if (pdcInfo->Flags & DS_DS_FLAG)
    {
        *pfInDomain = TRUE;

    }

    if (pszDomain != NULL)
    {
        dwErr = NetApiBufferAllocate((wcslen(pdcInfo->DomainName)+1) * sizeof(WCHAR),
                                     (LPVOID *)pszDomain);

        if ((NERR_Success == dwErr) && (NULL != *pszDomain))
        {
            wcscpy(*pszDomain,pdcInfo->DomainName);
        }
    }

    if (pdcInfo != NULL)
        NetApiBufferFree(pdcInfo);

    return dwErr;
}

/*++

Function:

    LicenseServerCachingThread

Description:

    This is the thread that does the license server caching.

Arguments:

    lpParam - contains the exit event handle

Returns:

    Always 1

--*/

DWORD WINAPI
LicenseServerCachingThread(
    LPVOID lpParam )
{
    DWORD
        dwWaitStatus;
    HANDLE
        hExit = (HANDLE)lpParam;
    DWORD
        dwDiscoveryInterval = DISCOVERY_INTERVAL;
    HANDLE
        rgWaitHandles[] = {hExit,g_hImmediateDiscovery,g_hDiscoverySoon};
    BOOL
        bFoundServer;
    BOOL
        bSkipOne = FALSE;
    HANDLE
        hEvent;

    //
    // Yield our time slice to other threads now, so that the terminal server
    // service can start up quickly.  Refresh the license server cache when we
    // resume our time slice.
    //

    Sleep( 0 );

    while (1)
    {
        if (!bSkipOne)
        {
            bFoundServer = TLSRefreshLicenseServerCache(INFINITE);

            if ((!g_fOffSiteLicenseServer) && bFoundServer)
            {
                dwDiscoveryInterval = INFINITE;
            }
        }
        else
        {
            bSkipOne = FALSE;
        }

        dwWaitStatus = WaitForMultipleObjects(
                            sizeof(rgWaitHandles) / sizeof(HANDLE),
                            rgWaitHandles,
                            FALSE, // wait for any one event
                            dwDiscoveryInterval);

        if (WAIT_OBJECT_0 == dwWaitStatus)
        {
            // hExit was signalled
            goto done;
        }

        if ((WAIT_OBJECT_0+1) == dwWaitStatus)
        {
            // g_hImmediateDiscovery was signalled
            // reduce dwDiscoveryInterval

            dwDiscoveryInterval = DISCOVERY_INTERVAL;
        }

        if ((WAIT_OBJECT_0+2) == dwWaitStatus)
        {
            // g_hDiscoverySoon was signalled
            // reduce dwDiscoveryInterval, but wait one round

            dwDiscoveryInterval = DISCOVERY_INTERVAL;
            bSkipOne = TRUE;
        }

        // we timed out, or hImmediateDiscovery was signalled.  Re-start
        // discovery
    }

done:
    hEvent = g_hCachingThreadExit;
    g_hCachingThreadExit = NULL;

    CloseHandle(hEvent);

    hEvent = g_hImmediateDiscovery;
    g_hImmediateDiscovery = NULL;

    CloseHandle(hEvent);

    hEvent = g_hDiscoverySoon;
    g_hDiscoverySoon = NULL;

    CloseHandle(hEvent);

    return 1;
}

extern "C" void
TLSShutdown()
{
    if (0 < InterlockedDecrement(&lLibUsage))
    {
        //
        // Someone else is using it
        //
        return;
    }

    TLSStopDiscovery();

    if (NULL != g_pRpcIdentity)
    {
        PSEC_WINNT_AUTH_IDENTITY pRpcIdentity = g_pRpcIdentity;

        g_pRpcIdentity = NULL;

        if (NULL != pRpcIdentity->User)
        {
            LocalFree(pRpcIdentity->User);
        }

        LocalFree(pRpcIdentity);
    }

    //
    // Cleanup random number generator
    //
    TSRNG_Shutdown();

    LsCsp_Exit();
}

extern "C" DWORD WINAPI
TLSInit()
{
    LICENSE_STATUS status;
    BOOL fInDomain = FALSE;

    if (0 != InterlockedExchangeAdd(&lLibUsage,1))
    {
        //
        // Already been initialized
        //
        return ERROR_SUCCESS;
    }

    status = LsCsp_Initialize();
    if (LICENSE_STATUS_OK != status)
    {
        InterlockedDecrement(&lLibUsage);
        switch (status)
        {        
            case LICENSE_STATUS_OUT_OF_MEMORY:
                return ERROR_NOT_ENOUGH_MEMORY;

            case LICENSE_STATUS_NO_CERTIFICATE:
                return SCARD_E_CERTIFICATE_UNAVAILABLE;

            case LICENSE_STATUS_INVALID_CERTIFICATE:
                return CERT_E_MALFORMED;

            default:
                return E_FAIL;
        }
    }

    if ((NO_ERROR == TLSInDomain(&fInDomain, NULL))
        && (fInDomain)
        && (IsSystemService()))
    {

        // 
        // We're running as SYSTEM
        // Create an RPC identity for use as an RPC client
        //

        g_pRpcIdentity = (PSEC_WINNT_AUTH_IDENTITY) LocalAlloc(LPTR, sizeof(SEC_WINNT_AUTH_IDENTITY));

        if (NULL != g_pRpcIdentity)
        {
            g_pRpcIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

            g_pRpcIdentity->UserLength = MAX_COMPUTERNAME_LENGTH + 2;

            g_pRpcIdentity->User = (WCHAR *) LocalAlloc(LPTR, g_pRpcIdentity->UserLength * sizeof(WCHAR));

            if (NULL != g_pRpcIdentity->User)
            {
                if (GetComputerNameEx(ComputerNamePhysicalNetBIOS,g_pRpcIdentity->User,&(g_pRpcIdentity->UserLength)))
                {
                    if (g_pRpcIdentity->UserLength < MAX_COMPUTERNAME_LENGTH + 1)
                    {
                        g_pRpcIdentity->User[g_pRpcIdentity->UserLength++] = L'$';
                        g_pRpcIdentity->User[g_pRpcIdentity->UserLength] = 0;

                    }
                    else
                    {
                        LocalFree(g_pRpcIdentity->User);

                        LocalFree(g_pRpcIdentity);
                        g_pRpcIdentity = NULL;

                        InterlockedDecrement(&lLibUsage);

                        return E_FAIL;
                    }
                }
                else
                {
                    LocalFree(g_pRpcIdentity->User);

                    LocalFree(g_pRpcIdentity);
                    g_pRpcIdentity = NULL;

                    InterlockedDecrement(&lLibUsage);

                    return GetLastError();
                }
            }
            else
            {
                LocalFree(g_pRpcIdentity);
                g_pRpcIdentity = NULL;

                InterlockedDecrement(&lLibUsage);

                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }
        else
        {
            InterlockedDecrement(&lLibUsage);
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    //
    // Init random number generator
    //
    TSRNG_Initialize();

    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI
TLSStartDiscovery()
{
    HANDLE hCachingThread = NULL;
    HANDLE hEvent;

    if (NULL != g_hCachingThreadExit)
    {		
        // already started
        return ERROR_SUCCESS;
    }

    //
    // Create the event to signal thread exit
    //
        
    g_hCachingThreadExit = CreateEvent( NULL, FALSE, FALSE, NULL );
    
    if( NULL == g_hCachingThreadExit )
    {
        return GetLastError();
    }

    g_hImmediateDiscovery = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (NULL == g_hImmediateDiscovery)
    {
        hEvent = g_hCachingThreadExit; 
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        return GetLastError();
    }


    g_hDiscoverySoon = CreateEvent(NULL,FALSE,FALSE,NULL);

    if (NULL == g_hDiscoverySoon)
    {
        hEvent = g_hCachingThreadExit; 
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        hEvent = g_hImmediateDiscovery; 
        g_hImmediateDiscovery = NULL;

        CloseHandle(hEvent);

        return GetLastError();
    }

    //
    // Create the caching thread
    //
        
    hCachingThread = CreateThread(
                                    NULL,
                                    0,
                                    LicenseServerCachingThread,
                                    ( LPVOID )g_hCachingThreadExit,
                                    0,
                                    NULL );

    if (hCachingThread == NULL)
    {		
        hEvent = g_hCachingThreadExit; 
        g_hCachingThreadExit = NULL;

        CloseHandle(hEvent);

        hEvent = g_hImmediateDiscovery; 
        g_hImmediateDiscovery = NULL;

        CloseHandle(hEvent);

        hEvent = g_hDiscoverySoon; 
        g_hDiscoverySoon = NULL;

        CloseHandle(hEvent);

        return GetLastError();
    }

    CloseHandle(hCachingThread);

    return ERROR_SUCCESS;
}

extern "C" DWORD WINAPI
TLSStopDiscovery()
{
    //
    // Signal the thread to exit
    //

    if (NULL != g_hCachingThreadExit)
    {
        SetEvent( g_hCachingThreadExit );
    }

    return ERROR_SUCCESS;
}

//
// Number of DCs to allocate space for at a time
//
#define DC_LIST_CHUNK   10

//+------------------------------------------------------------------------
// Function:   
//
//      EnumerateLsServer()
//
// Description:
//
//      Routine to enumerate all hydra license server in network
//
// Arguments:
//
//      szScope - Scope limit, NULL if doen't care.
//      dwPlatformType - verify if license server have licenses for this platform, 
//                       LSKEYPACKPLATFORMTYPE_UNKNOWN if doesn't care.
//      fCallBack - call back routine when EnumerateServer() founds any server,
//      dwUserData - data to be pass to call back routine
//    
// Return Value:
//
//      RPC_S_OK or any RPC specific error code.
//
// NOTE: 
//
//      Enumeration terminate when either there is no more server or call back
//      routine return TRUE.
//
//-------------------------------------------------------------------------
DWORD WINAPI
EnumerateTlsServerInDomain(  
    IN LPCTSTR szDomain,                           
    IN TLSENUMERATECALLBACK fCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    IN BOOL fRegOnly,
    IN OUT BOOL *pfOffSite
    )
/*++

++*/
{   
    DWORD entriesread = 0;
    BOOL bCancel=FALSE;
    DWORD dwErrCode;
    LPWSTR pwszServerTmp = NULL;
    LPWSTR pwszServer = NULL;
    HRESULT hr;
    LPWSTR pwszServers = NULL;
    LPWSTR pwszServersTmp = NULL;
    DWORD cchServers = 0;
    DWORD cchServer;
    LPWSTR *rgwszServers = NULL;
    LPWSTR *rgwszServersTmp;
    LPWSTR pwszServerNames = NULL;
    DWORD dwErr = ERROR_SUCCESS, i;
    HANDLE hDcOpen = NULL;
    LPWSTR szSiteName = NULL;
    BOOL fOffSiteIn;
    BOOL fFoundOne = FALSE;
    BOOL fFoundOneOffSite = FALSE;
    DWORD cChunks = 0;
    DWORD cServersOnSite = 0;   
    

    if (fRegOnly)
    {
        //
        // check for a license server in the registry
        //
		if(g_bLog)
           LogMsg(L"\n----------Trying Domain License Server Discovery Cache----------\n");
        hr = GetLicenseServersFromReg(REG_DOMAIN_SERVER_MULTI,&pwszServerNames,&entriesread,&rgwszServers);
        if (FAILED(hr))
        {
            dwErr = hr;
            goto Cleanup;
        }
    } 
    else
    {
		if(g_bLog)
		   LogMsg(L"\n----------Trying Domain License Server Discovery----------\n");
        if (NULL == pfOffSite)
        {
            return ERROR_INVALID_PARAMETER;
        }

        fOffSiteIn = *pfOffSite;

        *pfOffSite = FALSE;

        dwErr = DsGetSiteName(NULL,&szSiteName);
        if(dwErr != ERROR_SUCCESS)
        {
           if(g_bLog)
              LogMsg(L"DsGetSiteName failed %x\n",dwErr);
            goto Cleanup;
        }

        dwErr = DsGetDcOpenW(szDomain,
                             fOffSiteIn ? DS_NOTIFY_AFTER_SITE_RECORDS: DS_ONLY_DO_SITE_NAME,
                             szSiteName,
                             NULL,       // DomainGuid
                             NULL,       // DnsForestName
                             0,          // Flags
                             &hDcOpen
                             );

        if(dwErr != ERROR_SUCCESS)
        {
           if(g_bLog)
              LogMsg(L"DsGetDcOpen failed %x\n",dwErr);
            goto Cleanup;
        }

        rgwszServers = (LPWSTR *) LocalAlloc(LPTR,
                                             DC_LIST_CHUNK * sizeof(LPWSTR));
        if (NULL == rgwszServers)
        {
           if(g_bLog)
              LogMsg(L"Out of memory\n");
            dwErr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        cChunks = 1;

        //
        // Read the whole DC list
        //

        do
        {
            if (entriesread >= (cChunks * DC_LIST_CHUNK))
            {                
                cChunks++;

                rgwszServersTmp = (LPWSTR *)
                    LocalReAlloc(rgwszServers,
                                 DC_LIST_CHUNK * sizeof(LPWSTR) * cChunks,
                                 LHND);

                if (NULL == rgwszServersTmp)
                {
                    dwErr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                else
                {
                    rgwszServers = rgwszServersTmp;
                }
            }

            dwErr = DsGetDcNextW(hDcOpen,
                                 NULL,
                                 NULL,
                                 rgwszServers+entriesread);         

            
            if (ERROR_FILEMARK_DETECTED == dwErr)
            {                
                                
                // Now going off-site; use NULL ptr marker

                rgwszServers[entriesread] = NULL;

                cServersOnSite = entriesread;

                dwErr = ERROR_SUCCESS;

                fFoundOneOffSite = TRUE;
            }                  

            entriesread++;

        } while (ERROR_SUCCESS == dwErr);

        // don't count the final error
        entriesread--;

        if (!fFoundOneOffSite)
            cServersOnSite = entriesread;

        // Now randomize the two portions of the array

        RandomizeArray(rgwszServers,cServersOnSite);

        if (fFoundOneOffSite)
        {
            RandomizeArray(rgwszServers+cServersOnSite+1,
                           entriesread - cServersOnSite - 1);
        }

        // Now allocate memory for registry entry

        pwszServers = (LPWSTR) LocalAlloc(LPTR,2*sizeof(WCHAR));
        if (NULL == pwszServers)
        {
           if(g_bLog)
              LogMsg(L"Out of memory\n");
            dwErr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        cchServers = 2;
        pwszServers[0] = pwszServers[1] = L'\0';
    }

    for(i=0; bCancel == FALSE; i++)
    {
        PCONTEXT_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;

        if (!fRegOnly)
        {
            if (fFoundOneOffSite && i == cServersOnSite)
            {
                if (fFoundOne)
                    break;

                // Now going off-site

                i++;
                *pfOffSite = TRUE;
            }
        }

        if (i >= entriesread)
            break;

        pwszServerTmp = rgwszServers[i];

        bCancel=fCallBack(pContext, pwszServerTmp, dwUserData);
        if(bCancel == TRUE)
            continue;

        if(!(pContext = TLSConnectToLsServer(pwszServerTmp)))
        {
            //
            // could be access denied.
            //
           if(g_bLog)
              LogMsg(L"Can't connect to %s. Maybe it has no License Service running on it.\n",pwszServerTmp);

            continue;
        }        

        do {
            //
            // Skip enterprise server
            //
            DWORD dwVersion;
            rpcStatus = TLSGetVersion( pContext, &dwVersion );
            if(rpcStatus != RPC_S_OK)
            {
                break;
            }

#if ENFORCE_LICENSING

            //
            // W2K Beta 3 to RC1 upgrade, don't connect to any non-enforce
            // server 5.2 or older
            //
            if(IS_ENFORCE_LSSERVER(dwVersion) == FALSE)
            {
                if( GET_LSSERVER_MAJOR_VERSION(dwVersion) <= 5 &&
                    GET_LSSERVER_MINOR_VERSION(dwVersion) <= 2 )
                {
                    continue;
                }
            }

           if( GET_LSSERVER_MAJOR_VERSION(dwVersion) < 6 )
           {
               continue;
           }

            //
            // Prevent beta <-> RTM server talking to each other
            //

            //
            // TLSIsBetaNTServer() returns TRUE if eval NT
            // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
            //

            if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
            {
                continue;
            }
#endif

            if(dwVersion & TLS_VERSION_ENTERPRISE_BIT)
            {
                continue;
            }           

            if(g_bLog)
               LogMsg(L"!!!Connected to License Service on %s\n",pwszServerTmp);
            bCancel=fCallBack(pContext, pwszServerTmp, dwUserData);    

            if (!fRegOnly)
            {
                // 
                // Add to list of servers
                //
                cchServer = wcslen(pwszServerTmp);
                
                pwszServersTmp = (LPWSTR) LocalReAlloc(pwszServers,(cchServers+cchServer+1)*sizeof(TCHAR),LHND);
                if (NULL == pwszServersTmp)
                {
                    break;
                }
                
                pwszServers = pwszServersTmp;
                
                if (cchServers == 2)
                {
                    wcscpy(pwszServers,pwszServerTmp);
                    
                    cchServers += cchServer;
                } else
                {
                    wcscpy(pwszServers+cchServers-1,pwszServerTmp);
                    
                    cchServers += cchServer + 1;
                    
                }
                pwszServers[cchServers-1] = L'\0';
            }

            fFoundOne = TRUE;

        } while (FALSE);

        if(bCancel == FALSE && pContext != NULL)
        {
            TLSDisconnect(&pContext);
        }

    } // for loop

    if (!fRegOnly)
    {
        WriteLicenseServersToReg(REG_DOMAIN_SERVER_MULTI,pwszServers,cchServers);
    }

Cleanup:
    if (NULL != hDcOpen)
        DsGetDcCloseW(hDcOpen);

    if (NULL != rgwszServers)
    {
        if (!fRegOnly)
        {
            for (i = 0; i < entriesread; i++)
            {
                if (NULL != rgwszServers[i])
                {
                    NetApiBufferFree(rgwszServers[i]);
                }
            }
        }
        LocalFree(rgwszServers);
    }

    if (szSiteName)
        NetApiBufferFree(szSiteName);

    if (pwszServerNames)
        LocalFree(pwszServerNames);

    if (pwszServers)
        LocalFree(pwszServers);

    if (pwszServer)
        LocalFree(pwszServer);

    return dwErr;
}

DWORD WINAPI
EnumerateTlsServerInWorkGroup(  
    IN TLSENUMERATECALLBACK pfCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    IN BOOL fRegOnly
    )
/*++


++*/
{   
    DWORD dwStatus=ERROR_SUCCESS;

    TCHAR szServerMailSlotName[MAX_PATH+1];
    TCHAR szLocalMailSlotName[MAX_PATH+1];

    HANDLE hClientSlot = INVALID_HANDLE_VALUE;
    HANDLE hServerSlot = INVALID_HANDLE_VALUE;

    TCHAR szDiscMsg[MAX_MAILSLOT_MSG_SIZE+1];
    TCHAR szComputerName[MAXCOMPUTERNAMELENGTH+1];
    TCHAR szRandomMailSlotName[MAXCOMPUTERNAMELENGTH+1];

    DWORD cbComputerName=MAXCOMPUTERNAMELENGTH+1;

    DWORD cbWritten=0;
    DWORD cbRead=0;    
    BOOL bCancel = FALSE;
    DWORD dwErrCode;
    HRESULT hr;
    LPWSTR pwszServers = NULL;
    LPWSTR pwszServersTmp = NULL;
    DWORD cchServers = 0;
    DWORD cchServer;
    LPWSTR *rgwszServers = NULL;
    LPWSTR pwszServerNames = NULL;
    DWORD cServers = 0;
    DWORD i = 0;
    LPWSTR pwszServerTmp = szComputerName;

    if (!fRegOnly)
    {
		if(g_bLog)
		   LogMsg(L"\n----------Trying Workgroup License Server Discovery----------\n");
        if(!GetComputerName(szComputerName, &cbComputerName))
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        if (0 == (1 & GetSystemMetrics(SM_NETWORK)))
        {
            // No network; try local machine
            if(g_bLog)
               LogMsg(L"No network, trying local computer=%s\n",szComputerName);

            dwStatus = ERROR_SUCCESS;
            goto TryServer;
        }

        wsprintf(
                 szRandomMailSlotName,
                 _TEXT("%08x"),
                 GetCurrentThreadId()
                 );
            
        _stprintf(
                  szLocalMailSlotName, 
                  _TEXT("\\\\.\\mailslot\\%s"), 
                  szRandomMailSlotName
                  );

        // 
        // Create local mail slot for server's response
        //
        hClientSlot=CreateMailslot( 
                                   szLocalMailSlotName, 
                                   0,
                                   (dwTimeOut == MAILSLOT_WAIT_FOREVER) ? 5 * 1000: dwTimeOut,
                                   NULL
                                   );

        if(hClientSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // Open server's mail slot
        //
        _stprintf(
                  szServerMailSlotName, 
                  _TEXT("\\\\%s\\mailslot\\%s"), 
                  _TEXT("*"), 
                  _TEXT(SERVERMAILSLOTNAME)
                  );

        hServerSlot=CreateFile(
                               szServerMailSlotName,
                               GENERIC_WRITE,             // only need write
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               FILE_ATTRIBUTE_NORMAL,
                               NULL
                               );
        if(hServerSlot == INVALID_HANDLE_VALUE)
        {
            dwStatus = GetLastError();
            goto cleanup;
        }

        //
        // Formulate discovery message
        //
        _stprintf(
                  szDiscMsg, 
                  _TEXT("%s %c%s%c %c%s%c"), 
                  _TEXT(LSERVER_DISCOVERY), 
                  _TEXT(LSERVER_OPEN_BLK), 
                  szComputerName,
                  _TEXT(LSERVER_CLOSE_BLK),
                  _TEXT(LSERVER_OPEN_BLK), 
                  szRandomMailSlotName,
                  _TEXT(LSERVER_CLOSE_BLK)
                  );

        if (!WriteFile(hServerSlot, szDiscMsg, (_tcslen(szDiscMsg) + 1) * sizeof(TCHAR), &cbWritten, NULL) ||
            (cbWritten != (_tcslen(szDiscMsg) + 1 ) * sizeof(TCHAR)))
        {
            dwStatus = GetLastError();
            
            if (dwStatus == ERROR_NETWORK_UNREACHABLE)
            {
                // No network; try local machine
                if(g_bLog)
                   LogMsg(L"No network, trying local computer=%s\n",szComputerName);
                dwStatus = ERROR_SUCCESS;
                goto TryServer;
            }
            else
            {
                goto cleanup;            
            }
        }

        // Allocate for registry entry

        pwszServers = (LPWSTR) LocalAlloc(LPTR,2*sizeof(WCHAR));
        if (NULL == pwszServers)
        {
        if(g_bLog)
            LogMsg(L"Out of memory\n");
            
            dwStatus = E_OUTOFMEMORY;
            goto cleanup;
        }
        
        cchServers = 2;
        pwszServers[0] = pwszServers[1] = L'\0';
    } else
    {
        //
        // check for a license server in the registry
        //
		if(g_bLog)
           LogMsg(L"\n----------Trying Workgroup License Server Discovery Cache----------");
        hr = GetLicenseServersFromReg(REG_DOMAIN_SERVER_MULTI,&pwszServerNames,&cServers,&rgwszServers);
        if (FAILED(hr))
        {
            dwStatus = hr;
            goto cleanup;
        }
    }

    do {
        if(fRegOnly)
        {
            if (i >= cServers)
            {
                break;
            }

            pwszServerTmp = rgwszServers[i++];
        } else
        {
            memset(szComputerName, 0, sizeof(szComputerName));
            if(!ReadFile(hClientSlot, szComputerName, sizeof(szComputerName) - sizeof(TCHAR), &cbRead, NULL))
            {
                dwStatus=GetLastError();
                break;
            }

            if(g_bLog)
               LogMsg(L"Trying server=%s\n",szComputerName);

        }

TryServer:

        bCancel=pfCallBack(NULL, pwszServerTmp, dwUserData);
        if(bCancel == TRUE)
        {
            continue;
        }

        PCONTEXT_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;

        if(!(pContext = TLSConnectToLsServer(pwszServerTmp)))
        {
            //
            // could be access denied.
            //
            continue;
			if(g_bLog)
               LogMsg(L"Can't connect to %s. Maybe it has no License Service running on it.\n",pwszServerTmp);
        }

        do {            
            //
            // Skip enterprise server
            //
            DWORD dwVersion;
            rpcStatus = TLSGetVersion( pContext, &dwVersion );
            if(rpcStatus != RPC_S_OK)
            {
                continue;
            }

#if ENFORCE_LICENSING

            //
            // W2K Beta 3 to RC1 upgrade, don't connect to any non-enforce
            // server 5.2 or older
            //
            if(IS_ENFORCE_LSSERVER(dwVersion) == FALSE)
            {
                if( GET_LSSERVER_MAJOR_VERSION(dwVersion) <= 5 &&
                    GET_LSSERVER_MINOR_VERSION(dwVersion) <= 2 )
                {
                    continue;
                }
            }
           if( GET_LSSERVER_MAJOR_VERSION(dwVersion) < 6 )
           {
               continue;
           }
            //
            // No Beta <--> RTM server.
            //
            //
            // TLSIsBetaNTServer() returns TRUE if eval NT
            // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
            //
            if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
            {
                continue;
            }

#endif

            if(dwVersion & TLS_VERSION_ENTERPRISE_BIT)
            {
                continue;
            }           
        
			if(g_bLog)
               LogMsg(L"!!!Connected to License Service on %s\n",pwszServerTmp);
            bCancel=pfCallBack(pContext, pwszServerTmp, dwUserData);    
            
            if (!fRegOnly)
            {
                // 
                // Add to list of servers
                //
                cchServer = wcslen(pwszServerTmp);
                    
                pwszServersTmp = (LPWSTR) LocalReAlloc(pwszServers,(cchServers+cchServer+1)*sizeof(TCHAR),LHND);
                if (NULL == pwszServersTmp)
                {
                    continue;
                }
                
                pwszServers = pwszServersTmp;
                
                if (cchServers == 2)
                {
                    wcscpy(pwszServers,pwszServerTmp);
                
                    cchServers += cchServer;
                } else
                {
                    wcscpy(pwszServers+cchServers-1,pwszServerTmp);
                    
                    cchServers += cchServer + 1;
                
                }
                pwszServers[cchServers-1] = L'\0';
            }
        } while (FALSE);

        if(bCancel == FALSE && pContext != NULL)
        {
            TLSDisconnectFromServer(pContext);
        }

    } while(bCancel == FALSE);

    if (!fRegOnly)
    {
        WriteLicenseServersToReg(REG_DOMAIN_SERVER_MULTI,pwszServers,cchServers);
    }


cleanup:    

    if(hClientSlot != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hClientSlot);
    }

    if(hServerSlot != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hServerSlot);
    }

    if (pwszServerNames)
        LocalFree(pwszServerNames);

    if (pwszServers)
        LocalFree(pwszServers);

    if (rgwszServers)
        LocalFree(rgwszServers);

    return dwStatus;
}

DWORD 
GetServersFromRegistry(
                       LPWSTR wszRegKey,
                       LPWSTR **prgszServers,
                       DWORD  *pcCount
                       )
{
    HKEY hParamKey = NULL;
    DWORD dwValueType;
    DWORD cbValue = 0, dwDisp;
    LONG lReturn;
    DWORD cbServer;
    DWORD cServers;
    DWORD cchServerMax;
    LPWSTR *rgszServers;
    DWORD i, j;

    *prgszServers = NULL;
    *pcCount = 0;

    lReturn = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           wszRegKey,
                           0,
                           KEY_READ,
                           &hParamKey );

    if (ERROR_SUCCESS != lReturn)
        return lReturn;

    lReturn = RegQueryInfoKey(hParamKey,
                              NULL,
                              NULL,
                              NULL,
                              &cServers,
                              &cchServerMax,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL,
                              NULL);

    if (ERROR_SUCCESS != lReturn)
    {
        RegCloseKey( hParamKey );
        return lReturn;
    }

    if (0 == cServers)
    {
        RegCloseKey( hParamKey );
        return ERROR_NO_MORE_ITEMS;
    }

    rgszServers = (LPWSTR *) LocalAlloc(LPTR,cServers*sizeof(LPWSTR));
    if (NULL == rgszServers)
    {
        RegCloseKey( hParamKey );
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // Add one for null terminator
    cchServerMax++;
    
    for (i = 0; i < cServers; i++)
    {
        rgszServers[i] = (LPWSTR) LocalAlloc(LPTR,cchServerMax * sizeof(WCHAR));

        if (NULL == rgszServers[i])
        {
            for (j = 0; j < i; j++)
            {
                LocalFree(rgszServers[j]);
            }
            LocalFree(rgszServers);

            RegCloseKey( hParamKey );
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        cbServer = cchServerMax * sizeof(WCHAR);

        lReturn = RegEnumKeyEx(hParamKey,
                               i,
                               rgszServers[i],
                               &cbServer,
                               NULL,
                               NULL,
                               NULL,
                               NULL);

        if (ERROR_SUCCESS != lReturn)
        {
            for (j = 0; j <= i; j++)
            {
                LocalFree(rgszServers[j]);
            }
            LocalFree(rgszServers);

            RegCloseKey( hParamKey );

            return lReturn;
        }
    }

    *prgszServers = rgszServers;
    *pcCount = cServers;

    return ERROR_SUCCESS;
}

DWORD WINAPI
EnumerateTlsServerInRegistry(
    IN TLSENUMERATECALLBACK pfCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    LPWSTR wszRegKey
    )
/*++


++*/
{
    BOOL bCancel=FALSE;
    DWORD dwIndex = 0;
    DWORD cServers = 0;
    LPWSTR *rgszServers = NULL;
    DWORD lReturn;
	
    lReturn = GetServersFromRegistry(wszRegKey,
                                     &rgszServers,
                                     &cServers
                                     );

    if (ERROR_SUCCESS != lReturn)
    {
        return lReturn;
    }
	if(g_bLog)
       LogMsg(L"\n----------Trying Registry Bypass Discovery----------\n");

    RandomizeArray(rgszServers,cServers);

    for (;dwIndex < cServers; dwIndex++)
    {
        PCONTEXT_HANDLE pContext=NULL;
        RPC_STATUS rpcStatus;

        bCancel=pfCallBack(pContext, rgszServers[dwIndex], dwUserData);
        if(bCancel == TRUE)
            continue;

        if(!(pContext = TLSConnectToLsServer(rgszServers[dwIndex])))
        {
            //
            // could be access denied, or the machine is gone
            //
			if(g_bLog)
               LogMsg(L"Can't connect to %s. Maybe it has no License Service running on it.\n",rgszServers[dwIndex]);
            continue;
        }

        do {            
            //
            // Skip enterprise server
            //
            DWORD dwVersion;
            rpcStatus = TLSGetVersion( pContext, &dwVersion );
            if(rpcStatus != RPC_S_OK)
            {
                break;
            }

#if ENFORCE_LICENSING

            //
            // W2K Beta 3 to RC1 upgrade, don't connect to any non-enforce
            // server 5.2 or older
            //
            if(IS_ENFORCE_LSSERVER(dwVersion) == FALSE)
            {
                if( GET_LSSERVER_MAJOR_VERSION(dwVersion) <= 5 &&
                    GET_LSSERVER_MINOR_VERSION(dwVersion) <= 2 )
                {
                    // old License Server
                    continue;
                }
            }

           if( GET_LSSERVER_MAJOR_VERSION(dwVersion) < 6 )
           {
               continue;
           }
            //
            // Prevent beta <-> RTM server talking to each other
            //

            //
            // TLSIsBetaNTServer() returns TRUE if eval NT
            // IS_LSSERVER_RTM() returns TRUE if LS is an RTM.
            //

            if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
            {
                continue;
            }
#endif
			if(g_bLog)
               LogMsg(L"!!!Connected to License Service on %s\n",rgszServers[dwIndex]);
            bCancel=pfCallBack(pContext, rgszServers[dwIndex], dwUserData);    

        } while (FALSE);

        if(bCancel == FALSE && pContext != NULL)
        {
            TLSDisconnect(&pContext);
        }

    } // for loop

    for (dwIndex = 0; dwIndex < cServers; dwIndex++)
    {
        LocalFree(rgszServers[dwIndex]);
    }
    LocalFree(rgszServers);

    return ERROR_SUCCESS;
}

DWORD WINAPI
EnumerateTlsServer(  
    IN TLSENUMERATECALLBACK pfCallBack, 
    IN HANDLE dwUserData,
    IN DWORD dwTimeOut,
    IN BOOL fRegOnly
    )
/*++


++*/
{

    DWORD dwErr;
    LPWSTR szDomain = NULL;
    BOOL fOffSite = FALSE;      // don't try to go off-site

    //
    // First check for a registry bypass of discovery
    //

    dwErr = EnumerateTlsServerInRegistry(
                                         pfCallBack,
                                         dwUserData,
                                         dwTimeOut,
                                         TEXT(TERMINAL_SERVICE_PARAM_DISCOVERY)
                                         );

    if ((!fRegOnly) || (g_fInDomain == -1))
    {
        //
        // Check even if set (for !fRegOnly), to get domain name
        //
        dwErr = TLSInDomain(&g_fInDomain, fRegOnly ? NULL : &szDomain);
        if (dwErr != NO_ERROR)
            return dwErr;
    }
    
    //
    // Reading registry failed, use full discovery
    //

    if(g_fInDomain)
    {
        dwErr = EnumerateTlsServerInDomain(
                                szDomain,
                                pfCallBack,
                                dwUserData,
                                dwTimeOut,
                                fRegOnly,
                                &fOffSite
                            );

        if ((dwErr == NO_ERROR) && !fRegOnly)
        {
            g_fOffSiteLicenseServer = fOffSite;
        }
    }
    else
    {
        dwErr = EnumerateTlsServerInWorkGroup(
                                              pfCallBack,
                                              dwUserData,
                                              dwTimeOut,
                                              fRegOnly
                                              );
    }

    if (NULL != szDomain)
    {
        NetApiBufferFree(szDomain);
    }

    if ((NULL != g_hImmediateDiscovery)
        && (dwErr != NO_ERROR) && fRegOnly)
    {
        SetEvent(g_hImmediateDiscovery);
    }

    if ((NULL != g_hDiscoverySoon)
        && (dwErr == NO_ERROR) && fOffSite && !fRegOnly)
    {
        SetEvent(g_hDiscoverySoon);
    }

    return dwErr;
}

TLS_HANDLE
ConnectAndCheckServer(LPWSTR szServer)
{
    TLS_HANDLE hBinding;
    DWORD dwVersion;
    RPC_STATUS rpcStatus;
    
    hBinding = TLSConnectToLsServer(szServer);

    if(hBinding == NULL)
    {
        goto done;
    }

    // Skip Windows 2000 License servers

        
    DWORD dwSupportFlags = 0;
    DWORD dwErrCode = 0;

        dwErrCode = TLSGetSupportFlags(
            hBinding,
            &dwSupportFlags
    );

	if ((dwErrCode == RPC_S_OK) && !(dwSupportFlags & SUPPORT_WHISTLER_CAL))
    {                    
        TLSDisconnect(&hBinding);
        goto done;
    }

    // If the call fails => Windows 2000 LS
    else if(dwErrCode != RPC_S_OK)
    {
        TLSDisconnect(&hBinding);
        goto done;
    }


    rpcStatus = TLSGetVersion( 
                              hBinding, 
                              &dwVersion 
                              );
    if( GET_LSSERVER_MAJOR_VERSION(dwVersion) < 6 )
    {
        TLSDisconnect(&hBinding);
        goto done;
    }


    if(rpcStatus != RPC_S_OK)
    {
        TLSDisconnect(&hBinding);
        goto done;
    }
            
    if( TLSIsBetaNTServer() == IS_LSSERVER_RTM(dwVersion) )
    {
        TLSDisconnect(&hBinding);
        goto done;
    }

done:
    return hBinding;
}
 
//+------------------------------------------------------------------------
// Function:   TLSConnectToAnyLsServer()
//
// Description:
//
//      Routine to bind to any license server
//
// Arguments:
//      dwTimeout - INFINITE for going off-site
//
// Return Value:
//
//      RPC binding handle or NULL if error, use GetLastError() to retrieve
//      detail error.
//-------------------------------------------------------------------------
TLS_HANDLE WINAPI
TLSConnectToAnyLsServer(
    DWORD dwTimeout
    )
/*++

++*/
{
    TLS_HANDLE hBinding=NULL;
    HRESULT hr = S_OK;
    LPWSTR *rgszServers = NULL;
    DWORD cServers = 0;
    DWORD i;
    DWORD dwErr;
    BOOL fInDomain;
    LPWSTR szDomain = NULL;
    LPWSTR szServerFound = NULL;
    BOOL fRegOnly = (dwTimeout != INFINITE);
    LPWSTR pwszServerNames = NULL;
    BOOL fFreeServerNames = TRUE;

    // TODO: add error codes/handling to all of this

    //
    // First check for a registry bypass of discovery
    //

    dwErr = GetServersFromRegistry(
                                   TEXT(TERMINAL_SERVICE_PARAM_DISCOVERY),
                                   &rgszServers,
                                   &cServers
                                   );

    if (ERROR_SUCCESS == dwErr)
    {
        RandomizeArray(rgszServers,cServers);

        for (i = 0; i < cServers; i++)
        {
            hBinding = ConnectAndCheckServer(rgszServers[i]);

            if (NULL != hBinding)
            {
                szServerFound = rgszServers[i];
                goto found_one;
            }
        }

        if(NULL != rgszServers)
        {
            for (i = 0; i < cServers; i++)
            {
                LocalFree(rgszServers[i]);
            }
            LocalFree(rgszServers);
            
            rgszServers = NULL;
        }
    }
                                         
    //
    // Next try Site (Enterprise) license servers
    //

    if (!fRegOnly)
    {
        hr = GetAllEnterpriseServers(&rgszServers,&cServers);

        if (SUCCEEDED(hr))
        {
            RandomizeArray(rgszServers,cServers);
        }
    }
    else
    {
        // rgszServers[i] is an index into pwszServerNames; don't free
        fFreeServerNames = FALSE;

        hr = GetLicenseServersFromReg(ENTERPRISE_SERVER_MULTI,
                                      &pwszServerNames,
                                      &cServers,
                                      &rgszServers);
    }

    if (SUCCEEDED(hr))
    {
        for (i = 0; i < cServers; i++)
        {
            hBinding = ConnectAndCheckServer(rgszServers[i]);

            if (NULL != hBinding)
            {
                szServerFound = rgszServers[i];
                goto found_one;
            }
        }

        if(NULL != rgszServers)
        {
            if (fFreeServerNames)
            {
                for (i = 0; i < cServers; i++)
                {
                    LocalFree(rgszServers[i]);
                }
                LocalFree(rgszServers);
            }

            rgszServers = NULL;
        }
    }


    // 
    // No Site LS found, try Domain/Workgroup servers
    //

    dwErr = TLSInDomain(&fInDomain, &szDomain);
    if (dwErr != NO_ERROR)
    {
        return NULL;
    }

    LS_ENUM_PARAM param;

    param.hBinding = &hBinding;
    param.dwTimeout = INFINITE;
    QueryPerformanceCounter(&(param.timeInitial));

    fFreeServerNames = TRUE;

    if (fInDomain)
    {
        BOOL fOffSite = TRUE;

        dwErr = EnumerateTlsServerInDomain(
                                szDomain,
                                BindAnyServer,
                                &param,
                                INFINITE,
                                fRegOnly,
                                &fOffSite
                            );

        if (dwErr == NO_ERROR)
        {
            g_fOffSiteLicenseServer = fOffSite;
        }
    }
    else
    {
        dwErr = EnumerateTlsServerInWorkGroup(
                                              BindAnyServer,
                                              &param,
                                              MAILSLOT_WAIT_FOREVER,
                                              fRegOnly
                                              );        
    }

    if (NULL != szDomain)
    {
        NetApiBufferFree(szDomain);
    }

    if (hBinding != NULL)
        goto found_one;

    if (NULL != pwszServerNames)
    {
        LocalFree(pwszServerNames);
    }

    if ((NULL != g_hImmediateDiscovery)
        && fRegOnly)
    {
        SetEvent(g_hImmediateDiscovery);
    }
    else if ((NULL != g_hDiscoverySoon)
        && !fRegOnly && g_fOffSiteLicenseServer)
    {
        SetEvent(g_hDiscoverySoon);
    }

    return NULL;

found_one:

    if (NULL != pwszServerNames)
    {
        LocalFree(pwszServerNames);
    }

    if(NULL != rgszServers)
    {
        if (fFreeServerNames)
        {
            for (i = 0; i < cServers; i++)
            {
                LocalFree(rgszServers[i]);
            }
        }
        LocalFree(rgszServers);
    }

    return hBinding;
}

BOOL
TLSRefreshLicenseServerCache(
    IN DWORD dwTimeOut
    )
/*++

Abstract:

    Refresh license server cache in registry.

Parameter:

    dwTimeOut : Reserverd, should pass in INIFINITE for now

Returns:

    TRUE/FALSE

--*/
{
    BOOL bFoundServer = FALSE;
    TLS_HANDLE hBinding = NULL;

    hBinding = TLSConnectToAnyLsServer(dwTimeOut);

    if (NULL != hBinding)
    {
        bFoundServer = TRUE;

        TLSDisconnect(&hBinding);
    }

    return bFoundServer;
}

LICENSE_STATUS
InstallCertificate(LPVOID lpParam)
{
    Sleep(INSTALL_CERT_DELAY);

    return LsCsp_InstallX509Certificate(NULL);
}
   

//-------------------------------------------------------------------------

TLS_HANDLE WINAPI
TLSConnectToLsServer( 
    LPTSTR pszLsServer 
    )
	
/*++

++*/
{
    TCHAR szMachineName[MAX_COMPUTERNAME_LENGTH + 1] ;
    PCONTEXT_HANDLE pContext=NULL;
    DWORD cbMachineName=MAX_COMPUTERNAME_LENGTH;
    HANDLE hThread = NULL;
    static BOOL fLSFound = FALSE;

    memset(szMachineName, 0, sizeof(szMachineName));
    GetComputerName(szMachineName, &cbMachineName);
    if(pszLsServer == NULL || _tcsicmp(szMachineName, pszLsServer) == 0)
    {
        pContext=ConnectLsServer(
                            szMachineName, 
                            _TEXT(RPC_PROTOSEQLPC), 
                            NULL, 
                            RPC_C_AUTHN_LEVEL_DEFAULT
                        );
        if(GetLastError() >= LSERVER_ERROR_BASE)
        {
            return NULL;
        }
        // try to connect with TCP protocol, if local procedure failed
    }

    if(pContext == NULL)
    {
        pContext=ConnectLsServer(
                            pszLsServer, 
                            _TEXT(RPC_PROTOSEQNP), 
                            _TEXT(LSNAMEPIPE), 
                            RPC_C_AUTHN_LEVEL_PKT_PRIVACY
                        );

    }

    if (!fLSFound && (NULL != pContext))
    {
        fLSFound = TRUE;

        // Now that someone's connected, we can install a license
        hThread = CreateThread(NULL,
                               0,
                               InstallCertificate,
                               NULL,
                               0,
                               NULL);

        if (hThread != NULL)
        {
            CloseHandle(hThread);
        }
        else
        {
            // Can't create the thread; try again later
            fLSFound = FALSE;
        }

    }

    return (TLS_HANDLE) pContext;
}

//-------------------------------------------------------------------------
void WINAPI
TLSDisconnectFromServer( 
    TLS_HANDLE pHandle 
    )
/*++

++*/
{
    if(pHandle != NULL)
    {
        TLSDisconnect( &pHandle );
    }
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSConnect( 
    handle_t binding,
    TLS_HANDLE *ppHandle 
    )
/*++

++*/
{
	RPC_STATUS rpc_status;

    rpc_status = TLSRpcConnect(binding, ppHandle);

	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcConnect returned %d\n", rpc_status);

    return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSDisconnect(
    TLS_HANDLE* pphHandle
    )
/*++

++*/
{
    RPC_STATUS rpc_status;

    rpc_status = TLSRpcDisconnect( pphHandle );

	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcDisconnect returned %d\n", rpc_status);

	if(rpc_status != RPC_S_OK)
    {
        RpcSmDestroyClientContext(pphHandle);
    }

    *pphHandle = NULL;

    return ERROR_SUCCESS;
}

//-------------------------------------------------------------------------
DWORD WINAPI
TLSGetVersion (
    IN TLS_HANDLE hHandle,
    OUT PDWORD pdwVersion
    )
/*++

++*/
{
	RPC_STATUS rpc_status;

    rpc_status = TLSRpcGetVersion( hHandle, pdwVersion );

	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcGetVersion returned %d and version 0x%x\n", rpc_status, *pdwVersion);

	return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSSendServerCertificate( 
     TLS_HANDLE hHandle,
     DWORD cbCert,
     PBYTE pbCert,
     PDWORD pdwErrCode
    )
/*++

++*/
{
	RPC_STATUS rpc_status;

    rpc_status = TLSRpcSendServerCertificate(
                                hHandle, 
                                cbCert, 
                                pbCert, 
                                pdwErrCode
                            );
	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcSendServerCertificate returned %d and errorcode %d\n", rpc_status, *pdwErrCode);

	return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerName( 
     TLS_HANDLE hHandle,
     LPTSTR szMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
    )
/*++

++*/
{
	RPC_STATUS rpc_status;

    rpc_status = TLSRpcGetServerName(
                            hHandle, 
                            szMachineName, 
                            pcbSize, 
                            pdwErrCode
                        );
	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcGetServerName returned %d and errorcode %d\n", rpc_status, *pdwErrCode);

	return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerNameEx( 
     TLS_HANDLE hHandle,
     LPTSTR szMachineName,
     PDWORD pcbSize,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    RPC_STATUS rpc_status;

    rpc_status = TLSRpcGetServerNameEx(
                            hHandle, 
                            szMachineName, 
                            pcbSize, 
                            pdwErrCode
                        );

	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcGetServerNameEx returned %d and errorcode %d\n", rpc_status, *pdwErrCode);

     if (rpc_status == RPC_S_PROCNUM_OUT_OF_RANGE)

    {
        rpc_status = TLSRpcGetServerName(
                            hHandle, 
                            szMachineName, 
                            pcbSize, 
                            pdwErrCode
                        );		
  	    if(g_bLog)
		   LogMsg(L"\tRPC call TLSRpcGetServerName returned %d and errorcode %d\n", rpc_status, *pdwErrCode);
    }

    return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerNameFixed( 
     TLS_HANDLE hHandle,
     LPTSTR *pszMachineName,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    RPC_STATUS rpc_status;

	rpc_status = TLSRpcGetServerNameFixed(
                            hHandle, 
                            pszMachineName, 
                            pdwErrCode
                        );
	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcGetServerNameFixed returned %d and errorcode %d\n", rpc_status, *pdwErrCode);

    return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerScope( 
     TLS_HANDLE hHandle,
     LPTSTR szScopeName,
     PDWORD pcbSize,
     PDWORD pdwErrCode)
/*++

++*/
{
    RPC_STATUS rpc_status;

	rpc_status = TLSRpcGetServerScope(
                            hHandle, 
                            szScopeName, 
                            pcbSize, 
                            pdwErrCode
                        );
	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcGetServerScope returned %d and errorcode %d\n", rpc_status, *pdwErrCode);

    return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerScopeFixed( 
     TLS_HANDLE hHandle,
     LPTSTR *pszScopeName,
     PDWORD pdwErrCode)
/*++

++*/
{
    RPC_STATUS rpc_status;

	rpc_status = TLSRpcGetServerScopeFixed(
                            hHandle, 
                            pszScopeName, 
                            pdwErrCode
                        );
	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcGetServerScopeFixed returned %d and errorcode %d\n", rpc_status, *pdwErrCode);

    return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssuePlatformChallenge( 
     TLS_HANDLE hHandle,
     DWORD dwClientInfo,
     PCHALLENGE_CONTEXT pChallengeContext,
     PDWORD pcbChallengeData,
     PBYTE* pChallengeData,
     PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcIssuePlatformChallenge(
                                hHandle, 
                                dwClientInfo, 
                                pChallengeContext, 
                                pcbChallengeData, 
                                pChallengeData, 
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssueNewLicense( 
     TLS_HANDLE hHandle,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

	return TLSRpcRequestNewLicense(
                        hHandle, 
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssueNewLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     DWORD dwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwStatus;
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

	dwStatus = TLSRpcRequestNewLicenseEx(
                        hHandle,
                        pSupportFlags,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        dwQuantity,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );

    if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        *pSupportFlags = 0;

	    dwStatus = TLSRpcRequestNewLicense(
                        hHandle,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );
    }

    return(dwStatus);
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSIssueNewLicenseExEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     CHALLENGE_CONTEXT ChallengeContext,
     LICENSEREQUEST  *pRequest,
     LPTSTR pMachineName,
     LPTSTR pUserName,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     BOOL bAcceptTemporaryLicense,
     BOOL bAcceptFewerLicenses,
     DWORD *pdwQuantity,
     PDWORD pcbLicense,
     PBYTE* ppbLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwStatus;
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

	dwStatus = TLSRpcRequestNewLicenseExEx(
                        hHandle,
                        pSupportFlags,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        bAcceptFewerLicenses,
                        pdwQuantity,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                    );

    if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
	    dwStatus = TLSRpcRequestNewLicenseEx(
                        hHandle,
                        pSupportFlags,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        *pdwQuantity,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                        );

        if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
        {
            *pSupportFlags = 0;

            dwStatus = TLSRpcRequestNewLicense(
                        hHandle,
                        ChallengeContext, 
                        &rpcRequest, 
                        pMachineName, 
                        pUserName, 
                        cbChallengeResponse,
                        pbChallengeResponse,
                        bAcceptTemporaryLicense,
                        pcbLicense,
                        ppbLicense,
                        pdwErrCode
                        );
        }
    }

    return(dwStatus);
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSUpgradeLicense( 
     TLS_HANDLE hHandle,
     LICENSEREQUEST *pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

	return TLSRpcUpgradeLicense(
                         hHandle,
                         &rpcRequest,
                         ChallengeContext,
                         cbChallengeResponse,
                         pbChallengeResponse,
                         cbOldLicense,
                         pbOldLicense,
                         pcbNewLicense,
                         ppbNewLicense,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSUpgradeLicenseEx( 
     TLS_HANDLE hHandle,
     PDWORD pSupportFlags,
     LICENSEREQUEST *pRequest,
     CHALLENGE_CONTEXT ChallengeContext,
     DWORD cbChallengeResponse,
     PBYTE pbChallengeResponse,
     DWORD cbOldLicense,
     PBYTE pbOldLicense,
     DWORD dwQuantity,
     PDWORD pcbNewLicense,
     PBYTE* ppbNewLicense,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwStatus;
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

	dwStatus = TLSRpcUpgradeLicenseEx(
                         hHandle,
                         pSupportFlags,
                         &rpcRequest,
                         ChallengeContext,
                         cbChallengeResponse,
                         pbChallengeResponse,
                         cbOldLicense,
                         pbOldLicense,
                         dwQuantity,
                         pcbNewLicense,
                         ppbNewLicense,
                         pdwErrCode
                    );

    if (dwStatus == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        *pSupportFlags = 0;

        dwStatus = TLSRpcUpgradeLicense(
                         hHandle,
                         &rpcRequest,
                         ChallengeContext,
                         cbChallengeResponse,
                         pbChallengeResponse,
                         cbOldLicense,
                         pbOldLicense,
                         pcbNewLicense,
                         ppbNewLicense,
                         pdwErrCode
                    );
    }

    return(dwStatus);
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSAllocateConcurrentLicense( 
     TLS_HANDLE hHandle,
     LPTSTR szHydraServer,
     LICENSEREQUEST  *pRequest,
     LONG  *dwQuantity,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcAllocateConcurrentLicense(
                                     hHandle,
                                     szHydraServer,
                                     &rpcRequest,
                                     dwQuantity,
                                     pdwErrCode
                                );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetLastError( 
     TLS_HANDLE hHandle,
     DWORD cbBufferSize,
     LPTSTR pszBuffer,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    RPC_STATUS rpc_status;

	rpc_status = TLSRpcGetLastError( 
                            hHandle,
                            &cbBufferSize,
                            pszBuffer,
                            pdwErrCode
                        );
	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcGetLastError returned %d\n", rpc_status);

    return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetLastErrorFixed( 
     TLS_HANDLE hHandle,
     LPTSTR *pszBuffer,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    RPC_STATUS rpc_status;

	rpc_status = TLSRpcGetLastErrorFixed( 
                            hHandle,
                            pszBuffer,
                            pdwErrCode
                        );
	if(g_bLog)
		LogMsg(L"\tRPC call TLSRpcGetLastErrorFixed returned %d\n", rpc_status);

    return rpc_status;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackEnumBegin( 
     TLS_HANDLE hHandle,
     DWORD dwSearchParm,
     BOOL bMatchAll,
     LPLSKeyPackSearchParm lpSearchParm,
     PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcKeyPackEnumBegin( 
                         hHandle,
                         dwSearchParm,
                         bMatchAll,
                         lpSearchParm,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackEnumNext( 
    TLS_HANDLE hHandle,
    LPLSKeyPack lpKeyPack,
    PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcKeyPackEnumNext( 
                    hHandle,
                    lpKeyPack,
                    pdwErrCode
                );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackEnumEnd( 
     TLS_HANDLE hHandle,
     PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcKeyPackEnumEnd(hHandle, pdwErrCode);
}


//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumBegin( 
    TLS_HANDLE hHandle,
    DWORD dwSearchParm,
    BOOL bMatchAll,
    LPLSLicenseSearchParm lpSearchParm,
    PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcLicenseEnumBegin( 
                            hHandle,
                            dwSearchParm,
                            bMatchAll,
                            lpSearchParm,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumNext( 
    TLS_HANDLE hHandle,
    LPLSLicense lpLicense,
    PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcLicenseEnumNext( 
                            hHandle,
                            lpLicense,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumNextEx( 
    TLS_HANDLE hHandle,
    LPLSLicenseEx lpLicenseEx,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    DWORD dwRet;

    if (NULL == lpLicenseEx)
    {
        return ERROR_INVALID_PARAMETER;
    }

	dwRet = TLSRpcLicenseEnumNextEx( 
                            hHandle,
                            lpLicenseEx,
                            pdwErrCode
                        );

    if (RPC_S_PROCNUM_OUT_OF_RANGE == dwRet)
    {
        LSLicense License;

		dwRet = TLSRpcLicenseEnumNext(
                            hHandle,
                            &License,
                            pdwErrCode
                            );

        if ((dwRet == RPC_S_OK)
            && (NULL != pdwErrCode)
            && (*pdwErrCode == ERROR_SUCCESS))
        {
            // older versions only support quantity == 1

            memcpy(lpLicenseEx,&License,sizeof(License));
            lpLicenseEx->dwQuantity = 1;
        }
    }

    return dwRet;
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSLicenseEnumEnd( 
    TLS_HANDLE hHandle,
    PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcLicenseEnumEnd(hHandle, pdwErrCode);
}


//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetAvailableLicenses( 
    TLS_HANDLE hHandle,
    DWORD dwSearchParm,
    LPLSKeyPack lplsKeyPack,
    LPDWORD lpdwAvail,
    PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcGetAvailableLicenses( 
                        hHandle,
                        dwSearchParm,
                        lplsKeyPack,
                        lpdwAvail,
                        pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetRevokeKeyPackList( 
    TLS_HANDLE hHandle,
    PDWORD pcbNumberOfRange,
    LPLSRange  *ppRevokeRange,
    PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcGetRevokeKeyPackList( 
                             hHandle,
                             pcbNumberOfRange,
                             ppRevokeRange,
                             pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetRevokeLicenseList( 
    TLS_HANDLE hHandle,
    PDWORD pcbNumberOfRange,
    LPLSRange  *ppRevokeRange,
    PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcGetRevokeLicenseList( 
                             hHandle,
                             pcbNumberOfRange,
                             ppRevokeRange,
                             pdwErrCode
                        );
}


//----------------------------------------------------------------------------
DWORD WINAPI
TLSMarkLicense(
    TLS_HANDLE hHandle,
    UCHAR ucFlags,
    DWORD cbLicense,
    PBYTE pLicense,
    PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcMarkLicense(
                            hHandle,
                            ucFlags,
                            cbLicense,
                            pLicense,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSCheckLicenseMark(
    TLS_HANDLE hHandle,
    DWORD cbLicense,
    PBYTE pLicense,
    PUCHAR pucFlags,
    PDWORD pdwErrCode
    )
/*++

++*/
{
	return TLSRpcCheckLicenseMark(
                            hHandle,
                            cbLicense,
                            pLicense,
                            pucFlags,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSGetSupportFlags(
    TLS_HANDLE hHandle,
    DWORD *pdwSupportFlags
    )
/*++

++*/
{
	return TLSRpcGetSupportFlags(
                            hHandle,
                            pdwSupportFlags
                        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\keyinfo.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  keyinfo.c                                  **
**                                             **
**  registry keys - TSREG                      **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <TCHAR.H>
#include "tsreg.h"

///////////////////////////////////////////////////////////////////////////////

KEY_INFO g_KeyInfo[KEYCOUNT] = {

    { TEXT("Shadow Bitmap Enabled"), 0x0, 0x0 },            //  0
    { TEXT("Dedicated Terminal"), 0x1, 0x1 },               //  1
    { TEXT("BitmapCacheSize"), 0x5dc, 0x5dc },              //  2

    //
    // g_KeyInfo - 3 through 12
    //
    { TEXT("GlyphCacheCell1Size"), 0x4, 0x4 },              //  3
    { TEXT("GlyphCacheCell2Size"), 0x4, 0x4 },              //  4
    { TEXT("GlyphCacheCell3Size"), 0x8, 0x8 },              //  5
    { TEXT("GlyphCacheCell4Size"), 0x8, 0x8 },              //  6
    { TEXT("GlyphCacheCell5Size"), 0x10, 0x10 },            //  7
    { TEXT("GlyphCacheCell6Size"), 0x20, 0x20 },            //  8
    { TEXT("GlyphCacheCell7Size"), 0x40, 0x40 },            //  9
    { TEXT("GlyphCacheCell8Size"), 0x80, 0x80 },            // 10
    { TEXT("GlyphCacheCell9Size"), 0x100, 0x100 },          // 11
    { TEXT("GlyphCacheCell10Size"), 0x200, 0x200 },         // 12
    //
    // g_KeyInfo - 13 through 17
    //
    { TEXT("BitmapCache1Prop"), 0xA, 0xA },                 // 13
    { TEXT("BitmapCache2Prop"), 0x14, 0x14 },               // 14
    { TEXT("BitmapCache3Prop"), 0x46, 0x46 },               // 15
    { TEXT("BitmapCache4Prop"), 0x0, 0x0 },                 // 16
    { TEXT("BitmapCache5Prop"), 0x0, 0x0 },                 // 17
    //
    // g_KeyInfo - 18 through 20
    //
    { TEXT("TextFragmentCellSize"), 0x100, 0x100 },         // 18
    { TEXT("GlyphSupportLevel"), 0x3, 0x3 },                // 19
    { TEXT("Order Draw Threshold"), 0x19, 0x19 },           // 20

    // begin new registry keys 21 - 31 (32 total keys)
    //////////////////////////
    { TEXT("BitmapCacheNumCellCaches"), 0x3, 0x3 },         // 21

    { TEXT("BitmapCache1Persistence"), 0x0, 0x0 },          // 22
    { TEXT("BitmapCache2Persistence"), 0x0, 0x0 },          // 23
    { TEXT("BitmapCache3Persistence"), 0x0, 0x0 },          // 24
    { TEXT("BitmapCache4Persistence"), 0x0, 0x0 },          // 25
    { TEXT("BitmapCache5Persistence"), 0x0, 0x0 }           // 26


};


// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\tslsview.cpp ===
// tslsview.cpp : Defines the entry point for the application.
//

#include "stdafx.h"
//#include "resource.h"
extern "C" {
   BOOL OpenLog(VOID);
   VOID LogMsg(PWCHAR msgFormat, ...);
   BOOL LogDiagnosisFile( LPTSTR );
   VOID CloseLog(VOID);
}


//=---------globals------------
static HINSTANCE g_hinst;
static BOOL g_fInitialized;
ServerEnumData g_sed;
PLIST g_pHead;
static HANDLE g_hEvent;
static BOOL g_bAutomaticLog;
BOOL g_bDiagnosticLog = FALSE;
static DWORD g_dwInterval = 1000 * 60 * 5;
static BOOL g_bLog = 1;

TCHAR szLsViewKey[] = TEXT( "Software\\Microsoft\\Windows NT\\CurrentVersion\\LsView" );
//-----------------------------

//-------------function prototypes ----------------
INT_PTR CALLBACK Dlg_Proc( HWND hwnd , UINT msg , WPARAM wp, LPARAM lp );
BOOL OnInitApp( HWND );
void OnTimedEvent( HWND hDlg );
DWORD DiscoverServers( LPVOID ptr );
BOOL ServerEnumCallBack( TLS_HANDLE hHandle,
                         LPCTSTR pszServerName,
                         HANDLE dwUserData );

void OnReSize( HWND hwnd ,
               WPARAM wp ,
               LPARAM lp );
BOOL DeleteList( PLIST );
BOOL AddItem( LPTSTR , LPTSTR , LPTSTR  );
void CreateLogFile( HWND );
BOOL Tray_Init( HWND hwnd , BOOL );
BOOL Tray_ToGreen( HWND hwnd );
BOOL Tray_ToYellow( HWND hwnd , LPTSTR szMsg );
BOOL Tray_ToRed( HWND hwnd );
BOOL Tray_Remove( HWND hwnd );
BOOL Tray_ToXXX( HWND hwnd , LPTSTR szTip , UINT resid );
BOOL Tray_Notify( HWND hwnd , WPARAM wp , LPARAM lp );
UINT_PTR CALLBACK OFNHookProc( HWND hdlg , UINT uiMsg, WPARAM wParam, LPARAM lParam );
BOOL RetrieveDataObject( PDATAOBJECT pObj );
BOOL StoreDataObject( PDATAOBJECT pObj );
BOOL LogFile( LPTSTR szFileName );
//-------------------------------------------------

//=---------constants------------
const UINT kTimerId = 23456;
const UINT kDefaultElapseTime = 1000 * 60 * 5;
const UINT kMaxMinutes = 71582;
const UINT kBubbleTimeout = 10 * 1000;
#define TN_MESSAGE ( WM_USER + 60 )
//-----------------------------
DWORD
GetPageSize( VOID ) {

    static DWORD dwPageSize = 0;

    if ( !dwPageSize ) {

      SYSTEM_INFO sysInfo = { 0 };
        
      GetSystemInfo( &sysInfo ); // cannot fail.

      dwPageSize = sysInfo.dwPageSize;

    }

    return dwPageSize;

}

/*++**************************************************************
  NAME:      MyVirtualAlloc

  as Malloc, but automatically protects the last page of the 
  allocation.  This simulates pageheap behavior without requiring
  it.

  MODIFIES:  ppvData -- receives memory

  TAKES:     dwSize  -- minimum amount of data to get

  RETURNS:   TRUE when the function succeeds.
             FALSE otherwise.
  LASTERROR: not set
  Free with MyVirtualFree

  
 **************************************************************--*/

BOOL
MyVirtualAlloc( IN  DWORD  dwSize,
            OUT PVOID *ppvData )
 {

    PBYTE pbData;
    DWORD dwTotalSize;
    PVOID pvLastPage;

    // ensure that we allocate one extra page

    dwTotalSize = dwSize / GetPageSize();
    if( dwSize % GetPageSize() ) {
        dwTotalSize ++;
    }

    // this is the guard page
    dwTotalSize++;
    dwTotalSize *= GetPageSize();

    // do the alloc

    pbData = (PBYTE) VirtualAlloc( NULL, // don't care where
                                   dwTotalSize,
                                   MEM_COMMIT |
                                   MEM_TOP_DOWN,
                                   PAGE_READWRITE );
    
    if ( pbData ) {

      pbData += dwTotalSize;

      // find the LAST page.

      pbData -= GetPageSize();

      pvLastPage = pbData;

      // now, carve out a chunk for the caller:

      pbData -= dwSize;

      // last, protect the last page:

      if ( VirtualProtect( pvLastPage,
                           1, // protect the page containing the last byte
                           PAGE_NOACCESS,
                           &dwSize ) ) {

        *ppvData = pbData;
        return TRUE;

      } 

      VirtualFree( pbData, 0, MEM_RELEASE );

    }

    return FALSE;

}


VOID
MyVirtualFree( IN PVOID pvData ) 
{

    VirtualFree( pvData, 0, MEM_RELEASE ); 

}


//-------------------------------------------------------------------------
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR    lpCmdLine,
                     int       nCmdShow)
{    
    
    INITCOMMONCONTROLSEX icc = { sizeof( INITCOMMONCONTROLSEX ) ,
                                 ICC_LISTVIEW_CLASSES };

    HANDLE hMutex = CreateMutex( NULL , FALSE , TEXT("TSLSVIEW2" ) );

    if( GetLastError() == ERROR_ALREADY_EXISTS )
    {
        TCHAR szTitle[ 60 ];

        DBGMSG( TEXT( "TSLSVIEW: App instance already running\n" ) , 0 );

        LoadString( hInstance , 
                    IDS_TITLE ,
                    szTitle ,
                    SIZEOF( szTitle ) );

        HWND hWnd = FindWindow( NULL , szTitle );

        if( hWnd != NULL )
        {
            SetForegroundWindow( hWnd );
        }

        return 0;
    }

    if( !InitCommonControlsEx( &icc ) )
    {
        DBGMSG( TEXT("InitCommonControlsEx failed with 0x%x\n") , GetLastError( ) );

        return 0;
    }

    g_hinst = hInstance;

    g_fInitialized = FALSE;

    g_hEvent = CreateEvent( NULL , FALSE , TRUE , NULL );

	if(OpenLog() == FALSE)
	{
		ODS(TEXT("Failed to open temporary file for discovery diagnostics"));

		return 0;
	}

    g_pHead = ( PLIST )new LIST[1];

    if( g_pHead == NULL )
    {
        ODS( TEXT( "LSVIEW out of memory\n" ) );

        return 0;
    }

    g_pHead->pszMachineName = NULL;
    g_pHead->pszTimeFormat = NULL;
    g_pHead->pszType = NULL;
    g_pHead->pNext = NULL;

	DialogBox( hInstance ,
               MAKEINTRESOURCE( IDD_LSVIEW ),
               NULL,
               Dlg_Proc);

    
    CloseHandle( hMutex );

    CloseHandle( g_hEvent );

    DeleteList( g_pHead );

	CloseLog();

    return 0;
}

//-------------------------------------------------------------------------
INT_PTR CALLBACK Dlg_Proc( HWND hwnd , UINT msg , WPARAM wp, LPARAM lp )
{
    TCHAR szTitle[ 60 ];

    switch( msg )
    {
    case WM_COMMAND:
        switch( LOWORD( wp ) )
        {
        case ID_FILE_EXIT:
            EndDialog( hwnd , 0 );
            break;

        case ID_FILE_CREATELOGFILE:

            if( WaitForSingleObject( g_hEvent , 0 ) == WAIT_TIMEOUT )
            {
                TCHAR szBuffer[ 255 ];

                LoadString( g_hinst ,
                            IDS_ERROR_QS ,
                            szBuffer ,
                            SIZEOF( szBuffer )
                           );

                LoadString( g_hinst ,
                            IDS_TITLE ,
                            szTitle ,
                            SIZEOF( szTitle )
                          );

                MessageBox( hwnd , szBuffer, szTitle , MB_OK | MB_ICONINFORMATION );
            }
            else
            {
                SetEvent( g_hEvent );

                CreateLogFile( hwnd );
            }
            break;

        case ID_HELP_ABOUT:

            LoadString( g_hinst ,
                        IDS_TITLE ,
                        szTitle ,
                        SIZEOF( szTitle )
                      );

            ShellAbout( hwnd ,
                        szTitle ,
                        NULL ,
                        LoadIcon( g_hinst , MAKEINTRESOURCE( IDI_TSLSVIEW ) )
                        );
            break;

        case IDM_MINIMIZE:
            ShowWindow( hwnd , SW_MINIMIZE );
            break;

        case IDM_RESTORE:
            ShowWindow( hwnd , SW_RESTORE );
            break;

        case IDM_EXIT:
            DestroyWindow( hwnd );
            break;
        }      

        break;

    case WM_CLOSE:
    case WM_DESTROY:

        Tray_ToRed( hwnd );

        KillTimer( hwnd , kTimerId );

        Tray_Remove( hwnd );

        EndDialog( hwnd , 0 );

        break;

    case WM_INITDIALOG:
        OnInitApp( hwnd );
        break;

    case WM_TIMER:
        if( wp == ( WPARAM )kTimerId )
        {
            OnTimedEvent( hwnd );
        }

        break;

    case WM_SIZE:
        
        OnReSize( hwnd , wp , lp );

        break;

    case TN_MESSAGE:

        Tray_Notify( hwnd , wp , lp );

        break;

    }
    return FALSE;
}
//-------------------------------------------------------------------------
BOOL InitListView( HWND hwnd )
{
    int rgIds[] = { IDS_STR_COL1 ,
                  IDS_STR_COL2 ,
                  IDS_STR_COL3 ,
                   -1 };

    LV_COLUMN lvc;
    TCHAR tchBuffer[ 60 ];

    HWND hListView = GetDlgItem( hwnd , IDC_LSVIEW_LIST ) ;

    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM;
    lvc.fmt = LVCFMT_LEFT;
    
    for( int idx=0; rgIds[idx] != -1; ++idx )
    {
        LoadString( g_hinst ,
                    ( UINT )rgIds[idx],
                    tchBuffer,
                    SIZEOF( tchBuffer ) );

        if( idx == 1 )
        {
            lvc.cx = 225;
        }
        else
        {
            lvc.cx = 75;
        }

        lvc.pszText = tchBuffer;
        lvc.iSubItem = idx;

        ListView_InsertColumn( hListView ,
                               idx ,
                               &lvc );

    }

    DWORD dwStyle = ( DWORD )SendMessage( hListView ,
                                          LVM_GETEXTENDEDLISTVIEWSTYLE ,
                                          0 ,
                                          0 );

    dwStyle |= ( LVS_EX_FULLROWSELECT | LVS_EX_GRIDLINES ) ;

    SendMessage( hListView , LVM_SETEXTENDEDLISTVIEWSTYLE , 0 , dwStyle );

    return TRUE;
}

//-------------------------------------------------------------------------
BOOL OnInitApp( HWND hwnd )
{
    DATAOBJECT dobj;

    // set up listview extended mode

    InitListView( hwnd );

    LONG_PTR lptrIcon;

    lptrIcon = ( LONG_PTR )LoadImage( g_hinst ,
                                      MAKEINTRESOURCE( IDI_TSLSVIEW ),
                                      IMAGE_ICON,
                                      16,
                                      16,
                                      0
                                      );


    SetClassLongPtr( hwnd , GCLP_HICONSM , lptrIcon );

    lptrIcon = ( LONG_PTR )LoadImage( g_hinst ,
                                      MAKEINTRESOURCE( IDI_TSLSVIEW ),
                                      IMAGE_ICON,
                                      0,
                                      0,
                                      0
                                      );

    SetClassLongPtr( hwnd , GCLP_HICON , lptrIcon );

    ZeroMemory( &dobj , sizeof( dobj ) );

    if( RetrieveDataObject( &dobj ) )
    {
        g_bAutomaticLog = dobj.bIsChecked;

        g_bDiagnosticLog = dobj.bIsDiagnosisChecked;

        g_dwInterval = dobj.dwTimeInterval * 1000 * 60;
    }

    if( dobj.dwTimeInterval == 0 )
    {
        g_dwInterval = ( DWORD )kDefaultElapseTime;
    }
    
    // setup initial trayicon

    Tray_Init( hwnd , dobj.bNotifyOnce );

    if( !dobj.bNotifyOnce )
    {
        dobj.bNotifyOnce = TRUE;

        StoreDataObject( &dobj );
    }

    // set cursor to hourglass
       
    OnTimedEvent( hwnd );

    SetTimer( hwnd ,
              kTimerId,
              g_dwInterval,
              NULL
            );             



    return TRUE;
}

//-------------------------------------------------------------------------
void OnTimedEvent( HWND hDlg )
{
    ODS( L"LSVIEW: OnTimedEvent fired " );

    g_sed.dwNumServer = 0;
    g_sed.dwDone = 0;
    g_sed.hList = GetDlgItem( hDlg , IDC_LSVIEW_LIST );
    
    // remove all listview items
    DWORD dwValue;    

    dwValue = WaitForSingleObject( g_hEvent , 0 );

    if( dwValue == WAIT_TIMEOUT )
    {
        ODS( TEXT("still looking for servers\n" ) );
        
        return;
    }

    SetEvent( g_hEvent );

    ODS( TEXT("launching thread\n" ) );

    HANDLE hThread = CreateThread( NULL ,
                                   0 ,
                                   ( LPTHREAD_START_ROUTINE )DiscoverServers,
                                   ( LPVOID )&g_sed ,
                                   0,
                                   &dwValue
                                   );

    if( hThread == NULL )
    {
        DBGMSG( TEXT( "Failed to create DiscoverServer thread last error 0x%x\n" ) , GetLastError( ) );

        Tray_ToRed( hDlg );
    }

    CloseHandle( hThread );
}

//-------------------------------------------------------------------------
DWORD DiscoverServers( LPVOID ptr )
{
    WaitForSingleObject( g_hEvent , INFINITE );

    ODS( L"LSVIEW -- entering DiscoverServers\n" );

        

    if (!g_fInitialized)
    {
        TLSInit();
        g_fInitialized = TRUE;
    }

    LPWSTR *ppszEnterpriseServer = NULL;
    DWORD dwCount;
    DWORD index;
    
    // we could be writing out to a file we should wait




    if( g_pHead != NULL )
    {
        DeleteList( g_pHead->pNext );

        g_pHead->pNext = NULL;
    }
    //
    // Look for all license servers in domain
    //

    ServerEnumData *pEnumData = ( ServerEnumData * )ptr;

    TCHAR szBuffer[ 60 ];

    LoadString( g_hinst ,
                IDS_YELLOW ,
                szBuffer ,
                SIZEOF( szBuffer )
                );

    Tray_ToYellow( GetParent( pEnumData->hList ) , szBuffer );


    HRESULT hResult = EnumerateTlsServer( 
                               ServerEnumCallBack,
                               ptr,
                               3000,
                               FALSE
                               );

    hResult = GetAllEnterpriseServers( 
                               &ppszEnterpriseServer,
                               &dwCount
                               );

    if( hResult == ERROR_SUCCESS && dwCount != 0 && ppszEnterpriseServer != NULL )
    {

        TLS_HANDLE TlsHandle = NULL;


        //
        // Inform dialog
        //
        for(index = 0; index < dwCount && pEnumData->dwDone == 0; index++)
        {

            if( ppszEnterpriseServer[index] == NULL )
            {
                continue;
            }

            if(ServerEnumCallBack( 
                                NULL,
                                (LPTSTR)ppszEnterpriseServer[index],
                                pEnumData ) == TRUE 
                                )
            {
                continue;
            }

            TlsHandle = TLSConnectToLsServer(
                                (LPTSTR)ppszEnterpriseServer[index]
                                );

            if(TlsHandle == NULL )
            {
                continue;
                if(g_bLog)
                   LogMsg(L"Can't connect to %s. Maybe it has no License Service running on it.\n", (LPTSTR)ppszEnterpriseServer[index]);
            }

			if(g_bLog)
               LogMsg(L"!!!Connected to License Service on %s\n",(LPTSTR)ppszEnterpriseServer[index]);

            ServerEnumCallBack( TlsHandle,
                                (LPTSTR)ppszEnterpriseServer[index],
                                pEnumData
                                );


            TLSDisconnectFromServer(TlsHandle);
        }
    

        if( ppszEnterpriseServer != NULL )
        {
            for( index = 0; index < dwCount; index ++)
            {
                if( ppszEnterpriseServer[ index ] != NULL )
                {
                    LocalFree( ppszEnterpriseServer[ index ] );
                }
            }

            LocalFree( ppszEnterpriseServer );
        }

    }


    ListView_DeleteAllItems( pEnumData->hList );  
    
    PLIST pTemp;

    if( g_pHead != NULL )
    {
        pTemp = g_pHead->pNext;

        while( pTemp != NULL )
        {      
            int nItem = ListView_GetItemCount( pEnumData->hList );

            LVITEM lvi;

            ZeroMemory( &lvi , sizeof( LVITEM ) );

            lvi.mask = LVIF_TEXT;
            lvi.pszText = pTemp->pszMachineName;
            lvi.cchTextMax = lstrlen( pTemp->pszMachineName );
            lvi.iItem = nItem;
            lvi.iSubItem = 0;

            ListView_InsertItem( pEnumData->hList ,
                                 &lvi
                               );

            // Set item for second column
            lvi.pszText = pTemp->pszTimeFormat;
            lvi.iSubItem = 1;
            lvi.cchTextMax = sizeof( pTemp->pszTimeFormat );

            ListView_SetItem( pEnumData->hList ,
                                 &lvi
                               );       

            // Set item for third column
            lvi.pszText = pTemp->pszType;
            lvi.iSubItem = 2;
            lvi.cchTextMax = sizeof( pTemp->pszType );

            ListView_SetItem( pEnumData->hList ,
                                 &lvi
                               );       

            pTemp = pTemp->pNext;
        }
    }

    if( g_bAutomaticLog )
    {
        DATAOBJECT db;

        ZeroMemory( &db , sizeof( DATAOBJECT ) );

        if( RetrieveDataObject( &db ) )
        {
			if( g_bDiagnosticLog  )
			   LogDiagnosisFile( db.wchFileName );               
			else
			   LogFile( db.wchFileName );
        }
    }

    ODS( L"LSVIEW : DiscoverServers completing\n" );

    // motion for green

    Tray_ToGreen( GetParent( pEnumData->hList ) );

    SetEvent( g_hEvent );

    ExitThread( hResult );

    return ( DWORD )hResult;
}

typedef DWORD (WINAPI* PTLSGETSERVERNAMEFIXED) (
                                TLS_HANDLE hHandle,
                                LPTSTR *pszMachineName,
                                PDWORD pdwErrCode
                                );

typedef DWORD (WINAPI* PTLSGETSERVERNAMEEX) (
                                TLS_HANDLE hHandle,
                                LPTSTR pszMachineName,
								PDWORD pdwSize,
                                PDWORD pdwErrCode
                                );
RPC_STATUS
TryGetServerName(PCONTEXT_HANDLE hBinding,
                 LPTSTR *pszServer)
{
    RPC_STATUS status;
    DWORD      dwErrCode;
    HINSTANCE  hModule = LoadLibrary(L"mstlsapi.dll");

    if (hModule)
    {
        PTLSGETSERVERNAMEFIXED pfnGetServerNameFixed = (PTLSGETSERVERNAMEFIXED) GetProcAddress(hModule,"TLSGetServerNameFixed");

        if (pfnGetServerNameFixed)
        {
            status = pfnGetServerNameFixed(hBinding,pszServer,&dwErrCode);
            if(status == RPC_S_OK && dwErrCode == ERROR_SUCCESS && pszServer != NULL)
            {
                FreeLibrary(hModule);
                return status;
            }
        }        
    
        LPTSTR     lpszMachineName = NULL;
        try
        {			
            if ( !MyVirtualAlloc( ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof( TCHAR ),
                              (PVOID*) &lpszMachineName ) )
            {
                return RPC_S_OUT_OF_MEMORY;
            }

            DWORD      uSize = MAX_COMPUTERNAME_LENGTH+1 ;

            memset(lpszMachineName, 0, ( MAX_COMPUTERNAME_LENGTH+1 ) * sizeof( TCHAR ));			

			PTLSGETSERVERNAMEEX pfnGetServerNameEx = (PTLSGETSERVERNAMEEX) GetProcAddress(hModule,"TLSGetServerNameEx");
			if (pfnGetServerNameEx != NULL)
			{
				status = pfnGetServerNameEx(hBinding,lpszMachineName,&uSize, &dwErrCode);
				
				if(status == RPC_S_OK && dwErrCode == ERROR_SUCCESS)
				{
					*pszServer = (LPTSTR) MIDL_user_allocate((lstrlen(lpszMachineName)+1)*sizeof(TCHAR));

					if (NULL != *pszServer)
					{
						lstrcpy(*pszServer,lpszMachineName);
					}
				}
			}
        }
        catch (...)
        {
            status = ERROR_NOACCESS;
        }
        if(lpszMachineName)
            MyVirtualFree(lpszMachineName);
		if(hModule)
			FreeLibrary(hModule);
    }

    return status;
}


//-------------------------------------------------------------------------
BOOL ServerEnumCallBack( TLS_HANDLE hHandle,
                         LPCTSTR pszServerName,
                         HANDLE dwUserData )
                        
{
    int i;
    
    ServerEnumData* pEnumData = (ServerEnumData *)dwUserData;

    BOOL bCancel;

    if( pEnumData == NULL )
    {
        return FALSE;
    }

    bCancel = ( InterlockedExchange( &(pEnumData->dwDone) ,
                                     pEnumData->dwDone) == 1);

    if( bCancel == TRUE )
    {
        return TRUE;
    }


    if( hHandle != NULL )
    {
        DWORD dwStatus;
        DWORD dwErrCode;
        DWORD dwVersion;


        LPTSTR szServer = NULL;
        TCHAR szMcType[ MAX_COMPUTERNAME_LENGTH + 1 ];
        TCHAR szTimeFormat[ 256 ];
        DWORD dwBufSize = SIZEOF( szServer);
       
        dwStatus = TryGetServerName( hHandle,
                                     &szServer
                                     );

        if( dwStatus != ERROR_SUCCESS || szServer == NULL )
        {
            return FALSE;
        }

        TLSGetVersion(hHandle, &dwVersion);

        if( dwVersion & TLS_VERSION_ENTERPRISE_BIT )
        {
            LoadString( g_hinst , 
                        IDS_TYPE_ENT,
                        szMcType,
                        SIZEOF( szMcType ) );
            
        }
        else
        {
            LoadString( g_hinst , 
                        IDS_TYPE_DOMAIN,
                        szMcType,
                        SIZEOF( szMcType ) );

        }

        SYSTEMTIME st;

        TCHAR szDate[ 80 ];
        TCHAR szTime[ 80 ];

        GetLocalTime( &st );

        GetDateFormat( LOCALE_USER_DEFAULT ,
                       DATE_LONGDATE ,
                       &st,
                       NULL,
                       szDate,
                       SIZEOF( szDate ) );        

        GetTimeFormat( LOCALE_USER_DEFAULT,                       
                       TIME_NOSECONDS,
                       &st,
                       NULL,
                       szTime,
                       SIZEOF( szTime ) );

        wsprintf( szTimeFormat , TEXT( "%s %s") , szDate , szTime );

        AddItem( szServer , szTimeFormat , szMcType );

        pEnumData->dwNumServer++;

        MIDL_user_free(szServer);
    }


    //
    // Continue enumeration
    //
    return InterlockedExchange(&(pEnumData->dwDone), pEnumData->dwDone) == 1;
}

//-------------------------------------------------------------------------
void OnReSize( HWND hwnd , WPARAM wp , LPARAM lp )
{
    HWND hList = GetDlgItem( hwnd , IDC_LSVIEW_LIST );
    
    if( hList != NULL )
    {
        MoveWindow( hList , 
                    0 , 
                    0 ,
                    LOWORD( lp ),
                    HIWORD( lp ) ,
                    TRUE
                  );

    

        if( wp == SIZE_RESTORED  || wp == SIZE_MAXIMIZED )
        {
            ListView_RedrawItems( hList , 
                                  0 ,
                                  ListView_GetItemCount( hList )
                                );
        }
    }

}


//------------------------------------------------------------------------
// link list methods
//------------------------------------------------------------------------
BOOL AddItem( LPTSTR szMachineName , LPTSTR szTimeFormat , LPTSTR szType )
{
    ODS( TEXT("LSVIEW : Adding an item\n" ) );

    if( g_pHead == NULL )
    {
        return FALSE;
    }

    PLIST pNewItem = ( PLIST )new LIST[1];

    if( pNewItem == NULL )
    {
        ODS( TEXT( "LSVIEW AddItem out of memory\n" ) );

        return FALSE;
    }

    pNewItem->pNext = NULL;

    if( szMachineName != NULL )
    {
        pNewItem->pszMachineName = ( LPTSTR )new TCHAR[ lstrlen( szMachineName ) + 1 ];

        if( pNewItem->pszMachineName != NULL )
        {
            lstrcpy( pNewItem->pszMachineName , szMachineName );
        }
    }
    else
    {
        pNewItem->pszMachineName = NULL;
    }

    if( szTimeFormat != NULL )
    {
        pNewItem->pszTimeFormat = ( LPTSTR )new TCHAR[ lstrlen( szTimeFormat ) + 1 ];

        if( pNewItem->pszTimeFormat != NULL )
        {
            lstrcpy( pNewItem->pszTimeFormat , szTimeFormat );
        }
    }
    else
    {
        pNewItem->pszTimeFormat = NULL;
    }

    if( szType != NULL )
    {
        pNewItem->pszType = ( LPTSTR )new TCHAR[ lstrlen( szType ) + 1 ];

        if( pNewItem->pszType != NULL )
        {
            lstrcpy( pNewItem->pszType , szType );
        }
    }
    else
    {
        pNewItem->pszType = NULL;
    }

    //=--- find the next available entry

    PLIST pTemp = g_pHead;

    while( pTemp->pNext != NULL )
    {
        pTemp = pTemp->pNext;
    }

    pTemp->pNext = pNewItem;


    return TRUE;
}

//------------------------------------------------------------------------
BOOL DeleteList( PLIST pStart )
{
    PLIST pPleaseKillMe;

    if( pStart == NULL )
    {
        return TRUE;
    }   

    while( pStart != NULL )
    {
        pPleaseKillMe = pStart->pNext;

        if( pStart->pszMachineName != NULL )
        {
            delete[] pStart->pszMachineName;

        }
        if( pStart->pszTimeFormat != NULL )
        {
            delete[] pStart->pszTimeFormat;
        }          
        if( pStart->pszType != NULL )
        {
            delete[] pStart->pszType;
        }

        delete pStart;

        pStart = pPleaseKillMe;
    }


    return TRUE;

}

//------------------------------------------------------------------------
void CreateLogFile( HWND hwnd )
{
    // start the save as dialog
    OPENFILENAME ofn;
    TCHAR szBuffer[ 60 ];
    TCHAR szFilter[ 60 ] = { 0 };
    TCHAR szFileName[ MAX_PATH ];
    TCHAR szExt[ 10 ];
    DATAOBJECT dobj;

    ZeroMemory( &ofn , sizeof( OPENFILENAME ) );

    ZeroMemory( &dobj , sizeof( DATAOBJECT ) );

    RetrieveDataObject( &dobj );

    if( dobj.bIsChecked )
    {
        lstrcpy( szFileName , dobj.wchFileName );
    }
    else
    {
        szFileName[0] = 0;
    }


    LoadString( g_hinst ,
                IDS_FILTER ,
                szFilter ,
                SIZEOF( szFilter )
                );

    LoadString( g_hinst ,
                IDS_EXTENSION ,
                szExt ,
                SIZEOF( szExt )
                );


    ofn.lStructSize = sizeof( OPENFILENAME );
    ofn.hwndOwner = hwnd;
    ofn.lpstrFilter = szFilter;
    ofn.lpstrFile = szFileName;
    ofn.nMaxFile  = MAX_PATH;
    ofn.Flags = OFN_HIDEREADONLY | OFN_EXPLORER | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK;
    ofn.lpTemplateName = MAKEINTRESOURCE( IDD_CDEXT );
    ofn.lpstrDefExt = szExt;
    ofn.hInstance = g_hinst;
    ofn.FlagsEx = OFN_EX_NOPLACESBAR;
    ofn.lpfnHook = OFNHookProc;

    // ok let's make them wait

    WaitForSingleObject( g_hEvent , INFINITE );

    // motion for yellow

    LoadString( g_hinst ,
                IDS_TRAYFILE ,
                szBuffer ,
                SIZEOF( szBuffer )
                );

    Tray_ToYellow( hwnd , szBuffer );

    if( GetSaveFileName( &ofn ) )
    {
        if( g_bDiagnosticLog )
            LogDiagnosisFile( szFileName );
		else
			LogFile( szFileName );
    }
    else
    {
        DBGMSG( TEXT( "Last error was 0x%x\n" ) , CommDlgExtendedError( ) );
    }

    // motion for green

    Tray_ToGreen( hwnd );

    SetEvent( g_hEvent );

}

//-------------------------------------------------------------------------
UINT_PTR CALLBACK OFNHookProc( 
  HWND hdlg,      // handle to child dialog box window
  UINT uiMsg,     // message identifier
  WPARAM wParam,  // message parameter
  LPARAM lParam   // message parameter
  )
{
    DATAOBJECT dobj;
    TCHAR szDigits[ 16 ];

    switch( uiMsg )
    {
    
    case WM_INITDIALOG:
        {
            ODS( TEXT("OFNHookProc WM_INITDIALOG\n" ) );            

            ZeroMemory( &dobj , sizeof( DATAOBJECT ) );

            SendMessage( GetDlgItem( hdlg , IDC_SPIN1 ) , UDM_SETRANGE32 , ( WPARAM ) 1 , ( LPARAM )71582 );
    
            SendMessage( GetDlgItem( hdlg , IDC_SPIN1 ) , UDM_SETPOS32 , 1 , 0 );

            RetrieveDataObject( &dobj );
            
            CheckDlgButton( hdlg ,
                            IDC_CHECK1 ,
                            dobj.bIsChecked ? BST_CHECKED : BST_UNCHECKED
                          );

            CheckDlgButton( hdlg ,
                            IDC_CHECK2 ,
                            dobj.bIsDiagnosisChecked ? BST_CHECKED : BST_UNCHECKED
                          );

            dobj.dwTimeInterval = ( g_dwInterval / 60 ) / 1000 ;

			StoreDataObject( &dobj );

            if( dobj.dwTimeInterval > 0 )
            {  
                wsprintf( szDigits , TEXT("%d" ), dobj.dwTimeInterval );
                
                SetWindowText( GetDlgItem( hdlg , ID_EDT_NUM ) , szDigits );
            }
        }

        break;

    case WM_NOTIFY:
        {
            ODS( TEXT("OFNHookProc WM_NOTIFY\n" ) );            

            LPOFNOTIFY pOnotify = ( LPOFNOTIFY )lParam;

            if( pOnotify != NULL && pOnotify->hdr.code == CDN_FILEOK )
            {
                DBGMSG( TEXT("File name to store in registry %s.\n") , pOnotify->lpOFN->lpstrFile );
				                
				ZeroMemory( &dobj , sizeof( DATAOBJECT ) );

                lstrcpy( dobj.wchFileName , pOnotify->lpOFN->lpstrFile );

                GetWindowText( GetDlgItem( hdlg , ID_EDT_NUM ) , szDigits , SIZEOF(  szDigits ) );

                if( szDigits[0] == 0 )
                {
                    // reset to default elaspe time

                    dobj.dwTimeInterval = 5;
                }
                else
                {
                    dobj.dwTimeInterval = _wtoi( szDigits );
                }

                dobj.bIsChecked = IsDlgButtonChecked( hdlg , IDC_CHECK1 ) == BST_CHECKED;

                g_bAutomaticLog = dobj.bIsChecked;

                dobj.bIsDiagnosisChecked = IsDlgButtonChecked( hdlg , IDC_CHECK2 ) == BST_CHECKED;

                g_bDiagnosticLog = dobj.bIsDiagnosisChecked;

                if( dobj.dwTimeInterval < 1 )
                {
                    dobj.dwTimeInterval = 1;
                }

                if( dobj.dwTimeInterval > kMaxMinutes )
                {
                    dobj.dwTimeInterval = kMaxMinutes;
                }

				dobj.bNotifyOnce = TRUE;

                g_dwInterval = dobj.dwTimeInterval * 60 * 1000;

                KillTimer( GetParent( GetParent( hdlg ) ) , kTimerId );

                SetTimer( GetParent( GetParent( hdlg ) ) , kTimerId , g_dwInterval , NULL );            

                StoreDataObject( &dobj );
            }           
            
        }
      
        break;
    }

    return 0;
}


//-------------------------------------------------------------------------
BOOL Tray_Init( HWND hwnd , BOOL bNotify )
{
    NOTIFYICONDATA nid;

    TCHAR szTip[ 60 ];
    TCHAR szBubble[ 255 ];
    TCHAR szTitle[ 60 ];

    ZeroMemory( &nid , sizeof( NOTIFYICONDATA ) );

    LoadString( g_hinst ,
                IDS_TIP ,
                szTip ,
                SIZEOF( szTip )
                );

    if( !bNotify )
    {
        LoadString( g_hinst ,
                    IDS_BUBBLE ,
                    szBubble ,
                    SIZEOF( szBubble )
                  );
        
        LoadString( g_hinst ,
                    IDS_TITLE ,
                    szTitle ,
                    SIZEOF( szTitle )
                 );
        
        nid.uFlags = NIF_TIP | NIF_INFO;
    }
    
    nid.cbSize = sizeof( NOTIFYICONDATA );
    nid.hWnd = hwnd;
    nid.uID = TN_MESSAGE;
    nid.uFlags |= NIF_ICON | NIF_MESSAGE;
    nid.uCallbackMessage = TN_MESSAGE;
    nid.hIcon = LoadIcon( g_hinst , MAKEINTRESOURCE( IDC_ICON_NONE ) );

    lstrcpy( nid.szTip , szTip );
    lstrcpy( nid.szInfo , szBubble );
    lstrcpy( nid.szInfoTitle , szTitle );

    nid.dwInfoFlags = NIIF_INFO;
    nid.uTimeout = kBubbleTimeout;    

    return Shell_NotifyIcon( NIM_ADD , &nid );
}

//-------------------------------------------------------------------------
BOOL Tray_ToGreen( HWND hwnd )
{
    TCHAR szBuffer[ 260 ];

    LoadString( g_hinst ,
                IDS_TRAYGREEN ,
                szBuffer ,
                SIZEOF( szBuffer)
                );

    return Tray_ToXXX( hwnd , szBuffer , IDC_ICON_GO );       
}

//-------------------------------------------------------------------------
BOOL Tray_ToYellow( HWND hwnd , LPTSTR szMsg )
{
    return Tray_ToXXX( hwnd , szMsg , IDC_ICON_CAUTION );    
}

//-------------------------------------------------------------------------
BOOL Tray_ToRed( HWND hwnd )
{
    TCHAR szBuffer[ 260 ];

    LoadString( g_hinst ,
                IDS_TRAYSTOP ,
                szBuffer ,
                SIZEOF( szBuffer)
                );

    return Tray_ToXXX( hwnd , szBuffer , IDC_ICON_STOP );
}

//-------------------------------------------------------------------------
BOOL Tray_Remove( HWND hwnd )
{
    NOTIFYICONDATA nid;

    ZeroMemory( &nid , sizeof( NOTIFYICONDATA ) );
    
    nid.cbSize = sizeof( NOTIFYICONDATA );
    nid.hWnd = hwnd;
    nid.uID = TN_MESSAGE;
 
    return Shell_NotifyIcon( NIM_DELETE , &nid );
}

//-------------------------------------------------------------------------
BOOL Tray_ToXXX( HWND hwnd , LPTSTR szTip , UINT resid )
{
    NOTIFYICONDATA nid;

    ZeroMemory( &nid , sizeof( NOTIFYICONDATA ) );
    
    nid.cbSize = sizeof( NOTIFYICONDATA );
    nid.hWnd = hwnd;
    nid.uID = TN_MESSAGE;
    nid.uFlags = NIF_ICON | NIF_MESSAGE | NIF_TIP;
    nid.uCallbackMessage = TN_MESSAGE;
    nid.hIcon = LoadIcon( g_hinst , MAKEINTRESOURCE( resid ) );
    lstrcpy( nid.szTip , szTip );

    return Shell_NotifyIcon( NIM_MODIFY , &nid );
}

//-------------------------------------------------------------------------
BOOL Tray_Notify( HWND hwnd , WPARAM wp , LPARAM lp )
{
    switch( lp ) 
    {
    case WM_LBUTTONDBLCLK:
        
        OpenIcon( hwnd );
        SetForegroundWindow( hwnd );
        break;

    case WM_RBUTTONDOWN:
        {
            HMENU hmenuParent = LoadMenu( g_hinst, MAKEINTRESOURCE( IDR_TRAYMENU ) );
            if( hmenuParent != NULL ) 
            {
                HMENU hpopup = GetSubMenu( hmenuParent , 0 );

                RemoveMenu( hmenuParent , 0 , MF_BYPOSITION );

                DestroyMenu( hmenuParent );

                // Display the tray icons context menu at 
                // the current cursor location

                if( hpopup != NULL )
                {
                    POINT pt;

                    GetCursorPos( &pt );

                    SetForegroundWindow( hwnd );

                    TrackPopupMenuEx( hpopup,
                                      0,
                                      pt.x,
                                      pt.y,
                                      hwnd,
                                      NULL);

                    DestroyMenu(hpopup);
                }
            }
            
        }
        break;

    }
    
    return FALSE;
}

//-------------------------------------------------------------------------
//  pObj is a pointer a DATAOBJECT buffer
//-------------------------------------------------------------------------
BOOL StoreDataObject( PDATAOBJECT pObj )
{
    DWORD dwStatus;

    HKEY hKey;

    dwStatus = RegCreateKeyEx( HKEY_CURRENT_USER ,
                               szLsViewKey,
                               0,
                               NULL,
                               0,
                               KEY_WRITE,
                               NULL,
                               &hKey,
                               NULL );

    if( dwStatus != ERROR_SUCCESS )
    {
        // format a message and display an error

        return FALSE;
    }

    dwStatus = RegSetValueEx( hKey,
                              TEXT( "DataObject" ),
                              0,
                              REG_BINARY,                            
                              ( CONST BYTE * )pObj,
                              sizeof( DATAOBJECT ) );

    if( dwStatus != ERROR_SUCCESS )
    {
		RegCloseKey( hKey );
        return FALSE;
    }

    RegCloseKey( hKey );
    return TRUE;

}


//-------------------------------------------------------------------------
// pObj is a pointer to a DATAOBJECT buffer
//-------------------------------------------------------------------------
BOOL RetrieveDataObject( PDATAOBJECT pObj )
{
    DWORD dwStatus;
    DWORD dwSizeOfDO = sizeof( DATAOBJECT );

    HKEY hKey;

    dwStatus = RegOpenKeyEx( HKEY_CURRENT_USER ,
                             szLsViewKey,
                             0,
                             KEY_READ,
                             &hKey );
 
    if( dwStatus != ERROR_SUCCESS )
    {
        // could obtain information which is ok.

        return FALSE;
    }

    dwStatus = RegQueryValueEx( hKey,
                                TEXT( "DataObject" ),
                                0, 
                                0,
                                ( LPBYTE )pObj,
                                &dwSizeOfDO );

    if( dwStatus != ERROR_SUCCESS )
    {
        DBGMSG( TEXT( "LSVIEW:RetrieveDataObject RegOpenKey succeed QueryValueEx failed 0x%x\n" ) , dwStatus );
        RegCloseKey( hKey );
        return FALSE;
    }

    RegCloseKey( hKey );

    return TRUE;

}

//-------------------------------------------------------------------------
BOOL LogFile( LPTSTR szFileName )
{
    FILE *fp = NULL;
    
    if( ( fp = _wfopen( szFileName , TEXT( "w" ) ) ) != NULL )
    {
        DBGMSG( TEXT( "File name is %ws\n" ) , szFileName ) ;

        // delimiter not specified use tabs,
        // loop through list and construct a line

        if( g_pHead != NULL )
        {
            PLIST pItem = g_pHead->pNext;

            while( pItem != NULL )
            {
                WCHAR wchBuffer[ 260 ];
                CHAR chBuffer[ 260 ];

                if((sizeof(wchBuffer)/sizeof(wchBuffer[0])) < (wcslen(pItem->pszMachineName) + wcslen(pItem->pszTimeFormat) + wcslen(pItem->pszType) + 1 ))
                {
                    fclose( fp );
                    return FALSE;
                }

                wsprintf( wchBuffer ,
                          TEXT( "%ws\t%ws\t%ws\n" ) ,
                          pItem->pszMachineName ,
                          pItem->pszTimeFormat ,
                          pItem->pszType );

                // DBCS is a hard when streaming; convert this to MBCS

                WideCharToMultiByte( CP_ACP ,
                                     0,
                                     wchBuffer,
                                     SIZEOF( wchBuffer ),
                                     chBuffer,
                                     sizeof( chBuffer ),
                                     NULL,
                                     NULL
                                     );

                fprintf( fp , chBuffer );

                pItem = pItem->pNext;
            }
        }

        fclose( fp );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\lsview\tlslogp.cpp ===
//+--------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1996-1998
//
// File:        tlsapip.cpp
//
// Contents:    Private API
//
// History:     09-09-97    HueiWang    Created
//
//---------------------------------------------------------------------------
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <rpc.h>
#include "lscommon.h"
#include <wincrypt.h>
#include "tlsrpc.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include <secdbg.h>

//----------------------------------------------------------------------------
BOOL
TLSIsLicenseEnforceEnable()
/*++

--*/
{
    #if ENFORCE_LICENSING
    return TRUE;
    #else
    return FALSE;
    #endif
}

//----------------------------------------------------------------------------
BOOL
TLSIsBetaNTServer()
/*++

Abstract:

    Detemine if base NT is a beta or RTM version.

Parameter:

    None.

Return:

    TRUE/FALSE

--*/
{
    BOOL bBetaNt = FALSE;
    DWORD dwStatus;
    DWORD cbData;
    DWORD cbType;
    HKEY hKey = NULL;

    __try {
        LARGE_INTEGER Time = USER_SHARED_DATA->SystemExpirationDate;

        if(Time.QuadPart)
        {
            bBetaNt = TRUE;

            // check our special registry key - force
            // issuing a RTM license.
            dwStatus = RegOpenKeyEx(
                                HKEY_LOCAL_MACHINE,
                                L"SOFTWARE\\Microsoft\\TermServLicensing",
                                0,
                                KEY_ALL_ACCESS,
                                &hKey
                            );

            if(dwStatus == ERROR_SUCCESS)
            {
                dwStatus = RegQueryValueEx(
                                    hKey,
                                    _TEXT("RunAsRTM"),
                                    NULL,
                                    &cbType,
                                    NULL,
                                    &cbData
                                );

                // for testing, force it to run as RTM version.
                // key must exist and must be DWORD type
                if(dwStatus == ERROR_SUCCESS && cbType == REG_DWORD)
                {
                    bBetaNt = FALSE;
                }
            }
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        ASSERT(FALSE);
    }

    if(hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    return bBetaNt;
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSAllocateInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const CHALLENGE_CONTEXT ChallengeContext,
    IN const LICENSEREQUEST* pRequest,
    IN LPTSTR pszMachineName,
    IN LPTSTR pszUserName,
    IN const DWORD cbChallengeResponse,
    IN const PBYTE pbChallengeResponse,
    OUT PTLSInternetLicense pInternetLicense,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );

    return TLSRpcAllocateInternetLicenseEx(
                                hHandle,
                                ChallengeContext,
                                &rpcRequest,
                                pszMachineName,
                                pszUserName,
                                cbChallengeResponse,
                                pbChallengeResponse,
                                pInternetLicense,
                                pdwErrCode
                            );
}
//----------------------------------------------------------------------------

DWORD WINAPI
TLSReturnInternetLicenseEx(
    IN TLS_HANDLE hHandle,
    IN const LICENSEREQUEST* pRequest,
    IN const ULARGE_INTEGER* pulSerialNumber,
    IN const DWORD dwQuantity,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    TLSLICENSEREQUEST rpcRequest;
    RequestToTlsRequest( pRequest, &rpcRequest );
    
    return TLSRpcReturnInternetLicenseEx(
                                hHandle,
                                &rpcRequest,
                                pulSerialNumber,
                                dwQuantity,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------

DWORD WINAPI 
TLSRegisterLicenseKeyPack( 
    TLS_HANDLE hHandle,
    LPBYTE pbCHCertBlob,
    DWORD cbCHCertBlobSize,
    LPBYTE pbRootCertBlob,
    DWORD cbRootCertBlob,
    LPBYTE lpKeyPackBlob,
    DWORD dwKeyPackBlobLen,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcRegisterLicenseKeyPack( 
                                hHandle,
                                pbCHCertBlob,
                                cbCHCertBlobSize,
                                pbRootCertBlob,
                                cbRootCertBlob,
                                lpKeyPackBlob,
                                dwKeyPackBlobLen,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------

DWORD WINAPI
TLSTelephoneRegisterLKP(
    IN TLS_HANDLE hHandle,
    IN DWORD cbData,
    IN PBYTE pbData,
    OUT PDWORD pdwErrCode
    )

/*++


--*/

{
    return TLSRpcTelephoneRegisterLKP(
                                hHandle,
                                cbData,
                                pbData,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------

DWORD WINAPI
RequestToTlsRequest( 
    const LICENSEREQUEST* lpRequest, 
    TLSLICENSEREQUEST* lpRpcRequest 
    )
/*++

++*/
{
    if(lpRequest == NULL || lpRpcRequest == NULL || lpRequest->pProductInfo == NULL)
        return ERROR_INVALID_PARAMETER;

    //
    // NOTE : No memory allocation, DO NOT FREE ...
    //
    lpRpcRequest->cbEncryptedHwid = lpRequest->cbEncryptedHwid;
    lpRpcRequest->pbEncryptedHwid = lpRequest->pbEncryptedHwid;
    lpRpcRequest->dwLanguageID = lpRequest->dwLanguageID;
    lpRpcRequest->dwPlatformID = lpRequest->dwPlatformID;
    lpRpcRequest->ProductInfo.dwVersion = lpRequest->pProductInfo->dwVersion;
    lpRpcRequest->ProductInfo.cbCompanyName = lpRequest->pProductInfo->cbCompanyName;
    lpRpcRequest->ProductInfo.pbCompanyName = lpRequest->pProductInfo->pbCompanyName;
    lpRpcRequest->ProductInfo.cbProductID = lpRequest->pProductInfo->cbProductID;
    lpRpcRequest->ProductInfo.pbProductID = lpRequest->pProductInfo->pbProductID;
    return ERROR_SUCCESS;
}

//----------------------------------------------------------------------------

DWORD WINAPI 
TLSReturnLicense( 
     TLS_HANDLE hHandle,
     DWORD dwKeyPackId,
     DWORD dwLicenseId,
     DWORD dwRetrunReason,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcReturnLicense( 
                         hHandle,
                         dwKeyPackId,
                         dwLicenseId,
                         dwRetrunReason,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------

DWORD WINAPI 
TLSGetLSPKCS10CertRequest(
    TLS_HANDLE hHandle,
    DWORD dwCertType,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetLSPKCS10CertRequest(
                            hHandle,
                            dwCertType,
                            pcbData,
                            ppbData,
                            pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSRequestTermServCert( 
    TLS_HANDLE hHandle,
    LPLSHydraCertRequest pRequest,
    PDWORD cbChallengeData,
    PBYTE* pbChallengeData,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    TLSHYDRACERTREQUEST CertRequest;

    CertRequest.dwHydraVersion = pRequest->dwHydraVersion;
    CertRequest.pbEncryptedHwid = pRequest->pbEncryptedHwid;
    CertRequest.cbEncryptedHwid = pRequest->cbEncryptedHwid;
    CertRequest.szSubjectRdn = pRequest->szSubjectRdn;
    CertRequest.pSubjectPublicKeyInfo = (TLSCERT_PUBLIC_KEY_INFO *)pRequest->SubjectPublicKeyInfo;
    CertRequest.dwNumCertExtension = pRequest->dwNumCertExtension;
    CertRequest.pCertExtensions = (TLSCERT_EXTENSION *)pRequest->pCertExtensions;

    return TLSRpcRequestTermServCert(
                                hHandle,
                                &CertRequest,
                                cbChallengeData,
                                pbChallengeData,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI
TLSRetrieveTermServCert( 
    TLS_HANDLE hHandle,
    DWORD cbResponseData,
    PBYTE pbResponseData,
    PDWORD pcbCert,
    PBYTE* ppbCert,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcRetrieveTermServCert(
                                hHandle,
                                cbResponseData,
                                pbResponseData,
                                pcbCert,
                                ppbCert,
                                pdwErrCode
                            );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSInstallCertificate( 
     TLS_HANDLE hHandle,
     DWORD dwCertType,
     DWORD dwCertLevel,
     DWORD cbSingnatureCert,
     PBYTE pbSingnatureCert,
     DWORD cbExchangeCert,
     PBYTE pbExchangeCert,
     PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcInstallCertificate( 
                         hHandle,
                         dwCertType,
                         dwCertLevel,
                         cbSingnatureCert,
                         pbSingnatureCert,
                         cbExchangeCert,
                         pbExchangeCert,
                         pdwErrCode
                    );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSGetServerCertificate( 
    TLS_HANDLE hHandle,
    BOOL bSignCert,
    LPBYTE  *ppbCertBlob,
    LPDWORD lpdwCertBlobLen,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcGetServerCertificate( 
                             hHandle,
                             bSignCert,
                             ppbCertBlob,
                             lpdwCertBlobLen,
                             pdwErrCode
                        );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackAdd( 
    TLS_HANDLE hHandle,
    LPLSKeyPack lpKeypack,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackAdd( 
                    hHandle,
                    lpKeypack,
                    pdwErrCode
                );
}

//----------------------------------------------------------------------------
DWORD WINAPI 
TLSKeyPackSetStatus( 
    TLS_HANDLE hHandle,
    DWORD dwSetParm,
    LPLSKeyPack lpKeyPack,
    PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcKeyPackSetStatus( 
                            hHandle,
                            dwSetParm,
                            lpKeyPack,
                            pdwErrCode
                        );
}

//-----------------------------------------------------------------

DWORD WINAPI
TLSAnnounceServer(
    IN TLS_HANDLE hHandle,
    IN DWORD dwType,
    IN FILETIME* pftTime,
    IN LPTSTR pszSetupId,
    IN LPTSTR pszDomainName,
    IN LPTSTR pszMachineName,
    OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    return TLSRpcAnnounceServer(
                        hHandle,
                        dwType,
                        pftTime,
                        pszSetupId,
                        pszDomainName,
                        pszMachineName,
                        pdwErrCode
                    );
}

//-----------------------------------------------------------------

DWORD WINAPI
TLSLookupServer(
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLookupSetupId,
    OUT LPTSTR pszLsSetupId,
    IN OUT PDWORD pcbSetupId,
    OUT LPTSTR pszDomainName,
    IN OUT PDWORD pcbDomainName,
    IN LPTSTR pszLsName,
    IN OUT PDWORD pcbMachineName,
    OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    return TLSRpcLookupServer(
                        hHandle,
                        pszLookupSetupId,
                        pszLsSetupId,
                        pcbSetupId,
                        pszDomainName,
                        pcbDomainName,
                        pszLsName,
                        pcbMachineName,
                        pdwErrCode
                    );
}

//-----------------------------------------------------------------

DWORD WINAPI
TLSLookupServerFixed(
    IN TLS_HANDLE hHandle,
    IN LPTSTR pszLookupSetupId,
    OUT LPTSTR *pszLsSetupId,
    OUT LPTSTR *pszDomainName,
    OUT LPTSTR *pszLsName,
    IN OUT PDWORD pdwErrCode
    )
/*++


++*/
{
    return TLSRpcLookupServerFixed(
                        hHandle,
                        pszLookupSetupId,
                        pszLsSetupId,
                        pszDomainName,
                        pszLsName,
                        pdwErrCode
                    );
}

//-------------------------------------------------------

DWORD WINAPI
TLSAnnounceLicensePack(
    IN TLS_HANDLE hHandle,
    IN PTLSReplRecord pReplRecord,
    OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcAnnounceLicensePack(
                            hHandle,
                            pReplRecord,
                            pdwErrCode
                        );
}

//-------------------------------------------------------

DWORD WINAPI
TLSReturnLicensedProduct(
    IN TLS_HANDLE hHandle,
    IN PTLSLicenseToBeReturn pClientLicense,
    OUT PDWORD pdwErrCode
    )
/*++

++*/
{
    return TLSRpcReturnLicensedProduct(
                                hHandle,
                                pClientLicense,
                                pdwErrCode
                            );
}

//-------------------------------------------------------

DWORD WINAPI
TLSChallengeServer( 
    IN TLS_HANDLE hHandle,
    IN DWORD dwClientType,
    IN PTLSCHALLENGEDATA pClientChallenge,
    OUT PTLSCHALLENGERESPONSEDATA* ppServerResponse,
    OUT PTLSCHALLENGEDATA* ppServerChallenge,
    OUT PDWORD pdwErrCode
    )
/*++


--*/
{
    return TLSRpcChallengeServer(
                            hHandle,
                            dwClientType,
                            pClientChallenge,
                            ppServerResponse,
                            ppServerChallenge,
                            pdwErrCode
                        );
}

//-------------------------------------------------------

DWORD WINAPI
TLSResponseServerChallenge( 
    IN TLS_HANDLE hHandle,
    IN PTLSCHALLENGERESPONSEDATA pClientResponse,
    OUT PDWORD pdwErrCode
    )

/*++

--*/

{

    return TLSRpcResponseServerChallenge(
                                hHandle,
                                pClientResponse,
                                pdwErrCode
                            );
}

//------------------------------------------------------

DWORD WINAPI
TLSGetTlsPrivateData( 
    IN TLS_HANDLE hHandle,
    IN DWORD dwGetDataType,
    IN PTLSPrivateDataUnion pGetParm,
    OUT PDWORD pdwRetDataType,
    OUT PTLSPrivateDataUnion* ppRetData,
    OUT PDWORD pdwErrCode
    )
/*++

--*/
{
    return TLSRpcGetTlsPrivateData(
                                hHandle,
                                dwGetDataType,
                                pGetParm,
                                pdwRetDataType,
                                ppRetData,
                                pdwErrCode
                            );
}

//------------------------------------------------------

DWORD WINAPI
TLSTriggerReGenKey( 
    IN TLS_HANDLE hHandle,
    IN BOOL bKeepSPK,
    OUT PDWORD pdwErrCode
    )

/*++


--*/

{
    return TLSRpcTriggerReGenKey(
                            hHandle,
                            bKeepSPK,
                            pdwErrCode
                        );
}

//------------------------------------------------------
DWORD
GetPrivateBinaryDataFromServer(
    TLS_HANDLE hHandle,
    DWORD dwType,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )

/*++

--*/

{
    TLSPrivateDataUnion SearchParm;
    PTLSPrivateDataUnion pPrivateData = NULL;
    DWORD dwRetType;
    DWORD dwStatus;

    memset(
            &SearchParm, 
            0, 
            sizeof(TLSPrivateDataUnion)
        );

    dwStatus = TLSRpcGetTlsPrivateData(
                                hHandle,
                                dwType,
                                &SearchParm,
                                &dwRetType,
                                &pPrivateData,
                                pdwErrCode
                            );

    if(dwStatus != RPC_S_OK || *pdwErrCode != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(dwRetType != dwType)
    {
        //
        // License Server error
        //
        *pdwErrCode = LSERVER_E_INVALID_RETURN;
        goto cleanup;
    }
     
    //
    // Copy over unique ID
    //
    *ppbData = (PBYTE)MIDL_user_allocate(pPrivateData->BinaryData.cbData);
    if(*ppbData != NULL)
    {
        memset(
                *ppbData, 
                0, 
                pPrivateData->BinaryData.cbData
            );

        *pcbData = pPrivateData->BinaryData.cbData;

        memcpy( 
            *ppbData,
            pPrivateData->BinaryData.pbData,
            pPrivateData->BinaryData.cbData
        );
    }
    else
    {
        *pdwErrCode = LSERVER_E_OUTOFMEMORY;
    }        

cleanup:

    if(pPrivateData != NULL)
    {
        midl_user_free(pPrivateData);
    }

    return dwStatus;
}  


//------------------------------------------------------

DWORD WINAPI
TLSGetServerPID(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )

/*++

--*/

{
    return GetPrivateBinaryDataFromServer(
                                        hHandle,
                                        TLS_PRIVATEDATA_PID,
                                        pcbData,
                                        ppbData,
                                        pdwErrCode
                                    );
}

//------------------------------------------------------

DWORD WINAPI
TLSGetServerSPK(
    TLS_HANDLE hHandle,
    PDWORD pcbData,
    PBYTE* ppbData,
    PDWORD pdwErrCode
    )

/*++

--*/

{
    TLSPrivateDataUnion SearchParm;
    PTLSPrivateDataUnion pPrivateData = NULL;
    DWORD dwRetType;
    DWORD dwStatus;

    memset(
            &SearchParm, 
            0, 
            sizeof(TLSPrivateDataUnion)
        );

    dwStatus = TLSRpcGetTlsPrivateData(
                                hHandle,
                                TLS_PRIVATEDATA_SPK,
                                &SearchParm,
                                &dwRetType,
                                &pPrivateData,
                                pdwErrCode
                            );

    if(dwStatus != RPC_S_OK || *pdwErrCode != ERROR_SUCCESS)
    {
        goto cleanup;
    }

    if(dwRetType != TLS_PRIVATEDATA_SPK)
    {
        //
        // License Server error
        //
        *pdwErrCode = LSERVER_E_INVALID_RETURN;
        goto cleanup;
    }
     
    //
    // Copy over Server's SPK.
    // Server never return CH's cert extension.
    //
    *ppbData = (PBYTE)MIDL_user_allocate(pPrivateData->SPK.cbSPK);
    if(*ppbData != NULL)
    {
        memset(
                *ppbData, 
                0, 
                pPrivateData->SPK.cbSPK
            );

        *pcbData = pPrivateData->SPK.cbSPK;

        memcpy( 
            *ppbData,
            pPrivateData->SPK.pbSPK,
            pPrivateData->SPK.cbSPK
        );
    }
    else
    {
        *pdwErrCode = LSERVER_E_OUTOFMEMORY;
    }        

cleanup:

    if(pPrivateData != NULL)
    {
        midl_user_free(pPrivateData);
    }

    return dwStatus;
}  


//-----------------------------------------------------------

DWORD WINAPI
TLSDepositeServerSPK(
    IN TLS_HANDLE hHandle,
    IN DWORD cbSPK,
    IN PBYTE pbSPK,
    IN PCERT_EXTENSIONS pCertExtensions,
    OUT PDWORD pdwErrCode
    )
/*++

--*/

{
    TLSPrivateDataUnion SetData;
    DWORD dwStatus;

    SetData.SPK.cbSPK = cbSPK;
    SetData.SPK.pbSPK = pbSPK;
    SetData.SPK.pCertExtensions = pCertExtensions;

    return TLSRpcSetTlsPrivateData( 
                            hHandle,
                            TLS_PRIVATEDATA_SPK,
                            &SetData,
                            pdwErrCode
                        );   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\misc.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  misc.c                                     **
**                                             **
**  Miscellaneous dialog - TSREG               **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <winuser.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"


//HKEY_CURRENT_USER\Control Panel\Desktop\ForegroundLockTimeout. Set it to zero
TCHAR lpszTimoutPath[] = "Control Panel\\Desktop";
TCHAR lpszTimeoutKey[] = "ForegroundLockTimeout";

HWND g_hwndMiscDlg;
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK Miscellaneous(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr;
    static HWND hwndComboOrder;
    static HWND hwndRadioShadowEn, hwndRadioShadowDis;
    static HWND hwndRadioDedicatedEn, hwndRadioDedicatedDis;
	static HWND hwndSliderTimeout, hwndEditTimeout;
	static HWND hwndSliderFrame;
    static TCHAR lpszRegPath[MAX_PATH];

    TCHAR lpszBuffer[6];
    TCHAR lpszMBoxTitle[25];
    TCHAR lpszMBoxError[90];
    int i, nPos;

    LPHELPINFO lphi;


    OSVERSIONINFO osvi;
    static BOOL bIsWindows98orLater;
    static BOOL bIsNT5orLater;
    static int nLockValue;



    //
    // get a pointer to the NMHDR struct for apply button
    //
    lpnmhdr = (LPNMHDR) lParam;

    switch (nMsg) {

        case WM_INITDIALOG:


            LoadString (g_hInst, IDS_REG_PATH,
                lpszRegPath, sizeof (lpszRegPath));
            //
            // get handles
            //
            g_hwndMiscDlg = hDlg;

            hwndComboOrder = GetDlgItem(hDlg, IDC_COMBO_ORDER);
            hwndRadioShadowEn = GetDlgItem(hDlg, IDC_SHADOW_ENABLED);
            hwndRadioShadowDis = GetDlgItem(hDlg, IDC_SHADOW_DISABLED);
            hwndRadioDedicatedEn = GetDlgItem(hDlg, IDC_DEDICATED_ENABLED);
            hwndRadioDedicatedDis = GetDlgItem(hDlg, IDC_DEDICATED_DISABLED);



            //
            // lock timeout stuff ------->

			hwndSliderTimeout = GetDlgItem(hDlg, IDC_SLD_TIMEOUT);
			hwndEditTimeout = GetDlgItem(hDlg, IDC_TXT_TIMEOUT);
			hwndSliderFrame = GetDlgItem(hDlg, IDC_FRAME_TIMEOUT);
            //
            // Find out what operating system is is
            // before doing the lock timeout stuff
            //
            osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx (&osvi);
            bIsWindows98orLater =
               (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
               ( (osvi.dwMajorVersion > 4) ||
               ( (osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion > 0) ) );


            osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
            GetVersionEx (&osvi);
            bIsNT5orLater =
               (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
               ( (osvi.dwMajorVersion > 4) ||
               ( (osvi.dwMajorVersion == 5) ) );


            if ((bIsNT5orLater == TRUE) || (bIsWindows98orLater == TRUE)) {

                //
                // set range on slider
                //
                SendMessage(hwndSliderTimeout, TBM_SETRANGE, TRUE,
                        (LPARAM) MAKELONG(1, 6));


				//
				// get value from registry
				//
				nPos = GetKeyVal(lpszTimoutPath, lpszTimeoutKey);
				
                // Use '<=' here - if there is no reg value for
                // ForegroundWindowLockTimeout, the slider control
                // will read -1.
                if (nPos <= 0) {
                    SendMessage(hwndSliderTimeout,
                            TBM_SETPOS, TRUE, 0);
                    _itot(0, lpszBuffer, 10);
                    SetWindowText(hwndEditTimeout, lpszBuffer);
				} else {
                    SendMessage(hwndSliderTimeout, TBM_SETPOS, TRUE,
                    		((nPos / 100000) + 1));
                    _itot(nPos / 100000, lpszBuffer, 10);
                    SetWindowText(hwndEditTimeout, lpszBuffer);
                }

            } else {

            //
            // disable controls if not NT 5 / Win98 or greater
            //
            EnableWindow(hwndSliderTimeout, FALSE);
            EnableWindow(hwndEditTimeout, FALSE);
            EnableWindow(hwndSliderFrame, FALSE);
            }
            //<------------  end lock timeout stuff
            //_____________________________________________________



            //
            // set radio buttons
            //
            RestoreSettings(hDlg, SHADOWINDEX,
                    IDC_SHADOW_DISABLED, IDC_SHADOW_ENABLED,
                    lpszRegPath);

            RestoreSettings(hDlg, DEDICATEDINDEX,
                    IDC_DEDICATED_ENABLED, IDC_DEDICATED_DISABLED,
                    lpszRegPath);

            // ---------------------------------------
            // fill the combo box list with a range of
            // typical values.
            //
            SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                    (LPARAM) (LPCTSTR) TEXT("0"));

            for (i = 5; i < 55; i+= 5) {
                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop

            for (i = 100; i < 1000; i+= 100) {
                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop

            for (i = 1000; i < 10000; i+= 1000) {
                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop

            for (i = 10000; i < 70000; i+= 10000) {
                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboOrder, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop
            //
            // end filling the combo box dropdown list.
            // ----------------------------------------


            //
            // limit combo box to 5 characters
            //
            SendMessage(hwndComboOrder, CB_LIMITTEXT, 5, 0);

            //
            // set edit box from registry
            //
            if (GetRegKey(ORDERINDEX, lpszRegPath) == 1) {
                g_KeyInfo[ORDERINDEX].CurrentKeyValue =
                        (GetRegKeyValue(ORDERINDEX));

            } else {
                g_KeyInfo[ORDERINDEX].CurrentKeyValue =
                        g_KeyInfo[ORDERINDEX].DefaultKeyValue;
            }

            //
            // write to the edit box
            //
            _itot( g_KeyInfo[ORDERINDEX].CurrentKeyValue, lpszBuffer, 10);
            SetWindowText(hwndComboOrder, lpszBuffer);
            break;

        case WM_NOTIFY:

            switch (lpnmhdr->code) {

                case PSN_HELP:
                    lphi = (LPHELPINFO) lParam;

                    WinHelp(lphi->hItemHandle,
                        g_lpszPath, HELP_CONTENTS, lphi->iCtrlId);
                    break;

                case PSN_APPLY:

                    if (g_KeyInfo[ORDERINDEX].CurrentKeyValue ==
                            g_KeyInfo[ORDERINDEX].DefaultKeyValue) {
                        DeleteRegKey(ORDERINDEX, lpszRegPath);
                    } else {
                        SetRegKey(ORDERINDEX, lpszRegPath);
                    }

                    //
                    // save radio button settings
                    //
                    SaveSettings(hDlg, DEDICATEDINDEX, IDC_DEDICATED_ENABLED,
                            IDC_DEDICATED_DISABLED, lpszRegPath);

                    SaveSettings(hDlg, SHADOWINDEX, IDC_SHADOW_DISABLED,
                            IDC_SHADOW_ENABLED, lpszRegPath);

			        //
			        // Write the lock timeout (milliseconds) to
			        // the registry.
			        //
					SetRegKeyVal(lpszTimoutPath,
								lpszTimeoutKey,
						 		(nLockValue - 1) * 100000);
				 		
                    break;
                }
                break;

        case WM_HELP:

            lphi = (LPHELPINFO) lParam;

            WinHelp(lphi->hItemHandle,
                    g_lpszPath, HELP_CONTEXTPOPUP, lphi->iCtrlId);
            break;

        case WM_COMMAND:

            switch  LOWORD (wParam) {

                case IDC_SHADOW_ENABLED:
                    CheckDlgButton(hDlg, IDC_SHADOW_DISABLED, FALSE);
                    break;
                case IDC_SHADOW_DISABLED:
                    CheckDlgButton(hDlg, IDC_SHADOW_ENABLED, FALSE);
                    break;
                case IDC_DEDICATED_ENABLED:
                    CheckDlgButton(hDlg, IDC_DEDICATED_DISABLED, FALSE);
                    break;
                case IDC_DEDICATED_DISABLED:
                    CheckDlgButton(hDlg, IDC_DEDICATED_ENABLED, FALSE);
                    break;
                case IDC_MISC_BUTTON_RESTORE:
                    CheckDlgButton(hDlg, IDC_SHADOW_ENABLED, TRUE);
                    CheckDlgButton(hDlg, IDC_SHADOW_DISABLED, FALSE);
                    CheckDlgButton(hDlg, IDC_DEDICATED_DISABLED, TRUE);
                    CheckDlgButton(hDlg, IDC_DEDICATED_ENABLED, FALSE);
                    _itot( g_KeyInfo[ORDERINDEX].DefaultKeyValue,
                            lpszBuffer, 10);
                    SetWindowText(hwndComboOrder, lpszBuffer);

                    g_KeyInfo[ORDERINDEX].CurrentKeyValue =
                            g_KeyInfo[ORDERINDEX].DefaultKeyValue;

		            //
		            // Reset the position of the slider control
		            // for the foreground lock timeout.
		            //
                    _itot(LOCK_TIMEOUT / 100000, lpszBuffer, 10);
                    SetWindowText(hwndEditTimeout, lpszBuffer);

	                SendMessage(hwndSliderTimeout, TBM_SETPOS, TRUE,
	                		((LOCK_TIMEOUT / 100000) + 1));
	                nLockValue = (LOCK_TIMEOUT / 100000) + 1;
	

                    break;
            }

            switch  HIWORD (wParam) {

                case CBN_SELCHANGE:

                    g_KeyInfo[ORDERINDEX].CurrentKeyValue = (DWORD)
                            SendMessage(hwndComboOrder, CB_GETCURSEL, 0, 0);
                    SendMessage(hwndComboOrder, CB_GETLBTEXT,
                            g_KeyInfo[ORDERINDEX].CurrentKeyValue,
                            (LPARAM) lpszBuffer);
                    g_KeyInfo[ORDERINDEX].CurrentKeyValue = _ttoi(lpszBuffer);
                    break;

                case CBN_EDITUPDATE:

                    GetWindowText(hwndComboOrder, lpszBuffer, 6);
                    g_KeyInfo[ORDERINDEX].CurrentKeyValue = _ttoi(lpszBuffer);

                    break;

                case CBN_KILLFOCUS:
                    GetWindowText(hwndComboOrder, lpszBuffer, 6);
                    g_KeyInfo[ORDERINDEX].CurrentKeyValue = _ttoi(lpszBuffer);

                    if ( (g_KeyInfo[ORDERINDEX].CurrentKeyValue >
                            MAX_ORDER_DRAW_VAL) ) {

                        //
                        // display error if value is off
                        //
                        LoadString (g_hInst, IDS_MISC_TAB, lpszMBoxTitle,
                                sizeof (lpszMBoxTitle));

                        LoadString (g_hInst, IDS_ODRAW_ERROR, lpszMBoxError,
                                sizeof (lpszMBoxError));

                        MessageBox(hDlg, lpszMBoxError,
                                   lpszMBoxTitle,
                                   MB_OK | MB_ICONEXCLAMATION);

                        _itot(g_KeyInfo[ORDERINDEX].DefaultKeyValue,
                                lpszBuffer, 10);
                        SetWindowText(hwndComboOrder, lpszBuffer);
                        g_KeyInfo[ORDERINDEX].CurrentKeyValue =
                                g_KeyInfo[ORDERINDEX].DefaultKeyValue ;
                    }
                    break;
            }
            break;


        case WM_HSCROLL:

            //
            // get the position of the slider control
            //
            nLockValue = (int) SendMessage(hwndSliderTimeout, TBM_GETPOS, 0,0);
                    _itot(nLockValue - 1, lpszBuffer, 10);
                    SetWindowText(hwndEditTimeout, lpszBuffer);
					
			break;


    }
    return (FALSE);
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\profiles.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  profiles.c                                 **
**                                             **
**  Profiles dialog - TSREG                    **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include "tsreg.h"
#include "resource.h"

PROFILE_KEY_INFO *g_pkfProfile;
PROFILE_KEY_INFO *g_pkfStart;
HWND g_hwndProfilesDlg;

///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK ProfilePage(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    static HWND hwndProfilesCBO;
    static HWND hwndProfilesEdit;
    static HKEY hKey;
    TCHAR lpszClientProfilePath[MAX_PATH];
    TCHAR lpszBuffer[MAXKEYSIZE];
    TCHAR lpszKeyName[MAXKEYSIZE];
    TCHAR lpszConfirm[MAX_MESSAGE_LEN + MAXKEYSIZE+MAXTEXTSIZE];
    TCHAR lpszDeleteCaption[90]; // for message box
    TCHAR lpszDeleteTitle[25]; // for message box
    TCHAR lpszSubKeyPath[MAX_PATH];
    TCHAR lpszText[MAXTEXTSIZE];
    ULONG lpPathLen = MAX_PATH;
    NMHDR *lpnmhdr;
    LPHELPINFO lphi;
    LRESULT i;
    int index;
    BOOL bContinue;

    lpnmhdr = (LPNMHDR) lParam;

    switch (nMsg) {

        case WM_INITDIALOG:

            hwndProfilesCBO = GetDlgItem(hDlg, IDC_CBO_PROFILES);
            hwndProfilesEdit = GetDlgItem(hDlg, IDC_EDIT_PROFILES);
            g_hwndProfilesDlg = hDlg;
            LoadKeyValues();

            LoadString(g_hInst, IDS_DEFAULT, lpszText, MAXTEXTSIZE);

            // display 'Default' in edit cell of combo box
            //
            i = SendMessage(hwndProfilesCBO,
                        CB_FINDSTRING, 0,
                        (LPARAM) lpszText);

            SendMessage(hwndProfilesCBO,
                        CB_SETCURSEL, i, 0);
            break;


        case WM_NOTIFY:

            switch (lpnmhdr->code) {

                case PSN_HELP:
                    lphi = (LPHELPINFO) lParam;

                    WinHelp(lphi->hItemHandle,
                        g_lpszPath, HELP_CONTENTS, lphi->iCtrlId);
                    break;
                }
            break;


        case WM_HELP:

            lphi = (LPHELPINFO) lParam;

            WinHelp(lphi->hItemHandle,
                    g_lpszPath, HELP_CONTEXTPOPUP, lphi->iCtrlId);
            break;

        case WM_COMMAND:

            switch  LOWORD (wParam) {

                case IDC_BTN_LOAD:


                    GetWindowText(hwndProfilesCBO, lpszBuffer, MAXKEYSIZE);

                    // if string is null, exit routine
                    //
                    if (_tcscmp(lpszBuffer, TEXT("")) == 0) {
                        LoadString(g_hInst, IDS_PROFILE_LOAD, lpszText, MAXTEXTSIZE);

                        MessageBox(hDlg, lpszText, NULL, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(hwndProfilesCBO);
                        break;
                    }

                    ReloadKeys(lpszBuffer, hwndProfilesCBO);

                    SetEditCell(lpszBuffer,
                           hwndProfilesCBO);

                    // change window caption
                    ResetTitle(lpszBuffer);


                    LoadString (g_hInst, IDS_PROFILE_LOADED,
                            lpszConfirm, sizeof(lpszConfirm));
                    LoadString (g_hInst, IDS_PROFILE_LOADED2,
                            lpszText, MAXTEXTSIZE);

                    _tcscat(lpszConfirm, lpszBuffer);
                    _tcscat(lpszConfirm, lpszText);

                    MessageBox(hDlg,
                            lpszConfirm,
                            TEXT("Profile Loaded"),
                            MB_OK | MB_ICONEXCLAMATION);

                    break;

                case IDC_BTN_SAVE:

                    DialogBox(g_hInst,
                            MAKEINTRESOURCE(IDD_SAVE_FORM),
                            g_hwndProfilesDlg,
                            SaveDialog);

                    break;

                case IDC_BTN_DELETE:

                    GetWindowText(hwndProfilesCBO, lpszBuffer, MAXKEYSIZE);

                    if (_tcscmp(lpszBuffer, TEXT("")) == 0) {

                        LoadString(g_hInst, IDS_PROFILE_DELETE, lpszText, MAXTEXTSIZE);

                        MessageBox(hDlg, lpszText, NULL, MB_OK | MB_ICONEXCLAMATION);
                        SetFocus(hwndProfilesCBO);
                        break;
                    }
                    //
                    // confirm delete
                    //
                    LoadString (g_hInst, IDS_DELETE_TITLE,
                            lpszDeleteTitle,
                            sizeof (lpszDeleteTitle));

                    LoadString (g_hInst, IDS_DELETE_CAPTION,
                            lpszDeleteCaption,
                            sizeof (lpszDeleteCaption));

                    i = MessageBox(hDlg, lpszDeleteCaption,
                                  lpszDeleteTitle,
                                  MB_YESNO | MB_ICONEXCLAMATION);

                    if ( i == IDYES) {

                        LoadString (g_hInst, IDS_PROFILE_PATH,
                                lpszClientProfilePath,
                                sizeof(lpszClientProfilePath));

                        GetWindowText(hwndProfilesCBO,
                                lpszBuffer, MAXKEYSIZE);

                        _tcscpy(lpszSubKeyPath, lpszClientProfilePath);
                        _tcscat(lpszSubKeyPath, TEXT("\\"));
                        _tcscat(lpszSubKeyPath, lpszBuffer);

                        //
                        // delete all subkeys first
                        //
                        index = 0;
                        if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszSubKeyPath, 0,
                                KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {
                            do {
                                if (RegEnumKeyEx(hKey, index, &lpszKeyName[0],
                                        &lpPathLen, NULL, NULL, NULL, NULL) ==
                                        ERROR_SUCCESS) {

                                    if (_tcscmp( lpszKeyName,
                                            TEXT("Default")) != 0) {
                                            RegDeleteKey(hKey,
                                                    &lpszKeyName[0]);
                                    }
                                    bContinue = TRUE;
                                    index++;
                                } else {
                                    bContinue = FALSE;
                                }
                            } while (bContinue == TRUE);
                            RegCloseKey(hKey);
                        }

                        //
                        // delete the parent key
                        //
                        if (_tcscmp( lpszBuffer,
                                TEXT("Default")) == 0) {
                            MessageBox(hDlg,
                                    TEXT("Can not delete default key."),
                                    NULL, MB_OK | MB_ICONEXCLAMATION);

                        } else {

                            if (RegOpenKeyEx(HKEY_CURRENT_USER,
                                        lpszClientProfilePath, 0,
                                        KEY_ALL_ACCESS, &hKey) ==
                                        ERROR_SUCCESS)
                            {

                                RegDeleteKey(hKey, &lpszBuffer[0]);
                                RegCloseKey(hKey);
                            }

                            //
                            // remove key from list box
                            //
                            i = SendMessage(hwndProfilesCBO,
                                        CB_FINDSTRING, 0,
                                        (LPARAM) lpszBuffer);

                            SendMessage(hwndProfilesCBO,
                                        CB_DELETESTRING, i, 0);

                            // reload the data struct with default key
                            ReloadKeys(TEXT("Default"), hwndProfilesCBO);

                            // change window caption
                            ResetTitle(TEXT("Default"));
                            SetEditCell(TEXT("Default"),
                                    hwndProfilesCBO);
                        }

                    } else {

                        SetEditCell(lpszBuffer,
                                hwndProfilesCBO);

                        SetFocus(hwndProfilesEdit);
                    }
                    break;
            }
    }
    return (FALSE);
}


// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\save.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  save.c                                     **
**                                             **
**  Save dialog - TSREG                        **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"

int SaveKeys(HWND hDlg,
            HWND hwndEditSave,
            HWND hwndProfilesCBO);

BOOL InitListViewItems(HWND hwndSaveList);
BOOL InitListViewImageLists(HWND hwndSaveList);
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK SaveDialog(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    TCHAR lpszBuffer[MAXKEYSIZE];
    static HWND hwndProfilesCBO;
    static HWND hwndSaveList;
    static HWND hwndEditSave;
    LPNMLISTVIEW lpnmlv;
    NMHDR *lpnmhdr;

    lpnmlv = (LPNMLISTVIEW) lParam;
    lpnmhdr = ((LPNMHDR)lParam);

    switch (nMsg) {

        case WM_INITDIALOG:

            hwndProfilesCBO = GetDlgItem(g_hwndProfilesDlg, IDC_CBO_PROFILES);
            hwndSaveList = GetDlgItem(hDlg, IDC_SAVE_LIST);
            hwndEditSave = GetDlgItem(hDlg, IDC_EDIT_KEY);
            InitListViewImageLists(hwndSaveList);
            InitListViewItems(hwndSaveList);
            SetFocus(hwndEditSave);
            break;

       case WM_NOTIFY:

            //
            // display text in edit box or save when user
            // clicks or double clicks an icon.
            //
            switch (lpnmlv->hdr.code) {

                case NM_DBLCLK:
                    if (SaveKeys(hDlg, hwndEditSave, hwndProfilesCBO))
                        EndDialog(hDlg, TRUE);
                    break;

                case NM_CLICK:

                    ListView_GetItemText(hwndSaveList,
                            lpnmlv->iItem, 0, lpszBuffer,
                            sizeof(lpszBuffer));		
                    SetWindowText(hwndEditSave, lpszBuffer);
                    break;
            }
            break;

        case WM_COMMAND:

            switch  LOWORD (wParam) {

                case IDOK:
                    if (SaveKeys(hDlg, hwndEditSave, hwndProfilesCBO))
                        EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:

                    EndDialog(hDlg, FALSE);

                    break;
            }
            break;
    }

    return (FALSE);
}

///////////////////////////////////////////////////////////////////////////////

BOOL InitListViewImageLists(HWND hwndSaveList)
{

    HICON hiconItem = NULL;        // icon for list view items
    HIMAGELIST himlSmall = NULL;   // image list for other views

    himlSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON),
            GetSystemMetrics(SM_CYSMICON), TRUE, 1, 1);

    // Add an icon to the image list.
    hiconItem = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_FOLDER_ICON));
    if(( hiconItem != NULL) && (himlSmall != NULL)) {
        ImageList_AddIcon(himlSmall, hiconItem);
        DeleteObject(hiconItem);

        // Assign the image lists to the list view control.
        ListView_SetImageList(hwndSaveList, himlSmall, LVSIL_SMALL);
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////


BOOL InitListViewItems(HWND hwndSaveList)
{
    int i;
    LVITEM lvi;

    lvi.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM | LVIF_STATE;
    lvi.state = 0;
    lvi.stateMask = 0;
    lvi.iImage = 0;

    //
    // Get the key names and add them to the image list
    //
    g_pkfProfile = g_pkfStart;
    for (i = 0; i <= g_pkfProfile->Index; i++) {

        lvi.pszText = g_pkfProfile->KeyInfo->Key;
        lvi.iItem = i;
        lvi.iSubItem = 0;
        ListView_InsertItem(hwndSaveList, &lvi);
        g_pkfProfile = g_pkfProfile->Next;
    }

    return TRUE;
}

///////////////////////////////////////////////////////////////////////////////
int SaveKeys(HWND hDlg,
            HWND hwndEditSave,
            HWND hwndProfilesCBO)
{
    TCHAR lpszClientProfilePath[MAX_PATH] = TEXT("");
    TCHAR lpszSubKeyPath[MAX_PATH];
    TCHAR lpszBuffer[MAXKEYSIZE];
    TCHAR lpszText[MAXTEXTSIZE];
    static HKEY hKey;
    int i;


    GetWindowText(hwndEditSave, lpszBuffer, MAXKEYSIZE);

    // check for null string
    //
    if (_tcscmp(lpszBuffer, TEXT("")) == 0) {

        LoadString(g_hInst, IDS_KEY_SAVE, lpszText, MAXTEXTSIZE);

        MessageBox(hDlg, lpszText, NULL, MB_OK | MB_ICONEXCLAMATION);
        SetFocus(hwndEditSave);
        return 0;
    }

    LoadString (g_hInst, IDS_PROFILE_PATH,
            lpszClientProfilePath,
            sizeof(lpszClientProfilePath));

    _tcscpy(lpszSubKeyPath, lpszClientProfilePath);
    _tcscat(lpszSubKeyPath, TEXT("\\"));
    _tcscat(lpszSubKeyPath, lpszBuffer);
    //
    // only add values to the combo box that aren't already listed
    //
    if (SendMessage(hwndProfilesCBO, CB_FINDSTRING, 0,
        (LPARAM) lpszBuffer) == CB_ERR) {

        SendMessage(hwndProfilesCBO, CB_ADDSTRING, 0,
                (LPARAM) lpszBuffer);
    }
    //
    // change window caption
    //
    ResetTitle(lpszBuffer);
    //
    // save the settings to the registry
    //
    WriteBlankKey(lpszSubKeyPath);//save even if nothing is set

    SaveBitmapSettings(lpszSubKeyPath);

    SaveSettings(g_hwndMiscDlg, DEDICATEDINDEX, IDC_DEDICATED_ENABLED,
            IDC_DEDICATED_DISABLED, lpszSubKeyPath);

    SaveSettings(g_hwndMiscDlg, SHADOWINDEX, IDC_SHADOW_DISABLED,
            IDC_SHADOW_ENABLED, lpszSubKeyPath);

    for (i = 2; i < KEYCOUNT; i++) {

        if (g_KeyInfo[i].CurrentKeyValue != g_KeyInfo[i].DefaultKeyValue)
            SetRegKey(i, lpszSubKeyPath);
        else
            DeleteRegKey(i, lpszSubKeyPath);
    }

    //
    // release memory and re-read key values for all defined
    // profiles
    //
    ReloadKeys(lpszBuffer, hwndProfilesCBO);
    SetEditCell(lpszBuffer,
           hwndProfilesCBO);
	return 1;

}//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tsreg.rc
//
#define IDS_BITMAP_CACHE                1
#define IDS_GLYPH_CACHE                 2
#define IDS_PROFILE_PATH                2
#define IDS_MISCELLANEOUS               3
#define IDS_START_ERROR                 3
#define IDS_WINDOW_TITLE                4
#define IDS_REG_PATH                    5
#define IDS_SHADOW_BITMAP               6  // KEYSTART
#define IDS_DEDICTED_TERMINAL           7
#define IDS_BITMAP_CACHE_SIZE           8
#define IDS_GLYPHCELL1                  9
#define IDS_GLYPHCELL2                  10
#define IDS_GLYPHCELL3                  11
#define IDS_GLYPHCELL4                  12
#define IDS_GLYPHCELL5                  13
#define IDS_GLYPHCELL6                  14
#define IDS_GLYPHCELL7                  15
#define IDS_GLYPHCELL8                  16
#define IDS_GLYPHCELL9                  17
#define IDS_GLYPHCELL10                 18
#define IDS_BMPROP1                     19
#define IDS_BMPROP2                     20
#define IDS_BMPROP3                     21
#define IDS_BMPROP4                     22
#define IDS_BMPROP5                     23
#define IDS_TEXTFRAG                    24
#define IDS_GSUPLEVEL                   25
#define IDS_ORDERDRAW                   26
#define IDS_BM_NUM_CACHES               27
#define IDS_BM_C1_PERSIST               28
#define IDS_BM_C2_PERSIST               29
#define IDS_BM_C3_PERSIST               30
#define IDS_BM_C4_PERSIST               31
#define IDS_BM_C5_PERSIST               32
#define IDS_BM_C1_MAX_CEL               33
#define IDS_BM_C2_MAX_CEL               34
#define IDS_BM_C3_MAX_CEL               35
#define IDS_BM_C4_MAX_CEL               36
#define IDS_BM_C5_MAX_CEL               37  // KEYEND
#define IDS_PERCENT_ERROR               39
#define IDS_BMCACHE_ERROR               40
#define IDS_ODRAW_ERROR                 41
#define IDS_MISC_TAB                    42
#define IDS_DELETE_TITLE                43
#define IDS_DELETE_CAPTION              44
#define IDS_PROFILE_LOADED              45
#define IDS_DEFAULT                     46
#define IDS_PROFILE_LOAD                47
#define IDS_PROFILE_DELETE              48
#define IDS_PROFILE_LOADED2             49
#define IDS_KEY_SAVE                    50
#define IDS_PATH_TOO_LONG               51
#define IDD_DEDICATED                   102
#define IDD_PROFILES                    107
#define IDD_GLYPH_CACHE_DLG             111
#define IDD_MISC                        112
#define IDI_ICON1                       115
#define IDI_FOLDER_ICON                 116
#define IDD_SAVE_FORM                   120
#define IDD_SHADOW                      151
#define IDC_DEDICATED_ENABLED           1000
#define IDC_SHADOW_DISABLED             1001
#define IDC_CACHING                     1002
#define IDC_DEDICATED                   1004
#define IDC_SHADOW_ENABLED              1005
#define IDC_DEDICATED_DISABLED          1006
#define IDC_STATIC                      -1
#define IDC_CACHE_SIZE                  1010
#define IDC_COMBO_CACHE_SIZE            1011
#define IDC_CACHE_PROP                  1050

#define IDC_SLD_NO_CACHES               2000
#define IDC_TXT_NO_CACHES               2001

#define IDC_TXT_DST_PROP_1              2002
#define IDC_TXT_DST_PROP_2              2003
#define IDC_TXT_DST_PROP_3              2004
#define IDC_TXT_DST_PROP_4              2005
#define IDC_TXT_DST_PROP_5              2006

#define IDC_SLD_DST_PROP_1              2007
#define IDC_SLD_DST_PROP_2              2008
#define IDC_SLD_DST_PROP_3              2009
#define IDC_SLD_DST_PROP_4              2010
#define IDC_SLD_DST_PROP_5              2011

#define IDC_PERSIST_FRAME               2012

#define IDC_CHK_CSH_1                   2014
#define IDC_CHK_CSH_2                   2015
#define IDC_CHK_CSH_3                   2016
#define IDC_CHK_CSH_4                   2017
#define IDC_CHK_CSH_5                   2018
#define IDC_ACTIVE                      2022

#define IDC_BTN_RESTORE                 1054
#define IDC_RADIO_NONE                  1057
#define IDC_RADIO_PARTIAL               1058
#define IDC_RADIO_FULL                  1059
#define IDC_CBO_TXT_FRAG                1061
#define IDC_FRAME_OD                    1062
#define IDC_COMBO_ORDER                 1064
#define IDC_SLIDER1                     1070
#define IDC_SLIDER2                     1071
#define IDC_SLIDER3                     1072
#define IDC_SLIDER4                     1073
#define IDC_SLIDER5                     1074
#define IDC_SLIDER6                     1075
#define IDC_SLIDER7                     1076
#define IDC_SLIDER8                     1077
#define IDC_SLIDER9                     1078
#define IDC_SLIDER10                    1079
#define IDC_GLYPH_CACHE                 1080
#define IDC_STATIC1                     1083
#define IDC_STATIC2                     1084
#define IDC_STATIC3                     1085
#define IDC_STATIC4                     1086
#define IDC_STATIC5                     1087
#define IDC_STATIC6                     1088
#define IDC_STATIC7                     1089
#define IDC_STATIC8                     1090
#define IDC_STATIC9                     1091
#define IDC_STATIC10                    1092
#define IDC_RESTORE                     1093
#define IDC_CHECK_RESTORE               1094
#define IDC_GLYPH_BTN_RESTORE           1097
#define IDC_MISC_BUTTON_RESTORE         1098
#define IDC_CBO_PROFILES                1102
#define IDC_BTN_LOAD                    1103
#define IDC_BTN_SAVE                    1104
#define IDC_BTN_DELETE                  1105
#define IDC_EDIT_PROFILES               1106
#define IDC_PSAVE                       1107
#define IDC_SAVE_LIST                   1115
#define IDC_EDIT_KEY                    1116


#define IDC_FRAME_TIMEOUT               1117
#define IDC_TXT_TIMEOUT                 1119
#define IDC_SLD_TIMEOUT                 1120


#define IDC_STATIC_CACHE_SIZE           5011

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        121
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1117
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\reg.c ===
/*-----------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation     **
**            All Rights reserved                **
**                                               **
**  reg.c                                        **
**                                               **
**  Functions for reading, writing, and deleting **
**  registry keys - TSREG                        **
**  07-01-98 a-clindh Created                    **
**-----------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"

///////////////////////////////////////////////////////////////////////////////

// Had to have this function in case the user wants to save a profile
// that only has default settings.  This will write a key but the key
// will contain no values.
///////////////////////////////////////////////////////////////////////////////

void WriteBlankKey(TCHAR lpszRegPath[MAX_PATH])
{
    HKEY hKey;
    DWORD dwDisposition;

    RegCreateKeyEx(HKEY_CURRENT_USER, lpszRegPath,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition);

    RegCloseKey(hKey);

}

///////////////////////////////////////////////////////////////////////////////
void SetRegKey(int i, TCHAR lpszRegPath[MAX_PATH])
{
    HKEY hKey;
    DWORD dwDisposition;

    RegCreateKeyEx(HKEY_CURRENT_USER, lpszRegPath,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition);

    //
    // write the key value to the registry
    //
    if(hKey != NULL) {
    RegSetValueEx(hKey, g_KeyInfo[i].Key, 0, REG_DWORD,
            & (unsigned char) (g_KeyInfo[i].CurrentKeyValue),
            sizeof(DWORD));
    }
    RegCloseKey(hKey);

}

///////////////////////////////////////////////////////////////////////////////

void DeleteRegKey(int i, TCHAR lpszRegPath[MAX_PATH])
{
    HKEY hKey;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
            KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {

        RegDeleteValue(hKey, g_KeyInfo[i].Key);
        RegCloseKey(hKey);
    }
}

///////////////////////////////////////////////////////////////////////////////

// returns 1 if the registry key is there and 0 if it isn't
///////////////////////////////////////////////////////////////////////////////
int GetRegKey(int i, TCHAR lpszRegPath[MAX_PATH])
{
    DWORD *dwKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, g_KeyInfo[i].Key, 0,
                &dwType, (LPBYTE) &dwKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return 1;
        }
        RegCloseKey(hKey);
    }
    return 0;
}

///////////////////////////////////////////////////////////////////////////////

void SaveSettings(HWND dlghwnd, int i,
        int nCtlID1, int nCtlID2, TCHAR lpszRegPath[MAX_PATH])
{
    do {
        if (IsDlgButtonChecked(dlghwnd, nCtlID1)) {

            SetRegKey(i, lpszRegPath);

        } else {

             if (IsDlgButtonChecked(dlghwnd, nCtlID2)) {

                 DeleteRegKey(i, lpszRegPath);
             }
        }
    dlghwnd = GetNextWindow(dlghwnd, GW_HWNDNEXT);
    } while (dlghwnd != NULL);
}

///////////////////////////////////////////////////////////////////////////////

void RestoreSettings(HWND dlghwnd, int i,
        int nCtlID1, int nCtlID2, TCHAR lpszRegPath[MAX_PATH])
{

    // check settings and enable appropriate radio button.
    if (GetRegKey(i, lpszRegPath) != 0) {

        CheckDlgButton(dlghwnd, nCtlID1, TRUE);
        CheckDlgButton(dlghwnd, nCtlID2, FALSE);

    } else {

        CheckDlgButton(dlghwnd, nCtlID1, FALSE);
        CheckDlgButton(dlghwnd, nCtlID2, TRUE);

    }
}

///////////////////////////////////////////////////////////////////////////////

// pass the index of the key and the function
// returns the value stored in the registry
///////////////////////////////////////////////////////////////////////////////
int GetRegKeyValue(int i)
{
    int nKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;
    TCHAR lpszRegPath[MAX_PATH];

    LoadString (g_hInst, IDS_REG_PATH, lpszRegPath, sizeof (lpszRegPath));

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, g_KeyInfo[i].Key, 0,
                &dwType, (LPBYTE) &nKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return nKeyValue;
        }
        RegCloseKey(hKey);
    }
    return 0;
}
///////////////////////////////////////////////////////////////////////////////

//  Initialize the controls for the original "misc" sheet.
///////////////////////////////////////////////////////////////////////////////
void InitMiscControls(HWND hDlg, HWND hwndComboBox)
{
    TCHAR szBuffer[4];
    int i, nKeyVal;
    TCHAR lpszRegPath[MAX_PATH];

    LoadString (g_hInst, IDS_REG_PATH, lpszRegPath, sizeof (lpszRegPath));

    //
    // fill the combo box list
    //
    SendMessage(hwndComboBox, CB_ADDSTRING, 0,
            (LPARAM) (LPCTSTR) TEXT("0"));

    for (i = 2; i <= MAXTEXTFRAGSIZE; i*= 2) {
        _itot(i, szBuffer, 10);
        SendMessage(hwndComboBox, CB_ADDSTRING, 0,
                (LPARAM) (LPCTSTR) szBuffer);
    } // ** end for loop

    //
    // limit combo box to 4 characters
    //
    SendMessage(hwndComboBox, CB_LIMITTEXT, 3, 0);

    //
    // get values from registry for text frag combo box
    //
    nKeyVal = GetRegKey(TEXTFRAGINDEX, lpszRegPath); // check for null

    if ( nKeyVal == 1 ) {
        nKeyVal = GetRegKeyValue(TEXTFRAGINDEX);
    } else {
        nKeyVal = g_KeyInfo[TEXTFRAGINDEX].DefaultKeyValue;
    }

    g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue = nKeyVal;
    _itot( nKeyVal, szBuffer, 10);
    SendMessage(hwndComboBox, CB_SELECTSTRING, -1,
            (LPARAM)(LPCSTR) szBuffer);

    //
    // get values from registry for radio buttons
    //
    nKeyVal = GetRegKey(GLYPHINDEX, lpszRegPath); // check for null

    if ( nKeyVal == 1 ) {
        nKeyVal = GetRegKeyValue(GLYPHINDEX);
        switch (nKeyVal) {

            case 0:
                CheckDlgButton(hDlg, IDC_RADIO_NONE, TRUE);
                break;

            case 1:
                CheckDlgButton(hDlg, IDC_RADIO_PARTIAL, TRUE);
                break;

            case 2:
                CheckDlgButton(hDlg, IDC_RADIO_FULL, TRUE);
                break;
        }
    } else {
        nKeyVal = g_KeyInfo[GLYPHINDEX].DefaultKeyValue;
        CheckDlgButton(hDlg, IDC_RADIO_FULL, TRUE);
    }

    g_KeyInfo[GLYPHINDEX].CurrentKeyValue = nKeyVal;

}

///////////////////////////////////////////////////////////////////////////////

// Needed a special funtion to save settings for the bitmap cache.  The
// combined total must be 100 and can only be checked after all combo
// boxes have been filled.
///////////////////////////////////////////////////////////////////////////////
BOOL SaveBitmapSettings(TCHAR lpszRegPath[MAX_PATH])
{
    static HWND hwndComboCache;
    static HWND hwndSliderNumCaches;
    static HWND hwndSliderDistProp[PERCENT_COMBO_COUNT];
    static HWND hwndPropChkBox[PERCENT_COMBO_COUNT];
    static HWND hwndSliderBuddy[PERCENT_COMBO_COUNT];
    TCHAR lpszBuffer[6];
    int i;

    //
    // get handles for cache size combo box and the
    // number of caches slider
    /////////////////////////////////////////////////////////////////
    hwndSliderNumCaches = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_SLD_NO_CACHES);

    hwndComboCache = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_COMBO_CACHE_SIZE);
    //---------------------------------------------------------------

    //
    // save settings for cache size
    /////////////////////////////////////////////////////////////////
    if (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue ==
                g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue) {
        DeleteRegKey(CACHESIZEINDEX, lpszRegPath);
    } else {
        SetRegKey(CACHESIZEINDEX, lpszRegPath);
    }
    //---------------------------------------------------------------

    //
    // save settings for number of caches
    /////////////////////////////////////////////////////////////////
    if ( g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue ==
            g_KeyInfo[NUM_CELL_CACHES_INDEX].DefaultKeyValue) {
        DeleteRegKey(NUM_CELL_CACHES_INDEX, lpszRegPath);
    } else {
        SetRegKey(NUM_CELL_CACHES_INDEX, lpszRegPath);
    }
    //---------------------------------------------------------------


    for (i = 0; i < PERCENT_COMBO_COUNT; i++) {
        //
        // get handles to sliders, edit, & check boxes
        /////////////////////////////////////////////////////////////
        hwndSliderDistProp[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                    IDC_SLD_DST_PROP_1 + i);

        hwndSliderBuddy[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                    IDC_TXT_DST_PROP_1 + i);

        hwndPropChkBox[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                    IDC_CHK_CSH_1 + i);
        //-----------------------------------------------------------
        GetWindowText(hwndSliderBuddy[i], lpszBuffer, 4);
        g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue =
                _ttoi(lpszBuffer);
        //
        // save settings for cache sizes
        /////////////////////////////////////////////////////////////
        if ( g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue ==
                g_KeyInfo[CACHEPROP1 + i].DefaultKeyValue) {
            DeleteRegKey(CACHEPROP1 + i, lpszRegPath);
        } else {
            SetRegKey(CACHEPROP1 + i, lpszRegPath);
        }
        //-----------------------------------------------------------


        //
        // save settings for persistent caching
        /////////////////////////////////////////////////////////////
        if (IsDlgButtonChecked(g_hwndShadowBitmapDlg, IDC_CHK_CSH_1 + i)) {
            g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue = 1;
            SetRegKey(BM_PERSIST_BASE_INDEX + i, lpszRegPath);
        } else {
            g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue = 0;
            DeleteRegKey(BM_PERSIST_BASE_INDEX + i, lpszRegPath);
        }
        //-----------------------------------------------------------

    } // ** end for loop

        return TRUE;

}

///////////////////////////////////////////////////////////////////////////////

// reads individual key values for each profile into it's associated
// variable from the regisgry (if there is a value) or assigns the
// element it's default value.
///////////////////////////////////////////////////////////////////////////////
void LoadKeyValues()
{

    TCHAR lpszClientProfilePath[MAX_PATH];
    static HWND hwndProfilesCBO;
    int i, index, nKeyValue;
    TCHAR lpszSubKeyPath[MAX_PATH];
    DWORD dwType;
    DWORD dwSize;
    static HKEY hKey;


    hwndProfilesCBO = GetDlgItem(g_hwndProfilesDlg, IDC_CBO_PROFILES);

    LoadString (g_hInst, IDS_PROFILE_PATH,
        lpszClientProfilePath, sizeof(lpszClientProfilePath));

    // get the key name of each profile
    GetClientProfileNames(lpszClientProfilePath);

    g_pkfProfile = g_pkfStart;
    for (index = 0; index <= g_pkfProfile->Index; index++) {

        // fill combo box existing profile names
        SendMessage(hwndProfilesCBO, CB_ADDSTRING, 0,
                    (LPARAM) g_pkfProfile->KeyInfo->Key);

        _tcscpy(lpszSubKeyPath, lpszClientProfilePath);
        _tcscat(lpszSubKeyPath, TEXT("\\"));
        _tcscat(lpszSubKeyPath, g_pkfProfile->KeyInfo->Key);

        for (i = 0; i < KEYCOUNT; i++) {
            if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszSubKeyPath, 0,
                    KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {

                g_pkfProfile->KeyInfo[i].DefaultKeyValue =
                        g_KeyInfo[i].DefaultKeyValue;

                _tcscpy(g_pkfProfile->KeyInfo[i].KeyPath,
                        lpszSubKeyPath);

                    if (RegQueryValueEx(hKey, g_KeyInfo[i].Key, 0,
                                    &dwType, (LPBYTE) &nKeyValue,
                                    &dwSize) == ERROR_SUCCESS) {
                        g_pkfProfile->KeyInfo[i].CurrentKeyValue =
                                nKeyValue;
                        RegCloseKey(hKey);
                    } else {
                        g_pkfProfile->KeyInfo[i].CurrentKeyValue =
                                g_KeyInfo[i].DefaultKeyValue;
                        RegCloseKey(hKey);
                    }
                    RegCloseKey(hKey);
            }
        }// inner for loop
        g_pkfProfile =  g_pkfProfile->Next;
    }// outer for loop

}

///////////////////////////////////////////////////////////////////////////////

void ReadRecordIn(TCHAR lpszBuffer[])
{
    // adds values from linked list to default data structure.
    int i, index;

    g_pkfProfile = g_pkfStart;
    for (index = 0; index <= g_pkfProfile->Index; index++) {

        if (_tcscmp( lpszBuffer,
                g_pkfProfile->KeyInfo->Key) == 0) {

            for (i = 0; i < KEYCOUNT; i++) {
                g_KeyInfo[i].CurrentKeyValue =
                        g_pkfProfile->KeyInfo[i].
                        CurrentKeyValue;
            }
            break;
        }
        g_pkfProfile = g_pkfProfile->Next;
    }
}

///////////////////////////////////////////////////////////////////////////////

void ReloadKeys(TCHAR lpszBuffer[], HWND hwndProfilesCBO)
{
    int index;

    SendMessage(hwndProfilesCBO, CB_RESETCONTENT, 0, 0);

    // free any allocated memory.
    g_pkfProfile = g_pkfStart;
    for (index = 0; index <= g_pkfProfile->Index; index++) 
    {
        g_pkfProfile = g_pkfProfile->Next;
        if (g_pkfStart)
            free(g_pkfStart);
        g_pkfStart = g_pkfProfile;
    }
    if (g_pkfStart)
        free(g_pkfStart);

    // allocate memory and reload keys.
    LoadKeyValues();

    // read linked list into current key data struct.
    ReadRecordIn(lpszBuffer);

    // adjust the controls accordingly.
    SetControlValues();
}

///////////////////////////////////////////////////////////////////////////////

// change the title of the app to reflect the currently selected profile
///////////////////////////////////////////////////////////////////////////////
void ResetTitle(TCHAR lpszBuffer[])
{
    HWND hWndParent;
    TCHAR lpszCaption[MAXKEYSIZE] = TEXT("");

    // change window caption
    LoadString (g_hInst, IDS_WINDOW_TITLE,
            lpszCaption, sizeof (lpszCaption));
    _tcscat(lpszCaption, lpszBuffer);
    hWndParent = GetParent(g_hwndProfilesDlg);
    SendMessage(hWndParent, WM_SETTEXT, 0,
            (LPARAM) lpszCaption);
}

///////////////////////////////////////////////////////////////////////////////

void SetEditCell(TCHAR lpszBuffer[],
                 HWND hwndProfilesCBO)
{
    LRESULT i;
    //
    // set edit cell text to selected profile string
    //
    i = SendMessage(hwndProfilesCBO,
                CB_FINDSTRING, 0,
                (LPARAM) lpszBuffer);

    SendMessage(hwndProfilesCBO,
                CB_SETCURSEL, i, 0);
}

///////////////////////////////////////////////////////////////////////////////

// Recursive function to allocate memory and read in the values stored
// in the registry.
///////////////////////////////////////////////////////////////////////////////
void GetClientProfileNames(TCHAR lpszClientProfilePath[])
{
    TCHAR lpszKeyName[MAX_PATH];
    ULONG lpPathLen = MAX_PATH;
    static HKEY hKey;
    static int nKeyIndex = 0;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszClientProfilePath, 0,
            KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS) {

        if (RegEnumKeyEx(hKey, nKeyIndex, &lpszKeyName[0], &lpPathLen,
                NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {

            //
            // allocate memory for the first key
            //
            if (nKeyIndex == 0) {
                g_pkfProfile = (PROFILE_KEY_INFO *) malloc
                        (sizeof(PROFILE_KEY_INFO));
                g_pkfStart = g_pkfProfile;
            }

            //
            // Catches failure if malloc fails above
            //
            if(!g_pkfProfile)
            {
                return;
            }

            // save the key name to the data structure
            _tcsncpy(g_pkfProfile->KeyInfo->Key, lpszKeyName,
                     sizeof(g_pkfProfile->KeyInfo->Key)/sizeof(TCHAR));

            // give the data element an index number
            g_pkfProfile->Index = nKeyIndex;

            // allocate memory for the next structure
            g_pkfProfile->Next = (PROFILE_KEY_INFO *) malloc
                    (sizeof(PROFILE_KEY_INFO));

            // increment the pointer to the next element
            g_pkfProfile = g_pkfProfile->Next;

            // close the current registry key
            RegCloseKey(hKey);

            if(!g_pkfProfile)
            {
                return;
            }

            nKeyIndex++;
            GetClientProfileNames(lpszClientProfilePath);
        }
        RegCloseKey(hKey);
    }
    nKeyIndex = 0;
}

///////////////////////////////////////////////////////////////////////////////

// adjust all of the controls in the application to the values stored
// by the profile.
///////////////////////////////////////////////////////////////////////////////
void SetControlValues()
{
    TCHAR lpszBuffer[MAXKEYSIZE];
    HWND hwndComboCache;
    static HWND hwndSliderNumCaches;
    static HWND hwndSliderDistProp[PERCENT_COMBO_COUNT];
    static HWND hwndSliderDistBuddy[PERCENT_COMBO_COUNT];
    static HWND hwndPropChkBox[PERCENT_COMBO_COUNT];
    static HWND hwndSlider[NUMBER_OF_SLIDERS];
    static HWND hwndSliderEditBuddy[NUMBER_OF_SLIDERS];
    static HWND hwndEditNumCaches;
    static HWND hwndComboTextFrag;
    static HWND hwndComboOrder;
    static HWND hwndRadioShadowEn, hwndRadioShadowDis;
    static HWND hwndRadioDedicatedEn, hwndRadioDedicatedDis;
    static TCHAR lpszRegPath[MAX_PATH];
    static UINT nGlyphBuffer;
    int nPos;
    int i;

    LoadString (g_hInst, IDS_REG_PATH, lpszRegPath, sizeof (lpszRegPath));

    // shadow bitmap page *****************************************************

    hwndComboCache = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_COMBO_CACHE_SIZE);
    hwndSliderNumCaches = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_SLD_NO_CACHES);
    hwndEditNumCaches = GetDlgItem(g_hwndShadowBitmapDlg,
            IDC_TXT_NO_CACHES);

    for (i = 0; i < PERCENT_COMBO_COUNT; i++) {
        _itot(g_KeyInfo[i + CACHEPROP1].CurrentKeyValue,
                lpszBuffer, 10);

        hwndSliderDistProp[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                IDC_SLD_DST_PROP_1 + i);
        hwndSliderDistBuddy[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                IDC_TXT_DST_PROP_1 + i);

        SetWindowText(hwndSliderDistBuddy[i], lpszBuffer);

        hwndPropChkBox[i] = GetDlgItem(g_hwndShadowBitmapDlg,
                IDC_CHK_CSH_1 + i);
    }

    //
    // enable/disable check boxes and sliders
    //
    EnableControls(g_hwndShadowBitmapDlg, hwndSliderDistProp,
                hwndPropChkBox, hwndSliderDistBuddy,
                hwndEditNumCaches, hwndSliderNumCaches,
                PERCENT_COMBO_COUNT, lpszRegPath);

    _itot(g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue, lpszBuffer, 10);
    SetWindowText(hwndComboCache, lpszBuffer);

    // glyph page *************************************************************

    hwndComboTextFrag = GetDlgItem(g_hwndGlyphCacheDlg, IDC_CBO_TXT_FRAG);

    switch (g_KeyInfo[GLYPHINDEX].CurrentKeyValue) {

        case 0:
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_NONE, TRUE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_PARTIAL, FALSE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_FULL, FALSE);
            break;

        case 1:
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_NONE, FALSE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_PARTIAL, TRUE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_FULL, FALSE);
            break;

        case 2:
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_NONE, FALSE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_PARTIAL, FALSE);
            CheckDlgButton(g_hwndGlyphCacheDlg, IDC_RADIO_FULL, TRUE);
            break;
    }

    _itot(g_KeyInfo[TEXTFRAGINDEX].CurrentKeyValue, lpszBuffer, 10);
    SendMessage(hwndComboTextFrag, CB_SELECTSTRING, -1,
            (LPARAM)(LPCSTR) lpszBuffer);

    for (i = 0; i < NUMBER_OF_SLIDERS; i++) {

        hwndSlider[i] = GetDlgItem(g_hwndGlyphCacheDlg,
                (IDC_SLIDER1 + i));
        hwndSliderEditBuddy[i] = GetDlgItem(g_hwndGlyphCacheDlg,
                (IDC_STATIC1 + i));

        SetWindowLongPtr(hwndSlider[i], GWLP_USERDATA, i);

        _itot(g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue,
                (lpszBuffer), 10);
        //
        // position the thumb on the slider control
        //
        nGlyphBuffer = g_KeyInfo[i + GLYPHCACHEBASE].CurrentKeyValue;

#ifdef _X86_
        // EXECUTE ASSEMBLER CODE ONLY IF X86 PROCESSOR
        // BSF: Bit Scan Forward -
        // Scans the value contained in the EAX regiseter
        // for the first significant (1) bit.
        // This function returns the location of the first
        // significant bit.  The function is used in this
        // application as a base 2 logarythm.  The location
        // of the bit is determined, stored in the nPos
        // variable, and nPos is used to set the slider
        // control. ie. If the register value is 4, nPos
        // is set to 2 (00000100).  10 minus 2 (position 8
        // on the slider control) represents the value 4.

        __asm
        {
            BSF  EAX, nGlyphBuffer
            MOV  nPos, EAX
        }
        nPos = 10 - nPos;
        SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, (LPARAM)nPos);

#else

       switch (nGlyphBuffer) {
           case 4:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 8);
               break;
           case 8:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 7);
               break;
           case 16:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 6);
               break;
           case 32:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 5);
               break;
           case 64:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 4);
               break;
           case 128:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 3);
               break;
           case 256:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 2);
               break;
           case 512:
               SendMessage(hwndSlider[i], TBM_SETPOS, TRUE, 1);
               break;
       }
#endif

    }

    //misc page ***************************************************************

    hwndComboOrder = GetDlgItem(g_hwndMiscDlg, IDC_COMBO_ORDER);
    hwndRadioShadowEn = GetDlgItem(g_hwndMiscDlg, IDC_SHADOW_ENABLED);
    hwndRadioShadowDis = GetDlgItem(g_hwndMiscDlg, IDC_SHADOW_DISABLED);
    hwndRadioDedicatedEn = GetDlgItem(g_hwndMiscDlg, IDC_DEDICATED_ENABLED);
    hwndRadioDedicatedDis = GetDlgItem(g_hwndMiscDlg, IDC_DEDICATED_DISABLED);
    //
    // set radio buttons
    //
    RestoreSettings(g_hwndMiscDlg, SHADOWINDEX,
            IDC_SHADOW_DISABLED, IDC_SHADOW_ENABLED,
            g_pkfProfile->KeyInfo[i].KeyPath);

    RestoreSettings(g_hwndMiscDlg, DEDICATEDINDEX,
            IDC_DEDICATED_ENABLED, IDC_DEDICATED_DISABLED,
            g_pkfProfile->KeyInfo[i].KeyPath);

    _itot( g_KeyInfo[ORDERINDEX].CurrentKeyValue,
    lpszBuffer, 10);
    SetWindowText(hwndComboOrder, lpszBuffer);
}

///////////////////////////////////////////////////////////////////////////////
//
//
// send handles to controls and the integer value for the number of
// enabled combo & check boxes
///////////////////////////////////////////////////////////////////////////////
void EnableControls(HWND hDlg,
            HWND hwndSliderDistProp[],
            HWND hwndPropChkBox[],
            HWND hwndSliderDistBuddy[],
            HWND hwndEditNumCaches,
            HWND hwndSliderNumCaches,
            int nNumCellCaches,
            TCHAR lpszRegPath[])
{

    int i, nPos;
    TCHAR lpszBuffer[6];


    for (i = 0; i < nNumCellCaches; i++) {
        //
        // check/uncheck check boxes for persistent caching
        //
        if (g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue == 0)
            CheckDlgButton(hDlg, IDC_CHK_CSH_1 + i, FALSE);
        else
            CheckDlgButton(hDlg, IDC_CHK_CSH_1 + i, TRUE);

        //
        // enable/disable check & slider controls
        //
        if (i < (INT) g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue) {
            EnableWindow(hwndSliderDistProp[i], TRUE);
            EnableWindow(hwndPropChkBox[i], TRUE);
            EnableWindow(hwndSliderDistBuddy[i], TRUE);
            _itot(g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue,
                                        lpszBuffer, 10);
            SetWindowText(hwndSliderDistBuddy[i], lpszBuffer);
            //
            // position the thumb on the slider control
            //
            nPos = g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue;
            SendMessage(hwndSliderDistProp[i], TBM_SETPOS, TRUE,
                    11 - nPos / 10);
            } else {
                EnableWindow(hwndSliderDistProp[i], FALSE);
                EnableWindow(hwndPropChkBox[i], FALSE);
                EnableWindow(hwndSliderDistBuddy[i], FALSE);
                SetWindowText(hwndSliderDistBuddy[i], NULL);
                CheckDlgButton(hDlg, IDC_CHK_CSH_1 + i, FALSE);
                SendMessage(hwndSliderDistProp[i], TBM_SETPOS, TRUE, 11);
            }
    }
    //
    // position the thumb on the slider control (num caches)
    //
    SendMessage(hwndSliderNumCaches, TBM_SETPOS, TRUE,
            g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue + 1);

    _itot( g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue,
            lpszBuffer, 10);
    //
    // display string in edit cell
    //
    SetWindowText(hwndEditNumCaches, lpszBuffer);

}


// end of file
///////////////////////////////////////////////////////////////////////////////
// pass the key name along with the key path and the function
// returns the value stored in the registry
// DWORD values
///////////////////////////////////////////////////////////////////////////////
int GetKeyVal(TCHAR lpszRegPath[MAX_PATH], TCHAR lpszKeyName[MAX_PATH])
{
    int nKeyValue;
    HKEY hKey;
    DWORD dwType;
    DWORD dwSize;

    dwType = REG_SZ;
    dwSize = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
                KEY_READ, &hKey) == ERROR_SUCCESS) {

        if (RegQueryValueEx(hKey, lpszKeyName, 0,
                &dwType, (LPBYTE) &nKeyValue,
                &dwSize) == ERROR_SUCCESS) {

            RegCloseKey(hKey);
            return nKeyValue;
        }
        RegCloseKey(hKey);
    }
    return 0;
}
///////////////////////////////////////////////////////////////////////////////

// send path AND key name to set key value - used with foreground window
// lock timeout.
///////////////////////////////////////////////////////////////////////////////
void SetRegKeyVal(TCHAR lpszRegPath[MAX_PATH],
			TCHAR lpszKeyName[MAX_PATH],
	 		int nKeyValue)
{
    HKEY hKey;
    DWORD dwDisposition;

    RegCreateKeyEx(HKEY_CURRENT_USER, lpszRegPath,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, 0, &hKey, &dwDisposition);

    //
    // write the key value to the registry
    //
    if(hKey != NULL) {
        RegSetValueEx(hKey, lpszKeyName, 0, REG_DWORD,
                & (unsigned char) (nKeyValue),
                sizeof(DWORD));
        RegCloseKey(hKey);
    }
}

//////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\shadow.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  shadow.c                                   **
**                                             **
**  Shadow bitmap dialog - TSREG               **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h>
#include <TCHAR.H>
#include <stdlib.h>
#include "tsreg.h"
#include "resource.h"


HWND g_hwndShadowBitmapDlg;
///////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK ShadowBitmap(HWND hDlg, UINT nMsg,
        WPARAM wParam, LPARAM lParam)
{
    NMHDR *lpnmhdr;
    static HWND hwndComboCacheSize;
    static HWND hwndSliderNumCaches;
    static HWND hwndEditNumCaches;
    static HWND hwndSliderDistProp[PERCENT_COMBO_COUNT];
    static HWND hwndSliderDistBuddy[PERCENT_COMBO_COUNT];
    static HWND hwndPropChkBox[PERCENT_COMBO_COUNT];
    static TCHAR lpszRegPath[MAX_PATH];

    TCHAR lpszBuffer[6];
    TCHAR lpszMBoxTitle[25];
    TCHAR lpszMBoxError[90];
    LPHELPINFO lphi;
    int i, nPos;
    HWND hwndCtl;
    //
    // get a pointer to the NMHDR struct for apply button
    //
    lpnmhdr = (LPNMHDR) lParam;

    switch (nMsg) {

        case WM_NOTIFY:
            //
            // save settings
            //
            switch (lpnmhdr->code) {
                case PSN_KILLACTIVE:
                    SetWindowLongPtr(lpnmhdr->hwndFrom, DWLP_MSGRESULT, FALSE);
                    break;

                case PSN_HELP:
                    lphi = (LPHELPINFO) lParam;
                    WinHelp(lphi->hItemHandle,
                        g_lpszPath, HELP_CONTENTS, lphi->iCtrlId);
                    break;

                case PSN_APPLY:
                    SaveBitmapSettings(lpszRegPath);
                    break;
            }
            break;

        case WM_VSCROLL:

            hwndCtl = (HWND) (lParam);
            i = (int)GetWindowLongPtr(hwndCtl, GWLP_USERDATA);
            nPos = (int) SendMessage(hwndSliderDistProp[i], TBM_GETPOS, 0,0);
            GetWindowText(hwndSliderDistBuddy[i], lpszBuffer, 4);
            //
            // save cache size values to global data struct
            //
            g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue = _ttoi(lpszBuffer);
            //
            // display values in edit controls
            //
            _itot(10 * (11 - nPos), lpszBuffer, 10);
            SetWindowText(hwndSliderDistBuddy[i], lpszBuffer);
            break;

        case WM_HSCROLL:

            nPos = (int) SendMessage(hwndSliderNumCaches, TBM_GETPOS, 0,0);
                    _itot(nPos - 1, lpszBuffer, 10);
                    SetWindowText(hwndEditNumCaches, lpszBuffer);
            //
            // save values to global data struct (number caches)
            //
            g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue = nPos - 1;
            //
            // enable/disable check boxes and sliders
            //
            EnableControls(hDlg, hwndSliderDistProp,
                        hwndPropChkBox, hwndSliderDistBuddy,
                        hwndEditNumCaches, hwndSliderNumCaches,
                        PERCENT_COMBO_COUNT, lpszRegPath);
            break;

        case WM_INITDIALOG:

            LoadString (g_hInst, IDS_REG_PATH,
                lpszRegPath, sizeof (lpszRegPath));
            //
            // get handles
            //
            g_hwndShadowBitmapDlg = hDlg;
            hwndComboCacheSize = GetDlgItem(hDlg, IDC_COMBO_CACHE_SIZE);
            hwndSliderNumCaches = GetDlgItem(hDlg, IDC_SLD_NO_CACHES);
            hwndEditNumCaches = GetDlgItem(hDlg, IDC_TXT_NO_CACHES);
            //
            // set range on slider
            //
            SendMessage(hwndSliderNumCaches, TBM_SETRANGE, TRUE,
                    (LPARAM) MAKELONG(1, 6));

            for (i = 0; i < PERCENT_COMBO_COUNT; i++) {
                hwndSliderDistProp[i] = GetDlgItem(hDlg, IDC_SLD_DST_PROP_1 + i);
                hwndPropChkBox[i] = GetDlgItem(hDlg, IDC_CHK_CSH_1 + i);
                hwndSliderDistBuddy[i] = GetDlgItem(hDlg, IDC_TXT_DST_PROP_1 + i);
                //
                // save the index of the control
                //
                SetWindowLongPtr(hwndSliderDistProp[i], GWLP_USERDATA, i);
                SetWindowLongPtr(hwndSliderDistBuddy[i], GWLP_USERDATA, i);

                SendMessage(hwndSliderDistProp[i], TBM_SETRANGE, TRUE,
                        (LPARAM) MAKELONG(1, 11));

                //
                // get values for persistent caching check boxes
                //
                if (GetRegKey(NUM_CACHE_INDEX + i, lpszRegPath) == 0)
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue =
                            g_KeyInfo[BM_PERSIST_BASE_INDEX +
                            i].DefaultKeyValue;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue =
                            GetRegKeyValue(BM_PERSIST_BASE_INDEX + i);

                //
                // get values for sliders
                //
                if (GetRegKey(CACHEPROP1 + i, lpszRegPath) == 0)
                    g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue =
                            g_KeyInfo[CACHEPROP1 + i].DefaultKeyValue;
                else
                    g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue =
                            GetRegKeyValue(CACHEPROP1 + i);

                _itot(g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue,
                        lpszBuffer, 10);
                //
                // display the value in the static edit controls (dist prop.)
                //
                SetWindowText(hwndSliderDistBuddy[i], lpszBuffer);
                //
                // position the thumb on the slider control
                //
                nPos = g_KeyInfo[CACHEPROP1 + i].CurrentKeyValue;
                SendMessage(hwndSliderDistProp[i], TBM_SETPOS, TRUE,
                        11 - nPos / 10);

            } // end for loop **************************************************


            //
            // get value from registry for number of enabled
            // check & slider controls
            //
            if (GetRegKey(NUM_CELL_CACHES_INDEX, lpszRegPath) == 0)
                g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue =
                        g_KeyInfo[NUM_CELL_CACHES_INDEX].DefaultKeyValue;
            else
                g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue =
                        GetRegKeyValue(NUM_CELL_CACHES_INDEX);
            //
            // show number of enabled caches in edit box
            //
            _itot(g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue,
                    lpszBuffer, 10);
            SetWindowText(hwndEditNumCaches, lpszBuffer);
            //
            // position the thumb on the slider control (num caches)
            //
            SendMessage(hwndSliderNumCaches, TBM_SETPOS, TRUE,
                    g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue + 1);
            //
            // enable/disable check boxes and sliders
            //
            EnableControls(hDlg, hwndSliderDistProp,
                        hwndPropChkBox, hwndSliderDistBuddy,
                        hwndEditNumCaches, hwndSliderNumCaches,
                        PERCENT_COMBO_COUNT, lpszRegPath);
            //
            // display text in cache size edit box from registry
            //
            g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                    (GetRegKeyValue(CACHESIZEINDEX));

            if ( (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue <
                    MIN_BITMAP_CACHE_SIZE) ||
                    (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue >
                    MAX_BITMAP_CACHE_SIZE)) {

                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue;
            }

            _itot( g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue,
                    lpszBuffer, 10);
            SetWindowText(hwndComboCacheSize, lpszBuffer);
            //
            // fill the cache size combo box list
            //
            SendMessage(hwndComboCacheSize, CB_ADDSTRING, 0,
                    (LPARAM) _itot(MIN_BITMAP_CACHE_SIZE, lpszBuffer, 10));

            for (i = CACHE_LIST_STEP_VAL;
                    i <= MAX_BITMAP_CACHE_SIZE;
                    i+= CACHE_LIST_STEP_VAL) {

                _itot(i, lpszBuffer, 10);
                SendMessage(hwndComboCacheSize, CB_ADDSTRING, 0,
                        (LPARAM) (LPCTSTR) lpszBuffer);
            } // ** end for loop

            //
            // limit cache size combo box to 4 characters
            //
            SendMessage(hwndComboCacheSize, CB_LIMITTEXT, 4, 0);
            break;

        case WM_HELP:

            lphi = (LPHELPINFO) lParam;

            WinHelp(lphi->hItemHandle,
                    g_lpszPath, HELP_CONTEXTPOPUP, lphi->iCtrlId);
            break;


        case WM_COMMAND:

        switch  LOWORD (wParam) {

            case IDC_BTN_RESTORE:

                for (i = 0; i < PERCENT_COMBO_COUNT; i++) {
                    _itot(g_KeyInfo[i + CACHEPROP1].DefaultKeyValue,
                            lpszBuffer, 10);
                    SetWindowText(hwndSliderDistProp[i], lpszBuffer);
                    g_KeyInfo[i + CACHEPROP1].CurrentKeyValue =
                            g_KeyInfo[i + CACHEPROP1].DefaultKeyValue;

                    g_KeyInfo[BM_PERSIST_BASE_INDEX + i].CurrentKeyValue =
                            g_KeyInfo[BM_PERSIST_BASE_INDEX +
                            i].DefaultKeyValue;
                }

                _itot(g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue,
                            lpszBuffer, 10);
                SetWindowText(hwndComboCacheSize, lpszBuffer);
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue;

                g_KeyInfo[NUM_CELL_CACHES_INDEX].CurrentKeyValue =
                        g_KeyInfo[NUM_CELL_CACHES_INDEX].DefaultKeyValue;
            //
            // enable/disable check boxes and sliders
            //
            EnableControls(hDlg, hwndSliderDistProp,
                        hwndPropChkBox, hwndSliderDistBuddy,
                        hwndEditNumCaches, hwndSliderNumCaches,
                        PERCENT_COMBO_COUNT, lpszRegPath);
                break;

            case IDC_CHK_CSH_1:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_1))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX].DefaultKeyValue;
                break;
            case IDC_CHK_CSH_2:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_2))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 1].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 1].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX + 1].DefaultKeyValue;
                break;
            case IDC_CHK_CSH_3:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_3))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 2].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 2].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX + 2].DefaultKeyValue;
                break;
            case IDC_CHK_CSH_4:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_4))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 3].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 3].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX + 3].DefaultKeyValue;
                break;
            case IDC_CHK_CSH_5:
                if(IsDlgButtonChecked(hDlg, IDC_CHK_CSH_5))
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 4].CurrentKeyValue = 1;
                else
                    g_KeyInfo[BM_PERSIST_BASE_INDEX + 4].CurrentKeyValue =
                        g_KeyInfo[BM_PERSIST_BASE_INDEX + 4].DefaultKeyValue;
                break;
        }


        switch  HIWORD (wParam) {

            case CBN_SELCHANGE:
                //
                // get values for cache size
                //
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue = (DWORD)
                        SendMessage(hwndComboCacheSize, CB_GETCURSEL, 0, 0);

                SendMessage(hwndComboCacheSize, CB_GETLBTEXT,
                        g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue,
                        (LPARAM) (LPCSTR) lpszBuffer);
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        _ttoi(lpszBuffer);
                break;


            case CBN_EDITUPDATE:

                GetWindowText(hwndComboCacheSize, lpszBuffer, 5);
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        _ttoi(lpszBuffer);
                break;

            case CBN_KILLFOCUS:
                //
                // only allow values within acceptable range
                //
                GetWindowText(hwndComboCacheSize, lpszBuffer, 5);
                g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                        _ttoi(lpszBuffer);

                if ( (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue <
                        MIN_BITMAP_CACHE_SIZE) ||
                        (g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue >
                        MAX_BITMAP_CACHE_SIZE) ) {
                    //
                    // display error if cache size is too big
                    //
                    LoadString (g_hInst,
                            IDS_BITMAP_CACHE,
                            lpszMBoxTitle,
                            sizeof (lpszMBoxTitle));

                    LoadString (g_hInst,
                            IDS_BMCACHE_ERROR,
                            lpszMBoxError,
                            sizeof (lpszMBoxError));

                    MessageBox(hDlg, lpszMBoxError,
                               lpszMBoxTitle,
                               MB_OK | MB_ICONEXCLAMATION);

                    _itot(g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue,
                            lpszBuffer, 10);

                    SetWindowText(hwndComboCacheSize, lpszBuffer);

                    g_KeyInfo[CACHESIZEINDEX].CurrentKeyValue =
                            g_KeyInfo[CACHESIZEINDEX].DefaultKeyValue;

                }
                break;
        }
    }
    return FALSE;
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\psheet.c ===
/*------------------------------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation                        **
**            All Rights reserved                                   **
**                                                                  **
**  psheet.c                                                        **
**                                                                  **
**  Function for defining and creating the property sheets - TSREG  **
**  07-01-98 a-clindh Created                                       **
**------------------------------------------------------------------*/

#include <windows.h>
#include <commctrl.h> 
#include <TCHAR.H>
#include "tsreg.h"
#include "resource.h"


/////////////////////////////////////////////////////////////////////////////// 

INT_PTR CreatePropertySheet(HWND hwndOwner)
{
    PROPSHEETPAGE psp[PAGECOUNT];
    PROPSHEETHEADER psh;
    TCHAR lpszBuf[MAXKEYSIZE] = TEXT("");


    psp[0].dwSize = sizeof(PROPSHEETPAGE);
    psp[0].dwFlags = PSP_PREMATURE | PSP_HASHELP;
    psp[0].hInstance = g_hInst;
    psp[0].pszTemplate = MAKEINTRESOURCE(IDD_SHADOW);
    psp[0].pszIcon = NULL;
    psp[0].pfnDlgProc = ShadowBitmap;
    psp[0].lParam = 0;

    psp[1].dwSize = sizeof(PROPSHEETPAGE);
    psp[1].dwFlags = PSP_PREMATURE | PSP_HASHELP;
    psp[1].hInstance = g_hInst;
    psp[1].pszTemplate = MAKEINTRESOURCE(IDD_GLYPH_CACHE_DLG);
    psp[1].pszIcon = NULL;
    psp[1].pfnDlgProc = GlyphCache;
    psp[1].lParam = 0;

    psp[2].dwSize = sizeof(PROPSHEETPAGE);
    psp[2].dwFlags = PSP_PREMATURE | PSP_HASHELP;
    psp[2].hInstance = g_hInst;
    psp[2].pszTemplate = MAKEINTRESOURCE(IDD_MISC);
    psp[2].pszIcon = NULL;
    psp[2].pfnDlgProc = Miscellaneous;
    psp[2].lParam = 0;

    psp[3].dwSize = sizeof(PROPSHEETPAGE);
    psp[3].dwFlags = PSP_PREMATURE | PSP_HASHELP;
    psp[3].hInstance = g_hInst;
    psp[3].pszTemplate = MAKEINTRESOURCE(IDD_PROFILES);
    psp[3].pszIcon = NULL;
    psp[3].pfnDlgProc = ProfilePage;
    psp[3].lParam = 0;


    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    psh.hwndParent = hwndOwner;
    psh.hInstance = g_hInst;
    psh.pszIcon = MAKEINTRESOURCE(IDI_ICON1);
    LoadString (g_hInst, IDS_WINDOW_TITLE, lpszBuf, sizeof (lpszBuf)); 
    _tcscat(lpszBuf, TEXT("Default"));
    psh.pszCaption = lpszBuf;
    psh.nPages = sizeof(psp) / sizeof(PROPSHEETPAGE);
    psh.ppsp = (LPCPROPSHEETPAGE) &psp;

    return PropertySheet(&psh);
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\jetrpc-s.c ===
#include <jetrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\dis.h ===
/****************************************************************************/
// Directory Integrity Service, header file
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <shellapi.h>
#include <stdio.h>
#include <process.h>
#include <sddl.h>

#include <initguid.h>
#include <ole2.h>
#include <objbase.h>
#include <comdef.h>                     
#include <adoid.h>
#include <adoint.h>

#include <winsta.h>
#include <Lm.h>
#include <Clusapi.h>

#include "tssdcommon.h"

#include "trace.h"



typedef enum _SERVER_STATUS {
    NotResponding,
    Responding
} SERVER_STATUS;

typedef struct {
    unsigned int count;         // number of servers
    WCHAR **ServerNameArray;    // Names
} SDRecoverServerNames;

// Shortcut VARIANT class to handle cleanup on destruction and common code
// inlining.
class CVar : public VARIANT
{
public:
    CVar() { VariantInit(this); }
    CVar(VARTYPE vt, SCODE scode = 0) {
        VariantInit(this);
        this->vt = vt;
        this->scode = scode;
    }
    CVar(VARIANT var) { *this = var; }
    ~CVar() { VariantClear(this); }

    void InitNull() { this->vt = VT_NULL; }
    void InitFromLong(long L) { this->vt = VT_I4; this->lVal = L; }
    void InitNoParam() {
        this->vt = VT_ERROR;
        this->lVal = DISP_E_PARAMNOTFOUND;
    }

    HRESULT InitFromWSTR(PCWSTR WStr) {
        this->bstrVal = SysAllocString(WStr);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    // Inits from a non-NULL-terminated set of WCHARs.
    HRESULT InitFromWChars(WCHAR *WChars, unsigned Len) {
        this->bstrVal = SysAllocStringLen(WChars, Len);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT InitEmptyBSTR(unsigned Size) {
        this->bstrVal = SysAllocStringLen(L"", Size);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT Clear() { return VariantClear(this); }
};



HRESULT CreateADOStoredProcCommand(
        PWSTR CmdName,
        ADOCommand **ppCommand,
        ADOParameters **ppParameters);

HRESULT AddADOInputStringParam(
        PWSTR Param,
        PWSTR ParamName,
        ADOCommand *pCommand,
        ADOParameters *pParameters,
        BOOL bNullOnNull);

HRESULT GetRowArrayStringField(
        SAFEARRAY *pSA,
        unsigned RowIndex,
        unsigned FieldIndex,
        WCHAR *OutStr,
        unsigned MaxOutStr);

void PostSessDirErrorMsgEvent(unsigned EventCode, WCHAR *szMsg, WORD wType);

RPC_STATUS RPC_ENTRY SDRPCAccessCheck(RPC_IF_HANDLE idIF, void *Binding);

RPC_STATUS RPC_ENTRY SDQueryRPCAccessCheck(RPC_IF_HANDLE idIF, void *Binding);

BOOL CheckRPCClientProtoSeq(void *ClientBinding, WCHAR *SeqExpected);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\disutil.cpp ===
/****************************************************************************/
// Directory Integrity Service
//
// Utility functions
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include "dis.h"



extern ADOConnection *g_pConnection;



/****************************************************************************/
// AddADOInputStringParam
//
// Creates and adds to the given ADOParameters object a WSTR-initialized
// parameter value.
/****************************************************************************/
HRESULT AddADOInputStringParam(
        PWSTR Param,
        PWSTR ParamName,
        ADOCommand *pCommand,
        ADOParameters *pParameters,
        BOOL bNullOnNull)
{
    HRESULT hr;
    CVar varParam;
    BSTR ParamStr;
    ADOParameter *pParam;
    int Len;

    ParamStr = SysAllocString(ParamName);
    if (ParamStr != NULL) {
        // ADO does not seem to like accepting string params that are zero
        // length. So, if the string we have is zero length and bNullOnNull says
        // we can, we send a null VARIANT type, resulting in a null value at
        // the SQL server.
        if (wcslen(Param) > 0 || !bNullOnNull) {
            hr = varParam.InitFromWSTR(Param);
            Len = wcslen(Param);
        }
        else {
            varParam.vt = VT_NULL;
            varParam.bstrVal = NULL;
            Len = -1;
            hr = S_OK;
        }

        if (SUCCEEDED(hr)) {
            hr = pCommand->CreateParameter(ParamStr, adVarWChar, adParamInput,
                    Len, varParam, &pParam);
            if (SUCCEEDED(hr)) {
                hr = pParameters->Append(pParam);
                if (FAILED(hr)) {
                    ERR((TB,"InStrParam: Failed append param %S, hr=0x%X",
                            ParamName, hr));
                }

                // ADO will have its own ref for the param.
                pParam->Release();
            }
            else {
                ERR((TB,"InStrParam: Failed CreateParam %S, hr=0x%X",
                        ParamName, hr));
            }
        }
        else {
            ERR((TB,"InStrParam: Failed alloc variant bstr, "
                    "param %S, hr=0x%X", ParamName, hr));
        }

        SysFreeString(ParamStr);
    }
    else {
        ERR((TB,"InStrParam: Failed alloc paramname"));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



/****************************************************************************/
// GetRowArrayStringField
//
// Retrieves a WSTR from a specified row and field of the given SafeArray.
// Returns failure if the target field is not a string. MaxOutStr is max
// WCHARs not including NULL.
/****************************************************************************/
HRESULT GetRowArrayStringField(
        SAFEARRAY *pSA,
        unsigned RowIndex,
        unsigned FieldIndex,
        WCHAR *OutStr,
        unsigned MaxOutStr)
{
    HRESULT hr;
    CVar varField;
    long DimIndices[2];

    DimIndices[0] = FieldIndex;
    DimIndices[1] = RowIndex;
    SafeArrayGetElement(pSA, DimIndices, &varField);

    if (varField.vt == VT_BSTR) {
        wcsncpy(OutStr, varField.bstrVal, MaxOutStr);
        hr = S_OK;
    }
    else if (varField.vt == VT_NULL) {
        OutStr[0] = L'\0';
        hr = S_OK;
    }
    else {
        ERR((TB,"GetRowStrField: Row %u Col %u value %d is not a string",
                RowIndex, FieldIndex, varField.vt));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// CreateADOStoredProcCommand
//
// Creates and returns a stored proc ADOCommand, plus a ref to its
// associated Parameters.
/****************************************************************************/
HRESULT CreateADOStoredProcCommand(
        PWSTR CmdName,
        ADOCommand **ppCommand,
        ADOParameters **ppParameters)
{
    HRESULT hr;
    BSTR CmdStr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;

    CmdStr = SysAllocString(CmdName);
    if (CmdStr != NULL) {
        hr = CoCreateInstance(CLSID_CADOCommand, NULL, CLSCTX_INPROC_SERVER,
                IID_IADOCommand25, (LPVOID *)&pCommand);
        if (SUCCEEDED(hr)) {
            // Set the connection.
            hr = pCommand->putref_ActiveConnection(g_pConnection);
            if (SUCCEEDED(hr)) {
                // Set the command text.
                hr = pCommand->put_CommandText(CmdStr);
                if (SUCCEEDED(hr)) {
                    // Set the command type.
                    hr = pCommand->put_CommandType(adCmdStoredProc);
                    if (SUCCEEDED(hr)) {
                        // Get the Parameters pointer from the Command to
                        // allow appending params.
                        hr = pCommand->get_Parameters(&pParameters);
                        if (FAILED(hr)) {
                            ERR((TB,"Failed getParams for command, "
                                    "hr=0x%X", hr));
                            goto PostCreateCommand;
                        }
                    }
                    else {
                        ERR((TB,"Failed set cmdtype for command, hr=0x%X",
                                hr));
                        goto PostCreateCommand;
                    }
                }
                else {
                    ERR((TB,"Failed set cmdtext for command, hr=0x%X", hr));
                    goto PostCreateCommand;
                }
            }
            else {
                ERR((TB,"Command::putref_ActiveConnection hr=0x%X", hr));
                goto PostCreateCommand;
            }
        }
        else {
            ERR((TB,"CoCreate(Command) returned 0x%X", hr));
            goto PostAllocCmdStr;
        }

        SysFreeString(CmdStr);
    }
    else {
        ERR((TB,"Failed to alloc cmd str"));
        hr = E_OUTOFMEMORY;
        goto ExitFunc;
    }

    *ppCommand = pCommand;
    *ppParameters = pParameters;
    return hr;

// Error handling.

PostCreateCommand:
    pCommand->Release();

PostAllocCmdStr:
    SysFreeString(CmdStr);

ExitFunc:
    *ppCommand = NULL;
    *ppParameters = NULL;
    return hr;
}


 
/****************************************************************************/
// CheckRPCClientProtoSeq
//
// Check if the client uses the expected RPC protocol sequence or not
//
//  Parameters:
//      ClientBinding: The client binding handle
//      SeqExpected: Protocol sequence expected
//      
//  Return:
//      True on getting the expected seq, False otherwise
/****************************************************************************/
BOOL CheckRPCClientProtoSeq(void *ClientBinding, WCHAR *SeqExpected) {
    BOOL fAllowProtocol = FALSE;
    WCHAR *pBinding = NULL;
    WCHAR *pProtSeq = NULL;

    if (RpcBindingToStringBinding(ClientBinding,&pBinding) == RPC_S_OK) {

        if (RpcStringBindingParse(pBinding,
                                  NULL,
                                  &pProtSeq,
                                  NULL,
                                  NULL,
                                  NULL) == RPC_S_OK) {
			
            // Check that the client request was made using expected protoal seq.
            if (lstrcmpi(pProtSeq, SeqExpected) == 0)
                fAllowProtocol = TRUE;

            if (pProtSeq)	
                RpcStringFree(&pProtSeq); 
        }

        if (pBinding)	
            RpcStringFree(&pBinding);
    }
    return fAllowProtocol;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\tsreg.h ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  tsreg.h                                    **
**                                             **
**  Project definitions for TSREG.             **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/


// Defines
#define SHADOWINDEX 0
#define DEDICATEDINDEX 1
#define CACHESIZEINDEX 2
#define GLYPHCACHEBASE 3
#define CACHEPROP1 13
#define CACHEPROP2 14
#define CACHEPROP3 15
#define CACHEPROP4 16
#define CACHEPROP5 17
#define NUM_CACHE_INDEX 22
#define TEXTFRAGINDEX 18
#define GLYPHINDEX 19
#define ORDERINDEX 20

#define MAXTEXTFRAGSIZE 256
#define NUMBER_OF_SLIDERS 10
#define MIN_GLYPH_CACHE_SIZE 4
#define MAX_GLYPH_CACHE_SIZE 512
#define MAX_ORDER_DRAW_VAL 65535
#define MIN_ORDER_DRAW_VAL 0
#define MIN_BITMAP_CACHE_SIZE 150
#define MAX_BITMAP_CACHE_SIZE 4500
#define MAX_MESSAGE_LEN 100
#define CACHE_LIST_STEP_VAL 500
#define PERCENT_COMBO_COUNT 5
#define NUM_SLIDER_STOPS 8
#define NUM_CELL_CACHES_INDEX 21
#define BM_PERSIST_BASE_INDEX 22

#define FULL 2
#define PARTIAL 1
#define NONE 0

#define PAGECOUNT 4

#define MAXTEXTSIZE 1024

//
// constants for g_KeyInfo
//
#define KEYSTART 6  // constants for using string table
#define KEYEND 32   // to load key names.

#define KEYCOUNT 27 // total number of keys per profile
#define MAXKEYSIZE 120

// Foreground window lock timeout default value
#define LOCK_TIMEOUT 200000

//
// un-comment if you want to use string table for key names
//
// #define USE_STRING_TABLE 1

/////////////////////////// Quick MessageBox Macro ////////////////////////////
#define DIMOF(Array) (sizeof(Array) / sizeof(Array[0]))
#define MB(s) {                                                      \
        TCHAR szTMP[128];                                            \
        GetModuleFileName(NULL, szTMP, DIMOF(szTMP));                \
        MessageBox(GetActiveWindow(), s, szTMP, MB_OK);              \
}

// Types
typedef struct _KeyInfo
{
    TCHAR Key[MAXKEYSIZE];
    DWORD DefaultKeyValue;
    DWORD CurrentKeyValue;
    TCHAR KeyPath[MAX_PATH];
} KEY_INFO;

typedef struct _ProfileKeyInfo
{
    struct _ProfileKeyInfo *Next;
    KEY_INFO KeyInfo[KEYCOUNT];
    int Index;
} PROFILE_KEY_INFO;


// Externs
extern KEY_INFO g_KeyInfo[KEYCOUNT];
extern HINSTANCE g_hInst;
extern TCHAR g_lpszPath[MAX_PATH];
extern TCHAR g_lpszClientProfilePath[MAX_PATH];

extern HWND g_hwndShadowBitmapDlg;
extern HWND g_hwndGlyphCacheDlg;
extern HWND g_hwndMiscDlg;
extern HWND g_hwndProfilesDlg;


extern PROFILE_KEY_INFO *g_pkfProfile;
extern PROFILE_KEY_INFO *g_pkfStart;

extern TCHAR lpszTimoutPath[MAX_PATH];
extern TCHAR lpszTimeoutKey[MAX_PATH];

// Prototypes
INT_PTR CALLBACK ShadowBitmap(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK GlyphCache(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK Miscellaneous(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK ProfilePage(HWND, UINT, WPARAM, LPARAM);
INT_PTR CALLBACK SaveDialog(HWND, UINT, WPARAM, LPARAM);

INT_PTR CreatePropertySheet(HWND);
void DeleteRegKey(int, TCHAR lpszRegPath[MAX_PATH]);
void SetRegKey(int, TCHAR lpszRegPath[MAX_PATH]);
void WriteBlankKey(TCHAR lpszRegPath[MAX_PATH]);
int  GetRegKey(int, TCHAR lpszRegPath[MAX_PATH]);
void SaveSettings(HWND, int, int, int, TCHAR lpszRegPath[MAX_PATH]);
void RestoreSettings(HWND, int, int, int, TCHAR lpszRegPath[MAX_PATH]);
BOOL SaveBitmapSettings(TCHAR lpszRegPath[MAX_PATH]);
int GetRegKeyValue(int);
void InitMiscControls(HWND, HWND);
int GetCellSize(int, int);
void GetClientProfileNames(TCHAR lpszClientProfilePath[]);
void SetControlValues();
void LoadKeyValues();
void ReadRecordIn(TCHAR lpszBuffer[]);
void WriteRecordOut(TCHAR lpszBuffer[]);
void ReloadKeys(TCHAR lpszBuffer[], HWND hwndProfilesCBO);
void ResetTitle(TCHAR lpszBuffer[]);
void SetEditCell(TCHAR lpszBuffer[],
                 HWND hwndProfilesCBO);
void DisplayControlValue(HWND hwndSlider[],
            HWND hwndSliderEditBuddy[],  int i);

int GetKeyVal(TCHAR lpszRegPath[MAX_PATH],
			TCHAR lpszKeyName[MAX_PATH]);

void SetRegKeyVal(TCHAR lpszRegPath[MAX_PATH],
			TCHAR lpszKeyName[MAX_PATH],
	 		int nKeyValue);	

void EnableControls(HWND hDlg,
            HWND hwndSliderDistProp[],
            HWND hwndPropChkBox[],
            HWND hwndSliderDistBuddy[],
            HWND hwndEditNumCaches,
            HWND hwndSliderNumCaches,
            int nNumCellCaches,
            TCHAR lpszRegPath[]);

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\reskit\tsreg\tsreg.c ===
/*---------------------------------------------**
**  Copyright (c) 1998 Microsoft Corporation   **
**            All Rights reserved              **
**                                             **
**  tsreg.c                                    **
**                                             **
**  Entry point for TSREG, WinMain.            **
**  07-01-98 a-clindh Created                  **
**---------------------------------------------*/

#include <windows.h>
#include <commctrl.h> 
#include <TCHAR.H>
#include "resource.h"
#include "tsreg.h"

HINSTANCE g_hInst;
TCHAR g_lpszPath[MAX_PATH];
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
        LPSTR lpCmdLine, int nCmdShow)
{
    TCHAR lpszRegPath[MAX_PATH];
    TCHAR lpszBuf[MAX_PATH];
    HKEY hKey;
    INITCOMMONCONTROLSEX  cmctl;
    TCHAR AppBasePath[MAX_PATH];
    int nPathLen;

    /************************************************************************/
    // Grab the app's executable path.
    // Note that the end backslash remains.
    /************************************************************************/
    nPathLen = GetModuleFileName(hInstance,
            AppBasePath, MAX_PATH);
    if (nPathLen > 0) {
        // Strip the module name off the end to leave the executable
        // directory path, by looking for the last backslash.
        nPathLen--;
        while (nPathLen != 0) {
            if (AppBasePath[nPathLen] != _T('\\')) {
                nPathLen--;
                continue;
            }
            nPathLen++;
            break;
        }
    }

    //
    // Check that the path is not too long to contain the base path
    //
    if (nPathLen + MAXKEYSIZE > MAX_PATH) {
        TCHAR lpszText[MAXTEXTSIZE];

        LoadString(hInstance, IDS_PATH_TOO_LONG, lpszText, MAXTEXTSIZE);

        MB(lpszText);
        nPathLen = 0;
    }
    
    AppBasePath[nPathLen] = '\0';

    //
    // Append the name of the help file to the app path and 
    // copy it to the global variable.
    //
    _tcscat(AppBasePath, TEXT("tsreg.hlp"));
    _tcscpy(g_lpszPath, AppBasePath);

    cmctl.dwICC = ICC_TAB_CLASSES | ICC_BAR_CLASSES;
    cmctl.dwSize = sizeof(INITCOMMONCONTROLSEX);
    InitCommonControlsEx(&cmctl);

    //
    // make sure Windows Terminal Server client is installed first.
    //
    LoadString (hInstance, IDS_PROFILE_PATH, lpszRegPath, sizeof (lpszRegPath)); 
    LoadString (hInstance, IDS_START_ERROR, lpszBuf, sizeof (lpszBuf)); 

    if (RegOpenKeyEx(HKEY_CURRENT_USER, lpszRegPath, 0,
            KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS) {

            MessageBox(NULL, lpszBuf,
                       NULL,
                       MB_OK | MB_ICONEXCLAMATION);
        RegCloseKey(hKey);
        return 1;
    }


#ifdef USE_STRING_TABLE
    {
        int i;

        //
        // load string table values into g_KeyInfo data structure
        //
        for (i = KEYSTART; i < (KEYEND + 1); i++) {
                LoadString (hInstance, i, 
                        g_KeyInfo[i - KEYSTART].Key, 
                        sizeof (g_KeyInfo[i - KEYSTART].Key)); 
        }
    }

#endif

    g_hInst = hInstance;
    CreatePropertySheet(NULL);

    return 0;  
                                                 
}

// end of file
///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\jetrpcfn.cpp ===
/****************************************************************************/
// jetrpcfn.cpp
//
// TS Directory Integrity Service Jet RPC server-side implementations.
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include "dis.h"
#include "tssdshrd.h"
#include "jetrpc.h"
#include "jetsdis.h"
#include "sdevent.h"
#include <Lm.h>

#pragma warning (push, 4)

extern PSID g_pSid;
extern DWORD g_dwClusterState;
extern WCHAR *g_ClusterNetworkName;

/****************************************************************************/
// MIDL_user_allocate
// MIDL_user_free
//
// RPC-required allocation functions.
/****************************************************************************/
void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t Size)
{
    return LocalAlloc(LMEM_FIXED, Size);
}

void __RPC_USER MIDL_user_free(void __RPC_FAR *p)
{
    LocalFree(p);
}


/****************************************************************************/
// OutputAllTables (debug only)
//
// Output all tables to debug output.
/****************************************************************************/
#ifdef DBG
void OutputAllTables()
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID clusdirtableid;
    JET_RETRIEVECOLUMN rcSessDir[NUM_SESSDIRCOLUMNS];
    WCHAR UserNameBuf[256];
    WCHAR DomainBuf[127];
    WCHAR ApplicationBuf[256];
    WCHAR ServerNameBuf[128];
    WCHAR ClusterNameBuf[128];
    WCHAR ServerDNSNameBuf[SDNAMELENGTH];
    unsigned count;
    long num_vals[NUM_SESSDIRCOLUMNS];
    char state;
    char SingleSessMode;

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));
    CALL(JetBeginTransaction(sesid));

    TSDISErrorOut(L"SESSION DIRECTORY\n");
    
    err = JetMove(sesid, sessdirtableid, JET_MoveFirst, 0);

    if (JET_errNoCurrentRecord == err) {
        TSDISErrorOut(L" (empty database)\n");
    }

    while (JET_errNoCurrentRecord != err) {
        // Retrieve all the columns
        memset(&rcSessDir[0], 0, sizeof(JET_RETRIEVECOLUMN) * 
                NUM_SESSDIRCOLUMNS);
        for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
            rcSessDir[count].columnid = sesdircolumnid[count];
            rcSessDir[count].pvData = &num_vals[count];
            rcSessDir[count].cbData = sizeof(long);
            rcSessDir[count].itagSequence = 1;
        }
        // fix up pvData, cbData for non-int fields
        rcSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].pvData = UserNameBuf;
        rcSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].cbData = sizeof(UserNameBuf);
        rcSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].pvData = DomainBuf;
        rcSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].cbData = sizeof(DomainBuf);
        rcSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].pvData = ApplicationBuf;
        rcSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].cbData = 
                sizeof(ApplicationBuf);
        rcSessDir[SESSDIR_STATE_INTERNAL_INDEX].pvData = &state;
        rcSessDir[SESSDIR_STATE_INTERNAL_INDEX].cbData = sizeof(state);

        CALL(JetRetrieveColumns(sesid, sessdirtableid, &rcSessDir[0], 
                NUM_SESSDIRCOLUMNS));

        TSDISErrorOut(L"%8s, %s, %d, %d, %d\n", 
                UserNameBuf, 
                DomainBuf, 
                num_vals[SESSDIR_SERVERID_INTERNAL_INDEX], 
                num_vals[SESSDIR_SESSIONID_INTERNAL_INDEX],
                num_vals[SESSDIR_TSPROTOCOL_INTERNAL_INDEX]);

        TSDISErrorTimeOut(L" %s, ", 
                num_vals[SESSDIR_CTLOW_INTERNAL_INDEX],
                num_vals[SESSDIR_CTHIGH_INTERNAL_INDEX]);

        TSDISErrorTimeOut(L"%s\n",
                num_vals[SESSDIR_DTLOW_INTERNAL_INDEX],
                num_vals[SESSDIR_DTHIGH_INTERNAL_INDEX]);

        TSDISErrorOut(L" %s, %d, %d, %d, %s\n",
                ApplicationBuf ? L"(no application)" : ApplicationBuf, 
                num_vals[SESSDIR_RESWIDTH_INTERNAL_INDEX],
                num_vals[SESSDIR_RESHEIGHT_INTERNAL_INDEX],
                num_vals[SESSDIR_COLORDEPTH_INTERNAL_INDEX],
                state ? L"disconnected" : L"connected");

        err = JetMove(sesid, sessdirtableid, JET_MoveNext, 0);
    }

    // Output Server Directory (we are reusing the rcSessDir structure).
    TSDISErrorOut(L"SERVER DIRECTORY\n");
    
    err = JetMove(sesid, servdirtableid, JET_MoveFirst, 0);
    if (JET_errNoCurrentRecord == err) {
        TSDISErrorOut(L" (empty database)\n");
    }

    while (JET_errNoCurrentRecord != err) {
        // Retrieve all the columns.
        memset(&rcSessDir[0], 0, sizeof(JET_RETRIEVECOLUMN) * 
                NUM_SERVDIRCOLUMNS);
        for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
            rcSessDir[count].columnid = servdircolumnid[count];
            rcSessDir[count].pvData = &num_vals[count];
            rcSessDir[count].cbData = sizeof(long);
            rcSessDir[count].itagSequence = 1;
        }
        rcSessDir[SERVDIR_SERVADDR_INTERNAL_INDEX].pvData = ServerNameBuf;
        rcSessDir[SERVDIR_SERVADDR_INTERNAL_INDEX].cbData = 
                sizeof(ServerNameBuf);
        rcSessDir[SERVDIR_SERVDNSNAME_INTERNAL_INDEX].pvData = ServerDNSNameBuf;
        rcSessDir[SERVDIR_SERVDNSNAME_INTERNAL_INDEX].cbData = 
                sizeof(ServerDNSNameBuf);
        rcSessDir[SERVDIR_SINGLESESS_INTERNAL_INDEX].pvData = &SingleSessMode;
        rcSessDir[SERVDIR_SINGLESESS_INTERNAL_INDEX].cbData = sizeof(SingleSessMode);


        CALL(JetRetrieveColumns(sesid, servdirtableid, &rcSessDir[0],
                NUM_SERVDIRCOLUMNS));

        TSDISErrorOut(L"%d, %s, %d, %d, %d, %d, %s\n", num_vals[
                SERVDIR_SERVID_INTERNAL_INDEX], ServerNameBuf, num_vals[
                SERVDIR_CLUSID_INTERNAL_INDEX], num_vals[
                SERVDIR_AITLOW_INTERNAL_INDEX], num_vals[
                SERVDIR_AITHIGH_INTERNAL_INDEX], num_vals[
                SERVDIR_NUMFAILPINGS_INTERNAL_INDEX], SingleSessMode ? 
                L"single session mode" : L"multi-session mode");

        err = JetMove(sesid, servdirtableid, JET_MoveNext, 0);
   
    }


    // Output Cluster Directory
    TSDISErrorOut(L"CLUSTER DIRECTORY\n");

    err = JetMove(sesid, clusdirtableid, JET_MoveFirst, 0);
    if (JET_errNoCurrentRecord == err) {
        TSDISErrorOut(L" (empty database)\n");
    }

    while (JET_errNoCurrentRecord != err) {
        memset(&rcSessDir[0], 0, sizeof(JET_RETRIEVECOLUMN) * 
                NUM_CLUSDIRCOLUMNS);
        for (count = 0; count < NUM_CLUSDIRCOLUMNS; count++) {
            rcSessDir[count].columnid = clusdircolumnid[count];
            rcSessDir[count].pvData = &num_vals[count];
            rcSessDir[count].cbData = sizeof(long);
            rcSessDir[count].itagSequence = 1;
        }
        rcSessDir[CLUSDIR_CLUSNAME_INTERNAL_INDEX].pvData = ClusterNameBuf;
        rcSessDir[CLUSDIR_CLUSNAME_INTERNAL_INDEX].cbData = 
                sizeof(ClusterNameBuf);
        rcSessDir[CLUSDIR_SINGLESESS_INTERNAL_INDEX].pvData = &SingleSessMode;
        rcSessDir[CLUSDIR_SINGLESESS_INTERNAL_INDEX].cbData = 
                sizeof(SingleSessMode);

        CALL(JetRetrieveColumns(sesid, clusdirtableid, &rcSessDir[0],
                NUM_CLUSDIRCOLUMNS));

        TSDISErrorOut(L"%d, %s, %s\n", num_vals[CLUSDIR_CLUSID_INTERNAL_INDEX],
                ClusterNameBuf, SingleSessMode ? L"single session mode" : 
                L"multi-session mode");

        err = JetMove(sesid, clusdirtableid, JET_MoveNext, 0);
    }

    TSDISErrorOut(L"\n");

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
}
#endif //DBG


typedef DWORD CLIENTINFO;

long 
DeleteExistingServerSession(
    JET_SESID   sesid,
    JET_TABLEID sessdirtableid,
    CLIENTINFO *pCI, 
    DWORD SessionID
    )
/*++


--*/
{
    JET_ERR err = JET_errSuccess;
    DWORD dwNumRecordDeleted = 0;

    TSDISErrorOut(L"In DeleteExistingServerSession, ServID=%d, "
            L"SessID=%d\n", *pCI, SessionID);

    ASSERT( (sesid != JET_sesidNil), (TB, "Invalid JETBLUE Session...") );
    
    // Delete all sessions in session directory that have this Server ID/Session ID
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "primaryIndex"));
    CALL(JetMakeKey(sesid, sessdirtableid, pCI, sizeof(*pCI), JET_bitNewKey));
    CALL(JetMakeKey(sesid, sessdirtableid, &SessionID, sizeof(SessionID), 0));

    err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange);

    while ( JET_errSuccess == err ) {

        // TODO - check build, retrieve server id and session Id, assert if not equal to what
        // we looking for
        CALL(JetDelete(sesid, sessdirtableid));
        dwNumRecordDeleted++;

        // Move to the next matching record.
        err = JetMove(sesid, sessdirtableid, JET_MoveNext, 0);
    }

    ASSERT( (dwNumRecordDeleted < 2), (TB, "Delete %d record...", dwNumRecordDeleted) );

    TSDISErrorOut(L"Deleted %d for ServID=%d, "
            L"SessID=%d\n", dwNumRecordDeleted, *pCI, SessionID);

    return dwNumRecordDeleted;

HandleError:

    // the only way to come here is error in one of Jet call wrap around CALL.
    ASSERT( (err == JET_errSuccess), (TB, "Error in DeleteExistingServerSession %d", err) );
   
    return -1;
}

/****************************************************************************/
// SDRPCAccessCheck
//
// Check if this RPC caller havs access right or not
/****************************************************************************/
RPC_STATUS RPC_ENTRY SDRPCAccessCheck(RPC_IF_HANDLE idIF, void *Binding)
{
    RPC_STATUS rpcStatus, rc;
    HANDLE hClientToken = NULL;
    DWORD Error;
    BOOL AccessStatus = FALSE;
    RPC_AUTHZ_HANDLE hPrivs;
    DWORD dwAuthn;
    RPC_BINDING_HANDLE ServerBinding = 0;
    WCHAR *StringBinding = NULL;
    WCHAR *ServerAddress = NULL;

    idIF;

    if (RpcBindingServerFromClient(Binding, &ServerBinding) != RPC_S_OK) {
        TSDISErrorOut(L"In SDRPCAccessCheck: BindingServerFromClient failed!\n");
        goto HandleError;
    }
    if (RpcBindingToStringBinding(ServerBinding, &StringBinding) != RPC_S_OK) {
        TSDISErrorOut(L"In SDRPCAccessCheck: BindingToStringBinding failed!\n");
        goto HandleError;
    }
    if (RpcStringBindingParse(StringBinding, NULL, NULL, &ServerAddress, NULL, 
            NULL) != RPC_S_OK) {
        TSDISErrorOut(L"In SDRPCAccessCheck: StringBindingParse failed!\n");
        goto HandleError;
    } 

    // Check if the client uses the protocol sequence we expect
    if (!CheckRPCClientProtoSeq(Binding, L"ncacn_ip_tcp")) {
        TSDISErrorOut(L"In SDRPCAccessCheck: Client doesn't use the tcpip protocol sequence\n");
        goto HandleError;
    }

    // Check what security level the client uses
    rpcStatus = RpcBindingInqAuthClient(Binding,
                                        &hPrivs,
                                        NULL,
                                        &dwAuthn,
                                        NULL,
                                        NULL);
    if (rpcStatus != RPC_S_OK) {
        TSDISErrorOut(L"In SDRPCAccessCheck: RpcBindingIngAuthClient fails with %u\n", rpcStatus);
        goto HandleError;
    }
    // We request at least privacy-level authentication
    if (dwAuthn < RPC_C_AUTHN_LEVEL_PKT_PRIVACY) {
        TSDISErrorOut(L"In SDRPCAccessCheck: Attemp by client to use weak authentication\n");
        goto HandleError;
    }
    
    // Check the access right of this rpc call
    rpcStatus = RpcImpersonateClient(Binding);   
    if (RPC_S_OK != rpcStatus) {
        TSDISErrorOut(L"In SDRPCAccessCheck: RpcImpersonateClient fail with %u\n", rpcStatus);
        goto HandleError;
    }
    // get our impersonated token
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hClientToken)) {
        Error = GetLastError();
        TSDISErrorOut(L"In SDRPCAccessCheck: OpenThreadToken Error %u\n", Error);
        RpcRevertToSelf();
        goto HandleError;
    }
    RpcRevertToSelf();
    
    if (!CheckTokenMembership(hClientToken,
                              g_pSid,
                              &AccessStatus)) {
        AccessStatus = FALSE;
        Error = GetLastError();
        TSDISErrorOut(L"In SDRPCAccessCheck: CheckTokenMembership fails with %u\n", Error);
    }
    
HandleError:
    if (AccessStatus) {
        rc = RPC_S_OK;
    }
    else {
        if (ServerAddress) {
            TSDISErrorOut(L"In SDRPCAccessCheck: Unauthorized RPC call from server %s\n", ServerAddress);
            PostSessDirErrorMsgEvent(EVENT_FAIL_RPC_DENY_ACCESS, ServerAddress, EVENTLOG_ERROR_TYPE);
        }
        rc = ERROR_ACCESS_DENIED;
    }

    if (hClientToken != NULL) {
        CloseHandle(hClientToken);
    }
    if (ServerBinding != NULL)
        RpcBindingFree(&ServerBinding);
    if (StringBinding != NULL)
        RpcStringFree(&StringBinding);
    if (ServerAddress != NULL)
        RpcStringFree(&ServerAddress);

    return rc;
}

/****************************************************************************/
// TSSDRpcServerOnline
//
// Called for server-active indications on each cluster TS machine.
/****************************************************************************/
DWORD TSSDRpcServerOnline( 
        handle_t Binding,
        WCHAR __RPC_FAR *ClusterName,
        /* out */ HCLIENTINFO *hCI,
        DWORD SrvOnlineFlags,
        /* in, out */ WCHAR *ComputerName,
        /* in */ WCHAR *ServerIPAddr)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID clusdirtableid;
    JET_TABLEID servdirtableid;
    JET_SETCOLUMN scServDir[NUM_SERVDIRCOLUMNS];
    WCHAR *StringBinding = NULL;
    WCHAR *ServerAddress = NULL;
    RPC_BINDING_HANDLE ServerBinding = 0;
    unsigned long cbActual;
    long ClusterID;
    long ServerID = 0;
    long zero = 0;
    // The single session mode of this server.
    char SingleSession = (char) SrvOnlineFlags & SINGLE_SESSION_FLAG;
    char ClusSingleSessionMode;
    unsigned count;
    DWORD rc = (DWORD) E_FAIL;
    DWORD cchBuff;
    WCHAR ServerDNSName[SDNAMELENGTH];

    // "unreferenced" parameter (referenced by RPC)
    Binding;
    ServerIPAddr;

    TSDISErrorOut(L"In ServOnline, ClusterName=%s, SrvOnlineFlags=%u\n", 
            ClusterName, SrvOnlineFlags);
    // Make a copy of TS server DNS server name
    wcsncpy(ServerDNSName, ComputerName, SDNAMELENGTH);
    TSDISErrorOut(L"In ServOnline, the Server Name is %s\n", ServerDNSName);
    // Determine client address.
    if (RpcBindingServerFromClient(Binding, &ServerBinding) != RPC_S_OK) {
        TSDISErrorOut(L"ServOn: BindingServerFromClient failed!\n");
        goto HandleError;
    }
    if (RpcBindingToStringBinding(ServerBinding, &StringBinding) != RPC_S_OK) {
        TSDISErrorOut(L"ServOn: BindingToStringBinding failed!\n");
        goto HandleError;
    }
    if (RpcStringBindingParse(StringBinding, NULL, NULL, &ServerAddress, NULL, 
            NULL) != RPC_S_OK) {
        TSDISErrorOut(L"ServOn: StringBindingParse failed!\n");
        goto HandleError;
    }   

    //TSDISErrorOut(L"In ServOnline, ServerAddress is %s\n", 
    //        ServerAddress);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    // This server comes with NO_REPOPULATE_SESSION flag
    // We will reuse its info in the database
    if (SrvOnlineFlags & NO_REPOPULATE_SESSION) {
        CALL(JetBeginTransaction(sesid));

        CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServDNSNameIndex"));
        CALL(JetMakeKey(sesid, servdirtableid, ServerDNSName, (unsigned)
                (wcslen(ServerDNSName) + 1) * sizeof(WCHAR), JET_bitNewKey));
        err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ);
        if (JET_errSuccess == err) {
            CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVID_INTERNAL_INDEX], &ServerID, sizeof(ServerID), 
                    &cbActual, 0, NULL));
            *hCI = ULongToPtr(ServerID);
            TSDISErrorOut(L"In ServOnline, ServerID is %d\n", *hCI);
        } else {
            // If we can't find this server, fail ServOnline call and server will rejoin SD
            TSDISErrorOut(L"ServOn: This server with no-populate flag can't be found\n");
            goto HandleError;
        }
        CALL(JetCommitTransaction(sesid, 0));

        goto NormalExit;
    }

    // First, delete all entries for this server from the session/server 
    //directories
    CALL(JetBeginTransaction(sesid));

    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServDNSNameIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, ServerDNSName, (unsigned)
            (wcslen(ServerDNSName) + 1) * sizeof(WCHAR), JET_bitNewKey));
    err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ);
    if (JET_errSuccess == err) {
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_SERVID_INTERNAL_INDEX], &ServerID, sizeof(ServerID), 
                &cbActual, 0, NULL));
        if (TSSDPurgeServer(ServerID) != 0)
            TSDISErrorOut(L"ServOn: PurgeServer %d failed.\n", ServerID);
    } else if (JET_errRecordNotFound != err) {
        CALL(err);
    }
    CALL(JetCommitTransaction(sesid, 0));

    // We have to do the add in a loop, because we have to:
    // 1) Check if the record is there.
    // 2) If it's not, add it.  (The next time through the loop, therefore,
    //    we'll go step 1->3, and we're done.)
    // 3) If it is, retrieve the value of clusterID and break out.
    //
    // There is an additional complication in that someone else may be in the
    // thread simultaneously, doing the same thing.  Therefore, someone might
    // be in step 2 and try to add a new cluster, but fail because someone
    // else added it.  So they have to keep trying, because though the other
    // thread has added it, it may not have committed the change.  To try to
    // keep that to a minimum, we sleep a short time before trying again.
    for ( ; ; ) {
        // Now do the actual add.
        CALL(JetBeginTransaction(sesid));

        // Search for the cluster in the cluster directory.
        CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusNameIndex"));
        CALL(JetMakeKey(sesid, clusdirtableid, ClusterName, (unsigned)
                (wcslen(ClusterName) + 1) * sizeof(WCHAR), JET_bitNewKey));
        err = JetSeek(sesid, clusdirtableid, JET_bitSeekEQ);

        // If the cluster does not exist, create it.
        if (JET_errRecordNotFound == err) {
            CALL(JetPrepareUpdate(sesid, clusdirtableid, JET_prepInsert));

            // ClusterName
            CALL(JetSetColumn(sesid, clusdirtableid, clusdircolumnid[
                    CLUSDIR_CLUSNAME_INTERNAL_INDEX], ClusterName, 
                    (unsigned) (wcslen(ClusterName) + 1) * sizeof(WCHAR), 0, 
                    NULL));

            // SingleSessionMode

            // Since this is the only server in the cluster, the single session
            // mode is simply the mode of this server.
            CALL(JetSetColumn(sesid, clusdirtableid, clusdircolumnid[
                    CLUSDIR_SINGLESESS_INTERNAL_INDEX], &SingleSession, 
                    sizeof(SingleSession), 0, NULL));
            
            err = JetUpdate(sesid, clusdirtableid, NULL, 0, &cbActual);

            // If it's a duplicate key, someone else made the key so we should
            // be ok.  Yield the processor and try the query again, next time
            // through the loop.
            if (JET_errKeyDuplicate == err) {
                CALL(JetCommitTransaction(sesid, 0));
                Sleep(100);
            }
            else {
                CALL(err);

                // Now we've succeeded.  Just continue through the loop.
                // The next time through, we will retrieve the autoincrement
                // column we just added and break out.
                CALL(JetCommitTransaction(sesid, 0));
            }

        }
        else {
            CALL(err);

            // If the above check makes it here, we have found the row.
            // Now retrieve the clusid, commit, and break out of the loop.
            CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
                    CLUSDIR_CLUSID_INTERNAL_INDEX], &ClusterID, 
                    sizeof(ClusterID), &cbActual, 0, NULL));

            CALL(JetCommitTransaction(sesid, 0));
            break;
            
        }
    }

    CALL(JetBeginTransaction(sesid));
    
    // Insert the servername, clusterid, 0, 0 into the server directory table
    err = JetMove(sesid, servdirtableid, JET_MoveLast, 0);

    CALL(JetPrepareUpdate(sesid, servdirtableid, JET_prepInsert));

    memset(&scServDir[0], 0, sizeof(JET_SETCOLUMN) * NUM_SERVDIRCOLUMNS);
    
    for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
        scServDir[count].columnid = servdircolumnid[count];
        scServDir[count].cbData = 4; // most of them, set the rest individually
        scServDir[count].itagSequence = 1;
    }
    scServDir[SERVDIR_SERVADDR_INTERNAL_INDEX].pvData = ServerAddress;
    scServDir[SERVDIR_SERVADDR_INTERNAL_INDEX].cbData = 
            (unsigned) (wcslen(ServerAddress) + 1) * sizeof(WCHAR);
    scServDir[SERVDIR_CLUSID_INTERNAL_INDEX].pvData = &ClusterID;
    scServDir[SERVDIR_AITLOW_INTERNAL_INDEX].pvData = &zero;
    scServDir[SERVDIR_AITHIGH_INTERNAL_INDEX].pvData = &zero;
    scServDir[SERVDIR_NUMFAILPINGS_INTERNAL_INDEX].pvData = &zero;
    scServDir[SERVDIR_SINGLESESS_INTERNAL_INDEX].pvData = &SingleSession;
    scServDir[SERVDIR_SINGLESESS_INTERNAL_INDEX].cbData = sizeof(SingleSession);
    scServDir[SERVDIR_SERVDNSNAME_INTERNAL_INDEX].pvData = ServerDNSName;
    scServDir[SERVDIR_SERVDNSNAME_INTERNAL_INDEX].cbData = 
            (unsigned) (wcslen(ServerDNSName) + 1) * sizeof(WCHAR);

    // Don't set the first column (index 0)--it is autoincrement.
    CALL(JetSetColumns(sesid, servdirtableid, &scServDir[
            SERVDIR_SERVADDR_INTERNAL_INDEX], NUM_SERVDIRCOLUMNS - 1));
    CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));

    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServNameIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, ServerAddress, (unsigned)
            (wcslen(ServerAddress) + 1) * sizeof(WCHAR), JET_bitNewKey));
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
            SERVDIR_SERVID_INTERNAL_INDEX], &ServerID, sizeof(ServerID), 
            &cbActual, 0, NULL));
    *hCI = ULongToPtr(ServerID);

    TSDISErrorOut(L"In ServOnline, ServerID is %d\n", *hCI);

    // Now that the server is all set up, we have to set the cluster to the
    // correct mode.  If any server in the cluster is in multisession mode, then
    // we stick with multisession.  If they are all single session, though, we
    // turn on single session in this cluster.  

    // Check the cluster to see if its single-session mode.
    CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusIDIndex"));
    CALL(JetMakeKey(sesid, clusdirtableid, (const void *)&ClusterID,
            sizeof(ClusterID), JET_bitNewKey));
    CALL(JetSeek(sesid, clusdirtableid, JET_bitSeekEQ));
    CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
            CLUSDIR_SINGLESESS_INTERNAL_INDEX], &ClusSingleSessionMode, sizeof(
            ClusSingleSessionMode), &cbActual, 0, NULL));

    // If the new server is multi-session mode and cluster is single-session, change the mode.
    if ((SingleSession == 0) && (ClusSingleSessionMode != SingleSession)) {
        err = JetPrepareUpdate(sesid, clusdirtableid, JET_prepReplace);

        if (JET_errWriteConflict == err) {
            // Another thread is updating this setting, so no need to update
        }
        else {
            CALL(err);

            CALL(JetSetColumn(sesid, clusdirtableid, clusdircolumnid[
                CLUSDIR_SINGLESESS_INTERNAL_INDEX], &SingleSession, 
                sizeof(SingleSession), 0, NULL));
            CALL(JetUpdate(sesid, clusdirtableid, NULL, 0, &cbActual));
        }
    }

    CALL(JetCommitTransaction(sesid, 0));

NormalExit:
    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    // Get the local computer name
    cchBuff = SDNAMELENGTH - 2;
    if (g_dwClusterState == ClusterStateRunning) {
        // return ClusterNetworkName as the computer name if it's 
        //  running on fail-over cluster
        wcsncpy(ComputerName, g_ClusterNetworkName, cchBuff);
    }
    else {
        if (!GetComputerNameEx(ComputerNamePhysicalNetBIOS, ComputerName, &cchBuff)) {
            TSDISErrorOut(L"GetComputerNameEx fails with 0x%x\n", GetLastError());
            goto HandleError;
        }
    }
    wcscat(ComputerName, L"$");

    if (ServerBinding != NULL)
        RpcBindingFree(&ServerBinding);
    if (StringBinding != NULL)
        RpcStringFree(&StringBinding);
    if (ServerAddress != NULL)
        RpcStringFree(&ServerAddress);

    

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    TSDISErrorOut(L"ERROR : ServOnline %s failed with possible error code %d, start TSSDPurgeServer\n", ComputerName, err);

    if (ServerBinding != NULL)
        RpcBindingFree(&ServerBinding);
    if (StringBinding != NULL)
        RpcStringFree(&StringBinding);
    if (ServerAddress != NULL)
        RpcStringFree(&ServerAddress);

    // Just in case we got to commit.
    if (ServerID != 0)
        TSSDPurgeServer(ServerID);

    // Close the context handle.
    *hCI = NULL;
    
    return rc;
}


/****************************************************************************/
// TSSDRpcServerOffline
//
// Called for server-shutdown indications on each cluster TS machine.
/****************************************************************************/
DWORD TSSDRpcServerOffline(
        handle_t Binding,
        HCLIENTINFO *hCI)
{
    DWORD retval = 0;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"WARNING: In ServOff, hCI = 0x%x\n", *hCI);
    
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;

    if (pCI != NULL)
        retval = TSSDPurgeServer(*pCI);

    *hCI = NULL;

    return retval;
}


/****************************************************************************/
// TSSDPurgeServer
//
// Delete a server and all its sessions from the session directory.
/****************************************************************************/
DWORD TSSDPurgeServer(
        DWORD ServerID)
{
    JET_SESID sesid = JET_sesidNil;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID clusdirtableid;
    JET_DBID dbid;
    JET_ERR err;
    long ClusterID;
    unsigned long cbActual;
    char MultiSession = 0;
    char SingleSessionMode;
    WCHAR Msg[SDNAMELENGTH * 2 + 3], ServerIP[SDNAMELENGTH];
    DWORD numSessionDeleted = 0;    // number of session deleted for this server
    BOOL bLoadServerIPSucceeeded = FALSE; // successful in loading serverip from table

    // initialize string for event log
    ZeroMemory( Msg, sizeof(Msg) );
    ZeroMemory( ServerIP, sizeof(ServerIP) );

    TSDISErrorOut(L"WARNING: In PurgeServer, ServerID=%d\n", ServerID);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));

    CALL(JetBeginTransaction(sesid));
    
    // Delete all sessions in session directory that have this serverid
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "ServerIndex"));
    CALL(JetMakeKey(sesid, sessdirtableid, &ServerID, sizeof(ServerID),
            JET_bitNewKey));
    err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ);

    while (0 == err) {
        CALL(JetDelete(sesid, sessdirtableid));

        numSessionDeleted++;
        CALL(JetMakeKey(sesid, sessdirtableid, &ServerID, sizeof(ServerID),
                JET_bitNewKey));
        err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ);
    }

    // Should be err -1601 -- JET_errRecordNotFound

    // Delete the server in the server directory with this serverid
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, &ServerID, sizeof(ServerID),
            JET_bitNewKey));
    err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ);
    if (JET_errSuccess == err) {
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_CLUSID_INTERNAL_INDEX], &ClusterID, 
                    sizeof(ClusterID), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SINGLESESS_INTERNAL_INDEX], &SingleSessionMode, 
                    sizeof(SingleSessionMode), &cbActual, 0, NULL));
        // Get the server DNS name and IP
        cbActual = SDNAMELENGTH * sizeof(WCHAR);
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVDNSNAME_INTERNAL_INDEX], Msg, 
                    cbActual, &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVADDR_INTERNAL_INDEX], ServerIP, 
                    sizeof(ServerIP), &cbActual, 0, NULL));

        bLoadServerIPSucceeeded = TRUE;

        CALL(JetDelete(sesid, servdirtableid));
        // If the server is the only one in cluster, delete this cluster in cluster directory
        CALL(JetSetCurrentIndex(sesid, servdirtableid, "ClusterIDIndex"));
        CALL(JetMakeKey(sesid, servdirtableid, &ClusterID, sizeof(ClusterID),
                JET_bitNewKey));
        err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ);
        if (JET_errRecordNotFound == err) {
            // There's no other server in this cluster, delete this cluster
        
            CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusIDIndex"));
            CALL(JetMakeKey(sesid, clusdirtableid, &ClusterID, sizeof(ClusterID), JET_bitNewKey));
            err = JetSeek(sesid, clusdirtableid, JET_bitSeekEQ);
            if (JET_errSuccess == err)
            {
                CALL(JetDelete(sesid, clusdirtableid));
            }
        }
        else {
            CALL(err);
            // Update the SingleSessionMode of the cluster
            // If server removed is SingleSession, the cluster single session mode won't be affected
            //  otherwise, seach the sever table for server in the cluster with multi-session mode
            //      if not found, change the cluster single-session mode to single-session, otherwise do nothing
            if (SingleSessionMode == 0) {
                CALL(JetSetCurrentIndex(sesid, servdirtableid, "SingleSessionIndex"));
                CALL(JetMakeKey(sesid, servdirtableid, &ClusterID, sizeof(ClusterID),
                    JET_bitNewKey));
                CALL(JetMakeKey(sesid, servdirtableid, &MultiSession, sizeof(MultiSession),
                    0));
                err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ);
                if (JET_errRecordNotFound == err) {
                    // Set the cluster single-session mode to True
                    SingleSessionMode = (char)1;
                    CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusIDIndex"));
                    CALL(JetMakeKey(sesid, clusdirtableid, &ClusterID, sizeof(ClusterID), JET_bitNewKey));
                    CALL(JetSeek(sesid, clusdirtableid, JET_bitSeekEQ));

                    CALL(JetPrepareUpdate(sesid, clusdirtableid, JET_prepReplace));
                    CALL(JetSetColumn(sesid, clusdirtableid, clusdircolumnid[
                            CLUSDIR_SINGLESESS_INTERNAL_INDEX], &SingleSessionMode, sizeof(SingleSessionMode), 0, NULL));
                    CALL(JetUpdate(sesid, clusdirtableid, NULL, 0, &cbActual));
                }
            }
        }
    }

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, sessdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    // we don't want to log event if we can't load serverIP from table.
    if( bLoadServerIPSucceeeded ) 
    {
        // Construct log msg to record TS leaving SD
        wcscat(Msg, L"(");
        wcsncat(Msg, ServerIP, SDNAMELENGTH);
        wcscat(Msg, L")");
        PostSessDirErrorMsgEvent(EVENT_SUCCESS_LEAVE_SESSIONDIRECTORY, Msg, EVENTLOG_SUCCESS);
    }
    else
    {
        TSDISErrorOut(L"WARNING: In PurgeServer() deleted %d "
                      L"sessions for ServerID=%d but failed to load IP\n", numSessionDeleted, ServerID);
    }
    
    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return (DWORD) E_FAIL;
}


/****************************************************************************/
// TSSDRpcGetUserDisconnectedSessions
//
// Queries disconnected sessions from the session database.
/****************************************************************************/
DWORD TSSDRpcGetUserDisconnectedSessions(
        handle_t Binding,
        HCLIENTINFO *hCI,
        WCHAR __RPC_FAR *UserName,
        WCHAR __RPC_FAR *Domain,
        /* out */ DWORD __RPC_FAR *pNumSessions,
        /* out */ TSSD_DiscSessInfo __RPC_FAR __RPC_FAR **padsi)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID clusdirtableid;
    *pNumSessions = 0;
    unsigned i = 0;
    unsigned j = 0;
    unsigned long cbActual;
    DWORD tempClusterID;
    DWORD CallingServersClusID;
    long ServerID;
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;
    TSSD_DiscSessInfo *adsi = NULL;
    char one = 1;
    char bSingleSession = 0;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In GetUserDiscSess: ServID = %d, User: %s, "
            L"Domain: %s\n", *pCI, UserName, Domain);

    *padsi = (TSSD_DiscSessInfo *) MIDL_user_allocate(sizeof(TSSD_DiscSessInfo) * 
            TSSD_MaxDisconnectedSessions);

    adsi = *padsi;

    if (adsi == NULL) {
        TSDISErrorOut(L"GetUserDisc: Memory alloc failed!\n");
        goto HandleError;
    }
    
    // Set the pointers to 0 to be safe, and so that we can free uninitialized
    // ones later without AVing.
    for (j = 0; j < TSSD_MaxDisconnectedSessions; j++) {
        adsi[j].ServerAddress = NULL;
        adsi[j].AppType = NULL;
    }
    
    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0,
            &clusdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }
    
    // First, get the cluster ID for the server making the query.
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, (const void *)pCI, sizeof(DWORD),
            JET_bitNewKey));
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
            SERVDIR_CLUSID_INTERNAL_INDEX], &CallingServersClusID, sizeof(
            CallingServersClusID), &cbActual, 0, NULL));

    // Now that we have the cluster id, check to see whether this cluster
    // is in single session mode.
    CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusIDIndex"));
    CALL(JetMakeKey(sesid, clusdirtableid, (const void *)&CallingServersClusID,
            sizeof(CallingServersClusID), JET_bitNewKey));
    CALL(JetSeek(sesid, clusdirtableid, JET_bitSeekEQ));
    CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
            CLUSDIR_SINGLESESS_INTERNAL_INDEX], &bSingleSession, sizeof(
            bSingleSession), &cbActual, 0, NULL));

    // Now, get all the disconnected or all sessions for this cluster, depending
    // on the single session mode retrieved above.
    if (bSingleSession == FALSE) {
        CALL(JetSetCurrentIndex(sesid, sessdirtableid, "DiscSessionIndex"));

        CALL(JetMakeKey(sesid, sessdirtableid, UserName, (unsigned)
                (wcslen(UserName) + 1) * sizeof(WCHAR), JET_bitNewKey));
        CALL(JetMakeKey(sesid, sessdirtableid, Domain, (unsigned)
                (wcslen(Domain) + 1) * sizeof(WCHAR), 0));
        CALL(JetMakeKey(sesid, sessdirtableid, &one, sizeof(one), 0));
    }
    else {
        CALL(JetSetCurrentIndex(sesid, sessdirtableid, "AllSessionIndex"));

        CALL(JetMakeKey(sesid, sessdirtableid, UserName, (unsigned)
                (wcslen(UserName) + 1) * sizeof(WCHAR), JET_bitNewKey));
        CALL(JetMakeKey(sesid, sessdirtableid, Domain, (unsigned)
                (wcslen(Domain) + 1) * sizeof(WCHAR), 0));
    }

    err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange);

    while ((i < TSSD_MaxDisconnectedSessions) && (JET_errSuccess == err)) {
        // Remember the initial retrieval does not have cluster id in the 
        // index, so filter by cluster id for each one.

        // Get the ServerID for this record.
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                SESSDIR_SERVERID_INTERNAL_INDEX], &ServerID, sizeof(ServerID), 
                &cbActual, 0, NULL));

        // Get the clusterID
        CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
        CALL(JetMakeKey(sesid, servdirtableid, &ServerID, sizeof(ServerID),
                JET_bitNewKey));
        CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_CLUSID_INTERNAL_INDEX], &tempClusterID, 
                sizeof(tempClusterID), &cbActual, 0, NULL));

        // Compare to the passed-in cluster id.
        if (tempClusterID == CallingServersClusID) {
            // Allocate space.
            adsi[i].ServerAddress = (WCHAR *) MIDL_user_allocate(64 * 
                    sizeof(WCHAR));
            adsi[i].AppType = (WCHAR *) MIDL_user_allocate(256 * sizeof(WCHAR));

            if ((adsi[i].ServerAddress == NULL) || (adsi[i].AppType == NULL)) {
                TSDISErrorOut(L"GetUserDisc: Memory alloc failed!\n");
                goto HandleError;
            }
            
            // ServerAddress comes out of the server table
            CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVADDR_INTERNAL_INDEX], adsi[i].ServerAddress, 
                    128, &cbActual, 0, NULL));
            // The rest come out of the session directory
            // Session ID
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_SESSIONID_INTERNAL_INDEX], 
                    &(adsi[i].SessionID), sizeof(DWORD), &cbActual, 0, NULL));
            // TSProtocol
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_TSPROTOCOL_INTERNAL_INDEX], 
                    &(adsi[i].TSProtocol), sizeof(DWORD), &cbActual, 0, NULL));
            // Application Type
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_APPTYPE_INTERNAL_INDEX], 
                    adsi[i].AppType, 512, &cbActual, 0, NULL));
            // ResolutionWidth
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_RESWIDTH_INTERNAL_INDEX], 
                    &(adsi[i].ResolutionWidth), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // ResolutionHeight
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_RESHEIGHT_INTERNAL_INDEX], 
                    &(adsi[i].ResolutionHeight), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // Color Depth
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_COLORDEPTH_INTERNAL_INDEX], 
                    &(adsi[i].ColorDepth), sizeof(DWORD), &cbActual, 0, NULL));
            // CreateTimeLow
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_CTLOW_INTERNAL_INDEX], 
                    &(adsi[i].CreateTimeLow), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // CreateTimeHigh
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_CTHIGH_INTERNAL_INDEX], 
                    &(adsi[i].CreateTimeHigh), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // DisconnectTimeLow
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_DTLOW_INTERNAL_INDEX], 
                    &(adsi[i].DisconnectTimeLow), sizeof(DWORD), &cbActual, 0, 
                    NULL));
            // DisconnectTimeHigh
            CALL(JetRetrieveColumn(sesid, sessdirtableid, 
                    sesdircolumnid[SESSDIR_DTHIGH_INTERNAL_INDEX], 
                    &(adsi[i].DisconnectTimeHigh), sizeof(DWORD), &cbActual, 0,
                    NULL));
            // State
            // This is retrieving a byte that is 0xff or 0x0 into a DWORD
            // pointer.
            CALL(JetRetrieveColumn(sesid, sessdirtableid,
                    sesdircolumnid[SESSDIR_STATE_INTERNAL_INDEX],
                    &(adsi[i].State), sizeof(BYTE), &cbActual, 0,
                    NULL));

            i += 1;
        }

        // Move to the next matching record.
        err = JetMove(sesid, sessdirtableid, JET_MoveNext, 0);
    }

    *pNumSessions = i;
    
    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

#ifdef DBG
    OutputAllTables();
#endif // DBG

    return 0;

HandleError:
    // Deallocate memory.
    if (adsi != NULL) {
        for (j = 0; j < TSSD_MaxDisconnectedSessions; j++) {
            if (adsi[j].ServerAddress)
                MIDL_user_free(adsi[j].ServerAddress);
            if (adsi[j].AppType)
                MIDL_user_free(adsi[j].AppType);
        }
    }
    
    // Can't really recover.  Just bail out.
    if (sesid != JET_sesidNil) {
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed.
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    TSDISErrorOut(L"WARNING: TSSDRpcGetUserDisconnectedSessions() initiate TSSDPurgeServer()\n");

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;
    
    return (DWORD) E_FAIL;
}


/****************************************************************************/
// TSSDRpcCreateSession
//
// Called on a session logon.
/****************************************************************************/
DWORD TSSDRpcCreateSession( 
        handle_t Binding,
        HCLIENTINFO *hCI,
        WCHAR __RPC_FAR *UserName,
        WCHAR __RPC_FAR *Domain,
        DWORD SessionID,
        DWORD TSProtocol,
        WCHAR __RPC_FAR *AppType,
        DWORD ResolutionWidth,
        DWORD ResolutionHeight,
        DWORD ColorDepth,
        DWORD CreateTimeLow,
        DWORD CreateTimeHigh)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_SETCOLUMN scSessDir[NUM_SESSDIRCOLUMNS];
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;
    unsigned count;
    int zero = 0;
    unsigned long cbActual;
    char state = 0;
    long numDeletedSession = 0;

    // "unreferenced" parameter (referenced by RPC)
    Binding;


    TSDISErrorOut(L"Inside TSSDRpcCreateSession, ServID=%d, "
            L"UserName=%s, Domain=%s, SessID=%d, TSProt=%d, AppType=%s, "
            L"ResWidth=%d, ResHeight=%d, ColorDepth=%d\n", *pCI, UserName, 
            Domain, SessionID, TSProtocol, AppType, ResolutionWidth,
            ResolutionHeight, ColorDepth);
    TSDISErrorTimeOut(L" CreateTime=%s\n", CreateTimeLow, CreateTimeHigh);
    
    memset(&scSessDir[0], 0, sizeof(JET_SETCOLUMN) * NUM_SESSDIRCOLUMNS);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }

    numDeletedSession = DeleteExistingServerSession( sesid, sessdirtableid, pCI, SessionID );
    if( numDeletedSession < 0 ) {
        goto HandleError;
    }

    err = JetMove(sesid, sessdirtableid, JET_MoveLast, 0);

    CALL(JetPrepareUpdate(sesid, sessdirtableid, JET_prepInsert));

    for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
        scSessDir[count].columnid = sesdircolumnid[count];
        scSessDir[count].cbData = 4; // most of them, set the rest individually
        scSessDir[count].itagSequence = 1;
    }
    scSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].cbData = 
            (unsigned) (wcslen(UserName) + 1) * sizeof(WCHAR);
    scSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].cbData = 
            (unsigned) (wcslen(Domain) + 1) * sizeof(WCHAR);
    scSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].cbData = 
            (unsigned) (wcslen(AppType) + 1) * sizeof(WCHAR);
    scSessDir[SESSDIR_STATE_INTERNAL_INDEX].cbData = sizeof(char);

    scSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].pvData = UserName;
    scSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].pvData = Domain;
    scSessDir[SESSDIR_SERVERID_INTERNAL_INDEX].pvData = pCI;
    scSessDir[SESSDIR_SESSIONID_INTERNAL_INDEX].pvData = &SessionID;
    scSessDir[SESSDIR_TSPROTOCOL_INTERNAL_INDEX].pvData = &TSProtocol;
    scSessDir[SESSDIR_CTLOW_INTERNAL_INDEX].pvData = &CreateTimeLow;
    scSessDir[SESSDIR_CTHIGH_INTERNAL_INDEX].pvData = &CreateTimeHigh;
    scSessDir[SESSDIR_DTLOW_INTERNAL_INDEX].pvData = &zero;
    scSessDir[SESSDIR_DTHIGH_INTERNAL_INDEX].pvData = &zero;
    scSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].pvData = AppType;
    scSessDir[SESSDIR_RESWIDTH_INTERNAL_INDEX].pvData = &ResolutionWidth;
    scSessDir[SESSDIR_RESHEIGHT_INTERNAL_INDEX].pvData = &ResolutionHeight;
    scSessDir[SESSDIR_COLORDEPTH_INTERNAL_INDEX].pvData = &ColorDepth;
    scSessDir[SESSDIR_STATE_INTERNAL_INDEX].pvData = &state;

    CALL(JetSetColumns(sesid, sessdirtableid, scSessDir, NUM_SESSDIRCOLUMNS));
    CALL(JetUpdate(sesid, sessdirtableid, NULL, 0, &cbActual));
    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed.
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    TSDISErrorOut(L"WARNING: TSSDRpcCreateSession failed, start TSSDPurgeServer()\n");

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;
    
    return (DWORD) E_FAIL;
}


/****************************************************************************/
// TSSDRpcDeleteSession
//
// Called on a session logoff.
/****************************************************************************/
DWORD TSSDRpcDeleteSession(
        handle_t Binding,
        HCLIENTINFO *hCI, 
        DWORD SessionID)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In DelSession, ServID=%d, "
            L"SessID=%d\n", *pCI, SessionID);


    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }

    // Delete all sessions in session directory that have this serverid
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "primaryIndex"));
    CALL(JetMakeKey(sesid, sessdirtableid, pCI, 
            sizeof(*pCI), JET_bitNewKey));
    CALL(JetMakeKey(sesid, sessdirtableid, &SessionID, sizeof(SessionID),
            0));

    CALL(JetSeek(sesid, sessdirtableid, JET_bitSeekEQ));

    CALL(JetDelete(sesid, sessdirtableid));

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed.
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    TSDISErrorOut(L"WARNING: DelSession can't find ServID=%d SessID=%d, start TSSDPurgeServer()\n", *pCI, SessionID);

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;
    
    return (DWORD) E_FAIL;
}


/****************************************************************************/
// TSSDRpcSetSessionDisconnected
//
// Called on a session disconnection.
/****************************************************************************/
DWORD TSSDRpcSetSessionDisconnected( 
        handle_t Binding,
        HCLIENTINFO *hCI,
        DWORD SessionID,
        DWORD DiscTimeLow,
        DWORD DiscTimeHigh)
{
    unsigned long cbActual;
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;
    char one = 1;
    DWORD rc = (DWORD) E_FAIL;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In SetSessDisc, ServID=%d, SessID=%d\n", *pCI, SessionID);
    TSDISErrorTimeOut(L" DiscTime=%s\n", DiscTimeLow, DiscTimeHigh);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "primaryIndex"));
    
    // find the record with the serverid, sessionid we are looking for
    CALL(JetMakeKey(sesid, sessdirtableid, pCI, sizeof(DWORD), 
            JET_bitNewKey));
    CALL(JetMakeKey(sesid, sessdirtableid, &SessionID, sizeof(DWORD), 0));

    CALL(JetSeek(sesid, sessdirtableid, JET_bitSeekEQ));

    CALL(JetPrepareUpdate(sesid, sessdirtableid, JET_prepReplace));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_STATE_INTERNAL_INDEX], &one, sizeof(one), 0, NULL));
    CALL(JetUpdate(sesid, sessdirtableid, NULL, 0, &cbActual));

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = 0;
    return rc;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    TSDISErrorOut(L"WARNING: SetSessDisc can't find ServID=%d SessID=%d, start TSSDPurgeServer()\n", *pCI, SessionID);

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;

    return rc;
}


/****************************************************************************/
// TSSDRpcSetSessionReconnected
//
// Called on a session reconnection.
/****************************************************************************/
DWORD TSSDRpcSetSessionReconnected(
        handle_t Binding,
        HCLIENTINFO *hCI,
        DWORD SessionID,
        DWORD TSProtocol,
        DWORD ResWidth,
        DWORD ResHeight,
        DWORD ColorDepth)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;
    DWORD rc = (DWORD) E_FAIL;

    char zero = 0;
    unsigned long cbActual;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"In SetSessRec, ServID=%d, SessID=%d, TSProt=%d, "
            L"ResWid=%d, ResHt=%d, ColDepth=%d\n", *pCI, 
            SessionID, TSProtocol, ResWidth, ResHeight,
            ColorDepth);


    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    
    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }

    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "primaryIndex"));
    
    // Find the record with the serverid, sessionid we are looking for.
    CALL(JetMakeKey(sesid, sessdirtableid, pCI, sizeof(DWORD), 
            JET_bitNewKey));
    CALL(JetMakeKey(sesid, sessdirtableid, &SessionID, sizeof(DWORD), 0));

    CALL(JetSeek(sesid, sessdirtableid, JET_bitSeekEQ));

    CALL(JetPrepareUpdate(sesid, sessdirtableid, JET_prepReplace));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_TSPROTOCOL_INTERNAL_INDEX], &TSProtocol, sizeof(TSProtocol),
            0, NULL));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_RESWIDTH_INTERNAL_INDEX], &ResWidth, sizeof(ResWidth), 
            0, NULL));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_RESHEIGHT_INTERNAL_INDEX], &ResHeight, sizeof(ResHeight), 
            0, NULL));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_COLORDEPTH_INTERNAL_INDEX], &ColorDepth, sizeof(ColorDepth),
            0, NULL));
    CALL(JetSetColumn(sesid, sessdirtableid, sesdircolumnid[
            SESSDIR_STATE_INTERNAL_INDEX], &zero, sizeof(zero), 0, NULL));
    CALL(JetUpdate(sesid, sessdirtableid, NULL, 0, &cbActual));
    
    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = 0;
    return rc;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed.
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    TSDISErrorOut(L"WARNING: SetSessRec can't find ServID=%d SessID=%d, start TSSDPurgeServer()\n", *pCI, SessionID);

    // Delete the server and close the context handle.  Their states are bad.
    TSSDPurgeServer(PtrToUlong(*hCI));
    *hCI = NULL;

    return rc;
}


DWORD TSSDRpcSetServerReconnectPending(
        handle_t Binding,
        WCHAR __RPC_FAR *ServerAddress,
        DWORD AlmostTimeLow,
        DWORD AlmostTimeHigh)
{
    // Ignored parameters
    Binding;
    AlmostTimeLow;
    AlmostTimeHigh;

    
    return TSSDSetServerAITInternal(ServerAddress, FALSE, NULL);
}


/****************************************************************************/
// TSSDRpcUpdateConfigurationSetting
//
// Extensible interface to update a configuration setting.
/****************************************************************************/
DWORD TSSDSetServerAddress(HCLIENTINFO *hCI, WCHAR *ServerName)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID servdirtableid;
    unsigned long cbActual;
    WCHAR Msg[SDNAMELENGTH * 2 + 3];
    DWORD rc = (DWORD) E_FAIL;

    TSDISErrorOut(L"INFO: TSSDSetServerAddress ServID=%d, %s\n", *hCI, ServerName);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    // Find the server in the server directory
    CALL(JetBeginTransaction(sesid));

    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, (const void *)hCI, sizeof(DWORD),
            JET_bitNewKey));
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));

    // Get the server DNS name
    cbActual = SDNAMELENGTH * sizeof(WCHAR);
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_SERVDNSNAME_INTERNAL_INDEX], Msg, 
                cbActual, &cbActual, 0, NULL));

    // Prepare to update.
    CALL(JetPrepareUpdate(sesid, servdirtableid, JET_prepReplace));

    // Now set the column to what we want
    CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_SERVADDR_INTERNAL_INDEX], (void *) ServerName, 
                (unsigned) (wcslen(ServerName) + 1) * sizeof(WCHAR), 0, 
                NULL));

    CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));


    CALL(JetCommitTransaction(sesid, 0));

    // Clean up.
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    // Construct log msg to record TS joining SD
    wcscat(Msg, L"(");
    wcsncat(Msg, ServerName, SDNAMELENGTH);
    wcscat(Msg, L")");
    PostSessDirErrorMsgEvent(EVENT_SUCCESS_JOIN_SESSIONDIRECTORY, Msg, EVENTLOG_SUCCESS);

    rc = 0;
    return rc;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    TSDISErrorOut(L"WARNING: TSSDSetServerAddress can't find ServID=%d, start TSSDPurgeServer()\n", *hCI);
    TSSDPurgeServer(PtrToUlong(*hCI));

    // Close the context handle.
    *hCI = NULL;

    return rc;
}


/****************************************************************************/
// TSSDRpcUpdateConfigurationSetting
//
// Extensible interface to update a configuration setting.
/****************************************************************************/
DWORD TSSDRpcUpdateConfigurationSetting(
        handle_t Binding,
        HCLIENTINFO *hCI,
        DWORD dwSetting,
        DWORD dwSettingLength,
        BYTE __RPC_FAR *pbValue)
{
    // Unreferenced parameters.
    Binding;
    hCI;
    dwSetting;
    dwSettingLength;
    pbValue;

    if (dwSetting == SDCONFIG_SERVER_ADDRESS) {
        TSDISErrorOut(L"Server is setting its address as %s\n", 
                (WCHAR *) pbValue);
        return TSSDSetServerAddress(hCI, (WCHAR *) pbValue);
    }
    
    return (DWORD) E_NOTIMPL;
}



/****************************************************************************/
// TSSDSetServerAITInternal
//
// Called on a client redirection from one server to another, to let the
// integrity service determine how to ping the redirection target machine.
//
// Args:
//  ServerAddress (in) - the server address to set values for
//  bResetToZero (in) - whether to reset all AIT values to 0
//  FailureCount (in/out) - Pointer to nonzero on entry means increment the 
//   failure count.  Returns the result failure count.
/****************************************************************************/
DWORD TSSDSetServerAITInternal( 
        WCHAR *ServerAddress,
        DWORD bResetToZero,
        DWORD *FailureCount)
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID servdirtableid;
    DWORD AITFromServDirLow;
    DWORD AITFromServDirHigh;
    unsigned long cbActual;
    DWORD rc = (DWORD) E_FAIL;

    TSDISErrorOut(L"SetServAITInternal: ServAddr=%s, bResetToZero=%d, bIncFail"
            L"=%d\n", ServerAddress, bResetToZero, (FailureCount == NULL) ? 
            0 : *FailureCount);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServNameIndex"));

    CALL(JetMakeKey(sesid, servdirtableid, ServerAddress, (unsigned)
            (wcslen(ServerAddress) + 1) * sizeof(WCHAR), JET_bitNewKey));

    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));

    // Algorithm for set reconnect pending:
    // 1) If server is not already pending a reconnect,
    // 2) Set the AlmostTimeLow and High to locally computed times (using
    //    the times from the wire is dangerous and requires clocks to be the
    //    same).

    // Retrieve the current values of AlmostInTimeLow and High
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
            SERVDIR_AITLOW_INTERNAL_INDEX], &AITFromServDirLow, 
            sizeof(AITFromServDirLow), &cbActual, 0, NULL));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
            SERVDIR_AITHIGH_INTERNAL_INDEX], &AITFromServDirHigh, 
            sizeof(AITFromServDirHigh), &cbActual, 0, NULL));


    // If it's time to reset, reset to 0.
    if (bResetToZero != 0) {
        DWORD zero = 0;
        
        CALL(JetPrepareUpdate(sesid, servdirtableid, JET_prepReplace));

        // Set the columns: Low, High, and NumFailedPings.
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_AITLOW_INTERNAL_INDEX], &zero, sizeof(zero), 0, NULL));
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_AITHIGH_INTERNAL_INDEX], &zero, sizeof(zero), 0, NULL));
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_NUMFAILPINGS_INTERNAL_INDEX], &zero, sizeof(zero), 0, 
                NULL));

        CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));
    }
    // Otherwise, if the server isn't already pending a reconnect,
    else if ((AITFromServDirLow == 0) && (AITFromServDirHigh == 0)) {
        FILETIME ft;
        SYSTEMTIME st;
        
        // Retrieve the time.
        GetSystemTime(&st);
        SystemTimeToFileTime(&st, &ft);

        err = JetPrepareUpdate(sesid, servdirtableid, JET_prepReplace);

        if (JET_errWriteConflict == err) {
            // If we are here, it's that more than two threads are updating the time 
            // field at the same time. Since we only need to update it once, so just
            // bail out the other ones, but still return success
            rc = 0;
            goto HandleError;
        }
        else {
            CALL(err);
        }

        // Set the columns.
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_AITLOW_INTERNAL_INDEX], &(ft.dwLowDateTime), 
                sizeof(ft.dwLowDateTime), 0, NULL));
        CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_AITHIGH_INTERNAL_INDEX], &(ft.dwHighDateTime), 
                sizeof(ft.dwHighDateTime), 0, NULL));

        CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));
    }
    // Else if we were told to increment the failure count
    else if (FailureCount != NULL) {
        if (*FailureCount != 0) {
            DWORD FailureCountFromServDir;

            // Get the current failure count.
            CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_NUMFAILPINGS_INTERNAL_INDEX], 
                    &FailureCountFromServDir, sizeof(FailureCountFromServDir), 
                    &cbActual, 0, NULL));

            // Set return value, also value used for update.
            *FailureCount = FailureCountFromServDir + 1;

            CALL(JetPrepareUpdate(sesid, servdirtableid, JET_prepReplace));
  
            // Set the column.
            CALL(JetSetColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_NUMFAILPINGS_INTERNAL_INDEX],
                    FailureCount, sizeof(*FailureCount), 0, NULL));
            CALL(JetUpdate(sesid, servdirtableid, NULL, 0, &cbActual));
            
        }
    }

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = 0;
    return rc;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    return rc;
}


DWORD TSSDRpcRepopulateAllSessions(
        handle_t Binding,
        HCLIENTINFO *hCI,
        DWORD NumSessions,
        TSSD_RepopInfo rpi[])
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_SETCOLUMN scSessDir[NUM_SESSDIRCOLUMNS];
    CLIENTINFO *pCI = (CLIENTINFO *) hCI;
    unsigned count; // inside each record
    unsigned iCurrSession;
    unsigned long cbActual;
    char State;
    DWORD rc = (DWORD) E_FAIL;
    long numDeletedSession = 0;

    // "unreferenced" parameter (referenced by RPC)
    Binding;

    TSDISErrorOut(L"RepopAllSess: ServID = %d, NumSessions = %d, ...\n",
            *pCI, NumSessions);
    
    memset(&scSessDir[0], 0, sizeof(JET_SETCOLUMN) * NUM_SESSDIRCOLUMNS);

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Verify that the ServerID passed in was OK.
    if (TSSDVerifyServerIDValid(sesid, servdirtableid, PtrToUlong(*hCI)) == FALSE) {
        TSDISErrorOut(L"Invalid ServerID was passed in\n");
        goto HandleError;
    }


    // Set up some constants for all updates.
    for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
        scSessDir[count].columnid = sesdircolumnid[count];
        scSessDir[count].cbData = 4; // most of them, set the rest individually
        scSessDir[count].itagSequence = 1;
    }
    scSessDir[SESSDIR_STATE_INTERNAL_INDEX].cbData = sizeof(char);

    // Now do each update in a loop.
    for (iCurrSession = 0; iCurrSession < NumSessions; iCurrSession += 1) {
        // make sure session does not exist at this point
        numDeletedSession = DeleteExistingServerSession( sesid, sessdirtableid, pCI, rpi[iCurrSession].SessionID );
        if( numDeletedSession < 0 ) {
            goto HandleError;
        }

        err = JetMove(sesid, sessdirtableid, JET_MoveLast, 0);

        CALL(JetPrepareUpdate(sesid, sessdirtableid, JET_prepInsert));

        TSDISErrorOut(L"RepopAllSess: ServID = %d, SessionId = %d, %s %s...\n",
                *pCI, 
                rpi[iCurrSession].SessionID,
                rpi[iCurrSession].UserName,
                rpi[iCurrSession].Domain
            );

        ASSERT( (wcslen(rpi[iCurrSession].UserName) > 0), (TB, "NULL User Name...") );
        ASSERT( (wcslen(rpi[iCurrSession].Domain) > 0), (TB, "NULL Domain Name...") );

        scSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].cbData = 
                (unsigned) (wcslen(rpi[iCurrSession].UserName) + 1) * 
                sizeof(WCHAR);
        scSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].cbData =
                (unsigned) (wcslen(rpi[iCurrSession].Domain) + 1) * 
                sizeof(WCHAR);
        scSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].cbData = 
                (unsigned) (wcslen(rpi[iCurrSession].AppType) + 1) * 
                sizeof(WCHAR);

        scSessDir[SESSDIR_USERNAME_INTERNAL_INDEX].pvData = 
                rpi[iCurrSession].UserName;
        scSessDir[SESSDIR_DOMAIN_INTERNAL_INDEX].pvData = 
                rpi[iCurrSession].Domain;
        scSessDir[SESSDIR_SERVERID_INTERNAL_INDEX].pvData = pCI;
        scSessDir[SESSDIR_SESSIONID_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].SessionID;
        scSessDir[SESSDIR_TSPROTOCOL_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].TSProtocol;
        scSessDir[SESSDIR_CTLOW_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].CreateTimeLow;
        scSessDir[SESSDIR_CTHIGH_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].CreateTimeHigh;
        scSessDir[SESSDIR_DTLOW_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].DisconnectTimeLow;
        scSessDir[SESSDIR_DTHIGH_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].DisconnectTimeHigh;
        scSessDir[SESSDIR_APPTYPE_INTERNAL_INDEX].pvData = 
                rpi[iCurrSession].AppType;
        scSessDir[SESSDIR_RESWIDTH_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].ResolutionWidth;
        scSessDir[SESSDIR_RESHEIGHT_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].ResolutionHeight;
        scSessDir[SESSDIR_COLORDEPTH_INTERNAL_INDEX].pvData = 
                &rpi[iCurrSession].ColorDepth;

        State = (char) rpi[iCurrSession].State;
        scSessDir[SESSDIR_STATE_INTERNAL_INDEX].pvData = &State;

        CALL(JetSetColumns(sesid, sessdirtableid, scSessDir, 
                NUM_SESSDIRCOLUMNS));
        CALL(JetUpdate(sesid, sessdirtableid, NULL, 0, &cbActual));
    }

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = 0;
    return rc;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    TSDISErrorOut(L"WARNING: TSSDRpcRepopulateAllSessions failed, ServID=%d\n", *pCI);
    return rc;
}


//
// RPC call that caller uses to see if it have access to Session Directory
//
DWORD TSSDRpcPingSD(handle_t Binding) 
{
    Binding;

    // RPC Security check is done at SDRPCAccessCheck() before this
    // function is hit, just return RPC_S_OK

    TRC1((TB,"Somebody calls pint sd"));
    return RPC_S_OK;
}

// Called to determine whether a ServerID passed in is valid.  TRUE if valid,
// FALSE otherwise.
// 
// Must be inside a transaction, and sesid and servdirtableid must be ready to 
// go.
BOOL TSSDVerifyServerIDValid(JET_SESID sesid, JET_TABLEID servdirtableid, 
        DWORD ServerID)
{
    JET_ERR err;
    
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, (const void *) &ServerID, 
            sizeof(DWORD), JET_bitNewKey));
    // If the ServerID is there, this will succeed, otherwise it will fail and
    // jump to HandleError.
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));

    return TRUE;

HandleError:
    return FALSE;
}

// Rundown procedure for when a CLIENTINFO is destroyed as a result of a
// connection loss or client termination.
void HCLIENTINFO_rundown(HCLIENTINFO hCI)
{
    CLIENTINFO CI = PtrToUlong(hCI);

    TSDISErrorOut(L"WARNING: In HCLIENTINFO_rundown: ServerID=%d\n", CI);

    if (CI != NULL)
        TSSDPurgeServer(CI);
    
    hCI = NULL;
}

#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\jetsdis.h ===
/****************************************************************************/
// Jet-Based Session Directory and Integrity Service, header file
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <esent.h>
#include <stdarg.h>
#include <clusapi.h>
#include <resapi.h>
#include <winioctl.h>
#include <basetsd.h>


#define NUM_SESSDIRCOLUMNS 14
#define NUM_SERVDIRCOLUMNS 8
#define NUM_CLUSDIRCOLUMNS 3

#define JETDISMAXSESSIONS 256
#define TSSD_MaxDisconnectedSessions 10

// NOTE: Change these both at the same time.  Also, if you change these,
// change the following two.
#define JETDISDBDIRECTORY ".\\tssesdir\\"
#define JETDISDBDIRECTORYW L".\\tssesdir\\"

// NOTE: Change these both at the same time.
#define JETDBFILENAME ".\\tssesdir\\tssesdir.edb"
#define JETDBFILENAMEW L".\\tssesdir\\tssesdir.edb"


// Auxiliary JET files for deletion when starting clean
#define JETAUXFILENAME1W L".\\tssesdir\\edb.chk"
#define JETAUXFILENAME2W L".\\tssesdir\\edb.log"
#define JETAUXFILENAME3W L".\\tssesdir\\res1.log"
#define JETAUXFILENAME4W L".\\tssesdir\\res2.log"
#define JETAUXFILENAME5W L".\\tssesdir\\tmp.edb"
#define JETAUXFILENAME6W L".\\tssesdir\\edbtmp.log"
#define JETLOGFILENAME L".\\tssesdir\\edb*.log"

#define JETTIMESTAMPFILEW L".\\tssesdir\\sddbtime.chk"

// "edbxxxxx.log" (with null terminator) is 13, but we also need the directory
// name.
#define MAX_LOGFILE_LENGTH 256


#define MAX_DEBUG_STRING_LENGTH 256

// "4294967295: " (no null required)
#define MAX_THREADIDSTR_LENGTH 12

#define MAX_DATE_TIME_STRING_LENGTH 64


#define CALL(x) { \
    err = x; \
    if (err != JET_errSuccess) { \
        TSDISErrorOut(L"TSSDIS: Jet error %d, line %d, file %S\n", err, __LINE__, \
                __FILE__); \
        goto HandleError; \
    } \
}


typedef struct _DIRCOLUMNS {
    char *szColumnName;
    JET_COLTYP coltyp;
    int colMaxLen;
} DIRCOLUMNS;


extern const DIRCOLUMNS SessionDirectoryColumns[];
extern const DIRCOLUMNS ServerDirectoryColumns[];
extern const DIRCOLUMNS ClusterDirectoryColumns[];

extern JET_COLUMNID sesdircolumnid[];
extern JET_COLUMNID servdircolumnid[];
extern JET_COLUMNID clusdircolumnid[];

extern JET_INSTANCE g_instance;

#define SESSDIR_USERNAME_INTERNAL_INDEX 0
#define SESSDIR_DOMAIN_INTERNAL_INDEX 1
#define SESSDIR_SERVERID_INTERNAL_INDEX 2
#define SESSDIR_SESSIONID_INTERNAL_INDEX 3
#define SESSDIR_TSPROTOCOL_INTERNAL_INDEX 4
#define SESSDIR_CTLOW_INTERNAL_INDEX 5
#define SESSDIR_CTHIGH_INTERNAL_INDEX 6
#define SESSDIR_DTLOW_INTERNAL_INDEX 7
#define SESSDIR_DTHIGH_INTERNAL_INDEX 8
#define SESSDIR_APPTYPE_INTERNAL_INDEX 9
#define SESSDIR_RESWIDTH_INTERNAL_INDEX 10
#define SESSDIR_RESHEIGHT_INTERNAL_INDEX 11
#define SESSDIR_COLORDEPTH_INTERNAL_INDEX 12
#define SESSDIR_STATE_INTERNAL_INDEX 13

#define SERVDIR_SERVID_INTERNAL_INDEX 0
#define SERVDIR_SERVADDR_INTERNAL_INDEX 1
#define SERVDIR_CLUSID_INTERNAL_INDEX 2
#define SERVDIR_AITLOW_INTERNAL_INDEX 3
#define SERVDIR_AITHIGH_INTERNAL_INDEX 4
#define SERVDIR_NUMFAILPINGS_INTERNAL_INDEX 5
#define SERVDIR_SINGLESESS_INTERNAL_INDEX 6
#define SERVDIR_SERVDNSNAME_INTERNAL_INDEX 7

#define CLUSDIR_CLUSID_INTERNAL_INDEX 0
#define CLUSDIR_CLUSNAME_INTERNAL_INDEX 1
#define CLUSDIR_SINGLESESS_INTERNAL_INDEX 2


void TSDISErrorOut(wchar_t *format_string, ...);
void TSDISErrorTimeOut(wchar_t *format_string, DWORD TimeLow, DWORD TimeHigh);
DWORD TSSDPurgeServer(DWORD ServerID);
BOOL TSSDVerifyServerIDValid(JET_SESID sesid, JET_TABLEID servdirtableid, 
        DWORD ServerID);
DWORD TSSDSetServerAITInternal(WCHAR *ServerAddress, DWORD bResetToZero, DWORD
        *FailureCount);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\sdqueryrpcfn.cpp ===
/****************************************************************************/
// sdqueryrpcfn.cpp
//
// TS Session Directory Query RPC server-side implementations.
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include "dis.h"
#include "tssdshrd.h"
#include "jetrpc.h"
#include "jetsdis.h"
#include "sdevent.h"

#pragma warning (push, 4)

#define TSSD_SERACH_MAX_RECORD 0xFFFFFFFF
#define TSSD_NameLength 128

extern PSID g_pAdminSid;

/****************************************************************************/
// SDQueryRPCAccessCheck
//
// Check if this SD Query RPC caller havs access right or not
// Access is given only to administrator using ncalrpc protocol
/****************************************************************************/
RPC_STATUS RPC_ENTRY SDQueryRPCAccessCheck(RPC_IF_HANDLE idIF, void *Binding)
{
    RPC_STATUS rpcStatus, rc;
    HANDLE hClientToken = NULL;
    DWORD Error;
    BOOL AccessStatus = FALSE;
    //RPC_AUTHZ_HANDLE hPrivs;
    //DWORD dwAuthn;

    idIF;

    if (NULL == g_pAdminSid) {
        goto HandleError;
    }

    // Check if the client uses the protocol sequence we expect
    if (!CheckRPCClientProtoSeq(Binding, L"ncalrpc")) {
        TSDISErrorOut(L"In SDQueryRPCAccessCheck: Client doesn't use the ncalrpc protocol sequence %u\n");
        goto HandleError;
    }
    
    // Check the access right of this rpc call
    rpcStatus = RpcImpersonateClient(Binding);   
    if (RPC_S_OK != rpcStatus) {
        TSDISErrorOut(L"In SDQueryRPCAccessCheck: RpcImpersonateClient fail with %u\n", rpcStatus);
        goto HandleError;
    }
    // get our impersonated token
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hClientToken)) {
        Error = GetLastError();
        TSDISErrorOut(L"In SDQueryRPCAccessCheck: OpenThreadToken Error %u\n", Error);
        RpcRevertToSelf();
        goto HandleError;
    }
    RpcRevertToSelf();
    
    if (!CheckTokenMembership(hClientToken,
                              g_pAdminSid,
                              &AccessStatus)) {
        AccessStatus = FALSE;
        Error = GetLastError();
        TSDISErrorOut(L"In SDQueryRPCAccessCheck: CheckTokenMembership fails with %u\n", Error);
    }
    
HandleError:
    if (AccessStatus) {
        rc = RPC_S_OK;
    }
    else {
        TSDISErrorOut(L"In SDQueryRPCAccessCheck: Unauthorized LPC call\n");
        rc = ERROR_ACCESS_DENIED;
    }

    if (hClientToken != NULL) {
        CloseHandle(hClientToken);
    }
    return rc;
}


// Query sessions for a username/domainname
DWORD TSSDRpcQuerySessionInfoByUserName( 
    /* [in] */ handle_t Binding,
    /* [in] */ WCHAR *UserName,
    /* [in] */ WCHAR *DomainName,
    /* [out] */ DWORD *pNumberOfSessions,
    /* [out] */ TSSD_SessionInfo __RPC_FAR __RPC_FAR **ppSessionInfo)
{
    Binding;
    TSSD_SessionInfo *pSessionInfo = NULL;
    DWORD rc = (DWORD) E_FAIL;
    JET_SESID sesid = JET_sesidNil;
    JET_TABLEID servdirtableid;
    JET_TABLEID sessdirtableid;
    JET_DBID dbid;
    JET_ERR err;
    unsigned long cbActual;
    long ServerID;
    DWORD i;
   
    *pNumberOfSessions = 0;
    *ppSessionInfo = NULL;

    TRC1((TB,"TSSDRpcQuerySessionInfoByUserName: Query for user: %S\\%S", DomainName, UserName));

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));

    CALL(JetBeginTransaction(sesid));

    // search the session table for DomainName/UserName
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "AllSessionIndex"));
    CALL(JetMakeKey(sesid, sessdirtableid, UserName, (unsigned)
                (wcslen(UserName) + 1) * sizeof(WCHAR), JET_bitNewKey));
    CALL(JetMakeKey(sesid, sessdirtableid, DomainName, (unsigned)
                (wcslen(DomainName) + 1) * sizeof(WCHAR), 0));
    err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange);
    if (err != JET_errSuccess) {
        TRC1((TB,"TSSDRpcQuerySessionInfoByUserName: Query for user: %S\\%S does not exist", DomainName, UserName));
        goto HandleError;
    }
    CALL(JetIndexRecordCount(sesid, sessdirtableid, pNumberOfSessions, TSSD_SERACH_MAX_RECORD)); 

    TRC1((TB, "Find %d session for this user", *pNumberOfSessions));
        
    *ppSessionInfo = (TSSD_SessionInfo *) MIDL_user_allocate(sizeof(TSSD_SessionInfo) * 
                        *pNumberOfSessions);
    pSessionInfo = *ppSessionInfo;
    if (pSessionInfo == NULL) {
        ERR((TB, "TSSDRpcQuerySessionInfoByUserName: Memory alloc failed!\n"));
        goto HandleError;
    }

    // retrieve the info for Sessions
    CALL(JetMove(sesid, sessdirtableid, JET_MoveFirst, 0));
    CALL(JetMakeKey(sesid, sessdirtableid, UserName, (unsigned)
                (wcslen(UserName) + 1) * sizeof(WCHAR), JET_bitNewKey));
    CALL(JetMakeKey(sesid, sessdirtableid, DomainName, (unsigned)
                (wcslen(DomainName) + 1) * sizeof(WCHAR), 0));
    CALL(JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange));

    for (i=0; i<*pNumberOfSessions; i++) {
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_SERVERID_INTERNAL_INDEX], &ServerID, 
                    sizeof(ServerID), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_USERNAME_INTERNAL_INDEX], pSessionInfo[i].UserName, 
                    sizeof(pSessionInfo[i].UserName), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_DOMAIN_INTERNAL_INDEX], pSessionInfo[i].DomainName, 
                    sizeof(pSessionInfo[i].DomainName), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_SESSIONID_INTERNAL_INDEX], &(pSessionInfo[i].SessionID), 
                    sizeof(pSessionInfo[i].SessionID), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_TSPROTOCOL_INTERNAL_INDEX], &(pSessionInfo[i].TSProtocol), 
                    sizeof(pSessionInfo[i].TSProtocol), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_APPTYPE_INTERNAL_INDEX], pSessionInfo[i].ApplicationType, 
                    sizeof(pSessionInfo[i].ApplicationType), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_RESWIDTH_INTERNAL_INDEX], &(pSessionInfo[i].ResolutionWidth), 
                    sizeof(pSessionInfo[i].ResolutionWidth), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_RESHEIGHT_INTERNAL_INDEX], &(pSessionInfo[i].ResolutionHeight), 
                    sizeof(pSessionInfo[i].ResolutionHeight), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_COLORDEPTH_INTERNAL_INDEX], &(pSessionInfo[i].ColorDepth), 
                    sizeof(pSessionInfo[i].ColorDepth), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_STATE_INTERNAL_INDEX], &(pSessionInfo[i].SessionState), 
                    sizeof(pSessionInfo[i].SessionState), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_CTLOW_INTERNAL_INDEX], &(pSessionInfo[i].CreateTime.dwLowDateTime), 
                    sizeof(pSessionInfo[i].CreateTime.dwLowDateTime), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_CTHIGH_INTERNAL_INDEX], &(pSessionInfo[i].CreateTime.dwHighDateTime), 
                    sizeof(pSessionInfo[i].CreateTime.dwHighDateTime), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_DTLOW_INTERNAL_INDEX], &(pSessionInfo[i].DisconnectTime.dwLowDateTime), 
                    sizeof(pSessionInfo[i].DisconnectTime.dwLowDateTime), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_DTHIGH_INTERNAL_INDEX], &(pSessionInfo[i].DisconnectTime.dwHighDateTime), 
                    sizeof(pSessionInfo[i].DisconnectTime.dwHighDateTime), &cbActual, 0, NULL));
        
        // Find the cluster name the server belongs to
        CALL(JetMove(sesid, servdirtableid, JET_MoveFirst, 0));
        CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerIDIndex"));
        CALL(JetMakeKey(sesid, servdirtableid, (const void *)&ServerID, sizeof(ServerID),
                    JET_bitNewKey));
        CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVDNSNAME_INTERNAL_INDEX], pSessionInfo[i].ServerName, 
                    sizeof(pSessionInfo[i].ServerName), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVADDR_INTERNAL_INDEX], pSessionInfo[i].ServerIPAddress, 
                    sizeof(pSessionInfo[i].ServerIPAddress), &cbActual, 0, NULL));

        if (i != *pNumberOfSessions -1) {
            CALL(JetMove(sesid, sessdirtableid, JET_MoveNext, 0));
        }
    }
    

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, sessdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));
    CALL(JetEndSession(sesid, 0));

    rc = (DWORD)RPC_S_OK;
HandleError:
    if ((sesid != JET_sesidNil) && (rc != 0)) {
        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return rc;
}

// Query for all sessions on a server
DWORD TSSDRpcQuerySessionInfoByServer( 
    /* [in] */ handle_t Binding,
    /* [in] */ WCHAR *ServerName,
    /* [out] */ DWORD *pNumberOfSessions,
    /* [out] */ TSSD_SessionInfo __RPC_FAR __RPC_FAR **ppSessionInfo)
{
    Binding;
    TSSD_SessionInfo *pSessionInfo = NULL;
    DWORD rc = (DWORD) E_FAIL;
    JET_SESID sesid = JET_sesidNil;
    JET_TABLEID servdirtableid;
    JET_TABLEID sessdirtableid;
    JET_DBID dbid;
    JET_ERR err;
    unsigned long cbActual;
    long ServerID;
    WCHAR ServerIPAddress[TSSD_NameLength];
    DWORD i;
   
    *pNumberOfSessions = 0;
    *ppSessionInfo = NULL;

    TRC1((TB,"TSSDRpcQuerySessionInfoByServer: Query for servername %S", ServerName));

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));

    CALL(JetBeginTransaction(sesid));

    // search the server table by the ServerName for SeverID
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServDNSNameIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, ServerName, (unsigned)
                (wcslen(ServerName) + 1) * sizeof(WCHAR), JET_bitNewKey));
    err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ);
    if (err != JET_errSuccess) {
        TRC1((TB,"TSSDRpcQuerySessionInfoByServer: Query for servername: %S does not exist", ServerName));
        goto HandleError;
    }

    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVID_INTERNAL_INDEX], &ServerID, 
                    sizeof(ServerID), &cbActual, 0, NULL));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVADDR_INTERNAL_INDEX], ServerIPAddress, 
                    sizeof(ServerIPAddress), &cbActual, 0, NULL));

    // search the sessions by this ServerID
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "ServerIndex"));
    CALL(JetMakeKey(sesid, sessdirtableid, &ServerID, sizeof(ServerID), JET_bitNewKey));
    err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange);
    if (err != JET_errSuccess) {
        TRC1((TB,"TSSDRpcQuerySessionInfoByServer: Query for servername: %S does not have any session", ServerName));
        goto HandleError;
    }

    CALL(JetIndexRecordCount(sesid, sessdirtableid, pNumberOfSessions, TSSD_SERACH_MAX_RECORD)); 

    TRC1((TB, "Find %d session for this user", *pNumberOfSessions));
        
    *ppSessionInfo = (TSSD_SessionInfo *) MIDL_user_allocate(sizeof(TSSD_SessionInfo) * 
                        *pNumberOfSessions);
    pSessionInfo = *ppSessionInfo;
    if (pSessionInfo == NULL) {
        ERR((TB, "TSSDRpcQuerySessionInfoByServer: Memory alloc failed!\n"));
        goto HandleError;
    }

    // retrieve the info for Sessions
    CALL(JetMove(sesid, sessdirtableid, JET_MoveFirst, 0));
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "ServerIndex"));
    CALL(JetMakeKey(sesid, sessdirtableid, &ServerID, sizeof(ServerID), JET_bitNewKey));
    CALL(JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange));

    for (i=0; i<*pNumberOfSessions; i++) {
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_SERVERID_INTERNAL_INDEX], &ServerID, 
                    sizeof(ServerID), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_USERNAME_INTERNAL_INDEX], pSessionInfo[i].UserName, 
                    sizeof(pSessionInfo[i].UserName), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_DOMAIN_INTERNAL_INDEX], pSessionInfo[i].DomainName, 
                    sizeof(pSessionInfo[i].DomainName), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_SESSIONID_INTERNAL_INDEX], &(pSessionInfo[i].SessionID), 
                    sizeof(pSessionInfo[i].SessionID), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_TSPROTOCOL_INTERNAL_INDEX], &(pSessionInfo[i].TSProtocol), 
                    sizeof(pSessionInfo[i].TSProtocol), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_APPTYPE_INTERNAL_INDEX], pSessionInfo[i].ApplicationType, 
                    sizeof(pSessionInfo[i].ApplicationType), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_RESWIDTH_INTERNAL_INDEX], &(pSessionInfo[i].ResolutionWidth), 
                    sizeof(pSessionInfo[i].ResolutionWidth), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_RESHEIGHT_INTERNAL_INDEX], &(pSessionInfo[i].ResolutionHeight), 
                    sizeof(pSessionInfo[i].ResolutionHeight), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_COLORDEPTH_INTERNAL_INDEX], &(pSessionInfo[i].ColorDepth), 
                    sizeof(pSessionInfo[i].ColorDepth), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_STATE_INTERNAL_INDEX], &(pSessionInfo[i].SessionState), 
                    sizeof(pSessionInfo[i].SessionState), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_CTLOW_INTERNAL_INDEX], &(pSessionInfo[i].CreateTime.dwLowDateTime), 
                    sizeof(pSessionInfo[i].CreateTime.dwLowDateTime), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_CTHIGH_INTERNAL_INDEX], &(pSessionInfo[i].CreateTime.dwHighDateTime), 
                    sizeof(pSessionInfo[i].CreateTime.dwHighDateTime), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_DTLOW_INTERNAL_INDEX], &(pSessionInfo[i].DisconnectTime.dwLowDateTime), 
                    sizeof(pSessionInfo[i].DisconnectTime.dwLowDateTime), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, sessdirtableid, sesdircolumnid[
                    SESSDIR_DTHIGH_INTERNAL_INDEX], &(pSessionInfo[i].DisconnectTime.dwHighDateTime), 
                    sizeof(pSessionInfo[i].DisconnectTime.dwHighDateTime), &cbActual, 0, NULL));
        
        wcsncpy(pSessionInfo[i].ServerName, ServerName, TSSD_NameLength);
        (pSessionInfo[i].ServerName)[TSSD_NameLength -1] = L'\0';
        wcsncpy(pSessionInfo[i].ServerIPAddress, ServerIPAddress, TSSD_NameLength);
        (pSessionInfo[i].ServerIPAddress)[TSSD_NameLength -1] = L'\0';

        if (i != *pNumberOfSessions -1) {
            CALL(JetMove(sesid, sessdirtableid, JET_MoveNext, 0));
        }
    }
    

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, sessdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = (DWORD)RPC_S_OK;
HandleError:
    if ((sesid != JET_sesidNil) && (rc != 0)) {
        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return rc;
}


// Query the server info by server name
DWORD TSSDRpcQueryServerByName( 
    /* [in] */ handle_t Binding,
    /* [in] */ WCHAR *ServerName,
    /* [out] */ DWORD *pNumberOfServers,
    /* [out] */ TSSD_ServerInfo __RPC_FAR __RPC_FAR **ppServerInfo)
{
    Binding;

    TSSD_ServerInfo *pServerInfo;
    DWORD rc = (DWORD) E_FAIL;
    JET_SESID sesid = JET_sesidNil;
    JET_TABLEID clusdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID sessdirtableid;
    JET_DBID dbid;
    JET_ERR err;
    unsigned long cbActual;
    long ServerID, ClusterID;
   
    *pNumberOfServers = 0;
    *ppServerInfo = NULL;
    pServerInfo = NULL;

    TRC1((TB,"TSSDRpcQueryServerByName: Query for Server Name: %S", ServerName));

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));

    CALL(JetBeginTransaction(sesid));

    // search the server table for ServerName
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServDNSNameIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, ServerName, (unsigned)
                (wcslen(ServerName) + 1) * sizeof(WCHAR), JET_bitNewKey));
    err = JetSeek(sesid, servdirtableid, JET_bitSeekEQ);
    if (err != JET_errSuccess) {
        TRC1((TB,"TSSDRpcQueryServerByName: Query for servername: %S does not exist", ServerName));
        goto HandleError;
    }
        
    *pNumberOfServers = 1;
    *ppServerInfo = (TSSD_ServerInfo *) MIDL_user_allocate(sizeof(TSSD_ServerInfo) * 
                        *pNumberOfServers);
    pServerInfo = *ppServerInfo;
    if (pServerInfo == NULL) {
        ERR((TB, "TSSDRpcQueryServerByName: Memory alloc failed!\n"));
        goto HandleError;
    }

    // retrive the info for ServerInfo
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_SERVID_INTERNAL_INDEX], &ServerID, 
                sizeof(ServerID), &cbActual, 0, NULL));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_CLUSID_INTERNAL_INDEX], &ClusterID, 
                sizeof(ClusterID), &cbActual, 0, NULL));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_SERVDNSNAME_INTERNAL_INDEX], pServerInfo->ServerName, 
                sizeof(pServerInfo->ServerName), &cbActual, 0, NULL));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_SERVADDR_INTERNAL_INDEX], pServerInfo->ServerIPAddress, 
                sizeof(pServerInfo->ServerIPAddress), &cbActual, 0, NULL));
    CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                SERVDIR_SINGLESESS_INTERNAL_INDEX], &(pServerInfo->SingleSessionMode), 
                sizeof(pServerInfo->SingleSessionMode), &cbActual, 0, NULL));
        
    // Find the session numbers in this server
    CALL(JetMove(sesid, sessdirtableid, JET_MoveFirst, 0));
    CALL(JetSetCurrentIndex(sesid, sessdirtableid, "ServerIndex"));
    CALL(JetMakeKey(sesid, sessdirtableid, (const void *)&ServerID, sizeof(ServerID),
                JET_bitNewKey));
    err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange);
    if (JET_errSuccess == err) {
        CALL(JetIndexRecordCount(sesid, sessdirtableid, &(pServerInfo->NumberOfSessions), TSSD_SERACH_MAX_RECORD));
    }
    else {
        // This server doesn't have any session
        pServerInfo->NumberOfSessions = 0;
    }
        
    TRC1((TB,"TSSDRpcQueryServerByName: Get SessionNum is %d", pServerInfo->NumberOfSessions));

    // Find the cluster name the server belongs to
    CALL(JetMove(sesid, clusdirtableid, JET_MoveFirst, 0));
    CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusIDIndex"));
    CALL(JetMakeKey(sesid, clusdirtableid, (const void *)&ClusterID, sizeof(ClusterID),
                JET_bitNewKey));
    CALL(JetSeek(sesid, clusdirtableid, JET_bitSeekEQ));
    CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
                CLUSDIR_CLUSNAME_INTERNAL_INDEX], pServerInfo->ClusterName, 
                sizeof(pServerInfo->ClusterName), &cbActual, 0, NULL));

    TRC1((TB,"TSSDRpcQueryServerByName: Get ClusterName is %S", pServerInfo->ClusterName));
    

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = (DWORD)RPC_S_OK;
HandleError:
    if ((sesid != JET_sesidNil) && (rc != 0)) {
        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return rc;
}


// Query info for all servers
DWORD TSSDRpcQueryAllServers( 
    /* [in] */ handle_t Binding,
    /* [out] */ DWORD *pNumberOfServers,
    /* [out] */ TSSD_ServerInfo __RPC_FAR __RPC_FAR **ppServerInfo)
{
    Binding;
    TSSD_ServerInfo *pServerInfo;
    DWORD rc = (DWORD) E_FAIL;
    JET_SESID sesid = JET_sesidNil;
    JET_TABLEID clusdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID sessdirtableid;
    JET_DBID dbid;
    JET_ERR err;
    unsigned long cbActual;
    long ServerID, ClusterID;
    DWORD i;
   
    *pNumberOfServers = 0;
    *ppServerInfo = NULL;
    pServerInfo = NULL;

    TRC1((TB,"TSSDRpcQueryAllServers"));

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));

    CALL(JetBeginTransaction(sesid));

    // Get the number of servers in server table
    err = JetMove(sesid, servdirtableid, JET_MoveFirst, 0);    
    if (err != JET_errSuccess) {
        TRC1((TB,"TSSDRpcQueryAllServers: Session directory does not have any servers in it"));
        goto HandleError;
    }
    CALL(JetIndexRecordCount(sesid, servdirtableid, pNumberOfServers, TSSD_SERACH_MAX_RECORD));
    TRC1((TB, "Number of Servers found is %d", *pNumberOfServers));
        
    *ppServerInfo = (TSSD_ServerInfo *) MIDL_user_allocate(sizeof(TSSD_ServerInfo) * 
                        *pNumberOfServers);
    pServerInfo = *ppServerInfo;
    if (pServerInfo == NULL) {
        ERR((TB, "TSSDRpcQueryAllServers: Memory alloc failed!\n"));
        goto HandleError;
    }

    // Get all the servers
    CALL(JetMove(sesid, servdirtableid, JET_MoveFirst, 0));

    for (i=0; i<*pNumberOfServers; i++) {
    
        // retrive the info for ServerInfo
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVID_INTERNAL_INDEX], &ServerID, 
                    sizeof(ServerID), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_CLUSID_INTERNAL_INDEX], &ClusterID, 
                    sizeof(ClusterID), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVDNSNAME_INTERNAL_INDEX], pServerInfo[i].ServerName, 
                    sizeof(pServerInfo[i].ServerName), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVADDR_INTERNAL_INDEX], pServerInfo[i].ServerIPAddress, 
                    sizeof(pServerInfo[i].ServerIPAddress), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SINGLESESS_INTERNAL_INDEX], &(pServerInfo[i].SingleSessionMode), 
                    sizeof(pServerInfo[i].SingleSessionMode), &cbActual, 0, NULL));
        
        // Find the session numbers in this server
        err = JetMove(sesid, sessdirtableid, JET_MoveFirst, 0);
        if (JET_errSuccess == err) {
            CALL(JetSetCurrentIndex(sesid, sessdirtableid, "ServerIndex"));
            CALL(JetMakeKey(sesid, sessdirtableid, (const void *)&ServerID, sizeof(ServerID),
                        JET_bitNewKey));
            err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange);
            if (JET_errSuccess == err) {
                CALL(JetIndexRecordCount(sesid, sessdirtableid, &(pServerInfo[i].NumberOfSessions), TSSD_SERACH_MAX_RECORD));
            }
            else {
                // This server doens't have any session
                pServerInfo[i].NumberOfSessions = 0;
            }
        }
        else {
            // Session table is empty
            pServerInfo[i].NumberOfSessions = 0;
        }
        
        TRC1((TB,"TSSDRpcQueryServersInCluster: Get SessionNum is %d", pServerInfo[i].NumberOfSessions));

        // Find the cluster name the server belongs to
        CALL(JetMove(sesid, clusdirtableid, JET_MoveFirst, 0));
        CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusIDIndex"));
        CALL(JetMakeKey(sesid, clusdirtableid, (const void *)&ClusterID, sizeof(ClusterID),
                    JET_bitNewKey));
        CALL(JetSeek(sesid, clusdirtableid, JET_bitSeekEQ));
        CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
                    CLUSDIR_CLUSNAME_INTERNAL_INDEX], pServerInfo[i].ClusterName, 
                    sizeof(pServerInfo[i].ClusterName), &cbActual, 0, NULL));

        if (i != *pNumberOfServers - 1) {
            CALL(JetMove(sesid, servdirtableid, JET_MoveNext, 0));
        }
    }    

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = (DWORD)RPC_S_OK;
HandleError:
    if ((sesid != JET_sesidNil) && (rc != 0)) {
        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return rc;
}

// Query all servers in the cluster by the cluster name
DWORD TSSDRpcQueryServersInCluster( 
    /* [in] */ handle_t Binding,
    /* [in] */ WCHAR *ClusterName,
    /* [out] */ DWORD *pNumberOfServers,
    /* [out] */ TSSD_ServerInfo __RPC_FAR __RPC_FAR **ppServerInfo)
{
    Binding;
    TSSD_ServerInfo *pServerInfo;
    DWORD rc = (DWORD) E_FAIL;
    JET_SESID sesid = JET_sesidNil;
    JET_TABLEID clusdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID sessdirtableid;
    JET_DBID dbid;
    JET_ERR err;
    unsigned long cbActual;
    long ServerID, ClusterID;
    DWORD i;
   
    *pNumberOfServers = 0;
    *ppServerInfo = NULL;
    pServerInfo = NULL;

    TRC1((TB,"TSSDRpcQueryServersInCluster: Query for Cluster Name: %S", ClusterName));

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));
    CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
            &sessdirtableid));

    CALL(JetBeginTransaction(sesid));

    // search the cluster table for ClusterName
    CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusNameIndex"));
    CALL(JetMakeKey(sesid, clusdirtableid, ClusterName, (unsigned)
                (wcslen(ClusterName) + 1) * sizeof(WCHAR), JET_bitNewKey));
    err = JetSeek(sesid, clusdirtableid, JET_bitSeekEQ);
    if (err != JET_errSuccess) {
        TRC1((TB,"TSSDRpcQueryServersInCluster: Clustername %S does not exist", ClusterName));
        goto HandleError;
    }
    
    CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
                CLUSDIR_CLUSID_INTERNAL_INDEX], &ClusterID, 
                sizeof(ClusterID), &cbActual, 0, NULL));


    // search the server table for ClusterID
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ClusterIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, &ClusterID, sizeof(ClusterID), JET_bitNewKey));
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange));
    CALL(JetIndexRecordCount(sesid, servdirtableid, pNumberOfServers, TSSD_SERACH_MAX_RECORD));
    TRC1((TB, "Number of Servers found is %d", *pNumberOfServers));
        
    *ppServerInfo = (TSSD_ServerInfo *) MIDL_user_allocate(sizeof(TSSD_ServerInfo) * 
                        *pNumberOfServers);
    pServerInfo = *ppServerInfo;
    if (pServerInfo == NULL) {
        ERR((TB, "TSSDRpcQueryServersInCluster: Memory alloc failed!\n"));
        goto HandleError;
    }

    // Get all the servers for this ClusterID
    CALL(JetMove(sesid, servdirtableid, JET_MoveFirst, 0));
    CALL(JetSetCurrentIndex(sesid, servdirtableid, "ClusterIDIndex"));
    CALL(JetMakeKey(sesid, servdirtableid, &ClusterID, sizeof(ClusterID), JET_bitNewKey));
    CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange));

    for (i=0; i<*pNumberOfServers; i++) {
    
        // retrive the info for ServerInfo
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVID_INTERNAL_INDEX], &ServerID, 
                    sizeof(ServerID), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVDNSNAME_INTERNAL_INDEX], pServerInfo[i].ServerName, 
                    sizeof(pServerInfo[i].ServerName), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SERVADDR_INTERNAL_INDEX], pServerInfo[i].ServerIPAddress, 
                    sizeof(pServerInfo[i].ServerIPAddress), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_SINGLESESS_INTERNAL_INDEX], &(pServerInfo[i].SingleSessionMode), 
                    sizeof(pServerInfo[i].SingleSessionMode), &cbActual, 0, NULL));
        wcsncpy(pServerInfo[i].ClusterName, ClusterName, TSSD_NameLength);
        (pServerInfo[i].ClusterName)[TSSD_NameLength - 1] = L'\0';
        
        // Find the session numbers for this server
        err = JetMove(sesid, sessdirtableid, JET_MoveFirst, 0);
        if (JET_errSuccess == err) {
            CALL(JetSetCurrentIndex(sesid, sessdirtableid, "ServerIndex"));
            CALL(JetMakeKey(sesid, sessdirtableid, (const void *)&ServerID, sizeof(ServerID),
                        JET_bitNewKey));
            err = JetSeek(sesid, sessdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange);
            if (JET_errSuccess == err) {
                CALL(JetIndexRecordCount(sesid, sessdirtableid, &(pServerInfo[i].NumberOfSessions), TSSD_SERACH_MAX_RECORD));
            }
            else {
                // This server doesn't have any sessions
                pServerInfo[i].NumberOfSessions = 0;
            }
        
            TRC1((TB,"TSSDRpcQueryServersInCluster: Get SessionNum is %d", pServerInfo[i].NumberOfSessions));
        }
        else {
            // Session table is empty
            pServerInfo[i].NumberOfSessions = 0;
        }

        if (i != *pNumberOfServers - 1) {
            CALL(JetMove(sesid, servdirtableid, JET_MoveNext, 0));
        }
    }    

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = (DWORD)RPC_S_OK;
HandleError:
    if ((sesid != JET_sesidNil) && (rc != 0)) {
        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return rc;
}


// Query the info for all cluster
DWORD TSSDRpcQueryAllClusterInfo( 
    /* [in] */ handle_t Binding,
    /* [out] */ DWORD __RPC_FAR *pNumberOfClusters,
    /* [out] */ TSSD_ClusterInfo __RPC_FAR __RPC_FAR **ppClusterInfo)
{
    Binding;
    pNumberOfClusters;

    TSSD_ClusterInfo *pClusterInfo;
    DWORD rc = (DWORD) E_FAIL;
    JET_SESID sesid = JET_sesidNil;
    JET_TABLEID clusdirtableid;
    JET_TABLEID servdirtableid;
    JET_DBID dbid;
    JET_ERR err;
    long *pClusterID = NULL;
    unsigned long cbActual;
    DWORD i;
   
    *pNumberOfClusters = 0;
    pClusterInfo = NULL;
    *ppClusterInfo = pClusterInfo;

    TRC1((TB,"TSSDRpcQueryAllClusterInfo"));

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // ClusterName is not specified
    // Get the ClusterID for all clusters
    err = JetMove(sesid, clusdirtableid, JET_MoveFirst, 0);
    if (err != JET_errSuccess) {
        TRC1((TB,"TSSDRpcQueryAllClusterInfo: Session Directory is empty"));
        goto HandleError;
    }

    CALL(JetIndexRecordCount(sesid, clusdirtableid, pNumberOfClusters, TSSD_SERACH_MAX_RECORD));
    pClusterID = (long *)LocalAlloc(LMEM_FIXED, *pNumberOfClusters * sizeof(long));
    if (pClusterID == NULL) {
        goto HandleError;
    }
    *ppClusterInfo = (TSSD_ClusterInfo *) MIDL_user_allocate(sizeof(TSSD_ClusterInfo) * 
                    *pNumberOfClusters);
    pClusterInfo = *ppClusterInfo;
    if (pClusterInfo == NULL) {
        TSDISErrorOut(L"TSSDRpcQueryClusterInfo: Memory alloc failed!\n");
        goto HandleError;
    }
    err = JetMove(sesid, clusdirtableid, JET_MoveFirst, 0);
    i = 0;
    while (err != JET_errNoCurrentRecord) {
        CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
            CLUSDIR_CLUSID_INTERNAL_INDEX], &pClusterID[i], 
            sizeof(pClusterID[i]), &cbActual, 0, NULL)); 
        CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
                CLUSDIR_CLUSNAME_INTERNAL_INDEX], pClusterInfo[i].ClusterName, 
                sizeof(pClusterInfo[i].ClusterName), &cbActual, 0, NULL));
        CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
                CLUSDIR_SINGLESESS_INTERNAL_INDEX], &(pClusterInfo[i].SingleSessionMode), 
                sizeof(pClusterInfo[i].SingleSessionMode), &cbActual, 0, NULL));
        err = JetMove(sesid, clusdirtableid, JET_MoveNext, 0);
        i++;
    }
    
    // Find the server numbers in this cluster
    for (i=0; i<*pNumberOfClusters; i++) {
        CALL(JetMove(sesid, servdirtableid, JET_MoveFirst, 0));
        CALL(JetSetCurrentIndex(sesid, servdirtableid, "ClusterIDIndex"));
        CALL(JetMakeKey(sesid, servdirtableid, (const void *)&pClusterID[i], sizeof(pClusterID[i]),
                JET_bitNewKey));
        CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange));

        CALL(JetIndexRecordCount(sesid, servdirtableid, &(pClusterInfo[i].NumberOfServers), TSSD_SERACH_MAX_RECORD));
        TRC1((TB,"TSSDRpcQueryClusterInfo: Get ServerNum is %d", pClusterInfo[0].NumberOfServers));
    }

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = (DWORD)RPC_S_OK;
HandleError:
    // Deallocate memory
    if (pClusterID != NULL) {
        LocalFree(pClusterID);
    }
    if ((sesid != JET_sesidNil) && (rc != 0)) {
        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return rc;
}


// Query the cluster info by the cluster name
DWORD TSSDRpcQueryClusterInfo( 
    /* [in] */ handle_t Binding,
    /*[in]  */ WCHAR __RPC_FAR *ClusterName,
    /* [out] */ DWORD __RPC_FAR *pNumberOfClusters,
    /* [out] */ TSSD_ClusterInfo __RPC_FAR __RPC_FAR **ppClusterInfo)
{
    Binding;

    TSSD_ClusterInfo *pClusterInfo;
    DWORD rc = (DWORD) E_FAIL;
    JET_SESID sesid = JET_sesidNil;
    JET_TABLEID clusdirtableid;
    JET_TABLEID servdirtableid;
    JET_DBID dbid;
    JET_ERR err;
    long *pClusterID = NULL;
    unsigned long cbActual;
    DWORD i;
   
    *pNumberOfClusters = 0;
    pClusterInfo = NULL;
    TRC1((TB,"Query for cluster Name: %S", ClusterName));

    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
            &clusdirtableid));
    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    // From the clustername find the clusterID
    CALL(JetSetCurrentIndex(sesid, clusdirtableid, "ClusNameIndex"));
    CALL(JetMakeKey(sesid, clusdirtableid, ClusterName, (unsigned)
            (wcslen(ClusterName) + 1) * sizeof(WCHAR), JET_bitNewKey));
    err = JetSeek(sesid, clusdirtableid, JET_bitSeekEQ);
    if (err != JET_errSuccess) {
        TRC1((TB,"TSSDRpcQueryClusterInfo: Clustername %S does not exist", ClusterName));
        goto HandleError;
    }
        
    *pNumberOfClusters = 1;

    pClusterID = (long *)LocalAlloc(LMEM_FIXED, *pNumberOfClusters * sizeof(long));
    if (pClusterID == NULL) {
        TSDISErrorOut(L"TSSDRpcQueryClusterInfo: Memory alloc failed!\n");
        goto HandleError;
    }
    *ppClusterInfo = (TSSD_ClusterInfo *) MIDL_user_allocate(sizeof(TSSD_ClusterInfo) * 
                    *pNumberOfClusters);
    pClusterInfo = *ppClusterInfo;
    if (pClusterInfo == NULL) {
        TSDISErrorOut(L"TSSDRpcQueryClusterInfo: Memory alloc failed!\n");
        goto HandleError;
    }
        
    CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
            CLUSDIR_CLUSID_INTERNAL_INDEX], &pClusterID[0], 
            sizeof(pClusterID[0]), &cbActual, 0, NULL));
    CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
            CLUSDIR_CLUSNAME_INTERNAL_INDEX], pClusterInfo[0].ClusterName, 
            sizeof(pClusterInfo[0].ClusterName), &cbActual, 0, NULL));
    TRC1((TB,"TSSDRpcQueryClusterInfo: Get cluster name %S", pClusterInfo[0].ClusterName));
    CALL(JetRetrieveColumn(sesid, clusdirtableid, clusdircolumnid[
            CLUSDIR_SINGLESESS_INTERNAL_INDEX], &(pClusterInfo[0].SingleSessionMode), 
            sizeof(pClusterInfo[0].SingleSessionMode), &cbActual, 0, NULL));
    
    // Find the server numbers in this cluster
    for (i=0; i<*pNumberOfClusters; i++) {
        CALL(JetMove(sesid, servdirtableid, JET_MoveFirst, 0));
        CALL(JetSetCurrentIndex(sesid, servdirtableid, "ClusterIDIndex"));
        CALL(JetMakeKey(sesid, servdirtableid, (const void *)&pClusterID[i], sizeof(pClusterID[i]),
                JET_bitNewKey));
        CALL(JetSeek(sesid, servdirtableid, JET_bitSeekEQ | JET_bitSetIndexRange));

        CALL(JetIndexRecordCount(sesid, servdirtableid, &(pClusterInfo[i].NumberOfServers), TSSD_SERACH_MAX_RECORD));
        TRC1((TB,"TSSDRpcQueryClusterInfo: Get ServerNum is %d", pClusterInfo[i].NumberOfServers));
    }

    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    rc = (DWORD)RPC_S_OK;
HandleError:
    // Deallocate memory
    if (pClusterID != NULL) {
        LocalFree(pClusterID);
    }
    if ((sesid != JET_sesidNil) && (rc != 0)) {
        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return rc;
}


#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\sdrpc-c.c ===
#include <sdrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\trace.h ===
/****************************************************************************/
// trace.h
//
// Tracing definitions. See trace.c for other information.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


#if DBG || defined(_DEBUG)

#include <stdio.h>


// Zones. Up to 32 zones can be defined, these are predefined for general use.
#define Z_ASSERT 0x01
#define Z_ERR    0x02
#define Z_WRN    0x04
#define Z_TRC1   0x08
#define Z_TRC2   0x10

// Defined in msmcs.c.
extern char TB[1024];
extern UINT32 g_TraceMask;
void TracePrintZ(UINT32, char *);

// Error, warning, trace level 1, and trace level 2 definitions.
#define ERR(X) TRCZ(Z_ERR, X)
#define WRN(X) TRCZ(Z_WRN, X)
#define TRC1(X) TRCZ(Z_TRC1, X)
#define TRC2(X) TRCZ(Z_TRC2, X)
#define ASSERT(COND, X) \
{  \
    if (!(COND)) { \
        TRCZ(Z_ASSERT, X); \
        DebugBreak(); \
    }  \
}

#define TRCZ(Z, X) \
{ \
    if (g_TraceMask & (Z)) { \
        sprintf X; \
        TracePrintZ((Z), TB); \
    } \
}


#else  // DBG

#define ERR(X)
#define WRN(X)
#define TRC1(X)
#define TRC2(X)
#define ASSERT(COND, X)

#endif  // DBG



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\trace.c ===
/****************************************************************************/
// trace.c
//
// Tracing code and definitions. See trace.h for other info.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#if DBG || defined(_DEBUG)

#include <windows.h>

#include "trace.h"


struct _ZoneInfo
{
    UINT32 Zone;
    char *Prefix;
} TRC_ZI[] =
{
    { Z_ASSERT, "DIS: !!! ASSERT: " },
    { Z_ERR,    "DIS: *** ERROR: " },
    { Z_WRN,    "DIS: Warning: " },
    { Z_TRC1,   "DIS: " },
    { Z_TRC2,   "DIS: " },
};
int NumTRC_ZIEntries = sizeof(TRC_ZI) / sizeof(struct _ZoneInfo);


// Globals.
UINT32 g_TraceMask = 0xFFFFFFFF;
char TB[1024];
char TB2[1024];


// Main output function.
void TracePrintZ(UINT32 ZoneFlag, char *OutString)
{
    int i;
    char *Prefix = "";

    // Find the zone information in the zone table.
    for (i = 0; i < NumTRC_ZIEntries; i++)
        if (TRC_ZI[i].Zone == ZoneFlag)
            Prefix = TRC_ZI[i].Prefix;

    // Now create the final string.
    wsprintfA(TB2, "%s%s\n", Prefix, OutString);

    // Send to output.
    OutputDebugStringA(TB2);
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sds.rc
//

#define IDS_SDLOCALGROUP_NAME           1024
#define IDS_SDLOCALGROUP_DES            1025
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\dis\tssdis.cpp ===
/****************************************************************************/
// Directory Integrity Service
//
// Copyright (C) 2000, Microsoft Corporation
/****************************************************************************/

#include "dis.h"
#include "jetrpc.h"
#include "jetsdis.h"
#include "sdevent.h"
#include "resource.h"
#include "tssdshrd.h"
#include "sdrpc.h"


#pragma warning (push, 4)

#define SERVER_ADDRESS_LENGTH 64
#define NUM_JETRPC_THREADS 10
#define MAX_DRIVE_LETTER_LENGTH 24
#define SD_QUERY_ENDPOINT_NAME L"TSSessionDirectoryQueryApi"
// Number of 100-nanosecond periods in 1 second.
#define FILETIME_INTERVAL_TO_SECONDS_MULTIPLIER 10000000

#define DEBUG_LOG_FILENAME L"tssdis.log"

#define REG_SESSION_DIRECTROY_CONTROL L"System\\CurrentControlSet\\Services\\Tssdis\\Parameters"

#define MAX_TSSERVERS_TO_RECOVER 0xFFFF
#define NO_RECOVER_WHEN_START 0
//do we recover previous jet database when starting SD
DWORD g_RecoverWhenStart = 1; 
//  if asking TS to repopulate session when it rejoins
//  RepoluateSession is set to FALSE only when tssdis is 
//  running on failover cluster and it's restarted within a time limit
BOOL  g_RepopulateSession = TRUE;
// If tssdis is not restarted within this time (3 mins), we think the db is not consistent
ULONGLONG g_TimeLimitToDeleteDB = 3 * 60 * FILETIME_INTERVAL_TO_SECONDS_MULTIPLIER;

//
// Global for fail-over cluster
//
DWORD g_dwClusterState;
// Cluster network name
WCHAR *g_ClusterNetworkName = NULL;
// Cluster account token
HANDLE g_hClusterToken = NULL;

// File Handle for the database timestamp file
HANDLE g_hTimeFile;

#define SDLOCALGROUPNAMELENGTH 64
#define SDLOCALGROUPDESLENGTH 128

const DIRCOLUMNS SessionDirectoryColumns[NUM_SESSDIRCOLUMNS] = {
    { "UserName", JET_coltypLongText, 512 },
    { "Domain", JET_coltypLongText, 254 },
    { "ServerID", JET_coltypLong, 0 },
    { "SessionID", JET_coltypLong, 0 },
    { "TSProtocol", JET_coltypLong, 0 },
    { "CreateTimeLow", JET_coltypLong, 0 },
    { "CreateTimeHigh", JET_coltypLong, 0 },
    { "DisconnectTimeLow", JET_coltypLong, 0 },
    { "DisconnectTimeHigh", JET_coltypLong, 0 },
    { "ApplicationType", JET_coltypLongText, 512 },
    { "ResolutionWidth", JET_coltypLong, 0 },
    { "ResolutionHeight", JET_coltypLong, 0 },
    { "ColorDepth", JET_coltypLong, 0 },
    { "State", JET_coltypBit, 0 },
};


const DIRCOLUMNS ServerDirectoryColumns[NUM_SERVDIRCOLUMNS] = {
    { "ServerID", JET_coltypLong, 0 },
    { "ServerAddress", JET_coltypLongText, 128 },
    { "ClusterID", JET_coltypLong, 0 },
    { "AlmostInTimeLow", JET_coltypLong, 0 },
    { "AlmostInTimeHigh", JET_coltypLong, 0 },
    { "NumberFailedPings", JET_coltypLong, 0 },
    { "SingleSessionMode", JET_coltypBit, 0 },
    { "ServerDNSName", JET_coltypLongText, 128 },
};


const DIRCOLUMNS ClusterDirectoryColumns[NUM_CLUSDIRCOLUMNS] = {
    { "ClusterID", JET_coltypLong, 0 },
    { "ClusterName", JET_coltypLongText, 128 },
    { "SingleSessionMode", JET_coltypBit, 0 },
};


JET_COLUMNID sesdircolumnid[NUM_SESSDIRCOLUMNS];
JET_COLUMNID servdircolumnid[NUM_SERVDIRCOLUMNS];
JET_COLUMNID clusdircolumnid[NUM_CLUSDIRCOLUMNS];

JET_INSTANCE g_instance = 0;

ADOConnection *g_pConnection;
HANDLE g_hStopServiceEvent;

SERVICE_STATUS g_DISStatus;
SERVICE_STATUS_HANDLE g_DISStatusHandle;

BOOL g_bDebug = FALSE;

PSID g_pSid = NULL;                    //Sid for SD local group 
PSID g_pAdminSid = NULL;               //Sid for admin on the SD server

// Registry settings follow
#if 0
DWORD g_bUseSQL = 0;
#endif


enum TraceOutputMode {
    NoTraceOutput,
    DebugPrintOutput,
    StdOutput,
    FileOutput
};

TraceOutputMode g_TraceOutputMode = NoTraceOutput;
HANDLE g_hFileOutput = INVALID_HANDLE_VALUE;

// For debugging purposes, we can set the ping mode to something other than
// WinStationOpenServer using the registry.
enum PingMode {
    NormalMode,
    AlwaysSucceed,
    AlwaysFail
};

PingMode g_PingMode = NormalMode;

ULONGLONG g_TimeServerSilentBeforePing = 60 * FILETIME_INTERVAL_TO_SECONDS_MULTIPLIER;
DWORD DISNumberSecondsBetweenPings = 10;
DWORD g_NumberFailedPingsBeforePurge = 3;


#ifdef DBG
void OutputAllTables();
#endif

void DISDeleteLocalGroupSecDes();
RPC_STATUS SDInitQueryRPC(VOID);

void TSDISErrorOut(wchar_t *format_string, ...)
{
    // Immediately bail out if we are in NoTraceOutput mode.
    if (g_TraceOutputMode == NoTraceOutput) {
        return;
    }
    else {
        // Otherwise, do the right thing.
        wchar_t TotalString[MAX_DEBUG_STRING_LENGTH + MAX_THREADIDSTR_LENGTH];
        wchar_t *ThreadIDString = TotalString;
        wchar_t *DebugOutString = NULL;
        va_list args;
        int ThreadStrLength;

        // Get the current thread ID
        ThreadStrLength = _snwprintf(ThreadIDString, MAX_THREADIDSTR_LENGTH, 
                L"%d: ", GetCurrentThreadId());

        // Set the place for the out string to after the string, or after the whole
        // buffer if _snwprintf didn't have enough space.
        if (ThreadStrLength > 0)
            DebugOutString = &TotalString[ThreadStrLength];
        else
            DebugOutString = &TotalString[MAX_THREADIDSTR_LENGTH];
            
        va_start(args, format_string);

        // Create the debug output string.
        _vsnwprintf(DebugOutString, MAX_DEBUG_STRING_LENGTH, format_string, args);
        DebugOutString[MAX_DEBUG_STRING_LENGTH - 1] = '\0';

        // Output to the correct place.
        switch (g_TraceOutputMode) {
            
        case DebugPrintOutput:
            OutputDebugString(TotalString);
            break;

        case StdOutput:
            wprintf(TotalString);
            break;

        case FileOutput:
            {
                char TotalStringA[MAX_DEBUG_STRING_LENGTH + 
                        MAX_THREADIDSTR_LENGTH];
                DWORD dwBytes = 0;

                // Convert to ANSI.
                dwBytes = WideCharToMultiByte(CP_ACP, 0, TotalString, 
                        -1, TotalStringA, MAX_DEBUG_STRING_LENGTH + 
                        MAX_THREADIDSTR_LENGTH, 0, 0);

                // Don't write the terminating NULL (3rd argument)!
                // Ignore return value.
                WriteFile(g_hFileOutput, TotalStringA, dwBytes - 1, 
                        &dwBytes, NULL);
                
                break;
            }
        }

        va_end(args);
    }
}


// TSDISErrorTimeOut
//
// This function is used to output a single FILETIME low, high pair.  The format
// string, given as the first argument, MUST specify a %s format specifier for
// where the date/time should go.
//
// Example:
//  TSDISErrorTimeOut(L"The date and time are %s\n", CurrTimeLow, CurrTimeHigh);
void TSDISErrorTimeOut(wchar_t *format_string, DWORD TimeLow, DWORD TimeHigh)
{
    if (g_TraceOutputMode == NoTraceOutput) {
        return;
    }
    else {
        // We just need to convert the FILETIME we have into a SYSTEMTIME,
        // and then output the SYSTEMTIME using GetDateFormat and GetTimeFormat.
        FILETIME ft;
        SYSTEMTIME st;
        SYSTEMTIME stloc;
        int offset = 0;
        wchar_t DateString[MAX_DATE_TIME_STRING_LENGTH];

        ft.dwLowDateTime = TimeLow;
        ft.dwHighDateTime = TimeHigh;

        if (FileTimeToSystemTime(&ft, &st) != 0) {
            // st is the system time.

            // UTC format?
            if (SystemTimeToTzSpecificLocalTime(NULL, &st, &stloc) != 0) {
                offset = GetDateFormat(LOCALE_SYSTEM_DEFAULT, DATE_SHORTDATE, 
                        &stloc, NULL, DateString, MAX_DATE_TIME_STRING_LENGTH);

                if (offset != 0) {
                    // Turn the terminating NULL into a space.
                    DateString[offset - 1] = ' ';
                    
                    // Write the time after the space.
                    offset = GetTimeFormat(LOCALE_SYSTEM_DEFAULT, 0, &stloc, 
                            NULL, &DateString[offset], 
                            MAX_DATE_TIME_STRING_LENGTH - offset);

                    if (offset != 0) {
                        // Output the string.
                        TSDISErrorOut(format_string, DateString);
                    }
                }
            }
        }
    }
}


// This function is duplicated from \nt\termsrv\winsta\server\sessdir.cpp.
//
// PostSessDirErrorValueEvent
//
// Utility function used to create a system log wType event containing one
// hex DWORD code value.
void PostSessDirErrorValueEvent(unsigned EventCode, DWORD ErrVal, WORD wType)
{
    HANDLE hLog;
    WCHAR hrString[128];
    PWSTR String = NULL;
    static DWORD numInstances = 0;
    //
    //count the numinstances of out of memory error, if this is more than
    //a specified number, we just won't log them
    //
    if( MY_STATUS_COMMITMENT_LIMIT == ErrVal )
    {
        if( numInstances > MAX_INSTANCE_MEMORYERR )
            return;
         //
        //if applicable, tell the user that we won't log any more of the out of memory errors
        //
        if( numInstances >= MAX_INSTANCE_MEMORYERR - 1 ) {
            wsprintfW(hrString, L"0x%X. This type of error will not be logged again to avoid eventlog fillup.", ErrVal);
            String = hrString;
        }
        numInstances++;
    }

    hLog = RegisterEventSource(NULL, L"TermServSessDir");
   if (hLog != NULL) {
        if( NULL == String ) {
            wsprintfW(hrString, L"0x%X", ErrVal);
            String = hrString;
        }
        ReportEvent(hLog, wType, 0, EventCode, NULL, 1, 0,
                (const WCHAR **)&String, NULL);
        DeregisterEventSource(hLog);
    }
}

// PostSessDirErrorMsgEvent
//
// Utility function used to create a system log wType event containing one
// WCHAR msg.
void PostSessDirErrorMsgEvent(unsigned EventCode, WCHAR *szMsg, WORD wType)
{
    HANDLE hLog;
    
    hLog = RegisterEventSource(NULL, L"TermServSessDir");
    if (hLog != NULL) {
        ReportEvent(hLog, wType, 0, EventCode, NULL, 1, 0,
                (const WCHAR **)&szMsg, NULL);
        DeregisterEventSource(hLog);
    }
}


// DISJetGetServersPendingReconnects
//
// Returns arrays of max length 10 of servers pending reconnects, where the
// reconnect is greater than g_TimeServerSilentBeforePing seconds.
HRESULT STDMETHODCALLTYPE DISJetGetServersPendingReconnects(
        OUT long __RPC_FAR *pNumSessionsReturned,
        OUT WCHAR ServerAddressRows[10][SERVER_ADDRESS_LENGTH],
        OUT DWORD ServerIDs[10])
{
    JET_ERR err;
    JET_SESID sesid = JET_sesidNil;
    JET_DBID dbid;
    JET_TABLEID servdirtableid;
    DWORD zero = 0;
    *pNumSessionsReturned = 0;
    unsigned i = 0;
    unsigned long cbActual;
    // These are really FILETIMEs, but we want to do 64-bit math on them,
    // and they're the same structure as FILETIMEs.
    ULARGE_INTEGER ulCurrentTime;
    ULARGE_INTEGER ulAITTime;
        
    //TSDISErrorOut(L"GetPendRec...");
    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
            &servdirtableid));

    // Get the current file time.
    SYSTEMTIME st;
    
    // Retrieve the time.
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, (FILETIME *) &ulCurrentTime);

    // Set the current time to the sd timestamp file    
    SetFileTime(g_hTimeFile, NULL, NULL, (FILETIME *)&ulCurrentTime);

    CALL(JetBeginTransaction(sesid));
    
    // Since Jet has no unsigned long type, go through the servers first
    // looking for keys greater than 0, 0, then looking for keys less than 0, 0
    // TODO: Consider how to do this with JET_coltypDateTime or using NULLs
    for (int j = 0; j < 2; j++) {
        CALL(JetSetCurrentIndex(sesid, servdirtableid, "ServerAlmostInTimes"));

        CALL(JetMakeKey(sesid, servdirtableid, &zero, sizeof(zero), 
                JET_bitNewKey));
        CALL(JetMakeKey(sesid, servdirtableid, &zero, sizeof(zero), 0));

        if (0 == j)
            err = JetSeek(sesid, servdirtableid, JET_bitSeekGT);
        else
            err = JetSeek(sesid, servdirtableid, JET_bitSeekLT);

        while ((i < TSSD_MaxDisconnectedSessions) && (JET_errSuccess == err)) {

            // Get AlmostInTimeLow, AlmostInTimeHigh (3 + 4) for computation.
            CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_AITLOW_INTERNAL_INDEX], &(ulAITTime.LowPart), 
                    sizeof(ulAITTime.LowPart), &cbActual, 0, NULL));
            CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                    SERVDIR_AITHIGH_INTERNAL_INDEX], &(ulAITTime.HighPart), 
                    sizeof(ulAITTime.HighPart), &cbActual, 0, NULL));

            // If the difference between the current time and the time the
            // server was stamped is greater than the set 
            // TimeServerSilentBeforePing, then put it in the return array, 
            // else don't.
            if ((ulCurrentTime.QuadPart - ulAITTime.QuadPart) > 
                    g_TimeServerSilentBeforePing) {

                // Get ServerID
                CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                        SERVDIR_SERVID_INTERNAL_INDEX], &ServerIDs[i], 
                        sizeof(ServerIDs[i]), &cbActual, 0, NULL));

                // Get the ServerAddress for this record.
                CALL(JetRetrieveColumn(sesid, servdirtableid, servdircolumnid[
                        SERVDIR_SERVADDR_INTERNAL_INDEX], 
                        &ServerAddressRows[i][0], sizeof(ServerAddressRows[i]),
                        &cbActual, 0, NULL));

                i += 1;
            }

            // Move to the next matching record.
            if (0 == j)
                err = JetMove(sesid, servdirtableid, JET_MoveNext, 0);
            else
                err = JetMove(sesid, servdirtableid, JET_MovePrevious, 0);
        }
    }

    *pNumSessionsReturned = i;
    
    CALL(JetCommitTransaction(sesid, 0));

    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    return S_OK;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    return E_FAIL;
}


#if 0
HRESULT STDMETHODCALLTYPE DISSQLGetServersPendingReconnects(
        OUT long __RPC_FAR *pNumSessionsReturned, 
        OUT CVar *pVarRows)
{
    long NumRecords = 0;
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;
    CVar varFields;
    CVar varStart;

    TRC2((TB,"GetServersWithDisconnectedSessions"));

    ASSERT((pNumSessionsReturned != NULL),(TB,"NULL pNumSess"));

    hr = CreateADOStoredProcCommand(L"SP_TSDISGetServersPendingReconnects",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        // Execute the command.
        hr = pCommand->Execute(NULL, NULL, adCmdStoredProc,
                &pResultRecordSet);

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"GetServersWDiscSess: Failed create cmd, hr=0x%X", hr));
    }
        
    // At this point we have a result recordset containing the server rows
    // corresponding to all of the disconnected sessions.
    if (SUCCEEDED(hr)) {
        long State;

        NumRecords = 0;

        hr = pResultRecordSet->get_State(&State);
        if (SUCCEEDED(hr)) {
            if (!(State & adStateClosed)) {
                VARIANT_BOOL VB;

                // If EOF the recordset is empty.
                hr = pResultRecordSet->get_EOF(&VB);
                if (SUCCEEDED(hr)) {
                    if (VB) {
                        TRC1((TB,"GetServersWDiscSess: Result recordset EOF, "
                                "0 rows"));
                        goto PostUnpackResultSet;
                    }
                }
                else {
                    ERR((TB,"GetServersWDiscSess: Failed get_EOF, hr=0x%X", 
                            hr));
                    goto PostUnpackResultSet;
                }
            }
            else {
                ERR((TB,"GetServersWDiscSess: Closed result recordset"));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetServersWDiscSess: get_State failed, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }
        
        // Grab the result data into a safearray, starting with the default
        // current row and all fields.
        varStart.InitNoParam();
        varFields.InitNoParam();
        hr = pResultRecordSet->GetRows(adGetRowsRest, varStart,
                varFields, pVarRows);
        if (SUCCEEDED(hr)) {
            hr = SafeArrayGetUBound(pVarRows->parray, 2, &NumRecords);
            if (SUCCEEDED(hr)) {
                // 0-based array bound was returned, num rows is that + 1.
                NumRecords++;

                TRC1((TB,"%d rows retrieved from safearray", NumRecords));
            }
            else {
                ERR((TB,"GetServersWithDisc: Failed safearray getubound, "
                        "hr=0x%X", hr));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetServersWDiscSess: Failed to get rows, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }


PostUnpackResultSet:
        pResultRecordSet->Release();
    }
    else {
        ERR((TB,"GetServersWDiscSess: Failed exec, hr=0x%X", hr));
    }

    *pNumSessionsReturned = NumRecords;
    return hr;
}
#endif


/****************************************************************************/
// DISDebugControlHandler
//
// Handle console control events for when service is in debug mode.
/****************************************************************************/
BOOL WINAPI DISDebugControlHandler(DWORD dwCtrlType) {

    switch(dwCtrlType)
    {
    case CTRL_BREAK_EVENT:
    case CTRL_C_EVENT:
        TSDISErrorOut(L"Stopping service\n");

        SetEvent(g_hStopServiceEvent);
        // Should I wait for that to complete?

        return TRUE;
        break;
    }
    return FALSE;
}


/****************************************************************************/
// DISPingServer
//
// Given the IP address of a server, pings it.  Returns TRUE on success, FALSE 
// on failure.
/****************************************************************************/
BOOLEAN DISPingServer(WCHAR *ServerAddress) {
    HANDLE hServer = NULL;
    hServer = WinStationOpenServer(ServerAddress);

    // The only case where we return false is where hServer is NULL and the
    // reason is not ERROR_ACCESS_DENIED.
    if (hServer == NULL) {
        if (GetLastError() != ERROR_ACCESS_DENIED)
            return FALSE;
    }
    else {
        // The hServer is valid, so clean up.
        WinStationCloseServer(hServer);
    }
    return TRUE;
}


/****************************************************************************/
// DISGetServerStatus
//
// Given the IP address of a server, determines its state (Responding or 
// NotResponding).
// 
// Currently implemented as a ping.  See lengthy comment in main for one
// possible future optimization.
/****************************************************************************/
SERVER_STATUS DISGetServerStatus(WCHAR *ServerAddress) {

    switch (g_PingMode) {

    case AlwaysFail:
        return NotResponding;

    case AlwaysSucceed:
        return Responding;

    case NormalMode:
        // NOTE INTENTIONAL FALLTHROUGH.
    default:
        if (DISPingServer(ServerAddress) == TRUE)
            return Responding;
        else
            return NotResponding;

    }

}


#if 0
HRESULT DISSQLInitialize() {
    // Retrieve number of seconds to wait from the registry -- NOT IMPLEMENTED
    HRESULT hr = S_OK;
    BSTR ConnectString = NULL;
    LONG RegRetVal;
    HKEY hKey;
    BSTR ConnectStr = NULL;
    BSTR UserStr = NULL;
    BSTR PwdStr = NULL;

    RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            TEXT("Software\\Microsoft\\DIS"), 0, KEY_READ, &hKey);
    if (RegRetVal == ERROR_SUCCESS) {
        DWORD Type, DataSize;

        // Determine the needed size.
        DataSize = 0;
        RegRetVal = RegQueryValueExW(hKey, L"ConnectString", NULL,
                &Type, NULL, &DataSize);
        DataSize &= ~1;
        if (RegRetVal == ERROR_SUCCESS && Type == REG_SZ) {
            ConnectString = SysAllocStringLen(L"", DataSize /
                    sizeof(WCHAR));
            if (ConnectString != NULL) {
                RegRetVal = RegQueryValueExW(hKey, L"ConnectString",
                        NULL, &Type, (BYTE *)ConnectString,
                        &DataSize);
                if (RegRetVal == ERROR_SUCCESS) {
                    // Hold onto the connect string for use below.
                    TRC1((TB,"Retrieved conn str %S", ConnectString));
                }
                else {
                    ERR((TB,"Final RegQuery failed, err=%u", RegRetVal));
                    hr = E_FAIL;
                    goto Cleanup;
                }
            }
            else {
                ERR((TB,"Failed alloc connect string"));
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
        }
        else {
            ERR((TB,"Failed RegQuery - err=%u, DataSize=%u, type=%u",
                    RegRetVal, DataSize, Type));
            hr = E_FAIL;
            goto Cleanup;
        }

        RegCloseKey(hKey);
    }
    else {
        ERR((TB,"RegOpenKeyEx returned err %u", RegRetVal));
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = CoInitialize(NULL);

    // Alloc the BSTRs for the connection.
    ConnectStr = SysAllocString(ConnectString);
    UserStr = SysAllocString(L"");
    PwdStr = SysAllocString(L"");

    if ((ConnectStr == NULL) || (UserStr == NULL) || (PwdStr == NULL)) {
        ERR((TB, "Failed alloc Connect, User, or PwdStr"));
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Create an ADO connection instance and connect.
    hr = CoCreateInstance(CLSID_CADOConnection, NULL,
            CLSCTX_INPROC_SERVER, IID_IADOConnection,
            (LPVOID *)&g_pConnection);
    if (SUCCEEDED(hr)) {
        // Do the open.
        hr = g_pConnection->Open(ConnectStr, UserStr, PwdStr,
                adOpenUnspecified);
        if (!SUCCEEDED(hr)) {
            ERR((TB,"Failed open DB, hr=0x%X", hr));
            g_pConnection->Release();
            g_pConnection = NULL;
        }
    }
    else {
        ERR((TB,"CoCreate(ADOConn) returned 0x%X", hr));
    }

Cleanup:

    // SysFreeString(NULL) is ok.
    SysFreeString(ConnectString);
    SysFreeString(ConnectStr);
    SysFreeString(UserStr);
    SysFreeString(PwdStr);

    return hr;
}
#endif


// Call each TS Server to ask them to rejoin SD
void __cdecl DISOpenServer(void *Para)
{
    HRESULT hr;
    WCHAR *pBindingString = NULL;
    RPC_BINDING_HANDLE hRPCBinding = NULL;
    WCHAR *szPrincipalName = NULL;
    WCHAR *ServerName = NULL;
    SDRecoverServerNames *SDRRecoverServerPara = (SDRecoverServerNames *)Para;
    unsigned int count = SDRRecoverServerPara->count;
    WCHAR ** ServerNameArray = SDRRecoverServerPara->ServerNameArray;
    unsigned int i;
    unsigned long RpcException;
    DWORD dwRejoinFlag = 0;

    dwRejoinFlag |= TSSD_FORCEREJOIN;

    // Impersonate the cluster account to make the rejoin RPC call
    if (g_dwClusterState == ClusterStateRunning) {
        if (g_hClusterToken) {
            if(!ImpersonateLoggedOnUser(g_hClusterToken)) {
                // If we failed to impersonate the cluster account, don't ask TS to rejoin, since it will 
                //  fail anyway due to access denied
                TSDISErrorOut(L"SD Recover: Error %d in ImpersonateLoggedOnUser\n", GetLastError());
                goto HandleError;
            }
        }
        else {
            // If g_hClusterToken is NULL, don't ask TS to rejoin, since it will 
            //  fail anyway due to access denied
            goto HandleError;
        }
    }

    // If it's on failover cluster, set the flag to tell server not to repopulate its sessions
    if (g_RepopulateSession == FALSE) {
        dwRejoinFlag |= TSSD_NOREPOPULATE;
    }

    for (i=0;i<count;i++) {
        if (NULL != hRPCBinding) {
            RpcBindingFree(&hRPCBinding);
            hRPCBinding = NULL;
        }
    
        ServerName = *(ServerNameArray + i);
        // Connect to the tssdjet RPC server according to the server name provided.
        // We first create an RPC binding handle from a composed binding string.
        hr = RpcStringBindingCompose(/*(WCHAR *)g_RPCUUID,*/
                0,
                L"ncacn_ip_tcp", ServerName,
                0,
                NULL, &pBindingString);

        if (hr == RPC_S_OK) {
            // Generate the RPC binding from the canonical RPC binding string.
            hr = RpcBindingFromStringBinding(pBindingString, &hRPCBinding);
            if (hr != RPC_S_OK) {
                ERR((TB,"SD Recover: Error %d in RpcBindingFromStringBinding\n", hr));
                goto LogError;
            } 
        }
        else {
            ERR((TB,"SD Recover: Error %d in RpcStringBindingCompose\n", hr));
            goto LogError;
        }

        hr = RpcEpResolveBinding(hRPCBinding, TSSDTOJETRPC_ClientIfHandle);
        if (hr != RPC_S_OK) {
            ERR((TB, "SD Recover: Error %d in RpcEpResolveBinding", hr));
            goto LogError;
        }

        hr = RpcMgmtInqServerPrincName(hRPCBinding,
                                       RPC_C_AUTHN_GSS_NEGOTIATE,
                                       &szPrincipalName);
        if (hr != RPC_S_OK) {
            ERR((TB,"SD Recover: Error %d in RpcMgmtIngServerPrincName", hr));
            goto LogError;
        }

        hr = RpcBindingSetAuthInfo(hRPCBinding,
                                szPrincipalName,
                                RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                RPC_C_AUTHN_GSS_NEGOTIATE,
                                NULL,  //CurrentIdentity
                                NULL);
        RpcStringFree(&szPrincipalName);

        if (hr != RPC_S_OK) {
            ERR((TB,"SD Recover: Error %d in RpcBindingSetAuthInfo", hr));
            goto LogError;
        } 

        RpcTryExcept {
            // Make the call to TS to ask it to rejoin
            hr = TSSDRPCRejoinSD(hRPCBinding, dwRejoinFlag);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            hr = RpcException;
            ERR((TB,"ForceRejoin: RPC Exception %d\n", RpcException));
        }
        RpcEndExcept
                
LogError:
        if (hr != RPC_S_OK) {
            PostSessDirErrorMsgEvent(EVENT_FAIL_CALL_TS_REJOIN, ServerName, EVENTLOG_ERROR_TYPE);
        }
    }

    // Stop Impersonating
    if (g_dwClusterState == ClusterStateRunning) {
        RevertToSelf();
    }

HandleError:

    if (NULL != hRPCBinding) {
        RpcBindingFree(&hRPCBinding);
        hRPCBinding = NULL;
    }
    // Free 
    for (i=0;i<count;i++) {
        LocalFree(*(ServerNameArray + i));
    }
    LocalFree(ServerNameArray);
    LocalFree(SDRRecoverServerPara);
    
    return;
}

// When SD service is restarted, try to recover the Servers in the SD
// Jet database and ask them to rejoin SD
BOOL DISJetRecover()
{
    JET_SESID sesid = JET_sesidNil;;
    JET_TABLEID servdirtableid;
    JET_DBID dbid = JET_dbidNil;
    JET_COLUMNDEF jcd;
    JET_COLUMNID ServerAddrCId;
    JET_ERR err = JET_errSuccess;
    unsigned long i, count = 0;
    WCHAR ServerName[SERVER_ADDRESS_LENGTH];
    WCHAR **ServerNameArray = NULL;
    unsigned long cbActual;
    SDRecoverServerNames *pSDRecoverServerPara;

    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramSystemPath, 
            0, JETDISDBDIRECTORY));
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramTempPath,
            0, JETDISDBDIRECTORY));
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramLogFilePath,
            0, JETDISDBDIRECTORY));
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramCircularLog,
            1, NULL));
    
    CALL(JetInit(&g_instance));
    CALL(JetBeginSession(g_instance, &sesid, "user", ""));

        

    CALL(JetAttachDatabase(sesid, JETDBFILENAME, 0));

    // Populate our columnid arrays
    CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

    CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
                &servdirtableid));

    CALL(JetBeginTransaction(sesid));

    CALL(JetGetColumnInfo(sesid, dbid, "ServerDirectory",
                    ServerDirectoryColumns[SERVDIR_SERVADDR_INTERNAL_INDEX].szColumnName, &jcd,
                    sizeof(jcd), 0));
    ServerAddrCId = jcd.columnid;

    pSDRecoverServerPara = (SDRecoverServerNames *)LocalAlloc(LMEM_FIXED, sizeof(SDRecoverServerNames));
    if (NULL == pSDRecoverServerPara) {
        goto HandleError;
    }
    // Get number of TS Servers in the SD
    err = JetIndexRecordCount(sesid, servdirtableid, &count, MAX_TSSERVERS_TO_RECOVER);

    if (err != JET_errSuccess)
        goto HandleError;
    if (count) {
        CALL(JetMove(sesid, servdirtableid, JET_MoveFirst, 0));
        ServerNameArray = (WCHAR **)LocalAlloc(LMEM_FIXED, count * sizeof(WCHAR *));
        if (NULL == ServerNameArray) {
            goto HandleError;
        }
    }
    TSDISErrorOut(L"We have %d Servers to recover\n", count);
    for(i=0;i<count;i++)
    {
        CALL(JetRetrieveColumn(sesid, servdirtableid, ServerAddrCId,
                          ServerName, SERVER_ADDRESS_LENGTH, &cbActual, 0, NULL));
        TSDISErrorOut(L"Server %d is %s\n", i+1, ServerName);

        *(ServerNameArray + i) = (WCHAR *)LocalAlloc(LMEM_FIXED, sizeof(ServerName));
        if (NULL == *(ServerNameArray+i)) {
            goto HandleError;
        }
        memcpy((BYTE *)(*(ServerNameArray + i)), (BYTE*)ServerName, sizeof(ServerName));

        if (i != (count-1))
            CALL(JetMove(sesid, servdirtableid, JET_MoveNext, 0));
    }
    // Spin a thread to call TS servers to rejoin SD
    pSDRecoverServerPara->count = count;
    pSDRecoverServerPara->ServerNameArray = ServerNameArray;
    if(-1 == _beginthread(DISOpenServer, 0, (PVOID)pSDRecoverServerPara)) {
        TSDISErrorOut(L"Unable to begin DISOpenServer thread\n");
        // Free mem
        for (i=0;i<count;i++) {
            LocalFree(*(pSDRecoverServerPara->ServerNameArray + i));
        }
        LocalFree(pSDRecoverServerPara->ServerNameArray);
        LocalFree(pSDRecoverServerPara);

    }

    CALL(JetCommitTransaction(sesid, 0));


    CALL(JetCloseTable(sesid, servdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    CALL(JetTerm(g_instance));
    g_instance = 0;

    return TRUE;

HandleError: 
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }
    
    JetTerm(g_instance);
    g_instance = 0;

    return FALSE;
}

// Delete the database and all other JET files (if present)
void DeleteJetFiles()
{
    HANDLE hFileFind;
    WIN32_FIND_DATA FindFileData;
    WCHAR filename[MAX_LOGFILE_LENGTH];
    DWORD dwError;

    // Delete the database and all other JET files (if present), and start anew.
    (void) DeleteFile(JETDBFILENAMEW);
    (void) DeleteFile(JETAUXFILENAME1W);
    (void) DeleteFile(JETAUXFILENAME2W);
    (void) DeleteFile(JETAUXFILENAME3W);
    (void) DeleteFile(JETAUXFILENAME4W);
    (void) DeleteFile(JETAUXFILENAME5W);
    (void) DeleteFile(JETAUXFILENAME6W);

    // Delete numbered log files.  Jet can create a bunch of log files
    // of the form edb00001.log, edb00002.log, . . ., edb0000a.log,
    // edb0000b.log, . . ., edb0000f.log, edb00010.log, . . .
    hFileFind = FindFirstFile(JETLOGFILENAME, &FindFileData);
    if (hFileFind != INVALID_HANDLE_VALUE) {
        swprintf(filename, JETDISDBDIRECTORYW);
        wcsncat(filename, FindFileData.cFileName, MAX_LOGFILE_LENGTH - sizeof(JETDISDBDIRECTORYW) / sizeof(WCHAR) - 1);
        if (DeleteFile(filename) == 0) {
            dwError = GetLastError();
            if (dwError != ERROR_FILE_NOT_FOUND) {
                PostSessDirErrorValueEvent(EVENT_PROBLEM_DELETING_LOGS, 
                        dwError, EVENTLOG_ERROR_TYPE);
            }
        }
        while (FindNextFile(hFileFind, &FindFileData)) {
            swprintf(filename, JETDISDBDIRECTORYW);
            wcsncat(filename, FindFileData.cFileName, MAX_LOGFILE_LENGTH - sizeof(JETDISDBDIRECTORYW) / sizeof(WCHAR) - 1);
            if (DeleteFile(filename) == 0) {
                dwError = GetLastError();
                if (dwError != ERROR_FILE_NOT_FOUND) {
                    PostSessDirErrorValueEvent(EVENT_PROBLEM_DELETING_LOGS, 
                            dwError, EVENTLOG_ERROR_TYPE);
                    break;
                }
            }
        }

        FindClose(hFileFind);
    }
}

//
// Session directory initialization on fail-over cluster
//
// Return True on success
//
BOOL DISJetInitInCluster()
{
    BOOL fRet = FALSE;
    DWORD dwError;
    HCLUSTER hclus = NULL;
    HRESOURCE hrSD = NULL;
    WCHAR *pszDriveLetter = NULL;
    DWORD cchDriveLetter = MAX_DRIVE_LETTER_LENGTH;
    HCLUSENUM hClusEnum = NULL;
    DWORD dwIndex, dwCount;
    WCHAR ResourceName[256], *ServiceName;
    DWORD dwSize, dwType;
    LPVOID pPropertyList = NULL;
    DWORD rc;
    BOOL bFindSDService = FALSE;
    HRESOURCE hrNetworkName = NULL;
    struct CLUS_NETNAME_VS_TOKEN_INFO VsTokenInfo;
    DWORD dwReturnSize = 0;
    HANDLE hVSToken = NULL;

    // Change the current directory to the right place on the shared
    // drive.

    // Open the cluster.
    hclus = OpenCluster(NULL);

    if (hclus == NULL) {
        // TODO: Log event.
        TSDISErrorOut(L"Unable to open cluster, error %d\n", 
                      GetLastError());
        goto HandleError;
    }

    // Enuerate all the resources in the cluster to find the generic service
    // resource named "tssdis" i.e. the session directory service
    hClusEnum = ClusterOpenEnum(hclus, CLUSTER_ENUM_RESOURCE);
    if (hClusEnum == NULL) {
        // TODO: Log event.
        TSDISErrorOut(L"Unable to open cluster enum, error %d\n",
                      GetLastError());
        goto HandleError;
    }
    dwCount = ClusterGetEnumCount(hClusEnum);

    for (dwIndex=0; dwIndex<dwCount; dwIndex++) {
        if (pPropertyList != NULL) {
            LocalFree(pPropertyList);
            pPropertyList = NULL;
        }
        if (hrSD != NULL) {
            CloseClusterResource(hrSD);
            hrSD = NULL;
        }

        dwSize = sizeof(ResourceName) / sizeof(WCHAR);
        if (ClusterEnum(hClusEnum, dwIndex, &dwType, 
                        ResourceName, &dwSize) != ERROR_SUCCESS) {
            TSDISErrorOut(L"ClusterEnum fails with error %d\n",
                          GetLastError());
            continue;
        }
        hrSD = OpenClusterResource(hclus, ResourceName);
        if (hrSD == NULL) {
            TSDISErrorOut(L"OpenClusterResource fails with error %d\n",
                          GetLastError());
            continue;
        }
        pPropertyList = NULL;
        dwSize = 0;
        rc = ClusterResourceControl(hrSD,                                           // hResource
                                    NULL,                                           // hHostNode
                                    CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,        // dwControlCode
                                    NULL,                                           // lpInBuffer
                                    0,                                              // cbInBufferSize
                                    NULL,                                           // lpOutBuffer
                                    0,                                              // cbOutBufferSiz 
                                    &dwSize);                                       // lpcbByteReturned


        if (rc != ERROR_SUCCESS) {
            TSDISErrorOut(L"ResourceControl fails with error %d\n", rc);
            continue;
        }
        dwSize += sizeof(WCHAR);
        pPropertyList = LocalAlloc(LMEM_FIXED, dwSize);
        if (pPropertyList == NULL) {
            TSDISErrorOut(L"Can't allocate memory for propertylist with size %d\n", dwSize);
            continue;
        }
        rc = ClusterResourceControl(hrSD, 
                                    NULL, 
                                    CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES, 
                                    NULL, 
                                    0, 
                                    pPropertyList, 
                                    dwSize,
                                    NULL);
        if (rc != ERROR_SUCCESS) {
            TSDISErrorOut(L"ResourceControl fails with error %d\n", rc);
            continue;
        }

        rc = ResUtilFindSzProperty(pPropertyList, dwSize, L"ServiceName", &ServiceName);
        if (rc == ERROR_SUCCESS) {
            if (_wcsicmp(ServiceName, L"tssdis") == 0) {
                TSDISErrorOut(L"Find tssdis resource\n");
                bFindSDService = TRUE;
                LocalFree(ServiceName);
                break;
            }
            if (ServiceName != NULL) {
                LocalFree(ServiceName);
                ServiceName = NULL;
            }
        }

        CloseClusterResource(hrSD);
        hrSD = NULL;
    }
    if (pPropertyList != NULL) {
        LocalFree(pPropertyList);
        pPropertyList = NULL;
    }
    ClusterCloseEnum(hClusEnum);

    // Bail out if can't find tssdis resource
    if (!bFindSDService) {
        // TODO: Log event.
        TSDISErrorOut(L"Unable to find the resource with service name tssdis\n");
        goto HandleError;
    }

    // Find the network name resource
    hrNetworkName = ResUtilGetResourceDependency(hrSD, L"Network Name");
    if (hrNetworkName == NULL) {
        TSDISErrorOut(L"Unable to get the dependent NetworkName resource, error is %d\n", GetLastError());
        goto HandleError;
    }

    pPropertyList = NULL;
    dwSize = 0;
    // Get the property of the network name resource
    // This is the 1st call, just get the size of the porperty list
    rc = ClusterResourceControl(hrNetworkName,                                  // hResource
                                NULL,                                           // hHostNode
                                CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES,        // dwControlCode
                                NULL,                                           // lpInBuffer
                                0,                                              // cbInBufferSize
                                NULL,                                           // lpOutBuffer
                                0,                                              // cbOutBufferSiz 
                                &dwSize);                                       // lpcbByteReturned


    if (rc != ERROR_SUCCESS) {
        TSDISErrorOut(L"ResourceControl fails with error %d\n", rc);
        goto HandleError;
    }
    dwSize += sizeof(WCHAR);
    pPropertyList = LocalAlloc(LMEM_FIXED, dwSize);
    if (pPropertyList == NULL) {
        TSDISErrorOut(L"Can't allocate memory for propertylist with size %d\n", dwSize);
        goto HandleError;
    }
    // Get the property of the network name resource
    rc = ClusterResourceControl(hrNetworkName, 
                                NULL, 
                                CLUSCTL_RESOURCE_GET_PRIVATE_PROPERTIES, 
                                NULL, 
                                0, 
                                pPropertyList, 
                                dwSize,
                                NULL);
    if (rc != ERROR_SUCCESS) {
        TSDISErrorOut(L"ResourceControl fails with error %d\n", rc);
        goto HandleError;
    }

    // Find the "name" propery in the property list
    rc = ResUtilFindSzProperty(pPropertyList, dwSize, L"Name", &g_ClusterNetworkName);
    if (rc != ERROR_SUCCESS) {
        g_ClusterNetworkName = NULL;
        TSDISErrorOut(L"ResUtilFindSzProperty fails with error %d\n", rc);
        goto HandleError;
    }
    if (pPropertyList != NULL) {
        LocalFree(pPropertyList);
        pPropertyList = NULL;
    }

    VsTokenInfo.ProcessID = GetCurrentProcessId();
    VsTokenInfo.DesiredAccess = 0;
    VsTokenInfo.InheritHandle = FALSE;

    // Get the token of the virtual server
    rc = ClusterResourceControl(
                       hrNetworkName,
                       0,
                       CLUSCTL_RESOURCE_NETNAME_GET_VIRTUAL_SERVER_TOKEN,
                       &VsTokenInfo,
                       sizeof(CLUS_NETNAME_VS_TOKEN_INFO),
                       &hVSToken,
                       sizeof(HANDLE),
                       &dwReturnSize
                       );
    if (rc != ERROR_SUCCESS) {
        TSDISErrorOut(L"Get the virtual server token failed with error %d\n", rc);
        hVSToken = NULL;
        goto HandleError;
    }

    // Duplicate the virtual server token
    if(!DuplicateTokenEx(
            hVSToken,
            MAXIMUM_ALLOWED,
            NULL,
            SecurityImpersonation,
            TokenImpersonation,
            &g_hClusterToken)) {
        TSDISErrorOut(L"DuplicateTokenEx failed with error %d\n", GetLastError());
        CloseHandle(hVSToken);
        hVSToken = NULL;
        g_hClusterToken = NULL;

        goto HandleError;
    }
    if (hVSToken) {
        CloseHandle(hVSToken);
        hVSToken = NULL;
    }


    pszDriveLetter = new WCHAR[cchDriveLetter];

    if (pszDriveLetter == NULL) {
        TSDISErrorOut(L"Failed to allocate memory for drive letter.\n");
        goto HandleError;
    }

    // Get the drive we're supposed to use.
    dwError = ResUtilFindDependentDiskResourceDriveLetter(hclus, hrSD,
                                                          pszDriveLetter, &cchDriveLetter);

    if (dwError == ERROR_MORE_DATA) {
        // Wow, big drive letter!
        delete [] pszDriveLetter;
        pszDriveLetter = new WCHAR[cchDriveLetter];

        if (pszDriveLetter == NULL) {
            TSDISErrorOut(L"Failed to allocate memory for drive letter\n");
            goto HandleError;
        }

        dwError = ResUtilFindDependentDiskResourceDriveLetter(hclus, hrSD,
                                                              pszDriveLetter, &cchDriveLetter);
    }

    if (dwError != ERROR_SUCCESS) {
        TSDISErrorOut(L"Could not determine resource drive letter.\n");
        delete [] pszDriveLetter;
        pszDriveLetter = NULL;
        goto HandleError;
    }

    // Switch the working directory to that drive.
    if (SetCurrentDirectory(pszDriveLetter) == FALSE) {
        TSDISErrorOut(L"Could not set current directory to that of "
                      L"shared disk %s.  Error=%d\n", pszDriveLetter, 
                      GetLastError());
        delete [] pszDriveLetter;
        pszDriveLetter = NULL;
        goto HandleError;
    }
    fRet = TRUE;

HandleError:

    if (pszDriveLetter != NULL) {
        delete [] pszDriveLetter;
        pszDriveLetter = NULL;
    }
    if (pPropertyList != NULL) {
        LocalFree(pPropertyList);
        pPropertyList = NULL;
    }
    if (hrSD != NULL) {
        CloseClusterResource(hrSD);
        hrSD = NULL;
    }  
    if (hrNetworkName != NULL) {
        CloseClusterResource(hrNetworkName);
        hrNetworkName = NULL;
    }
    if (hclus != NULL) {
        CloseCluster(hclus);
        hclus = NULL;
    }
    return fRet;
}


HRESULT DISJetInitialize()
{
    JET_SESID sesid = JET_sesidNil;;
    JET_TABLEID sessdirtableid;
    JET_TABLEID servdirtableid;
    JET_TABLEID clusdirtableid;
    JET_DBID dbid = JET_dbidNil;

    JET_ERR err = JET_errSuccess;
    JET_TABLECREATE tSess;
    JET_COLUMNCREATE cSess[NUM_SESSDIRCOLUMNS];
    JET_TABLECREATE tServ;
    JET_COLUMNCREATE cServ[NUM_SERVDIRCOLUMNS];
    JET_TABLECREATE tClus;
    JET_COLUMNCREATE cClus[NUM_CLUSDIRCOLUMNS];
    unsigned count;
    DWORD dwError;
    BOOL br;
    SECURITY_ATTRIBUTES SA;
    SYSTEMTIME SystemTime;
    ULARGE_INTEGER ulCurrentTime;
    ULARGE_INTEGER ulLastTime;


    g_dwClusterState = ClusterStateNotInstalled;

    //
    // This is a string security descriptor.  Look up "Security Descriptor 
    // Definition Language" in MSDN for more details.
    //
    // This one says:
    //
    // D: <we are creating a DACL>
    // (A; <Allow ACE>
    // OICI; <Perform object and container inheritance, i.e., let files and 
    //        directories under this one have these attributes>
    // GA <Generic All Access--Full Control>
    // ;;;SY) <SYSTEM>
    // (A;OICI;GA;;;BA) <same for Builtin Administrators group>
    // (A;OICI;GA;;;CO) <same for creator/owner>
    //
    // We'll use it below to create our directory with the right permissions.

    WCHAR *pwszSD = L"D:(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)(A;OICI;GA;;;CO)";

    // Failover support--before reactivating, check logic versus reading curr directory from registry.


    // First, determine whether we are running in a cluster.  If so, files
    // will have to go on the shared drive.  If not, files will go in
    // JETDISDBDIRECTORYW.
    dwError = GetNodeClusterState(NULL, &g_dwClusterState);

    if (dwError != ERROR_SUCCESS) {
        g_dwClusterState = ClusterStateNotInstalled;
        TSDISErrorOut(L"TSDIS: Unable to get cluster state, err = %d\n", 
                      dwError);
    }

    // Do initialization if running on fail-over cluster
    if (g_dwClusterState == ClusterStateRunning) {
        if (!DISJetInitInCluster()) {
            goto HandleError;
        }
    }


    // Create security descriptor for database directory

    SA.nLength = sizeof(SECURITY_ATTRIBUTES);
    SA.bInheritHandle = FALSE;
    SA.lpSecurityDescriptor = NULL;
    br = ConvertStringSecurityDescriptorToSecurityDescriptor(pwszSD, 
                                                             SDDL_REVISION_1, &(SA.lpSecurityDescriptor), NULL);

    if (br == 0) {
        PostSessDirErrorValueEvent(EVENT_COULDNOTSECUREDIR, GetLastError(), EVENTLOG_ERROR_TYPE);
        goto HandleError;
    }

    // Create the system32\tssesdir directory.
    if (CreateDirectory(JETDISDBDIRECTORYW, &SA) == 0) {
        if (ERROR_ALREADY_EXISTS != (dwError = GetLastError())) {
            PostSessDirErrorValueEvent(EVENT_COULDNOTCREATEDIR, dwError, EVENTLOG_ERROR_TYPE);
            goto HandleError;
        }
    } else {
        // We created it successfully, so set the directory attributes to not 
        // compress.

        // Obtain a handle to the directory.
        HANDLE hSDDirectory = CreateFile(JETDISDBDIRECTORYW, GENERIC_READ | 
                                         GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, 
                                         OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

        if (INVALID_HANDLE_VALUE != hSDDirectory) {
            // We've succeeded opening the directory.

            USHORT CompressionState = COMPRESSION_FORMAT_NONE;
            USHORT OldCompressionState;
            DWORD BytesReturned = 0;

            // Get the current compression state.
            if (DeviceIoControl(hSDDirectory, FSCTL_GET_COMPRESSION,
                                NULL, 0, &OldCompressionState, sizeof(USHORT), 
                                &BytesReturned, NULL) != 0) {

                // If the current compression state is compressed, uncompress.
                if (OldCompressionState != COMPRESSION_FORMAT_NONE) {
                    if (DeviceIoControl(hSDDirectory, FSCTL_SET_COMPRESSION, 
                                        &CompressionState, sizeof(USHORT), NULL, 0, 
                                        &BytesReturned, NULL) == 0) {
                        // Set compression state failed--this should only be a trace,
                        // it may merely mean that the drive is FAT.
                        TSDISErrorOut(L"TSDIS: Set compression state off failed, "
                                      L"lasterr=0x%X\n", GetLastError());
                    } else {
                        PostSessDirErrorValueEvent(EVENT_UNDID_COMPRESSION, 0, EVENTLOG_ERROR_TYPE);
                    }
                }
            }

            CloseHandle(hSDDirectory);

        } else {
            // Nonfatal to have an error opening the directory
            TSDISErrorOut(L"TSDIS: Open directory to change compression state "
                          L"failed, lasterr=0x%X\n", GetLastError());
        }
    }

    // Open the timestamp file, compare with current time
    //  If the time difference is less than a limit, reuse the db
    //  otherwise delete db files
    g_hTimeFile = CreateFile(JETTIMESTAMPFILEW,
                             GENERIC_WRITE,
                             FILE_SHARE_WRITE,
                             &SA,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);
    if (g_hTimeFile == INVALID_HANDLE_VALUE) {
        // This file doesn't exist, create new one
        g_hTimeFile = CreateFile(JETTIMESTAMPFILEW,
                                 GENERIC_WRITE,
                                 FILE_SHARE_WRITE,
                                 &SA,
                                 CREATE_NEW,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);           
    } 
    else {
        if (GetFileTime(g_hTimeFile, NULL, NULL, (FILETIME *)&ulLastTime)) {
            GetSystemTime(&SystemTime);
            if (SystemTimeToFileTime(&SystemTime, (FILETIME *) &ulCurrentTime)) {
                if ((ulCurrentTime.QuadPart - ulLastTime.QuadPart) < g_TimeLimitToDeleteDB) {
                    if (g_dwClusterState == ClusterStateRunning) {
                        g_RepopulateSession = FALSE;
                        TSDISErrorOut(L"SD in restarted within a time limit, database can be reused\n");
                    }
                }
            }
        } 
        else
            TSDISErrorOut(L"SD is not restarted within a time limit, need to delete DB files \n");
    }

    // Recover Servers in Jet Database 
    if (g_RecoverWhenStart > NO_RECOVER_WHEN_START)
        DISJetRecover();
    // Delete database files if tssdis is not running on failover cluster
    //if (g_dwClusterState != ClusterStateRunning)
    if (g_RepopulateSession == TRUE)
        DeleteJetFiles();

    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramSystemPath, 
                               0, JETDISDBDIRECTORY));
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramTempPath,
                               0, JETDISDBDIRECTORY));
    //CALL(JetSetSystemParameter(&g_instance, 0, JET_paramMaxSessions,
    //        JETDISMAXSESSIONS, NULL));
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramLogFilePath,
                               0, JETDISDBDIRECTORY));
    CALL(JetSetSystemParameter(&g_instance, 0, JET_paramCircularLog,
                               1, NULL));

    CALL(JetInit(&g_instance));
    CALL(JetBeginSession(g_instance, &sesid, "user", ""));
    err = JetCreateDatabase(sesid, JETDBFILENAME, "", &dbid, 0);

    if (JET_errDatabaseDuplicate == err) {
        JET_COLUMNDEF jcd;

        err = JetAttachDatabase(sesid, JETDBFILENAME, 0);

        // if we get a wrnDatabaseAttached, then we have recovered.  Otherwise,
        // check the return value as usual.
        if (JET_wrnDatabaseAttached != err) {
            CALL(err);
        }

        // Populate our columnid arrays
        CALL(JetOpenDatabase(sesid, JETDBFILENAME, "", &dbid, 0));

        CALL(JetOpenTable(sesid, dbid, "SessionDirectory", NULL, 0, 0, 
                          &sessdirtableid));
        CALL(JetOpenTable(sesid, dbid, "ServerDirectory", NULL, 0, 0, 
                          &servdirtableid));
        CALL(JetOpenTable(sesid, dbid, "ClusterDirectory", NULL, 0, 0, 
                          &clusdirtableid));

        CALL(JetBeginTransaction(sesid));

        for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
            CALL(JetGetColumnInfo(sesid, dbid, "SessionDirectory", 
                                  SessionDirectoryColumns[count].szColumnName, &jcd, 
                                  sizeof(jcd), 0));
            sesdircolumnid[count] = jcd.columnid;
        }
        for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
            CALL(JetGetColumnInfo(sesid, dbid, "ServerDirectory",
                                  ServerDirectoryColumns[count].szColumnName, &jcd,
                                  sizeof(jcd), 0));
            servdircolumnid[count] = jcd.columnid;
        }
        for (count = 0; count < NUM_CLUSDIRCOLUMNS; count++) {
            CALL(JetGetColumnInfo(sesid, dbid, "ClusterDirectory",
                                  ClusterDirectoryColumns[count].szColumnName, &jcd,
                                  sizeof(jcd), 0));
            clusdircolumnid[count] = jcd.columnid;
        }

        CALL(JetCommitTransaction(sesid, 0));

        goto NormalExit;
    } else {
        CALL(err);
    }

    CALL(JetBeginTransaction(sesid));

    // Set up to create session directory schema
    tSess.cbStruct = sizeof(tSess);
    tSess.szTableName = "SessionDirectory";
    tSess.szTemplateTableName = NULL;
    tSess.ulPages = 0;
    tSess.ulDensity = 100;
    tSess.rgcolumncreate = &cSess[0];
    tSess.cColumns = NUM_SESSDIRCOLUMNS;
    tSess.rgindexcreate = NULL;
    tSess.cIndexes = 0;
    tSess.grbit = JET_bitTableCreateFixedDDL;

    for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
        cSess[count].cbStruct = sizeof(JET_COLUMNCREATE);
        cSess[count].szColumnName = SessionDirectoryColumns[count].szColumnName;
        cSess[count].coltyp = SessionDirectoryColumns[count].coltyp;
        cSess[count].cbMax = SessionDirectoryColumns[count].colMaxLen;
        cSess[count].grbit = 0;
        cSess[count].pvDefault = NULL;
        cSess[count].cbDefault = 0;
        cSess[count].cp = 1200;
        cSess[count].columnid = 0;
        cSess[count].err = JET_errSuccess;
    }


    // Actually create the session directory table.
    CALL(JetCreateTableColumnIndex(sesid, dbid, &tSess));

    // Store columnids, tableid for later reference.
    for (count = 0; count < NUM_SESSDIRCOLUMNS; count++) {
        sesdircolumnid[count] = cSess[count].columnid;
    }
    sessdirtableid = tSess.tableid;

    // Create server, session index.
    CALL(JetCreateIndex(sesid, sessdirtableid, "primaryIndex", 0, 
                        "+ServerID\0+SessionID\0", sizeof("+ServerID\0+SessionID\0"), 
                        100));
    // Create index by server for deletion.
    CALL(JetCreateIndex(sesid, sessdirtableid, "ServerIndex", 0,
                        "+ServerID\0", sizeof("+ServerID\0"), 100));
    // Create index for disconnected session retrieval.
    CALL(JetCreateIndex(sesid, sessdirtableid, "DiscSessionIndex", 0,
                        "+UserName\0+Domain\0+State\0", 
                        sizeof("+UserName\0+Domain\0+State\0"), 100));
    // Create index for all session retrieval.
    CALL(JetCreateIndex(sesid, sessdirtableid, "AllSessionIndex", 0,
                        "+UserName\0+Domain\0",
                        sizeof("+UserName\0+Domain\0"), 100));

    // Create server directory.
    tServ.cbStruct = sizeof(tServ);
    tServ.szTableName = "ServerDirectory";
    tServ.szTemplateTableName = NULL;
    tServ.ulPages = 0;
    tServ.ulDensity = 100;
    tServ.rgcolumncreate = &cServ[0];
    tServ.cColumns = NUM_SERVDIRCOLUMNS;
    tServ.rgindexcreate = NULL;
    tServ.cIndexes = 0;
    tServ.grbit = JET_bitTableCreateFixedDDL;

    for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
        cServ[count].cbStruct = sizeof(JET_COLUMNCREATE);
        cServ[count].szColumnName = ServerDirectoryColumns[count].szColumnName;
        cServ[count].coltyp = ServerDirectoryColumns[count].coltyp;
        cServ[count].cbMax = ServerDirectoryColumns[count].colMaxLen;
        cServ[count].grbit = 0;
        cServ[count].pvDefault = NULL;
        cServ[count].cbDefault = 0;
        cServ[count].cp = 1200;
        cServ[count].columnid = 0;
        cServ[count].err = JET_errSuccess;
    }
    // Set the autoincrement column to autoincrement
    cServ[0].grbit |= JET_bitColumnAutoincrement;

    CALL(JetCreateTableColumnIndex(sesid, dbid, &tServ));

    for (count = 0; count < NUM_SERVDIRCOLUMNS; count++) {
        servdircolumnid[count] = cServ[count].columnid;
    }
    servdirtableid = tServ.tableid;

    // Create Server Name (IP) index.
    CALL(JetCreateIndex(sesid, servdirtableid, "ServNameIndex", 0,
                        "+ServerAddress\0", sizeof("+ServerAddress\0"), 100));
    // Create Server DNS host Name index.
    CALL(JetCreateIndex(sesid, servdirtableid, "ServDNSNameIndex", 0,
                        "+ServerDNSName\0", sizeof("+ServerDNSName\0"), 100));
    // Create Server ID index.
    CALL(JetCreateIndex(sesid, servdirtableid, "ServerIDIndex", 0,
                        "+ServerID\0", sizeof("+ServerID\0"), 100));
    // Create Pending Reconnect index.
    CALL(JetCreateIndex(sesid, servdirtableid, "ServerAlmostInTimes", 0,
                        "+AlmostInTimeLow\0+AlmostInTimeHigh\0", 
                        sizeof("+AlmostInTimeLow\0+AlmostInTimeHigh\0"), 100));
    // Create the single session index.
    CALL(JetCreateIndex(sesid, servdirtableid, "SingleSessionIndex", 0,
                        "+ClusterID\0+SingleSessionMode\0", 
                        sizeof("+ClusterID\0+SingleSessionMode\0"), 100));
    // Create the ClusterID index.
    CALL(JetCreateIndex(sesid, servdirtableid, "ClusterIDIndex", 0,
                        "+ClusterID\0", sizeof("+ClusterID\0"), 100));

    // Create cluster directory.
    tClus.cbStruct = sizeof(tClus);
    tClus.szTableName = "ClusterDirectory";
    tClus.szTemplateTableName = NULL;
    tClus.ulPages = 0;
    tClus.ulDensity = 100;
    tClus.rgcolumncreate = &cClus[0];
    tClus.cColumns = NUM_CLUSDIRCOLUMNS;
    tClus.rgindexcreate = NULL;
    tClus.cIndexes = 0;
    tClus.grbit = JET_bitTableCreateFixedDDL;

    for (count = 0; count < NUM_CLUSDIRCOLUMNS; count++) {
        cClus[count].cbStruct = sizeof(JET_COLUMNCREATE);
        cClus[count].szColumnName = ClusterDirectoryColumns[count].szColumnName;
        cClus[count].coltyp = ClusterDirectoryColumns[count].coltyp;
        cClus[count].cbMax = ClusterDirectoryColumns[count].colMaxLen;
        cClus[count].grbit = 0;
        cClus[count].pvDefault = NULL;
        cClus[count].cbDefault = 0;
        cClus[count].cp = 1200;
        cClus[count].columnid = 0;
        cClus[count].err = JET_errSuccess;
    }
    // Set the autoincrement column to autoincrement
    cClus[0].grbit |= JET_bitColumnAutoincrement;

    CALL(JetCreateTableColumnIndex(sesid, dbid, &tClus));

    for (count = 0; count < NUM_CLUSDIRCOLUMNS; count++) {
        clusdircolumnid[count] = cClus[count].columnid;
    }
    clusdirtableid = tClus.tableid;

    // Create Cluster Name index.
    CALL(JetCreateIndex(sesid, clusdirtableid, "ClusNameIndex", 
                        JET_bitIndexUnique, "+ClusterName\0", sizeof("+ClusterName\0"), 
                        100));
    // Create cluster ID index.
    CALL(JetCreateIndex(sesid, clusdirtableid, "ClusIDIndex", 0,
                        "+ClusterID\0", sizeof("+ClusterID\0"), 100));


    CALL(JetCommitTransaction(sesid, 0));

    // Tables were opened with exclusive access from CreateTableColumnIndex.
    // Close them now.
NormalExit:
    CALL(JetCloseTable(sesid, sessdirtableid));
    CALL(JetCloseTable(sesid, servdirtableid));
    CALL(JetCloseTable(sesid, clusdirtableid));

    CALL(JetCloseDatabase(sesid, dbid, 0));

    CALL(JetEndSession(sesid, 0));

    LocalFree(SA.lpSecurityDescriptor);
    SA.lpSecurityDescriptor = NULL;

#ifdef DBG
    OutputAllTables();
#endif // DBG

    return 0;

HandleError:
    if (sesid != JET_sesidNil) {
        // Can't really recover.  Just bail out.
        (VOID) JetRollback(sesid, JET_bitRollbackAll);

        // Force the session closed
        (VOID) JetEndSession(sesid, JET_bitForceSessionClosed);
    }

    if (SA.lpSecurityDescriptor != NULL) {
        LocalFree(SA.lpSecurityDescriptor);
        SA.lpSecurityDescriptor = NULL;
    }                                             

    PostSessDirErrorValueEvent(EVENT_JET_COULDNT_INIT, err, EVENTLOG_ERROR_TYPE);

    exit(1);
}


/****************************************************************************/
// DISCleanupGlobals
//
// Common cleanup code for SQL and Jet code paths.
/****************************************************************************/
void DISCleanupGlobals()
{
    if (g_hStopServiceEvent != NULL) {
        CloseHandle(g_hStopServiceEvent);
        g_hStopServiceEvent = NULL;
    }

    if (g_hFileOutput != INVALID_HANDLE_VALUE) {
        if (CloseHandle(g_hFileOutput) == 0) {
            ERR((TB, "CloseHandle on output file failed: lasterr=0x%X", 
                    GetLastError()));
        }
        g_hFileOutput = INVALID_HANDLE_VALUE;
    }

    if (g_hTimeFile != INVALID_HANDLE_VALUE) {
        CloseHandle(g_hTimeFile);
        g_hTimeFile =  INVALID_HANDLE_VALUE;
    }

    if (g_ClusterNetworkName != NULL) {
        LocalFree(g_ClusterNetworkName);
        g_ClusterNetworkName = NULL;
    }

    if (g_hClusterToken) {
        CloseHandle(g_hClusterToken);
        g_hClusterToken = NULL;
    }
}


#if 0
/****************************************************************************/
// DISCallSPForServer
//
// Generic function to call a stored procedure that takes a ServerAddress as an
// argument.
/****************************************************************************/
void DISCallSPForServer(WCHAR *StoredProcName, WCHAR *ServerAddress) {
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;


    hr = CreateADOStoredProcCommand(StoredProcName, &pCommand, &pParameters);

    if (SUCCEEDED(hr)) {
        hr = AddADOInputStringParam(ServerAddress, L"ServerAddress", 
                pCommand, pParameters, FALSE);
        if (SUCCEEDED(hr)) {
            // Execute the command.
            hr = pCommand->Execute(NULL, NULL, adCmdStoredProc, 
                    &pResultRecordSet);
            if (SUCCEEDED(hr)) {
                pResultRecordSet->Release();
            } else {
                ERR((TB, "DISCallSPForServer: Failed Execute, hr = 0x%X", 
                        hr));
            }
        }
        else {
            ERR((TB,"DISCallSPForServer: Failed add parameter, hr=0x%X", hr));
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"DISCallSPForServer: Failed create cmd, hr=0x%X", hr));
    }
}
#endif


/****************************************************************************/
// DISJetHandleDeadServer
//
// When a server is not responding, this function call sends the command to the
// Jet database to remove all entries pertaining to that server.
/****************************************************************************/
void DISJetHandleDeadServer(WCHAR *ServerAddress, DWORD ServerID) {
    // FailureCount is initially set to 1, TRUE, to tell SetServerAITInternal
    // to increment the failure count and return the resultant count.
    DWORD FailureCount = 1;

    TSSDSetServerAITInternal(ServerAddress, FALSE, &FailureCount);

    TSDISErrorOut(L"Server %s (%d) not responding (Failure Count: %d).\n",
            ServerAddress, ServerID, FailureCount);

    if (FailureCount >= g_NumberFailedPingsBeforePurge)
        TSSDPurgeServer(ServerID);
}


// TODO: Possible optimization: pass in ServerID
void DISJetSetServerPingSuccessful(WCHAR *ServerAddress) {
    TSSDSetServerAITInternal(ServerAddress, TRUE, NULL);
}


#if 0
/****************************************************************************/
// DISSQLHandleDeadServer
//
// When a server is not responding, this function call sends the command to the
// database to execute SP_TSDISServerNotResponding.
/****************************************************************************/
void DISSQLHandleDeadServer(WCHAR *ServerAddress) {
    DISCallSPForServer(L"SP_TSDISServerNotResponding", ServerAddress);
}


void DISSQLSetServerPingSuccessful(WCHAR *ServerAddress) {
    DISCallSPForServer(L"SP_TSDISSetServerPingSuccessful", ServerAddress);
}
#endif


VOID DISCtrlHandler(DWORD opcode) {

    switch(opcode)
    {
    //case SERVICE_CONTROL_PAUSE:
        // pause
    //    g_DISStatus.dwCurrentState = SERVICE_PAUSED;
    //    break;

    //case SERVICE_CONTROL_CONTINUE:
        // continue
    //    g_DISStatus.dwCurrentState = SERVICE_RUNNING;
    //    break;

    case SERVICE_CONTROL_STOP:
        //stop
        g_DISStatus.dwWin32ExitCode = 0;
        g_DISStatus.dwCurrentState = SERVICE_STOP_PENDING;
        g_DISStatus.dwCheckPoint = 0;
        g_DISStatus.dwWaitHint = 0;

        if (!SetServiceStatus(g_DISStatusHandle, &g_DISStatus)) {
            ERR((TB, "SetServiceStatus failed"));
        }

        // Here is where to actually stop the service
        SetEvent(g_hStopServiceEvent);
        // Should I wait for that to complete?

        return;

    case SERVICE_CONTROL_INTERROGATE:
        // fall through to return current status
        break;

    default:
        ERR((TB, "Unrecognized opcode to DISCtrlHandler - 0x%08x", opcode));
    }

    // send current status
    if (!SetServiceStatus(g_DISStatusHandle, &g_DISStatus)) {
        ERR((TB, "SetServiceStatus failed"));
    }
}


void DISDirectoryIntegrityLoop() {
    CVar varRows;
    WCHAR *ServerAddress;
#if 0
    WCHAR ServerAddressBuf[SERVER_ADDRESS_LENGTH];
#endif
    WCHAR ServerAddressRows[10][SERVER_ADDRESS_LENGTH];
    DWORD ServerIDs[10];
    long NumSessionsReturned = 0;
#if 0
    HRESULT hr = S_OK;
#endif
    SERVER_STATUS ServerStatus;
    DWORD EventStatus;

#if 0
    ServerAddress = ServerAddressBuf; // In SQL case, we need a static buffer
#endif

#if 0
    TSDISErrorOut(L"%s active\n", g_bUseSQL ? L"Directory Integrity Service" : 
            L"Session Directory");
#endif

    TSDISErrorOut(L"Session Directory Active\n");
            
    // Loop forever
    for ( ; ; ) {
        // Retrieve set of servers that have disconnected sessions pending
        // reconnects
#if 0
        if (g_bUseSQL == FALSE)
#endif
            DISJetGetServersPendingReconnects(&NumSessionsReturned,
                    ServerAddressRows, ServerIDs);
#if 0
        else
            DISSQLGetServersPendingReconnects(&NumSessionsReturned, 
                    &varRows);
#endif

        // For each server,
        for (DWORD i = 0; i < (unsigned)NumSessionsReturned; i++) {
#if 0
            if (g_bUseSQL == FALSE)
#endif

            ServerAddress = ServerAddressRows[i];

#if 0
            else
                hr = GetRowArrayStringField(varRows.parray, i, 0,
                        ServerAddress, sizeof(ServerAddressBuf) /
                        sizeof(WCHAR) - 1);

            if (FAILED(hr)) {
                ERR((TB,"DISDirectoryIntegrityLoop: Row %u returned hr=0x%X",
                        i, hr));
            }
#endif

            ServerStatus = DISGetServerStatus(ServerAddress);

            // if the server does not respond, handle dead server.
            // The function we call will do the right thing, which may be
            // to purge immediately, or may be to simply increment a failure
            // count.
            if (ServerStatus == NotResponding) {
#if 0
                if (FALSE == g_bUseSQL)
#endif
                DISJetHandleDeadServer(ServerAddress, ServerIDs[i]);
#if 0
                else
                    DISSQLHandleDeadServer(ServerAddress);
#endif

#ifdef DBG
                OutputAllTables();
#endif // DBG
            } 
            // else stop pinging
            else if (ServerStatus == Responding) {
#if 0
                if (FALSE == g_bUseSQL)
#endif
                    DISJetSetServerPingSuccessful(ServerAddress);
#if 0
                else
                    DISSQLSetServerPingSuccessful(ServerAddress);
#endif
            }
            else {
                ERR((TB, "DISDirectoryIntegrityLoop: ServerStatus enum has bad "
                        "value %d", ServerStatus));
            }
        }
        // Wait DISNumberSecondsBetweenPings
        EventStatus = WaitForSingleObjectEx(g_hStopServiceEvent, 
                DISNumberSecondsBetweenPings * 1000, FALSE);
        if (EventStatus == WAIT_TIMEOUT) {
            // do normal stuff
            continue;
        } else if (EventStatus == WAIT_OBJECT_0) {
            // the event was signaled -- clean up
            DISDeleteLocalGroupSecDes();
            break;
        } else if (EventStatus == -1) {
            // there is an error
        } else {
            // weird output from that function
        } 
    }
}
    

#if 0
/****************************************************************************/
// DISSQLStart
//
// Service main entry point for when the service is configured to verify
// SQL tables.
/****************************************************************************/
VOID DISSQLStart(DWORD argc, LPTSTR *argv) {
    HRESULT hr = S_OK;

    // unreferenced parameters
    argv;
    argc;
    
    g_DISStatus.dwServiceType = SERVICE_WIN32;
    g_DISStatus.dwCurrentState = SERVICE_START_PENDING;
    g_DISStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    g_DISStatus.dwWin32ExitCode = 0;
    g_DISStatus.dwServiceSpecificExitCode = 0;
    g_DISStatus.dwCheckPoint = 0;
    g_DISStatus.dwWaitHint = 0;
    g_DISStatusHandle = RegisterServiceCtrlHandler(
            _T("Directory Integrity Service"), DISCtrlHandler);
    if (g_DISStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        ERR((TB, "DISSQLStart: RegisterServiceCtrlHandler failed"));
        goto ExitFunc;
    }

    // Initialization code goes here
    hr = DISSQLInitialize();
    if (FAILED(hr)) {
        ERR((TB, "DISSQLStart: DISSQLInitialize failed"));
        goto PostRegisterService;
    }

    g_DISStatus.dwCurrentState = SERVICE_RUNNING;
    g_DISStatus.dwCheckPoint = 1;
    if (!SetServiceStatus(g_DISStatusHandle, &g_DISStatus)) {
        ERR((TB, "DISSQLStart: SetServiceHandler failed"));
        goto PostRegisterService;
    }

    DISDirectoryIntegrityLoop();

PostRegisterService:
    g_DISStatus.dwCurrentState = SERVICE_STOPPED;
    g_DISStatus.dwCheckPoint = 2;
    SetServiceStatus(g_DISStatusHandle, &g_DISStatus);

ExitFunc:
    DISCleanupGlobals();
}
#endif


BOOL DISGetSDAdminSid()
{
    DWORD cbSid = 0;
    DWORD dwErr;
    BOOL rc = FALSE;

    if (!CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, NULL, &cbSid)) {
        dwErr = GetLastError();
        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {
            g_pAdminSid = LocalAlloc(LMEM_FIXED, cbSid);
        }
        else {
            TSDISErrorOut(L"DISGetSDAdminSid: CreateWellKnownSid fails with %u\n", GetLastError());
            goto HandleError;
        }
    }
    else {
        goto HandleError;
    }

    if (NULL == g_pAdminSid) {
        TSDISErrorOut(L"DISGetSDAdminSid: Memory allocation fails with %u\n", GetLastError());
        goto HandleError;
    }

	if (!CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, g_pAdminSid, &cbSid)) {
        g_pAdminSid = NULL;
        TSDISErrorOut(L"DISGetSDAdminSid: CreateWellKnownSid fails with %u\n", GetLastError());
        goto HandleError;
    }
    rc = TRUE;

HandleError:
    return rc;
}


/****************************************************************************/
// DISCreateLocalGroupSecDes
//
// Create Session Directory Computers local group if not exist
// and create the security descriptor of this local group
/****************************************************************************/
BOOL DISCreateLocalGroupSecDes()
{
    DWORD Error;
    ULONG SidSize, ReferencedDomainNameSize;
    LPWSTR ReferencedDomainName = NULL;
    SID_NAME_USE SidNameUse;
    WCHAR SDLocalGroupName[SDLOCALGROUPNAMELENGTH];
    WCHAR SDLocalGroupDes[SDLOCALGROUPDESLENGTH];
    GROUP_INFO_1 SDGroupInfo = {SDLocalGroupName, SDLocalGroupDes};
    HMODULE HModule = NULL;
    LPBYTE pbBuffer = NULL;
    DWORD dwEntriesRead = 0, dwTotalEntry = 0;
    DWORD_PTR resumehandle = NULL;
   
    NET_API_STATUS NetStatus;
    BOOL rc = FALSE;

    HModule = GetModuleHandle(NULL);
    if (HModule == NULL) {
        Error = GetLastError();
        TSDISErrorOut(L"GetModuleHandle returns error : %u\n", Error);
        goto HandleError;
    }
    if (!LoadString(HModule, IDS_SDLOCALGROUP_NAME, SDLocalGroupName, sizeof(SDLocalGroupName) / sizeof(WCHAR)) ||
        !LoadString(HModule, IDS_SDLOCALGROUP_DES, SDLocalGroupDes, sizeof(SDLocalGroupDes) / sizeof(WCHAR)))
    {
        TSDISErrorOut(L"LoadString fails with %u\n", GetLastError());
        goto HandleError;
    }
    // Create local group if not exist
    NetStatus = NetLocalGroupAdd(
                NULL,
                1,
                (LPBYTE)&SDGroupInfo,
                NULL
                );

    if(NERR_Success != NetStatus) {
        if((NERR_GroupExists != NetStatus)
           && (ERROR_ALIAS_EXISTS != NetStatus)) {
            //
            // Didn't create the group and group doesn't exist either.
            //
            
            TSDISErrorOut(L"NetLocalGroupAdd(%s) returns error: %u\n",
                            SDGroupInfo.grpi1_name, NetStatus);
            goto HandleError;
        }
    }
    
    //
    // Group created. Now lookup the SID.
    //
    SidSize = ReferencedDomainNameSize = 0;
    ReferencedDomainName = NULL;
    NetStatus = LookupAccountName(
                NULL,
                SDGroupInfo.grpi1_name,
                g_pSid,
                &SidSize,
                ReferencedDomainName,
                &ReferencedDomainNameSize,
                &SidNameUse);
    if( NetStatus ) 
        goto HandleError;       
        
    Error = GetLastError();
    if( ERROR_INSUFFICIENT_BUFFER != Error ) 
        goto HandleError;
        
    g_pSid = (PSID)LocalAlloc(LMEM_FIXED, SidSize);
    if (NULL == g_pSid) {
        goto HandleError;
    }
    ReferencedDomainName = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                              sizeof(WCHAR)*(1+ReferencedDomainNameSize));
    if (NULL == ReferencedDomainName) {
        goto HandleError;
    }
        
    NetStatus = LookupAccountName(
                NULL,
                SDGroupInfo.grpi1_name,
                g_pSid,
                &SidSize,
                ReferencedDomainName,
                &ReferencedDomainNameSize,
                &SidNameUse
                );
    if( 0 == NetStatus ) {
        //
        // Failed.
        //
        Error = GetLastError();
        TSDISErrorOut(L"LookupAccountName failed with %u\n", Error);            
        goto HandleError;
    }
        
    // Get the members of the local group
    NetStatus = NetLocalGroupGetMembers(
                    NULL,
                    SDGroupInfo.grpi1_name,
                    0,
                    &pbBuffer,
                    MAX_PREFERRED_LENGTH,
                    &dwEntriesRead,
                    &dwTotalEntry,
                    &resumehandle
                    );
    if (NERR_Success == NetStatus) {
        if (dwEntriesRead == 0) {
            // Th group is emptry, throw the event log
            PostSessDirErrorMsgEvent(EVENT_SD_GROUP_EMPTY, SDGroupInfo.grpi1_name, EVENTLOG_WARNING_TYPE);
        }
        else {
            if (pbBuffer) {
                NetApiBufferFree(pbBuffer);
                pbBuffer = NULL;
            }
        }
    }
    else {
        TSDISErrorOut(L"NetLocalGroupGetMembersfailed with %d\n", NetStatus);
    }

    rc = TRUE;
    return rc;

HandleError:
    if (ReferencedDomainName)
        LocalFree(ReferencedDomainName);
    // Clean
    DISDeleteLocalGroupSecDes();

    return rc;
}

void DISDeleteLocalGroupSecDes()
{
    if (g_pSid) {
        LocalFree(g_pSid);
        g_pSid = NULL;
    }

    if (g_pAdminSid) {
        LocalFree(g_pAdminSid);
        g_pAdminSid = NULL;
    }
}

/****************************************************************************/
// DISJetStart
//
// Service main entry point for when the service is configured to act as
// an RPC server and use Jet for all session directory transactions.
/****************************************************************************/
VOID DISJetStart(DWORD argc, LPTSTR *argv) {
    RPC_STATUS Status;
    RPC_BINDING_VECTOR *pBindingVector = 0;
    RPC_POLICY rpcpol = {sizeof(rpcpol), 0, 0};
    WCHAR *szPrincipalName = NULL;

    // unreferenced parameters
    argv;
    argc;


    g_DISStatus.dwServiceType = SERVICE_WIN32;
    g_DISStatus.dwCurrentState = SERVICE_START_PENDING;
    g_DISStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    g_DISStatus.dwWin32ExitCode = 0;
    g_DISStatus.dwServiceSpecificExitCode = 0;
    g_DISStatus.dwCheckPoint = 0;
    g_DISStatus.dwWaitHint = 0;

    if (g_bDebug == FALSE) {
        g_DISStatusHandle = RegisterServiceCtrlHandler(
                _T("Directory Integrity Service"), DISCtrlHandler);

        if (g_DISStatusHandle == (SERVICE_STATUS_HANDLE)0) {
            ERR((TB, "DISJetStart: RegisterServiceCtrlHandler failed"));
            goto ExitFunc;
        }
    }

    // Init the RPC server interface.
    // Register the named pipe. This uses NT domain authentication.

    /*
    Status = RpcServerUseProtseqEp(
            L"ncacn_np",  // Protocol Sequence
            NUM_JETRPC_THREADS,  // Maximum calls at one time
            L"\\pipe\\TSSD_Jet_RPC_Service",  // Endpoint
            NULL);  // Security
    */

    if (!DISCreateLocalGroupSecDes()) {
        ERR((TB,"DISJetStart: Error in DISCreateLocalGroupSecDEs"));
        goto PostRegisterService;
    }

    // Get the Sid of the Admin of SD machine
    DISGetSDAdminSid();

    Status = RpcServerUseProtseqEx(L"ncacn_ip_tcp", 3, 0, &rpcpol);
    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d RpcUseProtseqEp on ncacn_ip_tcp", 
                Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_USEPROTSEQ, Status, EVENTLOG_ERROR_TYPE);
        goto PostRegisterService;
    }

    // Register our interface handle (found in jetrpc.h).
    Status = RpcServerRegisterIfEx(TSSDJetRPC_ServerIfHandle, NULL, NULL,
                                    0, RPC_C_LISTEN_MAX_CALLS_DEFAULT, SDRPCAccessCheck);
    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d RegIf", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_REGISTERIF, Status, EVENTLOG_ERROR_TYPE);
        goto PostRegisterService;
    }   

    Status = RpcServerInqBindings(&pBindingVector);

    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d InqBindings", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_INQBINDINGS, Status, EVENTLOG_ERROR_TYPE);
        goto PostRegisterService;
    }

    Status = RpcEpRegister(TSSDJetRPC_ServerIfHandle, pBindingVector, 0, 0);
    // TODO: Probably need to unregister, maybe delete some binding vector.

    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d EpReg", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_EPREGISTER, Status, EVENTLOG_ERROR_TYPE);
        goto PostRegisterService;
    }

    Status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, &szPrincipalName);
    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d ServerIngDefaultPrincName", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_INGPRINCNAME, Status, EVENTLOG_ERROR_TYPE);
        goto PostRegisterService;
    }

    Status = RpcServerRegisterAuthInfo(szPrincipalName, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL);
    RpcStringFree(&szPrincipalName);
    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d ServerRegisterAuthInfo", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_REGAUTHINFO, Status, EVENTLOG_ERROR_TYPE);
        goto PostRegisterService;
    }


    // Now initialize the JET database
    DISJetInitialize();

    // Init the RPC to support the query for SD
    Status = SDInitQueryRPC();
    if (Status != RPC_S_OK) {
        TSDISErrorOut(L"SDInitQueryRPC fails with %d\n", Status);
    }

    // Now do the RPC listen to service calls
    Status = RpcServerListen(1, RPC_C_LISTEN_MAX_CALLS_DEFAULT, TRUE);
    if (Status != RPC_S_OK) {
        ERR((TB,"DISJetStart: Error %d ServerListen", Status));
        PostSessDirErrorValueEvent(EVENT_FAIL_RPC_LISTEN, Status, EVENTLOG_ERROR_TYPE);
        goto PostRegisterService;
    }

    // We are now up.
    g_DISStatus.dwCurrentState = SERVICE_RUNNING;
    g_DISStatus.dwCheckPoint = 1;
    if (g_bDebug == FALSE)
        SetServiceStatus(g_DISStatusHandle, &g_DISStatus);

    // Now we have the RPC server running, we can just wait for the
    // service-stop event to be fired to let us know we need to exit.
    // We do this inside the Directory Integrity Loop.
    DISDirectoryIntegrityLoop();

    // Time to clean up.
    // Kill the RPC listener.
    RpcServerUnregisterIf(TSSDJetRPC_ServerIfHandle, NULL, NULL);
    RpcServerUnregisterIf(TSSDQUERYRPC_ServerIfHandle, NULL, NULL);
    
    TSDISErrorOut(L"Session Directory Stopped\n");

    JetTerm(g_instance);

PostRegisterService:    

    g_DISStatus.dwCurrentState = SERVICE_STOPPED;
    g_DISStatus.dwCheckPoint = 2;
    if (g_bDebug == FALSE) {
        if (!SetServiceStatus(g_DISStatusHandle, &g_DISStatus)) {
            ERR((TB, "SetServiceStatus failed: %d", GetLastError()));
        }
    }

ExitFunc:
    DISCleanupGlobals();
}


/****************************************************************************/
// DISInstallService
//
// Used to install the service, returns 0 on success, nonzero otherwise.
/****************************************************************************/
int DISInstallService() {
    WCHAR wzModulePathname[MAX_PATH];
    SC_HANDLE hSCM = NULL, hService = NULL;

    if (0 != GetModuleFileNameW(NULL, wzModulePathname, MAX_PATH)) {
        hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CREATE_SERVICE);
        if (hSCM != NULL) {
            hService = CreateServiceW(hSCM, L"Directory Integrity Service",
                    L"Directory Integrity Service", 0, 
                    SERVICE_WIN32_OWN_PROCESS, SERVICE_DEMAND_START,
                    SERVICE_ERROR_NORMAL, wzModulePathname, NULL, NULL, NULL,
                    NULL, NULL);
            if (hService != NULL) {
                CloseServiceHandle(hService);
                CloseServiceHandle(hSCM);
            } else {
                ERR((TB, "CreateService failed, error = 0x%X", GetLastError()));
                CloseServiceHandle(hSCM);
                return -1;
            }
        } else {
            ERR((TB, "OpenSCManager failed, error = 0x%X", GetLastError()));
            return -1;
        }
    } else {
        ERR((TB, "GetModuleFileNameW failed, error = 0x%X", GetLastError()));
        return -1;
    }

    return 0;
}


/****************************************************************************/
// DISRemoveService()
//
// Used to remove the service, returns 0 on success, nonzero otherwise.
/****************************************************************************/
int DISRemoveService() {
    SC_HANDLE hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_CONNECT);

    if (hSCM != NULL) {
        // Open this service for DELETE access
        SC_HANDLE hService = OpenServiceW(hSCM, L"Directory Integrity Service",
                DELETE);
        if (hService != NULL) {
            // Remove this service from the SCM's database.
            DeleteService(hService);
            CloseServiceHandle(hService);
            CloseServiceHandle(hSCM);

            return 0;
        } else {
            ERR((TB, "Failure opening service for delete, error = 0x%X", 
                    GetLastError()));
        }
        CloseServiceHandle(hService);
    } else {
        ERR((TB, "Failure opening SC Manager, error = 0x%X", GetLastError()));
    }

    return -1;
}


// Reads a DWORD value out of the registry.
//
// In:
//  hKey - an open HKEY
//  RegValName - the name of the registry value
//  pValue - pointer to the value.  The value will be set to the registry value
//    if the registry operation is a success, else it will remain untouched.
//
// Out:
//  0 if success, nonzero otherwise
int ReadRegVal(HKEY hKey, WCHAR *RegValName, DWORD *pValue)
{
    DWORD RegRetVal;
    DWORD Type, Temp, Size;

    Size = sizeof(Temp);
    RegRetVal = RegQueryValueExW(hKey, RegValName, NULL, &Type,
            (BYTE *)&Temp, &Size);
    if (RegRetVal == ERROR_SUCCESS) {
        *pValue = Temp;
        return 0;
    }
    else {
        TRC1((TB, "TSSDIS: Failed RegQuery for %S - "
                "err=%u, DataSize=%u, type=%u\n",
                RegValName, RegRetVal, Size, Type));
        return -1;
    }

}


// Reads a Unicode text value out of the registry.
//
// hKey (IN) - an open HKEY
// RegValName (IN) - the name of the registry value
// pText (IN/OUT) - pointer to the buffer to which to write.
// cbData (IN) - size of buffer IN BYTES
//
// returns 0 if success, nonzero otherwise.
int ReadRegTextVal(HKEY hKey, WCHAR *RegValName, WCHAR *pText, DWORD cbData)
{
    DWORD RegRetVal;
    DWORD Type, Size;

    Size = cbData;

    RegRetVal = RegQueryValueExW(hKey, RegValName, NULL, &Type,
            (BYTE *)pText, &Size);

    if (RegRetVal == ERROR_SUCCESS) {
        return 0;
    }
    else {
        TRC1((TB, "TSSDIS: Failed RegQuery for %S - err=%u, DataSize=%u, "
                "type=%u\n", RegValName, RegRetVal, Size, Type));
        return -1;
    }
}

// Reads configuration from the registry and sets global variables.
void ReadConfigAndSetGlobals()
{
    DWORD RegRetVal;
    HKEY hKey;
    DWORD Temp;
    WCHAR WorkingDirectory[MAX_PATH];
    WCHAR *pwszSD = L"D:(A;OICI;GA;;;SY)(A;OICI;GA;;;BA)(A;OICI;GA;;;CO)";
    SECURITY_ATTRIBUTES SA;
    BOOL br;

    // Open the service settings regkey and grab the UseJet flag.
    // Absence of the key or the setting means no jet.
#if 0
    g_bUseSQL = FALSE;
#endif
    RegRetVal = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            REG_SESSION_DIRECTROY_CONTROL, 0, KEY_READ, &hKey);
    if (RegRetVal == ERROR_SUCCESS) {

        // With each of these calls, an error is non-fatal.
#if 0
        // Query UseSQL value.
        ReadRegVal(hKey, L"UseSQL", &g_bUseSQL);
#endif

        // Query PingMode value.  Note this is an enum so sending the variable
        // in directly is illegal.
        if (ReadRegVal(hKey, L"PingMode", &Temp) == 0) {

            // Make sure this is a legal value for the enum.
            if (Temp > AlwaysFail)
                Temp = NormalMode;

            g_PingMode = (PingMode) Temp;
        }

        // Query TraceOutputMode value.  As above, enum means don't set it
        // directly.
        if (ReadRegVal(hKey, L"TraceOutputMode", &Temp) == 0) {

            // Make sure this is a legal value for the enum.
            if (Temp > FileOutput)
                Temp = NoTraceOutput;

            g_TraceOutputMode = (TraceOutputMode) Temp;

        }

        // Query NumberFailedPingsBeforePurge.
        ReadRegVal(hKey, L"NumberFailedPingsBeforePurge", 
                &g_NumberFailedPingsBeforePurge);

        // Query TimeBetweenPings.
        ReadRegVal(hKey, L"TimeBetweenPings", &DISNumberSecondsBetweenPings);

        // Query TimeServerSilentBeforePing.
        if (ReadRegVal(hKey, L"TimeServerSilentBeforePing", &Temp) == 0) {
            g_TimeServerSilentBeforePing = (ULONGLONG) Temp * 
                    FILETIME_INTERVAL_TO_SECONDS_MULTIPLIER;
        }

        // Query Working Directory
        if (ReadRegTextVal(hKey, L"WorkingDirectory", WorkingDirectory, 
                sizeof(WorkingDirectory)) == 0) {
            if (SetCurrentDirectory(WorkingDirectory) == 0) {
                DWORD Err;

                Err = GetLastError();
                PostSessDirErrorValueEvent(EVENT_PROBLEM_SETTING_WORKDIR, Err, EVENTLOG_ERROR_TYPE);
                ERR((TB, "TERMSRV: Unable to set directory to value read from "
                        "registry.  LastErr=0x%X", Err));
            }
        }
        
        // Query if we reover previous jet database when starting SD
        ReadRegVal(hKey, L"RecoverWhenStart", &g_RecoverWhenStart);
        
        RegCloseKey(hKey);

        // Now, if in file output mode, open the file.
        if (g_TraceOutputMode == FileOutput) {
            // Create security descriptor for the log file
            SA.nLength = sizeof(SECURITY_ATTRIBUTES);
            SA.bInheritHandle = FALSE;
            SA.lpSecurityDescriptor = NULL;
            br = ConvertStringSecurityDescriptorToSecurityDescriptor(pwszSD, 
                SDDL_REVISION_1, &(SA.lpSecurityDescriptor), NULL);

            if (br == TRUE) {
                g_hFileOutput = CreateFile(DEBUG_LOG_FILENAME, GENERIC_WRITE,
                        FILE_SHARE_READ, &SA, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,
                        NULL);

                if (g_hFileOutput == INVALID_HANDLE_VALUE) {
                    ERR((TB, "Could not open debug log file, lasterror=0x%X", 
                            GetLastError()));
                    g_TraceOutputMode = NoTraceOutput;
                } 
                else {
                    DWORD dwRetVal = 0;
                    // Set the insertion point to the end of the file and output 
                    // something.
                    dwRetVal = SetFilePointer(g_hFileOutput, 0, NULL, FILE_END);

                    if (dwRetVal == INVALID_SET_FILE_POINTER) {
                        ERR((TB, "Could not set to end of file, lasterror=0x%X",
                                GetLastError()));
                        g_TraceOutputMode = NoTraceOutput;
                    }
                    else {
                        DWORD dwBytesWritten = 0;
                        char *pszIntro = "\n\nNEW INSTANCE\n";
                    
                        if (WriteFile(g_hFileOutput, pszIntro, 
                                (DWORD) strlen(pszIntro), &dwBytesWritten, 
                                NULL) == 0) {
                            ERR((TB, "WriteFile failed, lasterr=0x%X", 
                                    GetLastError()));
                        }
                    }
                }
            }
            else {
                ERR((TB, "ConvertStringSecurityDescriptorToSecurityDescriptor fails with 0x%X",
                                GetLastError()));
                g_TraceOutputMode = NoTraceOutput;
            }
        }

    }
    else {
        WRN((TB,"TERMSRV: Unable to open settings key in HKLM, "
                "lasterr=0x%X", GetLastError()));
    }
}


/*****************************************************************************
 *  SDInitQueryRPC
 *
 *   Setup the RPC bindings, and listen for incoming requests.
 ****************************************************************************/
RPC_STATUS
SDInitQueryRPC(VOID)
{
    RPC_STATUS Status;

    // register the LPC (local only) interface
    Status = RpcServerUseProtseqEp(
                 L"ncalrpc",      // Protocol Sequence (LPC)
                 NUM_JETRPC_THREADS,  // Maximum calls at one time
                 SD_QUERY_ENDPOINT_NAME,    // Endpoint
                 NULL           // Security
                 );

    if( Status != RPC_S_OK ) {
        ERR((TB,"SDInitQueryRPC: Error %d RpcuseProtseqEp on ncalrpc", Status));
        return( Status );
    }

    Status = RpcServerRegisterIfEx(TSSDQUERYRPC_ServerIfHandle, NULL, NULL,
                                    0, RPC_C_LISTEN_MAX_CALLS_DEFAULT, SDQueryRPCAccessCheck);
    if( Status != RPC_S_OK ) {
        ERR((TB,"SDInitQueryRPC: Error %d RpcServerRegisterIf", Status));
        return( Status );
    }

    return RPC_S_OK;
}


int __cdecl main() {
    int nArgc;
    WCHAR **ppArgv = (WCHAR **) CommandLineToArgvW(GetCommandLineW(), &nArgc);
    BOOL fStartService = (nArgc < 2);
    int i;
    HANDLE hMutex;

    if ((fStartService == FALSE) && (ppArgv == NULL)) {
        PostSessDirErrorValueEvent(EVENT_NO_COMMANDLINE, GetLastError(), EVENTLOG_ERROR_TYPE);
        return -1;
    }
    
    SERVICE_TABLE_ENTRY DispatchTable[] =
    {
        { _T("Directory Integrity Service"), DISJetStart },  // Default to the
                                                             // Jet version.
        { NULL, NULL }
    };

    for (i = 1; i < nArgc; i++) {
        if ((ppArgv[i][0] == '-') || (ppArgv[i][0] == '/')) {
            if (wcscmp(&ppArgv[i][1], L"install") == 0) {
                if (DISInstallService()) {
                    ERR((TB, "Could not install service"));
                }
            }
            if (wcscmp(&ppArgv[i][1], L"remove") == 0) {
                if (DISRemoveService()) {
                    ERR((TB, "Could not remove service"));
                }
            }
            if (wcscmp(&ppArgv[i][1], L"debug") == 0) {
                TSDISErrorOut(L"Debugging Jet-based Session Directory\n");

                g_hStopServiceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

                g_bDebug = TRUE;

                // Only allow one session directory at a time.  System will close the
                // handle automatically when the process terminates.
                hMutex = CreateMutex(NULL, FALSE, 
                        _T("Global\\Windows Terminal Server Session Directory"));

                if (hMutex == NULL) {
                    // Handle creation failed, not because it already existed.
                    PostSessDirErrorValueEvent(EVENT_PROBLEM_CREATING_MUTEX, 
                    GetLastError(), EVENTLOG_ERROR_TYPE);
                    return -1;
                }
    
                if (GetLastError() == ERROR_ALREADY_EXISTS) {
                    // Already a session directory out there.
                    PostSessDirErrorValueEvent(EVENT_TWO_SESSDIRS, 0, EVENTLOG_ERROR_TYPE);
                    return -1;
                }


                // Log to stdout by default in this mode, but can be
                // overridden by the registry.
                g_TraceOutputMode = StdOutput;
                
                ReadConfigAndSetGlobals();

                SetConsoleCtrlHandler(DISDebugControlHandler, TRUE);

                DISJetStart(nArgc, ppArgv);
            }
        }
    }

    HeapFree(GetProcessHeap(), 0, (PVOID) ppArgv);

    if (fStartService) {
        // Stop event - signals for the ServiceMain thread to exit.
        g_hStopServiceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        ReadConfigAndSetGlobals();

#if 0
        if (g_bUseSQL) {
            // Switch from the default to the SQL service start.
            DispatchTable[0].lpServiceProc = DISSQLStart;
        }
#endif

        if (!StartServiceCtrlDispatcher(DispatchTable)) {
#ifdef DBG
            DWORD dw = GetLastError();
#endif // DBG
            ERR((TB, "Could not start service control dispatcher, error 0x%X",
                    dw));
        }
    }

    return 0;
}

#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\inc\tssd.h ===
/****************************************************************************/
// tssd.h
//
// Terminal Server Session Directory Interface main header.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __TSSD_H
#define __TSSD_H

#include "itssd.h"


// Max number of disconnected sessions allowed from a disc session query.
#define TSSD_MaxDisconnectedSessions 10

// Return value from UI code to signal that TermSrv needs to update
// its info from the registry.

// TS protocol types.
#define TSProtocol_ICA 1
#define TSProtocol_RDP 2


// {0241e043-1cb6-4716-aa50-6a492049c3f3}
DEFINE_GUID(IID_ITSSessionDirectory,
        0x0241e043, 0x1cb6, 0x4716, 0xaa, 0x50, 0x6a, 0x49, 0x20, 0x49, 0xc3, 0xf3);

// {012b47b7-2f06-4154-ad0c-c64bcdf0d512}
DEFINE_GUID(IID_ITSSessionDirectoryEx,
        0x012b47b7, 0x2f06, 0x4154, 0xad, 0x0c, 0xc6, 0x4b, 0xcd, 0xf0, 0xd5, 0x12);

#endif  // __TSSD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sds.rc
//
#define IDD_DIALOG_SDS                  101
#define IDC_CHECK_ENABLE                1000
#define IDC_EDIT_SERVERNAME             1001
#define IDC_EDIT_CLUSTERNAME            1002
#define IDS_DISABLE                     1004
#define IDS_ENABLE                      1005
#define IDS_ATTRIBUTE_NAME              1006
#define IDS_PROPERTIES                  1007
#define IDS_DESCRIP_ENABLE              1008
#define IDS_ERROR_SDIRLOC               1009
#define IDS_DESCRIP_PROPS               1010
#define IDC_EDIT_ACCOUNTNAME            1011
#define IDC_EDIT_PASSWORD               1012
#define IDC_STATIC_STORENAME            1013
#define IDC_STATIC_CLUSTERNAME          1014
#define IDS_ERROR_TITLE                 1017
#define IDS_ERROR_TEXT                  1018
#define IDS_ERROR_TEXT2                 1019
#define IDS_ERROR_TEXT3                 1020
#define IDS_HELPFILE                    1021
#define IDS_ERROR_SDIREMPTY             1022
#define IDC_CHECK_EXPOSEIP              1023
#define IDS_DEFAULT                     1026
#define IDM_MENU_ENABLE                 2000
#define IDM_MENU_PROPS                  2001
#define IDC_WARNING_ICON                2002
#define IDI_SMALLWARN                   2003
#define IDC_IPCOMBO                     2004
#define IDC_STATIC_IPCOMBO              2005
#define IDS_ERROR_SDVERIFY              2006
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1027
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\inc\tssdcommon.h ===
/****************************************************************************/
// tssdcommon.h
//
// Terminal Server Session Directory header.  Contains constants
// common between termsrv, tssdjet and SD.
//
// Copyright (C) 2002 Microsoft Corporation
/****************************************************************************/


#ifndef __TSSDCOMMON_H
#define __TSSDCOMMON_H
                       
// UpdateConfigurationSettings dwSetting values
#define SDCONFIG_SERVER_ADDRESS 1

#define SINGLE_SESSION_FLAG 0x1
#define NO_REPOPULATE_SESSION 0x2

#define TSSD_UPDATE 0x1
#define TSSD_FORCEREJOIN 0x2
#define TSSD_NOREPOPULATE 0x4

#define SDNAMELENGTH 128

// Length of some strings
#define TSSD_UserNameLen 256
#define TSSD_DomainLength 128
#define TSSD_ServAddrLen 128
#define TSSD_AppTypeLen 256
#define TSSD_ClusterNameLen 128
#define TSSD_ServerNameLen 128

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\jetrpc-c.c ===
#include <jetrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\factory.h ===
/****************************************************************************/
// factory.h
//
// TSLI class factory definition.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __FACTORY_H
#define __FACTORY_H


class CClassFactory : public IClassFactory
{
protected:
    long m_RefCount;

public:
    CClassFactory() : m_RefCount(0) {}

    // Standard COM methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory COM interfaces
    STDMETHODIMP CreateInstance(IUnknown *, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};



#endif  // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\factory.cpp ===
/****************************************************************************/
// factory.cpp
//
// TS Session Directory class factory code.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>

#include <ole2.h>
#include <objbase.h>
#include <comutil.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>

#include "tssdjet.h"
#include "factory.h"
#include "trace.h"


extern long g_lObjects;
extern long g_lLocks;


/****************************************************************************/
// CClassFactory::QueryInterface
//
// Standard COM IUnknown interface function.
// Handles interface queries for the class factory only.
/****************************************************************************/
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown) {
        *ppv = (LPVOID)(IUnknown *)this;
    }
    else if(riid == IID_IClassFactory) {
        *ppv = (LPVOID)(IClassFactory *)this;
    }
    else {
        TRC2((TB,"ClassFactory: Unknown interface"));
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


/****************************************************************************/
// CClassFactory::AddRef
//
// Standard COM IUnknown function.
/****************************************************************************/
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_RefCount);
}


/****************************************************************************/
// CClassFactory::Release
//
// Standard COM IUnknown function.
/****************************************************************************/
STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    long Refs = InterlockedDecrement(&m_RefCount);
    if (Refs == 0)
        delete this;

    return Refs;
}


/****************************************************************************/
// CClassFactory::CreateInstance
//
// IClassFactory creator function.
/****************************************************************************/
STDMETHODIMP CClassFactory::CreateInstance(
        IN IUnknown *pUnknownOuter,
        IN REFIID iid,
        OUT LPVOID *ppv)
{
    HRESULT hr;
    CTSSessionDirectory *pTSSDI = NULL;

    *ppv = NULL;

    TRC2((TB,"ClassFactory::CreateInstance"));

    // We do not support aggregation
    if (pUnknownOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    // Create the provider object
    pTSSDI = new CTSSessionDirectory;
    if (pTSSDI != NULL) {
        // Retrieve the requested interface.
        hr = pTSSDI->QueryInterface(iid, ppv);
        if (!FAILED(hr)) {
            return S_OK;
        }
        else {
            delete pTSSDI;
            return hr;
        }
    }
    else {
        return E_OUTOFMEMORY;
    }
}


/****************************************************************************/
// CClassFactory::LockServer
//
// IClassFactory lock function.
/****************************************************************************/
STDMETHODIMP CClassFactory::LockServer(IN BOOL bLock)
{
    if (bLock)
        InterlockedIncrement(&g_lLocks);
    else
        InterlockedDecrement(&g_lLocks);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\inc\tssdshrd.h ===
/****************************************************************************/
// tssdshrd.h
//
// Terminal Server Session Directory Interface header.  Contains constants
// common between tssdjet and SD.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#define MY_STATUS_COMMITMENT_LIMIT          (0xC000012DL)

#define MAX_INSTANCE_MEMORYERR 20

                                                                            
/****************************************************************************/
// Static RPC Exception Filter structure and function, based on 
// I_RpcExceptionFilter in \nt\com\rpc\runtime\mtrt\clntapip.cxx.
/****************************************************************************/

// windows.h includes windef.h includes winnt.h, which defines some exceptions
// but not others.  ntstatus.h contains the two extra we want, 
// STATUS_POSSIBLE_DEADLOCK and STATUS_INSTRUCTION_MISALIGNMENT, but it would
// be very difficult to get the right #includes in without a lot of trouble.

#define STATUS_POSSIBLE_DEADLOCK         0xC0000194L
#define STATUS_INSTRUCTION_MISALIGNMENT  0xC00000AAL

const ULONG FatalExceptions[] = 
{
    STATUS_ACCESS_VIOLATION,
    STATUS_POSSIBLE_DEADLOCK,
    STATUS_INSTRUCTION_MISALIGNMENT,
    STATUS_DATATYPE_MISALIGNMENT,
    STATUS_PRIVILEGED_INSTRUCTION,
    STATUS_ILLEGAL_INSTRUCTION,
    STATUS_BREAKPOINT,
    STATUS_STACK_OVERFLOW
};

const int FATAL_EXCEPTIONS_ARRAY_SIZE = sizeof(FatalExceptions) / 
        sizeof(FatalExceptions[0]);

static int TSSDRpcExceptionFilter (unsigned long ExceptionCode)
{
    int i;

    for (i = 0; i < FATAL_EXCEPTIONS_ARRAY_SIZE; i++) {
        if (ExceptionCode == FatalExceptions[i])
            return EXCEPTION_CONTINUE_SEARCH;
        }

    return EXCEPTION_EXECUTE_HANDLER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\synch.h ===
/******************************************************************************/
// synch.h
//
// Terminal Server Session Directory shared reader/writer header.
//
// Copyright (C) 2001 Microsoft Corporation
/******************************************************************************/

#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif

typedef struct _SHAREDRESOURCE {
    CRITICAL_SECTION ReaderMutex;
    HANDLE WriterSemaphore;

    DWORD Readers;
    BOOL Valid;
} SHAREDRESOURCE, *PSHAREDRESOURCE;


BOOL
InitializeSharedResource(
    IN OUT PSHAREDRESOURCE psr
    );

VOID
AcquireResourceShared(
    IN PSHAREDRESOURCE psr
    );

VOID
ReleaseResourceShared(
    IN PSHAREDRESOURCE psr
    );

VOID
AcquireResourceExclusive(
    IN PSHAREDRESOURCE psr
    );

VOID
ReleaseResourceExclusive(
    IN PSHAREDRESOURCE psr
    );

VOID
FreeSharedResource(
    IN OUT PSHAREDRESOURCE psr
    );

BOOL
VerifyNoSharedAccess(
    IN PSHAREDRESOURCE psr
    );

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\sdrpc-s.c ===
#include <sdrpc_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\trace.h ===
/****************************************************************************/
// trace.h
//
// Tracing definitions. See trace.c for other information.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


#if DBG || defined(_DEBUG)

#include <stdio.h>


// Zones. Up to 32 zones can be defined, these are predefined for general use.
#define Z_ASSERT 0x01
#define Z_ERR    0x02
#define Z_WRN    0x04
#define Z_TRC1   0x08
#define Z_TRC2   0x10

// Defined in msmcs.c.
extern char TB[1024];
extern UINT32 g_TraceMask;
void TracePrintZ(UINT32, char *);

// Error, warning, trace level 1, and trace level 2 definitions.
#define ERR(X) TRCZ(Z_ERR, X)
#define WRN(X) TRCZ(Z_WRN, X)
#define TRC1(X) TRCZ(Z_TRC1, X)
#define TRC2(X) TRCZ(Z_TRC2, X)
#define ASSERT(COND, X) \
{  \
    if (!(COND)) { \
        TRCZ(Z_ASSERT, X); \
        DebugBreak(); \
    }  \
}

#define TRCZ(Z, X) \
{ \
    if (g_TraceMask & (Z)) { \
        sprintf X; \
        TracePrintZ((Z), TB); \
    } \
}


#else  // DBG

#define ERR(X)
#define WRN(X)
#define TRC1(X)
#define TRC2(X)
#define ASSERT(COND, X)

#endif  // DBG



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\trace.c ===
/****************************************************************************/
// trace.c
//
// Tracing code and definitions. See trace.h for other info.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#if DBG || defined(_DEBUG)

#include <windows.h>

#include "trace.h"


struct _ZoneInfo
{
    UINT32 Zone;
    char *Prefix;
} TRC_ZI[] =
{
    { Z_ASSERT, "TSSDJET: !!! ASSERT: " },
    { Z_ERR,    "TSSDJET: *** ERROR: " },
    { Z_WRN,    "TSSDJET: Warning: " },
    { Z_TRC1,   "TSSDJET: " },
    { Z_TRC2,   "TSSDJET: " },
};
int NumTRC_ZIEntries = sizeof(TRC_ZI) / sizeof(struct _ZoneInfo);


// Globals.
UINT32 g_TraceMask = 0xFFFFFFFF;
char TB[1024];
char TB2[1024];


// Main output function.
void TracePrintZ(UINT32 ZoneFlag, char *OutString)
{
    int i;
    char *Prefix = "";

    // Find the zone information in the zone table.
    for (i = 0; i < NumTRC_ZIEntries; i++)
        if (TRC_ZI[i].Zone == ZoneFlag)
            Prefix = TRC_ZI[i].Prefix;

    // Now create the final string.
    wsprintfA(TB2, "%s%s\n", Prefix, OutString);

    // Send to output.
    OutputDebugStringA(TB2);
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdsql\factory.h ===
/****************************************************************************/
// factory.h
//
// TSLI class factory definition.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __FACTORY_H
#define __FACTORY_H


class CClassFactory : public IClassFactory
{
protected:
    long m_RefCount;

public:
    CClassFactory() : m_RefCount(0) {}

    // Standard COM methods
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IClassFactory COM interfaces
    STDMETHODIMP CreateInstance(IUnknown *, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};



#endif  // __FACTORY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\synch.c ===
/*++

Copyright (c) 2001 Microsoft Corporation

Module Name:

    synch.c

Abstract:

    This module contains routines for shared reader/writer locks for Session 
    Directory.  These reader/writer locks can starve writers, so the assumption
    is that there is not a lot of constant reading activity.

Author:

    Trevor Foucher (trevorfo) 01-Feb-2001

Environment:
    User mode.

Revision History:

    01-Feb-2001 trevorfo
        Created

--*/


#include "synch.h"


#if DBG
NTSYSAPI
VOID
NTAPI
RtlAssert(
    PVOID FailedAssertion,
    PVOID FileName,
    ULONG LineNumber,
    PCHAR Message
    );

#define ASSERT( exp ) \
    ((!(exp)) ? \
        (RtlAssert( #exp, __FILE__, __LINE__, NULL ),FALSE) : \
        TRUE)
#else
#define ASSERT( exp )         ((void) 0)
#endif



BOOL
InitializeSharedResource(
    IN OUT PSHAREDRESOURCE psr
    )

/*++

Routine Description:

    This routine initializes a shared resource object.  Call FreeSharedResource
    to free.

Arguments:

    psr - Pointer to SHAREDRESOURCE to initialize.  Must point to a valid block
          of memory, and the psr->Valid field must be FALSE.

Return Value:

    TRUE if the function succeeds, FALSE if it fails.

--*/
{
    BOOL brr = FALSE;
    BOOL retval = FALSE;
    HANDLE hSemaphore = NULL;

    ASSERT(!IsBadReadPtr(psr, sizeof(psr)));
    ASSERT(psr->Valid == FALSE);
    
    // Initialize Reader Mutex, Writer Mutex.
    __try {

        // Initialize the critical section to preallocate the event
        // and spin 4096 times on each try (since we don't spend very
        // long in our critical section).
        brr = InitializeCriticalSectionAndSpinCount(&psr->ReaderMutex, 
                0x80001000);
        // Create a semaphore with maximum count as 1, which means
        // that only one thread can own it
        hSemaphore = psr->WriterSemaphore = CreateSemaphore(NULL, 1, 1, NULL);

    }
    __finally {

        if (brr && hSemaphore) {
            retval = TRUE;
            psr->Valid = TRUE;
        }
        else {
            if (brr)
                DeleteCriticalSection(&psr->ReaderMutex);
            if (hSemaphore)
                CloseHandle(psr->WriterSemaphore);

            psr->Valid = FALSE;
        }
    }

    // Initialize Readers
    psr->Readers = 0;

    return retval;
}


VOID
AcquireResourceShared(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:

    This routine acquires a resource for shared access.
    
Arguments:

    psr - Pointer to SHAREDRESOURCE which has been initialized.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);
    
    EnterCriticalSection(&psr->ReaderMutex);

    psr->Readers += 1;

    if (psr->Readers == 1)
        WaitForSingleObject(psr->WriterSemaphore, INFINITE);

    LeaveCriticalSection(&psr->ReaderMutex);
}


VOID
ReleaseResourceShared(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:

    This routine releases a resource's shared access.
    
Arguments:

    psr - Pointer to SHAREDRESOURCE which has been initialized and which has
          shared (read) access.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);

    EnterCriticalSection(&psr->ReaderMutex);

    ASSERT(psr->Readers != 0);

    psr->Readers -= 1;

    if (psr->Readers == 0)        
        ReleaseSemaphore(psr->WriterSemaphore, 1, NULL);

    LeaveCriticalSection(&psr->ReaderMutex);
}


VOID
AcquireResourceExclusive(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:
    This routine acquires a resource for exclusive (write) access.

Arguments:

    psr - Pointer to SHAREDRESOURCE which has been initialized.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);

    WaitForSingleObject(psr->WriterSemaphore, INFINITE);
}


VOID
ReleaseResourceExclusive(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:
    This routine releases a resource for which we have exclusive (write) access.

Arguments:

    psr - Pointer to SHAREDRESOURCE which has been initialized and which has
          write access.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);

    ReleaseSemaphore(psr->WriterSemaphore, 1, NULL);
}


VOID
FreeSharedResource(
    IN OUT PSHAREDRESOURCE psr
    )
/*++

Routine Description:

    This routine frees resources taken up by a shared resource object allocated
    by InitializeSharedResource.  It does not free the memory.
    
Arguments:

    psr - Pointer to SHAREDRESOURCE whose resources should be freed.

Return Value:

    None.

--*/
{
    ASSERT(psr->Valid);
    ASSERT(psr->Readers == 0);

    DeleteCriticalSection(&psr->ReaderMutex);
    CloseHandle(psr->WriterSemaphore);
    
    psr->Readers = 0;
    psr->Valid = FALSE;
}


BOOL
VerifyNoSharedAccess(
    IN PSHAREDRESOURCE psr
    )
/*++

Routine Description:

    This routine verifies that the critical section does not currently have any
    shared accessors.

Arugments:

    psr - Pointer to SHAREDRESOURCE to verify.

Return Value:

    TRUE - if there are no shared accessors.
    FALSE - if there are shared accessors.

--*/
{
    ASSERT(psr->Valid);
    
    return (psr->Readers == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdsql\trace.h ===
/****************************************************************************/
// trace.h
//
// Tracing definitions. See trace.c for other information.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


#if DBG || defined(_DEBUG)

#include <stdio.h>


// Zones. Up to 32 zones can be defined, these are predefined for general use.
#define Z_ASSERT 0x01
#define Z_ERR    0x02
#define Z_WRN    0x04
#define Z_TRC1   0x08
#define Z_TRC2   0x10

// Defined in msmcs.c.
extern char TB[1024];
extern UINT32 g_TraceMask;
void TracePrintZ(UINT32, char *);

// Error, warning, trace level 1, and trace level 2 definitions.
#define ERR(X) TRCZ(Z_ERR, X)
#define WRN(X) TRCZ(Z_WRN, X)
#define TRC1(X) TRCZ(Z_TRC1, X)
#define TRC2(X) TRCZ(Z_TRC2, X)
#define ASSERT(COND, X) \
{  \
    if (!(COND)) { \
        TRCZ(Z_ASSERT, X); \
        DebugBreak(); \
    }  \
}

#define TRCZ(Z, X) \
{ \
    if (g_TraceMask & (Z)) { \
        sprintf X; \
        TracePrintZ((Z), TB); \
    } \
}


#else  // DBG

#define ERR(X)
#define WRN(X)
#define TRC1(X)
#define TRC2(X)
#define ASSERT(COND, X)

#endif  // DBG



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\server.cpp ===
/****************************************************************************/
// server.cpp
//
// General COM in-proc server framework code. TSSD-specific code is
// designated by CLSID SPECIFIC comments.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <tchar.h>

#define INITGUID
#include <ole2.h>
#include <objbase.h>
#include <comutil.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>
#include <initguid.h>

#include "factory.h"
#include "trace.h"

#define SDMAX_PATH 1024
/****************************************************************************/
// CLSID SPECIFIC section
//
// Provider-specific includes, unique CLSID, other info.
/****************************************************************************/

// For new components, this is the only area that needs to be modified in this
// file. Include any appropriate header files, a unique CLSID and update 
// the macros.

#include "tssd.h"

// {005a9c68-e216-4b27-8f59-b336829b3868}
DEFINE_GUID(CLSID_TSSDJET,
        0x005a9c68, 0xe216, 0x4b27, 0x8f, 0x59, 0xb3, 0x36, 0x82, 0x9b, 0x38, 0x68);

// {ec98d957-48ad-436d-90be-bc291f42709c}
DEFINE_GUID(CLSID_TSSDJETEX,
        0xec98d957, 0x48ad, 0x436d, 0x90, 0xbe, 0xbc, 0x29, 0x1f, 0x42, 0x70, 0x9c);


#define IMPLEMENTED_CLSID       CLSID_TSSDJET
#define IMPLEMENTED_CLSIDEX     CLSID_TSSDJETEX

#define SERVER_REGISTRY_COMMENT L"Terminal Server Session Directory Interface"
#define CPP_CLASS_NAME          CTSSessionDirectory
#define INTERFACE_CAST          (ITSSessionDirectory *)

/****************************************************************************/
// End CLSID SPECIFIC section
/****************************************************************************/


HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;


/****************************************************************************/
// DllMain
//
// Standard DLL entry point. Returns FALSE on failure.
/****************************************************************************/
BOOL WINAPI DllMain(
        HINSTANCE hInstDLL,
        DWORD dwReason,
        LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hInstDLL;
        DisableThreadLibraryCalls(hInstDLL);
    }

    return TRUE;
}


/****************************************************************************/
// DllGetClassObject
//
// Standard OLE In-Process Server entry point to return an class factory
// instance.
//***************************************************************************
STDAPI DllGetClassObject(
        REFCLSID rclsid,
        REFIID riid,
        LPVOID *ppv)
{
    CClassFactory *pClassFactory;
    HRESULT hr;

    TRC2((TB,"DllGetClassObject"));

    // Verify the caller is asking for our type of object
    if (rclsid == IMPLEMENTED_CLSID || rclsid == IMPLEMENTED_CLSIDEX) { 
        // Create the class factory.
        pClassFactory = new CClassFactory;
        if (pClassFactory != NULL) {
            hr = pClassFactory->QueryInterface(riid, ppv);
            if (FAILED(hr)) {
                ERR((TB,"DllGetClassObject: GUID not found"));
                delete pClassFactory;
            }
        }
        else {
            ERR((TB,"DllGetClassObject: Failed alloc class factory"));
            hr = E_OUTOFMEMORY;
        }
    }
    else {
        ERR((TB,"DllGetClassObject: Failed alloc class factory"));
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}


/****************************************************************************/
// DllCanUnloadNow
//
// Standard COM entry point for COM server shutdown request. Allows shutdown
// only if no outstanding objects or locks are present.
/****************************************************************************/
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;

    if (g_lLocks == 0 && g_lObjects == 0)
        hr = S_OK;
    else
        hr = S_FALSE;

    return hr;
}


/****************************************************************************/
// DllRegisterServer
//
// Standard COM entry point for registering the server.
/****************************************************************************/
HRESULT RegisterCLSID(CLSID  clsid)
{
    HRESULT hr = E_FAIL;
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[SDMAX_PATH];
    wchar_t Path[SDMAX_PATH];

    // Get the DLL's filename
    GetModuleFileNameW(g_hInstance, Path, 1024);
    Path[SDMAX_PATH - 1] = L'\0';

    TRC2((TB,"RegisterCLSID: %S", KeyPath));

    // Convert CLSID to string.
    if( SUCCEEDED( StringFromCLSID(clsid, &pGuidStr) ) )
    {  
        swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

        // Place it in registry.
        // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
        //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 :
        //        <no_name> : "path to DLL"
        //        ThreadingModel : "both"
        HKEY hKey;
        LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (lRes == 0) {
            wchar_t *pName = SERVER_REGISTRY_COMMENT;
            RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *)pName,
                    wcslen(pName) * 2 + 2);
    
            HKEY hSubkey;
            lRes = RegCreateKeyW(hKey, L"InprocServer32", &hSubkey);
    
            RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path,
                    wcslen(Path) * 2 + 2);
            RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ,
                    (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);
    
            RegCloseKey(hSubkey);
            RegCloseKey(hKey);
        }
        else {
            TRC2((TB,"RegisterCLSID: Failed to Create key: %x", lRes));
        }
    
        CoTaskMemFree(pGuidStr);
    
        hr = HRESULT_FROM_WIN32( lRes );
    }
    else {
        TRC2((TB,"RegisterCLSID failed"));
    }

    return hr;
}

STDAPI DllRegisterServer(void)
{
    HRESULT hr = E_FAIL;
    
    hr = RegisterCLSID(IMPLEMENTED_CLSID);
    hr = RegisterCLSID(IMPLEMENTED_CLSIDEX);
    
    return hr;    
}


/****************************************************************************/
// DllUnregisterServer
//
// Standard COM entry point for unregistering the server.
/****************************************************************************/
HRESULT UnregisterCLSID(REFCLSID rclsid)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];
    HRESULT hr = E_FAIL;

    if( SUCCEEDED( StringFromCLSID(rclsid, &pGuidStr) ) )
    {
        swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

        // Delete InProcServer32 subkey.
        LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (!lRes) {
            RegDeleteKeyW(hKey, L"InprocServer32");
            RegCloseKey(hKey);

            // Delete CLSID GUID key.
            lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
            if (!lRes) {
                RegDeleteKeyW(hKey, pGuidStr);
                RegCloseKey(hKey);
            }
        }
        
        CoTaskMemFree(pGuidStr);

        hr = HRESULT_FROM_WIN32( lRes );
    }

    return hr;
}

STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];
    HRESULT hr = E_FAIL;

    hr = UnregisterCLSID(IMPLEMENTED_CLSID);
    hr = UnregisterCLSID(IMPLEMENTED_CLSIDEX);
    
    return hr;    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\tssdjet.h ===
/****************************************************************************/
// tssdjet.h
//
// Terminal Server Session Directory Interface Jet RPC provider header.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __TSSDJET_H
#define __TSSDJET_H

#include <tchar.h>

#include "tssd.h"
#include "tssdcommon.h"
#include "tssdshrd.h"
#include "srvsetex.h"
#include "jetrpc.h"
#include "synch.h"


/****************************************************************************/
// Defines
/****************************************************************************/


/****************************************************************************/
// Types
/****************************************************************************/

// CTSSessionDirectory
//
// C++ class instantiation of ITSSessionDirectory.
class CTSSessionDirectory : public ITSSessionDirectory, 
        public IExtendServerSettings, public ITSSessionDirectoryEx
{
private:
    long m_RefCount;

    BOOL m_bConnected;
    HCLIENTINFO m_hCI;
    RPC_BINDING_HANDLE m_hRPCBinding;
    WCHAR m_StoreServerName[64];
    WCHAR m_LocalServerAddress[64];
    WCHAR m_ClusterName[64];

    // Flags passed in from Termsrv
    DWORD m_Flags;

    // Private data for UI menus
    BOOL m_fEnabled;

    // Autorecovery variables
    //
    // Events
    // * m_hSDServerDown - Event that is signalled to awaken recovery thread,
    // which wakes up, polls the session directory until it comes back up,
    // and then refreshes the database.
    // * m_hTerminateRecovery - Recovery thread, when it enters waits, can be
    // terminated by the use of this event
    //
    // Thread Information
    // * m_hRecoveryThread - Handle to the recovery thread.
    // * m_RecoveryTid - Thread identifier for recovery thread.
    //
    // Boolean
    // * m_bSDIsUp - If this is on then we think the session directory is up.
    // * m_sr - Protects m_SDIsUp.
    //
    // DWORD
    // * m_RecoveryTimeout - time in ms between attempts to reestablish
    // connection with the session directory.
    //
    // Function pointer
    // * m_repopfn - pointer to the repopulation function in termsrv to call
    // when we want an update.

    OVERLAPPED m_OverLapped;
    HANDLE m_hIPChange;
    HANDLE m_NotifyIPChange;

    HANDLE m_hSDServerDown;
    HANDLE m_hTerminateRecovery;
    uintptr_t m_hRecoveryThread;

    unsigned m_RecoveryTid;

    // m_sr protects SDIsUp flag
    SHAREDRESOURCE m_sr;
    volatile LONG m_SDIsUp;

    HANDLE  m_hInRepopulate;    // Signal if not in repopulate, 
                                // non-signal if repopulate is in progress
    LONG m_ConnectionEstablished;

    // Flag for whether shared reader/writer lock init succeeded.  If it doesn't
    // succeed, we can't do anything.
    BOOL m_LockInitializationSuccessful;

    BOOL m_bStartRPCListener;

    DWORD m_RecoveryTimeout;

    DWORD (*m_repopfn)();

    // Autorecovery thread
    unsigned static __stdcall RecoveryThread(void *);
    VOID RecoveryThreadEx();

    // Helper functions
    DWORD RequestSessDirUpdate();
    DWORD ReestablishSessionDirectoryConnection();
    void Terminate();
    void StartupSD();
    void NotifySDServerDown();
    boolean EnterSDRpc();
    void LeaveSDRpc();
    void DisableSDRpcs();
    void EnableSDRpcs();

    void SetSDConnectionDown() {
        InterlockedExchange( &m_ConnectionEstablished, FALSE );
    }

    void SetSDConnectionReady() {
        InterlockedExchange( &m_ConnectionEstablished, TRUE );
    }

    BOOL IsSDConnectionReady() {
        return (BOOL) InterlockedExchangeAdd( &m_ConnectionEstablished, 0 );
    }

public:
    CTSSessionDirectory();
    ~CTSSessionDirectory();

    // Standard COM methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, void **);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ITSSessionDirectory COM interface
    HRESULT STDMETHODCALLTYPE Initialize(LPWSTR, LPWSTR, LPWSTR, LPWSTR, 
            DWORD, DWORD (*)(), DWORD (*)(DWORD));
    HRESULT STDMETHODCALLTYPE Update(LPWSTR, LPWSTR, LPWSTR, LPWSTR, DWORD, BOOL);
    HRESULT STDMETHODCALLTYPE GetUserDisconnectedSessions(LPWSTR, LPWSTR,
            DWORD __RPC_FAR *, TSSD_DisconnectedSessionInfo __RPC_FAR
            [TSSD_MaxDisconnectedSessions]);
    HRESULT STDMETHODCALLTYPE NotifyCreateLocalSession(
            TSSD_CreateSessionInfo __RPC_FAR *);
    HRESULT STDMETHODCALLTYPE NotifyDestroyLocalSession(DWORD);
    HRESULT STDMETHODCALLTYPE NotifyDisconnectLocalSession(DWORD, FILETIME);

    HRESULT STDMETHODCALLTYPE NotifyReconnectLocalSession(
            TSSD_ReconnectSessionInfo __RPC_FAR *);
    HRESULT STDMETHODCALLTYPE NotifyReconnectPending(WCHAR *);
    HRESULT STDMETHODCALLTYPE Repopulate(DWORD, TSSD_RepopulateSessionInfo *);
    HRESULT STDMETHODCALLTYPE GetLoadBalanceInfo(LPWSTR, BSTR*);
    HRESULT STDMETHODCALLTYPE PingSD(PWCHAR pszServerName);
    HRESULT STDMETHODCALLTYPE WaitForRepopulate(DWORD dwTimeOut);

    // IExtendServerSettings COM interface
    STDMETHOD(GetAttributeName)(WCHAR *);
    STDMETHOD(GetDisplayableValueName)(WCHAR *);
    STDMETHOD(InvokeUI)(HWND,PDWORD);
    STDMETHOD(GetMenuItems)(int *, PMENUEXTENSION *);
    STDMETHOD(ExecMenuCmd)(UINT, HWND, PDWORD);
    STDMETHOD(OnHelp)(int *);

    BOOL CTSSessionDirectory::CheckSessionDirectorySetting(WCHAR *Setting);
    BOOL CTSSessionDirectory::CheckIfSessionDirectoryNameEmpty(WCHAR *Setting);
    BOOL IsSessionDirectoryEnabled();
    BOOL CTSSessionDirectory::IsSessionDirectoryExposeServerIPEnabled();
    DWORD SetSessionDirectoryState(WCHAR *, BOOL);
    DWORD SetSessionDirectoryEnabledState(BOOL);
    DWORD SetSessionDirectoryExposeIPState(BOOL);
    void ErrorMessage(HWND hwnd , UINT res , DWORD);
    BOOL SDJETInitRPC();
    
public:
    TCHAR m_tchProvider[64];
    TCHAR m_tchDataSource[64];
    TCHAR m_tchUserId[64];
    TCHAR m_tchPassword[64];
};

RPC_STATUS RPC_ENTRY JetRpcAccessCheck(RPC_IF_HANDLE idIF, void *Binding);

#endif // __TSSDJET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdjet\tssdjet.cpp ===
/****************************************************************************/
// tssdjet.cpp
//
// Terminal Server Session Directory Jet RPC component code.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <process.h>

#include <ole2.h>
#include <objbase.h>
#include <comdef.h>
#include <winsta.h>
#include <regapi.h>
#include <winsock2.h>
#include <Lm.h>
#include <Security.h>
#include <Iphlpapi.h>
#include <wbemidl.h>
#include <shlwapi.h>

#include "tssdjet.h"
#include "trace.h"
#include "resource.h"
#include "sdjetevent.h"
#include "sdrpc.h"

#pragma warning (push, 4)

/****************************************************************************/
// Defines
/****************************************************************************/

#define SECPACKAGELIST L"Kerberos,-NTLM"

#define TSSD_FAILCOUNT_BEFORE_CLEARFLAG 4

// Per bug 629057, use 1 min as the interval
#define JET_RECOVERY_TIMEOUT 60*1000                // 1 min

// If a network adapter is unconfigured it will have the following IP address
#define UNCONFIGURED_IP_ADDRESS L"0.0.0.0"

 // Number of IP addresses for a machine
#define SD_NUM_IP_ADDRESS 64

#define LANATABLE_REG_NAME             REG_CONTROL_TSERVER   L"\\lanatable"
#define LANAID_REG_VALUE_NAME          L"LanaID"
#define NETCARDS_REG_NAME              L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NetworkCards"
#define NETCARD_DESC_VALUE_NAME        L"Description"
#define NETCARD_SERVICENAME_VALUE_NAME L"ServiceName"

/****************************************************************************/
// Prototypes
/****************************************************************************/
INT_PTR CALLBACK CustomUIDlg(HWND, UINT, WPARAM, LPARAM);
HRESULT GetSDIPList(WCHAR **pwszAddressList, DWORD *dwNumAddr, BOOL bIPAddress);
HRESULT QueryNetworkAdapterAndIPs(HWND hComboBox);
HRESULT GetNLBIP(LPWSTR * ppwszRetIP);
HRESULT BuildLanaGUIDList(LPWSTR * pastrLanaGUIDList, DWORD *dwLanaGUIDCount);
HRESULT GetLanAdapterGuidFromID(DWORD dwLanAdapterID, LPWSTR * ppszLanAdapterGUID);
HRESULT GetAdapterServiceName(LPWSTR wszAdapterDesc, LPWSTR * ppwszServiceName);

// User defined HResults
#define  S_ALL_ADAPTERS_SET  MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_ITF, 0x200 + 1)

/****************************************************************************/
// Globals
/****************************************************************************/
extern HINSTANCE g_hInstance;
DWORD (*g_updatesd)(DWORD);  // Point to UpdateSessionDirectory in sessdir.cpp

// The COM object counter (declared in server.cpp)
extern long g_lObjects;

// RPC binding string components - RPC over named pipes.
const WCHAR *g_RPCUUID = L"aa177641-fc9b-41bd-80ff-f964a701596f"; 
                                                    // From jetrpc.idl
const WCHAR *g_RPCOptions = L"Security=Impersonation Dynamic False";
const WCHAR *g_RPCProtocolSequence = L"ncacn_ip_tcp";   // RPC over TCP/IP
const WCHAR *g_RPCRemoteEndpoint = L"\\pipe\\TSSD_Jet_RPC_Service";

PSID g_pSDSid = NULL;                    //Sid for SD Computer


/****************************************************************************/
// TSSDJetGetLocalIPAddr
//
// Gets the local IP address of this machine.  On success, returns 0.  On
// failure, returns a failure code from the function that failed.
/****************************************************************************/
DWORD TSSDJetGetLocalIPAddr(WCHAR *LocalIP)
{
    unsigned char *tempaddr;
    char psServerNameA[64];
    struct hostent *hptr;
    int err, rc;
 
    rc = gethostname(psServerNameA, sizeof(psServerNameA));
    if (0 != rc) {
        err = WSAGetLastError();
        ERR((TB, "gethostname returns error %d\n", err));
        return err;
    }
    if ((hptr = gethostbyname(psServerNameA)) == 0) {
        err = WSAGetLastError();
        ERR((TB, "gethostbyname returns error %d\n", err));
        return err;
    }
     
    tempaddr = (unsigned char *)*(hptr->h_addr_list);
    wsprintf(LocalIP, L"%d.%d.%d.%d", tempaddr[0], tempaddr[1],
            tempaddr[2], tempaddr[3]);

    return 0;
}


/****************************************************************************/
// MIDL_user_allocate
// MIDL_user_free
//
// RPC-required allocation functions.
/****************************************************************************/
void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t Size)
{
    return LocalAlloc(LMEM_FIXED, Size);
}

void __RPC_USER MIDL_user_free(void __RPC_FAR *p)
{
    LocalFree(p);
}

//
// PostSDJetErrorValueEvent
//
// Utility function used to create a system log wType event containing one
// hex DWORD code value.
void PostSDJetErrorValueEvent(unsigned EventCode, DWORD ErrVal, WORD wType)
{
    HANDLE hLog;
    WCHAR hrString[128];
    PWSTR String = NULL;
    static DWORD numInstances = 0;
    //
    //count the numinstances of out of memory error, if this is more than
    //a specified number, we just won't log them
    //
    if( MY_STATUS_COMMITMENT_LIMIT == ErrVal )
    {
        if( numInstances > MAX_INSTANCE_MEMORYERR )
            return;
         //
        //if applicable, tell the user that we won't log any more of the out of memory errors
        //
        if( numInstances >= MAX_INSTANCE_MEMORYERR - 1 ) {
            wsprintfW(hrString, L"0x%X. This type of error will not be logged again to avoid eventlog fillup.", ErrVal);
            String = hrString;
        }
        numInstances++;
    }

    hLog = RegisterEventSource(NULL, L"TermServJet");
   if (hLog != NULL) {
        if( NULL == String ) {
            wsprintfW(hrString, L"0x%X", ErrVal);
            String = hrString;
        }
        ReportEvent(hLog, wType, 0, EventCode, NULL, 1, 0,
                (const WCHAR **)&String, NULL);
        DeregisterEventSource(hLog);
    }
}


// PostSDJetErrorMsgEvent
//
// Utility function used to create a system wType log event containing one
// WCHAR msg.
void PostSDJetErrorMsgEvent(unsigned EventCode, WCHAR *szMsg, WORD wType)
{
    HANDLE hLog;
    
    hLog = RegisterEventSource(NULL, L"TermServJet");
    if (hLog != NULL) {
        ReportEvent(hLog, wType, 0, EventCode, NULL, 1, 0,
                (const WCHAR **)&szMsg, NULL);
        DeregisterEventSource(hLog);
    }
}


// Get the Sid of the SD Server
BOOL LookUpSDComputerSID(WCHAR *SDComputerName)
{
    WCHAR *DomainName = NULL;
    DWORD DomainNameSize = 0;
    DWORD SidSize = 0;
    SID_NAME_USE SidNameUse;
    BOOL rc = FALSE;
    DWORD Error;

    if (g_pSDSid) {
        LocalFree(g_pSDSid);
        g_pSDSid = NULL;
    }
    rc = LookupAccountName(NULL,
                           SDComputerName,
                           g_pSDSid,
                           &SidSize,
                           DomainName,
                           &DomainNameSize,
                           &SidNameUse);
    if (rc) 
        goto HandleError;       
        
    Error = GetLastError();
    if( ERROR_INSUFFICIENT_BUFFER != Error ) 
        goto HandleError;


    g_pSDSid = (PSID)LocalAlloc(LMEM_FIXED, SidSize);
    if (NULL == g_pSDSid) {
        goto HandleError;
    }
    DomainName = (LPWSTR)LocalAlloc(LMEM_FIXED,
                                    sizeof(WCHAR)*(1+DomainNameSize));
    if (NULL == DomainName) {
        goto HandleError;
    }

    rc = LookupAccountName(NULL,
                           SDComputerName,
                           g_pSDSid,
                           &SidSize,
                           DomainName,
                           &DomainNameSize,
                           &SidNameUse);

    if (!rc) {
        // fail
        ERR((TB, "Fail to get Sid for SD computer %S, err is %d\n", SDComputerName, GetLastError()));
        LocalFree(g_pSDSid);
        g_pSDSid = NULL;
    }

    LocalFree(DomainName);
        
    return rc;
HandleError:
    rc = FALSE;
    return rc;
}

/****************************************************************************/
// CTSSessionDirectory::CTSSessionDirectory
// CTSSessionDirectory::~CTSSessionDirectory
//
// Constructor and destructor
/****************************************************************************/
CTSSessionDirectory::CTSSessionDirectory() :
        m_RefCount(0), m_hRPCBinding(NULL), m_hSDServerDown(NULL), 
        m_hTerminateRecovery(NULL), m_hRecoveryThread(NULL), m_RecoveryTid(0),
        m_LockInitializationSuccessful(FALSE), m_SDIsUp(FALSE), m_Flags(0),
        m_hIPChange(NULL), m_NotifyIPChange(NULL), m_hInRepopulate(NULL), m_ConnectionEstablished(FALSE)
{
    InterlockedIncrement(&g_lObjects);

    m_hCI = NULL;
    m_hRPCBinding = NULL;

    m_StoreServerName[0] = L'\0';
    m_LocalServerAddress[0] = L'\0';
    m_ClusterName[0] = L'\0';

    m_fEnabled = 0;
    m_tchProvider[0] = 0;
    m_tchDataSource[0] = 0;
    m_tchUserId[0] = 0;
    m_tchPassword[0] = 0;

    m_sr.Valid = FALSE;

    ZeroMemory(&m_OverLapped, sizeof(OVERLAPPED));

    // Recovery timeout should be configurable, but currently is not.
    // Time is in ms.
    m_RecoveryTimeout = JET_RECOVERY_TIMEOUT;

    m_bStartRPCListener = FALSE;

    if (InitializeSharedResource(&m_sr)) {
        m_LockInitializationSuccessful = TRUE;
    }
    else {
        ERR((TB, "Constructor: Failed to initialize shared resource"));
    }

    if( m_LockInitializationSuccessful == TRUE ) {
        // manual reset event in signal state initially
        m_hInRepopulate = CreateEvent( NULL, TRUE, TRUE, NULL );
        if( m_hInRepopulate == NULL ) {
            ERR((TB, "Init: Failed to create event for repopulate, err = "
                    "%d", GetLastError()));
            m_LockInitializationSuccessful = FALSE;
        } 
    }
}

CTSSessionDirectory::~CTSSessionDirectory()
{
    RPC_STATUS RpcStatus;

    if (m_bStartRPCListener) {
        RpcStatus = RpcServerUnregisterIf(TSSDTOJETRPC_ServerIfHandle, NULL, NULL);
        if (RpcStatus != RPC_S_OK) {
            ERR((TB,"Error 0x%x in RpcServerUnregisterIf\n", RpcStatus));
        }
    }

    if (g_pSDSid) {
        LocalFree(g_pSDSid);
        g_pSDSid = NULL;
    }

    // Clean up.
    if (m_LockInitializationSuccessful) {
        Terminate();
    }

    if( m_hInRepopulate != NULL ) {
        CloseHandle( m_hInRepopulate );
        m_hInRepopulate = NULL;
    }

    if (m_sr.Valid)
        FreeSharedResource(&m_sr);
    
    // Decrement the global COM object counter.
    InterlockedDecrement(&g_lObjects);
}


/****************************************************************************/
// CTSSessionDirectory::QueryInterface
//
// Standard COM IUnknown function.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::QueryInterface(
        REFIID riid,
        void **ppv)
{
    if (riid == IID_IUnknown) {
        *ppv = (LPVOID)(IUnknown *)(ITSSessionDirectory *)this;
    }
    else if (riid == IID_ITSSessionDirectory) {
        *ppv = (LPVOID)(ITSSessionDirectory *)this;
    }
    else if (riid == IID_IExtendServerSettings) {
        *ppv = (LPVOID)(IExtendServerSettings *)this;
    }
    else if (riid == IID_ITSSessionDirectoryEx) {
        *ppv = (LPVOID)(ITSSessionDirectoryEx *)this;
    }
    else {
        ERR((TB,"QI: Unknown interface"));
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


/****************************************************************************/
// CTSSessionDirectory::AddRef
//
// Standard COM IUnknown function.
/****************************************************************************/
ULONG STDMETHODCALLTYPE CTSSessionDirectory::AddRef()
{
    return InterlockedIncrement(&m_RefCount);
}


/****************************************************************************/
// CTSSessionDirectory::Release
//
// Standard COM IUnknown function.
/****************************************************************************/
ULONG STDMETHODCALLTYPE CTSSessionDirectory::Release()
{
    long lRef = InterlockedDecrement(&m_RefCount);

    if (lRef == 0)
        delete this;
    return lRef;
}


HRESULT STDMETHODCALLTYPE CTSSessionDirectory::WaitForRepopulate(
    DWORD dwTimeOut
    )
/*++

--*/
{
    DWORD dwStatus = ERROR_SUCCESS;
    
    ASSERT((m_hInRepopulate != NULL),(TB,"m_hInRepopulate is NULL"));

    if( m_hInRepopulate != NULL ) {
        dwStatus = WaitForSingleObject( m_hInRepopulate, dwTimeOut );
        
        #if DBG
        if( dwTimeOut > 0 && dwStatus != WAIT_OBJECT_0 ) {
            ERR((TB, "WARNING: WaitForRepopulate wait %d failed with %d", dwTimeOut, dwStatus)); 
        }
        #endif

        if( dwStatus == WAIT_OBJECT_0 ) {
            dwStatus = ERROR_SUCCESS;
        }
        else if( dwStatus == WAIT_TIMEOUT ) {
            dwStatus = ERROR_BUSY;
        } 
        else if( dwStatus == WAIT_FAILED ) {
            dwStatus = GetLastError();
        } 
        else {
            dwStatus = ERROR_INTERNAL_ERROR;
        }
    }
    else {
        dwStatus = ERROR_INTERNAL_ERROR;
    }

    return HRESULT_FROM_WIN32( dwStatus );
}

/****************************************************************************/
// CTSSessionDirectory::Initialize
//
// ITSSessionDirectory function. Called soon after object instantiation to
// initialize the directory. LocalServerAddress provides a text representation
// of the local server's load balance IP address. This information should be
// used as the server IP address in the session directory for client
// redirection by other pool servers to this server. SessionDirectoryLocation,
// SessionDirectoryClusterName, and SessionDirectoryAdditionalParams are 
// generic reg entries known to TermSrv which cover config info across any type
// of session directory implementation. The contents of these strings are 
// designed to be parsed by the session directory providers.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Initialize(
        LPWSTR LocalServerAddress,
        LPWSTR StoreServerName,
        LPWSTR ClusterName,
        LPWSTR OpaqueSettings,
        DWORD Flags,
        DWORD (*repopfn)(),
        DWORD (*updatesd)(DWORD))
{
    HRESULT hr = S_OK;
    DWORD Status;

    // Unreferenced parameter
    OpaqueSettings;

    if (m_LockInitializationSuccessful == FALSE) {
        hr = E_OUTOFMEMORY;
        goto ExitFunc;
    }
    if (!m_bStartRPCListener) {
        if (SDJETInitRPC())
            m_bStartRPCListener = TRUE;
    }

    ASSERT((LocalServerAddress != NULL),(TB,"Init: LocalServerAddr null!"));
    ASSERT((StoreServerName != NULL),(TB,"Init: StoreServerName null!"));
    ASSERT((ClusterName != NULL),(TB,"Init: ClusterName null!"));
    ASSERT((repopfn != NULL),(TB,"Init: repopfn null!"));
    ASSERT((updatesd != NULL),(TB,"Init: updatesd null!"));

    // Don't allow blank session directory server name.
    if (StoreServerName[0] == '\0') {
        hr = E_INVALIDARG;
        goto ExitFunc;
    }

    // Copy off the server address, store server, and cluster name for later
    // use.
    wcsncpy(m_StoreServerName, StoreServerName,
            sizeof(m_StoreServerName) / sizeof(WCHAR) - 1);
    m_StoreServerName[sizeof(m_StoreServerName) / sizeof(WCHAR) - 1] = L'\0';
    wcsncpy(m_LocalServerAddress, LocalServerAddress,
            sizeof(m_LocalServerAddress) / sizeof(WCHAR) - 1);
    m_LocalServerAddress[sizeof(m_LocalServerAddress) / sizeof(WCHAR) - 1] =
            L'\0';
    wcsncpy(m_ClusterName, ClusterName,
            sizeof(m_ClusterName) / sizeof(WCHAR) - 1);
    m_ClusterName[sizeof(m_ClusterName) / sizeof(WCHAR) - 1] = L'\0';
    m_Flags = Flags;
    m_repopfn = repopfn;
    g_updatesd = updatesd;

    TRC1((TB,"Initialize: Svr addr=%S, StoreSvrName=%S, ClusterName=%S, "
            "OpaqueSettings=%S, repopfn = %p",
            m_LocalServerAddress, m_StoreServerName, m_ClusterName,
            OpaqueSettings, repopfn));


    // Initialize recovery infrastructure
    // Initialize should not be called more than once.

    ASSERT((m_hSDServerDown == NULL),(TB, "Init: m_hSDServDown non-NULL!"));
    ASSERT((m_hRecoveryThread == NULL),(TB, "Init: m_hSDRecoveryThread "
            "non-NULL!"));
    ASSERT((m_hTerminateRecovery == NULL), (TB, "Init: m_hTerminateRecovery "
            "non-NULL!"));

    // we are initializing or re-initializing so connection to SD is down.
    SetSDConnectionDown();

    // Initially unsignaled
    m_hSDServerDown = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (m_hSDServerDown == NULL) {
        ERR((TB, "Init: Failed to create event necessary for SD init, err = "
                "%d", GetLastError()));
        hr = E_FAIL;
        goto ExitFunc;
    }

    // Initially unsignaled, auto-reset.
    m_hTerminateRecovery = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hTerminateRecovery == NULL) {
        ERR((TB, "Init: Failed to create event necessary for SD init, err = "
            "%d", GetLastError()));
        hr = E_FAIL;
        goto ExitFunc;
    }

    // Initially unsignaled, auto-reset.
    m_hIPChange = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (m_hIPChange == NULL) {
        ERR((TB, "Init: Failed to create event necessary for IP Change, err = "
                "%d", GetLastError()));
        hr = E_FAIL;
        goto ExitFunc;
    } 
    m_OverLapped.hEvent = m_hIPChange;
    Status = NotifyAddrChange(&m_NotifyIPChange, &m_OverLapped);
    if (ERROR_IO_PENDING == Status ) {
        TRC1((TB, "Success: NotifyAddrChange returned IO_PENDING"));
    }
    else {
        ERR((TB, "Failure: NotifyAddrChange returned %d", Status));
    }

    // make sure event is at signal state initially.
    SetEvent( m_hInRepopulate );

    m_hRecoveryThread = _beginthreadex(NULL, 0, RecoveryThread, (void *) this, 
            0, &m_RecoveryTid);
    if (m_hRecoveryThread == NULL) {
        ERR((TB, "Init: Failed to create recovery thread, errno = %d", errno));
        hr = E_FAIL;
        goto ExitFunc;
    }
    
    // Start up the session directory (by faking server down).
    StartupSD();
    
ExitFunc:

    return hr;
}


// Register RPC server on tssdjet, SD will call it when do recovering
BOOL CTSSessionDirectory::SDJETInitRPC()
{
    RPC_STATUS Status;
    RPC_BINDING_VECTOR *pBindingVector = 0;
    RPC_POLICY rpcpol = {sizeof(rpcpol), 0, 0};
    BOOL rc = FALSE;
    WCHAR *szPrincipalName = NULL;

    // Init the RPC server interface.
    Status = RpcServerUseProtseqEx(L"ncacn_ip_tcp", 3, 0, &rpcpol);
    if (Status != RPC_S_OK) {
        ERR((TB,"JETInitRPC: Error %d RpcUseProtseqEp on ncacn_ip_tcp", 
                Status));
        goto PostRegisterService;
    }

    // Register our interface handle (found in sdrpc.h).
    Status = RpcServerRegisterIfEx(TSSDTOJETRPC_ServerIfHandle, NULL, NULL,
                                   0, RPC_C_LISTEN_MAX_CALLS_DEFAULT, JetRpcAccessCheck);
    if (Status != RPC_S_OK) {
        ERR((TB,"JETInitRPC: Error %d RegIf", Status));
        goto PostRegisterService;
    }

    Status = RpcServerInqBindings(&pBindingVector);
    if (Status != RPC_S_OK) {
        ERR((TB,"JETInitRPC: Error %d InqBindings", Status));
        goto PostRegisterService;
    }

    Status = RpcEpRegister(TSSDTOJETRPC_ServerIfHandle, pBindingVector, 0, 0); 
    if (Status != RPC_S_OK) {
        ERR((TB,"JETInitRPC: Error %d EpReg", Status));
        goto PostRegisterService;
    }             

    Status = RpcServerInqDefaultPrincName(RPC_C_AUTHN_GSS_NEGOTIATE, &szPrincipalName);
    if (Status != RPC_S_OK) {
        ERR((TB,"JETInitRPC: Error %d ServerIngDefaultPrincName", Status));
        goto PostRegisterService;
    }

    Status = RpcServerRegisterAuthInfo(szPrincipalName, RPC_C_AUTHN_GSS_NEGOTIATE, NULL, NULL);
    RpcStringFree(&szPrincipalName);
    if (Status != RPC_S_OK) {
        ERR((TB,"JETInitRPC: Error %d RpcServerRegisterAuthInfo", Status));
        //PostSessDirErrorValueEvent(EVENT_FAIL_RPC_INIT_REGAUTHINFO, Status);
        goto PostRegisterService;
    }

    rc = TRUE;

PostRegisterService:
    if (pBindingVector) {
        RpcBindingVectorFree(&pBindingVector);
    }
    return rc;
}

/****************************************************************************/
// CTSSessionDirectory::Update
//
// ITSSessionDirectory function. Called whenever configuration settings change
// on the terminal server.  See Initialize for a description of the first four
// arguments, the fifth, Result, is a flag of whether to request a refresh of
// every session that should be in the session directory for this server after
// this call completes.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Update(
        LPWSTR LocalServerAddress,
        LPWSTR StoreServerName,
        LPWSTR ClusterName,
        LPWSTR OpaqueSettings,
        DWORD Flags,
        BOOL ForceRejoin)
{
    HRESULT hr = S_OK;

    ASSERT((LocalServerAddress != NULL),(TB,"Update: LocalServerAddr null!"));
    ASSERT((StoreServerName != NULL),(TB,"Update: StoreServerName null!"));
    ASSERT((ClusterName != NULL),(TB,"Update: ClusterName null!"));
    ASSERT((OpaqueSettings != NULL),(TB,"Update: OpaqueSettings null!"));

    // For update, we do not care about OpaqueSettings.  
    // If the StoreServerName, ClusterName, LocalServerAddress or Flags has changed, 
    // or ForceRejoin is TRUE
    // we terminate and then reinitialize.
    if ((_wcsnicmp(StoreServerName, m_StoreServerName, 64) != 0) 
            || (_wcsnicmp(ClusterName, m_ClusterName, 64) != 0)
            || (wcsncmp(LocalServerAddress, m_LocalServerAddress, 64) != 0)
            || (Flags != m_Flags)
            || ForceRejoin) { 

        // Terminate current connection.
        Terminate();
        
        // Initialize new connection.
        hr = Initialize(LocalServerAddress, StoreServerName, ClusterName, 
                OpaqueSettings, Flags, m_repopfn, g_updatesd);

    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::GetUserDisconnectedSessions
//
// Called to perform a query against the session directory, to provide the
// list of disconnected sessions for the provided username and domain.
// Returns zero or more TSSD_DisconnectedSessionInfo blocks in SessionBuf.
// *pNumSessionsReturned receives the number of blocks.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::GetUserDisconnectedSessions(
        LPWSTR UserName,
        LPWSTR Domain,
        DWORD __RPC_FAR *pNumSessionsReturned,
        TSSD_DisconnectedSessionInfo __RPC_FAR SessionBuf[
            TSSD_MaxDisconnectedSessions])
{
    DWORD NumSessions = 0;
    HRESULT hr;
    unsigned i;
    unsigned long RpcException;
    TSSD_DiscSessInfo *adsi = NULL;
    
    TRC2((TB,"GetUserDisconnectedSessions"));

    ASSERT((pNumSessionsReturned != NULL),(TB,"NULL pNumSess"));
    ASSERT((SessionBuf != NULL),(TB,"NULL SessionBuf"));


    // Make the RPC call.
    if (EnterSDRpc()) {
    
        RpcTryExcept {
            hr = TSSDRpcGetUserDisconnectedSessions(m_hRPCBinding, &m_hCI, 
                    UserName, Domain, &NumSessions, &adsi);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"GetUserDisc: RPC Exception %d\n", RpcException));

            // In case RPC messed with us.
            m_hCI = NULL;
            NumSessions = 0;
            adsi = NULL;

            hr = E_FAIL;
        }
        RpcEndExcept

        if (SUCCEEDED(hr)) {
            TRC1((TB,"GetUserDisc: RPC call returned %u records", NumSessions));

            // Loop through and fill out the session records.
            for (i = 0; i < NumSessions; i++) {
                // ServerAddress
                wcsncpy(SessionBuf[i].ServerAddress, adsi[i].ServerAddress,
                        sizeof(SessionBuf[i].ServerAddress) / 
                        sizeof(WCHAR) - 1);
                SessionBuf[i].ServerAddress[sizeof(
                        SessionBuf[i].ServerAddress) / 
                        sizeof(WCHAR) - 1] = L'\0';

                // SessionId, TSProtocol
                SessionBuf[i].SessionID = adsi[i].SessionID;
                SessionBuf[i].TSProtocol = adsi[i].TSProtocol;

                // ApplicationType
                wcsncpy(SessionBuf[i].ApplicationType, adsi[i].AppType,
                        sizeof(SessionBuf[i].ApplicationType) / 
                        sizeof(WCHAR) - 1);
                SessionBuf[i].ApplicationType[sizeof(SessionBuf[i].
                        ApplicationType) / sizeof(WCHAR) - 1] = L'\0';

                // Resolutionwidth, ResolutionHeight, ColorDepth, CreateTime,
                // DisconnectionTime.
                SessionBuf[i].ResolutionWidth = adsi[i].ResolutionWidth;
                SessionBuf[i].ResolutionHeight = adsi[i].ResolutionHeight;
                SessionBuf[i].ColorDepth = adsi[i].ColorDepth;
                SessionBuf[i].CreateTime.dwLowDateTime = adsi[i].CreateTimeLow;
                SessionBuf[i].CreateTime.dwHighDateTime = 
                        adsi[i].CreateTimeHigh;
                SessionBuf[i].DisconnectionTime.dwLowDateTime = 
                        adsi[i].DisconnectTimeLow;
                SessionBuf[i].DisconnectionTime.dwHighDateTime = 
                        adsi[i].DisconnectTimeHigh;

                // Free the memory allocated by the server.
                MIDL_user_free(adsi[i].ServerAddress);
                MIDL_user_free(adsi[i].AppType);
            }
        }
        else {
            ERR((TB,"GetUserDisc: Failed RPC call, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"GetUserDisc: Session Directory is unreachable"));
        hr = E_FAIL;
    }

    MIDL_user_free(adsi);

    *pNumSessionsReturned = NumSessions;
    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyCreateLocalSession
//
// ITSSessionDirectory function. Called when a session is created to add the
// session to the session directory. Note that other interface functions
// access the session directory by either the username/domain or the
// session ID; the directory schema should take this into account for
// performance optimization.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyCreateLocalSession(
        TSSD_CreateSessionInfo __RPC_FAR *pCreateInfo)
{
    HRESULT hr;
    unsigned long RpcException;
    BOOL bSDRPC = EnterSDRpc();
    BOOL bSDConnection = IsSDConnectionReady();

    // if EnterSDRPC() return FALSE and IsSDConnectionReady() return TRUE, that 
    // indicate repopuating thread did not complete its task within 30 second
    // and this logon thread is running way ahead of it, we still need to report
    // logon to session directory, session directory will remove duplicate
    // entry.

    TRC2((TB,"NotifyCreateLocalSession, SessID=%u", pCreateInfo->SessionID));

    ASSERT((pCreateInfo != NULL),(TB,"NotifyCreate: NULL CreateInfo"));

    #if DBG
    if( bSDConnection == TRUE && bSDRPC == FALSE ) {
        TRC2((TB,"NotifyCreateLocalSession, SessID=%u, logon thread is way ahead of repopulating thread", pCreateInfo->SessionID));
    }
    #endif

    // Make the RPC call.
    if (bSDConnection) {

        // Make the RPC call.
        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcCreateSession(m_hRPCBinding, &m_hCI, 
                    pCreateInfo->UserName,
                    pCreateInfo->Domain, pCreateInfo->SessionID,
                    pCreateInfo->TSProtocol, pCreateInfo->ApplicationType,
                    pCreateInfo->ResolutionWidth, pCreateInfo->ResolutionHeight,
                    pCreateInfo->ColorDepth, 
                    pCreateInfo->CreateTime.dwLowDateTime,
                    pCreateInfo->CreateTime.dwHighDateTime);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyCreate: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        // we only notify SD server down when EnterSDRpc() return TRUE,
        if (FAILED(hr) && bSDRPC) {
            ERR((TB,"NotifyCreate: Failed RPC call, hr=0x%X", hr));
            NotifySDServerDown();
        }
    }

    if( bSDRPC ) {
        LeaveSDRpc();
    }

    if( !bSDRPC && !bSDConnection ) {
        ERR((TB,"NotifyCreate: Session directory is unreachable"));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyDestroyLocalSession
//
// ITSSessionDirectory function. Removes a session from the session database.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyDestroyLocalSession(
        DWORD SessionID)
{
    HRESULT hr;
    unsigned long RpcException;

    TRC2((TB,"NotifyDestroyLocalSession, SessionID=%u", SessionID));

    // Make the RPC call.
    if (EnterSDRpc()) {

        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcDeleteSession(m_hRPCBinding, &m_hCI, SessionID);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyDestroy: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(hr)) {
            ERR((TB,"NotifyDestroy: Failed RPC call, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"NotifyDestroy: Session directory is unreachable"));
        hr = E_FAIL;
    }


    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyDisconnectLocalSession
//
// ITSSessionDirectory function. Changes the state of an existing session to
// disconnected. The provided time should be returned in disconnected session
// queries performed by any machine in the server pool.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyDisconnectLocalSession(
        DWORD SessionID,
        FILETIME DiscTime)
{
    HRESULT hr;
    unsigned long RpcException;

    TRC2((TB,"NotifyDisconnectLocalSession, SessionID=%u", SessionID));

    // Make the RPC call.
    if (EnterSDRpc()) {

        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcSetSessionDisconnected(m_hRPCBinding, &m_hCI, SessionID,
                    DiscTime.dwLowDateTime, DiscTime.dwHighDateTime);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyDisc: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(hr)) {
            ERR((TB,"NotifyDisc: RPC call failed, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"NotifyDisc: Session directory is unreachable"));
        hr = E_FAIL;
    }


    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyReconnectLocalSession
//
// ITSSessionDirectory function. Changes the state of an existing session
// from disconnected to connected.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyReconnectLocalSession(
        TSSD_ReconnectSessionInfo __RPC_FAR *pReconnInfo)
{
    HRESULT hr;
    unsigned long RpcException;

    TRC2((TB,"NotifyReconnectLocalSession, SessionID=%u",
            pReconnInfo->SessionID));
    
    // Make the RPC call.
    if (EnterSDRpc()) {

        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcSetSessionReconnected(m_hRPCBinding, &m_hCI, 
                    pReconnInfo->SessionID, pReconnInfo->TSProtocol, 
                    pReconnInfo->ResolutionWidth, pReconnInfo->ResolutionHeight,
                    pReconnInfo->ColorDepth);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyReconn: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(hr)) {
            ERR((TB,"NotifyReconn: RPC call failed, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"NotifyReconn: Session directory is unreachable"));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyReconnectPending
//
// ITSSessionDirectory function. Informs session directory that a reconnect
// is pending soon because of a revectoring.  Used by DIS to determine
// when a server might have gone down.  (DIS is the Directory Integrity
// Service, which runs on the machine with the session directory.)
//
// This is a two-phase procedure--we first check the fields, and then we
// add the timestamp only if there is no outstanding timestamp already (i.e., 
// the two Almost-In-Time fields are 0).  This prevents constant revectoring
// from updating the timestamp fields, which would prevent the DIS from 
// figuring out that a server is down.
//
// These two steps are done in the stored procedure to make the operation
// atomic.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyReconnectPending(
        WCHAR *ServerName)
{
    HRESULT hr;
    unsigned long RpcException;
    FILETIME ft;
    SYSTEMTIME st;
    
    TRC2((TB,"NotifyReconnectPending"));

    ASSERT((ServerName != NULL),(TB,"NotifyReconnectPending: NULL ServerName"));

    // Get the current system time.
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // Make the RPC call.
    if (EnterSDRpc()) {

        RpcTryExcept {
            // Make the call.
            hr = TSSDRpcSetServerReconnectPending(m_hRPCBinding, ServerName, 
                    ft.dwLowDateTime, ft.dwHighDateTime);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"NotifyReconnPending: RPC Exception %d\n", RpcException));
            hr = E_FAIL;
        }
        RpcEndExcept

        if (FAILED(hr)) {
            ERR((TB,"NotifyReconnPending: RPC call failed, hr=0x%X", hr));
            NotifySDServerDown();
        }

        LeaveSDRpc();
    }
    else {
        ERR((TB,"NotifyReconnPending: Session directory is unreachable"));
        hr = E_FAIL;
    }

    return hr;
}

/****************************************************************************/
// CTSSessionDirectory::Repopulate
//
// This function is called by the recovery thread, and repopulates the session
// directory with all sessions.
//
// Arguments: WinStationCount - # of winstations to repopulate
//   rsi - array of TSSD_RepopulateSessionInfo structs.
//
// Return value: HRESULT
/****************************************************************************/

#if DBG
#define MAX_REPOPULATE_SESSION  3
#else
#define MAX_REPOPULATE_SESSION  25
#endif

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Repopulate(DWORD WinStationCount,
        TSSD_RepopulateSessionInfo *rsi)
{
    HRESULT hr = S_OK;
    unsigned long RpcException;
    DWORD dwNumSessionLeft = WinStationCount;
    DWORD dwSessionsToRepopulate;
    DWORD i;

    ASSERT(((rsi != NULL) || (WinStationCount == 0)),(TB,"Repopulate: NULL "
            "rsi!"));

    RpcTryExcept {

        for(i = 0 ; dwNumSessionLeft > 0 && SUCCEEDED(hr); i++) {

            dwSessionsToRepopulate = (dwNumSessionLeft > MAX_REPOPULATE_SESSION) ? MAX_REPOPULATE_SESSION : dwNumSessionLeft;
            
            hr = TSSDRpcRepopulateAllSessions(m_hRPCBinding, &m_hCI, 
                        dwSessionsToRepopulate, 
                        (TSSD_RepopInfo *) (rsi + i * MAX_REPOPULATE_SESSION) );

            dwNumSessionLeft -= dwSessionsToRepopulate;
        }
                
        if (FAILED(hr)) {
            ERR((TB, "Repop: RPC call failed, hr = 0x%X", hr));
        }
    }
    RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
        RpcException = RpcExceptionCode();
        ERR((TB, "Repop: RPC Exception %d\n", RpcException));
        hr = E_FAIL;
    }
    RpcEndExcept

    return hr;

}



/****************************************************************************/
// Plug-in UI interface for TSCC
/****************************************************************************/


/****************************************************************************/
// describes the name of this entry in server settings
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::GetAttributeName(
        /* out */ WCHAR *pwszAttribName)
{
    TCHAR szAN[256];

    ASSERT((pwszAttribName != NULL),(TB,"NULL attrib ptr"));
    LoadString(g_hInstance, IDS_ATTRIBUTE_NAME, szAN, sizeof(szAN) / 
            sizeof(TCHAR));
    lstrcpy(pwszAttribName, szAN);
    return S_OK;
}


/****************************************************************************/
// for this component the attribute value indicates whether it is enabled
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::GetDisplayableValueName(
        /* out */WCHAR *pwszAttribValueName)
{
    TCHAR szAvn[256];    

    ASSERT((pwszAttribValueName != NULL),(TB,"NULL attrib ptr"));

	POLICY_TS_MACHINE gpolicy;
    RegGetMachinePolicy(&gpolicy);        

    if (gpolicy.fPolicySessionDirectoryActive)
		m_fEnabled = gpolicy.SessionDirectoryActive;
	else
		m_fEnabled = IsSessionDirectoryEnabled();
    
	if (m_fEnabled)
    {
        LoadString(g_hInstance, IDS_ENABLE, szAvn, sizeof(szAvn) / 
                sizeof(TCHAR));
    }
    else
    {
        LoadString(g_hInstance, IDS_DISABLE, szAvn, sizeof(szAvn) / 
                sizeof(TCHAR));
    }
    lstrcpy(pwszAttribValueName, szAvn);    
    return S_OK;
}


/****************************************************************************/
// Provides custom UI
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::InvokeUI(/* in */ HWND hParent, /*out*/ 
        PDWORD pdwStatus)
{
    WSADATA wsaData;

    if (WSAStartup(0x202, &wsaData) == 0)
    {
        INT_PTR iRet = DialogBoxParam(g_hInstance,
            MAKEINTRESOURCE(IDD_DIALOG_SDS),
            hParent,
            CustomUIDlg,
            (LPARAM)this
           );

        // TRC1((TB,"DialogBox returned 0x%x", iRet));
        // TRC1((TB,"Extended error = %lx", GetLastError()));
        *pdwStatus = (DWORD)iRet;
        WSACleanup();
    }
    else
    {
        *pdwStatus = WSAGetLastError();
        TRC1((TB,"WSAStartup failed with 0x%x", *pdwStatus));
        ErrorMessage(hParent, IDS_ERROR_TEXT3, *pdwStatus);
        return E_FAIL;
    }
    return S_OK;
}


/****************************************************************************/
// Custom menu items -- must be freed by LocalFree
// this is called everytime the user right clicks the listitem
// so you can alter the settings (i.e. enable to disable and vice versa)
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::GetMenuItems(
        /* out */ int *pcbItems,
        /* out */ PMENUEXTENSION *pMex)
{
    ASSERT((pcbItems != NULL),(TB,"NULL items ptr"));

    *pcbItems = 2;
    *pMex = (PMENUEXTENSION)LocalAlloc(LMEM_FIXED, *pcbItems * 
            sizeof(MENUEXTENSION));
    if (*pMex != NULL)
    {
        LoadString(g_hInstance, IDS_PROPERTIES,  (*pMex)[0].MenuItemName,
                sizeof((*pMex)[0].MenuItemName) / sizeof(WCHAR));
        LoadString(g_hInstance, IDS_DESCRIP_PROPS, (*pMex)[0].StatusBarText,
                sizeof((*pMex)[0].StatusBarText) / sizeof(WCHAR));
        (*pMex)[0].fFlags = 0;

        // menu items id -- this id will be passed back to you in ExecMenuCmd
        (*pMex)[0].cmd = IDM_MENU_PROPS;

        // load string to display enable or disable
        (*pMex)[1].fFlags = 0;
        if (!m_fEnabled)
        {
            LoadString(g_hInstance, IDS_ENABLE, (*pMex)[1].MenuItemName,
                    sizeof((*pMex)[1].MenuItemName) / sizeof(WCHAR));
            // Disable this menu item if the store server name is empty
            if (CheckIfSessionDirectoryNameEmpty(REG_TS_CLUSTER_STORESERVERNAME)) {
                //Clear the last 2 bits since MF_GRAYED is 
                //incompatible with MF_DISABLED
                (*pMex)[1].fFlags &= 0xFFFFFFFCL;
                (*pMex)[1].fFlags |= MF_GRAYED;
            }
        }
        else
        {
            LoadString(g_hInstance, IDS_DISABLE, (*pMex)[1].MenuItemName,
                    sizeof((*pMex)[1].MenuItemName) / sizeof(WCHAR));
        }  
        // acquire the description text for menu item
        LoadString(g_hInstance, IDS_DESCRIP_ENABLE, (*pMex)[1].StatusBarText,
                sizeof((*pMex)[1].StatusBarText) / sizeof(WCHAR));

        // menu items id -- this id will be passed back to you in ExecMenuCmd
        (*pMex)[1].cmd = IDM_MENU_ENABLE;

        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


/****************************************************************************/
// When the user selects a menu item the cmd id is passed to this component.
// the provider (which is us)
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::ExecMenuCmd(
        /* in */ UINT cmd,
        /* in */ HWND hParent,
        /* out*/ PDWORD pdwStatus)
{
    WSADATA wsaData;

    switch (cmd) {
        case IDM_MENU_ENABLE:
            
            m_fEnabled = m_fEnabled ? 0 : 1;
            
            TRC1((TB,"%ws was selected", m_fEnabled ? L"Disable" : L"Enable"));
            
            if (SetSessionDirectoryEnabledState(m_fEnabled) == ERROR_SUCCESS)
            {            
                *pdwStatus = UPDATE_TERMSRV_SESSDIR;
            }            
            break;
        case IDM_MENU_PROPS:
            
            if (WSAStartup(0x202, &wsaData) == 0)
            {
                INT_PTR iRet = DialogBoxParam(g_hInstance,
                    MAKEINTRESOURCE(IDD_DIALOG_SDS),
                    hParent,
                    CustomUIDlg,
                    (LPARAM)this);
                *pdwStatus = (DWORD)iRet;

                WSACleanup();
            }
            else
            {
                *pdwStatus = WSAGetLastError();
                TRC1((TB,"WSAStartup failed with 0x%x", *pdwStatus));        
                ErrorMessage(hParent, IDS_ERROR_TEXT3, *pdwStatus);
                return E_FAIL;
            }
    }
    return S_OK;
}


/****************************************************************************/
// Tscc provides a default help menu item,  when selected this method is called
// if we want tscc to handle (or provide) help return any value other than zero
// for those u can't follow logic return zero if you're handling help.
/****************************************************************************/
STDMETHODIMP CTSSessionDirectory::OnHelp(/* out */ int *piRet)
{
    ASSERT((piRet != NULL),(TB,"NULL ret ptr"));
    *piRet = 0;
    return S_OK;
}


/****************************************************************************/
// CheckSessionDirectorySetting returns a bool
/****************************************************************************/
BOOL CTSSessionDirectory::CheckSessionDirectorySetting(WCHAR *Setting)
{
    LONG lRet;
    HKEY hKey;
    DWORD dwEnabled = 0;
    DWORD dwSize = sizeof(DWORD);

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REG_CONTROL_TSERVER,
                         0,
                         KEY_READ,
                         &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        lRet = RegQueryValueEx(hKey,
                               Setting,
                               NULL,
                               NULL,
                               (LPBYTE)&dwEnabled,
                               &dwSize);
        RegCloseKey(hKey);
    }
    return (BOOL)dwEnabled;
}

/****************************************************************************/
// CheckSessionDirectorySetting returns a bool
//      returns TRUE if this registry value is empty
/****************************************************************************/
BOOL CTSSessionDirectory::CheckIfSessionDirectoryNameEmpty(WCHAR *Setting)
{
    LONG lRet;
    HKEY hKey;
    WCHAR Names[SDNAMELENGTH];
    DWORD dwSize = sizeof(Names);
    BOOL rc = TRUE;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         REG_TS_CLUSTERSETTINGS,
                         0,
                         KEY_READ,
                         &hKey);
    if (lRet == ERROR_SUCCESS)
    {
        lRet = RegQueryValueEx(hKey,
                               Setting,
                               NULL,
                               NULL,
                               (BYTE *)Names,
                               &dwSize);
        if (lRet == ERROR_SUCCESS) {
            if (wcslen(Names) != 0) {
                rc = FALSE;
            }
        }
        RegCloseKey(hKey);
    }
    return rc;
}


/****************************************************************************/
// IsSessionDirectoryEnabled returns a bool
/****************************************************************************/
BOOL CTSSessionDirectory::IsSessionDirectoryEnabled()
{
    return CheckSessionDirectorySetting(REG_TS_SESSDIRACTIVE);
}


/****************************************************************************/
// IsSessionDirectoryEnabled returns a bool
/****************************************************************************/
BOOL CTSSessionDirectory::IsSessionDirectoryExposeServerIPEnabled()
{
    return CheckSessionDirectorySetting(REG_TS_SESSDIR_EXPOSE_SERVER_ADDR);
}


/****************************************************************************/
// SetSessionDirectoryState - sets "Setting" regkey to bVal
/****************************************************************************/
DWORD CTSSessionDirectory::SetSessionDirectoryState(WCHAR *Setting, BOOL bVal)
{
    LONG lRet;
    HKEY hKey;
    DWORD dwSize = sizeof(DWORD);
    
    lRet = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        REG_CONTROL_TSERVER,
                        0,
                        KEY_WRITE,
                        &hKey);
    if (lRet == ERROR_SUCCESS)
    {   
        lRet = RegSetValueEx(hKey,
                              Setting,
                              0,
                              REG_DWORD,
                              (LPBYTE)&bVal,
                              dwSize);
        RegCloseKey(hKey);
    }
    else
    {
        ErrorMessage(NULL, IDS_ERROR_TEXT3, (DWORD)lRet);
    }
    return (DWORD)lRet;
}


/****************************************************************************/
// SetSessionDirectoryEnabledState - sets SessionDirectoryActive regkey to bVal
/****************************************************************************/
DWORD CTSSessionDirectory::SetSessionDirectoryEnabledState(BOOL bVal)
{
    return SetSessionDirectoryState(REG_TS_SESSDIRACTIVE, bVal);
}


/****************************************************************************/
// SetSessionDirectoryExposeIPState - sets SessionDirectoryExposeServerIP 
// regkey to bVal
/****************************************************************************/
DWORD CTSSessionDirectory::SetSessionDirectoryExposeIPState(BOOL bVal)
{
    return SetSessionDirectoryState(REG_TS_SESSDIR_EXPOSE_SERVER_ADDR, bVal);
}


/****************************************************************************/
// ErrorMessage --
/****************************************************************************/
void CTSSessionDirectory::ErrorMessage(HWND hwnd, UINT res, DWORD dwStatus)
{
    TCHAR tchTitle[64];
    TCHAR tchText[64];
    TCHAR tchErrorMessage[256];
    LPTSTR pBuffer = NULL;
    
    // report error
    ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,                                   //ignored
            (DWORD)dwStatus,                        //message ID
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),  //message language
            (LPTSTR)&pBuffer,                       //address of buffer pointer
            0,                                      //minimum buffer size
            NULL);  
    
    LoadString(g_hInstance, IDS_ERROR_TITLE, tchTitle, sizeof(tchTitle) / 
            sizeof(TCHAR));
    LoadString(g_hInstance, res, tchText, sizeof(tchText) / sizeof(TCHAR));
    wsprintf(tchErrorMessage, tchText, pBuffer);
    ::MessageBox(hwnd, tchErrorMessage, tchTitle, MB_OK | MB_ICONINFORMATION);
}


/****************************************************************************/
// CTSSessionDirectory::RecoveryThread
//
// Static helper function.  The SDPtr passed in is a pointer to this for
// when _beginthreadex is called during init.  RecoveryThread simply calls
// the real recovery function, which is RecoveryThreadEx.
/****************************************************************************/
unsigned __stdcall CTSSessionDirectory::RecoveryThread(void *SDPtr) {

    ((CTSSessionDirectory *)SDPtr)->RecoveryThreadEx();

    return 0;
}


/****************************************************************************/
// CTSSessionDirectory::RecoveryThreadEx
//
// Recovery thread for tssdjet recovery.  Sits around and waits for the
// server to go down.  When the server fails, it wakes up, sets a variable
// indicating that the server is unreachable, and then tries to reestablish
// a connection with the server.  Meanwhile, further calls to the session
// directory simply fail without delay.
//
// When the session directory finally comes back up, the recovery thread
// temporarily halts session directory updates while repopulating the database.
// If all goes well, it cleans up and goes back to sleep.  If all doesn't go
// well, it tries again.
//
// The recovery thread terminates if it fails a wait, or if m_hTerminateRecovery
// is set.
/****************************************************************************/
VOID CTSSessionDirectory::RecoveryThreadEx()
{
    DWORD err = 0;
    BOOL bErr;
    CONST HANDLE lpHandles[] = {m_hTerminateRecovery, m_hSDServerDown, m_hIPChange};
    WCHAR *pwszAddressList[SD_NUM_IP_ADDRESS];
    DWORD dwNumAddr = SD_NUM_IP_ADDRESS, i;
    BOOL bFoundIPMatch = FALSE;
    DWORD Status;
    HKEY hKey;
    LONG lRet;
        
    for ( ; ; ) {
        // Wait forever until there is a problem with the session directory,
        // or until we are told to shut down.
        err = WaitForMultipleObjects(3, lpHandles, FALSE, INFINITE);

        switch (err) {
            case WAIT_OBJECT_0: // m_hTerminateRecovery
                // We're quitting.
                return;
            case WAIT_OBJECT_0 + 1: // m_hSDServerDown
                // SD Server Down--go through recovery.
                break;
            case WAIT_OBJECT_0 + 2: // m_hIPChange
                // IP address changed --go through recovery.
                TRC1((TB, "Get notified that IP changed"));
                // wait for 15 seconds here so that RPC service can respond
                //  to IP change
                Sleep(15 * 1000);
                Status = NotifyAddrChange(&m_NotifyIPChange, &m_OverLapped);
                if (ERROR_IO_PENDING == Status ) {
                    TRC1((TB, "Success: NotifyAddrChange returned IO_PENDING"));
                }
                else {
                    ERR((TB, "Failure: NotifyAddrChange returned %d", Status));
                }

                break;
            default:
                // This is unexpected.  Assert on checked builds.  On free,
                // just return.
                ASSERT(((err == WAIT_OBJECT_0) || (err == WAIT_OBJECT_0 + 1)),
                        (TB, "RecoveryThreadEx: Unexpected value from Wait!"));
                return;
        }

        // we are disabling RPC connection to Session Directory
        SetSDConnectionDown();

        // Wait for all pending SD Rpcs to complete, and make all further
        // EnterSDRpc's return FALSE until we're back up.  Note that if there
        // is a failure in recovery that this can be called more than once.
        DisableSDRpcs();

        // Destroy context handle if it's not NULL
        if (m_hCI) {
            RpcTryExcept  {
                RpcSsDestroyClientContext(&m_hCI);
            } RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
                //
                // The try/except is for that bad handles don't bring
                // the process down
                //
                ERR((TB, "RpcSsDestroyClientContext raised an exception %d", RpcExceptionCode()));
            } RpcEndExcept;
            m_hCI = NULL;
        }
        
        // We need to tell if m_LocalServerAddress is a valid IP for SD redirection
        //  if not, we get a list of valid IPs and pick the 1st one as the SD redirection IP
        //  and write it to the SDRedirectionIP registry

        // Initialize pwszAddressList first
        for (i=0; i<dwNumAddr; i++) {
            pwszAddressList[i] = NULL;
        }

        if (GetSDIPList(pwszAddressList, &dwNumAddr, TRUE) == S_OK) {
            bFoundIPMatch = FALSE;
            for (i=0; i<dwNumAddr; i++) {
                if (!wcscmp(m_LocalServerAddress, pwszAddressList[i])) {
                    bFoundIPMatch = TRUE;
                    TRC1((TB, "The IP is in the list\n"));
                    break;
                }
            }
            if (!bFoundIPMatch && (dwNumAddr != 0)) {  

                // Pick the 1st IP from the list
                wcsncpy(m_LocalServerAddress, pwszAddressList[0], sizeof(m_LocalServerAddress) / sizeof(WCHAR)); 
            }
            
        }
        else {
            ERR((TB, "Get IP List Failed"));
        }
        // Write the IP to the registry
        lRet= RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_TS_CLUSTERSETTINGS,
                        0,
                        KEY_READ | KEY_WRITE, 
                        &hKey);
        if (lRet == ERROR_SUCCESS) {
            RegSetValueEx(hKey,
                          REG_TS_CLUSTER_REDIRECTIONIP,
                          0,
                          REG_SZ,
                          (CONST LPBYTE) m_LocalServerAddress,
                          (DWORD)(wcslen(m_LocalServerAddress) * 
                               sizeof(WCHAR)));
             RegCloseKey(hKey);
        }
        // Free the memory allocated in GetSDIPList
        for (i=0; i<dwNumAddr; i++) {
            LocalFree(pwszAddressList[i]);
        }
        
        
        // This function loops and tries to reestablish a connection with the
        // session directory.  When it thinks it has one, it returns.
        // If it returns nonzero, though, that means it was terminated or
        // an error occurred in the wait, so terminate recovery.
        if (ReestablishSessionDirectoryConnection() != 0) 
            return; // don't need to reset m_hInRepopulate.

        // Set to non-signal - we are in repopulation.
        ResetEvent( m_hInRepopulate );

        // RPC connection is ready, let notify logon to go thru
        SetSDConnectionReady();
        
        // Now we have (theoretically) a session directory connection.
        // Update the session directory.  Nonzero on failure.
        err = 0;
        if (0 == (m_Flags & NO_REPOPULATE_SESSION)) {
            err = RequestSessDirUpdate();
        }

        if (err != 0) {

            // Failed in repopuation and we will loop back to establish 
            // connection again so set RPC connection to SD to down state.
            SetSDConnectionDown();

            // set to signal - we are not in repopulation any more.
            SetEvent( m_hInRepopulate );

            // Keep trying, so serverdown event stays signaled.
            continue;
        }

        // Everything is good now.  Clean up and wait for the next failure.
        bErr = ResetEvent(m_hSDServerDown);
        
        EnableSDRpcs();

        // set to signal - we are not in repopulation any more.
        SetEvent( m_hInRepopulate );
    }
}


/****************************************************************************/
// StartupSD
//
// Initiates a connection by signaling to the recovery thread that the server
// is down.
/****************************************************************************/
void CTSSessionDirectory::StartupSD()
{
    if (SetEvent(m_hSDServerDown) == FALSE) {
        ERR((TB, "StartupSD: SetEvent failed.  GetLastError=%d",
                GetLastError()));
    }
}


/****************************************************************************/
// NotifySDServerDown
//
// Tells the recovery thread that the server is down.
/****************************************************************************/
void CTSSessionDirectory::NotifySDServerDown()
{
    if (SetEvent(m_hSDServerDown) == FALSE) {
        ERR((TB, "NotifySDServerDown: SetEvent failed.  GetLastError=%d",
                GetLastError()));
    }
}


/****************************************************************************/
// EnterSDRpc
//
// This function returns whether it is OK to make an RPC right now.  It handles
// not letting anyone make an RPC call if RPCs are disabled, and also, if anyone
// is able to make an RPC, it ensures they will be able to do so until they call
// LeaveSDRpc.
//
// Return value:
//  true - if OK to make RPC call, in which case you must call LeaveSDRpc when
//   you are done.
//  false - if not OK.  You must not call LeaveSDRpc.
//  
/****************************************************************************/
boolean CTSSessionDirectory::EnterSDRpc()
{
    AcquireResourceShared(&m_sr);

    if (m_SDIsUp) {
        return TRUE;
    }
    else {
        ReleaseResourceShared(&m_sr);
        return FALSE;
    }
    
}


/****************************************************************************/
// LeaveSDRpc
//
// If you were able to EnterSDRpc (i.e., it returned true), you must call this 
// function when you are done with your Rpc call no matter what happened.
/****************************************************************************/
void CTSSessionDirectory::LeaveSDRpc()
{
    ReleaseResourceShared(&m_sr);
}


/****************************************************************************/
// DisableSDRpcs
//
// Prevent new EnterSDRpcs from returning true, and then wait for all pending
// EnterSDRpcs to be matched by their LeaveSDRpc's.
/****************************************************************************/
void CTSSessionDirectory::DisableSDRpcs()
{

    //
    // First, set the flag that the SD is up to FALSE, preventing further Rpcs.
    // Then, we grab the resource exclusive and release it right afterwards--
    // this forces us to wait until all RPCs we're already in have completed.
    //

    (void) InterlockedExchange(&m_SDIsUp, FALSE);

    AcquireResourceExclusive(&m_sr);
    ReleaseResourceExclusive(&m_sr);
}


/****************************************************************************/
// EnableSDRpcs
//
// Enable EnterSDRpcs to return true once again.
/****************************************************************************/
void CTSSessionDirectory::EnableSDRpcs()
{
    ASSERT((VerifyNoSharedAccess(&m_sr)),(TB,"EnableSDRpcs called but "
            "shouldn't be when there are shared readers."));

    (void) InterlockedExchange(&m_SDIsUp, TRUE);
}



/****************************************************************************/
// RequestSessDirUpdate
//
// Requests that termsrv update the session directory using the batchupdate
// interface.
//
// This function needs to know whether the update succeeded and return 0 on
// success, nonzero on failure.
/****************************************************************************/
DWORD CTSSessionDirectory::RequestSessDirUpdate()
{
    return (*m_repopfn)();
}


/****************************************************************************/
// ReestablishSessionDirectoryConnection
//
// This function loops and tries to reestablish a connection with the
// session directory.  When it has one, it returns.
//
// Return value: 0 if normal exit, nonzero if terminated by TerminateRecovery
// event.
/****************************************************************************/
DWORD CTSSessionDirectory::ReestablishSessionDirectoryConnection()
{
    HRESULT hr;
    unsigned long RpcException;
    DWORD err;
    WCHAR *szPrincipalName = NULL;
    RPC_SECURITY_QOS RPCSecurityQos;
    SEC_WINNT_AUTH_IDENTITY_EX CurrentIdentity;
    WCHAR CurrentUserName[SDNAMELENGTH];
    DWORD cchBuff;     
    WCHAR SDComputerName[SDNAMELENGTH];
    unsigned int FailCountBeforeClearFlag = 0;
    WCHAR LocalIPAddress[64];
    WCHAR *pBindingString = NULL;

    RPCSecurityQos.Version = RPC_C_SECURITY_QOS_VERSION;
    RPCSecurityQos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    RPCSecurityQos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    RPCSecurityQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    CurrentIdentity.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
    CurrentIdentity.Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EX);
    CurrentIdentity.Password = NULL;
    CurrentIdentity.PasswordLength = 0;
    CurrentIdentity.Domain = NULL;
    CurrentIdentity.DomainLength = 0;
    CurrentIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    CurrentIdentity.PackageList = SECPACKAGELIST;
    CurrentIdentity.PackageListLength = (unsigned long)wcslen(SECPACKAGELIST);

    cchBuff = sizeof(CurrentUserName) / sizeof(WCHAR);
    GetComputerNameEx(ComputerNamePhysicalNetBIOS, CurrentUserName, &cchBuff);
    wcscat(CurrentUserName, L"$");

    CurrentIdentity.User = CurrentUserName;
    CurrentIdentity.UserLength = (unsigned long)wcslen(CurrentUserName);

    if (m_hRPCBinding) {
        RpcBindingFree(&m_hRPCBinding);
        m_hRPCBinding = NULL;
    }
    // Connect to the Jet RPC server according to the server name provided.
    // We first create an RPC binding handle from a composed binding string.
    hr = RpcStringBindingCompose(/*(WCHAR *)g_RPCUUID,*/
            0,
            (WCHAR *)g_RPCProtocolSequence, m_StoreServerName,
            /*(WCHAR *)g_RPCRemoteEndpoint, */
            0,
            NULL, &pBindingString);

    if (hr == RPC_S_OK) {
        // Generate the RPC binding from the canonical RPC binding string.
        hr = RpcBindingFromStringBinding(pBindingString, &m_hRPCBinding);
        if (hr != RPC_S_OK) {
            ERR((TB,"Init: Error %d in RpcBindingFromStringBinding\n", hr));
            PostSDJetErrorValueEvent(EVENT_FAIL_RPCBINDINGFROMSTRINGBINDING, hr, EVENTLOG_ERROR_TYPE);
            m_hRPCBinding = NULL;
            goto ExitFunc;
        } 
    }
    else {
        ERR((TB,"Init: Error %d in RpcStringBindingCompose\n", hr));
        PostSDJetErrorValueEvent(EVENT_FAIL_RPCSTRINGBINDINGCOMPOSE, hr, EVENTLOG_ERROR_TYPE);
        pBindingString = NULL;
        goto ExitFunc;
    }

    
    
    m_RecoveryTimeout = JET_RECOVERY_TIMEOUT;
    for ( ; ; ) {
        // If the machine joins the SD during the OS boot time, we may get the local IP
        // as the localhost (127.0.0.1) since DHCP is not started yet. Therefore we need
        // to reget the local IP here
        if (!wcscmp(m_LocalServerAddress, L"127.0.0.1")) {
            if (0 != TSSDJetGetLocalIPAddr(LocalIPAddress)) {
                goto HandleError;
            }
            if (wcscmp(LocalIPAddress, L"127.0.0.1")) {
                wcscpy(m_LocalServerAddress, LocalIPAddress);
            }
            else {
                goto HandleError;
            }
        }

        hr = RpcBindingReset(m_hRPCBinding);
        if (hr != RPC_S_OK) {
            ERR((TB, "Recover: Error %d in RpcBindingReset", hr));
            PostSDJetErrorValueEvent(EVENT_FAIL_RPCBINDINGRESET, hr, EVENTLOG_ERROR_TYPE);
            goto HandleError;
        }   

        hr = RpcEpResolveBinding(m_hRPCBinding, TSSDJetRPC_ClientIfHandle);
        if (hr != RPC_S_OK) {
            ERR((TB, "Recover: Error %d in RpcEpResolveBinding", hr));
            if (RPC_S_SERVER_UNAVAILABLE == hr) {
                PostSDJetErrorMsgEvent(EVENT_SESSIONDIRECTORY_NAME_INVALID, m_StoreServerName, EVENTLOG_ERROR_TYPE);
            }
            else {
                PostSDJetErrorMsgEvent(EVENT_SESSIONDIRECTORY_UNAVAILABLE, m_StoreServerName, EVENTLOG_ERROR_TYPE);
            }
            goto HandleError;
        }

        
        hr = RpcMgmtInqServerPrincName(m_hRPCBinding,
                                       RPC_C_AUTHN_GSS_NEGOTIATE,
                                       &szPrincipalName);
        if (hr != RPC_S_OK) {
            ERR((TB,"Recover: Error %d in RpcMgmtIngServerPrincName", hr));
            PostSDJetErrorValueEvent(EVENT_FAIL_RPCMGMTINGSERVERPRINCNAME, hr, EVENTLOG_ERROR_TYPE);
            goto HandleError;
        }

        //hr = RpcBindingSetAuthInfo(m_hRPCBinding, szPrincipalName, 
        //            RPC_C_AUTHN_LEVEL_PKT_PRIVACY, RPC_C_AUTHN_GSS_NEGOTIATE, 0, 0);
        hr = RpcBindingSetAuthInfoEx(m_hRPCBinding,
                                     szPrincipalName,
                                     RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                     RPC_C_AUTHN_GSS_NEGOTIATE,
                                     &CurrentIdentity,
                                     NULL,
                                     &RPCSecurityQos);

        if (hr != RPC_S_OK) {
            ERR((TB,"Recover: Error %d in RpcBindingSetAuthInfo", hr));
            PostSDJetErrorValueEvent(EVENT_FAIL_RPCBINDINGSETAUTHINFOEX, hr, EVENTLOG_ERROR_TYPE);
            goto HandleError;
        }

        // This option enable SD to get fresh machine logon info for tssdjet RPC call
        hr = RpcBindingSetOption(m_hRPCBinding, RPC_C_OPT_DONT_LINGER, 1);
        if (hr != RPC_S_OK) {
            ERR((TB,"Recover: Error %d in RpcBindingSetOption", hr));
            PostSDJetErrorValueEvent(EVENT_FAIL_RPCBIDINGSETOPTION, hr, EVENTLOG_ERROR_TYPE);
            // Per Chenyz's comment, this is OK.
            // goto HandleError;
        }   

        // Session Directory need to know the DNS host name of the TS server
        cchBuff = SDNAMELENGTH;
        GetComputerNameEx(ComputerNamePhysicalDnsFullyQualified, SDComputerName, &cchBuff); 

        // Execute ServerOnline.
        RpcTryExcept {
            hr = TSSDRpcServerOnline(m_hRPCBinding, m_ClusterName, &m_hCI, 
                    m_Flags, SDComputerName, m_LocalServerAddress);
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            m_hCI = NULL;
            RpcException = RpcExceptionCode();
            ERR((TB, "rpcserveronline returns exception: %u", RpcException));
            hr = RpcException;
        }
        RpcEndExcept
            
        // RPC got access denied by SD
        if (hr == ERROR_ACCESS_DENIED) {
            ERR((TB, "rpcserveronline returns access denied error: %u", hr));
            PostSDJetErrorMsgEvent(EVENT_RPC_ACCESS_DENIED, m_StoreServerName, EVENTLOG_ERROR_TYPE);
            goto HandleError;
        }   

        if (SUCCEEDED(hr)) {
            RpcTryExcept {
                hr = TSSDRpcUpdateConfigurationSetting(m_hRPCBinding, &m_hCI, 
                        SDCONFIG_SERVER_ADDRESS, 
                        (DWORD) (wcslen(m_LocalServerAddress) + 1) * 
                        sizeof(WCHAR), (PBYTE) m_LocalServerAddress);
            }
            RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
                m_hCI = NULL;
                RpcException = RpcExceptionCode();
                hr = E_FAIL;
            }
            RpcEndExcept

            if (SUCCEEDED(hr))  {
                PostSDJetErrorMsgEvent(EVENT_JOIN_SESSIONDIRECTORY_SUCESS, m_StoreServerName, EVENTLOG_SUCCESS);
                LookUpSDComputerSID(SDComputerName);
                return 0;
            }
        }
        else {
            ERR((TB, "TSSDRpcServerOnline: 0x%08x", hr));

            PostSDJetErrorValueEvent(EVENT_JOIN_SESSIONDIRECTORY_FAIL, hr, EVENTLOG_ERROR_TYPE);
            ASSERT( SUCCEEDED(hr),(TB, "TSSDRpcServerOnline: failed with 0x%08x", hr));
        }
        
HandleError:
        // If joining SD fails, we need to clear NO_REPOPULATE_SESSION so that 
        // the next join will repopulate sessions
        FailCountBeforeClearFlag++;
        if (FailCountBeforeClearFlag > TSSD_FAILCOUNT_BEFORE_CLEARFLAG) {
            m_Flags &= (~NO_REPOPULATE_SESSION);
        }
        
        if (szPrincipalName != NULL) {
            RpcStringFree(&szPrincipalName);
            szPrincipalName = NULL;
        }
        if (pBindingString != NULL) {
            RpcStringFree(&pBindingString);
            pBindingString = NULL;
        }

        err = WaitForSingleObject(m_hTerminateRecovery, m_RecoveryTimeout);
        if (err != WAIT_TIMEOUT) {
            // It was not a timeout, it better be our terminate recovery event.
            ASSERT((err == WAIT_OBJECT_0),(TB, "ReestSessDirConn: Unexpected "
                    "value returned from wait"));

            // If it was not our event, we want to keep going through
            // this loop so this thread does not terminate.
            if (err == WAIT_OBJECT_0)
                return 1;
        }
    }
ExitFunc:
    if (pBindingString != NULL) {
        RpcStringFree(&pBindingString);
        pBindingString = NULL;
    }
    return 1;
}

/****************************************************************************/
// CTSSessionDirectory::PingSD
//
// This function is called to see if Session Directory is accessible or not
//
// Arguments: pszServerName -- Session Directory server name
//
// Return value: DWORD ERROR_SUCCESS if SD is accessible, otherwise return error code
/****************************************************************************/

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::PingSD(PWCHAR pszServerName)
{
    DWORD hr = ERROR_SUCCESS;
    RPC_BINDING_HANDLE hRPCBinding = NULL;
    WCHAR *szPrincipalName = NULL;
    RPC_SECURITY_QOS RPCSecurityQos;
    SEC_WINNT_AUTH_IDENTITY_EX CurrentIdentity;
    WCHAR CurrentUserName[SDNAMELENGTH+1];
    DWORD cchBuff = 0;     
    WCHAR *pBindingString = NULL;

    RPCSecurityQos.Version = RPC_C_SECURITY_QOS_VERSION;
    RPCSecurityQos.Capabilities = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    RPCSecurityQos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
    RPCSecurityQos.ImpersonationType = RPC_C_IMP_LEVEL_IMPERSONATE;

    CurrentIdentity.Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
    CurrentIdentity.Length = sizeof(SEC_WINNT_AUTH_IDENTITY_EX);
    CurrentIdentity.Password = NULL;
    CurrentIdentity.PasswordLength = 0;
    CurrentIdentity.Domain = NULL;
    CurrentIdentity.DomainLength = 0;
    CurrentIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    CurrentIdentity.PackageList = SECPACKAGELIST;
    CurrentIdentity.PackageListLength = (unsigned long)wcslen(SECPACKAGELIST);

    // we need one for NULL and one for wcscat() below.
    cchBuff = sizeof(CurrentUserName) / sizeof(CurrentUserName[0]) - 2;
    if (!GetComputerNameEx(ComputerNamePhysicalNetBIOS, CurrentUserName, &cchBuff)) {
        ERR((TB,"Error %d in GetComputerNameEx\n", GetLastError()));
        goto ExitFunc;
    }
    wcscat(CurrentUserName, L"$");

    CurrentIdentity.User = CurrentUserName;
    CurrentIdentity.UserLength = (unsigned long)wcslen(CurrentUserName);

    // Connect to the Jet RPC server according to the server name provided.
    // We first create an RPC binding handle from a composed binding string.
    hr = RpcStringBindingCompose(/*(WCHAR *)g_RPCUUID,*/
            0,
            (WCHAR *)g_RPCProtocolSequence, 
            pszServerName,
            0,
            NULL, 
            &pBindingString);

    if (hr != RPC_S_OK) {
        ERR((TB,"Error %d in RpcStringBindingCompose\n", hr));
        pBindingString = NULL;
        goto ExitFunc;
    }

    // Generate the RPC binding from the canonical RPC binding string.
    hr = RpcBindingFromStringBinding(pBindingString, &hRPCBinding);
    if (hr != RPC_S_OK) {
        ERR((TB,"Error %d in RpcBindingFromStringBinding\n", hr));
        hRPCBinding = NULL;
        goto ExitFunc;
    }
    
    hr = RpcEpResolveBinding(hRPCBinding, TSSDJetRPC_ClientIfHandle);
    if (hr != RPC_S_OK) {
        ERR((TB, "Error %d in RpcEpResolveBinding", hr));
        goto ExitFunc;
    }

        
    hr = RpcMgmtInqServerPrincName(hRPCBinding,
                                   RPC_C_AUTHN_GSS_NEGOTIATE,
                                   &szPrincipalName);
    if (hr != RPC_S_OK) {
        ERR((TB,"Error %d in RpcMgmtIngServerPrincName", hr));
        goto ExitFunc;
    }

    hr = RpcBindingSetAuthInfoEx(hRPCBinding,
                                 szPrincipalName,
                                 RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
                                 RPC_C_AUTHN_GSS_NEGOTIATE,
                                 &CurrentIdentity,
                                 NULL,
                                 &RPCSecurityQos);

    if (hr != RPC_S_OK) {
        ERR((TB,"Error %d in RpcBindingSetAuthInfo", hr));
        goto ExitFunc;
    }

    // This option enable SD to get fresh machine logon info for tssdjet RPC call
    hr = RpcBindingSetOption(hRPCBinding, RPC_C_OPT_DONT_LINGER, 1);
    if (hr != RPC_S_OK) {
        ERR((TB,"Error %d in RpcBindingSetOption", hr));
        // This error can be ignore
        //goto ExitFunc;
    }   


    // Execute IsSDAccessible.
    RpcTryExcept {
        hr = TSSDRpcPingSD(hRPCBinding);
    }
    RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
        hr = RpcExceptionCode();
        ERR((TB, "TSSDPingSD returns exception: %u", hr));
    }
    RpcEndExcept
            
ExitFunc:
    if (szPrincipalName != NULL) {
        RpcStringFree(&szPrincipalName);
        szPrincipalName = NULL;
    }

    if (pBindingString != NULL) {
        RpcStringFree(&pBindingString);
        pBindingString = NULL;
    }

    if( hRPCBinding != NULL ) {
        RpcBindingFree( &hRPCBinding );
        hRPCBinding = NULL;
    }

    return HRESULT_FROM_WIN32(hr);
}


/****************************************************************************/
// CTSSessionDirectory::Terminate
//
// Helper function called by the destructor and by Update when switching to
// another server.  Frees RPC binding, events, and recovery thread.
/****************************************************************************/
void CTSSessionDirectory::Terminate()
{
    HRESULT rc = S_OK;
    unsigned long RpcException;
    BOOL ConnectionMaybeUp;

    // we are terminating RPC connection to Session Directory
    SetSDConnectionDown();

    // Terminate recovery.
    if (m_hRecoveryThread != NULL) {
        SetEvent(m_hTerminateRecovery);
        WaitForSingleObject((HANDLE) m_hRecoveryThread, INFINITE);
        m_hRecoveryThread = NULL;
    }

    ConnectionMaybeUp = EnterSDRpc();
    if (ConnectionMaybeUp)
        LeaveSDRpc();

    // Wait for current Rpcs to complete (if any), disable new ones.
    DisableSDRpcs();
    // If we think there is a connection, disconnect it.
    if (ConnectionMaybeUp) {
        RpcTryExcept {
            rc = TSSDRpcServerOffline(m_hRPCBinding, &m_hCI);
            m_hCI = NULL;
            if (FAILED(rc)) {
                ERR((TB,"Term: SvrOffline failed, lasterr=0x%X", GetLastError()));
                PostSDJetErrorValueEvent(EVENT_CALL_TSSDRPCSEVEROFFLINE_FAIL, GetLastError(), EVENTLOG_WARNING_TYPE);
            }
        }
        RpcExcept(TSSDRpcExceptionFilter(RpcExceptionCode())) {
            RpcException = RpcExceptionCode();
            ERR((TB,"Term: RPC Exception %d\n", RpcException));
            PostSDJetErrorValueEvent(EVENT_CALL_TSSDRPCSEVEROFFLINE_FAIL, RpcException, EVENTLOG_WARNING_TYPE);
            rc = E_FAIL;
        }
        RpcEndExcept
    }

    // Clean up.
    if (m_hRPCBinding != NULL) {
        RpcBindingFree(&m_hRPCBinding);
        m_hRPCBinding = NULL;
    }

    if (m_hSDServerDown != NULL) {
        CloseHandle(m_hSDServerDown);
        m_hSDServerDown = NULL;
    }
    
    if (m_hTerminateRecovery != NULL) {
        CloseHandle(m_hTerminateRecovery);
        m_hTerminateRecovery = NULL;
    }

    if (m_hIPChange != NULL) {
        CloseHandle(m_hIPChange);
        m_hIPChange = NULL;
    }

    #if 0
    // wrong assert, timing issue, reader might just happen to increment counter
    // TODO - fix this so we can trap problem.
    if (m_sr.Valid == TRUE) {
        
        // We clean up only in the destructor, because we may initialize again.
        // On check builds verify that no one is currently accessing.

        ASSERT((VerifyNoSharedAccess(&m_sr)), (TB, "Terminate: Shared readers"
                " exist!"));
    }
    #endif

}


/****************************************************************************/
// CTSSessionDirectory::GetLoadBalanceInfo
//
// Based on the server address, generate load balance info to send to the client
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::GetLoadBalanceInfo(
        LPWSTR ServerAddress, 
        BSTR* LBInfo)        
{
    HRESULT hr = S_OK;
    
    // This is for test only
    //WCHAR lbInfo[MAX_PATH];
    //wcscpy(lbInfo, L"load balance info");

    *LBInfo = NULL;
    
    TRC2((TB,"GetLoadBalanceInfo"));

    if (ServerAddress) {
        //
        // "Cookie: msts=4294967295.65535.0000" + CR + LF + NULL, on 8-byte
        // boundary is 40 bytes.
        //
        // The format of the cookie for F5 is, for an IP of 1.2.3.4
        // using port 3389, Cookie: msts=67305985.15629.0000 + CR + LF + NULL.
        //
        #define TEMPLATE_STRING_LENGTH 40
        #define SERVER_ADDRESS_LENGTH 64
        
        char CookieTemplate[TEMPLATE_STRING_LENGTH];
        char AnsiServerAddress[SERVER_ADDRESS_LENGTH];
        
        unsigned long NumericalServerAddr = 0;
        int retval;

        // Compute integer for the server address.
        // First, get ServerAddress as an ANSI string.
        retval = WideCharToMultiByte(CP_ACP, 0, ServerAddress, -1, 
                AnsiServerAddress, SERVER_ADDRESS_LENGTH, NULL, NULL);

        if (retval == 0) {
            TRC2((TB, "GetLoadBalanceInfo WideCharToMB failed %d", 
                    GetLastError()));
            return E_INVALIDARG;
        }

        // Now, use inet_addr to turn into an unsigned long.
        NumericalServerAddr = inet_addr(AnsiServerAddress);

        if (NumericalServerAddr == INADDR_NONE) {
            TRC2((TB, "GetLoadBalanceInfo inet_addr failed"));
            return E_INVALIDARG;
        }

        // Compute the total cookie string.  0x3d0d is 3389 in correct byte
        // order.  We need to change this to whatever the port number has been
        // configured to.
        sprintf(CookieTemplate, "Cookie: msts=%u.%u.0000\r\n",
                NumericalServerAddr, 0x3d0d);

        // Generate returned BSTR.
        *LBInfo = SysAllocStringByteLen((LPCSTR)CookieTemplate, 
                (UINT) strlen(CookieTemplate));
        
        if (*LBInfo) {
            TRC2((TB,"GetLoadBalanceInfo: okay"));
            hr = S_OK;
        }
        else {
            TRC2((TB,"GetLoadBalanceInfo: failed"));
            hr = E_OUTOFMEMORY;
        }
    }
    else {
        TRC2((TB,"GetLoadBalanceInfo: failed"));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// IsServerNameValid
//
// This function tries to ping the server name to determine if its a valid 
// entry
//
// Return value: FALSE if we cannot ping.
// event.
/****************************************************************************/
BOOL IsServerNameValid(
    wchar_t * pwszName ,
    PDWORD pdwStatus
    )
{
    HCURSOR hCursor = NULL;
    long inaddr;
    char szAnsiServerName[256];
    struct hostent *hostp = NULL;
    BOOL bRet = TRUE;

    if (pwszName == NULL || pwszName[0] == '\0' || pdwStatus == NULL )
    {
        bRet = FALSE;
    }   
    else
    {
        *pdwStatus = ERROR_SUCCESS;

        hCursor = SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT)));
        // some winsock apis does accept wides.
        WideCharToMultiByte(CP_ACP,
            0,
            pwszName,
            -1,
            szAnsiServerName, 
            sizeof(szAnsiServerName),
            NULL, 
            NULL);
        
        //   
        // check ip format return true do a dns lookup.
        //

        if( ( inaddr = inet_addr( szAnsiServerName ) ) == INADDR_NONE )
        {
            hostp = gethostbyname( szAnsiServerName );

            if( hostp == NULL )
            {
                // Neither dotted, not name.
                bRet = FALSE;
            }
        }
        if( bRet )
        {
            bRet = _WinStationOpenSessionDirectory( SERVERNAME_CURRENT , pwszName );
            *pdwStatus = GetLastError();
        }


        SetCursor( hCursor );

    }

    return bRet;
}



BOOL OnHelp(HWND hwnd, LPHELPINFO lphi)
{
    UNREFERENCED_PARAMETER(hwnd);

    TCHAR tchHelpFile[MAX_PATH];

    //
    // For the information to winhelp api
    //

    if (IsBadReadPtr(lphi, sizeof(HELPINFO)))
    {
        return FALSE;
    }

    if (lphi->iCtrlId <= -1)
    {
        return FALSE;
    }

    LoadString(g_hInstance, IDS_HELPFILE, tchHelpFile, 
                sizeof (tchHelpFile) / sizeof(TCHAR));

    ULONG_PTR rgdw[2];

    rgdw[0] = (ULONG_PTR)lphi->iCtrlId;

    rgdw[1] = (ULONG_PTR)lphi->dwContextId;

    WinHelp((HWND) lphi->hItemHandle, tchHelpFile, HELP_WM_HELP, 
            (ULONG_PTR) &rgdw);
    
    return TRUE;
}

/****************************************************************************/
// Custom UI msg handler dealt with here
/****************************************************************************/
INT_PTR CALLBACK CustomUIDlg(HWND hwnd, UINT umsg, WPARAM wp, LPARAM lp)
{
    static BOOL s_fServerNameChanged;
    static BOOL s_fClusterNameChanged;
    static BOOL s_fRedirectIPChanged;
    static BOOL s_fPreviousButtonState;
    static BOOL s_fPreviousExposeIPState;
    
    CTSSessionDirectory *pCTssd;
    
    POLICY_TS_MACHINE gpolicy;
    
    switch(umsg)
    {
    case WM_INITDIALOG:
        {
            BOOL bEnable = FALSE;
            BOOL bExposeIP = FALSE;
            
            pCTssd = (CTSSessionDirectory *)lp;
            
            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR)pCTssd);
            
            SendMessage(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME),
                EM_LIMITTEXT,
                (WPARAM)64,
                0);
            SendMessage(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME),
                EM_LIMITTEXT,
                (WPARAM)64,
                0);
            SendMessage(GetDlgItem(hwnd, IDC_EDIT_ACCOUNTNAME),
                EM_LIMITTEXT,
                (WPARAM)64,
                0);
            SendMessage(GetDlgItem(hwnd, IDC_EDIT_PASSWORD),
                EM_LIMITTEXT,
                (WPARAM)64,
                0);
            
            HICON hIcon;
            
            hIcon = (HICON)LoadImage(
                g_hInstance,
                MAKEINTRESOURCE(IDI_SMALLWARN),
                IMAGE_ICON,
                0,
                0,
                0);
            // TRC1((TB, "CustomUIDlg - LoadImage returned 0x%p",hIcon));
            SendMessage(
                GetDlgItem(hwnd, IDC_WARNING_ICON),
                STM_SETICON,
                (WPARAM)hIcon,
                (LPARAM)0
               );
            
            LONG lRet;
            HKEY hKey;
            DWORD cbData = 256;
            TCHAR szString[256];    
            
            RegGetMachinePolicy(&gpolicy);        
            
            lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                REG_TS_CLUSTERSETTINGS,
                0,
                KEY_READ | KEY_WRITE, 
                &hKey);
            if (lRet == ERROR_SUCCESS)
            {               
                lRet = RegQueryValueEx(hKey,
                    REG_TS_CLUSTER_STORESERVERNAME,
                    NULL, 
                    NULL,
                    (LPBYTE)szString, 
                    &cbData);
                if (lRet == ERROR_SUCCESS)
                {
                    SetWindowText(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), 
                            szString);
                }
                
                cbData = 256;
                
                lRet = RegQueryValueEx(hKey,
                    REG_TS_CLUSTER_CLUSTERNAME,
                    NULL,
                    NULL,
                    (LPBYTE)szString,
                    &cbData);           
                if (lRet == ERROR_SUCCESS)
                {
                    SetWindowText(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), 
                            szString);
                }
                RegCloseKey(hKey);
            }
            else
            {
                if (pCTssd != NULL)
                {
                    pCTssd->ErrorMessage(hwnd, IDS_ERROR_TEXT, (DWORD)lRet);
                }
                EndDialog(hwnd, lRet);                
            }        
            
            
            if (gpolicy.fPolicySessionDirectoryActive)
            {
                bEnable = gpolicy.SessionDirectoryActive;
                EnableWindow(GetDlgItem(hwnd, IDC_CHECK_ENABLE), FALSE);
            }
            else
            {
                if (pCTssd != NULL)
                    bEnable = pCTssd->IsSessionDirectoryEnabled();
            }
            
            s_fPreviousButtonState = bEnable;
            CheckDlgButton(hwnd, IDC_CHECK_ENABLE, bEnable);

            if (gpolicy.fPolicySessionDirectoryLocation)
            {                    
                SetWindowText(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), 
                        gpolicy.SessionDirectoryLocation);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_STORENAME), FALSE);
            }                
            else
            {
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_STORENAME), bEnable);
            }
            
            if (gpolicy.fPolicySessionDirectoryClusterName != 0)
            {                    
                SetWindowText(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), 
                        gpolicy.SessionDirectoryClusterName);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), FALSE);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME),FALSE);
            }
            else
            {
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME),bEnable);
            }

            if (gpolicy.fPolicySessionDirectoryExposeServerIP != 0)
            {
                bExposeIP = gpolicy.SessionDirectoryExposeServerIP;
                CheckDlgButton(hwnd, IDC_CHECK_EXPOSEIP, bExposeIP);
                EnableWindow(GetDlgItem(hwnd, IDC_CHECK_EXPOSEIP), FALSE);
            }
            else
            {
                if (pCTssd != NULL)
                {
                    bExposeIP = 
                            pCTssd->IsSessionDirectoryExposeServerIPEnabled();
                }
                CheckDlgButton(hwnd, IDC_CHECK_EXPOSEIP, bExposeIP ? 
                        BST_CHECKED : BST_UNCHECKED);
                EnableWindow(GetDlgItem(hwnd, IDC_CHECK_EXPOSEIP), bEnable);                    
            }

            EnableWindow(GetDlgItem(hwnd, IDC_IPCOMBO), bEnable);
            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_IPCOMBO), bEnable);              

            // Get handle to Combo Box 
            HWND hIPComboBox;
            hIPComboBox = GetDlgItem(hwnd, IDC_IPCOMBO); 
            
            // Get list of Adapters and IP address and populate the combo box
            // If it fails to populate, just fall through and continue
            QueryNetworkAdapterAndIPs(hIPComboBox);

            s_fPreviousExposeIPState = bExposeIP;

            s_fServerNameChanged = FALSE;
            s_fClusterNameChanged = FALSE;
            s_fRedirectIPChanged = FALSE;
        }
        break;
    
        case WM_HELP:
            OnHelp(hwnd, (LPHELPINFO)lp);
            break;
        
        case WM_COMMAND:
            if (LOWORD(wp) == IDCANCEL)
            {                
                EndDialog(hwnd, 0);
            }
            else if (LOWORD(wp) == IDOK)
            {
                BOOL bEnabled;
                BOOL bExposeIP;
                DWORD dwRetStatus = 0;
                
                pCTssd = (CTSSessionDirectory *) GetWindowLongPtr(hwnd, 
                        DWLP_USER);
                
                bEnabled = (IsDlgButtonChecked(hwnd, IDC_CHECK_ENABLE) == 
                        BST_CHECKED);
                bExposeIP = (IsDlgButtonChecked(hwnd, IDC_CHECK_EXPOSEIP) ==
                        BST_CHECKED);
                
                if (bEnabled != s_fPreviousButtonState)
                {
                    DWORD dwStatus;
                    
                    dwStatus = pCTssd->SetSessionDirectoryEnabledState(
                            bEnabled);
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        return 0;
                    }
                    dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                }
                if ((bExposeIP != s_fPreviousExposeIPState) && bEnabled)
                {
                    DWORD dwStatus;

                    dwStatus = pCTssd->SetSessionDirectoryExposeIPState(
                            bExposeIP);
                    if (dwStatus != ERROR_SUCCESS)
                    {
                        return 0;
                    }
                    dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                }    
                if (s_fServerNameChanged || s_fClusterNameChanged || s_fRedirectIPChanged)
                {
                    HKEY hKey;
                    TCHAR szTrim[] = TEXT( " " );

                    LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        REG_TS_CLUSTERSETTINGS,
                        0,
                        KEY_READ | KEY_WRITE, 
                        &hKey);
                    
                    if (lRet == ERROR_SUCCESS)
                    {
                        TCHAR szName[64];
                        
                        if (s_fServerNameChanged)
                        {
                            BOOL fRet = FALSE;

                            GetWindowText( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) ,
                                szName ,
                                sizeof( szName ) / sizeof( TCHAR ) );

                            //
                            // remove trailing spaces
                            //

                            StrTrim( szName , szTrim );

                            if( lstrlen( szName ) != 0 )
                            {
                                fRet = IsServerNameValid( szName , &dwRetStatus );

                                if( !fRet || dwRetStatus != ERROR_SUCCESS )
                                {
                                    int nRet;
                                    TCHAR szError[1024];
                                    TCHAR szTitle[80];
                                    
                                    TRC1((TB,"Server name was not valid"));
                                    
                                    if( dwRetStatus != ERROR_SUCCESS )
                                    {
                                        LoadString( g_hInstance ,
                                            IDS_ERROR_SDVERIFY,
                                            szError,
                                            sizeof(szError)/sizeof(TCHAR));
                                    }
                                    else
                                    {
                                        LoadString(g_hInstance,
                                            IDS_ERROR_SDIRLOC,
                                            szError,
                                            sizeof(szError)/sizeof(TCHAR));
                                    }
                                    
                                    LoadString(g_hInstance,
                                        IDS_ERROR_TITLE,
                                        szTitle,
                                        sizeof(szTitle)/sizeof(TCHAR));
                                    
                                    nRet = MessageBox(hwnd, szError, szTitle, 
                                            MB_YESNO | MB_ICONWARNING);
                                    if (nRet == IDNO)
                                    {
                                        SetFocus(GetDlgItem(hwnd, 
                                                IDC_EDIT_SERVERNAME));
                                        
                                        SendMessage( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) ,
                                            EM_SETSEL ,
                                            ( WPARAM )0,
                                            ( LPARAM )-1 );

                                        bEnabled = s_fPreviousButtonState;
                                        pCTssd->SetSessionDirectoryEnabledState(bEnabled);
                                        return 0;
                                    }
                                }                                

                            }
                            else {
                                // Blank name not allowed if session directory
                                // is enabled.  This code will not be run if the
                                // checkbox is disabled because when it is
                                // disabled the static flags get set to 
                                // disabled.
                                TCHAR szError[256];
                                TCHAR szTitle[80];
                    
                                LoadString(g_hInstance, IDS_ERROR_TITLE,
                                        szTitle, sizeof(szTitle) / 
                                        sizeof(TCHAR));
                                LoadString(g_hInstance, IDS_ERROR_SDIREMPTY,
                                        szError, sizeof(szError) / 
                                        sizeof(TCHAR));

                                MessageBox(hwnd, szError, szTitle, 
                                        MB_OK | MB_ICONWARNING);

                                SetFocus(GetDlgItem(hwnd, 
                                        IDC_EDIT_SERVERNAME));

                                bEnabled = s_fPreviousButtonState;
                                pCTssd->SetSessionDirectoryEnabledState(bEnabled);
                                return 0;
                            }
                            RegSetValueEx(hKey,
                                REG_TS_CLUSTER_STORESERVERNAME,
                                0,
                                REG_SZ,
                                (CONST LPBYTE) szName,
                                sizeof(szName) - sizeof(TCHAR));
                        }
                        if (s_fClusterNameChanged)
                        {
                            
                            GetWindowText(GetDlgItem(hwnd, 
                                IDC_EDIT_CLUSTERNAME), szName, 
                                sizeof(szName) / sizeof(TCHAR));

                            StrTrim( szName , szTrim );

                            RegSetValueEx(hKey,
                                REG_TS_CLUSTER_CLUSTERNAME,
                                0,
                                REG_SZ,
                                (CONST LPBYTE) szName,
                                sizeof(szName) - sizeof(TCHAR));
                        }

                        if (s_fRedirectIPChanged)
                        {
                            HWND    hComboBox;
                            LRESULT lRes;
                            LRESULT lLen;
                            LPWSTR  pwszSel = NULL;
                            size_t  dwSelPos;

                            // get handle to Combo Box 
                            hComboBox = GetDlgItem(hwnd, IDC_IPCOMBO); 
                            
                            // get current selection position
                            lRes = SendMessage(hComboBox,
                                               CB_GETCURSEL, 
                                               0, 
                                               0);
                            
                            // get length of string stored at current selection
                            lLen = SendMessage(hComboBox, 
                                               CB_GETLBTEXTLEN, 
                                               (WPARAM)lRes, 
                                               0);
                            if (lLen > 0)
                            {                                
                                // allocate room for selection string
                                pwszSel = (LPWSTR)GlobalAlloc(GPTR, 
                                                  (lLen + 1) * sizeof(WCHAR));
                                if (pwszSel != NULL)
                                {
                                    SendMessage(hComboBox, 
                                                CB_GETLBTEXT, 
                                                (WPARAM)lRes, 
                                                (LPARAM)pwszSel);

                                    // we only want to store the IP address, 
                                    // however the string is returned in the
                                    // form "IP Address (adapter)", so we'll 
									// extract IP first
                                    
                                    // traverse the string until we find the
									// first space

                                    dwSelPos = 0;
								   
                                    // walk the string until we find the first
									// space or we reach the end
                                    while ( ( pwszSel[dwSelPos] != L' ' ) && 
										    ( dwSelPos < wcslen(pwszSel) ) )
                                    {
                                        dwSelPos++;
                                    }
                                   
									// for a match we know that there must be a
									// space followed by an open bracket lets
									// verify
                                    if ( (dwSelPos < (wcslen(pwszSel) - 1)) && 
										 (pwszSel[dwSelPos + 1] == L'(') )										
                                    {
										// set this char to NULL
										pwszSel[dwSelPos] = L'\0';
                                 
                                        // save new selection to registry
                                        RegSetValueEx(hKey,
                                             REG_TS_CLUSTER_REDIRECTIONIP,
                                             0,
                                             REG_SZ,
                                             (CONST LPBYTE) pwszSel,
                                             (DWORD)(wcslen(pwszSel) * 
                                                sizeof(WCHAR)));  
                                    }
                                    else
                                    {
                                        // store blank string
                                        RegSetValueEx(hKey,
                                             REG_TS_CLUSTER_REDIRECTIONIP,
                                             0,
                                             REG_SZ,
                                             (CONST LPBYTE) NULL,
                                             0);  
                                    }

                                    GlobalFree(pwszSel);                 
                                }
                            }
                        }

                        RegCloseKey(hKey);
                    }
                    else
                    {
                        pCTssd->ErrorMessage(hwnd, IDS_ERROR_TEXT2, 
                                (DWORD) lRet);
                        return 0;
                    }
                    dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                }

                EndDialog(hwnd, dwRetStatus);
            }
            else
            {
                switch(HIWORD(wp))
                {            
                case EN_CHANGE:
                    if (LOWORD(wp) == IDC_EDIT_SERVERNAME)
                    {
                        s_fServerNameChanged = TRUE;
                    }
                    else if (LOWORD(wp) == IDC_EDIT_CLUSTERNAME)
                    {
                        s_fClusterNameChanged = TRUE;
                    }
                    break;
                case CBN_SELCHANGE:
                    if (LOWORD(wp) == IDC_IPCOMBO)
                    {
                        s_fRedirectIPChanged = TRUE;
                    }
                    break;
                case BN_CLICKED:
                    if (LOWORD(wp) == IDC_CHECK_ENABLE)
                    {
                        BOOL bEnable;
                        
                        bEnable = (IsDlgButtonChecked(hwnd, IDC_CHECK_ENABLE) ==
                                BST_CHECKED ? TRUE : FALSE);
                        // set flags 
                        s_fServerNameChanged = bEnable;
                        s_fClusterNameChanged = bEnable;
                        s_fRedirectIPChanged = bEnable;
                        
                        RegGetMachinePolicy(&gpolicy);        
	
                        if (gpolicy.fPolicySessionDirectoryLocation)
                        {                    
                            EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), FALSE);
                            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_STORENAME), FALSE);
                        }                
                        else
                        {
                            EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), bEnable);
                            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_STORENAME), bEnable);
                        }
            
                        if (gpolicy.fPolicySessionDirectoryClusterName)
                        {                    
                            EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), FALSE);
                            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME),FALSE);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), bEnable);
                            EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME),bEnable);
                        }

                        if (gpolicy.fPolicySessionDirectoryExposeServerIP != 0)
                        {
                            EnableWindow(GetDlgItem(hwnd, IDC_CHECK_EXPOSEIP), FALSE);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hwnd, IDC_CHECK_EXPOSEIP), bEnable);
                        }                        

                        EnableWindow(GetDlgItem(hwnd, IDC_IPCOMBO), bEnable);
                        EnableWindow(GetDlgItem(hwnd, IDC_STATIC_IPCOMBO), bEnable);
                    }
                    break;
                }
            }   
            break;
    }
    return 0;
}

// When SD is restared, it will call this to ask for rejoining
DWORD TSSDRPCRejoinSD(handle_t Binding, DWORD flag)
{
    Binding;

    g_updatesd(flag);  // This call is from SD computer, rejoin it

    return RPC_S_OK;
}


/****************************************************************************/
// CheckRPCClientProtoSeq
//
// Check if the client uses the expected RPC protocol sequence or not
//
//  Parameters:
//      ClientBinding: The client binding handle
//      SeqExpected: Protocol sequence expected
//      
//  Return:
//      True on getting the expected seq, False otherwise
/****************************************************************************/
BOOL CheckRPCClientProtoSeq(void *ClientBinding, WCHAR *SeqExpected) {
    BOOL fAllowProtocol = FALSE;
    WCHAR *pBinding = NULL;
    WCHAR *pProtSeq = NULL;

    if (RpcBindingToStringBinding(ClientBinding,&pBinding) == RPC_S_OK) {

        if (RpcStringBindingParse(pBinding,
                                  NULL,
                                  &pProtSeq,
                                  NULL,
                                  NULL,
                                  NULL) == RPC_S_OK) {
			
            // Check that the client request was made using expected protoal seq.
            if (lstrcmpi(pProtSeq, SeqExpected) == 0)
                fAllowProtocol = TRUE;

            if (pProtSeq)	
                RpcStringFree(&pProtSeq); 
        }

        if (pBinding)	
            RpcStringFree(&pBinding);
    }
    return fAllowProtocol;
}


/****************************************************************************/
// JetRpcAccessCheck
//
// Check if this RPC caller from SD havs access right or not
/****************************************************************************/
RPC_STATUS RPC_ENTRY JetRpcAccessCheck(RPC_IF_HANDLE idIF, void *Binding)
{
    RPC_STATUS rpcStatus, rc;
    HANDLE hClientToken = NULL;
    DWORD Error;
    BOOL AccessStatus = FALSE;
    RPC_AUTHZ_HANDLE hPrivs;
    DWORD dwAuthn;

    idIF;

    if (NULL == g_pSDSid) {
        goto HandleError;
    }

    // Check if the client uses the protocol sequence we expect
    if (!CheckRPCClientProtoSeq(Binding, L"ncacn_ip_tcp")) {
        ERR((TB, "In JetRpcAccessCheck: Client doesn't use the tcpip protocol sequence\n"));
        goto HandleError;
    }

    // Check what security level the client uses
    rpcStatus = RpcBindingInqAuthClient(Binding,
                                        &hPrivs,
                                        NULL,
                                        &dwAuthn,
                                        NULL,
                                        NULL);
    if (rpcStatus != RPC_S_OK) {
        ERR((TB, "In JetRpcAccessCheck: RpcBindingIngAuthClient fails with %u\n", rpcStatus));
        goto HandleError;
    }
    // We request at least packet-level authentication
    if (dwAuthn < RPC_C_AUTHN_LEVEL_PKT) {
        ERR((TB, "In JetRpcAccessCheck: Attemp by client to use weak authentication\n"));
        goto HandleError;
    }
    
    // Check the access right of this rpc call
    rpcStatus = RpcImpersonateClient(Binding);   
    if (RPC_S_OK != rpcStatus) {
        ERR((TB, "In JetRpcAccessCheck: RpcImpersonateClient fail with %u\n", rpcStatus));
        goto HandleError;
    }
    // get our impersonated token
    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hClientToken)) {
        Error = GetLastError();
        ERR((TB, "In JetRpcAccessCheck: OpenThreadToken Error %u\n", Error));
        RpcRevertToSelf();
        goto HandleError;
    }
    RpcRevertToSelf();
    
    if (!CheckTokenMembership(hClientToken,
                              g_pSDSid,
                              &AccessStatus)) {
        AccessStatus = FALSE;
        Error = GetLastError();
        ERR((TB, "In JetRpcAccessCheck: CheckTokenMembership fails with %u\n", Error));
    }
    
HandleError:
    if (AccessStatus) {
        rc = RPC_S_OK;
    }
    else {
        rc = ERROR_ACCESS_DENIED;
    }

    if (hClientToken != NULL) {
        CloseHandle(hClientToken);
    }
    
    return rc;
}



//*****************************************************************************
// Method: 
//          GetSDIPList
// Synopsis:
//          Get a list of IP addresses that can be sued for Session Directory 
//          redirection. Omit IP address if it is the NLB IP address.
// Params:
//          Out: pwszAddressList -- Array of WCHAR to receive IP address list
//          In/Out: dwNumAddr -- In: Size of pwszAddressList array.
//                               Out: Number of IPs returned
//          In: bIPAddress -- True: Get IPs. False: Get IPs + NIC names 
// Return:
//          HRESULT, S_OK is successful or other if failed
//*****************************************************************************
HRESULT GetSDIPList(WCHAR **pwszAddressList, DWORD *pdwNumAddr, BOOL bIPAddress)
{
    DWORD            dwCount                  = 0;
    size_t            cbSize                   = 0;
    HRESULT          hr                       = S_OK;
    DWORD            dwResult;
    PIP_ADAPTER_INFO pAdapterInfo             = NULL;
    PIP_ADAPTER_INFO pAdapt;
    PIP_ADDR_STRING  pAddrStr;
    ULONG            ulAdapterInfoSize        = 0;
    WCHAR            wszAddress[MAX_PATH]     = L"";
    WCHAR            wszAdapterName[MAX_PATH] = L""; 
    LPWSTR           pwszNLBipAddress         = NULL;
    LPWSTR           pwszAdapterIP            = NULL;
    LPWSTR           pwszMatch;
    size_t           dwAdapterIPLength;
    LPWSTR           pwszAdapterGUID          = NULL;
    LPTSTR           astrLanaGUIDList[256]    = { 0 }; // This will hold 256 adapter cards
    DWORD            dwLanaGUIDCount          = 0;
    DWORD            i;
    BOOL             bAdapterFound            = FALSE;
    BOOL             bAllAdaptersSet          = FALSE;

    // get the NLB IP address if it exists
    hr = GetNLBIP(&pwszNLBipAddress);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // Get list of adapters used in ALL Winstations
    hr = BuildLanaGUIDList(astrLanaGUIDList, &dwLanaGUIDCount);
    if (FAILED(hr))
    {
        ERR((TB, "BuildLanaGUIDList fails with 0x%x", hr));
        goto Cleanup;
    }

    // if a winstation has "All Network Adapters set...", then we will display
    // all the adapters
    if (hr == S_ALL_ADAPTERS_SET)
    {
        bAllAdaptersSet = TRUE;
    }

    // enumerate all of the adapters

    // get size of buffer required, to do this we pass in an empty
    // buffer length and we expect ERROR_BUFFER_OVERFLOW with a returned
    // required buffer size
    dwResult = GetAdaptersInfo(NULL, &ulAdapterInfoSize);
    if (dwResult != ERROR_BUFFER_OVERFLOW)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // allocate memory for the linked list of adapter info's
    pAdapterInfo = (PIP_ADAPTER_INFO)GlobalAlloc(GPTR, ulAdapterInfoSize);
    if (pAdapterInfo == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // get the Adapter list
    // note: PIP_ADAPTER_INFO is a linked list of adapters
    dwResult = GetAdaptersInfo(pAdapterInfo, &ulAdapterInfoSize);
    if (dwResult != ERROR_SUCCESS)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // enumerate the list of adapters and their IP Address List
    pAdapt = pAdapterInfo;

    while(pAdapt)
    {
        // get the Adapter Name string
        MultiByteToWideChar(GetACP(), 
                            0,
                            pAdapt->Description,
                            -1,
                            wszAdapterName,
                            MAX_PATH);

        // if a winstation is configured with "all adapters set..." then
        // we can skip checking if each adapter is used in a winstation or not
        if (!bAllAdaptersSet)
        {
            // get the Adapter Service Name GUID
            hr = GetAdapterServiceName(wszAdapterName, &pwszAdapterGUID);
            if (SUCCEEDED(hr) && (pwszAdapterGUID != NULL))
            {
                // check if this adapter is used in a winstation
                // we've already got a list of GUIDs used so compare to that
                for (i=0; i < dwLanaGUIDCount; i++)
                {
                    bAdapterFound = FALSE;

                    if (!wcscmp(pwszAdapterGUID, astrLanaGUIDList[i]))
                    { 
                        bAdapterFound = TRUE;
                        break;
                    }
                }
            }

            // free the memory GetADapterServiceName allocated
            if (pwszAdapterGUID != NULL)
            {
                GlobalFree(pwszAdapterGUID);
                pwszAdapterGUID = NULL;
            }

            // if the adapter was not found above that means it is not configured
            // to a winstation so we don't want to add this adapter here
            if (!bAdapterFound)
            {
                pAdapt = pAdapt->Next;
                continue;
            }
        }

        // enumerate the list of IP Addresses associated with the adapter
        pAddrStr = &(pAdapt->IpAddressList);
        
        while(pAddrStr)
        {
             // get the IP Address string
            MultiByteToWideChar(GetACP(), 
                                0,
                                pAddrStr->IpAddress.String,
                                -1,
                                wszAddress,
                                MAX_PATH);

            // check if the Adapter IP address is configured.  If not it will
            // be "0.0.0.0" and don't include in list
            if (!wcscmp(wszAddress, UNCONFIGURED_IP_ADDRESS))
            {
                pAddrStr = pAddrStr->Next; 
                continue;
            }

            // concatenate the IP Address with the adapter name in the form
            // "IP Address (Adapter)"
            
            // calculate string length first and allocate heap memory
            // add 4 extra chars for space, 2 brackets and terminating NULL
            dwAdapterIPLength = wcslen(wszAdapterName) + wcslen(wszAddress) + 4;
            pwszAdapterIP = (LPWSTR)GlobalAlloc(GPTR, dwAdapterIPLength * 
                                                        sizeof(WCHAR));
            if (pwszAdapterIP == NULL) {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            wcscpy(pwszAdapterIP, wszAddress);
            wcscat(pwszAdapterIP, L" (");
            wcscat(pwszAdapterIP, wszAdapterName);
            wcscat(pwszAdapterIP, L")");
            pwszAdapterIP[dwAdapterIPLength - 1] = L'\0';

            if (bIPAddress) {
                cbSize = (wcslen(wszAddress) + 1) * sizeof(WCHAR);
                pwszAddressList[dwCount] = (LPWSTR)LocalAlloc(LMEM_FIXED, cbSize);
            }
             else {
                cbSize = (wcslen(pwszAdapterIP) + 1) * sizeof(WCHAR);
                pwszAddressList[dwCount] = (LPWSTR)LocalAlloc(LMEM_FIXED, cbSize);
            }
            if (pwszAddressList[dwCount] == NULL) {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }


            // add to list only if the IP address isn't the NLB CLUSER IP
            if (pwszNLBipAddress != NULL)
            {
                // check if IP address is NBL Cluster IP, we'll check for a match
                // if so we will omit from list
                pwszMatch = wcsstr(pwszNLBipAddress, wszAddress);
                if (pwszMatch == NULL)
                {
                    if (bIPAddress) {
                        // Get IP address only
                        wcsncpy(pwszAddressList[dwCount], wszAddress, cbSize / sizeof(WCHAR));
                    }
                    else {
                        // Get IP address and adapter name
                        wcsncpy(pwszAddressList[dwCount], pwszAdapterIP, cbSize / sizeof(WCHAR));
                    }
                    dwCount++;
                    if (dwCount == *pdwNumAddr) {
                        hr = S_OK;
                        goto Cleanup;
                    }
                }
            }
            else
            {
                if (bIPAddress) {
                    // Get IP address only
                    wcsncpy(pwszAddressList[dwCount], wszAddress, cbSize / sizeof(WCHAR));
                }
                else {
                    // Get IP address and adapter name
                    wcsncpy(pwszAddressList[dwCount], pwszAdapterIP, cbSize / sizeof(WCHAR));
                }
                dwCount++;
                if (dwCount == *pdwNumAddr) {
                    hr = S_OK;
                    goto Cleanup;
                }
            }

            pAddrStr = pAddrStr->Next;
        }

        pAdapt = pAdapt->Next;
    }
    *pdwNumAddr = dwCount;
    hr = S_OK;

Cleanup:
    if (pAdapterInfo)
        GlobalFree(pAdapterInfo);

    if (pwszAdapterIP)
        GlobalFree(pwszAdapterIP);

    if (pwszNLBipAddress)
        GlobalFree(pwszNLBipAddress);

    for (i=0; i < dwLanaGUIDCount; i++)
    {
        if (astrLanaGUIDList[i])
        {
            GlobalFree(astrLanaGUIDList[i]);
        }
    }
    return hr;
}



//*****************************************************************************
// Method: 
//          QueryNetworkAdapterAndIPs
// Synopsis:
//          Query the Adapters that are installed on the system and their 
//          correspoding IP addresses and populate the combo box with the 
//          selections.  Omit IP address if it is the NLB IP address.
// Params:
//          In: hComboBox, handle to combo box to receive Adapter/IP list
// Return:
//          HRESULT, S_OK is successful or other if failed
//*****************************************************************************
HRESULT 
QueryNetworkAdapterAndIPs(HWND hComboBox)
{
    HRESULT          hr                       = S_OK;
    DWORD            dwResult;
    LPWSTR           pwszMatch;
    DWORD            cbData                   = MAX_PATH;
    WCHAR            wszSetIP[MAX_PATH]       = L"";
    HKEY             hKey;
    int              nNumIPsInComboBox        = 0;
    LPWSTR           pwszSel                  = NULL;
    size_t           dwLen;    
    int              nPos;
    DWORD            i;
    WCHAR *pwszAddressList[SD_NUM_IP_ADDRESS];
    DWORD dwNumAddr = SD_NUM_IP_ADDRESS;


    if (hComboBox == NULL)
    {
        return E_INVALIDARG;
    }

    // clear contents of combo box
    SendMessage(hComboBox, CB_RESETCONTENT, 0, 0); 

    for (i=0; i<dwNumAddr; i++) {
        pwszAddressList[i] = NULL;
    }
    hr =  GetSDIPList(pwszAddressList, &dwNumAddr, FALSE);
    if ( hr != S_OK) {
        ERR((TB, "GetSDIPList fails with 0x%x", hr));
        goto Cleanup;
    }

    for (i=0; i<dwNumAddr; i++) {
        SendMessage(hComboBox, CB_ADDSTRING, 0, (LPARAM)pwszAddressList[i]);
        nNumIPsInComboBox++;
    }

    // set combo-box selection to first item in list
    SendMessage(hComboBox, CB_SETCURSEL, 0, (LPARAM)0); 

    // read in stored selection from registry we will then select it from list
    dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            REG_TS_CLUSTERSETTINGS,
                            0,
                            KEY_READ, 
                            &hKey);
    if (dwResult == ERROR_SUCCESS)
    {               
        RegQueryValueEx(hKey,
                        REG_TS_CLUSTER_REDIRECTIONIP,
                        NULL, 
                        NULL,
                        (LPBYTE)wszSetIP,
                        &cbData);
        RegCloseKey(hKey);
    }

    // if a string was loaded from registry search combo box for it and select
    if (wcslen(wszSetIP) > 0)
    {
        for (nPos = 0; nPos < nNumIPsInComboBox; nPos++)
        {            
            // get length of string stored at current position
            dwLen = SendMessage(hComboBox, 
                                CB_GETLBTEXTLEN, 
                                (WPARAM)nPos, 
                                0);
            if (dwLen > 0)
            {                                
                // allocate room for selection
                pwszSel = (LPWSTR)GlobalAlloc(GPTR, (dwLen + 1) * sizeof(WCHAR));
                if (pwszSel != NULL)
                {
                    SendMessage(hComboBox, 
                                CB_GETLBTEXT, 
                                (WPARAM)nPos, 
                                (LPARAM)pwszSel);
                    // if we got a string check if it contains the IP we loaded
                    // from the registry
                    if (wcslen(pwszSel) > 0)
                    {
                        pwszMatch = wcsstr(pwszSel, wszSetIP);
                        if (pwszMatch != NULL)
                        {
                            // it's a match, lets break out
                            GlobalFree(pwszSel);
                            break;
                        }
                    }
                    GlobalFree(pwszSel);
                    pwszSel = NULL;
                }
            }           
        }

        // if a match was found set it as the current selection
        if (nPos < nNumIPsInComboBox)
        {
            SendMessage(hComboBox, CB_SETCURSEL, (WPARAM)nPos, (LPARAM)0); 
        }
    }
Cleanup:
    for(i=0; i<dwNumAddr; i++) {
        if (pwszAddressList[i] != NULL) {
            LocalFree(pwszAddressList[i]);
        }
    }
    return hr;
}


//*****************************************************************************
// Method: 
//          GetNLBIP
// Synopsis:
//          Return the NLB IP Address if one exists.  Otherwise a NULL string
//          is returned.
// Params:
//          Out: ppwszRetIP, pointer to string to get IP address, caller must
//               free this when their done with it
// Return:
//          HRESULT, S_OK is successful or other if failed
//*****************************************************************************
HRESULT
GetNLBIP(LPWSTR * ppwszRetIP)
{
    HRESULT                hr               = S_OK;        
    IWbemLocator         * pWbemLocator     = NULL;
    IWbemServices        * pWbemServices    = NULL;
    IWbemClassObject     * pWbemObj         = NULL;
    IEnumWbemClassObject * pWbemEnum        = NULL;
    BSTR                   bstrServer       = NULL;
    BSTR                   bstrNode         = NULL;
    BSTR                   bstrNameProperty = NULL;
    ULONG                  uReturned;
    VARIANT                vtNLBNodeName; 
    size_t                 dwIPLength;


    // make sure an empty buffer is passed in
    if (*ppwszRetIP != NULL)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
       
    // create an instance of the WMI Locator, need this to query WMI
    hr = CoCreateInstance(CLSID_WbemLocator,
                          0,
                          CLSCTX_INPROC_SERVER,
                          IID_IWbemLocator,
                          reinterpret_cast<void**>(&pWbemLocator));
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    // create a connection to WMI Namespace "root\\MicrosoftNLB";
    bstrServer = SysAllocString(L"root\\MicrosoftNLB");
    if (bstrServer == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pWbemLocator->ConnectServer(bstrServer,
                                     NULL,
                                     NULL,
                                     0,
                                     NULL,
                                     0,
                                     0,
                                     &pWbemServices);
    if (FAILED(hr))
    {
        // If WMI is not available we don't want to fail, so just return S_OK
        if (hr == HRESULT_FROM_WIN32(ERROR_SERVICE_DISABLED))
        {
            hr = S_OK;
        }

        goto Cleanup;
    }

    // Set the proxy so that impersonation of the client occurs.
    hr = CoSetProxyBlanket(pWbemServices,
                           RPC_C_AUTHN_WINNT,
                           RPC_C_AUTHZ_NONE,
                           NULL,
                           RPC_C_AUTHN_LEVEL_CALL,
                           RPC_C_IMP_LEVEL_IMPERSONATE,
                           NULL,
                           EOAC_NONE);
    if (FAILED(hr))
    {
        goto Cleanup;
    }


    // get instance of MicrosoftNLB_NodeSetting, this is where we can get the 
    // IP Address for the Cluster IP through the "Name" property
    bstrNode = SysAllocString(L"MicrosoftNLB_NodeSetting");
    if (bstrNode == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pWbemServices->CreateInstanceEnum(bstrNode,
                                           WBEM_FLAG_RETURN_IMMEDIATELY,
                                           NULL,
                                           &pWbemEnum);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    uReturned = 0;

    // we only need to look at one instance to get the NLB IP Address
    hr = pWbemEnum->Next(WBEM_INFINITE, 
                         1,
                         &pWbemObj,
                         &uReturned);
    if (FAILED(hr))
    {
        // if NLB provider doesn't exist provider will fail to load
        // this is ok so we'll return S_OK in this case
        if (hr == WBEM_E_PROVIDER_LOAD_FAILURE)
        {
            hr = S_OK;
        }

        goto Cleanup;
    }    

    // Nothing to enumerate.
    if( hr == WBEM_S_FALSE && uReturned == 0 )
    {
        hr = S_OK;
        goto Cleanup;
    }

    if( pWbemObj == NULL ) 
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // query the "Name" property which holds the IP address we want
    bstrNameProperty = SysAllocString(L"Name");
    if (bstrNameProperty == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pWbemObj->Get(bstrNameProperty,
                       0,
                       &vtNLBNodeName,
                       NULL,
                       NULL);
    if (FAILED(hr))
    {
        goto Cleanup;
    }
    
    // We should get a string back
    if (vtNLBNodeName.vt != VT_BSTR)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // allocate memory for the return string, *** CALLER MUST FREE THIS ***
    dwIPLength = wcslen(vtNLBNodeName.bstrVal) + 1;
    *ppwszRetIP = (LPWSTR)GlobalAlloc(GPTR, dwIPLength * sizeof(WCHAR));
    if (*ppwszRetIP == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // Copy the string into our return buffer
    wcscpy(*ppwszRetIP, vtNLBNodeName.bstrVal);
    (*ppwszRetIP)[dwIPLength - 1] = L'\0';

Cleanup:

    if (pWbemLocator)
        pWbemLocator->Release();

    if (pWbemServices)
        pWbemServices->Release();

    if (pWbemEnum)
        pWbemEnum->Release();

    if (pWbemObj)
        pWbemObj->Release();
    
    if (bstrServer)
        SysFreeString(bstrServer);

    if (bstrNode)
        SysFreeString(bstrNode);

    if (bstrNameProperty)
        SysFreeString(bstrNameProperty);

    VariantClear(&vtNLBNodeName);

    return hr;
}


//*****************************************************************************
// Method: 
//          GetAdapterServiceName
// Synopsis:
//          Each NIC is given a Service Name which is a GUID. This method will
//          query this service name for the adapter associated with the
//          description passed in.
// Params:
//          wszAdapterDesc (IN): Adapter description to look up in the registry
//          ppwszServiceName (OUT): Service Name (or GUID)
//
// Return:
//          HRESULT, S_OK is successful or other if failed
//*****************************************************************************
HRESULT 
GetAdapterServiceName(LPWSTR wszAdapterDesc, LPWSTR * ppwszServiceName)
{
    HRESULT hr       = S_OK;
    LONG    lRet;
    HKEY    hKey     = NULL;
    HKEY    hSubKey  = NULL;
    DWORD   dwNetCardLength;
    TCHAR   tchNetCard[MAX_PATH];
    WCHAR   wszVal[MAX_PATH];
    DWORD   dwSize;
    DWORD   i;
    

    // Open the NetworkCards registry key
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        NETCARDS_REG_NAME, 
                        0, 
                        KEY_READ, 
                        &hKey);
    if (lRet != ERROR_SUCCESS)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // Enumerate the Network Cards list and extract the Service Name GUID
    for (i = 0, lRet = ERROR_SUCCESS; lRet == ERROR_SUCCESS; i++) 
    {
        // Get the Network Card key
        dwNetCardLength = MAX_PATH;
        lRet = RegEnumKeyEx(hKey,
                            i,
                            tchNetCard,
                            &dwNetCardLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
        if (lRet == ERROR_SUCCESS)
        {
            // Open the Network card key, if it fails go to the next one
            lRet = RegOpenKeyEx(hKey,
                                tchNetCard,
                                0,
                                KEY_READ,
                                &hSubKey);
            if (lRet == ERROR_SUCCESS)
            {
                // Query the Description Value
                dwSize = MAX_PATH;
                lRet = RegQueryValueEx(hSubKey,
                                       NETCARD_DESC_VALUE_NAME,
                                       NULL,
                                       NULL,
                                       (LPBYTE) &wszVal,
                                       &dwSize);
                if ( (lRet == ERROR_SUCCESS) && (wszVal != NULL) )
                {
                    // Check if this is the adapter we're looking for
                    if (!wcscmp(wszAdapterDesc, wszVal))
                    {
                        // Get GUID for this Lan adapter
                        dwSize = MAX_PATH;
                        lRet = RegQueryValueEx(hSubKey,
                                               NETCARD_SERVICENAME_VALUE_NAME,
                                               NULL,
                                               NULL,
                                               (LPBYTE) &wszVal,
                                               &dwSize);
                        if ( (lRet == ERROR_SUCCESS) && (wszVal != NULL) )
                        {
                            // Return dwSize from RegQueryValueEx is in bytes
                            *ppwszServiceName = (LPWSTR)GlobalAlloc(GPTR, 
                                                     (dwSize + 1) + sizeof(WCHAR));
                            if (*ppwszServiceName == NULL)
                            {
                                hr = E_OUTOFMEMORY;
                                goto Cleanup;
                            }
                            // Copy name over and return
                            wcscpy(*ppwszServiceName, wszVal);
                            goto Cleanup;                            
                        }
                    }
                }
                RegCloseKey(hSubKey);
                hSubKey = NULL;
            }
            // Set to success for our for loop
            lRet = ERROR_SUCCESS;
        }
    }


Cleanup:
    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    if (hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    return hr;
}


//*****************************************************************************
// Method: 
//          BuildLanaGUIDList
// Synopsis:
//          Build an array of strings (GUIDs) that represent LAN Adapter card
//          service names that are set in all winstations.
// Params:
//          pastrLanaGUIDList (OUT): Pointer to array of LPWSTR's to get 
//                                   service name GUIDs
//          dwLanaGUIDCount (OUT): Count of service names returned in array
//
// Return:
//          HRESULT, S_OK is successful or other if failed
//          One special case is if a winstation is set to "All Adapters ..."
//          then we'll just return S_ALL_ADAPTERS_SET
//*****************************************************************************
HRESULT
BuildLanaGUIDList(LPWSTR * pastrLanaGUIDList, DWORD *dwLanaGUIDCount)
{
    HRESULT hr       = S_OK;
    LONG    lRet;
    HKEY    hKey     = NULL;
    HKEY    hSubKey  = NULL;
    DWORD   dwWinstaNameLength;
    TCHAR   tchWinstaName[MAX_PATH];
    DWORD   dwVal    = 0;
    DWORD   dwSize;
    DWORD   i;
    LPWSTR  wszGUID  = NULL;
    DWORD   dwIndex  = 0;
    

    // Open the winstation registry key
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        WINSTATION_REG_NAME, 
                        0, 
                        KEY_READ, 
                        &hKey);
    if (lRet != ERROR_SUCCESS)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // Enumerate the winstation list and extract the Lan Adapter used for each
    for (i = 0, lRet = ERROR_SUCCESS; lRet == ERROR_SUCCESS; i++) 
    {
        // Get the winsstation name
        dwWinstaNameLength = MAX_PATH;
        lRet = RegEnumKeyEx(hKey,
                            i,
                            tchWinstaName,
                            &dwWinstaNameLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
        if (lRet == ERROR_SUCCESS)
        {
            // Open the winstation, if it fails: go to the next one
            lRet = RegOpenKeyEx(hKey,
                                tchWinstaName,
                                0,
                                KEY_READ,
                                &hSubKey);
            if (lRet == ERROR_SUCCESS)
            {
                // Query the Lan Adapter ID set for this winstation
                dwSize = sizeof(DWORD);
                lRet = RegQueryValueEx(hSubKey,
                                       WIN_LANADAPTER,
                                       NULL,
                                       NULL,
                                       (LPBYTE) &dwVal,
                                       &dwSize);
                if (lRet == ERROR_SUCCESS)
                {
                    // If we ever see a return of "0" this means
                    // all adapters are set, so lets return a special
                    // hresult here to use all adapters.
                    if (dwVal == 0)
                    {
                        hr = S_ALL_ADAPTERS_SET;
                        goto Cleanup;
                    }                    
                    
                    // Get Lan Adapter GUID for this ID
                    wszGUID = NULL;
                    hr = GetLanAdapterGuidFromID(dwVal, &wszGUID);
                    if (FAILED(hr))
                    {
                        goto Cleanup;
                    }
                    
                    if (wszGUID != NULL)
                    {
                        pastrLanaGUIDList[dwIndex] = wszGUID;
                        dwIndex++;
                    }
                }
                RegCloseKey(hSubKey);
                hSubKey = NULL;
            }
            // our for loop requires lRet to be ERROR_SUCCESS to keep going
            lRet = ERROR_SUCCESS;
        }
    }

    *dwLanaGUIDCount = dwIndex;

Cleanup:
    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    if (hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }
    
    return hr;
}


//*****************************************************************************
// Method: 
//          GetLanAdapterGuidFromID
// Synopsis:
//          Get the GUID (Service Name) associated with a LAN ID that 
//          the winstation stores, when set from tscc.msc
// Params:
//          dwLanAdapterID (IN): ID of adapter to get GUID for
//          ppszLanAdapterGUID (OUT): Returned GUID string associated with ID
//
// Return:
//          HRESULT, S_OK is successful or other if failed
//*****************************************************************************
HRESULT 
GetLanAdapterGuidFromID(DWORD dwLanAdapterID, LPWSTR * ppszLanAdapterGUID)
{
    HRESULT hr      = S_OK;
    LONG    lRet;
    HKEY    hKey    = NULL;
    HKEY    hSubKey = NULL;
    DWORD   dwLanAdapterGuidLength;
    TCHAR   tchLanAdapterGuid[MAX_PATH];
    DWORD   dwVal   = 0;
    DWORD   dwSize;
    DWORD   i;

    // Open the winstation registry key
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                        LANATABLE_REG_NAME, 
                        0, 
                        KEY_READ, 
                        &hKey);
    if (lRet != ERROR_SUCCESS)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    // Enumerate the list of lan adapter guids
    for (i = 0, lRet = ERROR_SUCCESS; lRet == ERROR_SUCCESS; i++) 
    {
        // Get the next lan adapter guid
        dwLanAdapterGuidLength = MAX_PATH;
        lRet = RegEnumKeyEx(hKey,
                            i,
                            tchLanAdapterGuid,
                            &dwLanAdapterGuidLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL);
        if (lRet == ERROR_SUCCESS)
        {
            // Open the next lan adapter guid, if it fails for any reason
            // we'll skip to the next
            lRet = RegOpenKeyEx(hKey,
                                tchLanAdapterGuid,
                                0,
                                KEY_READ,
                                &hSubKey);
            if (lRet == ERROR_SUCCESS)
            {
                // Query the Lan Adapter GUID for it's ID
                dwSize = sizeof(DWORD);
                lRet = RegQueryValueEx(hSubKey,
                                       LANAID_REG_VALUE_NAME,
                                       NULL,
                                       NULL,
                                       (LPBYTE) &dwVal,
                                       &dwSize);
                if (lRet == ERROR_SUCCESS)
                {
                    // Check if this is the guid we're looking for
                    if (dwVal == dwLanAdapterID)
                    {
                        // Copy GUID string to be returned and return
                        *ppszLanAdapterGUID = (LPWSTR)GlobalAlloc(GPTR, 
                                       (dwLanAdapterGuidLength + 1) * sizeof(WCHAR));
                        if (*ppszLanAdapterGUID == NULL)
                        {
                            hr = E_OUTOFMEMORY;
                            goto Cleanup;
                        }
                        wcscpy(*ppszLanAdapterGUID, tchLanAdapterGuid);
                        goto Cleanup;
                    }
                }
                RegCloseKey(hSubKey);
                hSubKey = NULL;
            }
            // need to set lRet to success for our for loop to continue
            lRet = ERROR_SUCCESS;
        }
    }


Cleanup:
    if (hKey != NULL)
    {
        RegCloseKey(hKey);
    }

    if (hSubKey != NULL)
    {
        RegCloseKey(hSubKey);
    }

    return hr;
}

#pragma warning (pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdsql\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sds.rc
//
#define IDD_DIALOG_SDS                  101
#define IDC_CHECK_ENABLE                1000
#define IDC_EDIT_SERVERNAME             1001
#define IDC_EDIT_CLUSTERNAME            1002
#define IDS_DISABLE                     1004
#define IDS_ENABLE                      1005
#define IDS_ATTRIBUTE_NAME              1006
#define IDS_PROPERTIES                  1007
#define IDS_DESCRIP_ENABLE              1008
#define IDS_DESCRIP_PROPS               1010
#define IDC_EDIT_ACCOUNTNAME            1011
#define IDC_EDIT_PASSWORD               1012
#define IDC_STATIC_SQLNAME              1013
#define IDC_STATIC_CLUSTERNAME          1014
#define IDC_STATIC_SQLACCOUNT           1015
#define IDC_STATIC_SQLPWD               1016
#define IDS_ERROR_TITLE                 1017
#define IDS_ERROR_TEXT                  1018
#define IDS_ERROR_TEXT2                 1019
#define IDS_ERROR_TEXT3                 1020
#define IDM_MENU_ENABLE                 2000
#define IDM_MENU_PROPS                  2001
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1021
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdsql\factory.cpp ===
/****************************************************************************/
// factory.cpp
//
// TS Session Directory class factory code.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>

#include <ole2.h>
#include <objbase.h>
#include <comutil.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>

#include "tssdsql.h"
#include "factory.h"
#include "trace.h"


extern long g_lObjects;
extern long g_lLocks;


/****************************************************************************/
// CClassFactory::QueryInterface
//
// Standard COM IUnknown interface function.
// Handles interface queries for the class factory only.
/****************************************************************************/
STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    if (riid == IID_IUnknown) {
        *ppv = (LPVOID)(IUnknown *)this;
    }
    else if(riid == IID_IClassFactory) {
        *ppv = (LPVOID)(IClassFactory *)this;
    }
    else {
        TRC2((TB,"ClassFactory: Unknown interface"));
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


/****************************************************************************/
// CClassFactory::AddRef
//
// Standard COM IUnknown function.
/****************************************************************************/
STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement(&m_RefCount);
}


/****************************************************************************/
// CClassFactory::Release
//
// Standard COM IUnknown function.
/****************************************************************************/
STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    long Refs = InterlockedDecrement(&m_RefCount);
    if (Refs == 0)
        delete this;

    return Refs;
}


/****************************************************************************/
// CClassFactory::CreateInstance
//
// IClassFactory creator function.
/****************************************************************************/
STDMETHODIMP CClassFactory::CreateInstance(
        IN IUnknown *pUnknownOuter,
        IN REFIID iid,
        OUT LPVOID *ppv)
{
    HRESULT hr;
    CTSSessionDirectory *pTSSDI = NULL;

    *ppv = NULL;

    TRC2((TB,"ClassFactory::CreateInstance"));

    // We do not support aggregation
    if (pUnknownOuter != NULL)
        return CLASS_E_NOAGGREGATION;

    // Create the provider object
    pTSSDI = new CTSSessionDirectory;
    if (pTSSDI != NULL) {
        // Retrieve the requested interface.
        hr = pTSSDI->QueryInterface(iid, ppv);
        if (!FAILED(hr)) {
            return S_OK;
        }
        else {
            delete pTSSDI;
            return hr;
        }
    }
    else {
        return E_OUTOFMEMORY;
    }
}


/****************************************************************************/
// CClassFactory::LockServer
//
// IClassFactory lock function.
/****************************************************************************/
STDMETHODIMP CClassFactory::LockServer(IN BOOL bLock)
{
    if (bLock)
        InterlockedIncrement(&g_lLocks);
    else
        InterlockedDecrement(&g_lLocks);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdsql\trace.c ===
/****************************************************************************/
// trace.c
//
// Tracing code and definitions. See trace.h for other info.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#if DBG || defined(_DEBUG)

#include <windows.h>

#include "trace.h"


struct _ZoneInfo
{
    UINT32 Zone;
    char *Prefix;
} TRC_ZI[] =
{
    { Z_ASSERT, "TSSDSQL: !!! ASSERT: " },
    { Z_ERR,    "TSSDSQL: *** ERROR: " },
    { Z_WRN,    "TSSDSQL: Warning: " },
    { Z_TRC1,   "TSSDSQL: " },
    { Z_TRC2,   "TSSDSQL: " },
};
int NumTRC_ZIEntries = sizeof(TRC_ZI) / sizeof(struct _ZoneInfo);


// Globals.
UINT32 g_TraceMask = 0xFFFFFFFF;
char TB[1024];
char TB2[1024];


// Main output function.
void TracePrintZ(UINT32 ZoneFlag, char *OutString)
{
    int i;
    char *Prefix = "";

    // Find the zone information in the zone table.
    for (i = 0; i < NumTRC_ZIEntries; i++)
        if (TRC_ZI[i].Zone == ZoneFlag)
            Prefix = TRC_ZI[i].Prefix;

    // Now create the final string.
    wsprintfA(TB2, "%s%s\n", Prefix, OutString);

    // Send to output.
    OutputDebugStringA(TB2);
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdsql\server.cpp ===
/****************************************************************************/
// server.cpp
//
// General COM in-proc server framework code. TSSDI-specific code is
// designated by CLSID SPECIFIC comments.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <tchar.h>

#define INITGUID
#include <ole2.h>
#include <objbase.h>
#include <comutil.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>
#include <initguid.h>
#include <regapi.h>
#include "factory.h"
#include "trace.h"

#define SDMAX_PATH 1024
/****************************************************************************/
// CLSID SPECIFIC section
//
// Provider-specific includes, unique CLSID, other info.
/****************************************************************************/

// For new components, this is the only area that needs to be modified in this
// file. Include any appropriate header files, a unique CLSID and update 
// the macros.

#include "tssd.h"

// {943e9311-c6a6-42cf-a591-e7ce8bb1de8d}
DEFINE_GUID(CLSID_TSSDSQL,
        0x943e9311, 0xc6a6, 0x42cf, 0xA5, 0x91, 0xe7, 0xce, 0x8b, 0xb1, 0xde, 0x8d);


#define IMPLEMENTED_CLSID       CLSID_TSSDSQL
#define SERVER_REGISTRY_COMMENT L"Terminal Server Session Directory Interface"
#define CPP_CLASS_NAME          CTSSessionDirectory
#define INTERFACE_CAST          (ITSSessionDirectory *)

/****************************************************************************/
// End CLSID SPECIFIC section
/****************************************************************************/


HINSTANCE g_hInstance;
long g_lLocks = 0;
long g_lObjects = 0;


/****************************************************************************/
// DllMain
//
// Standard DLL entry point. Returns FALSE on failure.
/****************************************************************************/
BOOL WINAPI DllMain(
        HINSTANCE hInstDLL,
        DWORD dwReason,
        LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH) {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hInstDLL;
        DisableThreadLibraryCalls(hInstDLL);
    }

    return TRUE;
}


/****************************************************************************/
// DllGetClassObject
//
// Standard OLE In-Process Server entry point to return an class factory
// instance.
//***************************************************************************
STDAPI DllGetClassObject(
        REFCLSID rclsid,
        REFIID riid,
        LPVOID *ppv)
{
    CClassFactory *pClassFactory;
    HRESULT hr;

    TRC2((TB,"DllGetClassObject"));

    // Verify the caller is asking for our type of object
    if (rclsid == IMPLEMENTED_CLSID) { 
        // Create the class factory.
        pClassFactory = new CClassFactory;
        if (pClassFactory != NULL) {
            hr = pClassFactory->QueryInterface(riid, ppv);
            if (FAILED(hr)) {
                ERR((TB,"DllGetClassObject: GUID not found"));
                delete pClassFactory;
            }
        }
        else {
            ERR((TB,"DllGetClassObject: Failed alloc class factory"));
            hr = E_OUTOFMEMORY;
        }
    }
    else {
        ERR((TB,"DllGetClassObject: Failed alloc class factory"));
        hr = CLASS_E_CLASSNOTAVAILABLE;
    }

    return hr;
}


/****************************************************************************/
// DllCanUnloadNow
//
// Standard COM entry point for COM server shutdown request. Allows shutdown
// only if no outstanding objects or locks are present.
/****************************************************************************/
STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;

    if (g_lLocks == 0 && g_lObjects == 0)
        hr = S_OK;
    else
        hr = S_FALSE;

    return hr;
}


/****************************************************************************/
// DllRegisterServer
//
// Standard COM entry point for registering the server.
/****************************************************************************/
STDAPI DllRegisterServer(void)
{
    wchar_t Path[SDMAX_PATH];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[SDMAX_PATH];
    HRESULT hr = E_FAIL;

    // Get the DLL's filename
    GetModuleFileNameW(g_hInstance, Path, 1024);
    Path[SDMAX_PATH - 1] = L'\0';

    // Convert CLSID to string.
    if( SUCCEEDED( StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr ) ) )
    {
        swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

        // Place it in registry.
        // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
        //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 :
        //        <no_name> : "path to DLL"
        //        ThreadingModel : "both"
        HKEY hKey;
        LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (lRes == 0)
        {
            wchar_t *pName = SERVER_REGISTRY_COMMENT;
            RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *)pName,
                    wcslen(pName) * 2 + 2);

            HKEY hSubkey;
            lRes = RegCreateKeyW(hKey, L"InprocServer32", &hSubkey);

            RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path,
                    wcslen(Path) * 2 + 2);
            RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ,
                    (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

            RegCloseKey(hSubkey);
            RegCloseKey(hKey);            
            hr = S_OK;
        }

        CoTaskMemFree(pGuidStr);

        hr = HRESULT_FROM_WIN32( lRes );
    }

    return hr;  
}


/****************************************************************************/
// DllUnregisterServer
//
// Standard COM entry point for unregistering the server.
/****************************************************************************/
STDAPI DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];
    HRESULT hr = E_FAIL;

    if( SUCCEEDED( StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr) ) )
    {
        swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

        // Delete InProcServer32 subkey.
        LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
        if (!lRes) {
            RegDeleteKeyW(hKey, L"InprocServer32");
            RegCloseKey(hKey);

            // Delete CLSID GUID key.
            lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
            if (!lRes) {
                RegDeleteKeyW(hKey, pGuidStr);
                RegCloseKey(hKey);
            }
        }
        
        CoTaskMemFree(pGuidStr);

        hr = HRESULT_FROM_WIN32( lRes );
    }

    return hr;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdsql\tssdsql.cpp ===
/****************************************************************************/
// tssdsql.cpp
//
// Terminal Server Session Directory Interface common component code.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/

#include <windows.h>
#include <stdio.h>
#include <process.h>

#include <ole2.h>
#include <objbase.h>
#include <comdef.h>
#include <adoid.h>
#include <adoint.h>
#include <regapi.h>
#include "tssdsql.h"
#include "trace.h"
#include "resource.h"


/****************************************************************************/
// Types
/****************************************************************************/

// Shortcut VARIANT class to handle cleanup on destruction and common code
// inlining.
class CVar : public VARIANT
{
public:
    CVar() { VariantInit(this); }
    CVar(VARTYPE vt, SCODE scode = 0) {
        VariantInit(this);
        this->vt = vt;
        this->scode = scode;
    }
    CVar(VARIANT var) { *this = var; }
    ~CVar() { VariantClear(this); }

    void InitNull() { this->vt = VT_NULL; }
    void InitFromLong(long L) { this->vt = VT_I4; this->lVal = L; }
    void InitNoParam() {
        this->vt = VT_ERROR;
        this->lVal = DISP_E_PARAMNOTFOUND;
    }

    HRESULT InitFromWSTR(PCWSTR WStr) {
        this->bstrVal = SysAllocString(WStr);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    // Inits from a non-NULL-terminated set of WCHARs.
    HRESULT InitFromWChars(WCHAR *WChars, unsigned Len) {
        this->bstrVal = SysAllocStringLen(WChars, Len);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT InitEmptyBSTR(unsigned Size) {
        this->bstrVal = SysAllocStringLen(L"", Size);
        if (this->bstrVal != NULL) {
            this->vt = VT_BSTR;
            return S_OK;
        }
        else {
            return E_OUTOFMEMORY;
        }
    }

    HRESULT Clear() { return VariantClear(this); }
};


/****************************************************************************/
// Prototypes
/****************************************************************************/
INT_PTR CALLBACK CustomUIDlg(HWND, UINT, WPARAM, LPARAM);
void FindSqlValue(LPTSTR, LPTSTR, LPTSTR);
LPTSTR ModifySqlValue( LPTSTR * , LPTSTR , LPTSTR );
LPTSTR FindField( LPTSTR pszString , LPTSTR pszKeyName );
VOID strtrim( TCHAR **pszStr);

/****************************************************************************/
// Globals
/****************************************************************************/
extern HINSTANCE g_hInstance;

// The COM object counter (declared in server.cpp)
extern long g_lObjects;


/****************************************************************************/
// CTSSessionDirectory::CTSSessionDirectory
// CTSSessionDirectory::~CTSSessionDirectory
//
// Constructor and destructor
/****************************************************************************/
CTSSessionDirectory::CTSSessionDirectory() :
        m_RefCount(0), m_pConnection(NULL)
{
    InterlockedIncrement(&g_lObjects);

    m_LocalServerAddress[0] = L'\0';
    m_DBConnectStr = NULL;
    m_DBPwdStr = NULL;
    m_DBUserStr = NULL;
    m_fEnabled = 0;

    m_pszOpaqueString = NULL;
    
}

CTSSessionDirectory::~CTSSessionDirectory()
{
    HRESULT hr;

    // If the database connection exists, release it.
    if (m_pConnection != NULL) {
        hr = ExecServerOffline();
        if (FAILED(hr)) {
            ERR((TB,"Destr: ExecSvrOffline failed, hr=0x%X", hr));
        }
        hr = m_pConnection->Close();
        if (FAILED(hr)) {
            ERR((TB,"pConn->Close() failed, hr=0x%X", hr));
        }
        m_pConnection->Release();
        m_pConnection = NULL;
    }

    // Decrement the global COM object counter
    InterlockedDecrement(&g_lObjects);

    if (m_DBConnectStr != NULL)
        SysFreeString(m_DBConnectStr);
    if (m_DBPwdStr != NULL)
        SysFreeString(m_DBPwdStr);
    if (m_DBUserStr != NULL)
        SysFreeString(m_DBUserStr);
}


/****************************************************************************/
// CTSSessionDirectory::QueryInterface
//
// Standard COM IUnknown function.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::QueryInterface(
        REFIID riid,
        void **ppv)
{
    if (riid == IID_IUnknown) {
        *ppv = (LPVOID)(IUnknown *)(ITSSessionDirectory *)this;
    }
    else if (riid == IID_ITSSessionDirectory) {
        *ppv = (LPVOID)(ITSSessionDirectory *)this;
    }
    else if (riid == IID_IExtendServerSettings) {
        *ppv = (LPVOID)(IExtendServerSettings *)this;
    }
    else {
        ERR((TB,"QI: Unknown interface"));
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


/****************************************************************************/
// CTSSessionDirectory::AddRef
//
// Standard COM IUnknown function.
/****************************************************************************/
ULONG STDMETHODCALLTYPE CTSSessionDirectory::AddRef()
{
    return InterlockedIncrement(&m_RefCount);
}


/****************************************************************************/
// CTSSessionDirectory::Release
//
// Standard COM IUnknown function.
/****************************************************************************/
ULONG STDMETHODCALLTYPE CTSSessionDirectory::Release()
{
    long lRef = InterlockedDecrement(&m_RefCount);

    if (lRef == 0)
        delete this;
    return lRef;
}


/****************************************************************************/
// CTSSessionDirectory::Initialize
//
// ITSSessionDirectory function. Called soon after object instantiation to
// intiialize the directory. LocalServerAddress provides a text representation
// of the local server's load balance IP address. This information should be
// used as the server IP address in the session directory for client
// redirection by other pool servers to this server. StoreServerName,
// ClusterName, and OpaqueSettings are generic reg entries known to TermSrv
// which cover config info across any type of session directory
// implementation. The contents of these strings are designed to be parsed
// by the session directory providers.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Initialize(
        LPWSTR LocalServerAddress,
        LPWSTR StoreServerName,
        LPWSTR ClusterName,
        LPWSTR OpaqueSettings,
        DWORD Flags,
        DWORD (*repopfn)(),
        DWORD (*updatesd)(DWORD))
{
    HRESULT hr = S_OK;
    unsigned Len;
    WCHAR *pSearch;
    WCHAR ConnectString[384];

    ASSERT((LocalServerAddress != NULL),(TB,"Init: LocalServerAddr null!"));
    ASSERT((StoreServerName != NULL),(TB,"Init: StoreServerName null!"));
    ASSERT((ClusterName != NULL),(TB,"Init: ClusterName null!"));
    ASSERT((OpaqueSettings != NULL),(TB,"Init: OpaqueSettings null!"));

    // Copy off the server address and cluster name for later use.
    wcsncpy(m_LocalServerAddress, LocalServerAddress,
            sizeof(m_LocalServerAddress) / sizeof(WCHAR) - 1);
    m_LocalServerAddress[sizeof(m_LocalServerAddress) / sizeof(WCHAR) - 1] =
            L'\0';
    wcsncpy(m_ClusterName, ClusterName,
            sizeof(m_ClusterName) / sizeof(WCHAR) - 1);
    m_ClusterName[sizeof(m_ClusterName) / sizeof(WCHAR) - 1] = L'\0';

    // Create the SQL connect string using the OpaqueSettings string
    // (which should contain some of the conn str including SQL security
    // username and password, sub-table names, provider type, etc.).
    // We add onto the end a semicolon (if not already present) and the
    // data source (from StoreServerName), if the "data source" substring
    // is not already in the connect string.
    pSearch = OpaqueSettings;
    while (*pSearch != L'\0') {
        if (*pSearch == L'D' || *pSearch == L'd') {
            if (!_wcsnicmp(pSearch, L"data source", wcslen(L"data source"))) {
                // Transfer the OpaqueSettings string as a whole to become
                // the connect str.
                wcscpy(ConnectString, OpaqueSettings);
                goto PostConnStrSetup;
            }
        }
        pSearch++;
    }

    Len = wcslen(OpaqueSettings);
    if (Len == 0 || OpaqueSettings[Len - 1] == L';')
        wsprintfW(ConnectString, L"%sData Source=%s", OpaqueSettings,
                StoreServerName);
    else
        wsprintfW(ConnectString, L"%s;Data Source=%s", OpaqueSettings,
                StoreServerName);

PostConnStrSetup:
    TRC1((TB,"Initialize: Svr addr=%S, StoreSvrName=%S, ClusterName=%S, "
            "OpaqueSettings=%S, final connstr=%S",
            m_LocalServerAddress, StoreServerName, m_ClusterName,
            OpaqueSettings, ConnectString));

    // Alloc the BSTRs for the connection strings.
    m_DBConnectStr = SysAllocString(ConnectString);
    if (m_DBConnectStr != NULL) {
        m_DBUserStr = SysAllocString(L"");
        if (m_DBUserStr != NULL) {
            m_DBPwdStr = SysAllocString(L"");
            if (m_DBPwdStr == NULL) {
                ERR((TB,"Failed alloc bstr for pwdstr"));
                goto ExitFunc;
            }
        }
        else {
            ERR((TB,"Failed alloc bstr for userstr"));
            goto ExitFunc;
        }
    }
    else {
        ERR((TB,"Failed alloc bstr for connstr"));
        goto ExitFunc;
    }

    // Create an ADO connection instance and connect.
    hr = CoCreateInstance(CLSID_CADOConnection, NULL,
            CLSCTX_INPROC_SERVER, IID_IADOConnection,
            (LPVOID *)&m_pConnection);
    if (SUCCEEDED(hr)) {
        // Set the connection timeout to only 8 seconds. Standard is 15
        // but we don't want to be holding up TermSrv's initialization.
        m_pConnection->put_ConnectionTimeout(8);

        // Do the open.
        hr = OpenConnection();
        if (SUCCEEDED(hr)) {
            // Signal the server is online.
            hr = ExecServerOnline();
        }
        else {
            m_pConnection->Release();
            m_pConnection = NULL;
        }
    }
    else {
        ERR((TB,"CoCreate(ADOConn) returned 0x%X", hr));
    }

ExitFunc:
    return hr;
}


HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Update(
        LPWSTR LocalServerAddress,
        LPWSTR StoreServerName,
        LPWSTR ClusterName,
        LPWSTR OpaqueSettings,
        DWORD Flags,
        BOOL ForceRejoin)
{
    return E_NOTIMPL;
}


/****************************************************************************/
// CTSSessionDirectory::OpenConnection
//
// Opens the connection to the SQL server based on the pre-existing
// connect string and allocated connection. This is called at init time,
// plus whenever the database connection times out and gets closed, but is
// still required 
/****************************************************************************/
HRESULT CTSSessionDirectory::OpenConnection()
{
    HRESULT hr;

    ASSERT((m_pConnection != NULL),(TB,"OpenConn: NULL pconn"));
    ASSERT((m_DBConnectStr != NULL),(TB,"OpenConn: NULL connstr"));
    ASSERT((m_DBUserStr != NULL),(TB,"OpenConn: NULL userstr"));
    ASSERT((m_DBPwdStr != NULL),(TB,"OpenConn: NULL pwdstr"));

    hr = m_pConnection->Open(m_DBConnectStr, m_DBUserStr, m_DBPwdStr,
            adOpenUnspecified);
    if (FAILED(hr)) {
        ERR((TB,"OpenConn: Failed open DB, connstring=%S, hr=0x%X",
                m_DBConnectStr, hr));
    }

    return hr;
}


/****************************************************************************/
// GetRowArrayStringField
//
// Retrieves a WSTR from a specified row and field of the given SafeArray.
// Returns failure if the target field is not a string. MaxOutStr is max
// WCHARs not including NULL.
/****************************************************************************/
HRESULT GetRowArrayStringField(
        SAFEARRAY *pSA,
        unsigned RowIndex,
        unsigned FieldIndex,
        WCHAR *OutStr,
        unsigned MaxOutStr)
{
    HRESULT hr;
    CVar varField;
    long DimIndices[2];

    DimIndices[0] = FieldIndex;
    DimIndices[1] = RowIndex;
    SafeArrayGetElement(pSA, DimIndices, &varField);

    if (varField.vt == VT_BSTR) {
        wcsncpy(OutStr, varField.bstrVal, MaxOutStr);
        hr = S_OK;
    }
    else if (varField.vt == VT_NULL) {
        OutStr[0] = L'\0';
        hr = S_OK;
    }
    else {
        ERR((TB,"GetRowStrField: Row %u Col %u value %d is not a string",
                RowIndex, FieldIndex, varField.vt));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// GetRowArrayDWORDField
//
// Retrieves a DWORD from a specified row and field of the given SafeArray.
// Returns failure if the target field is not a 4-byte integer.
/****************************************************************************/
HRESULT GetRowArrayDWORDField(
        SAFEARRAY *pSA,
        unsigned RowIndex,
        unsigned FieldIndex,
        DWORD *pOutValue)
{
    HRESULT hr;
    CVar varField;
    long DimIndices[2];

    DimIndices[0] = FieldIndex;
    DimIndices[1] = RowIndex;
    SafeArrayGetElement(pSA, DimIndices, &varField);

    if (varField.vt == VT_I4) {
        *pOutValue = (DWORD)varField.lVal;
        hr = S_OK;
    }
    else if (varField.vt == VT_NULL) {
        *pOutValue = 0;
        hr = S_OK;
    }
    else {
        ERR((TB,"GetRowDWField: Row %u Col %u value %d is not a VT_I4",
                RowIndex, FieldIndex, varField.vt));
        hr = E_FAIL;
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::GetUserDisconnectedSessions
//
// Called to perform a query against the session directory, to provide the
// list of disconnected sessions for the provided username and domain.
// Returns zero or more TSSD_DisconnectedSessionInfo blocks in SessionBuf.
// *pNumSessionsReturned receives the number of blocks.
/****************************************************************************/
#define NumOutputFields 11

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::GetUserDisconnectedSessions(
        LPWSTR UserName,
        LPWSTR Domain,
        DWORD __RPC_FAR *pNumSessionsReturned,
        TSSD_DisconnectedSessionInfo __RPC_FAR SessionBuf[
            TSSD_MaxDisconnectedSessions])
{
    DWORD NumSessions = 0;
    long State;
    long NumRecords;
    HRESULT hr;
    unsigned i, j;
    unsigned NumFailed;
    TSSD_DisconnectedSessionInfo *pInfo;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;
    ADOFields *pFields;
    CVar varRows;
    CVar varFields;
    CVar varStart;
    HRESULT hrFields[NumOutputFields];

    TRC2((TB,"GetUserDisconnectedSessions"));

    ASSERT((pNumSessionsReturned != NULL),(TB,"NULL pNumSess"));
    ASSERT((SessionBuf != NULL),(TB,"NULL SessionBuf"));

    hr = CreateADOStoredProcCommand(L"SP_TSSDGetUserDisconnectedSessions",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        hr = AddADOInputStringParam(UserName, L"UserName", pCommand,
                pParameters, FALSE);
        if (SUCCEEDED(hr)) {
            hr = AddADOInputStringParam(Domain, L"Domain", pCommand,
                    pParameters, FALSE);
            if (SUCCEEDED(hr)) {
                hr = AddADOInputDWORDParam(m_ClusterID, L"ClusterID",
                        pCommand, pParameters);
                if (SUCCEEDED(hr)) {
                    // Execute the command.
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc,
                            &pResultRecordSet);
                    if (FAILED(hr)) {
                        // If we've not used the connection for awhile, it
                        // might have been disconnected and the connection
                        // object will be invalid. Attempt a reopen then
                        // reissue the command.
                        TRC2((TB,"GetUserDisc: Failed cmd, hr=0x%X, retrying",
                                hr));
                        m_pConnection->Close();
                        hr = OpenConnection();
                        if (SUCCEEDED(hr)) {
                            hr = pCommand->Execute(NULL, NULL,
                                    adCmdStoredProc, &pResultRecordSet);
                            if (FAILED(hr)) {
                                ERR((TB,"GetUserDisc: Failed cmd, hr=0x%X",
                                        hr));
                            }
                        }
                        else {
                            ERR((TB,"GetUserDisc: Failed reopen conn, hr=0x%X",
                                    hr));
                        }
                    }
                }
                else {
                    ERR((TB,"GetUserDisc: Failed add cluster, hr=0x%X", hr));
                }
            }
            else {
                ERR((TB,"GetUserDisc: Failed add sessid, hr=0x%X", hr));
            }
        }
        else {
            ERR((TB,"GetUserDisc: Failed add svraddr, hr=0x%X", hr));
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"GetUserDisc: Failed create cmd, hr=0x%X", hr));
    }
        
    // At this point we have a result recordset containing the server rows
    // corresponding to all of the disconnected sessions.
    if (SUCCEEDED(hr)) {
        long State;

        NumSessions = 0;

        hr = pResultRecordSet->get_State(&State);
        if (SUCCEEDED(hr)) {
            if (!(State & adStateClosed)) {
                VARIANT_BOOL VB;

                // If EOF the recordset is empty.
                hr = pResultRecordSet->get_EOF(&VB);
                if (SUCCEEDED(hr)) {
                    if (VB) {
                        TRC1((TB,"GetUserDisc: Result recordset EOF, 0 rows"));
                        goto PostUnpackResultSet;
                    }
                }
                else {
                    ERR((TB,"GetUserDisc: Failed get_EOF, hr=0x%X", hr));
                    goto PostUnpackResultSet;
                }
            }
            else {
                ERR((TB,"GetUserDisc: Closed result recordset"));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetUserDisc: get_State failed, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }

        // Grab the result data into a safearray, starting with the default
        // current row and all fields.
        varStart.InitNoParam();
        varFields.InitNoParam();
        hr = pResultRecordSet->GetRows(TSSD_MaxDisconnectedSessions, varStart,
                varFields, &varRows);
        if (SUCCEEDED(hr)) {
            NumRecords = 0;
            hr = SafeArrayGetUBound(varRows.parray, 2, &NumRecords);
            if (SUCCEEDED(hr)) {
                // 0-based array bound was returned, num rows is that + 1.
                NumRecords++;
                ASSERT((NumRecords <= TSSD_MaxDisconnectedSessions),
                        (TB,"GetUserDisc: NumRecords %u greater than expected %u",
                        NumRecords, TSSD_MaxDisconnectedSessions));

                TRC1((TB,"%d rows retrieved from safearray", NumRecords));
            }
            else {
                ERR((TB,"GetUserDisc: Failed safearray getubound, hr=0x%X", hr));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetUserDisc: Failed to get rows, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }

        // Loop through and get the contents of each row, translating into
        // the output DiscSession structs.
        pInfo = SessionBuf;
        for (i = 0; i < (unsigned)NumRecords; i++) {
            // Stack up the hr's for each field before checking them all.
            hrFields[0] = GetRowArrayStringField(varRows.parray, i, 0,
                    pInfo->ServerAddress, sizeof(pInfo->ServerAddress) /
                    sizeof(TCHAR) - 1);
            hrFields[1] = GetRowArrayDWORDField(varRows.parray, i, 1,
                    &pInfo->SessionID);
            hrFields[2] = GetRowArrayDWORDField(varRows.parray, i, 2,
                    &pInfo->TSProtocol);
            hrFields[3] = GetRowArrayStringField(varRows.parray, i, 7,
                    pInfo->ApplicationType, sizeof(pInfo->ApplicationType) /
                    sizeof(TCHAR) - 1);
            hrFields[4] = GetRowArrayDWORDField(varRows.parray, i, 8,
                    &pInfo->ResolutionWidth);
            hrFields[5] = GetRowArrayDWORDField(varRows.parray, i, 9,
                    &pInfo->ResolutionHeight);
            hrFields[6] = GetRowArrayDWORDField(varRows.parray, i, 10,
                    &pInfo->ColorDepth);
            hrFields[7] = GetRowArrayDWORDField(varRows.parray, i, 3,
                    &pInfo->CreateTime.dwLowDateTime);
            hrFields[8] = GetRowArrayDWORDField(varRows.parray, i, 4,
                    &pInfo->CreateTime.dwHighDateTime);
            hrFields[9] = GetRowArrayDWORDField(varRows.parray, i, 5,
                    &pInfo->DisconnectionTime.dwLowDateTime);
            hrFields[10] = GetRowArrayDWORDField(varRows.parray, i, 6,
                    &pInfo->DisconnectionTime.dwHighDateTime);

            NumFailed = 0;
            for (j = 0; j < NumOutputFields; j++) {
                if (SUCCEEDED(hrFields[j])) {
                    continue;
                }
                else {
                    ERR((TB,"GetUserDisc: Row %u field %u returned hr=0x%X",
                            i, j, hrFields[j]));
                    NumFailed++;
                }
            }
            if (!NumFailed) {
                NumSessions++;
                pInfo++;
            }
        }


PostUnpackResultSet:
        pResultRecordSet->Release();
    }
    else {
        ERR((TB,"GetUserDisc: Failed exec, hr=0x%X", hr));
    }

    *pNumSessionsReturned = NumSessions;
    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyCreateLocalSession
//
// ITSSessionDirectory function. Called when a session is created to add the
// session to the session directory. Note that other interface functions
// access the session directory by either the username/domain or the
// session ID; the directory schema should take this into account for
// performance optimization.
/****************************************************************************/
#define NumCreateParams 11

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyCreateLocalSession(
        TSSD_CreateSessionInfo __RPC_FAR *pCreateInfo)
{
    unsigned i, NumFailed;
    HRESULT hr;
    HRESULT hrParam[NumCreateParams];
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyCreateLocalSession, SessID=%u", pCreateInfo->SessionID));

    ASSERT((pCreateInfo != NULL),(TB,"NotifyCreate: NULL CreateInfo"));

    hr = CreateADOStoredProcCommand(L"SP_TSSDCreateSession", &pCommand,
            &pParameters);
    if (SUCCEEDED(hr)) {
        // Create and add the params in one fell swoop. We'll check all
        // of the return values in a batch later.
        hrParam[0] = AddADOInputStringParam(pCreateInfo->UserName,
                L"UserName", pCommand, pParameters, FALSE);
        hrParam[1] = AddADOInputStringParam(pCreateInfo->Domain,
                L"Domain", pCommand, pParameters, FALSE);
        hrParam[2] = AddADOInputDWORDParam(m_ServerID,
                L"ServerID", pCommand, pParameters);
        hrParam[3] = AddADOInputDWORDParam(pCreateInfo->SessionID,
                L"SessionID", pCommand, pParameters);
        hrParam[4] = AddADOInputDWORDParam(pCreateInfo->TSProtocol,
                L"TSProtocol", pCommand, pParameters);
        hrParam[5] = AddADOInputStringParam(pCreateInfo->ApplicationType,
                L"AppType", pCommand, pParameters);
        hrParam[6] = AddADOInputDWORDParam(pCreateInfo->ResolutionWidth,
                L"ResolutionWidth", pCommand, pParameters);
        hrParam[7] = AddADOInputDWORDParam(pCreateInfo->ResolutionHeight,
                L"ResolutionHeight", pCommand, pParameters);
        hrParam[8] = AddADOInputDWORDParam(pCreateInfo->ColorDepth,
                L"ColorDepth", pCommand, pParameters);
        hrParam[9] = AddADOInputDWORDParam(pCreateInfo->CreateTime.dwLowDateTime,
                L"CreateTimeLow", pCommand, pParameters);
        hrParam[10] = AddADOInputDWORDParam(pCreateInfo->CreateTime.dwHighDateTime,
                L"CreateTimeHigh", pCommand, pParameters);

        NumFailed = 0;
        for (i = 0; i < NumCreateParams; i++) {
            if (SUCCEEDED(hrParam[i])) {
                continue;
            }
            else {
                ERR((TB,"NotifyCreate: Failed param create %u", i));
                NumFailed++;
                hr = hrParam[i];
            }
        }
        if (NumFailed == 0) {
            // Execute the command.
            hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                    adExecuteNoRecords, &pResultRecordSet);
            if (FAILED(hr)) {
                // If we've not used the connection for awhile, it might
                // have been disconnected and the connection object will
                // be invalid. Attempt a reopen then reissue the command.
                TRC2((TB,"NotifyCreate: Failed cmd, hr=0x%X, retrying",
                        hr));
                m_pConnection->Close();
                hr = OpenConnection();
                if (SUCCEEDED(hr)) {
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                            adExecuteNoRecords, &pResultRecordSet);
                    if (FAILED(hr)) {
                        ERR((TB,"NotifyCreate: Failed exec, hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"NotifyCreate: Failed reopen conn, hr=0x%X",
                            hr));
                }
            }
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyCreate: Failed create cmd, hr=0x%X", hr));
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyDestroyLocalSession
//
// ITSSessionDirectory function. Removes a session from the session database.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyDestroyLocalSession(
        DWORD SessionID)
{
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyDestroyLocalSession, SessionID=%u", SessionID));

    hr = CreateADOStoredProcCommand(L"SP_TSSDDeleteSession", &pCommand,
            &pParameters);
    if (SUCCEEDED(hr)) {
        hr = AddADOInputDWORDParam(m_ServerID, L"ServerID",
                pCommand, pParameters);
        if (SUCCEEDED(hr)) {
            hr = AddADOInputDWORDParam(SessionID, L"SessionID", pCommand,
                    pParameters);
            if (SUCCEEDED(hr)) {
                // Execute the command.
                hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                        adExecuteNoRecords, &pResultRecordSet);
                if (FAILED(hr)) {
                    // If we've not used the connection for awhile, it might
                    // have been disconnected and the connection object will
                    // be invalid. Attempt a reopen then reissue the command.
                    TRC2((TB,"NotifyDestroy: Failed cmd, hr=0x%X, retrying",
                            hr));
                    m_pConnection->Close();
                    hr = OpenConnection();
                    if (SUCCEEDED(hr)) {
                        hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                                adExecuteNoRecords, &pResultRecordSet);
                        if (FAILED(hr)) {
                            ERR((TB,"NotifyDestroy: Failed exec, hr=0x%X", hr));
                        }
                    }
                    else {
                        ERR((TB,"NotifyDestroy: Failed reopen conn, hr=0x%X",
                                hr));
                    }
                }
            }
            else {
                ERR((TB,"NotifyDestroy: Failed add sessid, hr=0x%X", hr));
            }
        }
        else {
            ERR((TB,"NotifyDestroy: Failed add svraddr, hr=0x%X", hr));
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyDestroy: Failed create cmd, hr=0x%X", hr));
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyDisconnectLocalSession
//
// ITSSessionDirectory function. Changes the state of an existing session to
// disconnected. The provided time should be returned in disconnected session
// queries performed by any machine in the server pool.
/****************************************************************************/
HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyDisconnectLocalSession(
        DWORD SessionID,
        FILETIME DiscTime)
{
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyDisconnectLocalSession, SessionID=%u", SessionID));

    hr = CreateADOStoredProcCommand(L"SP_TSSDSetSessionDisconnected",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        hr = AddADOInputDWORDParam(m_ServerID, L"ServerID",
                pCommand, pParameters);
        if (SUCCEEDED(hr)) {
            hr = AddADOInputDWORDParam(SessionID, L"SessionID", pCommand,
                    pParameters);
            if (SUCCEEDED(hr)) {
                hr = AddADOInputDWORDParam(DiscTime.dwLowDateTime,
                        L"DiscTimeLow", pCommand, pParameters);
                if (SUCCEEDED(hr)) {
                    hr = AddADOInputDWORDParam(DiscTime.dwHighDateTime,
                            L"DiscTimeHigh", pCommand, pParameters);
                    if (SUCCEEDED(hr)) {
                        // Execute the command.
                        hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                                adExecuteNoRecords, &pResultRecordSet);
                        if (FAILED(hr)) {
                            // If we've not used the connection for awhile, it
                            // might have been disconnected and the connection
                            // object will be invalid. Attempt a reopen then
                            // reissue the command.
                            TRC2((TB,"NotifyDisc: Failed cmd, hr=0x%X, "
                                    "retrying", hr));
                            m_pConnection->Close();
                            hr = OpenConnection();
                            if (SUCCEEDED(hr)) {
                                hr = pCommand->Execute(NULL, NULL,
                                        adCmdStoredProc | adExecuteNoRecords,
                                        &pResultRecordSet);
                                if (FAILED(hr)) {
                                    ERR((TB,"NotifyDisc: Failed exec, hr=0x%X",
                                            hr));
                                }
                            }
                            else {
                                ERR((TB,"NotifyDisc: Failed reopen conn, "
                                        "hr=0x%X", hr));
                            }
                        }
                    }
                    else {
                        ERR((TB,"NotifyDisconn: Failed add disctimehigh, "
                                "hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"NotifyDisconn: Failed add disctimelow, hr=0x%X",
                            hr));
                }
            }
            else {
                ERR((TB,"NotifyDisconn: Failed add sessid, hr=0x%X", hr));
            }
        }
        else {
            ERR((TB,"NotifyDisconn: Failed add svraddr, hr=0x%X", hr));
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyDisconn: Failed create cmd, hr=0x%X", hr));
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyReconnectLocalSession
//
// ITSSessionDirectory function. Changes the state of an existing session
// from disconnected to connected.
/****************************************************************************/
#define NumReconnParams 6

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyReconnectLocalSession(
        TSSD_ReconnectSessionInfo __RPC_FAR *pReconnInfo)
{
    HRESULT hr;
    HRESULT hrParam[NumReconnParams];
    unsigned i, NumFailed;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyReconnectLocalSession, SessionID=%u",
            pReconnInfo->SessionID));

    hr = CreateADOStoredProcCommand(L"SP_TSSDSetSessionReconnected",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        // Add the 5 parameters.
        hrParam[0] = AddADOInputDWORDParam(m_ServerID,
                L"ServerID", pCommand, pParameters);
        hrParam[1] = AddADOInputDWORDParam(pReconnInfo->SessionID,
                L"SessionID", pCommand, pParameters);
        hrParam[2] = AddADOInputDWORDParam(pReconnInfo->TSProtocol,
                L"TSProtocol", pCommand, pParameters);
        hrParam[3] = AddADOInputDWORDParam(pReconnInfo->ResolutionWidth,
                L"ResWidth", pCommand, pParameters);
        hrParam[4] = AddADOInputDWORDParam(pReconnInfo->ResolutionHeight,
                L"ResHeight", pCommand, pParameters);
        hrParam[5] = AddADOInputDWORDParam(pReconnInfo->ColorDepth,
                L"ColorDepth", pCommand, pParameters);
                
        NumFailed = 0;
        for (i = 0; i < NumReconnParams; i++) {
            if (SUCCEEDED(hrParam[i])) {
                continue;
            }
            else {
                ERR((TB,"NotifyReconn: Failed param create %u", i));
                NumFailed++;
                hr = hrParam[i];
            }
        }
        if (NumFailed == 0) {
            // Execute the command.
            hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                    adExecuteNoRecords, &pResultRecordSet);
            if (FAILED(hr)) {
                // If we've not used the connection for awhile, it might
                // have been disconnected and the connection object will
                // be in a bad state. Close, reopen, and reissue the
                // command.
                TRC2((TB,"NotifyReconn: Failed exec, hr=0x%X, retrying",
                        hr));
                m_pConnection->Close();
                hr = OpenConnection();
                if (SUCCEEDED(hr)) {
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                            adExecuteNoRecords, &pResultRecordSet);
                    if (FAILED(hr)) {
                        ERR((TB,"NotifyReconn: Failed exec, hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"NotifyReconn: Failed reopen conn, hr=0x%X",
                            hr));
                }
            }
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyReconn: Failed create cmd, hr=0x%X", hr));
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::NotifyReconnectPending
//
// ITSSessionDirectory function. Informs session directory that a reconnect
// is pending soon because of a revectoring.  Used by DIS to determine
// when a server might have gone down.  (DIS is the Directory Integrity
// Service, which runs on the machine with the session directory.)
//
// This is a two-phase procedure--we first check the fields, and then we
// add the timestamp only if there is no outstanding timestamp already (i.e., 
// the two Almost-In-Time fields are 0).  This prevents constant revectoring
// from updating the timestamp fields, which would prevent the DIS from 
// figuring out that a server is down.
//
// These two steps are done in the stored procedure to make the operation
// atomic.
/****************************************************************************/
#define NumReconPendParams 3

HRESULT STDMETHODCALLTYPE CTSSessionDirectory::NotifyReconnectPending(
        WCHAR *ServerName)
{
    HRESULT hr;
    HRESULT hrParam[NumReconPendParams];
    unsigned NumFailed, i;

    FILETIME ft;
    SYSTEMTIME st;
    
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    TRC2((TB,"NotifyReconnectPending"));

    ASSERT((ServerName != NULL),(TB,"NotifyReconnectPending: NULL ServerName"));

    // Get the current system time.
    GetSystemTime(&st);
    SystemTimeToFileTime(&st, &ft);

    // Call the stored procedure, which will update the fields if they are 0.
    hr = CreateADOStoredProcCommand(L"SP_TSSDSetServerReconnectPending",
            &pCommand, &pParameters);
    if (SUCCEEDED(hr)) {
        // Add the 3 parameters.
        hrParam[0] = AddADOInputStringParam(ServerName,
                L"ServerAddress", pCommand, pParameters, FALSE);
        hrParam[1] = AddADOInputDWORDParam(ft.dwLowDateTime,
                L"AlmostTimeLow", pCommand, pParameters);
        hrParam[2] = AddADOInputDWORDParam(ft.dwHighDateTime,
                L"AlmostTimeHigh", pCommand, pParameters);

        NumFailed = 0;
        for (i = 0; i < NumReconPendParams; i++) {
            if (SUCCEEDED(hrParam[i])) {
                continue;
            }
            else {
                ERR((TB,"NotifyReconPending: Failed param create %u", i));
                NumFailed++;
                hr = hrParam[i];
            }
        }
        if (NumFailed == 0) {
            // Execute the command.
            hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                    adExecuteNoRecords, &pResultRecordSet);
            if (FAILED(hr)) {
                // If we've not used the connection for awhile, it might
                // have been disconnected and the connection object will
                // be in a bad state. Close, reopen, and reissue the
                // command.
                TRC2((TB,"NotifyReconPending: Failed exec, hr=0x%X, retrying",
                        hr));
                m_pConnection->Close();
                hr = OpenConnection();
                if (SUCCEEDED(hr)) {
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                            adExecuteNoRecords, &pResultRecordSet);
                    if (FAILED(hr)) {
                        ERR((TB,"NotifyReconPending: Failed exec, hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"NotifyReconPending: Failed reopen conn, hr=0x%X",
                            hr));
                }
            }
        }

        pParameters->Release();
        pCommand->Release();
    }
    else {
        ERR((TB,"NotifyReconnectPending: Failed create cmd, hr=0x%X", hr));
    }


    return hr;
}


HRESULT STDMETHODCALLTYPE CTSSessionDirectory::Repopulate(
        DWORD WinStationCount, 
        TSSD_RepopulateSessionInfo *rsi)
{
    return E_NOTIMPL;
}


/****************************************************************************/
// CreateADOStoredProcCommand
//
// Creates and returns a stored proc ADOCommand, plus a ref to its
// associated Parameters.
/****************************************************************************/
HRESULT CTSSessionDirectory::CreateADOStoredProcCommand(
        PWSTR CmdName,
        ADOCommand **ppCommand,
        ADOParameters **ppParameters)
{
    HRESULT hr;
    BSTR CmdStr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;

    CmdStr = SysAllocString(CmdName);
    if (CmdStr != NULL) {
        hr = CoCreateInstance(CLSID_CADOCommand, NULL, CLSCTX_INPROC_SERVER,
                IID_IADOCommand25, (LPVOID *)&pCommand);
        if (SUCCEEDED(hr)) {
            // Set the connection.
            hr = pCommand->putref_ActiveConnection(m_pConnection);
            if (SUCCEEDED(hr)) {
                // Set the command text.
                hr = pCommand->put_CommandText(CmdStr);
                if (SUCCEEDED(hr)) {
                    // Set the command type.
                    hr = pCommand->put_CommandType(adCmdStoredProc);
                    if (SUCCEEDED(hr)) {
                        // Get the Parameters pointer from the Command to
                        // allow appending params.
                        hr = pCommand->get_Parameters(&pParameters);
                        if (FAILED(hr)) {
                            ERR((TB,"Failed getParams for command, "
                                    "hr=0x%X", hr));
                            goto PostCreateCommand;
                        }
                    }
                    else {
                        ERR((TB,"Failed set cmdtype for command, hr=0x%X",
                                hr));
                        goto PostCreateCommand;
                    }
                }
                else {
                    ERR((TB,"Failed set cmdtext for command, hr=0x%X", hr));
                    goto PostCreateCommand;
                }
            }
            else {
                ERR((TB,"Command::putref_ActiveConnection hr=0x%X", hr));
                goto PostCreateCommand;
            }
        }
        else {
            ERR((TB,"CoCreate(Command) returned 0x%X", hr));
            goto PostAllocCmdStr;
        }

        SysFreeString(CmdStr);
    }
    else {
        ERR((TB,"Failed to alloc cmd str"));
        hr = E_OUTOFMEMORY;
        goto ExitFunc;
    }

    *ppCommand = pCommand;
    *ppParameters = pParameters;
    return hr;

// Error handling.

PostCreateCommand:
    pCommand->Release();

PostAllocCmdStr:
    SysFreeString(CmdStr);

ExitFunc:
    *ppCommand = NULL;
    *ppParameters = NULL;
    return hr;
}


/****************************************************************************/
// AddADOInputDWORDParam
//
// Creates and adds to the given ADOParameters object a DWORD-initialized
// parameter value.
/****************************************************************************/
HRESULT CTSSessionDirectory::AddADOInputDWORDParam(
        DWORD Param,
        PWSTR ParamName,
        ADOCommand *pCommand,
        ADOParameters *pParameters)
{
    HRESULT hr;
    CVar varParam;
    BSTR ParamStr;
    ADOParameter *pParam;

    ParamStr = SysAllocString(ParamName);
    if (ParamStr != NULL) {
        varParam.vt = VT_I4;
        varParam.lVal = Param;
        hr = pCommand->CreateParameter(ParamStr, adInteger, adParamInput, -1,
                varParam, &pParam);
        if (SUCCEEDED(hr)) {
            hr = pParameters->Append(pParam);
            if (FAILED(hr)) {
                ERR((TB,"InDWParam: Failed append param %S, hr=0x%X",
                        ParamName, hr));
            }

            // ADO will have its own ref for the param.
            pParam->Release();
        }
        else {
            ERR((TB,"InDWParam: Failed CreateParam %S, hr=0x%X",
                    ParamName, hr));
        }

        SysFreeString(ParamStr);
    }
    else {
        ERR((TB,"InDWParam: Failed alloc paramname"));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/****************************************************************************/
// AddADOInputStringParam
//
// Creates and adds to the given ADOParameters object a WSTR-initialized
// parameter value.
/****************************************************************************/
HRESULT CTSSessionDirectory::AddADOInputStringParam(
        PWSTR Param,
        PWSTR ParamName,
        ADOCommand *pCommand,
        ADOParameters *pParameters,
        BOOL bNullOnNull)
{
    HRESULT hr;
    CVar varParam;
    BSTR ParamStr;
    ADOParameter *pParam;
    int Len;

    ParamStr = SysAllocString(ParamName);
    if (ParamStr != NULL) {
        // ADO does not seem to like accepting string params that are zero
        // length. So, if the string we have is zero length and bNullOnNull says
        // we can, we send a null VARIANT type, resulting in a null value at
        // the SQL server.
        if (wcslen(Param) > 0 || !bNullOnNull) {
            hr = varParam.InitFromWSTR(Param);
            Len = wcslen(Param);
        }
        else {
            varParam.vt = VT_NULL;
            varParam.bstrVal = NULL;
            Len = -1;
            hr = S_OK;
        }

        if (SUCCEEDED(hr)) {
            hr = pCommand->CreateParameter(ParamStr, adVarWChar, adParamInput,
                    Len, varParam, &pParam);
            if (SUCCEEDED(hr)) {
                hr = pParameters->Append(pParam);
                if (FAILED(hr)) {
                    ERR((TB,"InStrParam: Failed append param %S, hr=0x%X",
                            ParamName, hr));
                }

                // ADO will have its own ref for the param.
                pParam->Release();
            }
            else {
                ERR((TB,"InStrParam: Failed CreateParam %S, hr=0x%X",
                        ParamName, hr));
            }
        }
        else {
            ERR((TB,"InStrParam: Failed alloc variant bstr, "
                    "param %S, hr=0x%X", ParamName, hr));
        }

        SysFreeString(ParamStr);
    }
    else {
        ERR((TB,"InStrParam: Failed alloc paramname"));
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::ExecServerOnline
//
// Encapsulates creation and execution of the SP_TSSDServerOnline
// stored procedure on the server. Assumes that m_ClusterName is already set.
/****************************************************************************/
HRESULT CTSSessionDirectory::ExecServerOnline()
{
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;
    CVar varRows;
    CVar varFields;
    CVar varStart;
    long NumRecords;

    if (m_pConnection != NULL) {
        // Create the command.
        hr = CreateADOStoredProcCommand(L"SP_TSSDServerOnline", &pCommand,
                &pParameters);
        if (SUCCEEDED(hr)) {
            // Server name param.
            hr = AddADOInputStringParam(m_LocalServerAddress,
                    L"ServerAddress", pCommand, pParameters, FALSE);
            if (SUCCEEDED(hr)) {
                // Cluster name param.
                hr = AddADOInputStringParam(m_ClusterName,
                        L"ClusterName", pCommand, pParameters, TRUE);
                if (SUCCEEDED(hr)) {
                    // Execute the command.
                    hr = pCommand->Execute(NULL, NULL, adCmdStoredProc,
                            &pResultRecordSet);
                    if (SUCCEEDED(hr)) {
                        TRC2((TB,"ExecOn: Success"));
                    }
                    else {
                        ERR((TB,"Failed exec ServerOnline, hr=0x%X", hr));
                    }
                }
                else {
                    ERR((TB,"ExecOn: Failed adding ClusterName, hr=0x%X", hr));
                }
            }
            else {
                ERR((TB,"ExecOn: Failed adding ServerAddress, hr=0x%X",
                        hr));
            }

            pParameters->Release();
            pCommand->Release();
        }
        else {
            ERR((TB,"ExecOn: Failed create command, hr=0x%X", hr));
        }
    }
    else {
        ERR((TB,"ExecOn: Connection invalid"));
        hr = E_FAIL;
    }

    // Parse out the ServerID and ClusterID from the result recordset.
    if (SUCCEEDED(hr)) {
        long State;

        hr = pResultRecordSet->get_State(&State);
        if (SUCCEEDED(hr)) {
            if (!(State & adStateClosed)) {
                VARIANT_BOOL VB;

                // If EOF the recordset is empty.
                hr = pResultRecordSet->get_EOF(&VB);
                if (SUCCEEDED(hr)) {
                    if (VB) {
                        TRC1((TB,"ExecOnline: Result recordset EOF"));
                        hr = E_FAIL;
                        goto PostUnpackResultSet;
                    }
                }
                else {
                    ERR((TB,"GetUserDisc: Failed get_EOF, hr=0x%X", hr));
                    goto PostUnpackResultSet;
                }
            }
            else {
                ERR((TB,"GetUserDisc: Closed result recordset"));
                hr = E_FAIL;
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"GetUserDisc: get_State failed, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }

        // Grab the result data into a safearray, starting with the default
        // current row and all fields.
        varStart.InitNoParam();
        varFields.InitNoParam();
        hr = pResultRecordSet->GetRows(1, varStart, varFields, &varRows);
        if (SUCCEEDED(hr)) {
            NumRecords = 0;
            hr = SafeArrayGetUBound(varRows.parray, 2, &NumRecords);
            if (SUCCEEDED(hr)) {
                // 0-based array bound was returned, num rows is that + 1.
                NumRecords++;
                ASSERT((NumRecords == 1),
                        (TB,"ExecOnline: NumRecords %u != expected %u",
                        NumRecords, 1));

                TRC1((TB,"%d rows retrieved from safearray", NumRecords));
            }
            else {
                ERR((TB,"ExecOnline: Failed safearray getubound, hr=0x%X", hr));
                goto PostUnpackResultSet;
            }
        }
        else {
            ERR((TB,"ExecOnline: Failed to get rows, hr=0x%X", hr));
            goto PostUnpackResultSet;
        }

        // Get the fields.
        hr = GetRowArrayDWORDField(varRows.parray, 0, 0, &m_ServerID);
        if (SUCCEEDED(hr)) {
            hr = GetRowArrayDWORDField(varRows.parray, 0, 1, &m_ClusterID);
            if (FAILED(hr)) {
                ERR((TB,"ExecOnline: Failed retrieve ClusterID, hr=0x%X", hr));
            }
        }
        else {
            ERR((TB,"ExecOnline: Failed retrieve ServerID, hr=0x%X", hr));
        }

PostUnpackResultSet:
        pResultRecordSet->Release();
    }

    return hr;
}


/****************************************************************************/
// CTSSessionDirectory::ExecServerOffline
//
// Encapsulates creation and execution of the SP_TSSDServerOffline
// stored procedure on the server.
/****************************************************************************/
HRESULT CTSSessionDirectory::ExecServerOffline()
{
    HRESULT hr;
    ADOCommand *pCommand;
    ADOParameters *pParameters;
    ADORecordset *pResultRecordSet;

    if (m_pConnection != NULL) {
        // Create the command.
        hr = CreateADOStoredProcCommand(L"SP_TSSDServerOffline", &pCommand,
                &pParameters);
        if (SUCCEEDED(hr)) {
            // On an offline request, we need fast turn-around since we're
            // likely being called when the system is going down. Set the
            // timeout value for the command to 2 seconds.
            pCommand->put_CommandTimeout(2);

            hr = AddADOInputDWORDParam(m_ServerID,
                    L"ServerID", pCommand, pParameters);
            if (SUCCEEDED(hr)) {
                // Execute the command.
                hr = pCommand->Execute(NULL, NULL, adCmdStoredProc |
                        adExecuteNoRecords, &pResultRecordSet);
                if (SUCCEEDED(hr)) {
                    TRC2((TB,"ExecOff: Success"));
                }
                else {
                    ERR((TB,"Failed exec ServerOffline, hr=0x%X", hr));
                }
            }
            else {
                ERR((TB,"ExecOnOff: Failed adding ServerAddress, hr=0x%X",
                        hr));
            }

            pParameters->Release();
            pCommand->Release();
        }
        else {
            ERR((TB,"ExecOff: Failed create command, hr=0x%X", hr));
        }
    }
    else {
        ERR((TB,"ExecOff: Connection invalid"));
        hr = E_FAIL;
    }

    return hr;
}


/* ------------------------------------------------------------------------
   Plug-in UI interface for TSCC
   ------------------------------------------------------------------------*/


/* -------------------------------------------------------------------------------
 * describes the name of this entry in server settins
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::GetAttributeName(/* out */ WCHAR *pwszAttribName)
{
    TCHAR szAN[256];

    ASSERT((pwszAttribName != NULL),(TB,"NULL attrib ptr"));
    LoadString(g_hInstance, IDS_ATTRIBUTE_NAME, szAN, sizeof(szAN) / sizeof(TCHAR));
    lstrcpy(pwszAttribName, szAN);
    return S_OK;
}


/* -------------------------------------------------------------------------------
 * for this component the attribute value would indicate if its enabled or not
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::GetDisplayableValueName(
        /* out */WCHAR *pwszAttribValueName)
{
    TCHAR szAvn[256];    

    ASSERT((pwszAttribValueName != NULL),(TB,"NULL attrib ptr"));

    m_fEnabled = IsSessionDirectoryEnabled();
    if (m_fEnabled)
        LoadString(g_hInstance, IDS_ENABLE, szAvn, sizeof(szAvn) / sizeof(TCHAR));
    else
        LoadString(g_hInstance, IDS_DISABLE, szAvn, sizeof(szAvn) / sizeof(TCHAR));

    lstrcpy(pwszAttribValueName, szAvn);

    return S_OK;
}


/* -------------------------------------------------------------------------------
 * Custom UI provided here
 * pdwStatus informs Terminal Service Config to update termsrv
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::InvokeUI( /* in */ HWND hParent , /* out */ PDWORD pdwStatus )
{
    INT_PTR iRet = DialogBoxParam(g_hInstance, MAKEINTRESOURCE(IDD_DIALOG_SDS),
            hParent, CustomUIDlg, (LPARAM)this);

    TRC1((TB,"DialogBox returned 0x%x", iRet));

    *pdwStatus = ( DWORD )iRet;

    return S_OK;
}


/* -------------------------------------------------------------------------------
 * Custom menu items -- must be freed by LocalFree
 * this is called everytime the user right clicks the listitem
 * so you can alter the settings ( i.e. enable to disable and vice versa )
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::GetMenuItems(
        /* out */ int *pcbItems,
        /* out */ PMENUEXTENSION *pMex)
{
    ASSERT((pcbItems != NULL),(TB,"NULL items ptr"));

    *pcbItems = 2;

    *pMex = ( PMENUEXTENSION )LocalAlloc( LMEM_FIXED, *pcbItems * sizeof( MENUEXTENSION ) );

    if( *pMex != NULL )
    {
        // display enable or disable
        if( m_fEnabled )
        {
            LoadString(g_hInstance, IDS_DISABLE, (*pMex)[0].MenuItemName,
                    sizeof((*pMex)[0].MenuItemName) / sizeof(WCHAR));
        }
        else
        {
            LoadString(g_hInstance, IDS_ENABLE, (*pMex)[0].MenuItemName,
                    sizeof((*pMex)[0].MenuItemName) / sizeof(WCHAR));
        }
        
        LoadString(g_hInstance, IDS_DESCRIP_ENABLE, (*pMex)[0].StatusBarText,
                sizeof((*pMex)[0].StatusBarText) / sizeof(WCHAR));

        // menu items id -- this id will be passed back to u in ExecMenuCmd

        (*pMex)[0].cmd = IDM_MENU_ENABLE;

        LoadString(g_hInstance, IDS_PROPERTIES,  (*pMex)[1].MenuItemName,
                sizeof((*pMex)[1].MenuItemName) / sizeof(WCHAR));

        LoadString(g_hInstance, IDS_DESCRIP_PROPS, (*pMex)[1].StatusBarText,
                sizeof((*pMex)[1].StatusBarText) / sizeof(WCHAR));

        // menu items id -- this id will be passed back to u in ExecMenuCmd
        (*pMex)[1].cmd = IDM_MENU_PROPS;

        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}


/* -------------------------------------------------------------------------------
 * When the user selects a menu item the cmd id is passed to this component.
 * the provider ( which is us )
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::ExecMenuCmd(
        /* in */ UINT cmd,
        /* in */ HWND hParent ,
        /* out*/ PDWORD pdwStatus )
{
    switch (cmd) {
        case IDM_MENU_ENABLE:
            m_fEnabled = m_fEnabled ? 0 : 1;
            TRC1((TB,"%ws was selected", m_fEnabled ? L"Disable" : L"Enable"));
            if( SetSessionDirectoryState( m_fEnabled ) == ERROR_SUCCESS )
            {
                *pdwStatus = UPDATE_TERMSRV_SESSDIR;
            }
            break;

        case IDM_MENU_PROPS:
            INT_PTR iRet = DialogBoxParam(g_hInstance,
                    MAKEINTRESOURCE(IDD_DIALOG_SDS),
                    hParent,
                    CustomUIDlg,
                    (LPARAM)this);

            *pdwStatus = ( DWORD )iRet;
    }

    return S_OK;
}


/* -------------------------------------------------------------------------------
 * Tscc provides a default help menu item,  when selected this method is called
 * if we want tscc to handle ( or provide ) help return any value other than zero
 * for those u can't follow logic return zero if you're handling help.
 * -------------------------------------------------------------------------------
 */
STDMETHODIMP CTSSessionDirectory::OnHelp( /* out */ int *piRet)
{
    ASSERT((piRet != NULL),(TB,"NULL ret ptr"));
    *piRet = 0;
    return S_OK;
}


/* -------------------------------------------------------------------------------
 * IsSessionDirectoryEnabled returns a bool
 * -------------------------------------------------------------------------------
 */
BOOL CTSSessionDirectory::IsSessionDirectoryEnabled()
{
    LONG lRet;
    HKEY hKey;
    DWORD dwEnabled = 0;
    DWORD dwSize = sizeof(DWORD);
    
    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
            REG_CONTROL_TSERVER,
            0,
            KEY_READ,
            &hKey);

    if (lRet == ERROR_SUCCESS)
    {
        lRet = RegQueryValueEx( hKey ,
                                REG_TS_SESSDIRACTIVE,
                                NULL ,
                                NULL ,
                                ( LPBYTE )&dwEnabled ,
                                &dwSize );

        RegCloseKey( hKey );
    }  

    return ( BOOL )dwEnabled;
}


/* -------------------------------------------------------------------------------
 * SetSessionDirectoryState - sets SessionDirectoryActive regkey to bVal
 * -------------------------------------------------------------------------------
 */
DWORD CTSSessionDirectory::SetSessionDirectoryState( BOOL bVal )
{
    LONG lRet;
    HKEY hKey;
    DWORD dwSize = sizeof( DWORD );
    
    lRet = RegOpenKeyEx( 
                        HKEY_LOCAL_MACHINE ,
                        REG_CONTROL_TSERVER ,
                        0,
                        KEY_WRITE,
                        &hKey );
    if (lRet == ERROR_SUCCESS)
    {
        lRet = RegSetValueEx( hKey ,
                              REG_TS_SESSDIRACTIVE,
                              0,
                              REG_DWORD ,
                              ( LPBYTE )&bVal ,
                              dwSize );
        
        RegCloseKey( hKey );
    } 
    else
    {
        ErrorMessage( NULL , IDS_ERROR_TEXT3 , ( DWORD )lRet );
    }

    return ( DWORD )lRet;
}


/* -------------------------------------------------------------------------------
 * ErrorMessage --
 * -------------------------------------------------------------------------------
 */
void CTSSessionDirectory::ErrorMessage( HWND hwnd , UINT res , DWORD dwStatus )
{
    TCHAR tchTitle[ 64 ];
    TCHAR tchText[ 64 ];
    TCHAR tchErrorMessage[ 256 ];
    LPTSTR pBuffer = NULL;
    
    // report error
    ::FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
            FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,                                         //ignored
            ( DWORD )dwStatus,                            //message ID
            MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),  //message language
            (LPTSTR)&pBuffer,                             //address of buffer pointer
            0,                                            //minimum buffer size
            NULL);  
    
    LoadString(g_hInstance, IDS_ERROR_TITLE, tchTitle, sizeof(tchTitle) / sizeof(TCHAR));
    LoadString(g_hInstance, res, tchText, sizeof(tchText) / sizeof(TCHAR));
    wsprintf( tchErrorMessage , tchText , pBuffer );
    ::MessageBox(hwnd, tchErrorMessage, tchTitle, MB_OK | MB_ICONINFORMATION);
}


/* -------------------------------------------------------------------------------
 * Custom UI msg handler dealt with here
 * -------------------------------------------------------------------------------
 */
INT_PTR CALLBACK CustomUIDlg(HWND hwnd, UINT umsg, WPARAM wp, LPARAM lp)
{
    static BOOL s_fServerNameChanged;
    static BOOL s_fClusterNameChanged;
    static BOOL s_fOpaqueStringChanged;
    static BOOL s_fPreviousButtonState;

    CTSSessionDirectory *pCTssd;

    switch (umsg)
    {
        case WM_INITDIALOG:
        {
            pCTssd = ( CTSSessionDirectory * )lp;

            SetWindowLongPtr( hwnd , DWLP_USER , ( LONG_PTR )pCTssd );

            SendMessage( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) ,
                    EM_LIMITTEXT ,
                    ( WPARAM )64 ,
                    0 );
            SendMessage( GetDlgItem( hwnd , IDC_EDIT_CLUSTERNAME ) ,
                    EM_LIMITTEXT ,
                    ( WPARAM )64 ,
                    0 );
            SendMessage( GetDlgItem( hwnd , IDC_EDIT_ACCOUNTNAME ) ,
                    EM_LIMITTEXT ,
                    ( WPARAM )64 ,
                    0 );
            SendMessage( GetDlgItem( hwnd , IDC_EDIT_PASSWORD ) ,
                    EM_LIMITTEXT ,
                    ( WPARAM )64 ,
                    0 );
                 
            LONG lRet;
            HKEY hKey;
            
            TCHAR szString[ 256 ];
            DWORD cbData = sizeof( szString );

            lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                    REG_TS_CLUSTERSETTINGS ,
                    0,
                    KEY_READ | KEY_WRITE , 
                    &hKey );
            if( lRet == ERROR_SUCCESS )
            {
                lRet = RegQueryValueEx(hKey ,
                        REG_TS_CLUSTER_STORESERVERNAME,
                        NULL , 
                        NULL ,
                        ( LPBYTE )szString , 
                        &cbData );
                if( lRet == ERROR_SUCCESS )
                {
                    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) , szString );
                }
            
                cbData = sizeof( szString );

                lRet = RegQueryValueEx(hKey,
                        REG_TS_CLUSTER_CLUSTERNAME,
                        NULL,
                        NULL,
                        (LPBYTE)szString,
                        &cbData);           
                if( lRet == ERROR_SUCCESS )
                {
                    SetWindowText(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), szString);
                }

                cbData = 0;                

                lRet = RegQueryValueEx( hKey ,
                        REG_TS_CLUSTER_OPAQUESETTINGS,
                        NULL , 
                        NULL ,
                        (LPBYTE)NULL,
                        &cbData);

                if( lRet == ERROR_SUCCESS )
                {
                    pCTssd->m_pszOpaqueString =  ( LPTSTR )LocalAlloc( LMEM_FIXED , cbData );

                    if( pCTssd->m_pszOpaqueString != NULL )
                    {
                        lRet = RegQueryValueEx( hKey ,
                            REG_TS_CLUSTER_OPAQUESETTINGS,
                            NULL , 
                            NULL ,
                            (LPBYTE)pCTssd->m_pszOpaqueString ,
                            &cbData );
                    }
                    else
                    {
                        lRet = ERROR_OUTOFMEMORY;
                    }
                }                    

                if( lRet == ERROR_SUCCESS )
                {
                    // jump to user_id
                    TCHAR tchUserId[64] = { 0 };
                    TCHAR tchPassword[64] = { 0 };

                    LPTSTR pszUserId = tchUserId;
                    LPTSTR pszPassword = tchPassword;
                    
                    FindSqlValue( pCTssd->m_pszOpaqueString , TEXT("User Id"), pszUserId );
                    
                    strtrim( &pszUserId );                    

                    FindSqlValue( pCTssd->m_pszOpaqueString , TEXT("Password"), pszPassword );

                    strtrim( &pszPassword );                    
                     
                    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_ACCOUNTNAME ) , pszUserId );
                    SetWindowText( GetDlgItem( hwnd , IDC_EDIT_PASSWORD ) , pszPassword );
                } 

                RegCloseKey(hKey);
            }
            else
            {
                if( pCTssd != NULL )
                {
                    pCTssd->ErrorMessage( hwnd , IDS_ERROR_TEXT , ( DWORD )lRet );
                }
                
                EndDialog(hwnd, lRet);                
            }

            if( pCTssd != NULL )
            {
                BOOL bEnable;
                
                bEnable = pCTssd->IsSessionDirectoryEnabled();

                CheckDlgButton( hwnd , IDC_CHECK_ENABLE , bEnable ? BST_CHECKED : BST_UNCHECKED );
                
                s_fPreviousButtonState = bEnable;

                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_SERVERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_CLUSTERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_ACCOUNTNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_EDIT_PASSWORD), bEnable);      
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_SQLNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_CLUSTERNAME), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_SQLACCOUNT), bEnable);
                EnableWindow(GetDlgItem(hwnd, IDC_STATIC_SQLPWD), bEnable);
            }

            s_fServerNameChanged = FALSE;
            s_fClusterNameChanged = FALSE;
            s_fOpaqueStringChanged = FALSE;    
        }

        break;

                            
        case WM_COMMAND:
            if( LOWORD( wp ) == IDCANCEL )
            {
                pCTssd = ( CTSSessionDirectory * )GetWindowLongPtr( hwnd , DWLP_USER );

                if( pCTssd->m_pszOpaqueString != NULL )
                {
                    LocalFree( pCTssd->m_pszOpaqueString );
                }

                EndDialog(hwnd , 0);
            }
            else if( LOWORD( wp ) == IDOK )
            {
                BOOL bEnabled;

                DWORD dwRetStatus = 0;

                pCTssd = ( CTSSessionDirectory * )GetWindowLongPtr(hwnd, DWLP_USER);
                bEnabled = IsDlgButtonChecked( hwnd , IDC_CHECK_ENABLE ) == BST_CHECKED;

                if( bEnabled != s_fPreviousButtonState )
                {
                    DWORD dwStatus;

                    TRC1((TB,"EnableButtonChanged"));
                    dwStatus = pCTssd->SetSessionDirectoryState( bEnabled );
                    if( dwStatus != ERROR_SUCCESS )
                    {
                        return 0;
                    }

                    dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                }

                if( s_fServerNameChanged || s_fClusterNameChanged || s_fOpaqueStringChanged )
                {
                    HKEY hKey;

                    LONG lRet = RegOpenKeyEx( HKEY_LOCAL_MACHINE ,
                            REG_TS_CLUSTERSETTINGS ,
                            0,
                            KEY_READ | KEY_WRITE , 
                            &hKey );
                    
                    if( lRet == ERROR_SUCCESS )
                    {
                        TCHAR szName[ 64 ];

                        if( s_fServerNameChanged )
                        {
                            TRC1((TB,"SQLServerNameChanged" )) ;
                    
                            GetWindowText( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) , szName , sizeof( szName ) / sizeof( TCHAR )  );

                            RegSetValueEx( hKey ,
                                REG_TS_CLUSTER_STORESERVERNAME,
                                0,
                                REG_SZ,
                                ( CONST LPBYTE )szName ,
                                sizeof( szName ) );
                        }

                        if( s_fClusterNameChanged )
                        {
                            TRC1((TB,"ClusterNameChanged"));
                    
                            GetWindowText( GetDlgItem( hwnd , IDC_EDIT_CLUSTERNAME ) , szName , sizeof( szName ) / sizeof( TCHAR )  );

                            RegSetValueEx( hKey ,
                                REG_TS_CLUSTER_CLUSTERNAME,
                                0,
                                REG_SZ,
                                ( CONST LPBYTE )szName ,
                                sizeof( szName ) );
                        }
                        if( s_fOpaqueStringChanged )
                        {
                            TRC1((TB,"OpaqueStringChanged" )) ;  
                            
                            LPTSTR pszNewOpaqueString = NULL;

                            LPTSTR pszName = NULL;
                                                        
                            GetWindowText( GetDlgItem( hwnd , IDC_EDIT_ACCOUNTNAME ) , szName , sizeof( szName ) / sizeof( TCHAR )  );

                            pszName = szName;

                            strtrim( &pszName );

                            ModifySqlValue( &pCTssd->m_pszOpaqueString , L"User Id" , pszName );

                            GetWindowText( GetDlgItem( hwnd , IDC_EDIT_PASSWORD ) , szName , sizeof( szName ) / sizeof( TCHAR )  );

                            pszName = szName;

                            strtrim( &pszName );

                            if( ModifySqlValue( &pCTssd->m_pszOpaqueString , L"Password" , pszName ) != NULL )
                            {
                                RegSetValueEx( hKey ,
                                        REG_TS_CLUSTER_OPAQUESETTINGS,
                                        0,
                                        REG_SZ,
                                        ( CONST LPBYTE )pCTssd->m_pszOpaqueString ,
                                        lstrlen( pCTssd->m_pszOpaqueString ) * sizeof( TCHAR ) );
                            }
                        }

                        RegCloseKey(hKey);

                        dwRetStatus = UPDATE_TERMSRV_SESSDIR;
                    }
                    else
                    {
                        pCTssd->ErrorMessage(hwnd , IDS_ERROR_TEXT2 , (DWORD)lRet);
                        return 0;
                    }
                }

                if( pCTssd->m_pszOpaqueString != NULL )
                {
                    LocalFree( pCTssd->m_pszOpaqueString );
                }

                EndDialog( hwnd , ( INT_PTR )dwRetStatus );
            }
            else 
            {
                switch (HIWORD(wp)) 
                {            
                    case EN_CHANGE:
                        if( LOWORD( wp ) == IDC_EDIT_SERVERNAME )
                        {
                            s_fServerNameChanged = TRUE;
                        }
                        else if( LOWORD( wp ) == IDC_EDIT_CLUSTERNAME )
                        {
                            s_fClusterNameChanged = TRUE;
                        }
                        else if( LOWORD( wp ) == IDC_EDIT_ACCOUNTNAME || LOWORD( wp ) == IDC_EDIT_PASSWORD )
                        {
                            s_fOpaqueStringChanged = TRUE;
                        }                
                        break;

                    case BN_CLICKED:
                        if( LOWORD( wp ) == IDC_CHECK_ENABLE)
                        {
                            BOOL bEnable;

                            if( IsDlgButtonChecked( hwnd , IDC_CHECK_ENABLE ) == BST_CHECKED )
                            {
                                // enabled all controls
                                bEnable = TRUE;
                            }
                            else
                            {
                                // disable all controls
                                bEnable = FALSE;                       
                            }
                            
                            // set flags 
                            s_fServerNameChanged = bEnable;
                            s_fClusterNameChanged = bEnable;
                            s_fOpaqueStringChanged = bEnable;

                            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_SERVERNAME ) , bEnable );
                            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_CLUSTERNAME ) , bEnable );
                            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_ACCOUNTNAME ) , bEnable );
                            EnableWindow( GetDlgItem( hwnd , IDC_EDIT_PASSWORD ) , bEnable );      
                            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_SQLNAME ) , bEnable );
                            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_CLUSTERNAME ) , bEnable ); 
                            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_SQLACCOUNT ) , bEnable ); 
                            EnableWindow( GetDlgItem( hwnd , IDC_STATIC_SQLPWD ) , bEnable ); 

                        }
                        break;
                }
            }        

            break;
    }

    return 0;
}


HRESULT STDMETHODCALLTYPE CTSSessionDirectory::PingSD(PWCHAR pszServerName)
{
    pszServerName;
    // Not implemented
    return E_NOTIMPL;
}

/********************************************************************************************
 [in ] lpString is the buffer containing the OpaqueSettings
 [in ] lpKeyName is the field name within the OpaqueSettings string
 [out] pszValue is a buffer that will contain the field name value

 Ret: None
 *******************************************************************************************/
void FindSqlValue(LPTSTR lpString, LPTSTR lpKeyName, LPTSTR pszValue)
{    
    int i;

    LPTSTR lpszStart = lpString;
    LPTSTR lpszTemp;

    UINT nKeyName;

    if( lpString != NULL && lpKeyName != NULL )
    {
        // find field name

        lpString = FindField( lpString , lpKeyName );

        if( *lpString != 0 )
        {
            i = 0;

            while( *lpString != 0 && *lpString != ( TCHAR )';' )
            {
                pszValue[i] = *lpString;
                i++;
                lpString++;            
            }

            pszValue[ i ] = 0;
        }
    }
}
        
/********************************************************************************************

 [in/out ] lpszOpaqueSettings is the buffer containing the OpaqueSettings
 [in ] lpKeyName is the field name within the OpaqueSettings string
 [in ] lpszNewValue contains the value that will replace the original value in the field

 Ret: A new OpaqueSetting string is constructed and must be freed with LocalFree

********************************************************************************************/
LPTSTR ModifySqlValue( LPTSTR* lppszOpaqueSettings , LPTSTR lpszKeyName , LPTSTR lpszNewValue )
{
    LPTSTR szEndPos       = NULL;
    LPTSTR szSecondPos    = NULL;
    LPTSTR pszNewSettings = NULL;
    LPTSTR lpszOpaqueSettings = *lppszOpaqueSettings;
    LPTSTR pszTempSettings = lpszOpaqueSettings;    
    UINT cbSize = 0;
    
    //a ) find value
    //b ) set pos2 after ';'
    //c ) set endpos1 after '='  to null
    //d ) create a buffer the length of first string + value + ; + second string
    //e ) strcpy first string + value + ; + second string
    //f ) return buffer

    if( lpszKeyName != NULL && lpszOpaqueSettings != NULL  )
    {
        
        szEndPos = FindField( lpszOpaqueSettings , lpszKeyName );

        if( *szEndPos != 0 )
        {            
            lpszOpaqueSettings = szEndPos;

            while( *lpszOpaqueSettings != 0 ) 
            {
                if( *lpszOpaqueSettings == ( TCHAR )';' )
                {
                    szSecondPos = lpszOpaqueSettings + 1;

                    break;
                }

                lpszOpaqueSettings++;
            }                   

            *szEndPos = 0;

            cbSize = lstrlen( pszTempSettings );

            cbSize += lstrlen( lpszNewValue );

            cbSize += 2; // for the semicolon and null

            if( szSecondPos != NULL && *szSecondPos != 0 )
            {
                cbSize += lstrlen( szSecondPos );
            }

            pszNewSettings = ( LPTSTR )LocalAlloc( LMEM_FIXED , cbSize * sizeof( TCHAR ) );

            if( pszNewSettings != NULL )
            {
                lstrcpy( pszNewSettings , pszTempSettings );

                lstrcat( pszNewSettings , lpszNewValue );

                lstrcat( pszNewSettings , TEXT( ";" ) );

                if( szSecondPos != NULL )
                {
                    lstrcat( pszNewSettings , szSecondPos );
                }

                LocalFree( pszTempSettings );

                *lppszOpaqueSettings = pszNewSettings;                                    
            }                    

        }
        else
        {
            // we're here because either the field name didnot exist or is unattainable
            // so we're slapping the field name and value at the end.

            cbSize = lstrlen( pszTempSettings );

            // add the size of the keyname and = and ;
            cbSize += lstrlen( lpszKeyName ) + 2;

            // add the new value
            cbSize += lstrlen( lpszNewValue ) + 1;

            pszNewSettings = ( LPTSTR )LocalAlloc( LMEM_FIXED , cbSize * sizeof( TCHAR ) );

            if( pszNewSettings != NULL )
            {
                lstrcpy( pszNewSettings , pszTempSettings );
                lstrcat( pszNewSettings , lpszKeyName );
                lstrcat( pszNewSettings , TEXT( "=" ) );
                lstrcat( pszNewSettings , lpszNewValue );
                lstrcat( pszNewSettings , TEXT( ";" ) );

                LocalFree( pszTempSettings );

                *lppszOpaqueSettings = pszNewSettings;                    
            }

        }
    }

    return pszNewSettings;
}

/********************************************************************************************
 FindField -- greps the OpaqueString passed in
   pszString and searches for field name in pszKeyName

  [ in ] pszString - OpaqueString
  [ in ] pszKeyName - field name

  ret: the position of the field value ( after the " = " )

 *******************************************************************************************/
LPTSTR FindField( LPTSTR pszString , LPTSTR pszKeyName )
{
    LPTSTR lpszStart = pszString;
    LPTSTR lpszTemp;
    LPTSTR lpszFieldName;

    UINT nKeyName;

    // find field name

    nKeyName = lstrlen( pszKeyName );

    while( *pszString != 0 )
    {
        while( *pszString != 0 && *pszString != ( TCHAR )'=' )
        {            
            pszString++;
        }

        // ok move backwards to check for name
        if( *pszString != 0 )
        {
            lpszTemp = pszString - 1;            

            while(  lpszStart <= lpszTemp )
            {               

                if( IsCharAlphaNumeric( *lpszTemp ) )
                {
                    break;
                }

                lpszTemp--;
            }

            lpszFieldName = ( lpszTemp - nKeyName + 1 );            

            if( lpszStart <= lpszFieldName && _tcsncicmp( lpszFieldName , pszKeyName , nKeyName ) == 0 )
            {
                // found the name skip '='                
                pszString++;
                break;
            }
        }

        pszString++;
    }

    return pszString;
}

/*********************************************************************************************
 * borrowed from Ting Cai (tingcai) with slight modifications
 * net\upnp\ssdp\common\ssdpparser\parser.cpp
 *
 ********************************************************************************************/    
VOID strtrim( TCHAR **pszStr)
{

    TCHAR *end;
    TCHAR *begin;

    begin = *pszStr;
    end = begin + lstrlen( *pszStr ) - 1;

    while (*begin == ( TCHAR )' ' || *begin == ( TCHAR )'\t')
    {
        begin++;
    }

    *pszStr = begin;

    while (*end == ( TCHAR )' ' || *end == ( TCHAR )'\t')
    {
        end--;
    }

    *(end+1) = '\0';    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\assertbreak.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  AssertBreak.h
//
//  Purpose: AssertBreak macro definition
//
//***************************************************************************

#if _MSC_VER > 1000
#pragma once
#endif

#ifndef _ASSERT_BREAK_HMH_
#define _ASSERT_BREAK_HMH_

// Needed to add L to the __FILE__
#define __FRT2(x)      L ## x
#define _FRT2(x)       __FRT2(x)

// We'll need both of these values in case we're running in NT.
// Since our project is not an NT-only project, these are #ifdefd
// out of windows.h

#ifndef _WIN32_WINNT
#define MB_SERVICE_NOTIFICATION          0x00200000L
#define MB_SERVICE_NOTIFICATION_NT3X     0x00040000L
#endif

void WINAPI assert_break( LPCWSTR pszReason, LPCWSTR pszFilename, int nLine );

#if (defined DEBUG || defined _DEBUG)
#define ASSERT_BREAK(exp)    \
    if (!(exp)) { \
        assert_break( _FRT2(#exp), _FRT2(__FILE__), __LINE__ ); \
    }
#else
#define ASSERT_BREAK(exp)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdsql\tssdsql.h ===
/****************************************************************************/
// tssdsql.h
//
// Terminal Server Session Directory Interface SQL provider header.
//
// Copyright (C) 2000 Microsoft Corporation
/****************************************************************************/
#ifndef __TSSDSQL_H
#define __TSSDSQL_H

#include <tchar.h>

#include "tssd.h"
#include "srvsetex.h"


/****************************************************************************/
// Defines
/****************************************************************************/

/****************************************************************************/
// Types
/****************************************************************************/

// CTSSessionDirectory
//
// C++ class instantiation of ITSSessionDirectory.
class CTSSessionDirectory : public ITSSessionDirectory , public IExtendServerSettings
{
    long m_RefCount;
    BSTR m_DBConnectStr;
    BSTR m_DBPwdStr;
    BSTR m_DBUserStr;

    ADOConnection *m_pConnection;
    DWORD m_ServerID;
    DWORD m_ClusterID;

    WCHAR m_LocalServerAddress[64];
    WCHAR m_ClusterName[64];

    // Private data for UI menus

    // WCHAR m_szDisableEnable[ 64 ];
    BOOL m_fEnabled;

    // Private utility functions.
    HRESULT AddADOInputDWORDParam(DWORD, PWSTR, ADOCommand *, ADOParameters *);
    HRESULT AddADOInputStringParam(PWSTR, PWSTR, ADOCommand *,
            ADOParameters *, BOOL = TRUE);
    HRESULT CreateADOStoredProcCommand(PWSTR, ADOCommand **, ADOParameters **);

    HRESULT ExecServerOnline();
    HRESULT ExecServerOffline();

    HRESULT OpenConnection();

public:
    CTSSessionDirectory();
    ~CTSSessionDirectory();

    // Standard COM methods
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID, void **);
    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();

    // ITSSessionDirectory COM interface
    HRESULT STDMETHODCALLTYPE Initialize(LPWSTR, LPWSTR, LPWSTR, LPWSTR,
            DWORD, DWORD (*)(), DWORD (*)(DWORD));
    HRESULT STDMETHODCALLTYPE Update(LPWSTR, LPWSTR, LPWSTR, LPWSTR, DWORD, BOOL);
    HRESULT STDMETHODCALLTYPE GetUserDisconnectedSessions(LPWSTR, LPWSTR,
            DWORD __RPC_FAR *, TSSD_DisconnectedSessionInfo __RPC_FAR
            [TSSD_MaxDisconnectedSessions]);
    HRESULT STDMETHODCALLTYPE NotifyCreateLocalSession(
            TSSD_CreateSessionInfo __RPC_FAR *);
    HRESULT STDMETHODCALLTYPE NotifyDestroyLocalSession(DWORD);
    HRESULT STDMETHODCALLTYPE NotifyDisconnectLocalSession(DWORD, FILETIME);

    HRESULT STDMETHODCALLTYPE NotifyReconnectLocalSession(
            TSSD_ReconnectSessionInfo __RPC_FAR *);
    HRESULT STDMETHODCALLTYPE NotifyReconnectPending(WCHAR *);
    HRESULT STDMETHODCALLTYPE Repopulate(DWORD, TSSD_RepopulateSessionInfo *);
    HRESULT STDMETHODCALLTYPE PingSD(PWCHAR pszServerName);
    HRESULT STDMETHODCALLTYPE WaitForRepopulate(DWORD dwTimeOut) { return E_NOTIMPL; }


    // IExtendServerSettings COM interface
    STDMETHOD( GetAttributeName )( /* out */ WCHAR * pwszAttribName );
    STDMETHOD( GetDisplayableValueName )( /* out */WCHAR * pwszAttribValueName );
    STDMETHOD( InvokeUI )( /* in */ HWND hParent , /* out */ PDWORD pdwStatus );
    STDMETHOD( GetMenuItems )( /* out */ int * pcbItems , /* out */ PMENUEXTENSION *pMex );
    STDMETHOD( ExecMenuCmd )( /* in */ UINT cmd , /* in */ HWND hParent , /* out */ PDWORD pdwStatus );
    STDMETHOD( OnHelp )( /* out */ int *piRet );

    BOOL IsSessionDirectoryEnabled( );
    DWORD SetSessionDirectoryState( BOOL );
    void ErrorMessage( HWND hwnd , UINT res , DWORD );
    
public:

    LPTSTR m_pszOpaqueString;

};



#endif // __TSSDSQL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\assoc.cpp ===
//=================================================================
//
// assoc.cpp -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================
#include <stdafx.h>
#include "precomp.h"
#include <assertbreak.h>

#include "Assoc.h"

CAssociation::CAssociation(
    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName
    ) : Provider(pwszClassName, pwszNamespaceName)
{
    ASSERT_BREAK( ( pwszClassName != NULL ) &&
                  ( pwszLeftClassName != NULL ) &&
                  ( pwszRightClassName != NULL) &&
                  ( pwszLeftPropertyName != NULL ) &&
                  ( pwszRightPropertyName != NULL) );

    m_pwszLeftClassName = pwszLeftClassName;
    m_pwszRightClassName = pwszRightClassName;

    m_pwszLeftPropertyName = pwszLeftPropertyName;
    m_pwszRightPropertyName = pwszRightPropertyName;

}

CAssociation::~CAssociation()
{
}

HRESULT CAssociation::ExecQuery(

    MethodContext* pMethodContext,
    CFrameworkQuery &pQuery,
    long lFlags
)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    TRefPointerCollection<CInstance> lefts;

    CHStringArray sLeftPaths, sRightPaths;
    pQuery.GetValuesForProp ( m_pwszLeftPropertyName, sLeftPaths ) ;
    pQuery.GetValuesForProp ( m_pwszRightPropertyName, sRightPaths ) ;

    if (sLeftPaths.GetSize() == 0)
    {
        // GetLeftInstances populates lefts
        hr = GetLeftInstances(pMethodContext, lefts);
    }
    else
    {
        // For each sLeftPaths that is valid, create an entry in lefts
        hr = ValidateLeftObjectPaths(pMethodContext, sLeftPaths, lefts);
    }

    if (SUCCEEDED(hr) && lefts.GetSize() > 0)
    {
        if (sRightPaths.GetSize() == 0)
        {
            // GetRightInstances takes the 'lefts' and rubs all the
            // rights against them creating instances where appropriate
            hr = GetRightInstances(pMethodContext, &lefts);
        }
        else
        {
            TRefPointerCollection<CInstance> rights;

            // For each sRightPaths that is valid, create an instance
            hr = ValidateRightObjectPaths(pMethodContext, sRightPaths, lefts);
        }
    }

    return hr;
}

HRESULT CAssociation::GetObject(

    CInstance* pInstance,
    long lFlags,
    CFrameworkQuery &pQuery
)
{
    HRESULT hr = WBEM_E_NOT_FOUND;

    CHString sLeftPath, sRightPath;

    // Get the two endpoints
    if (pInstance->GetCHString(m_pwszLeftPropertyName, sLeftPath ) &&
        pInstance->GetCHString(m_pwszRightPropertyName, sRightPath ) )
    {
        CInstancePtr pLeft, pRight;

        // Try to get the objects
        if (SUCCEEDED(hr = RetrieveLeftInstance(sLeftPath, &pLeft, pInstance->GetMethodContext())) &&
            SUCCEEDED(hr = RetrieveRightInstance(sRightPath, &pRight, pInstance->GetMethodContext())) )
        {

            hr = WBEM_E_NOT_FOUND;

            // So, the end points exist.  Are they derived from or equal to the classes we are working with?
            CHString sLeftClass, sRightClass;

            pLeft->GetCHString(L"__CLASS", sLeftClass);
            pRight->GetCHString(L"__CLASS", sRightClass);

            BOOL bDerived = _wcsicmp(m_pwszLeftClassName, sLeftClass) == 0;
            if (!bDerived)
            {
                bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszLeftClassName, sLeftClass, pInstance->GetMethodContext());
            }

            if (bDerived)
            {
                // Left side was correct, now let's check the right
                bDerived = _wcsicmp(m_pwszRightClassName, sRightClass) == 0;

                if (!bDerived)
                {
                    bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszRightClassName, sRightClass, pInstance->GetMethodContext());
                }
            }

            if (bDerived)
            {
                // Just because two instances are valid and derive from the right class, doesn't mean they are related.  Do
                // any other checks.
                if (AreRelated(pLeft, pRight))
                {
                    hr = LoadPropertyValues(pInstance, pLeft, pRight);
                }
            }
        }
    }

    return hr;
}

HRESULT CAssociation::EnumerateInstances(

    MethodContext *pMethodContext,
    long lFlags /*= 0L*/
)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    TRefPointerCollection<CInstance> lefts;

    // GetLeftInstances populates lefts
    if (SUCCEEDED(hr = GetLeftInstances(pMethodContext, lefts)))
    {
        // GetRightInstances takes the 'lefts' and rubs all the
        // rights against them
        hr = GetRightInstances(pMethodContext, &lefts);
    }

    return hr;
}

HRESULT CAssociation::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_pwszRightClassName);

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        NULL,
        pMethodContext,
        lefts);

    return hr;
}

HRESULT WINAPI CAssociation::StaticEnumerationCallback(

    Provider* pThat,
    CInstance* pInstance,
    MethodContext* pContext,
    void* pUserData
)
{
    HRESULT hr;

    CAssociation *pThis = (CAssociation *) pThat;
    ASSERT_BREAK(pThis != NULL);

    if (pThis)
    {
        hr = pThis->EnumerationCallback(pInstance, pContext, pUserData);
    }
    else
    {
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

HRESULT CAssociation::EnumerationCallback(

    CInstance *pRight,
    MethodContext *pMethodContext,
    void *pUserData
)
{
    HRESULT hr = WBEM_E_FAILED;

    CInstancePtr pLeft;
    REFPTRCOLLECTION_POSITION posLeft;
    CHString sLeftPath, sRightPath;

    // Cast for userdata back to what it is
    TRefPointerCollection<CInstance> *pLefts = (TRefPointerCollection<CInstance> *)pUserData;

    if (pLefts->BeginEnum(posLeft))
    {
        hr = WBEM_S_NO_ERROR;

        // Walk all the pLefts
        for (pLeft.Attach(pLefts->GetNext(posLeft)) ;
            (SUCCEEDED(hr)) && (pLeft != NULL) ;
            pLeft.Attach(pLefts->GetNext(posLeft)) )
        {
            // Compare it to the current pRight
            if(AreRelated(pLeft, pRight))
            {
                // We have a winner.  Populate the properties and send it in.
                if (GetLocalInstancePath(pLeft,  sLeftPath) &&
                    GetLocalInstancePath(pRight, sRightPath))
                {
                    CInstancePtr pNewAssoc(CreateNewInstance(pMethodContext), false);

                    if (pNewAssoc->SetCHString(m_pwszLeftPropertyName, sLeftPath) &&
                        pNewAssoc->SetCHString(m_pwszRightPropertyName, sRightPath) )
                    {
                        if (SUCCEEDED(hr = LoadPropertyValues(pNewAssoc, pLeft, pRight)))
                        {
                            hr = pNewAssoc->Commit();
                        }
                    }
                    else
                    {
                        ASSERT_BREAK(0);
                    }
                }
            }
        }

        pLefts->EndEnum();
    }

    return hr;
}

HRESULT CAssociation::ValidateLeftObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    CInstancePtr pInstance;

    // Walk the object paths
    for (DWORD x=0; x < sPaths.GetSize(); x++)
    {

        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;

        int nStatus = objpathParser.Parse( sPaths[x],  &pParsedPath );

        if ( 0 == nStatus )
        {
            BOOL bDerived;

            try
            {
                 bDerived = _wcsicmp(m_pwszLeftClassName, pParsedPath->m_pClass) == 0;
                 if (!bDerived)
                 {
                    bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszLeftClassName, pParsedPath->m_pClass, pMethodContext);
                 }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );

            if (bDerived)
            {
                // See if it is valid
                if (SUCCEEDED(RetrieveLeftInstance(sPaths[x], &pInstance, pMethodContext)))
                {
                    // Yup, add it to the list
                    lefts.Add(pInstance);
                }
            }
        }
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CAssociation::ValidateRightObjectPaths(

    MethodContext *pMethodContext,
    const CHStringArray &sPaths,
    TRefPointerCollection<CInstance> &lefts
)
{
    HRESULT hr = WBEM_S_NO_ERROR;;
    CInstancePtr pInstance;

    // Walk the object paths
    for (DWORD x=0;
         (x < sPaths.GetSize()) && SUCCEEDED(hr);
         x++)
    {
        ParsedObjectPath    *pParsedPath = NULL;
        CObjectPathParser    objpathParser;

        int nStatus = objpathParser.Parse( sPaths[x],  &pParsedPath );

        if ( 0 == nStatus )
        {
            BOOL bDerived;
            try
            {
                 bDerived = _wcsicmp(m_pwszRightClassName, pParsedPath->m_pClass) == 0;
                 if (!bDerived)
                 {
                     bDerived = CWbemProviderGlue::IsDerivedFrom(m_pwszRightClassName, pParsedPath->m_pClass, pMethodContext);
                 }
            }
            catch ( ... )
            {
                objpathParser.Free( pParsedPath );
                throw;
            }

            objpathParser.Free( pParsedPath );

            if (bDerived)
            {
                // See if it is valid
                if (SUCCEEDED(RetrieveRightInstance(sPaths[x], &pInstance, pMethodContext)))
                {
                    hr = EnumerationCallback(pInstance, pMethodContext, &lefts);
                }
            }
        }
    }

    return hr;
}

HRESULT CAssociation::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH FROM %s", m_pwszLeftClassName);

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext);
}

HRESULT CAssociation::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}

HRESULT CAssociation::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    return CWbemProviderGlue::GetInstanceKeysByPath(lpwszObjPath, ppInstance, pMethodContext);
}


/*
//========================
CAssocSystemToOS::CAssocSystemToOS(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName
) : CAssociation (

    pwszClassName,
    pwszNamespaceName,

    pwszLeftClassName,
    pwszRightClassName,

    pwszLeftPropertyName,
    pwszRightPropertyName
    )
{
}

CAssocSystemToOS::~CAssocSystemToOS()
{
}

HRESULT CAssocSystemToOS::LoadPropertyValues(

    CInstance *pInstance,
    const CInstance *pLeft,
    const CInstance *pRight
)
{
    CAssociation::LoadPropertyValues(pInstance, pLeft, pRight);

    // This will work... until win32_os returns more than one instance.
    pInstance->Setbool(L"PrimaryOS", true);

    return WBEM_S_NO_ERROR;
}


CAssocSystemToOS MySystemToOperatingSystem(
    L"Win32_SystemOperatingSystem",
    L"root\\cimv2",
    L"Win32_ComputerSystem",
    L"Win32_OperatingSystem",
    IDS_GroupComponent,
    IDS_PartComponent
) ;

  */
bool CAssociation::IsInstance(const CInstance *pInstance)
{
    DWORD dwGenus = 0;

    pInstance->GetDWORD(L"__Genus", dwGenus);

    return dwGenus == WBEM_GENUS_INSTANCE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\conv.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    conv.h

Abstract:

    UNICODE / ASCII conversion macros

Author:

    Hakki T. Bostanci (hakkib) 5-Aug-1998

Revision History:

--*/

#ifndef USES_CONVERSION

// USES_CONVERSION must be defined in every function that uses the
// conversion macros

#define USES_CONVERSION int __nLength; PCWSTR __pUnicode; PCSTR __pAscii

//////////////////////////////////////////////////////////////////////////
//
// W2A
//
// Routine Description:
//   Converts a UNICODE string to ASCII. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          UNICODE string
//
// Return Value:
//   the converted ASCII string
//

#define W2A(pStr)								                \
												                \
	((__pUnicode = pStr) == 0 ? (PSTR) 0 : (	                \
												                \
	__nLength = WideCharToMultiByte(				            \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		0,										                \
		0,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pAscii = (PCSTR) _alloca(__nLength * sizeof(CHAR)),       \
												                \
	WideCharToMultiByte(						                \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		(PSTR) __pAscii,						                \
		__nLength,								                \
		0,										                \
		0										                \
	),											                \
												                \
	(PSTR) __pAscii))							                \


//////////////////////////////////////////////////////////////////////////
//
// A2W
//
// Routine Description:
//   Converts an ASCII string to UNICODE. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          ASCII string
//
// Return Value:
//   the converted UNICODE string
//

#define A2W(pStr)								                \
												                \
	((__pAscii = pStr) == 0 ? (PWSTR) 0 : (					    \
												                \
	__nLength = MultiByteToWideChar(				            \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pUnicode = (PCWSTR) _alloca(__nLength * sizeof(WCHAR)),	\
												                \
	MultiByteToWideChar(						                \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		(PWSTR) __pUnicode,							            \
		__nLength									            \
	),											                \
												                \
	(PWSTR) __pUnicode))							            \

//////////////////////////////////////////////////////////////////////////
//
// T2A, A2T, T2W, W2T
//
// Routine Description:
//   These macros expand to the corresponding correct form according to the
//   #definition of UNICODE. 
//
//   We use the cryptic form (__nLength, __pAscii, __pUnicode, pStr) to avoid 
//   the compiler warning "symbol defined but not used" due to the variables 
//   defined in USES_CONVERSION macro.
//

#ifdef UNICODE
	#define T2A(pStr) W2A(pStr)
	#define A2T(pStr) A2W(pStr)
	#define T2W(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define W2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2DA(pStr) W2A(pStr)
	#define A2DT(pStr) A2W(pStr)
	#define T2DW(pStr) _wcsdupa(pStr)
	#define W2DT(pStr) _wcsdupa(pStr)
#else //UNICODE
	#define T2A(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define A2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2W(pStr) A2W(pStr)
	#define W2T(pStr) W2A(pStr)
	#define T2DA(pStr) _strdupa(pStr)
	#define A2DT(pStr) _strdupa(pStr)
	#define T2DW(pStr) A2W(pStr)
	#define W2DT(pStr) W2A(pStr)
#endif //UNICODE


//////////////////////////////////////////////////////////////////////////
//
// _tcsdupa
//
// Routine Description:
//   Duplicates a string to a buffer allocated off the stack using _alloca
//
// Arguments:
//	 pStr          input string
//
// Return Value:
//   duplicated string
//

#define _wcsdupa(pStr)                                                  \
                                                                        \
    (__pAscii, (__pUnicode = pStr) == 0 ? (PWSTR) 0 : (                 \
                                                                        \
    __nLength = wcslen(__pUnicode) + 1,                                 \
                                                                        \
    wcscpy((PWSTR) _alloca(__nLength * sizeof(WCHAR)), __pUnicode)))    \


#define _strdupa(pStr)                                                  \
                                                                        \
    (__pUnicode, (__pAscii = pStr) == 0 ? (PSTR) 0 : (                  \
                                                                        \
    __nLength = strlen(__pAscii) + 1,                                   \
                                                                        \
    strcpy((PSTR) _alloca(__nLength * sizeof(CHAR)), __pAscii)))        \


#ifdef UNICODE 
#define _tcsdupa _wcsdupa
#else
#define _tcsdupa _strdupa
#endif


#endif //USES_CONVERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\makefile.inc ===
$(O)\tssdwmi.mof $(O)\tssdwmi.mfl: tssdwmi.mof
    mofcomp -amendment:ms_409 -MOF:$(O)\tssdwmi.mof -MFL:$(O)\tssdwmi.mfl tssdwmi.mof
    copy $(O)\tssdwmi.mof+$(O)\tssdwmi.mfl $(O)\tssdwmi.mof

$(O)\tssdwmi-install.bat: tssdwmi.bat
    copy tssdwmi.bat $(O)\tssdwmi-install.bat

$(O)\tssdwmi.txt: tssdwmi.txt
    copy tssdwmi.txt $(O)\tssdwmi.txt
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\binding.h ===
//=================================================================
//
// binding.h -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================

#pragma once
class CBinding : public CAssociation
{
    public:

        CBinding(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName,

            LPCWSTR pwszLeftBindingPropertyName,
            LPCWSTR pwszRightBindingPropertyName
        );

        ~CBinding();

    protected:

        BOOL AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        );

        HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts
        );

        HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        LPCWSTR m_pwszLeftBindingPropertyName;
        LPCWSTR m_pwszRightBindingPropertyName;
};

bool WINAPI CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\binding.cpp ===
//=================================================================
//
// binding.cpp -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================
#include <stdafx.h>
#include "precomp.h"
#include <assertbreak.h>

#include "Assoc.h"
#include "Binding.h"


bool CompareVariantsNoCase(const VARIANT *v1, const VARIANT *v2) 
{
   
   if (v1->vt == v2->vt) {
      switch (v1->vt) {
      case VT_BOOL: return (v1->boolVal == v2->boolVal);
      case VT_UI1:  return (v1->bVal == v2->bVal);
      case VT_I2:   return (v1->iVal == v2->iVal);
      case VT_I4:   return (v1->lVal == v2->lVal);
      case VT_R4:   return (v1->fltVal == v2->fltVal);
      case VT_R8:   return (v1->dblVal == v2->dblVal);
      case VT_BSTR: return (0 == _wcsicmp(v1->bstrVal, v2->bstrVal));
      default:
         ASSERT_BREAK(0);
      }
   }
   return false;
}

CBinding::CBinding(

    LPCWSTR pwszClassName,
    LPCWSTR pwszNamespaceName,

    LPCWSTR pwszLeftClassName,
    LPCWSTR pwszRightClassName,

    LPCWSTR pwszLeftPropertyName,
    LPCWSTR pwszRightPropertyName,

    LPCWSTR pwszLeftBindingPropertyName,
    LPCWSTR pwszRightBindingPropertyName
)

: CAssociation (

    pwszClassName,
    pwszNamespaceName,
    pwszLeftClassName,
    pwszRightClassName,
    pwszLeftPropertyName,
    pwszRightPropertyName
)
{
    ASSERT_BREAK( ( pwszLeftBindingPropertyName != NULL ) && ( pwszRightBindingPropertyName != NULL) );

    m_pwszLeftBindingPropertyName = pwszLeftBindingPropertyName;
    m_pwszRightBindingPropertyName = pwszRightBindingPropertyName;
}

CBinding::~CBinding()
{
}

//========================
BOOL CBinding::AreRelated(

    const CInstance *pLeft,
    const CInstance *pRight
)
{
    BOOL bRet = FALSE;

    variant_t   LeftBindingPropertyValue,
                RightBindingPropertyValue;

    if (pLeft->GetVariant(m_pwszLeftBindingPropertyName, LeftBindingPropertyValue) &&
        pRight->GetVariant(m_pwszRightBindingPropertyName,  RightBindingPropertyValue) )
    {
        bRet = CompareVariantsNoCase(&LeftBindingPropertyValue, &RightBindingPropertyValue);
    }
    else
    {
        ASSERT_BREAK(0);
    }

    return bRet;
}

HRESULT CBinding::GetRightInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> *lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH, %s FROM %s", m_pwszRightBindingPropertyName, m_pwszRightClassName);

    // 'StaticEnumerationCallback' will get called once for each instance
    // returned from the query
    HRESULT hr = CWbemProviderGlue::GetInstancesByQueryAsynch(
        sQuery,
        this,
        StaticEnumerationCallback,
        NULL,
        pMethodContext,
        lefts);

    return hr;
}

HRESULT CBinding::GetLeftInstances(

    MethodContext *pMethodContext,
    TRefPointerCollection<CInstance> &lefts
)
{
    CHString sQuery;
    sQuery.Format(L"SELECT __RELPATH, %s FROM %s", m_pwszLeftBindingPropertyName, m_pwszLeftClassName);

    return CWbemProviderGlue::GetInstancesByQuery(sQuery, &lefts, pMethodContext);
}

HRESULT CBinding::RetrieveLeftInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__RELPATH");
    csaProperties.Add(m_pwszLeftBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

HRESULT CBinding::RetrieveRightInstance(

    LPCWSTR lpwszObjPath,
    CInstance **ppInstance,
    MethodContext *pMethodContext
)
{
    CHStringArray csaProperties;
    csaProperties.Add(L"__RELPATH");
    csaProperties.Add(m_pwszRightBindingPropertyName);

    return CWbemProviderGlue::GetInstancePropertiesByPath(lpwszObjPath, ppInstance, pMethodContext, csaProperties);
}

// =========================================================================================================


CBinding MyTerminalServiceToSetting(
    L"Win32_TerminalServiceToSetting",
    L"root\\cimv2",
    L"Win32_TerminalService",
    L"Win32_TerminalServiceSetting",
    L"Element",
    L"Setting",
    L"Name",
    L"ServerName"
);

CBinding MyTerminalTerminalSetting(
    L"Win32_TerminalTerminalSetting",
    L"root\\cimv2",
    L"Win32_Terminal",
    L"Win32_TerminalSetting",
    L"Element",
    L"Setting",
    L"TerminalName",
    L"TerminalName"

);

CBinding MyTSSessionDirectorySetting(
    L"Win32_TSSessionDirectorySetting",
    L"root\\cimv2",
    L"Win32_TerminalService",
    L"Win32_TSSessionDirectory",
    L"Element",
    L"Setting",
    L"Name",
    L"SessionDirectoryActive"
);

/*
CBinding MyTSPermissionsSetting(
    L"Win32_TSPermissionsSetting",
    L"root\\cimv2",
    L"Win32_Terminal",
    L"Win32_TSAccount",
    L"Element",
    L"Setting",
    L"TerminalName",
    L"AccountName"
);

CBinding MyTSNetworkAdapterListSetting(
    L"Win32_TSNetworkAdapterListSetting",
    L"root\\cimv2",
    L"Win32_NetworkAdapter",
    L"Win32_TSNetworkAdapterSetting",
    L"Element",
    L"Setting",
    L"DeviceID",
    L"TerminalName"
);

*/

/*

CBinding MyNetAdaptToNetAdaptConfig(
    L"Win32_NetworkAdapterSetting",
    L"root\\cimv2",
    L"Win32_NetworkAdapter",
    L"Win32_NetworkAdapterConfiguration",
    L"Element",
    L"Setting",
    IDS_Index,
    IDS_Index);

CBinding PageFileToPagefileSetting(
    L"Win32_PageFileElementSetting",
    L"root\\cimv2",
    L"Win32_PageFileUsage",
    L"Win32_PageFileSetting",
    L"Element",
    L"Setting",
    IDS_Name,
    IDS_Name);

CBinding MyPrinterSetting(
    L"Win32_PrinterSetting",
    L"root\\cimv2",
    L"Win32_Printer",
    L"Win32_PrinterConfiguration",
    L"Element",
    L"Setting",
    IDS_DeviceID,
    IDS_Name);

CBinding MyDiskToPartitionSet(
    L"Win32_DiskDriveToDiskPartition",
    L"root\\cimv2",
    L"Win32_DiskDrive",
    L"Win32_DiskPartition",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_Index,
    IDS_DiskIndex
);

CBinding assocPOTSModemToSerialPort(
    L"Win32_POTSModemToSerialPort",
    L"root\\cimv2",
    L"Win32_SerialPort",
    L"Win32_POTSModem",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_DeviceID,
    IDS_AttachedTo
);

CBinding OStoQFE(
    L"Win32_OperatingSystemQFE",
    L"root\\cimv2",
    L"Win32_OperatingSystem",
    L"Win32_QuickFixEngineering",
    IDS_Antecedent,
    IDS_Dependent,
    IDS_CSName,
    IDS_CSName
);

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\assoc.h ===
//=================================================================
//
// assoc.h -- Generic association class
//
// Copyright 1999 Microsoft Corporation
//
//=================================================================

class CAssociation : public Provider
{
    public:

        CAssociation(
        LPCWSTR pwszClassName,
        LPCWSTR pwszNamespaceName,

        LPCWSTR pwszLeftClassName,
        LPCWSTR pwszRightClassName,

        LPCWSTR pwszLeftPropertyName,
        LPCWSTR pwszRightPropertyName
        );

        ~CAssociation();

        HRESULT ExecQuery(

            MethodContext* pMethodContext, 
            CFrameworkQuery &pQuery, 
            long lFlags 
        );

        HRESULT GetObject(

            CInstance* pInstance, 
            long lFlags,
            CFrameworkQuery &pQuery
        );

        HRESULT EnumerateInstances(

            MethodContext *pMethodContext,
            long lFlags /*= 0L*/
        );

    protected:
        
        bool IsInstance(const CInstance *pInstance);

        static HRESULT WINAPI StaticEnumerationCallback(

            Provider* pThat,
            CInstance* pInstance,
            MethodContext* pContext,
            void* pUserData
        );

        virtual HRESULT RetrieveLeftInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT RetrieveRightInstance(

            LPCWSTR lpwszObjPath,
            CInstance **ppInstance,
            MethodContext *pMethodContext
        );

        virtual HRESULT EnumerationCallback(

            CInstance *pRight, 
            MethodContext *pMethodContext, 
            void *pUserData
        );

        virtual HRESULT ValidateLeftObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual HRESULT ValidateRightObjectPaths(

            MethodContext *pMethodContext,
            const CHStringArray &sPaths,
            TRefPointerCollection<CInstance> &lefts
        );

        virtual BOOL AreRelated(

            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return IsInstance(pLeft) && IsInstance(pRight);
        }

        virtual HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        )
        {
            return WBEM_S_NO_ERROR;
        }

        virtual HRESULT GetLeftInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> &lefts
        );

        virtual HRESULT GetRightInstances(

            MethodContext *pMethodContext, 
            TRefPointerCollection<CInstance> *lefts
        );

        LPCWSTR m_pwszLeftClassName;
        LPCWSTR m_pwszRightClassName;

        LPCWSTR m_pwszLeftPropertyName;
        LPCWSTR m_pwszRightPropertyName;
};

/*
class CAssocSystemToOS : public CAssociation
{
    public:

        CAssocSystemToOS(
            LPCWSTR pwszClassName,
            LPCWSTR pwszNamespaceName,

            LPCWSTR pwszLeftClassName,
            LPCWSTR pwszRightClassName,

            LPCWSTR pwszLeftPropertyName,
            LPCWSTR pwszRightPropertyName

        );

        ~CAssocSystemToOS();

    protected:
        HRESULT LoadPropertyValues(

            CInstance *pInstance, 
            const CInstance *pLeft, 
            const CInstance *pRight
        );


};
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (C) 2001 Microsoft Corp.
//
//***************************************************************************
#include "stdafx.h"
#include <FWcommon.h>
#include <objbase.h>
#include <initguid.h>
#include <tchar.h>
#include "trace.h"
#include "sdwmi.h"

HINSTANCE g_hInstance = NULL;

#ifdef UNICODE
#pragma message("Its unicode")
#else
#pragma message("Its ansi")
#endif 

//============

// {BF258E47-A172-498d-971A-DA30A3301E94}
DEFINE_GUID(CLSID_CIM_WIN32_TSSESSIONDIRECTORYCLUSTER, 
0xbf258e47, 0xa172, 0x498d, 0x97, 0x1a, 0xda, 0x30, 0xa3, 0x30, 0x1e, 0x94);

// {f99a3c50-74fa-460a-8d75-db8ef2e3651d}
DEFINE_GUID(CLSID_CIM_WIN32_TSSESSIONDIRECTORYSERVER, 
0xf99a3c50, 0x74fa, 0x460a, 0x8d, 0x75, 0xdb, 0x8e, 0xf2, 0xe3, 0x65, 0x1d);

// {b745b87b-cc4e-4361-8d29-221d936c259c}
DEFINE_GUID(CLSID_CIM_WIN32_TSSESSIONDIRECTORYSESSION, 
0xb745b87b, 0xcc4e, 0x4361, 0x8d, 0x29, 0x22, 0x1d, 0x93, 0x6c, 0x25, 0x9c);

CRITICAL_SECTION g_critsect;

CWin32_SessionDirectoryCluster* g_pSessionDirectoryClusterobj = NULL;

CWin32_SessionDirectoryServer* g_pSessionDirectoryServerobj = NULL;

CWin32_SessionDirectorySession* g_pSessionDirectorySessionobj = NULL;

//Count number of objects and number of locks.
long g_cLock=0;



/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue (

    wchar_t *pszKey, 
    wchar_t *pszSubkey, 
    wchar_t *pszValueName, 
    wchar_t *pszValue
)
{
    HKEY        hKey;
    TCHAR       szKey[MAX_PATH+1];

    if(lstrlen(pszKey) > MAX_PATH)
    {
        return FALSE;
    }
    
    lstrcpy(szKey, pszKey);    

    if (NULL!=pszSubkey && (lstrlen(pszKey)+lstrlen(pszSubkey)+1) <= MAX_PATH )
    {
        lstrcat(szKey, TEXT("\\"));
        lstrcat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, (LPCTSTR)pszValueName, 0, REG_SZ, (BYTE *)(LPCTSTR)pszValue
            , (_tcslen(pszValue)+1)*sizeof(TCHAR)))
            return FALSE;
    }

    RegCloseKey(hKey);

    return TRUE;
}

//***************************************************************************
//
//  Is4OrMore
//
//  Returns true if win95 or any version of NT > 3.51
//
//***************************************************************************

BOOL Is4OrMore(void)
{
    OSVERSIONINFO os;

    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if(!GetVersionEx(&os))
        return FALSE;           // should never happen

    return os.dwMajorVersion >= 4;
}


HRESULT RegisterServer (

    TCHAR *a_pName, 
    REFGUID a_rguid
)
{   
    WCHAR      wcID[128];
    TCHAR      szCLSID[128];
    TCHAR      szModule[MAX_PATH];
    TCHAR * pName = TEXT("WBEM Framework Instance Provider");
    TCHAR * pModel;
    HKEY hKey1;

    GetModuleFileName(g_hInstance, szModule,  MAX_PATH);

    // Normally we want to use "Both" as the threading model since
    // the DLL is free threaded, but NT 3.51 Ole doesnt work unless
    // the model is "Aparment"

    if(Is4OrMore())
        pModel = TEXT("Free") ;
    else
        pModel = TEXT("Free") ;

    // Create the path.

    StringFromGUID2(a_rguid, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));

    lstrcat(szCLSID, wcID);

#ifdef LOCALSERVER

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID,TEXT("SOFTWARE\\CLASSES\\APPID\\"));

    lstrcat(szProviderCLSIDAppID, wcID);

    if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_pName ))
        return SELFREG_E_CLASS;
#endif

    // Create entries under CLSID

    RegCreateKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey1);

    RegSetValueEx(hKey1, NULL, 0, REG_SZ, (BYTE *)a_pName, (lstrlen(a_pName)+1) * 
        sizeof(TCHAR));


#ifdef LOCALSERVER

    if (FALSE ==SetKeyAndValue(szCLSID, TEXT("LocalServer32"), NULL,szModule))
        return SELFREG_E_CLASS;

    if (FALSE ==SetKeyAndValue(szCLSID, TEXT("LocalServer32"),TEXT("ThreadingModel"), pModel))
        return SELFREG_E_CLASS;
#else

    HKEY hKey2 ;
    RegCreateKey(hKey1, TEXT("InprocServer32"), &hKey2);

    RegSetValueEx(hKey2, NULL, 0, REG_SZ, (BYTE *)szModule, 
        (lstrlen(szModule)+1) * sizeof(TCHAR));
    RegSetValueEx(hKey2, TEXT("ThreadingModel"), 0, REG_SZ, 
        (BYTE *)pModel, (lstrlen(pModel)+1) * sizeof(TCHAR));

    CloseHandle(hKey2);

#endif

    CloseHandle(hKey1);

    return S_OK;
}

HRESULT UnregisterServer (

    REFGUID a_rguid
)
{
    TCHAR    szID[128];
    WCHAR    wcID[128];
    TCHAR    szCLSID[128];
    HKEY    hKey;

    // Create the path using the CLSID

    StringFromGUID2( a_rguid, wcID, 128);
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));

    lstrcat(szCLSID, wcID);

    DWORD dwRet ;

#ifdef LOCALSERVER

    TCHAR szProviderCLSIDAppID[128];
    _tcscpy(szProviderCLSIDAppID,TEXT("SOFTWARE\\CLASSES\\APPID\\"));
    _tcscat(szProviderCLSIDAppID,szCLSID);

    //Delete entries under APPID

    DWORD hrStatus = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

    TCHAR szTemp[128];
    _stprintf(szTemp, TEXT("%s\\%s"),szCLSID, TEXT("LocalServer32"));
    hrStatus = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#else

    // First delete the InProcServer subkey.

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, TEXT("InProcServer32") );
        CloseHandle(hKey);
    }

#endif

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\CLASSES\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        CloseHandle(hKey);
    }
    else
    {
        ERR((TB,"UnregisterServer ret 0x%x\n", dwRet));
    }

    return HRESULT_FROM_WIN32( dwRet );
    
}


//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if     it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr = S_OK;
    CWbemGlueFactory *pObj;

    if ((CLSID_CIM_WIN32_TSSESSIONDIRECTORYCLUSTER == rclsid) ||
        (CLSID_CIM_WIN32_TSSESSIONDIRECTORYSERVER == rclsid) ||
        (CLSID_CIM_WIN32_TSSESSIONDIRECTORYSESSION == rclsid))

    {
        EnterCriticalSection(&g_critsect);

        try{
            pObj =new CWbemGlueFactory () ;

            if (NULL==pObj)
            {                
                hr =  E_OUTOFMEMORY;
            }
            else
            {            
                hr=pObj->QueryInterface(riid, ppv);

                if (FAILED(hr))
                    delete pObj;
            }

            if( SUCCEEDED(hr) )
            {
                // EnterCriticalSection prevents more than one threads from instantiating the global pointers to the objects.

                if( g_pSessionDirectoryClusterobj == NULL )
                {                
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_SessionDirectoryCluster object created"));

                    g_pSessionDirectoryClusterobj = new CWin32_SessionDirectoryCluster( PROVIDER_NAME_Win32_WIN32_SESSIONDIRECTORYCLUSTER_Prov, L"root\\cimv2"); 
                }

                if( g_pSessionDirectoryServerobj == NULL )
                {                
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_SessionDirectoryServer object created"));

                    g_pSessionDirectoryServerobj = new CWin32_SessionDirectoryServer( PROVIDER_NAME_Win32_WIN32_SESSIONDIRECTORYSERVER_Prov, L"root\\cimv2"); 
                }

                if( g_pSessionDirectorySessionobj == NULL )
                {                
                    TRC2((TB, "DllMain DLL_PROCESS_ATTACH: CWin32_SessionDirectorySession object created"));

                    g_pSessionDirectorySessionobj = new CWin32_SessionDirectorySession( PROVIDER_NAME_Win32_WIN32_SESSIONDIRECTORYSESSION_Prov, L"root\\cimv2"); 
                }
            }       
        }
        catch (...)
        {
            hr = E_OUTOFMEMORY;
        }

        LeaveCriticalSection(&g_critsect);

    }
    else
    {
        hr=E_FAIL;
        ERR((TB, "DllGetClassObject ret 0x%x\n" , hr));
    }

    return hr;
}



//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    // It is OK to unload if there are no objects or locks on the 
    // class factory and the framework is done with you.
    
    if ((0L==g_cLock) && CWbemProviderGlue::FrameworkLogoffDLL(L"TSSDWMI"))
    {
        // EnterCriticalSection prevents multiple threads from accessing the global pointers concurrently and
        // allows only one thread access to free the objects based on the condition that g_cLock count is zero
        // and FrameworkLogoffDLL is TRUE.

		EnterCriticalSection(&g_critsect);

        if( g_pSessionDirectoryClusterobj != NULL )
        {
            TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_SessionDirectoryCluster object deleted"));

            delete g_pSessionDirectoryClusterobj;

            g_pSessionDirectoryClusterobj = NULL;
        }   

        if( g_pSessionDirectoryServerobj != NULL )
        {
            TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_SessionDirectoryServer object deleted"));

            delete g_pSessionDirectoryServerobj;

            g_pSessionDirectoryServerobj = NULL;
        }

        if( g_pSessionDirectorySessionobj != NULL )
        {
            TRC2((TB, "DllMain DLL_PROCESS_DETACH: CWin32_SessionDirectorySession object deleted"));

            delete g_pSessionDirectorySessionobj;

            g_pSessionDirectorySessionobj = NULL;
        }

        // LeaveCriticalSection releases the critical section once the thread has freed all objects.

		LeaveCriticalSection(&g_critsect);

        sc = S_OK;
    }
    else
    {
        sc = S_FALSE;
     //   ERR((TB, "DllCanUnloadNow ret 0x%x\n" , sc));
    }

    return sc;
}







//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    HRESULT hrStatus;


    hrStatus = RegisterServer( TEXT("WBEM WIN32_TSSESSIONDIRECTORYCLUSTER Provider"), CLSID_CIM_WIN32_TSSESSIONDIRECTORYCLUSTER ) ;
    
    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_WIN32_TSSESSIONDIRECTORYCLUSTER: succeeded"));      
    }

    hrStatus = RegisterServer( TEXT("WBEM WIN32_TSSESSIONDIRECTORYSERVER Provider"), CLSID_CIM_WIN32_TSSESSIONDIRECTORYSERVER ) ;
    
    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_WIN32_TSSESSIONDIRECTORYSERVER: succeeded"));      
    }

    hrStatus = RegisterServer( TEXT("WBEM WIN32_TSSESSIONDIRECTORYSESSION Provider"), CLSID_CIM_WIN32_TSSESSIONDIRECTORYSESSION ) ;
    
    if( SUCCEEDED( hrStatus ) )
    {
        TRC2((TB,"RegisterServer Win32_WIN32_TSSESSIONDIRECTORYSESSION: succeeded"));      
    }

    return hrStatus;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    
    UnregisterServer( CLSID_CIM_WIN32_TSSESSIONDIRECTORYCLUSTER );

    UnregisterServer( CLSID_CIM_WIN32_TSSESSIONDIRECTORYSERVER );

    UnregisterServer( CLSID_CIM_WIN32_TSSESSIONDIRECTORYSESSION );
    
    return S_OK;
}

//***************************************************************************
//
// DllMain
//
// Purpose: Called by the operating system when processes and threads are 
//          initialized and terminated, or upon calls to the LoadLibrary 
//          and FreeLibrary functions
//
// Return:  TRUE if load was successful, else FALSE
//***************************************************************************


BOOL APIENTRY DllMain ( HINSTANCE hInstDLL, // handle to dll module
                        DWORD  fdwReason,    // reason for calling function
                        LPVOID lpReserved   )   // reserved
{
    BOOL bRet = TRUE;

    // Perform actions based on the reason for calling.
    if( DLL_PROCESS_ATTACH == fdwReason )
    {

        DisableThreadLibraryCalls(hInstDLL);
        // CriticalSection object is initialized on Thread attach.

        __try
        {
		    InitializeCriticalSection(&g_critsect);                
        }
        __except (EXCEPTION_EXECUTE_HANDLER)
         {
	        return FALSE;
         }    
            
        g_hInstance = hInstDLL ;
      
        bRet = CWbemProviderGlue :: FrameworkLoginDLL ( L"TSSDWMI" ) ;
        
    }

    else if( DLL_PROCESS_DETACH == fdwReason )
    {
        // CriticalSection object is deleted

		DeleteCriticalSection(&g_critsect);

    }

    return bRet;  // Status of DLL_PROCESS_ATTACH.
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\precomp.h ===
#pragma message("Precompiling header...")

#include <fwcommon.h>
#include "smartptr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\sdqueryrpc-c.c ===
#include <jetrpc_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\resource.h ===
/****************************************************************************/
// Resource.h
//
// Resource file for TsSdWmi.dll
//
// Copyright (C) 2001 Microsoft Corp.
/****************************************************************************/

#define IDS_ERR_ENUMTSSETTINGS 40000
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\smartptr.h ===
//***************************************************************************
//
//  Copyright (c) 1997-1999 Microsoft Corporation
//
//  SmartPtr.h
//
//  Purpose: Declare smartpointer typedefs
//
//***************************************************************************

#pragma once
#include <io.h>

#include <comdef.h>

_COM_SMARTPTR_TYPEDEF(CInstance, __uuidof(CInstance));


_COM_SMARTPTR_TYPEDEF(IWbemClassObject, __uuidof(IWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemQualifierSet, __uuidof(IWbemQualifierSet));
_COM_SMARTPTR_TYPEDEF(IWbemObjectAccess, __uuidof(IWbemObjectAccess));
_COM_SMARTPTR_TYPEDEF(IWbemServices, __uuidof(IWbemServices));
_COM_SMARTPTR_TYPEDEF(IWbemContext, __uuidof(IWbemContext));
_COM_SMARTPTR_TYPEDEF(IWbemCallResult, __uuidof(IWbemCallResult));
_COM_SMARTPTR_TYPEDEF(IWbemObjectSink, __uuidof(IWbemObjectSink));
_COM_SMARTPTR_TYPEDEF(IEnumWbemClassObject, __uuidof(IEnumWbemClassObject));
_COM_SMARTPTR_TYPEDEF(IWbemLocator, __uuidof(IWbemLocator));
_COM_SMARTPTR_TYPEDEF(IUnsecuredApartment, __uuidof(IUnsecuredApartment));
_COM_SMARTPTR_TYPEDEF(IWbemStatusCodeText, __uuidof(IWbemStatusCodeText));
_COM_SMARTPTR_TYPEDEF(IWbemRefresher, __uuidof(IWbemRefresher));
_COM_SMARTPTR_TYPEDEF(IWbemHiPerfEnum, __uuidof(IWbemHiPerfEnum));
_COM_SMARTPTR_TYPEDEF(IWbemConfigureRefresher, __uuidof(IWbemConfigureRefresher));
_COM_SMARTPTR_TYPEDEF(IMofCompiler, __uuidof(IMofCompiler));
_COM_SMARTPTR_TYPEDEF(ExternalMethodContext, __uuidof(ExternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContext, __uuidof(InternalMethodContext));
_COM_SMARTPTR_TYPEDEF(InternalMethodContextAsynch, __uuidof(InternalMethodContextAsynch));

class SmartCloseHandle
{

private:
	HANDLE m_h;

public:
	SmartCloseHandle():m_h(INVALID_HANDLE_VALUE){}
	SmartCloseHandle(HANDLE h):m_h(h){}
   ~SmartCloseHandle(){if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) CloseHandle(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class Smart_findclose
{

private:
	long m_h;

public:
	Smart_findclose():m_h(0){}
	Smart_findclose(long h):m_h(h){}
   ~Smart_findclose(){if (m_h!=0) _findclose(m_h);}
	long operator =(long h) {if (m_h) _findclose(m_h); m_h=h; return h;}
	operator long() const {return m_h;}
	long* operator &() {if (m_h) _findclose(m_h); m_h = 0; return &m_h;}
};

class SmartFindClose
{

private:
	HANDLE m_h;

public:
	SmartFindClose():m_h(INVALID_HANDLE_VALUE){}
	SmartFindClose(HANDLE h):m_h(h){}
   ~SmartFindClose(){if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h);}
	HANDLE operator =(HANDLE h) {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h=h; return h;}
	operator HANDLE() const {return m_h;}
	HANDLE* operator &() {if (m_h!=INVALID_HANDLE_VALUE) FindClose(m_h); m_h = INVALID_HANDLE_VALUE; return &m_h;}
};

class SmartCloseServiceHandle
{

private:
	SC_HANDLE m_h;

public:
	SmartCloseServiceHandle():m_h(NULL){}
	SmartCloseServiceHandle(SC_HANDLE h):m_h(h){}
   ~SmartCloseServiceHandle(){if (m_h!=NULL) CloseServiceHandle(m_h);}
	SC_HANDLE operator =(SC_HANDLE h) {if (m_h!=NULL) CloseServiceHandle(m_h); m_h=h; return h;}
	operator SC_HANDLE() const {return m_h;}
	SC_HANDLE* operator &() {if (m_h!=NULL) CloseServiceHandle(m_h); m_h = NULL; return &m_h;}
};

class CSmartCreatedDC
{
public:
    CSmartCreatedDC(HDC hdc) { m_hdc = hdc;}
	operator HDC() const {return m_hdc;}
    ~CSmartCreatedDC() 
    { 
        if (m_hdc)
            DeleteDC(m_hdc); 
    }

protected:
    HDC m_hdc;
};

class CSmartBuffer
{
private:
	LPBYTE m_pBuffer;

public:
	CSmartBuffer() : m_pBuffer(NULL) {}
	CSmartBuffer(LPBYTE pBuffer) : m_pBuffer(pBuffer) {}
    CSmartBuffer(DWORD dwSize)
    {
        m_pBuffer = new BYTE[dwSize];
        if (m_pBuffer == NULL)
        {
            throw CHeap_Exception ( CHeap_Exception :: E_ALLOCATION_ERROR ) ;
        }
    }

    ~CSmartBuffer()
    {
        Free();
    }

	LPBYTE operator =(LPBYTE pBuffer) 
    {
        Free();
            
        m_pBuffer = pBuffer; 
        
        return m_pBuffer;
    }
	
    operator LPBYTE() const { return m_pBuffer; }
	
    LPBYTE* operator &()
    {
        Free();

        m_pBuffer = NULL;
        
        return &m_pBuffer;
    }

protected:
    void Free()
    {
        if (m_pBuffer != NULL) 
        {
            delete [] m_pBuffer;
        }
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\sdwmi.cpp ===
/******************************************************************
   Copyright (C) 2001 Microsoft Corp.

   sdwmi.cpp -- WMI provider class implementation

   Generated by Microsoft WMI Code Generation Engine
  
   TO DO: - See individual function headers
          - When linking, make sure you link to framedyd.lib & 
            msvcrtd.lib (debug) or framedyn.lib & msvcrt.lib (retail).            

   Description: 
   
  
  
******************************************************************/
#include "stdafx.h"
#include <fwcommon.h>
#include "sdwmi.h"
#include "smartptr.h"
#include <windows.h>

LPWSTR pszUuid = L"6af13c8b-0844-4c83-9064-1892ba825527"; // From JETRPC.IDL

#define SD_QUERY_ENDPOINT_NAME L"TSSessionDirectoryQueryApi"

/****************************************************************************/
// MIDL_user_allocate
// MIDL_user_free
//
// RPC-required allocation functions.
/****************************************************************************/
void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t Size)
{
    return LocalAlloc(LMEM_FIXED, Size);
}

void __RPC_USER MIDL_user_free(void __RPC_FAR *p)
{
    LocalFree(p);
}

// Get the handle of the SD RPC server
RPC_BINDING_HANDLE OpenSDWMIServer()
{

    HRESULT hr;
    WCHAR *pBindingString = NULL;
    RPC_BINDING_HANDLE hRPCBinding = NULL;

    hr = RpcStringBindingCompose(/*(WCHAR *)g_RPCUUID,*/
                0,
                L"ncalrpc", NULL,
                SD_QUERY_ENDPOINT_NAME,    // Endpoint
                NULL, &pBindingString);

    if (hr == RPC_S_OK) {
        // Generate the RPC binding from the canonical RPC binding string.
        hr = RpcBindingFromStringBinding(pBindingString, &hRPCBinding);
        if (hr != RPC_S_OK) {
            ERR((TB,"SDWMI OpenSDWMIServer: Error %d in RpcBindingFromStringBinding\n", hr));
            goto HandleError;
        } 
    }
    else {
        ERR((TB,"SDWMI OpenSDWMIServer: Error %d in RpcStringBindingCompose\n", hr));
        goto HandleError;
    }

    hr = RpcEpResolveBinding(hRPCBinding, TSSDQUERYRPC_ClientIfHandle);
    if (hr != RPC_S_OK) {
        ERR((TB, "SDWMI OpenSDWMIServer: Error %d in RpcEpResolveBinding", hr));
        goto HandleError;
    }
HandleError:
    if (pBindingString != NULL) {
        RpcStringFree(&pBindingString);
    }
    return hRPCBinding;
}


// wrapper to make RPC call: TSSDRpcQueryAllClusterInfo
BOOL SDWMIQueryAllClusterInfo(DWORD *pNumberOfClusters,
                              TSSD_ClusterInfo **ppClusterInfo)
{
    BOOL rc = FALSE;
    RPC_BINDING_HANDLE rpcHandle;
    DWORD result;
    unsigned long RpcException;

    rpcHandle = OpenSDWMIServer();
    if (rpcHandle == NULL) {
        goto HandleError;
    }

    RpcTryExcept {
        // Make the call.
        result = TSSDRpcQueryAllClusterInfo(rpcHandle, pNumberOfClusters, ppClusterInfo);
    }
    RpcExcept(TRUE) {
        RpcException = RpcExceptionCode();
        ERR((TB,"TSSDRpcQueryAllClusterInfo: RPC Exception %d\n", RpcException));
        result = E_FAIL;
    } 
    RpcEndExcept

    if (SUCCEEDED(result)) {
        rc = TRUE; 
    }
    else {
        ERR((TB,"TSSDRpcQueryAllClusterInfo: RPC call failed, result=0x%X", result));
    }

HandleError:
    return rc;
}


// wrapper to make RPC call: TSSDRpcQueryClusterInfo
BOOL SDWMIQueryClusterInfo(WCHAR *ClusterName, 
                           DWORD *pNumberOfClusters,
                           TSSD_ClusterInfo **ppClusterInfo)
{
    BOOL rc = FALSE;
    DWORD result;
    RPC_BINDING_HANDLE rpcHandle;
    unsigned long RpcException;

    rpcHandle = OpenSDWMIServer();
    if (rpcHandle == NULL) {
        goto HandleError;
    }

    RpcTryExcept {
        // Make the call.
        result = TSSDRpcQueryClusterInfo(rpcHandle, ClusterName,
                                         pNumberOfClusters, ppClusterInfo);
    }
    RpcExcept(TRUE) {
        RpcException = RpcExceptionCode();
        ERR((TB,"TSSDRpcQueryClusterInfo: RPC Exception %d\n", RpcException));
        result = E_FAIL;
    } 
    RpcEndExcept

    if (SUCCEEDED(result)) {
        rc = TRUE;
    }
    else {
        ERR((TB,"TSSDRpcQueryClusterInfo: RPC call failed, result=0x%X", result));
    }
HandleError:
    return rc;
}


// wrapper to make RPC call: TSSDRpcQueryServerByName
BOOL SDWMIQueryServerByName(WCHAR *ServerName,
                            DWORD *pNumberOfServers,
                            TSSD_ServerInfo **ppServerInfo)
{
    BOOL rc = FALSE;
    RPC_BINDING_HANDLE rpcHandle;
    DWORD result;
    unsigned long RpcException;

    rpcHandle = OpenSDWMIServer();
    if (rpcHandle == NULL) {
        goto HandleError;
    }

    RpcTryExcept {
        // Make the call.
        result = TSSDRpcQueryServerByName(rpcHandle, ServerName, pNumberOfServers, ppServerInfo);
    }
    RpcExcept(TRUE) {
        RpcException = RpcExceptionCode();
        ERR((TB,"TSSDRpcQueryServerByName: RPC Exception %d\n", RpcException));
        result = E_FAIL;
    } 
    RpcEndExcept

    if (SUCCEEDED(result)) {
        rc = TRUE;    
    }
    else {
        ERR((TB,"TSSDRpcQueryServerByName: RPC call failed, result=0x%X", result));
    }

HandleError:
    return rc;
}

// wrapper to make RPC call: TSSDRpcQueryServersInCluster
BOOL SDWMIQueryServersInCluster(WCHAR *ClusterName,
                               DWORD *pNumberOfServers,
                               TSSD_ServerInfo **ppServerInfo)
{
    BOOL rc = FALSE;
    RPC_BINDING_HANDLE rpcHandle;
    DWORD result;
    unsigned long RpcException;

    rpcHandle = OpenSDWMIServer();
    if (rpcHandle == NULL) {
        goto HandleError;
    }

    RpcTryExcept {
        // Make the call.
        result = TSSDRpcQueryServersInCluster(rpcHandle, ClusterName, pNumberOfServers, ppServerInfo);
    }
    RpcExcept(TRUE) {
        RpcException = RpcExceptionCode();
        ERR((TB,"TSSDRpcQueryServersInCluster: RPC Exception %d\n", RpcException));
        result = E_FAIL;
    } 
    RpcEndExcept

    if (SUCCEEDED(result)) {
        rc = TRUE;    
    }
    else {
        ERR((TB,"TSSDRpcQueryServersInCluster: RPC call failed, result=0x%X", result));
    }

HandleError:
    return rc;
}


// wrapper to make RPC call: TSSDRpcQueryAllServers
BOOL SDWMIQueryAllServers(DWORD *pNumberOfServers,
                          TSSD_ServerInfo **ppServerInfo)
{
    BOOL rc = FALSE;
    RPC_BINDING_HANDLE rpcHandle;
    DWORD result;
    unsigned long RpcException;

    rpcHandle = OpenSDWMIServer();
    if (rpcHandle == NULL) {
        goto HandleError;
    }

    RpcTryExcept {
        // Make the call.
        result = TSSDRpcQueryAllServers(rpcHandle, pNumberOfServers, ppServerInfo);
    }
    RpcExcept(TRUE) {
        RpcException = RpcExceptionCode();
        ERR((TB,"TSSDRpcQueryAllServers: RPC Exception %d\n", RpcException));
        result = E_FAIL;
    } 
    RpcEndExcept

    if (SUCCEEDED(result)) {
        rc = TRUE;    
    }
    else {
        ERR((TB,"TSSDRpcQueryAllServers: RPC call failed, result=0x%X", result));
    }

HandleError:
    return rc;
}



// wrapper to make RPC call: TSSDRpcQuerySessionInfoByUserName
BOOL SDWMIQuerySessionInfoByUserName(WCHAR *UserName,
                                     WCHAR *DomainName,
                                     DWORD *pNumberOfSessions,
                                     TSSD_SessionInfo **ppSessionInfo)
{
    BOOL rc = FALSE;
    RPC_BINDING_HANDLE rpcHandle;
    DWORD result;
    unsigned long RpcException;

    rpcHandle = OpenSDWMIServer();
    if (rpcHandle == NULL) {
        goto HandleError;
    }

    RpcTryExcept {
        // Make the call.
        result = TSSDRpcQuerySessionInfoByUserName(rpcHandle, UserName, DomainName, 
                                                         pNumberOfSessions, ppSessionInfo);
    }
    RpcExcept(TRUE) {
        RpcException = RpcExceptionCode();
        ERR((TB,"TSSDRpcQuerySessionInfoByUserName: RPC Exception %d\n", RpcException));
        result = E_FAIL;
    } 
    RpcEndExcept

    if (SUCCEEDED(result)) {
        rc = TRUE;    
    }
    else {
        ERR((TB,"TSSDRpcQuerySessionInfoByUserName: RPC call failed, result=0x%X", result));
    }

HandleError:
    return rc;
}


// wrapper to make RPC call: TSSDRpcQuerySessionInfoByServer
BOOL SDWMIQuerySessionInfoByServer(WCHAR *ServerName,
                                   DWORD *pNumberOfSessions,
                                   TSSD_SessionInfo **ppSessionInfo)
{
    BOOL rc = FALSE;
    RPC_BINDING_HANDLE rpcHandle;
    DWORD result;
    unsigned long RpcException;

    rpcHandle = OpenSDWMIServer();
    if (rpcHandle == NULL) {
        goto HandleError;
    }

    RpcTryExcept {
        // Make the call.
        result = TSSDRpcQuerySessionInfoByServer(rpcHandle, ServerName, 
                                                       pNumberOfSessions, ppSessionInfo);
    }
    RpcExcept(TRUE) {
        RpcException = RpcExceptionCode();
        ERR((TB,"TSSDRpcQuerySessionInfoByServer: RPC Exception %d\n", RpcException));
        result = E_FAIL;
    } 
    RpcEndExcept

    if (SUCCEEDED(result)) {
        rc = TRUE;    
    }
    else {
        ERR((TB,"TSSDRpcQuerySessionInfoByServer: RPC call failed, result=0x%X", result));
    }

HandleError:
    return rc;
}




// TO DO: Replace "NameSpace" with the appropriate namespace for your
//        provider instance.  For instance:  "root\\default or "root\\cimv2".
//===================================================================


/***********************************************************************
    CWin32_SessionDirectoryCluster
************************************************************************/


/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_SessionDirectoryCluster::CWin32_SessionDirectoryCluster
 *                  This class reads properties such as NumberOfServers, etc.
 *
 *****************************************************************************/
CWin32_SessionDirectoryCluster::CWin32_SessionDirectoryCluster (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{
    TRC2((TB, "CWin32_SessionDirectoryCluster_ctor"));       

    _tcscpy(m_szClusterName, _T("ClusterName"));

    _tcscpy(m_szNumberOfServers, _T("NumberOfServers"));

    _tcscpy(m_szSingleSessionMode, _T("SingleSessionMode"));

    m_pClusterInfo = NULL;
}

//=-------------
/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_SessionDirectoryCluster::~CWin32_SessionDirectoryCluster
 *****************************************************************************/
CWin32_SessionDirectoryCluster::~CWin32_SessionDirectoryCluster ()
{
}
//=-------------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectoryCluster::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_SessionDirectoryCluster::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_E_NOT_FOUND; 
        
    DWORD dwRequiredProperties = 0;
    //CHStringArray asNames;
    CHStringArray aszNames;
    DWORD i, NumberOfClusters = 0;
    WCHAR ClusterName[TSSD_NameLength];
    BOOL rc;

    ERR((TB, "EnumerateInstances in SDCluster"));

    rc = SDWMIQueryAllClusterInfo(&NumberOfClusters, &m_pClusterInfo);
    if (!rc || (NumberOfClusters == 0)) {
        goto HandleError;
    }

    // 
    for(i=0; i<NumberOfClusters; i++)
    {
        CInstance* pInstance = CreateNewInstance(pMethodContext);

        if( pInstance == NULL)
        {
           ERR((TB, "CWin32_SessionDirectoryCluster@ExecQuery: CreateNewInstance failed"));

           hr = WBEM_E_OUT_OF_MEMORY;
           goto HandleError;
        }            
  
        hr = LoadPropertyValues(pInstance, i, BIT_ALL_PROPERTIES);

        if( SUCCEEDED( hr ) )
        {
           hr = pInstance->Commit();
        }

        pInstance->Release();  
    }

    if (m_pClusterInfo != NULL) {
        MIDL_user_free(m_pClusterInfo);
        m_pClusterInfo = NULL;
    }
HandleError:
    return hr ;
}

//=---------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectoryCluster::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key property, the TerminalName. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*****************************************************************************/

HRESULT CWin32_SessionDirectoryCluster::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
    HRESULT hr = WBEM_E_NOT_FOUND;
    CHString StrClusterName;
    DWORD dwRequiredProperties = 0;
    DWORD NumberOfClusters = 0;
    WCHAR ClusterName[TSSD_NameLength];
    BOOL rc;

    ERR((TB, "GetObject in SDCluster"));
    if( Query.IsPropertyRequired(m_szClusterName))
       dwRequiredProperties |= BIT_CLUSTERNAME;
 
    if (Query.IsPropertyRequired(m_szNumberOfServers))
       dwRequiredProperties |= BIT_NUMBEROFSERVERS;

    if (Query.IsPropertyRequired(m_szSingleSessionMode))
       dwRequiredProperties |= BIT_SINGLESESSIONMODE;

    // Get the key property
    pInstance->GetCHString(m_szClusterName, StrClusterName);

    wcsncpy(ClusterName, StrClusterName, TSSD_NameLength);
    ClusterName[TSSD_NameLength - 1] = L'\0';    
    ERR((TB,"TSSDRpcQueryClusterInfo: Query cluster name: %S", ClusterName));
    rc = SDWMIQueryClusterInfo(ClusterName, &NumberOfClusters, &m_pClusterInfo);
    ERR((TB,"ExecQuery: Get numCluster is %d", NumberOfClusters));
    if (!rc || (NumberOfClusters == 0)) {
        goto HandleError;
    }

  
    hr = LoadPropertyValues(pInstance, 0, dwRequiredProperties);

    if (m_pClusterInfo != NULL) {
        MIDL_user_free(m_pClusterInfo);
        m_pClusterInfo = NULL;
    }

HandleError:
    return hr ;
}
//=---------

/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectoryCluster::ExecQuery
*
*  DESCRIPTION :    The method context is passed for use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CWin32_SessionDirectoryCluster::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

    HRESULT hr = WBEM_E_NOT_FOUND, result;
    DWORD dwRequiredProperties = 0;
    //CHStringArray asNames;
    CHStringArray aszNames;
    DWORD i, NumberOfClusters = 0;
    WCHAR ClusterName[TSSD_NameLength];
    BOOL rc;

    //Query.GetValuesForProp(m_szClusterName, asNames);

    //BOOL bGetAllInstances = asNames.GetSize() == 0;

    // Method 1
    if (Query.IsPropertyRequired(m_szClusterName))
        dwRequiredProperties |= BIT_CLUSTERNAME;

    if (Query.IsPropertyRequired(m_szNumberOfServers))
       dwRequiredProperties |= BIT_NUMBEROFSERVERS;

    if (Query.IsPropertyRequired(m_szSingleSessionMode))
       dwRequiredProperties |= BIT_SINGLESESSIONMODE;
    
    result = Query.GetValuesForProp(m_szClusterName, aszNames);
    if ((result != WBEM_S_NO_ERROR) ||
        (aszNames.GetSize() == 0)) {
        // No query found
        goto HandleError;
    }
        
    wcsncpy(ClusterName, aszNames.GetAt(0), TSSD_NameLength);
    ClusterName[TSSD_NameLength - 1] = L'\0';
    ERR((TB,"TSSDRpcQueryClusterInfo: Query cluster name: %S", ClusterName));

    rc = SDWMIQueryClusterInfo(ClusterName, &NumberOfClusters, &m_pClusterInfo);
    ERR((TB,"ExecQuery: Get numCluster is %d", NumberOfClusters));
    if (!rc || (NumberOfClusters == 0)) {
        goto HandleError;
    }

    // 
    for(i=0; i<NumberOfClusters; i++)
    {
        CInstance* pInstance = CreateNewInstance(pMethodContext);

        if( pInstance == NULL)
        {
           ERR((TB, "CWin32_SessionDirectoryCluster@ExecQuery: CreateNewInstance failed"));

           hr = WBEM_E_OUT_OF_MEMORY;
           goto HandleError;
        }            
  
        hr = LoadPropertyValues(pInstance, i, dwRequiredProperties);

        if( SUCCEEDED( hr ) )
        {
           hr = pInstance->Commit();
        }

        pInstance->Release();  
    }

    if (m_pClusterInfo != NULL) {
        MIDL_user_free(m_pClusterInfo);
        m_pClusterInfo = NULL;
    }

HandleError:
    return hr;
}



BOOL CWin32_SessionDirectoryCluster::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}


//=---------
/*************************************************************************************
*
*  FUNCTION    : CWin32_SessionDirectoryCluster::PutInstance
*
*  DESCRIPTION :    PutInstance is in provider classes that can 
*                   write instance information back to the registry.
*
*  INPUTS      :    A pointer to a CInstance object containing the key 
*                   property - ClusterName
* 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    :    
*
***************************************************************************************/

HRESULT CWin32_SessionDirectoryCluster::PutInstance ( const CInstance &Instance, long lFlags)
{   
    return (WBEM_E_PROVIDER_NOT_CAPABLE);    
}


//=---------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectoryCluster::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CWin32_SessionDirectoryCluster::DeleteInstance ( const CInstance &Instance,  long lFlags )
{
    

    return (WBEM_E_PROVIDER_NOT_CAPABLE);

}


//=---------
/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectoryCluster::ExecMethod
*
*  DESCRIPTION :    Override this function to provide support for methods.  
*                   A method is an entry point for the user of your provider 
*                   to request your class perform some function above and 
*                   beyond a change of state.  (A change of state should be 
*                   handled by PutInstance() )
*
*  INPUTS      :    A pointer to a CInstance containing the instance the method was executed against.
*                   A string containing the method name
*                   A pointer to the CInstance which contains the IN parameters.
*                   A pointer to the CInstance to contain the OUT parameters.
*                   A set of specialized method flags
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if not implemented for this class
*                   WBEM_S_NO_ERROR if method executes successfully
*                   WBEM_E_FAILED if error occurs executing method 
*
*  COMMENTS    :    Provides method to configure the License type base on
*                   the Terminal server mode, UseTempFolders, DeleteTempFolders
*                   and Help that are group policy based.
*
*****************************************************************************/
/*HRESULT CWin32_SessionDirectoryCluster::ExecMethod ( const CInstance& Inst,
                        const BSTR bstrMethodName,
                        CInstance *pInParams,
                        CInstance *pOutParams,
                        long lFlags)

{
    
    
    DWORD dwData = 0;
    BOOL fRet = FALSE;
    bool bRet;	
    HRESULT hr = WBEM_S_NO_ERROR;
    

	//If the method takes one or more parameters, require to check for validity of pInParams

    if(pInParams == NULL)
    {
        return WBEM_E_INVALID_METHOD_PARAMETERS;
    }
    

    if( _wcsicmp(bstrMethodName, m_szSetNumberOfSessions) == 0 )
    {   
        bRet = pInParams->GetDWORD(m_szNumberOfSessions, dwData);
        
        if ( !bRet )
        {
            return WBEM_E_INVALID_PARAMETER;
        }                    
                        
        
        // RPC function that sets the Number of Sessions                             
    
        TRC2( (TB, "CWin32_SessionDirectoryClusterSetting@ExecMethod returned 0x%x \n" , hr) );  
    
        if( ERROR_SUCCESS == hr && pOutParams != NULL )
        {
            pOutParams->SetDWORD(L"ReturnValue", WBEM_S_NO_ERROR);
        }
        else
        {                        
            hr = WBEM_E_INVALID_OPERATION;                        
        }                            
    }

    return hr;
}
        */
//=---------

HRESULT CWin32_SessionDirectoryCluster::LoadPropertyValues( CInstance *pInstance, DWORD dwIndex, DWORD dwRequiredProperties)
{      
    dwIndex;
    DWORD dwData = 0;
    DWORD dwSize = 0;
    BOOL bData = 0;
    BOOL bActivate = 0;
    DWORD dwStatus = 0;
    
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    
    // Your RPC call that gets all the data for the instance of interest. You could override the LoadPropertyValues method
    // to pass the data structure you got in GetObject, EnumerateInstances or ExecQuery

    if( dwRequiredProperties & BIT_CLUSTERNAME )
    {
        pInstance->SetCHString(m_szClusterName, m_pClusterInfo[dwIndex].ClusterName);  
        ERR((TB,"UserName is %S", m_pClusterInfo[dwIndex].ClusterName));
    }

    if( dwRequiredProperties & BIT_NUMBEROFSERVERS )
    {        
        pInstance->SetDWORD(m_szNumberOfServers, m_pClusterInfo[dwIndex].NumberOfServers);
        ERR((TB,"NumberofServers is %d", m_pClusterInfo[dwIndex].NumberOfServers));
    }

    if( dwRequiredProperties & BIT_SINGLESESSIONMODE )
    {        
        pInstance->SetDWORD(m_szSingleSessionMode, m_pClusterInfo[dwIndex].SingleSessionMode ? 1 : 0);
    }
    
    return S_OK;
}





/***********************************************************************
    CWin32_SessionDirectoryServer
************************************************************************/
    
    
    
    
/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_SessionDirectoryServer::CWin32_SessionDirectoryServer
 *                  
 *
 *****************************************************************************/
CWin32_SessionDirectoryServer::CWin32_SessionDirectoryServer (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{
        TRC2((TB, "CWin32_SessionDirectoryServer_ctor"));       

        _tcscpy(m_szServerName, _T("ServerName"));

        _tcscpy(m_szServerIPAddress, _T("ServerIPAddress"));

        _tcscpy(m_szClusterName, _T("ClusterName"));

        _tcscpy(m_szNumberOfSessions, _T("NumberOfSessions"));

        _tcscpy(m_szSingleSessionMode, _T("SingleSessionMode"));

        m_pServerInfo = NULL;
}


/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_SessionDirectoryServer::~CWin32_SessionDirectoryServer
 *****************************************************************************/
CWin32_SessionDirectoryServer::~CWin32_SessionDirectoryServer ()
{

}

/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectoryServer::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_SessionDirectoryServer::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    HRESULT hr = WBEM_E_NOT_FOUND; 
        
    RPC_BINDING_HANDLE rpcHandle = NULL;
    DWORD i, NumberOfServers = 0;
    BOOL rc;

    ERR((TB, "EnumerateInstances in SDServer"));

    rc = SDWMIQueryAllServers(&NumberOfServers, &m_pServerInfo);
    if (!rc || (NumberOfServers == 0)) {
        goto HandleError;
    }

    for(i=0; i<NumberOfServers; i++)
    {
        CInstance* pInstance = CreateNewInstance(pMethodContext);

        if( pInstance == NULL)
        {
           ERR((TB, "CWin32_SessionDirectoryServer@ExecQuery: CreateNewInstance failed"));

           hr = WBEM_E_OUT_OF_MEMORY;
           goto HandleError;
        }            
  
        hr = LoadPropertyValues(pInstance, i, BIT_ALL_PROPERTIES);

        if( SUCCEEDED( hr ) )
        {
           hr = pInstance->Commit();
        }

        pInstance->Release();  
    }

    if (m_pServerInfo != NULL) {
        MIDL_user_free(m_pServerInfo);
        m_pServerInfo = NULL;
    }
HandleError: 
    return hr ;
}


/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectoryServer::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key property, the TerminalName. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*****************************************************************************/

HRESULT CWin32_SessionDirectoryServer::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
    HRESULT hr = WBEM_E_NOT_FOUND, result;
    DWORD dwRequiredProperties = 0;
    CHString StrServerName;
    DWORD i, NumberOfServers = 0;
    WCHAR ServerName[TSSD_NameLength];
    BOOL rc;

    if (Query.IsPropertyRequired(m_szServerName))
        dwRequiredProperties |= BIT_SERVERNAME;

    if (Query.IsPropertyRequired(m_szServerIPAddress))
        dwRequiredProperties |= BIT_SERVERIPADDRESS;

    if (Query.IsPropertyRequired(m_szClusterName))
        dwRequiredProperties |= BIT_CLUSTERNAME;

    if (Query.IsPropertyRequired(m_szNumberOfSessions))
       dwRequiredProperties |= BIT_NUMBEROFSESSIONS;

    if (Query.IsPropertyRequired(m_szSingleSessionMode))
       dwRequiredProperties |= BIT_SINGLESESSIONMODE;
    
    // Get the key property
    pInstance->GetCHString(m_szServerName, StrServerName);

    wcsncpy(ServerName, StrServerName, TSSD_NameLength);
    ServerName[TSSD_NameLength - 1] = L'\0';

    // Query by Server Name
    ERR((TB,"SDQueryServerInfo: Query server name: %S", ServerName));
                 
    rc = SDWMIQueryServerByName(ServerName, &NumberOfServers, &m_pServerInfo);
    ERR((TB,"ExecQuery: Get numServer is %d", NumberOfServers));
    if (!rc || (NumberOfServers == 0)) {
        // Not found
            goto HandleError;
    }

    hr = LoadPropertyValues(pInstance, 0, dwRequiredProperties);

    if (m_pServerInfo != NULL) {
        MIDL_user_free(m_pServerInfo);
        m_pServerInfo = NULL;
    }

HandleError:
    return hr;
}


/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectoryServer::ExecQuery
*
*  DESCRIPTION :    The method context is passed for use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CWin32_SessionDirectoryServer::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

    HRESULT hr = WBEM_E_NOT_FOUND, result;
    DWORD dwRequiredProperties = 0;
    //CHStringArray asNames;
    CHStringArray aszNames;
    DWORD i, NumberOfServers = 0;
    WCHAR ServerName[TSSD_NameLength], ClusterName[TSSD_NameLength];
    BOOL rc;

    if (Query.IsPropertyRequired(m_szServerName))
        dwRequiredProperties |= BIT_SERVERNAME;

    if (Query.IsPropertyRequired(m_szServerIPAddress))
        dwRequiredProperties |= BIT_SERVERIPADDRESS;

    if (Query.IsPropertyRequired(m_szClusterName))
        dwRequiredProperties |= BIT_CLUSTERNAME;

    if (Query.IsPropertyRequired(m_szNumberOfSessions))
       dwRequiredProperties |= BIT_NUMBEROFSESSIONS;

    if (Query.IsPropertyRequired(m_szSingleSessionMode))
       dwRequiredProperties |= BIT_SINGLESESSIONMODE;
    
    // Query by Server Name
    result = Query.GetValuesForProp(m_szServerName, aszNames);
    if ((result == WBEM_S_NO_ERROR) &&
        (aszNames.GetSize() != 0)) {
        wcsncpy(ServerName, aszNames.GetAt(0), TSSD_NameLength);
        ServerName[TSSD_NameLength - 1] = L'\0';
        ERR((TB,"SDQueryServerInfo: Query server name: %S", ServerName));
                 
        rc = SDWMIQueryServerByName(ServerName, &NumberOfServers, &m_pServerInfo);
        ERR((TB,"ExecQuery: Get numServer is %d", NumberOfServers));
        if (!rc || (NumberOfServers == 0)) {
            // Not found
            goto HandleError;
        }
    }
    else {
        result = Query.GetValuesForProp(m_szClusterName, aszNames);
        if ((result == WBEM_S_NO_ERROR) &&
            (aszNames.GetSize() != 0)) {
            wcsncpy(ClusterName, aszNames.GetAt(0), TSSD_NameLength);
            ClusterName[TSSD_NameLength - 1] = L'\0';
            ERR((TB,"SDQueryServerInfo: Query Cluster name: %S", ClusterName));
                 
            rc = SDWMIQueryServersInCluster(ClusterName, &NumberOfServers, &m_pServerInfo);
            ERR((TB,"ExecQuery: Get numServer is %d", NumberOfServers));
            if (!rc || (NumberOfServers == 0)) {
                // Not found
                goto HandleError;
            }
        }
    }
    
    // 
    for(i=0; i<NumberOfServers; i++)
    {
        CInstance* pInstance = CreateNewInstance(pMethodContext);

        if( pInstance == NULL)
        {
           ERR((TB, "CWin32_SessionDirectoryServer@ExecQuery: CreateNewInstance failed"));

           hr = WBEM_E_OUT_OF_MEMORY;
           goto HandleError;
        }            
  
        hr = LoadPropertyValues(pInstance, i, dwRequiredProperties);

        if( SUCCEEDED( hr ) )
        {
           hr = pInstance->Commit();
        }

        pInstance->Release();  
    }

    if (m_pServerInfo != NULL) {
        MIDL_user_free(m_pServerInfo);
        m_pServerInfo = NULL;
    }

HandleError:
    return hr;
}



BOOL CWin32_SessionDirectoryServer::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}


/*************************************************************************************
*
*  FUNCTION    : CWin32_SessionDirectoryServer::PutInstance
*
*  DESCRIPTION :    PutInstance is in provider classes that can 
*                   write instance information back to the registry.
*
*  INPUTS      :    A pointer to a CInstance object containing the key 
*                   property - ClusterName
* 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    :    
*
***************************************************************************************/

HRESULT CWin32_SessionDirectoryServer::PutInstance ( const CInstance &Instance, long lFlags)
{   
    return (WBEM_E_PROVIDER_NOT_CAPABLE);    
}


/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectoryServer::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CWin32_SessionDirectoryServer::DeleteInstance ( const CInstance &Instance,  long lFlags )
{
    

    return (WBEM_E_PROVIDER_NOT_CAPABLE);

}



HRESULT CWin32_SessionDirectoryServer::LoadPropertyValues( CInstance *pInstance, DWORD dwIndex, DWORD dwRequiredProperties)
{      
    DWORD dwData = 0;
    DWORD dwSize = 0;
    BOOL bData = 0;
    BOOL bActivate = 0;
    DWORD dwStatus = 0;
    
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    
    if( dwRequiredProperties & BIT_SERVERNAME )
    {
        pInstance->SetCHString(m_szServerName, m_pServerInfo[dwIndex].ServerName);  
        ERR((TB,"Server is %S", m_pServerInfo[dwIndex].ServerName));
    }

    if( dwRequiredProperties & BIT_SERVERIPADDRESS )
    {
        pInstance->SetCHString(m_szServerIPAddress, m_pServerInfo[dwIndex].ServerIPAddress);  
        ERR((TB,"ServerIP is %S", m_pServerInfo[dwIndex].ServerIPAddress));
    }

    if( dwRequiredProperties & BIT_CLUSTERNAME )
    {
        pInstance->SetCHString(m_szClusterName, m_pServerInfo[dwIndex].ClusterName);  
        ERR((TB,"ClusterName is %S", m_pServerInfo[dwIndex].ClusterName));
    }

    if( dwRequiredProperties & BIT_NUMBEROFSESSIONS )
    {        
        pInstance->SetDWORD(m_szNumberOfSessions, m_pServerInfo[dwIndex].NumberOfSessions);
        ERR((TB,"NumberofSessions is %d", m_pServerInfo[dwIndex].NumberOfSessions));
    }

    if( dwRequiredProperties & BIT_SINGLESESSIONMODE )
    {        
        pInstance->SetDWORD(m_szSingleSessionMode, m_pServerInfo[dwIndex].SingleSessionMode ? 1 : 0);
    }
    
    return S_OK;
}





/***********************************************************************
    CWin32_SessionDirectorySession
************************************************************************/
    
    
    
    
/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_SessionDirectorySession::CWin32_SessionDirectorySession
 *                  
 *
 *****************************************************************************/
CWin32_SessionDirectorySession::CWin32_SessionDirectorySession (LPCWSTR lpwszName, LPCWSTR lpwszNameSpace ) : Provider( lpwszName, lpwszNameSpace )
{
        TRC2((TB, "CWin32_SessionDirectorySession_ctor"));       

        _tcscpy(m_szServerName, _T("ServerName"));

        _tcscpy(m_szSessionID, _T("SessionID"));

        _tcscpy(m_szUserName, _T("UserName"));

        _tcscpy(m_szDomainName, _T("DomainName"));

        _tcscpy(m_szServerIPAddress, _T("ServerIPAddress"));

        _tcscpy(m_szTSProtocol, _T("TSProtocol"));

        _tcscpy(m_szApplicationType, _T("ApplicationType"));

        _tcscpy(m_szResolutionWidth, _T("ResolutionWidth"));

        _tcscpy(m_szResolutionHeight, _T("ResolutionHeight"));

        _tcscpy(m_szColorDepth, _T("ColorDepth"));

        _tcscpy(m_szCreateTime, _T("CreateTime"));

        _tcscpy(m_szDisconnectTime, _T("DisconnectTime"));

        _tcscpy(m_szSessionState, _T("SessionState"));

        m_pSessionInfo = NULL;
}


/*****************************************************************************
 *
 *  FUNCTION    :   CWin32_SessionDirectorySession::~CWin32_SessionDirectorySession
 *****************************************************************************/
CWin32_SessionDirectorySession::~CWin32_SessionDirectorySession ()
{

}

/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectorySession::EnumerateInstances
*
*  DESCRIPTION :    Returns all the instances of this class.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                   WBEM_FLAG_DEEP, WBEM_FLAG_SHALLOW, WBEM_FLAG_RETURN_IMMEDIATELY, 
*                   WBEM_FLAG_FORWARD_ONLY, WBEM_FLAG_BIDIRECTIONAL
*
*  RETURNS     :    WBEM_S_NO_ERROR if successful
*
*  COMMENTS    :    All instances on the machine are returned here and
*                   all properties that this class knows how to populate must 
*                   be filled in.  If there are no instances, return 
*                   WBEM_S_NO_ERROR.  
*****************************************************************************/

HRESULT CWin32_SessionDirectorySession::EnumerateInstances (MethodContext* pMethodContext, long lFlags )
{
    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}


/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectorySession::GetObject
*
*  DESCRIPTION :    Find a single instance based on the key property, the TerminalName. 
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::GetObjectAsync.  
*
*  RETURNS     :    WBEM_S_NO_ERROR if the instance can be found
*                   WBEM_E_NOT_FOUND if the instance described by the key properties 
*                   could not be found
*                   WBEM_E_FAILED if the instance could be found but another error 
*                   occurred. 
*
*****************************************************************************/

HRESULT CWin32_SessionDirectorySession::GetObject ( CInstance* pInstance, long lFlags, CFrameworkQuery &Query )
{
    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}


/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectorySession::ExecQuery
*
*  DESCRIPTION :    The method context is passed for use in the creation of 
*                   instances that satisfy the query, and a CFrameworkQuery 
*                   which describes the query.  Create and populate all 
*                   instances which satisfy the query.  You may return more 
*                   instances or more properties than are requested and WinMgmt 
*                   will post filter out any that do not apply.
*
*  INPUTS      :    A pointer to the MethodContext for communication with WinMgmt.
*                   A query object describing the query to satisfy.
*                   A long that contains the flags described in 
*                   IWbemServices::CreateInstanceEnumAsync.  Note that the following
*                   flags are handled by (and filtered out by) WinMgmt:
*                       WBEM_FLAG_FORWARD_ONLY
*                       WBEM_FLAG_BIDIRECTIONAL
*                       WBEM_FLAG_ENSURE_LOCATABLE
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if queries not supported for 
*                       this class or if the query is too complex for this class
*                       to interpret.  The framework will call the EnumerateInstances
*                       function instead and let Winmgmt post filter.
*                   WBEM_E_FAILED if the query failed
*                   WBEM_S_NO_ERROR if query was successful 
*
*  COMMENTS    : TO DO: Most providers will not need to implement this method.  If you don't, WinMgmt 
*                       will call your enumerate function to get all the instances and perform the 
*                       filtering for you.  Unless you expect SIGNIFICANT savings from implementing 
*                       queries, you should remove this method.  You should also remove this method
*                       if you are implementing a 'method only' provider.
*
*****************************************************************************/
HRESULT CWin32_SessionDirectorySession::ExecQuery (MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags)
{

    HRESULT hr = WBEM_E_NOT_FOUND, result;
    DWORD dwRequiredProperties = 0;
    //CHStringArray asNames;
    CHStringArray aszNames;
    DWORD i, NumberOfSessions = 0;
    WCHAR UserName[TSSD_NameLength], DomainName[TSSD_NameLength], ServerName[TSSD_NameLength];
    BOOL rc;
    BOOL bQueryByServerName = FALSE;


    if (Query.IsPropertyRequired(m_szServerName))
        dwRequiredProperties |= BIT_SERVERNAME;

    if (Query.IsPropertyRequired(m_szSessionID))
        dwRequiredProperties |= BIT_SESSIONID;

    if (Query.IsPropertyRequired(m_szUserName))
        dwRequiredProperties |= BIT_USERNAME;

    if (Query.IsPropertyRequired(m_szDomainName))
        dwRequiredProperties |= BIT_DOMAINNAME;

    if (Query.IsPropertyRequired(m_szServerIPAddress))
       dwRequiredProperties |= BIT_SERVERIPADDRESS;

    if (Query.IsPropertyRequired(m_szTSProtocol))
       dwRequiredProperties |= BIT_TSPROTOCOL;

    if (Query.IsPropertyRequired(m_szApplicationType))
        dwRequiredProperties |= BIT_APPLICATIONTYPE;

    if (Query.IsPropertyRequired(m_szResolutionWidth))
        dwRequiredProperties |= BIT_RESOLUTIONWIDTH;

    if (Query.IsPropertyRequired(m_szResolutionHeight))
        dwRequiredProperties |= BIT_RESOLUTIONHEIGHT;

    if (Query.IsPropertyRequired(m_szColorDepth))
        dwRequiredProperties |= BIT_COLORDEPTH;

    if (Query.IsPropertyRequired(m_szCreateTime))
        dwRequiredProperties |= BIT_CREATETIME;

    if (Query.IsPropertyRequired(m_szDisconnectTime))
        dwRequiredProperties |= BIT_DISCONNECTTIME;

    if (Query.IsPropertyRequired(m_szSessionState))
        dwRequiredProperties |= BIT_SESSIONSTATE;

    // Get the server name
    result = Query.GetValuesForProp(m_szServerName, aszNames);
    if ((result == WBEM_S_NO_ERROR) &&
        (aszNames.GetSize() != 0)) {
        bQueryByServerName = TRUE;
        wcsncpy(ServerName, aszNames.GetAt(0), TSSD_NameLength);
        ServerName[TSSD_NameLength - 1] = L'\0';
        ERR((TB, "Query sessions for servername %S", ServerName));

        rc = SDWMIQuerySessionInfoByServer(ServerName, &NumberOfSessions, &m_pSessionInfo);
        ERR((TB,"ExecQuery: Get numSession is %d", NumberOfSessions));
        if (!rc || (NumberOfSessions == 0)) {
            goto HandleError;
        }
    }
    else {
        // Get the user name
        result = Query.GetValuesForProp(m_szUserName, aszNames);
        if ((result != WBEM_S_NO_ERROR) ||
            (aszNames.GetSize() == 0)) {
            // No query found
            goto HandleError;
        }
        wcsncpy(UserName, aszNames.GetAt(0), TSSD_NameLength);
        UserName[TSSD_NameLength - 1] = L'\0';
        ERR((TB, "Query UserName is %S", UserName));

        // Get the domain name
        result = Query.GetValuesForProp(m_szDomainName, aszNames);
        if ((result != WBEM_S_NO_ERROR) ||
            (aszNames.GetSize() == 0)) {
            // No query found
            goto HandleError;
        }
        wcsncpy(DomainName, aszNames.GetAt(0), TSSD_NameLength);
        DomainName[TSSD_NameLength - 1] = L'\0';
        ERR((TB, "Query DomainName is %S", DomainName));
    
        rc = SDWMIQuerySessionInfoByUserName(UserName, DomainName, &NumberOfSessions, &m_pSessionInfo);
        ERR((TB,"ExecQuery: Get numSession is %d", NumberOfSessions));
        if (!rc || (NumberOfSessions == 0)) {
            goto HandleError;
        }
    }

    // 
    for(i=0; i<NumberOfSessions; i++)
    {
        CInstance* pInstance = CreateNewInstance(pMethodContext);

        if( pInstance == NULL)
        {
           ERR((TB, "CWin32_SessionDirectorySession@ExecQuery: CreateNewInstance failed"));

           hr = WBEM_E_OUT_OF_MEMORY;
           goto HandleError;
        }            
  
        hr = LoadPropertyValues(pInstance, i, dwRequiredProperties);

        if( SUCCEEDED( hr ) )
        {
           hr = pInstance->Commit();
        }

        pInstance->Release();  
    }

    if (m_pSessionInfo != NULL) {
        MIDL_user_free(m_pSessionInfo);
        m_pSessionInfo = NULL;
    }

HandleError: 
    return hr;
}



BOOL CWin32_SessionDirectorySession::IsInList(const CHStringArray &asArray, LPCWSTR pszString)
{
    DWORD dwSize = asArray.GetSize();

    for (DWORD x=0; x < dwSize; x++)
    {
        if( asArray[x].CompareNoCase(pszString) == 0 )
        {
            return TRUE;
        }
    }

    return FALSE;
}


/*************************************************************************************
*
*  FUNCTION    : CWin32_SessionDirectorySession::PutInstance
*
*  DESCRIPTION :    PutInstance is in provider classes that can 
*                   write instance information back to the registry.
*
*  INPUTS      :    A pointer to a CInstance object containing the key 
*                   property - ClusterName
* 
*                   A long that contains the flags described in 
*                   IWbemServices::PutInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if PutInstance is not available
*                   WBEM_E_FAILED if there is an error delivering the instance
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly delivered
*
*  COMMENTS    :    
*
***************************************************************************************/

HRESULT CWin32_SessionDirectorySession::PutInstance ( const CInstance &Instance, long lFlags)
{   
    return (WBEM_E_PROVIDER_NOT_CAPABLE);    
}


/*****************************************************************************
*
*  FUNCTION    :    CWin32_SessionDirectorySession::DeleteInstance
*
*  DESCRIPTION :    DeleteInstance, like PutInstance, actually writes information
*                   to the software or hardware.  For most hardware devices, 
*                   DeleteInstance should not be implemented, but for software
*                   configuration, DeleteInstance implementation is plausible.
*
*  INPUTS      :    A pointer to a CInstance object containing the key properties. 
*                   A long that contains the flags described in 
*                   IWbemServices::DeleteInstanceAsync.  
*
*  RETURNS     :    WBEM_E_PROVIDER_NOT_CAPABLE if DeleteInstance is not available.
*                   WBEM_E_FAILED if there is an error deleting the instance.
*                   WBEM_E_INVALID_PARAMETER if any of the instance properties 
*                   are incorrect.
*                   WBEM_S_NO_ERROR if instance is properly deleted.
*
*  COMMENTS    : TO DO: If you don't intend to support deleting instances or are
*                       creating a 'method only' provider, remove this method.
*
*****************************************************************************/
HRESULT CWin32_SessionDirectorySession::DeleteInstance ( const CInstance &Instance,  long lFlags )
{ 
    return (WBEM_E_PROVIDER_NOT_CAPABLE);
}



HRESULT CWin32_SessionDirectorySession::LoadPropertyValues( CInstance *pInstance, DWORD dwIndex, DWORD dwRequiredProperties)
{      
    BOOL rc;
    
    HRESULT hr = WBEM_E_INVALID_PARAMETER;
    
    if( dwRequiredProperties & BIT_SERVERNAME )
    {
        pInstance->SetCHString(m_szServerName, m_pSessionInfo[dwIndex].ServerName);  
        ERR((TB,"Server is %S", m_pSessionInfo[dwIndex].ServerName));
    }

    if( dwRequiredProperties & BIT_SESSIONID )
    {
        pInstance->SetDWORD(m_szSessionID, m_pSessionInfo[dwIndex].SessionID);  
        ERR((TB,"Session ID is %d", m_pSessionInfo[dwIndex].SessionID));
    }

    if( dwRequiredProperties & BIT_USERNAME )
    {
        pInstance->SetCHString(m_szUserName, m_pSessionInfo[dwIndex].UserName);  
        ERR((TB,"UserName is %S", m_pSessionInfo[dwIndex].UserName));
    }

    if( dwRequiredProperties & BIT_DOMAINNAME )
    {
        pInstance->SetCHString(m_szDomainName, m_pSessionInfo[dwIndex].DomainName);  
        ERR((TB,"DomainName is %S", m_pSessionInfo[dwIndex].DomainName));
    }

    if( dwRequiredProperties & BIT_SERVERIPADDRESS )
    {
        pInstance->SetCHString(m_szServerIPAddress, m_pSessionInfo[dwIndex].ServerIPAddress);  
        ERR((TB,"ServerIP is %S", m_pSessionInfo[dwIndex].ServerIPAddress));
    }

    if( dwRequiredProperties & BIT_TSPROTOCOL )
    {
        pInstance->SetDWORD(m_szTSProtocol, m_pSessionInfo[dwIndex].TSProtocol);  
        ERR((TB,"TSProtocol is %d", m_pSessionInfo[dwIndex].TSProtocol));
    }

    if( dwRequiredProperties & BIT_APPLICATIONTYPE )
    {
        pInstance->SetCHString(m_szApplicationType, m_pSessionInfo[dwIndex].ApplicationType);  
        ERR((TB,"AppType is %S", m_pSessionInfo[dwIndex].ApplicationType));
    }

    if( dwRequiredProperties & BIT_RESOLUTIONWIDTH )
    {
        pInstance->SetDWORD(m_szResolutionWidth, m_pSessionInfo[dwIndex].ResolutionWidth);  
        ERR((TB,"ResolutionWidth is %d", m_pSessionInfo[dwIndex].ResolutionWidth));
    }

    if( dwRequiredProperties & BIT_RESOLUTIONHEIGHT )
    {
        pInstance->SetDWORD(m_szResolutionHeight, m_pSessionInfo[dwIndex].ResolutionHeight);  
        ERR((TB,"ResolutionHeight is %d", m_pSessionInfo[dwIndex].ResolutionHeight));
    }

    if( dwRequiredProperties & BIT_COLORDEPTH )
    {
        pInstance->SetDWORD(m_szColorDepth, m_pSessionInfo[dwIndex].ColorDepth);  
        ERR((TB,"ColorDepth is %d", m_pSessionInfo[dwIndex].ColorDepth));
    }

    if( dwRequiredProperties & BIT_CREATETIME )
    {
        rc = pInstance->SetDateTime(m_szCreateTime, WBEMTime(m_pSessionInfo[dwIndex].CreateTime));  
    }

    if( dwRequiredProperties & BIT_DISCONNECTTIME )
    {
        // Only set Disconnect time when the session is disconnected
        if (m_pSessionInfo[dwIndex].SessionState != 0) {
            pInstance->SetDateTime(m_szDisconnectTime, WBEMTime(m_pSessionInfo[dwIndex].DisconnectTime));  
        }
    }

    if( dwRequiredProperties & BIT_SESSIONSTATE )
    {
        pInstance->SetDWORD(m_szSessionState, m_pSessionInfo[dwIndex].SessionState ? 1 : 0);  
        ERR((TB,"SessionState is %d", m_pSessionInfo[dwIndex].SessionState));
    }   
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\sdwmi.h ===
/******************************************************************
   Copyright (C) 2001 Microsoft Corp.

   sdwmi.H -- WMI provider class definition
 
   Description: 
   
*******************************************************************/

// Property set identification
//============================

#ifndef _SessionDirectory_H_
#define _SessionDirectory_H_
#include "resource.h"
//#include <utilsub.h>
#include <allproc.h>
#include "trace.h"
#include "jetrpc.h"

#define SDWMI_NAME_LENGTH 64
#define TSSD_NameLength 128
#define PROVIDER_NAME_Win32_WIN32_SESSIONDIRECTORYCLUSTER_Prov L"Win32_SessionDirectoryCluster"
#define PROVIDER_NAME_Win32_WIN32_SESSIONDIRECTORYSERVER_Prov L"Win32_SessionDirectoryServer"
#define PROVIDER_NAME_Win32_WIN32_SESSIONDIRECTORYSESSION_Prov L"Win32_SessionDirectorySession"

#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( TCHAR )

extern BOOL g_bInitialized;

// See ExecQuery for details of the usage of these #defines
#define BIT_CLUSTERNAME                         0x00000001
#define BIT_NUMBEROFSERVERS                     0x00000002
#define BIT_SINGLESESSIONMODE                   0x00000004
#define BIT_SERVERNAME                          0x00000008
#define BIT_SERVERIPADDRESS                     0x00000010
#define BIT_NUMBEROFSESSIONS                    0x00000020
#define BIT_USERNAME                            0x00000040
#define BIT_DOMAINNAME                          0x00000080
#define BIT_SESSIONID                           0x00000100
#define BIT_TSPROTOCOL                          0x00000200
#define BIT_APPLICATIONTYPE                     0x00000400
#define BIT_RESOLUTIONWIDTH                     0x00000800
#define BIT_RESOLUTIONHEIGHT                    0x00001000
#define BIT_COLORDEPTH                          0x00002000
#define BIT_CREATETIME                          0x00004000
#define BIT_DISCONNECTTIME                      0x00008000
#define BIT_SESSIONSTATE                        0x00010000

#define BIT_ALL_PROPERTIES                      0xffffffff

//=---------


class CWin32_SessionDirectoryCluster : public Provider
{
    public:
        // Constructor/destructor
        //=======================

        CWin32_SessionDirectoryCluster(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CWin32_SessionDirectoryCluster();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions    
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        //virtual HRESULT ExecMethod(const CInstance& Instance,
         //               const BSTR bstrMethodName,
         //               CInstance *pInParams,
         //               CInstance *pOutParams,
         //               long lFlags = 0L );

        HRESULT LoadPropertyValues(CInstance *pInstance, DWORD dwIndex, DWORD dwRequiredProperties);


        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    

    private:
        // All data members for CTerminalWinstation should be included here.      

        BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
        TCHAR m_szClusterName[SDWMI_NAME_LENGTH];
        TCHAR m_szNumberOfServers[SDWMI_NAME_LENGTH];
        TCHAR m_szSingleSessionMode[SDWMI_NAME_LENGTH];
        //TCHAR m_szSetNumberOfSessions[ SDWMI_NAME_LENGTH ]; 
        TSSD_ClusterInfo *m_pClusterInfo;
} ;



class CWin32_SessionDirectoryServer : public Provider
{
    public:
        // Constructor/destructor
        //=======================

        CWin32_SessionDirectoryServer(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CWin32_SessionDirectoryServer();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions    
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        //virtual HRESULT ExecMethod(const CInstance& Instance,
         //               const BSTR bstrMethodName,
         //               CInstance *pInParams,
         //               CInstance *pOutParams,
         //               long lFlags = 0L );

        HRESULT LoadPropertyValues(CInstance *pInstance, DWORD dwIndex, DWORD dwRequiredProperties);


        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    

    private:
        // All data members for CWin32_SessionDirectoryServer should be included here.      

        BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
        TCHAR m_szServerName[SDWMI_NAME_LENGTH];
        TCHAR m_szServerIPAddress[SDWMI_NAME_LENGTH];
        TCHAR m_szClusterName[SDWMI_NAME_LENGTH];
        TCHAR m_szNumberOfSessions[SDWMI_NAME_LENGTH];
        TCHAR m_szSingleSessionMode[SDWMI_NAME_LENGTH];
        //TCHAR m_szSetNumberOfSessions[ SDWMI_NAME_LENGTH ]; 
        TSSD_ServerInfo *m_pServerInfo;
} ;




class CWin32_SessionDirectorySession : public Provider
{
    public:
        // Constructor/destructor
        //=======================

        CWin32_SessionDirectorySession(LPCWSTR lpwszClassName, LPCWSTR lpwszNameSpace);
        virtual ~CWin32_SessionDirectorySession();

    protected:
        // Reading Functions
        //============================
        virtual HRESULT EnumerateInstances(MethodContext*  pMethodContext, long lFlags = 0L);
        virtual HRESULT GetObject(CInstance* pInstance, long lFlags, CFrameworkQuery &Query);
        virtual HRESULT ExecQuery(MethodContext *pMethodContext, CFrameworkQuery& Query, long lFlags = 0L);

        // Writing Functions    
        //============================
        virtual HRESULT PutInstance(const CInstance& Instance, long lFlags = 0L);
        virtual HRESULT DeleteInstance(const CInstance& Instance, long lFlags = 0L);

        // Other Functions
        //virtual HRESULT ExecMethod(const CInstance& Instance,
         //               const BSTR bstrMethodName,
         //               CInstance *pInParams,
         //               CInstance *pOutParams,
         //               long lFlags = 0L );

        HRESULT LoadPropertyValues(CInstance *pInstance, DWORD dwIndex, DWORD dwRequiredProperties);


        // TO DO: Declare any additional functions and accessor
        // functions for private data used by this class
        //===========================================================

    

    private:
        // All data members for CWin32_SessionDirectorySession should be included here.      

        BOOL IsInList(const CHStringArray &asArray, LPCWSTR pszString);
        TCHAR m_szServerName[SDWMI_NAME_LENGTH];
        TCHAR m_szSessionID[SDWMI_NAME_LENGTH];
        TCHAR m_szUserName[SDWMI_NAME_LENGTH];
        TCHAR m_szDomainName[SDWMI_NAME_LENGTH];
        TCHAR m_szServerIPAddress[SDWMI_NAME_LENGTH];
        TCHAR m_szTSProtocol[SDWMI_NAME_LENGTH];
        TCHAR m_szApplicationType[SDWMI_NAME_LENGTH];
        TCHAR m_szResolutionWidth[SDWMI_NAME_LENGTH];
        TCHAR m_szResolutionHeight[SDWMI_NAME_LENGTH];
        TCHAR m_szColorDepth[SDWMI_NAME_LENGTH];
        TCHAR m_szCreateTime[SDWMI_NAME_LENGTH];
        TCHAR m_szDisconnectTime[SDWMI_NAME_LENGTH];
        TCHAR m_szSessionState[SDWMI_NAME_LENGTH];

        TSSD_SessionInfo *m_pSessionInfo;
} ;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\stdafx.h ===
/****************************************************************************/
// stdafx.h
//
// Copyright (C) 2001 Microsoft Corp.
/****************************************************************************/

#ifndef _STDAFX_H_
#define _STDAFX_H_
#endif

#ifdef DBG


#define DBGMSG( x , y ) \
    {\
    TCHAR tchErr[256]; \
    wsprintf( tchErr , x , y ); \
    ODS( tchErr ); \
    }

#define ODS OutputDebugString

#else

#define DBGMSG
#define ODS

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\trace.h ===
/****************************************************************************/
// trace.h
//
// Tracing definitions. See trace.c for other information.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif


#if DBG || defined(_DEBUG)

#include <stdio.h>


// Zones. Up to 32 zones can be defined, these are predefined for general use.
#define Z_ASSRT 0x01
#define Z_ERR    0x02
#define Z_WRN    0x04
#define Z_TRC1   0x08
#define Z_TRC2   0x10

// Defined in msmcs.c.
extern char TB[1024];
extern UINT32 g_TraceMask;
void TracePrintZ(UINT32, char *);

// Error, warning, trace level 1, and trace level 2 definitions.
#define ERR(X) TRCZ(Z_ERR, X)
#define WRN(X) TRCZ(Z_WRN, X)
#define TRC1(X) TRCZ(Z_TRC1, X)
#define TRC2(X) TRCZ(Z_TRC2, X)
#define ASSRT(COND, X) \
{  \
    if (!(COND)) { \
        TRCZ(Z_ASSRT, X); \
        DebugBreak(); \
    }  \
}

#define TRCZ(Z, X) \
{ \
    if (g_TraceMask & (Z)) { \
        sprintf X; \
        TracePrintZ((Z), TB); \
    } \
}


#else  // DBG

#define ERR(X)
#define WRN(X)
#define TRC1(X)
#define TRC2(X)
#define ASSRT(COND, X)

#endif  // DBG



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\sessdir\tssdwmi\trace.cpp ===
/****************************************************************************/
// trace.c
//
// Tracing code and definitions. See trace.h for other info.
//
// Copyright (C) 1999-2000 Microsoft Corporation
/****************************************************************************/
#include "stdafx.h"
#include <windows.h>
#include "trace.h"

#if DBG || defined(_DEBUG)



struct _ZoneInfo
{
    UINT32 Zone;
    char *Prefix;
} TRC_ZI[] =
{
    { Z_ASSRT,  "TSSDWMI: !!! ASSERT: " },
    { Z_ERR,    "TSSDWMI: *** ERROR: " },
    { Z_WRN,    "TSSDWMI: Warning: " },
    { Z_TRC1,   "TSSDWMI: " },
    { Z_TRC2,   "TSSDWMI: " },
};
int NumTRC_ZIEntries = sizeof(TRC_ZI) / sizeof(struct _ZoneInfo);


// Globals.
//UINT32 g_TraceMask = 0xFFFFFFFF;
UINT32 g_TraceMask = 0x0000000F;
char TB[1024];
char TB2[1024];


// Main output function.
void TracePrintZ(UINT32 ZoneFlag, char *OutString)
{
    int i;
    char *Prefix = "";

    // Find the zone information in the zone table.
    for (i = 0; i < NumTRC_ZIEntries; i++)
        if (TRC_ZI[i].Zone == ZoneFlag)
            Prefix = TRC_ZI[i].Prefix;

    // Now create the final string.
    wsprintfA(TB2, "%s%s\n", Prefix, OutString);

    // Send to output.
    OutputDebugStringA(TB2);
}



#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\acl.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *  Acl.h
 *
 *  Routine to add the TERMINAL_SERVER_RID to any object.
 *
 *  Breen Hagan - 5/4/99
 */

#ifndef __TSOC_ACL_H__
#define __TSOC_ACL_H__

//
//  Includes
//

#include <aclapi.h>

//
//  Function Prototypes
//

BOOL
AddTerminalServerUserToSD(
    PSECURITY_DESCRIPTOR *ppSd,
    DWORD  NewAccess,
    PACL   *ppDacl
    );

#ifdef LATERMUCHLATER
BOOL
AddTerminalServerUserToObjectsSecurityDescriptor(
    HANDLE hObject,
    SE_OBJECT_TYPE ObjectType,
    DWORD NewAccess
    );
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\acl.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation


/*************************************************************************
*
* acl.c
*
* Generic routines to manage ACL's
*
* Author:  John Richardson 04/25/97
*
*
*************************************************************************/

/*
 *  Includes
 */
#include "stdafx.h"
/*
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
*/

#include <windows.h>
#include <rpc.h>
#include <stdio.h>
#include <process.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <lmerr.h>

#undef DBG
#define DBG 1
#define DBGTRACE 1

#define DbgPrint(x)
#if DBG
//ULONG
//DbgPrint(
//    PCH Format,
//    ...
//    );

#define DBGPRINT(x) DbgPrint(x)
#if DBGTRACE
#define TRACE0(x)   DbgPrint x
#define TRACE1(x)   DbgPrint x
#else
#define TRACE0(x)
#define TRACE1(x)
#endif
#else
#define DBGPRINT(x)
#define TRACE0(x)
#define TRACE1(x)
#endif

/*
 * Forward references
 */
BOOL
xxxLookupAccountName(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    );

BOOL
SelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    );


/*****************************************************************************
 *
 *  AddTerminalServerUserToSD
 *
 *   Add the given user for the given domain to the security descriptor.
 *   The callers security descriptor may be re-allocated.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/
BOOL
AddTerminalServerUserToSD(
    PSECURITY_DESCRIPTOR *ppSd,
    DWORD  NewAccess,
    PACL   *ppDacl
    )
{
    ULONG i;
    BOOL Result;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    DWORD Length;
    DWORD NewAclLength;
    PACE_HEADER OldAce;
    PACE_HEADER NewAce;
    ACL_SIZE_INFORMATION AclInfo;
    PSID pSid = NULL;
    PACL Dacl = NULL;
    PACL NewDacl = NULL;
    PACL NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    PSECURITY_DESCRIPTOR OldSD = NULL;
    SID_IDENTIFIER_AUTHORITY SepNtAuthority = SECURITY_NT_AUTHORITY;

    OldSD = *ppSd;

    pSid = LocalAlloc(LMEM_FIXED, 1024);
    if (!pSid || !InitializeSid(pSid, &SepNtAuthority, 1))
    {
        return( FALSE );
    };

    *(GetSidSubAuthority(pSid, 0 )) = SECURITY_TERMINAL_SERVER_RID;


    /*
     * Convert SecurityDescriptor to absolute format. It generates
     * a new SecurityDescriptor for its output which we must free.
     */
    Result = SelfRelativeToAbsoluteSD( OldSD, &NewSD, NULL );
    if ( !Result ) {
        LOGMESSAGE1(_T("Could not convert to AbsoluteSD %d\n"),GetLastError());
        LocalFree( pSid );
        return( FALSE );
    }

    // Must get DACL pointer again from new (absolute) SD
    Result = GetSecurityDescriptorDacl(
                 NewSD,
                 &DaclPresent,
                 &Dacl,
                 &DaclDefaulted
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Could not get Dacl %d\n"),GetLastError());
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    //
    // If no DACL, no need to add the user since no DACL
    // means all accesss
    //
    if( !DaclPresent ) {
        LOGMESSAGE2(_T("SD has no DACL, Present %d, Defaulted %d\n"),DaclPresent,DaclDefaulted);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( TRUE );
    }

    //
    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows all access to the object.
    //
    if( Dacl == NULL ) {
        LOGMESSAGE2(_T("SD has NULL DACL, Present %d, Defaulted %d\n"),DaclPresent,DaclDefaulted);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( TRUE );
    }

    // Get the current ACL's size
    Result = GetAclInformation(
                 Dacl,
                 &AclInfo,
                 sizeof(AclInfo),
                 AclSizeInformation
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error GetAclInformation %d\n"),GetLastError());
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    //
    // Create a new ACL to put the new access allowed ACE on
    // to get the right structures and sizes.
    //
    NewAclLength = sizeof(ACL) +
                   sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                   GetLengthSid( pSid );

    NewAceDacl = (PACL) LocalAlloc( LMEM_FIXED, NewAclLength );
    if ( NewAceDacl == NULL ) {
        LOGMESSAGE1(_T("Error LocalAlloc %d bytes\n"),NewAclLength);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Initializing Acl %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = AddAccessAllowedAce(
                 NewAceDacl,
                 ACL_REVISION,
                 NewAccess,
                 pSid
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error adding Ace %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    LOGMESSAGE1(_T("Added 0x%x Access to ACL\n"),NewAccess);

    Result = GetAce( NewAceDacl, 0, (void **)&NewAce );
    if( !Result ) {
        LOGMESSAGE1(_T("Error getting Ace %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /* add CONTAINER_INHERIT_ACE TO AceFlags */
    NewAce->AceFlags |= CONTAINER_INHERIT_ACE;


    /*
     * Allocate new DACL and copy existing ACE list
     */
    Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    NewDacl = (PACL) LocalAlloc( LMEM_FIXED, Length );
    if( NewDacl == NULL ) {
        LOGMESSAGE1(_T("Error LocalAlloc %d bytes\n"),Length);
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = InitializeAcl( NewDacl, Length, ACL_REVISION );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Initializing Acl %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /*
     * Insert new ACE at the front of the DACL
     */
    Result = AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Adding New Ace to Acl %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /*
     * Now put the ACE's on the old Dacl to the new Dacl
     */
    for ( i = 0; i < AclInfo.AceCount; i++ ) {

        Result = GetAce( Dacl, i, (void **) &OldAce );
        if( !Result ) {
            LOGMESSAGE1(_T("Error getting old Ace from Acl %d\n"),GetLastError());
            LocalFree( NewDacl );
            LocalFree( NewAceDacl );
            LocalFree( pSid );
            LocalFree( NewSD );
            return( FALSE );
        }

        Result = AddAce( NewDacl, ACL_REVISION, i+1, OldAce, OldAce->AceSize );
        if( !Result ) {
            LOGMESSAGE1(_T("Error setting old Ace to Acl %d\n"),GetLastError());
            LocalFree( NewDacl );
            LocalFree( NewAceDacl );
            LocalFree( pSid );
            LocalFree( NewSD );
            return( FALSE );
        }
    }

    /*
     * Set new DACL for Security Descriptor
     */
    Result = SetSecurityDescriptorDacl(
                 NewSD,
                 TRUE,
                 NewDacl,
                 FALSE
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error setting New Dacl to SD %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    // the DACL must be passed back so that it can be saved to the registry using the new
    // GetNamedSecurityInfo() func.
    *ppDacl = Dacl = NewDacl;


    // Release the callers old security descriptor
//    LocalFree( OldSD );


    // There was a bug in W2K such that keys created under our install hive had the 
    // incorrect DACL headers which caused the DACL to be basically open to all users
    // for full control.
    // The prolem was due to the wrong SD->Control flag which was NT4 style though ACLs
    // were in NT5 style
    SetSecurityDescriptorControl(NewSD,
                        SE_DACL_AUTO_INHERIT_REQ|SE_DACL_AUTO_INHERITED,
                        SE_DACL_AUTO_INHERIT_REQ|SE_DACL_AUTO_INHERITED);

    *ppSd = NewSD;

    // The new SD is in absolute format, so don't free the SID.
//  LocalFree( pSid );

    return( TRUE );
}

/*****************************************************************************
 *
 *  AddUserToSD
 *
 *   Add the given user for the given domain to the security descriptor.
 *   The callers security descriptor may be re-allocated.
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
AddUserToSD(
    PSECURITY_DESCRIPTOR *ppSd,
    PWCHAR pAccount,
    PWCHAR pDomain,
    DWORD  NewAccess
    )
{
    ULONG i;
    BOOL Result;
    BOOL DaclPresent;
    BOOL DaclDefaulted;
    DWORD Length;
//    NET_API_STATUS Status;
    DWORD /*NewAceLength,*/ NewAclLength;
    PACE_HEADER OldAce;
    PACE_HEADER NewAce;
    ACL_SIZE_INFORMATION AclInfo;
    PWCHAR pDC = NULL;
    PSID pSid = NULL;
    PACL Dacl = NULL;
    PACL NewDacl = NULL;
    PACL NewAceDacl = NULL;
    PSECURITY_DESCRIPTOR NewSD = NULL;
    PSECURITY_DESCRIPTOR OldSD = NULL;

    OldSD = *ppSd;
/*
    // Get our domain controller
    Status = NetGetAnyDCName(
                 NULL,    // Local computer
                 pDomain,
                 (LPBYTE*)&pDC
                 );
    if( Status != NERR_Success ) {
        LOGMESSAGE2(_T("SUSERVER: Could not get domain controller %d for domain %ws\n"),Status,pDomain);
        return( FALSE );
    }
*/
    // Get Users SID
    Result  = xxxLookupAccountName(
                  pDomain,
                  pAccount,
                  &pSid
                  );
    if( !Result ) {
        LOGMESSAGE2(_T("SUSERVER: Could not get users SID %d, %ws\n"),GetLastError(),pAccount);
        NetApiBufferFree( pDC );
        return( FALSE );
    }

    NetApiBufferFree( pDC );

    /*
     * Convert SecurityDescriptor to absolute format. It generates
     * a new SecurityDescriptor for its output which we must free.
     */
    Result = SelfRelativeToAbsoluteSD( OldSD, &NewSD, NULL );
    if ( !Result ) {
        LOGMESSAGE1(_T("Could not convert to AbsoluteSD %d\n"),GetLastError());
        LocalFree( pSid );
        return( FALSE );
    }

    // Must get DACL pointer again from new (absolute) SD
    Result = GetSecurityDescriptorDacl(
                 NewSD,
                 &DaclPresent,
                 &Dacl,
                 &DaclDefaulted
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Could not get Dacl %d\n"),GetLastError());
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    //
    // If no DACL, no need to add the user since no DACL
    // means all accesss
    //
    if( !DaclPresent ) {
        LOGMESSAGE2(_T("SD has no DACL, Present %d, Defaulted %d\n"),DaclPresent,DaclDefaulted);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( TRUE );
    }

    //
    // Code can return DaclPresent, but a NULL which means
    // a NULL Dacl is present. This allows all access to the object.
    //
    if( Dacl == NULL ) {
        LOGMESSAGE2(_T("SD has NULL DACL, Present %d, Defaulted %d\n"),DaclPresent,DaclDefaulted);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( TRUE );
    }

    // Get the current ACL's size
    Result = GetAclInformation(
                 Dacl,
                 &AclInfo,
                 sizeof(AclInfo),
                 AclSizeInformation
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error GetAclInformation %d\n"),GetLastError());
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    //
    // Create a new ACL to put the new access allowed ACE on
    // to get the right structures and sizes.
    //
    NewAclLength = sizeof(ACL) +
                   sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG) +
                   GetLengthSid( pSid );

    NewAceDacl = (PACL) LocalAlloc( LMEM_FIXED, NewAclLength );
    if ( NewAceDacl == NULL ) {
        LOGMESSAGE1(_T("Error LocalAlloc %d bytes\n"),NewAclLength);
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = InitializeAcl( NewAceDacl, NewAclLength, ACL_REVISION );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Initializing Acl %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = AddAccessAllowedAce(
                 NewAceDacl,
                 ACL_REVISION,
                 NewAccess,
                 pSid
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error adding Ace %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    LOGMESSAGE1(_T("Added 0x%x Access to ACL\n"),NewAccess);

    Result = GetAce( NewAceDacl, 0, (void **)&NewAce );
    if( !Result ) {
        LOGMESSAGE1(_T("Error getting Ace %d\n"),GetLastError());
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /* add CONTAINER_INHERIT_ACE TO AceFlags */
    NewAce->AceFlags |= CONTAINER_INHERIT_ACE;


    /*
     * Allocate new DACL and copy existing ACE list
     */
    Length = AclInfo.AclBytesInUse + NewAce->AceSize;
    NewDacl = (PACL) LocalAlloc( LMEM_FIXED, Length );
    if( NewDacl == NULL ) {
        LOGMESSAGE1(_T("Error LocalAlloc %d bytes\n"),Length);
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Result = InitializeAcl( NewDacl, Length, ACL_REVISION );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Initializing Acl %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /*
     * Insert new ACE at the front of the DACL
     */
    Result = AddAce( NewDacl, ACL_REVISION, 0, NewAce, NewAce->AceSize );
    if( !Result ) {
        LOGMESSAGE1(_T("Error Adding New Ace to Acl %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    /*
     * Now put the ACE's on the old Dacl to the new Dacl
     */
    for ( i = 0; i < AclInfo.AceCount; i++ ) {

        Result = GetAce( Dacl, i, (void **) &OldAce );
        if( !Result ) {
            LOGMESSAGE1(_T("Error getting old Ace from Acl %d\n"),GetLastError());
            LocalFree( NewDacl );
            LocalFree( NewAceDacl );
            LocalFree( pSid );
            LocalFree( NewSD );
            return( FALSE );
        }

        Result = AddAce( NewDacl, ACL_REVISION, i+1, OldAce, OldAce->AceSize );
        if( !Result ) {
            LOGMESSAGE1(_T("Error setting old Ace to Acl %d\n"),GetLastError());
            LocalFree( NewDacl );
            LocalFree( NewAceDacl );
            LocalFree( pSid );
            LocalFree( NewSD );
            return( FALSE );
        }
    }

    /*
     * Set new DACL for Security Descriptor
     */
    Result = SetSecurityDescriptorDacl(
                 NewSD,
                 TRUE,
                 NewDacl,
                 FALSE
                 );
    if( !Result ) {
        LOGMESSAGE1(_T("Error setting New Dacl to SD %d\n"),GetLastError());
        LocalFree( NewDacl );
        LocalFree( NewAceDacl );
        LocalFree( pSid );
        LocalFree( NewSD );
        return( FALSE );
    }

    Dacl = NewDacl;

    // Release the callers old security descriptor
//    LocalFree( OldSD );

    *ppSd = NewSD;

    // The new SD is in absolute format, so don't free the SID.
//  LocalFree( pSid );

    return( TRUE );
}

/*******************************************************************************
 *
 * SelfRelativeToAbsoluteSD
 *
 *   Convert a Security Descriptor from self-relative format to absolute.
 *
 *  ENTRY:
 *    SecurityDescriptorIn (input)
 *      Pointer to self-relative SD to convert
 *    SecurityDescriptorIn (output)
 *      Pointer to location to return absolute SD
 *    ReturnLength (output)
 *      Pointer to location to return length of absolute SD
 *
 *  EXIT:
 *
 ******************************************************************************/

BOOL
SelfRelativeToAbsoluteSD(
    PSECURITY_DESCRIPTOR SecurityDescriptorIn,
    PSECURITY_DESCRIPTOR *SecurityDescriptorOut,
    PULONG ReturnedLength
    )
{
    BOOL Result;
    PACL pDacl, pSacl;
    PSID pOwner, pGroup;
    PSECURITY_DESCRIPTOR pSD;
    ULONG SdSize, DaclSize, SaclSize, OwnerSize, GroupSize;

    /*
     * Determine buffer size needed to convert self-relative SD to absolute.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
	SdSize = DaclSize = SaclSize = OwnerSize = GroupSize = 0;

    __try {
        
        Result = MakeAbsoluteSD(
                     SecurityDescriptorIn,
                     NULL, &SdSize,
                     NULL, &DaclSize,
                     NULL, &SaclSize,
                     NULL, &OwnerSize,
                     NULL, &GroupSize
                     );

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( Result || (GetLastError() != ERROR_INSUFFICIENT_BUFFER) ) {
        LOGMESSAGE1(_T("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n"),GetLastError());
        return( FALSE );
    }

    /*
     * Allocate memory for the absolute SD and setup various pointers
     */
    pSD = LocalAlloc( LMEM_FIXED, SdSize + DaclSize + SaclSize + OwnerSize + GroupSize );
    if ( pSD == NULL )
        return( FALSE );

    pDacl = (PACL)((PCHAR)pSD + SdSize);
    pSacl = (PACL)((PCHAR)pDacl + DaclSize);
    pOwner = (PSID)((PCHAR)pSacl + SaclSize);
    pGroup = (PSID)((PCHAR)pOwner + OwnerSize);

    /*
     * Now convert self-relative SD to absolute format.
     * We use try-except here since if the input security descriptor value
     * is sufficiently messed up, it is possible for this call to trap.
     */
    __try {
        Result = MakeAbsoluteSD(
                     SecurityDescriptorIn,
                     pSD, &SdSize,
                     pDacl, &DaclSize,
                     pSacl, &SaclSize,
                     pOwner, &OwnerSize,
                     pGroup, &GroupSize
                     );

    } __except( EXCEPTION_EXECUTE_HANDLER ) {
        SetLastError( ERROR_INVALID_SECURITY_DESCR );
        Result = FALSE;
    }

    if ( !Result ) {
        LOGMESSAGE1(_T("SUSERVER: SelfRelativeToAbsoluteSD, Error %d\n"),GetLastError());
        LocalFree( pSD );
        return( FALSE );
    }

    *SecurityDescriptorOut = pSD;

    if ( ReturnedLength )
        *ReturnedLength = SdSize + DaclSize + SaclSize + OwnerSize + GroupSize;

    return( TRUE );
}

/*****************************************************************************
 *
 *  xxxLookupAccountName
 *
 *   Wrapper to lookup the SID for a given account name
 *
 *   Returns a pointer to the SID in newly allocated memory
 *
 * ENTRY:
 *   Param1 (input/output)
 *     Comments
 *
 * EXIT:
 *   STATUS_SUCCESS - no error
 *
 ****************************************************************************/

BOOL
xxxLookupAccountName(
    PWCHAR pSystemName,
    PWCHAR pAccountName,
    PSID   *ppSid
    )
{
    BOOL  rc;
    DWORD Size, DomainSize, Error;
    SID_NAME_USE Type;
    PWCHAR pDomain = NULL;
    PSID pSid = NULL;
    WCHAR Buf;

    Size = 0;
    DomainSize = 0;

    rc = LookupAccountNameW(
             pSystemName,
             pAccountName,
             &Buf,    // pSid
             &Size,
             &Buf,    // pDomain
             &DomainSize,
             &Type
             );

    if( rc ) {
        return( FALSE );
    }
    else {
        Error = GetLastError();
        if( Error != ERROR_INSUFFICIENT_BUFFER ) {
            return( FALSE );
        }

        pSid = LocalAlloc( LMEM_FIXED, Size );
        if( pSid == NULL ) {
            return( FALSE );            
        }

        pDomain = (WCHAR *)LocalAlloc( LMEM_FIXED, DomainSize*sizeof(WCHAR) );
        if( pDomain == NULL ) {
            LocalFree( pSid );
            return( FALSE );            
        }

        rc = LookupAccountNameW(
                 pSystemName,
                 pAccountName,
                 pSid,
                 &Size,
                 pDomain,
                 &DomainSize,
                 &Type
                 );

        if( !rc ) {
            LocalFree( pSid );
            LocalFree( pDomain );
            return( FALSE );
        }

        *ppSid = pSid;

        LocalFree( pDomain );
        return( TRUE );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\cocpage.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *  COCPage.cpp
 *
 *  A base class for an optional component wizard page.
 */

#include "stdafx.h"
#include "COCPage.h"

/*
 *  Class COCPageData
 */

COCPageData::COCPageData ()
{
    m_fPageActivated = FALSE;
}

BOOL COCPageData::WasPageActivated ()
{
    return(m_fPageActivated);
}

COCPageData* COCPage::GetPageData () const
{
    return(m_pPageData);
}


/*
 *  Class COCPage
 */

COCPage::COCPage (IN COCPageData  *pPageData)
{
    ASSERT(pPageData);

    m_hDlgWnd = NULL;
    m_pPageData = pPageData;
}

COCPage::~COCPage ()
{
}

BOOL COCPage::Initialize ()
{
    dwFlags         = PSP_USECALLBACK;
    dwSize          = sizeof(PROPSHEETPAGE);
    hInstance       = GetInstance();
    lParam          = (LPARAM)this;
    pfnCallback     = PropSheetPageProc;
    pfnDlgProc      = PropertyPageDlgProc;
    pszTemplate     = MAKEINTRESOURCE(GetPageID());

    pszHeaderTitle = MAKEINTRESOURCE(GetHeaderTitleResource());
    if (pszHeaderTitle != NULL) 
	{
        dwFlags |= PSP_USEHEADERTITLE;
    }

    pszHeaderSubTitle = MAKEINTRESOURCE(GetHeaderSubTitleResource());
    if (pszHeaderSubTitle != NULL) 
	{
        dwFlags |= PSP_USEHEADERSUBTITLE;
    }

    return(pszTemplate != NULL ? TRUE : FALSE);
}

BOOL COCPage::OnNotify (IN HWND hDlgWnd, IN WPARAM wParam, IN LPARAM lParam)
{
    BOOL fApplied;
    NMHDR *pnmh = (LPNMHDR) lParam;

    switch(pnmh->code) 
	{
    case PSN_SETACTIVE:
        GetPageData()->m_fPageActivated = CanShow();
        SetWindowLongPtr(hDlgWnd, DWLP_MSGRESULT, GetPageData()->m_fPageActivated ? 0 : -1);
        PropSheet_SetWizButtons(GetParent(hDlgWnd), PSWIZB_NEXT | PSWIZB_BACK);
        
		if (GetPageData()->m_fPageActivated) 
		{
            GetHelperRoutines().ShowHideWizardPage(GetHelperRoutines().OcManagerContext,
                                        TRUE);
            OnActivation ();
        }

		break;

    case PSN_WIZNEXT:
        fApplied = ApplyChanges();
        SetWindowLongPtr(hDlgWnd, DWLP_MSGRESULT, fApplied ? 0 : -1);
        break;

    case PSN_WIZBACK:
        OnDeactivation();
        SetWindowLongPtr(hDlgWnd, DWLP_MSGRESULT, 0);
        break;

    case NM_CLICK:
    case NM_RETURN:
        OnLink(wParam);
        break;

    default:
        return(FALSE);

    }

    return(TRUE);
}

UINT CALLBACK COCPage::PropSheetPageProc (IN HWND /* hWnd */, IN UINT uMsg, IN LPPROPSHEETPAGE  pPsp)
{
    COCPage* pThis;

    ASSERT(pPsp != NULL);

    pThis = reinterpret_cast<COCPage*>(pPsp->lParam);
    ASSERT(pThis != NULL);

    switch(uMsg) 
	{
    case PSPCB_RELEASE:
        delete pThis;
    }

    return(1);
}

INT_PTR CALLBACK COCPage::PropertyPageDlgProc (IN HWND hDlgWnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam)
{
    COCPage*    pDlg;

    if (uMsg == WM_INITDIALOG) 
	{
        pDlg = reinterpret_cast<COCPage*>(LPPROPSHEETPAGE(lParam)->lParam);
    } 
	else 
	{
        pDlg = reinterpret_cast<COCPage*>(GetWindowLongPtr(hDlgWnd, DWLP_USER));
    }

    if (pDlg == NULL) 
	{
        return(0);
    }

    switch(uMsg) 
	{
    case WM_INITDIALOG:
        pDlg->SetDlgWnd(hDlgWnd);
        SetWindowLongPtr(hDlgWnd, DWLP_USER, (LONG_PTR)pDlg);
        return(pDlg->OnInitDialog(hDlgWnd, wParam, lParam));

    case WM_NOTIFY:
        return(pDlg->OnNotify(hDlgWnd, wParam, lParam));

    case WM_COMMAND:
        return(pDlg->OnCommand(hDlgWnd, wParam, lParam));
    }

    return(0);
}

VOID COCPage::OnLink (WPARAM /*wParam*/)
{
}

VOID COCPage::OnActivation ()
{
}

BOOL COCPage::OnCommand (IN HWND /* hDlgWnd */, IN WPARAM /* wParam */, IN LPARAM /* lParam */)
{
    return(TRUE);
}

VOID COCPage::OnDeactivation ()
{
}

BOOL COCPage::OnInitDialog(IN HWND /* hDlgWnd */, IN WPARAM /* wParam */, IN LPARAM /* lParam */ )
{
    return(TRUE);
}

BOOL COCPage::ApplyChanges ()
{
    return(TRUE);
}

VOID COCPage::SetDlgWnd (IN HWND hDlgWnd)
{
    m_hDlgWnd = hDlgWnd;
}

BOOL COCPage::VerifyChanges ()
{
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\cocpage.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
*  COCPage.h
*
*  A base class for an optional component wizard page.
*/

#ifndef __TSOC_COCPAGE_H__
#define __TSOC_COCPAGE_H__

#include "stdafx.h"

class COCPageData
{
    friend class COCPage;
    
public:
    
    //
    //  Constructor.
    //
    
    COCPageData		();
    
    //
    //  Standard functions.
    //
    
    BOOL WasPageActivated ();
    
protected:
    
    BOOL m_fPageActivated;
    
};

class COCPage : public PROPSHEETPAGE
{
public:
    
    //
    //  Constructor and destructor.
    //
    
    COCPage (IN COCPageData  *pPageData);
    
    ~COCPage ();
    
    //
    //  Standard functions.
    //
    
    BOOL Initialize ();
    
    // most of the messages are handled by base class.
    // if you override this function, you might want to rerount the message to base class
    // for handling common messages.
    virtual BOOL OnNotify (IN HWND hDlgWnd, IN WPARAM   wParam, IN LPARAM   lParam);
    
    //
    //  Callback functions.
    //
    
    static UINT CALLBACK PropSheetPageProc (IN HWND hWnd, IN UINT uMsg, IN LPPROPSHEETPAGE  pPsp);
    static INT_PTR CALLBACK PropertyPageDlgProc (IN HWND hDlgWnd, IN UINT uMsg, IN WPARAM wParam, IN LPARAM lParam);
    
protected:
    COCPageData*    m_pPageData;
    HWND            m_hDlgWnd;
    
    virtual BOOL	ApplyChanges();
    virtual BOOL    CanShow () = 0;
    
    virtual COCPageData* GetPageData () const;
    virtual UINT GetPageID () = 0;
    virtual UINT GetHeaderTitleResource () = 0;
    virtual UINT GetHeaderSubTitleResource () = 0;
    virtual VOID OnActivation ();
    virtual BOOL OnCommand (IN HWND hDlgWnd, IN WPARAM wParam, IN LPARAM lParam);
    virtual VOID OnDeactivation ();
    virtual BOOL OnInitDialog (IN HWND hDlgWnd, IN WPARAM wParam, IN LPARAM lParam);
    VOID SetDlgWnd (IN HWND hDlgWnd);
    virtual BOOL VerifyChanges ();
    virtual VOID OnLink(WPARAM wParam);
};

#endif // __TSOC_COCPAGE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\hydraoc.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      hydraoc.h
 *
 *  Abstract:
 *
 *      Common Header file for the HydraOC Component.
 *      HydraOc Component is an optional component which installs Termainal Server (Hydra)
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _HYDRAOC_H_
#define _HYDRAOC_H_


#include "state.h"

DWORD IsStringInMultiString         (HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound);
DWORD RemoveStringFromMultiString   (HKEY hkey, LPCTSTR szSuitekey, LPCTSTR szSuitevalue, LPCTSTR szAppend);
DWORD AppendStringToMultiString     (HKEY hkey, LPCTSTR szSuitekey, LPCTSTR szSuitevalue, LPCTSTR szAppend);
DWORD GetStringValue                (HINF hinf, LPCTSTR  section, LPCTSTR key,  LPTSTR outputbuffer, DWORD dwSize);
DWORD GetSectionToBeProcessed       (HINF hInf, LPTSTR section, LPCTSTR SubcomponentId);
BOOL  DoesHydraKeysExists           ();
BOOL  DisableNonRDPWinstations      ();
BOOL  UpgradeRdpWinstations         ();
BOOL  IsMetaFrameWinstation         (CRegistry *pRegWinstation);
BOOL  IsConsoleWinStation           (CRegistry *pRegWinstation);
BOOL  IsRdpWinStation               (CRegistry *pRegWinstation);
BOOL  UpdateRDPWinstation           (CRegistry *pRegWinstation);
BOOL  DisableWinStation             (CRegistry *pRegWinstation);
void TickGauge (DWORD  dwTickCount);
void TickComplete();

BOOL DisableInternetConnector ();

const int   S_SIZE                          = 256;
const int   MAX_PRODUCT_SUITE_SIZE          = 256;
const int   MAX_VERSION_STRING              = 256;
const UINT  COMPONENT_VERSION               = OCMANAGER_VERSION;

const UINT  REGSVR_ADDREMOVE                = 1;
const UINT  REGSVR_PROGRAM                  = 2;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\constants.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// constants.cpp
#include "stdafx.h"

LPCTSTR     TERMINAL_SERVER_THIS_VERSION    = _T("5.2");
LPCTSTR     TERMINAL_SERVER_NO_VERSION      = _T("0.0");

#ifdef UNICODE
LPCTSTR     PRODUCT_SUITE_KEY               = REG_CONTROL L"\\ProductOptions";
LPCTSTR     SYSTEM_RDPWD_KEY                = WD_REG_NAME L"\\rdpwd";
LPCTSTR     TS_LANATABLE_KEY                = REG_CONTROL_TSERVER L"\\LanaTable";
#else
LPCTSTR     PRODUCT_SUITE_KEY               = REG_CONTROL_A "\\ProductOptions";
LPCTSTR     SYSTEM_RDPWD_KEY                = WD_REG_NAME_A "\\rdpwd";
LPCTSTR     TS_LANATABLE_KEY                = REG_CONTROL_TSERVER_A "\\LanaTable";
#endif

LPCTSTR     TS_VIDEO_KEY                    = _T("VIDEO");
LPCTSTR     PRODUCT_SUITE_VALUE             = _T("ProductSuite");
LPCTSTR     TS_PRODUCT_SUITE_STRING         = _T("Terminal Server");
LPCTSTR     TS_ENABLED_VALUE                = _T("TSEnabled");
LPCTSTR     TS_APPCMP_VALUE                 = _T("TSAppCompat");

LPCTSTR     LOGFILE                         = _T("%SystemRoot%\\tsoc.log");
LPCTSTR     MODULENAME                      = _T("tsoc.dll");

LPCTSTR     BASE_COMPONENT_NAME             = _T("TerminalServices");
LPCTSTR     APPSRV_COMPONENT_NAME           = _T("TerminalServer");

LPCTSTR		REMOTE_ADMIN_SERVER_X86         = _T("RemoteAdmin.srv.x86");
LPCTSTR		APPSERVER_SERVER_X86            = _T("AppServer.srv.x86");
LPCTSTR		TSDISABLED_SERVER_X86           = _T("DisabledTS.srv.x86");
LPCTSTR		PERSONALTS_SERVER_X86           = _T("PersonalTS.srv.x86");

LPCTSTR		REMOTE_ADMIN_SERVER_AMD64       = _T("RemoteAdmin.srv.amd64");
LPCTSTR		APPSERVER_SERVER_AMD64          = _T("AppServer.srv.amd64");
LPCTSTR		TSDISABLED_SERVER_AMD64         = _T("DisabledTS.srv.amd64");
LPCTSTR		PERSONALTS_SERVER_AMD64         = _T("PersonalTS.srv.amd64");

LPCTSTR		REMOTE_ADMIN_SERVER_IA64        = _T("RemoteAdmin.srv.ia64");
LPCTSTR		APPSERVER_SERVER_IA64           = _T("AppServer.srv.ia64");
LPCTSTR		TSDISABLED_SERVER_IA64          = _T("DisabledTS.srv.ia64");
LPCTSTR		PERSONALTS_SERVER_IA64          = _T("PersonalTS.srv.ia64");

LPCTSTR     UPGRADE_FROM_40_SERVER_X86      = _T("UpgradeFrom40Section.server.x86");
LPCTSTR     UPGRADE_FROM_50_SERVER_X86      = _T("UpgradeFrom50Section.server.x86");
LPCTSTR     UPGRADE_FROM_51_SERVER_X86      = _T("UpgradeFrom51Section.server.x86");
LPCTSTR     UPGRADE_FROM_52_SERVER_X86      = _T("UpgradeFrom52Section.server.x86");
LPCTSTR     FRESH_INSTALL_SERVER_X86        = _T("FreshInstallSection.server.x86");

LPCTSTR     UPGRADE_FROM_52_SERVER_AMD64    = _T("UpgradeFrom52Section.server.amd64");
LPCTSTR     FRESH_INSTALL_SERVER_AMD64      = _T("FreshInstallSection.server.amd64");

LPCTSTR     UPGRADE_FROM_40_SERVER_IA64     = _T("UpgradeFrom40Section.server.ia64");
LPCTSTR     UPGRADE_FROM_50_SERVER_IA64     = _T("UpgradeFrom50Section.server.ia64");
LPCTSTR     UPGRADE_FROM_51_SERVER_IA64     = _T("UpgradeFrom51Section.server.ia64");
LPCTSTR     UPGRADE_FROM_52_SERVER_IA64     = _T("UpgradeFrom52Section.server.ia64");
LPCTSTR     FRESH_INSTALL_SERVER_IA64       = _T("FreshInstallSection.server.ia64");

LPCTSTR		REMOTE_ADMIN_PRO_X86            = _T("RemoteAdmin.pro.x86");
LPCTSTR		APPSERVER_PRO_X86               = _T("AppServer.pro.x86");
LPCTSTR		TSDISABLED_PRO_X86              = _T("DisabledTS.pro.x86");
LPCTSTR		PERSONALTS_PRO_X86              = _T("PersonalTS.pro.x86");

LPCTSTR		REMOTE_ADMIN_PRO_AMD64          = _T("RemoteAdmin.pro.amd64");
LPCTSTR		APPSERVER_PRO_AMD64             = _T("AppServer.pro.amd64");
LPCTSTR		TSDISABLED_PRO_AMD64            = _T("DisabledTS.pro.amd64");
LPCTSTR		PERSONALTS_PRO_AMD64            = _T("PersonalTS.pro.amd64");

LPCTSTR		REMOTE_ADMIN_PRO_IA64           = _T("RemoteAdmin.pro.ia64");
LPCTSTR		APPSERVER_PRO_IA64              = _T("AppServer.pro.ia64");
LPCTSTR		TSDISABLED_PRO_IA64             = _T("DisabledTS.pro.ia64");
LPCTSTR		PERSONALTS_PRO_IA64             = _T("PersonalTS.pro.ia64");

LPCTSTR     UPGRADE_FROM_40_PRO_X86         = _T("UpgradeFrom40Section.pro.x86");
LPCTSTR     UPGRADE_FROM_50_PRO_X86         = _T("UpgradeFrom50Section.pro.x86");
LPCTSTR     UPGRADE_FROM_51_PRO_X86         = _T("UpgradeFrom51Section.pro.x86");
LPCTSTR     UPGRADE_FROM_52_PRO_X86         = _T("UpgradeFrom52Section.pro.x86");
LPCTSTR     FRESH_INSTALL_PRO_X86           = _T("FreshInstallSection.pro.x86");

LPCTSTR     UPGRADE_FROM_52_PRO_AMD64       = _T("UpgradeFrom52Section.pro.amd64");
LPCTSTR     FRESH_INSTALL_PRO_AMD64         = _T("FreshInstallSection.pro.amd64");

LPCTSTR     UPGRADE_FROM_40_PRO_IA64        = _T("UpgradeFrom40Section.pro.ia64");
LPCTSTR     UPGRADE_FROM_50_PRO_IA64        = _T("UpgradeFrom50Section.pro.ia64");
LPCTSTR     UPGRADE_FROM_51_PRO_IA64        = _T("UpgradeFrom51Section.pro.ia64");
LPCTSTR     UPGRADE_FROM_52_PRO_IA64        = _T("UpgradeFrom52Section.pro.ia64");
LPCTSTR     FRESH_INSTALL_PRO_IA64          = _T("FreshInstallSection.pro.ia64");

// LPCTSTR     SECURITY_APPSRV_SECTION         = _T("TerminalServices.AppSrvDefaultSecurity");
// LPCTSTR     SECURITY_REMADM_SECTION         = _T("TerminalServices.RemAdmDefaultSecurity");
// LPCTSTR     SECURITY_PRO_SECTION            = _T("TerminalServices.ProDefaultSecurity");


LPCTSTR     TSCLIENTS_INSTALL_SECTION_SERVER       = _T("TSClientInstallSection.server");
LPCTSTR     TSCLIENTS_UNINSTALL_SECTION_SERVER     = _T("TSClientUninstallSection.server");

LPCTSTR     TSCLIENTS_INSTALL_SECTION_PRO   = _T("TSClientInstallSection.pro");
LPCTSTR     TSCLIENTS_UNINSTALL_SECTION_PRO = _T("TSClientUninstallSection.pro");

LPCTSTR     TS_UNATTEND_APPSRVKEY           = _T("TerminalServer");
LPCTSTR     TS_UNATTEND_PERMKEY             = _T("PermissionsSetting");
LPCTSTR     TSCLIENT_DIRECTORY              = _T("%SystemRoot%\\system32\\clients\\tsclient");

LPCTSTR     TS_EVENT_SOURCE                 = _T("TermService");

LPCTSTR     TERMSRV_PACK_4_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 4");
LPCTSTR     TERMSRV_PACK_5_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 5");
LPCTSTR     TERMSRV_PACK_6_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 6");
LPCTSTR     TERMSRV_PACK_7_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 7");
LPCTSTR     TERMSRV_PACK_8_KEY              = _T("Windows NT Terminal Server 4.0 Service Pack 8");

LPCTSTR     SOFTWARE_UNINSTALL_KEY          = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");
LPCTSTR	    DENY_CONN_VALUE                 = _T("fDenyTSConnections");
LPCTSTR	    TS_ALLOW_CON_ENTRY              = _T("AllowConnections");
LPCTSTR	    TS_ALLOW_CON_ENTRY_2            = _T("AllowConnection");
LPCTSTR	    TS_DENY_POPUP                   = _T("NoHelpPopup");
LPCTSTR	    TS_LICENSING_MODE               = _T("LicensingMode");

LPCTSTR     SVCHOSST_KEY                    = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost");
LPCTSTR     TERMSVCS_VAL                    = _T("termsvcs");
LPCTSTR     NETSVCS_VAL                     = _T("netsvcs");
LPCTSTR     TERMSERVICE                     = _T("TermService");
LPCTSTR     TERMSERVICE_MULTISZ             = _T("TermService\0");
LPCTSTR     TERMSVCS_PARMS                  = _T("CoInitializeSecurityParam");
LPCTSTR     SVCHOSST_TERMSRV_KEY            = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Svchost\\termsvcs");
LPCTSTR     RUN_KEY                         = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run");
LPCTSTR     HELP_POPUPRUN_VALUE             = _T("TerminalServerInstalled");
LPCTSTR     HELP_PUPUP_COMMAND              = _T("rundll32.exe %windir%\\system32\\tscc.dll, TSCheckList");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\constants.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// constants.cpp
#include "stdafx.h"

#ifndef __TSOC_CONSTANTS_H__
#define __TSOC_CONSTANTS_H__

extern LPCTSTR     TERMINAL_SERVER_THIS_VERSION;
extern LPCTSTR     TERMINAL_SERVER_NO_VERSION;

extern LPCTSTR     PRODUCT_SUITE_KEY;
extern LPCTSTR     SYSTEM_RDPWD_KEY;
extern LPCTSTR     TS_LANATABLE_KEY;
extern LPCTSTR     TS_VIDEO_KEY;
extern LPCTSTR     PRODUCT_SUITE_VALUE;
extern LPCTSTR     TS_PRODUCT_SUITE_STRING;
extern LPCTSTR     TS_ENABLED_VALUE;
extern LPCTSTR     TS_APPCMP_VALUE;

extern LPCTSTR     LOGFILE;
extern LPCTSTR     MODULENAME;

extern LPCTSTR     BASE_COMPONENT_NAME;
extern LPCTSTR     APPSRV_COMPONENT_NAME;

extern LPCTSTR      REMOTE_ADMIN_SERVER_X86;
extern LPCTSTR      APPSERVER_SERVER_X86;
extern LPCTSTR      TSDISABLED_SERVER_X86;
extern LPCTSTR      PERSONALTS_SERVER_X86;


extern LPCTSTR      REMOTE_ADMIN_SERVER_AMD64;
extern LPCTSTR      APPSERVER_SERVER_AMD64;
extern LPCTSTR      TSDISABLED_SERVER_AMD64;
extern LPCTSTR      PERSONALTS_SERVER_AMD64;

extern LPCTSTR      REMOTE_ADMIN_SERVER_IA64;
extern LPCTSTR      APPSERVER_SERVER_IA64;
extern LPCTSTR      TSDISABLED_SERVER_IA64;
extern LPCTSTR      PERSONALTS_SERVER_IA64;

extern LPCTSTR     UPGRADE_FROM_40_SERVER_X86;
extern LPCTSTR     UPGRADE_FROM_50_SERVER_X86;
extern LPCTSTR     UPGRADE_FROM_52_SERVER_X86;
extern LPCTSTR     FRESH_INSTALL_SERVER_X86;
extern LPCTSTR     UPGRADE_FROM_51_SERVER_X86;

extern LPCTSTR     UPGRADE_FROM_52_SERVER_AMD64;
extern LPCTSTR     FRESH_INSTALL_SERVER_AMD64;

extern LPCTSTR     UPGRADE_FROM_40_SERVER_IA64;
extern LPCTSTR     UPGRADE_FROM_50_SERVER_IA64;
extern LPCTSTR     UPGRADE_FROM_52_SERVER_IA64;
extern LPCTSTR     FRESH_INSTALL_SERVER_IA64;
extern LPCTSTR     UPGRADE_FROM_51_SERVER_IA64;

extern LPCTSTR      REMOTE_ADMIN_PRO_X86;
extern LPCTSTR      APPSERVER_PRO_X86;
extern LPCTSTR      TSDISABLED_PRO_X86;
extern LPCTSTR      PERSONALTS_PRO_X86;

extern LPCTSTR      REMOTE_ADMIN_PRO_AMD64;
extern LPCTSTR      APPSERVER_PRO_AMD64;
extern LPCTSTR      TSDISABLED_PRO_AMD64;
extern LPCTSTR      PERSONALTS_PRO_AMD64;

extern LPCTSTR      REMOTE_ADMIN_PRO_IA64;
extern LPCTSTR      APPSERVER_PRO_IA64;
extern LPCTSTR      TSDISABLED_PRO_IA64;
extern LPCTSTR      PERSONALTS_PRO_IA64;

// extern LPCTSTR     TOGGLE_ON_SECTION_PRO;
// extern LPCTSTR     TOGGLE_OFF_SECTION_PRO;

extern LPCTSTR     UPGRADE_FROM_40_PRO_X86;
extern LPCTSTR     UPGRADE_FROM_50_PRO_X86;
extern LPCTSTR     UPGRADE_FROM_51_PRO_X86;
extern LPCTSTR     UPGRADE_FROM_52_PRO_X86;
extern LPCTSTR     FRESH_INSTALL_PRO_X86;

extern LPCTSTR     UPGRADE_FROM_52_PRO_AMD64;
extern LPCTSTR     FRESH_INSTALL_PRO_AMD64;

extern LPCTSTR     UPGRADE_FROM_40_PRO_IA64;
extern LPCTSTR     UPGRADE_FROM_50_PRO_IA64;
extern LPCTSTR     UPGRADE_FROM_51_PRO_IA64;
extern LPCTSTR     UPGRADE_FROM_52_PRO_IA64;
extern LPCTSTR     FRESH_INSTALL_PRO_IA64;


// extern LPCTSTR     SECURITY_APPSRV_SECTION;
// extern LPCTSTR     SECURITY_REMADM_SECTION;
// extern LPCTSTR     SECURITY_PRO_SECTION;


extern LPCTSTR     TSCLIENTS_INSTALL_SECTION_SERVER;
extern LPCTSTR     TSCLIENTS_UNINSTALL_SECTION_SERVER;

extern LPCTSTR     TSCLIENTS_INSTALL_SECTION_PRO;
extern LPCTSTR     TSCLIENTS_UNINSTALL_SECTION_PRO;

extern LPCTSTR     TSCLIENT_DIRECTORY;

extern LPCTSTR     TS_EVENT_SOURCE;

#define            TS_UNATTEND_SECTION          BASE_COMPONENT_NAME
extern LPCTSTR     TS_UNATTEND_APPSRVKEY;
extern LPCTSTR     TS_UNATTEND_PERMKEY;

extern LPCTSTR     TERMSRV_PACK_4_KEY;
extern LPCTSTR     TERMSRV_PACK_5_KEY;
extern LPCTSTR     TERMSRV_PACK_6_KEY;
extern LPCTSTR     TERMSRV_PACK_7_KEY;
extern LPCTSTR     TERMSRV_PACK_8_KEY;
extern LPCTSTR     SOFTWARE_UNINSTALL_KEY;

extern LPCTSTR     DENY_CONN_VALUE;
extern LPCTSTR     TS_ALLOW_CON_ENTRY;
extern LPCTSTR     TS_ALLOW_CON_ENTRY_2;
extern LPCTSTR     TS_DENY_POPUP;
extern LPCTSTR     TS_LICENSING_MODE;

extern LPCTSTR     SVCHOSST_KEY;
extern LPCTSTR     NETSVCS_VAL;
extern LPCTSTR     TERMSERVICE;
extern LPCTSTR     TERMSVCS_VAL;
extern LPCTSTR     TERMSVCS_PARMS;
extern LPCTSTR     SVCHOSST_TERMSRV_KEY;
extern LPCTSTR     TERMSERVICE_MULTISZ;
extern LPCTSTR     RUN_KEY;
extern LPCTSTR     HELP_POPUPRUN_VALUE;
extern LPCTSTR     HELP_PUPUP_COMMAND;



//
//  REGAPI.H creates a wide and an ansi version, instead of #ifdef'ing as
//  necessary.
//

#ifdef UNICODE
#define REG_CHGUSR_OPTION_KEY   CHANGEUSER_OPTION_REG_NAME
#define REG_CONTROL_TS_KEY      REG_CONTROL_TSERVER
#define REG_PRODUCT_VER_KEY     REG_CITRIX_PRODUCTVERSION
#define REG_SECURITY_VALUE      REG_SECURITY
#define REG_WINSTATION_KEY      WINSTATION_REG_NAME
#else
#define REG_CHGUSR_OPTION_KEY   CHANGEUSER_OPTION_REG_NAME_A
#define REG_CONTROL_TS_KEY      REG_CONTROL_TSERVER_A
#define REG_PRODUCT_VER_KEY     REG_CITRIX_PRODUCTVERSION_A
#define REG_SECURITY_VALUE      REG_SECURITY_A
#define REG_WINSTATION_KEY      WINSTATION_REG_NAME_A
#endif

#define REG_CONTROL_TS_LICENSING_KEY    TEXT("System\\CurrentControlSet\\Control\\Terminal Server\\Licensing Core")

#define REG_LICENSING_MODE_AC_ON        TEXT("PolicyAcOn")
#define REG_LICENSING_MODE_AC_OFF       TEXT("PolicyAcOff")


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\pages.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// pages.cpp
#include "stdafx.h"

#include "hydraoc.h"
#include "pages.h"



const WARNING_STRING_LENGTH = 2048;

LPCTSTR GetUninstallKey()   {return _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall");}

//
//  ModePage Class
//
/*
void AddHyperLinkToStaticCtl(HWND hDialog, DWORD nTextBox)
{
EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
EXTERN_C BOOL WINAPI LinkWindow_UnregisterClass( HINSTANCE ) ;
#define SIZE_OF_BUFFER( x ) sizeof( x ) / sizeof( x[0] )
#define RECTWIDTH( rc )  ((rc).right - (rc).left)
#define RECTHEIGHT( rc ) ((rc).bottom - (rc).top)


    RECT rcTextCtrl;

    //Read the text that's already in the control.
    TCHAR tchBuffer[512];
    GetWindowText(GetDlgItem(hDialog, nTextBox), tchBuffer, SIZE_OF_BUFFER(tchBuffer));

    //Get the control dimensions
    GetWindowRect(GetDlgItem(hDialog, nTextBox) , &rcTextCtrl);
    if (!DestroyWindow(GetDlgItem(hDialog, nTextBox)))
        LOGMESSAGE0(_T("failed to destroy window"));

    //Registration info for the control
    MapWindowPoints(NULL, hDialog, (LPPOINT)&rcTextCtrl, 2);
    LinkWindow_RegisterClass();

    //Now create the window (using the same dimensions as the
    //hidden control) that will contain the link
    HWND hLW = CreateWindowEx(0,
                          _T("Link Window"),
                          _T("") ,
                          WS_CLIPSIBLINGS | WS_CHILD | WS_VISIBLE,
                          rcTextCtrl.left,
                          rcTextCtrl.top,
                          RECTWIDTH(rcTextCtrl),
                          RECTHEIGHT(rcTextCtrl),
                          hDialog,
                          (HMENU)nTextBox,
                          NULL,
                          NULL);
    if (!hLW)
        LOGMESSAGE2(_T("failed to create link window. %d, lasterror = %d"), hLW, GetLastError());


    //Now write it to the link window
    SetWindowText(hLW, tchBuffer);
}
*/

AppSrvWarningPage::AppSrvWarningPage (COCPageData* pPageData) : COCPage(pPageData)
{
}

BOOL AppSrvWarningPage ::CanShow ()
{
    return (!StateObject.IsUnattended() && StateObject.IsAppServerSelected() && !StateObject.WasItAppServer());
}

BOOL AppSrvWarningPage::OnInitDialog (HWND /* hwndDlg */, WPARAM /* wParam */, LPARAM /* lParam */)
{
    HICON hIcon;

    hIcon = (HICON)LoadImage(
        GetInstance(),
        MAKEINTRESOURCE(IDI_SMALLWARN),
        IMAGE_ICON,
        0,
        0,
        0
        );
    ASSERT(hIcon != NULL);

    SendMessage(
        GetDlgItem(m_hDlgWnd, IDC_WARNING_ICON),
        STM_SETICON,
        (WPARAM)hIcon,
        (LPARAM)0
        );

    TCHAR szWarningString[WARNING_STRING_LENGTH];
    UINT uiWarningId = StateObject.IsFreshInstall() ? IDS_STRING_TSINSTALL_CLEAN : IDS_STRING_TSINSTALL_ARP;
    if (LoadString( GetInstance(), uiWarningId, szWarningString, WARNING_STRING_LENGTH ))
    {
        SetDlgItemText(m_hDlgWnd, IDC_WARNING_MSG, szWarningString);
    }

    return(TRUE);
}


UINT AppSrvWarningPage::GetHeaderTitleResource ()
{
    return IDS_STRING_APPSRV_WARN_TITLE;
}

UINT AppSrvWarningPage::GetHeaderSubTitleResource () 
{
    return IDS_STRING_APPSRV_WARN_SUBTITLE;
}


AppSrvUninstallpage::AppSrvUninstallpage (COCPageData* pPageData) : COCPage(pPageData)
{
}

BOOL AppSrvUninstallpage ::CanShow ()
{
    return ( StateObject.IsStandAlone() && !StateObject.IsUnattended() && !StateObject.IsAppServerSelected() && StateObject.WasItAppServer());
}

BOOL AppSrvUninstallpage::OnInitDialog (HWND /* hwndDlg */, WPARAM /* wParam */, LPARAM /* lParam */)
{
    
    HICON hIcon;
    hIcon = (HICON)LoadImage(
        GetInstance(),
        MAKEINTRESOURCE(IDI_SMALLWARN),
        IMAGE_ICON,
        0,
        0,
        0
        );
    ASSERT(hIcon != NULL);

    SendMessage(
        GetDlgItem(m_hDlgWnd, IDC_WARNING_ICON),
        STM_SETICON,
        (WPARAM)hIcon,
        (LPARAM)0
        );


    TCHAR szWarningString[WARNING_STRING_LENGTH];
    if (LoadString( GetInstance(), IDS_STRING_TSREMOVE, szWarningString, WARNING_STRING_LENGTH ))
    {
        SetDlgItemText(m_hDlgWnd, IDC_WARNING_MSG, szWarningString);
    }


    // AddHyperLinkToStaticCtl(m_hDlgWnd, IDC_WARNING_MSG);

    return(TRUE);
}


UINT AppSrvUninstallpage::GetHeaderTitleResource ()
{
    return IDS_STRING_APPSRV_UNINSTALL_WARN_TITLE;
}

VOID AppSrvUninstallpage::OnLink (WPARAM wParam)
{
    if (wParam == IDC_WARNING_MSG)
    {
        /*
        // To Execute the link in Help&Support Center

        ShellExecute(NULL,TEXT("open"),
            TEXT("hcp://services/subsite?node=Administration_and_Scripting_Tools/Remote_Administration_Tools/")
            TEXT("Remote_Administration_Using_Terminal_Services&topic=MS-ITS:rdesktop.chm::/rdesktopS_setup_s.htm"),NULL,NULL,SW_SHOW);
        */



        const TCHAR szHelpDir[] = _T("%windir%\\Help");
        const TCHAR szHelpCommand[] = _T("MS-ITS:%windir%\\help\\rdesktop.chm::/rdesktopS_overview.htm");
        TCHAR szHelpDirEx[MAX_PATH];


        if (!ExpandEnvironmentStrings(
            szHelpDir,
            szHelpDirEx,
            sizeof(szHelpDirEx)/sizeof(szHelpDirEx[0])))
        {
            return;
        }

        TCHAR szHelpCommandEx[1024];
        if (!ExpandEnvironmentStrings(
            szHelpCommand,
            szHelpCommandEx,
            sizeof(szHelpCommandEx)/sizeof(szHelpCommandEx[0])))
        {
            return;
        }

        ShellExecute(NULL, TEXT("open"), _T("hh.exe"), szHelpCommandEx, szHelpDirEx, SW_SHOW);
    }
}

UINT AppSrvUninstallpage::GetHeaderSubTitleResource () 
{
    return IDS_STRING_APPSRV_UNINSTALL_WARN_SUBTITLE;
}

//
//  DefSecPageData Class
//

DefSecPageData::DefSecPageData() : COCPageData()
{
    m_cArray = 0;
    m_pWinStationArray = NULL;
}

DefSecPageData::~DefSecPageData()
{
    CleanArray();
}

VOID DefSecPageData::CleanArray()
{
    if (m_pWinStationArray != NULL) 
	{
        for (UINT i = 0; i < m_cArray; i++) 
		{
            if (m_pWinStationArray[i] != NULL) 
			{
                LocalFree(m_pWinStationArray[i]);
            }
        }

        LocalFree(m_pWinStationArray);
        m_pWinStationArray = NULL;
    }

    m_cArray = 0;
}


BOOL DefSecPageData::AlocateWinstationsArray (UINT uiWinstationCount)
{
	if (m_pWinStationArray != NULL) 
	{
		CleanArray();
	}

	ASSERT(m_pWinStationArray == NULL);

	if (uiWinstationCount > 0)
	{

		m_pWinStationArray = (LPTSTR*)LocalAlloc(LPTR, uiWinstationCount * sizeof(LPTSTR));

		if (NULL == m_pWinStationArray)
		{
			return FALSE;
		}
	}

	return TRUE;
}

BOOL DefSecPageData::AddWinstation (LPCTSTR pStr)
{
	ASSERT(NULL != m_pWinStationArray);
	ASSERT(pStr);

    LPTSTR pWinStation = (LPTSTR)LocalAlloc(LPTR, (_tcslen(pStr) + 1) * sizeof(TCHAR));

    if (pWinStation == NULL) 
	{
		return FALSE;
    } 
    
	_tcscpy(pWinStation, pStr);
	
    m_pWinStationArray[m_cArray] = pWinStation;
    m_cArray++;

	return TRUE;
}

//
//  DefaultSecurityPage Class
//

DefaultSecurityPage::DefaultSecurityPage(COCPageData* pPageData) : COCPage(pPageData)
{
    m_cWinStations = 0;
    m_hListView = NULL;
}

BOOL DefaultSecurityPage::CanShow ()
{
    return ((m_cWinStations > 0) && StateObject.IsTSEnableSelected() && StateObject.WasItAppServer() != StateObject.IsAppServerSelected() && !StateObject.IsUnattended());
}

BOOL DefaultSecurityPage::OnInitDialog (HWND /* hwndDlg */, WPARAM /* wParam */, LPARAM /* lParam */)
{
    LVCOLUMN lvColumn;
    RECT rc;

    m_hListView = GetDlgItem(m_hDlgWnd, IDC_SECURITY_LISTVIEW);
    ListView_SetExtendedListViewStyleEx(m_hListView, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);

    GetClientRect(m_hListView , &rc);
    lvColumn.mask = LVCF_FMT | LVCF_WIDTH;
    lvColumn.fmt = LVCFMT_LEFT;
    lvColumn.cx = rc.right - rc.left - GetSystemMetrics(SM_CXHSCROLL) - 2;

    ListView_InsertColumn(m_hListView, 0, &lvColumn);
    PopulateWinStationList();

    return(TRUE);
}

VOID DefaultSecurityPage::OnActivation ()
{
	ASSERT(CanShow());
    if (StateObject.IsAppServerSelected()) 
	{
        ShowWindow(GetDlgItem(m_hDlgWnd, IDC_SECURITY_DEFAULT_1), SW_HIDE);
        ShowWindow(GetDlgItem(m_hDlgWnd, IDC_SECURITY_DEFAULT_2), SW_SHOW);
    } 
	else 
	{
        ShowWindow(GetDlgItem(m_hDlgWnd, IDC_SECURITY_DEFAULT_1), SW_SHOW);
        ShowWindow(GetDlgItem(m_hDlgWnd, IDC_SECURITY_DEFAULT_2), SW_HIDE);
    }

}

VOID DefaultSecurityPage::OnDeactivation ()
{
	GetPageData()->CleanArray();
}

BOOL DefaultSecurityPage::ApplyChanges ()
{

    //
    //  If this page has been processed, then the back button on a succeeding page
    //  is pressed and this page is returned to the screen, empty out the old
    //  information.
    //

	ASSERT(CanShow());
    if (m_cWinStations != 0) 
	{
        LOGMESSAGE1(_T("%d WinStations to verify."), m_cWinStations);

        //
        //  Allocate an array big enough to hold all items, even if some are not checked.
        //  If the allocation fails, set the array size to zero, and continue as if there
        //  is no error.
        //
		if (!GetPageData()->AlocateWinstationsArray(m_cWinStations))
		{
            LOGMESSAGE0(_T("Error: Out of Memory creating WinStation list."));
            return(TRUE);
        }

        for (UINT i = 0; i < m_cWinStations; i++) 
		{
            if (ListView_GetCheckState(m_hListView, i)) 
			{
                TCHAR  pStr[S_SIZE];

                LOGMESSAGE1(_T("Item %d checked"), i);

                ListView_GetItemText(m_hListView, i, 0, pStr, S_SIZE);
				if (!GetPageData()->AddWinstation (pStr))
				{
					LOGMESSAGE1(_T("Error: Out of Memory creating %s entry."), pStr);
				}
            } 
			else 
			{
                LOGMESSAGE1(_T("Item %d unchecked"), i);
            }
        }
    } 
	else 
	{
        LOGMESSAGE0(_T("No WinStations to verify."));
    }

    LOGMESSAGE0(_T("Default Security change-list made.\r\n\r\n"));

    return(TRUE);
}

UINT DefaultSecurityPage::GetHeaderTitleResource ()
{
    return IDS_STRING_SEC_PAGE_HEADER_TITLE;
}

UINT DefaultSecurityPage::GetHeaderSubTitleResource ()
{
    return IDS_STRING_SEC_PAGE_HEADER_SUBTITLE;
}

DefSecPageData* DefaultSecurityPage::GetPageData()
{
    return(static_cast <DefSecPageData *> (COCPage::GetPageData()));
}

BOOL DefaultSecurityPage::PopulateWinStationList ()
{
    DWORD dwRet;
    ULONG cbWinStationName, cEntries, iWinStation;
    WINSTATIONNAME WinStationName;

    cbWinStationName = sizeof(WINSTATIONNAME);
    cEntries = 1;
    iWinStation = 0;
    m_cWinStations = 0;

    GetPageData()->CleanArray();

    LOGMESSAGE0(_T("Populating WinStation list."));

    while ((dwRet = RegWinStationEnumerate(
                        SERVERNAME_CURRENT,
                        &iWinStation,
                        &cEntries,
                        WinStationName,
                        &cbWinStationName)) == ERROR_SUCCESS)
    {
        LVITEM lvItem;
        ULONG cbSecDescLen = 0;

        //
        //  Skip the console winstation.
        //

        if (_tcsicmp(WinStationName, _T("Console")) == 0) 
		{
            LOGMESSAGE0(_T("Skipping Console winstation."));
            continue;
        }

        LOGMESSAGE1(_T("Checking %s for custom security."), WinStationName);

        //
        //  Check for custom security.
        //

        dwRet = RegWinStationQuerySecurity(
                    SERVERNAME_CURRENT,
                    WinStationName,
                    NULL,
                    0,
                    &cbSecDescLen
                    );
        if (dwRet == ERROR_INSUFFICIENT_BUFFER) 
		{

            //
            //  Insufficient buffer means the winstation has custom security.
            //  cbSecDescLen must be greater than zero.
            //

            ASSERT(cbSecDescLen > 0);
            dwRet = ERROR_SUCCESS;
            LOGMESSAGE1(_T("%s has custom security."), WinStationName);

			//
			//  The current winstation has custom security. Add it to the list.
			//

			lvItem.mask = LVIF_TEXT;
			lvItem.pszText = WinStationName;
			lvItem.iItem = m_cWinStations;
			lvItem.iSubItem = 0;

			ListView_InsertItem(m_hListView, &lvItem);
			ListView_SetCheckState(m_hListView, m_cWinStations, TRUE);

			m_cWinStations++;

        } 
		else 
		{
            LOGMESSAGE2(_T("%s does not have custom security: %ld"), WinStationName, dwRet);
        }
    }

    LOGMESSAGE0(_T("WinStation list populated.\r\n\r\n"));

    return(dwRet == ERROR_SUCCESS);
}


//
//  PermPage Class
//

PermPage::PermPage(COCPageData* pPageData) : COCPage(pPageData)
{
//  Link window registration is required if we are going to use any
// "Link WIndow" controls in our resources
//	if (!LinkWindow_RegisterClass())
//	{
//		LOGMESSAGE0(_T("ERROR:Failed to Register Link Window class"));
//	}
}

BOOL PermPage::CanShow()
{
    return(!StateObject.IsUnattended() && StateObject.IsAppServerSelected() && !StateObject.WasItAppServer() && StateObject.IsServer());
}

BOOL PermPage::OnInitDialog(HWND /* hwndDlg */, WPARAM /* wParam */, LPARAM /* lParam */)
{
    HICON hIcon;

    hIcon = (HICON)LoadImage(
        GetInstance(),
        MAKEINTRESOURCE(IDI_SMALLWARN),
        IMAGE_ICON,
        0,
        0,
        0
        );
    ASSERT(hIcon != NULL);

    SendMessage(
        GetDlgItem(m_hDlgWnd, IDC_WARNING_ICON),
        STM_SETICON,
        (WPARAM)hIcon,
        (LPARAM)0
        );

    TCHAR szWarningString[WARNING_STRING_LENGTH];
    if (LoadString( GetInstance(), IDS_STRING_TS4_PERM, szWarningString, WARNING_STRING_LENGTH ))
    {
        SetDlgItemText(m_hDlgWnd, IDC_TS4_SECURITY, szWarningString);
    }

    if (LoadString( GetInstance(), IDS_STRING_FULL_PERM, szWarningString, WARNING_STRING_LENGTH ))
    {
        SetDlgItemText(m_hDlgWnd, IDC_FULL_SECURITY, szWarningString);
    }

    return(TRUE);
}

VOID PermPage::OnActivation()
{
	ASSERT(CanShow());

    CheckRadioButton(
        m_hDlgWnd,
        IDC_RADIO_WIN2KPERM,
        IDC_RADIO_TS4PERM,
        StateObject.CurrentPermMode() == PERM_TS4 ? IDC_RADIO_TS4PERM : IDC_RADIO_WIN2KPERM
        );
}


BOOL PermPage::ApplyChanges()
{
	ASSERT(CanShow());
    if (IsDlgButtonChecked(m_hDlgWnd, IDC_RADIO_TS4PERM) == BST_CHECKED)
	{
		StateObject.SetCurrentPermMode (PERM_TS4);
    } 
	else
	{
		StateObject.SetCurrentPermMode (PERM_WIN2K);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\pages.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// pages.h

#ifndef __pages_h__
#define __pages_h__

#include "stdafx.h"
#include "cocpage.h"

class AppSrvWarningPage : public COCPage
{
    public:
    AppSrvWarningPage           (COCPageData* pPageData);

    UINT GetPageID              ()  {return IDD_PROPPAGE_TERMINAL_SERVER_APPSRV_WARN;}
    BOOL CanShow                () ;
    UINT GetHeaderTitleResource () ;
    UINT GetHeaderSubTitleResource () ;
	BOOL OnInitDialog           (HWND hwndDlg, WPARAM /* wParam */, LPARAM /* lParam */);

};

class AppSrvUninstallpage : public COCPage
{
    public:
    AppSrvUninstallpage           (COCPageData* pPageData);

    UINT GetPageID              ()  {return IDD_PROPPAGE_TERMINAL_SERVER_APPSRV_WARN_NOSCROLL;}
    BOOL CanShow                () ;
    UINT GetHeaderTitleResource () ;
    UINT GetHeaderSubTitleResource () ;
	BOOL OnInitDialog           (HWND hwndDlg, WPARAM /* wParam */, LPARAM /* lParam */);
    VOID OnLink                 (WPARAM wParam);

};

class DefSecPageData: public COCPageData
{
    public:
    DefSecPageData              ();
    ~DefSecPageData             ();

    LPTSTR* GetWinStationArray  ()  {return m_pWinStationArray;}
    UINT    GetWinStationCount  ()  {return m_cArray;}
	BOOL	AlocateWinstationsArray  (UINT uiWinstationCount);
	BOOL	AddWinstation		(LPCTSTR pStr);
	VOID    CleanArray          ();

    private:
    UINT    m_cArray;
    LPTSTR* m_pWinStationArray;


};

class DefaultSecurityPage : public COCPage
{
    public:
    DefaultSecurityPage         (COCPageData* pPageData);

    UINT GetPageID              ()  {return IDD_PROPPAGE_TERMINAL_SERVER_SEC;}
    BOOL CanShow                ();
    BOOL OnInitDialog           (HWND hwndDlg, WPARAM /* wParam */, LPARAM /* lParam */);
    UINT GetHeaderTitleResource ();
    UINT GetHeaderSubTitleResource () ;
    BOOL ApplyChanges           ();
    VOID OnActivation           ();
	VOID OnDeactivation			();

    private:
    HWND m_hListView;
    UINT m_cWinStations;

    BOOL PopulateWinStationList ();
    DefSecPageData* GetPageData();

};

/*
class PermPageData: public COCPageData
{

    public:
    PermPageData();
    ~PermPageData();

    EPermMode GetPermissionMode() {return m_ePermMode;}

    private:
    EPermMode m_ePermMode;
};
*/
class PermPage: public COCPage
{
    public:
    PermPage(COCPageData* pPageData);

    UINT GetPageID() {return IDD_PROPPAGE_TERMINAL_SERVER_PERM;}
    BOOL CanShow();
    BOOL OnInitDialog(HWND hwndDlg, WPARAM /* wParam */, LPARAM /* lParam */);
    VOID OnActivation();
    UINT GetHeaderTitleResource() {return IDS_STRING_PERM_PAGE_HEADER_TITLE;}
    UINT GetHeaderSubTitleResource() {return IDS_STRING_PERM_PAGE_HEADER_SUBTITLE;}
    BOOL ApplyChanges();

    // private:
    // PermPageData* GetPageData();
};


#endif // __pages_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\hydraoc.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      hydraoc.cpp
*
*  Abstract:
*
*      This file implements the optional component HydraOc for Terminal Server Installations.
*
*
*  Author:
*
*      Makarand Patwardhan  - March 6, 1998
*
*  Environment:
*
*    User Mode
* -------------------------------------------------------------------------------------------------------*/

#include "stdafx.h"
#include "hydraoc.h"
#include "pages.h"
#include "subtoggle.h"
#include "subcore.h"
#include "ocmanage.h"


#define INITGUID // must be before iadmw.h

#include "iadmw.h"      // Interface header
#include "iiscnfg.h"    // MD_ & IIS_MD_ defines

#define REASONABLE_TIMEOUT 1000

#define TRANS_ADD        0
#define TRANS_DEL        1
#define TRANS_PRINT_PATH 2
#define STRING_TS_WEBCLIENT_INSTALL _T("TSWebClient.Install")
#define STRING_TS_WEBCLIENT_UNINSTALL _T("TSWebClient.UnInstall")
#define STRING_TS_WEBCLIENT _T("TSWebClient")
#define STRING_TS_WEBCLIENT_DIR _T("\\web\\tsweb")

/*--------------------------------------------------------------------------------------------------------
* declarations.
* -------------------------------------------------------------------------------------------------------*/
EXTERN_C BOOL WINAPI LinkWindow_RegisterClass() ;
EXTERN_C BOOL WINAPI LinkWindow_UnregisterClass( HINSTANCE ) ;

//
// component manager message handlers.
//
DWORD OnPreinitialize               ();
DWORD OnInitComponent               (PSETUP_INIT_COMPONENT psc);
DWORD OnExtraRoutines               (PEXTRA_ROUTINES pExtraRoutines);
DWORD OnSetLanguage                 ();
DWORD OnQueryImage                  ();
DWORD OnSetupRequestPages           (WizardPagesType ePageType, SETUP_REQUEST_PAGES *pRequestPages);
DWORD OnQuerySelStateChange         (LPCTSTR SubcomponentId, UINT SelectionState,  LONG Flag);
DWORD OnCalcDiskSpace               (LPCTSTR SubcomponentId, DWORD addComponent, HDSKSPC dspace);
DWORD OnQueueFileOps                (LPCTSTR SubcomponentId, HSPFILEQ queue);
DWORD OnNotificationFromQueue       ();
DWORD OnQueryStepCount              (LPCTSTR SubComponentId);
DWORD OnCompleteInstallation        (LPCTSTR SubcomponentId);
DWORD OnCleanup                     ();
DWORD OnQueryState                  (LPCTSTR SubComponentId, UINT whichstate);
DWORD OnNeedMedia                   ();
DWORD OnAboutToCommitQueue          (LPCTSTR SubcomponentId);
DWORD OnQuerySkipPage               ();
DWORD OnWizardCreated               ();
DWORD_PTR WebClientSetup                (LPCTSTR, LPCTSTR, UINT, UINT_PTR, PVOID);

//
// private utility functions.      
//                                    
BOOL  OpenMetabaseAndDoStuff(WCHAR *wszVDir, WCHAR *wszDir, int iTrans);
BOOL  GetVdirPhysicalPath(IMSAdminBase *pIMSAdminBase,WCHAR * wszVDir,WCHAR *wszStringPathToFill);
BOOL  AddVirtualDir(IMSAdminBase *pIMSAdminBase, WCHAR *wszVDir, WCHAR *wszDir);
BOOL  RemoveVirtualDir(IMSAdminBase *pIMSAdminBase, WCHAR *wszVDir);
INT   CheckifServiceExist(LPCTSTR lpServiceName);

/*--------------------------------------------------------------------------------------------------------
* defines
* -------------------------------------------------------------------------------------------------------*/

/*--------------------------------------------------------------------------------------------------------
* constants
-------------------------------------------------------------------------------------------------------*/


//
// global variables and functions to access them.
//

SubCompToggle       *gpSubCompToggle    = NULL;
SubCompCoreTS       *gpSubCompCoreTS    = NULL;
COCPageData         *gpAppSrvUninstallPageData   = NULL;
DefSecPageData      *gpSecPageData      = NULL;
COCPageData         *gpPermPageData     = NULL;
COCPageData         *gpAppPageData		= NULL;


/*--------------------------------------------------------------------------------------------------------
* LPCTSTR GetOCFunctionName(UINT uiFunction)
* utility function for logging the oc messages.
* returns oc manager function name from funciton id.
* returns _T("Unknown Function") if its unknown.
* -------------------------------------------------------------------------------------------------------*/
LPCTSTR GetOCFunctionName(UINT uiFunction)
{
    struct
    {
        UINT  msg;
        TCHAR *desc;
    } gMsgs[] =
    {
        {OC_PREINITIALIZE,          TEXT("OC_PREINITIALIZE")},
        {OC_INIT_COMPONENT,         TEXT("OC_INIT_COMPONENT")},
        {OC_SET_LANGUAGE,           TEXT("OC_SET_LANGUAGE")},
        {OC_QUERY_IMAGE,            TEXT("OC_QUERY_IMAGE")},
        {OC_REQUEST_PAGES,          TEXT("OC_REQUEST_PAGES")},
        {OC_QUERY_CHANGE_SEL_STATE, TEXT("OC_QUERY_CHANGE_SEL_STATE")},
        {OC_CALC_DISK_SPACE,        TEXT("OC_CALC_DISK_SPACE")},
        {OC_QUEUE_FILE_OPS,         TEXT("OC_QUEUE_FILE_OPS")},
        {OC_NOTIFICATION_FROM_QUEUE,TEXT("OC_NOTIFICATION_FROM_QUEUE")},
        {OC_QUERY_STEP_COUNT,       TEXT("OC_QUERY_STEP_COUNT")},
        {OC_COMPLETE_INSTALLATION,  TEXT("OC_COMPLETE_INSTALLATION")},
        {OC_CLEANUP,                TEXT("OC_CLEANUP")},
        {OC_QUERY_STATE,            TEXT("OC_QUERY_STATE")},
        {OC_NEED_MEDIA,             TEXT("OC_NEED_MEDIA")},
        {OC_ABOUT_TO_COMMIT_QUEUE,  TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
        {OC_QUERY_SKIP_PAGE,        TEXT("OC_QUERY_SKIP_PAGE")},
        {OC_WIZARD_CREATED,         TEXT("OC_WIZARD_CREATED")},
        {OC_EXTRA_ROUTINES,         TEXT("OC_EXTRA_ROUTINES")}
    };
    
    for (int i = 0; i < sizeof(gMsgs) / sizeof(gMsgs[0]); i++)
    {
        if (gMsgs[i].msg == uiFunction)
            return gMsgs[i].desc;
    }
    
    return _T("Unknown Function");
}

/*--------------------------------------------------------------------------------------------------------
* called by CRT when _DllMainCRTStartup is the DLL entry point
* -------------------------------------------------------------------------------------------------------*/

BOOL WINAPI DllMain(IN HINSTANCE hinstance, IN DWORD reason, IN LPVOID    /*reserved*/    )
{
    SetInstance( hinstance );
    
    switch(reason)
    {
    case DLL_PROCESS_ATTACH:
        TCHAR szLogFile[MAX_PATH];
        ExpandEnvironmentStrings(LOGFILE, szLogFile, MAX_PATH);
        LOGMESSAGEINIT(szLogFile, MODULENAME);
        break;
        
    case DLL_THREAD_ATTACH:
    case DLL_PROCESS_DETACH:
    case DLL_THREAD_DETACH:
        break;
    }
    
    return(TRUE); // for successful process_attach
}


/*--------------------------------------------------------------------------------------------------------
*  This is our export function which will be called by OC Manager
* -------------------------------------------------------------------------------------------------------*/
DWORD_PTR HydraOc(
                  IN     LPCTSTR ComponentId,
                  IN     LPCTSTR SubcomponentId,
                  IN     UINT    Function,
                  IN     UINT_PTR  Param1,
                  IN OUT PVOID   Param2
                  )
{
    // we use this variable to track if we receive OnCompleteInstallation or not.
    // there is a problem with ocm which aborts all the components if any of them
    // does something wrong with file queue.
    static BOOL sbGotCompleteMessage = FALSE;
    
    LOGMESSAGE1(_T("Entering %s"), GetOCFunctionName(Function));
    
    if ((OC_PREINITIALIZE != Function) && SubcomponentId)
        LOGMESSAGE2(_T("Component=%s, SubComponent=%s"), ComponentId, SubcomponentId);
    else
        LOGMESSAGE2(_T("Component=%s, SubComponent=%s"), ComponentId, _T("(null)"));

    
    DWORD_PTR rc;
    
    if (SubcomponentId &&  _tcsicmp(SubcomponentId,  _T("tswebClient")) == 0)
    {
        rc = WebClientSetup(ComponentId, SubcomponentId, Function, Param1,   Param2);
        LOGMESSAGE2(_T("%s Done. Returning %lu\r\n\r\n"), GetOCFunctionName(Function), rc);
        return rc;
    }
    
    // since we are supporting only one component.
    ASSERT(_tcsicmp(APPSRV_COMPONENT_NAME,  ComponentId) == 0);
    
    
    switch(Function)
    {
    case OC_PREINITIALIZE:
        rc = OnPreinitialize();
        break;
        
    case OC_INIT_COMPONENT:
        rc = OnInitComponent((PSETUP_INIT_COMPONENT)Param2);
        break;
        
    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines((PEXTRA_ROUTINES)Param2);
        break;
        
    case OC_SET_LANGUAGE:
        rc = OnSetLanguage();
        break;
        
    case OC_QUERY_IMAGE:
        rc = OnQueryImage();
        break;
        
    case OC_REQUEST_PAGES:
        rc = OnSetupRequestPages(WizardPagesType(Param1),  PSETUP_REQUEST_PAGES (Param2));
        break;
        
    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(SubcomponentId, (UINT)Param1, LONG(ULONG_PTR(Param2)));
        break;
        
    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(SubcomponentId, (DWORD)Param1, Param2);
        break;
        
    case OC_QUEUE_FILE_OPS:
        rc = OnQueueFileOps(SubcomponentId, (HSPFILEQ)Param2);
        break;
        
    case OC_NOTIFICATION_FROM_QUEUE:
        rc = OnNotificationFromQueue();
        break;
        
    case OC_QUERY_STEP_COUNT:
        rc = OnQueryStepCount(SubcomponentId);
        break;
        
    case OC_COMPLETE_INSTALLATION:
        sbGotCompleteMessage = TRUE;
        
        rc = OnCompleteInstallation(SubcomponentId);
        break;
        
    case OC_CLEANUP:
        rc = OnCleanup();
        
        if (!sbGotCompleteMessage)
        {
            if (StateObject.IsStandAlone())
            {
                LOGMESSAGE0(_T("Error:StandAlone:TSOC Did not get OC_COMPLETE_INSTALLATION."));
            }
            else
            {
                LOGMESSAGE0(_T("Error:TSOC Did not get OC_COMPLETE_INSTALLATION."));
            }
        }
        break;
        
    case OC_QUERY_STATE:
        rc = OnQueryState(SubcomponentId, (UINT)Param1);
        break;
        
    case OC_NEED_MEDIA:
        rc = OnNeedMedia();
        break;
        
    case OC_ABOUT_TO_COMMIT_QUEUE:
        rc = OnAboutToCommitQueue(SubcomponentId);
        break;
        
    case OC_QUERY_SKIP_PAGE:
        rc = OnQuerySkipPage();
        break;
        
    case OC_WIZARD_CREATED:
        rc = OnWizardCreated();
        break;
        
    default:
        rc = 0; // it means we do not recognize this command.
        break;
    }
    
    LOGMESSAGE2(_T("%s Done. Returning %lu\r\n\r\n"), GetOCFunctionName(Function), rc);
    return rc;
}

/*--------------------------------------------------------------------------------------------------------
* OC Manager message handlers
* -------------------------------------------------------------------------------------------------------*/

DWORD OnPreinitialize(VOID)
{
#ifdef ANSI
    return OCFLAG_ANSI;
#else
    return OCFLAG_UNICODE;
#endif
    
}

/*--------------------------------------------------------------------------------------------------------
* OnInitComponent()
*
* handler for OC_INIT_COMPONENT
* -------------------------------------------------------------------------------------------------------*/

DWORD OnInitComponent(PSETUP_INIT_COMPONENT psc)
{
    ASSERT(psc);
    
    //
    // let the ocmanager know our version
    //
    
    psc->ComponentVersion = COMPONENT_VERSION;
    
    //
    // Is this component written for newer version than the oc manager ?
    //
    
    if (COMPONENT_VERSION  > psc->OCManagerVersion)
    {
        LOGMESSAGE2(_T("ERROR:OnInitComponent: COMPONENT_VERSION(%x) > psc->OCManagerVersion(%x)"), COMPONENT_VERSION, psc->OCManagerVersion);
        return ERROR_CALL_NOT_IMPLEMENTED;
    }
    
    if (!StateObject.Initialize(psc))
    {
        return ERROR_CANCELLED; // due to ERROR_OUTOFMEMORY;
    }
    
    // if its standalone (!guimode) setup, We must have  Hydra in product suite by now.
    // ASSERT( StateObject.IsGuiModeSetup() || DoesHydraKeysExists() );
    
    
    
    //
    // now create our subcomponents
    //
    gpSubCompToggle = new SubCompToggle;
    gpSubCompCoreTS = new SubCompCoreTS;
    
    if (!gpSubCompToggle || !gpSubCompCoreTS)
        return ERROR_CANCELLED;
    
    //
    // if initialization of any of the sub component fails
    // fail the setup
    //
    
    if (!gpSubCompToggle->Initialize() ||
        !gpSubCompCoreTS->Initialize())
        
        return ERROR_CANCELLED;
    
    
    return NO_ERROR;
}

DWORD
OnExtraRoutines(
                PEXTRA_ROUTINES pExtraRoutines
                )
{
    ASSERT(pExtraRoutines);
    
    return(SetExtraRoutines(pExtraRoutines) ? ERROR_SUCCESS : ERROR_CANCELLED);
}

/*--------------------------------------------------------------------------------------------------------
* OnCalcDiskSpace()
*
* handler for OC_ON_CALC_DISK_SPACE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnCalcDiskSpace(
                      LPCTSTR /* SubcomponentId */,
                      DWORD addComponent,
                      HDSKSPC dspace
                      )
{
    return gpSubCompCoreTS->OnCalcDiskSpace(addComponent, dspace);
}

/*--------------------------------------------------------------------------------------------------------
* OnQueueFileOps()
*
* handler for OC_QUEUE_FILE_OPS
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQueueFileOps(LPCTSTR SubcomponentId, HSPFILEQ queue)
{
    if (SubcomponentId == NULL)
    {
        return gpSubCompCoreTS->OnQueueFiles( queue );
    }
    else if (_tcsicmp(SubcomponentId, APPSRV_COMPONENT_NAME) == 0)
    {
        return gpSubCompToggle->OnQueueFiles( queue );
    }
    else
    {
        ASSERT(FALSE);
        LOGMESSAGE1(_T("ERROR, Got a OnQueueFileOps with unknown SubComp(%s)"), SubcomponentId);
        return 0;
    }
    
}


/*--------------------------------------------------------------------------------------------------------
* OnCompleteInstallation
*
* handler for OC_COMPLETE_INSTALLATION
* -------------------------------------------------------------------------------------------------------*/

DWORD OnCompleteInstallation(LPCTSTR SubcomponentId)
{
    static BOOL sbStateUpdated = FALSE;
    
    if (!sbStateUpdated)
    {
        StateObject.UpdateState();
        sbStateUpdated = TRUE;
    }
    
    if (SubcomponentId == NULL)
    {
        return gpSubCompCoreTS->OnCompleteInstall();
    }
    else if (_tcsicmp(SubcomponentId, APPSRV_COMPONENT_NAME) == 0)
    {
        return gpSubCompToggle->OnCompleteInstall();
    }
    else
    {
        ASSERT(FALSE);
        LOGMESSAGE1(_T("ERROR, Got a Complete Installation with unknown SubComp(%s)"), SubcomponentId);
        return 0;
    }
}


/*--------------------------------------------------------------------------------------------------------
* OnSetLanguage()
*
* handler for OC_SET_LANGUAGE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnSetLanguage()
{
    return false;
}

/*--------------------------------------------------------------------------------------------------------
* OnSetLanguage()
*
* handler for OC_SET_LANGUAGE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQueryImage()
{
    return NULL;
}

/*--------------------------------------------------------------------------------------------------------
* OnSetupRequestPages
*
* Prepares wizard pages and returns them to the OC Manager
* -------------------------------------------------------------------------------------------------------*/

DWORD OnSetupRequestPages (WizardPagesType ePageType, SETUP_REQUEST_PAGES *pRequestPages)
{
    if (ePageType == WizPagesEarly)
    {
        ASSERT(pRequestPages);
        const UINT uiPages = 4;
        
        // if we are provided sufficient space for our pages
        if (pRequestPages->MaxPages >= uiPages )
        {
            //
            //  Pages will be deleted in PSPCB_RELEASE in OCPage::PropSheetPageProc
            //
            LinkWindow_RegisterClass();
            
            gpAppPageData = new COCPageData;
            AppSrvWarningPage *pAppSrvWarnPage = new AppSrvWarningPage(gpAppPageData);
            
            gpSecPageData = new DefSecPageData;
            DefaultSecurityPage *pSecPage = new DefaultSecurityPage(gpSecPageData);
            
            gpPermPageData = new COCPageData;
            PermPage *pPermPage = new PermPage(gpPermPageData);
            
            gpAppSrvUninstallPageData = new COCPageData;
            AppSrvUninstallpage *pAppSrvUninstallPage = new  AppSrvUninstallpage(gpAppSrvUninstallPageData);
            
            if (pAppSrvWarnPage && pAppSrvWarnPage->Initialize() &&
                pSecPage     && pSecPage->Initialize()    &&
                pPermPage    && pPermPage->Initialize()   &&
                pAppSrvUninstallPage && pAppSrvUninstallPage->Initialize()
                )
            {
                ASSERT(pRequestPages->Pages);
                pRequestPages->Pages[0] = CreatePropertySheetPage((PROPSHEETPAGE *) pAppSrvWarnPage);
                pRequestPages->Pages[1] = CreatePropertySheetPage((PROPSHEETPAGE *) pSecPage);
                pRequestPages->Pages[2] = CreatePropertySheetPage((PROPSHEETPAGE *) pPermPage);
                pRequestPages->Pages[3] = CreatePropertySheetPage((PROPSHEETPAGE *) pAppSrvUninstallPage);
                
                ASSERT(pRequestPages->Pages[0]);
                ASSERT(pRequestPages->Pages[1]);
                ASSERT(pRequestPages->Pages[2]);
                ASSERT(pRequestPages->Pages[3]);
            }
            else
            {
                //
                // failed to allocate memory
                //
                
                if (gpAppPageData)
                    delete gpAppPageData;
                
                gpAppPageData = NULL;
                
                
                if (pAppSrvWarnPage)
                    delete pAppSrvWarnPage;
                
                pAppSrvWarnPage = NULL;
                
                if (gpSecPageData)
                    delete gpSecPageData;
                
                gpSecPageData = NULL;
                
                if (pSecPage)
                    delete pSecPage;
                
                pSecPage = NULL;
                
                if (gpPermPageData)
                    delete gpPermPageData;
                
                gpPermPageData = NULL;
                
                if (pPermPage)
                    delete pPermPage;
                
                pPermPage =NULL;
                
                if (gpAppSrvUninstallPageData)
                    delete gpAppSrvUninstallPageData;
                
                gpAppSrvUninstallPageData = NULL;
                
                if (pAppSrvUninstallPage)
                    delete pAppSrvUninstallPage;
                
                pAppSrvUninstallPage = NULL;
                
                SetLastError(ERROR_OUTOFMEMORY);
                return DWORD(-1);
            }
        }
        
        return uiPages;
    }
    
    return 0;
    
}

/*--------------------------------------------------------------------------------------------------------
* OnWizardCreated()
* -------------------------------------------------------------------------------------------------------*/

DWORD OnWizardCreated()
{
    return NO_ERROR;
}

/*--------------------------------------------------------------------------------------------------------
* OnQuerySkipPage()
*
* don't let the user deselect the sam component
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQuerySkipPage()
{
    return false;
}

/*--------------------------------------------------------------------------------------------------------
* OnQuerySelStateChange(LPCTSTR SubcomponentId, UINT SelectionState,  LONG Flag);
*
* informs that user has changed the state of the component/subcomponent and asks approval
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQuerySelStateChange(LPCTSTR SubcomponentId, UINT SelectionState,  LONG Flag)
{
    BOOL bNewState = SelectionState;
    BOOL bDirectSelection = Flag & OCQ_ACTUAL_SELECTION;
    LOGMESSAGE3(_T("OnQuerySelStateChange for %s, NewState = %d, DirectSelect = %s"), SubcomponentId, SelectionState, bDirectSelection ? _T("True") : _T("False"));
    
    return gpSubCompToggle->OnQuerySelStateChange(bNewState, bDirectSelection);
}

/*--------------------------------------------------------------------------------------------------------
* OnCleanup()
*
* handler for OC_CLEANUP
* -------------------------------------------------------------------------------------------------------*/

DWORD OnCleanup()
{
    
    if (gpAppPageData)
        delete gpAppPageData;
    
    if (gpSecPageData)
        delete gpSecPageData;
    
    if (gpPermPageData)
        delete gpPermPageData;
    
    if (gpAppSrvUninstallPageData)
        delete gpAppSrvUninstallPageData;
    
    if (gpSubCompToggle)
        delete gpSubCompToggle;
    
    if (gpSubCompCoreTS)
        delete gpSubCompCoreTS;
    
    // DestroySetupData();
    DestroyExtraRoutines();
    
    return NO_ERROR;
}

/*--------------------------------------------------------------------------------------------------------
* OnQueryState()
*
* handler for OC_QUERY_STATE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQueryState(LPCTSTR SubComponentId, UINT whichstate)
{
    ASSERT(OCSELSTATETYPE_ORIGINAL == whichstate ||
        OCSELSTATETYPE_CURRENT == whichstate ||
        OCSELSTATETYPE_FINAL == whichstate);
    
    TCHAR szState[256];
    
    switch (whichstate)
    {
    case OCSELSTATETYPE_ORIGINAL:
        _tcscpy(szState, _T("Original"));
        break;
    case OCSELSTATETYPE_CURRENT:
        _tcscpy(szState, _T("Current"));
        break;
    case OCSELSTATETYPE_FINAL:
        _tcscpy(szState, _T("Final"));
        break;
    default:
        ASSERT(FALSE);
        return ERROR_BAD_ARGUMENTS;
    }
    
    DWORD dwReturn = gpSubCompToggle->OnQueryState(whichstate);
    
    TCHAR szReturn[] = _T("SubcompUseOcManagerUknownState");
    switch (dwReturn)
    {
    case SubcompOn:
        _tcscpy(szReturn, _T("SubcompOn"));
        break;
    case SubcompUseOcManagerDefault:
        _tcscpy(szReturn, _T("SubcompUseOcManagerDefault"));
        break;
    case SubcompOff:
        _tcscpy(szReturn, _T("SubcompOff"));
        break;
    default:
        ASSERT(FALSE);
    }
    
    LOGMESSAGE3(_T("Query State Asked For %s, %s. Returning %s"), SubComponentId, szState, szReturn);
    
    return dwReturn;
}





/*--------------------------------------------------------------------------------------------------------
* OnNotificationFromQueue()
*
* handler for OC_NOTIFICATION_FROM_QUEUE
*
* NOTE: although this notification is defined,
* it is currently unimplemented in oc manager
* -------------------------------------------------------------------------------------------------------*/

DWORD OnNotificationFromQueue()
{
    return NO_ERROR;
}

/*--------------------------------------------------------------------------------------------------------
* OnQueryStepCount
*
* handler for OC_QUERY_STEP_COUNT
* -------------------------------------------------------------------------------------------------------*/

DWORD OnQueryStepCount(LPCTSTR /* SubcomponentId */)
{
    //
    // now return the ticks for the component
    //
    return gpSubCompCoreTS->OnQueryStepCount() + gpSubCompToggle->OnQueryStepCount();
    
}

/*--------------------------------------------------------------------------------------------------------
* OnNeedMedia()
*
* handler for OC_NEED_MEDIA
* -------------------------------------------------------------------------------------------------------*/

DWORD OnNeedMedia()
{
    return false;
}

/*--------------------------------------------------------------------------------------------------------
* OnAboutToCommitQueue()
*
* handler for OC_ABOUT_TO_COMMIT_QUEUE
* -------------------------------------------------------------------------------------------------------*/

DWORD OnAboutToCommitQueue(LPCTSTR /* SubcomponentId */)
{
    return NO_ERROR;
}


/*--------------------------------------------------------------------------------------------------------
* BOOL DoesHydraKeysExists()
*
* checks if Teminal server string exists in the product suite key.
* -------------------------------------------------------------------------------------------------------*/

BOOL DoesHydraKeysExists()
{
    BOOL bStringExists = FALSE;
    DWORD dw = IsStringInMultiString(
        HKEY_LOCAL_MACHINE,
        PRODUCT_SUITE_KEY,
        PRODUCT_SUITE_VALUE,
        TS_PRODUCT_SUITE_STRING,
        &bStringExists);
    
    return (dw == ERROR_SUCCESS) && bStringExists;
}



/*--------------------------------------------------------------------------------------------------------
* DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound)
* checks if parameter string exists in given multistring.
* returns error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, BOOL *pbFound)
{
    ASSERT(szkey && *szkey);
    ASSERT(szvalue && *szvalue);
    ASSERT(szCheckForString&& *szCheckForString);
    ASSERT(*szkey != '\\');
    ASSERT(pbFound);
    
    // not yet found.
    *pbFound = FALSE;
    
    CRegistry reg;
    DWORD dwError = reg.OpenKey(hkey, szkey, KEY_READ);  // open up the required key.
    if (dwError == NO_ERROR)
    {
        LPTSTR szSuiteValue;
        DWORD dwSize;
        dwError = reg.ReadRegMultiString(szvalue, &szSuiteValue, &dwSize);
        if (dwError == NO_ERROR)
        {
            LPCTSTR pTemp = szSuiteValue;
            while(_tcslen(pTemp) > 0 )
            {
                if (_tcscmp(pTemp, szCheckForString) == 0)
                {
                    *pbFound = TRUE;
                    break;
                }
                
                pTemp += _tcslen(pTemp) + 1; // point to the next string within the multistring.
                if ( DWORD(pTemp - szSuiteValue) > (dwSize / sizeof(TCHAR)))
                    break; // temporary pointer passes the size of the szSuiteValue something is wrong with szSuiteValue.
            }
        }
    }
    
    return dwError;
    
}

/*--------------------------------------------------------------------------------------------------------
* DWORD AppendStringToMultiString(HKEY hkey, LPCTSTR szSuitekey, LPCTSTR szSuitevalue, LPCTSTR szAppend)
* appends given string to the given multi_sz value
* the given key / value must exist.
* returns error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD AppendStringToMultiString(HKEY hkey, LPCTSTR szSuitekey, LPCTSTR szSuitevalue, LPCTSTR szAppend)
{
    ASSERT(szSuitekey && *szSuitekey);
    ASSERT(szSuitevalue && *szSuitevalue);
    ASSERT(szAppend && *szAppend);
    ASSERT(*szSuitekey != '\\');
    
    CRegistry reg;
    // open the registry key.
    DWORD dwResult = reg.OpenKey(hkey, szSuitekey, KEY_READ | KEY_WRITE);
    if (dwResult == ERROR_SUCCESS)
    {
        DWORD dwSize = 0;
        LPTSTR strOriginalString = 0;
        
        // read our multi string
        dwResult = reg.ReadRegMultiString(szSuitevalue, &strOriginalString, &dwSize);
        
        if (dwResult == ERROR_SUCCESS)
        {
            // now calculate the Memory required for appending the string.
            // as dwOldSize is in bytes and we are using TCHARs
            DWORD dwMemReq = dwSize + ((_tcslen(szAppend) + 2)  * sizeof(TCHAR) / sizeof(BYTE));
            
            // NOTE: if dwSize is >= 1 we just require
            // dwSize + ((_tcslen(szAppend) + 1)  * sizeof(TCHAR) / sizeof(BYTE));
            // But in case its 0 we provide space for an additional terminating null
            
            LPTSTR szProductSuite = (LPTSTR ) new BYTE [dwMemReq];
            
            if (!szProductSuite)
            {
                return ERROR_OUTOFMEMORY;
            }
            
            CopyMemory(szProductSuite, strOriginalString, dwSize);

            // convert the size into TCHARs
            dwSize = dwSize * sizeof(BYTE) / sizeof(TCHAR);
            
            if (dwSize <= 2)
            {
                // there are no strings out there.
                _tcscpy(szProductSuite, szAppend);

                // new size including terminating null in tchar
                dwSize = _tcslen(szAppend) + 2;
            }
            else
            {
                // there are strings in its. so append our string before the terminating null.
                //  for example for this string "A\0B\0\0" dwSize == 5 and we are doing tcscat at "A\0B\0\0" + 4
                _tcscpy(szProductSuite + dwSize - 1, szAppend);
                
                // new size including terminating null in tchar
                dwSize += _tcslen(szAppend) + 1;
            }
            
            // now append a final terminating null character.
            *(szProductSuite + dwSize-1) = NULL;

            // reconvert size into bytes.
            dwSize *= sizeof(TCHAR) / sizeof(BYTE);
            
            // and finally write the final string.
            dwResult = reg.WriteRegMultiString(szSuitevalue, szProductSuite, dwSize);
            
            delete [] szProductSuite;

        }
    }
    
    return dwResult;
}


/*--------------------------------------------------------------------------------------------------------
* BOOL GetStringValue(HINF hinf, LPCTSTR  section, LPCTSTR key,  LPTSTR outputbuffer, DWORD dwSize)
* returns the given string value under given section.
* returns success
* -------------------------------------------------------------------------------------------------------*/
DWORD GetStringValue(HINF hinf, LPCTSTR  section, LPCTSTR key,  LPTSTR outputbuffer, DWORD dwSize)
{
    INFCONTEXT          context;

    BOOL rc = SetupFindFirstLine(
        hinf,
        section,
        key,
        &context
        );
    if (rc)
    {
        rc = SetupGetStringField(
            &context,
            1,
            outputbuffer,
            dwSize,
            &dwSize
            );
    }
    
    if (!rc)
        return GetLastError();
    else
        return ERROR_SUCCESS;
}



DWORD_PTR WebClientSetup(LPCTSTR ComponentId,
                         LPCTSTR SubcomponentId,
                         UINT    Function,
                         UINT_PTR  Param1,
                         PVOID   Param2)
{
    DWORD_PTR rc = NO_ERROR;
    BOOL bCurrentState, bOriginalState;
    
    LOGMESSAGE1(_T("Entering %s"), _T("WebClient Setup"));
    
    switch(Function)
    {
    case OC_INIT_COMPONENT:
        return NO_ERROR;
        
    case OC_QUERY_STATE:
        return SubcompUseOcManagerDefault;
        break;
        
    case OC_SET_LANGUAGE:
        return FALSE;

    case OC_QUERY_IMAGE:
        rc = (DWORD_PTR)LoadImage(GetInstance(), MAKEINTRESOURCE(IDB_WEBCLIENT), IMAGE_BITMAP,
            0, 0, LR_DEFAULTCOLOR);
        LOGMESSAGE1(_T("Bitmap is: %d"), rc);
        return rc;
        
    case OC_QUERY_CHANGE_SEL_STATE:
        {
            BOOL rc = TRUE;
            BOOL fDependentSelection = (BOOL)((INT_PTR)Param2 & OCQ_DEPENDENT_SELECTION);
            BOOL fProposedState = (BOOL)Param1;

            //
            // Don't allow an indirect selection (e.g. don't allow clicking on
            // the parent to enable the child)
            //
            if (fDependentSelection && fProposedState) {
                rc = FALSE;
            }

            return rc;
            
        }
        break;
        
    case OC_CALC_DISK_SPACE:
        //rc = OnCalcDiskSpace(SubcomponentId, (DWORD)Param1, Param2);
        
        //_tcscpy(section, SubcomponentId);
        
        if ((DWORD)Param1)
        {
            rc = SetupAddInstallSectionToDiskSpaceList((HDSKSPC)Param2, GetComponentInfHandle(), NULL, 
                STRING_TS_WEBCLIENT_INSTALL, 0, 0);
        }
        else
        {
            rc = SetupRemoveInstallSectionFromDiskSpaceList((HDSKSPC)Param2, GetComponentInfHandle(), NULL, 
                STRING_TS_WEBCLIENT_INSTALL, 0, 0);
        }
        
        LOGMESSAGE1(_T("Query Disk Space return: %d"), rc);
        
        if (!rc)
            rc = GetLastError();
        else
            rc = NO_ERROR;
        break;
        
    case OC_QUEUE_FILE_OPS:
        rc = NO_ERROR;
        bOriginalState = GetHelperRoutines().QuerySelectionState(GetHelperRoutines().OcManagerContext, 
            STRING_TS_WEBCLIENT, OCSELSTATETYPE_ORIGINAL);
        bCurrentState = GetHelperRoutines().QuerySelectionState(GetHelperRoutines().OcManagerContext, 
            STRING_TS_WEBCLIENT, OCSELSTATETYPE_CURRENT);
        
        LOGMESSAGE2(_T("Original=%d, Current=%d"), bOriginalState, bCurrentState);
        
        if(bCurrentState)   {
            // Only copy files if it's machine upgrade or
            //  the component is not previously installed
            if (!StateObject.IsStandAlone() || !bOriginalState) {
                if (!SetupInstallFilesFromInfSection(GetComponentInfHandle(), NULL, (HSPFILEQ)Param2,
                    STRING_TS_WEBCLIENT_INSTALL, NULL, 0)) {
                    rc = GetLastError();
                    LOGMESSAGE2(_T("ERROR:OnQueueFileOps::SetupInstallFilesFromInfSection <%s> failed.GetLastError() = <%ul)"), SubcomponentId, rc);
                }
            }
            
            LOGMESSAGE1(_T("Copy files return: %d"), rc);
            break;
        }
        else    {
            if (!bOriginalState) {
                // Not installed before, do nothing
                return NO_ERROR;
            }
            if (!SetupInstallFilesFromInfSection(GetComponentInfHandle(), NULL, (HSPFILEQ)Param2,
                STRING_TS_WEBCLIENT_UNINSTALL, NULL, 0))
            {
                rc = GetLastError();
                LOGMESSAGE2(_T("ERROR:OnQueueFileOps::SetupInstallFilesFromInfSection <%s> failed.GetLastError() = <%ul)"), SubcomponentId, rc);
            }
            
            LOGMESSAGE1(_T("Remove files return: %d"), rc);
            break;
        }
        
    case OC_COMPLETE_INSTALLATION:
        bOriginalState = GetHelperRoutines().QuerySelectionState(GetHelperRoutines().OcManagerContext, _T("TSWebClient"), OCSELSTATETYPE_ORIGINAL);
        bCurrentState = GetHelperRoutines().QuerySelectionState(GetHelperRoutines().OcManagerContext, _T("TSWebClient"), OCSELSTATETYPE_CURRENT);
        LOGMESSAGE2(_T("Orinal=%d, Current=%d"), bOriginalState, bCurrentState);
        
        if(bOriginalState==bCurrentState) //state does not change
            return NO_ERROR;
        
        int iTrans;   //mark removing or adding tsweb dir
        int nLength;
        
        iTrans = 0;
        WCHAR wszVDirName[MAX_PATH];
        WCHAR wszDirPath[MAX_PATH];
        TCHAR szDirPath[MAX_PATH];
        TCHAR szVDirName[MAX_PATH];
        
        if (GetWindowsDirectory(szDirPath, MAX_PATH) == 0) {
            rc = GetLastError();
            return rc;
        }
        
        nLength = _tcsclen(szDirPath);
        if(_T('\\')==szDirPath[nLength-1])
            szDirPath[nLength-1]=_T('\0');
        _tcscat(szDirPath, STRING_TS_WEBCLIENT_DIR);
        
        if (LoadString(GetInstance(), IDS_STRING_TSWEBCLIENT_VIRTUALPATH, szVDirName, MAX_PATH) == 0)   {
            LOGMESSAGE0(_T("Can't load string  IDS_STRING_TSWEBCLIENT_VIRTUALPATH"));
            rc = GetLastError();;
        }
        
        LOGMESSAGE2(_T("Dir Path is: %s, Virtual Name is: %s"), szDirPath, szVDirName);
        
        if(bCurrentState)  //enable IIS directory
            iTrans = TRANS_ADD;
        else
            iTrans = TRANS_DEL;
        
#ifndef _UNICODE 
        MultiByteToWideChar(CP_ACP, 0, szDirPath, -1, (LPWSTR) wszDirPath, MAX_PATH);
        MultiByteToWideChar(CP_ACP, 0, szVDirName, -1, (LPWSTR) wszVDirName, MAX_PATH);
#else
        _tcscpy(wszDirPath, szDirPath);
        _tcscpy(wszVDirName, szVDirName);
#endif
        
        rc = OpenMetabaseAndDoStuff(wszVDirName, wszDirPath, iTrans)?0:1;
        
        LOGMESSAGE1(_T("Websetup complete, return is: %d"), rc);
        return rc;
    default:
        rc = NO_ERROR; // it means we do not recognize this command.
        break;
    }
    return rc;
}


BOOL
OpenMetabaseAndDoStuff(
                       WCHAR * wszVDir,
                       WCHAR * wszDir,
                       int iTrans)
{
    BOOL fRet = FALSE;
    HRESULT hr;
    IMSAdminBase *pIMSAdminBase = NULL;  // Metabase interface pointer
    WCHAR wszPrintString[MAX_PATH + MAX_PATH];
    
    // Make sure that IISADMIN service exists
    if (CheckifServiceExist(_T("IISADMIN")) != 0) 
    {
        LOGMESSAGE0(_T("IISADMIN service does not exist"));
        // We have to return TRUE here if IIS service does not exist
        return TRUE;
    }
    
    if( FAILED (hr = CoInitializeEx( NULL, COINIT_MULTITHREADED )) ||
        FAILED (hr = ::CoCreateInstance(CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void **)&pIMSAdminBase)))  
    {
        LOGMESSAGE1(_T("CoCreateInstance failed with error code %u"), hr);
        return FALSE;
    }
    
    switch (iTrans) {
    case TRANS_DEL:
        if(RemoveVirtualDir( pIMSAdminBase, wszVDir)) {
            
            hr = pIMSAdminBase->SaveData();
            
            if( SUCCEEDED( hr )) {
                fRet = TRUE;
            }
        }
        
        break;
    case TRANS_ADD:
        if(AddVirtualDir( pIMSAdminBase, wszVDir, wszDir)) {
            
            hr = pIMSAdminBase->SaveData();
            
            if( SUCCEEDED( hr )) {
                fRet = TRUE;
            }
        }
        break;
    default:
        break;
    }
    
    if (pIMSAdminBase) {
        pIMSAdminBase->Release();
        pIMSAdminBase = NULL;
    }
    
    CoUninitialize();
    return fRet;
}


BOOL
GetVdirPhysicalPath(
                    IMSAdminBase *pIMSAdminBase,
                    WCHAR * wszVDir,
                    WCHAR *wszStringPathToFill)
{
    HRESULT hr;
    BOOL fRet = FALSE;
    METADATA_HANDLE hMetabase = NULL;   // handle to metabase
    METADATA_RECORD mr;
    WCHAR  szTmpData[MAX_PATH];
    DWORD  dwMDRequiredDataLen;
    
    // open key to ROOT on website #1 (default)
    hr = pIMSAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
        L"/LM/W3SVC/1",
        METADATA_PERMISSION_READ,
        REASONABLE_TIMEOUT,
        &hMetabase);
    if( FAILED( hr )) {
        return FALSE;
    }
    
    // Get the physical path for the WWWROOT
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szTmpData );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szTmpData);
    
    //if nothing specified get the root.
    if (_wcsicmp(wszVDir, L"") == 0) {
        WCHAR wszTempDir[MAX_PATH];
        swprintf(wszTempDir,L"/ROOT/%s", wszVDir);
        hr = pIMSAdminBase->GetData( hMetabase, wszTempDir, &mr, &dwMDRequiredDataLen );
    } else {
        hr = pIMSAdminBase->GetData( hMetabase, L"/ROOT", &mr, &dwMDRequiredDataLen );
    }
    pIMSAdminBase->CloseKey( hMetabase );
    
    if( SUCCEEDED( hr )) {
        wcscpy(wszStringPathToFill,szTmpData);
        fRet = TRUE;
    }
    
    pIMSAdminBase->CloseKey( hMetabase );
    return fRet;
}



BOOL
AddVirtualDir(
              IMSAdminBase *pIMSAdminBase,
              WCHAR * wszVDir,
              WCHAR * wszDir)
{
    HRESULT hr;
    BOOL    fRet = FALSE;
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    WCHAR   szTempPath[MAX_PATH];
    DWORD   dwMDRequiredDataLen = 0;
    DWORD   dwAccessPerm = 0;
    METADATA_RECORD mr;
    
    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
        L"/LM/W3SVC/1/ROOT",
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        REASONABLE_TIMEOUT,
        &hMetabase );
    
    // Create the key if it does not exist.
    if( FAILED( hr )) {
        return FALSE;
    }
    
    fRet = TRUE;
    
    mr.dwMDIdentifier = MD_VR_PATH;
    mr.dwMDAttributes = 0;
    mr.dwMDUserType   = IIS_MD_UT_FILE;
    mr.dwMDDataType   = STRING_METADATA;
    mr.dwMDDataLen    = sizeof( szTempPath );
    mr.pbMDData       = reinterpret_cast<unsigned char *>(szTempPath);

    // see if MD_VR_PATH exists.
    hr = pIMSAdminBase->GetData( hMetabase, wszVDir, &mr, &dwMDRequiredDataLen );
    
    if( FAILED( hr )) {
        
        fRet = FALSE;
        if( hr == MD_ERROR_DATA_NOT_FOUND ||
            HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND ) {
            
            // Write both the key and the values if GetData() failed with any of the two errors.
            
            pIMSAdminBase->AddKey( hMetabase, wszVDir );
            
            mr.dwMDIdentifier = MD_VR_PATH;
            mr.dwMDAttributes = METADATA_INHERIT;
            mr.dwMDUserType   = IIS_MD_UT_FILE;
            mr.dwMDDataType   = STRING_METADATA;
            mr.dwMDDataLen    = (wcslen(wszDir) + 1) * sizeof(WCHAR);
            mr.pbMDData       = reinterpret_cast<unsigned char *>(wszDir);
            
            // Write MD_VR_PATH value
            hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
            fRet = SUCCEEDED( hr );
            
            // Set the default authentication method
            if( fRet ) {
                
                DWORD dwAuthorization = MD_AUTH_ANONYMOUS;     // NTLM only.
                
                mr.dwMDIdentifier = MD_AUTHORIZATION;
                mr.dwMDAttributes = METADATA_INHERIT;   // need to inherit so that all subdirs are also protected.
                mr.dwMDUserType   = IIS_MD_UT_FILE;
                mr.dwMDDataType   = DWORD_METADATA;
                mr.dwMDDataLen    = sizeof(DWORD);
                mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAuthorization);
                
                // Write MD_AUTHORIZATION value
                hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
                fRet = SUCCEEDED( hr );
            }
        }
    }
    
    // In the following, do the stuff that we always want to do to the virtual dir, regardless of Admin's setting.
    
    if( fRet ) {
        
        dwAccessPerm = MD_ACCESS_READ;
        
        mr.dwMDIdentifier = MD_ACCESS_PERM;
        mr.dwMDAttributes = METADATA_INHERIT;    // Make it inheritable so all subdirectories will have the same rights.
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = DWORD_METADATA;
        mr.dwMDDataLen    = sizeof(DWORD);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(&dwAccessPerm);
        
        // Write MD_ACCESS_PERM value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }
    
    if( fRet ) {
        
        PWCHAR  szDefLoadFile = L"Default.htm,Default.asp";
        
        mr.dwMDIdentifier = MD_DEFAULT_LOAD_FILE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_FILE;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szDefLoadFile) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szDefLoadFile);
        
        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }
    
    if( fRet ) {
        
        PWCHAR  szKeyType = IIS_CLASS_WEB_VDIR_W;
        
        mr.dwMDIdentifier = MD_KEY_TYPE;
        mr.dwMDAttributes = 0;   // no need for inheritence
        mr.dwMDUserType   = IIS_MD_UT_SERVER;
        mr.dwMDDataType   = STRING_METADATA;
        mr.dwMDDataLen    = (wcslen(szKeyType) + 1) * sizeof(WCHAR);
        mr.pbMDData       = reinterpret_cast<unsigned char *>(szKeyType);
        
        // Write MD_DEFAULT_LOAD_FILE value
        hr = pIMSAdminBase->SetData( hMetabase, wszVDir, &mr );
        fRet = SUCCEEDED( hr );
    }
    
    pIMSAdminBase->CloseKey( hMetabase );
    
    return fRet;
}


BOOL
RemoveVirtualDir(
                 IMSAdminBase *pIMSAdminBase,
                 WCHAR * wszVDir)
{
    METADATA_HANDLE hMetabase = NULL;       // handle to metabase
    HRESULT hr;
    
    // Attempt to open the virtual dir set on Web server #1 (default server)
    hr = pIMSAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
        L"/LM/W3SVC/1/ROOT",
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        REASONABLE_TIMEOUT,
        &hMetabase );
    
    if( FAILED( hr )) {
        return FALSE; 
    }
    
    // We don't check the return value since the key may already 
    // not exist and we could get an error for that reason.
    pIMSAdminBase->DeleteKey( hMetabase, wszVDir );
    
    pIMSAdminBase->CloseKey( hMetabase );    
    
    return TRUE;
}

//Check if the service "lpServiceName" exist or not
// if exist, return 0
// if not,  return error code
INT CheckifServiceExist(LPCTSTR lpServiceName)
{
    INT err = 0;
    SC_HANDLE hScManager = NULL;
    SC_HANDLE hService = NULL;
    
    if ((hScManager = OpenSCManager(NULL, NULL, GENERIC_ALL)) == NULL 
        || (hService = OpenService(hScManager, lpServiceName, GENERIC_ALL)) == NULL)
    {
        err = GetLastError();
    }
    
    if (hService) 
        CloseServiceHandle(hService);
    if (hScManager) 
        CloseServiceHandle(hScManager);
    return (err);
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\privs.cpp ===
//+-------------------------------------------------------------------------
//
//  
//  Copyright (C) Microsoft
//
//  File:       securd.cpp
//
//  History:    30-March-2000    a-skuzin   Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"

//
// #include <windows.h>
// #include <ntsecapi.h>
//

#ifndef NT_SUCCESS

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

#endif

NTSTATUS ChangePrivilegeOnAccount(IN BOOL addPrivilage, IN LPWSTR wszServer, IN LPWSTR wszPrivilegeName, IN PSID pSid);
// NTSTATUS OpenPolicy(IN LPWSTR wszServer,IN DWORD DesiredAccess,OUT PLSA_HANDLE pPolicyHandle );
void InitLsaString(OUT PLSA_UNICODE_STRING LsaString,IN LPWSTR String);
BOOL SetPrivilegeInAccessToken(LPCTSTR PrivilegeName,DWORD dwAttributes) ;


/*****************************************************************************
 *
 *  GrantRemotePrivilegeToEveryone
 *
 *   Grants "SeRemoteInteractiveLogonRight" privilege to "Everyone SID"
 *
 * ENTRY:
 *  BOOL    addPrivilage    - if TRUE, we are adding privilege, else, we are remving privilage
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD 
GrantRemotePrivilegeToEveryone( BOOL addPrivilege)
{
	USES_CONVERSION;
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSID pWorldSid;

    if(!AllocateAndInitializeSid( &WorldSidAuthority, 1,
                                   SECURITY_WORLD_RID,
                                   0, 0, 0, 0, 0, 0, 0,
                                   &pWorldSid ))
    {
        return GetLastError();
    }
    
    NTSTATUS Status = ChangePrivilegeOnAccount(addPrivilege, NULL, T2W(SE_REMOTE_INTERACTIVE_LOGON_NAME),pWorldSid);

    FreeSid(pWorldSid);

    return (DWORD)LsaNtStatusToWinError(Status);
}

/*****************************************************************************
 *
 *  ChangePrivilegeOnAccount
 *
 *   Grants or Remove privelege represented by wszPrivilegeName to account represented by  pSid
 *
 * ENTRY:
 *      BOOL    addPrivilage     - If TRUE, we are adding privilage, else, we are removing privilage
 *      LPCWSTR wszServer        - name of the server on which the privilege is being set
 *      LPCWSTR wszPrivilegeName - name of the privilege
 *      PSID pSid                - pointer to hte SID of the user (or group)
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: NTSTATUS code of an error if failure
 *           
 *          
 *
 ****************************************************************************/
NTSTATUS 
ChangePrivilegeOnAccount(
        IN BOOL   addPrivilege,       // add or remove
        IN LPWSTR wszServer,
        IN LPWSTR wszPrivilegeName,
        IN PSID pSid)
{
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle = NULL;

    Status = OpenPolicy(wszServer,POLICY_WRITE|POLICY_LOOKUP_NAMES,&PolicyHandle);

    if(!NT_SUCCESS(Status))
    {
        return Status;
    }
    
    
    LSA_UNICODE_STRING PrivilegeString;
    //
    // Create a LSA_UNICODE_STRING for the privilege name.
    //
    InitLsaString(&PrivilegeString, wszPrivilegeName);
    //
    // grant  the privilege
    //

    if ( addPrivilege) 
    {
        Status=LsaAddAccountRights(
                    PolicyHandle,       // open policy handle
                    pSid,               // target SID
                    &PrivilegeString,   // privileges
                    1                   // privilege count
                    );
    }
    else
    {
        Status=LsaRemoveAccountRights(
            PolicyHandle,       // open policy handle
            pSid,               // target SID
            FALSE,              // we are NOT removing all rights 
            &PrivilegeString,   // privileges
            1                   // privilege count
            );
    }

    LsaClose(PolicyHandle);

    return Status;
}

#if 0
/*****************************************************************************
 *
 *  OpenPolicy
 *
 *   Opens LSA policy
 *
 * ENTRY:
 *      IN LPWSTR wszServer
 *      IN DWORD DesiredAccess 
 *      OUT PLSA_HANDLE pPolicyHandle
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: NTSTATUS code of an error if failure
 *           
 *          
 *
 ****************************************************************************/
NTSTATUS  
OpenPolicy(
        IN LPWSTR wszServer,
        IN DWORD DesiredAccess, 
        OUT PLSA_HANDLE pPolicyHandle ) 
{ 
    LSA_OBJECT_ATTRIBUTES ObjectAttributes; 
    LSA_UNICODE_STRING ServerString; 
    // 
    // Always initialize the object attributes to all zeroes. 
    // 
    ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes)); 
    // 
    // Make a LSA_UNICODE_STRING out of the LPWSTR passed in 
    // 
    InitLsaString(&ServerString, wszServer); 
    // 
    // Attempt to open the policy. 
    // 
    return LsaOpenPolicy( 
                &ServerString, 
                &ObjectAttributes, 
                DesiredAccess, 
                pPolicyHandle); 
}


/*****************************************************************************
 *
 *  InitLsaString
 *
 *   Makes a LSA_UNICODE_STRING out of the LPWSTR passed in
 *
 * ENTRY:
 *      OUT PLSA_UNICODE_STRING LsaString
 *      IN LPWSTR String
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  NONE
 *           
 *          
 *
 ****************************************************************************/
void 
InitLsaString(
        OUT PLSA_UNICODE_STRING LsaString,
        IN LPWSTR String)
{
    DWORD StringLength;

    if (String == NULL) 
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = wcslen(String);
    LsaString->Buffer = String;
    LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
    LsaString->MaximumLength=(USHORT)(StringLength+1) * sizeof(WCHAR);
} 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\rdpdrstp.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    rdpdrstp

Abstract:

    This module implements Terminal Server RDPDR device redirector
    setup functions in C for user-mode NT.

Environment:

    User mode

Author:

    Tadb

--*/

#ifndef _RDPDRSTP_
#define _RDPDRSTP_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

////////////////////////////////////////////////////////////
//
//  Internal Defines
//

#define TRDPDRPNPID     TEXT("ROOT\\RDPDR")
#define RDPDRPNPID      L"ROOT\\RDPDR"
#define RDPDRDEVICEID   TEXT("Root\\RDPDR\\0000")



#ifdef TSOC_CONSOLE_SHADOWING

#define RDPMOUPNPID     L"ROOT\\RDP_MOU"
#define RDPMOUDEVICEID  TEXT("Root\\RDP_MOU\\0000")
#define RDPKBDPNPID     L"ROOT\\RDP_KBD"
#define RDPKBDDEVICEID  TEXT("Root\\RDP_KBD\\0000")

/*
const TCHAR szRDPCDDInfFile[]    = _T("%windir%\\inf\\rdpcdd.inf");
const TCHAR szRDPCDDHardwareID[] = _T("ROOT\\DISPLAY");             // should match with the inf entry.
const TCHAR szRDPCDDDeviceName[] = _T("ROOT\\DISPLAY\\0000");
*/

/*++

Routine Description:

    This is the single entry point for RDPDR (Terminal Server Device Redirector)
    GUI-mode setup install routine.

    It currently simply creates and installs a dev node for RDPDR to interact with
    PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
/*
DWORD
InstallRootEnumeratedDevice(
    IN  HWND   hwndParent,
    IN  PCTSTR DeviceName,
    IN  PCTSTR HardwareIdList,
    IN  PCTSTR FullInfPath,
    OUT PBOOL  RebootRequired  OPTIONAL
    );
*/
#endif // TSOC_CONSOLE_SHADOWING

BOOL RDPDRINST_GUIModeSetupInstall(
    IN  HWND    hwndParent,
    IN  WCHAR   *pPNPID,
    IN  TCHAR   *pDeviceID
    );


/*++

Routine Description:

    This is the single entry point for RDPDR (Terminal Server Device Redirector)
    GUI-mode setup uninstall routine.

    It currently simply remove the dev node created so that RDPDR can interact
    with PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
BOOL RDPDRINST_GUIModeSetupUninstall(HWND hwndParent, WCHAR *pPNPID, GUID *pGuid);
BOOL IsRDPDrInstalled ();

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // RDPDRSTP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\securd.cpp ===
//+-------------------------------------------------------------------------
//
//  
//  Copyright (C) Microsoft
//
//  File:       securd.cpp
//
//  History:    30-March-2000    a-skuzin   Created
//
//--------------------------------------------------------------------------

#include "stdafx.h"

#include <winsta.h>
#include <regapi.h>

#include "secupgrd.h"
#include "state.h"

// from winnt.h
#define MAXDWORD    0xffffffff

//Global variables
BYTE g_DefaultSD[] = {  0x01,0x00,0x14,0x80,0x88,0x00,0x00,0x00,0x94,0x00,
                        0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x00,0x00,
                        0x02,0x00,0x74,0x00,0x05,0x00,0x00,0x00,0x00,0x00,
                        0x18,0x00,0xBF,0x03,0x0F,0x00,0x01,0x02,0x00,0x00,
                        0x00,0x00,0x00,0x05,0x20,0x00,0x00,0x00,0x20,0x02,
                        0x00,0x00,0x00,0x00,0x14,0x00,0xBF,0x03,0x0F,0x00,
                        0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x12,0x00,
                        0x00,0x00,0x00,0x00,0x18,0x00,0x21,0x01,0x00,0x00,
                        0x01,0x02,0x00,0x00,0x00,0x00,0x00,0x05,0x20,0x00,
                        0x00,0x00,0x2B,0x02,0x00,0x00,0x00,0x00,0x14,0x00,
                        0x81,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,
                        0x00,0x05,0x13,0x00,0x00,0x00,0x00,0x00,0x14,0x00,
                        0x81,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,
                        0x00,0x05,0x14,0x00,0x00,0x00,0x01,0x01,0x00,0x00,
                        0x00,0x00,0x00,0x05,0x12,0x00,0x00,0x00,0x01,0x01,
                        0x00,0x00,0x00,0x00,0x00,0x05,0x12,0x00,0x00,0x00 };

BYTE g_ConsoleSD[] = {  0x01,0x00,0x14,0x80,0x70,0x00,0x00,0x00,0x7C,0x00,
                        0x00,0x00,0x00,0x00,0x00,0x00,0x14,0x00,0x00,0x00,
                        0x02,0x00,0x5C,0x00,0x04,0x00,0x00,0x00,0x00,0x00,
                        0x18,0x00,0xBF,0x03,0x0F,0x00,0x01,0x02,0x00,0x00,
                        0x00,0x00,0x00,0x05,0x20,0x00,0x00,0x00,0x20,0x02,
                        0x00,0x00,0x00,0x00,0x14,0x00,0x81,0x00,0x00,0x00,
                        0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x13,0x00,
                        0x00,0x00,0x00,0x00,0x14,0x00,0x81,0x00,0x00,0x00,
                        0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x14,0x00,
                        0x00,0x00,0x00,0x00,0x14,0x00,0xBF,0x03,0x0F,0x00,
                        0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,0x12,0x00,
                        0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x05,
                        0x12,0x00,0x00,0x00,0x01,0x01,0x00,0x00,0x00,0x00,
                        0x00,0x05,0x12,0x00,0x00,0x00 };

DWORD AreThereAnyCustomSecurityDescriptors( BOOL &any )
{
    HKEY hKey;
    DWORD err;

    err=RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REG_WINSTATION_KEY,
		0,
		KEY_READ,
		&hKey
		);

	if( err!=ERROR_SUCCESS )
	{
        LOGMESSAGE1(_T("Could not open TS key %d"),err);
		return err;
	}

    CDefaultSD DefaultSD;
    CDefaultSD ConsoleSD;
    //Load default SD from the registry, since we need to compare to this
    err = DefaultSD.Init(hKey,DefaultRDPSD);   
    
    if( err!=ERROR_SUCCESS )
    {
        RegCloseKey(hKey);
        return err;
    }

    //Load default console SD from the registry, since we need to compare to this
    err = ConsoleSD.Init(hKey,DefaultConsoleSD);   
    
    if( err!=ERROR_SUCCESS )
    {
        RegCloseKey(hKey);
        return err;
    }

    CNameAndSDList NameSDList;
    DWORD dwTotalWinStations = 0;
    DWORD dwDefaultWinStations = 0;

    err=EnumWinStationSecurityDescriptors( hKey, &NameSDList);
    if(err == ERROR_SUCCESS)
    {
        dwTotalWinStations = NameSDList.size();

        if(dwTotalWinStations)
        {
            CNameAndSDList::iterator it;
            
            for(it=NameSDList.begin();it!=NameSDList.end(); it++)
            {
                if((*it).IsDefaultOrEmpty(&DefaultSD,&ConsoleSD))
                {
                    dwDefaultWinStations++;
                }
            }

            //If all descriptors are default
            if(dwDefaultWinStations == dwTotalWinStations)
            {
                any = FALSE;
            }
            else
            {
                any = TRUE;
            }
        }
    }
    
    RegCloseKey(hKey);
    return err;
}

/*****************************************************************************
 *
 *  SetupWorker
 *
 * ENTRY:
 *  IN const TSState &State
 *  
 *  
 * NOTES:
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *
 ****************************************************************************/
DWORD
SetupWorker(
        IN const TSState &State )
{
    DWORD Result;
    const BOOL bStandAlone = State.IsStandAlone();
    const BOOL bClean = State.IsTSFreshInstall();
    const BOOL bAppServer = State.IsItAppServer();
    const BOOL bServer = State.IsServer();

    LOGMESSAGE4(_T("SetupWorker( %d, %d, %d, %d )"), bClean, bStandAlone, bServer, bAppServer );

    if (!bStandAlone) // we are in GUI-setup mode
    {  
        // clean install of OS or OS upgrade

        Result = SetupWorkerNotStandAlone( bClean, bServer,bAppServer );         
    }
    else
    {
        // we are being called from Add/Remove Programs, which means, we are
        // switching modes

        BOOL    anyCustomSDs;

        Result = AreThereAnyCustomSecurityDescriptors( anyCustomSDs ) ;

        LOGMESSAGE1(_T("AreThereAnyCustomSecurityDescriptors = %d"),  anyCustomSDs );

        if ( Result == ERROR_SUCCESS ) 
        {

            if (!anyCustomSDs )  
            {
                // make sure we don't have a left-over privilage on the EveryoneSID
                Result = GrantRemotePrivilegeToEveryone( FALSE );
            }

            if (!bAppServer) 
            {
                // we are switching to Remote-Admin mode, secure machine by
                // removing the content of the RDU-Group
                Result = RemoveAllFromRDUsersGroup();
            }
        }
        else
        {
            LOGMESSAGE1(_T("AreThereAnyCustomSecurityDescriptors() returned : %d"),Result );
        }

    }

    return Result; 
}



/*****************************************************************************
 *
 *  SetupWorkerNoStandAlone
 *      This will be called when machine is being upgraded or fresh OS is being installed.
 *      It is NOT called if switching modes (AS <->RA )
 *
 * ENTRY:
 *  none
 *  
 *  
 * NOTES:
 *  IN BOOL bClean 
 *  IN BOOL bServer
 *  IN BOOL bAppServer
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *
 ****************************************************************************/
DWORD SetupWorkerNotStandAlone( 
    IN BOOL bClean,
    IN BOOL bServer,
    IN BOOL bAppServer)
{
    HKEY hKey;
    DWORD err;

    err=RegOpenKeyEx(
		HKEY_LOCAL_MACHINE,
		REG_WINSTATION_KEY,
		0,
		KEY_READ|KEY_WRITE,
		&hKey
		);
	if( err!=ERROR_SUCCESS )
	{
        LOGMESSAGE1(_T("Could not open TS key %d"),err);
		return err;
	}

    if(!bClean)
    {
        err = GrantRemoteUsersAccessToWinstations(hKey,bServer,bAppServer);

        LOGMESSAGE1(_T("GrantRemoteUsersAccessToWinstations() returned : %d"),err);

        if(err != ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
            return err;
        }
    }

    err = SetNewDefaultSecurity(hKey);

    LOGMESSAGE1(_T("SetNewDefaultSecurity() returned : %d"),err);

    err = SetNewConsoleSecurity(hKey,bServer);
        
    LOGMESSAGE1(_T("SetNewConsoleSecurity() returned : %d"),err);

    RegCloseKey(hKey);

    return err;
}

/*****************************************************************************
 *
 *  GrantRemoteUsersAccessToWinstations
 *
 *   if all winstations have default SD - copies all members from "Users" to
 *   "Remote Desktop Users", then deletes all winstation's security descriptors; 
 *   otherwise grants "Everyone" with "SeRemoteInteractiveLogonRight" privilege 
 *   and then adds "Remote Desktop Users" to each winstation's security descriptor
 *
 * ENTRY:
 *  IN HKEY hKey - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *  IN BOOL bAppServer 
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *
 ****************************************************************************/
DWORD 
GrantRemoteUsersAccessToWinstations(
        IN HKEY hKey,
        IN BOOL bServer,
        IN BOOL bAppServer)
{
    DWORD err;
    
    CDefaultSD DefaultSD;
    CDefaultSD ConsoleSD;

    //Load default SD from the registry
    err = DefaultSD.Init(hKey,DefaultRDPSD);   
    
    if( err!=ERROR_SUCCESS )
    {
        //Default SD may not be present if TS was
        //never enabled.
        if(err == ERROR_FILE_NOT_FOUND)
        {
            err = ERROR_SUCCESS;

        }
        return err;
    }
    
    //Load default console SD from the registry
    err = ConsoleSD.Init(hKey,DefaultConsoleSD);   
    
    if( err!=ERROR_SUCCESS )
    {
        return err;
    }

    BOOL bDefaultSDHasRemoteUsers;

    err = DefaultSD.DoesDefaultSDHaveRemoteUsers(&bDefaultSDHasRemoteUsers);
    
    if( err!=ERROR_SUCCESS )
    {
        return err;
    }
    else
    {
        //in this case assume that system already has been upgraded before.
        if(bDefaultSDHasRemoteUsers)
        {
            return ERROR_SUCCESS;
        }
    }

    CNameAndSDList NameSDList;
    DWORD dwTotalWinStations = 0;
    DWORD dwDefaultWinStations = 0;

    err=EnumWinStationSecurityDescriptors( hKey, &NameSDList);
    if(err == ERROR_SUCCESS)
    {
        dwTotalWinStations = NameSDList.size();

        if(dwTotalWinStations)
        {
            CNameAndSDList::iterator it;
            
            for(it=NameSDList.begin();it!=NameSDList.end(); it++)
            {
                if((*it).IsDefaultOrEmpty(&DefaultSD,&ConsoleSD))
                {
                    dwDefaultWinStations++;
                }
            }

            //If all descriptors are default
            if(dwDefaultWinStations == dwTotalWinStations)
            {
                //remove all ald default SDs (because we will have
                //different default SD
                for(it=NameSDList.begin();it!=NameSDList.end(); it++)
                {
                    if((*it).m_pSD)
                    {
                        //in case of error, continue with other winstations
                        //but return first error.
                        if(!err)
                        {
                            err = RemoveWinstationSecurity( hKey, (*it).m_pName );   
                        }
                        else
                        {
                            RemoveWinstationSecurity( hKey, (*it).m_pName );  
                        }
                    }
                }
                
            }
            else
            {
                //Grant "SeRemoteInteractiveLogonRight" privilege to "Everyone"
                err = GrantRemotePrivilegeToEveryone( TRUE );
 
                //Add "Remote Desktop Users" group to WinStation's DS.
                //Add also "LocalService" and "NetworkService".
                //NOTE: (*it).m_pSD is being changed during each call
                //to AddLocalAndNetworkServiceToWinstationSD or 
                //AddRemoteUsersToWinstationSD
                for(it=NameSDList.begin();it!=NameSDList.end(); it++)
                {
                    //On server - skip console
                    if(bServer && (*it).IsConsole())
                    {
                        //if SD is not NULL add "LocalService" and "NetworkService" to it
                        if((*it).m_pSD)
                        {
                            if(!err)
                            {
                                err = AddLocalAndNetworkServiceToWinstationSD( hKey, &(*it) );   
                            }
                            else
                            {
                                AddLocalAndNetworkServiceToWinstationSD( hKey, &(*it) );  
                            }
                        }
                        continue;
                    }

                    //if SD is not NULL add RDU to it
                    if((*it).m_pSD)
                    {
                        //in case of error, continue with other winstations
                        //but return first error.
                        if(!err)
                        {
                            err = AddRemoteUsersToWinstationSD( hKey, &(*it) );   
                        }
                        else
                        {
                            AddRemoteUsersToWinstationSD( hKey, &(*it) );  
                        }
                        
                        //add "LocalService" and "NetworkService" to SD
                        if(!err)
                        {
                            err = AddLocalAndNetworkServiceToWinstationSD( hKey, &(*it) );   
                        }
                        else
                        {
                            AddLocalAndNetworkServiceToWinstationSD( hKey, &(*it) );  
                        }
                    }
                   
                }
                
            }
        }
    }
 
    return err;
}

/*****************************************************************************
 *
 *  AddRemoteUserToWinstationSD
 *
 *   Grants "user access" permissions to a winstation to "REMOTE DESKTOP USERS"
 *
 * ENTRY:
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN CNameAndSD *pNameSD  - name and security descriptor of a winstation
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD 
AddRemoteUsersToWinstationSD(
        IN HKEY hKeyParent,
        IN CNameAndSD *pNameSD)
{
    //
    DWORD err = ERROR_SUCCESS;

    PACL pDacl = NULL;

    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pRUSid=NULL;
    
    if( !AllocateAndInitializeSid( &sia, 2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, 
              0, 0, 0, 0, 0, 0,&pRUSid ) )
    {
        return GetLastError();
    }

    
    
    //get dacl
    err = GetDacl(pNameSD->m_pSD, &pDacl );

    if( err == ERROR_SUCCESS ) {
        
        
        if(!pDacl) 
        {
            //It shuold never be in our case 
            //so we return error here
            FreeSid(pRUSid);
            return ERROR_INVALID_PARAMETER;
        }
        
        //let's add it
        err = AddUserToDacl( hKeyParent, pDacl, pRUSid, WINSTATION_USER_ACCESS, pNameSD ); 

    }
    
    FreeSid(pRUSid);
    return err;
}

/*****************************************************************************
 *
 *  AddLocalAndNetworkServiceToWinstationSD
 *
 *   Grants WINSTATION_QUERY | WINSTATION_MSG permissions to 
 *   a winstation to LocalService and NetworkService accounts
 *
 * ENTRY:
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN CNameAndSD *pNameSD  - name and security descriptor of a winstation
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD 
AddLocalAndNetworkServiceToWinstationSD(
        IN HKEY hKeyParent,
        IN CNameAndSD *pNameSD)
{
    //
    DWORD err = ERROR_SUCCESS;
    PACL pDacl = NULL;
    
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pLSSid=NULL;
    PSID pNSSid=NULL;
    

    if( !AllocateAndInitializeSid( &sia, 1,
              SECURITY_LOCAL_SERVICE_RID,
              0, 0, 0, 0, 0, 0, 0,&pLSSid ) )
    {
        return GetLastError();
    }
    
    
    
    if( !AllocateAndInitializeSid( &sia, 1,
              SECURITY_NETWORK_SERVICE_RID,
              0, 0, 0, 0, 0, 0, 0,&pNSSid ) )
    {
        FreeSid(pLSSid);
        return GetLastError();
    }
    
    
    //get dacl
    err = GetDacl(pNameSD->m_pSD, &pDacl );

    if( err == ERROR_SUCCESS ) {
        
        
        if(!pDacl) 
        {
            //It shuold never be in our case 
            //so we return error here
            FreeSid(pLSSid);
            FreeSid(pNSSid);
            return ERROR_INVALID_PARAMETER;
        }
        
        //let's add it
        err = AddUserToDacl( hKeyParent, pDacl, pLSSid, 
            WINSTATION_QUERY | WINSTATION_MSG, pNameSD ); 
        if(err == ERROR_SUCCESS)
        {
            //SD has been changed. It makes pDacl invalid.
            //So we need to get it again
            err = GetDacl(pNameSD->m_pSD, &pDacl );
            
            ASSERT(pDacl);

            if(err == ERROR_SUCCESS)
            {
                err = AddUserToDacl( hKeyParent, pDacl, pNSSid, 
                    WINSTATION_QUERY | WINSTATION_MSG, pNameSD );
            }
        }

    }
    
    FreeSid(pLSSid);
    FreeSid(pNSSid);
    return err;
}

/*****************************************************************************
 *
 *  AddUserToDacl
 *
 *   Grants 
 *   WINSTATION_USER_ACCESS
 *   permissions to a winstation to user, defined by SID
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN PACL pOldACL:   pointer to prewvious DACL of the key
 *   IN PSID pSid:      pointer to SID of user to grant permissions to
 *   IN DWORD dwAccessMask: access flags for this SID
 *   IN CNameAndSD *pNameSD  - name and security descriptor of a winstation
 * NOTES:
 *
 * EXIT:
 *  Returns: error code if cannot grant permissions; ERROR_SUCCESS otherwise.
 *
 ****************************************************************************/

DWORD 
AddUserToDacl(
        IN HKEY hKeyParent,
        IN PACL pOldACL, 
        IN PSID pSid,
        IN DWORD dwAccessMask,
        IN CNameAndSD *pNameSD)
{
    //See if this user is already in the DACL.
    //In this case don't add the user
    //search ACL for "REMOTE USERS"  SID
    ACL_SIZE_INFORMATION asiAclSize; 
	DWORD dwBufLength=sizeof(asiAclSize);
    ACCESS_ALLOWED_ACE *paaAllowedAce; 
    DWORD dwAcl_i;
    
    ASSERT(pOldACL);

    if (GetAclInformation(pOldACL, 
                (LPVOID)&asiAclSize, 
                (DWORD)dwBufLength, 
                (ACL_INFORMATION_CLASS)AclSizeInformation)) 
    { 
    
        for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
        { 

            if(GetAce( pOldACL, dwAcl_i, (LPVOID *)&paaAllowedAce)) 
            {

                if(EqualSid((PSID)&(paaAllowedAce->SidStart),pSid)) 
                {
                    //some permission already exist, we don't need to 
                    //do anything (even if it is a different permission!)
                    return ERROR_SUCCESS;
                }
            }
        }
    }

    DWORD err=ERROR_SUCCESS;
    PACL pNewACL;
    ACCESS_ALLOWED_ACE *pNewACE;

    //calculate space needed for 1 additional ACE
    WORD wSidSize=(WORD)GetLengthSid( pSid);
    WORD wAceSize=(sizeof(ACCESS_ALLOWED_ACE)+wSidSize-sizeof( DWORD ));
    
	pNewACL=(PACL)LocalAlloc(LPTR,pOldACL->AclSize+wAceSize);
    if(!pNewACL) 
    {
        return GetLastError();
    }
    //copy old ACL to new ACL
    memcpy(pNewACL,pOldACL,pOldACL->AclSize);
    //correct size
    pNewACL->AclSize+=wAceSize;
	
    //prepare new ACE
    //----------------------------------------------------------
    pNewACE=(ACCESS_ALLOWED_ACE*)LocalAlloc(LPTR,wAceSize);
    if(!pNewACE) 
    {
        LocalFree(pNewACL);
        return GetLastError();
    }

    pNewACE->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    pNewACE->Header.AceFlags = 0;
    pNewACE->Header.AceSize = wAceSize;
    pNewACE->Mask = dwAccessMask;
    CopySid( wSidSize, (PSID) &(pNewACE->SidStart), pSid);
    
    //append new ACE to the ACL
     if(!AddAce(pNewACL,pNewACL->AclRevision,MAXDWORD,pNewACE,wAceSize)) 
    {
        err=GetLastError();
    }
    else
    {
        //create new security descriptor
        SECURITY_DESCRIPTOR NewAbsSD;
        if(InitializeSecurityDescriptor(&NewAbsSD, SECURITY_DESCRIPTOR_REVISION) && 
            SetSecurityDescriptorDacl(&NewAbsSD,TRUE,pNewACL,FALSE) ) 
        {

            //---------------------------------------------------------
            //Copy all other stuff from the old SD to the new SD
            SECURITY_DESCRIPTOR_CONTROL sdc;
            DWORD dwRevision;
            if(GetSecurityDescriptorControl(pNameSD->m_pSD,&sdc,&dwRevision))
            {
                //Clear SE_SELF_RELATIVE flag
                sdc &=~SE_SELF_RELATIVE;

                SetSecurityDescriptorControl(&NewAbsSD,sdc,sdc);
            }
            
            PSID pSidTmp = NULL;
            BOOL bDefaulted;
            if(GetSecurityDescriptorOwner(pNameSD->m_pSD,&pSidTmp,&bDefaulted) && pSidTmp)
            {
                SetSecurityDescriptorOwner(&NewAbsSD,pSidTmp,bDefaulted);                
            }
            
            pSidTmp = NULL;
            if(GetSecurityDescriptorGroup(pNameSD->m_pSD,&pSidTmp,&bDefaulted) && pSidTmp)
            {
                SetSecurityDescriptorGroup(&NewAbsSD,pSidTmp,bDefaulted);                
            }
            
            PACL pSacl = NULL;
            BOOL bSaclPresent;
            if(GetSecurityDescriptorSacl(pNameSD->m_pSD,&bSaclPresent,&pSacl,&bDefaulted))
            {
                SetSecurityDescriptorSacl(&NewAbsSD,bSaclPresent,pSacl,bDefaulted);
            }
            //---------------------------------------------------------

            DWORD dwSDLen = GetSecurityDescriptorLength( &NewAbsSD ); 
            PSECURITY_DESCRIPTOR pSD;

            pSD = ( PSECURITY_DESCRIPTOR )LocalAlloc(LPTR,dwSDLen);
            
            if(pSD)
            {
                if(MakeSelfRelativeSD( &NewAbsSD , pSD , &dwSDLen ))
                {
                    err = SetWinStationSecurity(hKeyParent, pNameSD->m_pName, pSD );
                    if(err == ERROR_SUCCESS)
                    {
                        pNameSD->SetSD(pSD);
                    }
                }
                else
                {
                     err=GetLastError();
                }
            }
            else
            {
                err=GetLastError();
            }
        }
        else
        {
            err=GetLastError();
        }
      
    }
    
    LocalFree(pNewACE);
    LocalFree(pNewACL);
    return err;    
}

/*****************************************************************************
 *
 *  GetDacl
 *
 *   Gets security descriptor DACL.
 *
 * ENTRY:
 *  
 *  IN PSECURITY_DESCRIPTOR *pSD: pointer to SD
 *  OUT PACL *ppDacl:  pointer to pointer to DACL inside SD
 *  
 * NOTES:
 *      Do not try to free DACL!
 *
 * EXIT:
 *  Returns: error code if cannot get DACL; ERROR_SUCCESS otherwise.
 *
 ****************************************************************************/

DWORD 
GetDacl(
        IN PSECURITY_DESCRIPTOR pSD, 
        OUT PACL *ppDacl)
{
	
    BOOL bDaclPresent;
    BOOL bDaclDefaulted;
    
    *ppDacl=NULL;
 
    if(GetSecurityDescriptorDacl(pSD,&bDaclPresent,ppDacl,&bDaclDefaulted)) {
        if(!bDaclPresent){
            *ppDacl=NULL;
        }
    } else {
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
} 

/*****************************************************************************
 *
 *  GetSacl
 *
 *   Gets security descriptor SACL.
 *
 * ENTRY:
 *  
 *  IN PSECURITY_DESCRIPTOR *pSD: pointer to SD
 *  OUT PACL *ppSacl:  pointer to pointer to SACL inside SD
 *  
 * NOTES:
 *      Do not try to free SACL!
 *
 * EXIT:
 *  Returns: error code if cannot get SACL; ERROR_SUCCESS otherwise.
 *
 ****************************************************************************/

DWORD 
GetSacl(
        IN PSECURITY_DESCRIPTOR pSD, 
        OUT PACL *ppSacl)
{
	
    BOOL bSaclPresent;
    BOOL bSaclDefaulted;
    
    *ppSacl=NULL;
 
    if(GetSecurityDescriptorSacl(pSD,&bSaclPresent,ppSacl,&bSaclDefaulted)) {
        if(!bSaclPresent){
            *ppSacl=NULL;
        }
    } else {
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
}

/*****************************************************************************
 *
 *  EnumWinStationSecurityDescriptors
 *
 *   Enumerates winstations and gets their security descriptors
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   OUT CNameAndSDList  - name and security descriptor of a winstation
 * NOTES:
 *      Call LocalFree function to free SD, do not try to free DACL!
 *
 * EXIT:
 *  Returns: error code or ERROR_SUCCESS
 *
 ****************************************************************************/
DWORD 
EnumWinStationSecurityDescriptors(
        IN  HKEY hKeyParent,
        OUT CNameAndSDList *pNameSDList)
{
    DWORD err;
    
	DWORD dwIndex;
	TCHAR wszTmpName[MAX_PATH+1];
	DWORD cbTmpName=MAX_PATH;
	FILETIME ftLastWriteTime;
    
	for(dwIndex=0;;dwIndex++)
	{
		cbTmpName=MAX_PATH;
		err=RegEnumKeyEx(
					hKeyParent, 	// handle of key to enumerate
					dwIndex, 	// index of subkey to enumerate
					wszTmpName, 	// address of buffer for subkey name
					&cbTmpName,  // address for size of subkey buffer
					NULL, // reserved
					NULL, // address of buffer for class string
					NULL, // address for size of class buffer
					&ftLastWriteTime // address for time key last written to
					);
		if((err!=ERROR_SUCCESS)&&
			(err!=ERROR_MORE_DATA)&&
			 (err!=ERROR_NO_MORE_ITEMS))
		{
			return err;
		}
		if(err==ERROR_NO_MORE_ITEMS)
			break;

		else
		{
            try
            {
                CNameAndSD Entry(wszTmpName);
                err = GetWinStationSecurity(hKeyParent, Entry.m_pName, 
                    _T("Security"), &(Entry.m_pSD));

                if( err == ERROR_SUCCESS || err == ERROR_FILE_NOT_FOUND )
                {
                    pNameSDList->push_back(Entry);
                }
            }
            catch(DWORD Except)
            {
                return Except;
            }

        }
	}

    return ERROR_SUCCESS;
}


/*****************************************************************************
 *
 *  GetWinStationSecurity
 *
 *   Returns WinStation's security descriptor.
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN  PWINSTATIONNAMEW pWSName  - name  of a winstation 
 *                        if pWSName is NULL - function returns default SD
 *   OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor - pointer to pointer to SD
 *
 * NOTES:
 *      Call LocalFree function to free SD!
 *
 * EXIT:
 *  Returns: error code or ERROR_SUCCESS 
 *
 ****************************************************************************/
DWORD 
GetWinStationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName,
        IN  LPCTSTR szValueName,  
        OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor)
{

    DWORD SDLength = 0;
    DWORD ValueType =0;
    HKEY hKey = NULL;
    DWORD err;

    *ppSecurityDescriptor = NULL;
    
    if(pWSName)
    {
        err = RegOpenKeyEx(hKeyParent, pWSName, 0,KEY_READ, &hKey );
    }
    else
    {
        //If pWSName - get defauilt SD
        hKey = hKeyParent;
        err = ERROR_SUCCESS;
    }

    if(err == ERROR_SUCCESS)
    {
        err = RegQueryValueEx( hKey, szValueName, NULL, &ValueType,NULL, &SDLength );
        if(err == ERROR_SUCCESS )
        {
            //Return error if not correct data type
            if (ValueType == REG_BINARY)
            {
 
                //Allocate a buffer to read the Security info and read it
                // ACLUI uses LocalFree
            
                *ppSecurityDescriptor = ( PSECURITY_DESCRIPTOR )LocalAlloc( LMEM_FIXED , SDLength );

                if ( *ppSecurityDescriptor )
                {
 
                    err = RegQueryValueEx( hKey, szValueName, NULL, &ValueType,
                                (BYTE *) *ppSecurityDescriptor, &SDLength );
                    if(err == ERROR_SUCCESS )
                    {
                        //Check for a valid SD before returning.
                        if(! IsValidSecurityDescriptor( *ppSecurityDescriptor ) )
                        {
                            LocalFree(*ppSecurityDescriptor);
                            *ppSecurityDescriptor = NULL;
                            err = ERROR_INVALID_DATA;
                        }
                    }
                    else
                    {
                        LocalFree(*ppSecurityDescriptor);
                        *ppSecurityDescriptor = NULL;
                    }
                }
                else
                {
                    err = ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            else
            {
                err = ERROR_INVALID_DATA;
            }
        }
        
        if(hKey != hKeyParent)
        {
            RegCloseKey(hKey);
        }
    }
    
    return err;

}  // GetWinStationSecurity

/*****************************************************************************
 *
 *  SetWinStationSecurity
 *
 *   Writes winstation security descriptor to the registry
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN PWINSTATIONNAMEW pWSName  - name of a winstation
 *   IN PSECURITY_DESCRIPTOR pSecurityDescriptor - pointer to SD
 *  
 * NOTES:
 *      Call LocalFree function to free SD, do not try to free DACL!
 *
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/

DWORD 
SetWinStationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName,
        IN  PSECURITY_DESCRIPTOR pSecurityDescriptor )
{

    HKEY hKey = NULL;
    DWORD err;

    err = RegOpenKeyEx(hKeyParent, pWSName, 0,KEY_WRITE, &hKey );
    if(err == ERROR_SUCCESS)
    {
        err = RegSetValueEx(hKey, _T("Security"),0,REG_BINARY,(LPBYTE)pSecurityDescriptor,
                    GetSecurityDescriptorLength(pSecurityDescriptor));

        RegCloseKey(hKey);
    }
    
    return err;

}  // SetWinStationSecurity


/*****************************************************************************
 *
 *  RemoveWinStationSecurity
 *
 *   Removes winstation's security descriptor from the registry
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN PWINSTATIONNAMEW pWSName  - name of a winstation
 *  
 * NOTES:
 *      
 *
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/
DWORD
RemoveWinstationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName)
{
    HKEY hKey = NULL;
    DWORD err;

    err = RegOpenKeyEx(hKeyParent, pWSName, 0,KEY_WRITE, &hKey );
    if(err == ERROR_SUCCESS)
    {
        err = RegDeleteValue(hKey, _T("Security"));

        RegCloseKey(hKey);
    }
    
    return err;
}

/*****************************************************************************
 *
 *  SetNewDefaultSecurity
 *
 *   Sets new default security descriptor
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *  
 * NOTES:
 *      
 *
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/
DWORD
SetNewDefaultSecurity( 
        IN  HKEY hKey)
{
    //
    DWORD err;
    err = RegSetValueEx(hKey, _T("DefaultSecurity"), 0, REG_BINARY, 
        (LPBYTE)g_DefaultSD, sizeof(g_DefaultSD));

    return err;
}

/*****************************************************************************
 *
 *  SetNewConsoleSecurity
 *
 *   Sets new console security descriptor
 *
 * ENTRY:
 *  
 *   IN HKEY hKeyParent      - handle to HKLM\SYSTEM\CurrentControlSet\
 *                                       Control\Terminal Server\WinStations
 *   IN BOOL bServer
 * NOTES:
 *      
 *
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/
DWORD
SetNewConsoleSecurity( 
        IN  HKEY hKeyParent,
        IN BOOL bServer)
{
    //
    DWORD err;
    
    //Set default console security
    if(bServer)
    {
        err = RegSetValueEx(hKeyParent, _T("ConsoleSecurity"), 0, REG_BINARY, 
            (LPBYTE)g_ConsoleSD, sizeof(g_ConsoleSD));
    }
    else
    { 
        // on Professional it's the same as "DefaultSecurity"
        err = RegSetValueEx(hKeyParent, _T("ConsoleSecurity"), 0, REG_BINARY, 
            (LPBYTE)g_DefaultSD, sizeof(g_DefaultSD));
    }

    return err;
}

/*****************************************************************************
 *
 *  CDefaultSD::DoesDefaultSDHaveRemoteUsers
 *
 *   Checks if defauilt SD has "Remote Desktop Users" SID. 
 *
 * ENTRY:
 *   OUT LPBOOL pbHas - TRUE if defauilt SD has "Remote Desktop Users" SID. 
 *  
 * NOTES:
 *  
 * EXIT:
 *  Returns: 0: if success
 *           Error code: otherwise
 *
 ****************************************************************************/
DWORD 
CDefaultSD::DoesDefaultSDHaveRemoteUsers(
        OUT LPBOOL pbHas)
{
    *pbHas = FALSE;
    //
    DWORD err = ERROR_SUCCESS;
    
    PACL pDacl = NULL;

    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pRUSid=NULL;
    
    if( !AllocateAndInitializeSid( &sia, 2,
              SECURITY_BUILTIN_DOMAIN_RID,
              DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, 
              0, 0, 0, 0, 0, 0,&pRUSid ) )
    {
        return GetLastError();
    }

    
    
    //get dacl
    err = GetDacl(m_pSD, &pDacl );

    if( err == ERROR_SUCCESS ) {
        //search ACL for "REMOTE USERS"  SID
        ACL_SIZE_INFORMATION asiAclSize; 
	    DWORD dwBufLength=sizeof(asiAclSize);
        ACCESS_ALLOWED_ACE *paaAllowedAce; 
        DWORD dwAcl_i;
        
        if(!pDacl) 
        {
            //It shuold never be in our case 
            //so we return error here
            FreeSid(pRUSid);
            return ERROR_INVALID_PARAMETER;
        }
        else
        //DACL present
        {

            if (GetAclInformation(pDacl, 
	            (LPVOID)&asiAclSize, 
	            (DWORD)dwBufLength, 
	            (ACL_INFORMATION_CLASS)AclSizeInformation)) 
            { 
	        
                for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
                { 

		            if(GetAce( pDacl, dwAcl_i, (LPVOID *)&paaAllowedAce)) 
                    {

                        if(EqualSid((PSID)&(paaAllowedAce->SidStart),pRUSid)) 
                        {
                            //permission already exist, we don't need to 
                            //do anything

                            *pbHas = TRUE;
		                }
                    }
                }
            }
        }
        
    }
    
    FreeSid(pRUSid);
    return err;
}

//*************************************************************
//
//  LookupSid()
//
//  Purpose:   Given SID allocates and returns string containing 
//             name of the user in format DOMAINNAME\USERNAME
//
//  Parameters: IN PSID pSid
//              OUT LPWSTR ppName 
//              OUT SID_NAME_USE *peUse   
//
//  Return:     TRUE if success, FALSE otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              10/23/00    skuzin     Created
//
//*************************************************************
BOOL
LookupSid(
    IN PSID pSid, 
    OUT LPWSTR *ppName,
    OUT SID_NAME_USE *peUse)
{
    LPWSTR szName = NULL;
    DWORD cName = 0;
    LPWSTR szDomainName = NULL;
    DWORD cDomainName = 0;
    
    *ppName = NULL;
    
    if(!LookupAccountSidW(NULL,pSid,
        szName,&cName,
        szDomainName,&cDomainName,
        peUse) && GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    {
        //cName and cDomainName include terminating 0
        *ppName = (LPWSTR)LocalAlloc(LPTR,(cName+cDomainName)*sizeof(WCHAR));

        if(*ppName)
        {
            szDomainName = *ppName;
            szName = &(*ppName)[cDomainName];

            if(LookupAccountSidW(NULL,pSid,
                    szName,&cName,
                    szDomainName,&cDomainName,
                    peUse))
            {
                //user name now in format DOMAINNAME\0USERNAME
                //let's replace '\0' with  '\\'
                //now cName and cDomainName do not include terminating 0
                //very confusing
                if(cDomainName)
                {
                    (*ppName)[cDomainName] = L'\\';
                }
                return TRUE;
            }
            else
            {
                LocalFree(*ppName);
                *ppName = NULL;
            }

        }

    }

    return FALSE;
}

//*************************************************************
//
//  IsLocal()
//
//  Purpose:    
//
//  Parameters: wszDomainandname   -  domain\user
//              determines whether the user is local or not
//              if local - cuts out domain name 
//
//  Return:     NONE
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
BOOL 
IsLocal(
        IN LPWSTR wszLocalCompName,
        IN OUT LPWSTR wszDomainandname)
{

    LPWSTR wszTmp = wcschr(wszDomainandname,L'\\');

    if(!wszTmp)
    {
        return TRUE;
    }

    if(!_wcsnicmp(wszDomainandname, wszLocalCompName,wcslen(wszLocalCompName) ))
    {
        //get rid of useless domain name
        wcscpy(wszDomainandname,wszTmp+1);
        return TRUE;
    }

    return FALSE;

}

//*************************************************************
//
//  GetAbsoluteSD()
//
//  Purpose:   Converts self-relative SD to absolute SD
//             returns pointers to SACL DACL Owner and Group 
//             of the absolute SD.
//
//  Parameters:
//             IN PSECURITY_DESCRIPTOR pSelfRelativeSD
//             OUT PSECURITY_DESCRIPTOR *ppAbsoluteSD
//             OUT PACL *ppDacl
//             OUT PACL *ppSacl
//             OUT PSID *ppOwner
//             OUT PSID *ppPrimaryGroup 
//
//  Return:  error code if fails, ERROR_SUCCESS otherwise
//
//  Comments: caller needs to free 
//            every returned pointer using LocalFree function.
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD
GetAbsoluteSD(
        IN PSECURITY_DESCRIPTOR pSelfRelativeSD,
        OUT PSECURITY_DESCRIPTOR *ppAbsoluteSD,
        OUT PACL *ppDacl,
        OUT PACL *ppSacl,
        OUT PSID *ppOwner,
        OUT PSID *ppPrimaryGroup)
{
    DWORD dwAbsoluteSDSize = 0;           // absolute SD size
    DWORD dwDaclSize = 0;                 // size of DACL
    DWORD dwSaclSize = 0;                 // size of SACL
    DWORD dwOwnerSize = 0;                // size of owner SID
    DWORD dwPrimaryGroupSize = 0;         // size of group SID

    *ppAbsoluteSD = NULL;
    *ppDacl = NULL;
    *ppSacl = NULL;
    *ppOwner = NULL;
    *ppPrimaryGroup = NULL;

    MakeAbsoluteSD(
              pSelfRelativeSD, // self-relative SD
              NULL,     // absolute SD
              &dwAbsoluteSDSize,           // absolute SD size
              NULL,                           // DACL
              &dwDaclSize,                 // size of DACL
              NULL,                           // SACL
              &dwSaclSize,                 // size of SACL
              NULL,                          // owner SID
              &dwOwnerSize,                // size of owner SID
              NULL,                   // primary-group SID
              &dwPrimaryGroupSize          // size of group SID
            );
    try
    {
        if(dwAbsoluteSDSize)
        {
            *ppAbsoluteSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,dwAbsoluteSDSize);
            if(!(*ppAbsoluteSD))
            {
                throw GetLastError();
            }
        }
        if(dwDaclSize)
        {
            *ppDacl = (PACL)LocalAlloc(LPTR,dwDaclSize);
            if(!(*ppDacl))
            {
                throw GetLastError();
            }
        }
        if(dwSaclSize)
        {
            *ppSacl = (PACL)LocalAlloc(LPTR,dwSaclSize);
            if(!(*ppSacl))
            {
                throw GetLastError();
            }
        }
        if(dwOwnerSize)
        {
            *ppOwner = (PSID)LocalAlloc(LPTR,dwOwnerSize);
            if(!(*ppOwner))
            {
                throw GetLastError();
            }
        }
        if(dwPrimaryGroupSize)
        {
            *ppPrimaryGroup = (PSID)LocalAlloc(LPTR,dwPrimaryGroupSize);
            if(!(*ppPrimaryGroup))
            {
                throw GetLastError();
            }
        }

        if(!MakeAbsoluteSD(
                  pSelfRelativeSD, // self-relative SD
                  *ppAbsoluteSD,     // absolute SD
                  &dwAbsoluteSDSize,           // absolute SD size
                  *ppDacl,                           // DACL
                  &dwDaclSize,                 // size of DACL
                  *ppSacl,                           // SACL
                  &dwSaclSize,                 // size of SACL
                  *ppOwner,                          // owner SID
                  &dwOwnerSize,                // size of owner SID
                  *ppPrimaryGroup,                   // primary-group SID
                  &dwPrimaryGroupSize          // size of group SID
                ))
        {
            throw GetLastError();
        }

    }
    catch(DWORD ret)
    {
        if(*ppAbsoluteSD)
        {
            LocalFree(*ppAbsoluteSD);
            *ppAbsoluteSD = NULL;
        }
        if(*ppDacl)
        {
            LocalFree(*ppDacl);
            *ppDacl = NULL;
        }
        if(*ppSacl)
        {
            LocalFree(*ppSacl);
            *ppSacl = NULL;
        }
        if(*ppOwner)
        {
            LocalFree(*ppOwner);
            *ppOwner = NULL;
        }
        if(*ppPrimaryGroup)
        {
            LocalFree(*ppPrimaryGroup);
            *ppPrimaryGroup = NULL;
        }

        return ret;
    }

    return ERROR_SUCCESS;
}

//*************************************************************
//
//  GetAbsoluteSD()
//
//  Purpose:   Converts absolute SD to self-relative SD
//             returns pointer to self-relative SD.
//
//  Parameters:
//             IN  PSECURITY_DESCRIPTOR pAbsoluteSD,
//             OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSD
//
//  Return:   error code if fails, ERROR_SUCCESS otherwise
//
//  Comments: caller needs to free 
//            returned pointer using LocalFree function.
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD
GetSelfRelativeSD(
  IN  PSECURITY_DESCRIPTOR pAbsoluteSD,
  OUT PSECURITY_DESCRIPTOR *ppSelfRelativeSD)
{
    DWORD dwBufferLength = 0;

    *ppSelfRelativeSD = NULL;

    MakeSelfRelativeSD(pAbsoluteSD, NULL, &dwBufferLength);
    
    if(dwBufferLength)
    {
        *ppSelfRelativeSD = (PSECURITY_DESCRIPTOR)LocalAlloc(LPTR,dwBufferLength);

        if(*ppSelfRelativeSD)
        {
            if(!MakeSelfRelativeSD(pAbsoluteSD, *ppSelfRelativeSD, &dwBufferLength))
            {
                DWORD dwResult = GetLastError();
                LocalFree(*ppSelfRelativeSD);
                return dwResult;
            }
        }

    }
    else
    {
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\rdpdrstp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    rdpdrstp

Abstract:

    This module implements Terminal Server RDPDR device redirector
    setup functions in C for user-mode NT.

Environment:

    User mode

Author:

    Tadb

--*/

// Toggle stand-alone testing.
//#define UNITTEST      1


#include "stdafx.h"


#ifdef UNITTEST
#include <windows.h>
#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
#include "objbase.h"        // for CoInitialize()
#endif

#include <devguid.h>
#include <cfgmgr32.h>
#include <winspool.h>
#include <rdpdrstp.h>
#include "newdev.h"

#define SIZECHARS(x)        (sizeof((x))/sizeof(*x))

//#define USBMON_DLL   TEXT("USBMON.DLL")
//#define USB_MON_NAME TEXT("USB Monitor")

#ifndef UNITTEST
#include "logmsg.h"
#endif

#ifdef UNITTEST
#define LOGMESSAGE1(arg1, arg2) ;
#define LOGMESSAGE0(arg1) ;
#endif


////////////////////////////////////////////////////////////
//
//  Internal Types
//

typedef BOOL (InstallDevInstFuncType)(
                    HWND hwndParent, LPCWSTR DeviceInstanceId,
                    BOOL UpdateDriver,
                    PDWORD pReboot,
                    BOOL silentInstall
                    );

BOOL RDPDRINST_GUIModeSetupInstall(
    IN  HWND    hwndParent,
    IN  WCHAR   *pPNPID,
    IN  TCHAR   *pDeviceID
    )
/*++

Routine Description:

    This is the single entry point for RDPDR (Terminal Server Device Redirector)
    GUI-mode setup install routine.

    It currently simply creates and installs a dev node for RDPDR to interact with
    PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    WCHAR               pnpID[256];
    DWORD               len;
    WCHAR               devInstanceID[MAX_PATH];
    InstallDevInstFuncType  *pInstallDevInst;
    HINSTANCE               hndl = NULL;
    //MONITOR_INFO_2 mi;

    //mi.pDLLName     =   USBMON_DLL;
    //mi.pEnvironment =   NULL;
    //mi.pName        =   USB_MON_NAME;


    // Add the USB port monitor
    //if (!AddMonitor(NULL, 2, (PBYTE)&mi)) {
    //    if (GetLastError() != ERROR_PRINT_MONITOR_ALREADY_INSTALLED) {
    //        LOGMESSAGE1(_T("AddMonitor failed.  Error code:  %ld."), GetLastError());
    //        return FALSE;
    //    }
    //}

    //
    //  Create the device info list.
    //
    devInfoSet = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_SYSTEM, hwndParent);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        LOGMESSAGE1(_T("Error creating device info list.  Error code:  %ld."),
                    GetLastError());
        return FALSE;
    }

    
    //
    //  Create the dev node.
    //
    ZeroMemory(&deviceInfoData, sizeof(SP_DEVINFO_DATA));
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiCreateDeviceInfo(devInfoSet,
                             pDeviceID,
                             &GUID_DEVCLASS_SYSTEM,
                             NULL,
                             hwndParent,
                             0L,   // No flags.
                             &deviceInfoData
                             ))
    {
        // If it already exists, then we are done ... because this was an
        // upgrade.
        if (GetLastError() == ERROR_DEVINST_ALREADY_EXISTS)
        {
            SetupDiDestroyDeviceInfoList(devInfoSet);
            return TRUE;
        }
        else {
            LOGMESSAGE1(_T("Error creating device node.  Error code:  %ld."),
                        GetLastError());
            SetupDiDestroyDeviceInfoList(devInfoSet);
            return FALSE;
        }
    }
    else if (!SetupDiSetSelectedDevice(devInfoSet, &deviceInfoData)) {
        LOGMESSAGE1(_T("Error selecting device node.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    //
    //  Add the RDPDR PnP ID.
    //

    // Create the PnP ID string.
    wcscpy(pnpID, pPNPID);
    len = wcslen(pnpID);

    // This is a multi_sz string, so we need to terminate with an extra null.
    pnpID[len+1] = 0;

    // Add it to the registry entry for the dev node.
    if (!SetupDiSetDeviceRegistryProperty(
                            devInfoSet, &deviceInfoData,
                            SPDRP_HARDWAREID, (CONST BYTE *)pnpID,
                            (len + 2) * sizeof(WCHAR))) {
        LOGMESSAGE1(_T("Error setting device registry property.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    //
    //  Register the, as of yet, phantom dev node with PnP to turn it into a real
    //  dev node.
    //
    if (!SetupDiRegisterDeviceInfo(devInfoSet, &deviceInfoData, 0, NULL,
                                NULL, NULL)) {
        LOGMESSAGE1(_T("Error registering device node with PnP.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    //
    //  Get the device instance ID.
    //
    if (!SetupDiGetDeviceInstanceIdW(devInfoSet, &deviceInfoData, devInstanceID,
        SIZECHARS(devInstanceID), NULL)) {
        LOGMESSAGE1(_T("Error getting the device instance id.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    //
    //  Use newdev.dll to install RDPDR as the driver for this new dev node.
    //
    hndl = LoadLibrary(TEXT("newdev.dll"));
    if (hndl == NULL) {
        LOGMESSAGE1(_T("Error loading newdev.dll.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    pInstallDevInst = (InstallDevInstFuncType *)GetProcAddress(hndl, "InstallDevInstEx");
    if (pInstallDevInst == NULL) {
        LOGMESSAGE1(_T("Error fetching InstallDevInst func.  Error code:  %ld."),
                    GetLastError());
        goto WhackTheDevNodeAndReturnError;
    }

    DWORD dwReboot;
    if ((*pInstallDevInst)(hwndParent, devInstanceID, FALSE, &dwReboot, TRUE)) {
        // Clean up and return success!
        SetupDiDestroyDeviceInfoList(devInfoSet);
        FreeLibrary(hndl);
        return TRUE;
    }
    else {
        LOGMESSAGE1(_T("Error in newdev install.  Error code:  %ld."),
            GetLastError());
    }

    //
    //  Whack the dev node and return failure.
    //
WhackTheDevNodeAndReturnError:
    SetupDiCallClassInstaller(DIF_REMOVE, devInfoSet, &deviceInfoData);
    SetupDiDestroyDeviceInfoList(devInfoSet);
    if (hndl != NULL) {
        FreeLibrary(hndl);
    }

    return FALSE;
}

BOOL RDPDRINST_GUIModeSetupUninstall(HWND hwndParent, WCHAR *pPNPID, GUID *pGuid)
/*++

Routine Description:

    This is the single entry point for RDPDR (Terminal Server Device Redirector)
    GUI-mode setup uninstall routine.

    It currently simply remove the dev node created so that RDPDR can interact
    with PnP.

Arguments:

    hwndParent    Handle to parent window for GUI required by this function.

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    DWORD               iLoop;
    BOOL                bMoreDevices;
    WCHAR               pnpID[256];
    BOOL                result;



    //
    //  Get the set of all devices with the RDPDR PnP ID.
    //
    devInfoSet = SetupDiGetClassDevs(pGuid, NULL, hwndParent,
                                   DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        LOGMESSAGE1(_T("Error getting RDPDR devices from PnP.  Error code:  %ld."),
                    GetLastError());
        return FALSE;
    }

    // Assume that we will be successful.
    result = TRUE;

    // Get the first device.
    iLoop=0;
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, iLoop, &deviceInfoData);

    // Get the details for all matching device interfaces.
    while (bMoreDevices)
    {
        // Get the PnP ID for the device.
        if (!SetupDiGetDeviceRegistryProperty(devInfoSet, &deviceInfoData,
                                SPDRP_HARDWAREID, NULL, (BYTE *)pnpID,
                                sizeof(pnpID), NULL)) {
            LOGMESSAGE1(_T("Error fetching PnP ID in RDPDR device node remove.  Error code:  %ld."),
                        GetLastError());
        }
        // If the current device matches RDPDR, then remove it.
        else if (!wcscmp(pnpID, pPNPID))
        {
            if (!SetupDiCallClassInstaller(DIF_REMOVE, devInfoSet, &deviceInfoData)) {
                // If we failed here, set the return status to indicate failure, but
                // don't give up on any other RDPDR dev nodes.
                LOGMESSAGE1(_T("Error removing RDPDR device node.  Error code:  %ld."),
                            GetLastError());
                result = FALSE;
            }
        }

        // Get the next one device interface.
        bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, ++iLoop, &deviceInfoData);
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return result;
}


ULONG RDPDRINST_DetectInstall()
/*++

Routine Description:

    Return the number of RDPDR.SYS devices found.

Arguments:

    NA

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    DWORD               iLoop;
    BOOL                bMoreDevices;
    ULONG               count;
    TCHAR               pnpID[256];


    GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;

    //
    //  Get the set of all devices with the RDPDR PnP ID.
    //
    devInfoSet = SetupDiGetClassDevs(pGuid, NULL, NULL,
                                   DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        LOGMESSAGE1(_T("ERRORgetting RDPDRINST_DetectInstall:RDPDR devices from PnP.  Error code:  %ld."),
                GetLastError());
        return 0;
    }

    // Get the first device.
    iLoop=0;
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, iLoop, &deviceInfoData);

    // Get the details for all matching device interfaces.
    count = 0;
    while (bMoreDevices)
    {
        // Get the PnP ID for the device.
        if (!SetupDiGetDeviceRegistryProperty(devInfoSet, &deviceInfoData,
                                SPDRP_HARDWAREID, NULL, (BYTE *)pnpID,
                                sizeof(pnpID), NULL)) {
            LOGMESSAGE1(_T("ERROR:fetching PnP ID in RDPDR device node remove.  Error code:  %ld."),
                        GetLastError());
        }

        // If the current device matches the RDPDR PNP ID
        if (!_tcscmp(pnpID, TRDPDRPNPID)) {
            count++;
        }

        // Get the next one device interface.
        bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, ++iLoop, &deviceInfoData);
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return count;
}

BOOL IsRDPDrInstalled ()
{
    ULONG ulReturn;
    LOGMESSAGE0(_T("Entered IsRDPDrInstalled"));
    
    ulReturn = RDPDRINST_DetectInstall();
    
    LOGMESSAGE1(_T("Returning IsRDPDrInstalled (ulReturn = %d)"), ulReturn);
    
    return 0 != ulReturn;
}

//
//      Unit-Test
//
#ifdef UNITTEST
void __cdecl main()
{
    RDPDRINST_GUIModeSetupInstall(NULL);
    RDPDRINST_GUIModeSetupUninstall(NULL);
}
#endif

#ifdef TSOC_CONSOLE_SHADOWING


//
// Need to instantiate the device class GUIDs so we can use the "Net" class
// GUID below...
//
/*
DWORD
InstallRootEnumeratedDevice(
    IN  HWND   hwndParent,
    IN  PCTSTR DeviceName,
    IN  PCTSTR HardwareIdList,
    IN  PCTSTR FullInfPath,
    OUT PBOOL  RebootRequired  OPTIONAL
    )
*/
/*++
    Routine Description:
    This routine creates and installs a new, root-enumerated devnode
    representing a network adapter.

    Arguments:
    hwndParent - Supplies the window handle to be used as the parent of any
    UI that is generated as a result of this device's installation.
    DeviceName - Supplies the full name of the devnode to be created (e.g.,
    "Root\VMWARE\0000"). Note that if this devnode already exists, the API
    will fail.

    HardwareIdList - Supplies a multi-sz list containing one or more hardware
    IDs to be associated with the device. These are necessary in order to
    match up with an INF driver node when we go to do the device
    installation.

    FullInfPath - Supplies the full path to the INF to be used when installing
    this device.

    RebootRequired - Optionally, supplies the address of a boolean that is set,
    upon successful return, to indicate whether or not a reboot is required
    to bring the newly-installed device on-line.
    Return Value:
    If the function succeeds, the return value is NO_ERROR.
    If the function fails, the return value is a Win32 error code indicating
    the cause of the failure.

--*/
/*
{
    HDEVINFO DeviceInfoSet;
    SP_DEVINFO_DATA DeviceInfoData;
    DWORD HardwareIdListSize, CurIdSize;
    PCTSTR p;
    DWORD Err;

    //
    // Create the container for the to-be-created device information element.
    //

    DeviceInfoSet = SetupDiCreateDeviceInfoList(&GUID_DEVCLASS_DISPLAY, hwndParent);

    if (DeviceInfoSet == INVALID_HANDLE_VALUE)
    {
        LOGMESSAGE1(_T("SetupDiCreateDeviceInfoList  failed. LastError = %ld"), GetLastError());
        return GetLastError();
    }

    //
    // Now create the element.
    //
    // ** Note that if the desire is to always have a unique devnode be created
    // (i.e., have an auto-generated name), then the caller would need to pass
    // in just the device part of the name (i.e., just the middle part of
    // "Root\<DeviceId>\<UniqueInstanceId>"). In that case, we'd need to pass
    // the DICD_GENERATE_ID flag in the next-to-last argument of the call below.
    //

    DeviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    if (!SetupDiCreateDeviceInfo(DeviceInfoSet,
                                DeviceName,
                                &GUID_DEVCLASS_DISPLAY,
                                NULL,
                                hwndParent,
                                0,
                                &DeviceInfoData))
    {

        LOGMESSAGE1(_T("SetupDiCreateDeviceInfo  failed. LastError = %ld"), GetLastError());


        Err = GetLastError();
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        return Err;
    }

    //
    // Now compute the size of the hardware ID list we're going to associate
    // with the device.
    //

    HardwareIdListSize = 1; // initialize to 1 for extra null terminating char
    for(p = HardwareIdList; *p; p += CurIdSize)
    {
        CurIdSize = lstrlen(p) + 1;
        HardwareIdListSize += CurIdSize;
    }

    //
    // (Need size in bytes, not characters, for call below.)
    //

    HardwareIdListSize *= sizeof(TCHAR);

    //
    // Store the hardware ID list to the device's HardwareID property.
    //

    if (!SetupDiSetDeviceRegistryProperty(DeviceInfoSet,
                                         &DeviceInfoData,
                                         SPDRP_HARDWAREID,
                                         (LPBYTE)HardwareIdList,
                                         HardwareIdListSize))
    {

        LOGMESSAGE1(_T("SetupDiSetDeviceRegistryProperty  failed. LastError = %ld"), GetLastError());
        Err = GetLastError();
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        return Err;
    }

    //
    // OK, now we can register our device information element. This transforms
    // the element from a mere registry presence into an actual devnode in the
    // PnP hardware tree.
    //

    if (!SetupDiCallClassInstaller(DIF_REGISTERDEVICE,
                                  DeviceInfoSet,
                                  &DeviceInfoData))
    {

        LOGMESSAGE1(_T("SetupDiCallClassInstaller  failed. LastError = %ld"), GetLastError());
        Err = GetLastError();
        SetupDiDestroyDeviceInfoList(DeviceInfoSet);
        return Err;
    }

    //
    // OK, the device information element has now been registered. From here
    // on, if we encounter any failure we'll also need to explicitly remove
    // this device from the system before bailing.
    //
    //
    // Now we're ready to install the device. (We need to initialize the
    // caller-supplied "RebootRequired" buffer to zero, because the call below
    // simply ORs in reboot-needed flags, as it performs device installations
    // that require reboot.)
    //

    if(RebootRequired)
    {
        *RebootRequired = FALSE;
    }

    if (!UpdateDriverForPlugAndPlayDevices(hwndParent,
                                          HardwareIdList, // use the first ID
                                          FullInfPath,
                                          INSTALLFLAG_FORCE,
                                          RebootRequired))
    {
        Err = GetLastError();
        LOGMESSAGE1(_T("UpdateDriverForPlugAndPlayDevices  failed. LastError = %ld"), GetLastError());

        if(Err == NO_ERROR)
        {
            //
            // The only time we should get NO_ERROR here is when
            // UpdateDriverForPlugAndPlayDevices didn't find anything to do.
            // That should never be the case here. However, since something
            // obviously went awry, go ahead and force some error, so the
            // caller knows things didn't work out.
            //

            Err = ERROR_NO_SUCH_DEVINST;
        }

        SetupDiCallClassInstaller(DIF_REMOVE,
                                  DeviceInfoSet,
                                  &DeviceInfoData
                                 );

        SetupDiDestroyDeviceInfoList(DeviceInfoSet);

        return Err;
    }

    //
    // We're done! We successfully installed the device.
    //

    SetupDiDestroyDeviceInfoList(DeviceInfoSet);

    return NO_ERROR;
}
*/

#endif//  TSOC_CONSOLE_SHADOWING
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\sources.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

!IF 0

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Makarand Patwardhan (makarp)

!ENDIF

TERMSRV_ROOT = ..\..\..




INCLUDES= \
    ..; \
    $(TERMSRV_ROOT)\winsta\server\$(O); \
    $(TERMSRV_ROOT)\common\license\inc; \
    $(TERMSRV_ROOT)\newclient\inc; \
    $(TERMSRV_ROOT)\setup\inc; \
    $(BASE_INC_PATH); \

TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLDEF=..\hydraoc.def
DLLBASE=0x2000000
DLLENTRY=_DllMainCRTStartup
USE_MSVCRT=1
USE_STL=1
USE_NATIVE_EH=1

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_SOURCEFILE = ..\stdafx.cpp
PRECOMPILED_CXX = 1

C_DEFINES=$(C_DEFINES) -DTSOC_CONSOLE_SHADOWING
!ifdef TERMSRV_PROC
C_DEFINES=$(C_DEFINES) -DTERMSRV_PROC
!endif


SOURCES=            \
  ..\hydraoc.rc     \
  ..\acl.cpp        \
  ..\cocpage.cpp    \
  ..\constants.cpp  \
  ..\hydraoc.cpp    \
  ..\pages.cpp      \
  ..\rdpdrstp.cpp   \
  ..\state.cpp      \
  ..\subcomp.cpp    \
  ..\subcore.cpp    \
  ..\subtoggle.cpp  \
  ..\util.cpp       \
  ..\privs.cpp      \
  ..\users.cpp      \
  ..\securd.cpp     \
  ..\sysprep.cpp


TARGETLIBS= \
         $(TERMSRV_LIB_PATH)\regapi.lib     \
         $(SDK_LIB_PATH)\user32.lib         \
         $(DS_LIB_PATH)\rsa32.lib   \
         $(DS_LIB_PATH)\randlib.lib \
         $(TERMSRV_ROOT)\lib\$(O)\tssec.lib \
         $(TERMSRV_ROOT)\lib\$(O)\cryptlib.lib \
         $(SDK_LIB_PATH)\kernel32.lib       \
         $(SDK_LIB_PATH)\advapi32.lib       \
         $(SDK_LIB_PATH)\comctl32.lib       \
         $(SDK_LIB_PATH)\ole32.lib          \
         $(SDK_LIB_PATH)\setupapi.lib       \
         $(SDK_LIB_PATH)\netapi32.lib       \
         $(SDK_LIB_PATH)\winspool.lib       \
         $(SDK_LIB_PATH)\uuid.lib           \
         $(DDK_LIB_PATH)\newdev.lib         \
         $(SDK_LIB_PATH)\loadperf.lib       \
         $(SDK_LIB_PATH)\winsta.lib         \
         $(SHELL_LIB_PATH)\shell32p.lib     \
         $(SDK_LIB_PATH)\Shlwapi.lib        \
         $(SDK_LIB_PATH)\msi.lib            \
         $(MAKS_LIB)                        \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by hydraoc.rc
//
#define IDS_STRING_SEC_PAGE_HEADER_TITLE 9
#define IDS_STRING_SEC_PAGE_HEADER_SUBTITLE 10
#define IDS_STRING_TSUSR_ACCOUNT_COMMENT 11
#define IDS_STRING_MESSAGE_BOX_TITLE    12
#define IDS_STRING_PROGRESS_CONFIGURING 13
#define IDS_STRING_PROGRESS_CORE_TS     14
#define IDS_STRING_PROGRESS_ENABLING    15
#define IDS_STRING_PROGRESS_DISABLING   16
#define IDS_STRING_WILL_BE_UNINSTALLED  17
#define IDS_STRING_MAY_NOT_WORK_PROPERLY 18
#define IDS_LISTVIEW_COLUMN_1_HEADER    19
#define IDS_LISTVIEW_COLUMN_2_HEADER    20
#define IDS_STRING_CSC_OFF              21
#define IDS_STRING_GENERIC_LANA_WARNING 22
#define IDS_STRING_PERM_PAGE_HEADER_TITLE 23
#define IDS_STRING_PERM_PAGE_HEADER_SUBTITLE 24
#define IDS_STRING_CLUSTERING_ISON      25
#define IDS_STRING_APPSRV_WARN_TITLE    26
#define IDS_STRING_APPSRV_WARN_SUBTITLE 27
#define IDS_STRING_TERMINAL_SERVER_UNINSTALLED 28
#define IDS_STRING_TSWEBCLIENT_VIRTUALPATH 29
#define IDS_STRING_FULL_PERM            30
#define IDS_STRING_TS4_PERM             31
#define IDD_PROPPAGE_TERMINAL_SERVER_TOGGLEON 107
#define IDD_PROPPAGE_TERMINAL_SERVER_TOGGLEOFF 108
#define IDD_PROPPAGE_TERMINAL_SERVER_SEC 110
#define IDD_PROPPAGE_TERMINAL_SERVER_APPSERVER 111
#define IDD_PROPPAGE_TERMINAL_SERVER_PERM 112
#define IDD_PROPPAGE_TERMINAL_SERVER_APPSRV_WARN 113
#define IDD_PROPPAGE_TERMINAL_SERVER_APPSRV_WARN_NOSCROLL 115
#define IDS_STRING_APPSRV_UNINSTALL_WARN_TITLE 114
#define IDS_STRING_APPSRV_UNINSTALL_WARN_SUBTITLE 115
#define IDS_STRING_TSINSTALL_ARP        117
#define IDS_STRING_TSINSTALL_CLEAN      118
#define IDS_STRING_TSREMOVE             119
#define IDS_IEHARD_EXCLUDES_TS          120
#define IDS_DIALOG_CAPTION_CONFIG_WARN  121
#define IDC_LIST_APPS_TOGGLE_ON         1001
#define IDC_LIST_APPS_TOGGLE_OFF        1002
#define IDC_RADIO_REMADM                1003
#define IDC_RADIO_APPSRV                1004
#define IDC_CONFIG_1                    1005
#define IDC_CONFIG_2                    1006
#define IDC_MANAGED_APPS_LISTVIEW       1006
#define IDC_NOTE_1                      1007
#define IDC_NOTE_2                      1008
#define IDC_WARNING_MSG                 1008
#define IDC_APPSRV_BLURB                1009
#define IDC_SECURITY_LISTVIEW           1010
#define IDC_SECURITY_DEFAULT_1          1011
#define IDC_SECURITY_DEFAULT_2          1012
#define IDC_RADIO_WIN2KPERM             1013
#define IDC_RADIO_TS4PERM               1014
#define IDC_WARNING_ICON                1015
#define IDC_FULL_SECURITY               1016
#define IDC_TS4_SECURITY                1017
#define IDI_SMALLWARN                   10000
#define IDB_WEBCLIENT                   10002
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\secupgrd.h ===
#include <tchar.h>
#include <list>
#include <Sddl.h>
#include <aclapi.h>

using namespace std;


class CDefaultSD;
class CNameAndSD;

typedef list<CNameAndSD> CNameAndSDList;

class TSState;

//from privs.cpp
DWORD GrantRemotePrivilegeToEveryone( IN BOOL addPrivilage );  // add or remove
//from securd.cpp
DWORD SetupWorker(IN const TSState &State);
//from users.cpp
DWORD CopyUsersGroupToRDUsersGroup();
DWORD RemoveAllFromRDUsersGroup();
DWORD CopyUsersGroupToRDUsersGroup();

//
DWORD 
GetDacl(
        IN PSECURITY_DESCRIPTOR pSD, 
        OUT PACL *ppDacl);

DWORD 
GetSacl(
        IN PSECURITY_DESCRIPTOR pSD, 
        OUT PACL *ppSacl);

DWORD 
EnumWinStationSecurityDescriptors(
        IN  HKEY hKeyParent,
        OUT CNameAndSDList *pNameSDList);

DWORD 
GetWinStationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName,
        IN  LPCTSTR szValueName,
        OUT PSECURITY_DESCRIPTOR *ppSecurityDescriptor );

DWORD 
SetWinStationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName,
        IN  PSECURITY_DESCRIPTOR pSecurityDescriptor );

DWORD 
AddRemoteUsersToWinstationSD(
        IN HKEY hKeyParent,
        IN CNameAndSD *pNameSD);

DWORD 
AddLocalAndNetworkServiceToWinstationSD(
        IN HKEY hKeyParent,
        IN CNameAndSD *pNameSD);
           
DWORD 
AddUserToDacl(
        IN HKEY hKeyParent,
        IN PACL pOldACL, 
        IN PSID pSid,
        IN DWORD dwAccessMask,
        IN CNameAndSD *pNameSD);

DWORD
RemoveWinstationSecurity( 
        IN  HKEY hKeyParent,
        IN  PWINSTATIONNAME pWSName);

DWORD
SetNewDefaultSecurity( 
        IN  HKEY hKey);

DWORD
SetNewConsoleSecurity( 
        IN  HKEY hKeyParent,
        IN BOOL bServer);

DWORD 
SetupWorkerNotStandAlone( 
    IN BOOL bClean,
    IN BOOL bServer,
    IN BOOL bAppServer );

DWORD 
GrantRemoteUsersAccessToWinstations(
        IN HKEY hKey,
        IN BOOL bServer,
        IN BOOL bAppServer);

BOOL
LookupSid(
        IN PSID pSid, 
        OUT LPWSTR *ppName,
        OUT SID_NAME_USE *peUse);

BOOL 
IsLocal(
        IN LPWSTR wszLocalCompName,
        IN OUT LPWSTR wszDomainandname);

DWORD
GetAbsoluteSD(
        IN PSECURITY_DESCRIPTOR pSelfRelativeSD,
        OUT PSECURITY_DESCRIPTOR *ppAbsoluteSD,
        OUT PACL *ppDacl,
        OUT PACL *ppSacl,
        OUT PSID *ppOwner,
        OUT PSID *ppPrimaryGroup);

DWORD
GetSelfRelativeSD(
  PSECURITY_DESCRIPTOR pAbsoluteSD,
  PSECURITY_DESCRIPTOR *ppSelfRelativeSD);

enum DefaultSDType {
    DefaultRDPSD = 0,
    DefaultConsoleSD
};


/*++ class CDefaultSD

Class Description:

    Represents the the default security descriptor 
    in binary (self relative) form

Revision History:

    06-June-2000    a-skuzin   Created
--*/
class CDefaultSD
{
private:
    PSECURITY_DESCRIPTOR    m_pSD;
    DWORD                   m_dwSDSize;
public:
    
    CDefaultSD() : m_pSD(NULL), m_dwSDSize(0)
    {
    }
    
    ~CDefaultSD()
    {
        if(m_pSD)
        {
            LocalFree(m_pSD);
        }
    }

    //read default SD from the registry
    DWORD Init(HKEY hKey, DefaultSDType Type)
    {
        DWORD err;

        if(Type == DefaultConsoleSD)
        {
            err = GetWinStationSecurity(hKey,NULL,_T("ConsoleSecurity"),&m_pSD);

            if(err == ERROR_FILE_NOT_FOUND)
            {
                //No "ConsoleSecurity" value means that 
                //"DefaultSecurity" value is used as a 
                //default SD for the console.
                err = GetWinStationSecurity(hKey,NULL,_T("DefaultSecurity"),&m_pSD);
            }
        }
        else
        {
            err = GetWinStationSecurity(hKey,NULL,_T("DefaultSecurity"),&m_pSD);
        }

        if(err == ERROR_SUCCESS)
        {
            m_dwSDSize = GetSecurityDescriptorLength(m_pSD);
        }

        return err;
    }

    // Must be a self-relative type of security descr, since after all, it is comming from 
    // the registry
    BOOL IsEqual(const PSECURITY_DESCRIPTOR pSD) const
    {
        return ((m_dwSDSize == GetSecurityDescriptorLength(pSD)) &&
                            !memcmp(pSD,m_pSD,m_dwSDSize));
    }

    // Must be a self-relative type of security descr, since after all, it is comming from 
    // the registry
    DWORD CopySD(PSECURITY_DESCRIPTOR *ppSD) const
    {
        *ppSD = ( PSECURITY_DESCRIPTOR )LocalAlloc( LMEM_FIXED , m_dwSDSize );

        if( *ppSD )
        {
            memcpy(*ppSD,m_pSD,m_dwSDSize);
            return ERROR_SUCCESS;
        }
        else
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    DWORD DoesDefaultSDHaveRemoteUsers(OUT LPBOOL pbHas);
};

/*++ class CNameAndSD

Class Description:

    Represents the the name of a winstation along with its 
    security descriptor

Revision History:

    30-March-2000    a-skuzin   Created
--*/
class CNameAndSD
{
public:
    PWINSTATIONNAME      m_pName;
    PSECURITY_DESCRIPTOR m_pSD;

    CNameAndSD() : 
        m_pName(NULL), m_pSD(NULL)
    {
    }
    
    CNameAndSD(LPCTSTR szName) : 
        m_pName(NULL), m_pSD(NULL)
    {
        if(szName)
        {
            m_pName = (PWINSTATIONNAME)LocalAlloc(LPTR,(_tcslen(szName)+1)*sizeof(TCHAR));
            if(m_pName)
            {
                _tcscpy(m_pName,szName);
            }
            else
            {
                throw(DWORD(ERROR_NOT_ENOUGH_MEMORY));
            }
        }
    }
    
    CNameAndSD(const CNameAndSD &ns) : 
        m_pName(NULL), m_pSD(NULL)
    {
        *this=ns;
    }
    
    ~CNameAndSD()
    {
        if(m_pSD)
        {
            LocalFree(m_pSD);
        }
        if(m_pName)
        {
            LocalFree(m_pName);
        }
    }

private:
    void operator=(const CNameAndSD &ns)
    {
        //If it is the same object - do nothing
        if(this == &ns)
        {
            return;
        }

        if(m_pSD)
        {
            LocalFree(m_pSD);
            m_pSD = NULL;
        }
        if(m_pName)
        {
            LocalFree(m_pName);
            m_pName = NULL;
        }

        if(ns.m_pName)
        {
            m_pName = (PWINSTATIONNAME)LocalAlloc(LPTR,(_tcslen(ns.m_pName)+1)*sizeof(TCHAR));
            if(m_pName)
            {
                _tcscpy(m_pName,ns.m_pName);
            }
            else
            {
                throw(DWORD(ERROR_NOT_ENOUGH_MEMORY));
            }
        }

        if(ns.m_pSD)
        {
            DWORD dwSize = GetSecurityDescriptorLength(ns.m_pSD);

            m_pSD = (PWINSTATIONNAME)LocalAlloc(LPTR,GetSecurityDescriptorLength(ns.m_pSD));
            if(m_pSD)
            {
                memcpy(m_pSD,ns.m_pSD,dwSize);
            }
            else
            {
                if(m_pName)
                {
                    LocalFree(m_pName);
                    m_pName = NULL;
                }

                throw(DWORD(ERROR_NOT_ENOUGH_MEMORY));
            }
        }

    }

public:    
    BOOL IsDefaultOrEmpty(const CDefaultSD *pds, //Default RDP SD
                          const CDefaultSD *pcs) const //Default console SD
    {
        if(!m_pSD)
        {
            return TRUE;
        }
        else
        {
            if(IsConsole())
            {
                ASSERT(pcs);
                return pcs->IsEqual(m_pSD);
            }
            else
            {
                ASSERT(pds);
                return pds->IsEqual(m_pSD);
            }
        }
    }
    
    // Inilialize the security descriptor of this object to be the one being passed into it.
    DWORD SetDefault(const CDefaultSD &ds)
    {
        if (m_pSD) 
        {
            LocalFree(m_pSD);
            m_pSD = NULL;
        }
        return ds.CopySD(&m_pSD);
    }

    BOOL IsConsole() const
    {
        if(m_pName && !(_tcsicmp(m_pName,_T("Console"))))
        {
            return TRUE;        
        }

        return FALSE;
    }
    
    void SetSD(PSECURITY_DESCRIPTOR pSD)
    {
        if (m_pSD) 
        {
            LocalFree(m_pSD);
            m_pSD = NULL;
        }
        m_pSD = pSD;
    }
};

/*++ class CNameSID

Class Description:

    Represents the the name of a user or a group 
    along with it's SID

Revision History:

    09-March-2001    skuzin   Created
--*/
class CNameSID
{
private:
    LPWSTR m_wszName;
    PSID   m_pSID;
    LPWSTR m_wszSID;
public:

    CNameSID() : 
        m_pSID(NULL), m_wszName(NULL), m_wszSID(NULL)
    {
    }
    
    CNameSID(LPCWSTR wszName, PSID   pSID) : 
        m_pSID(NULL), m_wszName(NULL), m_wszSID(NULL)
    {
        if(wszName)
        {
            m_wszName = (LPWSTR)LocalAlloc(LPTR,(wcslen(wszName)+1)*sizeof(WCHAR));
            if(m_wszName)
            {
                wcscpy(m_wszName,wszName);
            }
            else
            {
                throw(DWORD(ERROR_NOT_ENOUGH_MEMORY));
            }
        }

        if(pSID)
        {
            DWORD dwSidLength = GetLengthSid(pSID);
            m_pSID = (PSID)LocalAlloc(LPTR,dwSidLength);
            if(m_pSID)
            {
                CopySid(dwSidLength,m_pSID,pSID);
            }
            else
            {
                if(m_wszName)
                {
                    LocalFree(m_wszName);
                    m_wszName = NULL;
                }

                throw(DWORD(ERROR_NOT_ENOUGH_MEMORY));
            }
        }
    }
    
    CNameSID(const CNameSID &ns) : 
        m_pSID(NULL), m_wszName(NULL), m_wszSID(NULL)
    {
        *this=ns;
    }
    
    ~CNameSID()
    {
        if(m_pSID)
        {
            LocalFree(m_pSID);
            m_pSID = NULL;
        }
        if(m_wszName)
        {
            LocalFree(m_wszName);
            m_wszName = NULL;
        }
        if(m_wszSID)
        {
            LocalFree(m_wszSID);
            m_wszSID = NULL;
        }
    }
    
private:
    void operator=(const CNameSID &ns)
    {
        //If it is the same object - do nothing
        if(this == &ns)
        {
            return;
        }

        if(m_pSID)
        {
            LocalFree(m_pSID);
            m_pSID = NULL;
        }
        if(m_wszName)
        {
            LocalFree(m_wszName);
            m_wszName = NULL;
        }
        if(m_wszSID)
        {
            LocalFree(m_wszSID);
            m_wszSID = NULL;
        }

        if(ns.m_wszName)
        {
            m_wszName = (LPWSTR)LocalAlloc(LPTR,(wcslen(ns.m_wszName)+1)*sizeof(WCHAR));
            if(m_wszName)
            {
                wcscpy(m_wszName,ns.m_wszName);
            }
            else
            {
                throw(DWORD(ERROR_NOT_ENOUGH_MEMORY));
            }
        }

        if(ns.m_pSID)
        {
            DWORD dwSidLength = GetLengthSid(ns.m_pSID);
            m_pSID = (PSID)LocalAlloc(LPTR,dwSidLength);
            if(m_pSID)
            {
                CopySid(dwSidLength,m_pSID,ns.m_pSID);
            }
            else
            {
                if(m_wszName)
                {
                    LocalFree(m_wszName);
                    m_wszName = NULL;
                }

                throw(DWORD(ERROR_NOT_ENOUGH_MEMORY));
            }
        }

        if(ns.m_wszSID)
        {
            m_wszSID = (LPWSTR)LocalAlloc(LPTR,(wcslen(ns.m_wszSID)+1)*sizeof(WCHAR));
            if(m_wszSID)
            {
                wcscpy(m_wszSID,ns.m_wszSID);
            }
            else
            {
                if(m_wszName)
                {
                    LocalFree(m_wszName);
                    m_wszName = NULL;
                }
                if(m_pSID)
                {
                    LocalFree(m_pSID);
                    m_pSID = NULL;
                }
                throw(DWORD(ERROR_NOT_ENOUGH_MEMORY));
            }
        }

    }

public:
    LPCWSTR GetName()
    {
        return m_wszName;
    }

    const PSID GetSID()
    {
        if(!m_pSID && m_wszSID)
        {
            ConvertStringSidToSidW(m_wszSID,&m_pSID);
        }

        return m_pSID;
    }

    LPCWSTR GetTextSID()
    {
        if(!m_wszSID && m_pSID)
        {
            ConvertSidToStringSidW(m_pSID,&m_wszSID);
        }

        return m_wszSID;
    }
    
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\state.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
*
*  State.cpp
*
*  Routines to gather various state information.
*
*/

//
//	Includes
//


#define _STATE_CPP_

#include "stdafx.h"
#include "hydraoc.h"


// local functions
BOOL ReadStringFromAnsewerFile (LPTSTR *szValue);
BOOL ReadIntFromAnswerFile(LPCTSTR szSection, LPCTSTR szKey, int *piValue);

BOOL GetAllowConnectionFromAnswerFile (BOOL *pbAllowConnection);
BOOL GetPermissionsSettingsFromUnAttendedFile (EPermMode *pPermMode );
BOOL GetAppModeFromAnswerFile (BOOL *pbEnableAppCompat);


// global state object.
TSState StateObject;

//
// OC State Function Definitions
//

BOOL DoesTSAppCompatKeyExist( VOID )
{
    return TRUE;
}

BOOL ReadIntFromAnswerFile(LPCTSTR szSection, LPCTSTR szKey, int *piValue)
{
    ASSERT(szSection);
    ASSERT(szKey);
    ASSERT(piValue);
    
    HINF hInf = GetUnAttendedInfHandle();
    if (hInf)
    {
        INFCONTEXT InfContext;
        if (SetupFindFirstLine( hInf, szSection, szKey, &InfContext))
        {
            return SetupGetIntField( &InfContext, 1, piValue );
        }
    }
    
    return FALSE;
}


BOOL ReadStringFromAnsewerFile (LPCTSTR szSection, LPCTSTR szKey, LPTSTR szValue, DWORD dwBufferSize)
{
    ASSERT(szSection);
    ASSERT(szKey);
    ASSERT(szValue);
    ASSERT(dwBufferSize > 0);
    
    HINF hInf = GetUnAttendedInfHandle();
    
    if (hInf)
    {
        INFCONTEXT InfContext;
        if (SetupFindFirstLine(hInf, szSection, szKey, &InfContext))
        {
            return SetupGetStringField (&InfContext, 1, szValue, dwBufferSize, NULL);
        }
    }
    
    return FALSE;
}

BOOL GetAllowConnectionFromAnswerFile (BOOL *pbAllowConnection)
{
    ASSERT(pbAllowConnection);
    int iValue;
    if (ReadIntFromAnswerFile(TS_UNATTEND_SECTION, TS_ALLOW_CON_ENTRY, &iValue))
    {
        LOGMESSAGE2(_T("Found %s in unattended, Value = %d"), TS_ALLOW_CON_ENTRY, iValue);
        if (iValue == 1)
        {
            *pbAllowConnection = TRUE;
        }
        else if (iValue == 0)
        {
            *pbAllowConnection = FALSE;
        }
        else
        {
            LOGMESSAGE2(_T("ERROR, Invalid value for %s (%d)in answer file. Ignoring..."), TS_ALLOW_CON_ENTRY, iValue);
            return FALSE;
        }
        
        return TRUE;
    }
    else
    {
        //
        // if we did not find TS_ALLOW_CON_ENTRY in answer file, then look for TS_ALLOW_CON_ENTRY_2
        if (ReadIntFromAnswerFile(TS_UNATTEND_SECTION, TS_ALLOW_CON_ENTRY_2, &iValue))
        {
            LOGMESSAGE2(_T("Found %s in unattended, Value = %d"), TS_ALLOW_CON_ENTRY_2, iValue);
            if (iValue == 1)
            {
                *pbAllowConnection = TRUE;
            }
            else if (iValue == 0)
            {
                *pbAllowConnection = FALSE;
            }
            else
            {
                LOGMESSAGE2(_T("ERROR, Invalid value for %s (%d)in answer file. Ignoring..."), TS_ALLOW_CON_ENTRY_2, iValue);
                return FALSE;
            }
            
            return TRUE;
        }
        
    }
    
    LOGMESSAGE0(_T("answer file entry for allowconnection not found"));
    
    return FALSE;
}

BOOL GetAppModeFromAnswerFile  (BOOL *pbEnableAppCompat)
{
    ASSERT(pbEnableAppCompat);
    
    TCHAR szBuffer[256];
    if (ReadStringFromAnsewerFile(_T("Components"), APPSRV_COMPONENT_NAME, szBuffer, 256))
    {
        ASSERT(szBuffer);
        if (0 == _tcsicmp(_T("on"), szBuffer))
        {
            *pbEnableAppCompat = TRUE;
        }
        else if (0 == _tcsicmp(_T("off"), szBuffer))
        {
            *pbEnableAppCompat = FALSE;
        }
        else
        {
            LOGMESSAGE2(_T("ERROR, Invalid value for %s (%s) in answer file. Ignoring..."), APPSRV_COMPONENT_NAME, szBuffer);
            return FALSE;
        }
        
        return TRUE;
    }
    else
    {
        return FALSE;
    }
    
}

ETSLicensingMode GetLicensingModeFromAnswerFile()
{
	TCHAR szBuffer[256];

	if (ReadStringFromAnsewerFile(TS_UNATTEND_SECTION, TS_LICENSING_MODE, szBuffer, 256))
	{
		if (0 == _tcsicmp(_T("perdevice"), szBuffer))
		{
			return eLicPerDevice;
		}
		else if (0 == _tcsicmp(_T("persession"), szBuffer))
		{
			LOGMESSAGE2(_T("ERROR, Invalid value for %s (%s) in answer file. Defaulting to PerUser..."), TS_UNATTEND_SECTION, szBuffer);
			return eLicPerUser;
		}
		else if (0 == _tcsicmp(_T("peruser"), szBuffer))
		{            
			return eLicPerUser;
		}
		else if (0 == _tcsicmp(_T("pts"), szBuffer))
		{
			return eLicPTS;
		}
		else if (0 == _tcsicmp(_T("remoteadmin"), szBuffer))
		{
			return eLicRemoteAdmin;
		}
		else if (0 == _tcsicmp(_T("internetconnector"), szBuffer))
		{
			return eLicInternetConnector;
		}
		else
		{
			LOGMESSAGE2(_T("ERROR, Invalid value for %s (%s) in answer file. Ignoring..."), TS_UNATTEND_SECTION, szBuffer);
			return eLicUnset;
		}
    }
    else
    {
        return eLicUnset;
    }

}

BOOL GetPermissionsSettingsFromUnAttendedFile( EPermMode *pPermMode )
{
    ASSERT(pPermMode);
    
    int iValue;	
    if (ReadIntFromAnswerFile(TS_UNATTEND_SECTION, TS_UNATTEND_PERMKEY, &iValue))
    {
        if (iValue == PERM_TS4)
        {
            *pPermMode = PERM_TS4;
        }
        else if (iValue == PERM_WIN2K)
        {
            *pPermMode = PERM_WIN2K;
        }
        else
        {
            LOGMESSAGE2(_T("ERROR, Invalid value for %s (%d) in answer file, ignoring..."), TS_UNATTEND_PERMKEY, iValue);
            return FALSE;
        }
        
        return TRUE;
    }
    
    return FALSE;
}


DWORD SetTSVersion (LPCTSTR pszVersion)
{
    CRegistry pReg;
    DWORD dwRet;
    
    dwRet = pReg.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (dwRet == ERROR_SUCCESS)
    {
        dwRet = pReg.WriteRegString(REG_PRODUCT_VER_KEY, pszVersion);
    }
    
    return(dwRet);
}

BOOL WasTSInstalled (VOID)
{
    return (StateObject.GetInstalltype() != eFreshInstallTS);
}

PSETUP_INIT_COMPONENT GetSetupData ()
{
    ASSERT(StateObject.GetSetupData());
    return(StateObject.GetSetupData());
}


ETSInstallType TSState::GetInstalltype () const
{
    return m_eInstallType;
}

ETSMode TSState::OriginalTSMode () const
{
    return m_eOriginalTSMode;
}

ETSMode TSState::CurrentTSMode () const
{
    return m_eCurrentTSMode;
}

ETSLicensingMode TSState::NewLicMode () const
{
	return m_eNewLicMode;
}

EPermMode TSState::OriginalPermMode () const
{
    return m_eOriginalPermMode;
}

EPermMode TSState::CurrentPermMode () const
{
    return m_eCurrentPermMode;
}

BOOL TSState::IsFreshInstall () const
{
    return !IsStandAlone() && !IsUpgrade();
}

BOOL TSState::IsTSFreshInstall () const
{
    return m_eInstallType == eFreshInstallTS;
}

BOOL TSState::IsUpgradeFrom40TS () const
{
    return m_eInstallType == eUpgradeFrom40TS;
}

BOOL TSState::IsUpgradeFrom50TS () const
{
    return m_eInstallType == eUpgradeFrom50TS;
}

BOOL TSState::IsUpgradeFrom51TS () const
{
    return m_eInstallType == eUpgradeFrom51TS;
}

BOOL TSState::IsUpgradeFrom52TS () const
{
    return m_eInstallType == eUpgradeFrom52TS;
}


BOOL TSState::IsUnattended () const
{
    return (GetSetupData()->SetupData.OperationFlags & SETUPOP_BATCH) ? TRUE : FALSE;
}

BOOL TSState::IsStandAlone () const
{
    return (GetSetupData()->SetupData.OperationFlags & SETUPOP_STANDALONE) ? TRUE : FALSE;
}

BOOL TSState::IsGuiModeSetup () const
{
    return !IsStandAlone();
}

BOOL TSState::IsWorkstation () const
{
    return m_osVersion.wProductType == VER_NT_WORKSTATION;
}

BOOL TSState::IsPersonal () const
{
    return m_osVersion.wSuiteMask & VER_SUITE_PERSONAL;
}

BOOL TSState::IsProfessional() const
{
    return IsWorkstation() && !IsPersonal();
}

BOOL TSState::IsServer () const
{
    return !IsWorkstation();
}

BOOL TSState::IsAdvServerOrHigher () const
{
    return IsServer() && ((m_osVersion.wSuiteMask & VER_SUITE_ENTERPRISE) || (m_osVersion.wSuiteMask & VER_SUITE_DATACENTER));
}

BOOL TSState::IsSBS () const
{
    return IsServer () && (m_osVersion.wSuiteMask & VER_SUITE_SMALLBUSINESS);
}

BOOL TSState::IsBlade () const
{
    if (m_osVersion.wSuiteMask & VER_SUITE_BLADE)
    {
        ASSERT(IsServer());
        return TRUE;
    }

    return FALSE;
}


BOOL TSState::CanInstallAppServer () const
{
    // we dont want to allow app server on blade.
    return (IsServer () && !IsBlade() && !IsSBS());
}

BOOL TSState::WasTSInstalled () const
{
    return !IsTSFreshInstall();
}

BOOL TSState::WasTSEnabled () const
{
    return this->WasTSInstalled() && m_eOriginalTSMode != eTSDisabled;
}

BOOL TSState::IsUpgrade () const
{
    return (GetSetupData()->SetupData.OperationFlags & (SETUPOP_NTUPGRADE |
        SETUPOP_WIN95UPGRADE |
        SETUPOP_WIN31UPGRADE)) ? TRUE : FALSE;
}

BOOL TSState::WasItAppServer () const
{
    return eAppServer == OriginalTSMode();
}

BOOL TSState::WasItRemoteAdmin () const
{
    return eRemoteAdmin == OriginalTSMode();
}

BOOL TSState::IsItAppServer () const
{
    //
    // if its app server, we must have app server selected.
    //
    ASSERT((eAppServer != CurrentTSMode()) || IsAppServerSelected());
    
    //
    // if you cannot select app server,it cannot be app server.
    //
    ASSERT((eAppServer != CurrentTSMode()) || CanInstallAppServer());
    return eAppServer == CurrentTSMode();
}


//
// this returns the app server selection state.
//
BOOL TSState::IsAppServerSelected () const
{
    return(
        GetHelperRoutines().QuerySelectionState(
        GetHelperRoutines().OcManagerContext,
        APPSRV_COMPONENT_NAME,
        OCSELSTATETYPE_CURRENT
        )
        );
}
BOOL TSState::IsItRemoteAdmin () const
{
    // if its RA we must not have app server selected.
    ASSERT((eRemoteAdmin != CurrentTSMode()) || !IsAppServerSelected());
    return eRemoteAdmin == CurrentTSMode();
}

BOOL TSState::IsAppSrvModeSwitch () const
{
    ASSERT(m_bNewStateValid); // you can ask if this is mode switch only in after completeinstall
    return WasItAppServer() != IsItAppServer();

    // this functions return true if
    // 1) its mode switch ( either in standlaone or upgrade )
    // 2) if its fresh install of app server

}

BOOL TSState::IsStandAloneModeSwitch () const
{
    ASSERT(m_bNewStateValid); // you can ask if this is mode switch only in after completeinstall
    if (!IsServer())
        return FALSE;

    if (!IsStandAlone())
        return FALSE;

    return WasItAppServer() != IsItAppServer();
}

BOOL TSState::IsTSModeChanging () const
{
    return CurrentTSMode() != OriginalTSMode();
}

BOOL TSState::HasChanged () const
{
    return ((CurrentTSMode() != OriginalTSMode()) ||
        (CurrentPermMode() != OriginalPermMode()));
}

BOOL TSState::IsTSEnableSelected  () const
{
    //
    // For whistler we dont disable TS ever. OS is always TS Enabled.
    // But for some reason if we want to privide TS Off facility. This function
    // Should return accordingly.
    //
    return TRUE;
}

void TSState::SetCurrentConnAllowed (BOOL bAllowed)
{
    // we must not allow connections for personal.
    ASSERT(!bAllowed || !IsPersonal());
    m_bCurrentConnAllowed = bAllowed;
}

BOOL TSState::GetCurrentConnAllowed () const
{
    return m_bCurrentConnAllowed;
}

BOOL TSState::GetOrigConnAllowed () const
{
    return m_bOrigConnAllowed;
}


TSState::TSState ()
{
    m_gpInitComponentData = NULL;
    m_bNewStateValid = FALSE;
}

TSState::~TSState ()
{
    if (m_gpInitComponentData)
        LocalFree (m_gpInitComponentData);
    
}

const PSETUP_INIT_COMPONENT TSState::GetSetupData () const
{
    ASSERT(m_gpInitComponentData);
    return m_gpInitComponentData;
}

BOOL TSState::SetSetupData (PSETUP_INIT_COMPONENT pSetupData)
{
    m_gpInitComponentData = (PSETUP_INIT_COMPONENT)LocalAlloc(LPTR, sizeof(SETUP_INIT_COMPONENT));
    
    if (m_gpInitComponentData == NULL)
    {
        return(FALSE);
    }
    
    CopyMemory(m_gpInitComponentData, pSetupData, sizeof(SETUP_INIT_COMPONENT));
    
    return(TRUE);
}

BOOL TSState::GetNTType ()
{
    
    ZeroMemory(&m_osVersion, sizeof(OSVERSIONINFOEX));
    m_osVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if (GetVersionEx((LPOSVERSIONINFO )&m_osVersion))
    {
        return TRUE;
        
    }
    else
    {
        LOGMESSAGE1(_T("GetVersionEx failed, Error = %d"), GetLastError());
        return FALSE;
    }
}


BOOL TSState::Initialize (PSETUP_INIT_COMPONENT pSetupData)
{

    ASSERT(pSetupData);

    if ( !SetSetupData(pSetupData))
    {
        return FALSE;
    }

    //
    // This is a necessary step.
    //

    if (GetComponentInfHandle())
        SetupOpenAppendInfFile(NULL, GetComponentInfHandle(), NULL);

    //
    // now populate our state variables.
    // first check if its a professional or server installation.
    //

    VERIFY( GetNTType() );

    m_eInstallType = ReadInstallType();

    // Set Original TS Mode.
    switch (m_eInstallType)
    {
    case eFreshInstallTS:
        m_eOriginalTSMode = eTSDisabled;
        break;
        
    case eUpgradeFrom40TS:
        m_eOriginalTSMode = eAppServer;
        break;
        
    case eUpgradeFrom50TS:
    case eUpgradeFrom51TS:
    case eUpgradeFrom52TS:
    case eStandAloneSetup:
        m_eOriginalTSMode = ReadTSMode ();
        break;
        
    default:
        ASSERT(FALSE);
        m_eOriginalTSMode = eTSDisabled;
        
    }
    
    // Set Original Permission Modes.
    if (m_eOriginalTSMode == eAppServer)
    {
        m_eOriginalPermMode = ReadPermMode();
    }
    else
    {
        m_eOriginalPermMode = PERM_WIN2K;
    }
    
    //
    // Set Original Connection Allowed Status.
    //
    if (m_eInstallType == eFreshInstallTS)
    {
        m_bOrigConnAllowed = FALSE;
    }
    else
    {
        m_bOrigConnAllowed = AreConnectionsAllowed();
    }
    
    
    //
    // now lets pick default values for the new installation.
    //
    if (m_eInstallType == eFreshInstallTS)
    {
        if (IsWorkstation())
        {
            SetCurrentTSMode (ePersonalTS);
        }
        else
        {
            SetCurrentTSMode (eRemoteAdmin);
        }
        
        SetCurrentConnAllowed (FALSE);
    }
    else
    {
        if (m_eOriginalTSMode == eTSDisabled)
        {
            //
            // for whistler we have TS always on.
            // so if ts was disabled perviously, set it to on after upgrade.
            // just disallow connections for such upgrades.
            //
            SetCurrentPermMode (PERM_WIN2K);
            SetCurrentTSMode (IsWorkstation() ? ePersonalTS : eRemoteAdmin);
            SetCurrentConnAllowed (FALSE);
        }
        else if (m_eOriginalTSMode == eAppServer && !CanInstallAppServer())
        {
            //
            // this is upgrade from an app server machine to whistler sku that does not support app server.
            // we must downgrade this since app server is NOT supported on this sku
            //
            ASSERT(FALSE);  // this upgrade is not a valid case.

            SetCurrentPermMode (PERM_WIN2K);
            SetCurrentTSMode (eRemoteAdmin);
            SetCurrentConnAllowed (m_bOrigConnAllowed);
            LOGMESSAGE0(_T("WARNING:Your Terminal Server is uninstalled since its not supported in Server product. Terminal Server is supported only on Advanced Server or Datacenter products"));
            // LogErrorToSetupLog(OcErrLevWarning, IDS_STRING_TERMINAL_SERVER_UNINSTALLED);
        }
        else
        {
            //
            // for all other upgrade cases, retain the original values.
            //
            SetCurrentTSMode (m_eOriginalTSMode);
            SetCurrentPermMode (m_eOriginalPermMode);
            if (!IsPersonal())
            {
                SetCurrentConnAllowed (m_bOrigConnAllowed);
            }
            else
            {
                SetCurrentConnAllowed (FALSE);
            }

            // TurnOffConnectionsForWhistlerServerBetaUpgrades();
        }


    }
    
    //
    // Lets see if we are given the unattended file, to overwrite our new state
    //
    if (StateObject.IsUnattended())
    {
        ASSERT(eTSDisabled != CurrentTSMode());
        BOOL bAppServerMode;
        if (GetAppModeFromAnswerFile(&bAppServerMode))
        {
            LOGMESSAGE1(_T("Mode Setting is %s in answer file"), bAppServerMode ? _T("AppServer") : _T("RemoteAdmin"));
            if (!CanInstallAppServer())
            {
                // we support TS mode selection only on the adv server or data center.
                LOGMESSAGE0(_T("WARNING:Your unattended terminal server mode setting, can not be respected on this installation."));
                
                if (IsWorkstation())
                {
                    SetCurrentTSMode (ePersonalTS);
                }
                else
                {
                    ASSERT(IsServer());
                    SetCurrentTSMode (eRemoteAdmin);
                }
            }
            else
            {
                if (bAppServerMode)
                {
                    SetCurrentTSMode (eAppServer);
                    SetCurrentConnAllowed(TRUE);
                }
                else
                {
                    SetCurrentTSMode (eRemoteAdmin);
                    SetCurrentConnAllowed(FALSE);
                }
            }
        }
        
        EPermMode ePermMode;
        if (GetPermissionsSettingsFromUnAttendedFile(&ePermMode))
        {
            if (ePermMode == PERM_TS4)
            {
                if (m_eCurrentTSMode != eAppServer)
                {
                    LOGMESSAGE0(_T("WARNING:Your unattended setting:TS4 perm mode is inconsistent, can't be respected on professional or remote admin mode."));
                }
                else
                {
                    SetCurrentPermMode (PERM_TS4);
                }
            }
            else
            {
                SetCurrentPermMode (PERM_WIN2K);
            }
        }
        
        // Read Connection Allowed Settings.
        BOOL bAllowConnections;
        if (!IsPersonal() && GetAllowConnectionFromAnswerFile (&bAllowConnections))
        {
            SetCurrentConnAllowed (bAllowConnections);
        }
        
        // Read licensing mode
        ETSLicensingMode eLicMode;

        if (eLicUnset != (eLicMode = GetLicensingModeFromAnswerFile()))
        {
            if (!CanInstallAppServer() || ((eLicMode != eLicPerDevice) && (eLicMode != eLicPerUser)))
            {
                LOGMESSAGE0(_T("WARNING:Your unattended setting:licensing mode is inconsistent, can't be respected."));

                eLicMode = eLicUnset;
            }
            else
            {
                LOGMESSAGE1(_T("Licensing Mode Setting is %s in answer file"), (eLicMode == eLicPerDevice) ? _T("PerDevice") : _T("PerUser"));                
            }
        }
        SetNewLicMode(eLicMode);

    } // StateObject.IsUnattended()
    
    LogState();
    ASSERT( this->Assert () );
    return TRUE;
}

void TSState::UpdateState ()
{
    m_bNewStateValid = TRUE;
    if (IsAppServerSelected())
    {
        SetCurrentTSMode(eAppServer);
    }
    else
    {
        if (IsWorkstation())
        {
            SetCurrentTSMode(ePersonalTS);
        }
        else
        {
            SetCurrentTSMode(eRemoteAdmin);
        }
    }

    ASSERT(StateObject.Assert());
    UpdateConnectionAllowed();
}

//
// this really belongs in subtoggle, however we are doing it here, because the 
// WriteDenyConnectionRegistry happens in subcore. we must set the correct connection 
// value before we write that registry.
//
void TSState::UpdateConnectionAllowed ()
{
    //
    // whenever TS mode is switched,
    // we enable/disable connections allowed.
    // however for unattended setup dont need to do this,
    // as unattended seutp could have explicitely disabled
    // connections.
    //
    if (!IsUnattended())
    {
        if (IsStandAloneModeSwitch())
        {
            if (IsAppServerSelected())
            {
                SetCurrentConnAllowed(TRUE);
            }
            else
            {
                SetCurrentConnAllowed(FALSE);
            }
        }   
    }
}

void TSState::SetCurrentTSMode (ETSMode eNewMode)
{
    //
    // we no more have ts disabled mode.
    //
    ASSERT(eNewMode != eTSDisabled);
    
    // 
    // On server machine you cannot have Personal TS.
    //
    ASSERT(IsServer() || eNewMode == ePersonalTS);
    
    // you can have app server only on advance server or higher.
    ASSERT(CanInstallAppServer() || eNewMode != eAppServer);
    
    m_eCurrentTSMode = eNewMode;
    
    if (eNewMode != eAppServer)
    {
        SetCurrentPermMode (PERM_WIN2K);
    }
}

void TSState::SetNewLicMode (ETSLicensingMode eNewMode)
{
	//
	// we no more have IC mode.
	//
	ASSERT(eNewMode != eLicInternetConnector);

	m_eNewLicMode = eNewMode;
}

void TSState::SetCurrentPermMode (EPermMode eNewMode)
{
    //
    // if you want to set perm mode to PERM_TS4, you must first set AppServer Mode.
    //
    // ASSERT(eNewMode != PERM_TS4 || CurrentTSMode() == eAppServer);
    
    m_eCurrentPermMode = eNewMode;
}

ETSInstallType TSState::ReadInstallType () const
{
    DWORD dwError;
    CRegistry oRegTermsrv;
    if ( IsUpgrade() )
    {
        dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
        if (ERROR_SUCCESS == dwError)
        {
            //
            // TS was installed originally
            //
            DWORD cbVersion = 0;
            LPTSTR szVersion = NULL;
            
            //
            //	Determine if this is a TS 4.0 upgrade.
            //
            dwError = oRegTermsrv.ReadRegString(REG_PRODUCT_VER_KEY, &szVersion, &cbVersion);
            if (ERROR_SUCCESS == dwError)
            {
                if ((_tcsicmp(szVersion, _T("5.2")) == 0))
                {
                    return eUpgradeFrom52TS;
                }
                else if ((_tcsicmp(szVersion, _T("5.1")) == 0))
                {
                    return eUpgradeFrom51TS;
                }
                else if ((_tcsicmp(szVersion, _T("5.0")) == 0))
                {
                    return eUpgradeFrom50TS;
                }
                else if ((_tcsicmp(szVersion, _T("4.0")) == 0) || (_tcsicmp(szVersion, _T("2.10")) == 0))
                {
                    return eUpgradeFrom40TS;
                }
                else
                {
                    LOGMESSAGE1(_T("Error, dont recognize previous TS version (%s)"), szVersion);
                    return eFreshInstallTS;
                }
            }
            else
            {
                LOGMESSAGE1(_T("Error, Failed to retrive previous TS version, Errorcode = %d"), dwError);
                return eFreshInstallTS;
            }
        }
        else
        {
            LOGMESSAGE1(_T("Could not Open TermSrv Registry, Must be Fresh TS install. Errorcode = %d"), dwError);
            return eFreshInstallTS;
        }
    }
    else
    {
        
        if (IsStandAlone())
        {
            return eStandAloneSetup;
        }
        else
        {
            //
            // this is fresh install.
            //
            return eFreshInstallTS;
        }
        
    }
}

ETSMode TSState::ReadTSMode () const
{
    DWORD dwError;
    CRegistry oRegTermsrv;
    
    dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwValue = 0;
        dwError = oRegTermsrv.ReadRegDWord(TS_ENABLED_VALUE, &dwValue);
        if (ERROR_SUCCESS == dwError)
        {
            if (dwValue == 1)
            {
                //
                // ts was enabled, now find out the mode.
                //
                if (oRegTermsrv.ReadRegDWord(TS_APPCMP_VALUE, &dwValue) == ERROR_SUCCESS)
                {
                    if (dwValue == 1)
                    {
                        ASSERT(IsServer());
                        return eAppServer;
                    }
                    else
                    {
                        if (IsWorkstation())
                        {
                            return ePersonalTS;
                        }
                        else
                        {
                            return eRemoteAdmin;
                        }
                    }
                }
                else
                {
                    LOGMESSAGE0(_T("Error, TSMode registry is missing...Is it Beta version of W2k ?"));
                    return eAppServer;
                }
            }
            else
            {
                return eTSDisabled;
            }
        }
        else
        {
            LOGMESSAGE0(_T("Error, Failed to retrive previous TS enabled state, Is it TS40 Box??."));
            return eTSDisabled;
        }
    }
    else
    {
        LOGMESSAGE1(_T("Error Opening TermSrv Registry, ErrorCode = %d"), dwError);
        return eTSDisabled;
        
    }
}

BOOL TSState::AreConnectionsAllowed () const
{
    DWORD dwError;
    CRegistry oRegTermsrv;
    
    dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwDenyConnect;
        dwError = oRegTermsrv.ReadRegDWord(DENY_CONN_VALUE, &dwDenyConnect);
        if (ERROR_SUCCESS == dwError)
        {
            return !dwDenyConnect;
        }
    }
    
    //
    // could not read registry, this means connections were allowed.
    //
    return TRUE;
}

EPermMode TSState::ReadPermMode () const
{
    DWORD dwError;
    CRegistry oRegTermsrv;
    
    dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwPerm;
        dwError = oRegTermsrv.ReadRegDWord(_T("TSUserEnabled"), &dwPerm);
        if (ERROR_SUCCESS == dwError)
        {
            switch(dwPerm)
            {
            case PERM_TS4:
            case PERM_WIN2K:
                return	(EPermMode)dwPerm;
                break;
                
            default:
                // The TSUserEnabled key exists with unrecognized value. 
                // So it's not an upgrade from TS40. Hence return PERM_WIN2K.
                LOGMESSAGE1(_T("ERROR:Unrecognized, Permission value %d"), dwPerm);
                return	PERM_WIN2K;
                break;
            }
        }
        else
        {
            // The Read of TSUserEnabled failed. This key did not exist for TS40. 
            // So this could very well be upgrade from TS40. 
            // Check what upgrade it is and return PERM value accordingly.
            LOGMESSAGE1(_T("Warning Failed to read Permissions registry, Is it 40 TS / Beta 2000 upgrade > "), dwError);
            if (StateObject.IsUpgradeFrom40TS()) 
                return PERM_TS4;
            else
                return PERM_WIN2K;
        }
    }
    else
    {
        LOGMESSAGE1(_T("Error Opening TermSrv Registry, Errorcode = %d"), dwError);
        return PERM_WIN2K;
        
    }
}

BOOL TSState::LogState () const
{
    static BOOL sbLoggedOnce = FALSE;
    
    if (!sbLoggedOnce)
    {
        LOGMESSAGE0(_T("Setup Parameters ****************************"));


        ETSInstallType eInstall = StateObject.GetInstalltype();
        switch (eInstall)
        {
            case eFreshInstallTS:
                LOGMESSAGE1(_T("TS InstallType %s"),    _T("eFreshInstallTS"));
                break;
            case eUpgradeFrom40TS:
                LOGMESSAGE1(_T("TS InstallType %s"),    _T("eUpgradeFrom40TS (TS4 upgrade)"));
                break;
            case eUpgradeFrom50TS:
                LOGMESSAGE1(_T("TS InstallType %s"),    _T("eUpgradeFrom50TS (win2k upgrade)"));
                break;
            case eUpgradeFrom51TS:
                LOGMESSAGE1(_T("TS InstallType %s"),    _T("eUpgradeFrom51TS (xp upgrade)"));
                break;
            case eUpgradeFrom52TS:
                LOGMESSAGE1(_T("TS InstallType %s"),    _T("eUpgradeFrom52TS (Windows Server 2003 upgrade)"));
                break;
            case eStandAloneSetup:
                LOGMESSAGE1(_T("TS InstallType %s"),    _T("eStandAloneSetup (standalone)"));
                break;
            default:
                LOGMESSAGE1(_T("TS InstallType %s"),    _T("ERROR:UNKNOWN"));
                ASSERT(FALSE);
        }
        LOGMESSAGE0(_T("-------------------------------------------------------------------"));

        LOGMESSAGE1(_T("We are running on    = %s"),   StateObject.IsWorkstation()     ? _T("Wks")  : _T("Srv"));
        LOGMESSAGE1(_T("Is this adv server   = %s"),   StateObject.IsAdvServerOrHigher()? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("Is this Home Edition = %s"),   StateObject.IsPersonal()? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("Is this SBS server   = %s"),   StateObject.IsSBS()             ? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("Is this Blade        = %s"),   StateObject.IsBlade()           ? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsStandAloneSetup    = %s"),   StateObject.IsStandAlone()      ? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsFreshInstall       = %s"),   StateObject.IsFreshInstall()    ? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("IsUnattended         = %s"),   StateObject.IsUnattended()      ? _T("Yes")  : _T("No"));
        
        LOGMESSAGE0(_T("Original State ******************************"));
        LOGMESSAGE1(_T("WasTSInstalled       = %s"),   StateObject.WasTSInstalled()    ? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("WasTSEnabled         = %s"),   StateObject.WasTSEnabled()      ? _T("Yes")  : _T("No"));
        LOGMESSAGE1(_T("OriginalPermMode     = %s"),   StateObject.OriginalPermMode() == PERM_TS4 ? _T("TS4") : _T("WIN2K"));
        
        
        
        ETSMode eOriginalTSMode = StateObject.OriginalTSMode();
        switch (eOriginalTSMode)
        {
        case eRemoteAdmin:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("Remote Admin"));
            break;
        case eAppServer:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("App Server"));
            break;
        case eTSDisabled:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("TS Disabled"));
            break;
        case ePersonalTS:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("Personal TS"));
            break;
        default:
            LOGMESSAGE1(_T("Original TS Mode = %s"),  _T("Unknown"));
        }
        
        sbLoggedOnce = TRUE;
    }
    
    
    LOGMESSAGE0(_T("Current State   ******************************"));
    
    ETSMode eCurrentMode = StateObject.CurrentTSMode();
    switch (eCurrentMode)
    {
    case eRemoteAdmin:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("Remote Admin"));
        break;
    case eAppServer:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("App Server"));
        break;
    case eTSDisabled:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("TS Disabled"));
        break;
    case ePersonalTS:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("Personal TS"));
        break;
    default:
        LOGMESSAGE1(_T("New TS Mode = %s"),  _T("Unknown"));
    }
    
    EPermMode ePermMode = StateObject.CurrentPermMode();
    switch (ePermMode)
    {
    case PERM_WIN2K:
        LOGMESSAGE1(_T("New Permissions Mode = %s"),  _T("PERM_WIN2K"));
        break;
    case PERM_TS4:
        LOGMESSAGE1(_T("New Permissions Mode = %s"),  _T("PERM_TS4"));
        break;
    default:
        LOGMESSAGE1(_T("New Permissions Mode = %s"),  _T("Unknown"));
    }
    
    LOGMESSAGE1(_T("New Connections Allowed = %s"), StateObject.GetCurrentConnAllowed() ? _T("True") : _T("False"));
    
    return TRUE;
    
}

BOOL TSState::IsX86 () const
{
    SYSTEM_INFO sysInfo;
    ZeroMemory(&sysInfo, sizeof(sysInfo));
    GetSystemInfo(&sysInfo);
    
    return sysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL;
}


BOOL TSState::IsAMD64 () const
{
    SYSTEM_INFO sysInfo;
    ZeroMemory(&sysInfo, sizeof(sysInfo));
    GetSystemInfo(&sysInfo);
    
    return sysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64;
}


BOOL TSState::Assert () const
{
    
    // its assert !!
    ASSERT(IsCheckedBuild());
    
    // on professional there is no remote admin
    ASSERT(IsServer() || !WasItRemoteAdmin());
    
    // on professional there is no app server.
    ASSERT(IsServer() || !WasItAppServer());
    
    // if original perm was TS4 compatible, it must have been app server.
    ASSERT((OriginalPermMode() != PERM_TS4) || WasItAppServer());
    
    // make sure standalone is consistant.
    ASSERT(IsStandAlone() ==  (GetInstalltype() == eStandAloneSetup));
    
    if (m_bNewStateValid)
    {
        // we no more have disable ts state.
        ASSERT(CurrentTSMode() != eTSDisabled);
        
        // AppServer mode is available only for adv server, datacenter
        ASSERT(CanInstallAppServer() || !IsItAppServer());
        
        // we cannot be in RA mode for Professional.
        ASSERT(IsServer() || !IsItRemoteAdmin());
        
        // if permissions mode is TS4 compatible, it must be appserver 
        ASSERT((CurrentPermMode() != PERM_TS4) || IsItAppServer());
        
        // we should never allwe connections on Personal
        ASSERT(!IsPersonal() || !GetCurrentConnAllowed ());
        
    }
    
    return TRUE;
}

BOOL TSState::CanShowStartupPopup() const
{
    if (!StateObject.IsUnattended())
        return TRUE;

    int iValue = 0;
    if (ReadIntFromAnswerFile(TS_UNATTEND_SECTION, TS_DENY_POPUP, &iValue))
    {
        if (iValue != 0)
            return FALSE;
    }

    return TRUE;
}

BOOL TSState::IsCheckedBuild () const
{
#ifdef DBG
    return TRUE;
#else
    return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\state.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
*
*  State.h
*
*  Routines to gather various state information.
*
*/

#ifndef __TSOC_STATE_H__
#define __TSOC_STATE_H__


//
//  Type Definitions
//

typedef enum {
    PERM_WIN2K = 0,
        PERM_TS4 = 1
} EPermMode;

//
//  OC State Function Prototypes
//


DWORD SetTSVersion (LPCTSTR pszVersion);
PSETUP_INIT_COMPONENT GetSetupData(VOID);


enum ETSInstallType
{
        eFreshInstallTS,     // it could be an upgrade, but from non TS machine.
        eUpgradeFrom40TS,    // upgrade from TS4.
        eUpgradeFrom50TS,    // upgrade from Win2k
        eUpgradeFrom51TS,    // upgrade from Xp
        eUpgradeFrom52TS,    // upgrade from Windows Server 2003 builds
        eStandAloneSetup     // stand alone setup. (add remove programs) 
};

enum ETSMode
{
        eTSDisabled,
        eRemoteAdmin,
        eAppServer,
        ePersonalTS
};

// This must be in the same order as IDs in lscore
enum ETSLicensingMode
{
    eLicPTS,
    eLicRemoteAdmin,
    eLicPerDevice,
    eLicInternetConnector,  // not supported in Whistler
    eLicPerUser,
    eLicUnset
};

class TSState
{
    
public:
    
    
    TSState             ();
    virtual            ~TSState             ();
    
    BOOL                Initialize          (PSETUP_INIT_COMPONENT pSetupData);
    
    const PSETUP_INIT_COMPONENT GetSetupData() const;
    
    
    ETSInstallType      GetInstalltype      () const;
    
    ETSMode             OriginalTSMode      () const;
    ETSMode             CurrentTSMode       () const;
    
    EPermMode           OriginalPermMode    () const;
    EPermMode           CurrentPermMode     () const;

    ETSLicensingMode    NewLicMode          () const;

    BOOL                IsUpgrade           () const;
    BOOL                IsFreshInstall      () const;
    BOOL                IsTSFreshInstall    () const;
    BOOL                IsUpgradeFrom40TS   () const;
    BOOL                IsUpgradeFrom50TS   () const;
    BOOL                IsUpgradeFrom51TS   () const;
    BOOL                IsUpgradeFrom52TS   () const;
    BOOL                IsUnattended        () const;
    BOOL                IsGuiModeSetup      () const;
    BOOL                IsStandAlone        () const;
    BOOL                IsWorkstation       () const;
    BOOL                IsServer            () const;
    BOOL                IsSBS               () const;
    BOOL                IsBlade             () const;
    BOOL                CanInstallAppServer () const;
    BOOL                IsAdvServerOrHigher () const;
    BOOL                IsPersonal          () const;
    BOOL                IsProfessional      () const;
    BOOL                IsX86               () const;
    BOOL                IsAMD64             () const;
    BOOL                IsCheckedBuild      () const;
    
    BOOL                WasTSInstalled      () const;
    BOOL                WasTSEnabled        () const;
    BOOL                WasItAppServer      () const;
    BOOL                WasItRemoteAdmin    () const;
    
    BOOL                IsAppSrvModeSwitch  () const;
    BOOL                IsStandAloneModeSwitch () const;
    BOOL                IsTSModeChanging    () const;
    BOOL                IsItAppServer       () const;
    BOOL                IsAppServerSelected () const;
    BOOL                IsItRemoteAdmin     () const;
    BOOL                HasChanged          () const;
    BOOL                IsTSEnableSelected  () const;
    
    
    void                SetCurrentTSMode    (ETSMode eNewMode);
    void                SetCurrentPermMode  (EPermMode eNewMode);
    void                SetNewLicMode       (ETSLicensingMode eNewMode);
    void                UpdateState         ();
    
    BOOL                Assert () const;
    BOOL                LogState () const;
    
    BOOL                GetCurrentConnAllowed () const;
    BOOL                GetOrigConnAllowed   () const;

    void                UpdateConnectionAllowed ();
    BOOL                CanShowStartupPopup () const;
    
private:
    
    ETSInstallType      m_eInstallType;
    
    ETSMode             m_eOriginalTSMode;
    ETSMode             m_eCurrentTSMode;
    
    EPermMode           m_eOriginalPermMode;
    EPermMode           m_eCurrentPermMode;
    
    BOOL                m_bCurrentConnAllowed;
    BOOL                m_bOrigConnAllowed;
    
    BOOL                m_bNewStateValid;
    
    ETSLicensingMode    m_eNewLicMode;

    PSETUP_INIT_COMPONENT m_gpInitComponentData;
    OSVERSIONINFOEX     m_osVersion;
    
    
    BOOL                GetNTType           ();
    BOOL                SetSetupData        (PSETUP_INIT_COMPONENT pSetupData);
    
    
    ETSInstallType      ReadInstallType     () const;
    ETSMode             ReadTSMode          () const;
    EPermMode           ReadPermMode        () const;
    BOOL                AreConnectionsAllowed () const;
    void                SetCurrentConnAllowed (BOOL bAllowed);
};





extern TSState  StateObject;


#endif // __TSOC_STATE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\stdafx.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\subcore.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

//
// SubCore.h
// subcomponent enable terminal services.
//

#ifndef _SubCore_h_
#define _SubCore_h_

#include "subcomp.h" // defines OCMSubComp


class SubCompCoreTS : public OCMSubComp
{
    public:

    DWORD   GetStepCount                () const;
    LPCTSTR GetSubCompID                () const;
    DWORD   OnQueryState                (UINT uiWhichState);
    LPCTSTR GetSectionToBeProcessed     (ESections eSection) const;
    BOOL    BeforeCompleteInstall       ();
    BOOL    AfterCompleteInstall        ();
    DWORD   OnQuerySelStateChange       (BOOL bNewState, BOOL bDirectSelection) const;

    DWORD LoadOrUnloadPerf           ();
    BOOL SetupConsoleShadow          ();
    void AddRDPNP(LPTSTR szOldValue, LPTSTR szNewValue);
    void RemoveRDPNP(LPTSTR szOldValue, LPTSTR szNewValue);
    BOOL AddRemoveRDPNP              ();
    BOOL InstallUninstallRdpDr       ();
    BOOL HandleHotkey                ();
    BOOL UpdateMMDefaults            ();
    BOOL AddTermSrvToNetSVCS         ();
    BOOL AddRemoveTSProductSuite     ();
    BOOL UpgradeRdpWinstations       ();
    BOOL DoHydraRegistrySecurityChanges ();
    BOOL DisableInternetConnector    ();
    BOOL ResetTermServGracePeriod    ();
    BOOL RemoveOldKeys               ();
    BOOL RemoveTSServicePackEntry    ();
    BOOL RemoveMetaframeFromUserinit ();
    BOOL UninstallTSClient           ();
    BOOL WriteDenyConnectionRegistry ();
    bool DisableCSC                  ();
    bool InstallTermdd               ();
    void IsCSCEnabled                ();


    BOOL BackUpRestoreConnections    (BOOL bBackup);
    BOOL  IsConsoleShadowInstalled   ();
    void SetConsoleShadowInstalled   (BOOL bInstalled);
    BOOL IsTermSrvInNetSVCS                  ();
    BOOL DisableWinStation                   (CRegistry *pRegWinstation);
    BOOL DoesLanaTableExist                  ();
    void VerifyLanAdapters                   (CRegistry *pRegWinstation, LPTSTR pszWinstation);
    BOOL UpdateRDPWinstation                 (CRegistry *pRegWinstation, LPTSTR lpWinStationName);
    BOOL IsRdpWinStation                     (CRegistry *pRegWinstation);
    BOOL IsConsoleWinStation                 (CRegistry *pRegWinstation);
    BOOL IsMetaFrameWinstation               (CRegistry *pRegWinstation);
private:
    DWORD UnloadPerf();
    BOOL MoveWinStationPassword(CRegistry *pRegWinstation, LPTSTR pszWinStationName);
};
#endif // _SubCore_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\subcore.cpp ===
//
//Copyright (c) 1998 - 1999 Microsoft Corporation
//

//
// SubCore.cpp
// subcomponent Core terminal server implementation.
//

#include "stdafx.h"
#include "SubCore.h"
#include "acl.h"
#include "rdpdrstp.h"

BOOL UpdateAudioCodecs (BOOL bIsProfessional);



LPCTSTR SubCompCoreTS::GetSubCompID () const
{
    return BASE_COMPONENT_NAME;
}

DWORD SubCompCoreTS::GetStepCount () const
{
    return 18;
}

DWORD SubCompCoreTS::OnQueryState ( UINT /* uiWhichState */)
{
    AssertFalse(); // since this is our internal component.
    
    return SubcompUseOcManagerDefault;
}

DWORD SubCompCoreTS::OnQuerySelStateChange (BOOL /*bNewState*/, BOOL /*bDirectSelection*/) const
{
    // we are not a real sub comp.
    ASSERT(FALSE);
    return TRUE;
}


LPCTSTR SubCompCoreTS::GetSectionToBeProcessed (ESections /* eSection */) const
{
    LPCTSTR sectionname = NULL;
    if (StateObject.IsGuiModeSetup())   // core installation is only for gui-mode.
    {
        
        ETSInstallType eInstallType =  StateObject.GetInstalltype();
        
        switch (eInstallType)
        {
        case eFreshInstallTS:
            if (StateObject.IsX86())
            {
                sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_X86 : FRESH_INSTALL_SERVER_X86;
            }
            else
            {
                if (StateObject.IsAMD64())
                {
                    sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_AMD64 : FRESH_INSTALL_SERVER_AMD64;
                }
                else
                {
                    sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_IA64 : FRESH_INSTALL_SERVER_IA64;
                }
            }
            
            break;
        case eUpgradeFrom40TS:
            ASSERT(StateObject.IsServer());
            if (StateObject.IsX86())
            {
                sectionname = UPGRADE_FROM_40_SERVER_X86;
            }
            else
            {
                ASSERT(FALSE); // we did not have ts4 on ia64
                sectionname = UPGRADE_FROM_40_SERVER_IA64;
            }
            break;
            
        case eUpgradeFrom50TS:
            //
            // we dont really have a upgrade from 50 case for Professional, But to support old 51 (pre 2220) builds)
            // of pro which think that they are 50, we need to check for professional here.
            //
            if (StateObject.IsX86())
            {
                sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_51_PRO_X86 : UPGRADE_FROM_50_SERVER_X86;
            }
            else
            {
                sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_51_PRO_IA64 : UPGRADE_FROM_50_SERVER_IA64;
            }
            break;
            
        case eUpgradeFrom51TS:
            if (StateObject.IsX86())
            {
                sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_51_PRO_X86 : UPGRADE_FROM_51_SERVER_X86;
            }
            else
            {
                sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_51_PRO_IA64 : UPGRADE_FROM_51_SERVER_IA64;
            }
            break;
            
        case eUpgradeFrom52TS:
            if (StateObject.IsX86())
            {
                sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_52_PRO_X86 : UPGRADE_FROM_52_SERVER_X86;
            }
            else
            {
                if (StateObject.IsAMD64()) {
                    sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_52_PRO_AMD64 : UPGRADE_FROM_52_SERVER_AMD64;

                }
                else
                {
                    sectionname = StateObject.IsWorkstation() ? UPGRADE_FROM_52_PRO_IA64 : UPGRADE_FROM_52_SERVER_IA64;
                }
            }
            break;

        case eStandAloneSetup:
            ASSERT(FALSE);
            sectionname = NULL;
            break;
            
        default:
            ASSERT(FALSE);
            if (StateObject.IsX86())
            {
                sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_X86 : FRESH_INSTALL_SERVER_X86;
            }
            else
            {
                if (StateObject.IsAMD64())
                {
                    sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_AMD64 : FRESH_INSTALL_SERVER_AMD64;
                }
                else
                {
                    sectionname = StateObject.IsWorkstation() ? FRESH_INSTALL_PRO_IA64 : FRESH_INSTALL_SERVER_IA64;
                }
            }
            
        }
    }
    
    return sectionname;
}

BOOL SubCompCoreTS::BeforeCompleteInstall  ()
{
    IsCSCEnabled();
    return(TRUE);
}

BOOL SubCompCoreTS::AfterCompleteInstall  ()
{
    IsCSCEnabled();
    //
    // This is core TS subcomponent.
    // It has nothing to do with standalone seutp.
    // so if we are in standalone setup. just return.
    //
    
    //
    // Deny Connections registry
    //

    WriteDenyConnectionRegistry ();
    Tick();
    
    if (!StateObject.IsGuiModeSetup())
    {
        return TRUE;
    }
    
    
    SetProgressText(IDS_STRING_PROGRESS_CORE_TS);
    
    //
    // add ts product suite to registry.
    //
    AddRemoveTSProductSuite();
    Tick();
    
    
#ifndef TERMSRV_PROC
    //
    // add termsrv to netsvcs group.
    //
    AddTermSrvToNetSVCS ();
    Tick();
#endif
    
    //
    // apply hydra security to registry.
    //
    DoHydraRegistrySecurityChanges();
    Tick();
    
    //
    // Audio Redirection
    //
    UpdateAudioCodecs( StateObject.IsWorkstation() );
    Tick();
    
    //
    // Client Drive Mappings.
    //
    AddRemoveRDPNP();
    Tick();

    //
    // Hot key for Local Language change.
    //
    // We dont need to do this.
    //    HandleHotkey ();
    //    Tick();

    //
    // Printer Redirection.
    //
    InstallUninstallRdpDr ();
    Tick();
    
    
#ifdef TSOC_CONSOLE_SHADOWING
    //
    // Console Shadowing.
    //
    SetupConsoleShadow();
    Tick();
#endif // TSOC_CONSOLE_SHADOWING
    

    //InstallTermdd();
    //Tick();

    //
    // Performance monitors for TS. BUGBUG - check with ErikMa - do they work when TS is not started ?
    //
    LoadOrUnloadPerf();
    Tick();
    
    
   
    //
    //  If this were a real subcomponent, one that the OC manager knew
    //  about and handled, the following call would be to
    //  GetOriginalSubCompState().
    //
    
    if (StateObject.WasTSInstalled())
    {
        UpgradeRdpWinstations();
        Tick();
        
        //
        // This no longer exists in Whistler
        //
        DisableInternetConnector();
        Tick();
        
        if (StateObject.IsUpgradeFrom40TS())
        {
            //
            // this is upgrade from TS4
            // we want to remove service pack key in uninstall. this is to
            // ensure that service pack do not appear in Add/Remove Programs
            // and in our incompatible applications list.
            //
            RemoveTSServicePackEntry();
            Tick();
            
            //
            // There are some metaframe components in user init,
            // we need to remove thouse as we upgrade ts40
            //
            RemoveMetaframeFromUserinit ();
            Tick();
            
        }
        
        //
        // we need to reset Win2000 ts grace period for licenses on upgrades
        // Whistler uses a different location, so this won't affect RTM to
        // RTM upgrades
        //
        ResetTermServGracePeriod();
        Tick();

        //
        // Delete old LSA secrets used by public/private keys
        //
        RemoveOldKeys();
        Tick();

    }
    
    // some new code to uninstall TSClient.
    if (!UninstallTSClient())
    {
        LOGMESSAGE0(_T("ERROR: Could not uninstall tsclient."));
    }
    
    IsCSCEnabled();
    Tick();
    
    return TRUE;
}

BOOL SubCompCoreTS::IsTermSrvInNetSVCS ()
{
    BOOL bStringExists = FALSE;
    DWORD dw = IsStringInMultiString(
        HKEY_LOCAL_MACHINE,
        SVCHOSST_KEY,
        NETSVCS_VAL,
        TERMSERVICE,
        &bStringExists);
    
    return (dw == ERROR_SUCCESS) && bStringExists;
}

BOOL SubCompCoreTS::AddTermSrvToNetSVCS ()
{
    DWORD dw = NO_ERROR;
    if (StateObject.IsWorkstation())
    {
        //
        // for workstations, we want to share process with netsvcs group
        //
        if (!IsTermSrvInNetSVCS())
        {
            dw = AppendStringToMultiString(
                HKEY_LOCAL_MACHINE,
                SVCHOSST_KEY,
                NETSVCS_VAL,
                TERMSERVICE
                );
            
            if (dw != NO_ERROR)
            {
                LOGMESSAGE1(_T("Error, appending TermService to netsvcs, Errorcode = %u"), dw);
            }
        }
    }
    
    //
    // for servers we want to have our own svchost for termsrv.
    // lets create the necessary entries for pro as well, so that for debugging termsrv it'll be easier to switch to own svchost.
    //
    {
        //
        // for servers we want to have our own svchost process.
        //
        CRegistry oReg;
        dw = oReg.OpenKey(HKEY_LOCAL_MACHINE, SVCHOSST_KEY);
        if (ERROR_SUCCESS == dw)
        {
            dw = oReg.WriteRegMultiString(TERMSVCS_VAL, TERMSERVICE_MULTISZ, (_tcslen(TERMSERVICE) + 2) * sizeof(TCHAR));
            if (ERROR_SUCCESS == dw)
            {
                // add CoInitializeSecurityParam, so that CoInitialize gets called in main thread for this svc group.
                CRegistry termsvcKey;
                dw = termsvcKey.CreateKey(HKEY_LOCAL_MACHINE, SVCHOSST_TERMSRV_KEY );
                if (ERROR_SUCCESS == dw)
                {
                    dw = termsvcKey.WriteRegDWord(TERMSVCS_PARMS, 1);
                    if (ERROR_SUCCESS != dw)
                    {
                        LOGMESSAGE1(_T("Failed to write termsvc coinit params, Error = %d"), dw);
                    }
                }
                else
                {
                    LOGMESSAGE1(_T("Error, Failed to create svchost\termsrv key, Error = %d"), dw);
                }
            }
            else
            {
                LOGMESSAGE1(_T("Error, Writing termsrv value, Error = %d"), dw);
            }
        }
        else
        {
            LOGMESSAGE1(_T("Error, Opening Svchost key, Error = %d"), dw);
        }
        
    }
    
    return dw == NO_ERROR;
}
/*--------------------------------------------------------------------------------------------------------
* DWORD AddRemoveTSProductSuite (BOOL bAddRemove)
* does the necessary changes for installing hydra specific registry keys which are not done from inf.
* parameter state decides if key is to be added or removed.
* returns success
* -------------------------------------------------------------------------------------------------------*/
BOOL SubCompCoreTS::AddRemoveTSProductSuite ()
{
    
    //
    // add product suite key only for servers.
    // This is required only for TS4 compatibility.
    // TS4 applications detect if machine is terminal server using this key.
    //
    
    DWORD dw = NO_ERROR;
    if (StateObject.IsServer())
    {
        // installing/upgrading.
        if (!DoesHydraKeysExists())
        {
            ASSERT(FALSE == StateObject.WasTSInstalled());
            // now read the original data in this product suite value.
            dw = AppendStringToMultiString(
                HKEY_LOCAL_MACHINE,
                PRODUCT_SUITE_KEY,
                PRODUCT_SUITE_VALUE,
                TS_PRODUCT_SUITE_STRING
                );
            
            if (dw != NO_ERROR)
                LOGMESSAGE1(_T("ERROR:DoHydraRegistryChanges : Error Appending String = <%lu>"), dw);
        }
        
    }
    
    dw = SetTSVersion(TERMINAL_SERVER_THIS_VERSION);
    if (ERROR_SUCCESS != dw)
    {
        LOGMESSAGE1(_T("ERROR, Setting TS version, ErrorCode = %u "), dw);
    }
    
    return dw == NO_ERROR;
}


BOOL SubCompCoreTS::DisableWinStation (CRegistry *pRegWinstation)
{
    ASSERT(pRegWinstation);
    
#ifdef DBG
    // the value must be there already.
    DWORD dwValue;
    ASSERT(ERROR_SUCCESS == pRegWinstation->ReadRegDWord(_T("fEnableWinStation"), &dwValue));
#endif
    
    VERIFY(ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fEnableWinStation"), 0));
    
    return TRUE;
}

BOOL SubCompCoreTS::DoesLanaTableExist ()
{
    static fValueDetermined = FALSE;
    static fRet;
    
    if (fValueDetermined)
    {
        return(fRet);
    }
    else
    {
        CRegistry Reg;
        fRet = Reg.OpenKey(HKEY_LOCAL_MACHINE, TS_LANATABLE_KEY) == ERROR_SUCCESS;
        fValueDetermined = TRUE;
        
        LOGMESSAGE1(_T("DoesLanaTableExist: %s"), fRet ? _T("Yes") : _T("No"));
        return(fRet);
    }
}

void SubCompCoreTS::VerifyLanAdapters (CRegistry *pRegWinstation, LPTSTR pszWinstation)
{
    DWORD dwLana = 0;
    static BOOL fErrorLogged = FALSE;
    
    LOGMESSAGE1(_T("Verifying lan adapters for %s"), pszWinstation);
    
    if (DoesLanaTableExist())
    {
        LOGMESSAGE0(_T("OK: GuidTable already exists."));
        return;
    }
    
    if (pRegWinstation->ReadRegDWord(_T("LanAdapter"), &dwLana) == ERROR_SUCCESS)
    {
        if (dwLana == 0)
        {
            LOGMESSAGE0(_T("OK: using all adapters"));
        }
        else
        {
            LPTSTR lpStrings[1] = { NULL };
            
            LOGMESSAGE0(_T("ERROR: using custom bindings"));
            LOGMESSAGE1(_T("%s will be disabled and bindings reset"), pszWinstation);
            
            VERIFY(ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("LanAdapter"), (DWORD)-1));
            VERIFY(ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("fEnableWinStation"), 0));
            
            //
            //  Log error to setuperr.txt once. Log error to eventlog
            //  each time.
            //
            
            if (!fErrorLogged)
            {
                fErrorLogged = TRUE;
                LogErrorToSetupLog(OcErrLevWarning, IDS_STRING_GENERIC_LANA_WARNING);
            }
            
            lpStrings[0] = pszWinstation;
            LogErrorToEventLog(
                EVENTLOG_WARNING_TYPE,
                CATEGORY_NOTIFY_EVENTS,
                EVENT_WINSTA_DISABLED_DUE_TO_LANA,
                1,
                0,
                (LPCTSTR *)lpStrings,
                NULL
                );
        }
    }
    else
    {
        LOGMESSAGE0(_T("OK: No LanAdapter value"));
    }
}

BOOL SubCompCoreTS::UpdateRDPWinstation (CRegistry *pRegWinstation, LPTSTR lpWinStationName)
{
    //  BUG WARNING: ALL OF THESE VALUES MUST BE KEPT IN SYNC WITH TSOC.INX!!!
    //  
    //  These entries will be modified on upgrades.
    //
    LOGMESSAGE1(_T("Updating Winstation - %s"), lpWinStationName);
    ASSERT(pRegWinstation);
    
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fDisableClip"), 0) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fDisableCpm"), 0) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fDisableLPT"), 0) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fInheritAutoClient"), 1) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fAutoClientLpts"), 1) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fForceClientLptDef"), 1) );
    
    
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegString(_T("WdName"), _T("Microsoft RDP 5.2")));
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWord(_T("WdFlag"), 0x36) );
    
    // per JoyC updated for RDPWD, RDP-TCP winstations.
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fDisableCcm"), 0x0) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fDisableCdm"), 0x0) );
    
    //  enable audio redirection for Professional, disable for server
    //
    if ( StateObject.IsWorkstation() )
    {
        VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fDisableCam"), 0x0 ));
    }
    
    
    // Per AraBern, updated for RDPWD, RDP-TCP winstations.
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("ColorDepth"), StateObject.IsWorkstation() ? 0x4 : 0x3) );
    VERIFY( ERROR_SUCCESS == pRegWinstation->WriteRegDWordNoOverWrite(_T("fInheritColorDepth"), 0x0) );

//    HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp\UserOverride\Control Panel\Desktop","Wallpaper",STRIG_RETAIN,""
//    To address bug 727650 (appcompat problem if cursorblink is set to -1_, remove the following regvalue:
//    Remove HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp\UserOverride\Control Panel\Desktop","DisableCursorBlink"

    CRegistry oReg;
    if (ERROR_SUCCESS == oReg.CreateKey(*pRegWinstation, _T("UserOverride\\Control Panel\\Desktop")))
    {
        //
        // set cursor blink and wallpaper off on servers.
        //
        if (!StateObject.IsWorkstation())
        {
            oReg.DeleteValue(_T("DisableCursorBlink"));
            oReg.WriteRegString(_T("Wallpaper"), _T(""));
        }

    }
    
    // Move old autologon password into LSA (a-sajara)
    // We only want to move the password if a valid winstation name is provided
    if (lpWinStationName != NULL)
    {
        MoveWinStationPassword(pRegWinstation, lpWinStationName);
    }

    return TRUE;
}

/*****************************************************************************
*   Method:     MoveWinStationPassword
*
*   Overview:   For security reasons the lightly encrypted password that is 
*               stored in the winstation registry key is being moved to LSA
*               secret.  We are going to keep the password in it's encrypted
*               form so we can just copy it over as is.
*
*   Parameters: pRegWinstation (IN) - pointer to winstation registry key
*               strWinStationName (IN) - Winstation name we are looking at
*
*****************************************************************************/
BOOL
SubCompCoreTS::MoveWinStationPassword(CRegistry *pRegWinstation, 
                                      LPTSTR strWinStationName)
{
    USES_CONVERSION;

    DWORD  dwRet;
    LPTSTR strKeyName  = NULL;
    LPTSTR strPassword = NULL;
    DWORD  dwKeyLength;
    DWORD  dwPasswordLength;

    // Make sure a Winstation name is provided this is used for a unique LSA key
    if (strWinStationName == NULL)
    {
        LOGMESSAGE0(_T("ERROR, Winstation name not provided."));
        return FALSE;
    }

    // Read password from the registry
    dwRet = pRegWinstation->ReadRegString(OLD_PASSWORD_VALUE_NAME, 
                                          &strPassword, 
                                          &dwPasswordLength);
    if (dwRet != ERROR_SUCCESS)
    {
        LOGMESSAGE0(_T("Failed to read Password value for Winstation"));
        return FALSE;
    }

    LOGMESSAGE1(_T("Password for this winstation = %s"), strPassword);


    // Build LSA key name by appending the Winstation Name to the static KeyName
    dwKeyLength = _tcslen(LSA_PSWD_KEYNAME_T) + _tcslen(strWinStationName) + 1;
                   
    
    // Allocate memory for the password KEY
    strKeyName = (LPTSTR)LocalAlloc(LMEM_FIXED, dwKeyLength * sizeof(TCHAR));    
    if (strKeyName == NULL)
    {
        LOGMESSAGE0(_T("ERROR, Failed to allocate memory for LSA password key"));
        return FALSE;
    }

    _tcscpy(strKeyName, LSA_PSWD_KEYNAME_T);
    _tcscat(strKeyName, strWinStationName);
    strKeyName[dwKeyLength - 1] = _T('\0');

    LOGMESSAGE1(_T("Storing the password in LSA key:%s"), strKeyName);
    
    // Store the password in LSA    
    dwRet = StoreSecretKey(T2W(strKeyName),
                           (PBYTE)strPassword, 
                           dwPasswordLength);
    if (dwRet != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("StoreSecretKey(strKeyName) failed. Reason %ld"), dwRet);
    }

    LocalFree(strKeyName);

    LOGMESSAGE1(_T("Deleting password key:%s"),strKeyName);

    // Delete the password key
    dwRet = pRegWinstation->DeleteValue(OLD_PASSWORD_VALUE_NAME);
    if (dwRet != ERROR_SUCCESS)
    {
        LOGMESSAGE0(_T("ERROR, Failed to delete Password value for Winstation"));
        return FALSE;
    }

    return TRUE;
}


BOOL SubCompCoreTS::IsRdpWinStation(CRegistry *pRegWinstation)
{
    ASSERT(pRegWinstation);
    
    
    DWORD dwWdFlag;
    if (ERROR_SUCCESS == pRegWinstation->ReadRegDWord(_T("WdFlag"), &dwWdFlag))
    {
        
        
#ifdef DBG
        // if this is an RDP winstation,
        // we must have Microsoft in the WdName string
        if (WDF_TSHARE & dwWdFlag)
        {
            LPTSTR strWdName;
            DWORD dwSize;
            if (ERROR_SUCCESS == pRegWinstation->ReadRegString(_T("WdName"), &strWdName, &dwSize))
            {
                ASSERT(_tcsstr(strWdName,_T("Microsoft")) && _tcsstr(strWdName, _T("RDP")));
            }
            else
            {
                //
                // we failed to read strWdName.
                // it shouldn't have happened.
                ASSERT(FALSE);
            }
            
        }
#endif
        
        return WDF_TSHARE & dwWdFlag;
        
    }
    else
    {
        //
        // we failed to read WdFlag, it should not have happened.
        //
        LOGMESSAGE0(_T("ERROR, Failed to read WdFlag for winstation"));
        ASSERT(FALSE);
        return FALSE;
    }
    
    
}

BOOL SubCompCoreTS::IsConsoleWinStation(CRegistry *pRegWinstation)
{
    ASSERT(pRegWinstation);
    
    LPTSTR strWdName;
    DWORD dwSize;
    if (ERROR_SUCCESS == pRegWinstation->ReadRegString(_T("WdName"), &strWdName, &dwSize))
    {
        // if the value wdname contains the string "Console"
        // this is console winstation subkey
        
        LOGMESSAGE1(_T("WdName for this winstation = %s"), strWdName);
        
#ifdef DBG
        // if this is console winstation
        if (_tcsicmp(strWdName,_T("Console")) == 0)
        {
            // then it cannot be either RDP or MetaFrame winstation
            ASSERT(!IsMetaFrameWinstation(pRegWinstation) && !IsRdpWinStation(pRegWinstation));
        }
#endif
        
        return _tcsicmp(strWdName,_T("Console")) == 0;
        
    }
    else
    {
        LOGMESSAGE0(_T("ERROR, Failed to read Wdname for winstation"));
        ASSERT(FALSE);
        return FALSE;
    }
    
}

// returns true if this is non-rdp and non-console winstation subkey.
BOOL SubCompCoreTS::IsMetaFrameWinstation(CRegistry *pRegWinstation)
{
    ASSERT(pRegWinstation);
    
    DWORD dwWdFlag;
    if (ERROR_SUCCESS == pRegWinstation->ReadRegDWord(_T("WdFlag"), &dwWdFlag))
    {
        return WDF_ICA & dwWdFlag;
    }
    else
    {
        //
        // we could not read WdFlag value.
        //
        LOGMESSAGE0(_T("ERROR, Failed to read WdFlag for winstation"));
        ASSERT(FALSE);
        return TRUE;
    }
    
}


BOOL SubCompCoreTS::UpgradeRdpWinstations ()
{
    // we need to upgrade RDP capabilities for RDPWD and existing RDP winstations.
    // see also #240925
    
    // also if during upgrades we found any non-rdp winstations
    // we must disable them as they are not compatible with NT5.
    // #240905
    
    CRegistry reg;
    if (ERROR_SUCCESS == reg.OpenKey(HKEY_LOCAL_MACHINE, REG_WINSTATION_KEY))
    {
        
        LPTSTR lpStr = NULL;
        DWORD dwSize = 0;
        
        if (ERROR_SUCCESS == reg.GetFirstSubKey(&lpStr, &dwSize))
        {
            do
            {
                
                ASSERT(lpStr);
                ASSERT(dwSize > 0);
                
                // check if the current key is on rdp winstation
                CRegistry regSubKey;
                if ( ERROR_SUCCESS == regSubKey.OpenKey(reg, lpStr) )
                {
                    
                    if (IsRdpWinStation(&regSubKey))
                    {
                        LOGMESSAGE1(_T("Updating Winstation - %s"), lpStr);
                        UpdateRDPWinstation(&regSubKey, lpStr);
                        VerifyLanAdapters(&regSubKey, lpStr);
                    }
                    else if (IsMetaFrameWinstation(&regSubKey))
                    {
                        LOGMESSAGE1(_T("Disabling winstaion - %s"), lpStr);
                        DisableWinStation(&regSubKey);
                        VerifyLanAdapters(&regSubKey, lpStr);
                    }
                    else
                    {
                        LOGMESSAGE1(_T("Found a Console Winstation - %s"), lpStr);
                        // this must be console winstation
                        // do nothing for this.
                    }
                    
                }
                else
                {
                    AssertFalse();
                    LOGMESSAGE1(_T("ERROR:Failed to Open Winstation Key %s"), lpStr);
                }
                
            }
            while (ERROR_SUCCESS == reg.GetNextSubKey(&lpStr, &dwSize ));
            
        }
        else
        {
            // since this is upgrade we must find key under Winstations.
            AssertFalse();
            return FALSE;
        }
    }
    else
    {
        AssertFalse();
        return FALSE;
    }
    
    // we need to upgrade Wds\rdpwd as well.
    if ( ERROR_SUCCESS == reg.OpenKey(HKEY_LOCAL_MACHINE, SYSTEM_RDPWD_KEY))
    {
        //
        // this is not really a winstation.
        // but this call will upgrade the required entries.
        //
        UpdateRDPWinstation(&reg, NULL);
    }
    else
    {
        AssertFalse();
        return FALSE;
    }
    
    return TRUE;
}

/*--------------------------------------------------------------------------------------------------------
* BOOL DoHydraRegistrySecurityChanges ()
* does the necessary security changes for installing hydra
* that is Adds/remove LogOnLocall rights to EveryOne group.
* returns success
* Parameter decides if hydra is getting enabled or disabled.
* -------------------------------------------------------------------------------------------------------*/
BOOL SubCompCoreTS::DoHydraRegistrySecurityChanges ()
{
    BOOL bAddRemove = StateObject.IsTSEnableSelected();
    DWORD dwError = NO_ERROR;
    if (bAddRemove)
    {
        CRegistry reg;
        dwError = reg.OpenKey(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software"));
        if (ERROR_SUCCESS == dwError)
        {
            PSECURITY_DESCRIPTOR pSecDec, pSecDecNew;
            DWORD dwSize;
            dwError = reg.GetSecurity(&pSecDec, DACL_SECURITY_INFORMATION, &dwSize);

            if (dwError != ERROR_SUCCESS)
            {
                LOGMESSAGE1(_T("ERROR:GetSecurity failed with %u"), dwError);
            }
            else
            {
                ASSERT(pSecDec);
                ASSERT(IsValidSecurityDescriptor(pSecDec));
                pSecDecNew = pSecDec;

                PACL    pNewDacl = NULL;

                if (!AddTerminalServerUserToSD(&pSecDecNew, GENERIC_WRITE, &pNewDacl ))
                {
                    LOGMESSAGE1(_T("ERROR:AddUserToSD failed with %u"), GetLastError());
                }
                else
                {
                    // due to a bug in RegSetKeySecurity(), existing children of this key
                    // will not get the new SID, hence, we must use MARTA calls intead.
                    dwError  = SetNamedSecurityInfo(
                        _T("Machine\\Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server\\Install\\Software"),
                        SE_REGISTRY_KEY,
                        DACL_SECURITY_INFORMATION,
                        NULL,
                        NULL,
                        pNewDacl,
                        NULL);

                    if (dwError != ERROR_SUCCESS)
                    {
                        LOGMESSAGE1(_T("ERROR:SetNamedSecurityInfo failed with %u"), dwError);
                    }
                }

                // if new sec desciptor been allocated
                if (pSecDecNew != pSecDec)
                    LocalFree(pSecDecNew);
            }

        }
        else
        {
            LOGMESSAGE1(_T("ERROR, OpenKey failed, error = %d"), dwError);
        }

    }
    else
    {
        ASSERT(FALSE);
    }

    return dwError == NO_ERROR;
}


#define INTERNET_CONNECTOR_LICENSE_STORE    L"INET_LICENSE_STORE_2_60e55c11-a780-11d2-b1a0-00c04fa30cc4"
#define INTERNET_CONNECTOR_LSERVER_STORE    L"INET_LSERVER_STORE_2_341D3DAB-BD58-11d2-B130-00C04FB16103"
#define INTERNET_CONNECTOR_LSERVER_STORE2   L"INET_LSERVER_STORE_3_341D3DAB-BD58-11d2-B130-00C04FB16103"

#define HYDRA_SERVER_PARAM                  _T("SYSTEM\\CurrentControlSet\\Services\\TermService\\Parameters")
#define HS_PARAM_INTERNET_CONNECTOR_FLAG    _T("fInternetConnector")

BOOL SubCompCoreTS::DisableInternetConnector ()
{
    
    LOGMESSAGE0(_T("DisableInternetConnector"));
    
    // Wipe out the secret keys in LSA, regarding to Internet Connector
    DWORD dwStatus = StoreSecretKey(INTERNET_CONNECTOR_LICENSE_STORE,(PBYTE) NULL,0);
    if (dwStatus == ERROR_SUCCESS)
    {
        LOGMESSAGE0(_T("StoreSecretKey succeeded for INTERNET_CONNECTOR_LICENSE_STORE"));
        
    }
    else
    {
        LOGMESSAGE1(_T("StoreSecretKey(INTERNET_CONNECTOR_LICENSE_STORE) failed. Reason %ld"),dwStatus);
        
    }
    
    
    dwStatus = StoreSecretKey(INTERNET_CONNECTOR_LSERVER_STORE,(PBYTE) NULL,0);
    if (dwStatus == ERROR_SUCCESS)
    {
        LOGMESSAGE0(_T("StoreSecretKey succeeded for INTERNET_CONNECTOR_LSERVER_STORE"));
    }
    else
    {
        LOGMESSAGE1(_T("StoreSecretKey(INTERNET_CONNECTOR_LSERVER_STORE) failed. Reason %ld"),dwStatus);
    }
    
    
    dwStatus = StoreSecretKey(INTERNET_CONNECTOR_LSERVER_STORE2,(PBYTE) NULL,0);
    if (dwStatus == ERROR_SUCCESS)
    {
        LOGMESSAGE0(_T("StoreSecretKey succeeded for INTERNET_CONNECTOR_LSERVER_STORE2"));
    }
    else
    {
        LOGMESSAGE1(_T("StoreSecretKey(INTERNET_CONNECTOR_LSERVER_STORE2) failed. Reason %ld"),dwStatus);
    }
    
    NET_API_STATUS dwNtStatus = NetUserDel(NULL,L"TsInternetUser");
    
    if (dwNtStatus == NERR_Success)
    {
        LOGMESSAGE0(_T("NetUserDel succeeded for TsInternetUser"));
    }
    else
    {
        LOGMESSAGE1(_T("NetUserDel(TsInternetUser) failed. Reason %ld"),dwNtStatus);
    }
    
    return FALSE;
}


#define LICENSING_TIME_BOMB_5_0 L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB_5_0 L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

BOOL SubCompCoreTS::ResetTermServGracePeriod ()
{
    
    //
    // Wipe out the secret keys in LSA for the Win2000 grace period
    //
    
    LOGMESSAGE0(_T("Calling StoreSecretKey"));
    
    StoreSecretKey(LICENSING_TIME_BOMB_5_0,(PBYTE) NULL,0);
    
    StoreSecretKey(RTMLICENSING_TIME_BOMB_5_0,(PBYTE) NULL,0);
    
    return TRUE;
    
}

// Old LSA key names:
#define OLD_PRIVATE_KEY_NAME \
    L"HYDRAKEY_28ada6da-d622-11d1-9cb9-00c04fb16e75"

#define OLD_X509_CERT_PRIVATE_KEY_NAME \
    L"HYDRAKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"

#define OLD_X509_CERT_PUBLIC_KEY_NAME   \
    L"HYDRAPUBLICKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"

#define OLD_2_PRIVATE_KEY_NAME \
    L"HYDRAENCKEY_28ada6da-d622-11d1-9cb9-00c04fb16e75"

#define OLD_2_X509_CERT_PRIVATE_KEY_NAME \
    L"HYDRAENCKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"

#define OLD_2_X509_CERT_PUBLIC_KEY_NAME   \
    L"HYDRAENCPUBLICKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"


BOOL SubCompCoreTS::RemoveOldKeys ()
{
    
    //
    // Wipe out the secret keys in LSA for the public/private keys
    //
    
    LOGMESSAGE0(_T("Calling StoreSecretKey"));
    
    StoreSecretKey(OLD_PRIVATE_KEY_NAME,(PBYTE) NULL,0);
    
    StoreSecretKey(OLD_X509_CERT_PRIVATE_KEY_NAME,(PBYTE) NULL,0);
    
    StoreSecretKey(OLD_X509_CERT_PUBLIC_KEY_NAME,(PBYTE) NULL,0);
    
    StoreSecretKey(OLD_2_PRIVATE_KEY_NAME,(PBYTE) NULL,0);
    
    StoreSecretKey(OLD_2_X509_CERT_PRIVATE_KEY_NAME,(PBYTE) NULL,0);
    
    StoreSecretKey(OLD_2_X509_CERT_PUBLIC_KEY_NAME,(PBYTE) NULL,0);
    
    return TRUE;
    
}

BOOL SubCompCoreTS::RemoveTSServicePackEntry ()
{
    LOGMESSAGE0(_T("will delete terminal service pack uninstall keys."));
    
    CRegistry regUninstallKey;
    if (ERROR_SUCCESS != regUninstallKey.OpenKey(HKEY_LOCAL_MACHINE, SOFTWARE_UNINSTALL_KEY))
    {
        return(TRUE);
    }
    
    BOOL bReturn = TRUE;
    DWORD dwError;
    
    
    //
    // now try to delete various service pack key.
    // if the key does not exist its NOT an error. It means service pack was not installed at all.
    //
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_4_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_4_KEY, dwError);
    }
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_5_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_5_KEY, dwError);
    }
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_6_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_6_KEY, dwError);
    }
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_7_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_7_KEY, dwError);
    }
    
    dwError = RegDeleteKey(regUninstallKey, TERMSRV_PACK_8_KEY);
    if ((ERROR_SUCCESS != dwError) && (ERROR_FILE_NOT_FOUND != dwError))
    {
        bReturn = FALSE;
        LOGMESSAGE2(_T("Error deleting subkey %s (%d)"), TERMSRV_PACK_8_KEY, dwError);
    }
    
    return bReturn;
    
}


//
// #386628: we need remove metaframe executables - txlogon.exe and wfshell.exe from userinit key on TS40 upgrades,
// as these apps are broken after upgrade. // what about any other app that are appending value to userinit ? :
// BradG suggested, that we should just wack the reigsty to contain just userinit.
//

BOOL SubCompCoreTS::RemoveMetaframeFromUserinit ()
{
    ASSERT( StateObject.IsUpgradeFrom40TS() );
    
    CRegistry reg;
    const TCHAR szUserInitKey[] = _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon");
    const TCHAR szUserInitValue[] = _T("Userinit");
    const TCHAR szData[] = _T("userinit");
    
    if (ERROR_SUCCESS == reg.OpenKey(HKEY_LOCAL_MACHINE, szUserInitKey))
    {
        return (ERROR_SUCCESS == reg.WriteRegString(szUserInitValue, szData));
    }
    else
    {
        LOGMESSAGE0(_T("ERROR:Failed to open userinit key"));
    }
    
    return FALSE;
}



BOOL SubCompCoreTS::UninstallTSClient ()
{
    LPCTSTR SOFTWARE_MSFT = _T("Software\\Microsoft");
    LPCTSTR RUNONCE = _T("Windows\\CurrentVersion\\RunOnce");
    LPCTSTR TSC_UNINSTALL = _T("tscuninstall");
    LPCTSTR TSC_UNINSTALL_CMD = _T("%systemroot%\\system32\\tscupgrd.exe");

    CRegistry regAllUsers(HKEY_USERS);

    //
    // now enumerate through all the uses and Copy settings to new key.
    //
    
    DWORD dwSize;
    LPTSTR szUser = NULL;
    if (ERROR_SUCCESS == regAllUsers.GetFirstSubKey(&szUser, &dwSize))
    {
        do
        {
            ASSERT(szUser);
            
            TCHAR szSrcKey[512];
            
            _tcscpy(szSrcKey, szUser);
            _tcscat(szSrcKey, _T("\\"));
            _tcscat(szSrcKey, SOFTWARE_MSFT);
            _tcscat(szSrcKey, _T("\\"));
            _tcscat(szSrcKey, RUNONCE);
            
            CRegistry regSrc;
            DWORD dwError;
            
            if (ERROR_SUCCESS == (dwError = regSrc.CreateKey(HKEY_USERS, szSrcKey)))
            {
                
                if (ERROR_SUCCESS == regSrc.WriteRegExpString(TSC_UNINSTALL, TSC_UNINSTALL_CMD)) {
                    
                    LOGMESSAGE1(_T("Write TSC uninstall reg value to user %s"), szSrcKey);
                    
                }
                else {
                    
                    LOGMESSAGE1(_T("ERROR write TSC uninstall reg value, Lasterror was %d"), GetLastError());
                }
            }
            else {
                
                LOGMESSAGE1(_T("ERROR open user runonce key, Lasterror was %d"), dwError);
            }
            
        } while (ERROR_SUCCESS == regAllUsers.GetNextSubKey(&szUser, &dwSize));
    }
    else {
        
        LOGMESSAGE1(_T("ERROR open user hive"), GetLastError());
    }
    
    return TRUE;
}


BOOL SubCompCoreTS::WriteDenyConnectionRegistry ()
{
    //
    // we need to write this value only for fresh installs, or if its changed.
    //
    DWORD dwError;
    CRegistry oRegTermsrv;
    
    
    dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwDenyConnect = StateObject.GetCurrentConnAllowed() ? 0 : 1;
        LOGMESSAGE1(_T("Writing dwDenyConnect = %d"), dwDenyConnect);
        
        dwError = oRegTermsrv.WriteRegDWord(DENY_CONN_VALUE, dwDenyConnect);
        
        if (ERROR_SUCCESS == dwError)
        {
            if (dwDenyConnect == 0 && StateObject.IsServer())
            {
                // if we are allowing connections, then we must disble CSC on server machines.
                if (!DisableCSC())
                {
                    LOGMESSAGE0(_T("ERROR: failed to disable csc"));
                }
            }
            return TRUE;
        }
        else
        {
            LOGMESSAGE2(_T("Error (%d), Writing, %s Value"), dwError, DENY_CONN_VALUE);
            return FALSE;
        }
    }
    else
    {
        LOGMESSAGE2(_T("Error (%d), Opening , %s key"), dwError, REG_CONTROL_TS_KEY);
        return FALSE;
    }
    
}

void SubCompCoreTS::IsCSCEnabled()
{
    CRegistry oRegCSC;
    DWORD dwError = oRegCSC.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\NetCache"));
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwEnabled;
        dwError = oRegCSC.ReadRegDWord(_T("Enabled"), &dwEnabled);
        if (dwError == ERROR_SUCCESS)
        {
            LOGMESSAGE1(_T("CSC is %s"), dwEnabled ? _T("enabled") : _T("disabled"));
            return;
        }
    }

    LOGMESSAGE1(_T("Error reading CSC/Enabled value"), dwError);
}

bool SubCompCoreTS::DisableCSC()
{
    CRegistry oRegCSC;
    DWORD dwError = oRegCSC.CreateKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\NetCache"));
    if (ERROR_SUCCESS == dwError)
    {
        dwError = oRegCSC.WriteRegDWord(_T("Enabled"), 0);
        if (ERROR_SUCCESS != dwError)
        {
            LOGMESSAGE1(_T("Error: writing netcache/enabled(%d)"), dwError);
            return false;
        }
        else
        {
            LOGMESSAGE0(_T("Disabled CSC!"));

        }
    }
    else
    {
        LOGMESSAGE1(_T("Error: opening netcache registry(%d)"), dwError);
        return false;
    }

    return true;
}


LPCTSTR SERVICES_TERMDD_KEY = _T("SYSTEM\\CurrentControlSet\\Services\\TermDD");

void SubCompCoreTS::SetConsoleShadowInstalled (BOOL bInstalled)
{
    // ; HKLM, "SYSTEM\CurrentControlSet\Services\TermDD", "PortDriverEnable", 0x00010001, 0x1
    
    CRegistry Reg;
    if (ERROR_SUCCESS == Reg.CreateKey(HKEY_LOCAL_MACHINE, SERVICES_TERMDD_KEY))
    {
        if (ERROR_SUCCESS != Reg.WriteRegDWord(_T("PortDriverEnable"), bInstalled ? 1 : 0))
        {
            LOGMESSAGE0(_T("ERROR, Failed to write to PortDriverEnable"));
        }
        
    }
    else
    {
        LOGMESSAGE1(_T("ERROR, Failed to Create/Open %s"), SERVICES_TERMDD_KEY);
        
    }
    
}

BOOL SubCompCoreTS::IsConsoleShadowInstalled ()
{
    // ; HKLM, "SYSTEM\CurrentControlSet\Services\TermDD", "PortDriverEnable", 0x00010001, 0x1
    
    CRegistry Reg;
    
    if (ERROR_SUCCESS == Reg.OpenKey(HKEY_LOCAL_MACHINE, SERVICES_TERMDD_KEY))
    {
        DWORD dwPortDriverEnable;
        if (ERROR_SUCCESS == Reg.ReadRegDWord(_T("PortDriverEnable"), &dwPortDriverEnable))
        {
            return (dwPortDriverEnable == 1);
        }
        else
        {
            LOGMESSAGE0(_T("Failed to read from PortDriverEnable, Maybe Console Shadow is not installed yet."));
            
        }
        
    }
    else
    {
        LOGMESSAGE1(_T("ERROR, Failed to Open %s"), SERVICES_TERMDD_KEY);
        
    }
    
    return FALSE;
}

#ifdef TSOC_CONSOLE_SHADOWING
BOOL SubCompCoreTS::SetupConsoleShadow ()
{
    if (IsConsoleShadowInstalled () == StateObject.IsTSEnableSelected())
    {
        return TRUE;
    }
    
    if (StateObject.IsTSEnableSelected())
    {
        LOGMESSAGE0(_T("Installing RDP Keyboard/Mouse drivers!"));
        
        //
        // this code is new to install Mouse Device for console shadowing.
        //
        
        if (!RDPDRINST_GUIModeSetupInstall(NULL, RDPMOUPNPID, RDPMOUDEVICEID))
        {
            LOGMESSAGE0(_T("ERROR:Could not create mouse devnode"));
        }
        
        
        //
        // this code is new to install Kbd Device for console shadowing.
        //
        
        if (!RDPDRINST_GUIModeSetupInstall(NULL, RDPKBDPNPID, RDPKBDDEVICEID))
        {
            LOGMESSAGE0(_T("ERROR:Could not create kbd devnode"));
        }
        
        //
        // this code is new to install RDPCDD chained driver
        //
        
        
        /*
        TCHAR szInfFile[MAX_PATH];
        ExpandEnvironmentStrings(szRDPCDDInfFile, szInfFile, MAX_PATH);
        LOGMESSAGE1(_T("Inf file for RDPCDD is %s"), szInfFile);
        
          BOOL bRebootRequired = TRUE;
          
            if (NO_ERROR != InstallRootEnumeratedDevice( NULL, szRDPCDDDeviceName, szRDPCDDHardwareID, szInfFile, &bRebootRequired))
            {
            LOGMESSAGE0(_T("InstallRootEnumeratedDevice failed"));
            }
        */
        
    }
    else
    {
        GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;
        if (!RDPDRINST_GUIModeSetupUninstall(NULL, RDPMOUPNPID, pGuid))
        {
            LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupUninstall failed for RDP Mouse device"));
        }
        
        pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;
        if (!RDPDRINST_GUIModeSetupUninstall(NULL, RDPKBDPNPID, pGuid))
        {
            LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupUninstall failed for RDP KBD device"));
        }
        
        /*
        pGuid=(GUID *)&GUID_DEVCLASS_DISPLAY;
        if (!RDPDRINST_GUIModeSetupUninstall(NULL, (WCHAR *)T2W(szRDPCDDHardwareID), pGuid)) {
        LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupUninstall failed for Chained Display device"));
        }
        */
        
        CRegistry Reg;
        
        if (ERROR_SUCCESS == Reg.OpenKey(HKEY_LOCAL_MACHINE, SERVICES_TERMDD_KEY))
        {
            if (ERROR_SUCCESS != Reg.WriteRegDWord(_T("Start"), 4))
            {
                LOGMESSAGE0(_T("ERROR, Failed to write to TermDD\\Start"));
            }
        }
        else
        {
            LOGMESSAGE1(_T("ERROR, Failed to Open %s"), SERVICES_TERMDD_KEY);
            
        }
    }
    
    SetConsoleShadowInstalled( StateObject.IsTSEnableSelected() );
    
    return( TRUE );
}


#endif // TSOC_CONSOLE_SHADOWING

DWORD SubCompCoreTS::LoadOrUnloadPerf ()
{
    BOOL bLoad = StateObject.IsTSEnableSelected();
    LPCTSTR TERMSRV_SERVICE_PATH = _T("SYSTEM\\CurrentControlSet\\Services\\TermService");
    LPCTSTR TERMSRV_PERF_NAME = _T("Performance");
    LPCTSTR TERMSRV_PERF_COUNTERS = _T("SYSTEM\\CurrentControlSet\\Services\\TermService\\Performance");
    LPCTSTR TERMSRV_PERF_COUNTERS_FIRST_COUNTER = _T("First Counter");
    LPCTSTR TERMSRV_PERF_COUNTERS_LAST_COUNTER = _T("Last Counter");
    LPCTSTR TERMSRV_PERF_COUNTERS_FIRST_HELP = _T("First Help");
    LPCTSTR TERMSRV_PERF_COUNTERS_LAST_HELP = _T("Last Help");
    LPCTSTR TERMSRV_PERF_COUNTERS_LIBRARY = _T("Library");
    LPCTSTR TERMSRV_PERF_COUNTERS_LIBRARY_VALUE = _T("perfts.dll");
    LPCTSTR TERMSRV_PERF_CLOSE = _T("Close");
    LPCTSTR TERMSRV_PERF_CLOSE_VALUE = _T("CloseTSObject");
    LPCTSTR TERMSRV_PERF_COLLECT_TIMEOUT = _T("Collect Timeout");
    const DWORD TERMSRV_PERF_COLLECT_TIMEOUT_VALUE = 1000;
    LPCTSTR TERMSRV_PERF_COLLECT = _T("Collect");
    LPCTSTR TERMSRV_PERF_COLLECT_VALUE = _T("CollectTSObjectData");
    LPCTSTR TERMSRV_PERF_OPEN_TIMEOUT = _T("Open Timeout");
    const DWORD TERMSRV_PERF_OPEN_TIMEOUT_VALUE = 1000;
    LPCTSTR TERMSRV_PERF_OPEN = _T("Open");
    LPCTSTR TERMSRV_PERF_OPEN_VALUE = _T("OpenTSObject");
    
    TCHAR PerfArg[MAX_PATH + 10];
    CRegistry reg;
    DWORD RetVal;
    
    LOGMESSAGE1(_T("Entered LoadOrUnloadPerfCounters, load=%u"), bLoad);
    
    if (bLoad)
    {
        //
        // As a first step to installing, first clean out any existing
        // entries by unloading the counters
        //
        LOGMESSAGE0(_T("Unloading counters before install"));
        UnloadPerf();

        RetVal = reg.CreateKey(HKEY_LOCAL_MACHINE, TERMSRV_PERF_COUNTERS);
        if (RetVal == ERROR_SUCCESS)
        {
            
            TCHAR SystemDir[MAX_PATH];
            
            // On load we create and populate the entire Performance key.
            // This key must not be present when we are unloaded because
            // the WMI provider enumerates service performance DLLs
            // according to the presence of the Perf key. If it is present
            // but not fully filled in then an error log is generated.
            if (GetSystemDirectory(SystemDir, MAX_PATH))
            {
                // Just in case they are present, delete the counter number
                // entries to make sure we regenerate them correctly below.
                reg.DeleteValue(TERMSRV_PERF_COUNTERS_FIRST_COUNTER);
                reg.DeleteValue(TERMSRV_PERF_COUNTERS_LAST_COUNTER);
                reg.DeleteValue(TERMSRV_PERF_COUNTERS_FIRST_HELP);
                reg.DeleteValue(TERMSRV_PERF_COUNTERS_LAST_HELP);
                
                // Generate the static values.
                reg.WriteRegString(TERMSRV_PERF_CLOSE, TERMSRV_PERF_CLOSE_VALUE);
                reg.WriteRegDWord(TERMSRV_PERF_COLLECT_TIMEOUT, TERMSRV_PERF_COLLECT_TIMEOUT_VALUE);
                reg.WriteRegString(TERMSRV_PERF_COLLECT, TERMSRV_PERF_COLLECT_VALUE);
                reg.WriteRegDWord(TERMSRV_PERF_OPEN_TIMEOUT, TERMSRV_PERF_OPEN_TIMEOUT_VALUE);
                reg.WriteRegString(TERMSRV_PERF_OPEN, TERMSRV_PERF_OPEN_VALUE);
                reg.WriteRegString(TERMSRV_PERF_COUNTERS_LIBRARY, TERMSRV_PERF_COUNTERS_LIBRARY_VALUE);
                
                _stprintf(PerfArg, _T("%s %s\\%s"), _T("lodctr"), SystemDir, _T("tslabels.ini"));
                LOGMESSAGE1(_T("Arg is %s"), PerfArg);
                return DWORD(LoadPerfCounterTextStrings(PerfArg, FALSE));
            }
            else
            {
                unsigned LastErr = GetLastError();
                
                LOGMESSAGE1(_T("GetSystemDirectory Failure is %ld"), LastErr);
                return LastErr;
            }
        }
        else
        {
            LOGMESSAGE1(_T("Perf regkey create failure, err=%ld"), RetVal);
            return RetVal;
        }
    }
    else
    {
        return UnloadPerf();
    }
}

//
// Unload perf ctrs
//
DWORD SubCompCoreTS::UnloadPerf()
{
    TCHAR PerfArg[MAX_PATH + 10];
    CRegistry reg;
    DWORD RetVal;

    LPCTSTR TERMSRV_SERVICE_PATH = _T("SYSTEM\\CurrentControlSet\\Services\\TermService");
    LPCTSTR TERMSRV_PERF_NAME = _T("Performance");

    // On unload, first unload the counters we should have in the system.
    _stprintf(PerfArg, _T("%s %s"), _T("unlodctr"), _T("TermService"));
    LOGMESSAGE1(_T("Arg is %s"), PerfArg);
    UnloadPerfCounterTextStrings(PerfArg, FALSE);

    // Delete the entire Performance key and all its descendants. We have
    // to first open the ancestor key (TermService).
    RetVal = reg.OpenKey(HKEY_LOCAL_MACHINE, TERMSRV_SERVICE_PATH);
    if (RetVal == ERROR_SUCCESS)
    {
        RetVal = reg.RecurseDeleteKey(TERMSRV_PERF_NAME);
        if (RetVal != ERROR_SUCCESS)
        {
            LOGMESSAGE1(_T("ERROR deleting Performance key: %ld"), RetVal);
        }
    }
    else
    {
        LOGMESSAGE1(_T("Err opening Performance key, err=%ld"), RetVal);
    }

    return RetVal;
}


void SubCompCoreTS::AddRDPNP(LPTSTR szOldValue, LPTSTR szNewValue)
{
    TCHAR RDPNP_ENTRY[]  = _T("RDPNP");
    const TCHAR SZ_SEP[] = _T(" \t");
    
    //
    // We are adding our rdpnp entry to the beginning of the list
    //
    // we dont want to add comma if original value is empty.
    //
    if (_tcslen(szOldValue) != 0 && _tcstok(szOldValue, SZ_SEP))
    {
        _tcscpy(szNewValue, RDPNP_ENTRY);
        _tcscat(szNewValue, _T(","));
        _tcscat(szNewValue, szOldValue);
    }
    else {
        _tcscpy(szNewValue, RDPNP_ENTRY);
    }                   
    
}

void SubCompCoreTS::RemoveRDPNP(LPTSTR szOldValue, LPTSTR szNewValue)
{
    TCHAR RDPNP_ENTRY[]  = _T("RDPNP");
    
    //
    // this is little complicated,
    // we need to remove RDPNP from , seperated list.
    //
    // so lets get tokens.
    //
    
    
    TCHAR *szToken = NULL;
    const TCHAR SZ_SEP[] = _T(",");
    
    _tcscpy(szNewValue, _T(""));
    
    szToken = _tcstok(szOldValue, SZ_SEP);
    
    BOOL bFirstPass = TRUE;
    while (szToken)
    {
        // if the token is RDPNP, skip it.
        if (_tcsstr(szToken, RDPNP_ENTRY) == 0)
        {
            if (!bFirstPass)
            {
                _tcscat(szNewValue, _T(","));
            }
            
            _tcscat(szNewValue, szToken);
            
            bFirstPass = FALSE;
            
        }
        
        szToken = _tcstok(NULL, SZ_SEP);
        
    }
}

BOOL SubCompCoreTS::AddRemoveRDPNP ()
{
    // HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\NetworkProvider\Order
    
    BOOL bAdd = StateObject.IsTSEnableSelected();
    TCHAR NEWORK_PROVIDER_ORDER_KEY[] = _T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order");
    TCHAR PROVIDER_ORDER_VALUE[]      = _T("ProviderOrder");
    TCHAR RDPNP_ENTRY[]               = _T("RDPNP");
    
    CRegistry regNetOrder;
    if (ERROR_SUCCESS == regNetOrder.OpenKey(HKEY_LOCAL_MACHINE, NEWORK_PROVIDER_ORDER_KEY))
    {
        LPTSTR szOldValue;
        DWORD dwSize;
        if (ERROR_SUCCESS == regNetOrder.ReadRegString(PROVIDER_ORDER_VALUE, &szOldValue, &dwSize))
        {
            //
            // now we want to add or remove RDPNP_ENTRY depending on we are enabled or disabled.
            //
            
            BOOL bRdpNpExists = (_tcsstr(szOldValue, RDPNP_ENTRY) != NULL);
            
            if (bAdd == bRdpNpExists)
            {
                TCHAR szNewValue[256];
                
                //
                // already exists.
                //
                LOGMESSAGE0(_T("AddRemoveRDPNP, no change required."));
                
                //
                // Need to move to the right location
                // 
                RemoveRDPNP(szOldValue, szNewValue); 
                _tcscpy(szOldValue, szNewValue);
                AddRDPNP(szOldValue, szNewValue);           
                
                if (ERROR_SUCCESS != regNetOrder.WriteRegString(PROVIDER_ORDER_VALUE, szNewValue))
                {
                    
                    LOGMESSAGE2(_T("ERROR, Writing %s to %s"), szNewValue, PROVIDER_ORDER_VALUE);
                    
                }
            }
            else
            {
                TCHAR szNewValue[256];
                
                if (bAdd)
                {
                    //
                    // We are adding our rdpnp entry to the beginning of the list
                    //
                    
                    AddRDPNP(szOldValue, szNewValue);
                }
                else
                {
                    //
                    // this is little complicated,
                    // we need to remove RDPNP from , seperated list.
                    //
                    
                    RemoveRDPNP(szOldValue, szNewValue);                    
                }
                
                if (ERROR_SUCCESS != regNetOrder.WriteRegString(PROVIDER_ORDER_VALUE, szNewValue))
                {
                    
                    LOGMESSAGE2(_T("ERROR, Writing %s to %s"), szNewValue, PROVIDER_ORDER_VALUE);
                    
                }
                
            }
            
        }
        else
        {
            LOGMESSAGE1(_T("ERROR, Reading %s"), PROVIDER_ORDER_VALUE);
            return FALSE;
            
        }
    }
    else
    {
        LOGMESSAGE1(_T("ERROR, Opening %s"), NEWORK_PROVIDER_ORDER_KEY);
        return FALSE;
    }
    
    return TRUE;
}



/*
bool SubCompCoreTS::InstallTermdd ()
{
    // first check if termdd is installed.
    bool bInstalledAlready = false;
    CRegistry oRegTermsrv;
    DWORD dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, 
                        _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"));

    if (dwError == STATUS_SUCCESS)
    {
        DWORD dwTermddInstalled;
        if (STATUS_SUCCESS == oRegTermsrv.ReadRegDWord(_T("TermddInstalled"), &dwTermddInstalled))
        {
            bInstalledAlready = (dwTermddInstalled != 0);
        }
    }

    if (!bInstalledAlready)
    {
        LOGMESSAGE0(_T("Installing TERMDD"));
        if (RDPDRINST_GUIModeSetupInstall(NULL, TERMDDPNPID, TERMDDDEVICEID))
        {
            LOGMESSAGE0(_T("RDPDRINST_GUIModeSetupInstall succeeded for TERMDD"));
            oRegTermsrv.WriteRegDWord(_T("TermddInstalled"), 1);
        }
        else
        {
            LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupInstall failed for TERMDD"));
            return false;
        }
    }
    else
    {
        LOGMESSAGE0(_T("ERROR:termdd is already installed."));
        return false;
    }

    return true;
}
*/

BOOL SubCompCoreTS::InstallUninstallRdpDr ()
{
    //
    //  This code shouldn't run on Personal.  Device redirection isn't
    //  supported for Personal.
    //
    if (StateObject.IsPersonal()) {
        return TRUE;
    }

    //
    //  Installing RDPDR over itself is bad. Hence, only (un)install on
    //  a state change or an upgrade from TS40, but don't do unnecessary
    //  uninstalls. These are when coming from TS40, but using an unattended
    //  file to turn TS off. Therefore, RDPDR installation is the XOR of
    //  HasStateChanged() and IsUpgradeFromTS40().
    //

    // if state has changed.
    if (StateObject.IsUpgradeFrom40TS() || (StateObject.WasTSEnabled() != StateObject.IsTSEnableSelected())
        || !IsRDPDrInstalled() ) // last case checks for Personal -> Pro upgrades, we want to instsall rdpdr in those cases.
    {
        if (StateObject.IsTSEnableSelected())
        {
            LOGMESSAGE0(_T("Installing RDPDR"));
            if (!RDPDRINST_GUIModeSetupInstall(NULL, RDPDRPNPID, RDPDRDEVICEID))
            {
                LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupInstall failed"));
            }
        }
        else
        {
            LOGMESSAGE0(_T("Uninstalling RDPDR"));
            GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;
            if (!RDPDRINST_GUIModeSetupUninstall(NULL, RDPDRPNPID, pGuid))
            {
                LOGMESSAGE0(_T("ERROR:RDPDRINST_GUIModeSetupUninstall failed"));
            }
        }
    }
    
    return TRUE;
}

BOOL SubCompCoreTS::HandleHotkey ()
{
    if (StateObject.IsTSEnableSelected())
    {
        CRegistry pRegToggle;
        
        //
        // Install Hotkey if not exist key value in HKU/.Default/Keyboard Layout/Toggle!Hotkey
        //
#define REG_TOGGLE_KEY   _T(".Default\\Keyboard Layout\\Toggle")
#define REG_HOT_KEY      _T("Hotkey")
#define DEFAULT_HOT_KEY  _T("1")
        DWORD dwRet;
        
        dwRet = pRegToggle.CreateKey(HKEY_USERS, REG_TOGGLE_KEY);
        if (dwRet == ERROR_SUCCESS)
        {
            LPTSTR pszHotkey;
            DWORD  cbSize;
            
            dwRet = pRegToggle.ReadRegString(REG_HOT_KEY, &pszHotkey, &cbSize);
            if (dwRet != ERROR_SUCCESS)
            {
                dwRet = pRegToggle.WriteRegString(REG_HOT_KEY, DEFAULT_HOT_KEY);
                if (dwRet != ERROR_SUCCESS)
                {
                    LOGMESSAGE2(_T("ERROR:CRegistry::WriteRegString (%s=%s)"), REG_HOT_KEY, DEFAULT_HOT_KEY);
                }
            }
        }
        else
        {
            LOGMESSAGE1(_T("ERROR:CRegistry::CreateKey (%s)"), REG_TOGGLE_KEY);
        }
    }
    
    return TRUE;
}

/*
*  UpdateAudioCodecs - populates all audio codecs for RDP session
*/
#define DRIVERS32 _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32")
#define RDPDRV    ( DRIVERS32 _T("\\Terminal Server\\RDP") )
#ifdef  _WIN64
#define RDPDRVWOW64 _T("SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion\\Drivers32\\Terminal Server\\RDP")
#endif  // _WIN64

BOOL UpdateAudioCodecs (BOOL bIsProfessional)
{
    
    BOOL    rv = TRUE;
    LPTSTR  szBuff;
    DWORD   status;
    CRegistry regKey;
    CRegistry regDestKey;
    DWORD   size;
#ifdef  _WIN64
    CRegistry   regWow64;
#endif  // _WIN64
    
    //
    //  copy keys from
    //  HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Drivers32
    //      wavemapper
    //      midimapper
    //      EnableMP3Codec (Professional only)
    //
    

    status = regKey.OpenKey(
        HKEY_LOCAL_MACHINE,
        DRIVERS32
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    
    //
    //  Create the destination
    //
    status = regDestKey.CreateKey(
        HKEY_LOCAL_MACHINE,
        RDPDRV
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    //
    //  query for wavemapper
    //
    status = regKey.ReadRegString(
        _T("wavemapper"),
        &szBuff,
        &size
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    status = regDestKey.WriteRegString(
        _T("wavemapper"),
        szBuff
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    if ( bIsProfessional )
    {
        status = regDestKey.WriteRegDWord(
            _T("EnableMP3Codec"),
            1
            );
        
        if ( ERROR_SUCCESS != status )
            goto exitpt;
    }
    
    //
    //  query for midimapper
    //
    status = regKey.ReadRegString(
        _T("midimapper"),
        &szBuff,
        &size
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    status = regDestKey.WriteRegString(
        _T("midimapper"),
        szBuff
        );
    
    if ( ERROR_SUCCESS != status )
        goto exitpt;
    
    
#ifdef  _WIN64
    //
    //  Populate the wow64 keys
    //
    status = regWow64.CreateKey(
        HKEY_LOCAL_MACHINE,
        RDPDRVWOW64
        );

    if ( ERROR_SUCCESS != status )
    {
        goto exitpt;
    }

    status = regDestKey.ReadRegString(
        _T("wavemapper"),
        &szBuff,
        &size
        );

    if ( ERROR_SUCCESS != status )
    {
        goto exitpt;
    }

    status = regWow64.WriteRegString(
        _T("wavemapper"),
        szBuff
        );

    if ( ERROR_SUCCESS != status )
    {
        goto exitpt;
    }

    status = regDestKey.ReadRegString(
        _T("midimapper"),
        &szBuff,
        &size
        );

    if ( ERROR_SUCCESS != status )
    {
        goto exitpt;
    }

    status = regWow64.WriteRegString(
        _T("midimapper"),
        szBuff
        );

    if ( ERROR_SUCCESS != status )
    {
        goto exitpt;
    }

    status = regDestKey.ReadRegString(
        _T("wave"),
        &szBuff,
        &size
        );

    if ( ERROR_SUCCESS != status )
    {
        goto exitpt;
    }

    status = regWow64.WriteRegString(
        _T("wave"),
        szBuff
        );

    if ( ERROR_SUCCESS != status )
    {
        goto exitpt;
    }
#endif  // _WIN64

    rv = TRUE;
    
exitpt:
    
    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\stdafx.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      hydraoc.h
 *
 *  Abstract:
 *
 *      Common Header file for the HydraOC Component.
 *      HydraOc Component is an optional component which installs Termainal Server (Hydra)
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _stdafx_h_
#define _stdafx_h_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <devguid.h>
#include <initguid.h>
#include <objbase.h>
#include <tchar.h>
#include <time.h>
#include <lm.h>
#include <lmaccess.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
#include <loadperf.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commdlg.h>
#include <ocmanage.h>
#include <winsta.h>
#include <regapi.h>
#include <ntsecapi.h>
#include <malloc.h>
#include <appmgmt.h>
#include <msi.h>


#include "conv.h"
#include "constants.h"
#include "resource.h"
#include "Registry.h"
#include "logmsg.h"
#include "util.h"
#include "icaevent.h"

#define AssertFalse() ASSERT(FALSE)

#define VERIFY(x)  RTL_VERIFY(x)
//;

#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\subtoggle.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

//
// SubToggle.cpp
// subcomponent enable terminal server implementation.
//

#include "stdafx.h"
#include "SubToggle.h"
#include "hydraoc.h"
#include "pages.h"
#include "secupgrd.h"

#include "gpedit.h"
#pragma warning(push, 4)

// {0F6B957D-509E-11d1-A7CC-0000F87571E3}
DEFINE_GUID(CLSID_PolicySnapInMachine,0xf6b957d, 0x509e, 0x11d1, 0xa7, 0xcc, 0x0, 0x0, 0xf8, 0x75, 0x71, 0xe3);



// #define REGISTRY_EXTENSION_GUID  { 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2 }
DEFINE_GUID(CLSID_RegistryEntensionGuid, 0x35378EAC, 0x683F, 0x11D2, 0xA8, 0x9A, 0x00, 0xC0, 0x4F, 0xBB, 0xCF, 0xA2);


GUID guidRegistryEntension = REGISTRY_EXTENSION_GUID;
GUID guidPolicyMachineSnapin = CLSID_PolicySnapInMachine;




//
//  Globals
//
extern DefSecPageData *gpSecPageData;



DWORD SubCompToggle::GetStepCount () const
{
    return 4;
}

DWORD SubCompToggle::OnQueryState ( UINT uiWhichState ) const
{
    DWORD dwReturn = SubcompUseOcManagerDefault;
    
    switch(uiWhichState)
    {
    case OCSELSTATETYPE_FINAL:
        dwReturn = StateObject.IsItAppServer() ? SubcompOn : SubcompOff;
        break;
        
    case OCSELSTATETYPE_ORIGINAL:
        //
        // thought originally the comp was on, we want to unselect it for server sku.
        //
        if (StateObject.CanInstallAppServer())
        {
            dwReturn = StateObject.WasItAppServer() ? SubcompOn : SubcompOff;
        }
        else
        {
            if (StateObject.WasItAppServer())
            {
                LogErrorToSetupLog(OcErrLevWarning, IDS_STRING_TERMINAL_SERVER_UNINSTALLED);
            }
            dwReturn = SubcompOff;
        }
        break;

    case OCSELSTATETYPE_CURRENT:
        //
        // our state object knows best about the current state for unattended and fresh install cases.
        //
        if (StateObject.IsTSFreshInstall() || StateObject.IsUnattended())
        {
            if (StateObject.CurrentTSMode() == eAppServer)
            {
                dwReturn = SubcompOn;
            }
            else
            {
                dwReturn =  SubcompOff;
            }
        }
        else
        {
            dwReturn = SubcompUseOcManagerDefault;
        }
        break;

    default:
        AssertFalse();
        break;
    }

    return dwReturn;

}

BOOL IsIeHardforUserSelected()
{
    const TCHAR STRING_IEUSER_HARD[] = _T("IEHardenUser");
    return GetHelperRoutines().QuerySelectionState(GetHelperRoutines().OcManagerContext,
            STRING_IEUSER_HARD, OCSELSTATETYPE_CURRENT);

}

DWORD SubCompToggle::OnQuerySelStateChange (BOOL bNewState, BOOL bDirectSelection) const
{
    //
    // We dont have problems with somebody disabling TS.
    //
    if (!bNewState)
        return TRUE;

    //
    // this component is available only for adv server or highter. so dont let it be selected for
    // any other sku.
    //
    if (!StateObject.CanInstallAppServer())
        return FALSE;

    //
    // if its not a user selection let it go through.
    //
    if (!bDirectSelection)
        return TRUE;

    if (!IsIeHardforUserSelected())
    {
        return TRUE;
    }

    // IDS_IEHARD_EXCLUDES_TS          "Internet Explorer Enhanced Security for Users on a Terminal Server will substantially limit the users ability to browse the internet from their Terminal Server sessions\n\nContinue the install with this combination?"
    // IDS_DIALOG_CAPTION_CONFIG_WARN  "Configuration Warning"
    if ( IDYES == DoMessageBox(IDS_IEHARD_EXCLUDES_TS, IDS_DIALOG_CAPTION_CONFIG_WARN, MB_YESNO | MB_ICONEXCLAMATION))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }

    ASSERT(FALSE);
    return TRUE;
}

LPCTSTR SubCompToggle::GetSectionToBeProcessed (ESections eSection) const
{
    //
    //  If the state hasn't changed in stand alone setup, don't do anything.
    //  Note that an permission settings will be handled later.
    //

    if ((StateObject.CurrentTSMode() == StateObject.OriginalTSMode()) && 
        StateObject.IsStandAlone()) 
    {
        return(NULL);
    }
    
    //
    //  There are no files to install.
    //
    if ((eSection == kFileSection) || (eSection == kDiskSpaceAddSection))
    {
        return(NULL);
    }


    ETSMode eMode = StateObject.CurrentTSMode();
    if (StateObject.IsX86())
    {
        switch (eMode)
        {
        case eRemoteAdmin:
                return StateObject.IsWorkstation() ? REMOTE_ADMIN_PRO_X86 : REMOTE_ADMIN_SERVER_X86;
                break;
        case eAppServer:
                return StateObject.IsWorkstation() ? APPSERVER_PRO_X86 : APPSERVER_SERVER_X86;
                break;
        case ePersonalTS:
                return StateObject.IsWorkstation() ? PERSONALTS_PRO_X86 : PERSONALTS_SERVER_X86;
                break;
        case eTSDisabled:
        default:
                ASSERT(FALSE);
                return NULL;
        }
    }
    else
    {
        switch (eMode)
        {
        case eRemoteAdmin:
                if (StateObject.IsAMD64())
                {
                    return StateObject.IsWorkstation() ? REMOTE_ADMIN_PRO_AMD64 : REMOTE_ADMIN_SERVER_AMD64;
                }
                else
                {
                    return StateObject.IsWorkstation() ? REMOTE_ADMIN_PRO_IA64 : REMOTE_ADMIN_SERVER_IA64;
                }
                break;
        case eAppServer:
                if (StateObject.IsAMD64())
                {
                    return StateObject.IsWorkstation() ? APPSERVER_PRO_AMD64 : APPSERVER_SERVER_AMD64;
                }
                else
                {
                    return StateObject.IsWorkstation() ? APPSERVER_PRO_IA64 : APPSERVER_SERVER_IA64;
                }
                break;
        case ePersonalTS:
                if (StateObject.IsAMD64())
                {
                    return StateObject.IsWorkstation() ? PERSONALTS_PRO_AMD64 : PERSONALTS_SERVER_AMD64;
                }
                else
                {
                    return StateObject.IsWorkstation() ? PERSONALTS_PRO_IA64 : PERSONALTS_SERVER_IA64;
                }
                break;
        case eTSDisabled:
        default:
                ASSERT(FALSE);
                return NULL;
        }
    }

}

BOOL SubCompToggle::BeforeCompleteInstall  ()
{
    if (StateObject.IsItAppServer() != StateObject.WasItAppServer())
    {
        SetProgressText(StateObject.IsItAppServer() ? IDS_STRING_PROGRESS_ENABLING : IDS_STRING_PROGRESS_DISABLING);
    }
    
    return TRUE;
}


LPCTSTR SubCompToggle::GetSubCompID () const
{
    return (APPSRV_COMPONENT_NAME);
}

BOOL SubCompToggle::AfterCompleteInstall ()
{
    
    LOGMESSAGE0(_T("Entering AfterCompleteInstall"));
    ASSERT(StateObject.Assert());
    StateObject.LogState();
    
    WriteLicensingMode();
    Tick();

    SetPermissionsMode ();
    Tick();

    //
    // this need to be done even if there is no state change, as we want to do this on upgrades as well.
    //
    if (StateObject.IsStandAlone() && !StateObject.IsStandAloneModeSwitch ())
    {
        //
        // nothing has changed. dont bother to do any of the next steps.
        //
        return TRUE;
    }
    
    WriteModeSpecificRegistry();
    Tick();

    UpdateMMDefaults();
    Tick();

    ResetWinstationSecurity ();
    Tick();
    
    ModifyWallPaperPolicy();
    Tick();
    
    ModifyAppPriority();

    AddStartupPopup();
    Tick();

    
    
    // this really belongs in subcore, but since we want to it after ResetWinstationSecurity is called we are calling it here.
    //
    // we have modified winstation security mechanism for whistler.
    // Call this routine, which takes care of upgrades as well as clean installs.
    //
    LOGMESSAGE0(_T("Will Call SetupWorker now."));
    DWORD dwError = SetupWorker(StateObject);
    LOGMESSAGE0(_T("Done with SetupWorker."));
    
    if (dwError != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR :SetupWorker failed. ErrorCode = %d"), dwError);
    }
    
    if( StateObject.IsGuiModeSetup() )
    {
        // WARNING : this must be done after SetupWorker()
        SetupRunOnce( GetComponentInfHandle(), RUNONCE_SECTION_KEYWORD );
    }
    
    //
    //  We need a reboot if we toggled TS through AR/P.
    //
    
    if ( StateObject.IsStandAlone() && StateObject.IsStandAloneModeSwitch())
    {
        SetReboot();

        //
        // If we're changing into or out of app-compatibility mode, inform
        // the licensing system, because we're about to reboot
        //
        InformLicensingOfModeChange();
        Tick();
    }
    
    ASSERT(StateObject.Assert());
    StateObject.LogState();

    return(TRUE);
}



BOOL SubCompToggle::WriteLicensingMode ()
{
    LOGMESSAGE0(_T("Entering WriteLicensingMode"));

	//
	// we need to write this value only if it's set in answer file
	//
    if (StateObject.IsItAppServer() && (StateObject.NewLicMode() != eLicUnset))
    {
        DWORD dwError;
        CRegistry oRegTermsrv;
	
        dwError = oRegTermsrv.CreateKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_LICENSING_KEY);
        if (ERROR_SUCCESS == dwError)
        {
            DWORD dwMode = StateObject.NewLicMode();

            TCHAR *tszValueName = StateObject.IsItAppServer() ? REG_LICENSING_MODE_AC_ON : REG_LICENSING_MODE_AC_OFF;

            LOGMESSAGE2(_T("Writing %s = %d"), tszValueName, dwMode);
            
            dwError = oRegTermsrv.WriteRegDWord(tszValueName, dwMode);

            if (ERROR_SUCCESS == dwError)
            {
                return TRUE;
            }
            else
            {
                LOGMESSAGE2(_T("Error (%d), Writing, %s Value"), dwError, tszValueName);
                return FALSE;
            }
        }
        else
        {
            LOGMESSAGE2(_T("Error (%d), Opening , %s key"), dwError, REG_CONTROL_TS_LICENSING_KEY);
            return FALSE;
        }
	}
    else
    {
        return TRUE;
    }
}


BOOL SubCompToggle::ApplySection (LPCTSTR szSection)
{
    
    DWORD dwError;
    
    LOGMESSAGE1(_T("Setting up Registry from section =  %s"), szSection);
    dwError = SetupInstallFromInfSection(
        NULL,                                // hwndOwner
        GetComponentInfHandle(),             // inf handle
        szSection,                          //
        SPINST_REGISTRY,                     // operation flags
        NULL,                                // relative key root
        NULL,                                // source root path
        0,                                   // copy flags
        NULL,                                // callback routine
        NULL,                                // callback routine context
        NULL,                                // device info set
        NULL                                 // device info struct
        );
    
    if (dwError == 0)
    {
        LOGMESSAGE1(_T("ERROR:while installating section <%lu>"), GetLastError());
    }
    
    return (dwError != 0);
}


BOOL SubCompToggle::ResetWinstationSecurity ()
{
    //
    //  If the TS mode is changing, reset winstation securities.
    //
    
    DWORD dwError;
    if (StateObject.IsAppSrvModeSwitch() && gpSecPageData->GetWinStationCount() > 0)
    {
        CRegistry pReg;
        CRegistry pSubKey;
        LPTSTR* pWinStationArray = gpSecPageData->GetWinStationArray();
        UINT cArray = gpSecPageData->GetWinStationCount();
        
        LOGMESSAGE1(_T("%d WinStations to reset."), cArray);
        
        //
        //  Open the WinStations key. At this point, this key must exist.
        //
        
        VERIFY(pReg.OpenKey(HKEY_LOCAL_MACHINE, REG_WINSTATION_KEY) == ERROR_SUCCESS);
        
        if (cArray != 0)
        {
            ASSERT(pWinStationArray != NULL);
            
            for (UINT i = 0; i < cArray; i++)
            {
                LOGMESSAGE1(_T("Resetting %s."), pWinStationArray[i]);
                
                dwError = pSubKey.OpenKey(pReg, pWinStationArray[i]);
                if (dwError == ERROR_SUCCESS)
                {
                    LOGMESSAGE2(_T("Delete registry value %s\\%s"), pWinStationArray[i], REG_SECURITY_VALUE);
                    
                    dwError = pSubKey.DeleteValue(REG_SECURITY_VALUE);
                    if (dwError == ERROR_SUCCESS)
                    {
                        LOGMESSAGE0(_T("Registry value deleted."));
                    }
                    else
                    {
                        LOGMESSAGE1(_T("Error deleting value: %ld"), dwError);
                    }
                }
                else
                {
                    LOGMESSAGE2(_T("Couldn't open key %s: %ld"), pWinStationArray[i], dwError);
                }
            }
        }
    }
    
    return TRUE;
    
}

BOOL SubCompToggle::InformLicensingOfModeChange ()
{
    BOOL fRet;

    ASSERT(StateObject.IsTSModeChanging());

    //
    // RPC into licensing to tell it we're going to reboot
    //

    HANDLE hServer = ServerLicensingOpen(NULL);

    if (NULL == hServer)
    {
        LOGMESSAGE1(_T("ERROR: InformLicensingOfModeChange calling ServerLicensingOpen <%lu>"), GetLastError());

        return FALSE;
    }

    fRet = ServerLicensingDeactivateCurrentPolicy(
                                                  hServer
                                                  );
    if (!fRet)
    {
        LOGMESSAGE1(_T("ERROR: InformLicensingOfModeChange calling ServerLicensingDeactivateCurrentPolicy <%lu>"), GetLastError());
    }

    ServerLicensingClose(hServer);


    return fRet;
}

BOOL SubCompToggle::SetPermissionsMode ()
{
    //
    //  If TS is toggling on, set the security key based on the choices
    //  made through the wizard page. This must be done even if TS was
    //  already enabled, as the permissions mode can be changed by the
    //  unattended file.
    //
    
    CRegistry reg;
    EPermMode ePermMode = StateObject.CurrentPermMode();
    
    VERIFY(reg.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY) == ERROR_SUCCESS);
    // BUGBUG should be
    // return (ERROR_SUCCESS == reg.WriteRegDWord( _T("TSUserEnabled"), StateObject.IsItAppServer() ? (DWORD)ePermMode : (DWORD)PERM_WIN2K));
    return (ERROR_SUCCESS == reg.WriteRegDWord( _T("TSUserEnabled"), StateObject.IsTSEnableSelected() ? (DWORD)ePermMode : (DWORD)PERM_TS4));
    
}


BOOL RegisterDll(LPCTSTR szDll)
{
    HMODULE hMod = LoadLibrary(szDll);
    HRESULT hResult = E_FAIL;
    
    if (hMod)
    {
        FARPROC pfRegSrv = GetProcAddress(hMod, "DllRegisterServer");
        if (pfRegSrv)
        {
            __try
            {
                hResult = (HRESULT)pfRegSrv();
                if (hResult != S_OK)
                {
                    LOGMESSAGE2(_T("ERROR, DllRegister Server in %s failed, hResult = %x"), szDll, hResult);
                }
            }
            __except( 1 )
            {
                hResult = E_FAIL;
                LOGMESSAGE2(_T("ERROR, Exception hit Registrering  of %s failed, Exception = %x"), szDll, GetExceptionCode());
            }
            
        }
        else
        {
            LOGMESSAGE1(_T("ERROR, Failed to Get proc for DllregisterServer for %s"), szDll);
        }
        
        FreeLibrary(hMod);
    }
    else
    {
        LOGMESSAGE2(_T("ERROR, Failed to Load library %s, lastError = %d"), szDll, GetLastError());
    }
    
    return hResult == S_OK;
}


BOOL SubCompToggle::ModifyWallPaperPolicy ()
{
    BOOL bRet = FALSE;
    
    //
    // policy must be applied when we change modes.
    // also for fresh installs/upgrades of app server.
    //
    if (StateObject.IsAppSrvModeSwitch() || (StateObject.IsGuiModeSetup() && StateObject.IsItAppServer()))
    {
        LOGMESSAGE0(_T("Will apply/change policies now..."));
        if (StateObject.IsGuiModeSetup())
        {
            //
            // in case of Gui mode setup
            // the group policy object may not be registered yet.
            // so lets register it ourselves.
            //
            
            TCHAR szGPEditFile[MAX_PATH];
            if (GetSystemDirectory(szGPEditFile, MAX_PATH))
            {
                _tcscat(szGPEditFile, _T("\\gpedit.dll"));
                if (!RegisterDll(szGPEditFile))
                {
                    LOGMESSAGE1(_T("Error, failed to register dll - %s."), szGPEditFile);
                }
            }
            else
            {
                LOGMESSAGE0(_T("Error, failed to GetSystemDirectory."));
            }
        }
        
        OleInitialize(NULL);
        IGroupPolicyObject *pIGroupPolicyObject = NULL;
        HRESULT hResult = CoCreateInstance(
            CLSID_GroupPolicyObject,        //Class identifier (CLSID) of the object
            NULL,                           //Pointer to controlling IUnknown
            CLSCTX_ALL,                     //Context for running executable code
            IID_IGroupPolicyObject,         //Reference to the identifier of the interface
            (void **)&pIGroupPolicyObject   //Address of output variable that receives  the interface pointer requested in riid
            );
        if (SUCCEEDED(hResult))
        {
            ASSERT(pIGroupPolicyObject);
            
            hResult = pIGroupPolicyObject->OpenLocalMachineGPO(GPO_OPEN_LOAD_REGISTRY);
            if (SUCCEEDED(hResult))
            {
                HKEY hMachinePolicyKey = NULL;
                hResult = pIGroupPolicyObject->GetRegistryKey(GPO_SECTION_MACHINE, &hMachinePolicyKey);
                if (SUCCEEDED(hResult))
                {
                    ASSERT(hMachinePolicyKey);
                    
                    const LPCTSTR szNoActiveDesktop_key     = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer");
                    const LPCTSTR szNoActiveDesktop_val     = _T("NoActiveDesktop");
                    const DWORD   szNoActiveDesktop_dat     = 1;
                    
                    CRegistry regMachinePolicy;

                    if (ERROR_SUCCESS == regMachinePolicy.CreateKey(hMachinePolicyKey, szNoActiveDesktop_key))
                    {
                        if (StateObject.IsItAppServer())
                        {
                            if (ERROR_SUCCESS != regMachinePolicy.WriteRegDWord(szNoActiveDesktop_val, szNoActiveDesktop_dat))
                            {
                                LOGMESSAGE1(_T("ERROR, Failed to Write %s policy"), szNoActiveDesktop_val);
                            }
                        }
                        else
                        {
                            if (ERROR_SUCCESS != regMachinePolicy.DeleteValue(szNoActiveDesktop_val))
                            {
                                LOGMESSAGE1(_T("Failed to delete %s policy"), szNoActiveDesktop_val);
                            }
                        }
                    }
                    
                    pIGroupPolicyObject->Save(TRUE, TRUE, &guidRegistryEntension, &guidPolicyMachineSnapin);
                    RegCloseKey(hMachinePolicyKey);
                    bRet = TRUE;
                    
                }
                else
                {
                    LOGMESSAGE1(_T("ERROR, Failed to GetRegistryKey...hResult = %x"), hResult);
                }
            }
            else
            {
                LOGMESSAGE1(_T("ERROR, Failed to OpenLocalMachineGPO...hResult = %x"), hResult);
            }
            
            pIGroupPolicyObject->Release();
            
        }
        else
        {
            LOGMESSAGE1(_T("ERROR, Failed to get the interface IID_IGroupPolicyObject...hResult = %x"), hResult);
            
        }
        
        LOGMESSAGE0(_T("Done with Policy changes!"));
    }
    
    return bRet;
}


BOOL SubCompToggle::ModifyAppPriority()
{
    if (StateObject.IsAppSrvModeSwitch())
    {
        DWORD dwSrvPrioity = StateObject.IsItAppServer() ? 0x26 : 0x18;
        
        LPCTSTR PRIORITY_KEY = _T("SYSTEM\\CurrentControlSet\\Control\\PriorityControl");
        
        CRegistry oReg;
        if (ERROR_SUCCESS == oReg.OpenKey(HKEY_LOCAL_MACHINE, PRIORITY_KEY))
        {
            if (ERROR_SUCCESS != oReg.WriteRegDWord(_T("Win32PrioritySeparation"), dwSrvPrioity))
            {
                LOGMESSAGE0(_T("Error, Failed to update Win32PrioritySeparation"));
                return FALSE;
            }
            
            return TRUE;
        }
        else
        {
            LOGMESSAGE1(_T("Errror, Failed to open %s key"), PRIORITY_KEY);
            return FALSE;
        }
        
    }
    
    return TRUE;
}

BOOL SubCompToggle::UpdateMMDefaults ()
{
    LPCTSTR MM_REG_KEY = _T("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management");
    LPCTSTR SESSION_VIEW_SIZE_VALUE = _T("SessionViewSize");
    LPCTSTR SESSION_POOL_SIZE_VALUE = _T("SessionPoolSize");
    
    //
    // on app server machines, win32k uses the session pool, on all other platform 
    // it uses the global pool. MM defaults (when these registry are not set) are 
    // good only for TS AppServer.
    // 
    // For all other platform we set new values for SessionPool (set to minumum allowed (4MB))
    // and higher value for SessionView.
    //
    const DWORD dwViewSizeforNonTS = 48;
    const DWORD dwPoolSizeforNonTS = 4;

    //
    // these default applies only for X86 machines
    //
    if (!StateObject.IsX86())
        return TRUE;

    
    CRegistry  regMM;
    DWORD dwError = regMM.OpenKey(HKEY_LOCAL_MACHINE, MM_REG_KEY);

    if (ERROR_SUCCESS == dwError)
    {
        if (StateObject.IsItAppServer())
        {
            //
            // if this is a mode change then  then we have to delete mm settings.
            //
            if (!StateObject.WasItAppServer())
            {
                //
                // for app server machines, MM defaults are good,
                //
                regMM.DeleteValue(SESSION_VIEW_SIZE_VALUE);
                regMM.DeleteValue(SESSION_POOL_SIZE_VALUE);

            }

        }
        else
        {
            //
            // for all other platform set SessionPool and SessionView.
            //
            dwError = regMM.WriteRegDWordNoOverWrite(SESSION_VIEW_SIZE_VALUE, dwViewSizeforNonTS);
            if (dwError != ERROR_SUCCESS)
            {
                LOGMESSAGE2(_T("ERROR, Failed to write %s for nonTS (%d)"), SESSION_VIEW_SIZE_VALUE, dwError);
            }


            dwError = regMM.WriteRegDWordNoOverWrite(SESSION_POOL_SIZE_VALUE, dwPoolSizeforNonTS);
            if (dwError != ERROR_SUCCESS)
            {
                LOGMESSAGE2(_T("ERROR, Failed to write %s for nonTS(%d)"), SESSION_POOL_SIZE_VALUE, dwError);
            }
        }
    }
    else
    {
        LOGMESSAGE1(_T("ERROR, Failed to open mm Key (%d)"), dwError);
        return FALSE;
    }

    return TRUE;
}


BOOL SubCompToggle::WriteModeSpecificRegistry ()
{
    // here we do some registry changes that has weird requirements .
    // if the registry has to be retained on upgrades,
    // and it has different values for different modes then such registry
    // changes go here.


    if (!StateObject.IsServer())
        return true;


    CRegistry oRegTermsrv;
    DWORD dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, REG_CONTROL_TS_KEY);
    if (ERROR_SUCCESS == dwError)
    {
        DWORD dwSingleSessionPerUser;
        const TCHAR szSingleSession[] = _T("fSingleSessionPerUser");


        if (StateObject.IsItAppServer())
        {
            dwSingleSessionPerUser = 1;
        }
        else
        {
            dwSingleSessionPerUser = 0;
        }

        if (StateObject.IsAppSrvModeSwitch())
        {
            //
            // overwrite fSingleSessionPerUser with new value in case of mode switch.
            //
            dwError = oRegTermsrv.WriteRegDWord(szSingleSession, dwSingleSessionPerUser);
        }
        else
        {
            //
            // retain the original value in case of just upgrade.
            //
            dwError = oRegTermsrv.WriteRegDWordNoOverWrite(szSingleSession, dwSingleSessionPerUser);
        }

        if (ERROR_SUCCESS != dwError)
        {
            LOGMESSAGE1(_T("ERROR, failed to write fSingleSessionPerUser value(%d)"), dwError );
        }
    }
    else
    {
        LOGMESSAGE1(_T("ERROR, failed to open Termsrv registry(%d)"), dwError );
    }

    return ERROR_SUCCESS == dwError;
}

BOOL SubCompToggle::AddStartupPopup()
{
    //
    // we need to popup a help checklist when a machine is turned into TS App Server.
    //
    if (!StateObject.CanShowStartupPopup())
    {
        LOGMESSAGE0(_T("CanShowStartupPopup returned false!"));
        return TRUE;
    }

    if (StateObject.IsItAppServer() && !StateObject.WasItAppServer())
    {
        CRegistry oReg;
        DWORD dwError = oReg.OpenKey(HKEY_LOCAL_MACHINE, RUN_KEY);
        if (dwError == ERROR_SUCCESS)
        {
            dwError = oReg.WriteRegExpString(HELP_POPUPRUN_VALUE, HELP_PUPUP_COMMAND);
            if (dwError != ERROR_SUCCESS)
            {
                LOGMESSAGE1(_T("Error Failed to write Runonce value"), dwError);
            }
            else
            {
                LOGMESSAGE0(_T("added the startup Checklist Link!"));
            }
        }
        else
        {
            LOGMESSAGE1(_T("Error Failed to open Runonce key"), dwError);
        }
    }

    return TRUE;
}


#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\subcomp.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

//
// subcomp.h
// defines a subcomponent class
//

#ifndef _subcomp_h_
#define _subcomp_h_

#include "hydraoc.h"

#define RUNONCE_SECTION_KEYWORD     _T("RunOnce.Setup")
#define RUNONCE_DEFAULTWAIT         5 * 60 * 1000 // 5 mins default wait for process to complete.
#define RUNONCE_CMDBUFSIZE          512

class OCMSubComp
{
    private:
    LONG m_lTicks;

    public:
    enum ESections
    {
        kFileSection,
        kRegistrySection,
        kDiskSpaceAddSection
    };

    OCMSubComp ();

    void    Tick (DWORD  dwTickCount  =  1);
    void    TickComplete ();

    BOOL    HasStateChanged() const;
    BOOL    GetCurrentSubCompState () const;
    BOOL    GetOriginalSubCompState () const;
    DWORD   LookupTargetSection (LPTSTR szTargetSection, DWORD dwSize, LPCTSTR lookupSection);
    DWORD   GetTargetSection (LPTSTR szTargetSection, DWORD dwSize, ESections eSectionType, BOOL *pbNoSection);

    virtual LPCTSTR GetSubCompID    () const = 0;
    virtual LPCTSTR GetSectionToBeProcessed (ESections) const = 0;


    //
    // default implementaion is provided for all these
    //
    virtual BOOL Initialize ();
    virtual BOOL BeforeCompleteInstall  ();
    virtual BOOL AfterCompleteInstall   ();

    virtual DWORD GetStepCount          () const;

    virtual DWORD OnQuerySelStateChange (BOOL bNewState, BOOL bDirectSelection) const;
    virtual DWORD OnQueryState          (UINT uiWhichState) const;
    virtual DWORD OnCalcDiskSpace       (DWORD addComponent, HDSKSPC dspace);
    virtual DWORD OnQueueFiles          (HSPFILEQ queue);
    virtual DWORD OnCompleteInstall     ();
    virtual DWORD OnAboutToCommitQueue  ();

    // implemented by this class.
    DWORD OnQueryStepCount              ();

    virtual VOID SetupRunOnce( HINF inf, LPCTSTR SectionName );


};

#endif // _subcomp_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\subcomp.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// subcomp.cpp
// implementation a default sub component

#include "stdafx.h"
#include "subcomp.h"


OCMSubComp::OCMSubComp ()
{
    m_lTicks = 0;
}

BOOL OCMSubComp::Initialize ()
{

    return TRUE;
}

BOOL OCMSubComp::GetCurrentSubCompState () const
{
    return GetHelperRoutines().QuerySelectionState(
        GetHelperRoutines().OcManagerContext,
        GetSubCompID(),
        OCSELSTATETYPE_CURRENT);
}

BOOL OCMSubComp::GetOriginalSubCompState () const
{
    return GetHelperRoutines().QuerySelectionState(
        GetHelperRoutines().OcManagerContext,
        GetSubCompID(),
        OCSELSTATETYPE_ORIGINAL);
}

BOOL OCMSubComp::HasStateChanged () const
{
    //
    // returns true if current selection state is different from previous.
    //
    return GetCurrentSubCompState() != GetOriginalSubCompState();

}

//
// this functions ticks the gauge for the specified count
// keep traks of the count reported to the OC_QUERY_STEP_COUNT
//
void OCMSubComp::Tick (DWORD  dwTickCount /* = 1 */)
{
    if (m_lTicks > 0)
    {
        m_lTicks -= dwTickCount;
        while(dwTickCount--)
            GetHelperRoutines().TickGauge( GetHelperRoutines().OcManagerContext );

    }
    else
    {
        m_lTicks = 0;
    }
}

//
// completes the remaining ticks.
//
void OCMSubComp::TickComplete ()
{
    ASSERT(m_lTicks >= 0);
    while (m_lTicks--)
        GetHelperRoutines().TickGauge( GetHelperRoutines().OcManagerContext );
}

DWORD OCMSubComp::OnQueryStepCount()
{
    m_lTicks = GetStepCount() + 2;
    return m_lTicks;
}

DWORD OCMSubComp::GetStepCount () const
{
    return 0;
}


DWORD OCMSubComp::OnQueryState ( UINT uiWhichState ) const
{
	LOGMESSAGE1(_T("In OCMSubComp::OnQueryState  for %s"), GetSubCompID());

    ASSERT(OCSELSTATETYPE_ORIGINAL == uiWhichState ||
           OCSELSTATETYPE_CURRENT == uiWhichState ||
           OCSELSTATETYPE_FINAL == uiWhichState );

    return SubcompUseOcManagerDefault;

}

DWORD OCMSubComp::OnQuerySelStateChange (BOOL /* bNewState */, BOOL /* bDirectSelection */) const
{
    return TRUE;
}

DWORD OCMSubComp::LookupTargetSection(LPTSTR szTargetSection, DWORD dwSize, LPCTSTR lookupSection)
{
    DWORD dwError = GetStringValue(GetComponentInfHandle(), GetSubCompID(), lookupSection, szTargetSection, dwSize);
    if (dwError == ERROR_SUCCESS)
    {
        LOGMESSAGE2(_T("sectionname = <%s>, actual section = <%s>"), lookupSection, szTargetSection);
    }
    else
    {
        AssertFalse();
        LOGMESSAGE1(_T("ERROR:GetSectionToBeProcess:GetStringValue failed GetLastError() = %lu"), dwError);
    }

    return dwError;
}

DWORD OCMSubComp::GetTargetSection(LPTSTR szTargetSection, DWORD dwSize, ESections eSectionType, BOOL *pbNoSection)
{
    ASSERT(szTargetSection);
    ASSERT(pbNoSection);

    //
    // get section to be processed
    //
    LPCTSTR szSection = GetSectionToBeProcessed( eSectionType );

    if (szSection == NULL)
    {
        *pbNoSection = TRUE;
        return NO_ERROR;
    }
    else
    {
        //
        // there is a section to be processed.
        //
        *pbNoSection = FALSE;
    }


    //
    // look for the target section
    //
    return LookupTargetSection(szTargetSection, dwSize, szSection);

}

DWORD OCMSubComp::OnCalcDiskSpace ( DWORD addComponent, HDSKSPC dspace )
{
	LOGMESSAGE1(_T("In OCMSubComp::OnCalcDiskSpace for %s"), GetSubCompID());

    TCHAR TargetSection[S_SIZE];
    BOOL bNoSection = FALSE;

    DWORD rc = GetTargetSection(TargetSection, S_SIZE, kDiskSpaceAddSection, &bNoSection);

    //
    // if there is no section to be processed. just return success.
    //
    if (bNoSection)
    {
        return NO_ERROR;
    }

    if (rc == NO_ERROR)
    {
        if (addComponent)
        {
            LOGMESSAGE1(_T("Calculating disk space for add section =  %s"), TargetSection);
            rc = SetupAddInstallSectionToDiskSpaceList(
                dspace,
                GetComponentInfHandle(),
                NULL,
                TargetSection,
                0,
                0);
        }
        else
        {
            LOGMESSAGE1(_T("Calculating disk space for remove section =  %s"), TargetSection);
            rc = SetupRemoveInstallSectionFromDiskSpaceList(
                dspace,
                GetComponentInfHandle(),
                NULL,
                TargetSection,
                0,
                0);
        }

        if (!rc)
            rc = GetLastError();
        else
            rc = NO_ERROR;

    }

    return rc;
}

DWORD OCMSubComp::OnQueueFiles ( HSPFILEQ queue )
{
	LOGMESSAGE1(_T("In OCMSubComp::OnQueueFiles for %s"), GetSubCompID());

    TCHAR TargetSection[S_SIZE];
    BOOL bNoSection = FALSE;
    DWORD rc = GetTargetSection(TargetSection, S_SIZE, kFileSection, &bNoSection);

    //
    // if there is no section to be processed. just return success.
    //
    if (bNoSection)
    {
        return NO_ERROR;
    }


    if (rc == NO_ERROR)
    {
        LOGMESSAGE1(_T("Queuing Files from Section = %s"), TargetSection);
        if (!SetupInstallFilesFromInfSection(
            GetComponentInfHandle(),
            NULL,
            queue,
            TargetSection,
            NULL,
            0  // this should eliminate the warning about overwriting newer file.
            ))
        {
            rc = GetLastError();
            LOGMESSAGE2(_T("ERROR:OnQueueFileOps::SetupInstallFilesFromInfSection <%s> failed.GetLastError() = <%ul)"), TargetSection, rc);
        }
        else
        {
            return NO_ERROR;
        }

    }

    return rc;
}

DWORD OCMSubComp::OnCompleteInstall ()
{
	LOGMESSAGE1(_T("In OCMSubComp::OnCompleteInstall for %s"), GetSubCompID());
    if (!BeforeCompleteInstall ())
    {
        LOGMESSAGE0(_T("ERROR:BeforeCompleteInstall failed!"));
    }

    TCHAR TargetSection[S_SIZE];
    BOOL bNoSection = FALSE;
    DWORD dwError = GetTargetSection(TargetSection, S_SIZE, kRegistrySection, &bNoSection);

    //
    // if there is no section to be processed. just go ahead.
    //
    if (!bNoSection)
    {
        LOGMESSAGE1(_T("Setting up Registry/Links/RegSvrs from section =  %s"), TargetSection);
        dwError = SetupInstallFromInfSection(
            NULL,                                // hwndOwner
            GetComponentInfHandle(),             // inf handle
            TargetSection,                       //
            SPINST_ALL & ~SPINST_FILES,          // operation flags
            NULL,                                // relative key root
            NULL,                                // source root path
            0,                                   // copy flags
            NULL,                                // callback routine
            NULL,                                // callback routine context
            NULL,                                // device info set
            NULL                                 // device info struct
            );

        if (dwError == 0)
            LOGMESSAGE1(_T("ERROR:while installating section <%lu>"), GetLastError());
    }

    Tick();

    if (!AfterCompleteInstall ())
    {
        LOGMESSAGE0(_T("ERROR:AfterCompleteInstall failed!"));
    }

    TickComplete();
    return NO_ERROR;
}

BOOL OCMSubComp::BeforeCompleteInstall  ()
{
    return TRUE;
}

BOOL OCMSubComp::AfterCompleteInstall   ()
{
    return TRUE;
}

DWORD OCMSubComp::OnAboutToCommitQueue  ()
{
    return NO_ERROR;
}

void
OCMSubComp::SetupRunOnce( HINF hInf, LPCTSTR SectionName )
{
    INFCONTEXT  sic;
    TCHAR CommandLine[ RUNONCE_CMDBUFSIZE ];
    BOOL b;
    STARTUPINFO startupinfo;
    PROCESS_INFORMATION process_information;
    DWORD dwErr;

    if (!SetupFindFirstLine( hInf, SectionName, NULL , &sic))
    {
        LOGMESSAGE1(_T("WARNING: nothing in %s to be processed."), SectionName);
    }
    else
    {
        do  {
            if (!SetupGetStringField(&sic, 1, CommandLine, RUNONCE_CMDBUFSIZE, NULL))
            {
                LOGMESSAGE1(_T("WARNING: No command to be processed."), SectionName);
                break;
            }

            LOGMESSAGE1(_T("RunOnce: spawning process %s"), CommandLine);


            ZeroMemory( &startupinfo, sizeof(startupinfo) );
            startupinfo.cb = sizeof(startupinfo);
            startupinfo.dwFlags = STARTF_USESHOWWINDOW;
            startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

            b = CreateProcess( NULL,
                               CommandLine,
                               NULL,
                               NULL,
                               FALSE,
                               CREATE_DEFAULT_ERROR_MODE,
                               NULL,
                               NULL,
                               &startupinfo,
                               &process_information );
            if ( !b )
            {
                LOGMESSAGE1(_T("ERROR: failed to spawn %s process."), CommandLine);
                continue;
            }

            dwErr = WaitForSingleObject( process_information.hProcess, RUNONCE_DEFAULTWAIT );
            if ( dwErr != NO_ERROR )
            {
                LOGMESSAGE1(_T("ERROR: process %s failed to complete in time."), CommandLine);

                // Don't terminate process, just go on to next one.
            }
            else
            {
                LOGMESSAGE1(_T("INFO: process %s completed successfully."), CommandLine);
            }

            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
        } while ( SetupFindNextLine( &sic, &sic ) );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\subtoggle.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
*
*  SubToggle
*
*  A subcomponent class to toggle Terminal Services.
*
*/

#ifndef __TSOC__SUBTOGGLE_H__
#define __TSOC__SUBTOGGLE_H__

//
//  Includes
//

#include "subcomp.h"

//
//  Class Definition
//

class SubCompToggle : public OCMSubComp
{
public:
    
    virtual BOOL    BeforeCompleteInstall   ();
    virtual DWORD   GetStepCount            () const;
    virtual DWORD   OnQueryState            (UINT uiWhichState) const;
    virtual DWORD   OnQuerySelStateChange   (BOOL bNewState, BOOL bDirectSelection) const;
    
    BOOL    AfterCompleteInstall    ();
    
    LPCTSTR GetSectionToBeProcessed (ESections eSection) const;
    
    LPCTSTR GetSubCompID            () const;
    
    BOOL  ModifyWallPaperPolicy      ();
    BOOL  ModifyNFA                  ();
    BOOL  ApplyDefaultSecurity       ();
    BOOL  ApplyModeRegistry          ();
    BOOL  SetPermissionsMode         ();
    BOOL  ResetWinstationSecurity    ();
    BOOL  ApplySection               (LPCTSTR szSection);
    BOOL  ModifyAppPriority          ();
    BOOL  InformLicensingOfModeChange();
    BOOL  WriteLicensingMode         ();
    BOOL  UpdateMMDefaults           ();
    BOOL AddStartupPopup             ();
    BOOL WriteModeSpecificRegistry   ();
};

#endif // _SubToggle_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inc\conv.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    conv.h

Abstract:

    UNICODE / ASCII conversion macros

Author:

    Hakki T. Bostanci (hakkib) 5-Aug-1998

Revision History:

--*/

#ifndef USES_CONVERSION

// USES_CONVERSION must be defined in every function that uses the
// conversion macros

#define USES_CONVERSION int __nLength; PCWSTR __pUnicode; PCSTR __pAscii

//////////////////////////////////////////////////////////////////////////
//
// W2A
//
// Routine Description:
//   Converts a UNICODE string to ASCII. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          UNICODE string
//
// Return Value:
//   the converted ASCII string
//

#define W2A(pStr)								                \
												                \
	((__pUnicode = pStr) == 0 ? (PSTR) 0 : (	                \
												                \
	__nLength = WideCharToMultiByte(				            \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		0,										                \
		0,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pAscii = (PCSTR) _alloca(__nLength * sizeof(CHAR)),       \
												                \
	WideCharToMultiByte(						                \
		CP_ACP,									                \
		0,										                \
		__pUnicode,							                    \
		-1,										                \
		(PSTR) __pAscii,						                \
		__nLength,								                \
		0,										                \
		0										                \
	),											                \
												                \
	(PSTR) __pAscii))							                \


//////////////////////////////////////////////////////////////////////////
//
// A2W
//
// Routine Description:
//   Converts an ASCII string to UNICODE. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//	 pStr          ASCII string
//
// Return Value:
//   the converted UNICODE string
//

#define A2W(pStr)								                \
												                \
	((__pAscii = pStr) == 0 ? (PWSTR) 0 : (					    \
												                \
	__nLength = MultiByteToWideChar(				            \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		0,										                \
		0										                \
	),											                \
												                \
	__pUnicode = (PCWSTR) _alloca(__nLength * sizeof(WCHAR)),	\
												                \
	MultiByteToWideChar(						                \
		CP_ACP,									                \
		MB_PRECOMPOSED,							                \
		__pAscii,							                    \
		-1,										                \
		(PWSTR) __pUnicode,							            \
		__nLength									            \
	),											                \
												                \
	(PWSTR) __pUnicode))							            \

//////////////////////////////////////////////////////////////////////////
//
// T2A, A2T, T2W, W2T
//
// Routine Description:
//   These macros expand to the corresponding correct form according to the
//   #definition of UNICODE. 
//
//   We use the cryptic form (__nLength, __pAscii, __pUnicode, pStr) to avoid 
//   the compiler warning "symbol defined but not used" due to the variables 
//   defined in USES_CONVERSION macro.
//

#ifdef UNICODE
	#define T2A(pStr) W2A(pStr)
	#define A2T(pStr) A2W(pStr)
	#define T2W(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define W2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2DA(pStr) W2A(pStr)
	#define A2DT(pStr) A2W(pStr)
	#define T2DW(pStr) _wcsdupa(pStr)
	#define W2DT(pStr) _wcsdupa(pStr)
#else //UNICODE
	#define T2A(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define A2T(pStr) (__nLength, __pAscii, __pUnicode, pStr)
	#define T2W(pStr) A2W(pStr)
	#define W2T(pStr) W2A(pStr)
	#define T2DA(pStr) _strdupa(pStr)
	#define A2DT(pStr) _strdupa(pStr)
	#define T2DW(pStr) A2W(pStr)
	#define W2DT(pStr) W2A(pStr)
#endif //UNICODE


//////////////////////////////////////////////////////////////////////////
//
// _tcsdupa
//
// Routine Description:
//   Duplicates a string to a buffer allocated off the stack using _alloca
//
// Arguments:
//	 pStr          input string
//
// Return Value:
//   duplicated string
//

#define _wcsdupa(pStr)                                                  \
                                                                        \
    (__pAscii, (__pUnicode = pStr) == 0 ? (PWSTR) 0 : (                 \
                                                                        \
    __nLength = wcslen(__pUnicode) + 1,                                 \
                                                                        \
    wcscpy((PWSTR) _alloca(__nLength * sizeof(WCHAR)), __pUnicode)))    \


#define _strdupa(pStr)                                                  \
                                                                        \
    (__pUnicode, (__pAscii = pStr) == 0 ? (PSTR) 0 : (                  \
                                                                        \
    __nLength = strlen(__pAscii) + 1,                                   \
                                                                        \
    strcpy((PSTR) _alloca(__nLength * sizeof(CHAR)), __pAscii)))        \


#ifdef UNICODE 
#define _tcsdupa _wcsdupa
#else
#define _tcsdupa _strdupa
#endif


#endif //USES_CONVERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\users.cpp ===
#include "stdafx.h"

// #include <windows.h>
#include <lm.h>
#include <dsrole.h>

NET_API_STATUS GetDomainUsersSid(OUT PSID *ppSid);
DWORD GetWellKnownName(IN DWORD dwRID, OUT WCHAR **pszName);

/*****************************************************************************
 *
 *  RemoveAllFromRDUsersGroup
 *
 *   Removes all entries from "Remote Desktop Users" group
 *
 * ENTRY:
 *  none
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *
 *          
 *
 ****************************************************************************/
DWORD
RemoveAllFromRDUsersGroup()
{
    NET_API_STATUS Result,Result1;

    //Get "Remote Desktop Users" group name.
    //It may be different in different languages
    WCHAR *szRemoteGroupName = NULL;
    Result = GetWellKnownName(DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, &szRemoteGroupName);
    if(Result == NERR_Success)
    {
        //Copy members of "Users" group to "Remote Desktop Users" group
        PLOCALGROUP_MEMBERS_INFO_0 plmi0 = NULL;
        DWORD entriesread = 0;
        DWORD totalentries = 0;
        DWORD_PTR resumehandle = 0;

        do
        {
            Result = NetLocalGroupGetMembers(NULL,szRemoteGroupName,0,(LPBYTE *)&plmi0,
                            1000,&entriesread,
                            &totalentries,&resumehandle);

            if((Result == NERR_Success || Result == ERROR_MORE_DATA) &&
                entriesread)
            {
                for(DWORD i=0;i<entriesread;i++)
                {
                    //We have to add users one by one because of the stupid behaviour 
                    //of this function, not allowing to add users if some of them are already
                    //members of the group.
                    Result1 = NetLocalGroupDelMembers(NULL,szRemoteGroupName,0,(LPBYTE)&plmi0[i],1);
                    if(Result1 != ERROR_SUCCESS && Result1 != ERROR_MEMBER_IN_ALIAS)
                    {
                        LOGMESSAGE1(_T("NetLocalGroupDelMembers failed %d\n"),Result1);
                        break;
                    }
                }
                NetApiBufferFree(plmi0);
                if(Result1 != ERROR_SUCCESS && Result1 != ERROR_MEMBER_IN_ALIAS)
                {
                    Result = Result1;
                    break;
                }
            }

        }while (Result == ERROR_MORE_DATA);

        delete szRemoteGroupName;
    }
    else
    {
        LOGMESSAGE1(_T("GetWellKnownName(DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS) failed %d\n"),Result);
    }
    
    return Result;
}

/*****************************************************************************
 *
 *  CopyUsersGroupToRDUsersGroup
 *
 *   Copies all members of "Users" group to "Remote Desktop Users" group
 *
 * ENTRY:
 *  none
 *  
 *  
 * NOTES:
 * 
 *  
 * EXIT:
 *  Returns: 0 if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD 
CopyUsersGroupToRDUsersGroup()
{
    NET_API_STATUS Result,Result1;

    //Get real name of "Users" group
    //It may be different in different languages
    WCHAR *szUsersName = NULL;
    Result = GetWellKnownName(DOMAIN_ALIAS_RID_USERS, &szUsersName);
    if(Result != NERR_Success)
    {
        LOGMESSAGE1(_T("GetWellKnownName(DOMAIN_ALIAS_RID_USERS) failed %d\n"),Result);
        return Result;
    }
    
    //Get "Remote Desktop Users" group name.
    //It may be different in different languages
    WCHAR *szRemoteGroupName = NULL;
    Result = GetWellKnownName(DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS, &szRemoteGroupName);
    if(Result == NERR_Success)
    {
        //Copy members of "Users" group to "Remote Desktop Users" group
        PLOCALGROUP_MEMBERS_INFO_0 plmi0 = NULL;
        DWORD entriesread = 0;
        DWORD totalentries = 0;
        DWORD_PTR resumehandle = 0;

        do
        {
            Result = NetLocalGroupGetMembers(NULL,szUsersName,0,(LPBYTE *)&plmi0,
                            1000,&entriesread,
                            &totalentries,&resumehandle);

            if((Result == NERR_Success || Result == ERROR_MORE_DATA) &&
                entriesread)
            {
                for(DWORD i=0;i<entriesread;i++)
                {
                    //We have to add users one by one because of the stupid behaviour 
                    //of this function, not allowing to add users if some of them are already
                    //members of the group.
                    Result1 = NetLocalGroupAddMembers(NULL,szRemoteGroupName,0,(LPBYTE)&plmi0[i],1);
                    if(Result1 != ERROR_SUCCESS && Result1 != ERROR_MEMBER_IN_ALIAS)
                    {
                        LOGMESSAGE1(_T("NetLocalGroupAddMembers failed %d\n"),Result1);
                        break;
                    }
                }
                NetApiBufferFree(plmi0);
                if(Result1 != ERROR_SUCCESS && Result1 != ERROR_MEMBER_IN_ALIAS)
                {
                    Result = Result1;
                    break;
                }
            }

        }while (Result == ERROR_MORE_DATA);

        
        delete szRemoteGroupName;
    }
    else
    {
        LOGMESSAGE1(_T("GetWellKnownName(DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS) failed %d\n"),Result);
    }
    
    delete szUsersName;
    return Result;
}

/*****************************************************************************
 *
 *  GetWellKnownName
 *
 *   Returns a real name of any well-known account
 *
 * ENTRY:
 *    IN DWORD dwRID
 *    OUT WCHAR **pszName
 *  
 *  
 * NOTES:
 *   To free returned buffer use "delete" operator.
 *  
 * EXIT:
 *  Returns: NERR_Success if success, error code if failure
 *           
 *          
 *
 ****************************************************************************/
DWORD
GetWellKnownName( 
        IN DWORD dwRID,
        OUT WCHAR **pszName)
{
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    PSID pSid=NULL;
    
    if( !AllocateAndInitializeSid( &sia, 2,
              SECURITY_BUILTIN_DOMAIN_RID,
              dwRID, 
              0, 0, 0, 0, 0, 0,&pSid ) )
    {
        return GetLastError();
    }

    //Lookup name
    WCHAR *szDomainName = NULL;

    DWORD cName = MAX_PATH;
    DWORD cDomainName = MAX_PATH;
    SID_NAME_USE eUse;
    
    DWORD Result = NERR_Success;

    for(int i=0; i<2; i++)
    {
        Result = NERR_Success;

        *pszName = new WCHAR[cName];

        if(!(*pszName))
        {
            Result = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        szDomainName = new WCHAR[cDomainName];
        
        if(!szDomainName)
        {
            delete *pszName;
            *pszName = NULL;
            Result = ERROR_NOT_ENOUGH_MEMORY;
            break;
        }

        if(!LookupAccountSidW(NULL,pSid,
            *pszName,&cName,
            szDomainName,&cDomainName,
            &eUse))
        {
            delete *pszName;
            delete szDomainName;
            *pszName = NULL;
            szDomainName = NULL;

            Result = GetLastError();

            if(Result == ERROR_INSUFFICIENT_BUFFER)
            {
                continue;
            }
            else
            {
                break;
            }
        }
        
        break;
    }
    
    if(szDomainName)
    {
        delete szDomainName;
    }

    FreeSid(pSid);
    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\sysprep.cpp ===
#include "stdafx.h"
#include <SHlWapi.h>
#include "hydraoc.h"
#include "subcomp.h"
#include "secupgrd.h"
#include "lscsp.h"
#include "reglic.h"
#include "cryptkey.h"
//
// Define copy from newclient\inc\reglic.h
//
#define MSLICENSING_REG_KEY             _T("SOFTWARE\\Microsoft\\MSLicensing")

#define BETA_LICENSING_TIME_BOMB_5_1 L"L$BETA3TIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define RTM_LICENSING_TIME_BOMB_5_1 L"L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

typedef struct __SysPrepCmd {
    LPCTSTR pszFullExePath;
    LPCTSTR pszExeParm;
} SYSPREPCMD, *PSYSPREPCMD;

typedef DWORD (*PSETENTRIESINACL)(
  ULONG cCountOfExplicitEntries,           // number of entries
  PEXPLICIT_ACCESS pListOfExplicitEntries, // buffer
  PACL OldAcl,                             // original ACL
  PACL *NewAcl                             // new ACL
);


BOOL
AddACLToObjectSecurityDescriptor(
                                HANDLE hObject,
                                SE_OBJECT_TYPE ObjectType                                
                                 )
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID pAdminSid = NULL;
    PSID pSystemSid = NULL;
    PSID pPowerUsersSid = NULL;
    PSID pCreatorSid = NULL;
    PSID pUsersSid = NULL;
    PACL pNewDACL;

    DWORD                       dwError;
    BOOL                        bSuccess;

    DWORD                       i;

    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid = NULL;
    PSETENTRIESINACL            pSetEntriesInAcl = NULL;
    HMODULE                     pAdvApi32 = NULL;
    PFREESID_FN                 pFreeSid = NULL;

    PSETSECURITYINFO_FN pSetSecurityInfo;

    pAdvApi32 = LoadLibrary(ADVAPI_32_DLL);
    if (!pAdvApi32) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(pAdvApi32,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

#ifdef UNICODE
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclW" ));
#else
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclA" ));
#endif

    if (!pSetEntriesInAcl) {
        FreeLibrary( pAdvApi32 );
        return(FALSE);
    }

    EXPLICIT_ACCESS             ExplicitAccess[5];
    //
    // Create SIDs - Admins and System
    //

    bSuccess = pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pAdminSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pSystemSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_POWER_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pPowerUsersSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &CreatorAuthority,
                                                     1,
                                                     SECURITY_CREATOR_OWNER_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pCreatorSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid(&NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pUsersSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 5; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;
            ExplicitAccess[i].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;            
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }
        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)pAdminSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)pSystemSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)pCreatorSid;

        ExplicitAccess[3].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE;
        ExplicitAccess[3].Trustee.ptstrName = (LPTSTR)pPowerUsersSid;

        ExplicitAccess[4].grfAccessPermissions = GENERIC_READ;
        ExplicitAccess[4].Trustee.ptstrName = (LPTSTR)pUsersSid;

        dwError = (DWORD)pSetEntriesInAcl( 5,
                                           ExplicitAccess,
                                           NULL,
                                           &pNewDACL );        
        
        pSetSecurityInfo = (PSETSECURITYINFO_FN)GetProcAddress(pAdvApi32,SET_SECURITY_INFO);
        
        if (pSetSecurityInfo == NULL)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc SetSecurityInfo"));
            goto ErrorCleanup;
        }

        dwError = pSetSecurityInfo(
                    hObject,
                    ObjectType,
                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pNewDACL,
                    NULL
                    );
        
    }
ErrorCleanup:

    pFreeSid = (PFREESID_FN)
            GetProcAddress(pAdvApi32,
                           FREE_SID);

    if(pAdminSid)
        pFreeSid(pAdminSid);
    if(pSystemSid)
        pFreeSid(pSystemSid);
    if(pPowerUsersSid)
        pFreeSid(pPowerUsersSid);
    if(pCreatorSid)
        pFreeSid(pCreatorSid);
    if(pUsersSid)
        pFreeSid(pUsersSid);
    if(pNewDACL)
        LocalFree(pNewDACL);


    if(pAdvApi32)
        FreeLibrary( pAdvApi32 );

    return bSuccess;
}


BOOL
AddACLToStoreObjectSecurityDescriptor(
                                HANDLE hObject,
                                SE_OBJECT_TYPE ObjectType
                                 )
{
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY    CreatorAuthority = SECURITY_CREATOR_SID_AUTHORITY;
    PSID pAdminSid = NULL;
    PSID pSystemSid = NULL;
    PSID pPowerUsersSid = NULL;
    PSID pCreatorSid = NULL;
    PSID pUsersSid = NULL;
    PACL pNewDACL;

    DWORD                       dwError;
    BOOL                        bSuccess;

    DWORD                       i;

    PALLOCATEANDINITIALIZESID_FN pAllocateAndInitializeSid = NULL;
    PSETENTRIESINACL            pSetEntriesInAcl = NULL;    
    HMODULE                     pAdvApi32 = NULL;
    PFREESID_FN                 pFreeSid = NULL;
    PSETSECURITYINFO_FN pSetSecurityInfo;
    EXPLICIT_ACCESS             ExplicitAccess[6];

    pAdvApi32 = LoadLibrary(ADVAPI_32_DLL);
    if (!pAdvApi32) {
        return(FALSE);
    }

    pAllocateAndInitializeSid = (PALLOCATEANDINITIALIZESID_FN)
                                   GetProcAddress(pAdvApi32,
                                                  ALLOCATE_AND_INITITIALIZE_SID);
    if (pAllocateAndInitializeSid == NULL)
    {
        goto ErrorCleanup;
    }

#ifdef UNICODE
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclW" ));
#else
    pSetEntriesInAcl = reinterpret_cast<PSETENTRIESINACL>(GetProcAddress( pAdvApi32, "SetEntriesInAclA" ));
#endif

    if (!pSetEntriesInAcl) {
        FreeLibrary( pAdvApi32 );
        return(FALSE);
    }
    
    //
    // Create SIDs - Admins and System
    //

    bSuccess = pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_ADMINS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pAdminSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     1,
                                                     SECURITY_LOCAL_SYSTEM_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pSystemSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_POWER_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pPowerUsersSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid( &CreatorAuthority,
                                                     1,
                                                     SECURITY_CREATOR_OWNER_RID,
                                                     0, 0, 0, 0, 0, 0, 0,
                                                     &pCreatorSid);

    bSuccess = bSuccess && pAllocateAndInitializeSid(&NtAuthority,
                                                     2,
                                                     SECURITY_BUILTIN_DOMAIN_RID,
                                                     DOMAIN_ALIAS_RID_USERS,
                                                     0, 0, 0, 0, 0, 0,
                                                     &pUsersSid);

    if (bSuccess) {

        //
        // Initialize Access structures describing the ACEs we want:
        //  System Full Control
        //  Admins Full Control
        //
        // We'll take advantage of the fact that the unlocked private keys is
        // the same as the device parameters key and they are a superset of the
        // locked private keys.
        //
        // When we create the DACL for the private key we'll specify a subset of
        // the ExplicitAccess array.
        //
        for (i = 0; i < 6; i++) {
            ExplicitAccess[i].grfAccessMode = SET_ACCESS;              
            ExplicitAccess[i].Trustee.pMultipleTrustee = NULL;
            ExplicitAccess[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            ExplicitAccess[i].Trustee.TrusteeForm = TRUSTEE_IS_SID;
            ExplicitAccess[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
        }
        ExplicitAccess[0].grfAccessPermissions = KEY_ALL_ACCESS; 
        ExplicitAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[0].Trustee.ptstrName = (LPTSTR)pAdminSid;

        ExplicitAccess[1].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[1].Trustee.ptstrName = (LPTSTR)pSystemSid;

        ExplicitAccess[2].grfAccessPermissions = KEY_ALL_ACCESS;
        ExplicitAccess[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[2].Trustee.ptstrName = (LPTSTR)pCreatorSid;

        ExplicitAccess[3].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | DELETE;
        ExplicitAccess[3].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[3].Trustee.ptstrName = (LPTSTR)pPowerUsersSid;

        ExplicitAccess[4].grfAccessPermissions = GENERIC_READ | GENERIC_WRITE| KEY_CREATE_SUB_KEY |KEY_SET_VALUE;
        ExplicitAccess[4].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[4].Trustee.ptstrName = (LPTSTR)pUsersSid;

        ExplicitAccess[5].grfAccessPermissions = DELETE;
        ExplicitAccess[5].grfInheritance = INHERIT_ONLY_ACE | SUB_CONTAINERS_AND_OBJECTS_INHERIT;
        ExplicitAccess[5].Trustee.ptstrName = (LPTSTR)pUsersSid;

        dwError = (DWORD)pSetEntriesInAcl( 6,
                                           ExplicitAccess,
                                           NULL,
                                           &pNewDACL );
        
        pSetSecurityInfo = (PSETSECURITYINFO_FN)GetProcAddress(pAdvApi32,SET_SECURITY_INFO);
        
        if (pSetSecurityInfo == NULL)
        {
            OutputDebugString(_T("AddSidToObjectsSecurityDescriptor: Can't get proc SetSecurityInfo"));
            goto ErrorCleanup;
        }

        dwError = pSetSecurityInfo(
                    hObject,
                    ObjectType,
                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                    NULL,
                    NULL,
                    pNewDACL,
                    NULL
                    );
        
    }
ErrorCleanup:

    pFreeSid = (PFREESID_FN)
            GetProcAddress(pAdvApi32,
                           FREE_SID);

    if(pAdminSid)
        pFreeSid(pAdminSid);
    if(pSystemSid)
        pFreeSid(pSystemSid);
    if(pPowerUsersSid)
        pFreeSid(pPowerUsersSid);
    if(pCreatorSid)
        pFreeSid(pCreatorSid);
    if(pUsersSid)
        pFreeSid(pUsersSid);
    if(pNewDACL)
        LocalFree(pNewDACL);


    if(pAdvApi32)
        FreeLibrary( pAdvApi32 );

    return bSuccess;
}


BOOL CreateRegAddAcl(VOID)
{
    BOOL fRet = FALSE;
    DWORD dwDisposition, dwError = NO_ERROR;
    HKEY hKey = NULL, hKeyStore = NULL;

    dwError = RegCreateKeyEx(
                    HKEY_LOCAL_MACHINE,
                    MSLICENSING_REG_KEY,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKey,
                    &dwDisposition
                    );

    if (dwError != ERROR_SUCCESS) {
        return FALSE;
    }

    fRet = AddACLToObjectSecurityDescriptor(
                hKey,
                SE_REGISTRY_KEY
                );

    if (!fRet) {
        goto cleanup;
    }

    dwError = RegCreateKeyEx(
                    hKey,
                    MSLICENSING_STORE_SUBKEY,
                    0,
                    NULL,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hKeyStore,
                    &dwDisposition
                    );

    if (dwError != ERROR_SUCCESS) {
        fRet = FALSE;
        goto cleanup;
    }

    fRet = AddACLToStoreObjectSecurityDescriptor(
                hKeyStore,
                SE_REGISTRY_KEY
                );

cleanup:
    if (NULL != hKey)
    {
        RegCloseKey( hKey );
    }

    if (NULL != hKeyStore)
    {
        RegCloseKey( hKeyStore );
    }

    return fRet;
}

BOOL
CreateAndWriteHWID(VOID)
{    
    BOOL fRet = FALSE;
    DWORD dwDisposition, dwError = NO_ERROR;
    HKEY hKey = NULL;
    HWID hwid;

    // Write HWID to registry

    dwError = RegCreateKeyEx(
                             HKEY_LOCAL_MACHINE,
                             MSLICENSING_HWID_KEY,
                             0,
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisposition
                             );

    if (dwError != ERROR_SUCCESS) {
        goto cleanup;
    }

    // generate HWID

    if (LICENSE_STATUS_OK == GenerateClientHWID(&hwid))
    {

        dwError = RegSetValueEx(hKey,
                                MSLICENSING_HWID_VALUE,
                                0,
                                REG_BINARY,
                                (LPBYTE)&hwid,
                                sizeof(HWID));
        
        if (dwError != ERROR_SUCCESS) {
            goto cleanup;
        }
    }

    fRet = TRUE;
    

cleanup:
    if (NULL != hKey)
    {
        RegCloseKey( hKey );
    }

    return fRet;
}


BOOL SetupMSLicensingKey()
{
    OSVERSIONINFOA OsVer;
    memset(&OsVer, 0x0, sizeof(OSVERSIONINFOA));
    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&OsVer);

    if (VER_PLATFORM_WIN32_NT == OsVer.dwPlatformId)  //It should be Windows NT
    {
        if(CreateRegAddAcl())
        {
            // generate and write the HWID
            if (CreateAndWriteHWID())
            {
                return TRUE;
            }          
        }
    }
    return FALSE;
}



SYSPREPCMD sysPrepBackupCmd[] = { {_T("%windir%\\system32\\sessmgr.exe"), _T("-unregserver")} };
DWORD numSysPrepBackupCmd = sizeof(sysPrepBackupCmd) / sizeof(sysPrepBackupCmd[0]);
 
SYSPREPCMD sysPrepRestoreCmd[] = { {_T("%windir%\\system32\\sessmgr.exe"), _T("-service")} };
DWORD numSysPrepRestoreCmd = sizeof(sysPrepRestoreCmd) / sizeof(sysPrepRestoreCmd[0]);

class CNameSIDList : public list<CNameSID>
{
public:
    BOOL Save(HKEY hKey);
    BOOL LoadAndDelete(HKEY hKey);
    BOOL Find(PSID pSid, LPCWSTR *pwszName);
    void AddIfNotExist(CNameSID &NameSID);
};

DWORD
BackupTSCustomSercurity();

DWORD
RestoreTSCustomSercurity();

DWORD 
GetLocalSIDs(
        IN PSECURITY_DESCRIPTOR pSD, 
        IN OUT CNameSIDList &NameSIDList);

DWORD 
RenewLocalSIDs(
        IN OUT PSECURITY_DESCRIPTOR &pSD, 
        IN OUT CNameSIDList &NameSIDList);

DWORD
ResetTSPublicPrivateKeys();

BOOL 
CNameSIDList::Save(HKEY hKey)
{
    BOOL bResult = FALSE;
    CNameSIDList::iterator it;
    //
    //calc the size of the buffer we need
    //
    DWORD dwBufSize = 0;
    LPCWSTR wszTmp1,wszTmp2;
    for(it=begin();it!=end(); it++)
    {
        wszTmp1 = (*it).GetName();
        wszTmp2 = (*it).GetTextSID();
        if(wszTmp1 && wszTmp2)
        {
            dwBufSize += (wcslen(wszTmp1)+wcslen(wszTmp2)+2)*sizeof(WCHAR); 
        }
    }
    //
    //for second terminating 0.
    //
    dwBufSize += sizeof(WCHAR);
    //
    //Allocate buffer (this will also zeroinit it).
    //
    LPWSTR wszBuf = (LPWSTR)LocalAlloc(LPTR,dwBufSize);
    DWORD dwPos = 0;
    if(wszBuf)
    {
        //
        //Fill buffer with data
        //
        for(it=begin();it!=end(); it++)
        {
            wszTmp1 = (*it).GetName();
            wszTmp2 = (*it).GetTextSID();
            if(wszTmp1 && wszTmp2)
            {
                wcscpy(wszBuf+dwPos,wszTmp1);
                dwPos += wcslen(wszTmp1)+1; 
                wcscpy(wszBuf+dwPos,wszTmp2);
                dwPos += wcslen(wszTmp2)+1; 
            }
        }
        //
        //Save data in the registry
        //
        if(dwPos && RegSetValueExW(hKey,L"BackupSids",0,REG_MULTI_SZ,
                (CONST BYTE *)wszBuf,dwBufSize)==ERROR_SUCCESS)
        {
            bResult = TRUE;
        }

        LocalFree(wszBuf);
    }
    

    return bResult;
}

BOOL 
CNameSIDList::LoadAndDelete(HKEY hKey)
{
    BOOL bResult = FALSE;
    DWORD err;
    DWORD ValueSize = 0;
    DWORD ValueType = 0;
    
    //Get the name of this computer
    //We will add it to every user's name, 
    //to avoid confusion with global users.
    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD cComputerName = MAX_COMPUTERNAME_LENGTH + 1;
    
    if(!GetComputerNameW(wszComputerName, &cComputerName))
    {
        return FALSE;
    }

    err = RegQueryValueExW( hKey, L"BackupSids", NULL, &ValueType, NULL, &ValueSize );

    if(err == ERROR_SUCCESS && ValueType == REG_MULTI_SZ && ValueSize)
    {

        LPWSTR wszBuf = (LPWSTR)LocalAlloc(LPTR,ValueSize);

        if ( wszBuf )
        {

            err = RegQueryValueExW( hKey, L"BackupSids", NULL, &ValueType,
                        (BYTE *) wszBuf, &ValueSize );
            
            RegDeleteValueW(hKey,L"BackupSids");

            if(err == ERROR_SUCCESS )
            {
                LPCWSTR wszTmp1,wszTmp2;
                DWORD dwPos = 0,dwMaxPos = ValueSize/sizeof(WCHAR);
                while(dwPos < dwMaxPos)
                {
                    wszTmp1 = wszBuf + dwPos;
                    dwPos += wcslen(wszTmp1) + 1;
                    wszTmp2 = wszBuf + dwPos;
                    dwPos += wcslen(wszTmp2) + 1;
                    
                    PSID pSid;
                    if(ConvertStringSidToSidW(wszTmp2,&pSid))
                    {
                        LPWSTR wszUserName = (LPWSTR) LocalAlloc(LPTR, 
                            (wcslen(wszTmp1) + cComputerName + 2)*sizeof(WCHAR));

                        if(!wszUserName)
                        {
                            LocalFree(pSid);
                            LocalFree(wszBuf);
                            return FALSE;
                        }

                        wcsncpy(wszUserName, wszComputerName, cComputerName);
                        wcscat(wszUserName, L"\\");
                        wcscat(wszUserName, wszTmp1);

                        try
                        {
                            CNameSID NameSID(wszUserName,pSid);
                            push_back(NameSID);
                        }
                        catch(DWORD Except)
                        {
                            LocalFree(pSid);
                            LocalFree(wszUserName);
                            LocalFree(wszBuf);
                            return FALSE;
                        }
                        
                        LocalFree(pSid);
                        LocalFree(wszUserName);
                    }
                }
                
                bResult = TRUE;
            }
            
            LocalFree(wszBuf);
        }

    }

    return bResult;
}

BOOL 
CNameSIDList::Find(PSID pSid, LPCWSTR *pwszName)
{
    *pwszName = NULL;

    CNameSIDList::iterator it;
    
    for(it=begin();it!=end(); it++)
    {
        if(EqualSid(pSid,(*it).GetSID()))
        {
            *pwszName = (*it).GetName();
            return TRUE;
        }
    }
    
    return FALSE;
}

void 
CNameSIDList::AddIfNotExist(CNameSID &NameSID)
{
    LPCWSTR wszName;
    if(!Find(NameSID.GetSID(),&wszName))
    {
        push_back(NameSID);
    }
}

VOID
RunSysPrepCommands( PSYSPREPCMD pszCmds )
{
    STARTUPINFO startupinfo;
    PROCESS_INFORMATION process_information;
    BOOL bSuccess;
    DWORD dwErr;
    TCHAR pszCommand[ MAX_PATH + 1 ];
    TCHAR pszParm[ MAX_PATH + 1 ];
    DWORD nExpandedExeName;


    try {
        //
        // CreateProcessW() will fail if lpCommandLine is a const string 
        // AV if it is actually point to LPCTSTR.
        //
        nExpandedExeName = ExpandEnvironmentStrings( 
                                            pszCmds->pszFullExePath, 
                                            pszCommand,    
                                            sizeof(pszCommand) / sizeof(pszCommand[0]) 
                                            );
        if( 0 == nExpandedExeName || nExpandedExeName >= sizeof(pszCommand) / sizeof(pszCommand[0]) )
        {
            // can't expand full path exe name or expanded string has too many
            // chars, bail out
            LOGMESSAGE0(_T("Can't expand environment string.") );
            return;
        }


        lstrcpy( pszParm, pszCmds->pszExeParm );

        ZeroMemory( &startupinfo, sizeof(startupinfo) );
        startupinfo.cb = sizeof(startupinfo);
        startupinfo.dwFlags = STARTF_USESHOWWINDOW;
        startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

        LOGMESSAGE2(_T("Running command %s %s"), pszCmds, pszParm);
	    	
        bSuccess = CreateProcess( pszCommand,
                               pszParm,
                               NULL,
                               NULL,
                               FALSE,
                               CREATE_DEFAULT_ERROR_MODE,
                               NULL,
                               NULL,
                               &startupinfo,
                               &process_information );
        if ( !bSuccess )
        {
            LOGMESSAGE2(_T("ERROR: failed to spawn %s %s process."), pszCommand, pszParm);
        }
        else
        {
            dwErr = WaitForSingleObject( process_information.hProcess, RUNONCE_DEFAULTWAIT );
            if ( dwErr != NO_ERROR )
            {
                LOGMESSAGE2(_T("ERROR: process %s %s failed to complete in time."), pszCommand, pszParm);
            }
            else
            {
                LOGMESSAGE2(_T("INFO: process %s %s completed successfully."), pszCommand, pszParm);
            }

            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
        }
    }
    catch(...) {
        LOGMESSAGE0(_T("Command caused exception.") );
    }

    return;
}


__declspec( dllexport )
VOID
SysPrepBackup( void )
{
    DWORD dwIndex;
    TCHAR szLogFile[MAX_PATH + 1];

    ZeroMemory(szLogFile, sizeof(szLogFile));

    ExpandEnvironmentStrings(LOGFILE, szLogFile, MAX_PATH);
    LOGMESSAGEINIT(szLogFile, MODULENAME);

    LOGMESSAGE0( _T("Entering SysPrepBackup") );

    for(dwIndex = 0; dwIndex < numSysPrepBackupCmd; dwIndex++ )
    {
        RunSysPrepCommands( &sysPrepBackupCmd[dwIndex] );
    }
    
    DWORD err = BackupTSCustomSercurity();
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: BackupTSCustomSercurity() FAILED: %d"),err );
    }

    LOGMESSAGE0( _T("SysPrepBackup completed") );
}

__declspec( dllexport )
VOID
SysPrepRestore( void )
{
    DWORD dwIndex;
    TCHAR szLogFile[MAX_PATH + 1];
    
    ZeroMemory( szLogFile, sizeof(szLogFile) );

    ExpandEnvironmentStrings(LOGFILE, szLogFile, MAX_PATH);

    LOGMESSAGEINIT(szLogFile, MODULENAME);

    LOGMESSAGE0( _T("Entering SysPrepRestore") );

    for(dwIndex = 0; dwIndex < numSysPrepRestoreCmd; dwIndex++ )
    {
        RunSysPrepCommands( &sysPrepRestoreCmd[dwIndex]  );
    }
    
    DWORD err = RestoreTSCustomSercurity();
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: RestoreTSCustomSercurity() FAILED: %d"),err );
    }

    err = ResetTSPublicPrivateKeys();
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: ResetTSPublicPrivateKeys() FAILED: %d"),err );
    }

    //
    // This can be done at SysPrep time instead of SysRestore time; however, sysprep
    // might support back out sysprep so we delay deleting licensing key at restore time,
    // also, to keep it consistent with ResetTSPublicPrivateKey().
    //
    err = SHDeleteKey( HKEY_LOCAL_MACHINE, MSLICENSING_REG_KEY );

    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: Deleting MSLicensing key FAILED: %d"),err );
    }
    
    err = SetupMSLicensingKey();

    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: SetupMSLicensingKey() FAILED: %d"),err );
    }

    LOGMESSAGE0( _T("SysPrepRestore completed") );
}

//*************************************************************
//
//  BackupTSCustomSercurity()
//
//  Purpose:    Creates a list of all local SIDs and 
//              corresponding names included in WinStation's 
//              security descriptors, and saves it 
//              in the registry.
//
//  Parameters: NONE
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise   
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD
BackupTSCustomSercurity()
{
    HKEY hKey;
    DWORD err;
    //
    //Open "SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations" key
    //
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), 
        0,KEY_READ|KEY_WRITE, &hKey );
    
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: BackupTSCustomSercurity - RegOpenKeyEx FAILED: %d"),err );
        return err;
    }
    
    
    CNameAndSDList NameSDList; //List of security descriptors
    CNameSIDList NameSIDList;  //List of local SIDs

    err=EnumWinStationSecurityDescriptors( hKey, &NameSDList);

    if(err == ERROR_SUCCESS)
    {
        CNameAndSDList::iterator it;
            
        for(it=NameSDList.begin();it!=NameSDList.end(); it++)
        {
            //
            //If SD was not customized in most cases it is NULL
            //
            if((*it).m_pSD)
            {
                err = GetLocalSIDs((*it).m_pSD, NameSIDList);

                if(err != ERROR_SUCCESS)
                {
                    LOGMESSAGE2(_T("ERROR: GetLocalSIDs for  %s FAILED: %d"), (*it).m_pName, err );
                    break;
                }
            }
        }
        
        if(err == ERROR_SUCCESS)
        {
            if(!NameSIDList.Save(hKey))
            {
                LOGMESSAGE0(_T("ERROR: BackupTSCustomSercurity - NameSIDList.Save FAILED"));
                err = ERROR_FILE_NOT_FOUND;
            }
        }
    }
    else
    {
        LOGMESSAGE1(_T("ERROR: RestoreTSCustomSercurity - ")
            _T("EnumWinStationSecurityDescriptors FAILED: %d"),err );
    }
    
    RegCloseKey(hKey);

    return err;
}

//*************************************************************
//
//  RestoreTSCustomSercurity()
//
//  Purpose:    Gets a list of local SIDs and corresponding names 
//              (saved by BackupTSCustomSercurity)
//              from the registry and updates all WinStation's 
//              security descriptors with new SID for each  
//              local account.
//
//  Parameters: NONE
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD
RestoreTSCustomSercurity()
{
    HKEY hKey;
    DWORD err;
    //
    //Open "SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations" key
    //
    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), 
        0,KEY_READ|KEY_WRITE, &hKey );
    
    if(err != ERROR_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: RestoreTSCustomSercurity - RegOpenKeyEx FAILED: %d"),err );
        return err;
    }
    
    
    CNameAndSDList NameSDList; //List of security descriptors
    CNameSIDList NameSIDList;  //List of local SIDs
    
    //Now load
    if(!NameSIDList.LoadAndDelete(hKey))
    {
        LOGMESSAGE0(_T("ERROR: RestoreTSCustomSercurity - NameSIDList.LoadAndDelete FAILED"));
        RegCloseKey(hKey);
        return ERROR_FILE_NOT_FOUND;
    }

    err=EnumWinStationSecurityDescriptors( hKey, &NameSDList);
    
    if(err == ERROR_SUCCESS)
    {
        CNameAndSDList::iterator it;
            
        for(it=NameSDList.begin();it!=NameSDList.end(); it++)
        {
            //
            //If SD was not customized in most cases it is NULL
            //
            if((*it).m_pSD)
            {
                err = RenewLocalSIDs((*it).m_pSD, NameSIDList);

                if(err == ERROR_SUCCESS)
                {
                    err = SetWinStationSecurity( hKey, (*it).m_pName, (*it).m_pSD );

                    if(err !=ERROR_SUCCESS)
                    {
                        LOGMESSAGE2(_T("ERROR: SetWinStationSecurity for  %s FAILED: %d"),
                            (*it).m_pName, err );
                        break;
                    }
                }
                else
                {
                    LOGMESSAGE2(_T("ERROR: RenewLocalSIDs for  %s FAILED: %d"), 
                        (*it).m_pName, err );
                    break;
                }
            }
        }
        
    }
    else
    {
        LOGMESSAGE1(_T("ERROR: RestoreTSCustomSercurity - ")
            _T("EnumWinStationSecurityDescriptors FAILED: %d"),err );
    }
    
    RegCloseKey(hKey);

    return err;
}

//*************************************************************
//
//  GetLocalSIDs()
//
//  Purpose:    Gets local SIDs from a security descriptor 
//              and puts them in the list
//
//  Parameters: 
//              IN PSECURITY_DESCRIPTOR pSD, 
//              IN OUT CNameSIDList &NameSIDList
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************
DWORD 
GetLocalSIDs(
        IN PSECURITY_DESCRIPTOR pSD, 
        IN OUT CNameSIDList &NameSIDList)
{
    PACL pDacl;
    PACL pSacl;
    DWORD dwResult;
    
    DWORD cEntries = 0;
    
    dwResult = GetDacl(pSD,&pDacl);

    if(dwResult != ERROR_SUCCESS)
    {
        return dwResult;
    }
    
    dwResult = GetSacl(pSD,&pSacl);

    if(dwResult != ERROR_SUCCESS)
    {
        return dwResult;
    }
    
    DWORD dwCompNameSize = MAX_COMPUTERNAME_LENGTH + 1;
    WCHAR wszComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    
    if(!GetComputerNameW(wszComputerName, &dwCompNameSize))
    {
        return GetLastError();
    }


    ACL_SIZE_INFORMATION asiAclSize; 
    DWORD dwBufLength=sizeof(asiAclSize);
    ACCESS_ALLOWED_ACE *pAllowedAce; 
    SYSTEM_AUDIT_ACE *pSystemAce;
    DWORD dwAcl_i;
    LPWSTR wszName;
    SID_NAME_USE eUse;

    if(pDacl)
    {
        if (GetAclInformation(pDacl, 
                (LPVOID)&asiAclSize, 
                (DWORD)dwBufLength, 
                (ACL_INFORMATION_CLASS)AclSizeInformation)) 
        { 
            for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
            { 
                
                if(GetAce( pDacl, dwAcl_i, (LPVOID *)&pAllowedAce)) 
                {
                    if(LookupSid((PSID)&(pAllowedAce->SidStart),&wszName,&eUse))
                    {
                        if(IsLocal(wszComputerName, wszName))
                        {
                            try 
                            {
                                NameSIDList.AddIfNotExist(CNameSID(wszName,
                                    (PSID)&(pAllowedAce->SidStart)));
                            }
                            catch(DWORD Except)
                            {
                                LocalFree(wszName);
                                return Except;
                            }
                        }

                        LocalFree(wszName);
                    }
                        
                }
            }
        }
    }
    
    if(pSacl)
    {
        if (GetAclInformation(pSacl, 
                (LPVOID)&asiAclSize, 
                (DWORD)dwBufLength, 
                (ACL_INFORMATION_CLASS)AclSizeInformation)) 
        { 
            for (dwAcl_i = 0; dwAcl_i < asiAclSize.AceCount; dwAcl_i++) 
            { 
                
                if(GetAce( pSacl, dwAcl_i, (LPVOID *)&pSystemAce)) 
                {
                    if(LookupSid((PSID)&(pSystemAce->SidStart),&wszName,&eUse))
                    {
                        if(IsLocal(wszComputerName, wszName))
                        {
                            try
                            {
                                NameSIDList.AddIfNotExist(CNameSID(wszName,
                                    (PSID)&(pSystemAce->SidStart)));
                            }
                            catch(DWORD Except)
                            {
                                LocalFree(wszName);
                                return Except;
                            }
                        }

                        LocalFree(wszName);
                    }
                        
                }
            }
        }
    }

    return ERROR_SUCCESS;
}


//*************************************************************
//
//  RenewLocalSIDs()
//
//  Purpose:    Replaces all the local SIDs in a security 
//              descriptor with the new ones.
//
//  Parameters: 
//              IN OUT PSECURITY_DESCRIPTOR &pSD, 
//              IN OUT CNameSIDList &NameSIDList
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              03/13/01    skuzin     Created
//
//*************************************************************

DWORD 
RenewLocalSIDs(
        IN OUT PSECURITY_DESCRIPTOR &pSD, 
        IN OUT CNameSIDList &NameSIDList)
{
    PSECURITY_DESCRIPTOR pAbsoluteSD = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    PSID pOwner = NULL;
    PSID pPrimaryGroup = NULL;
    DWORD dwResult;
    
    dwResult = GetAbsoluteSD(
                    pSD,
                    &pAbsoluteSD,
                    &pDacl,
                    &pSacl,
                    &pOwner,
                    &pPrimaryGroup);

    if(dwResult != ERROR_SUCCESS)
    {
        return dwResult;
    }

    ULONG cEntries;
    PEXPLICIT_ACCESS_W pListOfEntries;
    LPCWSTR wszName;
    PACL pNewDacl = NULL, pNewSacl = NULL;

    __try
    {
        if(pDacl)
        {
            dwResult = GetExplicitEntriesFromAclW(pDacl, &cEntries, &pListOfEntries);

            if(dwResult != ERROR_SUCCESS)
            {
                return dwResult;
            }

            for(ULONG i=0;i<cEntries;i++)
            {
                if(pListOfEntries[i].Trustee.TrusteeForm == TRUSTEE_IS_SID &&
                    NameSIDList.Find((PSID)pListOfEntries[i].Trustee.ptstrName, &wszName))
                {
                    pListOfEntries[i].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
                    pListOfEntries[i].Trustee.ptstrName = const_cast<LPWSTR>(wszName);
                }
            }

            dwResult = SetEntriesInAclW(cEntries,pListOfEntries,NULL,&pNewDacl);
            
            LocalFree(pListOfEntries);

            if(dwResult != ERROR_SUCCESS)
            {
                return dwResult;
            }

            if(!SetSecurityDescriptorDacl(pAbsoluteSD,TRUE,pNewDacl,FALSE))
            {
                return GetLastError();
            }
        }
    
        if(pSacl)
        {
            dwResult = GetExplicitEntriesFromAclW(pSacl, &cEntries, &pListOfEntries);

            if(dwResult != ERROR_SUCCESS)
            {
                return dwResult;
            }

            for(ULONG i=0;i<cEntries;i++)
            {
                if(pListOfEntries[i].Trustee.TrusteeForm == TRUSTEE_IS_SID &&
                    NameSIDList.Find((PSID)pListOfEntries[i].Trustee.ptstrName, &wszName))
                {
                    pListOfEntries[i].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
                    pListOfEntries[i].Trustee.ptstrName = const_cast<LPWSTR>(wszName);
                }
            }

            dwResult = SetEntriesInAclW(cEntries,pListOfEntries,NULL,&pNewSacl);
            
            LocalFree(pListOfEntries);

            if(dwResult != ERROR_SUCCESS)
            {
                return dwResult;
            }

            if(!SetSecurityDescriptorSacl(pAbsoluteSD,TRUE,pNewSacl,FALSE))
            {
                return GetLastError();
            }
        }
        
        PSECURITY_DESCRIPTOR pTmpSD;

        dwResult = GetSelfRelativeSD(pAbsoluteSD,&pTmpSD);

        if(dwResult != ERROR_SUCCESS)
        {
            return dwResult;
        }

        LocalFree(pSD);
        pSD = pTmpSD;

    }
    __finally
    {
        if(pAbsoluteSD)
        {
            LocalFree(pAbsoluteSD);
        }
        if(pDacl)
        {
            LocalFree(pDacl);
        }
        if(pSacl)
        {
            LocalFree(pSacl);
        }
        if(pOwner)
        {
            LocalFree(pOwner);
        }
        if(pPrimaryGroup)
        {
            LocalFree(pPrimaryGroup);
        }
        if(pNewDacl)
        {
            LocalFree(pNewDacl);
        }
        if(pNewSacl)
        {
            LocalFree(pNewSacl);
        }

    }

    return ERROR_SUCCESS;
}


//*************************************************************
//
//  ResetTSPublicPrivateKeys()
//
//  Purpose:    Deletes keys from LSA secret, so that sysprep'd
//              machines don't share the same keys
//
//  Parameters: NONE
//
//  Return:     error code if fails, ERROR_SUCCESS otherwise   
//
//  Comments:   
//
//  History:    Date        Author     Comment
//              06/12/01    robleit    Created
//
//*************************************************************
DWORD
ResetTSPublicPrivateKeys()
{
    LSA_HANDLE
        PolicyHandle;
    UNICODE_STRING
        SecretKeyName;
    DWORD
        Status;

    LOGMESSAGE0(_T("INFO: Starting ResetTSPublicPrivateKeys.") );

    Status = OpenPolicy( NULL, POLICY_CREATE_SECRET, &PolicyHandle );

    if( ERROR_SUCCESS != Status )
    {
        return LsaNtStatusToWinError(Status);
    }

    SecretKeyName.Buffer = PRIVATE_KEY_NAME;
    SecretKeyName.Length = sizeof(PRIVATE_KEY_NAME) - sizeof(WCHAR);
    SecretKeyName.MaximumLength = sizeof(PRIVATE_KEY_NAME) ;

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                NULL
                );

    if (Status != STATUS_SUCCESS)
    {
        LOGMESSAGE1(_T("ERROR: ResetTSPublicPrivateKeys() FAILED to delete private key: %d"),Status );
    }

    SecretKeyName.Buffer = X509_CERT_PRIVATE_KEY_NAME;
    SecretKeyName.Length = sizeof(X509_CERT_PRIVATE_KEY_NAME) - sizeof(WCHAR);
    SecretKeyName.MaximumLength = sizeof(X509_CERT_PRIVATE_KEY_NAME);

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                NULL
                );

    if (Status != STATUS_SUCCESS)
    {
        LOGMESSAGE1(_T("WARNING: ResetTSPublicPrivateKeys() FAILED to delete X509 private key: %d"),Status );
    }

    SecretKeyName.Buffer = X509_CERT_PUBLIC_KEY_NAME;
    SecretKeyName.Length = sizeof(X509_CERT_PUBLIC_KEY_NAME) - sizeof(WCHAR);
    SecretKeyName.MaximumLength = sizeof(X509_CERT_PUBLIC_KEY_NAME);

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                NULL
                );

    if (Status != STATUS_SUCCESS)
    {
        LOGMESSAGE1(_T("WARNING: ResetTSPublicPrivateKeys() FAILED to delete X509 public key: %d"),Status );
    }


    SecretKeyName.Buffer = BETA_LICENSING_TIME_BOMB_5_1;
    SecretKeyName.Length = sizeof(BETA_LICENSING_TIME_BOMB_5_1) - sizeof(WCHAR);
    SecretKeyName.MaximumLength = sizeof(BETA_LICENSING_TIME_BOMB_5_1);

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                NULL
                );

    if (Status != STATUS_SUCCESS)
    {
        LOGMESSAGE1(_T("WARNING: ResetTSPublicPrivateKeys() FAILED to delete BETA_LICENSING_TIME_BOMB_5_1 key: %d"),Status );
    }

    SecretKeyName.Buffer = RTM_LICENSING_TIME_BOMB_5_1;
    SecretKeyName.Length = sizeof(RTM_LICENSING_TIME_BOMB_5_1) - sizeof(WCHAR);
    SecretKeyName.MaximumLength = sizeof(RTM_LICENSING_TIME_BOMB_5_1);

    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                NULL
                );

    if (Status != STATUS_SUCCESS)
    {
        LOGMESSAGE1(_T("WARNING: ResetTSPublicPrivateKeys() FAILED to delete RTM_LICENSING_TIME_BOMB_5_1 key: %d"),Status );
    }

    LsaClose( PolicyHandle );

    Status = LsaNtStatusToWinError( Status );

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\util.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Util.h
 *
 *  Utility routines.
 *
 */

#ifndef __TSOC_UTIL_H__
#define __TSOC_UTIL_H__

//
//  Includes
//

#include "stdafx.h"

//
//  Function prototypes
//

VOID
DestroyExtraRoutines(
    VOID
    );

VOID
DestroySetupData(
    VOID
    );

BOOL
DoMessageBox(
    UINT uiMsg,
    UINT uiCaption,
    UINT Style
    );

HINF
GetComponentInfHandle(
    VOID
    );

OCMANAGER_ROUTINES
GetHelperRoutines(
    VOID
    );

HINSTANCE
GetInstance(
    VOID
    );

PSETUP_INIT_COMPONENT
GetSetupData(
    VOID
    );

HINF
GetUnAttendedInfHandle(
    VOID
    );

VOID
LogErrorToEventLog(
    WORD wType,
    WORD wCategory,
    DWORD dwEventId,
    WORD wNumStrings,
    DWORD dwDataSize,
    LPCTSTR *lpStrings,
    LPVOID lpRawData
    );

VOID
LogErrorToSetupLog(
    OcErrorLevel ErrorLevel,
    UINT uiMsg
    );

VOID
SetInstance(
    HINSTANCE hInstance
    );

VOID
SetProgressText(
    UINT uiMsg
    );

BOOL
SetReboot(
    VOID
    );

BOOL
SetExtraRoutines(
    PEXTRA_ROUTINES pExtraRoutines
    );

BOOL
SetSetupData(
    PSETUP_INIT_COMPONENT pSetupData
    );

BOOL Delnode( IN LPCTSTR  Directory );

DWORD StoreSecretKey(PWCHAR  pwszKeyName, BYTE *  pbKey, DWORD   cbKey );

DWORD OpenPolicy(LPWSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle );

void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String );

#endif // __TSOC_UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\vermak.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server Optional Component Setup"
#define VER_INTERNALNAME_STR        "tsoc"
#define VER_ORIGINALFILENAME_STR    "tsoc.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\dll\util.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Util.cpp
 *
 *  Utility routines.
 *
 */

//
//  Includes
//

#include "stdafx.h"
#include "hydraoc.h"


//
//  Globals
//

HINSTANCE               ghInstance          = NULL;
PEXTRA_ROUTINES         gpExtraRoutines     = NULL;
// PSETUP_INIT_COMPONENT   gpInitComponentData = NULL;

//
//  Function Definitions
//

VOID
DestroyExtraRoutines(
    VOID
    )
{
    if (gpExtraRoutines != NULL) {
        LocalFree(gpExtraRoutines);
    }
}


int
DoMessageBox(
    UINT uiMsg, UINT uiCaption, UINT Style
    )
{
    TCHAR strMsg[1024];
    TCHAR strTitle[1024];

    ASSERT(!StateObject.IsUnattended());

    if ((LoadString(GetInstance(), uiCaption, strTitle, 1024) != 0) &&
        (LoadString(GetInstance(), uiMsg, strMsg, 1024) != 0))
    {
        return MessageBox(
            GetHelperRoutines().QueryWizardDialogHandle(GetHelperRoutines().OcManagerContext),
            strMsg,
            strTitle,
            Style
            );

    }

    return(IDCANCEL);
}

/*
BOOL
DoMessageBox(
    UINT uiMsg
    )
{
    TCHAR strMsg[1024];
    TCHAR strTitle[1024];

    ASSERT(!StateObject.IsUnattended());

    if ((LoadString(GetInstance(), IDS_STRING_MESSAGE_BOX_TITLE, strTitle, 1024) != 0) &&
        (LoadString(GetInstance(), uiMsg, strMsg, 1024) != 0))
    {
        MessageBox(
            GetHelperRoutines().QueryWizardDialogHandle(GetHelperRoutines().OcManagerContext),
            strMsg,
            strTitle,
            MB_OK
            );

        return(TRUE);
    }

    return(FALSE);
}
*/

HINF
GetComponentInfHandle(
    VOID
    )
{
    if (INVALID_HANDLE_VALUE == GetSetupData()->ComponentInfHandle) {
        return(NULL);
    } else {
        return(GetSetupData()->ComponentInfHandle);
    }
}

EXTRA_ROUTINES
GetExtraRoutines(
    VOID
    )
{
    return(*gpExtraRoutines);
}

OCMANAGER_ROUTINES
GetHelperRoutines(
    VOID
    )
{
    return(GetSetupData()->HelperRoutines);
}

HINSTANCE
GetInstance(
    VOID
    )
{
    ASSERT(ghInstance);
    return(ghInstance);
}


HINF
GetUnAttendedInfHandle(
    VOID
    )
{
    ASSERT(StateObject.IsUnattended());
    return(GetHelperRoutines().GetInfHandle(INFINDEX_UNATTENDED,GetHelperRoutines().OcManagerContext));
}

VOID
LogErrorToEventLog(
    WORD wType,
    WORD wCategory,
    DWORD dwEventId,
    WORD wNumStrings,
    DWORD dwDataSize,
    LPCTSTR *lpStrings,
    LPVOID lpRawData
    )
{
    HANDLE hEventLog;

    hEventLog = RegisterEventSource(NULL, TS_EVENT_SOURCE);
    if (hEventLog != NULL) {
        if (!ReportEvent(
                hEventLog,
                wType,
                wCategory,
                dwEventId,
                NULL,
                wNumStrings,
                dwDataSize,
                lpStrings,
                lpRawData
                )) {
            LOGMESSAGE1(_T("ReportEvent failed %ld"), GetLastError());
        }

        DeregisterEventSource(hEventLog);
    } else {
        LOGMESSAGE1(_T("RegisterEventSource failed %ld"), GetLastError());
        return;
    }
}

VOID
LogErrorToSetupLog(
    OcErrorLevel ErrorLevel,
    UINT uiMsg
    )
{
    TCHAR szFormat[1024];

    if (LoadString(GetInstance(), uiMsg, szFormat, 1024) != 0) {

        GetExtraRoutines().LogError(
            GetHelperRoutines().OcManagerContext,
            ErrorLevel,
            szFormat
            );
    }
}

VOID
SetInstance(
    HINSTANCE hInstance
    )
{
    ghInstance = hInstance;
}

VOID
SetProgressText(
    UINT uiMsg
    )
{
    TCHAR strMsg[1024];

    if (LoadString(GetInstance(), uiMsg, strMsg, 1024) != 0) {
        GetHelperRoutines().SetProgressText(GetHelperRoutines().OcManagerContext, strMsg);
    }
}

BOOL
SetReboot(
    VOID
    )
{
    return(GetHelperRoutines().SetReboot(GetHelperRoutines().OcManagerContext, 0));
}

BOOL
SetExtraRoutines(
    PEXTRA_ROUTINES pExtraRoutines
    )
{
    if (pExtraRoutines->size != sizeof(EXTRA_ROUTINES)) {
        LOGMESSAGE0(_T("WARNING: Extra Routines are a different size than expected!"));
    }

    gpExtraRoutines = (PEXTRA_ROUTINES)LocalAlloc(LPTR, pExtraRoutines->size);
    if (gpExtraRoutines == NULL) {
        return(FALSE);
    }

    CopyMemory(gpExtraRoutines, pExtraRoutines, pExtraRoutines->size);

    return(TRUE);
}


BOOL Delnode( IN LPCTSTR  Directory )
{
    TCHAR           szDirectory[MAX_PATH + 1];
    TCHAR           szPattern[MAX_PATH + 1];
    WIN32_FIND_DATA FindData;
    HANDLE          FindHandle;

    LOGMESSAGE0(_T("Delnode: Entered"));

    //
    //  Delete each file in the given directory, then remove the directory
    //  itself. If any directories are encountered along the way recurse to
    //  delete them as they are encountered.
    //
    //  Start by forming the search pattern, which is <currentdir>\*.
    //

    ExpandEnvironmentStrings(Directory, szDirectory, MAX_PATH);
    LOGMESSAGE1(_T("Delnode: Deleting %s"), szDirectory);

    _tcscpy(szPattern, szDirectory);
    _tcscat(szPattern, _T("\\"));
    _tcscat(szPattern, _T("*"));

    //
    // Start the search.
    //

    FindHandle = FindFirstFile(szPattern, &FindData);
    if(FindHandle != INVALID_HANDLE_VALUE)
    {

        do
        {

            //
            // Form the full name of the file or directory we just found.
            //

            _tcscpy(szPattern, szDirectory);
            _tcscat(szPattern, _T("\\"));
            _tcscat(szPattern, FindData.cFileName);

            //
            // Remove read-only atttribute if it's there.
            //

            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_READONLY)
            {
                SetFileAttributes(szPattern, FILE_ATTRIBUTE_NORMAL);
            }

            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {

                //
                // The current match is a directory.  Recurse into it unless
                // it's . or ...
                //

                if ((_tcsicmp(FindData.cFileName,_T("."))) &&
                    (_tcsicmp(FindData.cFileName,_T(".."))))
                {
                    if (!Delnode(szPattern))
                    {
                        LOGMESSAGE1(_T("DelNode failed on %s"), szPattern);
                    }
                }

            }
            else
            {

                //
                // The current match is not a directory -- so delete it.
                //

                if (!DeleteFile(szPattern))
                {
                    LOGMESSAGE2(_T("Delnode: %s not deleted: %d"), szPattern, GetLastError());
                }
            }

        }
        while(FindNextFile(FindHandle, &FindData));

        FindClose(FindHandle);
    }

    //
    // Remove the directory we just emptied out. Ignore errors.
    //

    if (!RemoveDirectory(szDirectory))
    {
        LOGMESSAGE2(_T("Failed to remove the directory %s (%d)"), szDirectory, GetLastError());
        return FALSE;
    }

    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Function:	StoreSecretKey
//
//  Synopsis:	stores a key in the LSA
//
//  Arguments:	[pwszKeyName] -- the license server
//				[pbKey]     -- the product id to add license on
//				[cbKey]	  -- the key pack type to add the license to
//
//  Returns:	returns a WinError code
//
//  History:    September 17, 1998 - created [hueiwang]
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD StoreSecretKey(PWCHAR  pwszKeyName, BYTE *  pbKey, DWORD   cbKey )
{
    LSA_HANDLE PolicyHandle;
    UNICODE_STRING SecretKeyName;
    UNICODE_STRING SecretData;
    DWORD Status;

    if( ( NULL == pwszKeyName ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // setup the UNICODE_STRINGs for the call.
    //

    InitLsaString( &SecretKeyName, pwszKeyName );

    SecretData.Buffer = ( LPWSTR )pbKey;
    SecretData.Length = ( USHORT )cbKey;
    SecretData.MaximumLength = ( USHORT )cbKey;

    Status = OpenPolicy( NULL, POLICY_CREATE_SECRET, &PolicyHandle );

    if( Status != ERROR_SUCCESS )
    {
        return LsaNtStatusToWinError(Status);
    }


    Status = LsaStorePrivateData(
                PolicyHandle,
                &SecretKeyName,
                pbKey ? &SecretData : NULL
                );

    LsaClose(PolicyHandle);

    return LsaNtStatusToWinError(Status);
}

//+--------------------------------------------------------------------------
//
//  Function:	OpenPolicy
//
//  Synopsis:	opens a policy of the LSA component
//
//  Arguments:	[ServerName]     -- server
//				[DesiredAccess]  --
//				[PociyHandle]	 --
//
//  Returns:	returns nt error code
//
//  History:    September 17, 1998 - created [hueiwang]
//
//  Notes:
//
//---------------------------------------------------------------------------
DWORD OpenPolicy(LPWSTR ServerName,DWORD DesiredAccess,PLSA_HANDLE PolicyHandle )
{
    LSA_OBJECT_ATTRIBUTES ObjectAttributes;
    LSA_UNICODE_STRING ServerString;
    PLSA_UNICODE_STRING Server;

    //
    // Always initialize the object attributes to all zeroes.
    //

    ZeroMemory( &ObjectAttributes, sizeof( ObjectAttributes ) );

    if( NULL != ServerName )
    {
        //
        // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
        //

        InitLsaString( &ServerString, ServerName );
        Server = &ServerString;

    }
    else
    {
        Server = NULL;
    }

    //
    // Attempt to open the policy.
    //

    return( LsaOpenPolicy(
                Server,
                &ObjectAttributes,
                DesiredAccess,
                PolicyHandle ) );
}


//+--------------------------------------------------------------------------
//
//  Function:	InitLsaString
//
//  Synopsis:	initializes LSA string
//
//  Arguments:	[LsaString] --
//				[String]    --
//
//  Returns:	void
//
//  History:    September 17, 1998 - created [hueiwang]
//
//  Notes:
//
//---------------------------------------------------------------------------
void InitLsaString(PLSA_UNICODE_STRING LsaString,LPWSTR String )
{
    DWORD StringLength;

    if( NULL == String )
    {
        LsaString->Buffer = NULL;
        LsaString->Length = 0;
        LsaString->MaximumLength = 0;
        return;
    }

    StringLength = lstrlenW( String );
    LsaString->Buffer = String;
    LsaString->Length = ( USHORT ) (StringLength * sizeof( WCHAR ));
    LsaString->MaximumLength=( USHORT ) (( StringLength + 1 ) * sizeof( WCHAR ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inc\registry.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.h
*
*  Abstract:
*
*      declaration of a simple registry class CRegistry.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#if !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)
#define AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


#include <winreg.h>


class CRegistry
{
private:

    LPBYTE      m_pMemBlock;
    HKEY        m_hKey;
    int         m_iEnumIndex;
    int         m_iEnumValueIndex;

    DWORD       ReadReg             (LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype);
    void *      Allocate            (DWORD dwSize);



    //
    // This class is not designed to allow copy constructors, = assignments,
    // therefore we should ensure that copy ctor, assignment operator are not
    // generated by compiler. we do that by declaring these functions private
    // and not implementing them. This will ensure that these functions are
    // not generated by compilers, and caller will get error if he tries to
    // use them.
    //

                CRegistry           (const CRegistry &reg);     // copy ctor
  CRegistry &   operator=           (const CRegistry &reg);     // = oprerator



#ifdef DBG
    DWORD       m_dwSizeDebugOnly;
#endif

public:
                CRegistry           ();
                CRegistry           (HKEY hKey);

    virtual     ~CRegistry          ();

    void        Release             ();

    operator    HKEY                ()    {return m_hKey;}


    DWORD       OpenKey             (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, LPCTSTR lpMachineName = NULL);
    DWORD       CreateKey           (HKEY hKey, LPCTSTR lpSubKey, REGSAM access = KEY_ALL_ACCESS, DWORD *pDisposition = NULL, LPSECURITY_ATTRIBUTES lpSecAttr  = NULL );

    DWORD       DeleteValue         (LPCTSTR lpValue);
    DWORD       RecurseDeleteKey    (LPCTSTR lpSubKey);
    DWORD       CopyTree            (CRegistry &regSrc);

    DWORD       ReadRegString       (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegDWord        (LPCTSTR lpValue, DWORD *pdw);
    DWORD       ReadRegMultiString  (LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw);
    DWORD       ReadRegBinary       (LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw);

    DWORD       WriteRegString      (LPCTSTR lpValueName, LPCTSTR lpStr);
    DWORD       WriteRegExpString      (LPCTSTR lpValueName, LPCTSTR lpStr);
    DWORD       WriteRegDWord       (LPCTSTR lpValueName, DWORD dwValue);
    DWORD       WriteRegDWordNoOverWrite (LPCTSTR lpValueName, DWORD dwValue);      // if value exists, do not overwrite
    DWORD       WriteRegMultiString (LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize);
	DWORD		WriteRegBinary		(LPCTSTR lpValueName, LPBYTE lpData, DWORD dwSize);
	DWORD		ExistInMultiString  (LPCTSTR lpValueName, LPCTSTR lpCheckForStr, BOOL *pbExists);
	DWORD		AppendToMultiString (LPCTSTR lpValueName, LPCTSTR lpStr);


    DWORD       GetFirstSubKey      (LPTSTR *lppStr, DWORD *pdw);
    DWORD       GetNextSubKey       (LPTSTR *lppStr, DWORD *pdw);

    DWORD       GetFirstValue       (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);
    DWORD       GetNextValue        (LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType);

    DWORD       GetSecurity         (PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize);
    DWORD       SetSecurity         (PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation);

};

#endif // !defined(AFX_REGISTRY_H__AA7047C5_B519_11D1_B05F_00C04FA35813__INCLUDED_)

//EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\sources.inc ===
# Copyright (c) 1998 - 1999 Microsoft Corporation
#
# This file is designed to be included from 2 levels below
# (ie, daytona\srv, daytona\wks, cairo\srv, or cairo\wks).
#

MAJORCOMP=setup
MINORCOMP=infs

TARGETNAME=inf
TARGETPATH=obj
TARGETTYPE=notarget


!ifdef _PER_SKU_
C_DEFINES=$(C_DEFINES) -D_PER_SKU_
!endif

!ifdef _PRO_SKU_
C_DEFINES=$(C_DEFINES) -D_PRO_SKU_
!endif

!ifdef _SRV_SKU_
C_DEFINES=$(C_DEFINES) -D_SRV_SKU_
!endif

!ifdef _ADS_SKU_
C_DEFINES=$(C_DEFINES) -D_ADS_SKU_
!endif

!ifdef _DTC_SKU_
C_DEFINES=$(C_DEFINES) -D_DTC_SKU_
!endif



#
# No explicit sources because build doesn't understand .inf files.
#
SOURCES=

#
# Use NTTARGETFILE0 macros to cause the infs to get built during
# the compile phase. We do this so that we can disable MP build for
# this directory, using BLOCK and DRAIN.
#
NTTARGETFILE0=make_infs

NO_BROWSER_FILE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inc\logmsg.h ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.h: interface for the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
#define AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_
#define _LOGMESSAGE_INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000


class LogMsg
{



private:

    TCHAR m_szLogFile[MAX_PATH];
    TCHAR m_szLogModule[MAX_PATH];
    bool m_bInitialized;

public:
	
    
                LogMsg          (int value);
	virtual     ~LogMsg         ();

    DWORD       Init            (LPCTSTR szLogFile, LPCTSTR szLogModule);
    DWORD       Log             (LPCTSTR file, int line, TCHAR *fmt, ...);

 //   static LogMsg GetLogObject();

};

// instantiated in LogMsg.cpp.
#ifndef _LOGMESSAGE_CPP_

extern LogMsg thelog;

#endif

// maks_todo : how to make sure that we get compiler error if we use macro with fewer parameters when we should have used macro with more parameters ?
// for example : LOGERROR1(_T("Show Two Values %s, %s"), firstvalue, secondvalue) how to catch this error during compilation ?
#define LOGMESSAGEINIT(logfile, module)                 thelog.Init(logfile, module)
#define LOGMESSAGE0(msg)                                thelog.Log(_T(__FILE__), __LINE__, msg)
#define LOGMESSAGE1(msg, arg1)                          thelog.Log(_T(__FILE__), __LINE__, msg, arg1)
#define LOGMESSAGE2(msg, arg1, arg2)                    thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2)
#define LOGMESSAGE3(msg, arg1, arg2, arg3)              thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3)
#define LOGMESSAGE4(msg, arg1, arg2, arg3, arg4)        thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4)
#define LOGMESSAGE5(msg, arg1, arg2, arg3, arg4, arg5)  thelog.Log(_T(__FILE__), __LINE__, msg, arg1, arg2, arg3, arg4, arg5)

#endif // !defined(AFX_LOGMSG_H__8A651DB1_D876_11D1_AE27_00C04FA35813__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\makefile.inc ===
# Copyright (c) 1998 - 1999 Microsoft Corporation
#
# For daytona, this file is designed to be included from 3 levels below
# ie, dayona\$(LANGUAGE)inf\srv, or daytona\$(LANGUAGE)inf\wks
#
# Note: NEC98 builds go through this file twice, the second time
# with "ALT_PROJECT"=="NEC_98".  These latter produce a subset
# of binaries which are only used on NEC98 machines.
#

!IFNDEF LANGUAGE
LANGUAGE=usa
!ENDIF

_LNG=..\..\..\$(LANGUAGE)
_INX=..\..\..
_INF=obj\$(TARGET_DIRECTORY)

!ifdef _PER_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b perinf)
!endif

!ifdef _PRO_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD)
!endif

!ifdef _SRV_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b srvinf)
!endif

!ifdef _ADS_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b entinf)
!endif

!ifdef _DTC_SKU_
TSBINPLACE_CMD=$(BINPLACE_CMD:binplace=binplace -b dtcinf)
!endif


make_infs:$(_INF)\tsoc.inf

$(_INF)\tsoc.inf: $(_INX)\tsoc.inx $(_LNG)\tsoc.txt
    @type <<$(ECHO_RSP)
$(ECHO_MSG_P)
<<NOKEEP
    @$(C_PREPROCESSOR_NAME) @<<$(CL_RSP) /Tc$(_INX)\$(@B).inx > $(O)\$(@B).tmp
$(CPPXX: =
)
<<NOKEEP
    copy $(O)\$(@B).tmp+$(_LNG)\$(@B).txt $@
    $(TSBINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\arainf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\arainf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\arainf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\arainf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\arainf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ARA
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\brinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\brinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\brinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\brinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\brinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=br
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chtinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chsinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chsinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chsinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chsinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chtinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chtinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chtinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chsinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHS
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\chtinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=CHT
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\dainf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\dainf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\csinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\csinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\csinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\dainf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\csinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\csinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=cs
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\dainf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\dainf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=da
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\elinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\elinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\elinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\esinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\esinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\elinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\esinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\elinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=el
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\esinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\esinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=es
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\fiinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\frinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\frinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\fiinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\frinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\fiinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\fiinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\fiinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fi
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\frinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\frinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=fr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\gerinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\gerinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\gerinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\hebinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\gerinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\hebinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\gerinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=GER
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\hebinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\hebinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\hebinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=HEB
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\itinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\itinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\huinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\huinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\huinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\itinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\huinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\huinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=hu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\itinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\itinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=it
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\jpninf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\korinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\jpninf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\jpninf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\jpninf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\jpninf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=JPN
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\korinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\korinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\korinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\korinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

C_DEFINES = $(C_DEFINES) -DDONT_NEED_WIN16_TSCLIENT
LANGUAGE=KOR
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\nlinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\nlinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\nlinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\nlinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\nlinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=nl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\noinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\noinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\noinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\noinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\noinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=no
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\plinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\psuinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\plinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\plinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\psuinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\plinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\psuinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\plinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pl
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\psuinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\psuinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=psu
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ptinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ptinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ruinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ptinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ptinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ptinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=pt
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ruinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ruinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ruinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\ruinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=ru
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\trinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\trinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\svinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\svinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\svinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\svinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\trinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\svinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=sv
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\trinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\trinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=tr
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\usainf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\usainf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\tstinf\dtc\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\usainf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\tstinf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\tstinf\ads\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\usainf\srv\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\tstinf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\tstinf\per\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation

LANGUAGE=TST
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\inf\daytona\usainf\pro\makefile.inc ===
#Copyright (c) 1998 - 1999 Microsoft Corporation
!include ..\..\..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\lib\logmsg.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

// LogMsg.cpp: implementation of the LogMsg class.
//
//////////////////////////////////////////////////////////////////////

#define _LOGMESSAGE_CPP_

#include "stdafx.h"
#include "LogMsg.h"

DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz);


// maks_todo: is there any standard file to be used for  logs.
//////////////////////////////////////////////////////////////////////
// constants
//////////////////////////////////////////////////////////////////////
const UINT        LOG_ENTRY_SIZE             = 1024;
const UINT        STAMP_SIZE                 = 1024;
LPCTSTR           UNINITIALIZED              = _T("uninitialized");


//////////////////////////////////////////////////////////////////////
// globals.
////////////////////////////////////////////////////////////////////////
LogMsg thelog(26);  // used by LOGMESSAGE macros.


//////////////////////////////////////////////////////////////////////
// Construction / destruction
////////////////////////////////////////////////////////////////////////
LogMsg::LogMsg(int value)
{
    m_bInitialized = false;
}

LogMsg::~LogMsg()
{
    LOGMESSAGE0(_T("********Terminating Log."));
}

/*--------------------------------------------------------------------------------------------------------
* DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
* creates/opens the szLogFile for logging messages.
* must be called befour using the Log Function.
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Init(LPCTSTR szLogFile, LPCTSTR szLogModule)
{

    USES_CONVERSION;
    ASSERT(szLogFile);
    ASSERT(szLogModule);

    // dont call this function twice.
    // maks_todo:why is the constructor not getting called?
    // maks_todo:enable this assert.
    //ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) == 0);

    ASSERT(_tcslen(szLogFile) < MAX_PATH);
    ASSERT(_tcslen(szLogModule) < MAX_PATH);

    _tcsncpy(m_szLogFile, szLogFile, sizeof(m_szLogFile)/sizeof(m_szLogFile[0]) -1);
    _tcsncpy(m_szLogModule, szLogModule, sizeof(m_szLogModule)/sizeof(m_szLogModule[0]) -1);

    m_szLogFile[sizeof(m_szLogFile)/sizeof(m_szLogFile[0]) -1] = NULL;
    m_szLogModule[sizeof(m_szLogModule)/sizeof(m_szLogModule[0]) -1] = NULL;


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(m_szLogFile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {

        // lets prepare for writing to the file.
        SetFilePointer(hfile, 0, NULL, FILE_END);
        DWORD  bytes;

        // get the current time/date stamp.
        TCHAR   time[STAMP_SIZE];
        TCHAR   date[STAMP_SIZE];
        TCHAR   output_unicode[LOG_ENTRY_SIZE];

        _tstrdate(date);
        _tstrtime(time);


        _sntprintf(output_unicode, sizeof(output_unicode)/sizeof(output_unicode[0]) -1, _T("\r\n\r\n*******Initializing Message Log:%s %s %s\r\n"), m_szLogModule, date, time);
        output_unicode[sizeof(output_unicode)/sizeof(output_unicode[0]) -1] = NULL;
        ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


        // TCharStringToAnsiString(output_unicode, output);

        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);


        // now write some more info about the version etc.
        OSVERSIONINFO OsV;
        OsV.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        if (GetVersionEx(&OsV)== 0)
        {
            // get version failed.
            _sntprintf(output_unicode, sizeof(output_unicode)/sizeof(output_unicode[0]) -1, _T("GetVersionEx failed, ErrrorCode = %lu\r\n"), GetLastError());
            output_unicode[sizeof(output_unicode)/sizeof(output_unicode[0]) -1] = NULL;

            ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);

            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);

        }
        else
        {
            //
            // ok we have the version info, write it out
            //

            _sntprintf(output_unicode, sizeof(output_unicode)/sizeof(output_unicode[0]) -1, _T("*******Version:Major=%lu, Minor=%lu, Build=%lu, PlatForm=%lu, CSDVer=%s, %s\r\n\r\n"),
                OsV.dwMajorVersion,
                OsV.dwMinorVersion,
                OsV.dwBuildNumber,
                OsV.dwPlatformId,
                OsV.szCSDVersion,
#ifdef DBG
                _T("Checked")
#else
                _T("Free")
#endif
                );

            output_unicode[sizeof(output_unicode)/sizeof(output_unicode[0]) -1] = NULL;


            WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        }

        m_bInitialized = true;
        CloseHandle(hfile);
    }

    return GetLastError();
}


/*--------------------------------------------------------------------------------------------------------
* void log(TCHAR *fmt, ...)
* writes message to the log file. (LOGFILE)
* -------------------------------------------------------------------------------------------------------*/
DWORD LogMsg::Log(LPCTSTR file, int line, TCHAR *fmt, ...)
{
    if (!m_bInitialized)
        return 0;

    USES_CONVERSION;
    ASSERT(file);
    ASSERT(fmt);
    ASSERT(_tcscmp(m_szLogFile, UNINITIALIZED) != 0);

     // write down file and line info into the buffer..
    TCHAR   fileline_unicode[LOG_ENTRY_SIZE];

    // file is actually full path to the file.
    ASSERT(_tcschr(file, '\\'));

    // we want to print only file name not full path
    UINT uiFileLen = _tcslen(file);
    while (uiFileLen && *(file + uiFileLen - 1) != '\\')
    {
        uiFileLen--;
    }
    ASSERT(uiFileLen);

    _sntprintf(fileline_unicode, sizeof(fileline_unicode)/sizeof(fileline_unicode[0]) -1, _T("%s(%d)"), (file+uiFileLen), line);
    fileline_unicode[sizeof(fileline_unicode)/sizeof(fileline_unicode[0]) -1] = NULL;



    // create the output string
    TCHAR  output_unicode[LOG_ENTRY_SIZE];
    va_list vaList;
    va_start(vaList, fmt);
    _vsntprintf(output_unicode, sizeof(output_unicode)/sizeof(output_unicode[0]) -1, fmt, vaList);
    va_end(vaList);

    output_unicode[sizeof(output_unicode)/sizeof(output_unicode[0]) -1] = NULL;
    ASSERT(_tcslen(output_unicode) < LOG_ENTRY_SIZE);


    // open the log file
    HANDLE hfile = CreateFile(m_szLogFile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);

        DWORD  bytes;
        const LPCSTR CRLF = "\r\n";
        WriteFile(hfile, T2A(fileline_unicode), _tcslen(fileline_unicode), &bytes, NULL);
        WriteFile(hfile, T2A(output_unicode), _tcslen(output_unicode), &bytes, NULL);
        WriteFile(hfile, CRLF, strlen(CRLF) * sizeof(char), &bytes, NULL);

        CloseHandle(hfile);
    }

    return GetLastError();
}

/*--------------------------------------------------------------------------------------------------------
* TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
* converts the given TCHAR * to char *
* -------------------------------------------------------------------------------------------------------*/

DWORD TCharStringToAnsiString(const TCHAR *tsz ,char *asz)
{

    ASSERT(tsz && asz);

#ifdef UNICODE
    DWORD count;

    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > STAMP_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}


// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\lib\stdafx.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      stdafx.h
 *
 *  Abstract:
 *
 *      Common Header file for the my library components
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _stdafx_h_
#define _stdafx_h_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tchar.h>
#include <string.h>
#include <stdio.h>
#include <time.h>
#include <malloc.h>

#include "conv.h"

#define AssertFalse() ASSERT(FALSE)
#ifdef DBG
#define VERIFY(x) ASSERT(x)
#else
#define VERIFY(x)  (x)
#endif


#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( TSDiag )
EXTERN_PROXY_FILE( tsdiag )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( TSDiag ),
  REFERENCE_PROXY_FILE( tsdiag ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\lib\registry.cpp ===
//Copyright (c) 1998 - 1999 Microsoft Corporation

/*--------------------------------------------------------------------------------------------------------
*
*  Module Name:
*
*      Registry.cpp
*
*  Abstract:
*
*      Registry.cpp: implementation of the CRegistry class.
*      This class helps with registry by allocating memory by itself
*      As a result caller must copy the pointer returned by Get functions
*      immediately.
*
*
*
*  Author:
*
*      Makarand Patwardhan  - April 9, 1997
*
* -------------------------------------------------------------------------------------------------------*/

#include "stdafx.h"
#include "Registry.h"


/*--------------------------------------------------------------------------------------------------------
* Constructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::CRegistry()
{
    m_pMemBlock = NULL;
    m_hKey = NULL;
    m_iEnumIndex = -1;
    m_iEnumValueIndex = -1;

#ifdef DBG
    m_dwSizeDebugOnly = 0;
#endif
}


CRegistry::CRegistry(HKEY hKey)
{
    m_pMemBlock = NULL;
    m_hKey = hKey;
    m_iEnumIndex = -1;
    m_iEnumValueIndex = -1;
}

/*--------------------------------------------------------------------------------------------------------
* Destructor
* -------------------------------------------------------------------------------------------------------*/
CRegistry::~CRegistry()
{
    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }
    Release();
}

/*--------------------------------------------------------------------------------------------------------
* void Allocate (DWORD dwSize)
* This private function is used for allocating the memory for
* reading registry
* returns the pointer to memory allocated.
* -------------------------------------------------------------------------------------------------------*/
void *CRegistry::Allocate (DWORD dwSize)
{
    if (m_pMemBlock)
        Release();

    m_pMemBlock = new BYTE[dwSize];

#ifdef DBG
    // remember the size of the block to be allocated.
    m_dwSizeDebugOnly = dwSize;
#endif

    return m_pMemBlock;
}

/*--------------------------------------------------------------------------------------------------------
* void Release ()
* This private function is used for releasing internal memory block
* -------------------------------------------------------------------------------------------------------*/
void CRegistry::Release ()
{
    if (m_pMemBlock)
    {

#ifdef DBG
        // fistly fill up the block we allocated previously with garbage.
        // so that if anybody is using this block, it is more lilely to
        // catch the bug.
        FillMemory(m_pMemBlock, m_dwSizeDebugOnly, 'c');
        m_dwSizeDebugOnly = 0;

#endif

        delete [] m_pMemBlock;
    }
    
    m_pMemBlock = 0;
}


///*--------------------------------------------------------------------------------------------------------
//* DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
//* opens/creates the key specified. before attempting any operation on any key/value. this function
//* must be called.
//* hKey - hive
//* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
//* access - access desired. like REG_READ, REG_WRITE..
//* RETURNS error code.
//* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::CreateKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, DWORD *pDisposition /*= NULL*/, LPSECURITY_ATTRIBUTES lpSecAttr /* = NULL */)
{
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    // security descriptor should be null or it should be a valid one.
    ASSERT(!lpSecAttr || IsValidSecurityDescriptor(lpSecAttr->lpSecurityDescriptor));

    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    DWORD dwDisposition;
    LONG lResult = RegCreateKeyEx(
                    hKey,               // handle of an open key
                    lpSubKey,           // address of subkey name
                    0,                  // reserved
                    NULL,               // address of class string
                    REG_OPTION_NON_VOLATILE ,  // special options flag
                    access,             // desired security access
                    lpSecAttr,          // address of key security structure
                    &m_hKey,            // address of buffer for opened handle
                    &dwDisposition      // address of disposition value buffer
                    );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    if (pDisposition)
        *pDisposition = dwDisposition;

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access) ()
* opens the key specified. before attempting any operation on any key/value. this function
* must be called.
* hKey - hive
* lpSubKey - Path of the key in the format _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server")
* access - access desired. like REG_READ, REG_WRITE..
* lpMachineName - machine name if registry is to be opened on remote machine.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::OpenKey(HKEY hKey, LPCTSTR lpSubKey, REGSAM access /*= KEY_ALL_ACCESS*/, LPCTSTR lpMachineName /* = NULL */)
{
    LONG lResult;
    ASSERT(lpSubKey);
    ASSERT(*lpSubKey != '\\');
    LPTSTR szCompName = NULL;
    

    if (lpMachineName)
    {
        // if remote name is specified, hkey must be one of following.
        ASSERT(hKey == HKEY_LOCAL_MACHINE || hKey == HKEY_USERS || hKey == HKEY_PERFORMANCE_DATA);

        szCompName = new TCHAR[_tcslen(lpMachineName) + 3];
        if (!szCompName)
            return ERROR_OUTOFMEMORY;

        _tcscpy(szCompName, _T(""));
        if (*lpMachineName != '\\')
        {
            ASSERT(*(lpMachineName + 1) != '\\');
            _tcscpy(szCompName, _T("\\\\"));
        }
        
        _tcscat(szCompName, lpMachineName);

        // now connect to the remote computer.
        lResult = RegConnectRegistry (szCompName, hKey, &hKey);
        if (ERROR_SUCCESS != lResult)
        {
            delete [] szCompName;
            return lResult;
        }
    }

    if (m_hKey != NULL)
    {
        RegCloseKey(m_hKey);
        m_hKey = NULL;
    }

    lResult = RegOpenKeyEx(
        hKey,                       // handle of open key
        lpSubKey,                   // address of name of subkey to open
        0 ,                         // reserved
        access,                     // security access mask
        &m_hKey                     // address of handle of open key
        );

    if (lResult != ERROR_SUCCESS)
    {
        m_hKey = NULL;
    }

    // if we opened remote registry.. lets close the top level key
    if (szCompName)
    {
        RegCloseKey(hKey);
        delete [] szCompName;
    }

    return lResult;
}

DWORD CRegistry::DeleteValue (LPCTSTR lpValue)
{
    ASSERT(lpValue);
    ASSERT(m_hKey);
    return RegDeleteValue(m_hKey, lpValue);

}
DWORD CRegistry::RecurseDeleteKey (LPCTSTR lpSubKey)
{
    ASSERT(lpSubKey);
    ASSERT(m_hKey);

    CRegistry reg;
    DWORD dwError = reg.OpenKey(m_hKey, lpSubKey);
    if (dwError != ERROR_SUCCESS)
        return dwError;


    LPTSTR lpChildKey;
    DWORD  dwSize;

    // we needn't/shouldn't use GetNextSubKey in this here
    // as we are deleting the key during the loop.
    while (ERROR_SUCCESS == reg.GetFirstSubKey(&lpChildKey, &dwSize))
    {
        VERIFY(reg.RecurseDeleteKey(lpChildKey) == ERROR_SUCCESS);
    }

    return RegDeleteKey(m_hKey, lpSubKey);

}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
* Reads the registry used internally.
* LPCTSTR lpValue - value to be read.
* LPBYTE *lppbyte - address of the lpbyte at which to place the output buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* dword datatype - datatype you are expecting.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadReg(LPCTSTR lpValue, LPBYTE *lppbyte, DWORD *pdw, DWORD dwDatatype)
{
    ASSERT(lpValue);
    ASSERT(lppbyte);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    *pdw = 0;

    DWORD dwType;
    DWORD lResult = RegQueryValueEx(
        m_hKey,             // handle of key to query
        lpValue,            // address of name of value to query
        0,                  // reserved
        &dwType,            // address of buffer for value type
        0,                  // address of data buffer 
        pdw                 // address of data buffer size 
        );

    if (lResult == ERROR_SUCCESS)
    {
        ASSERT(dwType == dwDatatype || dwType == REG_EXPAND_SZ);

        if (0 == Allocate(*pdw))
            return ERROR_OUTOFMEMORY;

        lResult = RegQueryValueEx(
            m_hKey,                 // handle of key to query
            lpValue,                // address of name of value to query
            0,                      // reserved
            &dwType,                // address of buffer for value type
            m_pMemBlock,            // address of data buffer 
            pdw                     // address of data buffer size 
            ); 

        ASSERT (ERROR_MORE_DATA != lResult);
    
        if (lResult == ERROR_SUCCESS)
            *lppbyte = m_pMemBlock;
    }

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
* Reads A string (REG_SZ) from the registry
* LPCTSTR lpValue value to be read.
* DWORD  *pdw  - address of dword in which the read dword returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegDWord(LPCTSTR lpValue, DWORD *pdw)
{
    ASSERT(pdw);

    DWORD dwSize;
    LPBYTE pByte;
    DWORD dwReturn = ReadReg(lpValue, &pByte, &dwSize, REG_DWORD);
    ASSERT(dwReturn != ERROR_SUCCESS || dwSize == sizeof(DWORD));

    if (dwReturn == ERROR_SUCCESS)
        *pdw = * LPDWORD(pByte);

    return dwReturn;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegMultiString(LPCTSTR lpValue, LPTSTR *lppStr, DWORD *pdw)
{
    return ReadReg(lpValue, (LPBYTE *)lppStr, pdw, REG_MULTI_SZ);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
* Reads A string (REG_MULTI_SZ) from the registry
* LPCTSTR lpValue value to be read.
* LPBYTE *lppByte - address of LPBYTE in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::ReadRegBinary(LPCTSTR lpValue, LPBYTE *lppByte, DWORD *pdw)
{
    return ReadReg(lpValue, lppByte, pdw, REG_BINARY);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
* Reads a first subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy 
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    m_iEnumIndex = 0;

    return GetNextSubKey(lppStr, pdw);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextSubKey(LPTSTR *lppStr, DWORD *pdw
* Reads the next subkey for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextSubKey(LPTSTR *lppStr, DWORD *pdw)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumIndex >= 0); // must call GetFirstSubKey first.

    *pdw = 1024;
    if (0 == Allocate(*pdw * sizeof(TCHAR)))
        return ERROR_NOT_ENOUGH_MEMORY;

    LONG lResult = RegEnumKeyEx(
        m_hKey,                     // handle of key to enumerate
        m_iEnumIndex,               // index of subkey to enumerate
        (LPTSTR)m_pMemBlock,        // address of buffer for subkey name
        pdw,                        // address for size of subkey buffer
        0,                          // reserved
        NULL,                       // address of buffer for class string
        NULL,                       // address for size of class buffer
        NULL                        // address for time key last written to
        );

    (*pdw)++;    // since null is not included in the size.
    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;

    m_iEnumIndex++;

    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;

    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a first value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy
* the buffer to immediately. caller must not use this buffer except for copying it. 
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetFirstValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);

    m_iEnumValueIndex = 0;
    return GetNextValue(lppStr, pdw, pDataType);
}

/*--------------------------------------------------------------------------------------------------------
* DWORD GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
* Reads a next value for the key
* LPTSTR *lppStr - address of LPTSTR in which resultant buffer is returned. caller must copy
* the buffer to immediately. caller must not use this buffer except for copying it.
* caller must not write to this buffer.
* used to enumerate the registry.
* DWORD  *pdw  - address of dword in which size of the buffer (in bytes) is returned.
* DWORD *pDataType - datatype of the value is returned in this one.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::GetNextValue(LPTSTR *lppStr, DWORD *pdw, DWORD *pDataType)
{
    ASSERT(lppStr);
    ASSERT(pdw);
    ASSERT(pDataType);
    ASSERT(m_hKey != NULL);
    ASSERT(m_iEnumValueIndex >= 0); // must call GetFirstSubKey first.

    *pdw = 1024;
    if (0 == Allocate(*pdw * sizeof(TCHAR)))
        return ERROR_NOT_ENOUGH_MEMORY;

    LONG lResult = RegEnumValue(
        m_hKey,                     // handle of key to query
        m_iEnumValueIndex,          // index of value to query
        (LPTSTR)m_pMemBlock,        // address of buffer for value string
        pdw,                        // address for size of value buffer
        0,                          // reserved
        pDataType,                  // address of buffer for type code
        NULL,                       // address of buffer for value data    maks_todo : use this
        NULL                        // address for size of data buffer
        );

    (*pdw)++;    // since null is not included in the size.

    if (ERROR_NO_MORE_ITEMS == lResult)
        return lResult;


    m_iEnumValueIndex++;
    if (lResult == ERROR_SUCCESS)
        *lppStr = (LPTSTR)m_pMemBlock;
    
    return lResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
* writes REG_SZ value into the registry
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegString(LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

    DWORD dwSize = (_tcslen(lpStr) + 1) * sizeof(TCHAR) / sizeof(BYTE);
    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for
        lpValueName,            // address of value to set
        0,                      // Reserved
        REG_SZ,                 // flag for value type
        (LPBYTE)lpStr,          // address of value data
        dwSize                  // size of value data
        );
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegExpString(LPCTSTR lpValueName, LPCTSTR lpStr)
* writes REG_EXPAND_SZ value into the registry
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegExpString(LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

    DWORD dwSize = (_tcslen(lpStr) + 1) * sizeof(TCHAR) / sizeof(BYTE);
    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for
        lpValueName,            // address of value to set
        0,                      // Reserved
        REG_EXPAND_SZ,                 // flag for value type
        (LPBYTE)lpStr,          // address of value data
        dwSize                  // size of value data
        );
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
* writes REG_MULTI_SZ value into the registry 
* LPCTSTR lpValueName - value name to be written to
* LPCTSTR lpStr - data to be written 
* DWORD   dwSize - size of data.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegMultiString(LPCTSTR lpValueName, LPCTSTR lpStr, DWORD dwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);

#ifdef DBG
    
    // lets make sure that the given size is right.
    LPCTSTR lpTemp = lpStr;
    DWORD rightsize = 0;
    while (_tcslen(lpTemp) > 0)
    {
        rightsize  += _tcslen(lpTemp) + 1;
        lpTemp += _tcslen(lpTemp) + 1;
    }

    ASSERT(*lpTemp == 0);           // final NULL.
    rightsize++;                    // account for final terminating null

    rightsize *= sizeof(TCHAR) / sizeof(BYTE); // size must be in bytes.

    ASSERT(dwSize == rightsize);
    
#endif

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_MULTI_SZ,           // flag for value type
        (LPBYTE)lpStr,          // address of value data 
        dwSize                  // size of value data 
        ); 
}

/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegBinary (LPCTSTR lpValueName, LPBYTE lpData, DWORD dwSize)
* writes REG_BINARY value into the registry 
* LPCTSTR lpValueName - value name to be written to
* LPBYTE lpData - data to be written 
* DWORD   dwSize - size of data.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegBinary (LPCTSTR lpValueName, LPBYTE lpData, DWORD dwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpData);
	ASSERT(dwSize > 0);

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved 
        REG_BINARY,           // flag for value type
        lpData,          // address of value data 
        dwSize                  // size of value data 
        ); 
}



/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
* writes REG_DWORD value into the registry 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR dwValue - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegDWord(LPCTSTR lpValueName, DWORD dwValue)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);

    return RegSetValueEx(
        m_hKey,                 // handle of key to set value for 
        lpValueName,            // address of value to set 
        0,                      // Reserved
        REG_DWORD,              // flag for value type
        (LPBYTE)&dwValue,       // address of value data 
        sizeof(dwValue)         // size of value data 
        );
}


/*--------------------------------------------------------------------------------------------------------
* DWORD WriteRegDWordNoOverWrite(LPCTSTR lpValueName, DWORD dwValue)
* writes REG_DWORD value into the registry if-and-only-if value does not already exist. 
* LPCTSTR lpValueName - value name to be written to 
* LPCTSTR dwValue - data to be written 
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::WriteRegDWordNoOverWrite(LPCTSTR lpValueName, DWORD dwValue)
{
    DWORD   dwTmp, rc;
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);

    rc = ReadRegDWord( lpValueName, &dwTmp);

    if ( rc  ==  ERROR_FILE_NOT_FOUND)
    {
        return RegSetValueEx(
            m_hKey,                 // handle of key to set value for 
            lpValueName,            // address of value to set 
            0,                      // Reserved
            REG_DWORD,              // flag for value type
            (LPBYTE)&dwValue,       // address of value data 
            sizeof(dwValue)         // size of value data 
            );
    }

    ASSERT( rc == ERROR_SUCCESS );
    return rc;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD ExistInMultiString  (LPCTSTR lpValueName, LPCTSTR lpStr, BOOL *pbExists)
* checks if given null terminated string exists in a multi_sz value
* LPCTSTR lpValueName - value name to be checked
* LPCTSTR lpCheckForStr - the value to be checked for 
* BOOL *pbExists - return. TRUE if exits.
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
/*
DWORD CRegistry::ExistInMultiString  (LPCTSTR  lpValueName, LPCTSTR lpCheckForStr, BOOL *pbExists)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpCheckForStr);
    ASSERT(*lpCheckForStr);
    ASSERT(pbExists);




    DWORD dwError = ERROR_SUCCESS;
    *pbExists = FALSE;

    LPTSTR szValue;
    DWORD dwSize;
    dwError = ReadRegMultiString(lpValueName, &szValue, dwSize);
    if (ERROR_SUCCESS == dwError)
    {
        LPCTSTR pTemp = szValue;
        while(_tcslen(pTemp) > 0 )
        {
            if (_tcscmp(pTemp, lpCheckForStr) == 0)
            {
                *pbExists = TRUE;
                break;
            }

            pTemp += _tcslen(pTemp) + 1; // point to the next string within the multistring.
            if ( DWORD(pTemp - szSuiteValue) > (dwSize / sizeof(TCHAR)))
                break; // temporary pointer passes the size of the szSuiteValue something is wrong with szSuiteValue.
        }
    }

    return dwError;


    ASSERT(FALSE);
    return ERROR_CALL_NOT_IMPLEMENTED;

}
*/

/*--------------------------------------------------------------------------------------------------------
* DWORD AppendToMultiString (LPCTSTR lpValueName, LPCTSTR lpStr)
* appends given string to a multistring value
* LPCTSTR lpValueName - value name to be appended to
* LPCTSTR lpStr - the value to be appended
* RETURNS error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD CRegistry::AppendToMultiString (LPCTSTR lpValueName, LPCTSTR lpStr)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(lpValueName);
    ASSERT(lpStr);
    ASSERT(*lpStr);

    return ERROR_CALL_NOT_IMPLEMENTED;

}

// copy the buffer immediately
DWORD CRegistry::GetSecurity(PSECURITY_DESCRIPTOR *ppSec, SECURITY_INFORMATION SecurityInformation, DWORD *pdwSize)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    ASSERT(ppSec);
    ASSERT(pdwSize);
    DWORD dwError;

    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    *pdwSize = 0;   // we just want to get the right size during the first call.

    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        &pSecurityDescriptor,    // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    // this call can not succeed. as we have set the size = 0
    ASSERT(dwError != ERROR_SUCCESS);

    if (dwError != ERROR_INSUFFICIENT_BUFFER)
    {
        // something else has went wronng.
        // return the error code
        return dwError;
    }

    ASSERT(*pdwSize != 0);

    // now we have got the right size, allocate it.
    if (0 == Allocate(*pdwSize))
        return ERROR_OUTOFMEMORY;

    dwError = RegGetKeySecurity(
        m_hKey,                  // open handle of key to set
        SecurityInformation,     // descriptor contents
        m_pMemBlock,             // address of descriptor for key
        pdwSize                  // address of size of buffer and descriptor
        );

    ASSERT(dwError != ERROR_INSUFFICIENT_BUFFER);

    if (dwError == ERROR_SUCCESS)
        *ppSec = m_pMemBlock;

    return dwError;
           
}

DWORD CRegistry::SetSecurity(PSECURITY_DESCRIPTOR pSec, SECURITY_INFORMATION SecurityInformation)
{
    ASSERT(m_hKey != NULL);     // call setkey before calling this function.
    return RegSetKeySecurity(
        m_hKey,                 // open handle of key to set
        SecurityInformation,    // descriptor contents
        pSec                    // address of descriptor for key
        );
}


// this function will fail miserably if the source and destination overlap.
DWORD CRegistry::CopyTree(CRegistry &regSrc)
{
    DWORD dwSize;
    LPTSTR szKey;
    LPTSTR szValue;
    DWORD dwError;

    if (ERROR_SUCCESS == (dwError = regSrc.GetFirstSubKey(&szKey, &dwSize)))
    {
        
        do
        {
            CRegistry regSrcKey;
            CRegistry regDstKey;
            if (ERROR_SUCCESS == (dwError = regSrcKey.OpenKey(regSrc, szKey)))
            {

                if (ERROR_SUCCESS == (dwError = regDstKey.CreateKey(m_hKey, szKey)))
                {
                    regDstKey.CopyTree(regSrcKey);
                }
            }

        }
        while (ERROR_SUCCESS == (dwError = regSrc.GetNextSubKey(&szKey, &dwSize)));

    }

    //
    // now copy values.
    //


    DWORD dwDataType;
    if (ERROR_SUCCESS == (dwError = regSrc.GetFirstValue(&szValue, &dwSize, &dwDataType)))
    {
        do
        {
            TCHAR *szValueName = new TCHAR[dwSize];
            if (!szValueName)
                break;

            _tcscpy(szValueName, szValue);

            LPBYTE pData;
            if (ERROR_SUCCESS == (dwError = regSrc.ReadReg(szValueName, &pData, &dwSize, dwDataType)))
            {
                dwError = RegSetValueEx(
                    m_hKey,                 // handle of key to set value for
                    szValueName,            // address of value to set
                    0,                      // Reserved
                    dwDataType,             // flag for value type
                    pData,                  // address of value data
                    dwSize                  // size of value data
                    );

            }
        }
        while (ERROR_SUCCESS == regSrc.GetNextValue(&szValue, &dwSize, &dwDataType));

    }

    return TRUE;

}

#ifdef _Maks_AutoTest_

//
// make sure that CRegistry does not support
// Copy constructor & assignment operator
//

void TestRegistry (CRegistry reg)
{
    CRegistry reg2 = reg;   // should get error for copy constructor
    CRegistry reg3(reg);     // should get error for copy constructor
    CRegistry reg4;
    reg4 = reg;             // should get error for = operator.
    TestRegistry(reg);       // should get error for copy construtor
}
#endif // _Maks_AutoTest_


// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__60AB0CA8_CB88_4D79_90FA_1A1775D53249__INCLUDED_)
#define AFX_DLLDATAX_H__60AB0CA8_CB88_4D79_90FA_1A1775D53249__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__60AB0CA8_CB88_4D79_90FA_1A1775D53249__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\lib\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

!ENDIF

TERMSRV_ROOT = ..\..\..
INCLUDES= \
    $(TERMSRV_ROOT)\setup\inc; \
    $(BASE_INC_PATH); \

TARGETPATH=$(TERMSRV_ROOT)\setup\lib\$(_OBJ_DIR)
TARGETTYPE=LIBRARY

SOURCES= \
    registry.cpp \
    logmsg.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\dlldatax.c ===
// wrapper for dlldata.c

#pragma warning( disable : 4206 )

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "TSDiag_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\drdetect.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*++


Module Name:

    drdetect

Abstract:

    Detect whether RDPDR was properly installed.

Environment:

    User mode

Author:

    Tadb

--*/

#include "stdafx.h"
#include <setupapi.h>

////////////////////////////////////////////////////////////
//
//  Internal Defines
//

#define RDPDRPNPID      _T("ROOT\\RDPDR")
#define RDPDRDEVICEID   TEXT("Root\\RDPDR\\0000")

const GUID GUID_DEVCLASS_SYSTEM =
{ 0x4d36e97dL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } };


ULONG RDPDRINST_DetectInstall()
/*++

Routine Description:

    Return the number of RDPDR.SYS devices found.

Arguments:

    NA

Return Value:

    TRUE on success.  FALSE, otherwise.

--*/
{
    HDEVINFO            devInfoSet;
    SP_DEVINFO_DATA     deviceInfoData;
    DWORD               iLoop;
    BOOL                bMoreDevices;
    ULONG               count;
    TCHAR               pnpID[256];


    GUID *pGuid=(GUID *)&GUID_DEVCLASS_SYSTEM;

    //
    //  Get the set of all devices with the RDPDR PnP ID.
    //
    devInfoSet = SetupDiGetClassDevs(pGuid, NULL, NULL,
                                   DIGCF_PRESENT);
    if (devInfoSet == INVALID_HANDLE_VALUE) {
        fprintf(stderr, "Error getting RDPDR devices from PnP.  Error code:  %ld.",
                GetLastError());
        return 0;
    }

    // Get the first device.
    iLoop=0;
    deviceInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
    bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, iLoop, &deviceInfoData);

    // Get the details for all matching device interfaces.
    count = 0;
    while (bMoreDevices)
    {
        // Get the PnP ID for the device.
        if (!SetupDiGetDeviceRegistryProperty(devInfoSet, &deviceInfoData,
                                SPDRP_HARDWAREID, NULL, (BYTE *)pnpID,
                                sizeof(pnpID), NULL)) {
            fprintf(stderr, "Error fetching PnP ID in RDPDR device node remove.  Error code:  %ld.",
                        GetLastError());
        }

        // If the current device matches the RDPDR PNP ID
        if (!_tcscmp(pnpID, RDPDRPNPID)) {
            count++;
        }

        // Get the next one device interface.
        bMoreDevices=SetupDiEnumDeviceInfo(devInfoSet, ++iLoop, &deviceInfoData);
    }

    // Release the device info list.
    SetupDiDestroyDeviceInfoList(devInfoSet);

    return count;
}


//
//      Unit-Test
//
//void __cdecl main()
//{
//    ULONG count;
//    count = RDPDRINST_DetectInstall();
//    printf("Found %ld instance(s) of RDPDR.SYS.\n", count);
//}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\event.cpp ===
#include "stdafx.h"
// #include "winbase.h"

#define MAX_INSERT_STRS     5

TCHAR *aszTSEventSources[] = { _T("TermService"), _T("TermDD"), _T("TermServDevices") };

bool ExtractEvents();
bool ExtractAllTSEvents()
{
    cout << endl;
    return ExtractEvents ();
}

bool ExtractEvents ()
{
    USES_CONVERSION;
    bool bFoundEvents = false;



    HANDLE hEventLog = OpenEventLog(NULL, _T("System"));
    if (hEventLog)
    {

        const DWORD dwBytesToRead =  1024*10;

        char *pBuff = new char[dwBytesToRead];
        if (pBuff)
        {
            DWORD dwBytesRead, dwBytesNeeded;

            while (ReadEventLog(hEventLog,
                        EVENTLOG_BACKWARDS_READ | EVENTLOG_SEQUENTIAL_READ,
                        0,
                        PVOID(pBuff),
                        dwBytesToRead,
                        &dwBytesRead,
                        &dwBytesNeeded))
            {
                if (dwBytesRead == 0)
                    break;

                for (PEVENTLOGRECORD pEventLogRecord = ( PEVENTLOGRECORD ) pBuff;
                    PCHAR(pEventLogRecord) + pEventLogRecord->Length < pBuff + dwBytesRead;
                    pEventLogRecord = (EVENTLOGRECORD *)(PCHAR(pEventLogRecord) + pEventLogRecord->Length)
                    )
                {
                    LPCTSTR szSource = LPCTSTR(PBYTE(pEventLogRecord) + sizeof(EVENTLOGRECORD));


                    //
                    // check if event source is among interesting ones.
                    //

                    LPCTSTR szEventSource = NULL;
                    for (int i = 0; i < (sizeof(aszTSEventSources) / sizeof(aszTSEventSources[0])); i++)
                    {
                        if (_tcsicmp(szSource, aszTSEventSources[i]) == 0)
                            szEventSource = aszTSEventSources[i];
                    }

                    if (!szEventSource)
                        continue;


                    //
                    // prepare the array of insert strings for FormatMessage - the
                    // insert strings are in the log entry.
                    //
                    char *aInsertStrings[MAX_INSERT_STRS];

                    char *p = (char *) ((LPBYTE) pEventLogRecord + pEventLogRecord->StringOffset);
                    for (i = 0; i < pEventLogRecord->NumStrings && i < MAX_INSERT_STRS; i++)
                    {
                        aInsertStrings[i] = p;
                        p += strlen(p) + 1;     // point to next string
                    }



                    //
                    // Get the binaries to look message in from registry.
                    //

                    TCHAR szSourceKey[1024];
                    _tcscpy(szSourceKey, _T("SYSTEM\\CurrentControlSet\\Services\\EventLog\\System\\"));
                    _tcscat(szSourceKey, szEventSource);

                    CRegistry oReg;
                    TCHAR szSourcePath[MAX_PATH];

                    if (oReg.OpenKey(HKEY_LOCAL_MACHINE, szSourceKey, KEY_READ) == ERROR_SUCCESS)
                    {
                        LPTSTR str;
                        DWORD dwSize;
                        if (ERROR_SUCCESS == oReg.ReadRegString(_T("EventMessageFile"), &str, &dwSize))
                        {

                            ExpandEnvironmentStrings(str, szSourcePath, MAX_PATH);
                        }
                        else
                        {
                            cout << "       Error Reading Registry (" << T2A(szSourceKey) << ")/(EventMessageFiles)" << endl;
                            continue;
                        }

                    }
                    else
                    {
                        cout << "       Error Reading Registry (" << T2A(szSourceKey) << endl;
                        continue;
                    }

                    //
                    // Binary String in registry could contain multipal binaries seperated by ;
                    //

                    TCHAR *szModule;
                    szModule = _tcstok(szSourcePath, _T(";"));

                    //
                    // for each binary found
                    //

                    DWORD dwBytesTransfered = 0;
                    do
                    {
                        HINSTANCE hModule = LoadLibrary(szModule);

                        TCHAR szMessage[1024];
                        dwBytesTransfered = FormatMessage(
                                            FORMAT_MESSAGE_FROM_HMODULE |
                                            FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                            hModule,
                                            pEventLogRecord->EventID,
                                            0,
                                            szMessage,
                                            1024,
					    (va_list *)aInsertStrings);

                        if (dwBytesTransfered)
                        {
                            bFoundEvents = true;
                            TCHAR szTimeString[512];
                            _tcsftime(szTimeString, 512, _T("%c"), localtime( (const time_t *)&pEventLogRecord->TimeGenerated ));
                            cout <<  "       " << T2A(szTimeString) << ": ( " << T2A(szEventSource) << " ) : " << T2A(szMessage);
                        }
                        else
                        {
                            cout << "       FormatMessage Failed. lasterror = " << GetLastError() << endl;
                        }

                        szModule = _tcstok(NULL, _T(";"));

                    }
                    while (!dwBytesTransfered && szModule);

                }


            }

        }

    }
    else
    {
        cout << "       Failed to Open Event log." << endl;
        return false;
    }

    return bFoundEvents;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\stdafx.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by tsdiag.rc
//
#define IDS_PROJNAME                    100
			
#define IDS_MACHINENAME					101
#define IDS_MACHINENAME_FAILED					201
#define IDS_DOMAINNAME					102
#define IDS_DOMAINNAME_FAILED					202
#define IDS_IP_ADDRESS					103
#define IDS_IP_ADDRESS_FAILED					203
#define IDS_PRODUCTTYPE					104
#define IDS_PRODUCTTYPE_FAILED					204
#define IDS_PRODUCTSUITE				105
#define IDS_PRODUCTSUITE_FAILED				205
#define IDS_TSVERSION					106
#define IDS_TSVERSION_FAILED					206
#define IDS_ISSERVER					107
#define IDS_ISSERVER_FAILED					207
#define IDS_CLIENT_VERSION				108
#define IDS_CLIENT_VERSION_FAILED				208
#define IDS_SESSION_USERNAME			109
#define IDS_SESSION_USERNAME_FAILED			209
#define IDS_IS_TSOCLOG_PRESENT			110
#define IDS_IS_TSOCLOG_PRESENT_FAILED			210
#define IDS_DID_SETUP_FINISH			111
#define IDS_DID_SETUP_FINISH_FAILED			211
#define IDS_CLUSTERING_INSTALLED		112
#define IDS_CLUSTERING_INSTALLED_FAILED		212
#define IDS_IS_TSPRODUCT				113
#define IDS_IS_TSPRODUCT_FAILED				213
#define IDS_DID_OCM_INSTALL_TS			114
#define IDS_DID_OCM_INSTALL_TS_FAILED			214
#define IDS_IS_TS_ENABLED				115
#define IDS_IS_TS_ENABLED_FAILED				215
#define IDS_IS_KERNEL_TSENABLED			116
#define IDS_IS_KERNEL_TSENABLED_FAILED			216
#define IDS_IS_TSREGISTRY_OK			117
#define IDS_IS_TSREGISTRY_OK_FAILED			217
#define IDS_WINSTATIONS_OK				118
#define IDS_WINSTATIONS_OK_FAILED				218
#define IDS_IS_TERMSRV_RUNNING			119
#define IDS_IS_TERMSRV_RUNNING_FAILED			219
#define IDS_IS_TS_STARTBIT_OK			120
#define IDS_IS_TS_STARTBIT_OK_FAILED			220
#define IDS_IS_TS_IN_SYSTEM_CONTEXT		121
#define IDS_IS_TS_IN_SYSTEM_CONTEXT_FAILED		221
#define IDS_IS_LISTNER_PRESENT			122
#define IDS_IS_LISTNER_PRESENT_FAILED			222
#define IDS_REMOTE_CONNECTION_GP		123
#define IDS_REMOTE_CONNECTION_GP_FAILED		223
#define IDS_REMOTE_CONNECTION_LOCAL		124
#define IDS_REMOTE_CONNECTION_LOCAL_FAILED		224
#define IDS_RDPDR_INSTALLED				125
#define IDS_RDPDR_INSTALLED_FAILED				225
#define IDS_RDPNP_INSTALLED				126
#define IDS_RDPNP_INSTALLED_FAILED				226
#define IDS_MULTIPAL_CONNECTION_ALLOWED	127
#define IDS_MULTIPAL_CONNECTION_ALLOWED_FAILED	227
#define IDS_LOGON_UI					128
#define IDS_LOGON_UI_FAILED					228
#define IDS_TS_MODE						129
#define IDS_TS_MODE_FAILED						229
#define IDS_IS_MODE_REGISTRYOK			130
#define IDS_IS_MODE_REGISTRYOK_FAILED			230
#define IDS_PERM_MODE					131
#define IDS_PERM_MODE_FAILED					231
#define IDS_STACK_BINARIES_SIGNED		132
#define IDS_STACK_BINARIES_SIGNED_FAILED		232
#define IDS_ENCRYPTION_LEVEL			133
#define IDS_ENCRYPTION_LEVEL_FAILED			233
#define IDS_IS_BETA_SYSTEM				134
#define IDS_IS_BETA_SYSTEM_FAILED				234
#define IDS_GRACE_PERIOD_OK				135
#define IDS_GRACE_PERIOD_OK_FAILED				235
#define IDS_CLIENT_SUPPORT_AUDIO		136
#define IDS_CLIENT_SUPPORT_AUDIO_FAILED		236
#define IDS_CLIENT_SUPPORT_PRINTER		137
#define IDS_CLIENT_SUPPORT_PRINTER_FAILED		237
#define IDS_CLIENT_SUPPORT_FILE			138
#define IDS_CLIENT_SUPPORT_FILE_FAILED			238
#define IDS_CLIENT_SUPPORT_CLIPBOARD	139
#define IDS_CLIENT_SUPPORT_CLIPBOARD_FAILED	239
#define IDS_TERMSRV_CONFIG_PRINTER		140
#define IDS_TERMSRV_CONFIG_PRINTER_FAILED		240
#define IDS_TERMSRV_CONFIG_AUDIO		141
#define IDS_TERMSRV_CONFIG_AUDIO_FAILED		241
#define IDS_TERMSRV_CONFIG_COM			142
#define IDS_TERMSRV_CONFIG_COM_FAILED			242
#define IDS_TERMSRV_CONFIG_CLIPBOARD	143
#define IDS_TERMSRV_CONFIG_CLIPBOARD_FAILED	243
#define IDS_TERMSRV_CONFIG_FILE			145
#define IDS_TERMSRV_CONFIG_FILE_FAILED			245
#define IDS_TERMSRV_CONFIG_LPT			146
#define IDS_TERMSRV_CONFIG_LPT_FAILED			246
#define IDS_REMOTELOGON_ENABLED			147
#define IDS_REMOTELOGON_ENABLED_FAILED			148

#define IDS_TERMSRV_CLIENT_AUDIO_ENABLED        149
#define IDS_TERMSRV_CLIENT_AUDIO_ENABLED_FAILED 150
#define IDS_TERMSRV_CLIENT_AUDIO_SETTINGS       151
#define IDS_TERMSRV_CLIENT_AUDIO_SETTINGS_FAILED 152

#define IDR_TSDIAGNOSIS                 101
#define IDD_DIALOG1                     501

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\ping.cpp ===
// ping.cpp
#include "stdafx.h"
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <snmp.h>
#include <winsock2.h>

#include "llinfo.h"
//#include "tcpcmd.h"
#include "ipexport.h"
#include "icmpapi.h"
//#include "nlstxt.h"
#include "Icmpapi.h"

#include "tstst.h"
#include "testdata.h"

unsigned long get_pingee(char *ahstr, char **hstr, int *was_inaddr, int dnsreq)
{
    struct hostent *hostp = NULL;
    long            inaddr;

    if ( strcmp( ahstr, "255.255.255.255" ) == 0 ) {
        return(0L);
    }

    if ((inaddr = inet_addr(ahstr)) == -1L) {
        hostp = gethostbyname(ahstr);
        if (hostp) {
            /*
             * If we find a host entry, set up the internet address
             */
            inaddr = *(long *)hostp->h_addr;
            *was_inaddr = 0;
        } else {
            // Neither dotted, not name.
            return(0L);
        }

    } else {
        // Is dotted.
        *was_inaddr = 1;
        if (dnsreq == 1) {
            hostp = gethostbyaddr((char *)&inaddr,sizeof(inaddr),AF_INET);
        }
    }

    *hstr = hostp ? hostp->h_name : (char *)NULL;
    return(inaddr);
}

bool CanPing ()
{
	if (!CTSTestData::GetMachineName())
		return true;

	USES_CONVERSION;
	const Timeout = 4000L;

	WSADATA WsaData;
    if (WSAStartup( 0x0101, &WsaData)) 
	{
		return false;
    }

	HANDLE  IcmpHandle;
	IcmpHandle = IcmpCreateFile();
	if (IcmpHandle == INVALID_HANDLE_VALUE)
	{
		return false;
	}
	
	char    *hostname = NULL;
	int     was_inaddr;
	int     dnsreq = 0;
	IPAddr  address = 0;
	address = get_pingee(T2A(CTSTestData::GetMachineName()), &hostname, &was_inaddr, dnsreq);
	if ( !address || (address == INADDR_NONE) ) 
	{
		return false;
	}

	const SendSize = 32;
	const RecvSize = 0x2000 - 8;
	char *SendBuffer = (char *)LocalAlloc(LMEM_FIXED, SendSize);
	char *RcvBuffer = (char *)LocalAlloc(LMEM_FIXED, RecvSize);
	if (!RcvBuffer || !SendBuffer)
	{
		if (RcvBuffer)
			LocalFree(RcvBuffer);

		if (SendBuffer)
			LocalFree(SendBuffer);

		return false;
	}
	
	IP_OPTION_INFORMATION SendOpts;
    SendOpts.OptionsData = NULL;
    SendOpts.OptionsSize = 0;
    SendOpts.Ttl = 128;
    SendOpts.Tos = 0;
    SendOpts.Flags = 0;

    if (IcmpSendEcho2(IcmpHandle,
                     0,
                     NULL,
                     NULL,
                     address,
                     SendBuffer,
                     (unsigned short) SendSize,
                     &SendOpts,
                     RcvBuffer,
                     RecvSize,
                     Timeout) == 0) 
	{
		return false;
	}

	IcmpCloseHandle(IcmpHandle);
	LocalFree(SendBuffer);
	LocalFree(RcvBuffer);

	return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\stdafx.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/*
 *
 *  Module Name:
 *
 *      hydraoc.h
 *
 *  Abstract:
 *
 *      Common Header file for the HydraOC Component.
 *      HydraOc Component is an optional component which installs Termainal Server (Hydra)
 *
 *  Author:
 *
 *
 *  Environment:
 *
 *    User Mode
 */

#ifndef _stdafx_h_
#define _stdafx_h_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <devguid.h>
#include <initguid.h>
#include <objbase.h>
#include <tchar.h>
#include <time.h>
#include <stdio.h>
#include <setupapi.h>
#include <prsht.h>
#include <loadperf.h>
#include <shellapi.h>
#include <shlobj.h>
#include <commdlg.h>
#include <lm.h>
#include <lmerr.h>
#include <lmserver.h>
#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>
#include <string.h>
#include <clusapi.h>        // for GetNodeClusterState
#include <malloc.h>
#include <stddef.h>
#include <wincrypt.h>
#include <imagehlp.h>


#include <coguid.h>
#pragma message ("*** Including comdef.h ")
#include <comdef.h>
#pragma message ("*** Including atlbase.h ")
#include <atlbase.h>

//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#pragma message ("*** Including atlcom.h ")

#include <atlcom.h>
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>


#include "Registry.h"       // CRegistry
#include "logmsg.h"


#define AssertFalse() ASSERT(FALSE)
#define VERIFY(x)     RTL_VERIFY(x)
#pragma message ("*** done with stdaf.h ")

#endif // _stdafx_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\suite.h ===
// Suite.h: interface for the CSuite class.
//
//////////////////////////////////////////////////////////////////////
#include "test.h"

#if !defined(AFX_SUITE_H__F1A2E086_3DAE_4F83_ABEA_BF59D1571439__INCLUDED_)
#define AFX_SUITE_H__F1A2E086_3DAE_4F83_ABEA_BF59D1571439__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class ATL_NO_VTABLE CSuite : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CTest, &CLSID_TSDiagnosis>,
	public IDispatchImpl<ITestSuite, &IID_ITestSuite, &LIBID_TSDIAGLib>

{
public:
	CSuite();
	virtual ~CSuite();

DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSuite)
	COM_INTERFACE_ENTRY(ITestSuite)
	COM_INTERFACE_ENTRY2(IDispatch, ITest)
END_COM_MAP()

// ITestSuite
public:
		STDMETHOD(get_Name)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(get_Description)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(get_IsApplicable)(/*[out, retval]*/ BOOL *pVal);
		STDMETHOD(get_WhyNotApplicable)(/*[out, retval]*/ BSTR  *pVal);
		
		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
		STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *pVal);
		STDMETHOD(get_Item)(/*[in]*/ VARIANT Index, /*[out, retval]*/ VARIANT *pVal);

		void SetSuiteIndex (DWORD dwSuite);

private:
	
	DWORD m_dwSuiteIndex;
	void SetInvalidSuiteIndex() {m_dwSuiteIndex = 0xffffffff;};
	bool IsValid() const		{return m_dwSuiteIndex != 0xffffffff;};
	bool GetTest(const VARIANT &Index, DWORD dwSuiteIndex, PTVerificationTest *ppTest);

	
};

#endif // !defined(AFX_SUITE_H__F1A2E086_3DAE_4F83_ABEA_BF59D1571439__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\suites.cpp ===
// Suites.cpp: implementation of the CSuites class.
//
//////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "TSDiag.h"
#include "Suites.h"

#include "suite.h"
#include "testdata.h"



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CSuites::CSuites()
{

}

CSuites::~CSuites()
{

}


STDMETHODIMP CSuites::get_Count(long *pVal)
{
	if (!pVal)
		return E_POINTER;

	*pVal = GlobalTestData.GetSuiteCount();
	return S_OK;
}

STDMETHODIMP CSuites::get__NewEnum(LPUNKNOWN *pVal)
{
	if (!pVal)
		return E_POINTER;

	return E_NOTIMPL;
}

STDMETHODIMP CSuites::get_Item(VARIANT Index, VARIANT *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}


	// BUGBUG find right index value.
	DWORD dwIndex;
	if (!SuiteIndexFromVarient(Index, &dwIndex ))
	{
		return E_INVALIDARG;
	}

	ASSERT(dwIndex < GlobalTestData.GetSuiteCount());

	CComObject<CSuite> *pSuite;
	HRESULT hr = CComObject<CSuite>::CreateInstance(&pSuite);
	if (FAILED(hr))
		return hr;

	// if we need to initialize our Suite object, it should be done here.
	pSuite->SetSuiteIndex(dwIndex);
	
	IDispatch* pDisp = NULL;

	hr = pSuite->QueryInterface(&pDisp);
	if (SUCCEEDED(hr))
	{
		VariantInit(pVal);
		pVal->vt = VT_DISPATCH;
		pVal->pdispVal = pDisp;

	}
	else
	{
		delete pSuite;
	}

	return hr;
	
}

bool CSuites::SuiteIndexFromVarient(const VARIANT &Index, DWORD *pdwIndex)
{
	ASSERT(pdwIndex);
	*pdwIndex = 0xffffffff;

	switch(Index.vt)
	{
	case VT_I4:
	case VT_UI2:
	case VT_UINT:
	case VT_INT:
	case VT_I2:
		{
			if ((Index.iVal >= 0) && (DWORD(Index.iVal) < GlobalTestData.GetSuiteCount()))
			{
				*pdwIndex = Index.iVal;
				return true;
			}
			else 
			{
				return false;
			}
		}
		break;

	case VT_BSTR :
		{
			if (!Index.bstrVal)
			{
				return false;
			}
			else
			{
				for (DWORD dw = 0; dw < GlobalTestData.GetSuiteCount(); dw++)
				{
					if (_tcscmp(GlobalTestData.GetSuiteName(dw), Index.bstrVal) == 0)
					{
						// ok we got the index
						*pdwIndex = dw;
						return true;
					}
				}
				
				return false;
			}
		}
		break;

	default:
		return false;
		break;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\suite.cpp ===
// Suite.cpp: implementation of the CSuite class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TSDiag.h"

#include "Suite.h"

#include "testdata.h"
#include "test.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////



CSuite::CSuite()
{
	SetInvalidSuiteIndex();
}

CSuite::~CSuite()
{

}


void CSuite::SetSuiteIndex (DWORD dwSuite)
{
	ASSERT(GlobalTestData.GetSuiteCount() > dwSuite);
	m_dwSuiteIndex = dwSuite;
}

STDMETHODIMP CSuite::get_Name(BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	bstr_t bstr = GlobalTestData.GetSuiteName(m_dwSuiteIndex);
	*pVal = bstr.copy();
	return S_OK;
}

STDMETHODIMP CSuite::get_Description(BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
	bstr_t bstr = GlobalTestData.GetSuiteName(m_dwSuiteIndex);
	*pVal = bstr.copy();

	return E_NOTIMPL;
}

STDMETHODIMP CSuite::get_IsApplicable(BOOL *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	*pVal = GlobalTestData.CanExecuteSuite(m_dwSuiteIndex);
	return S_OK;
}

STDMETHODIMP CSuite::get_WhyNotApplicable(BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	if (GlobalTestData.CanExecuteSuite(m_dwSuiteIndex))
	{
		return CO_E_NOTCONSTRUCTED;
	}

	bstr_t bstr = GlobalTestData.GetSuiteErrorText(m_dwSuiteIndex);
	*pVal = bstr.copy();

	return S_OK;
}

STDMETHODIMP CSuite::get_Count(long *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	*pVal = GlobalTestData.GetTestCount(m_dwSuiteIndex);

	return S_OK;
}

STDMETHODIMP CSuite::get__NewEnum(LPUNKNOWN *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	return E_NOTIMPL;
}

STDMETHODIMP CSuite::get_Item(VARIANT Index, VARIANT *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	CComObject<CTest> *pTest;
	
	HRESULT hr = CComObject<CTest>::CreateInstance(&pTest);
	if (FAILED(hr))
	{
		return hr;
	}

	PTVerificationTest ptheTest;
	if (!GetTest(Index, m_dwSuiteIndex, &ptheTest))
	{
		delete pTest;
		return E_INVALIDARG;
	}
	
	// initialize test object;
	pTest->SetTest(ptheTest);
	IDispatch* pDisp = NULL;

	hr = pTest->QueryInterface(&pDisp);
	if (SUCCEEDED(hr))
	{
		pVal->vt = VT_DISPATCH;
		pVal->pdispVal = pDisp;

		// if we need to initialize our Suites object, it should be done here.
	}
	else
	{
		delete pTest;
	}

	return hr;
}


bool CSuite::GetTest(const VARIANT &Index, DWORD dwSuiteIndex, PTVerificationTest *ppTest)
{
	ASSERT(	IsValid() );

	ASSERT(ppTest);
	ASSERT(dwSuiteIndex < GlobalTestData.GetSuiteCount());
	
	*ppTest = NULL;
	

	switch(Index.vt)
	{
	case VT_I4 :
	case VT_UI2:
	case VT_UINT:
	case VT_INT:
	case VT_I2:
		{
			if ((Index.iVal >= 0) && (DWORD(Index.iVal) < GlobalTestData.GetTestCount(dwSuiteIndex)))
			{
				*ppTest = GlobalTestData.GetTest(dwSuiteIndex, Index.iVal);
				return true;
			}
			else 
			{
				return false;
			}
		}
		break;

	case VT_BSTR :
		{
			if (!Index.bstrVal)
			{
				return false;
			}
			else
			{
				for (DWORD dw = 0; dw < GlobalTestData.GetTestCount(dwSuiteIndex); dw++)
				{
					USES_CONVERSION;
					CComBSTR bstr;
					VERIFY(bstr.LoadString(GlobalTestData.GetTest(dwSuiteIndex, dw)->uiName));
					if (_tcscmp(bstr, Index.bstrVal) == 0)
					{
						// ok we got the index
						*ppTest = GlobalTestData.GetTest(dwSuiteIndex, dw);
						return true;
					}
				}
				
				return false;
			}
		}
		break;

	default:
		return false;
		break;
	}
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\suites.h ===
// Suites.h: interface for the CSuites class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SUITES_H__50063540_1265_4B9D_AB5E_579294044F0B__INCLUDED_)
#define AFX_SUITES_H__50063540_1265_4B9D_AB5E_579294044F0B__INCLUDED_

#include "resource.h"       // main symbols
#include "testdata.h"		// for CTSTestData 


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class ATL_NO_VTABLE CSuites : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CTest, &CLSID_TSDiagnosis>,
	public IDispatchImpl<ITestSuites, &IID_ITestSuites, &LIBID_TSDIAGLib>

{
public:
	CSuites();
	virtual ~CSuites();


DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSuites)
	COM_INTERFACE_ENTRY(ITestSuites)
	COM_INTERFACE_ENTRY2(IDispatch, ITestSuites)
END_COM_MAP()

// ITestSuites
public:
		STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
		STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *pVal);
		STDMETHOD(get_Item)(/*[in]*/ VARIANT Index, /*[out, retval]*/ VARIANT *pVal);

private:

	static bool SuiteIndexFromVarient(const VARIANT &pIndex, DWORD *pdwIndex);
	// our data and private functions, declared here.
};

#endif // !defined(AFX_SUITES_H__50063540_1265_4B9D_AB5E_579294044F0B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\test.h ===
// Test.h: interface for the CTest class.
//
//////////////////////////////////////////////////////////////////////


#if !defined(AFX_TEST_H__3761055A_21CF_4689_908F_1758001D332D__INCLUDED_)
#define AFX_TEST_H__3761055A_21CF_4689_908F_1758001D332D__INCLUDED_

//#import "F:\nt\termsrv\setup\tsdiag\dll\obj\i386\tsdiag.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids 
//#import "tsdiag.tlb" raw_interfaces_only, raw_native_types, no_namespace, named_guids 
#include "resource.h"       // main symbols
#include "testdata.h"		// for CTSTestData 
#include "tstst.h"


#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class ATL_NO_VTABLE CTest : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CTest, &CLSID_TSDiagnosis>,
	public IDispatchImpl<ITest, &IID_ITest, &LIBID_TSDIAGLib>
{
public:
	CTest();
	virtual ~CTest();


DECLARE_NO_REGISTRY()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTest)
	COM_INTERFACE_ENTRY(ITest)
	COM_INTERFACE_ENTRY2(IDispatch, ITest)
END_COM_MAP()

// ITest
public:
		STDMETHOD(get_Name)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(get_Description)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(get_IsApplicable)(/*[out, retval]*/ BOOL *pVal);
		STDMETHOD(get_WhyNotApplicable)(/*[out, retval]*/ BSTR  *pVal);
		STDMETHOD(Execute)();
		STDMETHOD(get_Result)(/*[out, retval]*/ long *pVal);
		STDMETHOD(get_ResultString)(/*[out, retval]*/ BSTR *pVal);
		STDMETHOD(get_ResultDetails)(/*[out, retval]*/ BSTR *pVal);

		void SetTest(PTVerificationTest ptheTest) { m_pTest = ptheTest;}

private:

	bool m_bTestRun;
	EResult m_eResult;
	bstr_t m_bstrResult;
	bstr_t m_bDetails;
	PTVerificationTest m_pTest;
	bool IsValid() const { return m_pTest != NULL;};
};

#endif // !defined(AFX_TEST_H__3761055A_21CF_4689_908F_1758001D332D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\test.cpp ===
// Test.cpp: implementation of the CTest class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "TSDiag.h"
#include "Test.h"

//#include "tstst.h"
#include "testdata.h"



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CTest::CTest() : m_pTest(0), m_bTestRun(false)
{

}

CTest::~CTest()
{

}

STDMETHODIMP CTest::get_Name (BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	CComBSTR bstr;
	bstr.LoadString(m_pTest->uiName);
	*pVal = bstr.Copy();
	return S_OK;
}

STDMETHODIMP CTest::get_Description (BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
//	bstr_t bstr = m_pTest->szTestName;
//	*pVal = bstr.copy();
	return E_NOTIMPL;
}

STDMETHODIMP CTest::get_IsApplicable (BOOL *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
	if (m_pTest->pfnNeedRunTest)
	{
		*pVal = (*m_pTest->pfnNeedRunTest)();
	}
	else
	{
		*pVal = true;
	}

	return S_OK;
}

STDMETHODIMP CTest::get_WhyNotApplicable (BSTR  *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	bstr_t bstr = m_pTest->TestDetails;
	*pVal = bstr.copy();

	return S_OK;
}

STDMETHODIMP CTest::Execute ()
{
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	if (m_pTest->pfnNeedRunTest && !(*m_pTest->pfnNeedRunTest)())
	{
		return ERROR_INVALID_PARAMETER;
	}

	char szOutput[512];
	
	ostrstream oTestResult(szOutput, 512);
	ZeroMemory(oTestResult.str(), 512);
	
	m_eResult = (*m_pTest->pfnTestFunc)(oTestResult);
	m_bstrResult  = oTestResult.str();
	m_bTestRun = true;

	return S_OK;
}

STDMETHODIMP CTest::get_Result (long *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}

	if (!m_bTestRun)
	{
		return CO_E_NOTCONSTRUCTED;
	}

	*pVal = m_eResult;
	return S_OK;
}

STDMETHODIMP CTest::get_ResultString (BSTR *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
	if (!m_bTestRun)
	{
		return CO_E_NOTCONSTRUCTED;
	}

	*pVal = m_bstrResult.copy();

	return S_OK;
}

STDMETHODIMP CTest::get_ResultDetails (BSTR *pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}
	
	if (!IsValid())
	{
		return CO_E_NOTCONSTRUCTED;
	}
	
	if (!m_bTestRun)
	{
		return CO_E_NOTCONSTRUCTED;
	}

	UINT uiDetailsResource = m_pTest->uiTestDetailsLocal;
	if (!IsItLocalMachine() && m_pTest->uiTestDetailsRemote != 0)
	{
		uiDetailsResource = m_pTest->uiTestDetailsRemote;
	}

	CComBSTR bstr;
	bstr.LoadString(uiDetailsResource);
	*pVal = bstr.Copy();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\testdata.h ===
#ifndef __testdata_h__
#define __testdata_h__

#include "tst.h"

class CTSTestData :public CTestData
{

private:
	

public:
	
	CTSTestData();
	~CTSTestData();

	virtual bool				CanExecuteSuite (DWORD dwSuite) const;
	virtual LPCTSTR				GetSuiteErrorText (DWORD dwSuite) const;
	virtual DWORD 				GetSuiteCount	() const;
	virtual LPCTSTR				GetSuiteName	(DWORD dwSuite) const;
	virtual DWORD				GetTestCount    (DWORD dwSuite) const;
	virtual PTVerificationTest	GetTest			(DWORD dwSuite, DWORD iTestNumber) const;
	
	static BOOL					SetMachineName	(LPCTSTR lpMachineName);
	static LPCTSTR			    GetMachineName  ();
	static LPCTSTR				GetMachineNamePath  ();

	static LPTSTR m_lpMachineName;

};


#ifndef ____InsideTestData____
extern 
#endif 

CTSTestData GlobalTestData;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\tscert.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

#include "stdafx.h"

#define MemAlloc malloc // for certfy.inc
#define MemFree free

#include "../../tscert/inc/pubblob.h"    // needed by certvfy.inc
#include "../../tscert/inc/certvfy.inc"  // VerifyFile()


bool FileExists (char *pszFullNameAndPath); // from tstst.cpp

bool CheckifBinaryisSigned(TCHAR *szFile)
{
    USES_CONVERSION;
    TCHAR szFullFile[MAX_PATH +1];
    RTL_CRITICAL_SECTION VfyLock;

    if (ExpandEnvironmentStrings(szFile, szFullFile, MAX_PATH))
    {
        if (FileExists(T2A(szFullFile)))
        {
            RtlInitializeCriticalSection( &VfyLock );

            if ( VerifyFile( T2W(szFullFile), &VfyLock ) )
            {
                return true;
            }
        }

    }

    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\timebomb.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation
#include "stdafx.h"
#include "license.h"
#include "tlsapi.h"
#include "tlsapip.h"
#include "secstore.h"

#define LICENSING_TIME_BOMB L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

#define LICENSING_TIME_BOMB_5_0 L"TIMEBOMB_832cc540-3244-11d2-b416-00c04fa30cc4"
#define RTMLICENSING_TIME_BOMB_5_0 L"RTMTSTB_832cc540-3244-11d2-b416-00c04fa30cc4"

// L$ means only readable from the local machine

#define BETA_LICENSING_TIME_BOMB_5_1 L"L$BETA3TIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define RTM_LICENSING_TIME_BOMB_5_1 L"L$RTMTIMEBOMB_1320153D-8DA3-4e8e-B27B-0D888223A588"

#define BETA_LICENSING_TIME_BOMB_LATEST_VERSION BETA_LICENSING_TIME_BOMB_5_1

#define RTM_LICENSING_TIME_BOMB_LATEST_VERSION RTM_LICENSING_TIME_BOMB_5_1

#define X509_CERT_PRIVATE_KEY_NAME \
    L"L$HYDRAENCKEY_dd2d98db-2316-11d2-b414-00c04fa30cc4"

///////////////////////////////////////////////////////////////////

typedef BOOL
(* TLSISBETANTSERVER)();

BOOL FIsBetaSystem ()
{
    HMODULE hmodTlsAPI = LoadLibrary( _T("mstlsapi.dll") );

    if (hmodTlsAPI)
    {
        TLSISBETANTSERVER pfnTLSIsBetaNTServer;
        BOOL fBeta = FALSE;
        
        pfnTLSIsBetaNTServer = (TLSISBETANTSERVER) GetProcAddress(hmodTlsAPI,"TLSIsBetaNTServer");

        if (NULL != pfnTLSIsBetaNTServer)
        {
            fBeta = pfnTLSIsBetaNTServer();
        }

        FreeLibrary(hmodTlsAPI);

        return fBeta;
    }
    else
    {
        return FALSE;
    }
}

bool IsBetaSystem ()
{
    return (FIsBetaSystem() != 0);
}

bool HasLicenceGracePeriodExpired ()
{
    DWORD status;
    DWORD  cbByte;
    PBYTE  pbByte = NULL;
    LPWSTR szTimeBombKey;
    FILETIME timebomb;
    FILETIME filetimeCurrent;
    DWORD dwVersion;


    dwVersion = GetVersion();

    if ((dwVersion & 0x80000000)
        || (LOBYTE(LOWORD(dwVersion)) <= 4))
    {
        cout << endl << "       Pre-Windows 2000.  No grace period";
        return false;
    }
    else if ((LOBYTE(LOWORD(dwVersion)) == 5)
             && (HIBYTE(LOWORD(dwVersion)) == 0))
    {
        // Windows 2000

        if (FIsBetaSystem())
            szTimeBombKey = LICENSING_TIME_BOMB_5_0;
        else
            szTimeBombKey = RTMLICENSING_TIME_BOMB_5_0;
    }
    else if ((LOBYTE(LOWORD(dwVersion)) == 5)
             && (HIBYTE(LOWORD(dwVersion)) == 1))
    {
        // Whistler

        if (FIsBetaSystem())
            szTimeBombKey = BETA_LICENSING_TIME_BOMB_5_1;
        else
            szTimeBombKey = RTM_LICENSING_TIME_BOMB_5_1;
    }
    else
    {
        cout << endl << "       Unknown OS.  Assume no grace period";
        return false;
    }

    status = RetrieveKey(
                         szTimeBombKey,
                         &pbByte,
                         &cbByte
                         );


    if(status == ERROR_SUCCESS && pbByte)
    {
        timebomb = *(FILETIME *)pbByte;


        GetSystemTimeAsFileTime(&filetimeCurrent);

        // yes license has expired if filetimeCurrent >= timebomb
        return (CompareFileTime(&timebomb, &filetimeCurrent) < 1);

    }
    else
    {
        // It hasn't been set yet, so we're not expired

        return false;
    }
}

static gdwCount = 0;
static TCHAR gLicenseServers[1024];

BOOL ServerEnumCallBack(
    IN TLS_HANDLE hHandle,
    IN LPCTSTR pszServerName,
    IN HANDLE /* dwUserData */)
{
    USES_CONVERSION;

    if (hHandle)
    {
		_tcscat(gLicenseServers, pszServerName);
        cout << endl << "       Found #" << ++gdwCount << ":"<< T2A(pszServerName);
    }


    return 0;
}

typedef HANDLE
(* TLSCONNECTTOANYLSSERVER)(  
    DWORD dwTimeOut
);

typedef DWORD 
(* ENUMERATETLSSERVERNEW)(  
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);


typedef DWORD 
(* ENUMERATETLSSERVEROLD)(  
    LPCTSTR szDomain,
    LPCTSTR szScope, 
    DWORD dwPlatformType, 
    TLSENUMERATECALLBACK fCallBack, 
    HANDLE dwUserData,
    DWORD dwTimeOut,
    BOOL fRegOnly
);

bool EnumerateLicenseServers ()
{
    HMODULE hmodTlsAPI = LoadLibrary( _T("mstlsapi.dll") );

    if (hmodTlsAPI)
    {
        DWORD dwResult;
		_tcscat(gLicenseServers, _T(""));

        // load TLSShutdown to see if we have the new APIs
        if (NULL == GetProcAddress(hmodTlsAPI,"TLSShutdown"))
        {
            ENUMERATETLSSERVEROLD pfnEnumerateTlsServer;

            pfnEnumerateTlsServer = (ENUMERATETLSSERVEROLD) GetProcAddress(hmodTlsAPI,"EnumerateTlsServer");

            if (NULL != pfnEnumerateTlsServer)
            {

                dwResult = pfnEnumerateTlsServer(
                            NULL,
                            NULL,
                            LSKEYPACKPLATFORMTYPE_UNKNOWN,
                            ServerEnumCallBack,
                            0,
                            0,
                            FALSE);
            }
            else
            {
                cout << endl << "       Failed to GetProcAddress,ErrorCode = " << GetLastError() << endl;

                return false;
            }
        }
        else
        {
            if (NULL != GetProcAddress(hmodTlsAPI,"TLSGetSupportFlags"))
            {
                // Use newer discovery function

                TLSCONNECTTOANYLSSERVER pfnTLSConnectToAnyLsServer;
                TLS_HANDLE hServer;

                pfnTLSConnectToAnyLsServer = (TLSCONNECTTOANYLSSERVER) GetProcAddress(hmodTlsAPI,"TLSConnectToAnyLsServer");

                if (NULL != pfnTLSConnectToAnyLsServer)
                {
                    hServer = pfnTLSConnectToAnyLsServer(INFINITE);

                    if (NULL != hServer)
                    {
                        return true;
                    }
                    else
                    {
                        return false;
                    }
                }
                else
                {
                    cout << endl << "       Failed to GetProcAddress TLSConnectToAnyLsServer,ErrorCode = " << GetLastError() << endl;
                    
                    return FALSE;
                }
            }
            else
            {
                ENUMERATETLSSERVERNEW pfnEnumerateTlsServer;
        
                pfnEnumerateTlsServer = (ENUMERATETLSSERVERNEW) GetProcAddress(hmodTlsAPI,"EnumerateTlsServer");

                if (NULL != pfnEnumerateTlsServer)
                {
                    dwResult = pfnEnumerateTlsServer(
                                                     ServerEnumCallBack,
                                                     0,
                                                     0,
                                                     FALSE);
                }
                else
                {
                    cout << endl << "       Failed to GetProcAddress,ErrorCode = " << GetLastError() << endl;

                    return false;
                }
            }
        }
        
        FreeLibrary(hmodTlsAPI);
        
        if (dwResult != NO_ERROR)
            cout << endl << "       Failed to EnumerateTlsServer,ErrorCode = " << dwResult << endl;


        if (gdwCount > 0)
            cout << endl;

        return gdwCount > 0;

    }
    else
    {
        cout << endl << "       Failed to load mstlsapi.dll,ErrorCode = " << GetLastError() << endl;

        return false;
    }

}

TCHAR *GetLicenseServers ()
{	
	if (EnumerateLicenseServers ())
		return gLicenseServers;
	else
		return TEXT("Failed");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\tsdgns.cpp ===
// tsdgns.cpp : Implementation of CTSDiagnosis
#include "stdafx.h"
#include "TSDiag.h"
#include "tsdgns.h"

#include "testdata.h"
#include "suites.h"


static int iTSDiag = 0;
CTSDiagnosis::CTSDiagnosis()
{
	m_dwSuite = 0;
	iTSDiag++;
	TCHAR szString[256];
	_stprintf(szString, _T("iTSDiag = %d\n"), iTSDiag);
	OutputDebugString(szString);

}


CTSDiagnosis::~CTSDiagnosis()
{
	iTSDiag--;
	TCHAR szString[256];
	_stprintf(szString, _T("iTSDiag = %d\n"), iTSDiag);
	OutputDebugString(szString);
}

DWORD CTSDiagnosis::GetTotalTestCount ()
{
	return GlobalTestData.GetTestCount(m_dwSuite);

}
STDMETHODIMP CTSDiagnosis::get_TestCount(long *pVal)
{
	// TODO: Add your implementation code here
	*pVal = GetTotalTestCount ();
	return ERROR_SUCCESS;
}

STDMETHODIMP CTSDiagnosis::get_TestDescription(int i, BSTR * pVal)
{
	
	// TODO: Add your implementation code here
	if (i >= (int)GetTotalTestCount ())
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	return E_NOTIMPL;


	return ERROR_SUCCESS;
}

STDMETHODIMP CTSDiagnosis::get_TestApplicable(int i, BOOL *pbApplicable)
{
	if (i >= (int)GetTotalTestCount ())
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (!pbApplicable)
	{
		return ERROR_INVALID_PARAMETER;
	}
	
	PTVerificationTest pTest = GlobalTestData.GetTest(m_dwSuite, i);
	if (pTest->pfnNeedRunTest && !(*(pTest->pfnNeedRunTest))())
	{
		*pbApplicable = FALSE;
	}
	else
	{
		*pbApplicable = TRUE;
	}

	return ERROR_SUCCESS;
}

STDMETHODIMP CTSDiagnosis::RunTest(int i)
{
	USES_CONVERSION;

	if (i >= (int)GetTotalTestCount ())
	{
		return ERROR_INVALID_PARAMETER;
	}

	PTVerificationTest pTest = GlobalTestData.GetTest(m_dwSuite, i);

	if (pTest->pfnNeedRunTest && !(*(pTest->pfnNeedRunTest))())
	{
		return ERROR_INVALID_PARAMETER;
	}

	ASSERT (pTest->pfnTestFunc);

	char szOutput[512];
	
	ostrstream oTestResult(szOutput, 512);
	ZeroMemory(oTestResult.str(), 512);
	m_lTestResult = (*(pTest->pfnTestFunc))(oTestResult);
	//oTestResult << "\0";

	m_bstrTestResultString  = oTestResult.str();
	
	return S_OK;
}

STDMETHODIMP CTSDiagnosis::get_TestResultString(BSTR *pVal)
{
	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}
	*pVal = m_bstrTestResultString.copy();
	return S_OK;
}

STDMETHODIMP CTSDiagnosis::get_TestResult(long *pVal)
{
	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	*pVal = m_lTestResult;
	return S_OK;
}


STDMETHODIMP CTSDiagnosis::put_TestType(VARIANT newVal)
{
	switch(newVal.vt)
	{
		case VT_I4 :
		case VT_UI2:
		case VT_UINT:
		case VT_INT:
		{
			if (DWORD(newVal.iVal) >= GlobalTestData.GetSuiteCount())
			{
				return E_INVALIDARG; 
			}
			else
			{
				m_dwSuite = newVal.iVal;
			}
		}
		break;

		case VT_BSTR :
		{
			if (!newVal.bstrVal)
			{
				return E_INVALIDARG;
			}
			else
			{
				_bstr_t bstrGroupName = newVal.bstrVal;

				for (DWORD i = 0; i < GlobalTestData.GetSuiteCount(); i++)
				{
					if (0 == _tcscmp(bstrGroupName, GlobalTestData.GetSuiteName(i)) )
					{
						m_dwSuite = i;
					}
				}

				if (i ==  GlobalTestData.GetSuiteCount())
				{
					return E_INVALIDARG;
				}
			}
		}
		break;

		default:
			return E_INVALIDARG;
			break;
	}

	return S_OK;

}


STDMETHODIMP CTSDiagnosis::get_TestDetails(int i, BSTR *pVal)
{
	// TODO: Add your implementation code here
	if (i >= (int)GetTotalTestCount ())
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	bstr_t bstrTestDetails;

	PTVerificationTest pTest = GlobalTestData.GetTest(m_dwSuite, i);
	bstrTestDetails = pTest->TestDetails;
	*pVal = bstrTestDetails.copy();

	return ERROR_SUCCESS;
}


STDMETHODIMP CTSDiagnosis::ExecuteIt(BSTR strCommand)
{

    ASSERT(strCommand);
	HINSTANCE hInst = ShellExecute(NULL, _T("open"), strCommand, NULL, NULL, SW_SHOW );
	if (32 > PtrToLong(hInst))
	{

		PROCESS_INFORMATION pinfo;
		STARTUPINFO sinfo;

		ZeroMemory(&sinfo, sizeof(sinfo));
		sinfo.cb = sizeof(sinfo);

		if (CreateProcess(
			NULL,                             // name of executable module
			strCommand,						  // command line string
			NULL,                             // SD
			NULL,                             // SD
			FALSE,                            // handle inheritance option
			CREATE_NEW_PROCESS_GROUP,         // creation flags
			NULL,                             // new environment block
			NULL,                             // current directory name
			&sinfo,                             // startup information
			&pinfo                            // process information
			))
		{
			// MessageBox(NULL, _T("Executed fine"), _T("TSDIAG"), MB_OK);
		}
		else
		{
			MessageBox(NULL, _T("Failed to Execute"), _T("TSDIAG"), MB_OK);
		}
	}

	return S_OK;
}
STDMETHODIMP CTSDiagnosis::put_RemoteMachineName(BSTR newVal)
{
	if (!GlobalTestData.SetMachineName(newVal))
		return E_OUTOFMEMORY;

	return S_OK;
}

STDMETHODIMP CTSDiagnosis::get_SuiteApplicable (DWORD dwSuite, BOOL * pVal)
{
	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (dwSuite >= GlobalTestData.GetSuiteCount())
	{
		return ERROR_INVALID_PARAMETER;
	}
	
	*pVal = GlobalTestData.CanExecuteSuite(dwSuite);
	return S_OK;

}

STDMETHODIMP CTSDiagnosis::get_SuiteErrorText (DWORD dwSuite, BSTR  * pVal)
{
	if (!pVal)
	{
		return ERROR_INVALID_PARAMETER;
	}

	if (dwSuite >= GlobalTestData.GetSuiteCount())
	{
		return ERROR_INVALID_PARAMETER;
	}

	bstr_t bstrSuiteError;
	bstrSuiteError = GlobalTestData.GetSuiteErrorText(dwSuite);
	*pVal =  bstrSuiteError.copy();
	
	return S_OK;
}

STDMETHODIMP CTSDiagnosis::ExecuteCommand (BSTR strCommand)
{
    ASSERT(strCommand);
	HINSTANCE hInst = ShellExecute(NULL, _T("open"), strCommand, NULL, NULL, SW_SHOW );
	if (32 > PtrToLong(hInst))
	{

		PROCESS_INFORMATION pinfo;
		STARTUPINFO sinfo;

		ZeroMemory(&sinfo, sizeof(sinfo));
		sinfo.cb = sizeof(sinfo);

		if (CreateProcess(
			NULL,                             // name of executable module
			strCommand,						  // command line string
			NULL,                             // SD
			NULL,                             // SD
			FALSE,                            // handle inheritance option
			CREATE_NEW_PROCESS_GROUP,         // creation flags
			NULL,                             // new environment block
			NULL,                             // current directory name
			&sinfo,                             // startup information
			&pinfo                            // process information
			))
		{
			// MessageBox(NULL, _T("Executed fine"), _T("TSDIAG"), MB_OK);
		}
		else
		{
			MessageBox(NULL, _T("Failed to Execute"), _T("TSDIAG"), MB_OK);
		}
	}

	return S_OK;
}
STDMETHODIMP CTSDiagnosis::put_MachineName (BSTR newVal)
{
	if (!GlobalTestData.SetMachineName(newVal))
	{
		return E_OUTOFMEMORY;
	}

	return S_OK;
}

STDMETHODIMP CTSDiagnosis::get_Suites (VARIANT * pVal)
{
	if (!pVal)
	{
		return E_POINTER;
	}

	CComObject<CSuites> *pSuites;
	
	HRESULT hr = CComObject<CSuites>::CreateInstance(&pSuites);
	if (FAILED(hr))
		return hr;

	// if we need to initialize our Suites object, it should be done here.
	
	IDispatch* pDisp = NULL;

	hr = pSuites->QueryInterface(&pDisp);
	if (SUCCEEDED(hr))
	{
		pVal->vt = VT_DISPATCH;
		pVal->pdispVal = pDisp;

		// if we need to initialize our Suites object, it should be done here.
	}
	else
	{
		delete pSuites;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\tsdiag.cpp ===
// TSDiag.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for TSDiag.idl by adding the following 
//      files to the Outputs.
//          TSDiag_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f TSDiagps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "TSDiag.h"
#include "dlldatax.h"

#include "TSDiag_i.c"
#include "tsdgns.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;



BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_TSDiagnosis, CTSDiagnosis)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_TSDIAGLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
     return _Module.RegisterServer(TRUE);

}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\tstst.h ===
#ifndef ___TSTST_H___
#define ___TSTST_H___

#include "tst.h"		// basic test structures.



// tests.

PFN_TEST_FUNC GetCompName;
PFN_TEST_FUNC GetDomName;
PFN_TEST_FUNC GetIPAddress;
PFN_TEST_FUNC GetProductType;
PFN_TEST_FUNC GetProductSuite ;
PFN_TEST_FUNC GetTSVersion;
PFN_TEST_FUNC IsItServer;
PFN_TEST_FUNC IsTSOClogPresent;
PFN_TEST_FUNC DidTsOCgetCompleteInstallationMessage;
PFN_TEST_FUNC IsClusteringInstalled ;
PFN_TEST_FUNC DoesProductSuiteContainTS;
PFN_TEST_FUNC DidOCMInstallTSEnable;
PFN_TEST_FUNC TSEnabled;
PFN_TEST_FUNC IsKernelTSEnable;
PFN_TEST_FUNC IsTerminalServerRegistryOk;
PFN_TEST_FUNC GetWinstationList ; 
PFN_TEST_FUNC IsTerminalServiceRunning;
PFN_TEST_FUNC IsTerminalServiceStartBitSet;
PFN_TEST_FUNC IsTermSrvInSystemContext;
PFN_TEST_FUNC IsListenerSessionPresent;
PFN_TEST_FUNC AreRemoteLogonEnabled;
PFN_TEST_FUNC IsGroupPolicyOk;
PFN_TEST_FUNC AreConnectionsAllowed;
PFN_TEST_FUNC IsRdpDrInstalledProperly;
PFN_TEST_FUNC IsRDPNPinNetProviders ;
PFN_TEST_FUNC IsMultiConnectionAllowed ;
PFN_TEST_FUNC LogonType ;
PFN_TEST_FUNC CheckVideoKeys;
PFN_TEST_FUNC GetTSMode ;
PFN_TEST_FUNC VerifyModeRegistry;
PFN_TEST_FUNC GetModePermissions;
PFN_TEST_FUNC Check_StackBinSigatures;
PFN_TEST_FUNC GetCypherStrenthOnRdpwd ;
PFN_TEST_FUNC IsBetaSystem ;
PFN_TEST_FUNC HasLicenceGracePeriodExpired ;
PFN_TEST_FUNC GetClientVersion;
PFN_TEST_FUNC DoesClientSupportAudioRedirection;
PFN_TEST_FUNC CanClientPlayAudio;
PFN_TEST_FUNC NotConsoleAudio;
PFN_TEST_FUNC DoesClientSupportPrinterRedirection;
PFN_TEST_FUNC DoesClientSupportFileRedirection;
PFN_TEST_FUNC DoesClientSupportClipboardRedirection;
PFN_TEST_FUNC GetUserName;
PFN_TEST_FUNC GetPolicy;
PFN_TEST_FUNC CanRedirectAudio;
PFN_TEST_FUNC CanRedirectCom;
PFN_TEST_FUNC CanRedirectClipboard;
PFN_TEST_FUNC CanRedirectDrives;
PFN_TEST_FUNC CanRedirectPrinter;
PFN_TEST_FUNC CanRedirectLPT;



PFN_SuiteErrorReason WhyCantRunAllTests;
PFN_SuiteErrorReason WhyCantRunGeneralInfo;
PFN_SuiteErrorReason WhyCantRunCantConnect;
PFN_SuiteErrorReason WhyCantRunCantPrint;
PFN_SuiteErrorReason WhyCantRunCantCopyPaste;
PFN_SuiteErrorReason WhyCantRunFileRedirect;
PFN_SuiteErrorReason WhyCantRunLptRedirect;
PFN_SuiteErrorReason WhyCantRunComRedirect;
PFN_SuiteErrorReason WhyCantRunAudioRedirect;

PFN_SUITE_FUNC CanRunAllTests;
PFN_SUITE_FUNC CanRunGeneralInfo;
PFN_SUITE_FUNC CanRunCantConnect;
PFN_SUITE_FUNC CanRunCantPrint;
PFN_SUITE_FUNC CanRunCantCopyPaste;
PFN_SUITE_FUNC CanRunFileRedirect;
PFN_SUITE_FUNC CanRunLptRedirect;
PFN_SUITE_FUNC CanRunComRedirect;
PFN_SUITE_FUNC CanRunAudioRedirect;



// helpers

// BOOL AreEffectiveConnectionAllowed ();
PFN_BOOL IsTSOClogPresent;
PFN_BOOL AreWeInsideSession;
PFN_BOOL IsUserRemoteAdmin;
PFN_BOOL IsItLocalServer;
PFN_BOOL IsItLocalMachine;
PFN_BOOL IsIt51TS;
PFN_BOOL IsIt50TS;
PFN_BOOL IsTerminalServiceRunning;
PFN_BOOL IsItServer;
PFN_BOOL IsAudioEnabled;
PFN_BOOL IsItRemoteConsole;






#endif // ___TSTST_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\tsdgns.h ===
// tsdgns.h : Declaration of the CTSDiagnosis

#ifndef __TSDIAGNOSIS_H_
#define __TSDIAGNOSIS_H_

// #import "F:\nt\termsrv\setup\tsdiag\dll\obj\i386\tsdiag.dll" raw_interfaces_only, raw_native_types, no_namespace, named_guids 
// #import "tsdiag.tlb" raw_interfaces_only, raw_native_types, no_namespace, named_guids 
#include "resource.h"       // main symbols


#include "testdata.h"		// for CTSTestData 


/////////////////////////////////////////////////////////////////////////////
// CTSDiagnosis
class ATL_NO_VTABLE CTSDiagnosis : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CTSDiagnosis, &CLSID_TSDiagnosis>,
	public IDispatchImpl<ITSDiagnosis, &IID_ITSDiagnosis, &LIBID_TSDIAGLib>,
	public IDispatchImpl<ITSDiagnosis2, &IID_ITSDiagnosis2, &LIBID_TSDIAGLib>
{

	enum
	{
		eFailed = 0,
		ePassed = 1,
		eUnknown = 2
	};

	
public:
	CTSDiagnosis();
	~CTSDiagnosis();

DECLARE_REGISTRY_RESOURCEID(IDR_TSDIAGNOSIS)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CTSDiagnosis)
	COM_INTERFACE_ENTRY(ITSDiagnosis2)
	COM_INTERFACE_ENTRY(ITSDiagnosis)
	COM_INTERFACE_ENTRY2(IDispatch, ITSDiagnosis2)
	COM_INTERFACE_ENTRY2(IDispatch, ITSDiagnosis)
END_COM_MAP()

// ITSDiagnosis

public:
	STDMETHOD(ExecuteIt)(BSTR strCommand);
	STDMETHOD(get_TestDetails)(int i, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_TestType)(/*[in]*/ VARIANT newVal);
	STDMETHOD(get_TestResult)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_TestResultString)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(RunTest)(int i);
	STDMETHOD(get_TestDescription)(int i, /*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_TestCount)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_TestApplicable)(int i, /*[out, retval]*/ BOOL *pbApplicable);
	STDMETHOD(put_RemoteMachineName)(BSTR newVal);
	STDMETHOD(get_SuiteApplicable) (DWORD dw, BOOL *pVal);
	STDMETHOD(get_SuiteErrorText) (DWORD dw, BSTR  *pVal);

public:
// ITSDiagnosis2
	STDMETHOD(ExecuteCommand)(BSTR strCommand);
	STDMETHOD(put_MachineName)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_Suites)(/*[out, retval]*/ VARIANT *pVal);

private:
	DWORD GetTotalTestCount ();
	
	bstr_t m_bstrTestResultString;
	long m_lTestResult;
	
	// CTSTestData m_TSTests;
	DWORD m_dwSuite;
/*
// ITSDiagnosis
	STDMETHOD(get_TestCount)(LONG * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_TestDescription)(INT i, BSTR * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_TestApplicable)(INT i, LONG * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(RunTest)(INT i)
	{
		return E_NOTIMPL;
	}
	STDMETHOD(get_TestResult)(LONG * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_TestDetails)(INT i, BSTR * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_SuiteApplicable)(ULONG dwSuite, LONG * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
	STDMETHOD(get_SuiteErrorText)(ULONG dwSuite, BSTR * pVal)
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}

// ITSDiagnosis2
	STDMETHOD(ExecuteCommand)(BSTR strCommand)
	{
		return E_NOTIMPL;
	}

	STDMETHOD(MachineName)(BSTR newVal);
	{
		return E_NOTIMPL;
	}
	
	STDMETHOD(Suites)(VARIANT *pVal);
	{
		if (pVal == NULL)
			return E_POINTER;
			
		return E_NOTIMPL;
	}
*/
	};

#endif //__TSDIAGNOSIS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\tstst.cpp ===
// Copyright (c) 1998 - 1999 Microsoft Corporation



#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "stdafx.h"
#include <dsrole.h>
#include <wtsapi32.h>
#include "winsta.h"
#include "tstst.h"
#include "testdata.h"
#include <rdpsndp.h>
#include <rdpstrm.h>
//
// global utilities and veraibles.
//
bool CheckifBinaryisSigned        (TCHAR *szFile);  // from tscert.cpp
bool EnumerateLicenseServers      ();               // from timebomb.cpp
bool HasLicenceGracePeriodExpired ();               // from timebomb.cpp
bool ExtractAllTSEvents();
TCHAR *GetLicenseServers ();
bool ValidateProductSuite (LPSTR SuiteName);
bool IsTerminalServicesEnabled ( VOID );
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, bool *pbFound);
bool DoesHydraKeysExists ();
bool IsItRemoteMachine ();


bool IsTermDDStartBitSet ();
bool GetTSOCLogFileName (char *strFileName, UINT uiSize);
bool FileExists (char *pszFullNameAndPath);
bool IsRemoteAdminMode ();
bool CheckModePermissions(DWORD *pdwSecurtyMode);
bool IsFile128Bit(LPTSTR szFile, bool *pb128Bit);
ULONG RDPDRINST_DetectInstall();    // defined in drdetect.cpp
bool IsBetaSystem();
bool CheckModeRegistry (bool bAppCompat, ostrstream &ResultStream);
bool GetWinstationConfiguration (WINSTATIONCONFIG **ppInfo);

bool CanPing (); // comes from ping.cpp

const SERVER_INFO_101 *GetServerInfo()
{
	ASSERT(IsItRemoteMachine());

    // for local machines, we will get GetMachineName() as null,
    if (CTSTestData::GetMachineName())
    {
    	USES_CONVERSION;
    	static SERVER_INFO_101 ServerInfo;
    	LPBYTE Buffer;
    	static bool bGotOnce = false;
    	if (!bGotOnce)
    	{
    		TCHAR szMachineName[256];
    		_tcscpy(szMachineName, CTSTestData::GetMachineName());
    		if (NERR_Success == NetServerGetInfo(
    			T2W(szMachineName),
    			102,
    			&Buffer
    			))
    		{
    			bGotOnce = true;
    			CopyMemory(&ServerInfo, Buffer, sizeof(SERVER_INFO_101));
    			return &ServerInfo;
    		}
    		else
    		{
    			return NULL;
    		}
    	}
    	else
    	{
    		return &ServerInfo;
    	}
    }

    return NULL;
}

const OSVERSIONINFOEX *GetOSVersionInfo()
{
	ASSERT(!IsItRemoteMachine());
    static OSVERSIONINFOEX gOsVersion;
    static bool bGotOnce = false;
    if (!bGotOnce)
    {
        ZeroMemory(&gOsVersion, sizeof(OSVERSIONINFOEX));
        gOsVersion.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
        GetVersionEx( (LPOSVERSIONINFO ) &gOsVersion);
        bGotOnce = true;
    }

    return &gOsVersion;
}



// #include <strstream>
#include "winsock2.h"


// ostringstream sz

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(P)          (P)
#endif

#define OLD_VER_SET_CONDITION(_m_,_t_,_c_)  _m_=(_m_|(_c_<<(1<<_t_)))


TCHAR *aszStack[] = {
//  _T("noexport\%SystemRoot%\\system32\\drivers\\rdpwdd.sys"),
    _T("%SystemRoot%\\system32\\drivers\\termdd.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdasync.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdipx.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdnetb.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdpipe.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdspx.sys"),
    _T("%SystemRoot%\\system32\\drivers\\tdtcp.sys"),
    _T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"),
    _T("%SystemRoot%\\system32\\rdpdd.dll"),
    _T("%SystemRoot%\\system32\\rdpwsx.dll")
};


TCHAR *GetTSVersion()
{
	static TCHAR Version[256] = TEXT("");

	if (_tcslen(Version) != 0)
		return Version;

	CRegistry oRegTermsrv;
	DWORD cbVersion = 0;
	LPTSTR szVersion = NULL;

	if ((ERROR_SUCCESS == oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName())) &&
		(ERROR_SUCCESS == oRegTermsrv.ReadRegString(_T("ProductVersion"), &szVersion, &cbVersion)))
	{
		_tcscpy(Version, szVersion);
		return Version;
	}

	return _T("Error finding Version.");
}

EResult GetTSVersion (ostrstream &ResultStream)
{
	USES_CONVERSION;
	ResultStream << T2A(GetTSVersion());
	return ePassed;
}

bool IsIt50TS()
{
	return (0 == _tcsicmp(GetTSVersion(), _T("5.0")));
}

bool IsIt51TS()
{
	return (0 == _tcsicmp(GetTSVersion(), _T("5.1")));
}


bool DoIhaveRPCPermissions ()
{
	HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;
	if (CTSTestData::GetMachineName())
	{
		TCHAR szMachineName[256];
		_tcscpy(szMachineName, CTSTestData::GetMachineName());
		hServer = WTSOpenServer (szMachineName);
	}

	LPTSTR buffer;
	DWORD dwBytesReturned;
	if (WTSQuerySessionInformation(
			hServer,
			65536,
			WTSInitialProgram,
			&buffer,
			&dwBytesReturned))
	{
		WTSFreeMemory(buffer);
		return true;
	}

	if (CTSTestData::GetMachineName())
		WTSCloseServer(hServer);

	return false;
}


bool DoIHaveEnufPermissions ()
{
	char szOutput[512];
	ostrstream oTestResult(szOutput, 512);
	ZeroMemory(oTestResult.str(), 512);


	//if (!DoIhaveRPCPermissions())
	//{
	//	return false;
	//}

	CRegistry oRegTermsrv;
	return ERROR_SUCCESS == oRegTermsrv.OpenKey(
								HKEY_LOCAL_MACHINE, 
								_T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), 
								KEY_READ, 
								CTSTestData::GetMachineName()
								);
}

bool IsUserRemoteAdmin ()
{
	if (IsItRemoteMachine())
	{
		USES_CONVERSION;
		TCHAR strNTFilename[256];
		if (CTSTestData::GetMachineNamePath())
		{
			_tcscpy(strNTFilename, CTSTestData::GetMachineNamePath());
			_tcscat(strNTFilename, _T("\\admin$\\system32\\ntoskrnl.exe"));
		}

        HANDLE hFile = CreateFile(strNTFilename, 0, FILE_SHARE_READ,
					              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
		
		if (hFile != INVALID_HANDLE_VALUE)
		{
			CloseHandle(hFile);
			return true;
		}

		return false;
	}
	else
	{
		// we dont require admin priviledges if running on local machine
		return true;
	}
}

EResult HasLicenceGracePeriodExpired (ostrstream &ResultStream)
{
    if (HasLicenceGracePeriodExpired())
	{
		ResultStream << "Its expired";
		return eFailed;
	}
	else
	{
		ResultStream << "No, its not expired.";
		return ePassed;
	}
}

EResult Check_StackBinSigatures (ostrstream &ResultStream)
{

	USES_CONVERSION;
    bool bRet = true;

    LPTSTR aStackBins[] =
    {
        _T("%SystemRoot%\\system32\\drivers\\termdd.sys"),
        _T("%SystemRoot%\\system32\\drivers\\tdpipe.sys"),
        _T("%SystemRoot%\\system32\\drivers\\tdtcp.sys"),
        _T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"),
        _T("%SystemRoot%\\system32\\rdpdd.dll"),
        _T("%SystemRoot%\\system32\\rdpwsx.dll")
    };

    for (int i = 0; i < sizeof(aStackBins)/sizeof(aStackBins[0]); i++)
    {
        if (!CheckifBinaryisSigned(aStackBins[i]))
        {
            ResultStream << "Invalid Signature for:" << T2A(aStackBins[i]) << ",";
            bRet = false;
        }

    }

	if (bRet)
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		return eFailed;
	}
}

EResult IsRdpDrInstalledProperly (ostrstream &ResultStream)
{
	//
	// we cannot do this test for remote machine.
	//
	ASSERT(IsItLocalMachine());
    if (RDPDRINST_DetectInstall())
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		ResultStream << "Failed";
		return eFailed;

	}
}

EResult GetModePermissions (ostrstream &ResultStream)
{
    CRegistry reg;
    DWORD dwSecurityMode;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSUserEnabled"), &dwSecurityMode))
        {
            if (dwSecurityMode == 0)
            {
                ResultStream <<  "Its W2k Compatible";
				return ePassed;
            }
            else if (dwSecurityMode == 1)
            {
                ResultStream <<  "Its TS4 Compatible";
				return ePassed;
            }
            else
            {
                ResultStream << "SYSTEM\\CurrentControlSet\\Control\\Terminal Server/TSUserEnabled has wrong value" << dwSecurityMode << "!";
                return eFailedToExecute;
            }
        }
		else
		{
            ResultStream << "failed to read TSUserEnabled";
            return eFailedToExecute;
		}
    }
	else
	{
        ResultStream << "failed to read SYSTEM\\CurrentControlSet\\Control\\Terminal Server";
        return eFailedToExecute;
	}

}

bool CheckModePermissions (DWORD *pdwSecurtyMode)
{
//    PERM_WIN2K = 0,
//    PERM_TS4 = 1

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSUserEnabled"), pdwSecurtyMode))
        {
            return (*pdwSecurtyMode== 0) || (*pdwSecurtyMode== 1);
        }
    }

    return false;
}

EResult GetCypherStrenthOnRdpwd (ostrstream &ResultStream)
{
   
	bool bFile128bit;
	TCHAR strFileName[256];
	
	if (CTSTestData::GetMachineName())
	{
		_tcscpy(strFileName, CTSTestData::GetMachineNamePath());
		_tcscat(strFileName, _T("\\admin$\\system32\\drivers\\rdpwd.sys"));
	}
	else
	{
		_tcscpy(strFileName, _T("%SystemRoot%\\system32\\drivers\\rdpwd.sys"));
	}

    if ( IsFile128Bit(strFileName, &bFile128bit) )
    {
        ResultStream << (bFile128bit ? "128 Bit" : "56 Bit");
		return ePassed;
    }
    else
    {
		ResultStream << "Failed to get cypher strength on rdpwd.sys, You may not have sufficient permissions.";
        return eFailedToExecute;
    }

}


bool IsFile128Bit(LPTSTR szFile, bool *pb128Bit)
{
    USES_CONVERSION;
    DWORD dwHandle;

    TCHAR szFullFile[MAX_PATH +1];

    bool bSuccess = false;

    if (ExpandEnvironmentStrings(szFile, szFullFile, MAX_PATH))
    {
        if (FileExists(T2A(szFullFile)))
        {
            DWORD dwSize = GetFileVersionInfoSize(szFullFile, &dwHandle);
            if (dwSize > 0)
            {
                BYTE *pbData = new BYTE[dwSize];
                if (pbData)
                {
                    if (GetFileVersionInfo(szFullFile, 0, dwSize, pbData))
                    {
                        TCHAR *szFileDescription;
                        UINT uiLen = 0;
                        if (VerQueryValue(pbData, _T("\\StringFileInfo\\040904B0\\FileDescription"), (LPVOID *)&szFileDescription, &uiLen))
                        {
                            if (_tcsstr(szFileDescription, _T("Not for Export")))
                            {
                                *pb128Bit = true;
                                bSuccess = true;

                            }
                            else if (_tcsstr(szFileDescription, _T("Export Version")))
                            {
                                *pb128Bit = false;
                                bSuccess = true;
                            }
                        }
                    }

                    delete [] pbData;

                }

            }
        }
    }

    return bSuccess;
}



bool ValidateProductSuite (LPSTR SuiteName)
{
    bool rVal = false;
    LONG Rslt;
    HKEY hKey = NULL;
    DWORD Type = 0;
    DWORD Size = 0;
    LPSTR ProductSuite = NULL;
    LPSTR p;

    Rslt = RegOpenKeyA(
        HKEY_LOCAL_MACHINE,
        "System\\CurrentControlSet\\Control\\ProductOptions",
        &hKey
        );

    if (Rslt != ERROR_SUCCESS)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type, NULL, &Size );
    if (Rslt != ERROR_SUCCESS || !Size)
        goto exit;

    ProductSuite = (LPSTR) LocalAlloc( LPTR, Size );
    if (!ProductSuite)
        goto exit;

    Rslt = RegQueryValueExA( hKey, "ProductSuite", NULL, &Type,
        (LPBYTE) ProductSuite, &Size );
     if (Rslt != ERROR_SUCCESS || Type != REG_MULTI_SZ)
        goto exit;

    p = ProductSuite;
    while (*p)
    {
        if (lstrcmpA( p, SuiteName ) == 0)
        {
            rVal = true;
            break;
        }
        p += (lstrlenA( p ) + 1);
    }

exit:
    if (ProductSuite)
        LocalFree( ProductSuite );

    if (hKey)
        RegCloseKey( hKey );

    return rVal;
}


bool IsTerminalServicesEnabled( VOID )
{
    bool bResult = false;
    DWORD   dwVersion;
    OSVERSIONINFOEXA osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    HMODULE hmodK32 = NULL;
    typedef ULONGLONG (*PFnVerSetConditionMask) ( ULONGLONG, ULONG, UCHAR );
    typedef BOOL      (*PFnVerifyVersionInfoA) (POSVERSIONINFOEXA, DWORD, DWORDLONG);
    PFnVerSetConditionMask pfnVerSetConditionMask;
    PFnVerifyVersionInfoA pfnVerifyVersionInfoA;


    dwVersion = GetVersion();

    /* are we running NT ? */
    if (!(dwVersion & 0x80000000))
    {
        // Is it NT 50 or greater ?
        if (LOBYTE(LOWORD(dwVersion)) > 4)
        {
            /* In NT5 we need to use the Product Suite APIs
             Don't static link because it won't load on non-NT5 systems */

            hmodK32 = GetModuleHandleA( "KERNEL32.DLL" );
            if (hmodK32)
            {
                pfnVerSetConditionMask = (PFnVerSetConditionMask )GetProcAddress( hmodK32, "VerSetConditionMask");

                if (pfnVerSetConditionMask)
                {
                    /* get the condition mask. */
                    dwlConditionMask = (*pfnVerSetConditionMask)(dwlConditionMask, VER_SUITENAME, VER_AND);

                    pfnVerifyVersionInfoA = (PFnVerifyVersionInfoA)GetProcAddress( hmodK32, "VerifyVersionInfoA") ;

                    if (pfnVerifyVersionInfoA != NULL)
                    {

                        ZeroMemory(&osVersionInfo, sizeof(osVersionInfo));
                        osVersionInfo.dwOSVersionInfoSize = sizeof(osVersionInfo);
                        osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;
                        bResult = (*pfnVerifyVersionInfoA)(
                                          &osVersionInfo,
                                          VER_SUITENAME,
                                          dwlConditionMask) != 0;
                    }
                }
            }
        }
        else
        {
            /* This is NT 40 */
            bResult = ValidateProductSuite( "Terminal Server" );
        }
    }

    return bResult;
}

/*--------------------------------------------------------------------------------------------------------
* DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, bool *pbFound)
* checks if parameter string exists in given multistring.
* returns error code.
* -------------------------------------------------------------------------------------------------------*/
DWORD IsStringInMultiString(HKEY hkey, LPCTSTR szkey, LPCTSTR szvalue, LPCTSTR szCheckForString, bool *pbFound)
{
    ASSERT(szkey && *szkey);
    ASSERT(szvalue && *szvalue);
    ASSERT(szCheckForString&& *szCheckForString);
    ASSERT(*szkey != '\\');
    ASSERT(pbFound);

    // not yet found.
    *pbFound = false;

    CRegistry reg;
    DWORD dwError = reg.OpenKey(hkey, szkey, KEY_READ, CTSTestData::GetMachineName());  // open up the required key.
    if (dwError == NO_ERROR)
    {
        LPTSTR szSuiteValue;
        DWORD dwSize;
        dwError = reg.ReadRegMultiString(szvalue, &szSuiteValue, &dwSize);
        if (dwError == NO_ERROR)
        {
            LPCTSTR pTemp = szSuiteValue;
            while(_tcslen(pTemp) > 0 )
            {
                if (_tcscmp(pTemp, szCheckForString) == 0)
                {
                    *pbFound = true;
                    break;
                }

                pTemp += _tcslen(pTemp) + 1; // point to the next string within the multistring.
                if ( DWORD(pTemp - szSuiteValue) > (dwSize / sizeof(TCHAR)))
                    break; // temporary pointer passes the size of the szSuiteValue something is wrong with szSuiteValue.
            }
        }
    }

    return dwError;

}


bool DoesHydraKeysExists()
{
    bool bStringExists = false;
    DWORD dw = IsStringInMultiString(
        HKEY_LOCAL_MACHINE,
        _T("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
        _T("ProductSuite"),
        _T("Terminal Server"),
        &bStringExists);

    return (dw == ERROR_SUCCESS) && bStringExists;
}





/*
TCHAR *IsItAppServer ()
{
    return ((GetOSVersionInfo()->wSuiteMask & VER_SUITE_TERMINAL) &&
           !(GetOSVersionInfo()->wSuiteMask & VER_SUITE_SINGLEUSERTS)) ? _T("Yes") : _T("No");
}
*/
bool IsItPTS( VOID )
{
    return ( 0 != (GetOSVersionInfo()->wSuiteMask & VER_SUITE_SINGLEUSERTS));
}

bool IsItRemoteMachine ()
{
	return CTSTestData::GetMachineName() != NULL;
}

bool AreWeInsideSession ()
{
	return GetSystemMetrics(SM_REMOTESESSION) != 0;
}

bool IsItLocalMachine ()
{
	return !IsItRemoteMachine ();
}

bool IsItLocalServer ()
{
	return IsItServer () && IsItLocalMachine ();
}

bool IsItServer ()
{
	if (IsItRemoteMachine())
	{
		const SERVER_INFO_101 *pServerInfo;
		pServerInfo = GetServerInfo();
		if (pServerInfo)
		{
			return ( (pServerInfo->sv101_type & SV_TYPE_DOMAIN_CTRL) ||
					 (pServerInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) ||
					 (pServerInfo->sv101_type & SV_TYPE_SERVER_NT));
		}
		else
		{

			return true; // we could not determine if its server or not, Lets say its server.
		}

	}
	else
	{
		return GetOSVersionInfo()->wProductType != VER_NT_WORKSTATION;
	}

	
}

bool IsAudioEnabled()
{
    USES_CONVERSION;
    WINSTATIONCONFIG  *pWSInfo = NULL;

    if ( !AreWeInsideSession() )
        return FALSE;

    if (GetWinstationConfiguration(&pWSInfo))
    {
        return !(pWSInfo->User.fDisableCam);
    }

    return FALSE;
}

bool IsItRemoteConsole( VOID )
{
    return ( AreWeInsideSession() && (NtCurrentPeb()->SessionId == 0 || IsItPTS()) );
}

EResult IsItServer (ostrstream &ResultStream)
{
	ResultStream << (IsItServer ()) ? "Its a workstation" : "Its a server";
	return (IsItServer()) ? ePassed : eFailed;
}

EResult GetProductType (ostrstream &ResultStream)
{
	ASSERT(IsItLocalMachine());
    BYTE wProductType = GetOSVersionInfo()->wProductType;
    if (wProductType == VER_NT_WORKSTATION)
    {
		ResultStream << "VER_NT_WORKSTATION";
    }

    if (wProductType == VER_NT_DOMAIN_CONTROLLER)
    {
		ResultStream << "VER_NT_DOMAIN_CONTROLLER ";
    }

    if (wProductType == VER_NT_SERVER)
    {
		ResultStream << "VER_NT_SERVER ";
    }

    return ePassed;
}


EResult GetProductSuite (ostrstream &ResultStream)
{
	ASSERT(IsItLocalMachine());
    WORD wProductSuite = GetOSVersionInfo()->wSuiteMask;
    
	if (wProductSuite & VER_SERVER_NT)
    {
        ResultStream << "VER_SERVER_NT ";
    }
    if (wProductSuite & VER_WORKSTATION_NT)
    {
        ResultStream << "VER_WORKSTATION_NT ";
    }
    if (wProductSuite & VER_SUITE_SMALLBUSINESS)
    {
        ResultStream << "VER_SUITE_SMALLBUSINESS ";
    }
    if (wProductSuite & VER_SUITE_ENTERPRISE)
    {
        ResultStream << "VER_SUITE_ENTERPRISE ";
    }
    if (wProductSuite & VER_SUITE_BACKOFFICE)
    {
        ResultStream << "VER_SUITE_BACKOFFICE ";
    }
    if (wProductSuite & VER_SUITE_COMMUNICATIONS)
    {
        ResultStream << "VER_SUITE_COMMUNICATIONS ";
    }
    if (wProductSuite & VER_SUITE_TERMINAL)
    {
        ResultStream << "VER_SUITE_TERMINAL ";
    }
    if (wProductSuite & VER_SUITE_SMALLBUSINESS_RESTRICTED)
    {
        ResultStream << "VER_SUITE_SMALLBUSINESS_RESTRICTED ";
    }
    if (wProductSuite & VER_SUITE_EMBEDDEDNT)
    {
        ResultStream << "VER_SUITE_EMBEDDEDNT ";
    }
    if (wProductSuite & VER_SUITE_DATACENTER)
    {
        ResultStream << "VER_SUITE_DATACENTER ";
    }
    if (wProductSuite & VER_SUITE_SINGLEUSERTS)
    {
        ResultStream << "VER_SUITE_SINGLEUSERTS ";
    }
    if (wProductSuite & VER_SUITE_PERSONAL)
    {
        ResultStream << "VER_SUITE_PERSONAL ";
    }
    return ePassed;
}

/*
TCHAR *IsServer ()
{
    return IsItServer() ? _T("Its a Server") : _T("Its a WorkStation");
}
*/



EResult IsKernelTSEnable (ostrstream &ResultStream)
{
	ASSERT(IsItLocalMachine());
    if (IsTerminalServicesEnabled())
	{
		ResultStream << "Yes.";
		return ePassed;
	}
	else
	{
		ResultStream << "No.";
		return eFailed;
	}
}

bool TSEnabled ()
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwTSEnabled = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSEnabled"), &dwTSEnabled))
        {
            return dwTSEnabled == 1;
        }
    }

    return false;
}

EResult TSEnabled (ostrstream &ResultStream)
{
    if (TSEnabled())
	{
		ResultStream << "Yes.";
		return ePassed;
	}
	else
	{
		ResultStream << "No.";
		return eFailed;
	}
}

EResult DoesProductSuiteContainTS (ostrstream &ResultStream)
{
    if (DoesHydraKeysExists())
	{
		ResultStream << "Yes.";
		return ePassed;
	}
	else
	{
		ResultStream << "No.";
		return eFailed;
	}
}

EResult IsTerminalServerRegistryOk (ostrstream &ResultStream)
{
    CRegistry reg1;
    CRegistry reg2;
    CRegistry reg3;

    if (
    (ERROR_SUCCESS == reg1.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName())) &&
    (ERROR_SUCCESS == reg2.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), KEY_READ, CTSTestData::GetMachineName())) &&
    (ERROR_SUCCESS == reg3.OpenKey(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows NT\\CurrentVersion\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName())))
	{
		ResultStream << "Yes.";
		return ePassed;
	}
	else
	{
		ResultStream << "No.";
		return eFailed;
	}
}

EResult GetWinstationList (ostrstream &ResultStream)
{
	USES_CONVERSION;
    CRegistry reg2;
    
	bool bFoundNonConsoleWinstation = false;

    if (ERROR_SUCCESS == reg2.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations"), KEY_READ, CTSTestData::GetMachineName()))
    {
        LPTSTR szWinstation;
        DWORD dwSize;
		bool bFirst = true;

        if (ERROR_SUCCESS == reg2.GetFirstSubKey(&szWinstation, &dwSize))
        {
            do
            {
                if (0 != _tcsicmp(szWinstation, _T("Console")))
                {
                    bFoundNonConsoleWinstation = true;
                }

                if (!bFirst)
                {
					ResultStream << ", ";
                }

				ResultStream << T2A(szWinstation);
                bFirst = false;
            }
            while (ERROR_SUCCESS == reg2.GetNextSubKey(&szWinstation, &dwSize));
        }
    }
	else
	{
		ResultStream << "Failed to open winstations registry";
		return eFailed;
	}

    if (!bFoundNonConsoleWinstation)
    {
        // ResultStream << "Error, Only Console Winstation found";
		return eFailed;
    }
	else
	{
		return ePassed;
	}
}

EResult IsTerminalServiceStartBitSet (ostrstream &ResultStream)
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermService"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwTermServStartBit = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("Start"), &dwTermServStartBit))
        {
            switch (dwTermServStartBit)
            {
                case 2:
                ResultStream << "AutoStart";
                break;

                case 3:
                ResultStream << "Manual Start";
                break;

                case 4:
                ResultStream << "Error, Disabled";
                break;

                default:
                ResultStream << "ERROR:Wrong value for startbit";
            }

			if (IsIt50TS())
			{
				if (2 == dwTermServStartBit)
					return ePassed;
				else
					return eFailed;
			}
			else
			{
				if (IsIt51TS())
				{
					if (3 == dwTermServStartBit)
						return ePassed;
					else
						return eFailed;
				}

				ResultStream << "what version of its is it ?";
				return eFailedToExecute;
			}
        }
		else
		{
			ResultStream << "Failed to read startbit";
			return eFailedToExecute;
		}
    }
	else
	{
		ResultStream << "Failed to read startbit";
		return eFailedToExecute;
	}
}

bool IsTermDDStartBitSet ()
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermDD"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwTermDDStartBit = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("Start"), &dwTermDDStartBit))
        {
            return dwTermDDStartBit == 2;
        }
    }

    return false;
}

EResult IsGroupPolicyOk (ostrstream &ResultStream)
{
	CRegistry reg;
	if (ERROR_SUCCESS == reg.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Policies\\Microsoft\\Windows NT\\Terminal Services"), KEY_READ, CTSTestData::GetMachineName()))
	{
		DWORD dwDenyConnections;
		if (ERROR_SUCCESS == reg.ReadRegDWord(_T("fDenyTSConnections"), &dwDenyConnections))
		{
			if (dwDenyConnections == 0)
			{
				ResultStream << "Passed";
				return ePassed;
			}
			else
			{
				ResultStream << "Group Policy does not allow connections";
				return eFailed;
			}
		}
	}

	ResultStream << "Passed,Policy does not exist";
	return ePassed;

}

/*
bool AreEffectiveConnectionAllowed ()
{
    HMODULE hmodRegAPI = LoadLibrary( _T("RegApi.dll") );

    if (hmodRegAPI)
    {
        typedef BOOLEAN (*PFDenyConnectionPolicy) ();
        PFDenyConnectionPolicy pfnDenyConnectionPolicy;

        pfnDenyConnectionPolicy = (PFDenyConnectionPolicy) GetProcAddress( hmodRegAPI, "RegDenyTSConnectionsPolicy");
        if (pfnDenyConnectionPolicy)
        {
              return (*pfnDenyConnectionPolicy)() ? false : true;

        }
        else
        {
            szMoreInfo << "Failed to get proc RegDenyTSConnectionsPolicy" << endl;
            return false;
        }
    }
    else
    {
       szMoreInfo << "Failed to Load regapi.dll" << endl;
       return false;
    }


}
*/

EResult AreConnectionsAllowed(ostrstream &ResultStream)
{
	DWORD dwError;
	CRegistry oRegTermsrv;

	dwError = oRegTermsrv.OpenKey(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName());
	if (ERROR_SUCCESS == dwError)
	{
		DWORD dwDenyConnect;
		dwError = oRegTermsrv.ReadRegDWord(_T("fDenyTSConnections"), &dwDenyConnect);
		if (ERROR_SUCCESS == dwError)
		{
			if (dwDenyConnect == 1)
			{
				ResultStream << "Failed, Connections are denied";
				return eFailed;
			}
			else
			{
				ResultStream << "Passed, Connections are allowed";
				return ePassed;
			}
		}
		else
		{
			ResultStream << "failed to read value";
			return eFailedToExecute;
		}

	}
	else
	{
		ResultStream << "failed to open key";
		return eFailedToExecute;
	}
}

bool GetTSOCLogFileName(char *strFileName, UINT uiSize)
{

	USES_CONVERSION;
	if (CTSTestData::GetMachineName())
	{
		strcpy(strFileName, T2A(CTSTestData::GetMachineNamePath()));
		strcat(strFileName, "\\admin$");
	}
	else
	{
		if (!GetSystemWindowsDirectoryA(strFileName, uiSize))
			return false;
	}

    strcat(strFileName, "\\tsoc.log");
    ASSERT(strlen(strFileName) < uiSize);
    return true;
}

char *IncompleteMessage = "Error:TSOC Did not get OC_COMPLETE_INSTALLATION.";
EResult DidTsOCgetCompleteInstallationMessage (ostrstream &ResultStream)
{
    if (!IsTSOClogPresent())
    {
        ResultStream << "Failed because tsoc.log does not exist." << endl;
        return eFailedToExecute;
    }

    char strTSOCLog[256];
    GetTSOCLogFileName(strTSOCLog, 256);

	ifstream ifSrc(strTSOCLog);
	if(!ifSrc)
    {
        ResultStream << "Failed to open tsoc.log file." << endl;
        return eFailedToExecute;
    }


    char tempSrc[256];
	while(!ifSrc.eof())
	{
		ifSrc.getline(tempSrc, 256);
        if (strstr(tempSrc, IncompleteMessage))
        {
			ResultStream << "Failed";
            return eFailed;
        }
	}

	ResultStream << "Passed";
    return ePassed;
}

bool FileExists(char *pszFullNameAndPath)
{
    ASSERT(pszFullNameAndPath);

    if (pszFullNameAndPath && pszFullNameAndPath[0])
    {
        HANDLE hFile = CreateFileA(pszFullNameAndPath, 0, FILE_SHARE_READ | FILE_SHARE_WRITE,
					              NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

	    if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hFile);
            return true;
        }
    }

    return false;
}


bool IsTSOClogPresent ()
{
    char strTSOCLog[256];
    GetTSOCLogFileName(strTSOCLog, 256);
    return FileExists(strTSOCLog);
}

EResult IsTSOClogPresent (ostrstream &ResultStream)
{
	if (IsTSOClogPresent ())
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		ResultStream << "Failed";
		return eFailed;
	}

}

EResult DidOCMInstallTSEnable(ostrstream &ResultStream)
{
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\SubComponents"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwTSEnabled = 0;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("tsenable"), &dwTSEnabled))
        {
            if (dwTSEnabled == 1)
			{
				ResultStream << "Passed";
				return ePassed;
			}
			else
			{
				ResultStream << "Failed";
				return eFailed;
			}
        }
		else
		{
			ResultStream << "Failed to open Value";
			return eFailed;
		}
    }
	else
	{
		ResultStream << "Failed to open key";
		return eFailedToExecute;
	}

}


EResult IsClusteringInstalled  (ostrstream &ResultStream)
{
    DWORD dwClusterState;
    if (ERROR_SUCCESS == GetNodeClusterState(NULL, &dwClusterState))
    {
        if (dwClusterState != ClusterStateNotInstalled)
        {
			ResultStream <<  "***Failed. Clustering is installed.";
            return eFailed;
		}

    }

	ResultStream <<  "Passed.";
    return ePassed;
}


EResult GetTSMode  (ostrstream &ResultStream)
{
	if (!IsItServer() && !IsRemoteAdminMode())
	{
			ResultStream << "ERROR:The machine is in app server Mode for Professional";
			return eFailed;
	}
	else
	{
		ResultStream << (IsRemoteAdminMode() ?  "Remote Admin" : "Application Server");
		return ePassed;
	}
}

bool IsRemoteAdminMode ()
{
    // HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","TSAppCompat",0x00010001,0x0
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwAppCompat = 1;
        if ( ERROR_SUCCESS == reg.ReadRegDWord( _T("TSAppCompat"), &dwAppCompat))
        {
            return dwAppCompat == 0;
        }
        else
        {
            // if the registry TSAppCompat does not exist it means we are in app server mode.
            return false;
        }
    }

    // this return is bogus.
    return true;

}

EResult VerifyModeRegistry (ostrstream &ResultStream)
{
    if (CheckModeRegistry(!IsRemoteAdminMode(), ResultStream))
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		ResultStream << "Failed";
		return eFailed;
	}
}

bool CheckModeRegistry (bool bAppCompat, ostrstream &ResultStream)
{
    USES_CONVERSION;
    bool bOk = true;

    CRegistry reg;

    if (IsItServer())
    {
        CRegistry reg1;
        if ( ERROR_SUCCESS == reg1.OpenKey( HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ, CTSTestData::GetMachineName()))
        {
            LPTSTR str;
            DWORD dwSize;
            if (ERROR_SUCCESS == reg1.ReadRegString(_T("AppSetup"), &str, &dwSize))
            {
                if (bAppCompat)
                {
                    if (_tcsicmp(str, _T("UsrLogon.Cmd")) != 0)
                    {
                        bOk = false;
                        ResultStream << "ERROR: Wrong value (" << T2A(str) << ") for AppSetup, contact makarp/breenh" << endl;
                    }

                }
                else
                {
                    if (_tcslen(str) != 0)
                    {
                        bOk = false;
                        ResultStream << "ERROR: Wrong value (" << T2A(str) << ") for AppSetup, contact makarp/breenh" << endl;

                    }

                }

            }
            else
            {
                ResultStream << "ERROR reading appsetup registry" << endl;
                bOk = false;
            }

        }
        else
        {
            ResultStream << "ERROR:reading SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon" << endl;
            bOk = false;
        }

    }


    // check registry value
    // for appcompat mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\PriorityControl","Win32PrioritySeparation", 0x00010001,0x26
    // and for remote admin mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\PriorityControl","Win32PrioritySeparation", 0x00010001,0x18

    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\PriorityControl"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwPriority;
        if (ERROR_SUCCESS == reg.ReadRegDWord(_T("Win32PrioritySeparation"), &dwPriority))
        {
            if (bAppCompat)
            {
                if (0x26 != dwPriority)
                {
                    bOk = false;
                    ResultStream << "ERROR: Wrong Win32PrioritySeparation (" << dwPriority << ")" << endl;
                }

            }
            else if (IsItServer())
            {
                if (0x18 != dwPriority)
                {
                    bOk = false;
                    ResultStream << "ERROR: Wrong Win32PrioritySeparation (" << dwPriority << ")" << endl;
                }

            }
        }
        else
        {
            bOk = false;
            ResultStream << "ERROR:Reading Win32PrioritySeparation registry" << endl;

        }

    }
    else
    {
        bOk = false;
        ResultStream << "ERROR:Reading PriorityControl registry" << endl;
    }


    // check registry value
    // for appcompat mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","IdleWinStationPoolCount",0x00010001,0x2
    // and for remote admin mode
        //HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server","IdleWinStationPoolCount",0x00010001,0x0


    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server"), KEY_READ, CTSTestData::GetMachineName()))
    {
        DWORD dwIdleWinstations;
        if (ERROR_SUCCESS == reg.ReadRegDWord(_T("IdleWinStationPoolCount"), &dwIdleWinstations))
        {
            if (bAppCompat)
            {
                if (0x2 != dwIdleWinstations)
                {
                    bOk = false;
                    ResultStream << "ERROR: Wrong IdleWinStationPoolCount (" << dwIdleWinstations << ")" << endl;
                }

            }
            else
            {
                if (0 != dwIdleWinstations)
                {
                    bOk = false;
                    ResultStream << "ERROR: Wrong IdleWinStationPoolCount (" << dwIdleWinstations << ")" << endl;
                }

            }

        }
        else
        {
            bOk = false;
            ResultStream << "ERROR:Reading IdleWinStationPoolCount registry" << endl;

        }

    }
    else
    {
        bOk = false;
        ResultStream << "SYSTEM\\CurrentControlSet\\Control\\Terminal Server" << endl;
    }

    return bOk;


}

bool g_IsTermsrvRunning = false;
bool IsTerminalServiceRunning ()
{
	return g_IsTermsrvRunning;
}

EResult IsTerminalServiceRunning  (ostrstream &ResultStream)
{
	EResult eRes = eUnknown;
    bool bReturn = false;

    SC_HANDLE hServiceController = OpenSCManager(CTSTestData::GetMachineNamePath(), NULL, GENERIC_READ);
    if (hServiceController)
    {

        SC_HANDLE hTermServ = OpenService(hServiceController, _T("TermService"), SERVICE_QUERY_STATUS);
        if (hTermServ)
        {
            SERVICE_STATUS tTermServStatus;
            if (QueryServiceStatus(hTermServ, &tTermServStatus))
            {
                bReturn = (tTermServStatus.dwCurrentState == SERVICE_RUNNING);
				if (bReturn)
				{
					ResultStream << "Passed";
					eRes = ePassed;
					g_IsTermsrvRunning = true;
				}
				else
				{
					ResultStream << "Failed, Termsrv is not running";
					eRes = eFailed;
				}

            }
            else
            {
                ResultStream << "Failed to get service status, Error = " << GetLastError();
				eRes = eFailedToExecute;
            }

            VERIFY(CloseServiceHandle(hTermServ));

        }
        else
        {
            ResultStream << "Failed to open TermServ service, Error = " << GetLastError() << endl;
			eRes = eFailedToExecute;
        }

        VERIFY(CloseServiceHandle(hServiceController));
    }
    else
    {
        ResultStream << "Failed to Open Service Controller, Error = " << GetLastError() << endl;
		eRes = eFailedToExecute;
    }

	return eRes;
}


EResult CheckVideoKeys (ostrstream &ResultStream)
{
    //    HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\VIDEO\rdpdd","VgaCompatible",0x00000000,"\Device\Video0"
    //    HKLM ,"SYSTEM\CurrentControlSet\Control\Terminal Server\VIDEO\rdpdd","\Device\Video0",0x00000000,"\REGISTRY\Machine\System\ControlSet001\Services\RDPDD\Device0"

    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\VIDEO\\rdpdd"), KEY_READ, CTSTestData::GetMachineName()))
    {
        LPTSTR str = 0;
        DWORD dwSize = 0;
        if (ERROR_SUCCESS == reg.ReadRegString(_T("VgaCompatible"), &str, &dwSize))
        {
            if (0 == _tcsicmp(str, _T("\\Device\\Video0")))
            {
                if (ERROR_SUCCESS == reg.ReadRegString(_T("\\Device\\Video0"), &str, &dwSize))
                {
                    if ((0 == _tcsicmp(str, _T("\\REGISTRY\\Machine\\System\\ControlSet001\\Services\\RDPDD\\Device0"))) ||
                        (0 == _tcsicmp(str, _T("\\REGISTRY\\Machine\\System\\CurrentControlSet\\Services\\RDPDD\\Device0"))))
                    {
						ResultStream << "Passed";
						return ePassed;
                    }
                    else
                    {
                    }
                }
                else
                {
                }
            }
            else
            {

            }

        }
        else
        {
        }
    }
    else
    {
    }

	ResultStream << "Failed";
	return eFailed;
}

TCHAR szCompName[256];
EResult GetCompName (ostrstream &ResultStream)
{
	USES_CONVERSION;
	if (!CTSTestData::GetMachineName())
	{

		DWORD dwCompName = 256;
		if (GetComputerName(szCompName, &dwCompName))
		{
			ResultStream << T2A(szCompName);
			return ePassed;
		}
		return eFailedToExecute;
	}
	else
	{
		_tcscpy(szCompName, CTSTestData::GetMachineName());
		ResultStream << T2A(CTSTestData::GetMachineName());
		return ePassed;
	}
}

bool g_bIsInDomain = false;
EResult GetDomName (ostrstream &ResultStream)
{
	USES_CONVERSION;
    DSROLE_PRIMARY_DOMAIN_INFO_BASIC *pDomainInfo = NULL;
    DWORD dwErr;

    //
    // Check if we're in a workgroup
    //
    dwErr = DsRoleGetPrimaryDomainInformation(CTSTestData::GetMachineName(),
                                              DsRolePrimaryDomainInfoBasic,
                                              (PBYTE *) &pDomainInfo);

    if (ERROR_SUCCESS != dwErr)
	{
		ResultStream << "<Unknown Domain>";
		return eFailedToExecute;
	}

    switch (pDomainInfo->MachineRole)
    {
        case DsRole_RoleStandaloneWorkstation:
        case DsRole_RoleStandaloneServer:
            ResultStream << "<Workgroup>";
			return ePassed;
		default:
			break;
    }

    if (pDomainInfo->DomainNameFlat)
	{
        ResultStream << T2A(pDomainInfo->DomainNameFlat);
		g_bIsInDomain = true;
		return ePassed;
	}
    else if (pDomainInfo->DomainNameDns)
	{
        ResultStream << T2A(pDomainInfo->DomainNameDns);
		g_bIsInDomain = true;
		return ePassed;

	}
    else
	{
        ResultStream << "<Unknown Domain>";
		return eFailedToExecute;
	}
}


EResult GetIPAddress (ostrstream &ResultStream)
{
	USES_CONVERSION;
	WCHAR wszIPAddress[128];
	//
	//get host address
	//
	WORD wVersionRequested = MAKEWORD( 1, 1 ); 
	WSADATA wsaData;
	if (0 == WSAStartup(wVersionRequested,&wsaData))
    {
        hostent *h;
        if (NULL != (h=gethostbyname ( T2A(CTSTestData::GetMachineName()) )))
        {
            in_addr *inaddr=(struct in_addr *)*h->h_addr_list;

            MultiByteToWideChar(CP_ACP,0,inet_ntoa(*inaddr),-1,wszIPAddress,128);
			ResultStream << W2A(wszIPAddress);
			return ePassed;

        }
    }

	ResultStream << "Error Getting IP";
	return eFailedToExecute;
}



EResult IsRDPNPinNetProviders (ostrstream &ResultStream)
// TCHAR *IsRDPNPinNetProviders ()
{
    TCHAR NEWORK_PROVIDER_ORDER_KEY[] = _T("SYSTEM\\CurrentControlSet\\Control\\NetworkProvider\\Order");
    TCHAR PROVIDER_ORDER_VALUE[]      = _T("ProviderOrder");
    TCHAR RDPNP_ENTRY[]               = _T("RDPNP");
	bool bRdpNpExists				  = false;

	// read network privider key.
	CRegistry regNetOrder;
	LPTSTR szOldValue;
	DWORD dwSize;
	if ((ERROR_SUCCESS == regNetOrder.OpenKey(HKEY_LOCAL_MACHINE, NEWORK_PROVIDER_ORDER_KEY, KEY_READ, CTSTestData::GetMachineName())) && 
	   (ERROR_SUCCESS == regNetOrder.ReadRegString(PROVIDER_ORDER_VALUE, &szOldValue, &dwSize)))
	{
		bRdpNpExists = (_tcsstr(szOldValue, RDPNP_ENTRY) != NULL);
	
	}
	else
	{
		ResultStream << "Error: Failed to Read Registry!";
		return eFailedToExecute;
	}

	if (TSEnabled () == bRdpNpExists)
	{
		ResultStream << "Passed";
		return ePassed;
	}
	else
	{
		if (bRdpNpExists)
		{
			ResultStream << "Error: RDPNP, exists in ProviderOrder, but TS is disabled!";
			return eFailed;
		}
		else
		{
			if (IsIt50TS())
			{
				// rdp np is only for 51+ so its ok if its missing for 50.
				ResultStream << "Passed";
				return ePassed;
			}
			else
			{
				ResultStream << "ERROR, RDPNP is missing from ProviderOrder";
				return eFailed;
			}
		}
	}
}


EResult IsMultiConnectionAllowed (ostrstream &ResultStream)
// TCHAR *IsMultiConnectionAllowed ()
{
	// SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon","AllowMultipleTSSessions
	CRegistry regWL;
	DWORD dwAllowMultipal;
	if ((ERROR_SUCCESS == regWL.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ, CTSTestData::GetMachineName())) &&
		(ERROR_SUCCESS == regWL.ReadRegDWord(_T("AllowMultipleTSSessions"), &dwAllowMultipal)))
	{
		if (dwAllowMultipal)
		{
			ResultStream << "Yes";
		}
		else
		{
			ResultStream << "No";
		}

		return ePassed;
	}

	if (IsIt50TS())
	{
		ResultStream <<  "Yes";
		return ePassed;
	}
	else
	{
		ResultStream <<  "ERROR, registry missing";
		return eFailedToExecute;
	}
}

EResult LogonType (ostrstream &ResultStream)
// TCHAR *LogonType ()
{
	if (!g_bIsInDomain)
	{
		CRegistry regWL;
		DWORD dwLogonType;
		if ((ERROR_SUCCESS == regWL.OpenKey(HKEY_LOCAL_MACHINE, _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), KEY_READ, CTSTestData::GetMachineName())) &&
			(ERROR_SUCCESS == regWL.ReadRegDWord(_T("LogonType"), &dwLogonType)))
		{
			if (dwLogonType == 0)
			{
				ResultStream <<  "Classic Gina";
			}
			else
			{
				ResultStream <<  "New Fancy";
			}
			return ePassed;
		}

		if (IsIt50TS())
		{
			ResultStream << "Classic Gina";
			return ePassed;
		}
		else
		{
			ResultStream << "ERROR, registry missing";
			return eFailedToExecute;
		}
	}
	else
	{
		ResultStream << "Classic Gina";
		return ePassed;
	}
}

EResult IsTermSrvInSystemContext (ostrstream &ResultStream)
// bool IsTermSrvInSystemContext ()
{
    USES_CONVERSION;
    CRegistry reg;
    if ( ERROR_SUCCESS == reg.OpenKey( HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\TermService"), KEY_READ, CTSTestData::GetMachineName()))
    {
        TCHAR *szObjectName;
        DWORD dwSize;
        if ( ERROR_SUCCESS == reg.ReadRegString( _T("ObjectName"), &szObjectName, &dwSize))
        {
            if (0 == _tcsicmp(szObjectName, _T("LocalSystem")))
            {
				ResultStream << "Passed";
				return ePassed;

            }
            else
            {
				ResultStream << "ERROR:Termsrv is set to run using (" << T2A(szObjectName) << ") context." << endl;
				return eFailed;
            }
        }
        else
        {
			ResultStream << "failed to read Objectname";
			return eFailedToExecute;
        }
    }
    else
    {
		ResultStream << "failed to open termsrv registry";
		return eFailedToExecute;
    }
}
EResult IsBetaSystem (ostrstream &ResultStream)
{
	ASSERT (IsItLocalMachine()); 
	if (IsBetaSystem())
	{
		ResultStream << "Its a beta system";
	}
	else
	{
		ResultStream << "Its a retail build";
	}

	return ePassed;
}

EResult AreRemoteLogonEnabled (ostrstream &ResultStream)
{
	CRegistry oRegTermsrv;
	if (ERROR_SUCCESS == oRegTermsrv.OpenKey(
								HKEY_LOCAL_MACHINE, 
								_T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"), 
								KEY_READ, 
								CTSTestData::GetMachineName()
								))
	{
		DWORD dwSize = 0;
		LPTSTR szWinstationDisabled = NULL;
		if (ERROR_SUCCESS == oRegTermsrv.ReadRegString(_T("WinStationsDisabled"), &szWinstationDisabled, &dwSize))
		{
			if (_tcscmp(_T("0"), szWinstationDisabled) == 0)
			{
				ResultStream << "Passed";
				return ePassed;
			}
			else
			{
				USES_CONVERSION;
				ResultStream << "Failed, WinStationsDisabled is (" << T2A(szWinstationDisabled) << ")";
				return eFailed;
			}
		}
		else
		{
			ResultStream << "Failed to red registry";
			return eFailedToExecute;
		}
	}
	else
	{
		ResultStream << "Failed to read registry";
		return eFailedToExecute;
	}

}

EResult IsListenerSessionPresent(ostrstream &ResultStream)
{
    PWTS_SESSION_INFO pWtsSessionInfo;
    DWORD dwCount;
    bool bReturn = false;
	

	HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;
	if (CTSTestData::GetMachineName())
	{
		TCHAR szMachineName[256];
		_tcscpy(szMachineName, CTSTestData::GetMachineName());
		hServer = WTSOpenServer (szMachineName);
	}

    if (WTSEnumerateSessions(
        hServer,
        0,
        1,
        &pWtsSessionInfo,
        &dwCount
         ))
    {
        for (DWORD i = 0; i < dwCount; i++)
        {
            if (pWtsSessionInfo[i].State == WTSListen)
            {
                bReturn = true;
                break;
            }
        }

        WTSFreeMemory(pWtsSessionInfo);
    }
    else
    {
		ResultStream << "WTSEnumerateSessions failed!";
		return eFailedToExecute;
    }

	if (CTSTestData::GetMachineName())
		WTSCloseServer(hServer);

	if (bReturn)
	{
		ResultStream << "Passed!";
		return ePassed;
	}
	else
	{
		ResultStream << "Failed!";
		return eFailed;
	}
}


ULONG ulClientBuildNumber = 0xffffffff;
bool GetClientVersion(ULONG *pulClientBuildNumber)
{
	ASSERT(AreWeInsideSession());
	ASSERT(pulClientBuildNumber);
	if (ulClientBuildNumber == 0xffffffff)
	{
		LPTSTR pBuffer = NULL;
		DWORD dwBytesReturned = 0;
		if (WTSQuerySessionInformation(
			WTS_CURRENT_SERVER_HANDLE,
			WTS_CURRENT_SESSION,
			WTSClientBuildNumber,
			&pBuffer,
			&dwBytesReturned))
		{
			if (pBuffer && dwBytesReturned)
			{
				ulClientBuildNumber  =  ULONG(*pBuffer);
				*pulClientBuildNumber = ulClientBuildNumber;
				WTSFreeMemory(pBuffer);
				return true;
			}
			else
			{
				return false;
			}
			
		}
		else
		{
			return false;
		}
	}
	else
	{
		*pulClientBuildNumber = ulClientBuildNumber;
		return true;
	}
}

USHORT gusClientProtocol = 0xffff;
bool GetClientProtocol (USHORT *pusClientProtocol)
{
	ASSERT(AreWeInsideSession());
	ASSERT(pusClientProtocol);
	if (gusClientProtocol == 0xffff)
	{
		LPTSTR pBuffer = NULL;
		DWORD dwBytesReturned = 0;
		if (WTSQuerySessionInformation(
			WTS_CURRENT_SERVER_HANDLE,
			WTS_CURRENT_SESSION,
			WTSClientProtocolType,
			&pBuffer,
			&dwBytesReturned))
		{
			if (pBuffer && dwBytesReturned)
			{
				gusClientProtocol =  USHORT(*pBuffer);
				*pusClientProtocol = gusClientProtocol;
				WTSFreeMemory(pBuffer);
				return true;
			}
			else
			{
				return false;
			}
		}
		else
		{
			return false;
		}
	}
	else
	{
		*pusClientProtocol = gusClientProtocol;
		return true;
	}
}

EResult GetClientVersion(ostrstream &ResultStream)
{
	ULONG ulClientVersion;
	ASSERT(AreWeInsideSession());
	if (GetClientVersion(&ulClientVersion))
	{
		ResultStream << ulClientVersion;
		return ePassed;
	}
	else
	{
		ResultStream << "Failed to retrive client version";
		return eFailedToExecute;
	}

}

EResult GetClientProtocol(ostrstream &ResultStream)
{
	USHORT usClientProtocol;
	ASSERT(AreWeInsideSession());
	if (GetClientProtocol(&usClientProtocol))
	{
		switch (usClientProtocol)
		{
		case WTS_PROTOCOL_TYPE_CONSOLE:
			ResultStream << "WTS_PROTOCOL_TYPE_CONSOLE(" <<  usClientProtocol << ")";
			break;
		case WTS_PROTOCOL_TYPE_ICA:
			ResultStream << "WTS_PROTOCOL_TYPE_ICA(" <<  usClientProtocol << ")";
			break;
		case WTS_PROTOCOL_TYPE_RDP:
			ResultStream << "WTS_PROTOCOL_TYPE_RDP(" <<  usClientProtocol << ")";
			break;
		default:
			ResultStream << "Unknown Protocol Value(" <<  usClientProtocol << ")";
			break;
		}
		return ePassed;
	}
	else
	{
		ResultStream << "Failed to retrive client protocol";
		return eFailedToExecute;
	}
}	


EResult DoesClientSupportAudioRedirection (ostrstream &ResultStream)
{
	ASSERT(AreWeInsideSession());

	const USHORT GOOD_CLIENT_VERSION_FOR_AUDIO_REDIRECTION = 2252;
	ULONG ulClientVersion;
	USHORT usClientProtocol;
	
	if (GetClientVersion(&ulClientVersion) && GetClientProtocol(&usClientProtocol))
	{
		if (ulClientVersion >= GOOD_CLIENT_VERSION_FOR_AUDIO_REDIRECTION && usClientProtocol == WTS_PROTOCOL_TYPE_RDP)
		{
			ResultStream << "Passed";
			return ePassed;
		}
		else
		{
			if (ulClientVersion < GOOD_CLIENT_VERSION_FOR_AUDIO_REDIRECTION )
			{
				ResultStream << "Failed. You client is old, it does not support audio redirection.";
			}
			else if(usClientProtocol != WTS_PROTOCOL_TYPE_RDP)
			{
				ResultStream << "Failed. You client is not Microsoft RDP, it may not support audio redirection.";
			}
			else
			{
				ASSERT(false);
			}
			
			return eFailed;
		}
	}
	else
	{
		ResultStream  << "Failed to get client version";
		return eFailedToExecute;
	}
}

EResult DoesClientSupportPrinterRedirection (ostrstream &ResultStream)
{
	ASSERT(AreWeInsideSession());

	const USHORT GOOD_CLIENT_VERSION_FOR_PRINTER_REDIRECTION = 2100; // BUGBUG :get good value for this from tADB
	ULONG ulClientVersion;
	USHORT usClientProtocol;
	
	if (GetClientVersion(&ulClientVersion) && GetClientProtocol(&usClientProtocol))
	{
		if (ulClientVersion >= GOOD_CLIENT_VERSION_FOR_PRINTER_REDIRECTION && usClientProtocol == WTS_PROTOCOL_TYPE_RDP)
		{
			ResultStream << "Passed";
			return ePassed;
		}
		else
		{
			if (ulClientVersion < GOOD_CLIENT_VERSION_FOR_PRINTER_REDIRECTION )
			{
				ResultStream << "Failed. You client is old, it does not support printer redirection.";
			}
			else if(usClientProtocol != WTS_PROTOCOL_TYPE_RDP)
			{
				ResultStream << "Failed. You client is not Microsoft RDP, it may not support printer redirection.";
			}
			else
			{
				ASSERT(false);
			}
			
			return eFailed;
		}
	}
	else
	{
		ResultStream  << "Failed to get client version";
		return eFailedToExecute;
	}
}

EResult DoesClientSupportFileRedirection (ostrstream &ResultStream)
{
	ASSERT(AreWeInsideSession());

	const USHORT GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION = 2200; // BUGBUG :get good value for this from tADB
	ULONG ulClientVersion;
	USHORT usClientProtocol;
	
	if (GetClientVersion(&ulClientVersion) && GetClientProtocol(&usClientProtocol))
	{
		if (ulClientVersion >= GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION && usClientProtocol == WTS_PROTOCOL_TYPE_RDP)
		{
			ResultStream << "Passed";
			return ePassed;
		}
		else
		{
			if (ulClientVersion < GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION )
			{
				ResultStream << "Failed. You client is old, it does not support file redirection.";
			}
			else if(usClientProtocol != WTS_PROTOCOL_TYPE_RDP)
			{
				ResultStream << "Failed. You client is not Microsoft RDP, it may not support file redirection.";
			}
			else
			{
				ASSERT(false);
			}
			
			return eFailed;
		}
	}
	else
	{
		ResultStream  << "Failed to get client version";
		return eFailedToExecute;
	}
}



EResult DoesClientSupportClipboardRedirection (ostrstream &ResultStream)
{
	ASSERT(AreWeInsideSession());

	const USHORT GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION = 2100; // BUGBUG :get good value for this from Nadim
	ULONG ulClientVersion;
	USHORT usClientProtocol;
	
	if (GetClientVersion(&ulClientVersion) && GetClientProtocol(&usClientProtocol))
	{
		if (ulClientVersion >= GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION && usClientProtocol == WTS_PROTOCOL_TYPE_RDP)
		{
			ResultStream << "Passed";
			return ePassed;
		}
		else
		{
			if (ulClientVersion < GOOD_CLIENT_VERSION_FOR_FILE_REDIRECTION )
			{
				ResultStream << "Failed. You client is old, it does not support Clipboard redirection.";
			}
			else if(usClientProtocol != WTS_PROTOCOL_TYPE_RDP)
			{
				ResultStream << "Failed. You client is not Microsoft RDP, it may not support Clipboard redirection.";
			}
			else
			{
				ASSERT(false);
			}
			
			return eFailed;
		}
	}
	else
	{
		ResultStream  << "Failed to get client version";
		return eFailedToExecute;
	}
}

// #define TS_POLICY_SUB_TREE L"Software\\Policies\\Microsoft\\Windows NT\\Terminal Services"


bool GetWinstationInformation(WINSTATIONINFORMATION **ppInfo)
{
	ASSERT(ppInfo);
	ASSERT(AreWeInsideSession());
	static bool sbGotWinstaInfo = false;
    static WINSTATIONINFORMATION WSInfo;
	ULONG ReturnLength;

	if (sbGotWinstaInfo)
	{
		*ppInfo = &WSInfo; 
		return true;
	}

	if (WinStationQueryInformation(
			WTS_CURRENT_SERVER_HANDLE,
			WTS_CURRENT_SESSION,
			WinStationInformation,
			&WSInfo,
			sizeof(WSInfo),
			&ReturnLength
		))
	{
		sbGotWinstaInfo = true;
		*ppInfo = &WSInfo; 
		return true;
	}

	return false;
}

bool GetWinstationConfiguration (WINSTATIONCONFIG **ppInfo)
{
	ASSERT(ppInfo);
	ASSERT(AreWeInsideSession());
	static bool sbGotWinstaConfig = false;
	static WINSTATIONCONFIG WSConfig;
	ULONG ReturnLength;

	if (sbGotWinstaConfig)
	{
		*ppInfo = &WSConfig; 
		return true;
	}

	if (WinStationQueryInformation(
			WTS_CURRENT_SERVER_HANDLE,
			WTS_CURRENT_SESSION,
			WinStationConfiguration,
			&WSConfig,
			sizeof(WSConfig),
			&ReturnLength
		))
	{
		sbGotWinstaConfig = true;
		*ppInfo = &WSConfig; 
		return true;
	}

	return false;

}

EResult GetUserName(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONINFORMATION *pWSInfo = NULL;

	if (GetWinstationInformation(&pWSInfo))
	{
		TCHAR szUser[256];
		_tcscpy(szUser, pWSInfo->Domain);
		_tcscat(szUser, _T("\\"));
		_tcscat(szUser, pWSInfo->UserName);
		ResultStream << T2A(szUser);
		return ePassed;
	}

	ResultStream << "Failed to get UserName";
	return eFailedToExecute;
}

EResult GetPolicy (ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		/*
		ResultStream << "fPromptForPassword" << pWSInfo->User.fPromptForPassword << "," << endl;
		ResultStream << "fResetBroken" << pWSInfo->User.fResetBroken << "," << endl;
		ResultStream << "fReconnectSame " << pWSInfo->User.fReconnectSame << "," << endl;
		ResultStream << "fLogonDisabled " << pWSInfo->User.fLogonDisabled << "," << endl;;
		ResultStream << "fWallPaperDisabled" << pWSInfo->User.fWallPaperDisabled << "," << endl;
		ResultStream << "fAutoClientDrives" << pWSInfo->User.fAutoClientDrives << "," << endl;
		ResultStream << "fAutoClientLpts" << pWSInfo->User.fAutoClientLpts << "," << endl;
		ResultStream << "fForceClientLptDef" << pWSInfo->User.fForceClientLptDef << "," << endl;
		ResultStream << "fRequireEncryption" << pWSInfo->User.fRequireEncryption << "," << endl;
		ResultStream << "fDisableEncryption" << pWSInfo->User.fDisableEncryption << "," << endl;
		ResultStream << "fUnused1" << pWSInfo->User.fUnused1 << "," << endl;
		ResultStream << "fHomeDirectoryMapRoot" << pWSInfo->User.fHomeDirectoryMapRoot << "," << endl;
		ResultStream << "fUseDefaultGina" << pWSInfo->User.fUseDefaultGina << "," << endl;
		*/

		/*
    ULONG fDisableCpm : 1;
for printing
    ULONG fDisableCdm : 1;
for drive
    ULONG fDisableCcm : 1;
for com port
    ULONG fDisableLPT : 1;
for lpt port
    ULONG fDisableClip : 1;
for clipboard redirection
    ULONG fDisableExe : 1;

    ULONG fDisableCam : 1;
for audio redirection

    ULONG ColorDepth : 3;
Color depth.

		*/
		ResultStream << "printer redirection = " << pWSInfo->User.fDisableCpm << endl;
		ResultStream << "drive redirection = " << pWSInfo->User.fDisableCdm << endl;
		ResultStream << "com port redirection = " << pWSInfo->User.fDisableCcm << endl;
		ResultStream << "LPT port redirection = " << pWSInfo->User.fDisableLPT << endl;
		ResultStream << "Clipboard redirection =" << pWSInfo->User.fDisableClip << endl;
		ResultStream << "fDisableExe = " << pWSInfo->User.fDisableExe << endl;
		ResultStream << "Audio Redireciton = " << pWSInfo->User.fDisableCam << endl;

		return ePassed;

	}
	else
	{
		ResultStream << "Failed to get config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectPrinter (ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableCpm)
		{
			ResultStream << "Failed. Printer Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectDrives(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableCdm)
		{
			ResultStream << "Failed. Local Drive Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectClipboard(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableClip)
		{
			ResultStream << "Failed. Clipboard redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectCom(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableCcm)
		{
			ResultStream << "Failed. Com port Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanRedirectAudio(ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableCam)
		{
			ResultStream << "Failed. Audio Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
        }
        else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

EResult CanClientPlayAudio(ostrstream &ResultStream)
{
    EResult     rv = eFailedToExecute;
    HANDLE      hStream = NULL;
    PSNDSTREAM  Stream = NULL;

    hStream = OpenFileMapping(
                    FILE_MAP_ALL_ACCESS,
                    FALSE,
                    TSSND_STREAMNAME
                );

    if (NULL == hStream)
    {
        ResultStream << "Can't open audio stream";
        goto exitpt;
    }

    Stream = (PSNDSTREAM)MapViewOfFile(
                    hStream,
                    FILE_MAP_ALL_ACCESS,
                    0, 0,       // offset
                    sizeof(*Stream)
                    );

    if (NULL == Stream)
    {
        ResultStream << "Can't lock audio stream memory";
        goto exitpt;
    }

    if ( 0 != (TSSNDCAPS_ALIVE & Stream->dwSoundCaps) )
    {
        ResultStream << "Passed";
        rv = ePassed;
    }
    else
    {
        ResultStream << "Client doesn't have audio hardware or audio redirection is not enabled on the client side";
        rv = eFailed;
    }

exitpt:

    if ( NULL != Stream )
        UnmapViewOfFile( Stream );

    if ( NULL != hStream )
        CloseHandle( hStream );

    return rv;
}

EResult NotConsoleAudio( ostrstream &ResultStream )
{
    EResult rv = eFailedToExecute;


    if (NtCurrentPeb()->SessionId == 0 || IsItPTS())
    {
        HANDLE hConsoleAudioEvent = OpenEvent(SYNCHRONIZE, FALSE, L"Global\\WinMMConsoleAudioEvent");

        if (hConsoleAudioEvent != NULL)
        {
            DWORD status = WaitForSingleObject(hConsoleAudioEvent, 0);

            if (status == WAIT_OBJECT_0)
            {
                ResultStream << "Client audio settings are: Leave at remote computer";
                rv = eFailed;
            }
            else
            {
                ResultStream << "Passed";
                rv = ePassed;
            }

            CloseHandle(hConsoleAudioEvent);
        }
        else
        {
            ResultStream << "Failed to open Global\\WinMMConsoleAudioEvent";
    		rv = eFailedToExecute;
        }
    }
    else
    {
        ResultStream << "Not running on remote console or Whistler Professional";
        rv = ePassed;
    }

    return rv;
}

EResult CanRedirectLPT (ostrstream &ResultStream)
{
	USES_CONVERSION;
	ASSERT(AreWeInsideSession());
    WINSTATIONCONFIG  *pWSInfo = NULL;

	if (GetWinstationConfiguration(&pWSInfo))
	{
		if (pWSInfo->User.fDisableLPT)
		{
			ResultStream << "Failed. LPT port Redirection is disabled either by Group Policy or TSCC settings.";
			return eFailed;
		}
		else
		{
			ResultStream << "Passed";
			return ePassed;
		}
	}
	else
	{
		ResultStream << "Failed to retrive config data";
		return eFailedToExecute;
	}
}

bool CanRunAllTests()
{
	return DoIHaveEnufPermissions();
}

bool CanRunGeneralInfo ()
{
	return DoIHaveEnufPermissions();
}
bool CanRunCantConnect ()
{
	return (CanPing() && DoIHaveEnufPermissions());
}
bool CanRunCantPrint ()
{
	return AreWeInsideSession();
}
bool CanRunCantCopyPaste ()
{
	return AreWeInsideSession();
}
bool CanRunFileRedirect ()
{
	return AreWeInsideSession();
}
bool CanRunLptRedirect ()
{
	return AreWeInsideSession();
}
bool CanRunComRedirect ()
{
	return AreWeInsideSession();
}
bool CanRunAudioRedirect ()
{
	return AreWeInsideSession();
}

TCHAR *WhyCantRunAllTests()
{
	ASSERT(!CanRunAllTests());
	if (!DoIHaveEnufPermissions())
	{
		return _T("You do not have sufficient permissions to run this test against target system.");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunAllTests");
	}
}
TCHAR *WhyCantRunGeneralInfo()
{
	ASSERT(!CanRunGeneralInfo());
	if (!DoIHaveEnufPermissions())
	{
		return _T("You do not have sufficient permissions to run this test against target system.");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunGeneralInfo");
	}
}
TCHAR *WhyCantRunCantConnect()
{
	ASSERT(!CanRunCantConnect());
	if (!CanPing())
	{
		return _T("Ping test Failed for target machine. Please make sure target machine is on the network");
	}
	if (!DoIHaveEnufPermissions())
	{
		return _T("You do not have sufficient permissions to run this test against target system.");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunCantConnect");
	}
}
TCHAR *WhyCantRunCantPrint()
{
	ASSERT(!CanRunCantPrint());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunCantPrint");
	}

}
TCHAR *WhyCantRunCantCopyPaste()
{
	ASSERT(!CanRunCantCopyPaste());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunCantCopyPaste");
	}
}
TCHAR *WhyCantRunFileRedirect()
{
	ASSERT(!CanRunFileRedirect());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunFileRedirect");
	}
}
TCHAR *WhyCantRunLptRedirect()
{
	ASSERT(!CanRunLptRedirect());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunLptRedirect");
	}
}
TCHAR *WhyCantRunComRedirect()
{
	ASSERT(!CanRunComRedirect());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunComRedirect");
	}
}
TCHAR *WhyCantRunAudioRedirect()
{
	ASSERT(!CanRunAudioRedirect());
	if (!AreWeInsideSession())
	{
		return _T("For diagnosing this problem, you mush run these troubleshooter within the session. Plese create a remote desktop session to the target machine, and then troubleshoot");
	}
	else
	{
		ASSERT(false);
		return _T("WhyCantRunAudioRedirect");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\tst.h ===
//
// This file defines basic test structures
// this should not contain any ts specific things.
//

#ifndef ___TST_H___
#define ___TST_H___


enum EResult 
{
	eFailed = 0,
	ePassed = 1,
	eUnknown= 2,
	eFailedToExecute = 4
};

typedef bool	(PFN_SUITE_FUNC)();
typedef TCHAR * (PFN_SuiteErrorReason)(void);
typedef bool	(PFN_BOOL)(void);
typedef EResult (PFN_TEST_FUNC)(ostrstream &);


typedef struct _TVerificationTest
{
	UINT				uiName;
    //char szTestName[256];                   // descriptive name of the test
    PFN_BOOL            *pfnNeedRunTest;     // pointer to function that will be called to decide if the test need run, test is run if NULL.
	PFN_TEST_FUNC		*pfnTestFunc;
	DWORD				SuiteMask;
	UINT				uiTestDetailsLocal;
	UINT				uiTestDetailsRemote;
	char TestDetails[2048];

} TVerificationTest, *PTVerificationTest;


typedef struct _TTestSuite
{
	LPCTSTR					szSuiteName;
	PFN_SUITE_FUNC *		pfnCanRunSuite;
	PFN_SuiteErrorReason *  pfnSuiteErrorReason;				
	DWORD					dwTestCount;
	int	*					aiTests;

} TTestSuite, *PTTestSuite;




// to implement your test suites, derive from this class.
class CTestData 
{
	public:
		CTestData() {};
		virtual ~CTestData() {};


	virtual DWORD 				GetSuiteCount	() const = 0;
	virtual LPCTSTR				GetSuiteName	(DWORD dwSuite) const = 0 ;
	virtual DWORD				GetTestCount    (DWORD dwSuite) const = 0 ;
	virtual PTVerificationTest	GetTest			(DWORD dwSuite, DWORD iTestNumber) const = 0 ;
};


DWORD						GetTotalTestCount ();
PTVerificationTest			GetTest (DWORD dwTestIndex);

#endif // ___TST_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\vermak.h ===
// Copyright (c) 1998 - 1999 Microsoft Corporation

/////////////////////////////////////////////////////////////////////////////
// VERSION INFO
#include <ntverp.h>


#define	VER_FILETYPE	VFT_APP
#define	VER_FILESUBTYPE	VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Terminal Server Setup Test"
#define VER_INTERNALNAME_STR        "tstst"
#define VER_ORIGINALFILENAME_STR    "tstst.exe"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\dll\testdata.cpp ===
// testdata.cpp


#include "stdafx.h"

#define ____InsideTestData____
#include "testdata.h"
#include "tstst.h"
#include "resource.h"




/////////////////////////////////////////////////////////////////////////////
// CTSDiagnosis

enum ETSTestSuite
{
	eFirstSuite = 0,
	eAllTestsSuite	= 0,
	eGeneralInformation = 1,
	eCantConnect = 2,
	eCantPrint = 3,
	eCantCopyPaste = 4,
	eCantFileRedirect = 5,
	eCantLptRedirect = 6,
	eCantComRedirect = 7,
	eCantAudioRedirect = 8,
	eLastSuite = eCantAudioRedirect,
	eSuiteCount = eLastSuite + 1
};

const DWORD ALL_TEST_SUITE_MASK	= 		(0x1 << eAllTestsSuite);
const DWORD GENERAL_SUITE_MASK	=		(0x1 << eGeneralInformation);
const DWORD CANT_CONNECT_SUITE_MASK =	(0x1 << eCantConnect);
const DWORD CANT_PRINT_SUITE_MASK =		(0x1 << eCantPrint);
const DWORD CANT_COPYPASTE_SUITE_MASK = (0x1 << eCantCopyPaste);
const DWORD CANT_FILE_REDIRECT_SUITE_MASK = (0x1 << eCantFileRedirect);
const DWORD CANT_LPT_REDIRECT_SUITE_MASK = (0x1 << eCantLptRedirect);
const DWORD CANT_COM_REDIRECT_SUITE_MASK = (0x1 << eCantComRedirect);
const DWORD CANT_AUDIO_REDIRECT_SUITE_MASK = (0x1 << eCantAudioRedirect);



#define  RemoteTABText "" \
"<HTML>\n" \
"<BODY>\n" \
"<OBJECT id=TSDiag classid=clsid:50B5F461-FDC2-40D4-B2C5-1C2EE0CDA190></OBJECT>\n" \
"Remote connections are disabled for this computer. To enable them, use <A href=javascript:ExecuteIt('control.exe%20sysdm.cpl,,5');>Remote Tab</A>\n" \
"</BODY>\n" \
"<SCRIPT LANGUAGE=javascript>\n" \
"function ExecuteIt(str)\n" \
"{\n" \
"var tsdiagObject =  new ActiveXObject(\"TSDiag.TSDiagnosis\");\n" \
"tsdiagObject.ExecuteIt(str);\n" \
"}\n" \
"</SCRIPT>\n" \
"</HTML>\n"

#define  GroupPolicyText "" \
"<HTML>\n" \
"<BODY>\n" \
"<OBJECT id=TSDiag classid=clsid:50B5F461-FDC2-40D4-B2C5-1C2EE0CDA190></OBJECT>\n" \
"Remote connections are disabled for this computer through Group Policy. you need to contact the administrator to set the right group policy. you can view current group policy configuration using <A href=javascript:ExecuteIt('gpedit.msc');>gpedit.msc</A>\n" \
"</BODY>\n" \
"<SCRIPT LANGUAGE=javascript>\n" \
"function ExecuteIt(str)\n" \
"{\n" \
"var tsdiagObject =  new ActiveXObject(\"TSDiag.TSDiagnosis\");\n" \
"tsdiagObject.ExecuteIt(str);\n" \
"}\n" \
"</SCRIPT>\n" \
"</HTML>\n"

#define  ServiceStartTypeProblemsText "" \
"<HTML>\n" \
"<BODY>\n" \
"<OBJECT id=TSDiag classid=clsid:50B5F461-FDC2-40D4-B2C5-1C2EE0CDA190></OBJECT>\n" \
"Terminal Server service Start Type is wrong on this computer. In order to work properly start Type for Terminal server must be Manual Start. If this test fails, to correct this problem open <A href=javascript:ExecuteIt('services.msc');>Services snapin</A> and change Terminal Services Service Start Type to manual start.\n" \
"</BODY>\n" \
"<SCRIPT LANGUAGE=javascript>\n" \
"function ExecuteIt(str)\n" \
"{\n" \
"var tsdiagObject =  new ActiveXObject(\"TSDiag.TSDiagnosis\");\n" \
"tsdiagObject.ExecuteIt(str);\n" \
"}\n" \
"</SCRIPT>\n" \
"</HTML>\n"

#define  ServiceContextTypeProblemsText "" \
"<HTML>\n" \
"<BODY>\n" \
"<OBJECT id=TSDiag classid=clsid:50B5F461-FDC2-40D4-B2C5-1C2EE0CDA190></OBJECT>\n" \
"Terminal Server service must be in the system context to work properly. If this test fails, use the <A href=javascript:ExecuteIt('services.msc');>Services snapin</A> to change the Terminal Server service to use System Account." \
"</BODY>\n" \
"<SCRIPT LANGUAGE=javascript>\n" \
"function ExecuteIt(str)\n" \
"{\n" \
"var tsdiagObject =  new ActiveXObject(\"TSDiag.TSDiagnosis\");\n" \
"tsdiagObject.ExecuteIt(str);\n" \
"}\n" \
"</SCRIPT>\n" \
"</HTML>\n"

TVerificationTest theTests[] =
{
	{IDS_MACHINENAME,
		NULL,
		GetCompName,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_MACHINENAME_FAILED,
		0},

	{IDS_DOMAINNAME,
		NULL,
		GetDomName,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_DOMAINNAME_FAILED,
		0
		},

	{IDS_IP_ADDRESS,
		NULL,
		GetIPAddress,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IP_ADDRESS_FAILED,
		0},

	{IDS_PRODUCTTYPE,
		IsItLocalMachine,
		GetProductType,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_PRODUCTTYPE_FAILED,
		0},

	{IDS_PRODUCTSUITE,
		IsItLocalMachine,
		GetProductSuite,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_PRODUCTSUITE_FAILED,
		0},

	{IDS_TSVERSION,
		NULL,
		GetTSVersion,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_TSVERSION_FAILED,
		0},

	{IDS_ISSERVER,
		IsIt50TS,
		IsItServer,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_ISSERVER_FAILED,
		0},

	{IDS_CLIENT_VERSION,
		AreWeInsideSession,
		GetClientVersion,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_CLIENT_VERSION_FAILED,
		0},

	{IDS_SESSION_USERNAME,
		AreWeInsideSession,
		GetUserName,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_SESSION_USERNAME_FAILED,
		0},

	{IDS_IS_TSOCLOG_PRESENT,
		IsUserRemoteAdmin,
		IsTSOClogPresent,
		ALL_TEST_SUITE_MASK |  CANT_CONNECT_SUITE_MASK,
		IDS_IS_TSOCLOG_PRESENT_FAILED,
		0},

	{IDS_DID_SETUP_FINISH,
		IsTSOClogPresent,
		DidTsOCgetCompleteInstallationMessage,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_DID_SETUP_FINISH_FAILED,
		0},

	{IDS_CLUSTERING_INSTALLED,
		IsIt50TS,
		IsClusteringInstalled,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_CLUSTERING_INSTALLED_FAILED,
		0},

	{IDS_IS_TSPRODUCT,
		IsItServer,
		DoesProductSuiteContainTS,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TSPRODUCT_FAILED,
		0},

	{IDS_DID_OCM_INSTALL_TS,
		IsIt50TS,
		DidOCMInstallTSEnable,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_DID_OCM_INSTALL_TS_FAILED,
		0},

	{IDS_IS_TS_ENABLED,
		NULL,
		TSEnabled,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TS_ENABLED_FAILED,
		0},

	{IDS_IS_KERNEL_TSENABLED,
		IsItLocalServer,
		IsKernelTSEnable,
		ALL_TEST_SUITE_MASK  | CANT_CONNECT_SUITE_MASK,
		IDS_IS_KERNEL_TSENABLED_FAILED,
		0},

	{IDS_IS_TSREGISTRY_OK,
		NULL,
		IsTerminalServerRegistryOk,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TSREGISTRY_OK_FAILED,
		0},

	{IDS_WINSTATIONS_OK,
		NULL,
		GetWinstationList,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_WINSTATIONS_OK_FAILED,
		0},

	{IDS_IS_TERMSRV_RUNNING,
		NULL,
		IsTerminalServiceRunning,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TERMSRV_RUNNING_FAILED,
		0},

	{IDS_IS_TS_STARTBIT_OK,
		IsUserRemoteAdmin,
		IsTerminalServiceStartBitSet,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TS_STARTBIT_OK_FAILED,
		0},

	{IDS_IS_TS_IN_SYSTEM_CONTEXT,
		IsUserRemoteAdmin,
		IsTermSrvInSystemContext,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_TS_IN_SYSTEM_CONTEXT_FAILED,
		0},

	{IDS_IS_LISTNER_PRESENT,
		IsTerminalServiceRunning,
		IsListenerSessionPresent,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_LISTNER_PRESENT_FAILED,
		0},

	{IDS_REMOTELOGON_ENABLED,
		NULL,
		AreRemoteLogonEnabled,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_REMOTELOGON_ENABLED_FAILED,
		0},

	{IDS_REMOTE_CONNECTION_GP,
		IsIt51TS,
		IsGroupPolicyOk,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_REMOTE_CONNECTION_GP_FAILED,
		0},

	{IDS_REMOTE_CONNECTION_LOCAL,
		IsIt51TS,
		AreConnectionsAllowed,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_REMOTE_CONNECTION_LOCAL_FAILED,
		0},

	{IDS_RDPDR_INSTALLED,
		IsItLocalMachine,
		IsRdpDrInstalledProperly,
		ALL_TEST_SUITE_MASK | CANT_PRINT_SUITE_MASK,
		IDS_RDPDR_INSTALLED_FAILED,
		0},

	{IDS_RDPNP_INSTALLED,
		IsIt51TS,
		IsRDPNPinNetProviders,
		ALL_TEST_SUITE_MASK | CANT_FILE_REDIRECT_SUITE_MASK,
		IDS_RDPNP_INSTALLED_FAILED,
		0},

	{IDS_MULTIPAL_CONNECTION_ALLOWED,
		IsIt51TS,
		IsMultiConnectionAllowed,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_MULTIPAL_CONNECTION_ALLOWED_FAILED,
		0},

	{IDS_LOGON_UI,
		IsIt51TS,
		LogonType,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_LOGON_UI_FAILED,
		0},
/*
	{"Are Video keys setup right?................",
		NULL,
		CheckVideoKeys,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		"Just another setup test."		},
*/

	{IDS_TS_MODE,
		NULL,
		GetTSMode,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_TS_MODE_FAILED,
		0},

	{IDS_IS_MODE_REGISTRYOK,
		NULL,
		VerifyModeRegistry,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_IS_MODE_REGISTRYOK_FAILED,
		0},

	{IDS_PERM_MODE,
		NULL,
		GetModePermissions,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK,
		IDS_PERM_MODE_FAILED,
		0},

	{IDS_STACK_BINARIES_SIGNED,
		IsItLocalMachine,
		Check_StackBinSigatures,
		ALL_TEST_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_STACK_BINARIES_SIGNED_FAILED,
		0},

	{IDS_ENCRYPTION_LEVEL,
		IsUserRemoteAdmin,
		GetCypherStrenthOnRdpwd,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_ENCRYPTION_LEVEL_FAILED,
		0},

	{IDS_IS_BETA_SYSTEM,
		IsItLocalMachine,
		IsBetaSystem,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_IS_BETA_SYSTEM_FAILED,
		0},

	{IDS_GRACE_PERIOD_OK,
		IsItLocalMachine,
		HasLicenceGracePeriodExpired,
		ALL_TEST_SUITE_MASK | GENERAL_SUITE_MASK | CANT_CONNECT_SUITE_MASK,
		IDS_GRACE_PERIOD_OK_FAILED,
		0},

	{IDS_CLIENT_SUPPORT_AUDIO,
		AreWeInsideSession,
 		DoesClientSupportAudioRedirection,
		ALL_TEST_SUITE_MASK | CANT_AUDIO_REDIRECT_SUITE_MASK,
		IDS_CLIENT_SUPPORT_AUDIO_FAILED,
		0},

	{IDS_CLIENT_SUPPORT_PRINTER,
		AreWeInsideSession,
		DoesClientSupportPrinterRedirection,
		ALL_TEST_SUITE_MASK | CANT_PRINT_SUITE_MASK,
		IDS_CLIENT_SUPPORT_PRINTER_FAILED,
		0},

	{IDS_CLIENT_SUPPORT_FILE,
		AreWeInsideSession,
		DoesClientSupportFileRedirection ,
		ALL_TEST_SUITE_MASK | CANT_FILE_REDIRECT_SUITE_MASK,
		IDS_CLIENT_SUPPORT_FILE_FAILED,
		0},

	{IDS_CLIENT_SUPPORT_CLIPBOARD,
		AreWeInsideSession,
		DoesClientSupportClipboardRedirection,
		ALL_TEST_SUITE_MASK | CANT_COPYPASTE_SUITE_MASK,
		IDS_CLIENT_SUPPORT_CLIPBOARD_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_PRINTER,
		AreWeInsideSession,
		CanRedirectPrinter,
		ALL_TEST_SUITE_MASK | CANT_PRINT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_PRINTER_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_AUDIO,
		AreWeInsideSession, 
		CanRedirectAudio,
		ALL_TEST_SUITE_MASK | CANT_AUDIO_REDIRECT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_AUDIO_FAILED,
		0},

    {IDS_TERMSRV_CLIENT_AUDIO_ENABLED,
        IsAudioEnabled,
        CanClientPlayAudio,
        ALL_TEST_SUITE_MASK | CANT_AUDIO_REDIRECT_SUITE_MASK,
        IDS_TERMSRV_CLIENT_AUDIO_ENABLED_FAILED,
        0},

    {IDS_TERMSRV_CLIENT_AUDIO_SETTINGS,
        IsItRemoteConsole,
        NotConsoleAudio,
        ALL_TEST_SUITE_MASK | CANT_AUDIO_REDIRECT_SUITE_MASK,
        IDS_TERMSRV_CLIENT_AUDIO_SETTINGS_FAILED,
        0},

	{IDS_TERMSRV_CONFIG_COM,
		AreWeInsideSession,
		CanRedirectCom,
		ALL_TEST_SUITE_MASK | CANT_COM_REDIRECT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_COM_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_CLIPBOARD,
		AreWeInsideSession,
		CanRedirectClipboard,
		ALL_TEST_SUITE_MASK | CANT_COPYPASTE_SUITE_MASK,
		IDS_TERMSRV_CONFIG_CLIPBOARD_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_FILE,
		AreWeInsideSession,
		CanRedirectDrives,
		ALL_TEST_SUITE_MASK | CANT_FILE_REDIRECT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_FILE_FAILED,
		0},

	{IDS_TERMSRV_CONFIG_LPT,
		AreWeInsideSession,
		CanRedirectLPT,
		ALL_TEST_SUITE_MASK | CANT_LPT_REDIRECT_SUITE_MASK,
		IDS_TERMSRV_CONFIG_LPT_FAILED,
		0},

};

TTestSuite m_pSuites[eSuiteCount] = 
{
	{_T("All Tests"), CanRunAllTests, WhyCantRunAllTests, 0, NULL},
	{_T("General Information"), CanRunGeneralInfo, WhyCantRunGeneralInfo, 0, NULL},
	{_T("Cant Connect"), CanRunCantConnect, WhyCantRunCantConnect, 0, NULL},
	{_T("Cant Print"), CanRunCantPrint, WhyCantRunCantPrint, 0, NULL},
	{_T("eCantCopyPaste"), CanRunCantCopyPaste, WhyCantRunCantCopyPaste, 0, NULL},
	{_T("eCantFileRedirect"), CanRunFileRedirect, WhyCantRunFileRedirect, 0, NULL},
	{_T("eCantLptRedirect"), CanRunLptRedirect, WhyCantRunLptRedirect, 0, NULL},
	{_T("eCantComRedirect"), CanRunComRedirect, WhyCantRunComRedirect, 0, NULL},
	{_T("eCantAudioRedirect"), CanRunAudioRedirect, WhyCantRunAudioRedirect, 0, NULL}
};

CTSTestData::CTSTestData()
{
	// generate the test database for suites.

	m_lpMachineName = NULL;
	for (DWORD dwSuite = 0; dwSuite < eSuiteCount; dwSuite++)
	{
		// get the test count for this suite.
		DWORD dwThisSuiteMask = 0x1  << dwSuite;
		m_pSuites[dwSuite].dwTestCount = 0;
		for (DWORD dwTest = 0; dwTest < sizeof(theTests) / sizeof(theTests[0]); dwTest++)
		{
			// if this test is for the given suite.
			if (theTests[dwTest].SuiteMask & dwThisSuiteMask)
			{
				m_pSuites[dwSuite].dwTestCount++;
			}
		}

		if (m_pSuites[dwSuite].dwTestCount > 0)
		{
			m_pSuites[dwSuite].aiTests = new int[m_pSuites[dwSuite].dwTestCount];
		}

		//
		// now fill up the test array with test indexes.
		//
		for (DWORD dwTest = 0, dwTestIndex = 0; dwTest < sizeof(theTests) / sizeof(theTests[0]); dwTest++)
		{
			// if this test is for the given suite.
			if (theTests[dwTest].SuiteMask & dwThisSuiteMask)
			{
				ASSERT(dwTestIndex < m_pSuites[dwSuite].dwTestCount);
				m_pSuites[dwSuite].aiTests[dwTestIndex] = dwTest;
				dwTestIndex++;
			}
		}

	}
}

CTSTestData::~CTSTestData()
{
	for (DWORD dwSuite = 0; dwSuite < eSuiteCount; dwSuite++)
	{
		if (m_pSuites[dwSuite].aiTests)
			delete [] m_pSuites[dwSuite].aiTests;
	}

	if (m_lpMachineName)
		delete [] m_lpMachineName;
}


DWORD CTSTestData::GetSuiteCount () const
{
	return eSuiteCount;
}

LPCTSTR CTSTestData::GetSuiteName	(DWORD dwSuite) const
{
	return m_pSuites[dwSuite].szSuiteName;
}



DWORD CTSTestData::GetTestCount (DWORD dwSuite) const
{
	ASSERT(m_pSuites);
	ASSERT( dwSuite < GetSuiteCount() );
	return m_pSuites[dwSuite].dwTestCount;
}

PTVerificationTest CTSTestData::GetTest (DWORD dwSuite, DWORD dwTestNumber) const
{

	ASSERT(m_pSuites);
	ASSERT( dwSuite < GetSuiteCount() );
	ASSERT( dwTestNumber < GetTestCount(dwSuite) );

	return &(theTests[m_pSuites[dwSuite].aiTests[dwTestNumber]]);
}

LPTSTR CTSTestData::m_lpMachineName = NULL;
BOOL CTSTestData::SetMachineName	(LPCTSTR lpMachineName)
{
	if (m_lpMachineName)
	{
		delete [] m_lpMachineName;
		m_lpMachineName = NULL;
	}

	

	if (lpMachineName && _tcslen(lpMachineName) > 1)
	{
		m_lpMachineName = new TCHAR[_tcslen(lpMachineName) + 1 + 2];
		if (!m_lpMachineName)
		{
			return FALSE;
		}
		_tcscpy(m_lpMachineName, _T("\\\\"));
		_tcscat(m_lpMachineName, lpMachineName);
		
	}

	return TRUE;
}

LPCTSTR CTSTestData::GetMachineNamePath  ()
{
	return m_lpMachineName;
}

LPCTSTR CTSTestData::GetMachineName  ()
{
	if (m_lpMachineName)
		return m_lpMachineName + 2;
	else
		return NULL;
}

bool CTSTestData::CanExecuteSuite (DWORD dwSuite) const
{
	ASSERT(m_pSuites);
	ASSERT( dwSuite < GetSuiteCount() );
	return (*m_pSuites[dwSuite].pfnCanRunSuite)();
}
LPCTSTR CTSTestData::GetSuiteErrorText (DWORD dwSuite) const
{
	ASSERT(m_pSuites);
	ASSERT( dwSuite < GetSuiteCount() );
	ASSERT(!CanExecuteSuite(dwSuite));
	return (*m_pSuites[dwSuite].pfnSuiteErrorReason)();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__3E6D10EE_E066_49F3_B1D1_59401B4AD3DC__INCLUDED_)
#define AFX_DLLDATAX_H__3E6D10EE_E066_49F3_B1D1_59401B4AD3DC__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__3E6D10EE_E066_49F3_B1D1_59401B4AD3DC__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( EventLogUtilities )
EXTERN_PROXY_FILE( eventutil )
EXTERN_PROXY_FILE( evntutl )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( EventLogUtilities ),
  REFERENCE_PROXY_FILE( eventutil ),
  REFERENCE_PROXY_FILE( evntutl ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\dlldatax.c ===
// wrapper for dlldata.c
#pragma warning( disable : 4206 )
#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "EventLogUtilities_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\events.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Events.cpp : Implementation of CEvents
#include "stdafx.h"
#include "Evntutl.h"
#include "Events.h"

/////////////////////////////////////////////////////////////////////////////
// CEvents

STDMETHODIMP CEvents::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IEvents
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Count
	Inputs:  empty long
	Outputs:  number events available
	Purpose:  Allows user to determine the number of Events in a Log
*/
STDMETHODIMP CEvents::get_Count(long *pVal)
{
	HRESULT hr = S_OK;

	if (!GetNumberOfEventLogRecords(m_hLog, &m_Count)) hr = HRESULT_FROM_WIN32(GetLastError());

	if (pVal) *pVal = m_Count;
	else hr = E_POINTER;

	return hr;
}

/*
	Function: get_NewEnum
	Inputs:   empty IUnknown pointer
	Outputs:  IEnumVariant object filled with Event objects
	Purpose:  Allows user to use For Each syntax to do operations on all Events in a log
	Notes:    Events are returned oldest first
*/
STDMETHODIMP CEvents::get__NewEnum(LPUNKNOWN *pVal)
{
	HRESULT hr = S_OK;

	if (NULL == pVal) return E_POINTER;
	*pVal = NULL;

	if (SUCCEEDED(hr))
	{
		EnumVar* pEVar = new EnumVar;

		hr = pEVar->Init(&m_pVector[0], &m_pVector[m_Count], NULL, AtlFlagCopy);
		if (SUCCEEDED(hr))
			hr = pEVar->QueryInterface(IID_IEnumVARIANT, (void**) pVal);

		if FAILED(hr)
			if (pEVar) delete pEVar;
	}

	return hr;
}

/*
	Function: get_Item
	Inputs:   Valid integer Index , empty Variant
	Outputs:  variant dispatch pointer to an Event object
	Purpose:  Allows user to access individual EventLogs by number
	Notes:    Events are returned oldest first
*/
STDMETHODIMP CEvents::get_Item(long Index, VARIANT *pVal)
{
	HRESULT hr = S_OK;

	// perform checks and exit if there is a problem
	if (NULL == pVal) return E_POINTER;
	if ((Index < 1) || (Index > long(m_Count))) return E_INVALIDARG;

	VariantInit(pVal);
	pVal->vt = VT_UNKNOWN;
	pVal->punkVal = NULL;
	VariantCopy(pVal, &m_pVector[Index-1]);

	return hr;
}

/*
	Function:  Init
	Inputs:  none
	Outputs:  HRESULT indicating what error if any occured
	Purpose:  Prepares a variant array filled with Log objects for 3 default logs.
*/
HRESULT CEvents::Init(HANDLE hLog, const LPCTSTR szEventLogName)
{
	HRESULT hr = S_OK;
	CComObject<CEvent>* pEvent;
	BYTE* pBuffer;
	EVENTLOGRECORD* pEventStructure;
	const unsigned long MaxEventLength = 80000;
	DWORD BytesRead = 0, BytesRequired = 0;
	unsigned long i = 0;

	if (hLog)
	{
		m_hLog = hLog;
		GetNumberOfEventLogRecords(m_hLog, &m_Count);
		if (m_pVector != NULL) delete []m_pVector;
		m_pVector = new CComVariant[m_Count];
		if (m_pVector)
		{
			pBuffer = new BYTE [MaxEventLength];
			if (pBuffer)
			{
				pEventStructure = (EVENTLOGRECORD*) pBuffer;
				// This loop fills a buffer with EventLog structures until there are no more to read
				while (ReadEventLog(m_hLog, EVENTLOG_SEQUENTIAL_READ | EVENTLOG_FORWARDS_READ, 
								 0, pEventStructure, MaxEventLength, &BytesRead, &BytesRequired))
				{
					// This inner loop should cut the buffer into individual EventLog structures
					// and fill the Variant array with the resulting Event objects.
					// It should finish when all the bytes read have been processed.
					while (BytesRead > 0)
					{
						// create a CEvent object
						hr = CComObject<CEvent>::CreateInstance(&pEvent);
						if (SUCCEEDED(hr))
						{
							hr = pEvent->Init(pEventStructure, szEventLogName);
							if (SUCCEEDED(hr))
							{
								// get IDispatch pointer and set the return pointer
								CComVariant& var = m_pVector[i];
								var.vt = VT_DISPATCH;
								hr = pEvent->QueryInterface(IID_IDispatch, (void**)&var.pdispVal);
								if (FAILED(hr)) BytesRead = 0; // dont do any more processing
								i++;
							}
							else BytesRead = 0;  // dont do any more processing
						}
						else BytesRead = 0;
						BytesRead -= pEventStructure->Length;  // decrement inner loop
						// set pEventStructure to the next EventLog structure
						pEventStructure = (EVENTLOGRECORD *)((BYTE*) pEventStructure + pEventStructure->Length);
					}
					if (FAILED(hr)) break;  // dont do any more processing
					pEventStructure = (EVENTLOGRECORD*) pBuffer;
				}
					delete [] pBuffer;
			}
			else hr = E_OUTOFMEMORY;
		}
		else hr = E_OUTOFMEMORY;
	}
	else hr = E_HANDLE;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\event.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Event.h : Declaration of the CEvent

#ifndef __EVENT_H_
#define __EVENT_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CEvent
class ATL_NO_VTABLE CEvent : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CEvent, &CLSID_Event>,
	public ISupportErrorInfo,
	public IDispatchImpl<IEvent, &IID_IEvent, &LIBID_EventLogUtilities>
{
private:
	long m_EventID; // Note:  EventID is displayed as WORD instead of DWORD in the System's EventViewer
	long m_EventCategory; // origionally a WORD (unsigned short)
	eEventType m_EventType;
	_bstr_t m_Description;
	_bstr_t m_SourceName;
	_bstr_t m_EventLogName;
	_bstr_t m_ComputerName;
	_bstr_t m_UserName;
	DATE m_OccurrenceTime;
	BYTE* m_pSid;
	SAFEARRAY* m_pDataArray;
	wchar_t** m_ppArgList;
	unsigned int m_NumberOfStrings;

	// Internal only functions
	HRESULT CheckDefaultDescription(wchar_t** Arguments);
	HRESULT ParseEventBlob(EVENTLOGRECORD* pEventStructure);
	HRESULT SetUser();
public:
	CEvent() : m_EventID(0), m_EventCategory(0), m_OccurrenceTime(0), m_pSid(NULL), m_pDataArray(NULL), m_NumberOfStrings(0), m_ppArgList(NULL)
	{
		m_Description = "";
		m_SourceName = "";
		m_ComputerName = "";
		m_UserName = "";
		m_EventLogName = "";
	}

	~CEvent()
	{
		unsigned int i;
		if (m_pSid) delete []m_pSid;
		if (m_ppArgList)
		{
			for (i=0;i<m_NumberOfStrings;i++)
					delete [] m_ppArgList[i];
				delete []m_ppArgList;
		}
//		if (m_pDataArray) SafeArrayDestroy(m_pDataArray);  // causes access violation
	}

	// Internal functions
	HRESULT Init(EVENTLOGRECORD* pEventStructure, const LPCTSTR szEventLogName);

DECLARE_REGISTRY_RESOURCEID(IDR_EVENT)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEvent)
	COM_INTERFACE_ENTRY(IEvent)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IEvent
	STDMETHOD(get_EventID)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_EventType)(/*[out, retval]*/ eEventType *pVal);
	STDMETHOD(get_Category)(/*[out, retval]*/ long *pVal);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Source)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_User)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_OccurrenceTime)(/*[out, retval]*/ DATE *pVal);
	STDMETHOD(get_ComputerName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(get_Data)(/*[out, retval]*/ VARIANT *pVal);
};

#endif //__EVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\event.cpp ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Event.cpp : Implementation of CEvent

#include "stdafx.h"
#include "Evntutl.h"
#include "Event.h"

/////////////////////////////////////////////////////////////////////////////
// CEvent

STDMETHODIMP CEvent::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IEvent
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*
	Function:  get_Server
	Inputs:  empty BSTR
	Outputs:  BSTR containing the Description for the Event (calculated)
	Purpose:  Allows user to access the description for an Event
*/
STDMETHODIMP CEvent::get_Description(BSTR *pVal)
{
	HRESULT hr = S_OK;
	unsigned int i;

	if (pVal)
	{
		if (m_Description.length() == 0)
		{
			hr = CheckDefaultDescription(m_ppArgList);
			if (SUCCEEDED(hr)) *pVal = m_Description.copy();

			if (m_ppArgList)
			{
				// delete the ArgList
				for (i=0;i<m_NumberOfStrings;i++)
					delete [] m_ppArgList[i];
				delete []m_ppArgList;
				m_ppArgList = NULL;
			}
		}
	}
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_Source
	Inputs:  empty BSTR
	Outputs:  BSTR containing the name of the component which caused the Event
	Purpose:  Allows user to access the name of the component which caused the Event
*/
STDMETHODIMP CEvent::get_Source(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_SourceName.copy();
	else hr = E_POINTER;

	return hr;
}


/*
	Function: get_User
	Inputs:   empty BSTR
	Outputs:  BSTR containing the name and domain of the user who caused the Event
	Purpose:  Allows user to access the name and domain of the user who caused the Event
	Notes:    The first time this function is called, it will do a SID lookup
*/
STDMETHODIMP CEvent::get_User(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal)
	{
		if (m_UserName.length() == 0)
		{
			SetUser();
		}
		*pVal = m_UserName.copy();
	}
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_ComputerName
	Inputs:  empty BSTR
	Outputs:  BSTR containing the name of the server on which the Event occured
	Purpose:  Allows user to access the name of the the server on which the Event occured
*/
STDMETHODIMP CEvent::get_ComputerName(BSTR *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_ComputerName.copy();
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_EventID
	Inputs:  empty long
	Outputs:  long containing the ID of the Event
	Purpose:  Allows user to access the ID which can be used to lookup a message for the event
	Notes:    Since description is provided, this function is not very useful, however,
			  it is provided for completeness
*/
STDMETHODIMP CEvent::get_EventID(long *pVal)
{
	HRESULT hr = S_OK;
//	m_EventID = m_EventID & 0xFFFF;  // The EventLog viewer uses this mask before displaying ID's
	if (pVal) *pVal = m_EventID;
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_Category
	Inputs:  empty long
	Outputs:  long containing the category ID for the event
	Purpose:  Allows user to access the category ID for the event
*/
STDMETHODIMP CEvent::get_Category(long *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_EventCategory;
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_EventType
	Inputs:  empty enumeration
	Outputs:  enumeration containing the type of event that occured
	Purpose:  Allows user to access the type of event that occured
*/
STDMETHODIMP CEvent::get_EventType(eEventType *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_EventType;
	else hr = E_POINTER;

	return hr;
}

/*
	Function:  get_OccurenceTime
	Inputs:  empty DATE structure
	Outputs:  DATE structure containing the local system time when the event occured
	Purpose:  Allows user to access the time when the event occured
*/
STDMETHODIMP CEvent::get_OccurrenceTime(DATE *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) *pVal = m_OccurrenceTime;
	else hr = E_POINTER;

	return hr;
}

/*
	Function: get_Data
	Inputs:   empty variant
	Outputs:  variant containing an array of bytes
	Purpose:  Allows user to access the data set by the event.  This may or may not be set,
			  and is frequently not useful
*/
STDMETHODIMP CEvent::get_Data(VARIANT *pVal)
{
	HRESULT hr = S_OK;

	if (pVal) 
	{
		pVal->vt = VT_ARRAY | VT_UI1;
		pVal->parray = m_pDataArray;
	}
	else hr = E_POINTER;

	return hr;
}

/*
	Function: Init
	Inputs:   pointer to an EVENTLOGRECORD structure
	Outputs:  does not modify input
	Purpose:  fill Event object properties which do not require loading external libs
*/
HRESULT CEvent::Init(EVENTLOGRECORD* pEventStructure, const LPCTSTR szEventLogName)
{
	HRESULT hr = S_OK;
	m_EventLogName = szEventLogName;
	hr = ParseEventBlob(pEventStructure);

	return hr;
}

/*
	Function: ParseEventBlob
	Inputs:   pointer to an EVENTLOGRECORD structure
	Outputs:  does not modify input
	Purpose:  Parse an EVENTLOGRECORD and set the appropriate internal structures of Event
*/
HRESULT CEvent::ParseEventBlob(EVENTLOGRECORD* pEventStructure)
{
	HRESULT hr = S_OK;
	wchar_t* wTempString;
	BYTE* pSourceName;
	BYTE* pComputerName;
	SAFEARRAYBOUND rgsabound[1];
	ULONG StringsToRetrieve = 0, CharsRead = 0, i = 0;
	long Index[1];
	BYTE pTemp;

	m_EventID = pEventStructure->EventID;
	m_EventCategory = pEventStructure->EventCategory;

	switch (pEventStructure->EventType)
	{
	case EVENTLOG_ERROR_TYPE:
		m_EventType = ErrorEvent;
		break;
	case EVENTLOG_WARNING_TYPE:
		m_EventType = WarningEvent;
		break;
	case EVENTLOG_INFORMATION_TYPE:
		m_EventType = InformationEvent;
		break;
	case EVENTLOG_AUDIT_SUCCESS:
		m_EventType = AuditSuccess;
		break;
	case EVENTLOG_AUDIT_FAILURE:
		m_EventType = AuditFailure;
		break;
	default:
		hr = E_FAIL;
	}

	// parse strings from the memory blob
	// Set source name
	pSourceName = (BYTE*) &(pEventStructure->DataOffset) + sizeof(pEventStructure->DataOffset);
	wTempString = (wchar_t*)pSourceName;
	m_SourceName = wTempString;
	// Set computer name
	pComputerName = (BYTE*)pSourceName + ((wcslen(wTempString)+1) * sizeof(wchar_t));
	wTempString = (wchar_t*)pComputerName;
	m_ComputerName = wTempString;

	// Set SID
	if ((pEventStructure->StringOffset - pEventStructure->UserSidOffset) != 0)
	{
		m_pSid = new BYTE[pEventStructure->UserSidLength];  // scope = CEvent, deleted in ~CEvent() or SetSID() whichever comes first
        if (m_pSid != NULL) {
            for (i = 0; i<pEventStructure->UserSidLength; i++)
                m_pSid[i] = (BYTE)(*((BYTE*)pEventStructure + pEventStructure->UserSidOffset + i * sizeof(BYTE)));
        }
	}

	// Set Occurence time
	// this code is copied from MSDN
	FILETIME FileTime, LocalFileTime;
    SYSTEMTIME SysTime;
    __int64 lgTemp;
    __int64 SecsTo1970 = 116444736000000000;

    lgTemp = Int32x32To64(pEventStructure->TimeGenerated,10000000) + SecsTo1970;

    FileTime.dwLowDateTime = (DWORD) lgTemp;
    FileTime.dwHighDateTime = (DWORD)(lgTemp >> 32);

    FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &SysTime);
	if(!SystemTimeToVariantTime(&SysTime, &m_OccurrenceTime)) hr = GetLastError();

	// Set Data (create and fill a SafeArray)
	if (pEventStructure->DataLength>0)
	{
		rgsabound[0].lLbound = 0;
		rgsabound[0].cElements = pEventStructure->DataLength;
		m_pDataArray = SafeArrayCreate(VT_UI1, 1, rgsabound);

		for (i=0;i<pEventStructure->DataLength;i++)
		{
			Index[0] = i;
			pTemp = (BYTE) (pEventStructure->DataOffset + i * sizeof(BYTE));
			hr = SafeArrayPutElement(m_pDataArray, Index, &pTemp);
			if (FAILED(hr)) i = pEventStructure->DataLength;
		}
	}

	// Set the description
	m_Description = "";
	if (m_SourceName.length() != 0)
	{
		// prepare the ArgList
		m_NumberOfStrings = pEventStructure->NumStrings;
		m_ppArgList = new wchar_t*[m_NumberOfStrings];  // scope = CEvent, deleted when ~CEvent or get_Description is called whichever is first
		for (i=0;i<m_NumberOfStrings;i++)
			m_ppArgList[i] = new wchar_t[(pEventStructure->DataOffset - pEventStructure->StringOffset)]; // can't be larger than the length of all the strings we got
		for (i=0;i<m_NumberOfStrings;i++)
		{
			wTempString = (wchar_t*) (((BYTE*)(pEventStructure)) + pEventStructure->StringOffset + CharsRead * sizeof(wchar_t));
			wcscpy(m_ppArgList[i], wTempString);
			CharsRead = CharsRead + wcslen(wTempString) + 1; // + 1 for the null
		}
	}
	else  // if there is no module to load a default description, just put all the string args in the description
	{
		StringsToRetrieve = pEventStructure->NumStrings;
		while (StringsToRetrieve > 0)
		{
			wTempString = (wchar_t*) (((BYTE*)(pEventStructure)) + pEventStructure->StringOffset + CharsRead * sizeof(wchar_t));
			m_Description = m_Description + " " + wTempString;
			CharsRead = CharsRead + wcslen(wTempString) + 1; // + 1 for the null
			StringsToRetrieve--;
		}
	}

	return hr;
}

/*
	Function: CheckDefaultDescription
	Inputs:   pointer pointer to a wide character
	Outputs:  does not modify input
	Purpose:  format a message from an EventID, set of input strings, and a source module
*/
HRESULT CEvent::CheckDefaultDescription(wchar_t** Arguments)
{
	HRESULT hr = S_OK;
	BYTE* wMessagePath = NULL;
	ULONG BufferSize = 40000;
	ULONG* lPathLength = NULL;
	wchar_t* wOrigionalPath = NULL;
	wchar_t* wExpandedPath = NULL;
	wchar_t* pBuffer = NULL;
	_bstr_t btRegKey;
	_bstr_t btTempString;
	HMODULE hiLib;
	HKEY hKey;

	try
	{
		lPathLength = new ULONG;
		if (lPathLength)
		{
			*lPathLength = 256*2;
			wMessagePath = new BYTE[*lPathLength];
			if (wMessagePath)
			{
				// get registry value for Source module path
				btRegKey = "SYSTEM\\CurrentControlSet\\Services\\Eventlog\\" + m_EventLogName;
				btRegKey = btRegKey + "\\";
				btRegKey = btRegKey + m_SourceName;
				hr = RegOpenKey(HKEY_LOCAL_MACHINE, btRegKey, &hKey);
				if (hKey)
				{
					hr = RegQueryValueEx(hKey, L"EventMessageFile", NULL, NULL, wMessagePath, lPathLength);
					if (hr == 0)
					{
						wOrigionalPath = (wchar_t*) wMessagePath;
						wExpandedPath = new wchar_t[(int)*lPathLength];
						if (wExpandedPath)
						{
							ExpandEnvironmentStrings(wOrigionalPath, wExpandedPath, *lPathLength);
							btTempString = wExpandedPath;

							// open the Source module
							hiLib = LoadLibraryEx(btTempString, NULL, LOAD_LIBRARY_AS_DATAFILE);
							hr = GetLastError();
							if (hiLib)
							{
								pBuffer = new wchar_t[BufferSize];
								if (pBuffer)
								{
									SetLastError(0);
									FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM | 
												  FORMAT_MESSAGE_ARGUMENT_ARRAY,
												  hiLib, m_EventID, 0, pBuffer, BufferSize,
												  reinterpret_cast<va_list*>(Arguments));
									hr = HRESULT_FROM_WIN32(GetLastError());
									m_Description = m_Description + pBuffer;

									delete []pBuffer;
									pBuffer = NULL;
								}
								else hr = E_OUTOFMEMORY;

								FreeLibrary(hiLib);
							}
							delete [] wExpandedPath;
							wExpandedPath = NULL;
						}
						else hr = E_OUTOFMEMORY;
					}
					else hr = HRESULT_FROM_WIN32(hr);

					RegCloseKey(hKey);
				}
				else hr = HRESULT_FROM_WIN32(hr);

				delete []wMessagePath;
				wMessagePath = NULL;
			}
			else hr = E_OUTOFMEMORY;

			delete lPathLength;
			lPathLength = NULL;
		}
		else hr = E_OUTOFMEMORY;

	} catch(...)
	{
		if (lPathLength != NULL) {
			delete lPathLength;
		}
		if (wMessagePath != NULL) {
			delete []wMessagePath;
		}
		if (wExpandedPath != NULL) {
			delete [] wExpandedPath;
		}
		if (pBuffer != NULL) {
			delete []pBuffer;
		}
	}

	return hr;
}

/*
	Function:  SetUser
	Inputs:  none
	Outputs:  HRESULT indicating what error if any occured
	Purpose:  finds alias and domain for a given SID
*/
HRESULT CEvent::SetUser()
{
	HRESULT hr = S_OK;
	SID_NAME_USE SidNameUse;
	wchar_t* wUserName = NULL;
	wchar_t* wDomainName = NULL;
	SID* pSid;
	unsigned long UserNameLength = 256;

	// Set user name and sid
    try 
    {
	    if (m_pSid !=NULL)
	    {
		    pSid = (SID*)m_pSid;
		    wUserName = new wchar_t[UserNameLength];
		    if (wUserName)
		    {
			    wDomainName = new wchar_t[UserNameLength];
			    if (wDomainName)
			    {
				    m_UserName = "";
				    if (LookupAccountSid(NULL, pSid, wUserName, &UserNameLength, wDomainName,
					     &UserNameLength, &SidNameUse))
					     m_UserName = m_UserName + wDomainName + L"\\" + wUserName;
				    else hr = HRESULT_FROM_WIN32(GetLastError());
				    delete []wDomainName;
			    }
			    else hr = E_OUTOFMEMORY;
			    delete []wUserName;
		    }
		    else hr = E_OUTOFMEMORY;
		    delete []m_pSid;
		    m_pSid = NULL;
	    }
    } 
    catch(...)
    {
        if (wUserName) 
        {
            delete [] wUserName;
        }

        if (wDomainName)
        {
            delete [] wDomainName;
        }
    }


	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\events.h ===
/////////////////////////////////////////////////////////////////////////////
//
// Copyright: Microsoft Corp. 1997-1999. All rights reserved
//
/////////////////////////////////////////////////////////////////////////////
// Events.h : Declaration of the CEvents

#ifndef __EVENTS_H_
#define __EVENTS_H_

#include "resource.h"       // main symbols
#include "Event.h"

/////////////////////////////////////////////////////////////////////////////
// CEvents
class ATL_NO_VTABLE CEvents : 
	public CComObjectRootEx<CComSingleThreadModel>,
//	public CComCoClass<CEvents, &CLSID_Events>,
	public ISupportErrorInfo,
	public IDispatchImpl<IEvents, &IID_IEvents, &LIBID_EventLogUtilities>
{
private:
	unsigned long m_Count;
	CComVariant* m_pVector;
	HANDLE m_hLog;

public:
	CEvents() : m_Count(0), m_pVector(NULL), m_hLog(NULL)
	{
	}

	~CEvents()
	{
		if (m_pVector) delete [] m_pVector;
	}

	// Internal functions
	HRESULT Init(HANDLE hLog, const LPCTSTR szEventLogName);  // requires a vaild Log handle to be set

DECLARE_REGISTRY_RESOURCEID(IDR_EVENTS)
DECLARE_NOT_AGGREGATABLE(CEvents)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CEvents)
	COM_INTERFACE_ENTRY(IEvents)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IEvents
	STDMETHOD(get_Item)(/*[in]*/ long Index, /*[out, retval]*/ VARIANT *pVal);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *pVal);
	STDMETHOD(get_Count)(/*[out, retval]*/ long *pVal);
};

#endif //__EVENTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\termsrv\setup\tsdiag\evntutl\evntutl.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0334 */
/* Compiler settings for evntutl.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __evntutl_h__
#define __evntutl_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IView_FWD_DEFINED__
#define __IView_FWD_DEFINED__
typedef interface IView IView;
#endif 	/* __IView_FWD_DEFINED__ */


#ifndef __ILogs_FWD_DEFINED__
#define __ILogs_FWD_DEFINED__
typedef interface ILogs ILogs;
#endif 	/* __ILogs_FWD_DEFINED__ */


#ifndef __ILog_FWD_DEFINED__
#define __ILog_FWD_DEFINED__
typedef interface ILog ILog;
#endif 	/* __ILog_FWD_DEFINED__ */


#ifndef __IEvents_FWD_DEFINED__
#define __IEvents_FWD_DEFINED__
typedef interface IEvents IEvents;
#endif 	/* __IEvents_FWD_DEFINED__ */


#ifndef __IEvent_FWD_DEFINED__
#define __IEvent_FWD_DEFINED__
typedef interface IEvent IEvent;
#endif 	/* __IEvent_FWD_DEFINED__ */


#ifndef __ILogs_FWD_DEFINED__
#define __ILogs_FWD_DEFINED__
typedef interface ILogs ILogs;
#endif 	/* __ILogs_FWD_DEFINED__ */


#ifndef __IEvents_FWD_DEFINED__
#define __IEvents_FWD_DEFINED__
typedef interface IEvents IEvents;
#endif 	/* __IEvents_FWD_DEFINED__ */


#ifndef __View_FWD_DEFINED__
#define __View_FWD_DEFINED__

#ifdef __cplusplus
typedef class View View;
#else
typedef struct View View;
#endif /* __cplusplus */

#endif 	/* __View_FWD_DEFINED__ */


#ifndef __Log_FWD_DEFINED__
#define __Log_FWD_DEFINED__

#ifdef __cplusplus
typedef class Log Log;
#else
typedef struct Log Log;
#endif /* __cplusplus */

#endif 	/* __Log_FWD_DEFINED__ */


#ifndef __Event_FWD_DEFINED__
#define __Event_FWD_DEFINED__

#ifdef __cplusplus
typedef class Event Event;
#else
typedef struct Event Event;
#endif /* __cplusplus */

#endif 	/* __Event_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_evntutl_0000 */
/* [local] */ 

typedef 
enum eEventType
    {	ErrorEvent	= 0,
	WarningEvent	= 1,
	InformationEvent	= 2,
	AuditSuccess	= 3,
	AuditFailure	= 4
    } 	eEventType;



extern RPC_IF_HANDLE __MIDL_itf_evntutl_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_evntutl_0000_v0_0_s_ifspec;

#ifndef __IView_INTERFACE_DEFINED__
#define __IView_INTERFACE_DEFINED__

/* interface IView */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IView;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CACECD29-3108-4132-9A4E-53B54FFDAFA0")
    IView : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Logs( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Server( 
            /* [in] */ BSTR newVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IViewVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IView * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IView * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IView * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            IView * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            IView * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            IView * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            IView * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Logs )( 
            IView * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Server )( 
            IView * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Server )( 
            IView * This,
            /* [in] */ BSTR newVal);
        
        END_INTERFACE
    } IViewVtbl;

    interface IView
    {
        CONST_VTBL struct IViewVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IView_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IView_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IView_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IView_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IView_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IView_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IView_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IView_get_Logs(This,pVal)	\
    (This)->lpVtbl -> get_Logs(This,pVal)

#define IView_get_Server(This,pVal)	\
    (This)->lpVtbl -> get_Server(This,pVal)

#define IView_put_Server(This,newVal)	\
    (This)->lpVtbl -> put_Server(This,newVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IView_get_Logs_Proxy( 
    IView * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB IView_get_Logs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE IView_get_Server_Proxy( 
    IView * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB IView_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE IView_put_Server_Proxy( 
    IView * This,
    /* [in] */ BSTR newVal);


void __RPC_STUB IView_put_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IView_INTERFACE_DEFINED__ */


#ifndef __ILogs_INTERFACE_DEFINED__
#define __ILogs_INTERFACE_DEFINED__

/* interface ILogs */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ILogs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("AAA9B130-C64E-400F-BC63-BA9C946082A6")
    ILogs : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ long *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ LPUNKNOWN *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT *pVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILogs * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILogs * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILogs * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILogs * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILogs * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILogs * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILogs * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Count )( 
            ILogs * This,
            /* [retval][out] */ long *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get__NewEnum )( 
            ILogs * This,
            /* [retval][out] */ LPUNKNOWN *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Item )( 
            ILogs * This,
            /* [in] */ VARIANT Index,
            /* [retval][out] */ VARIANT *pVal);
        
        END_INTERFACE
    } ILogsVtbl;

    interface ILogs
    {
        CONST_VTBL struct ILogsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILogs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILogs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILogs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILogs_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILogs_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILogs_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILogs_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILogs_get_Count(This,pVal)	\
    (This)->lpVtbl -> get_Count(This,pVal)

#define ILogs_get__NewEnum(This,pVal)	\
    (This)->lpVtbl -> get__NewEnum(This,pVal)

#define ILogs_get_Item(This,Index,pVal)	\
    (This)->lpVtbl -> get_Item(This,Index,pVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILogs_get_Count_Proxy( 
    ILogs * This,
    /* [retval][out] */ long *pVal);


void __RPC_STUB ILogs_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILogs_get__NewEnum_Proxy( 
    ILogs * This,
    /* [retval][out] */ LPUNKNOWN *pVal);


void __RPC_STUB ILogs_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILogs_get_Item_Proxy( 
    ILogs * This,
    /* [in] */ VARIANT Index,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB ILogs_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ILogs_INTERFACE_DEFINED__ */


#ifndef __ILog_INTERFACE_DEFINED__
#define __ILog_INTERFACE_DEFINED__

/* interface ILog */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ILog;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9FC21F08-F75C-4818-B42C-8A59DB3E33E7")
    ILog : public IDispatch
    {
    public:
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Events( 
            /* [retval][out] */ VARIANT *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Name( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ BSTR *pVal) = 0;
        
        virtual /* [helpstring][id][propput] */ HRESULT STDMETHODCALLTYPE put_Server( 
            /* [in] */ BSTR newVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ILogVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ILog * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ILog * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ILog * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ILog * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ILog * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ILog * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ILog * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Events )( 
            ILog * This,
            /* [retval][out] */ VARIANT *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Name )( 
            ILog * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propget] */ HRESULT ( STDMETHODCALLTYPE *get_Server )( 
            ILog * This,
            /* [retval][out] */ BSTR *pVal);
        
        /* [helpstring][id][propput] */ HRESULT ( STDMETHODCALLTYPE *put_Server )( 
            ILog * This,
            /* [in] */ BSTR newVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *Clear )( 
            ILog * This);
        
        END_INTERFACE
    } ILogVtbl;

    interface ILog
    {
        CONST_VTBL struct ILogVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ILog_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ILog_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ILog_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ILog_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ILog_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ILog_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ILog_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ILog_get_Events(This,pVal)	\
    (This)->lpVtbl -> get_Events(This,pVal)

#define ILog_get_Name(This,pVal)	\
    (This)->lpVtbl -> get_Name(This,pVal)

#define ILog_get_Server(This,pVal)	\
    (This)->lpVtbl -> get_Server(This,pVal)

#define ILog_put_Server(This,newVal)	\
    (This)->lpVtbl -> put_Server(This,newVal)

#define ILog_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILog_get_Events_Proxy( 
    ILog * This,
    /* [retval][out] */ VARIANT *pVal);


void __RPC_STUB ILog_get_Events_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id][propget] */ HRESULT STDMETHODCALLTYPE ILog_get_Name_Proxy( 
    ILog * This,
    /* [retval][out] */ BSTR *pVal);


void __RPC_STUB ILog_get_Name_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage