riteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);
            }
        }
    }

    OutputDebugStringA("\r\n");
    if (hfileDump)
        WriteFile(hfileDump, "\r\n", 2, &cbWritten, NULL);


    if (ped->IsRich())
    {
        if (ped->fUseUIFont())
            sprintf(szTempBuf, "Rich Text with UI Font");
        else
            sprintf(szTempBuf, "Rich Text Control");
    }
    else
        sprintf(szTempBuf, "Plain Text Control");

    OutputDebugStringA(szTempBuf);
    if (hfileDump)
        WriteFile(hfileDump, szTempBuf, strlen(szTempBuf), &cbWritten, NULL);

    OutputDebugStringA("\r\n");
    if (hfileDump)
        WriteFile(hfileDump, "\r\n", 2, &cbWritten, NULL);

    if (hfileDump)
        CloseHandle(hfileDump);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by richedit.rc
//
#define CUR_CROSS                       104
#define CUR_HAND                        105
#define CUR_ITALIC                      106
#define CUR_SELBAR                      107

#define IDC_DRAGDROPCOPY                109
#define IDC_DRAGDROPMOVE                110
#define IDC_DRAGDROPNONE                111

#if defined(APSTUDIO_INVOKED) || !defined(_MAC)
#define IDC_NOSCROLLH                   112
#define IDC_NOSCROLLV                   113
#define IDC_NOSCROLLVH                  114
#define IDC_SCROLLEAST                  115
#define IDC_SCROLLNE                    116
#define IDC_SCROLLNORTH                 117
#define IDC_SCROLLNW                    118
#define IDC_SCROLLSE                    119
#define IDC_SCROLLSOUTH                 120
#define IDC_SCROLLSW                    121
#define IDC_SCROLLWEST                  122
#define IDB_1DVSCROL                    125
#define IDB_2DSCROL                     126
#define IDB_1DHSCROL                    127
#endif

//Outline support
#if defined(DEBUG) || defined (_RELEASE_ASSERTS_)
#define IDC_MSG							200
#define IDD_ASSERT						201
#define ID_IGNOREALL					202
#define IDD_DEBUG						203
#define	IDC_MEMORY_STATISTICS			1000
#endif
#define BITMAP_ID_SUBTEXT               2100
#define BITMAP_ID_EXPANDED_HEADING      2101
#define BITMAP_ID_COLLAPSED_HEADING     2102
#define BITMAP_ID_EMPTY_HEADING         2103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        128
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\render.cpp ===
/*
 *	@doc INTERNAL
 *	
 *	@module - RENDER.CPP |
 *		CRenderer class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_render.h"
#include "_font.h"
#include "_disp.h"
#include "_edit.h"
#include "_select.h"
#include "_objmgr.h"
#include "_coleobj.h"


// Default colors for background and text on window's host printer
const COLORREF RGB_WHITE = RGB(255, 255, 255);
const COLORREF RGB_BLACK = RGB(0, 0, 0);
const COLORREF RGB_BLUE  = RGB(0, 0, 255);

ASSERTDATA

extern const COLORREF g_Colors[];
static HBITMAP g_hbitmapSubtext = 0;
static HBITMAP g_hbitmapExpandedHeading = 0;
static HBITMAP g_hbitmapCollapsedHeading = 0;
static HBITMAP g_hbitmapEmptyHeading = 0;

void EraseTextOut(HDC hdc, const RECT *prc)
{
	::ExtTextOutA(hdc, 0, 0, ETO_OPAQUE, prc, NULL, 0, NULL);
}


HRESULT InitializeOutlineBitmaps()
{
    g_hbitmapSubtext = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_SUBTEXT));
    g_hbitmapExpandedHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_EXPANDED_HEADING));
    g_hbitmapCollapsedHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_COLLAPSED_HEADING));
    g_hbitmapEmptyHeading = LoadBitmap(hinstRE, MAKEINTRESOURCE(BITMAP_ID_EMPTY_HEADING));

    if (!g_hbitmapSubtext ||
        !g_hbitmapExpandedHeading ||
        !g_hbitmapCollapsedHeading ||
        !g_hbitmapEmptyHeading)
    {
        return E_OUTOFMEMORY;
    }
    return NOERROR;
}

void ReleaseOutlineBitmaps()
{
    if (g_hbitmapSubtext)
	{
        DeleteObject(g_hbitmapSubtext);
		g_hbitmapSubtext = 0;
	}

    if (g_hbitmapExpandedHeading)
	{
		DeleteObject(g_hbitmapExpandedHeading);
		g_hbitmapExpandedHeading = 0;
	}

    if (g_hbitmapCollapsedHeading)
	{
		DeleteObject(g_hbitmapCollapsedHeading);		
		g_hbitmapCollapsedHeading = 0;
	}

    if (g_hbitmapEmptyHeading)
	{
		DeleteObject(g_hbitmapEmptyHeading);
		g_hbitmapEmptyHeading = 0;	
	}
}


/*
 * 	IsTooSimilar(cr1, cr2)
 *
 *	@mfunc
 *		Return TRUE if the colors cr1 and cr2 are so similar that they
 *		are hard to distinguish. Used for deciding to use reverse video
 *		selection instead of system selection colors.
 *
 *	@rdesc
 *		TRUE if cr1 is too similar to cr2 to be used for selection
 *
 *	@devnote
 *		The formula below uses RGB. It might be better to use some other
 *		color representation such as hue, saturation, and luminosity
 */
BOOL IsTooSimilar(
	COLORREF cr1,		//@parm First color for comparison
	COLORREF cr2)		//@parm Second color for comparison
{
	if((cr1 | cr2) & 0xFF000000)			// One color and/or the other
		return FALSE;						//  isn't RGB, so algorithm
											//  doesn't apply
	LONG DeltaR = abs(GetRValue(cr1) - GetRValue(cr2));
	LONG DeltaG = abs(GetGValue(cr1) - GetGValue(cr2));
	LONG DeltaB = abs(GetBValue(cr1) - GetBValue(cr2));

	return DeltaR + DeltaG + DeltaB < 80;
}


CRenderer::CRenderer (const CDisplay * const pdp) :
	CMeasurer (pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::CRenderer");

	Init();
}	
 
CRenderer::CRenderer (const CDisplay * const pdp, const CRchTxtPtr &rtp) :
	CMeasurer (pdp, rtp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::CRenderer");

	Init();
}

/*
 *	CRenderer::Init()
 *
 *	@mfunc
 *		Initialize most things to zero
 */
void CRenderer::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::Init");

	_fRenderer = TRUE;

	static const RECT zrect = { 0, 0, 0, 0 };
	_rcView		= zrect;
	_rcRender	= zrect;	  
	_rc			= zrect;
	_xWidthLine = 0;
	_dwFlags	= 0;
	_ptCur.x	= 0;
	_ptCur.y	= 0;

	_crCurBackground = CLR_INVALID;
	_crCurTextColor = CLR_INVALID;

	_hdc		= NULL;

	CTxtSelection *psel = GetPed()->GetSel();
	_fRenderSelection = psel && psel->GetShowSelection();
	
	// Get accelerator offset if any
	_cpAccelerator = GetPed()->GetCpAccelerator();
	_plogpalette   = NULL;
}
 

/*
 * 	CRenderer::StartRender (&rcView, &rcRender, yHeightBitmap)
 *
 *	@mfunc
 *		Prepare this renderer for rendering operations
 *
 *	@rdesc
 *		FALSE if nothing to render, TRUE otherwise	
 */
BOOL CRenderer::StartRender (
	const RECT &rcView,			//@parm View rectangle
	const RECT &rcRender,		//@parm Rectangle to render
	const LONG yHeightBitmap)	//@parm Height of bitmap for offscreen DC
{
	CTxtEdit *ped		   = GetPed();
	BOOL	  fInOurHost   = ped->fInOurHost();
	BOOL	  fTransparent = _pdp->IsTransparent();
						   
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::StartRender");

	// If this a metafile or a transparent control we better not be trying
	// to render off screen. Therefore, the bitmap height must be 0.
	AssertSz(!_pdp->IsMetafile() && !fTransparent || !yHeightBitmap,
		"CRenderer::StartRender: Metafile and request for off-screen DC");

	AssertSz(_hdc == NULL, "Calling StartRender() twice?");
	_hdc = _pdp->GetDC();

#ifdef Boustrophedon
	// Note: to make this a para effect, need to turn this property on/off
	// as new paras are encountered.  I.e., more work needed (plus need to
	// define PFE_BOUSTROPHEDON).
	//if(_pPF->_wEffects & PFE_BOUSTROPHEDON)
	{
		XFORM xform = {-1, 0, 0, 1, rcView.right, 0};
		SetGraphicsMode(_hdc, GM_ADVANCED);
		SetWorldTransform(_hdc, &xform);
	}
#endif

	// Set view and rendering rects
	_rcView   = rcView;
	_rcRender = rcRender;

	if(!fInOurHost || !_pdp->IsPrinter())
	{
		// If we are displaying to a window, or we are not in the window's
		// host, we use the colors specified by the host. For text and
		// foreground.
		_crBackground = ped->TxGetBackColor();
		_crTextColor  = ped->TxGetForeColor();
	}
	else
	{
		// When the window's host is printing, the default colors are white
		// for the background and black for the text.
		_crBackground = RGB_WHITE;
		_crTextColor  = RGB_BLACK;
	}

	::SetBkColor (_hdc, _crBackground);
	_crCurBackground = _crBackground;

	// If this isn't a metafile, we set a flag indicating whether we
	// can safely erase the background
	_fErase = !fTransparent;
	if(_pdp->IsMetafile() || !_pdp->IsMain())
	{
		// Since this isn't the main display or it is a metafile,
		// we want to ignore the logic to render selections
		_fRenderSelection = FALSE;

		// This is a metafile or a printer so clear the render rectangle 
		// and then pretend we are transparent.
		_fErase = FALSE;

		if(!fTransparent)					// If control is not transparent,
			EraseTextOut(_hdc, &rcRender);	//  clear display
	}

	// Set text alignment
	// Its much faster to draw using top/left alignment than to draw
	// using baseline alignment.
	SetTextAlign(_hdc, TA_TOP | TA_LEFT);
	SetBkMode(_hdc, TRANSPARENT);

	_fUseOffScreenDC = FALSE;			// Assume we won't use offscreen DC

	if(yHeightBitmap)
	{
		HPALETTE hpal = fInOurHost ? ped->TxGetPalette() : 
		(HPALETTE) GetCurrentObject(_hdc, OBJ_PAL);

		// Create off-screen DC for rendering
		if(!_osdc.Init(_hdc, _rcRender.right - _rcRender.left, yHeightBitmap, _crBackground))
			return FALSE;

		_osdc.SelectPalette(hpal);
		_fUseOffScreenDC = TRUE;		// We are using offscreen rendering
	}

	// For hack around ExtTextOutW OnWin9x EMF problems
	_fEnhancedMetafileDC = IsEnhancedMetafileDC(_hdc);

	return TRUE;
}

/*
 *	CRenderer::EndRender()
 *
 *	@mfunc
 *		If _fErase, erase any remaining areas between _rcRender and _rcView
 */
void CRenderer::EndRender()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::EndRender");
	AssertSz(_hdc, "CRenderer::EndRender() - No rendering DC");

	if(_fErase)
	{
		RECT rc = _rcRender;
		if(_ptCur.y < _rcRender.bottom)
		{
			rc.top = _ptCur.y;
			EraseTextOut(_hdc, &rc);
		}
	}
}

/*
 *	CRenderer::NewLine (&li)
 *
 *	@mfunc
 *		Init this CRenderer for rendering the specified line
 */
void CRenderer::NewLine (const CLine &li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::NewLine");

	_li = li;

	Assert(GetCp() + _li._cch <= GetTextLength());

	_xWidthLine = _li._xWidth;
	_li._xWidth = 0;
	_ptCur.x = _rcView.left - _pdp->GetXScroll();
	_fSelected = _fSelectedPrev = FALSE;
}

/*
 *	CRenderer::SetUpOffScreenDC(xAdj, yAdj)
 *
 *	@mfunc
 *		Setup renderer for using an off-screen DC
 *
 *	@rdesc
 *		NULL - an error occurred<nl>
 *		~NULL - DC to save 
 */
HDC CRenderer::SetUpOffScreenDC(
	LONG&	xAdj,		//@parm Offset to x 
	LONG&	yAdj)		//@parm Offset to y 
{
	// Save render DC
	HDC		hdcSave = _hdc;
	LONG	yHeightRC = _rc.bottom - _rc.top;

	// Replace render DC with an off-screen DC
	_hdc = _osdc.GetDC();
	if(!_hdc)
	{
		// There is no off-screen renderer 

		// This better be a line marked for a one-time off-screen rendering 
		// that wasn't. Note: standard cases for this happening are a line
		// that would have been displayed is scrolled off the screen 
		// because an update of the selection.
		AssertSz(_li._bFlags & fliOffScreenOnce, "Unexpected off screen DC failure");

		_hdc = hdcSave;
		return NULL;
	}

	AssertSz(!GetPed()->_fTransparent, "Off-screen render of tranparent control");

	_crCurTextColor = CLR_INVALID;
	if(_pccs)
	{
		// There is current a character format for the run so we need to
		// get in sync with that since the off screen DC isn't necessarily
		// set to that font.
		// Get the character format and set up the font
		SetFontAndColor(GetCF());
	}

	// We are rendering to a transparent background
	_fErase = FALSE;

	// Clear bitmap
	::SetBkColor(_hdc, _crBackground);
	_osdc.FillBitmap(_rcRender.right - _rcRender.left, yHeightRC);

	//Clear top of rcRender if necessary
	RECT rcErase = _rcRender;
	rcErase.top = _ptCur.y;
	rcErase.bottom = rcErase.top + _li._yHeight;

	//If the first line, erase to edge of rcRender
	if (rcErase.top <= _rcView.top)
		rcErase.top = min(_rcView.top, _rcRender.top);
	rcErase.bottom = _rc.top;

	if (rcErase.bottom > rcErase.top)
		EraseTextOut(hdcSave, &rcErase);

	// Restore background color if necessary
	if(_crBackground != _crCurBackground)
		::SetBkColor(_hdc, _crCurBackground);

	SetBkMode(_hdc, TRANSPARENT);

	// Store y adjustment to use in rendering off-screen bitmap
	yAdj = _rc.top;

	// Normalize _rc and _ptCur height for rendering to off-screen bitmap
	_ptCur.y   -= yAdj;
	_rc.top		= 0;
	_rc.bottom -= yAdj;

	// Store x adjustment to use in rendering off-screen bitmap
	xAdj = _rcRender.left;

	// Adjust _rcRender & _rcView so they are relative to x of 0
	_rcRender.left	-= xAdj;
	_rcRender.right -= xAdj;
	_rcView.left	-= xAdj;
	_rcView.right	-= xAdj;
	_rc.left		-= xAdj;
	_rc.right		-= xAdj;
	_ptCur.x		-= xAdj;

	return hdcSave;
}

/*
 *	CRenderer::RenderOffScreenBitmap(hdc, xAdj, yAdj)
 *
 *	@mfunc
 *		Render off screen bitmap and restore the state of the render.
 */
void CRenderer::RenderOffScreenBitmap(
	HDC		hdc,		//@parm DC to render to
	LONG	xAdj,		//@parm offset to real x base
	LONG	yAdj)		//@parm offset to real y base 
{	
	// Palettes for rendering bitmap
	HPALETTE hpalOld = NULL;
	HPALETTE hpalNew = NULL;

	// Restore x offsets
	_rc.left		+= xAdj;
	_rc.right		+= xAdj;
	_rcRender.left	+= xAdj;
	_rcRender.right += xAdj;
	_rcView.left	+= xAdj;
	_rcView.right	+= xAdj;
	_ptCur.x		+= xAdj;

	// Restore y offsets
	_ptCur.y		+= yAdj;
	_rc.top			+= yAdj;
	_rc.bottom		+= yAdj;

	// Create a palette if one is needed
	if(_plogpalette)				
		W32->ManagePalette(hdc, _plogpalette, hpalOld, hpalNew);

	// Render bitmap to real DC and restore _ptCur & _rc
	_osdc.RenderBitMap(hdc, xAdj, yAdj, _rcRender.right - _rcRender.left, _rc.bottom - _rc.top);

	// Restore palette after render if necessary
	if(_plogpalette)				
	{
		W32->ManagePalette(hdc, _plogpalette, hpalOld, hpalNew);
		CoTaskMemFree(_plogpalette);
		_plogpalette = NULL;
	}

	// Restore HDC to actual render DC
	_hdc = hdc;

	// Set this flag to what it should be for restored DC
	_fErase = TRUE;

	_crCurTextColor = CLR_INVALID;

	// Reset screen DC font 
	// Set up font on non-screen DC
	// Force color resynch
	if(!FormatIsChanged())				// Not on a new block,
		SetFontAndColor(GetCF());		//  so just set font and color
	else
	{									// On new block,
		ResetCachediFormat();			//  so reset everything
		SetNewFont();
	}
}

/*
 *	CRenderer::RenderLine (&li)
 *
 *	@mfunc
 *		Render visible part of current line
 *
 *	@rdesc
 *		TRUE if success, FALSE if failed
 *
 *	@devnote
 *		Only call this from CLine::RenderLine()
 */
BOOL CRenderer::RenderLine (
	CLine &	li)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderLine");

	BYTE	bUnderlineSave = 0;
	LONG 	cch;
	LONG 	cchChunk;
	LONG	cchInTextRun;
	LONG	cpSelMin, cpSelMost;
	BOOL	fAccelerator = FALSE;
	HDC		hdcSave = NULL;
	LONG	nSurrogates = 0;
	const WCHAR * pstrToRender;
	CTempWcharBuf twcb;
	WCHAR	chPassword = GetPasswordChar();
	LONG	xAdj = 0;
	LONG	yAdj = 0;

	UpdatePF();

	// This is used as a temporary buffer so that we can guarantee that we will
	// display an entire format run in one ExtTextOut.
	WCHAR *	pszTempBuffer = NULL;

	// Get range to display for this rendering
	GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);

	NewLine(li);						// Init render at start of line
	_ptCur.x += _li._xLeft;				// Add in line left indent 

	SetClipRect();
	if(cpSelMost != cpSelMin && cpSelMost == GetCp())
		_fSelectedPrev = TRUE;

	// We use an off screen DC if there are characters to render and the
	// measurer determined that this line needs off-screen rendering. The
	// main reason for the measurer deciding that a line needs off screen
	// rendering is if there are multiple formats in the line.
	if(_li._cch > 0 && _fUseOffScreenDC && (_li._bFlags & fliUseOffScreenDC))
	{
		// Set up an off-screen DC if we can. Note that if this fails,
		// we just use the regular DC which won't look as nice but
		// will at least display something readable.
		hdcSave = SetUpOffScreenDC(xAdj, yAdj);

		// Is this a uniform text being rendered off screen?
		if(_li._bFlags & fliOffScreenOnce)
		{
			// Yes - turn off special rendering since line has been rendered
			li._bFlags &= ~(fliOffScreenOnce | fliUseOffScreenDC);
		}
	}

	// Allow for special rendering at start of line
	LONG x = _ptCur.x;
	RenderStartLine();

	Assert(GetCp() + _li._cch <= GetTextLength());

	cch = _li._cch;

	if(chPassword && IsRich())
	{
		// It is kind of odd to allow rich text password edit controls.
		// However, it does make it that much easier to create a password
		// edit control since you don't have to know to change the box to
		// plain. Anyway, if there is such a thing, we don't want to put
		// out password characters for EOPs in general and the final EOP
		// specifically. Therefore, the following ...
		if(_pdp->IsMultiLine())
			cch -= _li._cchEOP;
		else
			cch = GetPed()->GetAdjustedTextLength();
	}

	for(; cch > 0; cch -= cchChunk)
	{
		// Initial chunk (number of character to render in a single TextOut)
		// is min between CHARFORMAT run length and line length. Start with
		// count of characters left in current format run
		cchChunk = GetCchLeftRunCF();
		AssertSz(cchChunk != 0, "empty CHARFORMAT run");

		DWORD dwEffects = GetCF()->_dwEffects;
		if(dwEffects & CFE_HIDDEN)			// Don't display hidden text
		{										
			Advance(cchChunk);
			continue;
		}

		// Limit chunk to count of characters we want to display.
		cchChunk = min(cch, cchChunk);

		// Get count of characters in text run
		pstrToRender = _rpTX.GetPch(cchInTextRun);
		AssertSz(cchInTextRun > 0, "empty text run");

		if (cchInTextRun < cchChunk || chPassword || dwEffects & CFE_ALLCAPS ||
			_li._bFlags & fliHasSurrogates)
		{
			// The amount of data in the backing store run is less than the
			// number of characters we wish to display. We will copy the
			// data out of the backing store.

			// Allocate a buffer if it is needed
			if(!pszTempBuffer)
			{
				// Allocate buffer big enough to handle all future
				// requests in this loop.
				pszTempBuffer = twcb.GetBuf(cch);
			}

			// Point at buffer
			pstrToRender = pszTempBuffer;
			if(chPassword)
			{
				// Fill buffer with password characters
				for (int i = 0; i < cchChunk; i++)
					pszTempBuffer[i] = chPassword;
			}
			else
			{	// Password not requested so copy text from backing
				// store to buffer
				_rpTX.GetText(cchChunk, pszTempBuffer);
				if(dwEffects & CFE_ALLCAPS)
					CharUpperBuff(pszTempBuffer, cchChunk);
			}
		}

		if(_cpAccelerator != -1)
		{
			LONG cpCur = GetCp();		// Get current cp

			// Does accelerator character fall in this chunk?
			if (cpCur < _cpAccelerator &&
				cpCur + cchChunk > _cpAccelerator)
			{
				// Yes. Reduce chunk to char just before accelerator
				cchChunk = _cpAccelerator - cpCur;
			}
			// Is this character the accelerator?
			else if(cpCur == _cpAccelerator)
			{							// Set chunk size to 1 since only
				cchChunk = 1;			//  want to output underlined char
				fAccelerator = TRUE;	// Tell downstream routines that
										//  we're handling accelerator
				_cpAccelerator = -1;	// Only 1 accelerator per line
			}
		}
		
		// Reduce chunk to account for selection if we are rendering for a
		// display that cares about selections.
		if(_fRenderSelection && cpSelMin != cpSelMost)
		{
			LONG cchSel = cpSelMin - GetCp();
			if(cchSel > 0)
				cchChunk = min(cchChunk, cchSel);

			else if(GetCp() < cpSelMost)
			{
				cchSel = cpSelMost - GetCp();
				if(cchSel >= cch)
					_fSelectToEOL = TRUE;
				else
					cchChunk = min(cchChunk, cchSel);

				_fSelected = TRUE;		// cpSelMin <= GetCp() < cpSelMost
			}							//  so current run is selected
		}

		// If start of CCharFormat run, select font and color
		if(FormatIsChanged() || _fSelected != _fSelectedPrev)
		{
			ResetCachediFormat();
			_fSelectedPrev = _fSelected;
			if(!SetNewFont())
				return FALSE;					// Failed
		}

		if(fAccelerator)
		{
			bUnderlineSave = _bUnderlineType;
			SetupUnderline(CFU_UNDERLINE);
		}

		// Allow for further reduction of the chunk and rendering of 
		// interleaved rich text elements
		if(RenderChunk(cchChunk, pstrToRender, cch))
		{
			AssertSz(cchChunk > 0, "CRenderer::RenderLine(): cchChunk == 0");
			_fSelected = FALSE;
			continue;
		}

		AssertSz(cchChunk > 0,"CRenderer::RenderLine() - cchChunk == 0");

#ifdef UNICODE_SURROGATES
		if(_li._bFlags & fliHasSurrogates)
		{
			WCHAR  ch;
			WCHAR *pchD = pszTempBuffer;
			WCHAR *pchS = pszTempBuffer;
			for(int i = cchChunk; i--; )
			{
				ch = *pchS++;
				if (IN_RANGE(0xD800, ch, 0xDBFF) && i &&
					IN_RANGE(0xDC00, *pchS, 0xDFFF))
				{
					// Project down into plane 0
					ch = (ch << 10) | (*pchS++ & 0x3FF);
				}
				*pchD++ = ch;
			}
			nSurrogates = pchS - pchD;
		}
#endif
		_fLastChunk = (cchChunk == cch);
		RenderText(pstrToRender, cchChunk - nSurrogates);	// Render the text
		nSurrogates = 0;

		if(fAccelerator)
		{
			_bUnderlineType = bUnderlineSave;
			fAccelerator = FALSE;			// Turn off special accelerator
		}						 			//  processing
		Advance(cchChunk);

		// Break if we went past right of render rect.
		if(_ptCur.x >= min(_rcView.right, _rcRender.right))
		{
			cch -= cchChunk;
			break;
		}
	}

	EndRenderLine(hdcSave, xAdj, yAdj, x);
	Advance(cch);
	return TRUE;						// Success
}

/*
 *	CRenderer::EndRenderLine (hdcSave, xAdj, yAdj, x)
 *
 *	@mfunc
 *		Finish up rendering of line, drawing table borders, rendering
 *		offscreen DC, and erasing to right of render rect if necessary.
 */
void CRenderer::EndRenderLine(
	HDC	 hdcSave,
	LONG xAdj,
	LONG yAdj,
	LONG x)
{
	// Display table borders (only 1 pixel wide)
	if(_pPF->InTable() && _li._bFlags & fliFirstInPara)
	{
		const LONG *prgxTabs = _pPF->GetTabs();
		COLORREF crf = _crTextColor;
		LONG	   icr = _pPF->_dwBorderColor & 0x1F;

		if (IN_RANGE(1, icr, 16))
			crf = g_Colors[icr-1];
		HPEN pen = CreatePen(PS_SOLID, 0, crf);

		LONG  h = LXtoDX(_pPF->_dxOffset);
		LONG dx = LXtoDX(_pPF->_dxStartIndent);
		x -= h;
		LONG xRight = x	+ LXtoDX(GetTabPos(prgxTabs[_pPF->_bTabCount - 1])) - dx;
		LONG yTop = _ptCur.y;
		LONG yBot = yTop + _li._yHeight;

		if(pen)
		{
			HPEN oldPen = SelectPen(_hdc, pen);
			MoveToEx(_hdc, x, yTop, NULL);
			LineTo  (_hdc, xRight, yTop);
			if(!_li._fNextInTable)
			{
				MoveToEx(_hdc, x,	   yBot - 1, NULL);
				LineTo	(_hdc, xRight, yBot - 1);
			}
			h = 0;
			for(LONG i = _pPF->_bTabCount; i >= 0; i--)
			{
				MoveToEx(_hdc, x + h, yTop, NULL);
				LineTo  (_hdc, x + h, yBot);

				if (i)
					h = LXtoDX(GetTabPos(*prgxTabs++)) - dx;
			}
			if(oldPen)			
				SelectPen(_hdc, oldPen);
			
			DeleteObject(pen);
		}
	}

	if(hdcSave)
		RenderOffScreenBitmap(hdcSave, xAdj, yAdj);

	// Handle setting background color. We need to do this for each line 
	// because we return the background color to the default after each
	// line so that opaquing will work correctly.
	if(_crBackground != _crCurBackground)
	{
		::SetBkColor(_hdc, _crBackground);	// Tell window background color
		_crCurBackground = _crBackground;
	}
}

/*
 *	CRenderer::UpdatePalette (pobj)
 *
 *	@mfunc
 *		Stores palette information so that we can render any OLE objects
 *		correctly in a bitmap.
 */
void CRenderer::UpdatePalette(
	COleObject *pobj)		//@parm OLE object wrapper.
{
#ifndef PEGASUS
	LOGPALETTE *plogpalette = NULL;
	LOGPALETTE *plogpaletteMerged;
	IViewObject *pviewobj;

	// Get IViewObject interface information so we can build a palette
	// to render the object correctly.
	if (((pobj->GetIUnknown())->QueryInterface(IID_IViewObject, 
		(void **) &pviewobj)) != NOERROR)
	{
		// Couldn't get it, so pretend this didn't happen
		return;
	}

	// Get logical palette information from object
	if(pviewobj->GetColorSet(DVASPECT_CONTENT, -1, NULL, NULL, 
			NULL, &plogpalette) != NOERROR || !plogpalette)
	{
		// Couldn't get it, so pretend this didn't happen
		goto CleanUp;
	}

	if(!_plogpalette)				
	{								// No palette entries yet
		_plogpalette = plogpalette;	// Just use the one returned
		goto CleanUp;
	}

	// We have had other palette entries. We just reallocate the table
	// and put the newest entry on the end. This is crude, we might
	// sweep the table and actually merge it. However, this code
	// should be executed relatively infrequently and therefore, crude
	// should be good enough.

	// Allocate a new table - Note the " - 1" in the end has to do with
	// the fact that LOGPALETTE is defined to have one entry already.
	AssertSz(_plogpalette->palNumEntries + plogpalette->palNumEntries >= 1,
		"CRenderer::UpdatePalette - invalid palettes to merge");
	plogpaletteMerged = (LOGPALETTE *) CoTaskMemAlloc(sizeof(LOGPALETTE) + 
		((_plogpalette->palNumEntries + plogpalette->palNumEntries - 1) * sizeof(PALETTEENTRY)));

	if(!plogpaletteMerged)				// Memory allocation failed
		goto CleanTempPalette;			// Just pretend it didn't happen

	// Copy in original table.
	memcpy(&plogpaletteMerged->palPalEntry[0], &_plogpalette->palPalEntry[0],
		_plogpalette->palNumEntries * sizeof(PALETTEENTRY));

	// Put new data at end
	memcpy(&plogpaletteMerged->palPalEntry[_plogpalette->palNumEntries], 
		&plogpalette->palPalEntry[0],
		plogpalette->palNumEntries * sizeof(PALETTEENTRY));

	// Set the version number and count
	plogpaletteMerged->palVersion = plogpalette->palVersion;
	plogpaletteMerged->palNumEntries = _plogpalette->palNumEntries 
		+ plogpalette->palNumEntries;

	// Replace current palette table with merged table
	CoTaskMemFree(_plogpalette);
	_plogpalette = plogpaletteMerged;

CleanTempPalette:
	CoTaskMemFree(plogpalette);

CleanUp:

	// Release object we got since we don't need it any more
	pviewobj->Release();
#endif
}

/*
 *	CRenderer::RenderChunk (&cchChunk, pstrToRender, cch)
 *
 *	@mfunc
 *		Method reducing the length of the chunk (number of character
 *		rendered in one RenderText) and to render items interleaved in text.
 *
 *	@rdesc	
 *		TRUE if this method actually rendered the chunk, 
 * 		FALSE if it just updated cchChunk and rendering is still needed
 */
BOOL CRenderer::RenderChunk(
	LONG&		 cchChunk,		//@parm in: chunk cch; out: # chars rendered
								//  if return TRUE; else # chars yet to render
	const WCHAR *pstrToRender,	//@parm String to render up to cchChunk chars
	LONG		 cch) 			//@parm # chars left to render on line
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderChunk");

	LONG		cchT;
	LONG		cchvalid;
	LONG		i;
	const TCHAR *pchT;
	COleObject *pobj;
	CObjectMgr *pobjmgr;
	
	// If line has objects, reduce cchChunk to go to next object only
	if(_li._bFlags & fliHasOle)
	{
		pchT = pstrToRender;
		cchvalid = cchChunk;

		// Search for object in chunk
		for( i = 0; i < cchvalid && *pchT != WCH_EMBEDDING; i++ )
			pchT++;

		if( i == 0 )
		{
			// First character is object so display object
			pobjmgr = GetPed()->GetObjectMgr();
			pobj = pobjmgr->GetObjectFromCp(GetCp());
			if(pobj)
			{
				LONG yAscent, yDescent, objwidth;
				pobj->MeasureObj(_dypInch, _dxpInch, objwidth, yAscent, yDescent, _li._yDescent);
				SetClipLeftRight(_li._xWidth + objwidth);

				if (W32->FUsePalette() && (_li._bFlags & fliUseOffScreenDC) && _pdp->IsMain())
				{
					// Keep track of palette needed for rendering bitmap
					UpdatePalette(pobj);
				}
				pobj->DrawObj(_pdp, _dypInch, _dxpInch, _hdc, _pdp->IsMetafile(), &_ptCur, &_rc, 
							  _li._yHeight - _li._yDescent, _li._yDescent);
				_ptCur.x	+= objwidth;
				_li._xWidth += objwidth;
			}
			cchChunk = 1;

			// Both tabs and object code need to advance the run pointer past
			// each character processed.
			Advance(1);
			return TRUE;
		}
		else 
		{
			// Limit chunk to character before object
			cchChunk -= cchvalid - i;
		}
	}

	// If line has tabs, reduce cchChunk
	if(_li._bFlags & fliHasTabs)
	{
		for(cchT = 0, pchT = pstrToRender;
			cchT < cchChunk && *pchT != TAB && *pchT != CELL
			&& *pchT != SOFTHYPHEN
			; pchT++, cchT++)
		{
			// this loop body intentionally left blank
		}
		if(!cchT)
		{
			// First char is a tab, render it and any that follow
			if(*pchT == SOFTHYPHEN)
			{
				if(cch == 1)				// Only render soft hyphen at EOL
				{
				TCHAR chT = '-';
				RenderText(&chT, 1);
				}
							
				Advance(1);					// Skip those within line
				cchChunk = 1;
			}
			else
				cchChunk = RenderTabs(cchChunk);
			Assert (cchChunk > 0);
			return TRUE;
		}
		cchChunk = cchT;		// Update cchChunk not to incl trailing tabs
	}

	// If line has special characters, reduce cchChunk to go to next special character
	if(_li._bFlags & fliHasSpecialChars)
	{
		pchT = pstrToRender;
		cchvalid = cchChunk;

		// Search for special character in chunk
		for( i = 0; i < cchvalid && *pchT != EURO; i++)
			pchT++;

		if(i == 0)
		{
			for(; i < cchvalid && *pchT == EURO; i++)
				pchT++;

			cchChunk = i;
		}
		else 
		{
			// Limit chunk to character before object
			cchChunk -= cchvalid - i;
		}
	}

	return FALSE;
}		

/*
 *	CRenderer::SetClipRect()
 *
 *	@mfunc
 *		Helper to set clipping rect for the line
 */
void CRenderer::SetClipRect()
{
	//Nominal clipping values
	_rc = _rcRender;
	_rc.top = _ptCur.y;
	_rc.bottom = _rc.top + _li._yHeight;

	//Clip to rcView
	_rc.left = max(_rc.left, _rcView.left);
	_rc.right = min(_rc.right, _rcView.right);

	_rc.top = max(_rc.top, _rcView.top);
	_rc.bottom = min(_rc.bottom, _rcView.bottom);
}

/*
 *	CRenderer::SetClipLeftRight (xWidth)
 *
 *	@mfunc
 *		Helper to sets left and right of clipping/erase rect.
 *	
 *	@rdesc
 *		Sets _rc left and right	
 */
void CRenderer::SetClipLeftRight(
	LONG xWidth)		//@parm	Width of chunk to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::SetClipLeftRight");

	//Nominal values
	_rc.left = _ptCur.x;
	_rc.right = _rc.left + xWidth;

	//Constrain left and right based on rcView, rcRender
	_rc.left = max(_rc.left, _rcView.left);
	_rc.left = max(_rc.left, _rcRender.left);

	_rc.right = max(_rc.right, _rc.left);
	_rc.right = min(_rc.right, _rcView.right);
	_rc.right = min(_rc.right, _rcRender.right);
}
	
/*
 *	CRenderer::GetConvertMode()
 *
 *	@mfunc
 *		Return the mode that should really be used in the RenderText call
 */
CONVERTMODE	CRenderer::GetConvertMode()
{
	CONVERTMODE cm = (CONVERTMODE)_pccs->_bConvertMode;

	// For hack around ExtTextOutW Win95 problems.
	if (cm != CVT_LOWBYTE && W32->OnWin9x() && (_pdp->IsMetafile() || _fEnhancedMetafileDC))
		return CVT_WCTMB;

	if (cm != CVT_LOWBYTE && _pdp->IsMetafile() && !_fEnhancedMetafileDC)
		return CVT_WCTMB;	// WMF cant store Unicode so we cant use ExtTextOutW

	return cm;
}		

/*
 *	CRenderer::RenderExtTextOut (x, y, fuOptions, &rc, pwchRun, cch, rgdxp)
 *
 *	@mfunc
 *		Calls ExtTextOut and handles disabled text. There is duplicate logic in OlsDrawGlyphs, but
 *		the params are different so that was simplest way.
 *
 */
void CRenderer::RenderExtTextOut(LONG x, LONG y, UINT fuOptions, RECT *prc, PCWSTR pch, UINT cch, const INT *rgdxp)
{
	CONVERTMODE cm = GetConvertMode();

	if (prc->left == prc->right)
		return;

	if(_fDisabled)
	{
		if(_crForeDisabled != _crShadowDisabled)
		{
			// The shadow should be offset by a hairline point, namely
			// 3/4 of a point.  Calculate how big this is in device units,
			// but make sure it is at least 1 pixel.
			DWORD offset = MulDiv(3, _dypInch, 4*72);
			offset = max(offset, 1);

			// Draw shadow
			SetTextColor(_crShadowDisabled);
					
			W32->REExtTextOut(cm, _pccs->_wCodePage, _hdc, x + offset, y + offset,
				fuOptions, prc, pch, cch, rgdxp, _fFEFontOnNonFEWin9x);

			// Now set drawing mode to transparent
			fuOptions &= ~ETO_OPAQUE;
		}
		SetTextColor(_crForeDisabled);
	}

	W32->REExtTextOut(cm, _pccs->_wCodePage, _hdc, x, y, fuOptions, prc, pch, cch, rgdxp, _fFEFontOnNonFEWin9x);
}

/*
 *	CRenderer::RenderText (pch, cch)
 *
 *	@mfunc
 *		Render text in the current context of this CRenderer
 *
 *
 *	@devnote
 *		Renders text only: does not do tabs or OLE objects
 */
void CRenderer::RenderText(
	const WCHAR *pch,	//@parm Text to render
	LONG cch)			//@parm Length of text to render
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderText");

	LONG		yOffsetForChar, cchT;

	// Variables used for calculating length of underline.
	LONG		xWidthSelPastEOL = 0;

	UINT		fuOptions = _pdp->IsMain() ? ETO_CLIPPED : 0;
	LONG		xWidth;
	LONG		tempwidth;
	CTempBuf	rgdx;

	//Reset clip rectangle to greater of view/render rectangle
	_rc.left = max(_rcRender.left, _rcView.left);
	_rc.right = min(_rcRender.right, _rcView.right);

	// Trim all nondisplayable linebreaking chars off end
	while(cch && IsASCIIEOP(pch[cch - 1]))
		cch--;
	
	int *pdx = (int *)rgdx.GetBuf(cch * sizeof(int));

	// Measure width of text to write so next point to write can be
	// calculated.
	xWidth = 0;

	for(cchT = 0;
		cchT < cch && xWidth < _rc.right - _ptCur.x;
		cchT++)
	{
		tempwidth = 0;
#ifdef UNICODE_SURROGATES
		Assert(!IN_RANGE(0xD800, *pch, 0xDFFF));
#endif
		if (!IN_RANGE(0x300, *pch, 0x36F) && !_pccs->Include(*pch, tempwidth))
		{
			TRACEERRSZSC("CRenderer::RenderText(): Error filling CCcs", E_FAIL);
			return;
		}

		*pdx++ = tempwidth;
  		pch++;
		xWidth += tempwidth;
	}

	// Go back to start of chunk
	cch = cchT;
	pch -= cch;
	pdx -= cch;

	if(_fLastChunk && _fSelectToEOL && _li._cchEOP)
	{
		// Use the width of the current font's space to highlight
		if(!_pccs->Include(' ', tempwidth))
		{
			TRACEERRSZSC("CRenderer::RenderText(): Error no length of space", E_FAIL);
			return;
		}
		xWidthSelPastEOL = tempwidth + _pccs->_xOverhang;
		xWidth += xWidthSelPastEOL;
		_fSelectToEOL = FALSE;			// Reset the flag
	}

	_li._xWidth += xWidth;

	// Setup for drawing selections via ExtTextOut.
 	if(_fSelected || _crBackground != _crCurBackground)
	{
		SetClipLeftRight(xWidth);
		if(_fSelected)
		{
			CTxtSelection *psel = GetPed()->GetSelNC();
			if (_pPF->InTable() && GetPrevChar() == CELL && psel &&
				psel->fHasCell() && GetCp() == psel->GetCpMin())
			{
				_rc.left -= LXtoDX(_pPF->_dxOffset);
			}
		}
		fuOptions = ETO_CLIPPED | ETO_OPAQUE;
	}

	yOffsetForChar = _ptCur.y + _li._yHeight - _li._yDescent + _pccs->_yDescent - _pccs->_yHeight;
		
	LONG yOffset, yAdjust;
	_pccs->GetOffset(GetCF(), _dypInch, &yOffset, &yAdjust);
	yOffsetForChar -= yOffset + yAdjust;

	RenderExtTextOut(_ptCur.x, yOffsetForChar, fuOptions, &_rc, pch, cch, pdx);

	// Calculate width to draw for underline/strikeout
	if(_bUnderlineType != CFU_UNDERLINENONE	|| _fStrikeOut)
	{
		LONG xWidthToDraw = xWidth - xWidthSelPastEOL;
		LONG xStart = _ptCur.x;
		LONG xEnd = xStart + xWidthToDraw;
		
		xStart = max(xStart, _rcRender.left);
		xStart = max(xStart, _rcView.left);

		xEnd = min(xEnd, _rcRender.right);
		xEnd = min(xEnd, _rcView.right);

		xWidthToDraw = xEnd - xStart;

		if(xWidthToDraw > 0)
		{
			LONG y = _ptCur.y + _li._yHeight - _li._yDescent;

			y -= yOffset + yAdjust;

			// Render underline if required
			if(_bUnderlineType != CFU_UNDERLINENONE)
				RenderUnderline(xStart,	y + _pccs->_dyULOffset, xWidthToDraw, _pccs->_dyULWidth);

			// Render strikeout if required
			if(_fStrikeOut)
				RenderStrikeOut(xStart, y + _pccs->_dySOOffset,	xWidthToDraw, _pccs->_dySOWidth);
		}
	}

	_fSelected = FALSE;

	_ptCur.x += xWidth;					// Update current point
}


/*
 *	CRenderer::RenderTabs (cchMax)
 *
 *	@mfunc
 *		Render a span of zero or more tab characters in chunk *this
 *
 *	@rdesc
 *		number of tabs rendered
 *
 *	@devnote
 *		*this is advanced by number of tabs rendered
 *		MS - tabs should be rendered using opaquing rect of adjacent string
 */
LONG CRenderer::RenderTabs(
	LONG cchMax)	//@parm Max cch to render (cch in chunk)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderTabs");

	LONG cch = cchMax;
	LONG ch = GetChar();
	LONG chPrev = 0;
	LONG xTab, xTabs;
	
	for(xTabs = 0; cch && (ch == TAB || ch == CELL); cch--)
	{
		xTab	= MeasureTab(ch);
		_li._xWidth += xTab;				// Advance internal width
		xTabs	+= xTab;					// Accumulate width of tabbed
		Advance(1);							//  region
		chPrev = ch;
		ch = GetChar();					   
	}

	if(_li._xWidth > _xWidthLine)
	{
		xTabs = 0;
		_li._xWidth = _xWidthLine;
	}

	if(xTabs)
	{
		LONG dx = 0;
		LONG xGap = 0;

		if(_fSelected && chPrev == CELL && ch != CR && _pPF->InTable())
		{
			LONG cpSelMin, cpSelMost;
			GetPed()->GetSelRangeForRender(&cpSelMin, &cpSelMost);
			if(GetCp() == cpSelMin || GetCp() == cpSelMost)
			{
				xGap = LXtoDX(_pPF->_dxOffset);
				if(GetCp() == cpSelMost)
				{
					dx = xGap;
					xGap = 0;
				}
			}
		}
		SetClipLeftRight(xTabs - dx);
		if(_rc.left < _rc.right)			// Something to erase
		{
			if(_fSelected)					// Use selection background color
			{
			    COLORREF cr = GetPed()->TxGetSysColor(COLOR_HIGHLIGHT);
				if (!UseXOR(cr))
				{
				    ::SetBkColor (_hdc, cr);
    				_crCurTextColor = GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);    				
				}
    			else
    			{ 
    			    const CCharFormat* pCF = GetCF();
    			    ::SetBkColor (_hdc, (pCF->_dwEffects & CFE_AUTOBACKCOLOR) ? 
    			                  _crBackground ^ RGB_WHITE : pCF->_crBackColor ^ RGB_WHITE);    		            		        
    				_crCurTextColor =  (pCF->_dwEffects & CFE_AUTOCOLOR) ? 
    				              _crTextColor ^ RGB_WHITE : pCF->_crTextColor ^ RGB_WHITE;    				
    			}
			}

			// Paint background with appropriate color
			if(_fSelected || _crBackground != _crCurBackground)
				EraseTextOut(_hdc, &_rc);

			// Render underline if required
			dx = _rc.right - _rc.left;
			LONG y = _ptCur.y + _li._yHeight - _li._yDescent;
			
			LONG yOffset, yAdjust;
			_pccs->GetOffset(GetCF(), _dypInch, &yOffset, &yAdjust);
			y -= yOffset + yAdjust;

			if(_bUnderlineType != CFU_UNDERLINENONE)
				RenderUnderline(_rc.left, y + _pccs->_dyULOffset, dx, _pccs->_dyULWidth);

			// Render strikeout if required
			if(_fStrikeOut)
				RenderStrikeOut(_rc.left, y +  _pccs->_dySOOffset, dx, _pccs->_dySOWidth);

			if(_fSelected)					// Restore colors
				::SetBkColor(_hdc, _crCurBackground);
		}
		_ptCur.x += xTabs;					// Update current point
	}
	return cchMax - cch;					// Return # tabs rendered
}

/*
 * 	CRenderer::SetNewFont()
 *
 *	@mfunc
 *		Select appropriate font and color in the _hdc based on the 
 *		current character format. Also sets the background color 
 *		and mode.
 *
 *	@rdesc
 *		TRUE if it succeeds
 *
 *	@devnote
 *		The calling chain must be protected by a CLock, since this present
 *		routine access the global (shared) FontCache facility.
 */
BOOL CRenderer::SetNewFont()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::SetNewFont");

	const CCharFormat	*pCF = GetCF();
	DWORD				dwEffects = pCF->_dwEffects;
		
	// Release previous font in use
	if(_pccs)
		_pccs->Release();

	Assert(_fTarget == FALSE);
	_pccs = GetCcs(pCF);

	if(!_pccs)
	{
		TRACEERRSZSC("CRenderer::SetNewFont(): no CCcs", E_FAIL);
		return FALSE;
	}

	// Select font in _hdc
	AssertSz(_pccs->_hfont, "CRenderer::SetNewFont _pccs->_hfont is NULL");

	SetFontAndColor(pCF);
	
	// Assume no underlining
	_bUnderlineType = CFU_UNDERLINENONE;

	// We want to draw revision marks and hyperlinks with underlining, so
	// just fake out our font information.
	if(dwEffects & (CFE_UNDERLINE | CFE_REVISED | CFE_LINK))
		SetupUnderline((dwEffects & CFE_LINK) ? CFU_UNDERLINE : pCF->_bUnderlineType);

	_fStrikeOut = (dwEffects & (CFE_STRIKEOUT | CFE_DELETED)) != 0;
	return TRUE;
}

/*
 * 	CRenderer::SetupUnderline (UnderlineType)
 *
 *	@mfunc
 *		Setup internal variables for underlining
 */
void CRenderer::SetupUnderline(
	LONG UnderlineType)
{
	_bUnderlineType	   = (BYTE) UnderlineType & 0xF;	// Low nibble gives type
	_bUnderlineClrIdx  = (BYTE) UnderlineType/16;		// High nibble gives color
}

/*
 * 	CRenderer::SetFontAndColor (pCF)
 *
 *	@mfunc
 *		Select appropriate font and color in the _hdc based on the 
 *		current character format. Also sets the background color 
 *		and mode.
 */
void CRenderer::SetFontAndColor(
	const CCharFormat *pCF)			//@parm Character format for colors
{
	CTxtEdit			*ped = GetPed();

	_fDisabled = FALSE;
	if((pCF->_dwEffects & (CFE_AUTOCOLOR | CFE_DISABLED))
					   == (CFE_AUTOCOLOR | CFE_DISABLED))
	{		
		_fDisabled = TRUE;
		
		_crForeDisabled   = ped->TxGetSysColor(COLOR_3DSHADOW);
		_crShadowDisabled = ped->TxGetSysColor(COLOR_3DHILIGHT);
	}

	_fFEFontOnNonFEWin9x = FALSE;
	if (IsFECharSet(pCF->_bCharSet) && W32->OnWin9x() && !W32->OnWin9xFE())
	{
		_fFEFontOnNonFEWin9x = TRUE;
	}

	SelectFont(_hdc, _pccs->_hfont);

	// Compute height and descent if not yet done
	if(_li._yHeight == -1)
	{
		SHORT	yAdjustFE = _pccs->AdjustFEHeight(!fUseUIFont() && ped->_pdp->IsMultiLine());
		// Note: this assumes plain text 
		// Should be used only for single line control
		_li._yHeight  = _pccs->_yHeight + (yAdjustFE << 1);
		_li._yDescent = _pccs->_yDescent + yAdjustFE;
	}
	SetTextColor(GetTextColor(pCF));	// Set current text color

	COLORREF  cr;

	if(_fSelected)						// Set current background color
	{
	    cr = GetPed()->TxGetSysColor(COLOR_HIGHLIGHT);
	    if (UseXOR(cr))
		{
		    // There are 2 cases to be concerned with
		    // 1) if the background color is the same as the selection color or
		    // 2) if 1.0 Window and the background color is NOT system default
		    cr = (pCF->_dwEffects & CFE_AUTOBACKCOLOR) ?
		          _crBackground ^ RGB_WHITE : pCF->_crBackColor ^ RGB_WHITE;	    
		}
	}
	else if(pCF->_dwEffects & CFE_AUTOBACKCOLOR)
		cr = _crBackground;
	else //Text has some kind of back color
		cr = pCF->_crBackColor;

	if(cr != _crCurBackground)
	{
		::SetBkColor(_hdc, cr);			// Tell window background color
		_crCurBackground = cr;			// Remember current background color
		_fBackgroundColor = _crBackground != cr; // Change render settings so we won't
	}									//  fill with background color
}

/*
 * 	CRenderer::SetTextColor (cr)
 *
 *	@mfunc
 *		Select given text color in the _hdc
 *		Used to maintain _crCurTextColor cache
 */
void CRenderer::SetTextColor(
	COLORREF cr)			//@parm color to set in the dc
{
	if(cr != _crCurTextColor)
	{
		_crCurTextColor = cr;
		::SetTextColor(_hdc, cr);
	}
}

/*
 *	CRenderer::GetTextColor(pCF)
 *
 *	@mfunc
 *		Return text color for pCF. Depends on _bRevAuthor, display tech
 *
 *  FUTURE (keithcu) It might be nice to have black or blue selected text be
 *  white, but to have all other colors stay their other colors. What do we
 *	do if the backcolor is blue??
 *
 *	@rdesc	
 *		text color
 */
COLORREF CRenderer::GetTextColor(
	const CCharFormat *pCF)	//@parm CCharFormat specifying text color
{
	if(_fSelected)
	{
	    // There are 2 cases where XOR for selection is needed
	    // 1) if the background is the same as the selection background
	    // 2) if 1.0 window and the background isn't the system default window
	    // background color

	    // if this doesn't match the above case just return the cr
	    if (!UseXOR(GetPed()->TxGetSysColor(COLOR_HIGHLIGHT)))
	        return GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);

	    // xor the current text color for the selected text color
		return (pCF->_dwEffects & CFE_AUTOCOLOR) ? _crTextColor ^ RGB_WHITE :
		    pCF->_crTextColor ^ RGB_WHITE;
    }

	// The following could be generalized to return a different color for
	// links that have been visited for this text instance (need to define
	// extra CCharFormat::_dwEffects internal flag to ID these links)
	if(pCF->_dwEffects & CFE_LINK)
	{
		// Blue doesnt show up very well against dark backgrounds.
		// In these situations, use the system selected text color.
		COLORREF crBackground = (pCF->_dwEffects & CFE_AUTOBACKCOLOR)
							  ? _crBackground :	pCF->_crBackColor;

		if (IsTooSimilar(crBackground, RGB_BLACK) || IsTooSimilar(crBackground, RGB_BLUE))
		{
			COLORREF crHighlightText = GetPed()->TxGetSysColor(COLOR_HIGHLIGHTTEXT);
			if (IsTooSimilar(crBackground, crHighlightText))
			{
				// Background is similar to highlight, use window text color
				return GetPed()->TxGetSysColor(COLOR_WINDOWTEXT);
			}
			else
			{
				return crHighlightText;
			}
		}
		else
		{
			return RGB_BLUE;
		}
	}

	if(pCF->_bRevAuthor)				// Rev author
	{
		// Limit color of rev authors to 0 through 7.
		return rgcrRevisions[(pCF->_bRevAuthor - 1) & REVMASK];
	}

	COLORREF cr = (pCF->_dwEffects & CFE_AUTOCOLOR)	? _crTextColor : pCF->_crTextColor;

	if(cr == RGB_WHITE)					// Text is white
	{
		COLORREF crBackground = (pCF->_dwEffects & CFE_AUTOBACKCOLOR)
							  ? _crBackground :	pCF->_crBackColor;
		if(crBackground != RGB_WHITE)
		{
			// Background color isn't white, so white text is probably
			// visible unless display device is only black/white. So we
			// switch to black text on such devices.
			if (GetDeviceCaps(_hdc, NUMCOLORS) == 2 ||
				GetDeviceCaps(_hdc, TECHNOLOGY) == DT_PLOTTER)
			{
				cr = RGB_BLACK;
			}
		}
	}
	return cr;
}

/*
 *	CRenderer::RenderStartLine()
 *
 *	@mfunc
 *		Render possible outline symbol and bullet if at start of line
 *
 *	@rdesc	
 *		TRUE if this method succeeded
 */
BOOL CRenderer::RenderStartLine()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderStartLine");
	BOOL fDrawBack = !(GetCF()->_dwEffects & CFE_AUTOBACKCOLOR) && GetPed()->_fExtendBackColor;
	RECT rcErase = _rcRender;

	rcErase.top = _ptCur.y;
	rcErase.bottom = min(rcErase.top + _li._yHeight, _rcRender.bottom);

	//If the first line, erase to edge of rcRender
	if (rcErase.top <= _rcView.top)
		rcErase.top = min(_rcView.top, _rcRender.top);

	if (_fErase && !fDrawBack)
		EraseTextOut(GetDC(), &rcErase);

	// Fill line with background color if we are in fExtendBackColor mode
	if (fDrawBack)
	{
		// capture the old color so we reset it to what it was when we're finished
		COLORREF crOld = ::SetBkColor(GetDC(), GetCF()->_crBackColor);
		EraseTextOut(GetDC(), &_rc);

		// reset background color to the old color
		::SetBkColor(GetDC(), crOld);

		//Erase the remainder of the background area
		if (_fErase)
		{
			RECT rcTemp = rcErase;
			//Erase the top part if necessary
			if (rcErase.top < _rc.top)
			{
				rcTemp.bottom = _rc.top;
				EraseTextOut(GetDC(), &rcTemp);
			}

			//Erase the left and right parts if necessary
			rcTemp.top = _rc.top;
			rcTemp.bottom = _rc.bottom;
			if (rcErase.left < _rc.left)
			{
				rcTemp.right = _rc.left;
				EraseTextOut(GetDC(), &rcTemp);
			}
			if (rcErase.right > _rc.right)
			{
				rcTemp.left = _rc.right;
				rcTemp.right = rcErase.right;
				EraseTextOut(GetDC(), &rcTemp);
			}
		}
	}

	if(IsRich() && (_li._bFlags & fliFirstInPara))
	{
		if(IsInOutlineView())
			RenderOutlineSymbol();

		if(_pPF->_wNumbering && !fUseLineServices())
			RenderBullet();	
	}

	// Reset format if there is special background color for previous line.
	// Otherwise, current line with the same format will not re-paint with the
	// special background color
	if (_fBackgroundColor)
	{
		_iFormat = -10;					// Reset to invalid format

		// Assume that there is no special background color for the line
		_fBackgroundColor = FALSE;
	}

	// Handle setting background color. If the current background
	// color is different than the default, we need to set the background
	// to this because the end of line processing reset the color so
	// that opaquing would work.
	if(_crBackground != _crCurBackground)
	{
		// Tell the window the background color
		::SetBkColor(_hdc, _crCurBackground);
		_fBackgroundColor = TRUE;
	}

	return TRUE;
}

/*
 *	CRenderer::RenderOutlineSymbol()
 *
 *	@mfunc
 *		Render outline symbol for current paragraph
 *
 *	@rdesc
 *		TRUE if outline symbol rendered
 */
BOOL CRenderer::RenderOutlineSymbol()
{
	AssertSz(IsInOutlineView(), 
		"CRenderer::RenderOutlineSymbol called when not in outline view");

	HBITMAP	hbitmap;
	LONG	height;
	LONG	width;
	LONG	x = _ptCur.x - _li._xLeft + LXtoDX(lDefaultTab/2 * _pPF->_bOutlineLevel);
	LONG	y = _ptCur.y;

	if(!g_hbitmapSubtext && InitializeOutlineBitmaps() != NOERROR)
		return FALSE;

    HDC hMemDC = CreateCompatibleDC(_hdc); // REVIEW: performance

    if(!hMemDC)
        return FALSE; //REVIEW: out of memory

	if(_pPF->_bOutlineLevel & 1)			// Subtext
	{
		width	= BITMAP_WIDTH_SUBTEXT;
		height	= BITMAP_HEIGHT_SUBTEXT;
		hbitmap	= g_hbitmapSubtext;
	}
	else									// Heading
	{
		width	= BITMAP_WIDTH_HEADING;
		height	= BITMAP_HEIGHT_HEADING;
		hbitmap	= g_hbitmapEmptyHeading;

		CPFRunPtr rp(*this);				// Check next PF for other
		LONG	  cch = _li._cch;		 	//  outline symbols

		if(_li._cch < rp.GetCchLeft())		// Set cch = count to heading
		{									//  EOP
			CTxtPtr tp(_rpTX);
			cch = tp.FindEOP(tomForward);
		}
		rp.AdvanceCp(cch);					// Go to next paragraph
		if(rp.IsCollapsed())
			hbitmap	= g_hbitmapCollapsedHeading;

		else if(_pPF->_bOutlineLevel < rp.GetOutlineLevel())
			hbitmap	= g_hbitmapExpandedHeading;
	}

	if(!hbitmap)
		return FALSE;

    HBITMAP hbitmapDefault = (HBITMAP)SelectObject(hMemDC, hbitmap);

    // REVIEW: what if the background color changes?  Also, use a TT font
	// for symbols
	LONG h = _pdp->Zoom(height);
	LONG dy = _li._yHeight - _li._yDescent - h;

	if(dy > 0)
		dy /= 2;
	else
		dy = -dy;

    StretchBlt(_hdc, x, y + dy, _pdp->Zoom(width), h, hMemDC, 0, 0, width, height, SRCCOPY);

    SelectObject(hMemDC, hbitmapDefault);
    DeleteDC(hMemDC);
	return TRUE;
}

/*
 *	CRenderer::RenderBullet()
 *
 *	@mfunc
 *		Render bullet at start of line
 *
 *	@rdesc	
 *		TRUE if this method succeeded
 */
BOOL CRenderer::RenderBullet()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CRenderer::RenderBullet");

	AssertSz(_pPF->_wNumbering, 
		"CRenderer::RenderBullet called for non-bullet");

	// Width of the bullet character
	LONG xWidth;

	// FUTURE: Unicode bullet is L'\x2022' We want to migrate to this and
	// other bullets
	LONG		cch;
	CCharFormat CF;
	WCHAR		szBullet[CCHMAXNUMTOSTR];

	CCcs *pccs = GetCcsBullet(&CF);

	if(!pccs)								// Bullet is suppressed because
		return TRUE;						//  preceding EOP is VT

	if(_pccs)
		_pccs->Release();

	_pccs = pccs;

	// Default to no underline
	_bUnderlineType = CFU_UNDERLINENONE;

	if(_pPF->IsListNumbered() && CF._dwEffects & CFE_UNDERLINE)
		_bUnderlineType = (BYTE) CF._bUnderlineType & 0xF;

	SetFontAndColor(&CF);

	BYTE bFlagSave		= _li._bFlags;
	LONG dxOffset		= LXtoDX(max(_pPF->_dxOffset, _pPF->_wNumberingTab));
	LONG xSave			= _ptCur.x;
	LONG xWidthLineSave = _xWidthLine;

	_li._bFlags = 0;

	// Set-up to render bullet in one chunk
	cch = GetBullet(szBullet, _pccs, &xWidth);
	dxOffset = max(dxOffset, xWidth);
	_xWidthLine = dxOffset;
	if(IsInOutlineView())
		dxOffset = _li._xLeft - LXtoDX(lDefaultTab/2 * (_pPF->_bOutlineLevel + 1));
	_ptCur.x -= dxOffset;

	// Render bullet
	_fLastChunk = TRUE;
	RenderText(szBullet, cch);

	// Restore render vars to continue with remainder of line.
	_ptCur.x = xSave;
	_xWidthLine = xWidthLineSave;
	_li._bFlags = bFlagSave;
	_li._xWidth = 0;

	// This releases the _pccs that we put in for the bullet
	SetNewFont();
	return TRUE;
}

/*
 *	CRenderer::RenderUnderline(xStart, yStart, xLength, yThickness)
 *
 *	@mfunc
 *		Render underline
 */
void CRenderer::RenderUnderline(
	LONG xStart, 		//@parm Horizontal start of underline
	LONG yStart,		//@parm Vertical start of underline
	LONG xLength,		//@parm Length of underline
	LONG yThickness)	//@parm Thickness of underline
{
	BOOL	 fUseLS = fUseLineServices();
	COLORREF crUnderline;
	RECT	 rcT;
	
	if (!_bUnderlineClrIdx ||
		GetPed()->GetEffectColor(_bUnderlineClrIdx, &crUnderline) != NOERROR ||
		crUnderline == tomAutoColor || crUnderline == tomUndefined)
	{
		crUnderline = _crCurTextColor;
	}

	if (_bUnderlineType != CFU_INVERT &&
		!IN_RANGE(CFU_UNDERLINEDOTTED, _bUnderlineType, CFU_UNDERLINEWAVE))
	{
		// Regular single underline case
		// Calculate where to put underline
		rcT.top = yStart;

		if (CFU_UNDERLINETHICK == _bUnderlineType)
		{
			rcT.top -= yThickness;
			yThickness += yThickness;	
		}

		// There are some cases were the following can occur - particularly
		// with bullets on Japanese systems.
		if(!fUseLS && rcT.top >= _ptCur.y + _li._yHeight)
			rcT.top = _ptCur.y + _li._yHeight -	yThickness;

		rcT.bottom	= rcT.top + yThickness;
		rcT.left	= xStart;
		rcT.right	= xStart + xLength;
		FillRectWithColor(&rcT, crUnderline);
		return;
	}

	if(_bUnderlineType == CFU_INVERT)			// Fake selection.
	{											// NOTE, not really
		rcT.top	= _ptCur.y;						// how we should invert text!!
		rcT.left = xStart;						// check out IME invert.
		rcT.bottom = rcT.top + _li._yHeight - _li._yDescent + _pccs->_yDescent;
		rcT.right = rcT.left + xLength;
  		InvertRect(_hdc, &rcT);
		return;
	}

	if(IN_RANGE(CFU_UNDERLINEDOTTED, _bUnderlineType, CFU_UNDERLINEWAVE))
	{
		static const char pen[] = {PS_DOT, PS_DASH, PS_DASHDOT, PS_DASHDOTDOT, PS_SOLID};

		HPEN hPen = CreatePen(pen[_bUnderlineType - CFU_UNDERLINEDOTTED],
							  1, crUnderline);	
		if(hPen)
		{
			HPEN hPenOld = SelectPen(_hdc, hPen);
			LONG right = xStart + xLength;

			MoveToEx(_hdc, xStart, yStart, NULL);
			if(_bUnderlineType == CFU_UNDERLINEWAVE)
			{
				LONG dy	= 1;					// Vertical displacement
				LONG x	= xStart + 1;			// x coordinate
				right++;						// Round up rightmost x
				for( ; x < right; dy = -dy, x += 2)
					LineTo(_hdc, x, yStart + dy);
			}
			else
				LineTo(_hdc, right, yStart);

			if(hPenOld)							// Restore original pen.
				SelectPen(_hdc, hPenOld);

			DeleteObject(hPen);
		}
	}
}

/*
 *	CRenderer::RenderStrikeOut(xStart, yStart, xWidth, yThickness)
 *
 *	@mfunc
 *		Render strikeout
 */
void CRenderer::RenderStrikeOut(
	LONG xStart, 		//@parm Horizontal start of strikeout
	LONG yStart,		//@parm Vertical start of strikeout
	LONG xLength,		//@parm Length of strikeout
	LONG yThickness)	//@parm Thickness of strikeout
{
	RECT rcT;

	// Calculate where to put strikeout rectangle 
	rcT.top		= yStart;
	rcT.bottom	= yStart + yThickness;
	rcT.left	= xStart;
	rcT.right	= xStart + xLength;
	FillRectWithColor(&rcT, GetTextColor(GetCF()));
}

/*
 *	CRenderer::FillRectWithTextColor(prc)
 *
 *	@mfunc
 *		Fill input rectangle with current color of text
 */
void CRenderer::FillRectWithColor(
	RECT *	 prc,		//@parm Rectangle to fill with color
	COLORREF cr)		//@parm Color to use
{
	// Create a brush with the text color
	HBRUSH hbrush = CreateSolidBrush(_fDisabled ? _crForeDisabled : cr);

	// Note if the CreateSolidBrush fails we just ignore it since there
	// isn't anything we can do about it anyway.
	if(hbrush)
	{
		// Save old brush
		HBRUSH hbrushOld = (HBRUSH)SelectObject(_hdc, hbrush);

		// Fill rectangle for underline
		PatBlt(_hdc, prc->left, prc->top, prc->right - prc->left,
			   prc->bottom - prc->top, PATCOPY);
		SelectObject(_hdc, hbrushOld);	// Put old brush back
		DeleteObject(hbrush);			// Free brush we created.
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\reinit.cpp ===
/*
 *
 *	REINIT.C
 *	
 *	Purpose:
 *		RICHEDIT initialization routines
 *	
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_font.h"
#include "_format.h"
#include "_disp.h"
#include "_clasfyc.h"
#include "zmouse.h"
#include "_rtfconv.h"
#include "_ols.h"
#include "_host.h"

// The IA64 linker does not currently handle DELAYLOAD
#include <delayimp.h>

ASSERTDATA

class CTxtEdit;
class CCmbBxWinHost;

extern void ReleaseTypeInfoPtrs();

static char szClassREA[sizeof(RICHEDIT_CLASSA)];
static WCHAR wszClassREW[sizeof(RICHEDIT_CLASSW)/sizeof(WCHAR)];

static WCHAR wszClassLBW[] = LISTBOX_CLASSW;
static WCHAR wszClassCBW[] = COMBOBOX_CLASSW;
#define REGISTERED_LISTBOX	1
#define REGISTERED_COMBOBOX 2

// a critical section for multi-threading support.
CRITICAL_SECTION g_CriticalSection;

HINSTANCE hinstRE = 0;

static BOOL RichFRegisterClass(VOID);

#ifdef DEBUG
BOOL fInDllMain = FALSE;  // used to ensure that GDI calls are not made during
						  // DLL_PROCESS_ATTACH
#endif

void FreeFontCache();					// Defined in font.cpp
void ReleaseOutlineBitmaps();			// Defined in render.cpp

#ifdef DEBUG
	void CatchLeaks(void);
#endif

static inline
void WINAPI
OverlayIAT(PImgThunkData pitdDst, PCImgThunkData pitdSrc) {
    memcpy(pitdDst, pitdSrc, CountOfImports(pitdDst) * sizeof IMAGE_THUNK_DATA);
    }

void OurUnloadDelayLoadedDlls(void)
{
    PUnloadInfo pui = __puiHead;

	for (;pui;)
	{
#if DELAYLOAD_VERSION >= 0x200
        if (pui->pidd->rvaUnloadIAT)
        {
            PCImgDelayDescr pidd = pui->pidd;
            HMODULE         hmod = *(HMODULE *)((PCHAR)&__ImageBase + pidd->rvaHmod);
            OverlayIAT((PImgThunkData)  ((PCHAR)&__ImageBase + pidd->rvaIAT),
                       (PCImgThunkData) ((PCHAR)&__ImageBase + pidd->rvaUnloadIAT));
            ::FreeLibrary(hmod);
			*(HMODULE *)((PCHAR)&__ImageBase+pidd->rvaHmod) = NULL;

			PUnloadInfo puiT = pui->puiNext;
			::LocalFree(pui);
			pui = puiT;
        }
#else
		if (pui->pidd->pUnloadIAT)
		{
			PCImgDelayDescr pidd = pui->pidd;
			HMODULE         hmod = *pidd->phmod;

			OverlayIAT(pidd->pIAT, pidd->pUnloadIAT);
			::FreeLibrary(hmod);
			*pidd->phmod = NULL;

			PUnloadInfo puiT = pui->puiNext;
			::LocalFree(pui);
			pui = puiT;
		}
#endif
	}
}

extern "C"
{

#ifdef PEGASUS
BOOL WINAPI DllMain(HANDLE hmod, DWORD dwReason, LPVOID lpvReserved)
#else
BOOL WINAPI DllMain(HMODULE hmod, DWORD dwReason, LPVOID lpvReserved)
#endif
{
	DebugMain (hmod, dwReason, lpvReserved);

	if(dwReason == DLL_PROCESS_DETACH)		// We are unloading
	{
		DeleteDanglingHosts();
		CRTFConverter::FreeFontSubInfo();
		FreeFontCache();
		DestroyFormatCaches();
		ReleaseTypeInfoPtrs();
		UninitKinsokuClassify();
		
		// Release various resouces allocated during running...
		delete g_pols;
		delete g_pusp;
		g_pusp = NULL;

		ReleaseOutlineBitmaps();

		if(hinstRE)
		{
			#ifndef PEGASUS
				UnregisterClassA(szClassREA, hinstRE);
				#ifdef RICHED32_BUILD
					UnregisterClassA(szClassRE10A, hinstRE);
				#endif
			#endif
			W32->UnregisterClass(wszClassREW, hinstRE);
			if (W32->_fRegisteredXBox)
			{
				// There may be cases where these window classes
				// are still in memory in which case UnregisterClass
				// will fail.  So keep track of that
				if (W32->UnregisterClass(wszClassLBW, hinstRE))
					W32->_fRegisteredXBox &= ~REGISTERED_LISTBOX;
				if (W32->UnregisterClass(wszClassCBW, hinstRE))
					W32->_fRegisteredXBox &= ~REGISTERED_COMBOBOX;
			}
		}
		delete W32;

#ifdef DEBUG
		CatchLeaks();
#endif
#ifndef _WIN64
		OurUnloadDelayLoadedDlls();
#endif
		DeleteCriticalSection(&g_CriticalSection);
	}
	else if(dwReason == DLL_PROCESS_ATTACH) // We have just loaded
	{
		#ifdef DEBUG
			fInDllMain = TRUE;
		#endif
		InitializeCriticalSection(&g_CriticalSection);
#ifndef DEBUG
		DisableThreadLibraryCalls(hmod);
#endif
		#ifdef PEGASUS
			hinstRE = (HINSTANCE) hmod;
		#else
			hinstRE = hmod;
		#endif

		W32 = new CW32System;

		WCHAR wszFileName[_MAX_PATH];
		CopyMemory(szClassREA, RICHEDIT_CLASSA, sizeof(CERICHEDIT_CLASSA));
		CopyMemory(wszClassREW, RICHEDIT_CLASSW, sizeof(CERICHEDIT_CLASSW));
		int iLen = W32->GetModuleFileName((HMODULE) hmod, wszFileName, _MAX_PATH);
		if (iLen)
		{
			iLen -= sizeof("riched20.dll") - 1;
			if (!lstrcmpi(&wszFileName[iLen] , TEXT("richedce.dll")))
			{
				// This code allows the dll to be renamed for Win CE.
				Assert(sizeof(RICHEDIT_CLASSA) == sizeof(CERICHEDIT_CLASSA));
				Assert(sizeof(RICHEDIT_CLASSW) == sizeof(CERICHEDIT_CLASSW));
				CopyMemory(szClassREA, CERICHEDIT_CLASSA, sizeof(CERICHEDIT_CLASSA));
				CopyMemory(wszClassREW, CERICHEDIT_CLASSW, sizeof(CERICHEDIT_CLASSW));
			}
		}

		if(!RichFRegisterClass())
		{
			return FALSE;
		}
		
		#ifdef DEBUG
			fInDllMain = FALSE;
		#endif
	}

	return TRUE;
}

} 	// extern "C"

/*
 *	RichFRegisterClass
 *
 *	Purpose:	
 *		registers the window classes used by richedit
 *
 *	Algorithm:
 *		register two window classes, a Unicode one and an ANSI
 *		one.  This enables clients to optimize their use of
 *		the edit control w.r.t to ANSI/Unicode data
 */

static BOOL RichFRegisterClass(VOID)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichFRegisterClass");
	WNDCLASS wc;

	wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC;
	wc.lpfnWndProc = RichEditWndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = sizeof(CTxtEdit FAR *);
	wc.hInstance = hinstRE;
	wc.hIcon = 0;
	wc.hCursor = 0;
	wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = wszClassREW;

	if( W32->RegisterREClass(&wc, szClassREA, RichEditANSIWndProc) == NULL )
	{
		return FALSE;
	};

	return TRUE;
}

/*
 *	RichFRegisterClass
 *
 *	Purpose:	
 *		registers the window classes used by REListbox
 *
 *	Algorithm:
 *		register two window classes, a Unicode one and an ANSI
 *		one.  This enables clients to optimize their use of
 *		the edit control w.r.t to ANSI/Unicode data
 */
extern LRESULT CALLBACK RichListBoxWndProc(HWND, UINT, WPARAM, LPARAM);
extern LRESULT CALLBACK RichComboBoxWndProc(HWND, UINT, WPARAM, LPARAM);
__declspec(dllexport) BOOL WINAPI REExtendedRegisterClass(VOID)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "REExtendedRegisterClass");
		
	WNDCLASS wc;

	if (!(W32->_fRegisteredXBox & REGISTERED_LISTBOX))
	{
		// Globally register the listbox
		wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC;
		wc.lpfnWndProc = RichListBoxWndProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = sizeof(CTxtEdit FAR *);
		wc.hInstance = hinstRE;
		wc.hIcon = 0;
		wc.hCursor = 0;
		wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = wszClassLBW;

		if(W32->RegisterREClass(&wc, NULL, NULL))
			W32->_fRegisteredXBox |= REGISTERED_LISTBOX;
	}

	if (!(W32->_fRegisteredXBox & REGISTERED_COMBOBOX))
	{
		// globally register the combobox
		wc.style = CS_DBLCLKS | CS_GLOBALCLASS | CS_PARENTDC | CS_VREDRAW | CS_HREDRAW;
		wc.lpfnWndProc = RichComboBoxWndProc;
		wc.cbClsExtra = 0;
		wc.cbWndExtra = sizeof(CCmbBxWinHost FAR *);
		wc.hInstance = hinstRE;
		wc.hIcon = 0;
		wc.hCursor = 0;
		wc.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
		wc.lpszMenuName = NULL;
		wc.lpszClassName = wszClassCBW;

		if(W32->RegisterREClass(&wc, NULL, NULL))
			W32->_fRegisteredXBox |= REGISTERED_COMBOBOX;
	}

	//Set flag so we unregister the window class
	return W32->_fRegisteredXBox;
}

BOOL g_fNoLS = FALSE;
BOOL g_fNoUniscribe = FALSE;
//This is a stub function which we call when we can't find LineServices.
//The stub function needs to be the the first function we call in LS.
LSERR WINAPI LsGetReverseLsimethodsStub(LSIMETHODS *plsim)
{
	return lserrOutOfMemory;
}

//Ugly, but good enough
BOOL FIsUniscribeDll (const char *szDll)
{
	return (*szDll == 'u' || *szDll == 'U');
}

HRESULT WINAPI ScriptGetPropertiesStub(const SCRIPT_PROPERTIES ***ppSp,int *piNumScripts)
{
	return E_FAIL;
}

const SCRIPT_LOGATTR* WINAPI ScriptString_pLogAttrStub(SCRIPT_STRING_ANALYSIS ssa)
{
	// USP build 0175 (shipped with IE5 and Office2K) doesnt support this API.
	return NULL;
}

// Get Uniscibe's fake entry points

FARPROC WINAPI GetUniscribeStubs(LPCSTR szProcName)
{
	if (!lstrcmpiA(szProcName, "ScriptGetProperties"))
		return (FARPROC)ScriptGetPropertiesStub;

	if (!lstrcmpiA(szProcName, "ScriptString_pLogAttr"))
		return (FARPROC)ScriptString_pLogAttrStub;

#ifdef DEBUG
	char szAssert[128];

	wsprintfA(szAssert, "Uniscribe API =%s= is missing. Fix it NOW!", szProcName);

	AssertSz(FALSE, szAssert);
#endif

	return (FARPROC)ScriptGetPropertiesStub;	// we're dying...
}

#ifndef _WIN64
FARPROC WINAPI DliHook(unsigned dliNotify, PDelayLoadInfo pdli)
{
	FARPROC fp = 0;

	switch (dliNotify)
	{
	case dliFailLoadLib:
		{
			if (FIsUniscribeDll(pdli->szDll))
				g_fNoUniscribe = TRUE;
			else
				g_fNoLS = TRUE;

			fp = (FARPROC)(HMODULE)hinstRE;
			char szBuf[255];

			FormatMessageA(FORMAT_MESSAGE_ARGUMENT_ARRAY | FORMAT_MESSAGE_FROM_SYSTEM, NULL,
						  ERROR_MOD_NOT_FOUND,
						  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
						  (char*)szBuf, sizeof(szBuf), NULL);

			CopyMemory(szBuf + lstrlenA(szBuf), " (", 3);
			CopyMemory(szBuf + lstrlenA(szBuf), pdli->szDll, lstrlenA(pdli->szDll) + 1);
			CopyMemory(szBuf + lstrlenA(szBuf), ")", 2);

			MessageBoxA(NULL, szBuf, NULL, MB_ICONEXCLAMATION | MB_TASKMODAL | MB_SETFOREGROUND);
		}
	break;


	case dliFailGetProc:
		if (FIsUniscribeDll(pdli->szDll))
			fp = (FARPROC)GetUniscribeStubs(pdli->dlp.szProcName);
		else
			fp = (FARPROC)LsGetReverseLsimethodsStub;
	break;
	}

	return fp;
}

PfnDliHook __pfnDliFailureHook = DliHook;

#endif //!_WIN64
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\rtext.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module RTEXT.CPP - Rich-text ptr class |
 *
 *		This text ptr consists of a plain text ptr (_rpTX), a CCharFormat
 *		run ptr (_rpCF), and a CParaFormat run ptr (_rpPF). This module
 *		contains the methods to manipulate this combination of run ptrs
 *		consistently.
 *	
 *	Authors:<nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Main implementation: Murray Sargent <nl>
 *		Undo and notification implementations: Alex Gounares <nl>
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_frunptr.h"
#include "_rtext.h"
#include "_disp.h"
#include "_select.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_objmgr.h"
#include "_txtbrk.h"

ASSERTDATA

#define DEBUG_CLASSNAME CRchTxtPtr
#include "_invar.h"

#ifdef DEBUG
/*
 *	CRchTxtPtr::Invariant
 */
BOOL CRchTxtPtr::Invariant( void ) const
{
	if (m_InvariantCheckInterval < 1 || m_InvariantCheckInterval > 10)
		const_cast<CRchTxtPtr *>(this)->m_InvariantCheckInterval = 10;

	const_cast<CRchTxtPtr *>(this)->m_InvariantCheckInterval--;

	if (m_InvariantCheckInterval)
		return TRUE;

	unsigned ch;
	LONG cch;
	LONG cchLength = GetTextLength();
	LONG cp;

	_rpTX.Invariant();
	_rpCF.Invariant();
	_rpPF.Invariant();

	if(_rpCF.IsValid())
	{
		cp  = _rpCF.CalculateCp();
		cch = _rpCF.CalcTextLength();
		Assert(GetCp() == cp && cchLength == cch);
		Assert(!_rpCF._iRun || GetPed()->IsBiDi() || _rpCF.GetRun(0)->_iFormat != _rpCF.GetRun(-1)->_iFormat);
	}

	if(_rpPF.IsValid())
	{
		cp  = _rpPF.CalculateCp();
		cch = _rpPF.CalcTextLength();
		Assert(GetCp() == cp && cchLength == cch);

		CTxtPtr	tp(_rpTX);

		tp.AdvanceCp(_rpPF.GetCchLeft() - 1);
		ch = tp.GetChar();
		if(!IsASCIIEOP(ch))
		{
			_rpTX.MoveGapToEndOfBlock();			// Make it easier to see
			AssertSz(FALSE,							//  what's going on
				"CRchTxtPtr::Invariant: PF run doesn't end with EOP");
		}

#ifdef EXTREME_CHECKING
		// We don't do this check normally as it is _extremely_ slow.
		// However, it's very useful for catching para-format run problems

		// Make sure each para format run ends on a paragraph mark!
		CFormatRunPtr	rpPF(_rpPF);

		rpPF.BindToCp(0);
		tp.BindToCp(0);
		do
		{
			tp.AdvanceCp(rpPF.GetRun(0)->_cch);
			if(!tp.IsAfterEOP())
			{
				AssertSz(0, "ParaFormat Run not aligned along paragraphs!");
			}
		} while( rpPF.NextRun() );
#endif // EXTREME_CHECKING
	}
	return TRUE;
}

#endif  // DEBUG

//======================= CRchTxtPtr constructors ========================================

CRchTxtPtr::CRchTxtPtr(CTxtEdit *ped) :
	_rpTX(ped, 0), _rpCF(NULL),	_rpPF(NULL)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	InitRunPtrs();
}

CRchTxtPtr::CRchTxtPtr(CTxtEdit *ped, LONG cp) :
	_rpTX(ped, cp), _rpCF(NULL), _rpPF(NULL)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	InitRunPtrs();
}

CRchTxtPtr::CRchTxtPtr (const CRchTxtPtr& rtp) :
	_rpTX(rtp._rpTX), _rpCF(rtp._rpCF), _rpPF(rtp._rpPF)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	_rpCF.AdjustForward();		// In case rtp is adjusted backward...
	_rpPF.AdjustForward();
}

CRchTxtPtr::CRchTxtPtr (const CDisplay * pdp) :
	_rpTX(pdp->GetPed(), 0), _rpCF(NULL), _rpPF(NULL)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::CRchTxtPtr");

	InitRunPtrs();
}

/*
 *	CRchTxtPtr::Advance(cch)
 *	
 *	@mfunc
 *		Move this rich-text ptr forward <p cch> characters.  If <p cch>
 *		<lt> 0, move backward by -<p cch> characters.
 *	
 *	@rdesc
 *		cch actually moved
 *
 */
LONG CRchTxtPtr::Advance(
	LONG cch)			// @parm count of characters to move - may be <lt> 0
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Advance");

	if( cch != 0 )
	{
		cch = _rpTX.AdvanceCp(cch);
		_rpCF.AdvanceCp(cch);
		_rpPF.AdvanceCp(cch);
		_TEST_INVARIANT_
	}

	return cch;
}

/*
 *  CRchTxtPtr::AdvanceCRLF()
 *
 *  @mfunc
 *      Advance this text ptr one char, treating CRLF as a single char.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CRchTxtPtr::AdvanceCRLF()
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::AdvanceCRLF");

    LONG cch = _rpTX.AdvanceCpCRLF();
    _rpPF.AdvanceCp(cch);
    _rpCF.AdvanceCp(cch);
    return cch;
}

/*
 *  CRchTxtPtr::SnapToCluster(INT iDirection)
 *
 *  @mfunc
 *      If this text ptr is not at cluster boundary, move it to the closest one.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CRchTxtPtr::SnapToCluster(INT iDirection)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::SnapToCluster");

	LONG	cch = 0;
	LONG	cp;

	if (GetPed()->_pbrk)
	{
		if (iDirection >= 0)
		{
			LONG	cpEnd = GetPed()->GetAdjustedTextLength();

			while ((cp = GetCp()) < cpEnd && !GetPed()->_pbrk->CanBreakCp(BRK_CLUSTER, cp))
				cch += AdvanceCRLF();
		}
		else
		{
			while ((cp = GetCp()) > 0 && !GetPed()->_pbrk->CanBreakCp(BRK_CLUSTER, cp))
				cch += BackupCRLF();
		}
	}
    return cch;
}

/*
 *  CRchTxtPtr::BackupCRLF()
 *
 *  @mfunc
 *      Backup this text ptr one char, treating CRLF as a single char.
 *
 *  @rdesc
 *      cch actually moved
 */
LONG CRchTxtPtr::BackupCRLF(
	BOOL fDiacriticCheck)
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEINTERN, "CRchTxtPtr::BackupCRLF");

    LONG cch = _rpTX.BackupCpCRLF(fDiacriticCheck);
    _rpPF.AdvanceCp(cch);
    _rpCF.AdvanceCp(cch);
    return cch;
}

/*
 * CRchTxtPtr::ValidateCp(&cp)
 *
 *	@mfunc
 *		If <p cp> <lt> 0, set it to 0; if it's <gt> text length, set it to
 *		text length.
 */
void CRchTxtPtr::ValidateCp(
	LONG &cp) const			// @parm new cp for this text ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ValidateCp");

	LONG cchT = GetTextLength();

	cp = min(cp, cchT);				// Be sure cp is valid
	cp = max(cp, 0);
}

/*
 * CRchTxtPtr::SetCp(cp)
 *
 *	@mfunc
 *		Set this rich text ptr's cp to cp
 */
LONG CRchTxtPtr::SetCp(
	LONG cp)			// @parm new cp for this text ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::SetCp");

	CRchTxtPtr::Advance(cp - GetCp());
	return GetCp();
}

/*	CRchTxtPtr::GetIchRunXX() and CRchTxtPtr::GetCchRunXX()
 *
 *	@mfunc
 *		Text-run management to retrieve current text run cch and offset
 *
 *	@rdesc
 *		current run ich or cch
 *
 *	@devnote
 *		Use of queries like _rpCF.IsValid() instead of an inclusive fRich
 *		allows rich-text formatting to be applied per rich-text category,
 *		e.g., CHARFORMATs, but not necessarily PARAFORMATs.  If the rp isn't
 *		valid, _cp is used for ich and the document length is used for cch,
 *		i.e., the values for a document describable by a single plain-text run
 */
LONG CRchTxtPtr::GetIchRunCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetIchRunCF");

	return _rpCF.IsValid() ? _rpCF.GetIch() : GetCp();
}

LONG CRchTxtPtr::GetIchRunPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetIchRunPF");

	return _rpPF.IsValid() ? _rpPF.GetIch() : GetCp();
}

LONG CRchTxtPtr::GetCchRunCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCchRunCF");

	return _rpCF.IsValid() ? _rpCF.GetRun(0)->_cch : GetTextLength();
}

/*	CRchTxtPtr::GetCchLeftRunCF() / GetCchLeftRunPF()
 *
 *	@mfunc
 *		Return cch left in run, i.e., cchRun - ich
 *
 *	@rdesc
 *		cch left in run
 */
LONG CRchTxtPtr::GetCchLeftRunCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCchLeftRunCF");

	return _rpCF.IsValid()
		? _rpCF.GetCchLeft() : GetTextLength() - GetCp();
}

LONG CRchTxtPtr::GetCchLeftRunPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCchLeftRunPF");

	return _rpPF.IsValid()
		? _rpPF.GetCchLeft() : GetTextLength() - GetCp();
}

/*
 *	CRchTxtPtr::FindText(cpMost, dwFlags, pch, cchToFind)
 *	
 *	@mfunc
 *		Find text in a range starting at this text pointer;
 *		if found, moves this text pointer to that position.
 *	
 *	@rdesc
 *		character position of first match
 *		<lt> 0 if no match
 *
 *	@devnote
 *		Would be easy to match a single format (like Word 6) provided
 *		cchToFind is nonzero.  Else need to search runs (also pretty easy).
 *		For format-sensitive searches, might be easier to search for matching
 *		format run first and then within that run search for text.
 */
LONG CRchTxtPtr::FindText (
	LONG		cpMost,		// @parm Limit of search; <lt> 0 for end of text
	DWORD		dwFlags,	// @parm FR_MATCHCASE	case must match
							//		 FR_WHOLEWORD	match must be a whole word
	TCHAR const *pch,		// @parm Text to search for
	LONG		cchToFind)	// @parm Length of text to search for
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::FindText");

	_TEST_INVARIANT_

	LONG cpSave = GetCp();
	LONG cpMatch = _rpTX.FindText(cpMost, dwFlags, pch, cchToFind);

	if(cpMatch >= 0)					// cpMatch = -1 means "not found"
		SetRunPtrs(GetCp(), cpSave);	
	
			// possible code for format-dependent Finds
	return cpMatch;
}

/*
 *	CRchTxtPtr::GetCF()/GetPF()
 *	
 *	@mfunc
 *		Return ptr to CCharFormat/CParaFormat at this text ptr. If no CF/PF runs
 *		are allocated, then return ptr to default format
 *	
 *	@rdesc
 *		Ptr to CCharFormat/CParaFormat at this text ptr
 */
const CCharFormat* CRchTxtPtr::GetCF() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetCF");

	return ((CTxtArray *)_rpTX._pRuns)->GetCharFormat(_rpCF.GetFormat());
}

const CParaFormat* CRchTxtPtr::GetPF() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetPF");

	return ((CTxtArray *)_rpTX._pRuns)->GetParaFormat(_rpPF.GetFormat());
}

/*
 *	CRchTxtPtr::ReplaceRange(cchOld, cchNew, *pch, pcpFirstRecalc, publdr,
 *							 iFormat, pcchMove, dwFlags)
 *	@mfunc
 *		Replace a range of text at this text pointer using CCharFormat iFormat
 *		and updating other text runs as needed
 *	
 *	@rdesc
 *		Count of new characters added
 *	
 *	@devnote
 *		Moves this text pointer to end of replaced text.
 *		May move text block and formatting arrays.
 */
LONG CRchTxtPtr::ReplaceRange(
	LONG		cchOld,		//@parm length of range to replace
							//		(<lt> 0 means to end of text)
	LONG		cchNew,		//@parm length of replacement text
	TCHAR const *pch,		//@parm replacement text
	IUndoBuilder *publdr,	//@parm Undo bldr to receive antievents
	LONG		iFormat,	//@parm CCharFormat iFormat to use for cchNew
	LONG *		pcchMove,	//@parm Out parm returning cch moved if paradir change
	DWORD		dwFlags)	//@parm Special flags
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ReplaceRange");

	LONG		  cch;
	LONG		  cchEndEOP = 0;				// Default 0 final EOP fixup
	LONG		  cchAdvance = 0;
	LONG		  cchBackup = 0;
	LONG		  cchMove = 0;					// Default nothing to move
	LONG		  cchNextEOP = cchOld;			// cch to next EOP
	LONG		  cchPrevEOP = 0;				// cch back to previous EOP
	LONG		  cpFR;							//  between PF runs
	LONG 		  cpSave = GetCp();
	LONG		  cpFormatMin = cpSave;			// Used for notifications
	LONG		  cpFormat = cpSave;			// Will add cchOld, maybe cchMove
	BOOL		  fParaDirChange = FALSE;
	CTxtEdit *	  ped = GetPed();
	IAntiEvent *  paeCF = NULL;
	IAntiEvent *  paePF = NULL;
	CNotifyMgr *  pnm;
	CObjectMgr *  pobjmgr;
	CFreezeDisplay fd(ped->_pdp);				// freeze until itemization is done

 	_TEST_INVARIANT_

	LONG cchEnd = GetTextLength() - GetCp();
	if(cchOld < 0 || cchOld > cchEnd)
		cchOld = cchEnd;

  	if(IsRich() && cchOld == cchEnd)			// Attempting to delete up
	{											//  thru final EOP
		cchEndEOP = (ped->fUseCRLF())			// Calc cch of final EOP
				  ? CCH_EOD_10 : CCH_EOD_20;

		if(cchEndEOP <= cchOld)					// Don't delete it unless
			cchOld -= cchEndEOP;				//  converting from 2.0
		if(_rpPF.IsValid())
		{
			_rpPF.AdjustBackward();				// If previous para is a
			if(GetPF()->InTable())				//  table row, don't delete
				cchEndEOP = 0;					//  final para formatting
		}										
	}
	else if(_rpPF.IsValid())					// If PARAFORMATs are enabled,
	{
		_rpPF.AdjustForward();
		if (cchOld)			
		{											//  get tp and rp at end of
			CFormatRunPtr rp(_rpPF);				//  range. Need bounding para
			CTxtPtr 	  tp(_rpTX);				//  counts to save valid PF
			BOOL		  fIsAtBOP;					//  for undo

			tp.AdvanceCp(cchOld);
			rp.AdvanceCp(cchOld);

			cch = 0;
			if(tp.IsAfterEOP())						// Range ends with an EOP:
			{										//  get EOP length by
				cch = -tp.BackupCpCRLF();			//  backing up over it
				tp.AdvanceCp(cch);					// Advance past EOP
			}
			cchNextEOP = tp.FindEOP(tomForward);	// Get cch up to next EOP

			fIsAtBOP = !GetCp() || _rpTX.IsAfterEOP();
			if (!fIsAtBOP && cch == cchOld) 		// Deleting EOP alone before
			{										// new PARAFORMAT run start
													// in para with more than EOP
				//bug fix #4978
				if (!(dwFlags & RR_NO_EOR_CHECK) &&
					(ped->GetParaFormat(rp.GetFormat())->_wEffects |
					 ped->GetParaFormat(_rpPF.GetFormat())->_wEffects) & PFE_TABLE)
					return 0;
					
				if (!rp.GetIch())						
				{
					cchMove = cchNextEOP;				// Need to move chars up to
					cpFormat += cchMove;				//  end of next para for
				}
			}
			
			cchNextEOP += cchOld;					// Count from GetCp() to EOP
				
			tp.SetCp(GetCp());						// Back to this ptr's _cp
			if(!fIsAtBOP)
				cchPrevEOP = tp.FindEOP(tomBackward);// Get cch to start of para

			// If deleting from within one format run up to or into another, set
			// up to move last para in starting format run into the run following
			// the deleted text
			LONG iPF1 =    rp.GetFormat();
			LONG iPF2 = _rpPF.GetFormat();
			if(iPF1 != iPF2)						// Change of format during
			{										//  deleted text not starting
				if(!fIsAtBOP && !cchMove)			//  at BOP
				{									
					cchMove = cchPrevEOP;			// Get cch to start of para
					cpFormatMin += cchMove;			//  in this ptr's run for
				}									//  moving into rp's run

				if ((ped->GetParaFormat(iPF1)->_wEffects ^
					 ped->GetParaFormat(iPF2)->_wEffects) & PFE_RTLPARA)
				{
					fParaDirChange = TRUE;			// Note that para direction
					Assert(ped->IsBiDi());			//  changed
				}									
			}
		}
		else if (((ped->GetParaFormat(_rpPF.GetFormat())->_wEffects) & PFE_TABLE) && _rpTX.IsAtEOP() &&
			!(dwFlags & RR_NO_EOR_CHECK) /*bug fix #5752*/)
		{
			// bug fix #5669
			// Don't allow pasting at end of row
			return 0;
		}
	}	
	
	Assert(cchNew >= 0 && cchOld >= 0);
	if(!(cchNew + cchOld))						// Nothing to do (note: all
	{											//  these cch's are >= 0)
		if(pcchMove)
			*pcchMove = 0;
		return 0;
	}						

	// Handle pre-replace range notifications.  This method is very
	// useful for delayed rendering of data copied to the clipboard.
	pnm = ped->GetNotifyMgr();
	if(pnm)
	{
		pnm->NotifyPreReplaceRange((ITxNotify *)this, cpSave, cchOld,
			cchNew, cpFormatMin, cpFormat + cchOld);
	}

	if(iFormat >= 0)
		Check_rpCF();

	// Get rid of objects first.  This let's us guarantee that when we
	// insert the objects as part of an undo, the objects themselves are
	// restored _after_ their corresponding WCH_EMBEDDINGs have been
	// added to the backing store.

	if(GetObjectCount())
	{
		pobjmgr = ped->GetObjectMgr();
		Assert(pobjmgr);
		pobjmgr->ReplaceRange(cpSave, cchOld, publdr);
	}

	// If BiDi doc, expand the range to cover the boundaries that guarantee
	// the valid state of the BiDi level so we can undo it properly. (wchao)
	if(ped->IsBiDi())
	{
		cchBackup = ExpandRangeFormatting (cchOld + cchEndEOP,
										fParaDirChange ? cchMove : 0, cchAdvance);
		Assert (cchBackup >= 0);
	}

	// The anti-events used below are a bit tricky (paeCF && paePF).
	// Essentially, this call, CRchTxtPtr::ReplaceRange generates one
	// 'combo' anti-event composed of up to two formatting AE's plus
	// the text anti-event.  These anti-events are combined together
	// to prevent ordering problems during undo/redo.
	cpFR = ReplaceRangeFormatting(cchOld + cchEndEOP, cchNew + cchEndEOP,
						iFormat, publdr, &paeCF, &paePF, cchMove, cchPrevEOP,
						cchNextEOP, cchBackup, cchAdvance);
	if(cchEndEOP)
	{
		// If we added in the EOP we need to back up by the EOP so
		// that the invariants don't get annoyed and the richtext object
		// doesn't get out of sync.
		_rpCF.AdvanceCp(-cchEndEOP);
		_rpPF.AdvanceCp(-cchEndEOP);
	}
			
	if(cpFR < 0)
	{
		Tracef(TRCSEVERR, "ReplaceRangeFormatting(%ld, %ld, %ld) failed", GetCp(), cchOld, cchNew);
		cch = 0;
		goto Exit;
	}

	// As noted above in the call to ReplaceRangeFormatting, the anti-events
	// paeCF and paePF, if non-NULL, were generated by ReplaceRangeFormatting.
	// In order to solve ordering problems, the anti-event generated by this
	// method is actually a combo anti-event of text && formatting AE's.
	cch = _rpTX.ReplaceRange(cchOld, cchNew, pch, publdr, paeCF, paePF);
	if(cch != cchNew)
	{
		Tracef(TRCSEVERR, "_rpTX.ReplaceRange(%ld, %ld, ...) failed", cchOld, cchNew);

#ifndef NODUMPFORMATRUNS
		// Boy, out of memory or something bad.  Dump our formatting and hope
		// for the best.
		//
		// FUTURE: (alexgo) degrade more gracefully than losing formatting
		// info.

		// Notify every interested party that they should dump their formatting
		if(pnm)
			pnm->NotifyPreReplaceRange(NULL, CONVERT_TO_PLAIN, 0, 0, 0, 0);

		// Tell document to dump its format runs
		ped->GetTxtStory()->DeleteFormatRuns();
#endif
		goto Exit;
	}
	AssertSz(!_rpPF.IsValid() || _rpPF.GetIch() || !GetCp() || _rpTX.IsAfterEOP(),
		"CRchTxtPtr::ReplaceRange: EOP not at end of PF run");
			
	// BUGBUG!! (alexgo) doesn't handle correctly the case where things fail
	// (due to out of memory or whatever).  See also notes in CTxtPtr::HandleReplaceRange
	// Undo.  The assert below is therefore somewhat bogus, but if it fires,
	// then our floating ranges are going to be in trouble until we fix
	// up the logic here.
	Assert(cch == cchNew);

Exit:

#ifdef DEBUG
	// Test invariant again before calling out to replace range notification.
	// In this way, we can catch bugs earlier. The invariant has its own
	// scope for convenience.
	if( 1 )
	{
		_TEST_INVARIANT_
	}
#endif

	if (ped->IsBiDi() && cpSave <= (LONG) ped->GetCpFirstStrong()
		&& ((cchOld != 0) || (cch != 0)))
	{
		// Remember whether formatting is valid before we set context direction
		BOOL fCFValidBeforeSetContextDirection = _rpCF.IsValid();
		
		// Need to check the direction of the control if the input characters
		// control the direction.
		ped->SetContextDirection();

		// Did SetContextDirection make the formatting valid?
		if (!fCFValidBeforeSetContextDirection && _rpCF.IsValid())
		{
			// Our invariant is that cps should be equal if formatting is valid
			// so make it so!
			_rpCF.BindToCp(GetCp());
		}
	}

	if(pnm)
	{
		pnm->NotifyPostReplaceRange((ITxNotify *)this, cpSave, cchOld, cch,
			cpFormatMin, cpFormat + cchOld);
	}

	ped->GetCallMgr()->SetChangeEvent(CN_TEXTCHANGED);

	if(pcchMove)						// Only return non0 cchMove if para
	{									//  direction changed, i.e., it's
		*pcchMove = fParaDirChange		//  a "BOOL" with a useful value,
				  ? cchMove : 0;		//  namely the count of chars with
	}									//  changed direction

	if (ped->IsComplexScript())
	{
		if (dwFlags & RR_ITMZ_NONE || (ped->IsStreaming() && (!pch || *pch != WCH_EMBEDDING)))
			ped->_fItemizePending = TRUE;
		else
			ItemizeReplaceRange(cchNew, fParaDirChange? cchMove : 0, publdr);
	}
	return cch;
}

/*
 *	CRchTxtPtr::InitRunPtrs()
 *
 *	@mfunc
 *		Initialize Run Ptrs of this rich-text ptr to correspond to
 *		document given by ped and to cp given by cp.
 */
void CRchTxtPtr::InitRunPtrs()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::InitRunPtrs");
	AssertSz(GetPed(), "RTP::InitRunPtrs: illegal GetPed()");

	LONG cp = GetCp();
	CTxtStory *pStory = GetPed()->GetTxtStory();// If there's RichData,
	if(pStory->_pCFRuns)						//  initialize format-run ptrs
	{
		_rpCF.SetRunArray((CRunArray *)pStory->_pCFRuns);
		_rpCF.BindToCp(cp);
	}
	if(IsRich() && pStory->_pPFRuns)
	{
		_rpPF.SetRunArray((CRunArray *)pStory->_pPFRuns);
		_rpPF.BindToCp(cp);
	}
}

/*
 *	CRchTxtPtr::SetRunPtrs(cp, cpFrom)
 *
 *	@mfunc set Run Ptrs of this rich-text ptr to correspond to cp
 *
 *	@rdesc
 *			TRUE unless cp is outside of doc (in which case RunPtrs are
 *			set to nearest document end).
 */
void CRchTxtPtr::SetRunPtrs(
	LONG cp,				// @parm character position to move RunPtrs to
	LONG cpFrom)			// @parm cp to start with
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::SetRunPtrs");

	if(cpFrom && 2*cp >= cpFrom)
	{
		_rpCF.AdvanceCp(cp - cpFrom);
		_rpPF.AdvanceCp(cp - cpFrom);
	}
	else
	{
		_rpCF.BindToCp(cp);
		_rpPF.BindToCp(cp);
	}
}

/*
 *	CRchTxtPtr::ExpandRangeFormatting(cchRange,	cchMove, cchAdvance, fSavePara)
 *
 *	@rdesc
 *		In BiDi scenario, it's possible that updating a character affects the level of
 *		the others. Such case should only happen when number being involved.
 *
 *		Example: (AN)"11:30" changing '3' to 'x' will change the level of colon from 2 to 1.
 *
 */
LONG CRchTxtPtr::ExpandRangeFormatting(
	LONG		cchRange,		// in: original length
	LONG		cchMove,		// in: number of chars moved after the replacement
	LONG&		cchAdvance)		// out: the extra chars added to the range after expanding
{
	LONG		cchBackup = 0;
	
	cchAdvance = 0;

	if (_rpCF.IsValid())
	{
   		CTxtPtr		tp(_rpTX);

		if (!IsRich())
		{
			cchBackup = -tp.FindEOP(tomBackward);
			tp.AdvanceCp(cchBackup + cchRange);
			cchAdvance = tp.FindEOP(tomForward);
		}
		else
		{
			CFormatRunPtr	rp(_rpCF);
			LONG			cp = GetCp();
	
			if (cchMove < 0)
			{
				// <cchMove> number of text to be moved down to the next paragraph
				cchBackup = -cchMove;
			}
			else if (cchMove > 0)
			{
				// <cchMove> number of text to be moved up to the previous paragraph
				cchAdvance = cchMove;
			}

			
			// Advancing/Backing up 2 adjacent runs seems to be sufficient for now.

			if (cchBackup == 0)
			{
				rp.AdjustBackward();
				cchBackup += rp.GetIch();
				if (rp.PrevRun())
					cchBackup += rp.GetCchLeft();
				rp.AdvanceCp(cchBackup);
			}

			// move the run pointer to the end of range
			rp.AdvanceCp(cchRange);
			tp.SetCp(cp + cchRange);
			if (cchAdvance == 0 && !tp.IsAtEOP())
			{
				rp.AdjustForward();
				cchAdvance += rp.GetCchLeft();
				if (rp.NextRun())
					cchAdvance += rp.GetCchLeft();
			}
		}
	}
	return cchBackup;
}


/*
 *	CRchTxtPtr::ItemizeReplaceRange(cchUpdate, cchMove, publdr, fUnicodeBidi)
 *
 *	@mfunc
 *		Find out the exact range to be itemized after calling :ReplaceRange
 *
 *	@rdesc
 *		result from ItemizeRuns.
 *		Guarantee *this* pointer wont move.
 */
BOOL CRchTxtPtr::ItemizeReplaceRange(
	LONG			cchUpdate,
	LONG			cchMove,		// Count of chars moved after replacing
	IUndoBuilder*	publdr,			//  (they need reitemizing)
	BOOL			fUnicodeBidi)
{
	BOOL	fr = FALSE;

	if (GetPed()->IsComplexScript())
	{
		Assert (cchUpdate >= 0);    // the range after ReplaceRange must be degenerate

		CTxtPtr tp(_rpTX);
		LONG    cp = GetCp();
		LONG    cpStart, cpEnd;
		BOOL    fNonUnicodeBidiRecurse = FALSE;
		BOOL	fUseCtxLevel = FALSE;


		tp.AdvanceCp(-cchUpdate);


		if (cchUpdate > 0 && GetPed()->IsRich() && fUnicodeBidi)
		{
			cpStart = cpEnd = cp;
			cpStart -= cchUpdate;

			if (GetPed()->IsBiDi())
			{
				// RAID bug 7094 : We wnat to use the IP to set the context for 
				// incoming text.
				// fUseCtxLevel = TRUE;

				// Recurse with non-BiDi, so the run preceding/succeeding this chunk get updated
				fNonUnicodeBidiRecurse = TRUE;
			}
		}
		else
		{
			tp.FindWhiteSpaceBound(cchUpdate, cpStart, cpEnd,
								!GetPed()->IsRich() ? FWS_BOUNDTOPARA : 0);
		}


		if (cchMove < 0)
		{
			// <cchMove> number of text -before- the replaced range
			// moves down to the next paragraph.
			cpStart = max(cp - cchUpdate + cchMove, 0);
		}
		else if (cchMove > 0)
		{
			// <cchMove> number of text -after- the replaced range
			// moves up to the previous paragraph.
			cpEnd = min(cp + cchMove, GetPed()->GetTextLength());
		}

		{
			CTxtRange	rg(*this, 0);

			rg.Set(cpEnd, cpEnd - cpStart);
	
			fr = rg.ItemizeRuns(publdr, fUnicodeBidi, fUseCtxLevel);

			// set pointer back to original cp
	
			// We cant use copy operator here since itemization changes format run.
			// It would cause invariant failure in _rpCF.
			cp -= rg.GetCp();
			_rpCF = rg._rpCF;
			_rpCF.AdvanceCp(cp);
	
			// ItemizeRuns invalidates rg._rpPF so that the paraformat run becomes valid
			// and we need to advance it to the current cp.
			_rpPF = rg._rpPF;
			_rpPF.AdvanceCp(cp);

			// Perf note: We dont want the range to be around when we recurse
			// since a range is a notification sink.
		}

		// Run itemization to the same range, this time forces it to be non-Bidi.
		if (fr && fNonUnicodeBidiRecurse)
			fr = ItemizeReplaceRange(cchUpdate, 0, publdr, FALSE);
	}
	return fr;
}


/*
 *	CRchTxtPtr::ReplaceRangeFormatting(cchOld, cchNew, iFormat, publdr,
 *									   ppaeCF, ppaePF, cchMove)
 *	@mfunc
 *		replace character and paragraph formatting at this text pointer
 *		using CCharFormat with index iFormat
 *	
 *	@rdesc
 *		count of new characters added
 *	
 *	@devnote
 *		moves _rpCF and _rpPF to end of replaced text
 *		moves format run arrays
 *		CCharFormat for iFormat is fully configured, i.e., no NINCHes
 */
LONG CRchTxtPtr::ReplaceRangeFormatting(
	LONG		cchOld,		//@parm length of range to replace
	LONG		cchNew,		//@parm length of replacement text
	LONG		iFormat,	//@parm Char format to use
	IUndoBuilder *publdr,	//@parm UndoBuilder to receive antievents
	IAntiEvent **ppaeCF,	//@parm where to return 'extra' CF anti-events
	IAntiEvent **ppaePF,	//@parm where to return extra PF anti-events
	LONG		cchMove,	//@parm cch to move between PF runs
	LONG		cchPrevEOP,	//@parm cch from _cp back to prev EOP
	LONG		cchNextEOP,	//@parm cch from _cp up to next EOP
	LONG		cchSaveBefore,
	LONG		cchSaveAfter)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ReplaceRangeFormatting");

	LONG				cp = GetCp();				
	ICharFormatCache *	pcfc = GetCharFormatCache();
	IParaFormatCache *	ppfc = GetParaFormatCache();
	LONG iRunMerge	= 0;

	AssertSz(cchOld >= 0,
		"CRchTxtPtr::ReplaceRangeFormatting: Illegal cchOld");

	if(_rpCF.IsValid())
	{
		iRunMerge = _rpCF._iRun;
		if(iRunMerge > 0)
			iRunMerge--;

		Assert (cchSaveBefore >= 0 && cchSaveAfter >= 0);
		if(cchOld + cchSaveAfter + cchSaveBefore > 0)
		{										// add the soon-to-be deleted
			if(publdr)							// formats to the undo list
			{
				// Include previous cchSaveBefore chars
				_rpCF.AdvanceCp(-cchSaveBefore);
				*ppaeCF = gAEDispenser.CreateReplaceFormattingAE(
							GetPed(), _rpCF, cchSaveAfter + cchOld + cchSaveBefore, pcfc, CharFormat);
				// Restore _rpCF (we just want to save value not delete it)
				_rpCF.AdvanceCp(cchSaveBefore);
			}
			if(cchOld)							// Delete/modify CF runs <-->
				_rpCF.Delete(cchOld, pcfc, 0);	//  to cchOld chars
		}
		// If we deleted all of text in story, don't bother adding a new
		// run.	Else insert/modify CF runs corresponding to cchNew chars
		//
		// In a plain-text control, there is no final EOP; hence the test
		// for equality.
		if(cchNew > 1 || cchNew && cchOld <= GetTextLength())
			_rpCF.InsertFormat(cchNew, iFormat, pcfc);

		if((cchOld || cchNew) && _rpCF.IsValid())// Deleting all text
		{										//  invalidates _rpCF
			_rpCF.AdjustForward();
			_rpCF.MergeRuns(iRunMerge, pcfc);
			_rpCF.BindToCp(cp + cchNew);
		}
	}

	if(_rpPF.IsValid())
	{
		_rpPF.AdjustForward();					// Be absolutely sure that
												//  PF runs end with EOPs
		iRunMerge = _rpPF._iRun;
		if(iRunMerge > 0)
			iRunMerge--;

		if(cchOld)								// Delete cchOld from PF runs
		{										// add the soon-to-be deleted
			if(publdr)							// formats to the undo list
			{
				CFormatRunPtr rp(_rpPF);

				rp.AdvanceCp(cchPrevEOP);
				*ppaePF = gAEDispenser.CreateReplaceFormattingAE(GetPed(),
								rp, cchNextEOP - cchPrevEOP, ppfc, ParaFormat);
			}
		    _rpPF.Delete(cchOld, ppfc, cchMove);
		}

		if(_rpPF.IsValid())						// Deleting all text
		{										//  invalidates _rpPF
			_rpPF.AdjustForward();
			_rpPF.GetRun(0)->_cch += cchNew;	// Insert cchNew into current
			_rpPF._ich	+= cchNew;				//  PF run
			if(cchOld || cchNew)
			{
				_rpPF.MergeRuns(iRunMerge, ppfc);
				_rpPF.BindToCp(cp + cchNew);
			}
		}
	}
	return cchNew;
}

/*
 *	CRchTxtPtr::ExtendFormattingCRLF()
 *	
 *	@mfunc
 *		Use the same CCharFormat and CParaFormat indices for the EOP at
 *		this text ptr as those immediately preceding it.
 *
 *	@devnote
 *		Leaves this text ptr's format ptrs at run you get from AdjustBackward
 *		since this run ends up including the new text.
 */	
void CRchTxtPtr::ExtendFormattingCRLF()
{
	LONG		cch = GetTextLength() - GetPed()->GetAdjustedTextLength();
	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();

	_rpCF.AdjustFormatting(cch, GetCharFormatCache());
	if(_rpPF.IsValid())
	{
		_rpPF.AdjustBackward();
		if(!InTable())
			_rpPF.AdjustFormatting(cch, GetParaFormatCache());
		_rpPF.AdjustForward();
	}

	if(pnm)
	{
		// We assume that Cch is positive (or zero) here
		Assert(cch >= 0);
		pnm->NotifyPostReplaceRange((ITxNotify *)this, CP_INFINITE, 0, 0,
				GetCp(), GetCp() + cch);
	}
}

/*
 *	CRchTxtPtr::IsRich()
 *	
 *	@mfunc
 *		Determine whether rich-text operation is operable
 *	
 *	@rdesc
 *		TRUE if associated CTxtEdit::_fRich = 1, i.e., control is allowed
 *		to be rich.
 */
BOOL CRchTxtPtr::IsRich()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::IsRich");

	return GetPed()->IsRich();
}

/*
 *	CRchTxtPtr::Check_rpCF()
 *	
 *	@mfunc
 *		enable _rpCF if it's not already enabled
 *	
 *	@rdesc
 *		TRUE if _rpCF is enabled
 */
BOOL CRchTxtPtr::Check_rpCF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Check_rpCF");

	if(_rpCF.IsValid())
		return TRUE;

	if(!_rpCF.InitRuns (GetCp(), GetTextLength(),
				&(GetPed()->GetTxtStory()->_pCFRuns)))
	{
		return FALSE;
	}

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();	// For notifying of changes
	if(pnm)
		pnm->NotifyPostReplaceRange(	 		// Notify interested parties
				(ITxNotify *)this, CP_INFINITE,	//  that
				0, 0, CP_INFINITE, CP_INFINITE);

	return TRUE;
}

/*
 *	CRchTxtPtr::Check_rpPF()
 *	
 *	@mfunc
 *		enable _rpPF if it's not already enabled
 *	
 *	@rdesc
 *		TRUE if _rpPF is enabled
 */
BOOL CRchTxtPtr::Check_rpPF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Check_rpPF");

	if(_rpPF.IsValid())
		return TRUE;

	if(!IsRich())
		return FALSE;

	if(!_rpPF.InitRuns (GetCp(), GetTextLength(),
				&(GetPed()->GetTxtStory()->_pPFRuns)))
	{
		return FALSE;
	}

	if (IsParaRTL())
		_rpPF.GetRun(0)->_level._value = 1;		// Set default paragraph base level

	CNotifyMgr *pnm = GetPed()->GetNotifyMgr();	// For notifying of changes
	if(pnm)
		pnm->NotifyPostReplaceRange(	 		// Notify interested parties
				(ITxNotify *)this, CP_INFINITE,	// of the change.
				0, 0, CP_INFINITE, CP_INFINITE);

	return TRUE;
}

/*
 * CRchTxtPtr::FindWordBreak(action, cpMost)
 *
 *	@mfunc
 *		Same as CTxtPtr::FindWordBreak(), but moves the whole rich text ptr
 *
 *	@rdesc
 *		cch this rich text ptr is moved
 */
LONG CRchTxtPtr::FindWordBreak(
	INT		action,		//@parm Kind of word break to find
	LONG	cpMost)		//@parm Limiting character position

{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::FindWordBreak");

	LONG cch = _rpTX.FindWordBreak(action, cpMost);
	_rpCF.AdvanceCp(cch);
	_rpPF.AdvanceCp(cch);

	return cch;
}

/*
 *	CRchTxtPtr::BindToCp(dwNewCp)
 *
 *	@mfunc
 *		Set cp to new value and recalculate that new position.
 */
void CRchTxtPtr::BindToCp(
	LONG cp)			// @parm new cp for rich text
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::BindToCp");

	_rpTX.BindToCp(cp);				// Recalculate cp for plain text

	// Use the InitRunPtrs routine so that the run pointers will get
	// re-initialized and rebound with the correct run array.  The
	// run array formerly used (if any at all) is not necessarily valid
	// when this function is called.

	InitRunPtrs();

	// Do invariant testing at end because this fixes up the rich text
	// pointer in the face of backing store changes.
	_TEST_INVARIANT_
}

/*
 *	CRchTxtPtr::CheckFormatRuns ()
 *
 *	@mfunc
 *		Check the format runs against what's in CTxtStory.  If
 *		different, forces a rebind to <p cp>
 */
void CRchTxtPtr::CheckFormatRuns()
{
	CTxtStory *pStory = GetPed()->GetTxtStory();

	if (pStory->GetCFRuns() != (CFormatRuns *)_rpCF._pRuns ||
		pStory->GetPFRuns() != (CFormatRuns *)_rpPF._pRuns)
	{
		InitRunPtrs();
	}

	_TEST_INVARIANT_
}

/*
 *	CRchTxtPtr::ChangeCase(cch, Type, publdr)
 *	
 *	@mfunc
 *		Change case of cch chars starting at this text ptr according to Type,
 *		which has the possible values:
 *
 *		tomSentenceCase	= 0: capitalize first letter of each sentence
 *		tomLowerCase	= 1: change all letters to lower case
 *		tomUpperCase	= 2: change all letters to upper case
 *		tomTitleCase	= 3: capitalize the first letter of each word
 *		tomToggleCase	= 4: toggle the case of each letter
 *	
 *	@rdesc
 *		TRUE iff a change occurred
 *
 *	@devnote
 *		Since this routine only changes the case of characters, it has no
 *		effect on rich-text formatting.  However it is part of the CRchTxtPtr
 *		class in order to notify the display of changes.  CTxtRanges are also
 *		notified just in case the text blocks are modified.
 */
BOOL CRchTxtPtr::ChangeCase (
	LONG		  cch,			//@parm # chars to change case for
	LONG		  Type,			//@parm Type of change case command
	IUndoBuilder *publdr)		//@parm UndoBuilder to receive anti-event
								//  	for any replacements
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::ChangeCase");
	_TEST_INVARIANT_

#define	BUFFERLEN	256

	LONG	cchChunk, cchFirst, cchFormat, cchGet, cchLast;
	BOOL	fAlpha, fToUpper, fUpper;			// Flags controling case change
	BOOL	fChange = FALSE;					// No change yet
	BOOL	fStart = TRUE;						// Start of Word/Sentence
	LONG	iCF;
	TCHAR *	pch;								// Ptr to walk rgCh with
	WORD *	pType;								// Ptr to walk rgType with
	WCHAR	rgCh[BUFFERLEN];					// Char buffer to work in
	WORD	rgType[BUFFERLEN];					// C1_TYPE array for rgCh

	if( GetCp() )
	{
		if( Type == tomSentenceCase )
		{
			fStart = _rpTX.IsAtBOSentence();
		}
		else if( Type == tomTitleCase )
		{
			// Check to see if we are at the beginning of
			// a word.  This is the case if the character preceeding
			// our current position is white space.
			fStart = IsWhiteSpace(GetPrevChar());
		}
	}
	while(cch > 0)								// Do 'em all (or as many as
	{											//  in story)
		cchChunk = min(BUFFERLEN, cch);			// Get next bufferful

		// FUTURE: it's too bad that we have to do all this format stuff
		// when the formatting isn't even going to change.  It would be
		// faster and simpler to use _rpTX.ReplaceRange() and just send
		// appropriate notifications.
		if(_rpCF.IsValid())						// Make sure it stays within
		{										//  current char/paraformat
			cchFormat = _rpCF.GetCchLeft();		//  runs to simplify changing
			cchChunk = min(cchChunk, cchFormat);//  text with undo
		}										
		if(_rpPF.IsValid())						
		{
			cchFormat = _rpPF.GetCchLeft();
			cchChunk = min(cchChunk, cchFormat);
		}
		cch -= cchChunk;						// Decrement the count
		cchGet = _rpTX.GetText(cchChunk, rgCh);	// Manipulate chars in buffer
		if(cchGet < cchChunk)					//  (for undo, need to use
		{										//  ReplaceRange())
			cch = 0;							// No more chars in story,
			if(!cchGet)							//  so we'll be done
				break;							// We're done already
			cchChunk = cchGet;					// Something in this chunk
		}

		W32->GetStringTypeEx(0, CT_CTYPE1, rgCh,// Find out whether chars are
						cchChunk, rgType);		//  UC, LC, or neither
		cchLast = 0;							// Default nothing to replace
		cchFirst = -1;
		for(pch = rgCh, pType = rgType;			// Process buffered chars
			cchChunk;
			cchChunk--, pch++, pType++)
		{
			fAlpha = *pType & (C1_UPPER | C1_LOWER); // Nonzero if UC or LC
			fUpper = (*pType & C1_UPPER) != 0;	// TRUE if UC
			fToUpper = fStart ? TRUE : fUpper;	// capitalize first letter of a
												// sentence
			switch(Type)
			{									// Decide whether to change
			case tomLowerCase:					//  case and determine start
				fToUpper = FALSE;				//  of word/sentence for title
				break;							//  and sentence cases

			case tomUpperCase:
				fToUpper = TRUE;
				break;

			case tomToggleCase:
				fToUpper = !fUpper;
				break;

			case tomSentenceCase:
				if(*pch == TEXT('.'))			// If sentence terminator,
					fStart = TRUE;				//  capitalize next alpha
				if(fAlpha)						// If this char is alpha, next
					fStart = FALSE;				//  char can't start a
				break;							//  sentence

			case tomTitleCase:					// If this char is alpha, next
				fStart = (fAlpha == 0);			//  char can't start a word
				break;
			default:
				return FALSE;
			}

			if(fAlpha && (fToUpper ^ fUpper))	// Only change case if it
			{									//  makes a difference (saves
				if(fToUpper)					//  on system calls and undos)
					CharUpperBuff(pch, 1);
				else
					CharLowerBuff(pch, 1);

				fChange = TRUE;					// Return value: change made
				if( cchFirst == -1 )			// Save cch of unchanged
					cchFirst = cchGet-cchChunk;	//  leading string
				cchLast = cchChunk - 1;			// Save cch of unchanged
			}									//  trailing string
		}
		if( cchFirst == -1 )
		{
			Assert(cchLast == 0);
			cchFirst = cchGet;
		}

		Advance(cchFirst);						// Skip unchanged leading
		cchGet -= cchFirst + cchLast;			//  string. cchGet = cch of
		_rpCF.AdjustForward();					//  changed span. Adjust in
												//  case cchFirst = 0
		iCF = _rpCF.GetFormat();
		GetCharFormatCache()->AddRef(iCF);
		ReplaceRange(cchGet, cchGet, rgCh + cchFirst, publdr, iCF);
		ReleaseFormats(iCF, -1);
		Advance(cchLast);						// Skip unchanged trailing
	}											//  string
	return fChange;
}

// The following defines a mask for Units implemented by UnitCounter()
#define IMPL ((1 << tomCharacter)  + (1 << tomWord) + (1 << tomSentence) + \
			  (1 << tomParagraph)  + (1 << tomLine) + (1 << tomStory) +	\
			  (1 << tomCharFormat) + (1 << tomParaFormat) + (1 << tomObject))

/*
 *	CRchTxtPtr::UnitCounter (Unit, &cUnit, cchMax)
 *
 *	@mfunc
 *		Helper function to count chars in <p cUnit> Units defined by <p Unit>
 *		<p cUnit> is a signed count.  If it extends beyond either end of the
 *		story, count up to that end and update <p cUnit> accordingly.  If
 *		<p cchMax> is nonzero, stop counting when the count exceeds <p cchMax>
 *		in magnitude.
 *
 *	@rdesc
 *		If unit is implemented, return cch corresponding to the units counted
 *		(up to a maximum magnitude of <p cchMax>) and update cUnit;
 *		else return tomForward to signal unit not implemented and cUnit = 0.
 *		If unit is implemented but unavailable, e.g., tomObject with no
 *		embedded objects, return tomBackward.
 *
 *	@devnote
 *		This is the basic engine used by the TOM CTxtRange::Move() and Index()
 *		methods.
 */
LONG CRchTxtPtr::UnitCounter (
	LONG	Unit,				//@parm Type of unit to count
	LONG &	cUnit,				//@parm Count of units to count chars for
	LONG	cchMax)				//@parm Maximum character count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CRchTxtPtr::UnitCounter");

	LONG	action;				// Gives direction and tomWord commands
	LONG	cch;				// Collects cch counted
	LONG	cchText = GetTextLength();
	LONG	cp = GetCp();
	LONG	iDir = cUnit > 0 ? 1 : -1;
	LONG	j;					// For-loop index
	CDisplay *pdp;				// Used for tomLine case

	if(!cUnit)									// Nothing to count
	{
		return ((DWORD)Unit > tomObject || !((IMPL >> Unit) & 1))
			? tomForward : 0;					// Indicate Unit not
	}											//  implemented
	if(cchMax <= 0)
		cchMax = tomForward;					// No cch limit

	switch(Unit)
	{
	case tomCharacter:							// Smallest Unit
		cp += cUnit;							// Requested new cp
		ValidateCp(cp);							// Make sure it's OK
		cch = cUnit = cp - GetCp();				// How many cch, cUnits
		break;									//  actually moved

	case tomStory:								// Largest Unit
		cch = (cUnit > 0) ? cchText - cp : -cp;	// cch to start of story
		cUnit = cch ? iDir : 0;					// If already at end/start,
		break;									//  of story, no count

	case tomCharFormat:							// Constant CHARFORMAT
		cch = _rpCF.CountRuns(cUnit, cchMax, cp, cchText);
		break;

	case tomParaFormat:							// Constant PARAFORMAT
		cch = _rpPF.CountRuns(cUnit, cchMax, cp, cchText);
		break;

	case tomObject:
		if(!GetObjectCount())					// No objects: can't move, so
		{
			cUnit = 0;							//  set cUnit = 0 and
			return tomBackward;					//  signal Unit unavailable
		}
		cch = GetPed()->_pobjmgr->CountObjects(cUnit, GetCp());
		break;

	case tomLine:
		pdp = GetPed()->_pdp;
		if(pdp)									// If this story has a display
		{										//  use a CLinePtr
			CLinePtr rp(pdp);
			pdp->WaitForRecalc(cp, -1);
			rp.RpSetCp(cp, FALSE);
			cch = rp.CountRuns(cUnit, cchMax, cp, cchText);
			break;
		}										// Else fall thru to treat as
												//  tomPara
	default:									// tp dependent cases
	  {											// Block to contain tp() which
		CTxtPtr tp(_rpTX);						//  takes time to construct

		if (cUnit < 0)							// Counting backward
		{
			action = (Unit == tomWord)
				? WB_MOVEWORDLEFT : tomBackward;
		}
		else									// Counting forward
		{
			action = (Unit == tomWord)
				? WB_MOVEWORDRIGHT : tomForward;
		}
	
		for (cch = 0, j = cUnit; j && abs(cch) < cchMax; j -= iDir)
		{
			cp = tp.GetCp();					// Save starting cp for
			switch (Unit)						//  calculating cch for this
			{									//  Unit
			case tomWord:
				tp.FindWordBreak(action);
				break;
	
			case tomSentence:
				tp.FindBOSentence(action);
				break;
		
			case tomLine:						// Story has no line array:
			case tomParagraph:					//  treat as tomParagraph
				tp.FindEOP(action);
				break;
		
			default:
				cUnit = 0;
				return tomForward;				// Return error
			}
			if(tp.GetCp() - cp == 0)			// No count:
				break;							//  don't decrement cUnit
			cch += tp.GetCp() - cp;
		}
		cUnit -= j;								// Discount any runs not
	  }											//  counted if |cch| >= cchMax
	}

	if(abs(cch) > cchMax)						// Keep cch within requested
	{											//  limit
		cch = cch > 0 ? cchMax : -cchMax;
		if(Unit == tomCharacter)
			cUnit = cch;
	}		

	Advance(cch);								// Move to new position
	return cch;									// Total cch counted
}

/*
 *	CRchTxtPtr::GetParaNumber ()
 *
 *	@mfunc
 *		Return number of current paragraph in a numbered list. This is
 *		0 if the current paragraph isn't part of a list. It's 1 if it's
 *		the first paragraph in a list, 2 if it's the second, etc.
 *
 *	@rdesc
 *		paragraph number active at this rich text ptr
 *
 *	@devnote
 *		When the display is calc'd from the beginning or recalc'd from
 *		a previous valid position, the list number can be determined from
 *		the display.  But if CDisplayPrinter::FormatRange() works without
 *		a display, it needs to know the number.  This routine can be so used
 *		for this purpose and for debugging the display choices.
 */
LONG CRchTxtPtr::GetParaNumber() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::GetParaNumber");

	LONG		 ch;
	LONG		 cPara = 0;
	LONG		 n;
	const CParaFormat *pPF, *pPFLast = NULL;
	CRchTxtPtr	 rtp(*this);

	while(1)
	{
		pPF = rtp.GetPF();
		// CParaFormat::UpdateNumber(2, pPFLast) returns:
		//		0 -- not a numbered list
		//		1 -- new numbered list or pPFLast = NULL
		//		2 -- list number suppressed
		//		3 -- different number in same list
		n = pPF->UpdateNumber(2, pPFLast);
		if(n == 0 || n == 1 && pPFLast && cPara)
			break;
		ch = rtp.GetPrevChar();
		if((!ch || IsASCIIEOP(ch) && ch != VT) && n != 2)
			cPara++;
		if(!ch)
			break;
		rtp._rpPF.AdvanceCp(rtp._rpTX.FindEOP(tomBackward));	
		pPFLast = pPF;						// Don't need to update _rpCF
	}										//  for this calculation
	return cPara;
}

/*
 *	Notes on RichEdit 1.0 mode:
 *
 *	CF_UNICODETEXT should not be used in RichEdit 1.0 mode.  \uN should use
 *	the alternative.
 *
 *	CleanseAndReplaceRange() and the RTF reader need to ensure that any
 *	Unicode chars entered belong to a CharSet and stamp it accordingly.
 *	If no CharSet exists for the character, then blank should be used.
 */

/*
 *	CRchTxtPtr::GetCachFromCch(cch)
 *
 *	@mfunc
 *		Return count of A chars corresponding to cch W chars starting at
 *		this text ptr.  On first call start with this text ptr at cp = 0.
 *
 *	@rdesc
 *		Count of A chars between this text ptr and cp
 *
 *	@comm
 *		The algorithm assumes that for a DBCS charset any character
 *		above 128 has two bytes, except for the halfwidth KataKana,
 *		which are single bytes in ShiftJis.
 */
LONG CRchTxtPtr::GetCachFromCch(
	LONG cch)		//@parm Count of chars to check
{
	BYTE		 bCharSet;
	LONG		 cach = 0;				// No ach counted yet
	LONG		 cch1;
	LONG		 cchRun;				// CF run count
	LONG		 cchValid;				// Text run count
	WCHAR		 ch;
	const WCHAR *pch;					// Ptr to text run
	const CCharFormat *pCF;

	while(cch > 0)
	{
		cchRun = _rpCF.IsValid()
			   ? _rpCF.GetCchLeft()
			   : GetTextLength() - GetCp();
		if(!cchRun)
			break;						// No more text
		pCF		 = GetCF();
		bCharSet = pCF->_bCharSet;
		if (!IsFECharSet(bCharSet) ||
			(pCF->_dwEffects & CFE_RUNISDBCS))
		{
			cchRun = min(cchRun, cch);
			cach  += cchRun;			// SBCS run or DBCS stored as
			cch   -= cchRun;			//  one byte per char
			Advance(cchRun);
			continue;
		}
		pch = GetPch(cchValid);
		Assert(pch);
		cchValid = min(cchValid, cchRun);
		for(cch1 = 0; cch > 0 && cchValid--; cch1++)
		{
			cch--;
			ch = *pch++;
			if(ch >= 128 && ch != WCH_EMBEDDING &&
				(bCharSet != SHIFTJIS_CHARSET || !IN_RANGE(0xFF61, ch, 0xFF9F)))
			{
				cach++;
			}
		}
		cach += cch1;
		Advance(cch1);
	}
	return cach;
}

/*
 *	CRchTxtPtr::GetCchFromCach(cach)
 *
 *	@mfunc
 *		Return count of W chars corresponding to cach A chars starting at this
 *		text ptr. On first call start with this text ptr at cp = 0.
 *
 *	@rdesc
 *		Count of W chars corresponding to cach A chars starting at this tp.
 *
 *	@comm
 *		The algorithm assumes that for a DBCS charset any character
 *		above 128 has two bytes, except for the halfwidth KataKana,
 *		which are single bytes in ShiftJis.
 */
LONG CRchTxtPtr::GetCchFromCach(
	LONG cach)		//@parm Count of ach's starting at this text ptr
{
	BYTE		 bCharSet;
	LONG		 cch = 0;				// No ch's yet
	LONG		 cch1;
	LONG		 cchRun;				// CF run count
	LONG		 cchValid;				// Text run count
	WCHAR		 ch;
	const WCHAR *pch;					// Ptr to text run
	const CCharFormat *pCF;

	while(cach > 0)
	{
		cchRun = _rpCF.IsValid()
			   ? _rpCF.GetCchLeft()
			   : GetTextLength() - GetCp();
		if(!cchRun)
			break;						// No more text
		pCF		 = GetCF();
		bCharSet = pCF->_bCharSet;
		if (!IsFECharSet(bCharSet) ||
			(pCF->_dwEffects & CFE_RUNISDBCS))
		{
			cchRun = min(cchRun, cach);	// SBCS run or DBCS stored as
			cach -= cchRun;				//  one byte per char
			cch  += cchRun;
			Advance(cchRun);
			continue;
		}
		pch = GetPch(cchValid);
		Assert(pch);
		cchValid = min(cchValid, cchRun);
		for(cch1 = 0; cach > 0 && cchValid--; cch1++)
		{
			cach--;
			ch = *pch++;
			if(ch >= 128 && ch != WCH_EMBEDDING &&
				(bCharSet != SHIFTJIS_CHARSET || !IN_RANGE(0xFF61, ch, 0xFF9F)))
			{
				cach--;
			}
		}
		cch += cch1;
		Advance(cch1);
	}
	return cch;
}

/*
 *	CRchTxtPtr::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie by NULLing out its _ped member
 */
void CRchTxtPtr::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRchTxtPtr::Zombie");

	_rpTX.Zombie();
	_rpCF.SetToNull();
	_rpPF.SetToNull();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\rtflog.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	RTFLOG.CPP - RichEdit RTF log
 *
 *		Contains the code for the RTFLog class which can be used 
 *		to log the number of times RTF tags are read by the RTF reader
 *		for use in coverage testing
 *
 *	Authors:<nl>
 *		Created for RichEdit 2.0:	Brad Olenick
 *
 *	Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtflog.h"
#include "tokens.h"

extern INT cKeywords;
extern const KEYWORD rgKeyword[];

/*
 *	CRTFLog::CRTFLog()
 *	
 *	@mfunc
 *		Constructor - 
 *			1.  Opens a file mapping to log hit counts, creating
 *					the backing file if neccessary
 *			2.  Map a view of the file mapping into memory
 *			3.  Register a windows message for change notifications
 *
 */
CRTFLog::CRTFLog() : _rgdwHits(NULL), _hfm(NULL), _hfile(NULL)
{
#ifndef PEGASUS
	const char cstrMappingName[] = "RTFLOG";
	const char cstrWM[] = "RTFLOGWM";
	const int cbMappingSize = sizeof(ELEMENT) * ISize();

	BOOL fNewFile = FALSE;

	// check for existing file mapping
	if(!(_hfm = OpenFileMappingA(FILE_MAP_ALL_ACCESS,
								TRUE,
								cstrMappingName)))
	{
		// no existing file mapping

		// get the file with which to create the file mapping

		// first, attempt to open an existing file
		if(!(_hfile = CreateFileA(LpcstrLogFilename(),
								GENERIC_READ | GENERIC_WRITE,
								0,
								NULL,
								OPEN_EXISTING,
								FILE_ATTRIBUTE_NORMAL,
								NULL)))
		{
			// no existing file, attempt to create new
			if(!(_hfile = CreateFileA(LpcstrLogFilename(),
										GENERIC_READ | GENERIC_WRITE,
										0,
										NULL,
										OPEN_ALWAYS,
										FILE_ATTRIBUTE_NORMAL,
										NULL)))
			{
				return;
			}

			fNewFile = TRUE;
		}

		if(!(_hfm = CreateFileMappingA(_hfile,
									NULL,
									PAGE_READWRITE,
									0,
									cbMappingSize,
									cstrMappingName)))
		{
			return;
		}
	}

	LPVOID lpv;
	if(!(lpv = MapViewOfFile(_hfm, 
							FILE_MAP_ALL_ACCESS, 
							0,
							0,
							cbMappingSize)))
	{
		return;
	}

	// register windows message for change notifications
	SideAssert(_uMsg = RegisterWindowMessageA(cstrWM));

	// memory-mapped file is now mapped to _rgdwHits
	_rgdwHits = (PELEMENT)lpv;

	// zero the memory-mapped file if we created it new
	// (Win95 gives us a new file w/ garbage in it for some reason)
	if(fNewFile)
	{
		Reset();
	}		
#endif	
}


/*
 *	CRTFLog::Reset()
 *	
 *	@mfunc
 *		Resets the hitcount of each element in the log to 0
 *
 */
void CRTFLog::Reset()
{
	if(!FInit())
	{
		return;
	}

	for(INDEX i = 0; i < ISize(); i++)
	{
		(*this)[i] = 0;
	}

	// notify clients of change
	ChangeNotifyAll();
}


/*
 *	CRTFLog::UGetWindowMsg
 *
 *	@mdesc
 *		Returns the window message id used for change notifications
 *
 *	@rdesc
 *		UINT		window message id
 *
 *	@devnote
 *		This should be inline, but the AssertSz macro doesn't compile
 *		properly on the Mac if its placed in a header file
 *
 */
UINT CRTFLog::UGetWindowMsg() const
{
	AssertSz(FInit(), "CRTFLog::UGetWindowMsg():  CRTFLog not initialized properly");

	return _uMsg;
}


/*
 *	CRTFLog::operator[]
 *
 *	@mdesc
 *		Returns reference to element i of RTF log (l-value)
 *
 *	@rdesc
 *		ELEMENT &			reference to element i of log
 *
 *	@devnote
 *		This should be inline, but the AssertSz macro doesn't compile
 *		properly on the Mac if its placed in a header file
 *
 */
CRTFLog::ELEMENT &CRTFLog::operator[](INDEX i)
{
	AssertSz(i < ISize(), "CRTFLog::operator[]:  index out of range");
	AssertSz(FInit(), "CRTFLog::operator[]:  CRTFLog not initialized properly");

	return _rgdwHits[i]; 
}


/*
 *	CRTFLog::operator[]
 *
 *	@mdesc
 *		Returns reference to element i of RTF log (r-value)
 *
 *	@rdesc
 *		const ELEMENT &	reference to element i of log
 *		
 *	@devnote
 *		This should be inline, but the AssertSz macro doesn't compile
 *		properly on the Mac if its placed in a header file
 *
 */
const CRTFLog::ELEMENT &CRTFLog::operator[](INDEX i) const
{
	AssertSz(i < ISize(), "CRTFLog::operator[]:  index out of range");
	AssertSz(FInit(), "CRTFLog::operator[]:  CRTFLog not initialized properly");

	return _rgdwHits[i]; 
}


/*
 *	CRTFLog::LpcstrLogFilename()
 *	
 *	@mfunc
 *		Returns name of file to be used for log
 *
 *	@rdesc
 *		LPCSTR		pointer to static buffer containing file name
 */
LPCSTR CRTFLog::LpcstrLogFilename() const
{
	const char cstrLogFilename[] = "RTFLOG";
	static char szBuf[MAX_PATH] = "";
#ifndef PEGASUS
	if(!szBuf[0])
	{
		DWORD cchLength;
		char szBuf2[MAX_PATH];

		SideAssert(cchLength = GetTempPathA(MAX_PATH, szBuf2));

		// append trailing backslash if neccessary
		if(szBuf2[cchLength - 1] != '\\')
		{
			szBuf2[cchLength] = '\\';
			szBuf2[cchLength + 1] = 0;
		}

		wsprintfA(szBuf, "%s%s", szBuf2, cstrLogFilename);
	}
#endif
	return szBuf;
}


/*
 *	CRTFLog::IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX piIndex)
 *	
 *	@mfunc
 *		Returns the index of the log element which corresponds to
 *		the RTF keyword, lpcstrKeyword
 *
 *	@rdesc
 *		BOOL		flag indicating whether index was found
 */
BOOL CRTFLog::IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX piIndex) const
{
	INDEX i;

	for(i = 0; i < ISize(); i++)
	{
		if(strcmp(lpcstrKeyword, rgKeyword[i].szKeyword) == 0)
		{
			break;
		}
	}

	if(i == ISize())
	{
		return FALSE;
	}

	if(piIndex)
	{
		*piIndex = i;
	}

	return TRUE;
}


/*
 *	CRTFLog::IIndexOfToken(TOKEN token, PINDEX piIndex)
 *	
 *	@mfunc
 *		Returns the index of the log element which corresponds to
 *		the RTF token, token
 *
 *	@rdesc
 *		BOOL		flag indicating whether index was found
 */
BOOL CRTFLog::IIndexOfToken(TOKEN token, PINDEX piIndex) const
{
	INDEX i;

	for(i = 0; i < ISize(); i++)
	{
		if(token == rgKeyword[i].token)
		{
			break;
		}
	}

	if(i == ISize())
	{
		return FALSE;
	}

	if(piIndex)
	{
		*piIndex = i;
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\rtflex.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module RTFLEX.CPP - RichEdit RTF reader lexical analyzer |
 *
 *		This file contains the implementation of the lexical analyzer part of
 *		the RTF reader.
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent <nl>
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfread.h"
#include "hash.h"

ASSERTDATA

#include "tokens.cpp"

// Array used by character classification macros to speed classification
// of chars residing in two or more discontiguous ranges, e.g., alphanumeric
// or hex.  The alphabetics used in RTF control words are lower-case ASCII.
// *** DO NOT DBCS rgbCharClass[] ***

#define	fCS		fCT + fSP
#define fSB		fBL + fSP
#define fHD		fHX + fDG
#define	fHU		fHX + fUC
#define	fHL		fHX + fLC

const BYTE rgbCharClass[256] =
{
	fCT,fCT,fCT,fCT,fCT,fCT,fCT,fCT, fCT,fCS,fCS,fCS,fCS,fCS,fCT,fCT,
	fCT,fCT,fCT,fCT,fCT,fCT,fCT,fCT, fCT,fCT,fCT,fCT,fCT,fCT,fCT,fCT,
	fSB,fPN,fPN,fPN,fPN,fPN,fPN,fPN, fPN,fPN,fPN,fPN,fPN,fPN,fPN,fPN,
	fHD,fHD,fHD,fHD,fHD,fHD,fHD,fHD, fHD,fHD,fPN,fPN,fPN,fPN,fPN,fPN,

	fPN,fHU,fHU,fHU,fHU,fHU,fHU,fUC, fUC,fUC,fUC,fUC,fUC,fUC,fUC,fUC,
	fUC,fUC,fUC,fUC,fUC,fUC,fUC,fUC, fUC,fUC,fUC,fPN,fPN,fPN,fPN,fPN,
	fPN,fHL,fHL,fHL,fHL,fHL,fHL,fLC, fLC,fLC,fLC,fLC,fLC,fLC,fLC,fLC,
	fLC,fLC,fLC,fLC,fLC,fLC,fLC,fLC, fLC,fLC,fLC,fPN,fPN,fPN,fPN,fPN,

	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,

	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0,
};

const char szRTFSig[] = "rtf";
#define cchRTFSig   3
#define cbRTFSig    (cchRTFSig * sizeof(char))

// Specifies the number of bytes we can safely "UngetChar"
// before possibly underflowing the buffer.
const int cbBackupMax = 4;

// Bug2298 - I found an RTF writer which emits uppercase RTF keywords,
// 			so I had to change IsLCAscii to IsAlphaChar for use in scanning
//			for RTF keywords.
inline BOOL IsAlphaChar(BYTE b)
{
	return IN_RANGE('a', b, 'z') || IN_RANGE('A', b, 'Z');
}

// Quick and dirty tolower(b)
inline BYTE REToLower(BYTE b)
{
	Assert(!b || IsAlphaChar(b));
	return b ? (BYTE)(b | 0x20) : 0;
}

extern BOOL IsRTF(char *pstr);

BOOL IsRTF(
	char *pstr)
{
	if(!pstr || *pstr++ != '{' || *pstr++ != '\\')
		return FALSE;					// Quick out for most common cases

	if(*pstr == 'u')					// Bypass u of possible urtf
		pstr++;

	return !CompareMemory(szRTFSig, pstr, cbRTFSig);
}

/*
 *	CRTFRead::InitLex()
 *
 *	@mfunc
 *		Initialize the lexical analyzer. Reset the variables. if reading in
 *		from resource file, sort the keyword list (). Uses global hinstRE
 *		from the RichEdit to find out where its resources are.  Note: in
 *		RichEdit 2.0, currently the resource option is not supported.
 *
 *	@rdesc
 *		TRUE				If lexical analyzer was initialized
 */
BOOL CRTFRead::InitLex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::InitLex");

	AssertSz(cKeywords == i_TokenIndexMax,
		"Keyword index enumeration is incompatible with rgKeyword[]");
	Assert(!_szText && !_pchRTFBuffer);

	// Allocate our buffers with an extra byte for szText so that hex
	// conversion doesn't have to worry about running off the end if the
	// first char is NULL
	if ((_szText	   = (BYTE *)PvAlloc(cachTextMax + 1, GMEM_ZEROINIT)) &&
		(_pchRTFBuffer = (BYTE *)PvAlloc(cachBufferMost, GMEM_ZEROINIT)))
	{
		return TRUE;					// Signal that lexer is initialized
	}

	_ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecLexInitFailed;
	return FALSE;
}

/*
 *	CRTFRead::DeinitLex()
 *
 *	@mfunc
 *		Shut down lexical analyzer
 */
void CRTFRead::DeinitLex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::DeinitLex");

#ifdef KEYWORD_RESOURCE
	if (hglbKeywords)
	{
		FreeResource(hglbKeywords);
		hglbKeywords = NULL;
		rgKeyword = NULL;
	}
#endif

	FreePv(_szText);
	FreePv(_pchRTFBuffer);
}

/*
 *	CRTFRead::GetChar()
 *	
 *	@mfunc
 *		Get next char, filling buffer as needed
 *	
 *	@rdesc
 *		BYTE			nonzero char value if success; else 0
 */
BYTE CRTFRead::GetChar()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetChar");

	if (_pchRTFCurrent == _pchRTFEnd && !FillBuffer())
	{
		_ecParseError = ecUnexpectedEOF;
		return 0;
	}
	return *_pchRTFCurrent++;
}

/*
 *	CRTFRead::FillBuffer()
 *
 *	@mfunc
 *		Fill RTF buffer & return != 0 if successful
 *
 *	@rdesc
 *		LONG			# chars read
 *
 *	@comm
 *		This routine doesn't bother copying anything down if
 *		pchRTFCurrent <lt> pchRTFEnd so anything not read yet is lost.
 *		The only exception to this is that it always copies down the
 *		last two bytes read so that UngetChar() will work. ReadData()
 *		actually counts on this behavior, so if you change it, change
 *		ReadData() accordingly.
 */
LONG CRTFRead::FillBuffer()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::FillBuffer");

	LONG cchRead;

	if (!_pchRTFCurrent)				
	{									
		// No data yet, nothing for backup
		// Leave cbBackupMax NULL chars so backup
		// area of buffer doesn't contain garbage.

		for(int i = 0; i < cbBackupMax; i++)
		{
			_pchRTFBuffer[i] = 0;
		}
	}
	else
	{
		Assert(_pchRTFCurrent == _pchRTFEnd);

		// Copy most recently read chars in case
		//  we need to back up

		int cbBackup = min((UINT) cbBackupMax, DiffPtrs(_pchRTFCurrent, &_pchRTFBuffer[cbBackupMax])); 
		int i;

		for(i = -1; i >= -cbBackup; i--)
			_pchRTFBuffer[cbBackupMax + i] = _pchRTFCurrent[i];

		if(cbBackup < cbBackupMax)
		{
			// NULL before the first valid character in the backup buffer
			_pchRTFBuffer[cbBackupMax + i] = 0;
		}
	}
	_pchRTFCurrent = &_pchRTFBuffer[cbBackupMax];

	// Fill buffer with as much as we can take given our starting offset
	_pes->dwError = _pes->pfnCallback(_pes->dwCookie,
									  _pchRTFCurrent,
									  cachBufferMost - cbBackupMax,
									  &cchRead);
	if (_pes->dwError)
	{
		TRACEERRSZSC("RTFLEX: GetChar()", _pes->dwError);
		_ecParseError = ecGeneralFailure;
		return 0;
	}

	_pchRTFEnd = &_pchRTFBuffer[cbBackupMax + cchRead];		// Point the end

#if defined(DEBUG) && !defined(MACPORT)
	if(_hfileCapture)
	{
		DWORD cbLeftToWrite = cchRead;
		DWORD cbWritten = 0;
		BYTE *pbToWrite = (BYTE *)_pchRTFCurrent;
		
		while(WriteFile(_hfileCapture,
						pbToWrite,
						cbLeftToWrite,
						&cbWritten,
						NULL) && 
						(pbToWrite += cbWritten,
						(cbLeftToWrite -= cbWritten)));
	}
#endif

	return cchRead;
}

/*
 *	CRTFRead::UngetChar()
 *
 *	@mfunc
 *		Bump our file pointer back one char
 *
 *	@rdesc
 *		BOOL				TRUE on success
 *
 *	@comm
 *		You can safely UngetChar _at most_ cbBackupMax times without
 *		error.
 */
BOOL CRTFRead::UngetChar()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::UngetChar");

	if (_pchRTFCurrent == _pchRTFBuffer || !_pchRTFCurrent)
	{
		Assert(0);
		_ecParseError = ecUnGetCharFailed;
		return FALSE;
	}

	--_pchRTFCurrent;
	return TRUE;
}

/*
 *	CRTFRead::UngetChar(cch)
 *
 *	@mfunc
 *		Bump our file pointer back 'cch' chars
 *
 *	@rdesc
 *		BOOL				TRUE on success
 *
 *	@comm
 *		You can safely UngetChar _at most_ cbBackupMax times without
 *		error.
 */
BOOL CRTFRead::UngetChar(UINT cch)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::UngetChar");

	AssertSz(cch <= cbBackupMax, "CRTFRead::UngetChar():  Number of UngetChar's "
								"exceeds size of backup buffer.");

	while(cch-- > 0)
	{
		if(!UngetChar())
			return FALSE;
	}

	return TRUE;
}

/*
 *	CRTFRead::GetHex()
 *
 *	@mfunc
 *		Get next char if hex and return hex value
 *		If not hex, leave char in buffer and return 255
 *
 *	@rdesc
 *		BYTE			hex value of GetChar() if hex; else 255
 */
BYTE CRTFRead::GetHex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetHex");

	BYTE ch = GetChar();

	if(IsXDigit(ch))
		return (BYTE)(ch <= '9' ? ch - '0' : (ch & 0x4f) - 'A' + 10);
	if(ch)
		UngetChar();
	return 255;
}

/*
 *	CRTFRead::GetHexSkipCRLF()
 *
 *	@mfunc
 *		Get next char if hex and return hex value
 *		If not hex, leave char in buffer and return 255
 *
 *	@rdesc
 *		BYTE			hex value of GetChar() if hex; else 255
 *
 *	@devnote
 *		Keep this in sync with GetHex above.
 */
BYTE CRTFRead::GetHexSkipCRLF()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetHexSkipCRLF");

	BYTE ch = GetChar();

	// Skip \r \n
	while(ch == CR || ch == LF)
		ch = GetChar(); 

	// Rest is same as CRTFRead::GetHex()
	if(IsXDigit(ch))
		return (BYTE)(ch <= '9' ? ch - '0' : (ch & 0x4f) - 'A' + 10);
	if(ch)
		UngetChar();
	return 255;
}

/*
 *	CRTFRead::TokenGetHex()
 *
 *	@mfunc
 *		Get an 8 bit character saved as a 2 hex digit value
 *
 *	@rdesc
 *		TOKEN			value of hex number read in
 */
TOKEN CRTFRead::TokenGetHex()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetHex");

	BYTE bChar0 = GetHex();
	BYTE bChar1;

	if(bChar0 < 16 && (bChar1 = GetHex()) < 16)
		_token = (WORD)(bChar0 << 4 | bChar1);
	else
		_token = tokenError;

	return _token;
}

/*
 *	CRTFRead::SkipToEndOfGroup()
 *
 *	@mfunc
 *		Skip to end of current group
 *
 *	@rdesc
 *		EC				An error code
 */
EC CRTFRead::SkipToEndOfGroup()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::SkipToEndOfGroup");

	INT		nDepth = 1;
	BYTE	ach;

	while(TRUE)
	{
		ach = GetChar();
		switch(ach)
		{
			case BSLASH:
			{
				BYTE achNext = GetChar();

				// EOF: goto done; else ignore NULLs
				if(!achNext && _ecParseError == ecUnexpectedEOF)
					goto done;

				if(achNext == 'b' && UngetChar() && 
					TokenGetKeyword() == tokenBinaryData)
				{
					// We've encountered the \binN tag in the RTF we want
					//	to skip.  _iParam contains N from \binN once the 
					// 	tag is parsed by TokenGetKeyword()
					SkipBinaryData(_iParam);
				}
				break;
			}

			case LBRACE:
				nDepth++;
				break;

			case RBRACE:
				if (--nDepth <= 0)
					goto done;
				break;

			case 0:
				if(_ecParseError == ecUnexpectedEOF)
					goto done;

			default:
				// Detect Lead bytes here.
				int cTrailBytes = GetTrailBytesCount(ach, _nCodePage);
				if (cTrailBytes)
				{
					for (int i = 0; i < cTrailBytes; i++)
					{
						ach = GetChar();
						if(ach == 0 && _ecParseError == ecUnexpectedEOF)
							goto done;			
					}
				}
				break;
		}
	} 

	Assert(!_ecParseError);
	_ecParseError = ecUnexpectedEOF;

done:
	return _ecParseError;
}

/*
 *	CRTFRead::TokenFindKeyword(szKeyword)
 *
 *	@mfunc
 *		Find keyword <p szKeyword> and return its token value
 *
 *	@rdesc
 *		TOKEN			token number of keyword
 */
TOKEN CRTFRead::TokenFindKeyword(
	BYTE *	szKeyword)			// @parm Keyword to find
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenFindKeyword");

	INT				iMin;
	INT				iMax;
	INT				iMid;
	INT				nComp;
	BYTE *			pchCandidate;
	BYTE *			pchKeyword;
	const KEYWORD *	pk;

	AssertSz(szKeyword[0],
		"CRTFRead::TokenFindKeyword: null keyword");

#ifdef RTF_HASHCACHE
	if ( _rtfHashInited )
	{
		// Hash is 23% faster than the following binary search on finds
		//  and 55% faster on misses: For 97 words stored in a 257 cache.
		//  Performance numbers will change when the total stored goes up.
		pk = HashKeyword_Fetch ( (CHAR *) szKeyword );
	}
	else
#endif
	{
		iMin = 0;
		iMax = cKeywords - 1;
		pk = NULL;
		do				// Note (MS3): Hash would be quicker than binary search
		{
			iMid		 = (iMin + iMax) / 2;
			pchCandidate = (BYTE *)rgKeyword[iMid].szKeyword;
			pchKeyword	 = szKeyword;
			while (!(nComp = REToLower(*pchKeyword) - *pchCandidate)	// Be sure to match
				&& *pchKeyword)											//  terminating 0's
			{
				pchKeyword++;
				pchCandidate++;
			}
			if (nComp < 0)
				iMax = iMid - 1;
			else if (nComp)
				iMin = iMid + 1;
			else
			{
				pk = &rgKeyword[iMid];
				break;
			}
		} while (iMin <= iMax);
	}


	if(pk)
	{
		_token = pk->token;
		
		// here, we log the RTF keyword scan to aid in tracking RTF tag ocverage
// TODO: Implement RTF tag logging for the Mac and WinCE
#if defined(DEBUG) && !defined(MACPORT) && !defined(PEGASUS)
		if(_prtflg) 
		{
#ifdef RTF_HASCACHE
			_prtflg->AddAt(szKeyword); 
#else
			_prtflg->AddAt((size_t)iMid);
#endif
		}
#endif
	}
	else
		_token = tokenUnknownKeyword;		// No match: TODO: place to take

	return _token;				 			//  care of unrecognized RTF
}

/*
 *	CRTFRead::TokenGetKeyword()
 *
 *	@mfunc
 *		Collect a keyword and its parameter. Return token's keyword
 *
 *	@rdesc
 *		TOKEN				token number of keyword
 *
 *	@comm
 *		Most RTF control words (keywords) consist of a span of lower-case
 *		ASCII letters possibly followed by a span of decimal digits. Other
 *		control words consist of a single character that isn't LC ASCII. No
 *		control words contain upper-case characters.
 */
TOKEN CRTFRead::TokenGetKeyword()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetKeyword");

	BYTE		ach = GetChar();
	BYTE		*pach;
	SHORT		cachKeyword = 1;
	BYTE		szKeyword[cachKeywordMax];

	_szParam[0] = '\0';							// Clear parameter
	_iParam = 0;

	if(!IsAlphaChar(ach))						// Not alpha, i.e.,
	{											//  single char
		if (ach == '\'')						// Most common case needs
		{										//  special treatment
			// Convert hex to char and store result in _token
			if(TokenGetHex() == tokenError)
			{							
				_ecParseError = ecUnexpectedChar;
				goto TokenError;
			}
			if((_token == CR || _token == LF) && FInDocTextDest())
			{
				// Add raw CR or LF in the byte stream as a \par
				return tokenEndParagraph;
			}
		}
		else
		{	
			// Check for other known symbols
			const BYTE *pachSym = szSymbolKeywords;
			
			while(ach != *pachSym && *pachSym)
				pachSym++;
			if(*pachSym)						// Found one
			{
				_token = tokenSymbol[pachSym - szSymbolKeywords];
				if(_token > 0x7F)				// Token or larger Unicode
					return _token;				//  value
			}
			else if (!ach)						// No more input chars
				goto TokenError;
			else								// Code for unrecognized RTF
				_token = ach;					// We'll just insert it for now 
		}
		_token = TokenGetText((BYTE)_token);
		return _token; 
	}

	szKeyword[0] = ach;							// Collect keyword that starts
	pach = szKeyword + 1;						// 	with ASCII
	while (cachKeyword < cachKeywordMax &&
		   IsAlphaChar(ach = GetChar()))
	{
		cachKeyword++;
		*pach++ = ach;
	}

	if (cachKeyword == cachKeywordMax)
	{
		_ecParseError = ecKeywordTooLong;
		goto TokenError;
	}
	*pach = '\0';								// Terminate keyword

	if (IsDigit(ach) || ach == '-')				// Collect parameter
	{
		BYTE *pachEnd = _szParam + sizeof(_szParam);
		pach = _szParam;
		*pach++ = ach;
		if(ach != '-')
			_iParam = ach - '0';				// Get parameter value

		while (IsDigit(ach = GetChar()))
		{
			_iParam = _iParam*10 + ach - '0';
			*pach++ = ach;
			if (pach >= pachEnd)
			{
				_ecParseError = ecKeywordTooLong;
				goto TokenError;
			}
		}
		*pach = '\0';							// Terminate parameter string
		if (_szParam[0] == '-')
			_iParam = -_iParam;
	}

	if (!_ecParseError &&						// We overshot:
		(ach == ' ' || UngetChar()))			//  if not ' ', unget char
			return TokenFindKeyword(szKeyword);	// Find and return keyword

TokenError:
	TRACEERRSZSC("TokenGetKeyword()", _ecParseError);
	return _token = tokenError;
}

/*
 *	CRTFRead::TokenGetText(ach)
 *
 *	@mfunc
 *		Collect a string of text starting with the char <p ach> and treat as a
 *		single token. The string ends when a LBRACE, RBRACE, or single '\\' is found.
 *
 *	@devnote
 *		We peek past the '\\' for \\'xx, which we decode and keep on going;
 *		else we return in a state where the next character is the '\\'.
 *
 *	@rdesc
 *		TOKEN			Token number of next token (tokenText or tokenError)
 */
TOKEN CRTFRead::TokenGetText(
	BYTE ach)				// @parm First char of 8-bit text string
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetText");

	BYTE *	pach = _szText;
	SHORT	cachText = 0;
	LONG	CodePage = _pstateStackTop->nCodePage;
	BOOL	fAllASCII = TRUE;
	int		cTrailBytesNeeded = 0;

	_token = tokenError;						// Default error

	// FUTURE(BradO):  This 'goto' into a while loop is pretty weak.
	//	Restructure this 'while' loop such that the 'goto' is removed.

	// Add character passed into routine
	goto add;

	// If cTrailBytesNeeded is non-zero, we need to get all the trail bytes.  Otherwise,
	// a string end in the middle of a DBC or UTF-8 will cause bad display/print problem
	// - 5 to allow extra space for up to 4 bytes for UTF-8 and Null char
	while (cachText < cachTextMax - 5 || cTrailBytesNeeded)
	{
		ach = GetChar();
		switch (ach)
		{
			case BSLASH:
			{
				// FUTURE(BradO):  This code looks ALOT like TokenGetKeyword.
				//	We should combine the two into a common routine.

				BYTE achNext;

				// Get char after BSLASH
				achNext = GetChar();
				if(!achNext)
					goto error;
	
				if(achNext == '\'')					// Handle most frequent
				{									//  case here
					if(TokenGetHex() == tokenError)
					{
						if(cTrailBytesNeeded)
						{
							// The trail-byte must be a raw BSLASH.
							// Unget the single-quote.

							if(!UngetChar())
								goto error;
							// fall through to add BSLASH
						}
						else
						{
							_ecParseError = ecUnexpectedChar;
							goto error;
						}
					}
					else
					{
						ach = (BYTE)_token;
						if (cTrailBytesNeeded == 0 && (ach == CR || ach == LF) &&
							FInDocTextDest())
						{
							// Here, we have a raw CR or LF in document text.  
							// Unget the whole lot of characters and bail out.  
							// TokenGetKeyword will convert this CR or LF into
							// a \par.

							if(!UngetChar(4))
								goto error;
							goto done;
						}
					}
					goto add;
				}

				// Check next byte against list of RTF symbol
				// NOTE:- we need to check for RTF symbol even if we
				// are expecting a trail byte.  According to the rtf spec,
				// we cannot just take this backslash as trail byte.
				// HWC 9/97

				const BYTE *pachSymbol = szSymbolKeywords;			
				while(achNext != *pachSymbol && *pachSymbol)	
					pachSymbol++;

				TOKEN tokenTmp;

				if (*pachSymbol && 
					(tokenTmp = tokenSymbol[pachSymbol - szSymbolKeywords])
						 <= 0x7F)
				{
					ach = (BYTE)tokenTmp;
					goto add;
				}

				// In either of the last two cases below, we will want
				// to unget the byte following the BSLASH
				if(!UngetChar())
					goto error;

				if(cTrailBytesNeeded && !IsAlphaChar(achNext))
				{
					// In this situation, either this BSLASH begins the next 
					// RTF keyword or it is a raw BSLASH which is the trail 
					// byte for a DBCS character.

					// I think a fair assumption here is that if an alphanum
					// follows the BSLASH, that the BSLASH begins the next
					// RTF keyword.

					// add the raw BSLASH
					goto add;					
				}

				// Here, my guess is that the BSLASH begins the next RTF 
				// keyword, so unget the BSLASH
			    if(!UngetChar())
					goto error;					

				goto done;
			}

			case LBRACE:						// End of text string
			case RBRACE:
				if(cTrailBytesNeeded)
				{
					// Previous char was a lead-byte of a DBCS pair or UTF-8, which
					// makes this char a raw trail-byte.
					goto add;
				}

				if(!UngetChar())				// Unget delimeter
					goto error;
				goto done;

			case LF:							// Throw away noise chars
			case CR:
				break;

			case 0:
				if(_ecParseError == ecUnexpectedEOF)
					goto done;
				ach = ' ';						// Replace NULL by blank

			default:							// Collect chars
add:
				// Outstanding chars to be skipped after \uN tag
				if(_cbSkipForUnicode)
				{
					_cbSkipForUnicode--;
					continue;
				}

				*pach++ = ach;
				++cachText;
				if(ach > 0x7F)
					fAllASCII = FALSE;
	
				// Check if we are expecting more trail bytes
				if (cTrailBytesNeeded)
					cTrailBytesNeeded--;
				else
					cTrailBytesNeeded = GetTrailBytesCount(ach, CodePage);
				Assert(cTrailBytesNeeded >= 0);
		}
	}

done:
	_token = (WORD)(fAllASCII ? tokenASCIIText : tokenText);
	*pach = '\0';								// Terminate token string

error:
	return _token;
}
 
/*
 *	CRTFRead::TokenGetToken()
 *
 *	@mfunc
 *		This function reads in next token from input stream
 *
 *	@rdesc
 *		TOKEN				token number of next token
 */
TOKEN CRTFRead::TokenGetToken()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::TokenGetToken");

	BYTE		ach;

	_tokenLast	= _token;					// Used by \* destinations and FE
	_token = tokenEOF;						// Default end-of-file

SkipNoise:
	ach = GetChar();
	switch (ach)
	{
	case CR:
	case LF:
		goto SkipNoise;

	case LBRACE:
		_token = tokenStartGroup;
		break;

	case RBRACE:
		_token = tokenEndGroup;
		break;

	case BSLASH:
		_token = TokenGetKeyword();
		break;

	case 0:									
		if(_ecParseError == ecUnexpectedEOF)
			break;
		ach = ' ';							// Replace NULL by blank
											// Fall thru to default
	default:
		if( !_pstateStackTop )
		{
			TRACEWARNSZ("Unexpected token in rtf file");
			Assert(_token == tokenEOF);
			if (_ped->Get10Mode())
				_ecParseError = ecUnexpectedToken;	// Signal bad file
		}
		else if (_pstateStackTop->sDest == destObjectData || 
				 _pstateStackTop->sDest == destPicture )
		// not text but data
		{
			_token = (WORD)(tokenObjectDataValue + _pstateStackTop->sDest
							- destObjectData);
			UngetChar();
		}
		else
			_token = TokenGetText(ach);
	}
	return _token;
}


/*
 *	CRTFRead::FInDocTextDest()
 *
 *	@mfunc
 *		Returns a BOOL indicating if the current destination is one in which
 *		we would encounter document text.
 *
 *	@rdesc
 *		BOOL	indicates the current destination may contain document text.
 */
BOOL CRTFRead::FInDocTextDest() const
{
	switch(_pstateStackTop->sDest)
	{
		case destRTF:
		case destField:
		case destFieldResult:
		case destFieldInstruction:
		case destParaNumbering:
		case destParaNumText:
		case destNULL:
			return TRUE;

		case destFontTable:
		case destRealFontName:
		case destObjectClass:
		case destObjectName:
		case destFollowingPunct:
		case destLeadingPunct:
		case destColorTable:
		case destBinary:
		case destObject:
		case destObjectData:
		case destPicture:
		case destDocumentArea:
			return FALSE;
	
		default:
			AssertSz(0, "CRTFRead::FInDocTextDest():  New destination "
							"encountered - update enum in _rtfread.h");
			return TRUE;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\rtfread.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module RTFREAD.CPP - RichEdit RTF reader (w/o objects) |
 *
 *      This file contains the nonobject code of RichEdit RTF reader.
 *      See rtfread2.cpp for embedded-object code.
 *
 *  Authors:<nl>
 *      Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *      Conversion to C++ and RichEdit 2.0 w/o objects:  Murray Sargent
 *      Lots of enhancements/maintenance: Brad Olenick
 *
 *  @devnote
 *      All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *      noted as a szW.
 *
 *  @todo
 *      1. Unrecognized RTF. Also some recognized won't round trip <nl>
 *      2. In font.c, add overstrike for CFE_DELETED and underscore for
 *          CFE_REVISED.  Would also be good to change color for CF.bRevAuthor
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfread.h"
#include "_util.h"
#include "_font.h"
#include "_disp.h"

ASSERTDATA

/*
 *      Global Variables
 */

#define PFM_ALLRTF      (PFM_ALL2 | PFM_COLLAPSED | PFM_OUTLINELEVEL | PFM_BOX)

// for object attachment placeholder list
#define cobPosInitial 8
#define cobPosChunk 8

#if CFE_SMALLCAPS != 0x40 || CFE_ALLCAPS != 0x80 || CFE_HIDDEN != 0x100 \
 || CFE_OUTLINE != 0x200  || CFE_SHADOW != 0x400
#error "Need to change RTF char effect conversion routines
#endif

// for RTF tag coverage testing
#if defined(DEBUG)
#define TESTPARSERCOVERAGE() \
    { \
        if(GetProfileIntA("RICHEDIT DEBUG", "RTFCOVERAGE", 0)) \
        { \
            TestParserCoverage(); \
        } \
    }
#define PARSERCOVERAGE_CASE() \
    { \
        if(_fTestingParserCoverage) \
        { \
            return ecNoError; \
        } \
    }
#define PARSERCOVERAGE_DEFAULT() \
    { \
        if(_fTestingParserCoverage) \
        { \
            return ecStackOverflow; /* some bogus error */ \
        } \
    }
#else
#define TESTPARSERCOVERAGE()
#define PARSERCOVERAGE_CASE()
#define PARSERCOVERAGE_DEFAULT()
#endif


// FF's should not have paragraph number prepended to them
inline BOOL CharGetsNumbering(WORD ch) { return ch != FF; }

// V-GUYB: PWord Converter requires loss notification.
#ifdef REPORT_LOSSAGE
typedef struct
{
    IStream *pstm;
    BOOL     bFirstCallback;
    LPVOID  *ppwdPWData;
    BOOL     bLoss;
} LOST_COOKIE;
#endif


//======================== OLESTREAM functions =======================================

DWORD CALLBACK RTFGetFromStream (
    RTFREADOLESTREAM *OLEStream,    //@parm OleStream
    void FAR *        pvBuffer,     //@parm Buffer to read
    DWORD             cb)           //@parm Bytes to read
{
    return OLEStream->Reader->ReadData ((BYTE *)pvBuffer, cb);
}

DWORD CALLBACK RTFGetBinaryDataFromStream (
    RTFREADOLESTREAM *OLEStream,    //@parm OleStream
    void FAR *        pvBuffer,     //@parm Buffer to read
    DWORD             cb)           //@parm Bytes to read
{
    return OLEStream->Reader->ReadBinaryData ((BYTE *)pvBuffer, cb);
}


//============================ STATE Structure =================================
/*
 *  STATE::AddPF(PF, lDefTab, lDocType)
 *
 *  @mfunc
 *      If the PF contains new info, this info is applied to the PF for the
 *      state.  If this state was sharing a PF with a previous state, a new
 *      PF is created for the state, and the new info is applied to it.
 *
 *  @rdesc
 *      TRUE unless needed new PF and couldn't allocate it
 */
BOOL STATE::AddPF(
    const CParaFormat &PF,  //@parm Current RTFRead _PF
    LONG lDocType,          //@parm Default doc type to use if no prev state
    DWORD dwMask)           //@parm Mask to use
{
    // Create a new PF if:
    //  1.  The state doesn't have one yet
    //  2.  The state has one, but it is shared by the previous state and
    //      there are PF deltas to apply to the state's PF
    if(!pPF || dwMask && pstatePrev && pPF == pstatePrev->pPF)
    {
        Assert(!pstatePrev || pPF);

        pPF = new CParaFormat;
        if(!pPF)
            return FALSE;

        // Give the new PF some initial values - either from the previous
        // state's PF or by CParaFormat initialization
        if(pstatePrev)
        {
            // Copy the PF from the previous state
            *pPF = *pstatePrev->pPF;
            dwMaskPF = pstatePrev->dwMaskPF;
        }
        else
        {
            // We've just created a new PF for the state - there is no
            // previous state to copy from.  Use default values.
            pPF->InitDefault(lDocType == DT_RTLDOC ? PFE_RTLPARA : 0);
            dwMaskPF = PFM_ALLRTF;
        }
    }

    // Apply the new PF deltas to the state's PF
    if(dwMask)
    {
        if(dwMask & PFM_TABSTOPS)               // Don't change _iTabs here
        {
            pPF->_bTabCount = PF._bTabCount;
            dwMask &= ~PFM_TABSTOPS;
        }
        pPF->Apply(&PF, dwMask);
    }

    return TRUE;
}

/*
 *  STATE::DeletePF()
 *
 *  @mfunc
 *      If the state's PF is not shared by the previous state, the PF for this
 *      state is deleted.
 */
void STATE::DeletePF()
{
    if(pPF && (!pstatePrev || pPF != pstatePrev->pPF))
        delete pPF;

    pPF = NULL;
}

/*
 *  STATE::SetCodePage(CodePage)
 *
 *  @mfunc
 *      If current nCodePage is CP_UTF8, use it for all conversions (yes, even
 *      for SYMBOL_CHARSET). Else use CodePage.
 */
void STATE::SetCodePage(
    LONG CodePage)
{
    if(nCodePage != CP_UTF8)
        nCodePage = CodePage;
}

//============================ CRTFRead Class ==================================
/*
 *  CRTFRead::CRTFRead(prg, pes, dwFlags)
 *
 *  @mfunc
 *      Constructor for RTF reader
 */
CRTFRead::CRTFRead (
    CTxtRange *     prg,            //@parm CTxtRange to read into
    EDITSTREAM *    pes,            //@parm Edit stream to read from
    DWORD           dwFlags         //@parm Read flags
)
    : CRTFConverter(prg, pes, dwFlags, TRUE)
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::CRTFRead");

    Assert(prg->GetCch() == 0);

    //TODO(BradO):  We should examine the member data in the constructor
    //  and determine which data we want initialized on construction and
    //  which at the beginning of every read (in CRTFRead::ReadRtf()).

    _sDefaultFont       = -1;               // No \deff n control word yet
    _sDefaultLanguage   = INVALID_LANGUAGE;
    _sDefaultLanguageFE = INVALID_LANGUAGE;
    _sDefaultTabWidth   = 0;
    _sDefaultBiDiFont   = -1;
    _dwMaskCF           = 0;                // No char format changes yet
    _dwMaskCF2          = 0;
    _nFieldCodePage     = 0;
    _ptfField           = NULL;
    _fRestoreFieldFormat= FALSE;
    _fSeenFontTable     = FALSE;            // No \fonttbl yet
    _fCharSet           = FALSE;            // No \fcharset yet
    _dwFlagsUnion       = 0;                // No flags yet
    _pes->dwError       = 0;                // No error yet
    _cchUsedNumText     = 0;                // No numbering text yet
    _cCell              = 0;                // No table cells yet
    _iCell              = 0;
    _cTab               = 0;
    _pstateStackTop     = NULL;
    _pstateLast         = NULL;
    _szText             =
    _pchRTFBuffer       =                   // No input buffer yet
    _pchRTFCurrent      =
    _szSymbolFieldResult=
    _pchRTFEnd          = NULL;
    _prtfObject         = NULL;
    _pcpObPos           = NULL;
    _bTabLeader         = 0;
    _bTabType           = 0;
    _pobj               = 0;
    _bAlignment         = PFA_LEFT;
    _cbSkipForUnicode   = 0;

    _fHyperlinkField    = FALSE;
    _szHyperlinkFldinst = NULL;
    _szHyperlinkFldrslt = NULL;

    _cCell = 0;                             // No cell right boundaries
    _dxCell = 0;                            //  or half gap defined yet
    _xRowOffset = 0;
    _bCellBrdrWdths = 0;
    _wBorderWidth = 0;                      // No borders yet
    _dwBorderColor  = 0;
    _bAlignment = PFA_LEFT;
	_iTabsTable = -1;                       // No cell widths yet

    // Does story size exceed the maximum text size? Be very careful to
    // use unsigned comparisons here since _cchMax has to be unsigned
    // (EM_LIMITTEXT allows 0xFFFFFFFF to be a large positive maximum
    // value). I.e., don't use signed arithmetic.
    DWORD cchAdj = _ped->GetAdjustedTextLength();
    _cchMax = _ped->TxGetMaxLength();

    if(_cchMax > cchAdj)
        _cchMax = _cchMax - cchAdj;         // Room left
    else
        _cchMax = 0;                        // No room left

    ZeroMemory(_rgStyles, sizeof(_rgStyles)); // No style levels yet

    _bBiDiCharSet = 0;
    if(_ped->IsBiDi())
    {
        _bBiDiCharSet = ARABIC_CHARSET;     // Default Arabic charset

        BYTE          bCharSet;
        CFormatRunPtr rpCF(prg->_rpCF);

        // Look backward in text, trying to find a RTL CharSet.
        // NB: \fN with an RTL charset updates _bBiDiCharSet.
        do
        {
            bCharSet = _ped->GetCharFormat(rpCF.GetFormat())->_bCharSet;
            if(IsRTLCharSet(bCharSet))
            {
                _bBiDiCharSet = bCharSet;
                break;
            }
        } while (rpCF.PrevRun());
    }
    
    // Initialize OleStream
    RTFReadOLEStream.Reader = this;
    RTFReadOLEStream.lpstbl->Get = (DWORD (CALLBACK*)(LPOLESTREAM, void *, DWORD))
                               RTFGetFromStream;
    RTFReadOLEStream.lpstbl->Put = NULL;

#ifdef DEBUG

// TODO: Implement RTF tag logging for the Mac
#if !defined(MACPORT)
    _fTestingParserCoverage = FALSE;
    _prtflg = NULL;

    if(GetProfileIntA("RICHEDIT DEBUG", "RTFLOG", 0))
    {
        _prtflg = new CRTFLog;
        if(_prtflg && !_prtflg->FInit())
        {
            delete _prtflg;
            _prtflg = NULL;
        }
        AssertSz(_prtflg, "CRTFRead::CRTFRead:  Error creating RTF log");
    }
#endif
#endif // DEBUG
}

/*
 *  CRTFRead::HandleStartGroup()
 *  
 *  @mfunc
 *      Handle start of new group. Alloc and push new state onto state
 *      stack
 *
 *  @rdesc
 *      EC                  The error code
 */
EC CRTFRead::HandleStartGroup()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleStartGroup");

    STATE * pstate     = _pstateStackTop;
    STATE * pstateNext = NULL;

    if(pstate)                                  // At least one STATE already
    {                                           //  allocated
        Apply_CF();                             // Apply any collected char
        // Note (igorzv) we don't Apply_PF() here so as not to change para
        // properties before we run into \par i.e. not to use paragraph
        // properties if we copy only one word from paragraph. We can use an
        // assertion here that neither we nor Word use end of group for
        // restoring paragraph properties. So everything will be OK with stack
        pstate->iCF = (SHORT)_prg->Get_iCF();   // Save current CF
        pstate = pstate->pstateNext;            // Use previously allocated
        if(pstate)                              //  STATE frame if it exists
            pstateNext = pstate->pstateNext;    // It does; save its forward
    }                                           //  link for restoration below

    if(!pstate)                                 // No new STATE yet: alloc one
    {
        pstate = new STATE(IsUTF8 ? CP_UTF8 : _nCodePage);
        if(!pstate)                             // Couldn't alloc new STATE
            goto memerror;

        _pstateLast = pstate;                   // Update ptr to last STATE
    }                                           //  alloc'd

    STATE *pstateGetsPF;

    // Apply the accumulated PF delta's to the old current state or, if there
    //  is no current state, to the newly created state.
    pstateGetsPF = _pstateStackTop ? _pstateStackTop : pstate;
    if(!pstateGetsPF->AddPF(_PF, _bDocType, _dwMaskPF))
        goto memerror;

    _dwMaskPF = 0;       // _PF contains delta's from *_pstateStackTop->pPF

    if(_pstateStackTop)                         // There's a previous STATE
    {
        *pstate = *_pstateStackTop;             // Copy current state info
        // N.B.  This will cause the current and previous state to share
        //  the same PF.  PF delta's are accumulated in _PF.  A new PF
        //  is created for _pstateStackTop when the _PF deltas are applied.

        _pstateStackTop->pstateNext = pstate;
    }

    pstate->pstatePrev = _pstateStackTop;       // Link STATEs both ways
    pstate->pstateNext = pstateNext;
    _pstateStackTop = pstate;                   // Push stack

done:
    TRACEERRSZSC("HandleStartGroup()", -_ecParseError);
    return _ecParseError;

memerror:
    _ped->GetCallMgr()->SetOutOfMemory();
    _ecParseError = ecStackOverflow;
    goto done;
}

/*
 *  CRTFRead::HandleEndGroup()
 *
 *  @mfunc
 *      Handle end of new group
 *
 *  @rdesc
 *      EC                  The error code
 */
EC CRTFRead::HandleEndGroup()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleEndGroup");

    STATE * pstate = _pstateStackTop;
    STATE * pstatePrev;

    Assert(_PF._iTabs == -1);

    if(!pstate)                                 // No stack to pop
    {
        _ecParseError = ecStackUnderflow;
        goto done;
    }

    _pstateStackTop =                           // Pop stack
    pstatePrev      = pstate->pstatePrev;

    if(!pstatePrev)
    {
        Assert(pstate->pPF);

        // We're ending the parse.  Copy the final PF into _PF so that
        // subsequent calls to Apply_PF will have a PF to apply.
        _PF = *pstate->pPF;
        _dwMaskPF = pstate->dwMaskPF;

        _PF._iTabs = -1;                        // Force recache
        _PF._wEffects &= ~PFE_TABLE;
    }

    // Adjust the PF for the new _pstateStackTop and delete unused PF's.
    if(pstate->sDest == destParaNumbering || pstate->sDest == destParaNumText)
    {
        if(pstatePrev && pstate->pPF != pstatePrev->pPF)
        {
            // Bleed the PF of the current state into the previous state for
            // paragraph numbering groups
            Assert(pstatePrev->pPF);
            pstatePrev->DeletePF();
            pstatePrev->pPF = pstate->pPF;
            pstate->pPF = NULL;
        }
        else
            pstate->DeletePF();
        // N.B.  Here, we retain the _PF diffs since they apply to the
        // enclosing group along with the PF of the group we are leaving
    }
    else
    {
        // We're popping the state, so delete its PF and discard the _PF diffs
        Assert(pstate->pPF);
        pstate->DeletePF();

        // If !pstatePrev, we're ending the parse, in which case the _PF
        // structure contains final PF (so don't toast it).
        if(pstatePrev)
            _dwMaskPF = 0;
    }

    if(pstatePrev)
    {
        _dwMaskCF = 0;                          // Discard any CF deltas
        _dwMaskCF2 = 0;

        switch(pstate->sDest)
        {
            case destParaNumbering:
                // {\pn ...}
                pstatePrev->sIndentNumbering = pstate->sIndentNumbering;
                pstatePrev->fBullet = pstate->fBullet;
                break;

            case destObject:
                // clear our object flags just in case we have corrupt RTF
                if(_fNeedPres)
                {
                    _fNeedPres = FALSE;
                    _fNeedIcon = FALSE;
                    _pobj = NULL;
                }
                break;

            case destFontTable:
                if(pstatePrev->sDest == destFontTable)
                {
                    // We're actually leaving a sub-group within the \fonttbl
                    // group.
                    break;
                }

                // We're leaving the {\fonttbl...} group.
                _fSeenFontTable = TRUE;

                // Default font should now be defined, so select it (this
                // creates CF deltas).
                SetPlain(pstate);

                // Ensure that a document-level codepage has been determined and
                // then scan the font names and retry the conversion to Unicode,
                // if necessary.

                if(_nCodePage == INVALID_CODEPAGE)
                {
                    // We haven't determined a document-level codepage
                    // from the \ansicpgN tag, nor from the font table
                    // \fcharsetN and \cpgN values.  As a last resort,
                    // let's use the \deflangN and \deflangfeN tags

                    LANGID langid;

                    if(_sDefaultLanguageFE != INVALID_LANGUAGE)
                        langid = _sDefaultLanguageFE;

                    else if(_sDefaultLanguage != INVALID_LANGUAGE &&
                            _sDefaultLanguage != sLanguageEnglishUS)
                    {
                        // _sDefaultLanguage == sLanguageEnglishUS is inreliable
                        // in the absence of \deflangfeN.  Many FE RTF writers
                        // write \deflang1033 (sLanguageEnglishUS).

                        langid = _sDefaultLanguage;
                    }
                    else if(_dwFlags & SFF_SELECTION)
                    {
                        // For copy/paste case, if nothing available, try the system
                        // default langid.  This is to fix FE Excel95 problem.      
                        langid = GetSystemDefaultLangID();
                    }
                    else
                        goto NoLanguageInfo;

                    _nCodePage = ConvertLanguageIDtoCodePage(langid);
                }

NoLanguageInfo:
                if(_nCodePage == INVALID_CODEPAGE)
                    break;

                // Fixup mis-converted font face names

                TEXTFONT *ptf;
                LONG i;

                for(i = 0; i < _fonts.Count(); i++)
                {
                    ptf = _fonts.Elem(i);

                    if (ptf->sCodePage == INVALID_CODEPAGE ||
                        ptf->sCodePage == CP_SYMBOL)
                    {
                        if(ptf->fNameIsDBCS)
                        {
                            char szaTemp[LF_FACESIZE];
                            BOOL fMissingCodePage;

                            // Un-convert mis-converted face name
                            SideAssert(WCTMB(ptf->sCodePage, 0,
                                                ptf->szName, -1,
                                                szaTemp, sizeof(szaTemp),
                                                NULL, NULL, &fMissingCodePage) > 0);
                            Assert(ptf->sCodePage == CP_SYMBOL ||
                                        fMissingCodePage);

                            // re-convert face name using new codepage info
                            SideAssert(MBTWC(_nCodePage, 0,
                                        szaTemp, -1,
                                        ptf->szName, sizeof(ptf->szName),
                                        &fMissingCodePage) > 0);

                            if(!fMissingCodePage)
                                ptf->fNameIsDBCS = FALSE;
                        }
                    }
                }
                break;

            default:;
                // nothing
        }
        _prg->Set_iCF(pstatePrev->iCF);         // Restore previous CharFormat
        ReleaseFormats(pstatePrev->iCF, -1);
    }

done:
    TRACEERRSZSC("HandleEndGroup()", - _ecParseError);
    return _ecParseError;
}
/*
 *  CRTFRead::HandleFieldEndGroup()
 *
 *  @mfunc
 *      Handle end of \field
 *
 */
void CRTFRead::HandleFieldEndGroup()
{
    STATE * pstate  = _pstateStackTop;

    if(pstate->sDest == destField)
    {
        // for SYMBOLS
        if(!_fHyperlinkField)
        {
            if(_szSymbolFieldResult)     // There is a new field result
            {
                if(_fRestoreFieldFormat)
                {
                    _fRestoreFieldFormat = FALSE;
                    _CF = _FieldCF;
                    pstate->ptf = _ptfField;
                    pstate->SetCodePage(_nFieldCodePage);
                    _dwMaskCF = _dwMaskFieldCF;
                    _dwMaskCF2 = _dwMaskFieldCF2;
                }
                HandleText(_szSymbolFieldResult, CONTAINS_NONASCII);
                FreePv(_szSymbolFieldResult);
                _szSymbolFieldResult =NULL;
            }
        }
        else if(pstate->pstateNext)
        {
            // Setup formatting for the field result
            _CF = _FieldCF;
            pstate->ptf = _ptfField;
            pstate->SetCodePage(_nFieldCodePage);
            _dwMaskCF = _dwMaskFieldCF;
            _dwMaskCF2 = _dwMaskFieldCF2;

            // for HYPERLINK
            if(_szHyperlinkFldrslt || _szHyperlinkFldinst)
            {
                // We have the final hyperlink fldrslt string.
                // Check if it is the same as the friendly name
        
                if (_szHyperlinkFldrslt && _szHyperlinkFldinst &&
                    _szHyperlinkFldinst[1] == '<' &&
                    !CompareMemory(
                        (char*)_szHyperlinkFldrslt,
                        (char*)&_szHyperlinkFldinst[2],
                        _cchHyperlinkFldrsltUsed - 1))
                {
                    // They are the same, only need to output friendly name
                    HandleText(&_szHyperlinkFldinst[1], CONTAINS_NONASCII, _cchHyperlinkFldinstUsed);                       
                }
                else
                {
                    // Output result string
                    if(_szHyperlinkFldrslt)
                        HandleText(_szHyperlinkFldrslt, CONTAINS_NONASCII, _cchHyperlinkFldrsltUsed);

                    // Output friendly name
                    if(_szHyperlinkFldinst)
                        HandleText(_szHyperlinkFldinst, CONTAINS_NONASCII, _cchHyperlinkFldinstUsed);
                }
                
                FreePv(_szHyperlinkFldinst);
                FreePv(_szHyperlinkFldrslt);
                _szHyperlinkFldinst = NULL;
                _szHyperlinkFldrslt = NULL;
                _fHyperlinkField = FALSE;
            }
        }
    }
    else if(pstate->sDest == destFieldResult && _fHyperlinkField)
    {
        // Save the current formatting for the field result if dwMask is valid.
        // NOTE: HandleEndGroup will zero out _dwMaskCF
        if(_dwMaskCF)
        {
            // We should use FE charset in case of mixed of FE and non-FE in the url
            // Also, only use codepage other than English in case of a mixed of English
            // and non-English (e.g. English and Russian )
            if (!IsFECharSet(_FieldCF._bCharSet) && IsFECharSet(_CF._bCharSet)  ||
                _nFieldCodePage != pstate->nCodePage && _nFieldCodePage == 1252 ||
                _FieldCF._bCharSet == _CF._bCharSet && _nFieldCodePage == pstate->nCodePage)
            {
                _FieldCF = _CF;
                _ptfField = pstate->ptf;
                _nFieldCodePage = pstate->nCodePage;
                _dwMaskFieldCF = _dwMaskCF;
                _dwMaskFieldCF2 = _dwMaskCF2;
            }
        }
    }
}

/*
 *  CRTFRead::SelectCurrentFont(iFont)
 *
 *  @mfunc
 *      Set active font to that with index <p iFont>. Take into account
 *      bad font numbers.
 */
void CRTFRead::SelectCurrentFont(
    INT iFont)                  //@parm font handle of font to select
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::SelectCurrentFont");

    LONG        i       = _fonts.Count();
    STATE *     pstate  = _pstateStackTop;
    TEXTFONT *  ptf     = _fonts.Elem(0);

    AssertSz(i, "CRTFRead::SelectCurrentFont: bad font collection");
    
    for(; i-- && iFont != ptf->sHandle; ptf++)  // Search for font with handle
        ;                                       //  iFont

    // Font handle not found: use default, which is valid
    //  since \rtf copied _prg's
    if(i < 0)                                   
        ptf = _fonts.Elem(0);
                                                
    BOOL fDefFontFromSystem = (i == (LONG)_fonts.Count() - 1 || i < 0) &&
                                !_fReadDefFont;

    _CF._iFont      = GetFontNameIndex(ptf->szName);
    _dwMaskCF2      |=  CFM2_FACENAMEISDBCS;
    _CF._dwEffects  &= ~CFE_FACENAMEISDBCS;
    if(ptf->fNameIsDBCS)
        _CF._dwEffects |= CFE_FACENAMEISDBCS;

    if(pstate->sDest != destFontTable)
    {
        _CF._bCharSet           = ptf->bCharSet;
        _CF._bPitchAndFamily    = ptf->bPitchAndFamily;
        _dwMaskCF               |= CFM_FACE | CFM_CHARSET;  
        
        if (IsRTLCharSet(_CF._bCharSet) && ptf->sCodePage == 1252)
            ptf->sCodePage = (SHORT)GetCodePage(_CF._bCharSet); // Fix sCodePage to match charset
    }

	if (_ped->Get10Mode() && !_fSeenFontTable 
		&& _nCodePage == INVALID_CODEPAGE && ptf->sCodePage == 1252)
	{
		if (W32->IsFECodePage(GetACP()))
			_nCodePage = GetACP();
	}

    // Ensure that the state's codepage is not supplied by the system.
    // That is, if we are using the codepage info from the default font,
    // be sure that the default font info was read from the RTF file.
    pstate->SetCodePage((fDefFontFromSystem && _nCodePage != INVALID_CODEPAGE) ||
        ptf->sCodePage == INVALID_CODEPAGE
                        ? _nCodePage : ptf->sCodePage);
    pstate->ptf = ptf;

#ifdef CHICAGO
    // Win95c 1719: try to match a language to the char set when RTF
    //              doesn't explicitly set a language

    if (!pstate->fExplicitLang && ptf->bCharSet != ANSI_CHARSET &&
        (!pstate->sLanguage || pstate->sLanguage == sLanguageEnglishUS))
    {
        i = AttIkliFromCharset(_ped, ptf->bCharSet);
        if(i >= 0)
            pstate->sLanguage = LOWORD(rgkli[i].hkl);
    }
#endif  // CHICAGO
}

/*
 *  CRTFRead::SetPlain(pstate)
 *
 *  @mfunc
 *      Setup _CF for \plain
 */
void CRTFRead::SetPlain(
    STATE *pstate)
{
    ZeroMemory(&_CF, sizeof(CCharFormat));

    _dwMaskCF    = CFM_ALL2;
    if(_dwFlags & SFF_SELECTION && _prg->GetCp() == _cpFirst && !_fCharSet)
    {
        // Let NT 4.0 CharMap use insertion point size
        _CF._yHeight = _ped->GetCharFormat(_prg->Get_iFormat())->_yHeight;
    }
    else
        _CF._yHeight = PointsToFontHeight(yDefaultFontSize);

    _CF._dwEffects  = CFE_AUTOCOLOR | CFE_AUTOBACKCOLOR; // Set default effects
    if(_sDefaultLanguage == INVALID_LANGUAGE)
        _dwMaskCF &= ~CFM_LCID;
    else
        _CF._lcid = MAKELCID((WORD)_sDefaultLanguage, SORT_DEFAULT);

    _CF._bUnderlineType = CFU_UNDERLINE;
    SelectCurrentFont(_sDefaultFont);

    // TODO: get rid of pstate->sLanguage, since CHARFORMAT2 has lcid
    pstate->sLanguage     = _sDefaultLanguage;
    pstate->fExplicitLang = FALSE;
}

/*
 *  CRTFRead::ReadFontName(pstate, iAllASCII)
 *
 *  @mfunc
 *      read font name _szText into <p pstate>->ptf->szName and deal with
 *      tagged fonts
 */
void CRTFRead::ReadFontName(
    STATE * pstate,         //@parm state whose font name is to be read into
    int iAllASCII)          //@parm indicates that _szText is all ASCII chars
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadFontName");

    if (pstate->ptf)
    {
        INT     cchName = LF_FACESIZE - 1;
        TCHAR * pchDst = pstate->ptf->szName;
        char  * pachName =  (char *)_szText ;
        
        // Append additional text from _szText to TEXTFONT::szName

        // We need to append here since some RTF writers decide
        // to break up a font name with other RTF groups
        while(*pchDst && cchName > 0)
        {
            pchDst++;
            cchName--;
        }
		if(!cchName)						// Probably illegal file
		{									//  e.g., extra {
			return;
		}
        INT cchLimit = cchName;
        BOOL    fTaggedName = FALSE;
        while (*pachName &&
               *pachName != ';' &&
               cchLimit)        // Remove semicolons
        {
            pachName++;
            cchLimit--;

            if (*pachName == '(')
                fTaggedName = TRUE;
        }
        *pachName = '\0';

        // Use the codepage of the font in all cases except where the font uses
        // the symbol charset (and the codepage has been mapped from the charset)
        // and UTF-8 isn't being used
        LONG nCodePage = pstate->nCodePage != CP_SYMBOL
                       ? pstate->nCodePage : _nCodePage;

        BOOL fMissingCodePage;
        Assert(!IsUTF8 || nCodePage == CP_UTF8);
        INT cch = MBTWC(nCodePage, 0,
                        (char *)_szText, -1,
                        pchDst, cchName, &fMissingCodePage);

        if(cch > 0 && fMissingCodePage && iAllASCII == CONTAINS_NONASCII)
            pstate->ptf->fNameIsDBCS = TRUE;
        else if(pstate->ptf->bCharSet == DEFAULT_CHARSET &&
                W32->IsFECodePage(nCodePage) &&
                GetTrailBytesCount(*_szText, nCodePage))
            pstate->ptf->bCharSet = GetCharSet(nCodePage);      // Fix up the charset


        // Make sure destination is null terminated
        if(cch > 0)
            pchDst[cch] = 0;

        // Fall through even if MBTWC <= 0, since we may be appending text to an
        // existing font name.

        if(pstate->ptf == _fonts.Elem(0))       // If it's the default font,
            SelectCurrentFont(_sDefaultFont);   //  update _CF accordingly

        TCHAR * szNormalName;

        if(pstate->ptf->bCharSet && pstate->fRealFontName)
        {
            // if we don't know about this font don't use the real name
            if(!FindTaggedFont(pstate->ptf->szName,
                               pstate->ptf->bCharSet, &szNormalName))
            {
                pstate->fRealFontName = FALSE;
                pstate->ptf->szName[0] = 0;
            }
        }
        else if(IsTaggedFont(pstate->ptf->szName,
                            &pstate->ptf->bCharSet, &szNormalName))
        {
            wcscpy(pstate->ptf->szName, szNormalName);
            pstate->ptf->sCodePage = (SHORT)GetCodePage(pstate->ptf->bCharSet);
            pstate->SetCodePage(pstate->ptf->sCodePage);
        }
        else if(fTaggedName && !fMissingCodePage)
        {
            // Fix up tagged name by removing characters after the ' ('
            INT i = 0;
            WCHAR   *pwchTag = pstate->ptf->szName;
            
            while (pwchTag[i] && pwchTag[i] != L'(')    // Search for '('
                i++;

            if(pwchTag[i] && i > 0)
            {               
                while (i > 0 && pwchTag[i-1] == 0x20)   // Remove spaces before the '('
                    i--;
                pwchTag[i] = 0;
            }
        }
    }
}

/*
 *  CRTFRead::GetColor (dwMask)
 *
 *  @mfunc
 *      Store the autocolor or autobackcolor effect bit and return the
 *      COLORREF for color _iParam
 *
 *  @rdesc
 *      COLORREF for color _iParam
 *
 *  @devnote
 *      If the entry in _colors corresponds to tomAutoColor, gets the value
 *      RGB(0,0,0) (since no \red, \green, and \blue fields are used), but
 *      isn't used by the RichEdit engine.  Entry 1 corresponds to the first
 *      explicit entry in the \colortbl and is usually RGB(0,0,0). The _colors
 *      table is built by HandleToken() when it handles the token tokenText
 *      for text consisting of a ';' for a destination destColorTable.
 */
COLORREF CRTFRead::GetColor(
    DWORD dwMask)       //@parm Color mask bit
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetColor");

    if(_iParam >= _colors.Count())              // Illegal _iParam
        return RGB(0,0,0);

    _dwMaskCF     |= dwMask;                    // Turn on appropriate mask bit
    _CF._dwEffects &= ~dwMask;                  // auto(back)color off: color is to be used

    COLORREF Color = *_colors.Elem(_iParam);
    if(Color == tomAutoColor)
    {
        _CF._dwEffects |= dwMask;               // auto(back)color on               
        Color = RGB(0,0,0);
    }       
    return Color;
}

/*
 *  CRTFRead::GetStandardColorIndex ()
 *
 *  @mfunc
 *      Return the color index into the standard 16-entry Word \colortbl
 *      corresponding to the color index _iParam for the current \colortbl
 *
 *  @rdesc
 *      Standard color index corresponding to the color associated with _iParam
 */
LONG CRTFRead::GetStandardColorIndex()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::GetColorIndex");

    if(_iParam >= _colors.Count())              // Illegal _iParam:
        return 0;                               //  use autocolor

    COLORREF Color = *_colors.Elem(_iParam);

    for(LONG i = 0; i < 16; i++)
    {
        if(Color == g_Colors[i])
            return i + 1;
    }
    return 0;                                   // Not there: use autocolor
}

/*
 *  CRTFRead::HandleChar(ch)
 *
 *  @mfunc
 *      Handle single Unicode character <p ch>
 *
 *  @rdesc
 *      EC          The error code
 */
EC CRTFRead::HandleChar(
    WCHAR ch)           //@parm char token to be handled
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleChar");

    if(!_ped->_pdp->IsMultiLine() && IsASCIIEOP(ch))
        _ecParseError = ecTruncateAtCRLF;
    else
    {
        AssertNr(ch <= 0x7F || ch > 0xFF || FTokIsSymbol(ch));
        _dwMaskCF2      |=  CFM2_RUNISDBCS;
        _CF._dwEffects  &= ~CFE_RUNISDBCS;
        AddText(&ch, 1, CharGetsNumbering(ch));
    }

    TRACEERRSZSC("HandleChar()", - _ecParseError);

    return _ecParseError;
}

/*
 *  CRTFRead::HandleEndOfPara()
 *
 *  @mfunc
 *      Insert EOP and apply current paraformat
 *
 *  @rdesc
 *      EC  the error code
 */
EC CRTFRead::HandleEndOfPara()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleEndOfPara");

    if(_pstateStackTop->fInTable)           // Our simple table model can't
    {                                       //  have numbering
        _PF._wNumbering = 0;    
        _dwMaskPF |= PFM_NUMBERING;
    }

    if(!_ped->_pdp->IsMultiLine())          // No EOPs permitted in single-
    {                                       //  line controls
        Apply_PF();                         // Apply any paragraph formatting
        _ecParseError = ecTruncateAtCRLF;   // Cause RTF reader to finish up
        return ecTruncateAtCRLF;
    }

    Apply_CF();                             // Apply _CF and save iCF, since
    LONG iFormat = _prg->Get_iCF();         //  it gets changed if processing
                                            //  CFE2_RUNISDBCS chars
    EC ec  = _ped->fUseCRLF()               // If RichEdit 1.0 compatibility
           ? HandleText(szaCRLF, ALL_ASCII) //  mode, use CRLF; else CR or VT
           : HandleChar((unsigned)(_token == tokenLineBreak ? VT :
                                   _token == tokenPage ? FF : CR));
    if(ec == ecNoError)
    {
        Apply_PF();
        _cpThisPara = _prg->GetCp();        // New para starts after CRLF
    }
    _prg->Set_iCF(iFormat);                 // Restore iFormat if changed
    ReleaseFormats(iFormat, -1);            // Release iFormat (AddRef'd by
                                            //  Get_iCF())
    return _ecParseError;
}

/*
 *  CRTFRead::HandleText(szText, iAllASCII)
 *
 *  @mfunc
 *      Handle the string of Unicode characters <p szText>
 *
 *  @rdesc
 *      EC          The error code
 */
EC CRTFRead::HandleText(
    BYTE * szText,          //@parm string to be handled
    int iAllASCII,          //@parm enum indicating if string is all ASCII chars
    LONG    cchText)        //@parm size of szText in bytes
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleText");

    LONG        cch;
    BOOL        fStateChng = FALSE;
    TCHAR *     pch;
    STATE *     pstate = _pstateStackTop;
    TEXTFONT *  ptf = pstate->ptf;

    struct TEXTFONTSAVE : TEXTFONT
    {
        TEXTFONTSAVE(TEXTFONT *ptf)
        {
            if (ptf)
            {
                bCharSet        = ptf->bCharSet;
                sCodePage       = ptf->sCodePage;
                fCpgFromSystem  = ptf->fCpgFromSystem;
            }
        }
    };

    BOOL fAdjustPtf = FALSE;

    if(pstate->fltrch || pstate->frtlch)
    {
        // CharSet resolution based on directional control words
        if(_CF._bCharSet == DEFAULT_CHARSET)
        {
            _CF._bCharSet = (BYTE)(pstate->fltrch
                         ? ANSI_CHARSET : _bBiDiCharSet);
            _dwMaskCF |= CFM_CHARSET;
            fAdjustPtf = TRUE;
        }
        else
        {
            BOOL fBiDiCharSet = IsRTLCharSet(_CF._bCharSet);

            // If direction token doesn't correspond to current charset
            if(fBiDiCharSet ^ pstate->frtlch)
            {
                _dwMaskCF |= CFM_CHARSET;
                fAdjustPtf = TRUE;
                if(!fBiDiCharSet)               // Wasn't BiDi, but is now
                    SelectCurrentFont(_sDefaultBiDiFont);
                _CF._bCharSet = (BYTE)(pstate->frtlch
                             ? _bBiDiCharSet : ANSI_CHARSET);
            }
            else if (fBiDiCharSet && ptf && !W32->IsBiDiCodePage(ptf->sCodePage))
                fAdjustPtf = TRUE;
        }
    }
    else if(_ped->IsBiDi() && _CF._bCharSet == DEFAULT_CHARSET)
    {
        _CF._bCharSet = ANSI_CHARSET;
        _dwMaskCF |= CFM_CHARSET;
        fAdjustPtf = TRUE;
    }
    if (fAdjustPtf && ptf)
    {
        ptf->sCodePage = (SHORT)GetCodePage(_CF._bCharSet);
        pstate->SetCodePage(ptf->sCodePage);
    }

    TEXTFONTSAVE    tfSave(ptf);

    // TODO: what if szText cuts off in middle of DBCS?

    if(!*szText)
        goto CleanUp;

    if (cchText != -1 && _cchUnicode < cchText)
    {
        // Re-allocate a bigger buffer
        _szUnicode = (TCHAR *)PvReAlloc(_szUnicode, (cchText + 1) * sizeof(TCHAR));
        if(!_szUnicode)                 // Re-allocate space for Unicode conversions
        {
            _ped->GetCallMgr()->SetOutOfMemory();
            _ecParseError = ecNoMemory;
            goto CleanUp;
        }
        _cchUnicode = cchText + 1;
    }

    if(iAllASCII == ALL_ASCII || pstate->nCodePage == CP_SYMBOL)
    {
        // Don't use MBTWC() in cases where text contains
        // only ASCII chars (which don't require conversion)
        for(cch = 0, pch = _szUnicode; *szText; cch++)
        {
            Assert(*szText <= 0x7F || _CF._bCharSet == SYMBOL_CHARSET);
            *pch++ = (TCHAR)*szText++;
        }
        *pch = 0;

        _dwMaskCF2      |=  CFM2_RUNISDBCS;
        _CF._dwEffects  &= ~CFE_RUNISDBCS;

        // Fall through to AddText at end of HandleText()
    }
    else
    {
        BOOL      fMissingCodePage;

        // Run of text contains bytes > 0x7F.
        // Ensure that we have the correct codepage with which to interpret
        // these (possibly DBCS) bytes.

        if(ptf && ptf->sCodePage == INVALID_CODEPAGE && !ptf->fCpgFromSystem)
        {
            if(_dwFlags & SF_USECODEPAGE)
            {
                _CF._bCharSet = GetCharSet(_nCodePage);
                _dwMaskCF |= CFM_CHARSET;
            }

            // Determine codepage from the font name
            else if(CpgInfoFromFaceName(pstate->ptf))
            {
                fStateChng     = TRUE;
                SelectCurrentFont(pstate->ptf->sHandle);
                Assert(ptf->sCodePage != INVALID_CODEPAGE);
                Assert(ptf->fCpgFromSystem);
            }
            else
            {
                // Here, we were not able to determine a cpg/charset value
                // from the font name.  We have two choices: (1) either choose
                // some fallback value like 1252/0 or (2) rely on the
                // document-level cpg value.
                //
                // I think choosing the document-level cpg value will give
                // us the best results.  In FE cases, it will likely err
                // on the side of tagging too many runs as CFE2_RUNISDBCS, but
                // that is safer than using a western cpg and potentially missing
                // runs which should be CFE2_RUNISDBCS.
            }
        }

        Assert(!IsUTF8 || pstate->nCodePage == CP_UTF8);

		if (pstate->nCodePage == INVALID_CODEPAGE && _ped->Get10Mode() && ptf)
			pstate->nCodePage = ptf->sCodePage;

        cch = MBTWC(pstate->nCodePage, 0,
                    (char *)szText, -1,
                    _szUnicode, _cchUnicode, &fMissingCodePage);

        AssertSz(cch > 0, "CRTFRead::HandleText():  MBTWC implementation changed"
                            " such that it returned a value <= 0");

        if(!fMissingCodePage || !W32->IsFECodePage(pstate->nCodePage))
        {
            // Use result of MBTWC if:
            //  (1) we converted some chars and did the conversion with the codepage
            //      provided.
            //  (2) we converted some chars but couldn't use the codepage provided,
            //      but the codepage is invalid.  Since the codepage is invalid,
            //      we can't do anything more sophisticated with the text before
            //      adding to the backing store

            cch--;  // don't want char count to including terminating NULL

            _dwMaskCF2      |=  CFM2_RUNISDBCS;
            _CF._dwEffects  &= ~CFE_RUNISDBCS;
            if(pstate->nCodePage == INVALID_CODEPAGE)
                _CF._dwEffects |= CFE_RUNISDBCS;

            // fall through to AddText at end of HandleText()
        }
        else
        {
            // Conversion to Unicode failed.  Break up the string of
            // text into runs of ASCII and non-ASCII characters.

            // FUTURE(BradO):  Here, I am saving dwMask and restoring it before
            //      each AddText.  I'm not sure this is neccessary.  When I have
            //      the time, I should revisit this save/restoring and
            //      determine that it is indeed neccessary.

            BOOL fPrevIsASCII = ((*szText <= 0x7F) ? TRUE : FALSE);
            BOOL fCurrentIsASCII = FALSE;
            BOOL fLastChunk = FALSE;
            DWORD dwMaskSave = _dwMaskCF;
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
            CCharFormat CFSave = _CF;
#endif

            pch = _szUnicode;
            cch = 0;

            // (!*szText && *pch) is the case where we do the AddText for the
            //  last chunk of text
            while(*szText || fLastChunk)
            {
                // fCurrentIsASCII assumes that no byte <= 0x7F is a
                //  DBCS lead-byte
                if(fLastChunk ||
                    (fPrevIsASCII != (fCurrentIsASCII = (*szText <= 0x7F))))
                {
                    _dwMaskCF = dwMaskSave;
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
                    _CF = CFSave;
#endif
                    *pch = 0;

                    _dwMaskCF2      |= CFM2_RUNISDBCS;
                    _CF._dwEffects  |= CFE_RUNISDBCS;
                    if(fPrevIsASCII)
                        _CF._dwEffects &= ~CFE_RUNISDBCS;

                    Assert(cch);
                    pch = _szUnicode;

                    AddText(pch, cch, TRUE);

                    cch = 0;
                    fPrevIsASCII = fCurrentIsASCII;

                    // My assumption in saving _dwMaskCF is that the remainder
                    // of the _CF is unchanged by AddText.  This assert verifies
                    // this assumption.
                    AssertSz(!CompareMemory(&CFSave._bCharSet, &_CF._bCharSet,
                        sizeof(CCharFormat) - sizeof(DWORD)) &&
                        !((CFSave._dwEffects ^ _CF._dwEffects) & ~CFE_RUNISDBCS),
                        "CRTFRead::HandleText():  AddText has been changed "
                        "and now alters the _CF structure.");

                    if(fLastChunk)          // Last chunk of text was AddText'd
                        break;
                }

                // Not the last chunk of text.
                Assert(*szText);

                // Advance szText pointer
                if (!fCurrentIsASCII && *(szText + 1) &&
                    GetTrailBytesCount(*szText, pstate->nCodePage))
                {
                    // Current byte is a lead-byte of a DBCS character
                    *pch++ = *szText++;
                    ++cch;
                }
                *pch++ = *szText++;
                ++cch;

                // Must do an AddText for the last chunk of text
                if(!*szText || cch >= _cchUnicode - 1)
                    fLastChunk = TRUE;
            }
            goto CleanUp;
        }
    }

    if(cch > 0)
    {
        AddText(_szUnicode, cch, TRUE);
        if(fStateChng && ptf)
        {
            ptf->bCharSet       = tfSave.bCharSet;
            ptf->sCodePage      = tfSave.sCodePage;
            ptf->fCpgFromSystem = tfSave.fCpgFromSystem;
            SelectCurrentFont(ptf->sHandle);
        }
    }

CleanUp:
    TRACEERRSZSC("HandleText()", - _ecParseError);
    return _ecParseError;
}

/*
 *  CRTFRead::AddText(pch, cch, fNumber)
 *  
 *  @mfunc
 *      Add <p cch> chars of the string <p pch> to the range _prg
 *
 *  @rdesc
 *      error code placed in _ecParseError
 */
EC CRTFRead::AddText(
    TCHAR * pch,        //@parm text to add
    LONG    cch,        //@parm count of chars to add
    BOOL    fNumber)    //@parm indicates whether or not to prepend numbering
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::AddText");

    LONG            cchAdded;
    LONG            cchT;
    STATE * const   pstate = _pstateStackTop;
    TCHAR *         szDest;
    LONG            cchMove;

    // AROO: No saving state before this point (other than pstate)
    // AROO: This would cause recursion problems below

    AssertSz(pstate, "CRTFRead::AddText: no state");

    if((DWORD)cch > _cchMax)
    {
        cch = (LONG)_cchMax;
        _ecParseError = ecTextMax;
    }

    if(!cch)
        return _ecParseError;

    // FUTURE(BradO):  This strategy for \pntext is prone to bugs, I believe.
    // The recursive call to AddText to add the \pntext will trounce the
    // accumulated _CF diffs associated with the text for which AddText is
    // called.  I believe we should save and restore _CF before and after
    // the recursive call to AddText below.  Also, it isn't sufficient to
    // accumulate bits of \pntext as below, since each bit might be formatted
    // with different _CF properties.  Instead, we should accumulate a mini-doc
    // complete with multiple text, char and para runs (or some stripped down
    // version of this strategy).

    if(pstate->sDest == destParaNumText)
    {
        szDest = _szNumText + _cchUsedNumText;
        cch = min(cch, cchMaxNumText - 1 - _cchUsedNumText);
        if(cch > 0)
        {
            MoveMemory((BYTE *)szDest, (BYTE *)pch, cch*2);
            szDest[cch] = TEXT('\0');       // HandleText() takes sz
            _cchUsedNumText += cch;
        }
        return ecNoError;
    }

    if(_cchUsedNumText && fNumber)          // Some \pntext available
    {
        // Bug 3496 - The fNumber flag is an ugly hack to work around RTF
        //  commonly written by Word.  Often, to separate a numbered list
        //  by page breaks, Word will write:
        //      <NUMBERING INFO> \page <PARAGRAPH TEXT>
        //  The paragraph numbering should precede the paragraph text rather
        //  than the page break.  The fNumber flag is set to FALSE when the
        //  the text being added should not be prepended with the para-numbering,
        //  as is the case with \page (mapped to FF).

        cchT = _cchUsedNumText;
        _cchUsedNumText = 0;                // Prevent infinite recursion

        if(!pstate->fBullet)
        {
            // If there are any _CF diffs to be injected, they will be trounced
            // by this recursive call (see FUTURE comment above).

            // Since we didn't save _CF data from calls to AddText with
            // pstate->sDest == destParaNumText, we have no way of setting up
            // CFE2_RUNISDBCS and CFM2_RUNISDBCS (see FUTURE comment above).

            AddText(_szNumText, cchT, FALSE);
        }
        else if(_PF.IsListNumbered() && _szNumText[cchT - 1] == TAB)
        {
            AssertSz(cchT >= 1, "Invalid numbered text count");

            if (cchT > 1)
            {
                WCHAR ch = _szNumText[cchT - 2];

                _wNumberingStyle = (_wNumberingStyle & ~0x300)
                     | (ch == '.' ? PFNS_PERIOD :
                        ch != ')' ? PFNS_PLAIN  :
                        _szNumText[0] == '(' ? PFNS_PARENS : PFNS_PAREN);
            }
            else
            {
                // There is only a tab so we will assume they meant to
                // skip numbering.
                _wNumberingStyle = PFNS_NONUMBER;
            }
        }
    }

    if (_cpFirst && _prg->GetCp() == _cpFirst && _prg->GetPF()->InTable() &&
        _cCell && !_prg->_rpTX.IsAfterEOP())
    {
        // FUTURE: handle more general table insertions into other tables
        _iCell = 0;
        return _ecParseError = ecGeneralFailure;
    }

    Apply_CF();                             // Apply formatting changes in _CF

    // BUGS 1577 & 1565 -
    // CTxtRange::ReplaceRange will change the character formatting
    // and possibly adjust the _rpCF forward if the current char
    // formatting includes protection.  The changes affected by
    // CTxtRange::ReplaceRange are necessary only for non-streaming
    // input, so we save state before and restore it after the call
    // to CTxtRange::ReplaceRange

    LONG iFormatSave = _prg->Get_iCF();     // Save state

    if(_cbSkipForUnicode && pstate->ptf && pstate->ptf->sCodePage == INVALID_CODEPAGE &&
       (!_fSeenFontTable || !(GetCharFlags(*pch) & fOTHER & ~255)))
    {
        // No charset info for \uN, so bind fonts if no font table or
        // else if *pch isn't classifield as "other"
        cchAdded = _prg->CleanseAndReplaceRange(cch, pch, FALSE, NULL, pch);
    }
    else
    {
        cchAdded = _prg->ReplaceRange(cch, pch, NULL, SELRR_IGNORE, &cchMove);

        DWORD dwFlags = 0;
        for(cchT = cch; cchT--; )
            dwFlags |= GetCharFlags(*pch++);    // Note if ComplexScript

        _ped->OrCharFlags(dwFlags);
    }

    _prg->Set_iCF(iFormatSave);                 // Restore state
    ReleaseFormats(iFormatSave, -1);
    Assert(!_prg->GetCch());

    if(cchAdded != cch)
    {
        Tracef(TRCSEVERR, "AddText(): Only added %d out of %d", cchAdded, cch);
        _ecParseError = ecGeneralFailure;
        if(cchAdded <= 0)
            return _ecParseError;
    }
    _cchMax -= cchAdded;

    return _ecParseError;
}

/*
 *  CRTFRead::Apply_CF()
 *  
 *  @mfunc
 *      Apply character formatting changes collected in _CF
 */
void CRTFRead::Apply_CF()
{
    // If any CF changes, update range's _iFormat
    if(_dwMaskCF || _dwMaskCF2)     
    {
        AssertSz(_prg->GetCch() == 0,
            "CRTFRead::Apply_CF: nondegenerate range");

        _prg->SetCharFormat(&_CF, 0, NULL, _dwMaskCF, _dwMaskCF2);
        _dwMaskCF = 0;                          
        _dwMaskCF2 = 0;
    }
}

/*
 *  CRTFRead::Apply_PF()
 *  
 *  @mfunc
 *      Apply paragraph format given by _PF
 */
void CRTFRead::Apply_PF()
{
    LONG         cp     = _prg->GetCp();
    DWORD        dwMask = _dwMaskPF;
    CParaFormat *pPF    = &_PF;

    if(_pstateStackTop)
    {
        Assert(_pstateStackTop->pPF);

        // Add PF diffs to *_pstateStackTop->pPF
        if(!_pstateStackTop->AddPF(_PF, _bDocType, _dwMaskPF))
        {
            _ped->GetCallMgr()->SetOutOfMemory();
            _ecParseError = ecNoMemory;
            return;
        }
        _dwMaskPF = 0;  // _PF contains delta's from *_pstateStackTop->pPF

        pPF    = _pstateStackTop->pPF;
        dwMask = _pstateStackTop->dwMaskPF;
        Assert(dwMask == PFM_ALLRTF);
        if(pPF->_wNumbering)
        {
            pPF->_wNumberingTab   = _pstateStackTop->sIndentNumbering;
            pPF->_wNumberingStyle = _wNumberingStyle;
        }

    }

    if(dwMask & PFM_TABSTOPS)
    {
        LONG cTab = _cCell ? _cCell : _cTab;

        // Caching a tabs array AddRefs the corresponding cached tabs entry.
        // Be absolutely sure to release the entry before exiting the routine
        // that caches it (see GetTabsCache()->Release at end of this funtion).
        pPF->_iTabs = GetTabsCache()->Cache(_rgxCell, cTab);
        if(pPF->InTable())                  // Save _iTabs when associated
            _iTabsTable = pPF->_iTabs;      //  with a table

        AssertSz(!cTab || pPF->_iTabs >= 0,
            "CRTFRead::Apply_PF: illegal pPF->_iTabs");

        pPF->_bTabCount = cTab;
    }

    if (!(dwMask & PFM_TABSTOPS) || !pPF->_bTabCount)
        pPF->_wEffects &= ~PFE_TABLE;       // No tabs, no table

    _prg->Set(cp, cp - _cpThisPara);        // Select back to _cpThisPara
    _prg->SetParaFormat(pPF, NULL, dwMask);
    _prg->Set(cp, 0);                       // Restore _prg to an IP

    GetTabsCache()->Release(pPF->_iTabs);
    pPF->_iTabs = -1;
}

/*
 *  CRTFRead::SetBorderParm(&Parm, Value)
 *
 *  @mfunc
 *      Set the border pen width in half points for the current border
 *      (_bBorder)
 */
void CRTFRead::SetBorderParm(
    WORD&   Parm,
    LONG    Value)
{
    Assert(_bBorder <= 3);

    Value = min(Value, 15);
    Value = max(Value, 0);
    Parm &= ~(0xF << 4*_bBorder);
    Parm |= Value << 4*_bBorder;
    _dwMaskPF |= PFM_BORDER;
}

/*
 *  CRTFRead::HandleToken()
 *
 *  @mfunc
 *      Grand switch board that handles all tokens. Switches on _token
 *
 *  @rdesc
 *      EC      The error code
 *
 *  @comm
 *      Token values are chosen contiguously (see tokens.h and tokens.c) to
 *      encourage the compiler to use a jump table.  The lite-RTF keywords
 *      come first, so that an optimized OLE-free version works well.  Some
 *      groups of keyword tokens are ordered so as to simplify the code, e.g,
 *      those for font family names, CF effects, and paragraph alignment.
 */
EC CRTFRead::HandleToken()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleToken");

    BYTE                bT;                     // Temporary BYTE
    DWORD               dwT;                    // Temporary DWORD
    LONG                dy, i;
    LONG                iParam = _iParam;
    const CCharFormat * pCF;
    COLORREF *          pclrf;
    STATE *             pstate = _pstateStackTop;
    TEXTFONT *          ptf;
    WORD                wT;                     // Temporary WORD

#if defined(DEBUG)
    if(!_fTestingParserCoverage)
#endif
    {
        if(_cbSkipForUnicode &&
            _token != tokenText &&
            _token != tokenStartGroup &&
            _token != tokenEndGroup &&
            _token != tokenBinaryData)
        {
            _cbSkipForUnicode--;
            goto done;
        }
    }

	if(IN_RANGE(tokenPicFirst, _token, tokenObjLast) && !_prtfObject)
	{
		_ecParseError = ecUnexpectedToken;
		return _ecParseError;
	}

    switch (_token)
    {
    case tokenURtf:                             // \urtfN - Preferred RE format
        PARSERCOVERAGE_CASE();                  // Currently we ignore the N
        _dwFlags &= 0xFFFF;                     // Kill possible codepage
        _dwFlags |= SF_USECODEPAGE | (CP_UTF8 << 16); // Save bit for Asserts
        pstate->SetCodePage(CP_UTF8);
        goto rtf;

    case tokenPocketWord:                       // \pwd - Pocket Word
        _dwFlags |= SFF_PWD;

    case tokenRtf:                              // \rtf - Backward compatible
        PARSERCOVERAGE_CASE();
rtf:    pstate->sDest = destRTF;
        Assert(pstate->nCodePage == INVALID_CODEPAGE ||
               pstate->nCodePage == (int)(_dwFlags >> 16) &&
                    (_dwFlags & SF_USECODEPAGE));

        if(!_fonts.Count() && !_fonts.Add(1, NULL)) // If can't add a font,
            goto OutOfRAM;                      //  report the bad news
        _sDefaultFont = 0;                      // Set up valid default font
        ptf = _fonts.Elem(0);
        pstate->ptf           = ptf;            // Get char set, pitch, family
        pCF                   = _prg->GetCF();  //  from current range font
        ptf->bCharSet         = pCF->_bCharSet; // These are guaranteed OK
        ptf->bPitchAndFamily  = pCF->_bPitchAndFamily;
        ptf->sCodePage        = (SHORT)GetCodePage(pCF->_bCharSet);
        wcscpy(ptf->szName, GetFontName(pCF->_iFont));
        ptf->fNameIsDBCS = (pCF->_dwEffects & CFE_FACENAMEISDBCS) != 0;
        pstate->cbSkipForUnicodeMax = iUnicodeCChDefault;
        break;

    case tokenViewKind:                         // \viewkind N
        if(!(_dwFlags & SFF_SELECTION) && IsUTF8) // RTF applies to document:
            _ped->SetViewKind(iParam);          // For RE 3.0, only settable
        break;                                  //  using RichEdit \urtf files

    case tokenViewScale:                        // \viewscale N
        if(_dwFlags & SFF_PERSISTVIEWSCALE &&
            !(_dwFlags & SFF_SELECTION))            // RTF applies to document:
            _ped->SetViewScale(iParam);
        break;

    case tokenCharacterDefault:                 // \plain
        PARSERCOVERAGE_CASE();
        SetPlain(pstate);
        break;

    case tokenCharSetAnsi:                      // \ansi
        PARSERCOVERAGE_CASE();
        _bCharSet = ANSI_CHARSET;
        break;

    case tokenDefaultLanguage:                  // \deflang
        PARSERCOVERAGE_CASE();
        _sDefaultLanguage = (SHORT)iParam;
        if(!pstate->sLanguage)
            pstate->sLanguage = _sDefaultLanguage;
        break;

    case tokenDefaultLanguageFE:                // \deflangfe
        PARSERCOVERAGE_CASE();
        _sDefaultLanguageFE = (SHORT)iParam;
        break;

    case tokenDefaultTabWidth:                  // \deftab
        PARSERCOVERAGE_CASE();
        _sDefaultTabWidth = (SHORT)iParam;
        break;


//--------------------------- Font Control Words -------------------------------

    case tokenDefaultFont:                      // \deff n
        PARSERCOVERAGE_CASE();
        if(iParam >= 0)
		{
			if(!_fonts.Count() && !_fonts.Add(1, NULL))	// If can't add a font,
				goto OutOfRAM;							//  report the bad news
			_fonts.Elem(0)->sHandle = _sDefaultFont = (SHORT)iParam;
		}
        TRACEERRSZSC("tokenDefaultFont: Negative value", iParam);
        break;

    case tokenDefaultBiDiFont:                  // \adeff n
        PARSERCOVERAGE_CASE();
        if(iParam >=0 && _fonts.Count() == 1)
        {
            if(!_fonts.Add(1, NULL))                
                goto OutOfRAM;                      
            _fonts.Elem(1)->sHandle = _sDefaultBiDiFont = (SHORT)iParam;
        }
        TRACEERRSZSC("tokenDefaultBiDiFont: Negative value", iParam);
        break;

    case tokenFontTable:                        // \fonttbl
        PARSERCOVERAGE_CASE();
        pstate->sDest = destFontTable;
        pstate->ptf = NULL;
        break;

    case tokenFontFamilyBidi:                   // \fbidi
    case tokenFontFamilyTechnical:              // \ftech
    case tokenFontFamilyDecorative:             // \fdecor
    case tokenFontFamilyScript:                 // \fscript
    case tokenFontFamilyModern:                 // \fmodern
    case tokenFontFamilySwiss:                  // \fswiss
    case tokenFontFamilyRoman:                  // \froman
    case tokenFontFamilyDefault:                // \fnil
        PARSERCOVERAGE_CASE();
        AssertSz(tokenFontFamilyRoman - tokenFontFamilyDefault == 1,
            "CRTFRead::HandleToken: invalid token definition");

        if(pstate->ptf)
        {
            pstate->ptf->bPitchAndFamily
                = (BYTE)((_token - tokenFontFamilyDefault) << 4
                         | (pstate->ptf->bPitchAndFamily & 0xF));

            // Setup SYMBOL_CHARSET charset for \ftech if there isn't any charset info
            if(tokenFontFamilyTechnical == _token && pstate->ptf->bCharSet == DEFAULT_CHARSET)
                pstate->ptf->bCharSet = SYMBOL_CHARSET;
        }
        break;

    case tokenPitch:                            // \fprq
        PARSERCOVERAGE_CASE();
        if(pstate->ptf)
            pstate->ptf->bPitchAndFamily
                = (BYTE)(iParam | (pstate->ptf->bPitchAndFamily & 0xF0));
        break;

    case tokenAnsiCodePage:                     // \ansicpg
        PARSERCOVERAGE_CASE();
#ifdef DEBUG
        if(_fSeenFontTable && _nCodePage == INVALID_CODEPAGE)
            TRACEWARNSZ("CRTFRead::HandleToken():  Found an \ansicpgN tag after "
                            "the font table.  Should have code to fix-up "
                            "converted font names and document text.");
#endif
        if(!(_dwFlags & SF_USECODEPAGE))
        {
            _nCodePage = iParam;
            pstate->SetCodePage(iParam);
        }
        Assert(!IsUTF8 || pstate->nCodePage == CP_UTF8);
        break;

    case tokenCodePage:                         // \cpg
        PARSERCOVERAGE_CASE();
        pstate->SetCodePage(iParam);
        if(pstate->sDest == destFontTable && pstate->ptf)
        {
            pstate->ptf->sCodePage = (SHORT)iParam;
            pstate->ptf->bCharSet = GetCharSet(iParam);

            // If a document-level code page has not been specified,
            // grab this from the first font table entry containing a
            // \fcharsetN or \cpgN
            if(_nCodePage == INVALID_CODEPAGE)
                _nCodePage = iParam;
        }
        break;

    case tokenCharSet:                          // \fcharset n
        PARSERCOVERAGE_CASE();
        if(pstate->ptf)
        {
            pstate->ptf->bCharSet = (BYTE)iParam;
            pstate->ptf->sCodePage = (SHORT)GetCodePage((BYTE)iParam);
            pstate->SetCodePage(pstate->ptf->sCodePage);

            // If a document-level code page has not been specified,
            // grab this from the first font table entry containing a
            // \fcharsetN or \cpgN
            if (pstate->nCodePage != CP_SYMBOL &&
                _nCodePage == INVALID_CODEPAGE)
            {
                _nCodePage = pstate->nCodePage;
            }
            if(IsRTLCharSet(iParam))
            {
                if(_sDefaultBiDiFont == -1)
                    _sDefaultBiDiFont = pstate->ptf->sHandle;

                else if(_sDefaultBiDiFont != pstate->ptf->sHandle)
                {
                    // Validate default BiDi font since Word 2000 may choose
                    // a nonBiDi font
                    i   = _fonts.Count();
                    ptf = _fonts.Elem(0);
                    for(; i-- && _sDefaultBiDiFont != ptf->sHandle; ptf++)
                        ;                                       
                    if(i >= 0 && !IsRTLCharSet(ptf->bCharSet))
                        _sDefaultBiDiFont = pstate->ptf->sHandle;
                }
                if(!IsRTLCharSet(_bBiDiCharSet))
                    _bBiDiCharSet = (BYTE)iParam;
            }
            _fCharSet = TRUE;
        }
        break;

    case tokenRealFontName:                     // \fname
        PARSERCOVERAGE_CASE();
        pstate->sDest = destRealFontName;
        break;

    case tokenAssocFontSelect:                  // \af n
        PARSERCOVERAGE_CASE();                  
        if(pstate->fltrch || pstate->frtlch)    // Be sure it's Western or RTL      
        {                                       //  script and not FE       
            i   = _fonts.Count();
            ptf = _fonts.Elem(0);
            for(; i-- && iParam != ptf->sHandle; ptf++) // Search for font
                ;                                       //  with handle iParam
            if(i >= 0 && IsRTLCharSet(ptf->bCharSet))
            {
                // FUTURE: set new variable _sFontAssocBiDi = iParam
                // and select _sFontAssocBiDi if run is rtlch. This
                // should give same display as Word.
                _bBiDiCharSet = ptf->bCharSet;
            }
            break;
        }   
        if(_sDefaultBiDiFont == -1 || !pstate->fdbch)// BiDi & FE script active?    
            break;                              // No
                                                // Yes: fall thru to \f n
    case tokenFontSelect:                       // \f n
        PARSERCOVERAGE_CASE();

		if(iParam == -1)						// Can't handle this bizarre choice
			goto skip_group;

        pstate->fdbch = FALSE;                  // Reset DBCS flag
        if(pstate->sDest == destFontTable)      // Building font table
        {
            if(iParam == _sDefaultFont)
            {
                _fReadDefFont = TRUE;
                ptf = _fonts.Elem(0);
            }
            else if(iParam == _sDefaultBiDiFont)
                ptf = _fonts.Elem(1);

            else if(!(ptf =_fonts.Add(1,NULL))) // Make room in font table for
            {                                   //  font to be parsed
OutOfRAM:
                _ped->GetCallMgr()->SetOutOfMemory();
                _ecParseError = ecNoMemory;
                break;
            }
            pstate->ptf     = ptf;
            ptf->sHandle    = (SHORT)iParam;    // Save handle
            ptf->szName[0]  = '\0';             // Start with null string
            ptf->bPitchAndFamily = 0;
            ptf->fNameIsDBCS = FALSE;
            ptf->sCodePage  = INVALID_CODEPAGE;
            ptf->fCpgFromSystem = FALSE;
            ptf->bCharSet = DEFAULT_CHARSET;
        }
        else                                    // Font switch in text
        {
            SelectCurrentFont(iParam);
            if(IsRTLCharSet(pstate->ptf->bCharSet))
                _bBiDiCharSet = pstate->ptf->bCharSet;
        }
        break;

    case tokenFontSize:                         // \fs n
        PARSERCOVERAGE_CASE();
        _CF._yHeight = PointsToFontHeight(iParam);  // Convert font size in
        _dwMaskCF |= CFM_SIZE;                  //  half points to logical
        break;                                  //  units

    // NOTE: \*\fontemb and \*\fontfile are discarded. The font mapper will
    //       have to do the best it can given font name, family, and pitch.
    //       Embedded fonts are particularly nasty because legal use should
    //       only support read-only which parser cannot enforce.

    case tokenLanguage:                         // \lang
        PARSERCOVERAGE_CASE();
        pstate->sLanguage = (SHORT)iParam;      // These 2 lines may not be
        pstate->fExplicitLang = TRUE;           //  needed with the new lcid
        _CF._lcid = MAKELCID(iParam, SORT_DEFAULT);
        if (W32->IsBiDiLcid(_CF._lcid))
            _bBiDiCharSet = GetCharSet(ConvertLanguageIDtoCodePage(iParam));
        _dwMaskCF |= CFM_LCID;
        break;


//-------------------------- Color Control Words ------------------------------

    case tokenColorTable:                       // \colortbl
        PARSERCOVERAGE_CASE();
        pstate->sDest = destColorTable;
        _fGetColorYet = FALSE;
        break;

    case tokenColorRed:                         // \red
        PARSERCOVERAGE_CASE();
        pstate->bRed = (BYTE)iParam;
        _fGetColorYet = TRUE;
        break;

    case tokenColorGreen:                       // \green
        PARSERCOVERAGE_CASE();
        pstate->bGreen = (BYTE)iParam;
        _fGetColorYet = TRUE;
        break;

    case tokenColorBlue:                        // \blue
        PARSERCOVERAGE_CASE();
        pstate->bBlue = (BYTE)iParam;
        _fGetColorYet = TRUE;
        break;

    case tokenColorForeground:                  // \cf
        PARSERCOVERAGE_CASE();
        _CF._crTextColor = GetColor(CFM_COLOR);
        // V-GUYB: Table cell backgrounds (\clcbpat) are not handled in RE 2.0.
        // This means all table cells will have a white background. Therefore
        // change any white text to black here.
        if(_pstateStackTop->fInTable && _CF._crTextColor == RGB(0xFF, 0xFF, 0xFF))
            _CF._crTextColor = RGB(0x00, 0x00, 0x00);
        break;

    case tokenColorBackground:                  // \highlight
        PARSERCOVERAGE_CASE();
        _CF._crBackColor = GetColor(CFM_BACKCOLOR);
        break;

    case tokenExpand:                           // \expndtw N
        PARSERCOVERAGE_CASE();
        _CF._sSpacing = (SHORT) iParam;
        _dwMaskCF |= CFM_SPACING;
        break;

    case tokenCharStyle:                        // \cs N
        PARSERCOVERAGE_CASE();
        /*  FUTURE (alexgo): we may want to support character styles
        in some future version.
        _CF._sStyle = (SHORT)iParam;
        _dwMaskCF |= CFM_STYLE;  */

        if(pstate->sDest == destStyleSheet)
            goto skip_group;
        break;          

    case tokenAnimText:                         // \animtext N
        PARSERCOVERAGE_CASE();
        _CF._bAnimation = (BYTE)iParam;
        _dwMaskCF |= CFM_ANIMATION;
        break;

    case tokenKerning:                          // \kerning N
        PARSERCOVERAGE_CASE();
        _CF._wKerning = (WORD)(10 * iParam);        // Convert to twips
        _dwMaskCF |= CFM_KERNING;
        break;

    case tokenFollowingPunct:                   // \*\fchars
        PARSERCOVERAGE_CASE();
        pstate->sDest = destFollowingPunct;
        {
            char *pwchBuf=NULL;
            if (ReadRawText((_dwFlags & SFF_SELECTION) ? NULL : &pwchBuf) && pwchBuf)
            {
                if (_ped->SetFollowingPunct(pwchBuf) != NOERROR)    // Store this buffer inside doc
                    FreePv(pwchBuf);
            }
            else if (pwchBuf)
                FreePv(pwchBuf);
        }
        break;

    case tokenLeadingPunct:                     // \*\lchars
        PARSERCOVERAGE_CASE();
        pstate->sDest = destLeadingPunct;
        {           
            char *pwchBuf=NULL;
            if (ReadRawText((_dwFlags & SFF_SELECTION) ? NULL : &pwchBuf) && pwchBuf)
            {
                if (_ped->SetLeadingPunct(pwchBuf) != NOERROR)  // Store this buffer inside doc 
                    FreePv(pwchBuf);
            }
            else if (pwchBuf)
                FreePv(pwchBuf);
        }
        break;

    case tokenDocumentArea:                     // \info
        PARSERCOVERAGE_CASE();
        pstate->sDest = destDocumentArea;
        break;

#ifdef FE
    USHORT      usPunct;                        // Used for FE word breaking

    case tokenNoOverflow:                       // \nooverflow
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("No Overflow");
        usPunct = ~WBF_OVERFLOW;
        goto setBrkOp;

    case tokenNoWordBreak:                      // \nocwrap
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("No Word Break" );
        usPunct = ~WBF_WORDBREAK;
        goto setBrkOp;

    case tokenNoWordWrap:                       // \nowwrap
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("No Word Word Wrap" );
        usPunct = ~WBF_WORDWRAP;

setBrkOp:
        if(!(_dwFlags & fRTFFE))
        {
            usPunct &= UsVGetBreakOption(_ped->lpPunctObj);
            UsVSetBreakOption(_ped->lpPunctObj, usPunct);
        }
        break;

    case tokenVerticalRender:                   // \vertdoc
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("Vertical" );
        if(pstate->sDest == destDocumentArea && !(_dwFlags & fRTFFE))
            _ped->fModeDefer = TRUE;
        break;

    case tokenHorizontalRender:                 // \horzdoc
        PARSERCOVERAGE_CASE();
        TRACEINFOSZ("Horizontal" );
        if(pstate->sDest == destDocumentArea && !(_dwFlags & fRTFFE))
            _ped->fModeDefer = FALSE;
        break;

#endif
//-------------------- Character Format Control Words -----------------------------

    case tokenUnderlineHairline:                // \ulhair          [10]
    case tokenUnderlineThick:                   // \ulth            [9]
    case tokenUnderlineWave:                    // \ulwave          [8]
    case tokenUnderlineDashDotDotted:           // \uldashdd        [7]
    case tokenUnderlineDashDotted:              // \uldashd         [6]
    case tokenUnderlineDash:                    // \uldash          [5]
    case tokenUnderlineDotted:                  // \uld             [4]
    case tokenUnderlineDouble:                  // \uldb            [3]
    case tokenUnderlineWord:                    // \ulw             [2]
        PARSERCOVERAGE_CASE();
        _CF._bUnderlineType = (BYTE)(_token - tokenUnderlineWord + 2);
        _token = tokenUnderline;                // CRenderer::RenderUnderline()
        goto under;                             //  reveals which of these are
                                                //  rendered specially
    case tokenUnderline:                        // \ul          [Effect 4]
        PARSERCOVERAGE_CASE();                  //  (see handleCF)
        _CF._bUnderlineType = CFU_UNDERLINE;
under:  _dwMaskCF |= CFM_UNDERLINETYPE;
        goto handleCF;

    case tokenDeleted:                          // \deleted
        PARSERCOVERAGE_CASE();
        _dwMaskCF2 = CFM2_DELETED;              
        dwT = CFE_DELETED;
        goto hndlCF;

    // These effects are turned on if their control word parameter is missing
    // or nonzero. They are turned off if the parameter is zero. This
    // behavior is usually identified by an asterisk (*) in the RTF spec.
    // The code uses fact that CFE_xxx = CFM_xxx
handleCF:
    case tokenRevised:                          // \revised         [4000]
    case tokenDisabled:                         // \disabled        [2000]
    case tokenImprint:                          // \impr            [1000]
    case tokenEmboss:                           // \embo             [800]
    case tokenShadow:                           // \shad             [400]
    case tokenOutline:                          // \outl             [200]
    case tokenHiddenText:                       // \v                [100]
    case tokenCaps:                             // \caps              [80]
    case tokenSmallCaps:                        // \scaps             [40]
    case tokenLink:                             // \link              [20]
    case tokenProtect:                          // \protect           [10]
    case tokenStrikeOut:                        // \strike             [8]
    case tokenItalic:                           // \i                  [2]
    case tokenBold:                             // \b                  [1]
        PARSERCOVERAGE_CASE();
        dwT = 1 << (_token - tokenBold);        // Generate effect mask
        _dwMaskCF |= dwT;                       
hndlCF: _CF._dwEffects &= ~dwT;                 // Default attribute off
        if(!*_szParam || _iParam)               // Effect is on
            _CF._dwEffects |= dwT;              // In either case, the effect
        break;                                  //  is defined

    case tokenStopUnderline:                    // \ulnone
        PARSERCOVERAGE_CASE();
        _CF._dwEffects &= ~CFE_UNDERLINE;       // Kill all underlining
        _dwMaskCF          |=  CFM_UNDERLINE;
        break;

    case tokenRevAuthor:                        // \revauth
        PARSERCOVERAGE_CASE();
        /* FUTURE: (alexgo) this doesn't work well now since we don't support
        revision tables.  We may want to support this better in the future.
        So what we do now is the 1.0 technique of using a color for the
        author */
        if(iParam > 0)
        {
            _CF._dwEffects &= ~CFE_AUTOCOLOR;
            _dwMaskCF |= CFM_COLOR;
            _CF._crTextColor = rgcrRevisions[(iParam - 1) & REVMASK];
        }
        break;

    case tokenUp:                               // \up
        PARSERCOVERAGE_CASE();
        dy = 10;
        goto StoreOffset;

    case tokenDown:                             // \down
        PARSERCOVERAGE_CASE();
        dy = -10;

StoreOffset:
        if(!*_szParam)
            iParam = dyDefaultSuperscript;
        _CF._yOffset = iParam * dy;             // Half points->twips
        _dwMaskCF |= CFM_OFFSET;
        break;

    case tokenSuperscript:                      // \super
        PARSERCOVERAGE_CASE();
         dwT = CFE_SUPERSCRIPT;
         goto SetSubSuperScript;

    case tokenSubscript:                        // \sub
        PARSERCOVERAGE_CASE();
         dwT = CFE_SUBSCRIPT;
         goto SetSubSuperScript;

    case tokenNoSuperSub:                       // \nosupersub
        PARSERCOVERAGE_CASE();
         dwT = 0;
SetSubSuperScript:
         _dwMaskCF     |=  (CFE_SUPERSCRIPT | CFE_SUBSCRIPT);
         _CF._dwEffects &= ~(CFE_SUPERSCRIPT | CFE_SUBSCRIPT);
         _CF._dwEffects |= dwT;
         break;



//--------------------- Paragraph Control Words -----------------------------

    case tokenStyleSheet:                       // \stylesheet
        PARSERCOVERAGE_CASE();
        pstate->sDest = destStyleSheet;
        _Style = 0;                             // Default normal style
        break;

    case tokenTabBar:                           // \tb
        PARSERCOVERAGE_CASE();
        _bTabType = PFT_BAR;                    // Fall thru to \tx

    case tokenTabPosition:                      // \tx. Ignore if in table
        PARSERCOVERAGE_CASE();                  //  since our simple model
        if(!pstate->fInTable)                   //  uses tab positions for
        {                                       //  cell widths
            if(_cTab < MAX_TAB_STOPS && (unsigned)iParam < 0x1000000)
            {
                _rgxCell[_cTab++] = GetTabPos(iParam)
                    + (_bTabType << 24) + (_bTabLeader << 28);
            }
            _dwMaskPF |= PFM_TABSTOPS;
        }
        break;

    case tokenDecimalTab:                       // \tqdec
    case tokenFlushRightTab:                    // \tqr
    case tokenCenterTab:                        // \tqc
        PARSERCOVERAGE_CASE();
        _bTabType = (BYTE)(_token - tokenCenterTab + PFT_CENTER);
        break;

    case tokenTabLeaderEqual:                   // \tleq
    case tokenTabLeaderThick:                   // \tlth
    case tokenTabLeaderUnderline:               // \tlul
    case tokenTabLeaderHyphen:                  // \tlhyph
    case tokenTabLeaderDots:                    // \tldot
        PARSERCOVERAGE_CASE();
        _bTabLeader = (BYTE)(_token - tokenTabLeaderDots + PFTL_DOTS);
        break;

    // The following need to be kept in sync with PFE_xxx
    case tokenCollapsed:                        // \collapsed
    case tokenSideBySide:                       // \sbys
    case tokenHyphPar:                          // \hyphpar
    case tokenNoWidCtlPar:                      // \nowidctlpar
    case tokenNoLineNumber:                     // \noline
    case tokenPageBreakBefore:                  // \pagebb
    case tokenKeepNext:                         // \keepn
    case tokenKeep:                             // \keep
    case tokenRToLPara:                         // \rtlpar
        PARSERCOVERAGE_CASE();
        wT = (WORD)(1 << (_token - tokenRToLPara));
        _PF._wEffects |= wT;
        _dwMaskPF |= (wT << 16);
        break;

    case tokenLToRPara:                         // \ltrpar
        PARSERCOVERAGE_CASE();
        _PF._wEffects &= ~PFE_RTLPARA;
        _dwMaskPF |= PFM_RTLPARA;
        break;

    case tokenLineSpacing:                      // \sl N
        PARSERCOVERAGE_CASE();
        _PF._dyLineSpacing = abs(iParam);
        _PF._bLineSpacingRule                   // Handle nonmultiple rules
                = (BYTE)(!iParam || iParam == 1000
                ? 0 : (iParam > 0) ? tomLineSpaceAtLeast
                    : tomLineSpaceExactly);     // \slmult can change (has to
        _dwMaskPF |= PFM_LINESPACING;           //  follow if it appears)
        break;

    case tokenDropCapLines:                     // \dropcapliN
        if(_PF._bLineSpacingRule == tomLineSpaceExactly)    // Don't chop off
            _PF._bLineSpacingRule = tomLineSpaceAtLeast;    //  drop cap
        break;

    case tokenLineSpacingRule:                  // \slmult N
        PARSERCOVERAGE_CASE();                  
        if(iParam)
        {                                       // It's multiple line spacing
            _PF._bLineSpacingRule = tomLineSpaceMultiple;
            _PF._dyLineSpacing /= 12;           // RE line spacing multiple is
            _dwMaskPF |= PFM_LINESPACING;       //  given in 20ths of a line,
        }                                       //  while RTF uses 240ths   
        break;

    case tokenSpaceBefore:                      // \sb N
        PARSERCOVERAGE_CASE();
        _PF._dySpaceBefore = iParam;
        _dwMaskPF |= PFM_SPACEBEFORE;
        break;

    case tokenSpaceAfter:                       // \sa N
        PARSERCOVERAGE_CASE();
        _PF._dySpaceAfter = iParam;
        _dwMaskPF |= PFM_SPACEAFTER;
        break;

    case tokenStyle:                            // \s N
        PARSERCOVERAGE_CASE();
        _Style = iParam;                        // Save it in case in StyleSheet
        if(pstate->sDest != destStyleSheet)
        {                                       // Select possible heading level
            _PF._sStyle = STYLE_NORMAL;         // Default Normal style
            _PF._bOutlineLevel |= 1;

            for(i = 0; i < NSTYLES && iParam != _rgStyles[i]; i++)
                ;                               // Check for heading style
            if(i < NSTYLES)                     // Found one
            {
                _PF._sStyle = (SHORT)(-i - 1);  // Store desired heading level
                _PF._bOutlineLevel = (BYTE)(2*(i-1));// Update outline level for
            }                                   //  nonheading styles
            _dwMaskPF |= PFM_ALLRTF;
        }
        break;

    case tokenIndentFirst:                      // \fi N
        PARSERCOVERAGE_CASE();
        _PF._dxStartIndent += _PF._dxOffset     // Cancel current offset
                            + iParam;           //  and add in new one
        _PF._dxOffset = -iParam;                    // Offset for all but 1st line
                                                //  = -RTF_FirstLineIndent
        _dwMaskPF |= (PFM_STARTINDENT | PFM_OFFSET);
        break;                      

    case tokenIndentLeft:                       // \li N
    case tokenIndentRight:                      // \ri N
        PARSERCOVERAGE_CASE();
        // AymanA: For RtL para indents has to be flipped.
        Assert(PFE_RTLPARA == 0x0001);
        if((_token == tokenIndentLeft) ^ (_PF.IsRtlPara()))
        {
            _PF._dxStartIndent = iParam - _PF._dxOffset;
            _dwMaskPF |= PFM_STARTINDENT;
        }
        else
        {
            _PF._dxRightIndent = iParam;
            _dwMaskPF |= PFM_RIGHTINDENT;
        }
        break;

    case tokenAlignLeft:                        // \ql
    case tokenAlignRight:                       // \qr
    case tokenAlignCenter:                      // \qc
    case tokenAlignJustify:                     // \qj
        PARSERCOVERAGE_CASE();
        if(!pstate->fInTable)
        {
            _PF._bAlignment = (WORD)(_token - tokenAlignLeft + PFA_LEFT);
            _dwMaskPF |= PFM_ALIGNMENT;
        }
        break;

    case tokenBorderOutside:                    // \brdrbar
    case tokenBorderBetween:                    // \brdrbtw
    case tokenBorderShadow:                     // \brdrsh
        PARSERCOVERAGE_CASE();
        _PF._dwBorderColor |= 1 << (_token - tokenBorderShadow + 20);
        _dwBorderColor = _PF._dwBorderColor;
        break;

    // Paragraph and cell border segments
    case tokenBox:                              // \box
        PARSERCOVERAGE_CASE();
        _PF._wEffects |= PFE_BOX;
        _dwMaskPF    |= PFM_BOX;
        _bBorder = 0;                           // Store parms as if for
        break;                                  //  \brdrt

    case tokenCellBorderRight:                  // \clbrdrr
    case tokenCellBorderBottom:                 // \clbrdrb
    case tokenCellBorderLeft:                   // \clbrdrl
    case tokenCellBorderTop:                    // \clbrdrt
    case tokenBorderRight:                      // \brdrr
    case tokenBorderBottom:                     // \brdrb
    case tokenBorderLeft:                       // \brdrl
    case tokenBorderTop:                        // \brdrt
        PARSERCOVERAGE_CASE();
        _bBorder = (BYTE)(_token - tokenBorderTop);
        break;

    // Paragraph border styles
    case tokenBorderTriple:                     // \brdrtriple
    case tokenBorderDoubleThick:                // \brdrth
    case tokenBorderSingleThick:                // \brdrs
    case tokenBorderHairline:                   // \brdrhair
    case tokenBorderDot:                        // \brdrdot
    case tokenBorderDouble:                     // \brdrdb
    case tokenBorderDashSmall:                  // \brdrdashsm
    case tokenBorderDash:                       // \brdrdash
        PARSERCOVERAGE_CASE();
        if(_bBorder < 4)                        // Only for paragraphs
            SetBorderParm(_PF._wBorders, _token - tokenBorderDash);
        break;

    case tokenBorderColor:                      // \brdrcf
        PARSERCOVERAGE_CASE();
        if(_bBorder < 4)                        // Only for paragraphs
        {
            iParam = GetStandardColorIndex();
            _PF._dwBorderColor &= ~(0x1F << (5*_bBorder));
            _PF._dwBorderColor |= iParam << (5*_bBorder);
            _dwBorderColor = _PF._dwBorderColor;
        }
        break;

    case tokenBorderWidth:                      // \brdrw
        PARSERCOVERAGE_CASE();                  // Width is in half pts
        if(_bBorder < 4)                        // For paragraphs
        {                                       // iParam is in twips
            if(IN_RANGE(1, iParam, 4))          // Give small but nonzero
                iParam = 1;                     //  values our minimum
            else                                //  size
                iParam = (iParam + 5)/10;

            SetBorderParm(_PF._wBorderWidth, iParam);
        }
        else                                    // For cells only have 2 bits
        {
            iParam = (iParam + 10)/20;
            iParam = max(iParam, 1);
            iParam = min(iParam, 3);
            _bCellBrdrWdths |= iParam << 2*(_bBorder - 4);
        }
        break;

    case tokenBorderSpace:                      // \brsp
        PARSERCOVERAGE_CASE();                  // Space is in pts
        if(_bBorder < 4)                        // Only for paragraphs
            SetBorderParm(_PF._wBorderSpace, iParam/20);// iParam is in twips
        break;

    // Paragraph shading
    case tokenBckgrndVert:                      // \bgvert
    case tokenBckgrndHoriz:                     // \bghoriz
    case tokenBckgrndFwdDiag:                   // \bgfdiag
    case tokenBckgrndDrkVert:                   // \bgdkvert
    case tokenBckgrndDrkHoriz:                  // \bgdkhoriz
    case tokenBckgrndDrkFwdDiag:                // \bgdkfdiag
    case tokenBckgrndDrkDiagCross:              // \bgdkdcross
    case tokenBckgrndDrkCross:                  // \bgdkcross
    case tokenBckgrndDrkBckDiag:                // \bgdkbdiag
    case tokenBckgrndDiagCross:                 // \bgdcross
    case tokenBckgrndCross:                     // \bgcross
    case tokenBckgrndBckDiag:                   // \bgbdiag
        PARSERCOVERAGE_CASE();
        _PF._wShadingStyle = (WORD)((_PF._wShadingStyle & 0xFFC0)
                        | (_token - tokenBckgrndBckDiag + 1));
        _dwMaskPF |= PFM_SHADING;
        break;

    case tokenColorBckgrndPat:                  // \cbpat
        PARSERCOVERAGE_CASE();
        iParam = GetStandardColorIndex();
        _PF._wShadingStyle = (WORD)((_PF._wShadingStyle & 0x07FF) | (iParam << 11));
        _dwMaskPF |= PFM_SHADING;
        break;

    case tokenColorForgrndPat:                  // \cfpat
        PARSERCOVERAGE_CASE();
        iParam = GetStandardColorIndex();
        _PF._wShadingStyle = (WORD)((_PF._wShadingStyle & 0xF83F) | (iParam << 6));
        _dwMaskPF |= PFM_SHADING;
        break;

    case tokenShading:                          // \shading
        PARSERCOVERAGE_CASE();
        _PF._wShadingWeight = (WORD)iParam;
        _dwMaskPF |= PFM_SHADING;
        break;

    // Paragraph numbering
    case tokenParaNum:                          // \pn
        PARSERCOVERAGE_CASE();
        pstate->sDest = destParaNumbering;
        pstate->fBullet = FALSE;
        _PF._wNumberingStart = 1;
        _dwMaskPF |= PFM_NUMBERINGSTART;
        break;

    case tokenParaNumIndent:                    // \pnindent N
        PARSERCOVERAGE_CASE();
        if(pstate->sDest == destParaNumbering)
            pstate->sIndentNumbering = (SHORT)iParam;
        break;

    case tokenParaNumStart:                     // \pnstart N
        PARSERCOVERAGE_CASE();
        if(pstate->sDest == destParaNumbering)
        {
            _PF._wNumberingStart = (WORD)iParam;
            _dwMaskPF |= PFM_NUMBERINGSTART;
        }
        break;

    case tokenParaNumCont:                      // \pnlvlcont
        PARSERCOVERAGE_CASE();                  
        _prg->_rpPF.AdjustBackward();           // Maintain numbering mode
        _PF._wNumbering = _prg->GetPF()->_wNumbering;
        _prg->_rpPF.AdjustForward();
        _wNumberingStyle = PFNS_NONUMBER;       // Signal no number
        _dwMaskPF |= PFM_NUMBERING;             // Note: can be new para with
        pstate->fBullet = TRUE;                 //  its own indents
        break;

    case tokenParaNumBody:                      // \pnlvlbody
        PARSERCOVERAGE_CASE();
        _wNumberingStyle = PFNS_PAREN;
        _token = tokenParaNumDecimal;           // Default to decimal
        goto setnum;
        
    case tokenParaNumBullet:                    // \pnlvlblt
        _wNumberingStyle = 0;                   // Reset numbering styles
        goto setnum;

    case tokenParaNumDecimal:                   // \pndec
    case tokenParaNumLCLetter:                  // \pnlcltr
    case tokenParaNumUCLetter:                  // \pnucltr
    case tokenParaNumLCRoman:                   // \pnlcrm
    case tokenParaNumUCRoman:                   // \pnucrm
        PARSERCOVERAGE_CASE();
        if(_PF._wNumbering == PFN_BULLET && pstate->fBullet)
            break;                              // Ignore above for bullets

setnum: if(pstate->sDest == destParaNumbering)
        {
            _PF._wNumbering = (WORD)(PFN_BULLET + _token - tokenParaNumBullet);
            _dwMaskPF |= PFM_NUMBERING;
            pstate->fBullet = TRUE;             // We do bullets, so don't
        }                                       //  output the \pntext group
        break;

    case tokenParaNumText:                      // \pntext
        PARSERCOVERAGE_CASE();
        // Throw away previously read paragraph numbering and use
        //  the most recently read to apply to next run of text.
        _cchUsedNumText = 0;
        pstate->sDest = destParaNumText;
        break;

    case tokenParaNumAlignCenter:               // \pnqc
    case tokenParaNumAlignRight:                // \pnqr
        PARSERCOVERAGE_CASE();
        _wNumberingStyle = (_wNumberingStyle & ~3) | _token - tokenParaNumAlignCenter + 1;
        break;

    case tokenParaNumAfter:                     // \pntxta
    case tokenParaNumBefore:                    // \pntxtb
    case tokenPictureQuickDraw:                 // \macpict
    case tokenPictureOS2Metafile:               // \pmmetafile
        PARSERCOVERAGE_CASE();

skip_group:
        if(!SkipToEndOfGroup())
        {
            // During \fonttbl processing, we may hit unknown destinations,
            // e.g., \panose, that cause the HandleEndGroup to select the
            // default font, which may not be defined yet.  So, we change
            // sDest to avoid this problem.
            if(pstate->sDest == destFontTable || pstate->sDest == destStyleSheet)
                pstate->sDest = destNULL;
            HandleEndGroup();
        }
        break;

    // Tables
    case tokenInTable:                          // \intbl
        PARSERCOVERAGE_CASE();
        // Our simple table model has one para per row, i.e., no paras in
        // cells. Also no tabs in cells (both are converted to blanks). On
        // receipt of \intbl, transfer stored table info into _PF.
        if(_fInTable)
            _ecParseError = ecGeneralFailure;

        _dwMaskPF |= PFM_TABSTOPS;
        if(_wBorderWidth)                       // Store any border info
        {
            _PF._dwBorderColor = _dwBorderColor;
            _PF._wBorders     = _wBorders;
            _PF._wBorderSpace  = _wBorderSpace;
            _PF._wBorderWidth  = _wBorderWidth;
            _dwMaskPF |= PFM_BORDER;
        }

        _PF._bAlignment   = _bAlignment;        // Row alignment (no cell align)
        _PF._dxStartIndent = _xRowOffset;       // \trleft N
        _PF._dxOffset     = _dxCell;            // \trgaph N
        _PF._wEffects |= PFE_TABLE;             
        _dwMaskPF    |= PFM_TABLE | PFM_OFFSET | PFM_ALIGNMENT;
        pstate->fInTable = TRUE;                
        break;

    case tokenCell:                             // \cell
        PARSERCOVERAGE_CASE();
        if(_fInTable)
            _ecParseError = ecGeneralFailure;

        else if(pstate->fInTable)                   
        {                                       
            if(!_cCell && _iTabsTable >= 0 &&			// No cells defined here;
				_iTabsTable < GetTabsCache()->Count())	// Use previous table defs
            {
                CTabs *pTabs = GetTabsCache()->Elem(_iTabsTable);
				if (pTabs)
				{
					_cCell = pTabs->_cTab;
					for(int i = _cCell; i--; )
						_rgxCell[i] = pTabs->_prgxTabs[i];
				}

            }
            if(_iCell < _cCell)                 // Don't add more cells than
            {                                   //  defined, since Word crashes
                _iCell++;                       // Count cells inserted
                HandleChar(CELL);               // Insert cell delimiter
            }
        }
        break;

    case tokenCellHalfGap:                      // \trgaph N
        PARSERCOVERAGE_CASE();                  // Save half space between
        _dxCell = iParam;                       //  cells to add to tabs
        break;                                  // Roundtrip value at end of
                                                //  tab array
    case tokenCellX:                            // \cellx N
        PARSERCOVERAGE_CASE();
        if(_cCell < MAX_TAB_STOPS)              // Save cell right boundaries
        {                                       //  for tab settings in our
            if(!_cCell)                         //  primitive table model
            {                                   // Save border info
                _wBorders = _PF._wBorders;
                _wBorderSpace = _PF._wBorderSpace;
                _wBorderWidth = _PF._wBorderWidth;
            }
            _rgxCell[_cCell++] = iParam + (_bCellBrdrWdths << 24);
            _bCellBrdrWdths = 0;
        }
        break;

    case tokenRowDefault:                       // \trowd
        PARSERCOVERAGE_CASE();
		if(_fInTable)							// Can't insert a table into
		{										//  a table in RE 3.0
            _ecParseError = ecGeneralFailure;
			break;
		}
        // Insert newline if we are inserting a table behind characters in the
        // same line.  This follows the Word9 model.
        if (_cpFirst == _prg->GetCp() && _cpThisPara != _cpFirst)
        {
            EC ec  = _ped->fUseCRLF()           // If RichEdit 1.0 compatibility
                ? HandleText(szaCRLF, ALL_ASCII)//  mode, use CRLF; else CR
                : HandleChar((unsigned)(CR));
            if(ec == ecNoError)
                _cpThisPara = _prg->GetCp();    // New para starts after CRLF
        }

        _cCell = 0;                             // No cell right boundaries
        _dxCell = 0;                            //  or half gap defined yet
        _xRowOffset = 0;
        _bCellBrdrWdths = 0;
        _wBorderWidth = 0;                      // No borders yet
        _dwBorderColor  = 0;
        _bAlignment = PFA_LEFT;
        _iTabsTable = -1;                       // No cell widths yet
        break;

    case tokenRowLeft:                          // \trleft
        PARSERCOVERAGE_CASE();
        _xRowOffset = iParam;
        break;
                                                
    case tokenRowAlignCenter:                   // \trqc
    case tokenRowAlignRight:                    // \trqr
        PARSERCOVERAGE_CASE();
        _bAlignment = (WORD)(_token - tokenRowAlignRight + PFA_RIGHT);
        break;

    case tokenPage:                             // \page

        // FUTURE: we want to be smarter about handling FF. But for
        // now we just ignore it for bulletted and number paragraphs
        // and just make it an EOP otherwise.
        if (_PF._wNumbering != 0)
            break;

        // Intentional fall thru to EOP.
    case tokenEndParagraph:                     // \par
    case tokenLineBreak:                        // \line
        PARSERCOVERAGE_CASE();
        if(_pstateStackTop->fInTable)
            HandleChar(' ');                    // Just use a blank for \par
        else                                    //  in table
        {
            _cCell = 0;
            HandleEndOfPara();
        }
        break;                              

    case tokenRow:                              // \row. Treat as hard CR
        PARSERCOVERAGE_CASE();
        for( ; _iCell < _cCell; _iCell++)       // If not enuf cells, add
            HandleChar(CELL);                   //  them since Word crashes
        _iCell = 0;                             //  if \cellx count differs
        HandleEndOfPara();                      //  from \cell count
        break;

    case tokenParagraphDefault:                 // \pard
        PARSERCOVERAGE_CASE();
		if(IN_RANGE(destColorTable, pstate->sDest, destPicture))
		{
			_ecParseError = ecUnexpectedChar;
			break;
		}
        if(pstate->sDest == destParaNumText)    // Ignore if \pn destination
            break;
                                                // Else fall thru to \secd
    case tokenEndSection:                       // \sect
    case tokenSectionDefault:                   // \sectd
        PARSERCOVERAGE_CASE();
        bT = _PF._bOutlineLevel;
        
        // Save outline level
        _PF.InitDefault(_bDocType == DT_RTLDOC ? PFE_RTLPARA : 0);
                                                // Reset para formatting
        pstate->fInTable = FALSE;               // Reset in table flag
        pstate->fBullet = FALSE;
        pstate->sIndentNumbering = 0;
        _cTab           = 0;                    // No tabs defined
        _bTabLeader     = 0;
        _bTabType       = 0;
        _bBorder        = 0;
        _PF._bOutlineLevel = (BYTE)(bT | 1);
        _dwMaskPF       = PFM_ALLRTF;
        break;


//----------------------- Field and Group Control Words --------------------------------
    // Note that we currently don't support nested fields.  For nested
    // fields, the usage of _szSymbolFieldResult, _FieldCF, _ptfField
    // and _sFieldCodePage needs to be rethought.

    case tokenField:                            // \field
        PARSERCOVERAGE_CASE();

        if (pstate->sDest == destDocumentArea ||
            pstate->sDest == destLeadingPunct ||
            pstate->sDest == destFollowingPunct ||
            pstate->fFieldInst)
        {
            // We're not equipped to handle symbols in these destinations, and
            // we don't want the fields added accidentally to document text.
            goto skip_group;
        }

        pstate->sDest = destField;
        
        _nFieldCodePage = pstate->nCodePage;    // init, for safety
        _ptfField = NULL;
        _fRestoreFieldFormat = TRUE;
        break;

    case tokenFieldResult:                      // \fldrslt
        PARSERCOVERAGE_CASE();

        pstate->fFieldInst = FALSE;
        pstate->fFieldRslt = TRUE;

        // Restore the formatting from the field instruction
        // when we are doing Hyperlink
        if(_fRestoreFieldFormat && _fHyperlinkField)
        {           
            _CF = _FieldCF;
            pstate->ptf = _ptfField;
            pstate->SetCodePage(_nFieldCodePage);
            _dwMaskCF = _dwMaskFieldCF;
            _dwMaskCF2 = _dwMaskFieldCF2;
        }
        _fRestoreFieldFormat = FALSE;

        if(!_fHyperlinkField)
        {
            // for SYMBOL
            pstate->sDest = destField;
            break;
        }

        // for HYPERLINK
        
        // By now, we should have the whole hyperlink fldinst string
        if(_szHyperlinkFldinst)
        {
            // V-GUYB: PWord Converter requires loss notification.
            // (Hyperlinks are NOT streamed out later)
            #ifdef REPORT_LOSSAGE
            if(!(_dwFlags & SFF_SELECTION)) // SFF_SELECTION is set if any kind of paste is being done.
            {
                ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = TRUE;
            }
            #endif // REPORT_LOSSAGE
        
            BYTE * pNewBuffer = NULL;

            // Check if this is a friendly name
            if(_szHyperlinkFldinst[1] == '\"')
            {   
                // This is a friendly name, replace quotes with <>.
                // Also, for an unknown reason, Word escapes some chars in its HYPERLINK presentation
                // we have to get rid of the backslashes

                BYTE *  pSrc = &_szHyperlinkFldinst[2];
                BYTE *  pBuffer;
                BOOL    fLeadByte = FALSE;
                LONG    CodePage;

                CodePage = IsFECharSet(_bInstFieldCharSet) ? GetCodePage(_bInstFieldCharSet): 0;

                pNewBuffer = (BYTE *)PvAlloc(_cchHyperlinkFldinstUsed+1, GMEM_ZEROINIT);
                if(!pNewBuffer)
                {
                    _ecParseError = ecNoMemory;
                    break;
                }

                pBuffer = pNewBuffer;
                *pBuffer++ = ' ';
                *pBuffer++ = '<';

                do
                {
                    if(!fLeadByte && *pSrc == '\\') // Get rid of backslashes
                        pSrc++;

                    else if(*pSrc == '\"')
                    {
                        *pBuffer = '>';             // Find end quote
                        break;
                    }
                    else if(CodePage)
                    {
                        // Check if this is a valid Lead byte.
                        fLeadByte = fLeadByte ? FALSE : GetTrailBytesCount(*pSrc, CodePage);
                    }
                } while (*pBuffer++ = *pSrc++);                     
            }

            // No longer need this buffer...
            FreePv(_szHyperlinkFldinst);

            // Setup for the new scanned buffer
            _szHyperlinkFldinst = pNewBuffer;
            _cchHyperlinkFldinst = _cchHyperlinkFldinstUsed+1;
        }

        pstate->sDest = destFieldResult;
        if(_szHyperlinkFldinst)
        {           
            // Pre-alloc a buffer for the fldrslt strings
            _cchHyperlinkFldrslt = MAX_PATH;
            _cchHyperlinkFldrsltUsed = 0;
            _szHyperlinkFldrslt = (BYTE *)PvAlloc(_cchHyperlinkFldrslt, GMEM_FIXED);

            if(!_szHyperlinkFldrslt)
            {
                _ecParseError = ecNoMemory;
                break;
            }
            _szHyperlinkFldrslt[0] = 0;         // No text yet
        }
        else
        {
            _cchHyperlinkFldrslt = 0;
            _cchHyperlinkFldrsltUsed = 0;
            FreePv(_szHyperlinkFldrslt);

            // No friendly HYPERLINK name, no need to accumulate fldrslt strings
            _szHyperlinkFldrslt = 0;
            _fHyperlinkField = FALSE;
        }
        break;

    case tokenFieldInstruction:                 // \fldinst
        PARSERCOVERAGE_CASE();
        if(pstate->fFieldInst || pstate->fFieldRslt)
            goto skip_group;                    // Skip nested field instr
        pstate->fFieldInst = TRUE;              // TODO: skip what follows up to \fldrslt
        pstate->sDest = destFieldInstruction;
        break;

    case tokenStartGroup:                       // Save current state by
        PARSERCOVERAGE_CASE();                  //  pushing it onto stack
        _cbSkipForUnicode = 0;
        HandleStartGroup();
        if (_fNoRTFtoken)
        {
            // Hack Alert !!!!! FOr 1.0 compatibility to allow no \rtf token.
            _fNoRTFtoken = FALSE;
            pstate = _pstateStackTop;
            goto rtf;
        }
        break;

    case tokenEndGroup:
        PARSERCOVERAGE_CASE();
        _cbSkipForUnicode = 0;

        HandleFieldEndGroup();                  // Special end group handling for \field
        HandleEndGroup();                       // Restore save state by
        break;                                  //  popping stack

    case tokenOptionalDestination:              // (see case tokenUnknown)
        PARSERCOVERAGE_CASE();
        break;

    case tokenNullDestination:                  // We've found a destination
        PARSERCOVERAGE_CASE();
        // tokenNullDestination triggers a loss notifcation here for...
        //      Footer related tokens - "footer", "footerf", "footerl", "footerr",
        //                              "footnote", "ftncn", "ftnsep", "ftnsepc"
        //      Header related tokens - "header", "headerf", "headerl", "headerr"
        //      Table of contents     - "tc"
        //      Index entries         - "xe"

        // V-GUYB: PWord Converter requires loss notification.
        #ifdef REPORT_LOSSAGE
        if(!(_dwFlags & SFF_SELECTION)) // SFF_SELECTION is set if any kind of paste is being done.
        {
            ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = TRUE;
        }
        #endif // REPORT_LOSSAGE
        
        goto skip_group;                        // for which we should ignore
                                                // the remainder of the group
    case tokenUnknownKeyword:
        PARSERCOVERAGE_CASE();
        if(_tokenLast == tokenOptionalDestination)
            goto skip_group;
        break;                                  // Nother place for
                                                //  unrecognized RTF


//-------------------------- Text Control Words --------------------------------

    case tokenUnicode:                          // \u <n>
        PARSERCOVERAGE_CASE();

        // FUTURE: for now, we will ignore \u <n> when we are handling fields.
        // We should re-visit the HYPERLINK handling where we are accumulating
        // ASCII text.  We will have to switch to aaccumulate Unicode in order
        // to insert this \u <n> into the string.
        if(_fHyperlinkField || pstate->fFieldInst)
            break;

        _dwMaskCF2      |=  CFM2_RUNISDBCS;
        _CF._dwEffects  &= ~CFE_RUNISDBCS;
        wT = (WORD)iParam;                      // Treat as unsigned integer
        if(pstate->ptf && pstate->ptf->bCharSet == SYMBOL_CHARSET)
        {
            if(IN_RANGE(0xF000, wT, 0xF0FF))    // Compensate for converters
                wT -= 0xF000;                   //  that write symbol codes
                                                //  up high
            else if(wT > 255)                   // Whoops, RTF is using con-                    
            {                                   //  verted value for symbol:
                char ach;                       //  convert back
                WCTMB(1252, 0, &wT, 1, &ach, 1, NULL, NULL, NULL);
                wT = (BYTE)ach;                 // Review: use CP_ACP??
            }
        }
        _cbSkipForUnicode = pstate->cbSkipForUnicodeMax;
        AddText((TCHAR *)&wT, 1, TRUE);         //  (avoids endian problems)
        break;

    case tokenUnicodeCharByteCount:             // \ucN
        PARSERCOVERAGE_CASE();
		if(IN_RANGE(0, iParam, 2))
			pstate->cbSkipForUnicodeMax = (WORD)iParam;
        break;

    case tokenText:                             // Lexer concludes tokenText
    case tokenASCIIText:
        PARSERCOVERAGE_CASE();
        switch (pstate->sDest)
        {
        case destColorTable:
            pclrf = _colors.Add(1, NULL);
            if(!pclrf)
                goto OutOfRAM;

            *pclrf = _fGetColorYet ?
                RGB(pstate->bRed, pstate->bGreen, pstate->bBlue) : tomAutoColor;

            // Prepare for next color table entry
            pstate->bRed =                      
            pstate->bGreen =                    
            pstate->bBlue = 0;
            _fGetColorYet = FALSE;              // in case more "empty" color
            break;

        case destFontTable:
            if(!pstate->fRealFontName)
            {
                ReadFontName(pstate,
                                _token == tokenASCIIText ?
                                        ALL_ASCII : CONTAINS_NONASCII);
            }
            break;

        case destRealFontName:
        {
            STATE * const pstatePrev = pstate->pstatePrev;

            if(pstatePrev && pstatePrev->sDest == destFontTable)
            {
                // Mark previous state so that tagged font name will be ignored
                // AROO: Do this before calling ReadFontName so that
                // AROO: it doesn't try to match font name
                pstatePrev->fRealFontName = TRUE;
                ReadFontName(pstatePrev,
                        _token == tokenASCIIText ? ALL_ASCII : CONTAINS_NONASCII);
            }

            break;
        }

        case destFieldInstruction:
            if(_szHyperlinkFldinst)
            {
                if(!IsFECharSet(_bInstFieldCharSet) && IsFECharSet(_CF._bCharSet))
                    _bInstFieldCharSet = _CF._bCharSet;

                _ecParseError = AppendString(& _szHyperlinkFldinst, _szText, &_cchHyperlinkFldinst, &_cchHyperlinkFldinstUsed );
            }
            else
            {
                HandleFieldInstruction();
                _bInstFieldCharSet = _CF._bCharSet;
            }
            break;

        case destObjectClass:
            if(StrAlloc(&_prtfObject->szClass, _szText))
                goto OutOfRAM;
            break;
            
        case destObjectName:
            if(StrAlloc(&_prtfObject->szName, _szText))
                goto OutOfRAM;
            break;

        case destStyleSheet:
            // _szText has style name, e.g., "heading 1"
            if(W32->ASCIICompareI(_szText, (unsigned char *)"heading", 7))
            {
                dwT = (unsigned)(_szText[8] - '0');
                if(dwT < NSTYLES)
                    _rgStyles[dwT] = (BYTE)_Style;
            }
            break;

        case destDocumentArea:
        case destFollowingPunct:
        case destLeadingPunct:
            break;

// This has been changed now.  We will store the Punct strings as
// raw text strings.  So, we don't have to convert them.
// This code is keep here just in case we want to change back.
#if 0
        case destDocumentArea:
            if (_tokenLast != tokenFollowingPunct &&
                _tokenLast != tokenLeadingPunct)
            {
                break;
            }                                       // Else fall thru to
                                                    //  destFollowingPunct
        case destFollowingPunct:
        case destLeadingPunct:
            // TODO(BradO):  Consider some kind of merging heuristic when
            //  we paste FE RTF (for lead and follow chars, that is).
            if(!(_dwFlags & SFF_SELECTION))
            {
                int cwch = MBTWC(INVALID_CODEPAGE, 0,
                                        (char *)_szText, -1,
                                        NULL, 0,
                                        NULL);
                Assert(cwch);
                WCHAR *pwchBuf = (WCHAR *)PvAlloc(cwch * sizeof(WCHAR), GMEM_ZEROINIT);

                if(!pwchBuf)
                    goto OutOfRAM;

                SideAssert(MBTWC(INVALID_CODEPAGE, 0,
                                    (char *)_szText, -1,
                                    pwchBuf, cwch,
                                    NULL) > 0);

                if(pstate->sDest == destFollowingPunct)
                    _ped->SetFollowingPunct(pwchBuf);
                else
                {
                    Assert(pstate->sDest == destLeadingPunct);
                    _ped->SetLeadingPunct(pwchBuf);
                }
                FreePv(pwchBuf);
            }
            break;
#endif

        case destFieldResult:
            if(_szSymbolFieldResult)            // Field has been recalculated
                break;                          // old result out of use
            if(_szHyperlinkFldrslt)             // Append _szText to _szHyperlinkFldrslt
            {
                _ecParseError = AppendString(&_szHyperlinkFldrslt, _szText,
                                  &_cchHyperlinkFldrslt, &_cchHyperlinkFldrsltUsed);
                break;
            }
            // FALL THRU to default case

        default:
            HandleText(_szText, _token == tokenASCIIText ? ALL_ASCII : CONTAINS_NONASCII);
        }
        break;

    // \ltrmark, \rtlmark, \zwj, and \zwnj are translated directly into
    // their Unicode values. \ltrmark and \rtlmark cause no further
    // processing here because we assume that the current font has the
    // CharSet needed to identify the direction.
    case tokenLToRChars:                        // \ltrch
    case tokenRToLChars:                        // \rtlch
        pstate->fltrch = (_token == tokenLToRChars);
        pstate->frtlch = !pstate->fltrch;
        _ped->OrCharFlags(fBIDI);
        break;

    case tokenDBChars:                          // \dbch
        pstate->fdbch = TRUE;
        break;

    case tokenLToRDocument:                     // \ltrdoc
        PARSERCOVERAGE_CASE();
        _bDocType = DT_LTRDOC;
        break;

    case tokenRToLDocument:                     // \rtldoc
        PARSERCOVERAGE_CASE();
        _bDocType = DT_RTLDOC;
        break;


//------------------------- Object Control Words --------------------------------

    case tokenObject:                           // \object
        PARSERCOVERAGE_CASE();
        // V-GUYB: PWord Converter requires loss notification.
        #ifdef REPORT_LOSSAGE
        if(!(_dwFlags & SFF_SELECTION)) // SFF_SELECTION is set if any kind of paste is being done.
        {
            ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = TRUE;
        }
        #endif // REPORT_LOSSAGE
        
        // Assume that the object failed to load until proven otherwise
        //  by RTFRead::ObjectReadFromEditStream
        // This works for both:
        //  - an empty \objdata tag
        //  - a non-existent \objdata tag
        _fFailedPrevObj = TRUE;

    case tokenPicture:                          // \pict
        PARSERCOVERAGE_CASE();

        pstate->sDest = (SHORT)(_token == tokenPicture ? destPicture : destObject);

        FreeRtfObject();
        _prtfObject = (RTFOBJECT *) PvAlloc(sizeof(RTFOBJECT), GMEM_ZEROINIT);
        if(!_prtfObject)
            goto OutOfRAM;
        _prtfObject->xScale = _prtfObject->yScale = 100;
        _prtfObject->cBitsPerPixel = 1;
        _prtfObject->cColorPlanes = 1;
        _prtfObject->szClass = NULL;
        _prtfObject->szName = NULL;
        _prtfObject->sType = -1;
        break;

    case tokenObjectEmbedded:                   // \objemb
    case tokenObjectLink:                       // \objlink
    case tokenObjectAutoLink:                   // \objautlink
        PARSERCOVERAGE_CASE();
        _prtfObject->sType = (SHORT)(_token - tokenObjectEmbedded + ROT_Embedded);
        break;

    case tokenObjectMacSubscriber:              // \objsub
    case tokenObjectMacPublisher:               // \objpub
    case tokenObjectMacICEmbedder:
        PARSERCOVERAGE_CASE();
        _prtfObject->sType = ROT_MacEdition;
        break;

    case tokenWidth:                            // \picw or \objw
        PARSERCOVERAGE_CASE();
        _prtfObject->xExt = iParam;
        break;

    case tokenHeight:                           // \pic or \objh
        PARSERCOVERAGE_CASE();
        _prtfObject->yExt = iParam;
        break;

    case tokenObjectSetSize:                    // \objsetsize
        PARSERCOVERAGE_CASE();
        _prtfObject->fSetSize = TRUE;
        break;

    case tokenScaleX:                           // \picscalex or \objscalex
        PARSERCOVERAGE_CASE();
        _prtfObject->xScale = iParam;
        break;

    case tokenScaleY:                           // \picscaley or \objscaley
        PARSERCOVERAGE_CASE();
        _prtfObject->yScale = iParam;
        break;

    case tokenCropLeft:                         // \piccropl or \objcropl
    case tokenCropTop:                          // \piccropt or \objcropt
    case tokenCropRight:                        // \piccropr or \objcropr
    case tokenCropBottom:                       // \piccropb or \objcropb
        PARSERCOVERAGE_CASE();
        *((LONG *)&_prtfObject->rectCrop
            + (_token - tokenCropLeft)) = iParam;
        break;

    case tokenObjectClass:                      // \objclass
        PARSERCOVERAGE_CASE();
        pstate->sDest = destObjectClass;
        break;

    case tokenObjectName:                       // \objname
        PARSERCOVERAGE_CASE();
        pstate->sDest = destObjectName;
        break;

    case tokenObjectResult:                     // \result
        PARSERCOVERAGE_CASE();
		if(_prtfObject->sType==ROT_MacEdition ||// If it's Mac stuff, we don't understand the data, 
		   _fFailedPrevObj || _fNeedPres)		//  or if we need an obj presentation,
		{
			pstate->sDest = destRTF;			//  use the object results
			break;
		}
		goto skip_group;

    case tokenObjectData:                       // \objdata
        PARSERCOVERAGE_CASE();
        pstate->sDest = destObjectData;
        if(_prtfObject->sType==ROT_MacEdition)  // It's Mac stuff so just
            goto skip_group;                    //  throw away the data
        break;

    case tokenPictureWindowsMetafile:           // wmetafile
#ifdef NOMETAFILES
        goto skip_group;
#endif NOMETAFILES

    case tokenPictureWindowsBitmap:             // wbitmap
    case tokenPictureWindowsDIB:                // dibitmap
        PARSERCOVERAGE_CASE();
        _prtfObject->sType = (SHORT)(_token - tokenPictureWindowsBitmap + ROT_Bitmap);
        _prtfObject->sPictureType = (SHORT)iParam;
        break;

    case tokenBitmapBitsPerPixel:               // \wbmbitspixel
        PARSERCOVERAGE_CASE();
        _prtfObject->cBitsPerPixel = (SHORT)iParam;
        break;

    case tokenBitmapNumPlanes:                  // \wbmplanes
        PARSERCOVERAGE_CASE();
        _prtfObject->cColorPlanes = (SHORT)iParam;
        break;

    case tokenBitmapWidthBytes:                 // \wbmwidthbytes
        PARSERCOVERAGE_CASE();
        _prtfObject->cBytesPerLine = (SHORT)iParam;
        break;

    case tokenDesiredWidth:                     // \picwgoal
        PARSERCOVERAGE_CASE();
        _prtfObject->xExtGoal = (SHORT)iParam;
        break;

    case tokenDesiredHeight:                    // \pichgoal
        PARSERCOVERAGE_CASE();
        _prtfObject->yExtGoal = (SHORT)iParam;
        break;

    case tokenBinaryData:                       // \bin
        PARSERCOVERAGE_CASE();

        if(_cbSkipForUnicode)
        {
            // a \binN and its associated binary data count as a single
            //  character for the purposes of skipping over characters
            //  following a \uN
            _cbSkipForUnicode--;
            SkipBinaryData(iParam);
        }
        else
        {
            // update OleGet function
            RTFReadOLEStream.lpstbl->Get =
                    (DWORD (CALLBACK* )(LPOLESTREAM, void FAR*, DWORD))
                           RTFGetBinaryDataFromStream;
            // set data length
            _cbBinLeft = iParam;
        
            switch (pstate->sDest)
            {
                case destObjectData:
                    _fFailedPrevObj = !ObjectReadFromEditStream();
                    break;
                case destPicture:
                    StaticObjectReadFromEditStream(iParam);
                    break;

                default:
                    AssertSz(FALSE, "Binary data hit but don't know where to put it");
            }

            // restore OleGet function
            RTFReadOLEStream.lpstbl->Get =
                    (DWORD (CALLBACK* )(LPOLESTREAM, void FAR*, DWORD))
                        RTFGetFromStream;
        }

        break;

    case tokenObjectDataValue:
        PARSERCOVERAGE_CASE();
        _fFailedPrevObj = !ObjectReadFromEditStream();
        goto EndOfObjectStream;
    
    case tokenPictureDataValue:
        PARSERCOVERAGE_CASE();
        StaticObjectReadFromEditStream();
EndOfObjectStream:
        if(!SkipToEndOfGroup())
            HandleEndGroup();
        break;          

    case tokenObjectPlaceholder:
        PARSERCOVERAGE_CASE();
        if(_ped->GetEventMask() & ENM_OBJECTPOSITIONS)
        {
            if(!_pcpObPos)
            {
                _pcpObPos = (LONG *)PvAlloc(sizeof(ULONG) * cobPosInitial, GMEM_ZEROINIT);
                if(!_pcpObPos)
                {
                    _ecParseError = ecNoMemory;
                    break;
                }
                _cobPosFree = cobPosInitial;
                _cobPos = 0;
            }
            if(_cobPosFree-- <= 0)
            {
                const int cobPosNew = _cobPos + cobPosChunk;
                LPVOID pv;

                pv = PvReAlloc(_pcpObPos, sizeof(ULONG) * cobPosNew);
                if(!pv)
                {
                    _ecParseError = ecNoMemory;
                    break;
                }
                _pcpObPos = (LONG *)pv;
                _cobPosFree = cobPosChunk - 1;
            }
            _pcpObPos[_cobPos++] = _prg->GetCp();
        }
        break;

    default:
        PARSERCOVERAGE_DEFAULT();
        if(pstate->sDest != destFieldInstruction && // Values outside token
           (DWORD)(_token - tokenMin) >             //  range are treated
                (DWORD)(tokenMax - tokenMin))       //  as Unicode chars
        {
            // Currently we don't allow TABs in tables
            if(_token == TAB && pstate->fInTable)   
                _token = TEXT(' '); 
            
            // 1.0 mode doesn't use Unicode bullets nor smart quotes
            if (_ped->Get10Mode() && IN_RANGE(LQUOTE, _token, RDBLQUOTE))
            {
                if (_token == LQUOTE || _token == RQUOTE)
                    _token = L'\'';
                else if (_token == LDBLQUOTE || _token == RDBLQUOTE)
                    _token = L'\"';
            }

            HandleChar(_token);
        }
        #if defined(DEBUG)
        else
        {
            if(GetProfileIntA("RICHEDIT DEBUG", "RTFCOVERAGE", 0))
            {
                CHAR *pszKeyword = PszKeywordFromToken(_token);
                CHAR szBuf[256];

                sprintf(szBuf, "CRTFRead::HandleToken():  Token not processed - token = %d, %s%s%s",
                            _token,
                            "keyword = ",
                            pszKeyword ? "\\" : "<unknown>",
                            pszKeyword ? pszKeyword : "");

                AssertSz(0, szBuf);
            }
        }
        #endif
    }

done:
    TRACEERRSZSC("HandleToken()", - _ecParseError);
    return _ecParseError;
}

/*
 *  CRTFRead::ReadRtf()
 *
 *  @mfunc
 *      The range _prg is replaced by RTF data resulting from parsing the
 *      input stream _pes.  The CRTFRead object assumes that the range is
 *      already degenerate (caller has to delete the range contents, if
 *      any, before calling this routine).  Currently any info not used
 *      or supported by RICHEDIT is thrown away.
 *
 *  @rdesc
 *      Number of chars inserted into text.  0 means none were inserted
 *      OR an error occurred.
 */
LONG CRTFRead::ReadRtf()
{
    TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadRtf");

    CTxtRange * prg = _prg;
    STATE *     pstate;
    LONG        cpFirstInPara;

    _cpFirst = prg->GetCp();
    if(!InitLex())
        goto Quit;

    TESTPARSERCOVERAGE();

    AssertSz(!prg->GetCch(),
        "CRTFRead::ReadRtf: range must be deleted");

    if(!(_dwFlags & SFF_SELECTION))
    {
        // SFF_SELECTION is set if any kind of paste is being done, i.e.,
        // not just that using the selection.  If it isn't set, data is
        // being streamed in and we allow this to reset the doc params
        _ped->InitDocInfo();
    }

    prg->SetIgnoreFormatUpdate(TRUE);

    _szUnicode = (TCHAR *)PvAlloc(cachTextMax * sizeof(TCHAR), GMEM_ZEROINIT);
    if(!_szUnicode)                 // Allocate space for Unicode conversions
    {
        _ped->GetCallMgr()->SetOutOfMemory();
        _ecParseError = ecNoMemory;
        goto CleanUp;
    }
    _cchUnicode = cachTextMax;

    // Initialize per-read variables
    _nCodePage = (_dwFlags & SF_USECODEPAGE)
               ? (_dwFlags >> 16) : INVALID_CODEPAGE;

    // Populate _PF with initial paragraph formatting properties
    _PF = *prg->GetPF();
	_dwMaskPF  = PFM_ALLRTF;			// Setup initial MaskPF
    _PF._iTabs = -1;                    // In case it's not -1
    _fInTable = _PF.InTable();

    // V-GUYB: PWord Converter requires loss notification.
    #ifdef REPORT_LOSSAGE
    if(!(_dwFlags & SFF_SELECTION))         // SFF_SELECTION is set if any
    {                                       //  kind of paste is being done
        ((LOST_COOKIE*)(_pes->dwCookie))->bLoss = FALSE;
    }
    #endif // REPORT_LOSSAGE

    // Valid RTF files start with "{\rtf", "{urtf", or "{\pwd"
    GetChar();                              // Fill input buffer                            
    UngetChar();                            // Put char back
    if(!IsRTF((char *)_pchRTFCurrent))      // Is it RTF?
    {                                       // No
        if (_ped->Get10Mode())
            _fNoRTFtoken = TRUE;
        else
        {
            _ecParseError = ecUnexpectedToken;  // Signal bad file
            goto CleanUp;
        }
    }

    // If initial cp follows EOP, use it for _cpThisPara.  Else
    // search for start of para containing the initial cp.
    _cpThisPara = _cpFirst;
    if(!prg->_rpTX.IsAfterEOP())
    {
        CTxtPtr tp(prg->_rpTX);
        tp.FindEOP(tomBackward);
        _cpThisPara = tp.GetCp();
    }
    cpFirstInPara = _cpThisPara;            // Backup to start of para before
                                            //  parsing
    while ( TokenGetToken() != tokenEOF &&  // Process tokens
            _token != tokenError        &&
            !HandleToken()              &&
            _pstateStackTop )
        ;

    if(_iCell)
    {
        if(_ecParseError == ecTextMax)  // Truncated table. Delete incomplete
        {                               //  row to keep Word happy
            CTxtPtr tp(prg->_rpTX);
            prg->Set(prg->GetCp(), -tp.FindEOP(tomBackward));
            prg->Delete(NULL, SELRR_IGNORE);
        }
        else
            AssertSz(FALSE, "CRTFRead::ReadRTF: Inserted cells but no row end");
    }
    _cCell = _iCell = 0;

    prg->SetIgnoreFormatUpdate(FALSE);          // Enable range _iFormat updates
    prg->Update_iFormat(-1);                    // Update _iFormat to CF
                                                //  at current active end
    if(!(_dwFlags & SFF_SELECTION))             // RTF applies to document:
    {                                           //  update CDocInfo
        // Apply char and para formatting of
        //  final text run to final CR
        if(prg->GetCp() == _ped->GetAdjustedTextLength())
        {
            // REVIEW: we need to think about what para properties should
            // be transferred here. E.g., borders were being transferred
            // incorrectly
            _dwMaskPF &= ~(PFM_BORDER | PFM_SHADING);
            Apply_PF();
            prg->ExtendFormattingCRLF();
        }

        // Update the per-document information from the RTF read
        CDocInfo *pDocInfo = _ped->GetDocInfo();

        if(!pDocInfo)
        {
            _ecParseError = ecNoMemory;
            goto CleanUp;
        }

        if (ecNoError == _ecParseError)         // If range end EOP wasn't
        {                                       // deleted and  new text
            prg->DeleteTerminatingEOP(NULL);    //  ends with an EOP, delete that EOP
        }

        pDocInfo->wCpg = (WORD)(_nCodePage == INVALID_CODEPAGE ?
                                        tomInvalidCpg : _nCodePage);
        if (pDocInfo->wCpg == CP_UTF8)
            pDocInfo->wCpg = 1252;

        _ped->SetDefaultLCID(_sDefaultLanguage == INVALID_LANGUAGE ?
                                tomInvalidLCID :
                                MAKELCID(_sDefaultLanguage, SORT_DEFAULT));

        _ped->SetDefaultLCIDFE(_sDefaultLanguageFE == INVALID_LANGUAGE ?
                                tomInvalidLCID :
                                MAKELCID(_sDefaultLanguageFE, SORT_DEFAULT));

        _ped->SetDefaultTabStop(TWIPS_TO_FPPTS(_sDefaultTabWidth));
        _ped->SetDocumentType(_bDocType);
    }

    if(_ped->IsComplexScript() && prg->GetCp() > cpFirstInPara)
    {
        Assert(!prg->GetCch());
        LONG    cpSave = prg->GetCp();
        LONG    cpLastInPara = cpSave;
        
        if(!prg->_rpTX.IsAtEOP())
        {
            CTxtPtr tp(prg->_rpTX);
            tp.FindEOP(tomForward);
            cpLastInPara = tp.GetCp();
            prg->Advance(cpLastInPara - cpSave);
        }
        // Itemize from the start of paragraph to be inserted till the end of
        // paragraph inserting. We need to cover all affected paragraphs because
        // paragraphs we're playing could possibly in conflict direction. Think
        // about the case that the range covers one LTR para and one RTL para, then
        // the inserting text covers one RTL and one LTR. Both paragraphs' direction
        // could have been changed after this insertion.
                
        prg->ItemizeReplaceRange(cpLastInPara - cpFirstInPara, 0, NULL);
        if (cpLastInPara != cpSave)
            prg->SetCp(cpSave);
    }

CleanUp:
    FreeRtfObject();

    pstate = _pstateStackTop;
    if(pstate)                                  // Illegal RTF file. Release
    {                                           //  unreleased format indices
        if(ecNoError == _ecParseError)          // It's only an overflow if no
            _ecParseError = ecStackOverflow;    //  other error has occurred

        while(pstate->pstatePrev)
        {
            pstate = pstate->pstatePrev;
            ReleaseFormats(pstate->iCF, -1);
        }
    }

    pstate = _pstateLast;
    if(pstate)
    {
        while(pstate->pstatePrev)               // Free all but first STATE
        {
            pstate->DeletePF();
            pstate = pstate->pstatePrev;
            FreePv(pstate->pstateNext);
        }
        pstate->DeletePF();
    }
    Assert(_PF._iTabs == -1);
    FreePv(pstate);                             // Free first STATE
    FreePv(_szUnicode);
    FreePv(_szHyperlinkFldinst);
    FreePv(_szHyperlinkFldrslt);

Quit:
    DeinitLex();

    if(_pcpObPos)
    {
        if((_ped->GetEventMask() & ENM_OBJECTPOSITIONS) && _cobPos > 0)
        {
            OBJECTPOSITIONS obpos;

            obpos.cObjectCount = _cobPos;
            obpos.pcpPositions = _pcpObPos;

            if (_ped->Get10Mode())
            {
                int i;
                LONG *pcpPositions = _pcpObPos;

                for (i = 0; i < _cobPos; i++, pcpPositions++)
                    *pcpPositions = _ped->GetAcpFromCp(*pcpPositions);
            }

            _ped->TxNotify(EN_OBJECTPOSITIONS, &obpos);
        }

        FreePv(_pcpObPos);
        _pcpObPos = NULL;
    }

#ifdef MACPORT
#if defined(ERROR_HANDLE_EOF) && ERROR_HANDLE_EOF != 38L
#error "ERROR_HANDLE_EOF value incorrect"
#endif
// transcribed from winerror.h
#define ERROR_HANDLE_EOF                 38L
#endif

    // FUTURE(BradO):  We should devise a direct mapping from our error codes
    //                  to Win32 error codes.  In particular our clients are
    //                  not expecting the error code produced by:
    //                      _pes->dwError = (DWORD) -(LONG) _ecParseError;
    if(_ecParseError)
    {
        AssertSz(_ecParseError >= 0,
            "Parse error is negative");

        if(_ecParseError == ecTextMax)
        {
            _ped->GetCallMgr()->SetMaxText();
            _pes->dwError = (DWORD)STG_E_MEDIUMFULL;
        }
        if(_ecParseError == ecUnexpectedEOF)
            _pes->dwError = (DWORD)HRESULT_FROM_WIN32(ERROR_HANDLE_EOF);

        if(!_pes->dwError && _ecParseError != ecTruncateAtCRLF)
            _pes->dwError = (DWORD) -(LONG) _ecParseError;

#if defined(DEBUG)
        TRACEERRSZSC("CchParse_", _pes->dwError);
        if(ecNoError < _ecParseError && _ecParseError < ecLastError)
            Tracef(TRCSEVERR, "Parse error: %s", rgszParseError[_ecParseError]);
#endif
    }

    return prg->GetCp() - _cpFirst;
}


/*
 *  CRTFRead::CpgInfoFromFaceName()
 *
 *  @mfunc
 *      This routine fills in the TEXTFONT::bCharSet and TEXTFONT::nCodePage
 *      members of the TEXTFONT structure by querying the system for the
 *      metrics of the font described by TEXTFONT::szName.
 *
 *  @rdesc
 *      A flag indicating whether the charset and codepage were successfully
 *      determined.
 */
BOOL CRTFRead::CpgInfoFromFaceName(
    TEXTFONT *ptf)
{
    // FUTURE(BradO): This code is a condensed version of a more sophisticated
    // algorithm we use in font.cpp to second-guess the font-mapper.
    // We should factor out the code from font.cpp for use here as well.

    // Indicates that we've tried to obtain the cpg info from the system,
    // so that after a failure we don't re-call this routine.   
    ptf->fCpgFromSystem = TRUE;

    if(ptf->fNameIsDBCS)
    {
        // If fNameIsDBCS, we have high-ANSI characters in the facename, and
        // no codepage with which to interpret them.  The facename is gibberish,
        // so don't waste time calling the system to match it.
        return FALSE;
    }

    HDC hdc = _ped->TxGetDC();
    if(!hdc)
        return FALSE;

    LOGFONT    lf = {0};
    TEXTMETRIC tm;

    wcscpy(lf.lfFaceName, ptf->szName);
    lf.lfCharSet = GetCharSet(GetSystemDefaultCodePage());

    if(!GetTextMetrics(hdc, lf, tm) || tm.tmCharSet != lf.lfCharSet)
    {
        lf.lfCharSet = DEFAULT_CHARSET;     // Doesn't match default sys
        GetTextMetrics(hdc, lf, tm);    //  charset, so see what
    }                                       //  DEFAULT_CHARSET gives
    _ped->TxReleaseDC(hdc);

    if(tm.tmCharSet != DEFAULT_CHARSET)     // Got something, so use it
    {
        ptf->bCharSet  = tm.tmCharSet;
        ptf->sCodePage = (SHORT)GetCodePage(tm.tmCharSet);
        return TRUE;
    }

    return FALSE;
}

#if defined(DEBUG)
/*
 *  CRTFRead::TestParserCoverage()
 *
 *  @mfunc
 *      A debug routine used to test the coverage of HandleToken.  The routine
 *      puts the routine into a debug mode and then determines:
 *      
 *          1.  Dead tokens - (T & !S & !P)
 *              Here, token:
 *                  a) is defined in tom.h  (T)
 *                  b) does not have a corresponding keyword (not scanned)  (!S)
 *                  c) is not processed by HandleToken  (!P)
 *          2.  Tokens that are parsed but not scanned - (T & !S & P)
 *              Here, token:
 *                  a) is defined in tom.h  (T)
 *                  b) does not have a corresponding keyword (not scanned)  (!S}
 *                  c) is processed by HandleToken  (P)
 *          3.  Tokens that are scanned but not parsed - (T & S & !P)
 *              Here, token:
 *                  a) is defined in tom.h  (T)
 *                  b) does have a corresponding keyword (is scanned)  (S)
 *                  c) is not processed by HandleToken  (!P)
 */
void CRTFRead::TestParserCoverage()
{
    int i;
    char *rgpszKeyword[tokenMax - tokenMin];
    BOOL rgfParsed[tokenMax - tokenMin];
    char szBuf[256];

    // Put HandleToken in debug mode
    _fTestingParserCoverage = TRUE;

    // Gather info about tokens/keywords
    for(i = 0; i < tokenMax - tokenMin; i++)
    {
        _token = (TOKEN)(i + tokenMin);
        rgpszKeyword[i] = PszKeywordFromToken(_token);
        rgfParsed[i] = HandleToken() == ecNoError;
    }

    // Reset HandleToken to non-debug mode
    _fTestingParserCoverage = FALSE;

    // Should coverage check include those we know will fail test, but
    // which we've examined and know why they fail?
    BOOL fExcuseCheckedToks = TRUE;

    if(GetProfileIntA("RICHEDIT DEBUG", "RTFCOVERAGESTRICT", 0))
        fExcuseCheckedToks = FALSE;

    // (T & !S & !P)  (1. above)
    for(i = 0; i < tokenMax - tokenMin; i++)
    {
        if(rgpszKeyword[i] || rgfParsed[i])
            continue;

        TOKEN tok = (TOKEN)(i + tokenMin);

        // token does not correspond to a keyword, but still may be scanned
        // check list of individual symbols which are scanned
        if(FTokIsSymbol(tok))
            continue;

        // check list of tokens which have been checked and fail
        // the sanity check for some known reason (see FTokFailsCoverageTest def'n)
        if(fExcuseCheckedToks && FTokFailsCoverageTest(tok))
            continue;

        sprintf(szBuf, "CRTFRead::TestParserCoverage():  Token neither scanned nor parsed - token = %d", tok);
        AssertSz(0, szBuf);
    }
                
    // (T & !S & P)  (2. above)
    for(i = 0; i < tokenMax - tokenMin; i++)
    {
        if(rgpszKeyword[i] || !rgfParsed[i])
            continue;

        TOKEN tok = (TOKEN)(i + tokenMin);

        // token does not correspond to a keyword, but still may be scanned
        // check list of individual symbols which are scanned
        if(FTokIsSymbol(tok))
            continue;

        // check list of tokens which have been checked and fail
        // the sanity check for some known reason (see FTokFailsCoverageTest def'n)
        if(fExcuseCheckedToks && FTokFailsCoverageTest(tok))
            continue;

        sprintf(szBuf, "CRTFRead::TestParserCoverage():  Token parsed but not scanned - token = %d", tok);
        AssertSz(0, szBuf);
    }

    // (T & S & !P)  (3. above)
    for(i = 0; i < tokenMax - tokenMin; i++)
    {
        if(!rgpszKeyword[i] || rgfParsed[i])
            continue;

        TOKEN tok = (TOKEN)(i + tokenMin);

        // check list of tokens which have been checked and fail
        // the sanity check for some known reason (see FTokFailsCoverageTest def'n)
        if(fExcuseCheckedToks && FTokFailsCoverageTest(tok))
            continue;

        sprintf(szBuf, "CRTFRead::TestParserCoverage():  Token scanned but not parsed - token = %d, tag = \\%s", tok, rgpszKeyword[i]);
        AssertSz(0, szBuf);
    }
}

/*
 *  CRTFRead::PszKeywordFromToken()
 *
 *  @mfunc
 *      Searches the array of keywords and returns the keyword
 *      string corresponding to the token supplied
 *
 *  @rdesc
 *      returns a pointer to the keyword string if one exists
 *      and NULL otherwise
 */
CHAR *CRTFRead::PszKeywordFromToken(TOKEN token)
{
    for(int i = 0; i < cKeywords; i++)
    {
        if(rgKeyword[i].token == token)
            return rgKeyword[i].szKeyword;
    }
    return NULL;
}


/*
 *  CRTFRead::FTokIsSymbol(TOKEN tok)
 *
 *  @mfunc
 *      Returns a BOOL indicating whether the token, tok, corresponds to an RTF symbol
 *      (that is, one of a list of single characters that are scanned in the
 *      RTF reader)
 *
 *  @rdesc
 *      BOOL -  indicates whether the token corresponds to an RTF symbol
 *
 */
BOOL CRTFRead::FTokIsSymbol(TOKEN tok)
{
    const BYTE *pbSymbol = NULL;

    extern const BYTE szSymbolKeywords[];
    extern const TOKEN tokenSymbol[];

    // check list of individual symbols which are scanned
    for(pbSymbol = szSymbolKeywords; *pbSymbol; pbSymbol++)
    {
        if(tokenSymbol[pbSymbol - szSymbolKeywords] == tok)
            return TRUE;
    }
    return FALSE;
}


/*
 *  CRTFRead::FTokFailsCoverageTest(TOKEN tok)
 *
 *  @mfunc
 *      Returns a BOOL indicating whether the token, tok, is known to fail the
 *      RTF parser coverage test.  These tokens are those that have been checked
 *      and either:
 *          1) have been implemented correctly, but just elude the coverage test
 *          2) have yet to be implemented, and have been recognized as such
 *
 *  @rdesc
 *      BOOL -  indicates whether the token has been checked and fails the
 *              the parser coverage test for some known reason
 *
 */
BOOL CRTFRead::FTokFailsCoverageTest(TOKEN tok)
{
    switch(tok)
    {
    // (T & !S & !P)  (1. in TestParserCoverage)
        // these really aren't tokens per se, but signal ending conditions for the parse
        case tokenError:
        case tokenEOF:

    // (T & !S & P)  (2. in TestParserCoverage)
        // emitted by scanner, but don't correspond to recognized RTF keyword
        case tokenUnknownKeyword:
        case tokenText:
        case tokenASCIIText:

        // recognized directly (before the scanner is called)
        case tokenStartGroup:
        case tokenEndGroup:

        // recognized using context information (before the scanner is called)
        case tokenObjectDataValue:
        case tokenPictureDataValue:

    // (T & S & !P)  (3. in TestParserCoverage)
        // None

            return TRUE;
    }

    return FALSE;
}
#endif // DEBUG


// Including a source file, but we only want to compile this code for debug purposes
// TODO: Implement RTF tag logging for the Mac
#if defined(DEBUG) && !defined(MACPORT)
#include "rtflog.cpp"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\select.cpp ===
/*
 *  @doc INTERNAL
 *
 *  @module SELECT.CPP -- Implement the CTxtSelection class |
 *
 *      This module implements the internal CTxtSelection methods.
 *      See select2.c and range2.c for the ITextSelection methods
 *
 *  Authors: <nl>
 *      RichEdit 1.0 code: David R. Fulmer
 *      Christian Fortini (initial conversion to C++)
 *      Murray Sargent <nl>
 *
 *  @devnote
 *      The selection UI is one of the more intricate parts of an editor.
 *      One common area of confusion is the "ambiguous cp", that is,
 *      a cp at the beginning of one line, which is also the cp at the
 *      end of the previous line.  We control which location to use by
 *      the _fCaretNotAtBOL flag.  Specifically, the caret is OK at the
 *      beginning of the line (BOL) (_fCaretNotAtBOL = FALSE) except in
 *      three cases:
 *
 *          1) the user clicked at or past the end of a wrapped line,
 *          2) the user typed End key on a wrapped line,
 *          3) the active end of a nondegenerate selection is at the EOL.
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_select.h"
#include "_edit.h"
#include "_disp.h"
#include "_measure.h"
#include "_font.h"
#include "_rtfconv.h"
#include "_antievt.h"

#ifdef LINESERVICES
#include "_ols.h"
#endif

ASSERTDATA


// ======================= Invariant stuff and Constructors ======================================================

#define DEBUG_CLASSNAME CTxtSelection
#include "_invar.h"

#ifdef DEBUG
BOOL
CTxtSelection::Invariant() const
{
    // FUTURE: maybe add some thoughtful asserts...

    static LONG numTests = 0;
    numTests++;             // how many times we've been called

    if(IsInOutlineView() && _cch)
    {
        LONG cpMin, cpMost;
        GetRange(cpMin, cpMost);

        CTxtPtr tp(_rpTX);                  // Scan range for an EOP
        tp.SetCp(cpMin);

        // _fSelHasEop flag may be off when last cr selected so don't
        // assert in that case.
        if (GetPed()->GetAdjustedTextLength() != cpMost)
        {
            AssertSz((unsigned)(tp.FindEOP(cpMost - cpMin) != 0) == _fSelHasEOP,
                "Incorrect CTxtSelection::_fSelHasEOP");
        }
    }

    return CTxtRange::Invariant();
}
#endif

CTxtSelection::CTxtSelection(CDisplay * const pdp) :
                CTxtRange(pdp->GetPed())
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CTxtSelection");

    Assert(pdp);
    Assert(GetPed());

    _fSel      = TRUE;                  // This range is a selection
    _pdp       = pdp;
    _hbmpCaret = NULL;
    _fEOP      = FALSE;                 // Haven't typed a CR

    // Set show-selection flag to inverse of hide-selection flag in ped
    _fShowSelection = !GetPed()->fHideSelection();

    // When we are initialized we don't have a selection therefore,
    // we do want to show caret.
    _fShowCaret = TRUE;
}

void SelectionNull(CTxtEdit *ped)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "SelectionNull");

    if(ped)
        ped->SetSelectionToNull();
}


CTxtSelection::~CTxtSelection()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::~CTxtSelection");

    DeleteCaretBitmap(FALSE);

    // Notify edit object that we are gone (if there's a nonNULL ped, i.e.,
    // if the selection isn't a zombie).
    SelectionNull(GetPed());
}

////////////////////////////////  Assignments  /////////////////////////////////////////


CRchTxtPtr& CTxtSelection::operator =(const CRchTxtPtr& rtp)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::operator =");

    _TEST_INVARIANT_
    return CTxtRange::operator =(rtp);
}

CTxtRange& CTxtSelection::operator =(const CTxtRange &rg)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::operator =");

    _TEST_INVARIANT_
    return CTxtRange::operator =(rg);
}

//////////////////////  Update caret & selection mechanism  ///////////////////////////////

/*
 *  CTxtSelection::Update(fScrollIntoView)
 *
 *  @mfunc
 *      Update selection and/or caret on screen. As a side
 *      effect, this methods ends deferring updates.
 *
 *  @rdesc
 *      TRUE if success, FALSE otherwise
 */
BOOL CTxtSelection::Update (
    BOOL fScrollIntoView)       //@parm TRUE if should scroll caret into view
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Update");

    LONG cch;
    LONG cchSave = _cch;
    LONG cchText = GetTextLength();
    LONG cp, cpMin, cpMost;
    BOOL fMoveBack = _fMoveBack;
    CTxtEdit *ped = GetPed();

    if(!_cch)                               // Update _cpAnchor, etc.
        UpdateForAutoWord();

    if(!ped->fInplaceActive() || ped->IsStreaming())
    {
        // Nothing to do while inactive or streaming in text or RTF data
        return TRUE;
    }

    if(_cch && (_fSelHasEOP || _fSelHasCell))
    {
        BOOL fInTable = GetPF()->InTable();
        if(!fInTable)
        {
            CFormatRunPtr rp(_rpPF);
            rp.AdvanceCp(-_cch);
            fInTable = (ped->GetParaFormat(rp.GetFormat()))->InTable();
        }
        if(fInTable)
            Expander(_fSelHasEOP ? tomParagraph : tomCell,
                 TRUE, NULL, &cpMin, &cpMost);
    }

    if(IsInOutlineView() && !ped->IsMouseDown() && _rpPF.IsValid())
    {
        CPFRunPtr rp(*this);

        cp = GetCp();
        GetRange(cpMin, cpMost);
        if(_cch && (cpMin || cpMost < cchText))
        {
            LONG *pcpMin  = &cpMin;
            LONG *pcpMost = &cpMost;

            // If selection contains an EOP, expand to para boundaries
            if(_fSelHasEOP)
            {
                if(_fMoveBack ^ (_cch < 0)) // Decreasing selection
                {                           //  size: move active end
                    if(_fMoveBack)
                        pcpMost = NULL;     //  to StartOf para
                    else
                        pcpMin = NULL;      //  to EndOf para
                }
                Expander(tomParagraph, TRUE, NULL, pcpMin, pcpMost);
            }

            LONG cpMinSave  = cpMin;        // Save initial cp's to see if
            LONG cpMostSave = cpMost;       //  we need to Set() below

            // The following handles selection expansion correctly, but
            // not compression; need logic like that preceding Expander()
            rp.AdvanceCp(cpMin - cp);       // Start at cpMin
            if(rp.IsCollapsed())
                cpMin += rp.FindExpandedBackward();
            rp.AdjustForward();

            BOOL fCpMinCollapsed = rp.IsCollapsed();
            rp.AdvanceCp(cpMost - cpMin);   // Go to cpMost
            Assert(cpMost == rp.CalculateCp());
            if(rp.IsCollapsed())
                cpMost += rp.FindExpandedForward();

            if(fCpMinCollapsed || rp.IsCollapsed() && cpMost < cchText)
            {
                if(rp.IsCollapsed())
                {
                    rp.AdvanceCp(cpMin - cpMost);
                    rp.AdjustForward();
                    cpMost = cpMin;
                }
                else
                    cpMin = cpMost;
            }
            if(cpMin != cpMinSave || cpMost != cpMostSave)
                Set(cpMost, cpMost - cpMin);
        }
        if(!_cch && rp.IsCollapsed())       // Note: above may have collapsed
        {                                   //  selection...
            cch = fMoveBack ? rp.FindExpandedBackward() : 0;
            if(rp.IsCollapsed())
                cch = rp.FindExpanded();

            _fExtend = FALSE;
            Advance(cch);
            rp.AdjustForward();
            if(cch <= 0 && rp.IsCollapsed() && _rpTX.IsAfterEOP())
                BackupCRLF();
            _fCaretNotAtBOL = FALSE;
        }
    }

    // Don't let active end be in hidden text
    CCFRunPtr rp(*this);

    cp = GetCp();
    GetRange(cpMin, cpMost);
    if(_cch && (cpMin || cpMost < cchText))
    {
        rp.AdvanceCp(cpMin - cp);           // Start at cpMin
        BOOL fHidden = rp.IsInHidden();
        rp.AdvanceCp(cpMost - cpMin);       // Go to cpMost

        if(fHidden)                         // It's hidden, so collapse
            Collapser(tomEnd);              //  selection at End for treatment

        else if(rp.IsInHidden() &&          // cpMin OK, how about cpMost?
            cpMost < cchText)
        {                                   // Check both sides of edge
            Collapser(tomEnd);              //  collapse selection at end
        }
    }
    if(!_cch && rp.IsInHidden())            // Note: above may have collapsed
    {                                       //  selection...
        cch = fMoveBack ? rp.FindUnhiddenBackward() : 0;
        if(!fMoveBack || rp.IsHidden())
            cch = rp.FindUnhidden();

        _fExtend = FALSE;
        Advance(cch);
        _fCaretNotAtBOL = FALSE;
    }
    if((cchSave ^ _cch) < 0)                // Don't change active end
        FlipRange();

    if(!_cch && cchSave)                    // Fixups changed nondegenerate
    {                                       //  selection to IP. Update
        Update_iFormat(-1);                 //  _iFormat and _fCaretNotAtBOL
        _fCaretNotAtBOL = FALSE;
    }

    _TEST_INVARIANT_

    // Recalc up to active end (caret)
    if(!_pdp->WaitForRecalc(GetCp(), -1))   // Line recalc failure
        Set(0, 0);                          // Put caret at start of text

    ShowCaret(ped->_fFocus);
    UpdateCaret(fScrollIntoView);           // Update Caret position, possibly
                                            //  scrolling it into view
    ped->TxShowCaret(FALSE);
    UpdateSelection();                      // Show new selection
    ped->TxShowCaret(TRUE);

    return TRUE;
}

/*
 *  CTxtSelection::CheckSynchCharSet(dwCharFlag)
 *
 *  @mfunc
 *      Check if the current keyboard matches the current font's charset;
 *      if not, call CheckChangeFont to find the right font
 *
 *  @rdesc
 *      Current keyboard codepage
 */
UINT CTxtSelection::CheckSynchCharSet(
    DWORD dwCharFlag)
{
    CTxtEdit *ped      = GetPed();
    LONG      iFormat  = GetiFormat();
    const CCharFormat *pCF = ped->GetCharFormat(iFormat);
    BYTE      bCharSet = pCF->_bCharSet;
    HKL       hkl      = GetKeyboardLayout(0xFFFFFFFF); // Force refresh
    WORD      wlidKbd  = LOWORD(hkl);
    UINT      uKbdCodePage = ConvertLanguageIDtoCodePage(wlidKbd);

    // If current font is not set correctly,
    // change to a font preferred by current keyboard.

    // To summarize the logic below:
    //      Check that lcidKbd is valid
    //      Check that current charset differs from current keyboard
    //      Check that current keyboard is legit in a single codepage control
    //      Check that current charset isn't SYMBOL, DEFAULT, or OEM
    if (wlidKbd &&
        (UINT)GetCodePage(bCharSet) != uKbdCodePage &&
        (!ped->_fSingleCodePage ||
            uKbdCodePage == 1252 ||
            uKbdCodePage == (ped->_pDocInfo ?
                                ped->_pDocInfo->wCpg :
                                GetSystemDefaultCodePage())) &&
        bCharSet != SYMBOL_CHARSET &&
        bCharSet != OEM_CHARSET &&
        !(W32->IsFECodePage(uKbdCodePage) && bCharSet == ANSI_CHARSET))
    {
        CheckChangeFont(hkl, uKbdCodePage, iFormat, dwCharFlag);
    }

    return uKbdCodePage;
}

/*
 *  CTxtSelection::MatchKeyboardToPara()
 *
 *  @mfunc
 *      Match the keyboard to the current paragraph direction. If the paragraph
 *      is an RTL paragraph then the keyboard will be switched to an RTL
 *      keyboard, and vice versa.
 *
 *  @rdesc
 *      TRUE iff a keyboard was changed
 *
 *  @devnote
 *      We use the following tests when trying to find a keyboard to match the
 *      paragraph direction:
 *
 *      See if the current keyboard matches the direction of the paragraph.
 *
 *      Search backward from rtp looking for a charset that matches the
 *          direction of the paragraph.
 *
 *      Search forward from rtp looking for a charset that matches the
 *          direction of the paragraph.
 *
 *      See if the default charformat charset matches the direction of the
 *          paragraph.
 *
 *      See if there's only a single keyboard that matches the paragraph
 *          direction.
 *
 *      If all this fails, just leave the keyboard alone.
 */
BOOL CTxtSelection::MatchKeyboardToPara()
{
    CTxtEdit *ped = GetPed();
    if(!ped->IsBiDi() || !GetPed()->_fFocus || GetPed()->_fIMEInProgress)
        return FALSE;

    BOOL fRTLPara = IsParaRTL();        // Get paragraph direction

    if(W32->IsBiDiLcid(LOWORD(GetKeyboardLayout(0))) == fRTLPara)
        return FALSE;

    // Current keyboard direction didn't match paragraph direction...

    BYTE                bCharSet;
    HKL                 hkl = 0;
    const CCharFormat * pCF;
    CFormatRunPtr       rpCF(_rpCF);

    // Look backward in text, trying to find a CharSet that matches
    // the paragraph direction.
    do
    {
        pCF = ped->GetCharFormat(rpCF.GetFormat());
        bCharSet = pCF->_bCharSet;
        if(IsRTLCharSet(bCharSet) == fRTLPara)
            hkl = W32->CheckChangeKeyboardLayout(bCharSet);
    } while (!hkl && rpCF.PrevRun());

    if(!hkl)
    {
        // Didn't find an appropriate charformat so reset run pointer
        // and look forward instead
        rpCF = _rpCF;
        while (!hkl && rpCF.NextRun())
        {
            pCF = ped->GetCharFormat(rpCF.GetFormat());
            bCharSet = pCF->_bCharSet;
            if(IsRTLCharSet(bCharSet) == fRTLPara)
                hkl = W32->CheckChangeKeyboardLayout(bCharSet);
        }
        if(!hkl)
        {
            // Still didn't find an appropriate charformat so see if
            // default charformat matches paragraph direction.
            pCF = ped->GetCharFormat(rpCF.GetFormat());
            bCharSet = pCF->_bCharSet;
            if(IsRTLCharSet(bCharSet) == fRTLPara)
                hkl = W32->CheckChangeKeyboardLayout(bCharSet);

            if(!hkl)
            {
                // If even that didn't work, walk through the list of
                // keyboards and grab the first one we come to that matches
                // the paragraph direction.
                pCF = NULL;
                hkl = W32->FindDirectionalKeyboard(fRTLPara);
            }
        }
    }

    if (hkl && ped->_fFocus && IsCaretShown())
    {
        CreateCaret();
        ped->TxShowCaret(TRUE);
    }

    return hkl ? TRUE : FALSE;
}

/*
 *  CTxtSelection::GetCaretPoint(&rcClient, pt, &rp)
 *
 *  @mfunc
 *      This routine determines where the caret should be positioned
 *      on screen.
 *      This routine is trivial, except for the Bidi case. In that case
 *      if we are told to retrieve formatting from the forward CP, we draw
 *      the caret at the logical left edge of the CP. Else, we draw it at
 *      the logical right edge of the previous CP.
 *
 *  @rdesc
 *      TRUE if we didn't OOM.
 */
BOOL CTxtSelection::GetCaretPoint(
    RECT &    rcClient,
    POINT &   pt,
    CLinePtr *prp,
    BOOL      fBeforeCp)
{
    CDispDim    dispdim;
    CRchTxtPtr  rtp(*this);
    UINT        taMode = TA_BASELINE | TA_LOGICAL;

    if(GetPed()->IsBiDi() && _rpCF.IsValid())
    {
        if(_fHomeOrEnd)                 // Home/End
            taMode |= _fCaretNotAtBOL ? TA_ENDOFLINE : TA_STARTOFLINE;

        else if(!GetIchRunCF() || !GetCchLeftRunCF())
        {
            // In a Bidi context on a run boundary where the reverse level
            // changes, then we should respect the fBeforeCp flag.
            BYTE    bLevelBwd, bLevelFwd;
            BOOL    fStart = FALSE;
            LONG    cp = rtp._rpTX.GetCp();
            CBiDiLevel level;

            bLevelBwd = bLevelFwd = rtp.IsParaRTL() ? 1 : 0;

            rtp._rpCF.AdjustBackward();
            if (cp)
                bLevelBwd = rtp._rpCF.GetLevel();

            rtp._rpCF.AdjustForward();
            if (cp != rtp._rpTX.GetTextLength())
            {
                bLevelFwd = rtp._rpCF.GetLevel(&level);
                fStart = level._fStart;
            }

            if((bLevelBwd != bLevelFwd || fStart) && !fBeforeCp && rtp.Advance(-1))
            {
                // Direction change at cp, caret in prev CF run, and can
                // backspace to previous char: then get to the right of
                // previous char
                taMode |= TA_RIGHT;
                _fCaretNotAtBOL = !rtp._rpTX.IsAfterEOP();
            }
        }
    }
    if (_pdp->PointFromTp(rtp, &rcClient, _fCaretNotAtBOL, pt, prp, taMode, &dispdim) < 0)
        return FALSE;

    return TRUE;
}

/*
 *  CTxtSelection::UpdateCaret(fScrollIntoView, bForceCaret)
 *
 *  @mfunc
 *      This routine updates caret/selection active end on screen.
 *      It figures its position, size, clipping, etc. It can optionally
 *      scroll the caret into view.
 *
 *  @rdesc
 *      TRUE if view was scrolled, FALSE otherwise
 *
 *  @devnote
 *      The caret is actually shown on screen only if _fShowCaret is TRUE.
 */
BOOL CTxtSelection::UpdateCaret (
    BOOL fScrollIntoView,   //@parm If TRUE, scroll caret into view if we have
    BOOL bForceCaret)       // focus or if not and selection isn't hidden
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::UpdateCaret");
    _TEST_INVARIANT_

    if(_pdp->IsFrozen())                // If display is currently frozen
    {                                   //  save call for another time
        _pdp->SaveUpdateCaret(fScrollIntoView);
        return FALSE;
    }

    CTxtEdit *ped = GetPed();
    if(ped->IsStreaming())              // Don't bother doing anything if we
        return FALSE;                   //  are loading in text or RTF data

    if(!ped->fInplaceActive())          // If not inplace active, set up
    {                                   //  for when focus is regained
        if(fScrollIntoView)
            ped->_fScrollCaretOnFocus = TRUE;
        return FALSE;
    }

    DWORD       dwScrollBars    = ped->TxGetScrollBars();
    BOOL        fAutoVScroll    = FALSE;
    BOOL        fAutoHScroll    = FALSE;
    BOOL        fBeforeCp       = _rpTX.IsAfterEOP();
    POINT       pt;
    CLinePtr    rp(_pdp);
    RECT        rcClient;
    RECT        rcView;

    LONG        xWidthView, yHeightView;
    LONG        xScroll         = _pdp->GetXScroll();
    LONG        yScroll         = _pdp->GetYScroll();

    INT         yAbove          = 0;    // Ascent of line above & beyond IP
    INT         yAscent;                // Ascent of IP
    INT         yAscentLine;
    LONG        yBase;                  // Base of IP & line
    INT         yBelow          = 0;    // Descent of line below & beyond IP
    INT         yDescent;               // Descent of IP
    INT         yDescentLine;
    INT         ySum;
    LONG        yViewTop, yViewBottom;

    if(ped->_fFocus && (_fShowCaret || bForceCaret))
    {
        _fShowCaret = TRUE; // We're trying to force caret to display so set this flag to true

        if(!_fDualFontMode && !_fNoKeyboardUpdate && !_fIsChar && !_fHomeOrEnd)
        {
            // Avoid re-entrance to CheckChangeKeyboardLayout
            _fNoKeyboardUpdate = TRUE;

            // If we're in "dual font" mode, charset change is only
            // temporary and we don't want to change keyboard layout
            CheckChangeKeyboardLayout();

            if(!fBeforeCp && ped->IsBiDi() && _rpCF.IsValid() &&
               (!_rpCF.GetIch() || !_rpCF.GetCchLeft()))
            {
                _rpCF.AdjustBackward();
                BOOL fRTLPrevRun = IsRTLCharSet(GetCF()->_bCharSet);
                _rpCF.AdjustForward();

                if (fRTLPrevRun != IsRTLCharSet(GetCF()->_bCharSet) &&
                    fRTLPrevRun != W32->IsBiDiLcid(GetKeyboardLCID()))
                {
                    fBeforeCp = TRUE;
                }
            }

            _fNoKeyboardUpdate = FALSE;
        }
    }

    // Get client rectangle once to save various callers getting it
    ped->TxGetClientRect(&rcClient);
    _pdp->GetViewRect(rcView, &rcClient);

    // View can be bigger than client rect because insets can be negative.
    // We don't want the caret to be any bigger than the client view otherwise
    // the caret will leave pixel dust on other windows.
    yViewTop    = max(rcView.top, rcClient.top);
    yViewBottom = min(rcView.bottom, rcClient.bottom);

    xWidthView = rcView.right - rcView.left;
    yHeightView = yViewBottom - yViewTop;

    if(fScrollIntoView)
    {
        fAutoVScroll = (dwScrollBars & ES_AUTOVSCROLL) != 0;
        fAutoHScroll = (dwScrollBars & ES_AUTOHSCROLL) != 0;

        // If we're not forcing a scroll, only scroll if window has focus
        // or selection isn't hidden
        if (!ped->Get10Mode() || !GetForceScrollCaret())
			fScrollIntoView = ped->_fFocus || !ped->fHideSelection();
    }

    if(!fScrollIntoView && (fAutoVScroll || fAutoHScroll))
    {                                           // Would scroll but don't have
        ped->_fScrollCaretOnFocus = TRUE;       //  focus. Signal to scroll
        if (!ped->Get10Mode() || !GetAutoVScroll())
            fAutoVScroll = fAutoHScroll = FALSE;    //  when we do get focus
    }
    SetAutoVScroll(FALSE);

    if (!_cch && IsInOutlineView() && IsCollapsed())
        goto not_visible;

    if (!GetCaretPoint(rcClient, pt, &rp, fBeforeCp))
        goto not_visible;

    // HACK ALERT - Because plain-text multiline controls do not have the
    // automatic EOP, we need to special case their processing here because
    // if you are at the end of the document and last character is an EOP,
    // you need to be on the next line in the display not the current line.

    if(CheckPlainTextFinalEOP())            // Terminated by an EOP
    {
        LONG Align = GetPF()->_bAlignment;

        pt.x = rcView.left;                 // Default left
        if(Align == PFA_CENTER)
            pt.x = (rcView.left + rcView.right)/2;

        else if(Align == PFA_RIGHT)
            pt.x = rcView.right;

        pt.x -= xScroll;                    // Absolute coordinate

        // Bump the y up a line. We get away with the calculation because
        // the document is plain text so all lines have the same height.
        // Also, note that the rp below is used only for height
        // calculations, so it is perfectly valid for the same reason
        // even though it is not actually pointing to the correct line.
        // (I told you this is a hack.)
        pt.y += rp->_yHeight;
    }

    _xCaret = (LONG) pt.x;
    yBase   = (LONG) pt.y;

    // Compute caret height, ascent, and descent
    yAscent = GetCaretHeight(&yDescent);
    yAscent -= yDescent;

    // Default to line empty case. Use what came back from the default
    // calculation above.
    yDescentLine = yDescent;
    yAscentLine = yAscent;

    if(rp.IsValid())
    {
        if(rp->_yDescent != -1)
        {
            // Line has been measured so we can use the line's values
            yDescentLine = rp->_yDescent;
            yAscentLine  = rp->_yHeight - yDescentLine;
        }
    }

    if(yAscent + yDescent == 0)
    {
        yAscent = yAscentLine;
        yDescent = yDescentLine;
    }
    else
    {
        // This is a bit counter-intuitive at first.  Basically, even if
        // the caret should be large (e.g., due to a large font at the
        // insertion point), we can only make it as big as the line.  If
        // a character is inserted, then the line becomes bigger, and we
        // can make the caret the correct size.
        yAscent = min(yAscent, yAscentLine);
        yDescent = min(yDescent, yDescentLine);
    }

    if(fAutoVScroll)
    {
        Assert(yDescentLine >= yDescent);
        Assert(yAscentLine >= yAscent);

        yBelow = yDescentLine - yDescent;
        yAbove = yAscentLine - yAscent;

        ySum = yAscent;

        // Scroll as much as possible into view, giving priorities
        // primarily to IP and secondarily ascents
        if(ySum > yHeightView)
        {
            yAscent = yHeightView;
            yDescent = 0;
            yAbove = 0;
            yBelow = 0;
        }
        else if((ySum += yDescent) > yHeightView)
        {
            yDescent = yHeightView - yAscent;
            yAbove = 0;
            yBelow = 0;
        }
        else if((ySum += yAbove) > yHeightView)
        {
            yAbove = yHeightView - (ySum - yAbove);
            yBelow = 0;
        }
        else if((ySum += yBelow) > yHeightView)
            yBelow = yHeightView - (ySum - yBelow);
    }
    else
    {
        AssertSz(yAbove == 0, "yAbove non-zero");
        AssertSz(yBelow == 0, "yBelow non-zero");
    }

    // Update real caret x pos (constant during vertical moves)
    _xCaretReally = _xCaret - rcView.left + xScroll;
    if (!(dwScrollBars & ES_AUTOHSCROLL) &&         // Not auto hscrolling
        !_pdp->IsHScrollEnabled())                  //  and no scrollbar
    {
        if (_xCaret < rcView.left)                  // Caret off left edge
            _xCaret = rcView.left;
        else if(_xCaret + GetCaretDelta() > rcView.right)// Caret off right edge
            _xCaret = rcView.right - dxCaret;       // Back caret up to
    }                                               //  exactly the right edge
    // From this point on we need a new caret
    _fCaretCreated = FALSE;
    if(ped->_fFocus)
        ped->TxShowCaret(FALSE);                    // Hide old caret before
                                                    //  making a new one
    if(yBase + yDescent + yBelow > yViewTop &&
        yBase - yAscent - yAbove < yViewBottom)
    {
        if(yBase - yAscent - yAbove < yViewTop)     // Caret is partially
        {                                           //  visible
            if(fAutoVScroll)                        // Top isn't visible
                goto scrollit;
            Assert(yAbove == 0);

            yAscent = yBase - yViewTop;             // Change ascent to amount
            if(yBase < yViewTop)                    //  visible
            {                                       // Move base to top
                yDescent += yAscent;
                yAscent = 0;
                yBase = yViewTop;
            }
        }
        if(yBase + yDescent + yBelow > yViewBottom)
        {
            if(fAutoVScroll)                        // Bottom isn't visible
                goto scrollit;
            Assert(yBelow == 0);

            yDescent = yViewBottom - yBase;         // Change descent to amount
            if(yBase > yViewBottom)                 //  visible
            {                                       // Move base to bottom
                yAscent += yDescent;
                yDescent = 0;
                yBase = yViewBottom;
            }
        }

        // Anything still visible?
        if(yAscent <= 0 && yDescent <= 0)
            goto not_visible;

        // If left or right isn't visible, scroll or set non_visible
        if (_xCaret < rcView.left ||                 // Left isn't visible
            _xCaret + GetCaretDelta() > rcView.right)// Right isn't visible
        {
            if(fAutoHScroll)
                goto scrollit;
            goto not_visible;
        }

        _yCaret = yBase - yAscent;
        _yHeightCaret = (INT) yAscent + yDescent;
    }
    else if(fAutoHScroll || fAutoVScroll)           // Caret isn't visible
        goto scrollit;                              //  scroll it into view
    else
    {
not_visible:
        // Caret isn't visible, don't show it
        _xCaret = -32000;
        _yCaret = -32000;
        _yHeightCaret = 1;
    }

    // Now update caret for real on screen. We only want to show the caret
    // if it is in the view and there is no selection.
    if(ped->_fFocus && _fShowCaret)
    {
        CreateCaret();
        ped->TxShowCaret(TRUE);
    }
    return FALSE;

scrollit:
    if(fAutoVScroll)
    {
        // Scroll to top for cp = 0. This is important if the first line
        // contains object(s) taller than the client area is high.  The
        // resulting behavior agrees with the Word UI in all ways except in
        // Backspacing (deleting) the char at cp = 0 when it is followed by
        // other chars that preceed the large object.
        if(!GetCp())
            yScroll = 0;

        else if(yBase - yAscent - yAbove < yViewTop)            // Top invisible
            yScroll -= yViewTop - (yBase - yAscent - yAbove);   // Make it so

        else if(yBase + yDescent + yBelow > yViewBottom)        // Bottom invisible
        {
            yScroll += yBase + yDescent + yBelow - yViewBottom; // Make it so

            // Don't do following special adjust if the current line is bigger
            // than the client area
            if(rp->_yHeight < yViewBottom - yViewTop)
            {
                yScroll = _pdp->AdjustToDisplayLastLine(yBase + rp->_yHeight,
                    yScroll);
            }
        }
    }
    if(fAutoHScroll)
    {
        if(_xCaret < rcView.left)                           // Left invisible
        {
            xScroll -= rcView.left - _xCaret;               // Make it visible
            if(xScroll > 0)                                 // Scroll left in
            {                                               //  chunks to make
                xScroll -= xWidthView / 3;                  //  typing faster
                xScroll = max(0, xScroll);
            }
        }
        else if(_xCaret + GetCaretDelta() > rcView.right)   // right invisible
        {                                                   // Make it visible
            xScroll += _xCaret + dxCaret - rcView.left      // We don't scroll
                    - xWidthView;                           // in chunks because
        }                                                   // this more edit
    }                                                       // control like.
    if(yScroll != _pdp->GetYScroll() || xScroll != _pdp->GetXScroll())
    {
        if (_pdp->ScrollView(xScroll, yScroll, FALSE, FALSE) == FALSE)
        {
            if(ped->_fFocus && _fShowCaret)
            {
                CreateCaret();
                ped->TxShowCaret(TRUE);
            }
            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

/*
 *  CTxtSelection::GetCaretHeight(pyDescent)
 *
 *  @mfunc
 *      Add a given amount to _xCaret (to make special case of inserting
 *      a character nice and fast)
 *
 *  @rdesc
 *      Caret height, <lt> 0 if failed
 */
INT CTxtSelection::GetCaretHeight (
    INT *pyDescent) const       //@parm Out parm to receive caret descent
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::GetCaretHeight");
                                // (undefined if the return value is <lt> 0)
    _TEST_INVARIANT_

    CLock lock;                     // Uses global (shared) FontCache
    CTxtEdit *ped = GetPed();
    const CCharFormat *pCF = ped->GetCharFormat(_iFormat);
    const CDevDesc *pdd = _pdp->GetDdRender();

    HDC hdc = pdd->GetDC();
    if(!hdc)
        return -1;

    LONG yHeight = -1;
    LONG dypInch = MulDiv(GetDeviceCaps(hdc, LOGPIXELSY), _pdp->GetZoomNumerator(), _pdp->GetZoomDenominator());
    CCcs *pccs = fc().GetCcs(pCF, dypInch);
    if(!pccs)
        goto ret;

    LONG yOffset, yAdjust;
    pccs->GetOffset(pCF, dypInch, &yOffset, &yAdjust);

    SHORT   yAdjustFE;
    yAdjustFE = pccs->AdjustFEHeight(!fUseUIFont() && ped->_pdp->IsMultiLine());
    if(pyDescent)
        *pyDescent = pccs->_yDescent + yAdjustFE - yAdjust - yOffset;

    yHeight = pccs->_yHeight + (yAdjustFE << 1);

    pccs->Release();
ret:
    pdd->ReleaseDC(hdc);
    return yHeight;
}

/*
 *  CTxtSelection::ShowCaret(fShow)
 *
 *  @mfunc
 *      Hide or show caret
 *
 *  @rdesc
 *      TRUE if caret was previously shown, FALSE if it was hidden
 */
BOOL CTxtSelection::ShowCaret (
    BOOL fShow)     //@parm TRUE for showing, FALSE for hiding
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ShowCaret");

    _TEST_INVARIANT_

    const BOOL fRet = _fShowCaret;

    if(fRet != fShow)
    {
        _fShowCaret = fShow;
        if(GetPed()->_fFocus || GetPed()->fInOurHost())
        {
            if(fShow && !_fCaretCreated)
                CreateCaret();
            GetPed()->TxShowCaret(fShow);
        }
    }
    return fRet;
}

/*
 *  CTxtSelection::IsCaretInView()
 *
 *  @mfunc
 *      Returns TRUE iff caret is inside visible view
 */
BOOL CTxtSelection::IsCaretInView() const
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::IsCaretInView");

    _TEST_INVARIANT_

    RECT rc;
    _pdp->GetViewRect(rc);

    return  (_xCaret + dxCaret       > rc.left) &&
            (_xCaret                 < rc.right) &&
            (_yCaret + _yHeightCaret > rc.top) &&
            (_yCaret                 < rc.bottom);
}

/*
 *  CTxtSelection::CaretNotAtBOL()
 *
 *  @mfunc
 *      Returns TRUE iff caret is not allowed at BOL
 */
BOOL CTxtSelection::CaretNotAtBOL() const
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CaretNotAtBOL");

    _TEST_INVARIANT_

    return _cch ? (_cch > 0) : _fCaretNotAtBOL;
}

/*
 *  CTxtSelection::LineLength(pcch)
 *
 *  @mfunc
 *      get # unselected chars on lines touched by current selection
 *
 *  @rdesc
 *      said number of chars
 */
LONG CTxtSelection::LineLength(
    LONG *pcp) const
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::LineLength");

    _TEST_INVARIANT_

    LONG     cch;
    CLinePtr rp(_pdp);

    if(!_cch)                           // Insertion point
    {
        rp.RpSetCp(GetCp(), _fCaretNotAtBOL);
        cch = rp.GetAdjustedLineLength();
        *pcp = GetCp() - rp.RpGetIch();
    }
    else
    {
        LONG cpMin, cpMost, cchLast;
        GetRange(cpMin, cpMost);
        rp.RpSetCp(cpMin, FALSE);       // Selections can't start at EOL
        cch = rp.RpGetIch();
        *pcp = cpMin - cch;
        rp.RpSetCp(cpMost, TRUE);       // Selections can't end at BOL

        // Remove trailing EOP, if it exists and isn't already selected
        cchLast = rp.GetAdjustedLineLength() - rp.RpGetIch();
        if(cchLast > 0)
            cch += cchLast;
    }
    return cch;
}

/*
 *  CTxtSelection::ShowSelection(fShow)
 *
 *  @mfunc
 *      Update, hide or show selection on screen
 *
 *  @rdesc
 *      TRUE iff selection was previously shown
 */
BOOL CTxtSelection::ShowSelection (
    BOOL fShow)         //@parm TRUE for showing, FALSE for hiding
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ShowSelection");

    _TEST_INVARIANT_

    const BOOL fShowPrev = _fShowSelection;
    const BOOL fInplaceActive = GetPed()->fInplaceActive();
    LONG cpSelSave = _cpSel;
    LONG cchSelSave = _cchSel;

    // Sleep(1000);
    _fShowSelection = fShow;

    if(fShowPrev && !fShow)
    {
        if(cchSelSave)          // Hide old selection
        {
            // Set up selection before telling the display to update
            _cpSel = 0;
            _cchSel = 0;

            if(fInplaceActive)
                _pdp->InvertRange(cpSelSave, cchSelSave, selSetNormal);
        }
    }
    else if(!fShowPrev && fShow)
    {
        if(_cch)                                // Show new selection
        {
            // Set up selection before telling the display to update
            _cpSel = GetCp();
            _cchSel = _cch;

            if(fInplaceActive)
                _pdp->InvertRange(GetCp(), _cch, selSetHiLite);
        }
    }
    return fShowPrev;
}

/*
 *  CTxtSelection::UpdateSelection()
 *
 *  @mfunc
 *      Updates selection on screen
 *
 *  Note:
 *      This method inverts the delta between old and new selections
 */
void CTxtSelection::UpdateSelection()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::UpdateSelection");

    _TEST_INVARIANT_

    LONG    cp = GetCp();
    LONG    cpNA    = cp - _cch;
    LONG    cpSelNA = _cpSel - _cchSel;
    LONG    cpMin, cpMost;
    LONG    cpMinSel = 0;
    LONG    cpMostSel = 0;
    CObjectMgr* pobjmgr = NULL;
    LONG    NumObjInSel = 0, NumObjInOldSel = 0;
    LONG    cpSelSave = _cpSel;
    LONG    cchSelSave = _cchSel;

    GetRange(cpMin, cpMost);

    //We need to know if there were objects is the previous and current
    //selections to determine how they should be selected.
    if(GetPed()->HasObjects())
    {
        pobjmgr = GetPed()->GetObjectMgr();
        if(pobjmgr)
        {
            CTxtRange   tr(GetPed(), _cpSel, _cchSel);

            tr.GetRange(cpMinSel, cpMostSel);
            NumObjInSel = pobjmgr->CountObjectsInRange(cpMin, cpMost);
            NumObjInOldSel = pobjmgr->CountObjectsInRange(cpMinSel, cpMostSel);
        }
    }

    //If the old selection contained a single object and nothing else
    //we need to notify the object manager that this is no longer the
    //case if the selection is changing.
    if (NumObjInOldSel && (abs(_cchSel) == 1) &&
        !(cpMin == cpMinSel && cpMost == cpMostSel))
    {
        if(pobjmgr)
            pobjmgr->HandleSingleSelect(GetPed(), cpMinSel, /* fHilite */ FALSE);
    }

    // Update selection data before the invert so the selection can be
    // painted by the render
    _cpSel  = GetCp();
    _cchSel = _cch;

    if(_fShowSelection)
    {
        if(!_cch || !cchSelSave ||              // Old/new selection missing,
            cpMost < min(cpSelSave, cpSelNA) || //  or new preceeds old,
            cpMin  > max(cpSelSave, cpSelNA))   //  or new follows old, so
        {                                       //  they don't intersect
            if(_cch)
                _pdp->InvertRange(cp, _cch, selSetHiLite);
            if(cchSelSave)
                _pdp->InvertRange(cpSelSave, cchSelSave, selSetNormal);
        }
        else
        {
            if(cpNA != cpSelNA)                 // Old & new dead ends differ
            {                                   // Invert text between them
                _pdp->InvertRange(cpNA, cpNA - cpSelNA, selUpdateNormal);
            }
            if(cp != cpSelSave)                 // Old & new active ends differ
            {                                   // Invert text between them
                _pdp->InvertRange(cp, cp - cpSelSave, selUpdateHiLite);
            }
        }
    }

    // If new selection contains a single object and nothing else, we need
    // to notify object manager as long as it's not the same object.
    if (NumObjInSel && abs(_cch) == 1 &&
        (cpMin != cpMinSel || cpMost != cpMostSel))
    {
        if(pobjmgr)
            pobjmgr->HandleSingleSelect(GetPed(), cpMin, /* fHiLite */ TRUE);
    }
}

/*
 *  CTxtSelection::SetSelection(cpFirst, cpMost)
 *
 *  @mfunc
 *      Set selection between two cp's
 *
 *  @devnote
 *      <p cpFirst> and <p cpMost> must be greater than 0, but may extend
 *      past the current max cp.  In that case, the cp will be truncated to
 *      the max cp (at the end of the text).
 */
void CTxtSelection::SetSelection (
    LONG cpMin,             //@parm Start of selection and dead end
    LONG cpMost)            //@parm End of selection and active end
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetSelection");

    _TEST_INVARIANT_
    CTxtEdit *ped = GetPed();

    StopGroupTyping();

    if(ped->HasObjects())
    {
        CObjectMgr* pobjmgr = GetPed()->GetObjectMgr();
        if(pobjmgr)
        {
			COleObject *pobjactive = pobjmgr->GetInPlaceActiveObject();
			if (pobjactive)
			{
				if (pobjactive != pobjmgr->GetObjectFromCp(cpMin) || cpMost - cpMin > 1)
					pobjactive->DeActivateObj();
			}
        }
    }

    _fCaretNotAtBOL = FALSE;            // Put caret for ambiguous cp at BOL
    Set(cpMost, cpMost - cpMin);        // Set() validates cpMin, cpMost

    if(GetPed()->fInplaceActive())              // Inplace active:
        Update(!ped->Get10Mode() ? TRUE : !ped->fHideSelection());  //  update selection now
    else
    {
        // Update selection data used for screen display so whenever we
        // get displayed the selection will be displayed.
        _cpSel  = GetCp();
        _cchSel = _cch;

        if(!ped->fHideSelection())
        {
            // Selection isn't hidden so tell container to update display
            // when it feels like.
            ped->TxInvalidateRect(NULL, FALSE);
            ped->TxUpdateWindow();
        }
    }
    CancelModes();                      // Cancel word selection mode
}

/*
 *  CTxtSelection::PointInSel(pt, prcClient, Hit)
 *
 *  @mfunc
 *      Figures whether a given point is within the selection
 *
 *  @rdesc
 *      TRUE if point inside selection, FALSE otherwise
 */
BOOL CTxtSelection::PointInSel (
    const POINT pt,         //@parm Point in containing window client coords
    const RECT *prcClient,  //@parm Client rectangle can be NULL if active
    HITTEST     Hit) const  //@parm May be computer Hit value
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PointInSel");
    _TEST_INVARIANT_

    if(!_cch || Hit && Hit < HT_Text)   // Degenerate range (no selection):
        return FALSE;                   //  mouse can't be in, or Hit not
                                        //  in text
    LONG cpActual;
    _pdp->CpFromPoint(pt, prcClient, NULL, NULL, FALSE, &Hit, NULL, &cpActual);

    if(Hit < HT_Text)
        return FALSE;

    LONG cpMin,  cpMost;
    GetRange(cpMin, cpMost);

    return cpActual >= cpMin && cpActual < cpMost;
}


//////////////////////////////////  Selection with the mouse  ///////////////////////////////////

/*
 *  CTxtSelection::SetCaret(pt, fUpdate)
 *
 *  @mfunc
 *      Sets caret at a given point
 *
 *  @devnote
 *      In the plain-text case, placing the caret at the beginning of the
 *      line following the final EOP requires some extra code, since the
 *      underlying rich-text engine doesn't assign a line to a final EOP
 *      (plain-text doesn't currently have the rich-text final EOP).  We
 *      handle this by checking to see if the count of lines times the
 *      plain-text line height is below the actual y position.  If so, we
 *      move the cp to the end of the story.
 */
void CTxtSelection::SetCaret(
    const POINT pt,     //@parm Point of click
    BOOL fUpdate)       //@parm If TRUE, update the selection/caret
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetCaret");

    _TEST_INVARIANT_

    LONG        cp, cpActual;
    CDispDim    dispdim;
    HITTEST     Hit;
    RECT        rcView;
    CLinePtr    rp(_pdp);
    CRchTxtPtr  rtp(GetPed());
    LONG        y;

    StopGroupTyping();

    // Set caret at point
    if(_pdp->CpFromPoint(pt, NULL, &rtp, &rp, FALSE, &Hit, &dispdim, &cpActual) >= 0)
    {
        cp = rtp.GetCp();

        // If the resolved CP is greater than the cp we are above, then we
        // want to stay backwards.
        BOOL fBeforeCp = cp <= cpActual;

        // Set selection to the correct location.  If plain-text
        // multiline control, we need to check to see if pt.y is below
        // the last line of text.  If so and if the text ends with an EOP,
        // we need to set the cp at the end of the story and set up to
        // display the caret at the beginning of the line below the last
        // line of text
        if(!IsRich() && _pdp->IsMultiLine())        // Plain-text,
        {                                           //  multiline control
            _pdp->GetViewRect(rcView, NULL);
            y = pt.y + _pdp->GetYScroll() - rcView.top;

            if(y > rp.Count()*rp->_yHeight)         // Below last line of
            {                                       //  text
                rtp.Advance(tomForward);            // Move rtp to end of text
                if(rtp._rpTX.IsAfterEOP())          // If text ends with an
                {                                   //  EOP, set up to move
                    cp = rtp.GetCp();               //  selection there
                    rp.AdvanceCp(-rp.GetIch());     // Set rp._ich = 0 to
                }                                   //  set _fCaretNotAtBOL
            }                                       //  = FALSE to display
        }                                           //  caret at next BOL

        Set(cp, 0);
        if(GetPed()->IsBiDi())
        {
            if(!fBeforeCp)
                _rpCF.AdjustBackward();
            else
                _rpCF.AdjustForward();
            Set_iCF(_rpCF.GetFormat());
        }
        _fCaretNotAtBOL = rp.RpGetIch() != 0;   // Caret OK at BOL if click
        if(fUpdate)
            Update(TRUE);
        else
            UpdateForAutoWord();

        _SelMode = smNone;                      // Cancel word selection mode
    }
}

/*
 *  CTxtSelection::SelectWord(pt)
 *
 *  @mfunc
 *      Select word around a given point
 */
void CTxtSelection::SelectWord (
    const POINT pt)         //@parm Point of click
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SelectWord");

    _TEST_INVARIANT_

    // Get rp where the hit is
    if(_pdp->CpFromPoint(pt, NULL, this, NULL, FALSE) >= 0)
    {
        // Extend both active and dead ends on word boundaries
        _cch = 0;                           // Start with IP at pt
        SetExtend(FALSE);
        FindWordBreak(WB_MOVEWORDRIGHT);    // Go to end of word
        SetExtend(TRUE);
        FindWordBreak(WB_MOVEWORDLEFT);     // Extend to start of word
        GetRange(_cpAnchorMin, _cpAnchorMost);
        GetRange(_cpWordMin, _cpWordMost);

        if(!_fInAutoWordSel)
            _SelMode = smWord;

        // cpMost needs to be the active end
        if(_cch < 0)
            FlipRange();
        Update(FALSE);
    }
}

/*
 *  CTxtSelection::SelectUnit(pt, Unit)
 *
 *  @mfunc
 *      Select line/paragraph around a given point and enter
 *      line/paragraph selection mode. In Outline View, convert
 *      SelectLine to SelectPara, and SelectPara to SelectPara
 *      along with all subordinates
 */
void CTxtSelection::SelectUnit (
    const POINT pt,     //@parm Point of click
    LONG        Unit)   //@parm tomLine or tomParagraph
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SelectPara");

    _TEST_INVARIANT_

    AssertSz(Unit == tomLine || Unit == tomParagraph,
        "CTxtSelection::SelectPara: Unit must equal tomLine/tomParagraph");

    LONG     nHeading;
    CLinePtr rp(_pdp);

    // Get rp and selection active end where the hit is
    if(_pdp->CpFromPoint(pt, NULL, this, &rp, FALSE) >= 0)
    {
        LONG cchBackward, cchForward;
        BOOL fOutline = IsInOutlineView();

        if(Unit == tomLine && !fOutline)            // SelectLine
        {
            _cch = 0;                               // Start with insertion
            cchBackward = -rp.RpGetIch();           //  point at pt
            cchForward  = rp->_cch;
            _SelMode = smLine;
        }
        else                                        // SelectParagraph
        {
            cchBackward = rp.FindParagraph(FALSE);  // Go to start of para
            cchForward  = rp.FindParagraph(TRUE);   // Extend to end of para
            _SelMode = smPara;
        }
        SetExtend(FALSE);
        Advance(cchBackward);

        if(Unit == tomParagraph && fOutline)        // Move para in outline
        {                                           //  view
            rp.AdjustBackward();                    // If heading, include
            nHeading = rp.GetHeading();             //  subordinate paras
            if(nHeading)
            {
                for(; rp.NextRun(); cchForward += rp->_cch)
                {
                    LONG n = rp.GetHeading();
                    if(n && n <= nHeading)
                        break;
                }
            }
        }
        SetExtend(TRUE);
        Advance(cchForward);
        GetRange(_cpAnchorMin, _cpAnchorMost);
        Update(FALSE);
    }
}

/*
 *  CTxtSelection::SelectAll()
 *
 *  @mfunc
 *      Select all text in story
 */
void CTxtSelection::SelectAll()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SelectAll");

    _TEST_INVARIANT_

    StopGroupTyping();

    LONG cchText = GetTextLength();

    Set(cchText,  cchText);
    Update(FALSE);
}

/*
 *  CTxtSelection::ExtendSelection(pt)
 *
 *  @mfunc
 *      Extend/Shrink selection (moves active end) to given point
 */
void CTxtSelection::ExtendSelection (
    const POINT pt)     //@parm Point to extend to
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ExtendSelection");

    _TEST_INVARIANT_

    LONG        cch;
    LONG        cchPrev = _cch;
    LONG        cp;
    LONG        cpMin, cpMost;
    BOOL        fAfterEOP;
    const BOOL  fWasInAutoWordSel = _fInAutoWordSel;
    INT         iDir = 0;
    CTxtEdit *  ped = GetPed();
    CLinePtr    rp(_pdp);
    CRchTxtPtr  rtp(ped);

    StopGroupTyping();

    // Get rp and rtp at the point pt
    if(_pdp->CpFromPoint(pt, NULL, &rtp, &rp, TRUE) < 0)
        return;

    // If we are in word, line, or paragraph select mode, we need to make
    // sure the active end is correct.  If we are extending backward from
    // the first Unit selected, we want the active end to be at cpMin. If
    // we are extending forward from the first Unit selected, we want the
    // active end to be at cpMost.
    if(_SelMode != smNone)
    {
        cch = _cpAnchorMost - _cpAnchorMin;
        GetRange(cpMin, cpMost);
        cp = rtp.GetCp();

        if(cp <= cpMin  && _cch > 0)            // If active end changes,
            Set(_cpAnchorMin, -cch);            //  select the original
                                                //  Unit (will be extended
        if(cp >= cpMost && _cch < 0)            //  below)
            Set(_cpAnchorMost, cch);
    }

    SetExtend(TRUE);
    cch = rp.RpGetIch();
    if(_SelMode > smWord && cch == rp->_cch)    // If in line or para select
    {                                           //  modes and pt at EOL,
        rtp.Advance(-cch);                      //  make sure we stay on that
        rp.RpAdvanceCp(-cch);                   //  line
        cch = 0;
    }

    SetCp(rtp.GetCp());                         // Move active end to pt
                                                // Caret OK at BOL _unless_
    _fCaretNotAtBOL = _cch > 0;                 //  forward selection
                                                // Now adjust selection
    if(_SelMode == smLine)                      //  depending on mode
    {                                           // Extend selection by line
        if(_cch >= 0)                           // Active end at cpMost
            cch -= rp->_cch;                    // Setup to add chars to EOL
        Advance(-cch);
    }
    else if(_SelMode == smPara)
        Advance(rp.FindParagraph(_cch >= 0));   // Extend selection by para

    else
    {
        // If the sign of _cch has changed this means that the direction
        // of the selection is changing and we want to reset the auto
        // selection information.
        if((_cch ^ cchPrev) < 0)
        {
            _fAutoSelectAborted = FALSE;
            _cpWordMin  = _cpAnchorMin;
            _cpWordMost = _cpAnchorMost;
        }

        cp = rtp.GetCp();
        fAfterEOP = rtp._rpTX.IsAfterEOP();

        _fInAutoWordSel = _SelMode != smWord && GetPed()->TxGetAutoWordSel()
            && !_fAutoSelectAborted
            && (cp < _cpWordMin || cp > _cpWordMost);

        if(_fInAutoWordSel && !fWasInAutoWordSel)
        {
            CTxtPtr txtptr(GetPed(), _cpAnchor);

            // Extend both ends dead to word boundaries
            ExtendToWordBreak(fAfterEOP,
                _cch < 0 ? WB_MOVEWORDLEFT : WB_MOVEWORDRIGHT);

            if(_cch < 0)
            {
                // Direction is left so update word border on left
                _cpWordPrev = _cpWordMin;
                _cpWordMin = GetCp();
            }
            else
            {
                // Direction is right so update word border on right
                _cpWordPrev = _cpWordMost;
                _cpWordMost = GetCp();
            }

            // If we are at start of a word already, we don't need to extend
            // selection in other direction
            if(!txtptr.IsAtBOWord() && txtptr.GetChar() != ' ')
            {
                FlipRange();
                Advance(_cpAnchor - GetCp());   // Extend from anchor

                FindWordBreak(_cch < 0 ? WB_MOVEWORDLEFT : WB_MOVEWORDRIGHT);

                if(_cch > 0)                // Direction is right so
                    _cpWordMost = GetCp();  //  update word border on right
                else                        // Direction is left so
                    _cpWordMin = GetCp();   //  update word border on left
                FlipRange();
            }
        }
        else if(_fInAutoWordSel || _SelMode == smWord)
        {
            // Save direction
            iDir = cp <= _cpWordMin ? WB_MOVEWORDLEFT : WB_MOVEWORDRIGHT;

            if(_SelMode == smWord)          // Extend selection by word
            {
                if(cp > _cpAnchorMost || cp < _cpAnchorMin)
                    FindWordBreak(iDir);
                else if(_cch <= 0)          // Maintain current active end
                    Set(_cpAnchorMin, _cpAnchorMin - _cpAnchorMost);
                else
                    Set(_cpAnchorMost, _cpAnchorMost - _cpAnchorMin);
            }
            else
                ExtendToWordBreak(fAfterEOP, iDir);

            if(_fInAutoWordSel)
            {
                if(WB_MOVEWORDLEFT == iDir)
                {
                    // Direction is left so update word border on left
                    _cpWordPrev = _cpWordMin;
                    _cpWordMin = GetCp();
                }
                else
                {
                    // Direction is right so update word border on right
                    _cpWordPrev = _cpWordMost;
                    _cpWordMost = GetCp();
                }
            }
        }
        else if(fWasInAutoWordSel)
        {
            // If we are in between where the previous word ended and
            // the cp we auto selected to, then we want to stay in
            // auto select mode.
            if(_cch < 0)
            {
                if(cp >= _cpWordMin && cp < _cpWordPrev)
                {
                    // Set direction for end of word search
                    iDir = WB_MOVEWORDLEFT;

                    // Mark that we are still in auto select mode
                    _fInAutoWordSel = TRUE;
                }
            }
            else if(cp <= _cpWordMost && cp >= _cpWordPrev)
            {
                // Mark that we are still in auto select mode
                _fInAutoWordSel = TRUE;

                // Set direction for end of word search
                iDir = WB_MOVEWORDRIGHT;
            }

            //We have to check to see if we are on the boundary between
            //words because we don't want to extend the selection until
            //we are actually beyond the current word.
            if(cp != _cpWordMost && cp != _cpWordMin)
            {
                if(_fInAutoWordSel)
                {
                    // Auto selection still on so make sure we have the
                    // entire word we are on selected
                    ExtendToWordBreak(fAfterEOP, iDir);
                }
                else
                {
                    // FUTURE: Word has a behavior where it extends the
                    // selection one word at a time unless you back up
                    // and then start extending the selection again, in
                    // which case it extends one char at a time.  We
                    // follow this behavior.  However, Word will resume
                    // extending a word at a time if you continue extending
                    // for several words.  We just keep extending on char
                    // at a time.  We might want to change this sometime.

                    _fAutoSelectAborted = TRUE;
                }
            }
        }

        if(_fAutoSelectAborted)
        {
            // If we are in the range of a word we previously selected
            // we want to leave that selected. If we have moved back
            // a word we want to pop back an entire word. Otherwise,
            // leave the cp were it is.
            if(_cch < 0)
            {
                if(cp > _cpWordMin && cp < _cpWordPrev)
                {
                    // In the range leave the range at the beginning of the word
                    ExtendToWordBreak(fAfterEOP, WB_MOVEWORDLEFT);
                }
                else if(cp >= _cpWordPrev)
                {
                    AutoSelGoBackWord(&_cpWordMin,
                        WB_MOVEWORDRIGHT, WB_MOVEWORDLEFT);
                }
            }
            else if(cp < _cpWordMost && cp >= _cpWordPrev)
            {
                // In the range leave the range at the beginning of the word
                ExtendToWordBreak(fAfterEOP, WB_MOVEWORDRIGHT);
            }
            else if(cp < _cpWordPrev)
            {
                AutoSelGoBackWord(&_cpWordMost,
                    WB_MOVEWORDLEFT, WB_MOVEWORDRIGHT);
            }
        }
    }
    // An OLE object cannot have an anchor point <b> inside </b> it,
    // but sometimes we'd like it to behave like a word. So, if
    // the direction changed, the object has to stay selected --
    // this is the "right thing" (kind of word selection mode)

    // If we had something selected and the direction changed
    if(cchPrev && (_cch ^ cchPrev) < 0)
    {
        FlipRange();

        // See if an object was selected on the other end
        BOOL fObjectWasSelected = (_cch > 0 ? _rpTX.GetChar() : GetPrevChar())
                                    == WCH_EMBEDDING;
        // If it was, we want it to stay selected
        if(fObjectWasSelected)
            Advance(_cch > 0 ? 1 : -1);

        FlipRange();
    }
    Update(TRUE);
}

/*
 *  CTxtSelection::ExtendToWordBreak (fAfterEOP, iAction)
 *
 *  @mfunc
 *      Moves active end of selection to the word break in the direction
 *      given by iDir unless fAfterEOP = TRUE.  When this is TRUE, the
 *      cursor just follows an EOP marker and selection should be suppressed.
 *      Otherwise moving the cursor to the left of the left margin would
 *      select the EOP on the line above, and moving the cursor to the
 *      right of the right margin would select the first word in the line
 *      below.
 */
void CTxtSelection::ExtendToWordBreak (
    BOOL fAfterEOP,     //@parm Cursor is after an EOP
    INT  iAction)       //@parm Word break action (WB_MOVEWORDRIGHT/LEFT)
{
    if(!fAfterEOP)
        FindWordBreak(iAction);
}

/*
 *  CTxtSelection::CancelModes(fAutoWordSel)
 *
 *  @mfunc
 *      Cancel either all modes or Auto Select Word mode only
 */
void CTxtSelection::CancelModes (
    BOOL fAutoWordSel)      //@parm TRUE cancels Auto Select Word mode only
{                           //     FALSE cancels word, line and para sel mode
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CancelModes");
    _TEST_INVARIANT_

    if(fAutoWordSel)
    {
        if(_fInAutoWordSel)
        {
            _fInAutoWordSel = FALSE;
            _fAutoSelectAborted = FALSE;
        }
    }
    else
        _SelMode = smNone;
}


///////////////////////////////////  Keyboard movements  ////////////////////////////////////

/*
 *  CTxtSelection::Left(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad left-arrow key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      Left/Right-arrow IPs can go to within one character (treating CRLF
 *      as a character) of EOL.  They can never be at the actual EOL, so
 *      _fCaretNotAtBOL is always FALSE for these cases.  This includes
 *      the case with a right-arrow collapsing a selection that goes to
 *      the EOL, i.e, the caret ends up at the next BOL.  Furthermore,
 *      these cases don't care whether the initial caret position is at
 *      the EOL or the BOL of the next line.  All other cursor keypad
 *      commands may care.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Left (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Left");

    _TEST_INVARIANT_

    LONG cp;

    CancelModes();
    StopGroupTyping();

    if(!_fExtend && _cch)                       // Collapse selection to
    {                                           //  nearest whole Unit before
        if(fCtrl)                               //  cpMin
            Expander(tomWord, FALSE, NULL, &cp, NULL);
        Collapser(tomStart);                    // Collapse to cpMin
    }
    else                                        // Not collapsing selection
    {
        if (!GetCp() ||                         // Already at beginning of
            !BypassHiddenText(tomBackward))     //  story
        {
            Beep();
            return FALSE;
        }
        if(IsInOutlineView() && (_fSelHasEOP || // If outline view with EOP
            _fExtend && _rpTX.IsAfterEOP()))    //  now or will have after
        {                                       //  this command,
            return Up(FALSE);                   //  treat as up arrow
        }
        if(fCtrl)                               // WordLeft
            FindWordBreak(WB_MOVEWORDLEFT);
        else                                    // CharLeft
        {
            BackupCRLF();
            SnapToCluster(-1);
        }
    }

    _fCaretNotAtBOL = FALSE;                    // Caret always OK at BOL
    Update(TRUE);
    return TRUE;
}

/*
 *  CTxtSelection::Right(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad right-arrow key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      Right-arrow selection can go to the EOL, but the cp of the other
 *      end identifies whether the selection ends at the EOL or starts at
 *      the beginning of the next line.  Hence here and in general for
 *      selections, _fCaretNotAtBOL is not needed to resolve EOL/BOL
 *      ambiguities.  It should be set to FALSE to get the correct
 *      collapse character.  See also comments for Left() above.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Right (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Right");

    _TEST_INVARIANT_

    LONG    cchText;
    LONG    cp;

    CancelModes();
    StopGroupTyping();

    if(!_fExtend && _cch)                       // Collapse selection to
    {                                           //  nearest whole Unit after
        if(fCtrl)                               //  cpMost
            Expander(tomWord, FALSE, NULL, NULL, &cp);
        Collapser(tomEnd);
    }
    else                                        // Not collapsing selection
    {
        cchText = _fExtend ? GetTextLength() : GetAdjustedTextLength();
        if (GetCp() >= cchText ||               // Already at end of story
            !BypassHiddenText(tomForward))
        {
            Beep();                             // Tell the user
            return FALSE;
        }
        if(IsInOutlineView() && _fSelHasEOP)    // If outline view with EOP
            return Down(FALSE);                 // Treat as down arrow
        if(fCtrl)                               // WordRight
            FindWordBreak(WB_MOVEWORDRIGHT);
        else                                    // CharRight
        {
            AdvanceCRLF();
            SnapToCluster();
        }
    }

    _fCaretNotAtBOL = _fExtend;                 // If extending to EOL, need
    Update(TRUE);                               //  TRUE to get _xCaretReally
    return TRUE;                                //  at EOL
}

/*
 *  CTxtSelection::Up(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad up-arrow key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      Up arrow doesn't go to EOL regardless of _xCaretPosition (stays
 *      to left of EOL break character), so _fCaretNotAtBOL is always FALSE
 *      for Up arrow.  Ctrl-Up/Down arrows always end up at BOPs or the EOD.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Up (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Up");

    _TEST_INVARIANT_

    LONG        cchSave = _cch;                 // Save starting position for
    LONG        cpSave = GetCp();               //  change check
    BOOL        fCollapse = _cch && !_fExtend;  // Collapse nondegenerate sel
    BOOL        fPTNotAtEnd;
    CLinePtr    rp(_pdp);
    LONG        xCaretReally = _xCaretReally;   // Save desired caret x pos

    CancelModes();
    StopGroupTyping();

    if(fCollapse)                               // Collapse selection at cpMin
    {
        Collapser(tomTrue);
        _fCaretNotAtBOL = FALSE;                // Selections can't begin at
    }                                           //  EOL
    rp.RpSetCp(GetCp(), _fCaretNotAtBOL);       // Initialize line ptr

    if(fCtrl)                                   // Move to beginning of para
    {
        if(!fCollapse &&                        // If no selection collapsed
            rp > 0 && !rp.RpGetIch())           //  and are at BOL,
        {                                       //  backup to prev BOL to make
            rp--;                               //  sure we move to prev. para
            Advance(-rp->_cch);
        }
        Advance(rp.FindParagraph(FALSE));       // Go to beginning of para
        _fCaretNotAtBOL = FALSE;                // Caret always OK at BOL
    }
    else                                        // Move up a line
    {                                           // If on first line, can't go
        fPTNotAtEnd = !CheckPlainTextFinalEOP();//  up
        if(rp <= 0 && fPTNotAtEnd)
        {
            //if(!_fExtend)// &&_pdp->GetYScroll())
                UpdateCaret(TRUE);              // Be sure caret in view
        }
        else
        {
            LONG cch;
            BOOL fSelHasEOPInOV = IsInOutlineView() && _fSelHasEOP;
            if(fSelHasEOPInOV && _cch > 0)
            {
                rp.AdjustBackward();
                cch = rp->_cch;
                rp.AdvanceCp(-cch);             // Go to start of line
                Assert(!rp.GetIch());
                cch -= rp.FindParagraph(FALSE); // Ensure start of para in
            }                                   //  case of word wrap
            else
            {
                cch = 0;
                if(fPTNotAtEnd)
                {
                    cch = rp.RpGetIch();
                    rp--;
                }
                cch += rp->_cch;
            }
            Advance(-cch);                      // Move to previous BOL
            if(fSelHasEOPInOV && !_fSelHasEOP)  // If sel had EOP but doesn't
            {                                   //  after Advance, must be IP
                Assert(!_cch);                  // Suppress restore of
                xCaretReally = -1;              //  _xCaretReally
            }
            else if(!SetXPosition(xCaretReally, rp))// Set this cp corresponding
                Set(cpSave, cchSave);           //  to xCaretReally here, but
        }                                       //   agree on Down()
    }

    if(GetCp() == cpSave && _cch == cchSave)
    {
        // Continue to select to the beginning of the first line
        // This is what 1.0 is doing
        if(_fExtend)
            return Home(fCtrl);

        Beep();                                 // Nothing changed, so beep
        return FALSE;
    }

    Update(TRUE);                               // Update and then restore
    if(!_cch && !fCtrl && xCaretReally >= 0)    //  _xCaretReally conditionally
        _xCaretReally = xCaretReally;           // Need to use _cch instead of
                                                //  cchSave in case of collapse
    return TRUE;
}

/*
 *  CTxtSelection::Down(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad down-arrow key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      Down arrow can go to the EOL if the _xCaretPosition (set by
 *      horizontal motions) is past the end of the line, so
 *      _fCaretNotAtBOL needs to be TRUE for this case.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Down (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Down");

    _TEST_INVARIANT_

    LONG        cch;
    LONG        cchSave = _cch;                 // Save starting position for
    LONG        cpSave = GetCp();               //  change check
    BOOL        fCollapse = _cch && !_fExtend;  // Collapse nondegenerate sel
    CLinePtr    rp(_pdp);
    LONG        xCaretReally = _xCaretReally;   // Save _xCaretReally

    CancelModes();
    StopGroupTyping();

    if(fCollapse)                               // Collapse at cpMost
    {
        Collapser(tomEnd);
        _fCaretNotAtBOL = TRUE;                 // Selections can't end at BOL
    }

    rp.RpSetCp(GetCp(), _fCaretNotAtBOL);
    if(fCtrl)                                   // Move to next para
    {
        Advance(rp.FindParagraph(TRUE));        // Go to end of para
        if(IsInOutlineView() && !BypassHiddenText(tomForward))
            SetCp(cpSave);
        else
            _fCaretNotAtBOL = FALSE;            // Next para is never at EOL
    }
    else if(_pdp->WaitForRecalcIli(rp + 1))     // Go to next line
    {
        LONG cch;
        BOOL fSelHasEOPInOV = IsInOutlineView() && _fSelHasEOP;
        if(fSelHasEOPInOV && _cch < 0)
            cch = rp.FindParagraph(TRUE);
        else
        {
            cch = rp.GetCchLeft();              // Advance selection to end
            rp++;                               //  of current line
        }
        Advance(cch);
        if(fSelHasEOPInOV && !_fSelHasEOP)      // If sel had EOP but doesn't
        {                                       //  after Advance, must be IP
            Assert(!_cch);                      // Suppress restore of
            xCaretReally = -1;                  //  _xCaretReally
        }
        else if(!SetXPosition(xCaretReally, rp))// Set *this to cp <--> x
            Set(cpSave, cchSave);               // If failed, restore sel
    }
    else if(!_fExtend)                          // No more lines to pass
        // && _pdp->GetYScroll() + _pdp->GetViewHeight() < _pdp->GetHeight())
    {
        if (!IsRich() && _pdp->IsMultiLine() && // Plain-text, multiline
            !_fCaretNotAtBOL)                   //  control with caret OK
        {                                       //  at BOL
            cch = Advance(rp.GetCchLeft());     // Advance selection to end
            if(!_rpTX.IsAfterEOP())             // If control doesn't end
                Advance(-cch);                  //  with EOP, go back
        }
        UpdateCaret(TRUE);                      // Be sure caret in view
    }

    if(GetCp() == cpSave && _cch == cchSave)
    {
        // Continue to select to the end of the lastline
        // This is what 1.0 is doing.
        if(_fExtend)
            return End(fCtrl);

        Beep();                                 // Nothing changed, so beep
        return FALSE;
    }

    Update(TRUE);                               // Update and then
    if(!_cch && !fCtrl && xCaretReally >= 0)    //  restore _xCaretReally
        _xCaretReally = xCaretReally;           // Need to use _cch instead of
    return TRUE;                                //  cchSave in case of collapse
}

/*
 *  CTxtSelection::SetXPosition(xCaret, rp)
 *
 *  @mfunc
 *      Put this text ptr at cp nearest to xCaret.  If xCaret is in right
 *      margin, we put caret either at EOL (for lines with no para mark),
 *      or just before para mark
 *
 *  @rdesc
 *      TRUE iff could create measurer
 */
BOOL CTxtSelection::SetXPosition (
    LONG        xCaret,     //@parm Desired horizontal coordinate
    CLinePtr&   rp)         //@parm Line ptr identifying line to check
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetXPosition");

    _TEST_INVARIANT_

    LONG        cch = 0;
    CMeasurer   me(_pdp, *this);

    if(IsInOutlineView())
    {
        BOOL fSelHasEOP = _fSelHasEOP;
        rp.AdjustForward();
        _fCaretNotAtBOL = FALSE;                // Leave at start of line
        while(rp->_fCollapsed)
        {
            if(_fMoveBack)
            {
                if(!rp.PrevRun())               // No more uncollapsed text
                    return FALSE;               //  before current cp
                cch -= rp->_cch;
            }
            else
            {
                cch += rp->_cch;
                if(!rp.NextRun())               // No more uncollapsed text
                    return FALSE;               //  after current cp
                if(_fExtend && _cch > 0)
                    _fCaretNotAtBOL = TRUE;     // Leave at end of line
            }
        }
        if(cch)
            Advance(cch);
        if(fSelHasEOP)
            return TRUE;
        if(cch)
            me.Advance(cch);
    }

    POINT pt = {xCaret, 0};
    CDispDim dispdim;
    HITTEST hit;
    cch = rp->CchFromXpos(me, pt, &dispdim, &hit);// Move out from start of line
    if(!_fExtend && cch == rp->_cch &&          // Not extending, at EOL,
        rp->_cchEOP)                            //  and have EOP:
    {                                           //  backup before EOP
        cch += me._rpTX.BackupCpCRLF();         // Note: me._rpCF/_rpPF
    }                                           //  are now inconsistent
    SetCp(me.GetCp());                          //  but doesn't matter since
    _fCaretNotAtBOL = cch != 0;                 //  me.GetCp() doesn't care

    return TRUE;
}

/*
 *  CTxtSelection::GetXCaretReally()
 *
 *  @mfunc
 *      Get _xCaretReally - horizontal scrolling + left margin
 *
 *  @rdesc
 *      x caret really
 */
LONG CTxtSelection::GetXCaretReally()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::GetXCaretReally");

    _TEST_INVARIANT_

    RECT rcView;

    _pdp->GetViewRect(rcView);

    return _xCaretReally - _pdp->GetXScroll() + rcView.left;
}

/*
 *  CTxtSelection::Home(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad Home key is supposed to do
 *
 *  @rdesc
 *          TRUE iff movement occurred
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Home (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Home");

    _TEST_INVARIANT_

    const LONG  cchSave = _cch;
    const LONG  cpSave  = GetCp();

    CancelModes();
    StopGroupTyping();

    if(fCtrl)                                   // Move to start of document
        SetCp(0);
    else
    {
        CLinePtr rp(_pdp);

        if(_cch && !_fExtend)                   // Collapse at cpMin
        {
            Collapser(tomStart);
            _fCaretNotAtBOL = FALSE;            // Selections can't start at
        }                                       //  EOL

        rp.RpSetCp(GetCp(), _fCaretNotAtBOL);   // Define line ptr for

        Advance(-rp.RpGetIch());                //  current state. Now BOL
    }
    _fCaretNotAtBOL = FALSE;                    // Caret always goes to BOL
    _fHomeOrEnd = TRUE;

    if(!MatchKeyboardToPara() && GetCp() == cpSave && _cch == cchSave)
    {
        Beep();                                 // No change, so beep
        _fHomeOrEnd = FALSE;
        return FALSE;
    }

    Update(TRUE);
    _fHomeOrEnd = FALSE;
    return TRUE;
}

/*
 *  CTxtSelection::End(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad End key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      On lines without paragraph marks (EOP), End can go all the way
 *      to the EOL.  Since this character position (cp) is the same as
 *      that for the start of the next line, we need _fCaretNotAtBOL to
 *      distinguish between the two possible caret positions.
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::End (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::End");

    _TEST_INVARIANT_

    LONG        cch;
    const LONG  cchSave = _cch;
    const LONG  cpSave  = GetCp();
    CLinePtr    rp(_pdp);

    CancelModes();
    StopGroupTyping();

    if(fCtrl)                                   // Move to end of document
    {
        SetCp(GetTextLength());
        _fCaretNotAtBOL = FALSE;
        goto Exit;
    }
    else if(!_fExtend && _cch)                  // Collapse at cpMost
    {
        Collapser(tomEnd);
        _fCaretNotAtBOL = TRUE;                 // Selections can't end at BOL
    }

    rp.RpSetCp(GetCp(), _fCaretNotAtBOL);       // Initialize line ptr

    cch = rp->_cch;                             // Default target pos in line
    Advance(cch - rp.RpGetIch());               // Move active end to EOL

    if(!_fExtend && rp->_cchEOP && _rpTX.IsAfterEOP())// Not extending and have EOP:
        cch += BackupCRLF();                          //  backup before EOP

    _fCaretNotAtBOL = cch != 0;                 // Decide ambiguous caret pos by whether at BOL

Exit:
    if(!MatchKeyboardToPara() && GetCp() == cpSave && _cch == cchSave)
    {
        Beep();                                 // No change, so Beep
        return FALSE;
    }

    _fHomeOrEnd = TRUE;
    Update(TRUE);
    _fHomeOrEnd = FALSE;
    return TRUE;
}

/*
 *  CTxtSelection::PageUp(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad PgUp key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::PageUp (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PageUp");

    _TEST_INVARIANT_

    const LONG  cchSave = _cch;
    const LONG  cpSave  = GetCp();
    LONG        xCaretReally = _xCaretReally;

    CancelModes();
    StopGroupTyping();

    if(_cch && !_fExtend)                       // Collapse selection
    {
        Collapser(tomStart);
        _fCaretNotAtBOL = FALSE;
    }

    if(fCtrl)                                   // Ctrl-PgUp: move to top
    {                                           //  of visible view for
        SetCp(_pdp->IsMultiLine()               //  multiline but top of
            ? _pdp->GetFirstVisibleCp() : 0);   //  text for SL
        _fCaretNotAtBOL = FALSE;
    }
    else if(_pdp->GetFirstVisibleCp() == 0)     // PgUp in top Pg: move to
    {                                           //  start of document
        SetCp(0);
        _fCaretNotAtBOL = FALSE;
    }
    else                                        // PgUp with scrolling to go
    {                                           // Scroll up one windowful
        ScrollWindowful(SB_PAGEUP);             //  leaving caret at same
    }                                           //  position in window

    if(GetCp() == cpSave && _cch == cchSave)    // Beep if no change
    {
        Beep();
        return FALSE;
    }

    Update(TRUE);
    if(GetCp())                                 // Maintain x offset on page
        _xCaretReally = xCaretReally;           //  up/down
    return TRUE;
}

/*
 *  CTxtSelection::PageDown(fCtrl)
 *
 *  @mfunc
 *      do what cursor-keypad PgDn key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::PageDown (
    BOOL fCtrl)     //@parm TRUE iff Ctrl key is pressed (or being simulated)
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PageDown");

    _TEST_INVARIANT_

    const LONG  cchSave         = _cch;
    LONG        cpMostVisible;
    const LONG  cpSave          = GetCp();
    POINT       pt;
    CLinePtr    rp(_pdp);
    LONG        xCaretReally    = _xCaretReally;

    CancelModes();
    StopGroupTyping();

    if(_cch && !_fExtend)                       // Collapse selection
    {
        Collapser(tomStart);
        _fCaretNotAtBOL = TRUE;
    }

    _pdp->GetCliVisible(&cpMostVisible, fCtrl);

    if(fCtrl)                                   // Move to end of last
    {                                           //  entirely visible line
        RECT rcView;

        SetCp(cpMostVisible);

        if(_pdp->PointFromTp(*this, NULL, TRUE, pt, &rp, TA_TOP) < 0)
            return FALSE;

        _fCaretNotAtBOL = TRUE;

        _pdp->GetViewRect(rcView);

        if(rp > 0 && pt.y + rp->_yHeight > rcView.bottom)
        {
            Advance(-rp->_cch);
            rp--;
        }

        if(!_fExtend && !rp.GetCchLeft() && rp->_cchEOP)
        {
            BackupCRLF();                       // After backing up over EOP,
            _fCaretNotAtBOL = FALSE;            //  caret can't be at EOL
        }
    }
    else if(cpMostVisible == GetTextLength())
    {                                           // Move to end of text
        SetCp(GetTextLength());
        _fCaretNotAtBOL = !_rpTX.IsAfterEOP();
    }
    else
    {
        if(!ScrollWindowful(SB_PAGEDOWN))       // Scroll down 1 windowful
            return FALSE;
    }

    if(GetCp() == cpSave && _cch == cchSave)    // Beep if no change
    {
        Beep();
        return FALSE;
    }

    Update(TRUE);
    _xCaretReally = xCaretReally;
    return TRUE;
}

/*
 *  CTxtSelection::ScrollWindowful(wparam)
 *
 *  @mfunc
 *      Sroll up or down a windowful
 *
 *  @rdesc
 *      TRUE iff movement occurred
 */
BOOL CTxtSelection::ScrollWindowful (
    WPARAM wparam)      //@parm SB_PAGEDOWN or SB_PAGEUP
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ScrollWindowful");
                                                // Scroll windowful
    _TEST_INVARIANT_

    POINT pt;                                   //  leaving caret at same
    CLinePtr rp(_pdp);                          //  point on screen
    LONG cpFirstVisible = _pdp->GetFirstVisibleCp();
    LONG cpLastVisible;
    LONG cpMin;
    LONG cpMost;

    GetRange(cpMin, cpMost);

    // Get last character in the view
    _pdp->GetCliVisible(&cpLastVisible, TRUE);

    // Is active end in visible area of control?
    if((cpMin < cpFirstVisible && _cch <= 0) || (cpMost > cpLastVisible && _cch >= 0))
    {
        // Not in view - we need to calculate a new range for selection
        SetCp(cpFirstVisible);

        // Real caret postion is now at beginning of line
        _xCaretReally = 0;
    }

    if(_pdp->PointFromTp(*this, NULL, _fCaretNotAtBOL, pt, &rp, TA_TOP) < 0)
        return FALSE;

    // The point is visible so use that
    pt.x = _xCaretReally;
    pt.y += rp->_yHeight / 2;
    _pdp->VScroll(wparam, 0);

    if(_fExtend)
    {
        // Disable auto word select -- if we have to use ExtendSelection()
        // for non-mouse operations, let's try to get rid of its side-effects
        BOOL fInAutoWordSel = _fInAutoWordSel;
        _fInAutoWordSel = FALSE;
        ExtendSelection(pt);
        _fInAutoWordSel = fInAutoWordSel;
    }
    else
        SetCaret(pt, FALSE);

    return TRUE;
}

//////////////////////////// Keyboard support /////////////////////////////////

/*
 *  CTxtSelection::CheckChangeKeyboardLayout (BOOL fChangedFont)
 *
 *  @mfunc
 *      Change keyboard for new font, or font at new character position.
 *
 *  @comm
 *      Using only the currently loaded KBs, locate one that will support
 *      the insertion points font. This is called anytime a character format
 *      change occurs, or the insert font (caret position) changes.
 *
 *  @devnote
 *      The current KB is preferred. If a previous association
 *      was made, see if the KB is still loaded in the system and if so use
 *      it. Otherwise, locate a suitable KB, preferring KB's that have
 *      the same charset ID as their default, preferred charset. If no match
 *      can be made then nothing changes.
 */
void CTxtSelection::CheckChangeKeyboardLayout ()
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CheckChangeKeyboardLayout");

    CTxtEdit * const ped = GetPed();                // Document context

    if (ped && ped->_fFocus && !ped->fUseUIFont() &&    // If ped, focus, not UIFont, & auto
        ped->IsAutoKeyboard() &&                        //  kbd, check kbd change
        !ped->_fIMEInProgress &&						//  not in IME composition and
		ped->GetAdjustedTextLength() &&					//  not empty control and
		_rpTX.GetPrevChar() != WCH_EMBEDDING)			//  not an object, then
    {													//  check kbd change
        LONG    iFormat = GetiFormat();

        const CCharFormat *pCF = ped->GetCharFormat(iFormat);
        BYTE bCharSet = pCF->_bCharSet;

        if (!IsFECharSet(bCharSet) &&
            (bCharSet != ANSI_CHARSET || !IsFELCID((WORD)GetKeyboardLayout(0))) &&
            !fc().GetInfoFlags(pCF->_iFont).fNonBiDiAscii)
        {
            // Don't do auto-kbd inside FE or single-codepage ASCII font.
            W32->CheckChangeKeyboardLayout(bCharSet);
        }
    }
}

/*
 *  CTxtSelection::CheckChangeFont (hkl, cpg, iSelFormat, dwCharFlag)
 *
 *  @mfunc
 *      Change font for new keyboard layout.
 *
 *  @comm
 *      If no previous preferred font has been associated with this KB, then
 *      locate a font in the document suitable for this KB.
 *
 *  @rdesc
 *      TRUE iff suitable font is found
 *
 *  @devnote
 *      This routine is called via WM_INPUTLANGCHANGEREQUEST message
 *      (a keyboard layout switch). This routine can also be called
 *      from WM_INPUTLANGCHANGE, but we are called more, and so this
 *      is less efficient.
 *
 *      Exact match is done via charset ID bitmask. If a match was previously
 *      made, use it. A user can force the insertion font to be associated
 *      to a keyboard if the control key is held through the KB changing
 *      process. The association is broken when another KB associates to
 *      the font. If no match can be made then nothing changes.
 */
bool CTxtSelection::CheckChangeFont (
    const HKL   hkl,            //@parm Keyboard Layout to go
    UINT        cpg,            //@parm code page to use (could be ANSI for FE with IME off)
    LONG        iSelFormat,     //@parm Format to use for selection case
    DWORD       dwCharFlag)     //@parm 0 if called from WM_INPUTLANGCHANGE/WM_INPUTLANGCHANGEREQUEST
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::CheckChangeFont");
    CTxtEdit * const ped = GetPed();

    if (!ped->IsAutoFont() ||           // EXIT if auto font is turned off
        _cch && !dwCharFlag)            //  or if kbd change with nondegenerate
        return true;                    //  selection (WM_INPUTLANGCHANGEREQUEST)

    // Set new format using current format and new KB info.
    LONG               iCurrentFormat = _cch ? iSelFormat : _iFormat;
    const CCharFormat *pCF = ped->GetCharFormat(iCurrentFormat);
    CCharFormat        CF = *pCF;
    WORD               wLangID = LOWORD(hkl);

    CF._lcid     = wLangID;
    CF._bCharSet = GetCharSet(cpg);

    if (pCF->_lcid == wLangID && CF._bCharSet == pCF->_bCharSet)
    {
        if (ped->_fFocus && IsCaretShown())
        {
            CreateCaret();
            ped->TxShowCaret(TRUE);
        }
        return true;
    }

    CCFRunPtr   rp(*this);
    int         iMatchFont = MATCH_FONT_SIG;

    // If current is a primary US or UK kbd. We allow matching ASCII fonts
    if ((!dwCharFlag || dwCharFlag & fASCII) &&
        PRIMARYLANGID(wLangID) == LANG_ENGLISH &&
        IN_RANGE (SUBLANG_ENGLISH_US, SUBLANGID(wLangID), SUBLANG_ENGLISH_UK) &&
        wLangID == HIWORD((DWORD_PTR)hkl))
    {
        iMatchFont |= MATCH_ASCII;
    }

    if (rp.GetPreferredFontInfo(
            cpg,
            CF._bCharSet,
            CF._iFont,
            CF._yHeight,
            CF._bPitchAndFamily,
            iCurrentFormat,
            iMatchFont))
    {
        if (W32->IsFECodePage(cpg) || cpg == CP_THAI)
            ped->OrCharFlags(GetFontSig((WORD)cpg) << 8);

        // FUTURE: turn current fBIDI into fRTL and make
        // fBIDI = (fRTL | fARABIC | fHEBREW). Then can combine following if
        // with preceding if
        else if (W32->IsBiDiCodePage(cpg))
            ped->OrCharFlags(fBIDI | (GetFontSig((WORD)cpg) << 8));

        if (!_cch)
        {
            SetCharFormat(&CF, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_LCID | CFM_SIZE, CFM2_NOCHARSETCHECK);
            if(ped->IsComplexScript())
                UpdateCaret(FALSE);
        }
        else
        {
            // Create a format and use it for the selection
            LONG    iCF;
            ICharFormatCache *pf = GetCharFormatCache();

            pf->Cache(&CF, &iCF);

#ifdef LINESERVICES
            if (g_pols)
                g_pols->DestroyLine(NULL);
#endif

            Set_iCF(iCF);
            pf->Release(iCF);                           // pf->Cache AddRef it
            _fUseiFormat = TRUE;
        }
        return true;
    }

    return false;
}


//////////////////////////// PutChar, Delete, Replace  //////////////////////////////////
/*
 *  CTxtSelection::PutChar(ch, dwFlags, publdr)
 *
 *  @mfunc
 *      Insert or overtype a character
 *
 *  @rdesc
 *      TRUE if successful
 */
BOOL CTxtSelection::PutChar (
    TCHAR       ch,         //@parm Char to put
    DWORD       dwFlags,    //@parm Overtype mode and whether keyboard input
    IUndoBuilder *publdr)   //@parm If non-NULL, where to put anti-events
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::PutChar");

    _TEST_INVARIANT_

    BOOL      fOver = dwFlags & 1;
    CTxtEdit *ped = GetPed();

    SetExtend(FALSE);

    if(ch == TAB && GetPF()->InTable())
    {
        LONG cpMin, cpMost;
        LONG cch = GetRange(cpMin, cpMost);
        LONG cch0 = 0;
        LONG iDir = GetKeyboardFlags() & SHIFT ? -1 : 1;
        if(_fSelHasEOP)                         // If selection has an EOP
        {                                       //  collapse to cpMin and
            Collapser(tomStart);                //  go forward
            iDir = 1;
            if(!GetPF()->InTable())
            {
                Update(TRUE);
                return TRUE;
            }
        }
        if((_cch ^ iDir) < 0)                   // If at cpMost going back or
            FlipRange();                        //  at cpMin going forward,
                                                //  switch active end
        CRchTxtPtr rtp(*this);

        CancelModes();
        StopGroupTyping();

        if(iDir < 0 || _cch)
            rtp.Advance(-1);

        // Scan for start/end of next/prev cell
        do
        {
            ch  = rtp.GetChar();
        } while(rtp.Advance(iDir) && ch != CELL && rtp.GetPF()->InTable());

        if(ch != CELL)
        {
            if(iDir < 0)
                return FALSE;
insertRow:  rtp.BackupCRLF();               // Tabbed past end of table:
            Set(rtp.GetCp(), 0);            //  insert new row
            return InsertEOP(publdr);
        }
        if(iDir > 0)                        // Check for IP between CELL
        {                                   //  and CR at row end
            if(rtp.GetChar() == CR)
                rtp.AdvanceCRLF();          // Bypass row end
        }
        for(cch = 0;                        // Determine cchSel
            (ch = rtp.GetChar()) != CELL && rtp.GetPF()->InTable();
            cch += iDir)
        {
            cch0 = rtp.Advance(iDir);
            if(!cch0)
                break;
        }
        if(iDir > 0)                        // Tabbing forward
        {
            if(ch != CELL)                  // Went past end of table
                goto insertRow;             //  so go insert new row
        }
        else if(cch)                        // Tabbing backward with
        {                                   //  nondegenerate selection
            if(cch0)                        // Didn't run into start of story
            {
                rtp.Advance(1);             // Advance over CELL. Then if at
                if(rtp.GetChar() == CR)     //  end of row, advance over EOP
                    cch += rtp.AdvanceCRLF();
            }
            else                            // Ran into start of story
                cch -= 1;                   // Include another char since
        }                                   //  broke out of for loop
        else if(cpMin > 1)                  // Handles tabbing back over
            rtp.Advance(1);                 //  adjacent null cells

        Set(rtp.GetCp(), cch);
        _fCaretNotAtBOL = FALSE;
        Update(TRUE);
        return TRUE;
    }

    // EOPs might be entered by ITextSelection::TypeText()
    if(IsEOP(ch))
        return _pdp->IsMultiLine()          // EOP isn't allowed in
            ? InsertEOP(publdr, ch) : FALSE;//  single line controls

    if(publdr)
    {
        publdr->SetNameID(UID_TYPING);
        publdr->StartGroupTyping();
    }

    // FUTURE: a Unicode lead surrogate needs to have a trail surrogate, i.e.,
    // two 16-bit chars. A more thorough check would worry about this.
    if ((DWORD)GetTextLength() >= ped->TxGetMaxLength() &&
        ((_cch == -1 || !_cch && fOver) && _rpTX.IsAtEOP() ||
         _cch == 1 && _rpTX.IsAfterEOP()))
    {
        // Can't overtype a CR, so need to insert new char but no room
        ped->GetCallMgr()->SetMaxText();
        return FALSE;
    }
    if((!fOver || !_cch && GetCp() == GetTextLength()) &&
        !CheckTextLength(1))                        // Return if we can't
    {                                               //  add even 1 more char
        return FALSE;
    }

    // The following if statement implements Word95's "Smart Quote" feature.
    // To build this in, we still need an API to turn it on and off.  This
    // could be EM_SETSMARTQUOTES with wparam turning the feature on or off.
    // murrays. NB: this needs localization for French, German, and many
    // other languages (unless system can provide open/close chars given
    // an LCID).

    if((ch == '\'' || ch == '"') &&                 // Smart quotes
        SmartQuotesEnabled() &&
        PRIMARYLANGID(GetKeyboardLayout(0)) == LANG_ENGLISH)
    {
        LONG    cp = GetCpMin();                    // Open vs close depends
        CTxtPtr tp(ped, cp - 1);                    //  on char preceding
                                                    //  selection cpMin
        ch = (ch == '"') ? RDBLQUOTE : RQUOTE;      // Default close quote
                                                    //  or apostrophe. If at
        WCHAR chp = tp.GetChar();
        if(!cp || IsWhiteSpace(chp) || chp == '(')  //  BOStory or preceded
            ch--;                                   //  by whitespace, use
    }                                               //  open quote/apos


    // Some languages, e.g., Thai, Vietnamese require verifying the input
    // sequence order before submitting it to the backing store.

    BOOL    fBaseChar = TRUE;                       // Assume ch is a base consonant
    if(!IsInputSequenceValid(&ch, 1, fOver, &fBaseChar))
    {
        SetDualFontMode(FALSE);                     // Ignore bad sequence
        return FALSE;
    }


    DWORD bCharSetDefault = ped->GetCharFormat(-1)->_bCharSet;
    DWORD dw = GetCharFlags(ch, bCharSetDefault);
    ped->OrCharFlags(dw, publdr);

    // BEFORE we do "dual-font", we sync the keyboard and current font's
    // (_iFormat) charset if it hasn't been done.
    const CCharFormat *pCFCurrent = NULL;
    CCharFormat CF = *ped->GetCharFormat(GetiFormat());
    BYTE bCharSet = CF._bCharSet;
    BOOL fRestoreCF = FALSE;

    if(ped->IsAutoFont())
    {
        UINT uKbdcpg = 0;
        BOOL fFEKbd = FALSE;

        if(!(ped->_fIMEInProgress))
            uKbdcpg = CheckSynchCharSet(dw);

        if (fUseUIFont() && ch <= 0x0FF)
        {
            // For UIFont, we need to format ANSI characters
            // so we will not have different formats between typing and
            // WM_SETTEXT.
            if (!ped->_fIMEInProgress && dw == fHILATIN1)
            {
                // Use Ansi font if based font or current font is FE.
                if(IsFECharSet(bCharSetDefault) || IsFECharSet(bCharSet))
                    SetupDualFont();                // Use Ansi font for HiAnsi
            }
            else if (dw & fASCII && (GetCharSetMask(TRUE) & fASCII) == fASCII)
            {
                CCharFormat CFDefault = *ped->GetCharFormat(-1);
                if (IsRich() && IsBiDiCharSet(CFDefault._bCharSet)
                    && !W32->IsBiDiCodePage(uKbdcpg))
                    CFDefault._bCharSet = ANSI_CHARSET;

                SetCharFormat(&CFDefault, SCF_NOKBUPDATE, publdr, CFM_CHARSET | CFM_FACE | CFM_SIZE,
                         CFM2_CHARFORMAT | CFM2_NOCHARSETCHECK | CFM2_HOLDITEMIZE);

                _fUseiFormat = FALSE;
                pCFCurrent = &CF;
                fRestoreCF = ped->_fIMEInProgress;

            }
        }
        else if(!fUseUIFont()    && bCharSet != ANSI_CHARSET &&
                (ped->_fDualFont && bCharSet != SYMBOL_CHARSET &&
                (((fFEKbd = (ped->_fIMEInProgress || W32->IsFECodePage(uKbdcpg))) && ch < 127 && IsAlpha(ch)) ||
                 (!fFEKbd && IsFECharSet(ped->GetCharFormat(GetiFormat())->_bCharSet) && ch < 127))
                || ped->_fHbrCaps))
        {
            SetupDualFont();
            pCFCurrent = &CF;
            fRestoreCF = ped->_fIMEInProgress;
        }
    }

    // = Indic/Thai overtyping convention =
    //
    // The deal is that we will overwrite the cluster if ch is a cluster-start char
    // otherwise we just insert. This new convention was proposed by SA Office2000.
    //
    //                     Abc.Def.Ghi
    // Typing X at D       Abc.X.Ghi
    // Typing y and z      Abc.Xyz.Ghi

    SetExtend(TRUE);                                // Tell Advance() to
    if(fOver && fBaseChar)                          //  select chars
    {                                               // If nothing selected and
        if(!_cch && !_rpTX.IsAtEOP())               //  not at EOP char, try
        {                                           //  to select char at IP
            LONG iFormatSave = Get_iCF();           // Remember char's format

            AdvanceCRLF();
            SnapToCluster();

            ReplaceRange(0, NULL, publdr,
                SELRR_REMEMBERENDIP);               // Delete this character.
            ReleaseFormats(_iFormat, -1);
            _iFormat = iFormatSave;                 // Restore char's format.
        }
    }
    else if(_SelMode == smWord && ch != TAB && _cch)// Replace word selection
    {
        // The code below wants the active end to be at the end of the
        // word.  Make sure this is so.

        // FUTURE: (alexgo, andreib), _cch will only be less than zero
        // in certain weird timing situations where we get a mouse move
        // message in between the double click and mouse up messages.
        // we should rethink how we process messages && the ordering thereof.
        if(_cch < 0)
            FlipRange();
                                                    // Leave word break chars
        CTxtPtr tp(_rpTX);                          //  at end of selection
        Assert(_cch > 0);

        tp.AdvanceCp(-1);
        if(tp.GetCp() && tp.FindWordBreak(WB_ISDELIMITER))// Delimeter at sel end
            FindWordBreak(WB_LEFTBREAK);            // Backspace over it, etc.
    }

    _fIsChar = TRUE;                                // Tell CDisplay::UpdateView
    _fDontUpdateFmt = TRUE;                         //  we're PuttingChar()
    LONG iFormat = GetiFormat();                    // Save current value
    AdjustEndEOP(NEWCHARS);
    if(!_cch)
        Set_iCF(iFormat);
    _fDontUpdateFmt = FALSE;

    if(ped->_fUpperCase)
        CharUpperBuff(&ch, 1);
    else if(ped->_fLowerCase)
        CharLowerBuff(&ch, 1);

    {
        CFreezeDisplay  fd(GetPed()->_pdp);

        if(!_cch)
        {
            if(bCharSet == DEFAULT_CHARSET)
            {
                CCharFormat CFTemp;

                if (dw & fFE)       // Find a better charset for FE char
                    CFTemp._bCharSet = MatchFECharSet(dw, GetFontSignatureFromFace(CF._iFont));
                else
                    CFTemp._bCharSet = GetCharSet(W32->ScriptIndexFromFontSig(dw >> 8), NULL);

                SetCharFormat(&CFTemp, SCF_NOKBUPDATE, NULL, CFM_CHARSET, CFM2_NOCHARSETCHECK);
            }
            else if(bCharSet == SYMBOL_CHARSET && dwFlags & KBD_CHAR && ch > 255)
            {
                UINT cpg = GetKeyboardCodePage(0);  // If 125x, convert char
                if(IN_RANGE(1250, cpg, 1257))       //  back to ANSI for storing
                {                                   //  SYMBOL_CHARSET chars
                    BYTE ach;
                    WCTMB(cpg, 0, &ch, 1, (char *)&ach, 1, NULL, NULL, NULL);
                    ch = ach;
                }
            }
        }
        if(dwFlags & KBD_CHAR || ped->_fIMEInProgress || bCharSet == SYMBOL_CHARSET)
            ReplaceRange(1, &ch, publdr, SELRR_REMEMBERRANGE);
        else
            CleanseAndReplaceRange(1, &ch, TRUE, publdr, NULL);
    }

    _fIsChar = FALSE;

    // Restore font for Hebrew CAPS. Note that FE font is not restored
    // (is handled by IME).
    if(pCFCurrent && (W32->UsingHebrewKeyboard() || fRestoreCF))
        SetCharFormat(pCFCurrent, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_SIZE, CFM2_NOCHARSETCHECK);

    else if(iFormat != Get_iFormat())
        CheckChangeKeyboardLayout();

    SetDualFontMode(FALSE);

    if (!_pdp->IsFrozen())
        CheckUpdateWindow();                        // Need to update display
                                                    //  for pending chars.
    return TRUE;
}

/*
 *  CTxtSelection::CheckUpdateWindow()
 *
 *  @mfunc
 *      If it's time to update the window, after pending-typed characters,
 *      do so now. This is needed because WM_PAINT has a lower priority
 *      than WM_CHAR.
 */
void CTxtSelection::CheckUpdateWindow()
{
    DWORD ticks = GetTickCount();
    DWORD delta = ticks - _ticksPending;

    if(!_ticksPending)
        _ticksPending = ticks;
    else if(delta >= ticksPendingUpdate)
        GetPed()->TxUpdateWindow();
}

/*
 *  CTxtSelection::BypassHiddenText(iDir)
 *
 *  @mfunc
 *      Bypass hidden text forward/backward for iDir positive/negative
 *
 *  @rdesc
 *      TRUE if succeeded or no hidden text. FALSE if at document limit
 *      (end/start for Direction positive/negative) or if hidden text between
 *      cp and that limit.
 */
BOOL CTxtSelection::BypassHiddenText(
    LONG iDir)
{
    if(iDir > 0)
        _rpCF.AdjustForward();
    else
        _rpCF.AdjustBackward();

    if(!(GetPed()->GetCharFormat(_rpCF.GetFormat())->_dwEffects & CFE_HIDDEN))
        return TRUE;

    BOOL fExtendSave = _fExtend;
    SetExtend(FALSE);

    CCFRunPtr rp(*this);
    LONG cch = (iDir > 0)
             ? rp.FindUnhiddenForward() : rp.FindUnhiddenBackward();

    BOOL bRet = !rp.IsHidden();             // Note whether still hidden
    if(bRet)                                // It isn't:
        Advance(cch);                       //  bypass hidden text
    SetExtend(fExtendSave);
    return bRet;
}

/*
 *  CTxtSelection::InsertEOP(publdr)
 *
 *  @mfunc
 *      Insert EOP character(s)
 *
 *  @rdesc
 *      TRUE if successful
 */
BOOL CTxtSelection::InsertEOP (
    IUndoBuilder *publdr,   //@parm If non-NULL, where to put anti-events
    WCHAR ch)               //@parm Possible EOP char
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::InsertEOP");

    _TEST_INVARIANT_

    LONG    cchEOP = GetPed()->fUseCRLF() ? 2 : 1;
    BOOL    fResult = FALSE;
    LONG    i, iFormatSave;
    WCHAR   szBlankRow[MAX_TAB_STOPS + 1] = {CR, LF, 0};
    WCHAR * pch = szBlankRow;
    BOOL    fPFInTable;
    WORD    wPFNumbering;
    BYTE    bPFTabCount;
    BOOL    fPrevPFInTable = TRUE;

    {
        const CParaFormat *pPF = GetPF();       // Get paragraph format

        // pPF may become invalid after SetParaFormat.  So, we need
        // to save up necessary data from pPF.
        fPFInTable = pPF->InTable();
        wPFNumbering = pPF->_wNumbering;
        bPFTabCount = pPF->_bTabCount;
    }

    if(ch && (GetPed()->fUseCRLF() || IN_RANGE(VT, ch, FF)))
    {
        szBlankRow[0] = ch;
        cchEOP = 1;
    }

    _fEOP = TRUE;

    if(publdr)
    {
        publdr->StartGroupTyping();
        publdr->SetNameID(UID_TYPING);
    }

    if(fPFInTable)
    {
        SetExtend(FALSE);               // Don't want extended selection
        if(!_cch && !_rpPF.GetIch())
        {
            const CParaFormat *pPFPrev; // Get previous paragraph format

            _rpPF.AdjustBackward();
            pPFPrev = GetPed()->GetParaFormat(_rpPF.GetFormat());
            fPrevPFInTable = (pPFPrev->_wEffects & PFE_TABLE) ? TRUE : FALSE;

            _rpPF.AdjustForward();
        }

        if(fPrevPFInTable)
        {
            if(GetCp() && !_rpTX.IsAfterEOP())
            {
                while(!_rpTX.IsAtEOP() && Advance(1))
                    ;
                *pch++ = CR;
            }
            for(i = bPFTabCount; i--; *pch++ = CELL)
                ;
            *pch++ = CR;
            pch = szBlankRow;
            cchEOP = bPFTabCount + 1;
        }
    }
    if(!GetCch() && wPFNumbering && _rpTX.IsAfterEOP())
    {
        // Two enters in a row turn off numbering
        CParaFormat PF;
        PF._wNumbering = 0;
        PF._dxOffset = 0;
        SetParaFormat(&PF, publdr, PFM_NUMBERING | PFM_OFFSET);
    }

    if(CheckTextLength(cchEOP))             // If cchEOP chars can fit...
    {
        CFreezeDisplay  fd(GetPed()->_pdp);
        iFormatSave = Get_iCF();            // Save CharFormat before EOP
                                            // Get_iCF() does AddRefFormat()
        if(wPFNumbering)                    // Bullet paragraph: EOP has
        {                                   //  desired bullet CharFormat
            CFormatRunPtr rpCF(_rpCF);      // Get run pointers for locating
            CTxtPtr       rpTX(_rpTX);      //  EOP CharFormat

            rpCF.AdvanceCp(rpTX.FindEOP(tomForward));
            rpCF.AdjustBackward();
            Set_iCF(rpCF.GetFormat());      // Set _iFormat to EOP CharFormat
        }

        // Put in appropriate EOP mark
        fResult = ReplaceRange(cchEOP, pch, // If Shift-Enter, insert VT
            publdr, SELRR_REMEMBERRANGE, NULL, RR_NO_EOR_CHECK);

        Set_iCF(iFormatSave);               // Restore _iFormat if changed
        ReleaseFormats(iFormatSave, -1);    // Release iFormatSave
        if(fPFInTable)
        {
            if(!fPrevPFInTable)             // Turn off PFE_TABLE bit of
            {                               //  EOP just inserted
                CParaFormat PF;
                _cch = cchEOP;              // Select EOP just inserted
                PF._wEffects = 0;
                SetParaFormat(&PF, publdr, PFM_TABLE);
                _cch = 0;                   // Back to insertion point
            }
            else if(cchEOP > 1)
            {
                if(*pch == CR)
                    cchEOP--;
                Advance(-cchEOP);
                _fCaretNotAtBOL = FALSE;
                Update(FALSE);
            }
        }
    }
    return fResult;
}

/*
 *  CTxtSelection::Delete(fCtrl, publdr)
 *
 *  @mfunc
 *      Delete the selection. If fCtrl is true, this method deletes from
 *      min of selection to end of word
 *
 *  @rdesc
 *      TRUE if successful
 */
BOOL CTxtSelection::Delete (
    DWORD fCtrl,            //@parm If TRUE, Ctrl key depressed
    IUndoBuilder *publdr)   //@parm if non-NULL, where to put anti-events
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Delete");

    _TEST_INVARIANT_

    SELRR   mode = SELRR_REMEMBERRANGE;

    AssertSz(!GetPed()->TxGetReadOnly(), "CTxtSelection::Delete(): read only");

    if(!_cch)
        BypassHiddenText(tomForward);

    if(publdr)
    {
        publdr->StopGroupTyping();
        publdr->SetNameID(UID_DELETE);
    }

    SetExtend(TRUE);                        // Setup to change selection
    if(fCtrl)
    {                                       // Delete to word end from cpMin
        Collapser(tomStart);                //  (won't necessarily repaint,
        FindWordBreak(WB_MOVEWORDRIGHT);    //  since won't delete it)
    }

    if(!_cch)                               // No selection
    {
        mode = SELRR_REMEMBERCPMIN;
        if(!AdvanceCRLF())                  // Try to select char at IP
        {                                   // End of text, nothing to delete
            Beep();                         // Only executed in plain text,
            return FALSE;                   //  since else there's always
        }                                   //  a final EOP to select
        SnapToCluster();
        _fMoveBack = TRUE;                  // Convince Update_iFormat() to
        _fUseiFormat = TRUE;                //  use forward format
    }
    AdjustEndEOP(NONEWCHARS);
    ReplaceRange(0, NULL, publdr, mode);    // Delete selection
    return TRUE;
}

/*
 *  CTxtSelection::BackSpace(fCtrl, publdr)
 *
 *  @mfunc
 *      do what keyboard BackSpace key is supposed to do
 *
 *  @rdesc
 *      TRUE iff movement occurred
 *
 *  @comm
 *      This routine should probably use the Move methods, i.e., it's
 *      logical, not directional
 *
 *  @devnote
 *      _fExtend is TRUE iff Shift key is pressed or being simulated
 */
BOOL CTxtSelection::Backspace (
    BOOL fCtrl,     //@parm TRUE iff Ctrl key is pressed (or being simulated)
    IUndoBuilder *publdr)   //@parm If not-NULL, where to put the antievents
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::Backspace");

    _TEST_INVARIANT_

    SELRR   mode = SELRR_REMEMBERRANGE;

    AssertSz(!GetPed()->TxGetReadOnly(),
        "CTxtSelection::Backspace(): read only");

    _fCaretNotAtBOL = FALSE;

    if(publdr)
    {
        publdr->SetNameID(UID_TYPING);

        if(_cch || fCtrl)
            publdr->StopGroupTyping();
    }

    SetExtend(TRUE);                        // Set up to extend range
    if(fCtrl)                               // Delete word left
    {
        if(!GetCpMin())                     // Beginning of story: no word
        {                                   //  to delete
            Beep();
            return FALSE;
        }
        Collapser(tomStart);                // First collapse to cpMin
        if(!BypassHiddenText(tomBackward))
            goto beep;
        FindWordBreak(WB_MOVEWORDLEFT);     // Extend word left
    }
    else if(!_cch)                          // Empty selection
    {                                       // Try to select previous char
        if (!BypassHiddenText(tomBackward) ||
            !BackupCRLF(FALSE))
        {                                   // Nothing to delete
beep:       Beep();
            return FALSE;
        }
        mode = SELRR_REMEMBERENDIP;

        if(publdr)
            publdr->StartGroupTyping();
    }
    ReplaceRange(0, NULL, publdr, mode);    // Delete selection

    return TRUE;
}

/*
 *  CTxtSelection::ReplaceRange(cchNew, pch, publdr, SELRRMode)
 *
 *  @mfunc
 *      Replace selected text by new given text and update screen according
 *      to _fShowCaret and _fShowSelection
 *
 *  @rdesc
 *      length of text inserted
 */
LONG CTxtSelection::ReplaceRange (
    LONG cchNew,            //@parm Length of replacing text or -1 to request
                            // <p pch> sz length
    const TCHAR *pch,       //@parm Replacing text
    IUndoBuilder *publdr,   //@parm If non-NULL, where to put anti-events
    SELRR SELRRMode,        //@parm what to do about selection anti-events.
    LONG*   pcchMove,       //@parm number of chars moved after replacing
    DWORD   dwFlags)        //@parm Special flags
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::ReplaceRange");

    _TEST_INVARIANT_

    LONG        cchNewSave;
    LONG        cchOld;
    LONG        cchText     = GetTextLength();
    LONG        cpFirstRecalc;
    LONG        cpMin, cpMost;
    LONG        cpSave;
    BOOL        fDeleteAll = FALSE;
    BOOL        fHeading = FALSE;
    const BOOL  fUpdateView = _fShowSelection;

    CancelModes();

    if(cchNew < 0)
        cchNew = wcslen(pch);

    if(!_cch && !cchNew)                        // Nothing to do
        return 0;

    if (!GetPed()->IsStreaming() &&             // If not pasting,
        (!_cch && *pch != CR &&                 // Don't insert bet CELL & CR
         CRchTxtPtr::GetChar() == CR && GetPrevChar() == CELL && GetPF()->InTable() ||
         _cch != cchText && (IsInOutlineView() && IsCollapsed() ||
         IsHidden())))
    {                                           // Don't insert into collapsed
        Beep();                                 //  or hidden region (should
        return 0;                               //  only happen if whole story
    }                                           //  collapsed or hidden)

    GetPed()->GetCallMgr()->SetSelectionChanged();

    CheckTableSelection();
    cchOld = GetRange(cpMin, cpMost);

    if (cpMin > min(_cpSel, _cpSel + _cchSel) ||// If new sel doesn't
        cpMost < max(_cpSel, _cpSel + _cchSel)) //  contain all of old
    {                                           //  sel, remove old sel
        ShowSelection(FALSE);
        _fShowCaret = TRUE;
    }

    _fCaretNotAtBOL = FALSE;
    _fShowSelection = FALSE;                    // Suppress the flashies

    // If we are streaming in text or RTF data, don't bother with incremental
    // recalcs.  The data transfer engine will take care of a final recalc
    if(!GetPed()->IsStreaming())
    {
        // Do this before calling ReplaceRange() so that UpdateView() works
        // AROO !!! Do this before replacing the text or the format ranges!!!
        if(!_pdp->WaitForRecalc(cpMin, -1))
        {
            Tracef(TRCSEVERR, "WaitForRecalc(%ld) failed", cpMin);
            cchNew = 0;                         // Nothing inserted
            goto err;
        }
    }

    if(publdr)
    {
        Assert(SELRRMode != SELRR_IGNORE);

        // Use selection AntiEvent mode to determine what to do for undo
        LONG cp = cpMin;
        LONG cch = 0;

        if(SELRRMode == SELRR_REMEMBERRANGE)
        {
            cp = GetCp();
            cch = _cch;
        }
        else if(SELRRMode == SELRR_REMEMBERENDIP)
        {
            cp = cpMost;
        }
        else
        {
            Assert(SELRRMode == SELRR_REMEMBERCPMIN);
        }

        HandleSelectionAEInfo(GetPed(), publdr, cp, cch, cpMin + cchNew,
            0, SELAE_MERGE);
    }

    if(_cch == cchText && !cchNew)              // For delete all, set
    {                                           //  up to choose Normal
        fDeleteAll = TRUE;                      //  or Heading 1
        FlipRange();
        fHeading = IsInOutlineView() && IsHeadingStyle(GetPF()->_sStyle);
    }

    cpSave      = cpMin;
    cpFirstRecalc = cpSave;
    cchNewSave  = cchNew;
    cchNew      = CTxtRange::ReplaceRange(cchNew, pch, publdr, SELRR_IGNORE, pcchMove, dwFlags);
    _cchSel     = 0;                            // No displayed selection
    _cpSel      = GetCp();
    cchText     = GetTextLength();              // Update total text length

    if(cchNew != cchNewSave)
    {
        Tracef(TRCSEVERR, "CRchTxtPtr::ReplaceRange(%ld, %ld, %ld) failed", GetCp(), cchOld, cchNew);
        _fShowSelection = fUpdateView;
        goto err;
    }

    // The cp should be at *end* (cpMost) of replaced range (it starts
    // at cpMin of the prior range).
    AssertSz(_cpSel == cpSave + cchNew && _cpSel <= cchText,
        "CTxtSelection::ReplaceRange() - Wrong cp after replacement");

    _fShowSelection = fUpdateView;

    if(fDeleteAll)                              // When all text is deleted
    {                                           //  use Normal style unless
        CParaFormat PF;                         //  in Outline View and first
        PF._sStyle = fHeading ? STYLE_HEADING_1 : STYLE_NORMAL;
        SetParaStyle(&PF, NULL, PFM_STYLE);     //  para was a heading
        if(GetPed()->IsBiDi())
        {
            if(GetPed()->_fFocus && !GetPed()->_fIMEInProgress)
            {
                MatchKeyboardToPara();
                CheckSynchCharSet(0);
            }
        }
        else
            Update_iFormat(-1);
    }

    // Only update caret if inplace active
    if(GetPed()->fInplaceActive())
        UpdateCaret(fUpdateView);               // May need to scroll
    else                                        // Update caret when we get
        GetPed()->_fScrollCaretOnFocus = TRUE;  //  focus again

    return cchNew;

err:
    TRACEERRSZSC("CTxtSelection::ReplaceRange()", E_FAIL);
    Tracef(TRCSEVERR, "CTxtSelection::ReplaceRange(%ld, %ld)", cchOld, cchNew);
    Tracef(TRCSEVERR, "cchText %ld", cchText);

    return cchNew;
}

/*
 *  CTxtSelection::GetPF()
 *
 *  @mfunc
 *      Return ptr to CParaFormat at active end of this selection. If no PF
 *      runs are allocated, then return ptr to default format.  If active
 *      end is at cpMost of a nondegenerate selection, use the PF of the
 *      previous char (last char in selection).
 *
 *  @rdesc
 *      Ptr to CParaFormat at active end of this selection
 */
const CParaFormat* CTxtSelection::GetPF()
{
    TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtSelection::GetPF");

    if(_cch > 0)
        _rpPF.AdjustBackward();
    const CParaFormat* pPF = GetPed()->GetParaFormat(_rpPF.GetFormat());
    if(_cch > 0)
        _rpPF.AdjustForward();
    return pPF;
}

/*
 *  CTxtSelection::CheckTableSelection()
 *
 *  @mfunc
 *      Select whole cells if one or more CELLs are selected
 */
void CTxtSelection::CheckTableSelection ()
{
    if(!_fSelHasEOP && GetPF()->InTable())          // For now, don't let
    {                                               //  table CELLs be
        LONG    cpMin, cpMost;                      //  deleted, unless in
        CTxtPtr tp(_rpTX);                          //  complete rows

        GetRange(cpMin, cpMost);
        if(_cch > 0)
            tp.AdvanceCp(-_cch);                    // Start at cpMin

        while(tp.GetCp() < cpMost)
        {
            if(tp.GetChar() == CELL)                // Stop selection at CELL
            {
                Set(cpMin, cpMin - tp.GetCp());
                UpdateSelection();
                return;
            }
            tp.AdvanceCp(1);
        }
    }
}

/*
 *  CTxtSelection::SetCharFormat(pCF, fApplyToWord, publdr, dwMask, dwMask2)
 *
 *  @mfunc
 *      apply CCharFormat *pCF to this selection.  If range is an IP
 *      and fApplyToWord is TRUE, then apply CCharFormat to word surrounding
 *      this insertion point
 *
 *  @rdesc
 *      HRESULT = NOERROR if no error
 */
HRESULT CTxtSelection::SetCharFormat (
    const CCharFormat *pCF, //@parm Ptr to CCharFormat to fill with results
    DWORD         flags,    //@parm If SCF_WORD and selection is an IP,
                            //      use enclosing word
    IUndoBuilder *publdr,   //@parm Undo context
    DWORD         dwMask,   //@parm CHARFORMAT2 mask
    DWORD         dwMask2)  //@parm Second mask
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetCharFormat");

    HRESULT hr = 0;
    LONG    iFormat = _iFormat;

    if(publdr)
        publdr->StopGroupTyping();

    /*
     * The code below applies character formatting to a double-clicked
     * selection the way Word does it, that is, not applying the formatting to
     * the last character in the selection if that character is a blank.
     *
     * See also the corresponding code in CTxtRange::GetCharFormat().
     */

    LONG        cpMin, cpMost;
    LONG        cch = GetRange(cpMin, cpMost);;
    BOOL        fCheckKeyboard = (flags & SCF_NOKBUPDATE) == 0;
    CTxtRange   rg(GetPed());
    CCharFormat CF;

    if(_SelMode == smWord && (flags & SCF_USEUIRULES) && cch)
    {
        // In word select mode, don't include final blank in SetCharFormat
        CTxtPtr tpLast(GetPed(), cpMost - 1);
        if(tpLast.GetChar() == ' ')         // Selection ends with a blank:
        {
            cpMost--;                       // Setup end point to end at last
            cch--;                          //  char in selection
            fCheckKeyboard = FALSE;
            flags &= ~SCF_WORD;
        }
    }

    BYTE bCharSet = pCF->_bCharSet;

    // Smart SB/DB Font Apply Feature
    if (cch && IsRich() &&                  // > 0 chars in rich text
        !GetPed()->_fSingleCodePage &&      // Not in single cp mode
        (dwMask & CFM_FACE))                // font change
    {

        if (!(dwMask & CFM_CHARSET) || bCharSet == DEFAULT_CHARSET)
        {
            // Setup charset for DEFAULT_CHARSET or when the client only specifies
            // facename
            CF = *pCF;
            CF._bCharSet = GetFirstAvailCharSet(GetFontSignatureFromFace(CF._iFont));
            pCF = &CF;
        }

        dwMask2 |= CFM2_MATCHFONT;          // Signal to match font charsets
#if 0
        // Single byte 125x CharSet
        CFreezeDisplay fd(_pdp);            // Speed this up

        CTxtPtr     tp(GetPed(), cpMin);
        CCharFormat CF = *pCF;

        while(cpMin < cpMost)
        {
            BOOL fInCharSet = In125x(tp.GetChar(), pCF->_bCharSet);

            while(fInCharSet == In125x(tp.GetChar(), pCF->_bCharSet) &&
                   tp.GetCp() < cpMost)
            {
                tp.AdvanceCp(1);
            }
            dwMask &= ~(CFM_FACE | CFM_CHARSET);
            if(fInCharSet)
                dwMask |= (CFM_FACE | CFM_CHARSET);

            rg.SetRange(cpMin, tp.GetCp());
            HRESULT hr1 = dwMask
                        ? rg.SetCharFormat(&CF, flags | SCF_IGNORESELAE, publdr, dwMask, dwMask2)
                        : NOERROR;
            hr = FAILED(hr) ? hr : hr1;
            cpMin = tp.GetCp();
        }
#endif
    }
    if(_cch)
    {
        // Selection is being set to a charformat
        if (IsRich())
        {
            GetPed()->SetfSelChangeCharFormat();
        }

        // REVIEW (murrays): can _iFormat change if _cch != 0?
        // It is OK to not update _iFormat for a non degenerate selection
        // even if UI rules and word select have reduced it.
        rg.SetRange(cpMin, cpMost);
        hr = rg.SetCharFormat(pCF, flags, publdr, dwMask, dwMask2);
    }
    else
    {
        // But for a degenerate selection, _iFormat must be updated
        hr = CTxtRange::SetCharFormat(pCF, flags, publdr, dwMask, dwMask2);
    }

    if(fCheckKeyboard && (dwMask & CFM_CHARSET) && _iFormat != iFormat)
        CheckChangeKeyboardLayout();

    _fIsChar = TRUE;
    UpdateCaret(!GetPed()->fHideSelection());
    _fIsChar = FALSE;
    return hr;
}

/*
 *  CTxtSelection::SetParaFormat(pPF, publdr)
 *
 *  @mfunc
 *      apply CParaFormat *pPF to this selection.
 *
 *  @rdesc
 *      HRESULT = NOERROR if no error
 */
HRESULT CTxtSelection::SetParaFormat (
    const CParaFormat* pPF, //@parm ptr to CParaFormat to apply
    IUndoBuilder *publdr,   //@parm Undo context for this operation
    DWORD         dwMask)   //@parm Mask to use
{
    TRACEBEGIN(TRCSUBSYSSEL, TRCSCOPEINTERN, "CTxtSelection::SetParaFormat");

    CFreezeDisplay  fd(GetPed()->_pdp);
    HRESULT         hr;

    if(publdr)
        publdr->StopGroupTyping();

    // Apply the format
    hr = CTxtRange::SetParaFormat(pPF, publdr, dwMask);

    UpdateCaret(!GetPed()->Get10Mode() || IsCaretInView());
    return hr;
}

/*
 *  CTxtSelection::SetSelectionInfo (pselchg)
 *
 *  @mfunc  Fills out data members in a SELCHANGE structure
 */
void CTxtSelection::SetSelectionInfo(
    SELCHANGE *pselchg)     //@parm SELCHANGE structure to use
{
    LONG cpMin, cpMost;
    LONG cch = GetRange(cpMin, cpMost);;

    pselchg->chrg.cpMin  = cpMin;
    pselchg->chrg.cpMost = cpMost;
    pselchg->seltyp      = SEL_EMPTY;

    // OR in the following selection type flags if active:
    //
    // SEL_EMPTY:       insertion point
    // SEL_TEXT:        at least one character selected
    // SEL_MULTICHAR:   more than one character selected
    // SEL_OBJECT:      at least one object selected
    // SEL_MULTIOJBECT: more than one object selected
    //
    // Note that the flags are OR'ed together.
    if(cch)
    {
        LONG cObjects = GetObjectCount();           // Total object count
        if(cObjects)                                // There are objects:
        {                                           //  get count in range
            CObjectMgr *pobjmgr = GetPed()->GetObjectMgr();
            Assert(pobjmgr);

            cObjects = pobjmgr->CountObjectsInRange(cpMin, cpMost);
            if(cObjects > 0)
            {
                pselchg->seltyp |= SEL_OBJECT;
                if(cObjects > 1)
                    pselchg->seltyp |= SEL_MULTIOBJECT;
            }
        }

        cch -= cObjects;
        AssertSz(cch >= 0, "objects are overruning the selection");

        if(cch > 0)
        {
            pselchg->seltyp |= SEL_TEXT;
            if(cch > 1)
                pselchg->seltyp |= SEL_MULTICHAR;
        }
    }
}

/*
 *  CTxtSelection::UpdateForAutoWord ()
 *
 *  @mfunc  Update state to prepare for auto word selection
 *
 *  @rdesc  void
 */
void CTxtSelection::UpdateForAutoWord()
{
    AssertSz(!_cch,
        "CTxtSelection::UpdateForAutoWord: Selection isn't degenerate");

    // If enabled, prepare Auto Word Sel
    if(GetPed()->TxGetAutoWordSel())
    {
        CTxtPtr tp(_rpTX);

        // Move anchor to new location
        _cpAnchor = GetCp();

        // Remember that FindWordBreak moves tp's cp
        // (aren't side effects wonderful?
        tp.FindWordBreak(WB_MOVEWORDRIGHT);
        _cpAnchorMost =_cpWordMost = tp.GetCp();

        tp.FindWordBreak(WB_MOVEWORDLEFT);
        _cpAnchorMin = _cpWordMin = tp.GetCp();

        _fAutoSelectAborted = FALSE;
    }
}

/*
 *  CTxtSelection::AutoSelGoBackWord(pcpToUpdate, iDirToPrevWord, iDirToNextWord)
 *
 *  @mfunc  Backup a word in auto word selection
 */
void CTxtSelection::AutoSelGoBackWord(
    LONG *  pcpToUpdate,    //@parm end of word selection to update
    int     iDirToPrevWord, //@parm direction to next word
    int     iDirToNextWord) //@parm direction to previous word
{
    if (GetCp() >= _cpAnchorMin &&
        GetCp() <= _cpAnchorMost)
    {
        // We are back in the first word. Here we want to pop
        // back to a selection anchored by the original selection

        Set(GetCp(), GetCp() - _cpAnchor);
        _fAutoSelectAborted = FALSE;
        _cpWordMin  = _cpAnchorMin;
        _cpWordMost = _cpAnchorMost;
    }
    else
    {
        // pop back a word
        *pcpToUpdate = _cpWordPrev;

        CTxtPtr tp(_rpTX);

        _cpWordPrev = GetCp() + tp.FindWordBreak(iDirToPrevWord);
        FindWordBreak(iDirToNextWord);
    }
}

/*
 *  CTxtSelection::InitClickForAutWordSel (pt)
 *
 *  @mfunc  Init auto selection for click with shift key down
 *
 *  @rdesc  void
 */
void CTxtSelection::InitClickForAutWordSel(
    const POINT pt)     //@parm Point of click
{
    // If enabled, prepare Auto Word Sel
    if(GetPed()->TxGetAutoWordSel())
    {
        // If auto word selection is occuring we want to pretend
        // that the click is really part of extending the selection.
        // Therefore, we want the auto word select data to look as
        // if the user had been extending the selection via the
        // mouse all along. So we set the word borders to the
        // word that would have been previously selected.

        // Need this for finding word breaks
        CRchTxtPtr  rtp(GetPed());
        LONG cpClick = _pdp->CpFromPoint(pt, NULL, &rtp, NULL, TRUE);
        int iDir = -1;

        if(cpClick < 0)
        {
            // If this fails what can we do? Prentend it didn't happen!
            // We can do this because it will only make the UI act a
            // little funny and chances are the user won't even notice.
            return;
        }

        // Assume click is within anchor word
        _cpWordMost = _cpAnchorMost;
        _cpWordMin = _cpAnchorMin;

        if(cpClick > _cpAnchorMost)
        {
            // Click is after anchor word, so set cpMost appropriately
            iDir = WB_MOVEWORDLEFT;
            rtp.FindWordBreak(WB_MOVEWORDLEFT);
            _cpWordMost = rtp.GetCp();
        }
        // Click is before the anchor word
        else if(cpClick < _cpAnchorMost)
        {
            // Click is before  anchor word, so set cpMin appropriately.
            iDir = WB_MOVEWORDRIGHT;
            rtp.FindWordBreak(WB_MOVEWORDRIGHT);
            _cpWordMin = rtp.GetCp();
        }

        if(iDir != -1)
        {
            rtp.FindWordBreak(iDir);
            _cpWordPrev = rtp.GetCp();
        }
    }
}

/*
 *  CTxtSelection::CreateCaret ()
 *
 *  @mfunc  Create a caret
 *
 *  @devnote
 *      The caret is characterized by a height (_yHeightCaret), a keyboard
 *      direction (if BiDi), a width (1 to 8, since OS can't handle carets
 *      larger than 8 pixels), and an italic state.  One could cache this
 *      info thereby avoiding computing the caret on every keystroke.
 */
void CTxtSelection::CreateCaret()
{
    CTxtEdit *      ped  = GetPed();
    const CCharFormat *pCF = ped->GetCharFormat(_iFormat);
    DWORD           dwCaretType = 0;
    BOOL            fItalic;
    LONG            y = min(_yHeightCaret, 512);

    y = max(0, y);

    // Caret shape reflects current charset
    if(IsComplexKbdInstalled())
    {
        // Custom carets aren't italicized
        fItalic = 0;
        LCID    lcid = GetKeyboardLCID();

        dwCaretType = CARET_CUSTOM;

        if (W32->IsBiDiLcid(lcid))
            dwCaretType = CARET_CUSTOM | CARET_BIDI;

        else if (PRIMARYLANGID(lcid) == LANG_THAI)
            dwCaretType = CARET_CUSTOM | CARET_THAI;

        else if (W32->IsIndicLcid(lcid))
            dwCaretType = CARET_CUSTOM | CARET_INDIC;
    }
    else
        fItalic = pCF->_dwEffects & CFE_ITALIC && _yHeightCaret > 15; //9 pt/15 pixels looks bad

    INT dx = dxCaret;
    DWORD dwCaretInfo = (_yHeightCaret << 16) | (dx << 8) | (dwCaretType << 4) |
                        (fItalic << 1) | !_cch;

    if (ped->_fKoreanBlockCaret)
    {
        // Support Korean block caret during Kor IME composition
        // Basically, we want to create a caret using the width and height of the
        // character at current cp.
        CDisplay    *pdp = ped->_pdp;
        LONG        cpMin, cpMost;
        POINT       ptStart, ptEnd;

        GetRange(cpMin, cpMost);

        CRchTxtPtr tp(ped, cpMin);

        if (pdp->PointFromTp(tp, NULL, FALSE, ptStart, NULL, TA_TOP+TA_LEFT) != -1 &&
            pdp->PointFromTp(tp, NULL, FALSE, ptEnd, NULL, TA_BOTTOM+TA_RIGHT) != -1)
        {
            // Destroy whatever caret bitmap we had previously
            DeleteCaretBitmap(TRUE);

            LONG    iCharWidth = ptEnd.x - ptStart.x;
            if (!ped->fUseLineServices())
            {
                const CCharFormat *pCF = tp.GetCF();
                CLock lock;
                HDC hdc = W32->GetScreenDC();
                if(hdc)
                {
                    LONG dypInch = MulDiv(GetDeviceCaps(hdc, LOGPIXELSY), _pdp->GetZoomNumerator(), _pdp->GetZoomDenominator());
                    CCcs *pccs = fc().GetCcs(pCF, dypInch);
                    if(pccs)
                    {
                        LONG iKorCharWidth;
                        if (pccs->Include(0xAC00, iKorCharWidth))
                            iCharWidth = iKorCharWidth;
                        pccs->Release();
                    }
                }
            }

            ped->TxCreateCaret(0, iCharWidth, ptEnd.y - ptStart.y);
            _fCaretCreated = TRUE;
            ped->TxSetCaretPos(ptStart.x, ptStart.y);
        }

        return;
    }

    // We always create the caret bitmap on the fly since it
    // may be of arbitrary size
    if (dwCaretInfo != _dwCaretInfo)
    {
        _dwCaretInfo = dwCaretInfo;                 // Update caret info

        // Destroy whatever caret bitmap we had previously
        DeleteCaretBitmap(FALSE);

        if (y && y == _yHeightCaret && (_cch || fItalic || dwCaretType))
        {
            LONG dy = 4;                            // Assign value to suppress
            LONG i;                                 //  compiler warning
            WORD rgCaretBitMap[512];
            WORD wBits = 0x0020;

            if(_cch)                                // Create blank bitmap if
            {                                       //  selection is nondegenerate
                y = 1;                              //  (allows others to query
                wBits = 0;                          //  OS where caret is)
                fItalic = FALSE;
            }
            if(fItalic)
            {
                i = (5*y)/16 - 1;                   // System caret can't be wider
                i = min(i, 7);                      //  than 8 bits
                wBits = 1 << i;                     // Make larger italic carets
                dy = y/7;                           //  more vertical. Ideal is
                dy = max(dy, 4);                    //  usually up 4 over 1, but
            }                                       //  if bigger go up 5 over 1...
            for(i = y; i--; )
            {
                rgCaretBitMap[i] = wBits;
                if(fItalic && !(i % dy))
                    wBits /= 2;
            }

            if(!fItalic && !_cch && dwCaretType)
            {
                dwCaretType &= ~CARET_CUSTOM;

                // Create an appropriate shape
                switch (dwCaretType)
                {
                    case CARET_BIDI:
                        // BiDi is a caret with a little triangle on top (flag shape pointing left)
                        rgCaretBitMap[0] = 0x00E0;
                        rgCaretBitMap[1] = 0x0060;
                        break;
                    case CARET_THAI:
                        // Thai is an L-like shape (same as system edit control)
                        rgCaretBitMap[y-2] = 0x0030;
                        rgCaretBitMap[y-1] = 0x0038;
                        break;
                    case CARET_INDIC:
                        // Indic is a T-like shape
                        rgCaretBitMap[0] = 0x00F8;
                        rgCaretBitMap[1] = 0x0070;
                        break;
                    default:
                        if (ped->IsBiDi())
                        {
                            // Non-BiDi caret in BiDi document (flag shape pointing right)
                            rgCaretBitMap[0] = 0x0038;
                            rgCaretBitMap[1] = 0x0030;
                        }
                }
            }
            _hbmpCaret = (HBITMAP)CreateBitmap(8, y, 1, 1, rgCaretBitMap);
        }
    }

    ped->TxCreateCaret(_hbmpCaret, dx, (INT)_yHeightCaret);
    _fCaretCreated = TRUE;

    LONG xShift = _hbmpCaret ? 2 : 0;
    if(fItalic)
    {
        // TODO: figure out better shift algorithm. Use CCcs::_xOverhang?
        if(pCF->_iFont == IFONT_TMSNEWRMN)
            xShift = 4;
        xShift += y/16;
    }
    xShift = _xCaret - xShift;
#ifdef Boustrophedon
    //if(_pPF->_wEffects & PFE_BOUSTROPHEDON)
    {
        RECT rcView;
        _pdp->GetViewRect(rcView, NULL);
        xShift = rcView.right - xShift;
    }
#endif
    ped->TxSetCaretPos(xShift, (INT)_yCaret);
}

/*
 *  CTxtSelection::DeleteCaretBitmap (fReset)
 *
 *  @mfunc  DeleteCaretBitmap
 */
void CTxtSelection::DeleteCaretBitmap(
    BOOL fReset)
{
    if(_hbmpCaret)
    {
        DestroyCaret();
        DeleteObject((void *)_hbmpCaret);
        _hbmpCaret = NULL;
    }
    if(fReset)
        _dwCaretInfo = 0;
}

/*
 *  CTxtSelection::SetDelayedSelectionRange (cp, cch)
 *
 *  @mfunc  sets the selection range such that it won't take effect until
 *          the control is "stable"
 */
void CTxtSelection::SetDelayedSelectionRange(
    LONG    cp,         //@parm Active end
    LONG    cch)        //@parm Signed extension
{
    CSelPhaseAdjuster *pspa;

    pspa = (CSelPhaseAdjuster *)GetPed()->GetCallMgr()->GetComponent(
                        COMP_SELPHASEADJUSTER);
    Assert(pspa);
    pspa->CacheRange(cp, cch);
}

/*
 *  CTxtSelection::CheckPlainTextFinalEOP ()
 *
 *  @mfunc
 *      returns TRUE if this is a plain-text, multiline control with caret
 *      allowed at BOL and the selection at the end of the story following
 *      and EOP
 *
 *  @rdesc
 *      TRUE if all of the conditions above are met
 */
BOOL CTxtSelection::CheckPlainTextFinalEOP()
{
    return !IsRich() && _pdp->IsMultiLine() &&      // Plain-text, multiline
           !_fCaretNotAtBOL &&                      //  with caret OK at BOL,
           GetCp() == GetTextLength() &&            //  & cp at end of story
           _rpTX.IsAfterEOP();
}


/*
 *  CTxtSelection::StopGroupTyping()
 *
 *  @mfunc
 *      Tell undo manager to stop group typing
 */
void CTxtSelection::StopGroupTyping()
{
    IUndoMgr * pundo = GetPed()->GetUndoMgr();

    if(pundo)
        pundo->StopGroupTyping();
}

/*
 *  CTxtSelection::SetupDualFont(ch)
 *
 *  @mfunc  checks to see if dual font support is necessary; in this case,
 *          switching to an English font if English text is entered into
 *          an FE run
 *  @rdesc
 *      A pointer to the current CharFormat if the font has to be changed.
 */
void CTxtSelection::SetupDualFont()
{
    CTxtEdit    *ped = GetPed();
    CCharFormat CF;

    CF._bCharSet = ANSI_CHARSET;
    CCFRunPtr   rp(*this);

    if (rp.GetPreferredFontInfo(
            1252,
            CF._bCharSet,
            CF._iFont,
            CF._yHeight,
            CF._bPitchAndFamily,
            _iFormat,
            IGNORE_CURRENT_FONT))
    {
        if (!_cch)
            SetCharFormat(&CF, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_SIZE, 0);
        else
        {
            // For selection, we need to set the character format at cpMin+1
            // and use the format for the selection.
            CTxtRange rg(ped, GetCpMin() + 1, 0);
            rg.SetCharFormat(&CF, SCF_NOKBUPDATE, NULL, CFM_FACE | CFM_CHARSET | CFM_SIZE, 0);
            Set_iCF(rg.Get_iCF());
            GetCharFormatCache()->Release(_iFormat);    // rg.Get_iCF() AddRefs it
            _fUseiFormat = TRUE;
        }

        SetDualFontMode(TRUE);
    }
}

//
//  CSelPhaseAdjuster methods
//

/*
 *  CSelPhaseAdjuster::CSelPhaseAdjuster
 *
 *  @mfunc  constructor
 */
CSelPhaseAdjuster::CSelPhaseAdjuster(
    CTxtEdit *ped)      //@parm the edit context
{
    _cp = _cch = -1;
    _ped = ped;
    _ped->GetCallMgr()->RegisterComponent((IReEntrantComponent *)this,
                            COMP_SELPHASEADJUSTER);
}

/*
 *  CSelPhaseAdjuster::~CSelPhaseAdjuster
 *
 *  @mfunc  destructor
 */
CSelPhaseAdjuster::~CSelPhaseAdjuster()
{
    // Save some indirections
    CTxtEdit *ped = _ped;

    if(_cp != -1)
    {
        ped->GetSel()->SetSelection(_cp - _cch, _cp);

        // If the selection is updated, then we invalidate the
        // entire display because the old selection can still
        // appear othewise because the part of the screen that
        // it was on is not updated.
        if(ped->fInplaceActive())
        {
            // Tell entire client rectangle to update.
            // FUTURE: The smaller we make this the better.
            ped->TxInvalidateRect(NULL, FALSE);
        }
    }
    ped->GetCallMgr()->RevokeComponent((IReEntrantComponent *)this);
}

/*
 *  CSelPhaseAdjuster::CacheRange(cp, cch)
 *
 *  @mfunc  tells this class the selection range to remember
 */
void CSelPhaseAdjuster::CacheRange(
    LONG    cp,         //@parm Active end to remember
    LONG    cch)        //@parm Signed extension to remember
{
    _cp     = cp;
    _cch    = cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\runptr.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module RUNPTR.C -- Text run and run pointer class |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		6/25/95	alexgo	Commented and Cleaned up.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_runptr.h"
#include "_text.h"

ASSERTDATA

//
//	Invariant stuff
//
#define DEBUG_CLASSNAME	CRunPtrBase

#include "_invar.h"

// ===========================  CRunPtrBase class  ==================================================

#ifdef DEBUG
/*
 *	CRunPtrBase::Invariant()
 *
 *	@mfunc
 *		Debug-only function that validates the internal state consistency
 *		for CRunPtrBase
 *
 *	@rdesc
 *		TRUE always (failures assert)
 */
BOOL CRunPtrBase::Invariant() const
{
	if(!IsValid())
	{
		Assert(_iRun == 0 && _ich >= 0);		// CLinePtr can have _ich > 0
	}
	else
	{
		Assert(_iRun < _pRuns->Count());
		LONG cch = _pRuns->Elem(_iRun)->_cch;
		Assert((DWORD)_ich <= (DWORD)cch);
	}
	return TRUE;
}

/*
 *	CRunPtrBase::ValidatePtr(pRun)
 *
 *	@mfunc
 *		Debug-only validation method that asserts if pRun doesn't point
 *		to a valid text run
 */
void CRunPtrBase::ValidatePtr(void *pRun) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::ValidatePtr");

	AssertSz(IsValid() && pRun >= _pRuns->Elem(0) &&
			 pRun <= _pRuns->Elem(Count() - 1),
		"CRunPtr::ValidatePtr: illegal ptr");
}

/*
 *	CRunPtrBase::CalcTextLength()
 *
 *	@mfunc
 *		Calculate length of text by summing text runs accessible by this
 *		run ptr
 *
 *	@rdesc
 *		length of text so calculated, or -1 if failed
 */
LONG CRunPtrBase::CalcTextLength() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CalcTextLength");
    AssertSz(_pRuns,
		"CTxtPtr::CalcTextLength() - Invalid operation on single run CRunPtr");

	LONG i = Count();
	if(!i)
		return 0;

	LONG	 cb = _pRuns->Size();
	LONG	 cchText = 0;
	CTxtRun *pRun = _pRuns->Elem(0);

	while(i--)
	{
		cchText += pRun->_cch;
		pRun = (CTxtRun *)((BYTE *)pRun + cb);
	}
	return cchText;
}

#endif

/*
 *	CRunPtrBase::GetCchLeft()
 *
 *	@mfunc
 *		Calculate count of chars left in run starting at current cp.
 *		Complements GetIch(), which	is length of text up to this cp. 
 *
 *	@rdesc
 *		Count of chars so calculated
 */
LONG CRunPtrBase::GetCchLeft() const	
{
	return GetRun(0)->_cch - GetIch();
}								

/*
 *	CRunPtrBase::CRunPtrBase(pRuns)
 *
 *	@mfunc		constructor
 */
CRunPtrBase::CRunPtrBase(
	CRunArray *pRuns)		//@parm	The Run array for the run ptr
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CRunPtrBase");

	_pRuns = pRuns; 
	_iRun = 0; 
	_ich = 0; 

	//make sure everything has been initialized
	Assert(sizeof(CRunPtrBase) == (sizeof(_pRuns) + sizeof(_iRun) 
		+ sizeof(_ich)));
}

/*
 *	CRunPtrBase::CRunPtrBase(rp)
 *
 *	Copy Constructor
 */
CRunPtrBase::CRunPtrBase(
	CRunPtrBase& rp)			//@parm	Other run pointer to initialize from
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CRunPtrBase");

	*this = rp;
}

/* 
 *	CRunPtrBase::SetRun(iRun, ich)
 *
 *	@mfunc
 *		Sets this run ptr to the given run.  If it does not
 *		exist, then we set ourselves to the closest valid run
 *
 *	@rdesc
 *		TRUE if moved to iRun
 */
BOOL CRunPtrBase::SetRun(
	LONG iRun,					//@parm Run index to use 
	LONG ich)					//@parm Char index within run to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::SetRun");

	_TEST_INVARIANT_

	BOOL	 bRet = TRUE;
	LONG	 count = Count();

	// Set the run

	if(!IsValid())						// No runs instantiated:
		return FALSE;					//  leave this rp alone

	if(iRun >= count)					// Validate iRun
	{
		bRet = FALSE;
		iRun = count - 1;				// If (!count), negative iRun 
	}									//  is handled by following if
	if(iRun < 0)
	{
		bRet = FALSE;
		iRun = 0;
	}
	_iRun = iRun;

	// Set the offset
	_ich = ich;
	CTxtRun *pRun = _pRuns->Elem(iRun);
	_ich = min(ich, pRun->_cch);

	return bRet;
}
												
/*
 *	CRunPtrBase::NextRun()
 *
 *	@mfunc
 *		Change this RunPtr to that for the next text run
 *
 *	@rdesc
 *		TRUE if succeeds, i.e., target run exists
 */
BOOL CRunPtrBase::NextRun()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::NextRun");

	_TEST_INVARIANT_

 	if(_pRuns && _iRun < Count() - 1)
	{
		++_iRun;
		_ich = 0;
		return TRUE;
	}
	return FALSE;
}

/*
 *	CRunPtrBase::PrevRun()
 *
 *	@mfunc
 *		Change this RunPtr to that for the previous text run
 *
 *	@rdesc
 *		TRUE if succeeds, i.e., target run exists
 */
BOOL CRunPtrBase::PrevRun()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::PrevRun");

	_TEST_INVARIANT_

	if(_pRuns)
	{
		_ich = 0;
		if(_iRun > 0)
		{
			_iRun--;
			return TRUE;
		}
	}
	return FALSE;
}

/*
 *	CRunPtrBase::GetRun(cRun)
 *
 *	@mfunc
 *		Get address of the TxtRun that is cRun runs away from the run
 *		pointed to by this RunPtr
 *
 *	@rdesc
 *		ptr to the CTxtRun cRun's away
 */
CTxtRun* CRunPtrBase::GetRun(
	LONG cRun) const	//@parm signed count of runs to reach target CTxtRun
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::GetRun");

	_TEST_INVARIANT_
	Assert(IsValid());						// Common problem...
	return _pRuns->Elem(_iRun + cRun);
}

/*
 *	CRunPtrBase::CalculateCp()
 *
 *	@mfunc
 *		Get cp of this RunPtr
 *
 *	@rdesc
 *		cp of this RunPtr
 *
 *	@devnote
 *		May be computationally expensive if there are many elements
 *		in the array (we have to run through them all to sum cch's.
 *		Used by TOM collections and Move commands, so needs to be fast.
 */
LONG CRunPtrBase::CalculateCp () const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::GetCp");

	_TEST_INVARIANT_

	Assert(IsValid());

	LONG cb = _pRuns->Size();
	LONG cp	 = _ich;			// Correct result if _iRun = 0
	LONG iRun = _iRun;

	if(!iRun)
		return cp;

	CTxtRun *pRun = GetRun(0);

	while(iRun--)
	{
		Assert(pRun);		
		pRun = (CTxtRun *)((BYTE *)pRun - cb);
		cp += pRun->_cch;
	}
	return cp;
}

/*
 *	CRunPtrBase::BindToCp(cp)
 *
 *	@mfunc
 *		Set this RunPtr to correspond to a cp.
 *
 *	@rdesc
 *		the cp actually set to
 */
LONG CRunPtrBase::BindToCp(
	LONG cp)			//@parm character position to move this RunPtr to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::BindToCp");

	_iRun = 0;
	_ich = 0;
	return AdvanceCp(cp);
}

/*
 *	CRunPtrBase::AdvanceCp(cch)
 *
 *	@mfunc
 *		Advance this RunPtr by (signed) cch chars.  If it lands on the
 *		end of a run, it automatically goes to the start of the next run
 *		(if one exists). 
 *
 *	@rdesc
 *		Count of characters actually moved
 */
LONG CRunPtrBase::AdvanceCp(
	LONG cch)			//@parm signed count of chars to move this RunPtr by
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::AdvanceCp");

	if(!cch || !IsValid())
		return cch;

	LONG cchSave = cch;

	if(cch < 0)
		while(cch < 0)
		{
			if(-cch <= _ich)
			{
				_ich += cch;					// Target is in this run
				cch = 0;
				break;
			}
			// Otherwise, we need to go to previous run. First add count
			// of chars from start of current run to current postion.
			cch += _ich;
			if(_iRun <= 0)						// Already in first run
			{
				_iRun = 0;
				_ich = 0;						// Move to run beginning
				break;
			}
			_ich = _pRuns->Elem(--_iRun)->_cch;	// Move to previous run
		}
	else
	{
		LONG	 cchRun;
		CTxtRun *pRun = GetRun(0);

		while(cch > 0)							// Move forward
		{
			cchRun = pRun->_cch;
			_ich += cch;

			if(_ich < cchRun)					// Target is in this run
			{
				cch = 0;						// Signal countdown completed
				break;							// (if _ich = cchRun, go to
			}									//  next run)	

			cch = _ich - cchRun;				// Advance to next run
			if(++_iRun >= Count())				// Ran past end, back up to
			{									//  end of story
				--_iRun;
				Assert(_iRun == Count() - 1);
				Assert(_pRuns->Elem(_iRun)->_cch == cchRun);
				_ich = cchRun;
				break;
			}
			_ich = 0;							// Start at new BOL
			pRun = (CTxtRun *)((BYTE *)pRun + _pRuns->Size());
		}
	}

	// NB! we check the invariant at the end to handle the case where
	// we are updating the cp for a floating range (i.e., we know that
	// the cp is invalid, so we fix it up).  So we have to check for
	// validity *after* the fixup.
	_TEST_INVARIANT_

	return cchSave - cch;						// Return TRUE if countdown
}												// completed

/*
 *	CRunPtrBase::CountRuns(&cRun, cchMax, cp, cchText)
 *
 *	@mfunc
 *		Count characters up to <p cRun> runs away or <p cchMax> chars,
 *		whichever comes first. If the target run and <p cchMax> are both
 *		beyond the corresponding end of the document, count up thru the
 *		closest run (0 or Count() - 1).  The direction of counting is
 *		determined by the sign of <p cRun>.  To count without being limited
 *		by <p cchMax>, set it equal to tomForward. An initial partial
 *		run counts as a run, i.e., if cRun > 0 and _ich < cch in current
 *		run or if cRun < 0 and _ich > 0, that counts as a run.
 *
 *	@rdesc
 *		Return the signed cch counted and set <p cRun> equal to count of runs
 *		actually counted.  If no runs are allocated, the text is treated as
 *		a single run.  If <p cRun> = 0, -_ich is returned. If <p cRun> <gt> 0
 *		and this run ptr points to the end of the last run, no change is made
 *		and 0 is returned.
 *
 *	@devnote
 *		The maximum count capability is included to be able to count units in
 *		a range.  The <p tp> argument is needed for getting the text length
 *		when no runs exist and <p cRun> selects forward counting.
 */
LONG CRunPtrBase::CountRuns (
	LONG &	cRun,			//@parm Count of runs to get cch for
	LONG	cchMax,			//@parm Maximum char count
	LONG	cp,				//@parm CRchTxtPtr::GetCp()
	LONG	cchText) const	//@parm Text length of associated story
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::CountRuns");

	_TEST_INVARIANT_

	LONG cch;

	if(!cRun)								// Nothing to do
		return 0;

	// Simple special single-run case
	if(!IsValid())							// No runs instantiated: act as a
	{										//  single run
		if(cRun > 0)						// Count forward
		{
			cch	= cchText - cp;				// Partial count to end of run
			cRun = 1;						// No more than one run
		}
		else								// Count backward
		{
			cch = -cp;						// Partial count to start of run
			cRun = -1;						// No less than minus one run
		}			
		if(!cch)							// No partial run, so no runs
			cRun = 0;						//  counted
		return cch;
	}

	// General case for which runs are instantiated

	LONG		cb	 = _pRuns->Size();		// Size of text run element
	LONG		iDir;
	LONG		iRun = _iRun;				// Cache run index for current run
	LONG		j, k;						// Handy integers
	CTxtRun *	pRun = GetRun(0);			// Not NULL since runs exist

	if(cRun < 0)							// Try to count backward cRun runs
	{
		iDir = -1;
		cb	 = -cb;							// Byte count to previous element
		cch	 = _ich;						// Remaining cch in current run
		if(cch)								// If cch != 0, initial run counts
			cRun++;							//  as a run: 1 less for for loop
		cRun = max(cRun, -iRun);			// Don't let for loop overshoot
	}
	else
	{										// Try to count forward cRun runs 
		Assert(cRun > 0);
		iDir = 1;
		cch	 = pRun->_cch - _ich;			// Remaining cch in current run
		if(cch)								// If cch != 0, initial run counts
			cRun--;							//  as a run: 1 less for for loop
		k	 = Count() - iRun - 1;			// k = # runs following current run
		cRun = min(cRun, k);				// Don't let for loop overshoot
	}

	k	 = cch;								// Remember if initial cch != 0
	for(j = cRun; j && cch < cchMax; j -= iDir)
	{
		pRun = (CTxtRun *)((BYTE *)pRun + cb);	// Point at following run
		cch += pRun->_cch;					// Add in its count
	}
	if(k)									// Initial partial run counts as
		cRun += iDir;						//  a run
	cRun -= j;								// Discount any runs not counted
											//  if |cch| >= cchMax
	return iDir*cch;						// Return total cch bypassed
}

/*
 *	CRunPtrBase::FindRun (pcpMin, pcpMost, cpMin, cch)
 *
 *	@mfunc
 *		Set *<p pcpMin>  = closest run cpMin <lt>= range cpMin, and
 *		set *<p pcpMost> = closest run cpMost <gt>= range cpMost
 *
 *	@devnote
 *		This routine plays a role analogous to CTxtRange::FindParagraph
 *		(pcpMin, pcpMost), but needs extra arguments since this run ptr does
 *		not know the range cp's.  This run ptr is located at the range active
 *		end, which is determined by the range's signed length <p cch> in
 *		conjunction with <p cpMin>.
 */
void CRunPtrBase::FindRun (
	LONG *pcpMin,			//@parm Out parm for bounding-run cpMin
	LONG *pcpMost,			//@parm Out parm for bounding-run cpMost
	LONG cpMin,				//@parm Range cpMin
	LONG cch,				//@parm Range signed length
	LONG cchText) const		//@parm Story length
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::FindRun");

	if(!IsValid())
	{
		if(pcpMin)						// Run is whole story
			*pcpMin = 0;
		if(pcpMost)
			*pcpMost = cchText;
		return;
	}

	BOOL fAdvanceCp;					// Controls AdvanceCp for pcpMost
	CRunPtrBase rp((CRunPtrBase&)(*this));	// Clone this runptr to keep it const

	rp.AdjustForward();					// Select forward run
	if(pcpMin)
	{									// If cch != 0, rp is sure to end up
		fAdvanceCp = cch;				//  at cpMin, so pcpMost needs advance
		if(cch > 0)						// rp is at cpMost, so move it to
			rp.AdvanceCp(-cch);			//  cpMin
		*pcpMin = cpMin - rp._ich;		// Subtract off offset in this run
	}
	else
		fAdvanceCp = cch < 0;			// Need to advance to get pcpMost

	if(pcpMost)
	{
		cch = abs(cch);
		if(fAdvanceCp)					// Advance to cpMost = cpMin + cch,
			rp.AdvanceCp(cch);			//  i.e., range's cpMost
		if(cch)
			rp.AdjustBackward();		// Since nondegenerate range
		*pcpMost = cpMin + cch			// Add remaining cch in run to range's
				+ rp.GetCchLeft();		//  cpMost
	}
}

/*
 *	CRunPtrBase::AdjustBackward()
 *
 *	@mfunc
 *		If the cp for this run ptr is at the "boundary" or edge between two
 *		runs, then make sure this run ptr points to the end of the first run.
 *
 *	@comm
 *		This function does nothing unless this run ptr points to the beginning
 *		or the end of a run.  This function may be needed in those cases
 *		because	a cp at the beginning of a run is identical to the cp for the
 *		end of the previous run (if it exists), i.e., such an "edge" cp is
 *		ambiguous, and you may need to be sure that this run ptr points to the
 *		end of the first run.
 *
 *		For example, consider a run that describes characters at cp's 0 to 10
 *		followed by a run that describes characters	at cp's 11 through 12. For
 *		a cp of 11, it is possible for the run ptr to be either at the *end*
 *		of the first run or at the *beginning* of the second run.	 
 *
 *	@rdesc 	nothing
 */
void CRunPtrBase::AdjustBackward()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::AdjustBackward");

	_TEST_INVARIANT_

	if(!_ich && PrevRun())				// If at start of run that isn't
		_ich = _pRuns->Elem(_iRun)->_cch;	//  the first, go to end of
}											//  previous run

/*
 *	CRunPtrBase::AdjustForward()
 *
 *	@mfunc
 *		If the cp for this run ptr is at the "boundary" or edge between two
 *		runs, then make sure this run ptr points to the start of the second
 *		run.
 *
 *	@rdesc
 *		nothing
 *	
 *	@xref
 *		<mf CRunPtrBase::AdjustBackward>
 */
void CRunPtrBase::AdjustForward()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::AdjustForward");

	_TEST_INVARIANT_

	if(!IsValid())
		return;

	CTxtRun *pRun = _pRuns->Elem(_iRun);

	if(pRun->_cch == _ich)					// If at end of run, go to start
		NextRun();							//  of next run (if it exists)
}

/*
 *	CRunPtrBase::IsValid()
 *
 *	@mfunc
 *		indicates whether the current run pointer is in the empty
 *		or NULL states (i.e. "invalid" states).
 *
 *	@rdesc
 *		TRUE is in the empty or NULL state, FALSE otherwise.
 */
BOOL CRunPtrBase::IsValid() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::IsValid");

	return _pRuns && _pRuns->Count();
}

/*
 *	CRunPtrBase::SetToNull()
 *
 *	@mfunc
 *		Sets all run pointer information to be NULL. This
 *		is designed to handle the response to clearing document runs
 *		such as when we convert from rich text to plain text.
 *
 *	@rdesc
 *		VOID
 */
void CRunPtrBase::SetToNull() 
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CRunPtrBase::SetToNull");

	_pRuns = NULL;
	_iRun = 0;
	_ich = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\rtfwrit2.cpp ===
/*
 *	rtfwrit2.cpp
 *
 *	Description:
 *		This file contains the embedded-object implementation of the RTF
 *		writer for the RICHEDIT subsystem.
 *
 *	Authors:
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco
 *		Conversion to C++ and RichEdit 2.0:  
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"


#include "_rtfwrit.h"
#include "_coleobj.h"

ASSERTDATA

// ************** V-GUYB: Add this for converting pictures to 2bpp during stream out.
#if defined(CONVERT2BPP) 

#define PWDV1_BPP   2

typedef struct 
{
    BITMAPINFOHEADER bmih;
    RGBQUAD          colors[4];
}
BMI2BPP;

const BYTE ColorTable2bpp[] = 
{
    0x00, 0x00, 0x00, 0x00, 
    0x55, 0x55, 0x55, 0x00, 
    0xAA, 0xAA, 0xAA, 0x00, 
    0xFF, 0xFF, 0xFF, 0x00
};
#endif // CONVERT2BPP
// ************** V-GUYB: End of conversion stuff.

static const CHAR szHexDigits[] = "0123456789abcdef";

static const CHAR szLineBreak[] = "\r\n";

const BYTE ObjectKeyWordIndexes [] =
{
	i_objw,i_objh,i_objscalex, i_objscaley, i_objcropl, i_objcropt, i_objcropr, i_objcropb
} ;

const BYTE PictureKeyWordIndexes [] =
{
	i_picw,i_pich,i_picscalex, i_picscaley, i_piccropl, i_piccropt, i_piccropr, i_piccropb
} ;

// TODO join with rtfwrit.cpp

// Most control-word output is done with the following printf formats
static const CHAR * rgszCtrlWordFormat[] =
{
	"\\%s", "\\%s%d", "{\\%s", "{\\*\\%s"
};

static const WORD IndexROT[] =
{
	i_wbitmap,
	i_wmetafile,
	i_dibitmap,
	i_objemb,
	i_objlink,
	i_objautlink
};


TFI *CRTFConverter::_rgtfi = NULL;				// @cmember Ptr to 1st font substitute record
INT CRTFConverter::_ctfi = 0;				    // @cmember Count of font substitute records
TCHAR *CRTFConverter::_pchFontSubInfo = NULL;	// @cmember Font name info


// internal table to insert charset into _rgtfi under winNT
typedef		struct
{
	TCHAR*	szLocaleName;
	BYTE	bCharSet;
} NTCSENTRY;

const NTCSENTRY	mpszcs[] =
{
	{ TEXT("cyr"),		204 },		// all lower case so we don't have to waste time
	{ TEXT("ce"),		238 },		// doing a tolower below - Exchange2 800
	{ TEXT("greek"),	161 },
	{ NULL,				0 }			// sentinel
};

#define		cszcs	ARRAY_SIZE(mpszcs)


/* 
 *  Service  RemoveAdditionalSpace (sz)
 *
 *  Purpose: 
 *			 Remove first and last space from the string 
 *			 Only one space will remain between words
 *
 *	Argument 
 *			 sz characters string
 */
void RemoveAdditionalSpace(TCHAR *sz)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "RemoveAdditionalSpace");

	TCHAR *szSource = sz;
	TCHAR *szDestination = sz;

	while(*szSource == TEXT(' ') || *szSource == TAB)
	{
		*szSource++;
	}

	while(*szSource)
	{	 
		if(*szSource != TEXT(' ') && *szSource != TAB)
		{
			*szDestination++ = *szSource++;
		}
		else
		{
			*szDestination++ = TEXT(' ');
			szSource++;

			while(*szSource == TEXT(' ') || *szSource == TAB)
			{
				*szSource++;
			}
	 	}
	}
	*szDestination = TEXT('\0');
}

/*
 *	CRTFConverter::FreeFontSubInfo(void)
 * 
 *	@mfunc	release any allocated memory for font substitutions
 *
 *	@rdesc	void
 */
void CRTFConverter::FreeFontSubInfo()
{
	FreePv(_pchFontSubInfo);
	FreePv(_rgtfi);
	_pchFontSubInfo = NULL;
	_rgtfi = NULL;
}

/*
 *		CRTFConverter::ReadFontSubInfo(void)
 *
 *		Purpose:				  
 *			Read the table of Font Substitutes and parse out the tagged fonts
 *
 *		Returns:
 *			BOOL  TRUE	if OK		
 */
void CRTFConverter::ReadFontSubInfo()
{
#ifndef NOFONTSUBINFO 
	CLock clock;
	int cchBuffer = 600;	// Approximately the amount used by NT

	int cch;
	static const TCHAR szFontSubSection[] = TEXT("FontSubstitutes");
	TCHAR *pchTMax;

	if(_ctfi)
		return;

	AssertSz(!_rgtfi, "CRTFConverter::ReadFontSubInfo():  Who donated the rgtfi?");

	_pchFontSubInfo = (TCHAR *)PvAlloc(cchBuffer * sizeof(TCHAR), GMEM_FIXED);
	if(!_pchFontSubInfo)
	{
		goto Cleanup;
	}

next_try:
	cch = GetProfileSection(szFontSubSection, _pchFontSubInfo, cchBuffer);
	if(cch >= cchBuffer - 2)	// GetProfileSection() magic number 2
	{							
		// didn't fit, double the buffer size
		const INT cchT = cchBuffer * 2;

		if(cchT < cchBuffer)	// >32k 
		{
			goto Cleanup;
		}
		cchBuffer = cchT;
		_pchFontSubInfo = (TCHAR *)PvReAlloc(_pchFontSubInfo, cchT * sizeof(TCHAR));
		if(!_pchFontSubInfo)
		{
			goto Cleanup;
		}
		goto next_try;
	}
	else if(!cch)
	{
		*_pchFontSubInfo = 0;
	}
	else //Fits, now resize _pchFontSubInfo
	{
		_pchFontSubInfo = (WCHAR*) PvReAlloc(_pchFontSubInfo, (cch) * sizeof(WCHAR));
	}

	_ctfi = 12;		// a preliminary guess

	_rgtfi = (TFI *)PvAlloc(_ctfi * sizeof(TFI), GMEM_FIXED);
	if(!_rgtfi)
	{
		goto Cleanup;
	}

	TFI *ptfi;
	TCHAR *pchT;

	pchT = _pchFontSubInfo;
	pchTMax = _pchFontSubInfo + cch;
	ptfi = &_rgtfi[0];

	TCHAR *szTaggedName;
	TCHAR *szNonTaggedName;
	BOOL fGotTaggedCharSet;
	BOOL fGotNonTaggedCharSet;
	BYTE bTaggedCharSet;
	BYTE bNonTaggedCharSet;
	PARSEFONTNAME iParseLeft;
	PARSEFONTNAME iParseRight;

	// parse the entries
	// we are interested in the following strings:
	//
	// <tagged font name> = <nontagged font name>
	//		(where <nontagged font name> = <tagged font name> - <tag>
	// <font1 name>,<font1 charset> = <font2 name>
	// <tagged font name> = <nontagged font name>,<nontagged font charset>
	//		(where <nontagged font charset> = <tag>)
	// <font1 name>,<font1 charset> = <font2 name>,<font2 charset>
	//		(where <font1 charset> == <font2 charset>)

	iParseLeft = iParseRight = PFN_SUCCESS;

	while(pchT < pchTMax && iParseLeft != PFN_EOF
						&& iParseRight != PFN_EOF)
	{
		fGotTaggedCharSet = FALSE;
		fGotNonTaggedCharSet = FALSE;

		if((iParseLeft = ParseFontName(pchT,
						pchTMax,
						TEXT('='),
						&szTaggedName, 
						bTaggedCharSet, 
						fGotTaggedCharSet, 
						&pchT)) == PFN_SUCCESS &&
			(iParseRight = ParseFontName(pchT, 
						pchTMax,
						TEXT('\0'),
						&szNonTaggedName, 
						bNonTaggedCharSet, 
						fGotNonTaggedCharSet, 
						&pchT)) == PFN_SUCCESS)
		{
			Assert(szTaggedName && szNonTaggedName);

			BYTE bCharSet;

			if(!fGotTaggedCharSet)
			{
				if(!FontSubstitute(szTaggedName, szNonTaggedName, &bCharSet))
				{
					continue;
				}
			}
			else
			{
				bCharSet = bTaggedCharSet;
			}

			if(fGotNonTaggedCharSet && bCharSet != bNonTaggedCharSet)
			{
				continue;
			}
					
			// We have a legitimate tagged/nontagged pair, so save it.
			ptfi->szTaggedName = szTaggedName;
			ptfi->szNormalName = szNonTaggedName;
			ptfi->bCharSet = bCharSet;

			ptfi++;

    		if(DiffPtrs(ptfi, &_rgtfi[0]) >= (UINT)_ctfi)
			{
				// allocate some more
				_rgtfi = (TFI *)PvReAlloc(_rgtfi, (_ctfi + cszcs) * sizeof(TFI));
				if(!_rgtfi)
				{
					goto Cleanup;
				}
				ptfi = _rgtfi + _ctfi;
				_ctfi += cszcs;	
			}
		}
	}				
	
	_ctfi = DiffPtrs(ptfi, &_rgtfi[0]);

	if (!_ctfi)
	{
		goto Cleanup;  // to cleanup alloc'd memory
	}
	return;

Cleanup:
	if(_pchFontSubInfo)
	{
		FreePv(_pchFontSubInfo);
		_pchFontSubInfo = NULL;
	}
	if(_rgtfi)
	{
		FreePv(_rgtfi);
		_rgtfi = NULL;
	}
	_ctfi = 0;
	return;
#endif // NOFONTSUBINFO
}


/*
 *		CRTFConverter::ParseFontName(pchBuf, pchBufMax, pszName, bCharSet, fSetCharSet, ppchBufNew, chDelimiter)
 *
 *		Purpose:
 *			Parses from the input buffer, pchBuf, a string of the form:
 *				{WS}*<font_name>{WS}*[,{WS}*<char_set>{WS}*]
 *			and sets:
 *				pszName = <font_name>
 *				bCharSet = <char_set>
 *				fSetCharSet = (bCharSet set by proc) ? TRUE : FALSE
 *				ppchBufNew = pointer to point in pchBuf after parsed font name
 *
 *		Returns:
 *			BOOL  TRUE	if OK		
 */
CRTFConverter::PARSEFONTNAME CRTFConverter::ParseFontName(TCHAR *pchBuf,	//@parm IN: buffer
								TCHAR *pchBufMax,	//@parm IN: last char in buffer
								TCHAR chDelimiter,	//@parm IN:	char which delimits font name
								TCHAR **pszName,	//@parm OUT: parsed font name
								BYTE &bCharSet,		//@parm OUT: parsed char set
								BOOL &fSetCharSet,	//@parm OUT: char set parsed?
								TCHAR **ppchBufNew	//@parm OUT: ptr to next font name in input buffer
								) const
{
	PARSEFONTNAME iRet = PFN_SUCCESS;

	Assert(pchBuf);
	Assert(pchBufMax);
	Assert(pchBufMax >= pchBuf);
	Assert(pszName);
	Assert(ppchBufNew);

	fSetCharSet = FALSE;
	*pszName = pchBuf;
	
	if(pchBuf > pchBufMax)
	{
		return PFN_EOF;
	}

	while(*pchBuf && *pchBuf != TEXT(',') && *pchBuf != chDelimiter)
	{
		pchBuf++;

		if(pchBuf > pchBufMax)
		{
			return PFN_EOF;
		}
	}

	TCHAR chTemp = *pchBuf;
	*pchBuf = TEXT('\0');
	RemoveAdditionalSpace(*pszName);

	if(chTemp == TEXT(','))
	{
		TCHAR *szCharSet = ++pchBuf;

		while(*pchBuf && *pchBuf != chDelimiter)
		{
			pchBuf++;

			if(pchBuf > pchBufMax)
			{
				return PFN_EOF;
			}
		}

		chTemp = *pchBuf;

		if(chTemp != chDelimiter)
		{
			goto UnexpectedChar;
		}

		*pchBuf = TEXT('\0');
		RemoveAdditionalSpace(szCharSet);

		bCharSet = 0;
		while(*szCharSet >= TEXT('0') && *szCharSet <= TEXT('9'))
		{
			bCharSet *= 10;
			bCharSet += *szCharSet++ - TEXT('0');
		}

		fSetCharSet = TRUE;
		// iRet = PFN_SUCCESS;	(done above)
	}
	else if(chTemp == chDelimiter)
	{
		// fSetCharSet = FALSE;	(done above)
		// iRet = PFN_SUCCESS;	(done above)
	}
	else // chTemp == 0
	{
UnexpectedChar:
		Assert(!chTemp);
		// fSetCharSet = FALSE; (done above)
		iRet = PFN_FAIL;
	}

	// we had to at least get a font name out of this
	if(!**pszName)
	{
		iRet = PFN_FAIL;
	}

	// advance past the delimiter (or NULL char if malformed buffer)
	Assert(chTemp == chDelimiter || iRet != PFN_SUCCESS && chTemp == TEXT('\0'));
	pchBuf++;
	*ppchBufNew = pchBuf;

	return iRet;
}


/*
 *		CRTFConverter::FontSubstitute(szTaggedName, szNormalName, pbCharSet)
 *
 *		Purpose:
 *			Verify that szTaggedName is szNormalName plus char set tag 
 *			If yes than write corresponding charSet tp pbCharSet
 *
 * 		Arguments:														 
 *			szTaggedName    name with tag
 *			szNormalName	name without tag
 *			pbcharSEt		where to write char set
 *
 *		Returns:
 *			BOOL			
 */
BOOL CRTFConverter::FontSubstitute(TCHAR *szTaggedName, TCHAR *szNormalName, BYTE *pbCharSet)
{
	const NTCSENTRY *pszcs = mpszcs;

	Assert(szTaggedName);
	Assert(szNormalName);
	Assert(pbCharSet);
	Assert(*szTaggedName);
	// ensure same name, except for prefix

	while(*szNormalName == *szTaggedName)
	{
		*szNormalName++;
		*szTaggedName++;
	}
	
	// verify that we have reached the end of szNormalName
	while(*szNormalName)
	{
		if(*szNormalName != TEXT(' ') && *szNormalName != TAB)
		{
			return FALSE;
		}

		szNormalName++;
	}

	szTaggedName++;

	while(pszcs->bCharSet)
	{
		if(!lstrcmpi(szTaggedName, pszcs->szLocaleName))
		{ 
			*pbCharSet=pszcs->bCharSet;
			return TRUE;
		}
		pszcs++;
	}

#if defined(DEBUG) && !defined(PEGASUS)
	char szBuf[MAX_PATH];
    char szTag[256];
	
	WideCharToMultiByte(CP_ACP, 0, szTaggedName, -1, szTag, sizeof(szTag), 
							NULL, NULL);

	sprintf(szBuf, "CRTFConverter::FontSubstitute():  Unrecognized tag found at"
					" end of tagged font name - \"%s\" (Raid this asap)", szTag);
	
	TRACEWARNSZ(szBuf);
#endif

	return FALSE;
}


/*
 *	CRTFConverter::FindTaggedFont(const char *szNormalName, BYTE bCharSet, char **ppchTaggedName)
 *
 *	Purpose:												   
 *		Find font name may be with additional special tag corresponding to szNormalName & bCharSet
 *
 *	Arguments:
 *		szNormalName	font name in RTF
 *		bCharSet 		RTF char set
 *		ppchTaggedName 	where to write tagged name
 *
 *	Returns:
 *		BOOL			TRUE if find
 */
BOOL CRTFConverter::FindTaggedFont(const TCHAR *szNormalName, BYTE bCharSet, TCHAR **ppchTaggedName)
{
	int itfi;

	if(!_rgtfi)
		return FALSE;

	for(itfi = 0; itfi < _ctfi; itfi++)
	{
		if(_rgtfi[itfi].bCharSet == bCharSet &&
			!lstrcmpi(szNormalName, _rgtfi[itfi].szNormalName))
		{
			*ppchTaggedName = _rgtfi[itfi].szTaggedName;
			return TRUE;
		}
	}

	return FALSE;
}


/*
 *	CRTFConverter::IsTaggedFont(const char *szName, BYTE *pbCharSet, char **ppchNormalName)
 *
 *	Purpose:												   
 *		Figure out is szName font name with additional tag corresponding to pbCharSet
 *		If no charset specified, still try to match	 and return the correct charset
 *
 *	Arguments:
 *		szNormalName	font name in RTF
 *		bCharSet 		RTF char set
 *		ppchNormalName 	where to write normal name
 *
 *	Returns:
 *		BOOL			TRUE if is
 */
BOOL CRTFConverter::IsTaggedFont(const TCHAR *szName, BYTE *pbCharSet, TCHAR **ppchNormalName)
{
	int itfi;

	if(!_rgtfi)
		return FALSE;

	for(itfi = 0; itfi < _ctfi; itfi++)
	{
		if((*pbCharSet <= 1 || _rgtfi[itfi].bCharSet == *pbCharSet) &&
			!lstrcmpi(szName, _rgtfi[itfi].szTaggedName))
		{
			*pbCharSet = _rgtfi[itfi].bCharSet;
			*ppchNormalName = _rgtfi[itfi].szNormalName;
			return TRUE;
		}
	}
	return FALSE;
}


/*
 *	CRTFWrite::WriteData(pbBuffer, cbBuffer)
 *
 *	Purpose:
 *		Write out object data. This must be called only after all
 *		initial object header information has been written out.
 *
 *	Arguments:
 *		pbBuffer		pointer to write buffer
 *		cbBuffer		number of bytes to write out
 *
 *	Returns:
 *		LONG			number of bytes written out
 */
LONG CRTFWrite::WriteData(BYTE * pbBuffer, LONG cbBuffer)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteData");

	LONG	cb = 0;
	BYTE	bT;

	_fNeedDelimeter = FALSE; 
	while(cb < cbBuffer )
	{
		bT = *pbBuffer++;						// Put out hex value of byte
		PutChar(szHexDigits[bT >> 4]);			// Store high nibble
		PutChar(szHexDigits[bT & 15]);		// Store low nibble

		// Every 78 chars and at end of group, drop a line
		if (!(++cb % 39) || (cb == cbBuffer)) 
			Puts(szLineBreak, sizeof(szLineBreak) - 1);
	}
	return cb;
}

/*
 *	CRTFWrite::WriteBinData(pbBuffer, cbBuffer)
 *
 *	Purpose:
 *		Write out object binary data. This must be called only after all
 *		initial object header information has been written out.
 *
 *	Arguments:
 *		pbBuffer		pointer to write buffer
 *		cbBuffer		number of bytes to write out
 *
 *	Returns:
 *		LONG			number of bytes written out
 */
LONG CRTFWrite::WriteBinData(BYTE * pbBuffer, LONG cbBuffer)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteData");

	LONG	cb = 0;
	BYTE	bT;

	_fNeedDelimeter = FALSE; 
	while(cb < cbBuffer )
	{
		bT = *pbBuffer++;
		if (!PutChar(bT))
			break;
		cb++;
	}
	return cb;
}

/*
 *	CRTFWrite::WriteRtfObject(prtfObject, fPicture)
 *
 *	Purpose:
 *		Writes out an picture or object header's render information
 *
 *	Arguments:
 *		prtfObject		The object header information
 *		fPicture		Is this a header for a picture or an object
 *
 *	Returns:
 *		EC				The error code
 *
 *	Comments:
 *		Eventually use keywords from rtf input list rather than partially
 *		creating them on the fly
 */
EC CRTFWrite::WriteRtfObject(RTFOBJECT & rtfObject, BOOL fPicture)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteRtfObject");

	LONG			i;
	LONG *			pDim;
	const BYTE *	pKeyWordIndex;

	if(fPicture)
	{
		pKeyWordIndex = PictureKeyWordIndexes;
		pDim = &rtfObject.xExtPict;
	}
	else
	{
		pKeyWordIndex = ObjectKeyWordIndexes; 
		pDim = &rtfObject.xExt;

	}


	//Extents
	for(i = 2; i--; pDim++, pKeyWordIndex++)
	{
		if (*pDim )
			PutCtrlWord(CWF_VAL, *pKeyWordIndex, (SHORT)*pDim);
	}

	// Scaling
	pDim = &rtfObject.xScale;
	for(i = 2; i--; pDim++, pKeyWordIndex++)
	{
		if (*pDim && *pDim != 100 )
			PutCtrlWord(CWF_VAL, *pKeyWordIndex, (SHORT)*pDim);
	}
	// Cropping
	pDim = &rtfObject.rectCrop.left;
	for(i = 4; i--; pDim++, pKeyWordIndex++)
	{
		if (*pDim )
		   	PutCtrlWord(CWF_VAL, *pKeyWordIndex, (SHORT)*pDim);
	}

	return _ecParseError;
}

/*
 *	CRTFWrite::WritePicture(REOBJECT &reObject,RTFOBJECT & rtfObject)
 *
 *	Purpose:
 *		Writes out an picture's header as well as the object's data.
 *
 *	Arguments:
 *		reObject		Information from GetObject
 *		prtfObject		The object header information
 *
 *	Returns:
 *			EC			The error code
 *
 *	Note:
 *		*** Writes only metafiles ***
 */
EC CRTFWrite::WritePicture(REOBJECT &reObject,RTFOBJECT & rtfObject)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WritePicture");

	_ecParseError = ecStreamOutObj;

	// Start and write picture group
	PutCtrlWord( CWF_GRP, i_pict );

	// Write that this is metafile 
	PutCtrlWord( CWF_VAL, i_wmetafile, rtfObject.sPictureType );

	// Write picture render details
	WriteRtfObject( rtfObject, TRUE );

	// Write goal sizes
	if (rtfObject.xExtGoal )
		PutCtrlWord ( CWF_VAL, i_picwgoal, rtfObject.xExtGoal );

	if (rtfObject.yExtGoal )
		PutCtrlWord (CWF_VAL, i_pichgoal, rtfObject.yExtGoal);

	// Start picture data
	Puts( szLineBreak, sizeof(szLineBreak) - 1 );

	// Write out the data
	if ((UINT) WriteData( rtfObject.pbResult, rtfObject.cbResult ) != rtfObject.cbResult)
	{
	   goto CleanUp;
	}

	_ecParseError = ecNoError;

CleanUp:
	PutChar( chEndGroup );					// End picture data

	return _ecParseError;
}

/*
 *	CRTFWrite::WriteDib(REOBJECT &reObject,RTFOBJECT & rtfObject)
 *
 *	Purpose:
 *		Writes out an DIB primarily for Win CE
 *
 *	Arguments:
 *		reObject		Information from GetObject
 *		prtfObject		The object header information
 *
 *	Returns:
 *			EC			The error code
 *
 *	Note:
 *		*** Writes only dibs ***
 */
EC CRTFWrite::WriteDib(REOBJECT &reObject,RTFOBJECT & rtfObject)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WritePicture");

	LPBITMAPINFO pbmi = (LPBITMAPINFO) rtfObject.pbResult;

	_ecParseError = ecStreamOutObj;

// ************** V-GUYB: Add this for converting pictures to 2bpp during stream out.

    // Store the original values so we can restore them on exit.
	LPBYTE  pbResult = rtfObject.pbResult;
	ULONG   cbResult = rtfObject.cbResult;
    HGLOBAL hMem2bpp = 0;

#if defined(CONVERT2BPP) 

    // Pictures must be saved as 2bpp if saving to PWord V1 format.
	if((_dwFlags & SFF_PWD) && ((_dwFlags & SFF_RTFVAL) >> 16 == 0))
    {
        if(pbmi->bmiHeader.biBitCount > PWDV1_BPP)
        {
            HWND         hWnd;
            HDC          hdc, hdcSrc, hdcDst;
            HBITMAP      hdibSrc, hdibDst; 
            LPBYTE       pbDibSrc, pbDibDst;
            BMI2BPP      bmi2bpp = {0};
            int          iOffset, nBytes;

            // First get a dc with the source dib in it.
            hWnd   = GetDesktopWindow();
            hdc    = GetDC(hWnd);
	        hdcSrc = CreateCompatibleDC(hdc);

            // Using CreateDIBSection below ensures that the working dibs and dcs will get a
            // bpp of the appropriate dib, not a bpp based on the bpp of the device display.
            if((hdibSrc = CreateDIBSection(hdcSrc, pbmi, DIB_RGB_COLORS, (void**)&pbDibSrc, NULL, 0)))
            {
                SelectObject(hdcSrc, hdibSrc);

                // Get an offset to the source bits.
                iOffset = sizeof(BITMAPINFOHEADER) + (sizeof(RGBQUAD) * (1<<pbmi->bmiHeader.biBitCount));
                memcpy(pbDibSrc, &rtfObject.pbResult[iOffset], rtfObject.cbResult - iOffset);

                // Now, build up a BITMAPINFO appropriate for a 2bpp dib.
                bmi2bpp.bmih = pbmi->bmiHeader;
                bmi2bpp.bmih.biBitCount = PWDV1_BPP;

                // Add the 4 color color-table.
                memcpy(bmi2bpp.colors, (RGBQUAD*)ColorTable2bpp, (1<<PWDV1_BPP) * sizeof(RGBQUAD));

                // Now create the new dib.
    	        hdcDst = CreateCompatibleDC(hdc);

            	if((hdibDst = CreateDIBSection(hdcDst, (BITMAPINFO*)&bmi2bpp, DIB_RGB_COLORS, (void**)&pbDibDst, NULL, 0)))
                {
                    SelectObject(hdcDst, hdibDst);

                    // Blit the > 2bpp dib into the 2bpp dib and let the system do the color mapping.
                    BitBlt(hdcDst, 0, 0, bmi2bpp.bmih.biWidth, bmi2bpp.bmih.biHeight, hdcSrc, 0, 0, SRCCOPY);

                    // Calculate the new bytes per line for the 2bpp dib.
                    rtfObject.cBytesPerLine = (((bmi2bpp.bmih.biWidth * PWDV1_BPP) + 31) & ~31) / 8; // DWORD boundary.

                    // Get the new size of the 2bpp byte array.
                    nBytes = rtfObject.cBytesPerLine * bmi2bpp.bmih.biHeight;

                    // Get total size of 2bpp dib, (including header and 4 color color-table).
                    cbResult = sizeof(bmi2bpp) + nBytes;

                    // Don't change the input pbResult as that is the internal representation of 
                    // the dib. This conversion to 2bpp is only for writing to the output file.
                    if((hMem2bpp = GlobalAlloc(GMEM_FIXED, cbResult)))
                    {
                        if((pbResult = (LPBYTE)GlobalLock(hMem2bpp)))
                        {
                            // Copy in the dib header.
                            memcpy(pbResult, &bmi2bpp.bmih, sizeof(BITMAPINFOHEADER));

                            // Copy in the 4 color color-table.
                            memcpy(&pbResult[sizeof(BITMAPINFOHEADER)], (RGBQUAD*)ColorTable2bpp, (1<<PWDV1_BPP) * sizeof(RGBQUAD));

                            // Now copy in the byte array.
                            memcpy(&pbResult[sizeof(bmi2bpp)], pbDibDst, nBytes);

                    	    _ecParseError = ecNoError;
                        }
                    }

                    DeleteObject(hdibDst);
                }

                DeleteDC(hdcDst);

                DeleteObject(hdibSrc);
            }

            DeleteDC(hdcSrc);
            ReleaseDC(hWnd, hdc);

            if(_ecParseError != ecNoError)
            {
                goto CleanUp;
            }
        }
    }
#endif // CONVERT2BPP
// ************** V-GUYB: End of conversion stuff.

	// Start and write picture group
	PutCtrlWord( CWF_GRP, i_pict );

	// Write that this is dib 
	PutCtrlWord( CWF_VAL, i_dibitmap,rtfObject.sPictureType );

	// V-GUYB:
    // rtfObject.*Scale is not updated as the user stretches the picture, 
    // so don't use those here. But rtfObject.*Ext has been set up in the 
    // calling routine to account for the current site dimensions.
	PutCtrlWord( CWF_VAL, i_picscalex, (rtfObject.xExt * 100) /  rtfObject.xExtGoal);
	PutCtrlWord( CWF_VAL, i_picscaley, (rtfObject.yExt * 100) /  rtfObject.yExtGoal);

	// Write picture render details
	PutCtrlWord( CWF_VAL, i_picw, pbmi->bmiHeader.biWidth );
	PutCtrlWord( CWF_VAL, i_pich, pbmi->bmiHeader.biHeight );
	PutCtrlWord( CWF_VAL, i_picwgoal, rtfObject.xExtGoal );
	PutCtrlWord( CWF_VAL, i_pichgoal, rtfObject.yExtGoal );
	PutCtrlWord( CWF_VAL, i_wbmbitspixel, pbmi->bmiHeader.biBitCount );
	PutCtrlWord( CWF_VAL, i_wbmplanes, pbmi->bmiHeader.biPlanes );
	PutCtrlWord( CWF_VAL, i_wbmwidthbytes, rtfObject.cBytesPerLine );

	// Write out the data
	PutCtrlWord( CWF_VAL, i_bin, cbResult );
	if ((UINT) WriteBinData( pbResult, cbResult ) != cbResult)
	{
		// This "recovery" action needs to be rethought.  There is no way
		// the reader will be able to get back in synch.
	   goto CleanUp;
	}

	_ecParseError = ecNoError;

CleanUp:

    // Did we lock or allocate some temporary space for a 2bpp dib?
    if(rtfObject.pbResult != pbResult)
    {
        // Yes, so unlock it now.
        GlobalUnlock(pbResult);
    }

    if(hMem2bpp)
    {
        GlobalFree(hMem2bpp);
    }

    // Restore original values.
  	rtfObject.pbResult = pbResult;
    rtfObject.cbResult = cbResult;

	PutChar(chEndGroup);					// End picture data

	return _ecParseError;
}

/*
 *	CRTFWrite::WriteObject(LONG cp)
 *
 *	Purpose:
 *		Writes out an object's header as well as the object's data.
 *
 *	Arguments:
 *		cp				The object position
 *
 *	Returns:
 *		EC				The error code
 */
EC CRTFWrite::WriteObject(LONG cp, COleObject *pobj)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteObject");

	RTFOBJECT		rtfObject;
	REOBJECT        reObject = { 0} ;

	Assert(pobj);

	reObject.cbStruct = sizeof (REOBJECT) ;
	reObject.cp = cp;

	if (pobj->GetObjectData(&reObject, REO_GETOBJ_POLESITE 
						| REO_GETOBJ_PSTG | REO_GETOBJ_POLEOBJ))	// todo fix Release
	{
		TRACEERRORSZ("Error geting object ");
	}

	GetRtfObject(reObject, rtfObject);

	HGLOBAL hdata = pobj->GetHdata();
	if (hdata)
	{
		COleObject::ImageInfo *pimageinfo = pobj->GetImageInfo();
		rtfObject.pbResult = (LPBYTE) GlobalLock( hdata );
		rtfObject.cbResult = GlobalSize( hdata );
		rtfObject.sType = ROT_DIB;
		rtfObject.xExt = (SHORT) TwipsFromHimetric( reObject.sizel.cx );
		rtfObject.yExt = (SHORT) TwipsFromHimetric( reObject.sizel.cy );
		rtfObject.xScale = pimageinfo->xScale;
		rtfObject.yScale = pimageinfo->yScale;
		rtfObject.xExtGoal = pimageinfo->xExtGoal;
		rtfObject.yExtGoal = pimageinfo->yExtGoal;
		rtfObject.cBytesPerLine = pimageinfo->cBytesPerLine;
		WriteDib( reObject, rtfObject );
		GlobalUnlock( rtfObject.pbResult );

		// Make sure to release otherwise the object won't go away
		if (reObject.pstg)	reObject.pstg->Release();
		if (reObject.polesite) reObject.polesite->Release();
		if (reObject.poleobj) reObject.poleobj->Release();

		return _ecParseError;
	}

	switch(rtfObject.sType)				// Handle pictures in our own
	{										//  special way
	case ROT_Embedded:
	case ROT_Link:
	case ROT_AutoLink:
		break;

	case ROT_Metafile:
	case ROT_DIB:
	case ROT_Bitmap:
		 WritePicture( reObject, rtfObject );
		 goto CleanUpNoEndGroup; 

#ifdef DEBUG
	default:
		AssertSz(FALSE, "CRTFW::WriteObject: Unknown ROT");
		break;
#endif DEBUG
	}

	// Start and write object group
	PutCtrlWord( CWF_GRP, i_object );
	PutCtrlWord( CWF_STR, IndexROT[rtfObject.sType] );
//	PutCtrlWord(CWF_STR, i_objupdate);  // TODO may be it needs more smart decision 

	if (rtfObject.szClass)  		// Write object class
	{
		PutCtrlWord( CWF_AST, i_objclass ); 
		WritePcData( rtfObject.szClass );
		PutChar( chEndGroup );
	}

	if (rtfObject.szName)			// Write object name
	{
		PutCtrlWord( CWF_AST, i_objname ); 
		WritePcData( rtfObject.szName );
		PutChar( chEndGroup );
	}

	if (rtfObject.fSetSize)		// Write object sizing
	{								//  options
		PutCtrlWord( CWF_STR, i_objsetsize );
	}

	WriteRtfObject( rtfObject, FALSE ) ;				// Write object render info
	PutCtrlWord( CWF_AST, i_objdata ) ;				//  info, start object
	Puts( szLineBreak, sizeof(szLineBreak) - 1);		//  data group

	if (!ObjectWriteToEditstream( reObject, rtfObject ))
	{
		TRACEERRORSZ("Error writing object data");
		if (!_ecParseError)
			_ecParseError = ecStreamOutObj;
		PutChar( chEndGroup );						// End object data
		goto CleanUp;
	}

	PutChar( chEndGroup );							// End object data

	PutCtrlWord( CWF_GRP, i_result );				// Start results group
	WritePicture( reObject,rtfObject ); 				// Write results group
	PutChar( chEndGroup ); 							// End results group

CleanUp:
	PutChar( chEndGroup );						    // End object group

CleanUpNoEndGroup:
	if (reObject.pstg)	reObject.pstg->Release();
	if (reObject.polesite) reObject.polesite->Release();
	if (reObject.poleobj) reObject.poleobj->Release();
	if (rtfObject.pbResult)
	{
		HGLOBAL hmem;

		hmem = GlobalHandle( rtfObject.pbResult );
		GlobalUnlock( hmem );
		GlobalFree( hmem );
	}
	if (rtfObject.szClass)
	{
		CoTaskMemFree( rtfObject.szClass );
	}

	return _ecParseError;
}

/*
 *	GetRtfObjectMetafilePict
 *
 *	@mfunc
 *		Gets information about an metafile into a structure.
 *
 *		Arguments:
 *			HGLOBAL		The object data
 *			RTFOBJECT 	Where to put the information.
 *
 *	@rdesc
 *		BOOL		TRUE on success, FALSE if object cannot be written to RTF.
 */
BOOL CRTFWrite::GetRtfObjectMetafilePict(HGLOBAL hmfp, RTFOBJECT &rtfobject, SIZEL &sizelGoal)
{
#ifndef NOMETAFILES
	BOOL fSuccess = FALSE;
	LPMETAFILEPICT pmfp = (LPMETAFILEPICT)GlobalLock(hmfp);
	HGLOBAL	hmem = NULL;
	ULONG cb;

	if (!pmfp)
		goto Cleanup;

	// Build the header
	rtfobject.sPictureType = (SHORT) pmfp->mm;
	rtfobject.xExtPict = (SHORT) pmfp->xExt;
	rtfobject.yExtPict = (SHORT) pmfp->yExt;
	rtfobject.xExtGoal = (SHORT) TwipsFromHimetric(sizelGoal.cx);
	rtfobject.yExtGoal = (SHORT) TwipsFromHimetric(sizelGoal.cy);

	// Find out how much room we'll need
	cb = GetMetaFileBitsEx(pmfp->hMF, 0, NULL);
	if (!cb)
		goto Cleanup;

	// Allocate that space
    hmem = GlobalAlloc(GHND, cb);
	if (!hmem)
		goto Cleanup;

	rtfobject.pbResult = (LPBYTE)GlobalLock(hmem);
	if (!rtfobject.pbResult)
	{
		GlobalFree(hmem);
		goto Cleanup;
	}

	// Get the data
	rtfobject.cbResult = (ULONG) GetMetaFileBitsEx(pmfp->hMF, (UINT) cb,
													rtfobject.pbResult);
	if (rtfobject.cbResult != cb)
	{
		rtfobject.pbResult = NULL;
		GlobalFree(hmem);
		goto Cleanup;
	}
	fSuccess = TRUE;

Cleanup:
	GlobalUnlock(hmfp);
	return fSuccess;
#else
	return FALSE;
#endif
}

/*
 *	GetRtfObject (REOBJECT &reobject, RTFOBJECT &rtfobject)
 *
 *	Purpose:			   
 *		Gets information about an RTF object into a structure.
 *
 *	Arguments:
 *		REOBJECT  	Information from GetObject
 *		RTFOBJECT 	Where to put the information. Strings are read only and
 *					are owned by the object subsystem, not the caller.
 *
 *	Returns:
 *		BOOL		TRUE on success, FALSE if object cannot be written to RTF.
 */
BOOL CRTFWrite::GetRtfObject(REOBJECT &reobject, RTFOBJECT &rtfobject)
{
	BOOL fSuccess = FALSE;
	BOOL fNoOleServer = FALSE;
	const BOOL fStatic = !!(reobject.dwFlags & REO_STATIC);
	SIZEL sizelObj = reobject.sizel;
	//COMPATIBILITY:  RICHED10 code had a frame size.  Do we need something similiar.
	LPTSTR szProgId;

	// Blank out the full structure
	ZeroMemory(&rtfobject, sizeof(RTFOBJECT));

	// If the object has no storage it cannot be written.
	if (!reobject.pstg)
		return FALSE;

	// If we don't have the progID for a real OLE object, get it now
	if (!fStatic )
	{
		rtfobject.szClass = NULL;
		// We need a ProgID to put into the RTF stream.
		//$ REVIEW: MAC This call is incorrect for the Mac.  It may not matter though
		//          if ole support in RichEdit is not needed for the Mac.
		if (ProgIDFromCLSID(reobject.clsid, &szProgId))
			fNoOleServer = TRUE;
		else
			rtfobject.szClass = szProgId;
	}

#ifndef NOMETAFILES
	HGLOBAL hmfp = OleStdGetMetafilePictFromOleObject(reobject.poleobj,
										reobject.dvaspect, &sizelObj, NULL);
	if (hmfp)
	{
		LPMETAFILEPICT pmfp = NULL;

		fSuccess = GetRtfObjectMetafilePict(hmfp, rtfobject, sizelObj);
		if (pmfp = (LPMETAFILEPICT)GlobalLock(hmfp))
		{
			if (pmfp->hMF)
				DeleteMetaFile(pmfp->hMF);
			GlobalUnlock(hmfp);
		}
		GlobalFree(hmfp);

		// If we don't have Server and we can't get metafile, forget it.
		if (!fSuccess && fNoOleServer)
			return fSuccess;
	}
#endif

	if (!fStatic)
	{
		// Fill in specific fields
		rtfobject.sType = fNoOleServer ? ROT_Metafile : ROT_Embedded;	//$ FUTURE: set for links
		rtfobject.xExt = (SHORT) TwipsFromHimetric(sizelObj.cx);
		rtfobject.yExt = (SHORT) TwipsFromHimetric(sizelObj.cy);

		// fSuccess set even if we couldn't retreive a metafile
		// because we don't need a metafile in the non-static case,
		// it's just nice to have one
		fSuccess = TRUE;
	}
	rtfobject.fSetSize = 0;			//$ REVIEW: Hmmm
	return fSuccess;
}

/*
 *	ObjectWriteToEditstream
 *
 *	Purpose:
 *		Writes an OLE object data to the RTF output stream.
 *
 *	Arguments:
 *		REOBJECT	Information from GetObject
 *		RTFOBJECT 	Where to get icon data.
 *
 *	Returns:
 *		BOOL		TRUE on success, FALSE on failure.
 */
BOOL CRTFWrite::ObjectWriteToEditstream(REOBJECT &reObject, RTFOBJECT &rtfobject)
{
	HRESULT hr = 0;

	// Force the object to update its storage				  //// ????
	// Not necessary.  Already done in WriteRtf
	// reObject.polesite->SaveObject();

	// If the object is iconic we do some special magic
	if (reObject.dvaspect == DVASPECT_ICON)
	{
		HANDLE	hGlobal;
		STGMEDIUM med;

		// Force the presentation to be the iconic view.
		med.tymed = TYMED_HGLOBAL;
		hGlobal = GlobalHandle(rtfobject.pbResult);
		med.hGlobal = hGlobal;
		hr = OleConvertIStorageToOLESTREAMEx(reObject.pstg,
											CF_METAFILEPICT,
											rtfobject.xExtPict,
											rtfobject.yExtPict,
											rtfobject.cbResult, &med,
											(LPOLESTREAM) &RTFWriteOLEStream);
	}
	else
	{
		// Do the standard conversion
		hr = OleConvertIStorageToOLESTREAM(reObject.pstg, (LPOLESTREAM) &RTFWriteOLEStream);
	}
	return SUCCEEDED(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\rtfread2.cpp ===
/*
 *	rtfread2.cpp
 *
 *	Description:
 *		This file contains the object functions for RichEdit RTF reader
 *
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	* NOTE:
 *	*	All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *	*	noted as a szW.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

#include "_rtfread.h"
#include "_coleobj.h"
//#include "_nlsprcs.h"

const char szFontsel[]="\\f";

ASSERTDATA


/*
 *	CRTFRead::HandleFieldInstruction()
 *
 *	@mfunc
 *		Handle field instruction
 *
 *	@rdesc
 *		EC		The error code
 */
EC CRTFRead::HandleFieldInstruction()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleFieldInstruction");

//TODO rewrite this function for common case
//FUTURE save field instruction

	BYTE *pch, *pch1;

	for(pch1 = _szText; *pch1 == ' '; pch1++)	// Bypass any leading blanks
		;
	for(pch = pch1; *pch && *pch != ' '; pch++)
		;

	_fHyperlinkField = FALSE;
	if(W32->ASCIICompareI(pch1, (BYTE *) "SYMBOL", 6))
		HandleFieldSymbolInstruction(pch);	//  SYMBOL

	else if (W32->ASCIICompareI(pch1, (BYTE *) "HYPERLINK", 9))
	{
		_fHyperlinkField = TRUE;
		HandleFieldHyperlink(pch);
	}
	// save the current formatting for the field result
	_FieldCF = _CF;
	_ptfField = _pstateStackTop->ptf;
	_nFieldCodePage = _pstateStackTop->nCodePage;
	_dwMaskFieldCF = _dwMaskCF;
	_dwMaskFieldCF2 = _dwMaskCF2;


	TRACEERRSZSC("HandleFieldInstruction()", - _ecParseError);
	return _ecParseError;
}

/*
 *	CRTFRead::HandleFieldSymbolInstruction(pch)
 *
 *	@mfunc
 *		Handle specific  symbol field
 *
 *	@rdesc
 *		EC	The error code
 *
 *	@devnote 
 *		FUTURE: the two whiles below can be combined into one fairly easily;
 *		Look at the definitions of IsXDigit() and IsDigit() and introduce
 *		a variable flag as well as a variable base multiplier (= 10 or 16).
 */
EC CRTFRead::HandleFieldSymbolInstruction(
	BYTE *pch )		//@parm Pointer to SYMBOL field instruction
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleFieldInstruction");

	BYTE	ch;
	BYTE	chSymbol = 0;
	const char *pchFontsel = szFontsel;

	while (*pch == ' ')						// Eat spaces
		++pch;
											// Collect symbol char's code 
	if (*pch == '0' &&						//  which may be in decimal
 		(*++pch | ' ') == 'x')				//  or hex
	{										// It's in hex
		ch = *++pch;
	   	while (ch && IsXDigit(ch))
	   	{
			chSymbol <<= 4;
			chSymbol += (ch <= '9') ? ch - '0' : (ch & 0x4f) - 'A' + 10;
			ch = *pch++;
	   	}
	}
	else									// Decimal
	{
	   ch = *pch;
	   while (ch && IsDigit(ch))
	   {
			chSymbol *= 10;
			chSymbol += ch - '0' ;
			ch = *++pch;
	   }
	}
	_szSymbolFieldResult = (BYTE *)PvAlloc(2, GMEM_ZEROINIT);

	if (NULL == _szSymbolFieldResult)
	{
	 	_ecParseError = ecNoMemory;
		goto CleanUp;
	}

	_szSymbolFieldResult[0] = chSymbol;

	// now check for the \\f "Facename" construct 
	// and deal with it

	while (*pch == ' ')						// Eat spaces
		++pch;

	while (*pch && *pch == *pchFontsel)		// Make sure *pch is a \f
	{										
		++pch;
		++pchFontsel;
	}
	if	(! (*pchFontsel) )
	{
		_ecParseError = HandleFieldSymbolFont(pch);	//  \\f "Facename"
	}

// ASSERTION   font & font size  will be in field result \flds
// BUGBUG: A more robust implementation would parse the font
// and font size from both \fldinst and \fldrslt (RE1.0 does this)
	
CleanUp:
	TRACEERRSZSC("HandleFieldInstruction()", - _ecParseError);
	return _ecParseError;
}

/*
 *	CRTFRead::HandleFieldSymbolFont(pch)
 *
 *	@mfunc
 *		Handle the \\f "Facename" instruction in the SYMBOL field
 *
 *	@rdesc
 *		EC	The error code
 *
 *	@devnote WARNING: may change _szText
 */
EC CRTFRead::HandleFieldSymbolFont(
	BYTE *pch)		//@parm Ptr to symbol field
{
	SHORT iFont = _fonts.Count();
	TEXTFONT tf;
	TEXTFONT *ptf = &tf;

	_pstateStackTop->ptf = &tf;
	// ReadFontName tries to append
	tf.szName[0] = '\0';

	// skip the initial blanks and quotes
	while (*pch && (*pch == ' ' || *pch == '\"'))
		++pch;

	// DONT WORRY, we'll get it back to normal
	// ReadFontName depends on _szText, so we need to alter it and then restore
	// it's just too bad we have to do it ...
	BYTE* szTextBAK = _szText;
	BOOL fAllAscii = TRUE;

	_szText = pch;

	// transform the trailing quote into ';'
	while (*pch)
	{
		if (*pch == '\"')
		{
			*pch = ';';
			break;
		}

		if(*pch > 0x7f)
			fAllAscii = FALSE;

		++pch;
	}

	// NOW we can read the font name!!
	ReadFontName(_pstateStackTop, fAllAscii ? ALL_ASCII : CONTAINS_NONASCII);

	// Try to find this face name in the font table
	BOOL fFontFound = FALSE;
	for (SHORT i = 0; i < iFont; ++i)
	{
		TEXTFONT *ptfTab = _fonts.Elem(i);
		if (0 == wcscmp(ptf->szName, ptfTab->szName))
		{
			fFontFound = TRUE;
			i = ptfTab->sHandle;
			break;
		}
	}

	// did we find the face name?
	if (!fFontFound)
	{
		Assert(i == iFont);
		i+= RESERVED_FONT_HANDLES;

		// Make room in font table for
		//  font to be inserted
		if (!(ptf =_fonts.Add(1,NULL)))
		{									
			_ped->GetCallMgr()->SetOutOfMemory();
			_ecParseError = ecNoMemory;
			goto exit;
		}

		// repeating inits from tokenFontSelect
		ptf->sHandle	= i;				// Save handle
		wcscpy(ptf->szName, tf.szName); 
		ptf->bPitchAndFamily = 0;
		ptf->fNameIsDBCS = FALSE;
		ptf->sCodePage = (SHORT)_nCodePage;
		ptf->bCharSet = DEFAULT_CHARSET;	// SYMBOL_CHARSET ??
	}

	SelectCurrentFont(i);
	
exit:
	// needs to go back to normal
	_szText = szTextBAK;

	return _ecParseError;
}

/*
 *	CRTFRead::HandleFieldHyperlink(pch)
 *
 *	@mfunc
 *		Handle HYPERLINK field
 *
 *	@rdesc
 *		EC	The error code
 */
EC CRTFRead::HandleFieldHyperlink(
	BYTE *pch)		//@parm Pointer to HYPERLINK field instruction
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::HandleFieldHyperlink");

	BYTE *pBuffer;

	for( ; *pch == ' '; pch++) ;				// Skip leading blanks

	// allocate the buffer and add the string to it
	_cchHyperlinkFldinst = MAX_PATH;
	_cchHyperlinkFldinstUsed = 1;
	pBuffer = (BYTE *)PvAlloc( MAX_PATH, GMEM_FIXED );
	
	if ( !pBuffer )
		return ( _ecParseError = ecNoMemory );		 

	pBuffer[0] = ' ';
	pBuffer[1] = '\0';
	_szHyperlinkFldinst = pBuffer;
	
	if ( *pch )
	{	
		_ecParseError = AppendString( &_szHyperlinkFldinst, pch, &_cchHyperlinkFldinst, &_cchHyperlinkFldinstUsed );
	}

	return _ecParseError;
}

/*
 *	CRTFRead::ReadData(pbBuffer, cbBuffer)
 *
 *	@mfunc
 *		Read in object data. This must be called only after all initial
 *		object header info has been read.
 *
 *	@rdesc
 *		LONG	count of bytes read in
 */
LONG CRTFRead::ReadData(
	BYTE *	pbBuffer,	//@parm Ptr to buffer where to put data
	LONG	cbBuffer)	//@parm How many bytes to read in
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadData");

	BYTE bChar0, bChar1;
	LONG cbLeft = cbBuffer;

	while (cbLeft && (bChar0 = GetHexSkipCRLF()) < 16 && 
					 (bChar1 = GetHexSkipCRLF()) < 16 &&
					 _ecParseError == ecNoError)
	{	
		*pbBuffer++ = bChar0 << 4 | bChar1;
		cbLeft--;
	}							   
	return cbBuffer - cbLeft ; 
}

/*
 *	CRTFRead::ReadBinaryData(pbBuffer, cbBuffer)
 *
 *	@mfunc
 *		Read cbBuffer bytes into pbBuffer
 *
 *	@rdesc
 *		Count of bytes read in
 */
LONG CRTFRead::ReadBinaryData(
	BYTE *	pbBuffer,	//@parm Ptr to buffer where to put data
	LONG	cbBuffer)	//@parm How many bytes to read in
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::ReadBinaryData");

	LONG cbLeft = min(_cbBinLeft, cbBuffer);

	cbBuffer = cbLeft;

	for (; cbLeft > 0 && _ecParseError == ecNoError ; cbLeft--)
	{
		*pbBuffer++ = GetChar();
	}

	_cbBinLeft -= cbBuffer - cbLeft; 

	return cbBuffer - cbLeft ;
}

/*
 *	CRTFRead::SkipBinaryData(cbSkip)
 *
 *	@mfunc
 *		Skip cbSkip bytes in input streamd
 *
 *	@rdesc
 *		LONG	count of bytes skipped
 */
LONG CRTFRead::SkipBinaryData(
	LONG cbSkip)	//@parm Count of bytes to skip
{
	BYTE rgb[1024];

	_cbBinLeft = cbSkip;

	while(ReadBinaryData(rgb, sizeof(rgb)) > 0 && _ecParseError == ecNoError) 
		;
	return cbSkip;
}

/*
 *	CRTFRead::ReadRawText(pszRawText)
 *
 *	@mfunc
 *		Read in raw text until }.  A buffer is allocated to save the text.
 *		The caller is responsible to free the buffer later.
 *
 *	@rdesc
 *		LONG	count of bytes read
 */
LONG CRTFRead::ReadRawText(
	char	**pszRawText)	//@parm Address of the buffer containing the raw text
{
	LONG	cch=0;
	char	*szRawTextStart = NULL;
	char	*szRawText = NULL;
	char	chLast=0;
	char	ch;
	short	cRBrace=0;
	LONG	cchBuffer = 0;
	bool	fNeedBuffer = (pszRawText != NULL);

	if (fNeedBuffer)
	{
		*pszRawText = NULL;
		cchBuffer = 128;
		szRawText = szRawTextStart = (char *)PvAlloc(128, GMEM_ZEROINIT);

		if(!szRawTextStart)
		{
			_ecParseError = ecNoMemory;
			return 0;
		}
	}

	while (_ecParseError == ecNoError)
	{
		ch = GetChar();
		
		if (ch == 0)		
			break;			// error case

		if (ch == LF || ch == CR)
			continue;		// ignore noice characters

		if (ch == '}' && chLast != '\\')
		{
			if (!cRBrace)
			{
				// Done
				UngetChar();

				if (fNeedBuffer)
					*szRawText = '\0';

				break;
			}
			cRBrace--;	// count the RBrace so we will ignore the matching pair of LBrace
		}

		if (ch == '{' && chLast != '\\')
			cRBrace++;

		chLast = ch;
		cch++;

		if (fNeedBuffer)
		{
			*szRawText = ch;
			
			if (cch == cchBuffer)
			{
				// Re-alloc a bigger buffer
				char *pNewBuff = (char *)PvReAlloc(szRawTextStart, cchBuffer + 64);
				
				if (!pNewBuff)
				{				
					_ecParseError = ecNoMemory;
					break;
				}
				
				cchBuffer += 64;
				szRawTextStart = pNewBuff;
				szRawText = szRawTextStart + cch;
			}
			else
				szRawText++;
		}
	}
	
	if (fNeedBuffer)
	{
		if (_ecParseError == ecNoError)
			*pszRawText = szRawTextStart;
		else
			FreePv(szRawTextStart);
	}
	return cch;
}

/*
 *	CRTFRead::StrAlloc(ppsz, sz)
 *
 *	@mfunc
 *		Set up a pointer to a newly allocated space to hold a string
 *
 *	@rdesc
 *		EC		The error code
 */
EC CRTFRead::StrAlloc(
	TCHAR ** ppsz,	//@parm Ptr to ptr to string that needs allocation
	BYTE *	 sz)	//@parm String to be copied into allocated space
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::StrAlloc");

	int Length =  strlen((CHAR *)sz)+1 ;

	*ppsz = (TCHAR *) PvAlloc((Length + 1)*sizeof(TCHAR), GMEM_ZEROINIT);
	if (!*ppsz)
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		_ecParseError = ecNoMemory;
		goto Quit;
	}
	MultiByteToWideChar(CP_ACP,0,(char *)sz,-1,*ppsz,Length) ;

Quit:
	return _ecParseError;
}

/*
 *	CRTFRead::FreeRtfObject()
 *
 *	@mfunc
 *		Cleans up memory used by prtfobject
 */
void CRTFRead::FreeRtfObject()
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CRTFRead::FreeRtfObject");

	if (_prtfObject)
	{
		FreePv(_prtfObject->szClass);
		FreePv(_prtfObject->szName);
		FreePv(_prtfObject);
		_prtfObject = NULL;
	}
}

/*
 *	CRTFRead::ObjectReadSiteFlags(preobj)
 *
 *	@mfunc
 *		Read dwFlags and dwUser bytes from a container specific stream
 *
 *	@rdesc
 *		BOOL	TRUE if successfully read the bytes
 */
BOOL CRTFRead::ObjectReadSiteFlags(
	REOBJECT * preobj)	//@parm REOBJ from where to copy flags. This preobj is
						//		then later put out in a site
{
	return (::ObjectReadSiteFlags(preobj) == NOERROR);
}

/*
 *	CRTFRead::ObjectReadFromStream()
 *
 *	@mfunc
 *		Reads an OLE object from the RTF output stream.
 *
 *	@rdesc
 *		BOOL		TRUE on success, FALSE on failure.
 */
BOOL CRTFRead::ObjectReadFromEditStream()
{
	WCHAR			ch = WCH_EMBEDDING;
	BOOL			fRet = FALSE;
	HRESULT			hr;
	CObjectMgr *	pObjectMgr = _ped->GetObjectMgr();
	LPOLECACHE		polecache = NULL;
	LPRICHEDITOLECALLBACK  precall=NULL;
	LPENUMSTATDATA	penumstatdata = NULL;
	REOBJECT		reobj = { 0 };
	STATDATA		statdata;

	if(!pObjectMgr)
	   goto Cleanup;
	
	precall = pObjectMgr->GetRECallback();

	// If no IRichEditOleCallback exists, then fail
	if (!precall)
		goto Cleanup;

//	AssertSz(_prtfObject->szClass,"ObFReadFromEditstream: reading unknown class");

	if (_prtfObject->szClass) 
		CLSIDFromProgID(_prtfObject->szClass, &reobj.clsid);

	// Get storage for the object from the application
	if (precall->GetNewStorage(&reobj.pstg))
		goto Cleanup;

	hr = OleConvertOLESTREAMToIStorage((LPOLESTREAM) &RTFReadOLEStream, reobj.pstg, NULL);
	if (FAILED(hr))					   
		goto Cleanup;		  

	// Create another object site for the new object
	_ped->GetClientSite(&reobj.polesite) ;
	if (!reobj.polesite ||
		OleLoad(reobj.pstg, IID_IOleObject, reobj.polesite,
				 (LPVOID *) &reobj.poleobj))
	{
		goto Cleanup;
	}

	CLSID	clsid;

	// Get the actual clsid from the object
	if (reobj.poleobj->GetUserClassID(&clsid) == NOERROR)
		reobj.clsid = clsid;
	
	reobj.cbStruct = sizeof(REOBJECT);
	reobj.cp = _prg->GetCp();
	reobj.sizel.cx = HimetricFromTwips(_prtfObject->xExt)
						* _prtfObject->xScale / 100;
	reobj.sizel.cy = HimetricFromTwips(_prtfObject->yExt)
						* _prtfObject->yScale / 100;

	// Read any container flags which may have been previously saved
	if (!ObjectReadSiteFlags(&reobj))
		reobj.dwFlags = REO_RESIZABLE;		// If no flags, make best guess	

	reobj.dvaspect = DVASPECT_CONTENT;		// OLE 1 forces DVASPECT_CONTENT

	// Ask the cache if it knows what to display
	if (!reobj.poleobj->QueryInterface(IID_IOleCache, (void**)&polecache) &&
		!polecache->EnumCache(&penumstatdata))
	{
		// Go look for the best cached presentation CF_METAFILEPICT
		while (penumstatdata->Next(1, &statdata, NULL) == S_OK)
		{
			if (statdata.formatetc.cfFormat == CF_METAFILEPICT)
			{
				LPDATAOBJECT pdataobj = NULL;
				STGMEDIUM med;
				BOOL fUpdate;

				ZeroMemory(&med, sizeof(STGMEDIUM));
                if (!polecache->QueryInterface(IID_IDataObject, (void**)&pdataobj) &&
					!pdataobj->GetData(&statdata.formatetc, &med))
                {
					HANDLE	hGlobal = med.hGlobal;

					if( FIsIconMetafilePict(hGlobal) )
				    {
					    OleStdSwitchDisplayAspect(reobj.poleobj, &reobj.dvaspect,
							DVASPECT_ICON, med.hGlobal, TRUE, FALSE, NULL, &fUpdate);
				    }
				}
				ReleaseStgMedium(&med);
				if (pdataobj)
					pdataobj->Release();
				break;
			}
		}
		polecache->Release();
		penumstatdata->Release();
	}

	// EVIL HACK ALERT.  This code is borrowed from RichEdit1.0; Word generates
	// bogus objects, so we need to compensate.

	if( reobj.dvaspect == DVASPECT_CONTENT )
	{
		IStream *pstm = NULL;
		BYTE bT;
		BOOL fUpdate;

		if (!reobj.pstg->OpenStream(OLESTR("\3ObjInfo"), 0, STGM_READ |
									   STGM_SHARE_EXCLUSIVE, 0, &pstm) &&
		   !pstm->Read(&bT, sizeof(BYTE), NULL) &&
		   (bT & 0x40))
		{
		   _fNeedIcon = TRUE;
		   _fNeedPres = TRUE;
		   _pobj = (COleObject *)reobj.polesite;
		   OleStdSwitchDisplayAspect(reobj.poleobj, &reobj.dvaspect, DVASPECT_ICON,
									   NULL, TRUE, FALSE, NULL, &fUpdate);
		}
		if( pstm )
			pstm->Release();
   }

	// Since we are loading an object, it shouldn't be blank
	reobj.dwFlags &= ~REO_BLANK;

	_prg->Set_iCF(-1);	
	_prg->ReplaceRange(1, &ch, NULL, SELRR_IGNORE);  
	hr = pObjectMgr->InsertObject(reobj.cp, &reobj, NULL);
	if(hr)
		goto Cleanup;

	// EVIL HACK ALERT!!  Word doesn't give us objects with presenation
	// caches; as a result, we can't draw them!  In order to get around this,
	// we check to see if there is a presentation cache (via the same way
	// RE1.0 did) using a GetExtent call.  If that fails, we'll just use
	// the presentation stored in the RTF.  
	//
	// COMPATIBILITY ISSUE: RE1.0, instead of using the presenation stored
	// in RTF, would instead call IOleObject::Update.  There are two _big_
	// drawbacks to this approach: 1. it's incredibly expensive (potentially,
	// MANY SECONDS per object), and 2. it doesn't work if the object server
	// is not installed on the machine.

	SIZE sizeltemp;

	if( reobj.poleobj->GetExtent(reobj.dvaspect, &sizeltemp) != NOERROR )
	{
		_fNeedPres = TRUE;
		_pobj = (COleObject *)reobj.polesite;
	}

	fRet = TRUE;

Cleanup:
	if (reobj.pstg)		reobj.pstg->Release();
	if (reobj.polesite) reobj.polesite->Release();
	if (reobj.poleobj)	reobj.poleobj->Release();

	return fRet;
}

/*
 *	ObHBuildMetafilePict(prtfobject, hBits)
 *
 *	@func
 *		Build a METAFILEPICT from RTFOBJECT and the raw data.
 *
 *	@rdesc
 *		HGLOBAL		Handle to a METAFILEPICT
 */
HGLOBAL ObHBuildMetafilePict(
	RTFOBJECT *	prtfobject,	//@parm Details we picked up from RTF
	HGLOBAL 	hBits)		//@parm Handle to the raw data
{
#ifndef NOMETAFILES
	ULONG	cbBits;
	HGLOBAL	hmfp = NULL;
	LPBYTE	pbBits;
	LPMETAFILEPICT pmfp = NULL;
	SCODE	sc = E_OUTOFMEMORY;

	// Allocate the METAFILEPICT structure
    hmfp = GlobalAlloc(GHND, sizeof(METAFILEPICT));
	if (!hmfp)
		goto Cleanup;

	// Lock it down
	pmfp = (LPMETAFILEPICT) GlobalLock(hmfp);
	if (!pmfp)
		goto Cleanup;

	// Put in the header information
	pmfp->mm = prtfobject->sPictureType;
	pmfp->xExt = prtfobject->xExt;
	pmfp->yExt = prtfobject->yExt;

	// Set the metafile bits
	pbBits = (LPBYTE) GlobalLock(hBits);
	cbBits = GlobalSize(hBits);
	pmfp->hMF = SetMetaFileBitsEx(cbBits, pbBits);
	
	// We can throw away the data now since we don't need it anymore
	GlobalUnlock(hBits);
	GlobalFree(hBits);

	if (!pmfp->hMF)
		goto Cleanup;
	GlobalUnlock(hmfp);
	sc = S_OK;

Cleanup:
	if (sc && hmfp)
	{
		if (pmfp)
		{
		    if (pmfp->hMF)
		        ::DeleteMetaFile(pmfp->hMF);
			GlobalUnlock(hmfp);
		}
		GlobalFree(hmfp);
		hmfp = NULL;
	}
	TRACEERRSZSC("ObHBuildMetafilePict", sc);
	return hmfp;
#else
	return NULL;
#endif
}

/*
 *	ObHBuildBitmap(prtfobject, hBits)
 *
 *	@func
 *		Build a BITMAP from RTFOBJECT and the raw data
 *
 *	@rdesc
 *		HGLOBAL		Handle to a BITMAP
 */
HGLOBAL ObHBuildBitmap(
	RTFOBJECT *	prtfobject,	//@parm Details we picked up from RTF
	HGLOBAL 	hBits)		//@parm Handle to the raw data
{
	HBITMAP hbm = NULL;
	LPVOID	pvBits = GlobalLock(hBits);

	if(pvBits)
	{
		hbm = CreateBitmap(prtfobject->xExt, prtfobject->yExt,
						prtfobject->cColorPlanes, prtfobject->cBitsPerPixel,
						pvBits);
	}
	GlobalUnlock(hBits);
	GlobalFree(hBits);
	return hbm;
}

/*
 *	ObHBuildDib(prtfobject, hBits)
 *
 *	@func
 *		Build a DIB from RTFOBJECT and the raw data
 *
 *	@rdesc
 *		HGLOBAL		Handle to a DIB
 */
HGLOBAL ObHBuildDib(
	RTFOBJECT *	prtfobject,	//@parm Details we picked up from RTF
	HGLOBAL 	hBits)		//@parm Handle to the raw data
{
	// Apparently DIB's are just a binary dump
	return hBits;
}

/*
 *	CRTFRead::StaticObjectReadFromEditstream(cb)
 *
 *	@mfunc
 *		Reads a picture from the RTF output stream.
 *
 *	@rdesc
 *		BOOL		TRUE on success, FALSE on failure.
 */
#define cbBufferMax	16384
#define cbBufferStep 1024
#define cbBufferMin 1024

BOOL CRTFRead::StaticObjectReadFromEditStream(
	int cb)		//@parm Count of bytes to read
{
	LONG		cbBuffer;
	LONG		cbRead;
	WCHAR		ch = WCH_EMBEDDING;
	DWORD		dwAdvf;
	DWORD		dwConn;
	FORMATETC	formatetc;
	BOOL		fRet = FALSE;
	HGLOBAL		hBits = NULL;
	HRESULT		hr;
	CObjectMgr *pObjectMgr = _ped->GetObjectMgr();
	LPPERSISTSTORAGE pperstg = NULL;
	LPOLECACHE	polecache = NULL;
	REOBJECT	reobj = { 0 };
	LPBYTE		pbBuffer = NULL;
	LPSTREAM	pstm = NULL;
	STGMEDIUM	stgmedium;
	HGLOBAL (*pfnBuildPict)(RTFOBJECT *, HGLOBAL) = NULL;
	LPRICHEDITOLECALLBACK  precall ;

	if(!pObjectMgr)
	   goto Cleanup;
	
	// precall may end up being null (e.g. Windows CE).
	precall = pObjectMgr->GetRECallback();

	// Initialize various data structures
	formatetc.ptd = NULL;
	formatetc.dwAspect = DVASPECT_CONTENT;
	formatetc.lindex = -1;
	formatetc.tymed = TYMED_NULL;
	switch (_prtfObject->sType)
	{
	case ROT_Metafile:
		reobj.clsid = CLSID_StaticMetafile;
		formatetc.cfFormat = CF_METAFILEPICT;
		formatetc.tymed = TYMED_MFPICT;
		pfnBuildPict = ObHBuildMetafilePict;
		break;

	case ROT_Bitmap:
		reobj.clsid = CLSID_StaticDib;
		formatetc.cfFormat = CF_BITMAP;
		formatetc.tymed = TYMED_GDI;
		pfnBuildPict = ObHBuildBitmap;
		break;

	case ROT_DIB:
		reobj.clsid = CLSID_StaticDib;
		formatetc.cfFormat = CF_DIB;
		formatetc.tymed = TYMED_HGLOBAL;
		pfnBuildPict = ObHBuildDib;
		break;
	}

	reobj.sizel.cx = (LONG) HimetricFromTwips(_prtfObject->xExtGoal)
						* _prtfObject->xScale / 100;
	reobj.sizel.cy = (LONG) HimetricFromTwips(_prtfObject->yExtGoal)
						* _prtfObject->yScale / 100;
	stgmedium.tymed = formatetc.tymed;
	stgmedium.pUnkForRelease = NULL;

	if (precall)
	{
		if( !_fNeedPres )
		{
			// Get storage for the object from the application
			if (precall->GetNewStorage(&reobj.pstg))
				goto Cleanup;
		}
		// Let's create a stream on HGLOBAL
		if (hr = CreateStreamOnHGlobal(NULL, FALSE, &pstm))
			goto Cleanup;

		// Allocate a buffer, preferably a big one
		for (cbBuffer = cbBufferMax;
			 cbBuffer >= cbBufferMin;
			cbBuffer -= cbBufferStep)
		{
			pbBuffer = (unsigned char *)PvAlloc(cbBuffer, 0);
			if (pbBuffer)
				break;
		}
	}
	else
	{
		cbBuffer = cb;
		if (!cb)
		{
			// this means we didn't understand the picture type; so just
			// skip it without failing.
			fRet = TRUE;
			goto Cleanup;
		}
		hBits = GlobalAlloc(GMEM_FIXED, cb);
		pbBuffer = (BYTE *) GlobalLock(hBits);
	}
		
	if (!pbBuffer)
		goto Cleanup;
	
	// Copy the data from RTF into our HGLOBAL

	while ((cbRead = RTFReadOLEStream.lpstbl->Get(&RTFReadOLEStream,pbBuffer,cbBuffer)) > 0)
	{
		if (pstm && (hr = pstm->Write( pbBuffer, cbRead, NULL)))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: Write", GetScode(hr));
			goto Cleanup;
		}
	}

	if (hBits)
	{
		Assert(!precall);
		GlobalUnlock(hBits);
		pbBuffer = NULL;		// To avoid free below
	}

	if (pstm && (hr = GetHGlobalFromStream(pstm, &hBits)))
	{
		TRACEERRSZSC("ObFReadStaticFromEditstream: no hglobal from stm", GetScode(hr));
		goto Cleanup;
	}

	// Build the picture
	if( pfnBuildPict )
	{
		stgmedium.hGlobal = pfnBuildPict(_prtfObject, hBits);
	}
	else
	{
		// this means we didn't understand the picture type; so just
		// skip it without failing.
		fRet = TRUE;
		goto Cleanup;
	}

	if( precall && !stgmedium.hGlobal )
		goto Cleanup;

	if( precall )
	{
		if( !_fNeedPres )
		{
			// Create the default handler
			hr = OleCreateDefaultHandler(reobj.clsid, NULL, IID_IOleObject,(void **) &reobj.poleobj);
			if (hr)
			{
				TRACEERRSZSC("ObFReadStaticFromEditstream: no def handler", GetScode(hr));
				goto Cleanup;
			}

			// Get the IPersistStorage and initialize it
			if ((hr = reobj.poleobj->QueryInterface(IID_IPersistStorage,(void **)&pperstg)) ||
				(hr = pperstg->InitNew(reobj.pstg)))
			{
				TRACEERRSZSC("ObFReadStaticFromEditstream: InitNew", GetScode(hr));
				goto Cleanup;
			}
			dwAdvf = ADVF_PRIMEFIRST;
		}
		else
		{
			Assert(_pobj);
			_pobj->GetIUnknown()->QueryInterface(IID_IOleObject, (void **)&(reobj.poleobj));
			dwAdvf = ADVF_NODATA;
			formatetc.dwAspect = _fNeedIcon ? DVASPECT_ICON : DVASPECT_CONTENT;
		}

		// Get the IOleCache and put the picture data there
		if (hr = reobj.poleobj->QueryInterface(IID_IOleCache,(void **)&polecache))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: QI: IOleCache", GetScode(hr));
			goto Cleanup;
		}

		if (FAILED(hr = polecache->Cache(&formatetc, dwAdvf,
													&dwConn)))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: Cache", GetScode(hr));
			goto Cleanup;
		}

		if (hr = polecache->SetData(&formatetc, &stgmedium,				 
											TRUE))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: SetData", GetScode(hr));
			goto Cleanup;
		}
	}

	if( !_fNeedPres )
	{
		// Create another object site for the new object
		_ped->GetClientSite(&reobj.polesite) ;
		if (!reobj.polesite )
			goto Cleanup;

		// Set the client site
		if (reobj.poleobj && (hr = reobj.poleobj->SetClientSite(reobj.polesite)))
		{
			TRACEERRSZSC("ObFReadStaticFromEditstream: SetClientSite", GetScode(hr));
			goto Cleanup;
		}
		else if (!reobj.poleobj)
		{
			if(_prtfObject->sType == ROT_DIB)
			{
				// Windows CE static object Save the data and mark it.
				COleObject *pobj = (COleObject *)reobj.polesite;
				COleObject::ImageInfo *pimageinfo = new COleObject::ImageInfo;
				pobj->SetHdata(hBits);
				pimageinfo->xScale = _prtfObject->xScale;
				pimageinfo->yScale = _prtfObject->yScale;
				pimageinfo->xExtGoal = _prtfObject->xExtGoal;
				pimageinfo->yExtGoal = _prtfObject->yExtGoal;
				pimageinfo->cBytesPerLine = _prtfObject->cBytesPerLine;
				pobj->SetImageInfo(pimageinfo);
			}
			else
				goto Cleanup;		// There has been a mistake
		}

		// Put object into the edit control
		reobj.cbStruct = sizeof(REOBJECT);
		reobj.cp = _prg->GetCp();
		reobj.dvaspect = DVASPECT_CONTENT;
		reobj.dwFlags = REO_RESIZABLE;
		// Since we are loading an object, it shouldn't be blank
		reobj.dwFlags &= ~REO_BLANK;

		_prg->Set_iCF(-1);	
		_prg->ReplaceRange(1, &ch, NULL, SELRR_IGNORE);  
		hr = pObjectMgr->InsertObject(reobj.cp, &reobj, NULL);
		if (hr)
			goto Cleanup;
	}
	else
	{
		// the new presentation may have a different idea about how big the
		// object is supposed to be.  Make sure the object stays the correct
		// size.
		_pobj->ResetSizel(reobj.sizel);
	}
	fRet = TRUE;

Cleanup:
	if (polecache)		polecache->Release()	;
	if (reobj.pstg)		reobj.pstg->Release();
	if (reobj.polesite)	reobj.polesite->Release();
	if (reobj.poleobj)	reobj.poleobj->Release();
	if (pperstg)		pperstg->Release();
	if (pstm)			pstm->Release();
	FreePv(pbBuffer);

	_fNeedIcon = FALSE;
	_fNeedPres = FALSE;
	_pobj = NULL;

	return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\rtfwrit.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	RTFWRIT.CPP - RichEdit RTF Writer (w/o objects) |
 *
 *		This file contains the implementation of the RTF writer
 *		for the RichEdit control, except for embedded objects,
 *		which are handled mostly in rtfwrit2.cpp
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent <nl>
 *		Lots of enhancements: Brad Olenick <nl>
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_rtfwrit.h"
#include "_objmgr.h"
#include "_coleobj.h"
#include "_font.h"

ASSERTDATA

extern const KEYWORD rgKeyword[];

//========================= Global String Constants ==================================

BYTE bCharSetANSI = ANSI_CHARSET;				// ToDo: make more general

#ifdef DEBUG
// Quick way to find out what went wrong: rgszParseError[ecParseError]
//
CHAR *	rgszParseError[] =
{
	"No error",
	"Can't convert to Unicode",				// FF
	"Color table overflow",					// FE
	"Expecting '\\rtf'",					// FD
	"Expecting '{'",						// FC
	"Font table overflow",					// FB
	"General failure",						// FA
	"Keyword too long",						// F9
	"Lexical analyzer initialize failed",	// F8
	"No memory",							// F7
	"Parser is busy",						// F6
	"PutChar() function failed",			// F5
	"Stack overflow",						// F4
	"Stack underflow",						// F3
	"Unexpected character",					// F2
	"Unexpected end of file",				// F1
	"Unexpected token",						// F0
	"UnGetChar() function failed",			// EF
	"Maximum text length reached",			// EE
	"Streaming out object failed",			// ED
	"Streaming in object failed",			// EC
	"Truncated at CR or LF",				// EB
	"Format-cache failure",					// EA
	NULL									// End of list marker
};

CHAR * szDest[] =
{
	"RTF",
	"Color Table",
	"Font Table",
	"Binary",
	"Object",
	"Object Class",
	"Object Name",
	"Object Data",
	"Field",
	"Field Result",
	"Field Instruction",
	"Symbol",
	"Paragraph Numbering",
	"Picture"
};

#endif

// Most control-word output is done with the following printf formats
static const CHAR * rgszCtrlWordFormat[] =
{
	"\\%s", "\\%s%d", "{\\%s", "{\\*\\%s", "{\\%s%d"
};

// Special control-word formats
static const CHAR szBeginFontEntryFmt[]	= "{\\f%d\\%s";
static const CHAR szBulletGroup[]		= "{\\pntext\\f%d\\'B7\\tab}";
static const CHAR szBulletFmt[]			= "{\\*\\pn\\pnlvl%s\\pnf%d\\pnindent%d{\\pntxtb\\'B7}}";
static const CHAR szBeginNumberGroup[]	= "{\\pntext\\f%d ";
static const CHAR szEndNumberGroup[]	= "\\tab}";
static const CHAR szBeginNumberFmt[]	= "{\\*\\pn\\pnlvl%s\\pnf%d\\pnindent%d\\pnstart%d";
static const CHAR szpntxtb[]			= "{\\pntxtb(}";
static const CHAR szpntxta[]			= "{\\pntxta%c}";
static const CHAR szColorEntryFmt[]		= "\\red%d\\green%d\\blue%d;";
static const CHAR szEndFontEntry[]		= ";}";
       const CHAR szEndGroupCRLF[]		= "}\r\n";
static const CHAR szEscape2CharFmt[]	= "\\'%02x\\'%02x";
static const CHAR szLiteralCharFmt[]	= "\\%c";
static const CHAR szPar[]				= "\\par\r\n";
static const CHAR szPar10[]				= "\r\n\\par ";
static const CHAR szObjPosHolder[] 		= "\\objattph\\'20";
static const CHAR szDefaultFont[]		= "\\deff0";
static const CHAR szHorzdocGroup[]		= "{\\horzdoc}";
static const CHAR szNormalStyle[]		= "{ Normal;}";
static const CHAR szHeadingStyle[]		= "{\\s%d heading %d;}";
static const CHAR szEndRow[]			= "\\row\r\n";

#define szEscapeCharFmt		&szEscape2CharFmt[6]

// Arrays of RTF control-word indices. NOTE: if any index is greater than 255,
// the corresponding array must be changed to a WORD array. The compiler
// issues a warning in such cases

const BYTE rgiszTerminators[] =
{
	i_cell, 0, i_tab, 0, i_line, i_page
};

// Keep these indices in sync with the special character values in _common.h
const WORD rgiszSpecial[] =
{
	i_enspace,				// 0x2002
	i_emspace,				// 0x2003
	0,						// 0x2004
	0,						// 0x2005
	0,						// 0x2006
	0,						// 0x2007
	0,						// 0x2008
	0,						// 0x2009
	0,						// 0x200A
	0,						// 0x200B
	i_zwnj,					// 0x200C
	i_zwj,					// 0x200D
	i_ltrmark,				// 0x200E
	i_rtlmark,				// 0x200F
	0,						// 0x2010
	0,						// 0x2011
	0,						// 0x2012
	i_endash,				// 0x2013
	i_emdash,				// 0x2014
	0,						// 0x2015
	0,						// 0x2016
	0,						// 0x2017
	i_lquote, 				// 0x2018
	i_rquote,				// 0x2019
	0,						// 0x201A
	0,						// 0x201B
	i_ldblquote, 			// 0x201C
	i_rdblquote,			// 0x201D
	0,						// 0x201E
	0,						// 0x201F
	0,						// 0x2020
	0,						// 0x2021
	i_bullet				// 0x2022
};

const BYTE rgiszEffects[] =							
{													// Effects keywords
	i_deleted, i_revised, i_disabled, i_impr, 		// Ordered max CFE_xx to
	i_embo, i_shad, i_outl, i_v, i_caps, i_scaps, 	//  min CFE_xx (cept i_deleted)
	i_disabled, i_protect, i_strike, i_ul, i_i,	i_b	// (see WriteCharFormat())
};													

#define CEFFECTS	ARRAY_SIZE(rgiszEffects)

const BYTE rgiszPFEffects[] =						// PF effects keywords
{													// Ordered max PFE_xx to
	i_collapsed, i_sbys, i_hyphpar, i_nowidctlpar,	//  min PFE_xx
	i_noline, i_pagebb, i_keepn, i_keep, i_rtlpar
};													// (see WriteParaFormat())

#define CPFEFFECTS	ARRAY_SIZE(rgiszPFEffects)

const BYTE rgiszUnderlines[] =
{
	i_ulnone, i_ul, i_ulw, i_uldb, i_uld,			// Std Word underlines
	i_uldash, i_uldashd, i_uldashdd, i_ulwave, i_ulth, i_ulhair
};

#define CUNDERLINES	ARRAY_SIZE(rgiszUnderlines)

const BYTE rgiszFamily[] =							// Font family RTF name
{													//  keywords in order of
	i_fnil, i_froman, i_fswiss, i_fmodern,			//  bPitchAndFamily
	i_fscript, i_fdecor, i_ftech, i_fbidi
};

#define CFAMILIES ARRAY_SIZE(rgiszFamily)

const BYTE rgiszAlignment[] =						// Alignment keywords
{													// Keep in sync with
	i_ql, i_qr,	i_qc, i_qj							//  alignment constants
};

const BYTE rgiszTabAlign[] =						// Tab alignment keywords
{													// Keep in sync with tab
	i_tqc, i_tqr, i_tqdec							//  alignment constants
};

const BYTE rgiszTabLead[] =							// Tab leader keywords
{													// Keep in sync with tab
	i_tldot, i_tlhyph, i_tlul, i_tlth, i_tleq		//  leader constants
};

const BYTE rgiszNumberStyle[] =						// Numbering style keywords
{													// Keep in sync with TOM
	i_pndec, i_pnlcltr, i_pnucltr,					//  values
	i_pnlcrm, i_pnucrm					
};

const BYTE rgiszBorders[] =							// Border combination keywords
{													
	i_box,
	i_brdrt, i_brdrl, i_brdrb, i_brdrr,
	i_trbrdrt, i_trbrdrl, i_trbrdrb, i_trbrdrr,
	i_clbrdrt, i_clbrdrl, i_clbrdrb, i_clbrdrr
};

const BYTE rgiszBorderStyles[] =					// Border style keywords
{													
	i_brdrdash, i_brdrdashsm, i_brdrdb, i_brdrdot,
	i_brdrhair, i_brdrs, i_brdrth, i_brdrtriple
};
#define CBORDERSTYLES ARRAY_SIZE(rgiszBorderStyles)

const BYTE rgiszBorderEffects[] =					// Border effect keywords
{													
	i_brdrbar, i_brdrbtw, i_brdrsh					// Reverse order from bits
};

const BYTE rgiszShadingStyles[] =					// Shading style keywords
{													
	i_bgbdiag, i_bgcross, i_bgdcross, i_bgdkbdiag,
	i_bgdkcross, i_bgdkdcross, i_bgdkfdiag, i_bgdkhoriz,
	i_bgdkvert, i_bgfdiag, i_bghoriz, i_bgvert 
};
#define CSHADINGSTYLES ARRAY_SIZE(rgiszShadingStyles)

// RGB with 2 bits per color type (in BGR order)
const COLORREF g_Colors[] =
{
	RGB(  0,   0,   0),	// \red0\green0\blue0
	RGB(  0,   0, 255),	// \red0\green0\blue255
	RGB(  0, 255, 255),	// \red0\green255\blue255
	RGB(  0, 255,   0),	// \red0\green255\blue0
	RGB(255,   0, 255),	// \red255\green0\blue255
	RGB(255,   0,   0),	// \red255\green0\blue0
	RGB(255, 255,   0),	// \red255\green255\blue0
	RGB(255, 255, 255),	// \red255\green255\blue255
	RGB(  0,   0, 128),	// \red0\green0\blue128
	RGB(  0, 128, 128),	// \red0\green128\blue128
	RGB(  0, 128,   0),	// \red0\green128\blue0
	RGB(128,   0, 128),	// \red128\green0\blue128
	RGB(128,   0,   0),	// \red128\green0\blue0
	RGB(128, 128,   0),	// \red128\green128\blue0
	RGB(128, 128, 128),	// \red128\green128\blue128
	RGB(192, 192, 192),	// \red192\green192\blue192
};

/*
 *	CRTFWrite::MapsToRTFKeywordW(wch)
 *
 *	@mfunc
 *		Returns a flag indicating whether the character maps to an RTF keyword
 *
 *	@rdesc
 *		BOOL			TRUE if char maps to RTF keyword
 */
inline BOOL CRTFWrite::MapsToRTFKeywordW(
	WCHAR wch)
{
	return
		!_fNCRForNonASCII &&
		(IN_RANGE(TAB, wch, CR) ||
		wch == CELL ||
		wch == BSLASH ||
		wch == LBRACE || 
		wch == RBRACE ||
		IN_RANGE(ENSPACE, wch, EMSPACE) ||
		IN_RANGE(ENDASH, wch, EMDASH) ||
		IN_RANGE(LQUOTE, wch, RQUOTE) ||
		IN_RANGE(LDBLQUOTE, wch, RDBLQUOTE) ||
		wch == BULLET ||
		wch == chOptionalHyphen ||
		wch == chNonBreakingSpace);
}

/*
 *	CRTFWrite::MapsToRTFKeywordA(ch)
 *
 *	@mfunc
 *		Returns a flag indicating whether the character maps to an RTF keyword
 *
 *	@rdesc
 *		BOOL			TRUE if char maps to RTF keyword
 */
inline BOOL CRTFWrite::MapsToRTFKeywordA(char ch)
{
	return IN_RANGE(TAB, ch, CR) ||
		ch == CELL ||
		ch == BSLASH ||
		ch == LBRACE || 
		ch == RBRACE;
}

/*
 *	CRTFWrite::MapToRTFKeywordW(pv, cch, iCharEncoding)
 *
 *	@mfunc
 *		Examines the first character in the string pointed to by pv and
 *		writes out the corresponding RTF keyword.  In situations where
 *		the first and subsequent characters map to a single keyword, we
 *		return the number of additional characters used in the mapping.
 *
 *	@rdesc
 *		int		indicates the number of additional characters used when
 *				the mapping to an RTF keyword involves > 1 characters.
 */
int CRTFWrite::MapToRTFKeyword(
	void *	pv,				//@parm ptr to ansi or Unicode string
	int		cch,
	int		iCharEncoding)
{
	Assert(iCharEncoding == MAPTOKWD_ANSI || iCharEncoding == MAPTOKWD_UNICODE);

	WCHAR ch = ((iCharEncoding == MAPTOKWD_ANSI) ? *(char *)pv : *(WCHAR *)pv);
	int cchRet = 0;

	Assert((iCharEncoding == MAPTOKWD_ANSI) ? MapsToRTFKeywordA(ch) : MapsToRTFKeywordW(ch));

	switch(ch)
	{
		case BULLET:
		case EMDASH:
		case EMSPACE:
		case ENDASH:
		case ENSPACE:
		case LDBLQUOTE:
		case LQUOTE:
		case RDBLQUOTE:
		case RQUOTE:
			Assert(ch > 0xFF);

			if(iCharEncoding != MAPTOKWD_ANSI)
			{
				AssertSz(rgiszSpecial[ch - ENSPACE] != 0,
					"CRTFWrite::WriteText(): rgiszSpecial out-of-sync");
				PutCtrlWord(CWF_STR, rgiszSpecial[ch - ENSPACE]);
			}
			break;

		case TAB:
#if TAB == CELL							// If TABs and CELLs are equal, in
			if(_pPF->InTable())			//  tables convert TABs to CELL value
				ch -= 2;				//  of 7 for rgiszTerminators[]
#else
		case CELL:
#endif
		case FF:
		case VT:
			PutCtrlWord(CWF_STR, rgiszTerminators[ch - (TAB - 2)]);
			break;

		case CR:
		{
			WCHAR ch1;
			WCHAR ch2;

			if(iCharEncoding == MAPTOKWD_ANSI)
			{
				char *pch = (char *)pv;
				ch1 = pch[1];
				ch2 = pch[2];
			}
			else
			{
				WCHAR *pch = (WCHAR *)pv;
				ch1 = pch[1];
				ch2 = pch[2];
			}

			if(cch > 1 && ch1 == CR && ch2 == LF)
			{
				// Translate CRCRLF	to a blank (represents soft line break)
				PutChar(' ');
				cchRet = 2;
				break;
			}
			if(cch && ch1 == LF)		// Ignore LF after CR
			{
				cchRet = 1;
			}							
			if(_pPF->InTable())			// CR terminates a row in our simple
			{							//  table model, so output \row
				Puts(szEndRow, sizeof(szEndRow) - 1);
				_fCheckInTable = TRUE;
				break;
			}
		}								// Fall thru to LF (EOP) case

		case LF:
			if (_ped->Get10Mode())
				Puts(szPar10, sizeof(szPar10) - 1);
			else
				Puts(szPar, sizeof(szPar) - 1);
			if(_fBullet)
			{
				if(cch > 0)
				{
					if(!_nNumber) 
						printF(szBulletGroup, _symbolFont);

					else if(!_pPF->IsNumberSuppressed())
					{
						WCHAR szNumber[CCHMAXNUMTOSTR];
						_pPF->NumToStr(szNumber, ++_nNumber, fRtfWrite);
						printF(szBeginNumberGroup, _nFont);
						WritePcData(szNumber, _cpg, FALSE);
						printF(szEndNumberGroup);
					}
				}
				else
					_fBulletPending = TRUE;
			}
			break;

		case chOptionalHyphen:
			ch = '-';					// Fall thru to printFLiteral

printFLiteral:
		case BSLASH:
		case LBRACE:
		case RBRACE:
			printF(szLiteralCharFmt, ch);
			break;

		case chNonBreakingSpace:
			ch = '~';
			goto printFLiteral;
	}
	
	return cchRet;
}


//======================== CRTFConverter Base Class ==================================

/*
 *	CRTFConverter::CRTFConverter()
 *
 *	@mfunc
 *		RTF Converter constructor
 */
CRTFConverter::CRTFConverter(
	CTxtRange *		prg,			//@parm CTxtRange for transfer
	EDITSTREAM *	pes,			//@parm Edit stream for transfer
	DWORD			dwFlags,		//@parm Converter flags
	BOOL 			fRead)			//@parm Initialization for a reader or writer
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFConverter::CRTFConverter");

	AssertSz(prg && pes && pes->pfnCallback,
		"CRTFWrite::CRTFWrite: Bad RichEdit");

	_prg			= prg;
	_pes			= pes;
	_ped			= prg->GetPed();
	_dwFlags		= dwFlags;
	_ecParseError	= ecNoError;

	if(!_ctfi)
		ReadFontSubInfo();

#if defined(DEBUG) && !defined(MACPORT)
	_hfileCapture = NULL;

#if !defined(PEGASUS)
	if(GetProfileIntA("RICHEDIT DEBUG", "RTFCAPTURE", 0))
	{
		char szTempPath[MAX_PATH] = "\0";
		const char cszRTFReadCaptureFile[] = "CaptureRead.rtf";
		const char cszRTFWriteCaptureFile[] = "CaptureWrite.rtf";
		DWORD cchLength;
		
		SideAssert(cchLength = GetTempPathA(MAX_PATH, szTempPath));

		// append trailing backslash if neccessary
		if(szTempPath[cchLength - 1] != '\\')
		{
			szTempPath[cchLength] = '\\';
			szTempPath[cchLength + 1] = 0;
		}

		strcat(szTempPath, fRead ? cszRTFReadCaptureFile : 
									cszRTFWriteCaptureFile);
		
		SideAssert(_hfileCapture = CreateFileA(szTempPath,
											GENERIC_WRITE,
											FILE_SHARE_READ,
											NULL,
											CREATE_ALWAYS,
											FILE_ATTRIBUTE_NORMAL,
											NULL));
	}
#endif // !defined(PEGASUS)

#endif // defined(DEBUG) && !defined(MACPORT)
}



//======================== OLESTREAM functions =======================================

DWORD CALLBACK RTFPutToStream (
	RTFWRITEOLESTREAM *	OLEStream,	//@parm OLESTREAM
	const void *		pvBuffer,	//@parm Buffer to  write
	DWORD				cb)			//@parm Bytes to write
{
	return OLEStream->Writer->WriteData ((BYTE *)pvBuffer, cb);
}



//============================ CRTFWrite Class ==================================

/*
 *	CRTFWrite::CRTFWrite()
 *
 *	@mfunc
 *		RTF writer constructor
 */
CRTFWrite::CRTFWrite(
	CTxtRange *		prg,			//@parm CTxtRange to write
	EDITSTREAM *	pes,			//@parm Edit stream to write to
	DWORD			dwFlags)		//@parm Write flags
	: CRTFConverter(prg, pes, dwFlags, FALSE)
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::CRTFWrite");

	ZeroMemory(&_CF, sizeof(CCharFormat));	// Setup "previous" CF with RTF
	_CF._dwEffects	= CFE_AUTOCOLOR | CFE_AUTOBACKCOLOR;//  Font info is given 
	_CF._yHeight	= -32768;				//  by first font in range
											//  [see end of LookupFont()]
	Assert(_ped);
	_ped->GetDefaultLCID(&_CF._lcid);

	// init OleStream
	RTFWriteOLEStream.Writer = this;
	RTFWriteOLEStream.lpstbl->Put = (DWORD (CALLBACK* )(LPOLESTREAM, const void FAR*, DWORD))
							   RTFPutToStream;
	RTFWriteOLEStream.lpstbl->Get = NULL;

	_fIncludeObjects = TRUE;
	if((dwFlags & SF_RTFNOOBJS) == SF_RTFNOOBJS)
		_fIncludeObjects = FALSE;

	_fNCRForNonASCII = (dwFlags & SF_NCRFORNONASCII) != 0;
	_fNeedDelimeter = FALSE;
	_nHeadingStyle = 0;					// No headings found
	_nNumber = 0;						// No paragraph numbering yet
	_fCheckInTable = FALSE;
	_pPF = NULL;
	_pbAnsiBuffer = NULL;
}											

/*
 *	CRTFWrite::FlushBuffer()
 *
 *	@mfunc
 *		Flushes output buffer
 *
 *	@rdesc
 *		BOOL			TRUE if successful
 */
BOOL CRTFWrite::FlushBuffer()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::FlushBuffer");

	LONG cchWritten;

	if (!_cchBufferOut)
		return TRUE;

#ifdef DEBUG_PASTE
	if (FromTag(tagRTFAsText))
	{
		CHAR *	pchEnd	= &_pchRTFBuffer[_cchBufferOut];
		CHAR	chT		= *pchEnd;

		*pchEnd = 0;
		TraceString(_pchRTFBuffer);
		*pchEnd = chT;
	}
#endif

	_pes->dwError = _pes->pfnCallback(_pes->dwCookie,
									  (unsigned char *)_pchRTFBuffer,
									  _cchBufferOut,	&cchWritten);

#if defined(DEBUG) && !defined(MACPORT) && !defined(PEGASUS)
	if(_hfileCapture)
	{
		DWORD cbLeftToWrite = _cchBufferOut;
		DWORD cbWritten2 = 0;
		BYTE *pbToWrite = (BYTE *)_pchRTFBuffer;
		
		while(WriteFile(_hfileCapture,
						pbToWrite,
						cbLeftToWrite,
						&cbWritten2,
						NULL) && 
						(pbToWrite += cbWritten2,
						(cbLeftToWrite -= cbWritten2)));
	}
#endif

	if (_pes->dwError)
	{
		_ecParseError = ecPutCharFailed; 
		return FALSE;
	}
	AssertSz(cchWritten == _cchBufferOut,
		"CRTFW::FlushBuffer: incomplete write");

	_cchOut		  += _cchBufferOut;
	_pchRTFEnd	  = _pchRTFBuffer;					// Reset buffer
	_cchBufferOut = 0;

	return TRUE;
}

/*
 *	CRTFWrite::PutChar(ch)
 *
 *	@mfunc
 *		Put out the character <p ch>
 *
 *	@rdesc
 *		BOOL	TRUE if successful
 */
BOOL CRTFWrite::PutChar(
	CHAR ch)				//@parm char to be put
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::PutChar");

	CheckDelimeter();					// If _fNeedDelimeter, may need to
										//  PutChar(' ')
	// Flush buffer if char won't fit
	if (_cchBufferOut + 1 >= cachBufferMost && !FlushBuffer())
		return FALSE;

	*_pchRTFEnd++ = ch;						// Store character in buffer
	++_cchBufferOut;	
	return TRUE;
}

/*
 *	CRTFWrite::CheckInTable(fPutIntbl)
 *
 *	@mfunc
 *		If _fCheckInTable or !fPutIntbl, output row header RTF. If fPutIntbl 
 *		and _fCheckInTable, output \intbl as well. Note that fPutIntbl is
 *		FALSE when a PF is being output, since this control word needs to
 *		be output after the \pard, but the other row RTF needs to be output
 *		before the \pard.
 *
 *	@rdesc
 *		BOOL	TRUE if in table and outputted all relevant \trowd stuff
 */
BOOL CRTFWrite::CheckInTable(
	BOOL fPutIntbl)		//@parm TRUE if \intbl should be output
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::CheckInTable");

	_fCheckInTable = FALSE;
	if(_pPF->InTable())
	{
		if(!_fRangeHasEOP)
			return TRUE;

		LONG  cTab = _pPF->_bTabCount;
		LONG  h	   = _pPF->_dxOffset;
		LONG  i, j = _pPF->_dxStartIndent;
		LONG  k	   = _pPF->_bAlignment;
		DWORD Tab, Widths;

		if (!PutCtrlWord(CWF_STR, i_trowd) || // Reset table properties
			h && !PutCtrlWord(CWF_VAL, i_trgaph, h) ||
			j && !PutCtrlWord(CWF_VAL, i_trleft, j) ||
			IN_RANGE(PFA_RIGHT, k, PFA_CENTER) &&
			!PutCtrlWord(CWF_STR, k == PFA_RIGHT ? i_trqr : i_trqc))
		{
			return FALSE;
		}
		PutBorders(TRUE);
		const LONG *prgxTabs = _pPF->GetTabs();
		for(i = 0; i < cTab; i++)
		{
			Tab = *prgxTabs++;
			Widths = Tab >> 24;
			if(Widths)
			{
				for(j = 0; j < 4; j++, Widths >>= 2)
				{
					LONG w = Widths & 3;
					if(w && (!PutCtrlWord(CWF_STR, rgiszBorders[j + 9]) ||
						!PutCtrlWord(CWF_VAL, i_brdrw, 15*w) ||
						!PutCtrlWord(CWF_STR, i_brdrs)))
					{
						return FALSE;
					}
				}
				CheckDelimeter();
			}
			if(!PutCtrlWord(CWF_VAL, i_cellx, GetTabPos(Tab)))
				return FALSE;
		}
		if(!fPutIntbl || PutCtrlWord(CWF_STR, i_intbl))
			return TRUE;
	}
	return FALSE;
}

/*
 *	CRTFWrite::PutBorders(fInTable)
 *
 *	@mfunc
 *		If any borders are defined, output their control words
 *
 *	@rdesc
 *		error code
 */
EC CRTFWrite::PutBorders(
	BOOL fInTable)
{
	DWORD Widths = _pPF->_wBorderWidth;
	BOOL  fBox	 = _pPF->_wEffects & PFE_BOX;

	if(Widths || fBox)
	{
		DWORD Colors = _pPF->_dwBorderColor;
		DWORD dwEffects = Colors >> 20;
		LONG  i = 1, iMax = 4;					// NonBox for loop limits
		LONG  j, k;
		DWORD Spaces = _pPF->_wBorderSpace;
		DWORD Styles = _pPF->_wBorders;

		if(fBox)
			i = iMax = 0;						// For box, only write one set

		for( ; i <= iMax; i++, Spaces >>= 4, Styles >>= 4, Widths >>= 4, Colors >>= 5)
		{
			if(!(Widths & 0xF) && !fBox)		// No width, so no border
				continue;

			j = TWIPS_PER_POINT*(Spaces & 0xF);
			k = Colors & 0x1F;
			if (!PutCtrlWord(CWF_STR, rgiszBorders[i + 4*fInTable])		||
				!PutCtrlWord(CWF_STR, rgiszBorderStyles[Styles & 0xF])	||
				!PutCtrlWord(CWF_VAL, i_brdrw, 10*(Widths & 0xF))		||
				k &&
				!PutCtrlWord(CWF_VAL, i_brdrcf, LookupColor(g_Colors[k-1]) + 1) ||
				j && !PutCtrlWord(CWF_VAL, i_brsp, j))
			{
				break;
			}
			for(j = 3; j--; dwEffects >>= 1)		// Output border effects
			{
				if (dwEffects & 1 &&
					!PutCtrlWord(CWF_STR, rgiszBorderEffects[j]))
				{
					break;
				}				
			}
			CheckDelimeter();						// Output a ' '
		}
	}
	return _ecParseError;
}

/*
 *	CRTFWrite::Puts(sz, cb)
 *
 *	@mfunc
 *		Put out the string <p sz>
 *	
 *	@rdesc
 *		BOOL				TRUE if successful
 */
BOOL CRTFWrite::Puts(
	CHAR const * sz,
	LONG cb)		//@parm String to be put
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::Puts");

	if(*sz == '\\' || *sz == '{' || *sz == ' ')
		_fNeedDelimeter = FALSE;

	CheckDelimeter();					// If _fNeedDelimeter, may need to
										//  PutChar(' ')
	// Flush buffer if string won't fit
	if (_cchBufferOut + cb >= cachBufferMost && !FlushBuffer())
		return FALSE;

	if (cb >= cachBufferMost)			// If buffer still can't handle string,
	{									//   we have to write string directly
		LONG	cbWritten;

#ifdef DEBUG_PASTE
		if (FromTag(tagRTFAsText))
			TraceString(sz);
#endif
		_pes->dwError = _pes->pfnCallback(_pes->dwCookie,
										(LPBYTE) sz, cb, &cbWritten);
		_cchOut += cbWritten;

#if defined(DEBUG) && !defined(MACPORT) && !defined(PEGASUS)
		if(_hfileCapture)
		{
			DWORD cbLeftToWrite = cb;
			DWORD cbWritten2 = 0;
			BYTE *pbToWrite = (BYTE *)sz;
		
			while(WriteFile(_hfileCapture,
							pbToWrite,
							cbLeftToWrite,
							&cbWritten2,
							NULL) && 
							(pbToWrite += cbWritten2,
							(cbLeftToWrite -= cbWritten2)));
		}
#endif

		if (_pes->dwError)
		{
			_ecParseError = ecPutCharFailed;
			return FALSE;
		}
		AssertSz(cbWritten == cb,
			"CRTFW::Puts: incomplete write");
	}
	else
	{
		CopyMemory(_pchRTFEnd, sz, cb);		// Put string into buffer for later
		_pchRTFEnd += cb;							//  output
		_cchBufferOut += cb;
	}

	return TRUE;
}

/*
 *	CRTFWrite::PutCtrlWord(iFormat, iCtrl, iValue)
 *
 *	@mfunc
 *		Put control word with rgKeyword[] index <p iCtrl> and value <p iValue>
 *		using format rgszCtrlWordFormat[<p iFormat>]
 *
 *	@rdesc
 *		TRUE if successful
 *
 *	@devnote
 *		Sets _fNeedDelimeter to flag that next char output must be a control
 *		word delimeter, i.e., not alphanumeric (see PutChar()).
 */
BOOL CRTFWrite::PutCtrlWord(

	LONG iFormat,			//@parm Format index into rgszCtrlWordFormat
	LONG iCtrl,				//@parm Index into Keyword array
	LONG iValue)			//@parm Control-word parameter value. If missing,
{							//		 0 is assumed
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::PutCtrlWord");

	BOOL	bRet;
	CHAR	szT[60];
	LONG    cb;

	cb = sprintf(szT,
			  (char *)rgszCtrlWordFormat[iFormat],
			  rgKeyword[iCtrl].szKeyword,
			  iValue);
	_fNeedDelimeter = FALSE;
	bRet = Puts(szT, cb);
	_fNeedDelimeter = TRUE;					// Ensure next char isn't
											//  alphanumeric
	return bRet;
}

/*
 *	CRTFWrite::printF(szFmt, ...)
 *
 *	@mfunc
 *		Provide formatted output
 *
 *	@rdesc
 *		TRUE if successful
 */
BOOL _cdecl CRTFWrite::printF(
	CONST CHAR * szFmt,		//@parm Format string for printf()
	...)					//@parmvar Parameter list
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::printF");
	va_list	marker;
	CHAR	szT[60];

	va_start(marker, szFmt);
	int cb = W32->WvsprintfA(60, szT, szFmt, marker);
	va_end(marker);

	return Puts(szT, cb);
}

/*
 *	CRTFWrite::WritePcData(szData, nCodePage, fIsDBCS)
 *
 *	@mfunc
 *		Write out the string <p szData> as #PCDATA where any special chars
 *		are protected by leading '\\'.
 *
 *	@rdesc
 *		EC (_ecParseError)
 */
EC CRTFWrite::WritePcData(
	const TCHAR * szData,	//@parm #PCDATA string to write
	INT  nCodePage,			//@parm code page default value CP_ACP
	BOOL fIsDBCS)			//@parm szData is a DBCS string stuffed into Unicode buffer
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WritePcData");

	BYTE		ch;
	BOOL		fMissingCodePage;
	BOOL		fMultiByte;
	const BYTE *pch;
	const char *pchToDBCSDefault = NULL;
	BOOL *		pfUsedDefault = NULL;

	if(IsUTF8)
		nCodePage = CP_UTF8;

	if(!*szData)
		return _ecParseError;

	int	DataSize = wcslen(szData) + 1;
	int BufferSize = DataSize * 3;
	char *pBuffer = (char *)PvAlloc(BufferSize, GMEM_ZEROINIT);
	if(!pBuffer)
		return ecNoMemory;

#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	// When WCTMB fails to convert a char, the following default
	// char is used as a placeholder in the string being converted
	const char	chToDBCSDefault = 0;
	BOOL		fUsedDefault;

	pchToDBCSDefault = &chToDBCSDefault;
	pfUsedDefault	 = &fUsedDefault;
#endif

	int cchRet = WCTMB(fIsDBCS ? INVALID_CODEPAGE : nCodePage, 0, 
						szData, -1, pBuffer, BufferSize,
						pchToDBCSDefault, pfUsedDefault,
						&fMissingCodePage);
	Assert(cchRet > 0);

	if(!fIsDBCS && fMissingCodePage && nCodePage != CP_ACP)
	{
		// Here, the system could not convert the Unicode string because the
		// code page is not installed on the system.  Fallback to CP_ACP.

		cchRet = WCTMB(CP_ACP, 0, 
						szData, -1, pBuffer, BufferSize,
						pchToDBCSDefault, pfUsedDefault,
						&fMissingCodePage);
		Assert(cchRet > 0);

		nCodePage = CP_ACP;
	}

	AssertSz(!fUsedDefault, "CRTFWrite::WritePcData():  Found character in "
							"control text which cannot be converted from "
							"Unicode");
	if(cchRet <= 0)
	{
		_ecParseError = ecCantUnicode;
		goto CleanUp;
	}

	BufferSize = cchRet;

	fMultiByte = (BufferSize > DataSize) || fIsDBCS || fMissingCodePage;
	pch = (BYTE *)pBuffer;
	ch = *pch;
	
	// If _fNeedDelimeter, may need	to PutChar(' ')
	CheckDelimeter();
									
	while (!_ecParseError && (ch = *pch++))
	{
		if(fMultiByte && *pch && nCodePage != CP_UTF8 && GetTrailBytesCount(ch, nCodePage))
			printF(szEscape2CharFmt, ch, *pch++);					// Output DBC pair
		else
		{
			if(ch == LBRACE || ch == RBRACE || ch == BSLASH)
				printF(szLiteralCharFmt, ch);

			else if(ch < 32 || ch == ';' || ch > 127)
				printF(szEscapeCharFmt, ch);

			else
				PutChar(ch);
		}
	}

CleanUp:
	FreePv(pBuffer); 
	return _ecParseError;
}

/*
 *	CRTFWrite::LookupColor(colorref)
 *
 *	@mfunc
 *		Return color-table index for color referred to by <p colorref>.
 *		If a match isn't found, an entry is added.
 *
 *	@rdesc
 *		LONG			Index into colortable
 *		<lt> 0			on error
 */
LONG CRTFWrite::LookupColor(
	COLORREF colorref)		//@parm colorref to look for
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::LookupColor");

	LONG		Count = _colors.Count();
	LONG		iclrf;
	COLORREF *	pclrf;

	for(iclrf = 0; iclrf < Count; iclrf++)		// Look for color
		if(_colors.GetAt(iclrf) == colorref)
		 	return iclrf;

	pclrf = _colors.Add(1, NULL);				// If we couldn't find it,
	if(!pclrf)									//  add it to color table
		return -1;
	*pclrf = colorref;

	return iclrf;
}

/*
 *	CRTFWrite::LookupFont(pCF)
 *
 *	@mfunc
 *		Returns index into font table for font referred to by
 *		CCharFormat *<p pCF>. If a match isn't found, an entry is added.
 *
 *	@rdesc
 *		SHORT		Index into fonttable
 *		<lt> 0		on error
 */
LONG CRTFWrite::LookupFont(
	CCharFormat const * pCF)	//@parm CCharFormat holding font name
{								//		 to look up
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::LookupFont");

	LONG		Count = _fonts.Count();
	LONG		itf;
	TEXTFONT *	ptf;
	
	for(itf = 0; itf < Count; itf++)
	{														// Look for font
		ptf = _fonts.Elem(itf);
		if (ptf->bPitchAndFamily == pCF->_bPitchAndFamily &&//  of same pitch,
			ptf->bCharSet		 == pCF->_bCharSet &&		//  char set, and
			ptf->iFont			 == pCF->_iFont)			//  name
		{
			return itf;										// Found it
		}
	}
	ptf = _fonts.Add(1, NULL);								// Didn't find it:
	if(!ptf)												//  add to table
		return -1;

	ptf->bPitchAndFamily = pCF->_bPitchAndFamily;
	ptf->bCharSet		 = pCF->_bCharSet;
	ptf->sCodePage		 = (short)GetCodePage (ptf->bCharSet);
	ptf->iFont			 = pCF->_iFont;
	ptf->fNameIsDBCS	 = (pCF->_dwEffects & CFE_FACENAMEISDBCS) != 0;

#if 0
	// Bug1523 - (BradO) I removed this section of code so that a /fN tag is always
	// emitted for the first run of text.  In theory, we should be able to
	// assume that the first run of text would carry the default font.
	// It turns out that when reading RTF, Word doesn't use anything predictable
	// for the font of the first run of text in the absence of an explicit /fN, 
	// thus, we have to explicitly emit a /fN tag for the first run of text.
	if(!Count)												// 0th font is
	{														//  default \deff0
		_CF.bPitchAndFamily	= pCF->bPitchAndFamily;			// Set "previous"
		_CF.bCharSet		= pCF->bCharSet;				//  CF accordingly
		wcscpy(_CF.szFaceName, pCF->szFaceName);
	}
#endif

	return itf;
}

/*
 *	CRTFWrite::BuildTables(rpCF, rpPF, cch, fNameIsDBCS)
 *
 *	@mfunc
 *		Build font and color tables for write range of length <p cch>
 *
 *	@rdesc
 *		EC			The error code
 */
EC CRTFWrite::BuildTables(
	CFormatRunPtr& rpCF,	//@parm CF run ptr for start of write range
	CFormatRunPtr& rpPF,	//@parm PF run ptr for start of write range
	LONG cch,				//@parm # chars in write range
	BOOL& fNameIsDBCS)		//@parm OUT =TRUE if there is any CFE_FACENAMEISDBCS Run in selection.
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::BuildTables");

	LONG				i;
	LONG				ifmt = 0;
	const CCharFormat *	pCF = NULL;
	const CParaFormat * pPF = NULL;
	CFormatRunPtr		rp(rpCF);
	CFormatRunPtr		rpPFtemp(rpPF);
	LONG				cchTotal = cch;

	fNameIsDBCS = FALSE;

	while(cch > 0)
	{
		ifmt = rp.GetFormat();					// _iFormat for next CF run
		pCF = _ped->GetCharFormat(ifmt);

		Assert(pCF);

		if (pCF->_dwEffects & CFE_FACENAMEISDBCS)
			fNameIsDBCS = TRUE;

		// Look up character-format *pCF's font and color. If either isn't
		// found, it is added to appropriate table.  Don't lookup color
		// for CCharFormats with auto-color

		if (LookupFont(pCF) < 0 ||
			(!(pCF->_dwEffects & CFE_AUTOCOLOR) &&
				LookupColor(pCF->_crTextColor) < 0) ||
			(!(pCF->_dwEffects & CFE_AUTOBACKCOLOR) &&
				LookupColor(pCF->_crBackColor) < 0))
		{
			break;
		}
		if(!rp.IsValid())
			break;
		cch -= rp.GetCchLeft();
		rp.NextRun();
	}

	// now look for bullets; if found, then we need to include
	// the "Symbol" font

	cch = cchTotal;
	_symbolFont = 0;

	while( cch > 0 )
	{
		ifmt = rpPFtemp.GetFormat();
		pPF = _ped->GetParaFormat(ifmt);
		if(!pPF)
			goto CacheError;
		
		if(pPF->_wNumbering == PFN_BULLET && !_symbolFont)
		{
			CCharFormat CF;

			// Be sure these choices agree with those in CMeasurer::GetCcsBullet()
			// and that LookupFont() doesn't access any other CF members.
			CF._iFont			= IFONT_SYMBOL;
			CF._bCharSet		= SYMBOL_CHARSET;
			CF._bPitchAndFamily = FF_DONTCARE;

			// Save Font index for Symbol. Reset it to 0 if LookupFont
			// returns error.
			_symbolFont = LookupFont(&CF);
			_symbolFont = max(_symbolFont, 0);

			// We don't need to bother looking for more bullets, since
			// in RichEdit 2.0, all bullets either have the same font or
			// have their formatting information in the character format
			// for the EOP mark.
			break;
		}
		
		WORD  Widths = pPF->_wBorderWidth;
		DWORD Colors = pPF->_dwBorderColor & 0xFFFFF;

		while(Widths && Colors)
		{
			i = Colors & 0x1F;
			if(i && (Widths & 0xF))
				LookupColor(g_Colors[i - 1]);

			Widths >>= 4;
			Colors >>= 5;
		}
		
		i = (pPF->_wShadingStyle >> 6) & 31;		// Shading forecolor
		if(i)
			LookupColor(g_Colors[i - 1]);
		i = pPF->_wShadingStyle >> 11;				// Shading backcolor
		if(i)
			LookupColor(g_Colors[i - 1]);

		if(IsHeadingStyle(pPF->_sStyle) && pPF->_sStyle < _nHeadingStyle)
			_nHeadingStyle = pPF->_sStyle;

		if(!rpPFtemp.IsValid())
			break;
		
		cch -= rpPFtemp.GetCchLeft();
		rpPFtemp.NextRun();
	}	

	return _ecParseError;

CacheError:
	_ecParseError = ecFormatCache;
	return ecFormatCache;					// Access to CF/PF cache failed
}

/*
 *	CRTFWrite::WriteFontTable()
 *
 *	@mfunc
 *		Write out font table
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteFontTable()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteFontTable");

	LONG			Count = _fonts.Count();
	int				itf;
	int				m;
	int				pitch;
	TEXTFONT *		ptf;
	char *			szFamily;
	const TCHAR *	szName;
	TCHAR *			szTaggedName;

	if(!Count || !PutCtrlWord(CWF_GRP, i_fonttbl))	// Start font table group
		goto CleanUp;

	for (itf = 0; itf < Count; itf++)
	{
		ptf = _fonts.Elem(itf);

//		if (ptf->sCodePage)
//			if (! PutCtrlWord(CWF_VAL, i_cpg, ptf->sCodePage ) )
//				goto CleanUp;

		// Define font family
		m			 = ptf->bPitchAndFamily >> 4;
		szFamily	 = rgKeyword[rgiszFamily[m < CFAMILIES ? m : 0]].szKeyword;
		szName		 = GetFontName(ptf->iFont);
		szTaggedName = NULL;

		// Check to see if this is a tagged font
		if (!ptf->bCharSet ||
			!FindTaggedFont(szName, ptf->bCharSet, &szTaggedName))
		{
			szTaggedName = NULL;
		}

		pitch = ptf->bPitchAndFamily & 0xF;					// Write font
		if (!printF(szBeginFontEntryFmt, itf, szFamily))	//  entry, family,
			goto CleanUp;
		_fNeedDelimeter = TRUE;
		if (pitch && !PutCtrlWord(CWF_VAL, i_fprq, pitch))	//  and pitch
			goto CleanUp;

		if(!ptf->sCodePage && ptf->bCharSet)
			ptf->sCodePage = (short)GetCodePage(ptf->bCharSet);

		// Write charset. Win32 uses ANSI_CHARSET to mean the default Windows
		// character set, so find out what it really is

		extern BYTE bCharSetANSI;

		if(ptf->bCharSet != DEFAULT_CHARSET)
		{
			BYTE bCharSet = ptf->bCharSet;
			BOOL fWroteCharSet = TRUE;

			if(ptf->bCharSet == PC437_CHARSET || IsPrivateCharSet(bCharSet))
			{
				fWroteCharSet = FALSE;
				bCharSet = ANSI_CHARSET;
			}
			if(!PutCtrlWord(CWF_VAL, i_fcharset, bCharSet))
				goto CleanUp;

			// Skip \cpgN output if we've already output a \fcharsetN tag.
			// This is to accomodate RE 1.0, which can't handle some \cpgN
			// tags properly. Specifically, when RE 1.0 parses the \cpgN tag
			// it looks up the corresponding charset value. Turns out its
			// codepage/charset table is incomplete so it maps some codepages
			// to charset 0, trouncing the previously read \fcharsetN value.
			if (fWroteCharSet)
				goto WroteCharSet;
		}

		if(ptf->sCodePage && !PutCtrlWord(CWF_VAL, i_cpg, ptf->sCodePage))
			goto CleanUp;

WroteCharSet:
		if(szTaggedName)							
		{											
			// Have a tagged font:  write out group with real name followed by tagged name
			if(!PutCtrlWord(CWF_AST, i_fname) ||	
				WritePcData(szName, ptf->sCodePage, ptf->fNameIsDBCS) ||			
				!Puts(szEndFontEntry, sizeof(szEndFontEntry) - 1) ||
				WritePcData(szTaggedName, ptf->sCodePage, ptf->fNameIsDBCS) ||
				!Puts(szEndFontEntry, sizeof(szEndFontEntry) - 1))
			{
				goto CleanUp;
			}
		}
		else if(WritePcData(szName, ptf->sCodePage, ptf->fNameIsDBCS) ||
					!Puts(szEndFontEntry, sizeof(szEndFontEntry) - 1))
		// If non-tagged font just write name out
		{
			goto CleanUp;
		}
	}
	Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF) - 1);							// End font table group

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteColorTable()
 *
 *	@mfunc
 *		Write out color table
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteColorTable()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteColorTable");

	LONG		Count = _colors.Count();
	COLORREF	clrf;
	LONG		iclrf;

	if (!Count || !PutCtrlWord(CWF_GRP, i_colortbl)	// Start color table group
		|| !PutChar(';'))							//  with null first entry
	{
		goto CleanUp;
	}

	for(iclrf = 0; iclrf < Count; iclrf++)
	{
		clrf = _colors.GetAt(iclrf);
		if (!printF(szColorEntryFmt,
					GetRValue(clrf), GetGValue(clrf), GetBValue(clrf)))
			goto CleanUp;
	}

	Puts(szEndGroupCRLF,sizeof(szEndGroupCRLF) -1);		// End color table group

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteCharFormat(pCF)
 *
 *	@mfunc
 *		Write deltas between CCharFormat <p pCF> and the previous CCharFormat
 *		given by _CF, and then set _CF = *<p pCF>.
 *
 *	@rdesc
 *		EC			The error code
 *
 *	@devnote
 *		For optimal output, could write \\plain and use deltas relative to
 *		\\plain if this results in less output (typically only one change
 *		is made when CF changes, so less output results when compared to
 *		previous CF than when compared to \\plain).
 */
EC CRTFWrite::WriteCharFormat(
	const CCharFormat * pCF)		//@parm Ptr to CCharFormat
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteCharFormat");

	DWORD	dwEffects = pCF->_dwEffects;			// Current effects
	DWORD	dwChanges = _CF._dwEffects;				// Previous effects (will be 
	LONG	i;										//  changed between them)
	LONG	iFormat;
	LONG	iValue;									// Control-word value
	LONG	i_sz;									// Temp ctrl string index
	LONG	yOffset = pCF->_yOffset;

	DWORD UType1 = _CF._bUnderlineType;				// Previous underline type
	if(UType1 >= CUNDERLINES)						// Special underlines are
		dwChanges &= ~CFE_UNDERLINE;				//  not written out, so
													//  claim they're not on
	DWORD UType2 = pCF->_bUnderlineType;			// Current underline type
	if(UType2 >= CUNDERLINES)						// _bUnderlineType for
		dwEffects &= ~CFE_UNDERLINE;				//  specials has non0
													//  high nibble
	dwChanges ^= dwEffects;							// Now dwChanges is the
													//  diff between effects
	if (dwChanges & CFE_AUTOCOLOR ||				// Change in autocolor
		pCF->_crTextColor != _CF._crTextColor)		//  or text color
	{
		iValue = 0;									// Default autocolor
		if(!(dwEffects & CFE_AUTOCOLOR))			// Make that text color
			iValue = LookupColor(pCF->_crTextColor) + 1;
		if(!PutCtrlWord(CWF_VAL, i_cf, iValue))
			goto CleanUp;
	}

	if (dwChanges & CFE_AUTOBACKCOLOR ||			// Change in autobackcolor
		pCF->_crBackColor != _CF._crBackColor)		//  or backcolor
	{
		iValue = 0;									// Default autobackcolor
		if(!(dwEffects & CFE_AUTOBACKCOLOR))		// Make that back color
			iValue = LookupColor(pCF->_crBackColor) + 1;
		if(!PutCtrlWord(CWF_VAL, i_highlight, iValue))
			goto CleanUp;
	}

	if (pCF->_lcid		!= _CF._lcid &&
		!PutCtrlWord(CWF_VAL, i_lang, LANGIDFROMLCID((WORD)pCF->_lcid)) ||
		pCF->_sSpacing	!= _CF._sSpacing &&
		!PutCtrlWord(CWF_VAL, i_expndtw, pCF->_sSpacing)		||
		/* FUTURE (alexgo): This code is incorrect and we don't
		yet handle the Style table.  We may want to support this
		better in a future version.
		pCF->_sStyle	!= _CF._sStyle && pCF->_sStyle > 0  &&
		!PutCtrlWord(CWF_VAL, i_cs, pCF->_sStyle)			|| */
		pCF->_bAnimation	!= _CF._bAnimation &&
		!PutCtrlWord(CWF_VAL, i_animtext, pCF->_bAnimation)	||
		/* FUTURE (alexgo): this code doesn't work yet, as we don't
		output the revision table.  We may want to support this 
		better in a future version
		pCF->_bRevAuthor!= _CF._bRevAuthor &&
		!PutCtrlWord(CWF_VAL, i_revauth, pCF->_bRevAuthor)	|| */
		pCF->_wKerning	!= _CF._wKerning &&
		!PutCtrlWord(CWF_VAL, i_kerning, pCF->_wKerning/10) )
	{
		goto CleanUp;
	}

	// Handle all underline types.  Special underline types (nonzero high
	// nibble in CCharFormat::_bUnderlineType) are considered to be no
	// underline and have their UType set equal to 0 above and underline
	// effect bits reset to 0.
	if ((dwChanges & CFM_UNDERLINE) ||
		(dwEffects & CFE_UNDERLINE)	&& UType1 != UType2)
	{
		dwChanges &= ~CFE_UNDERLINE;				// Suppress underline
		i = dwEffects & CFE_UNDERLINE ? UType2: 0;	//  action in next for()
		if(!PutCtrlWord(CWF_STR, rgiszUnderlines[i]))					
			goto CleanUp;						
	}
													// This must be before next stuff
	if(dwChanges & (CFM_SUBSCRIPT | CFM_SUPERSCRIPT))//  change in sub/sup
	{												// status	
	 	i_sz = dwEffects & CFE_SUPERSCRIPT ? i_super
	    	 : dwEffects & CFE_SUBSCRIPT   ? i_sub
	       	 : i_nosupersub;
     	if(!PutCtrlWord(CWF_STR, i_sz))
			goto CleanUp;
	}

	if(dwChanges & CFE_DELETED)						// Insert deleted at high
	{												//  end of bit string
		dwChanges |= CFE_REVISED << 1;
		if(dwEffects & CFE_DELETED)
			dwEffects |= CFE_REVISED << 1;
	}

	dwChanges &= ((1 << CEFFECTS) - 1) & ~CFE_LINK;	// Output keywords for
	for(i = CEFFECTS;								//  effects that changed
		dwChanges && i--;							// rgszEffects[] contains
		dwChanges >>= 1, dwEffects >>= 1)			//  effect keywords in
	{												//  order max CFE_xx to
		if(dwChanges & 1)							//  min CFE-xx
		{											// Change from last call
			iValue = dwEffects & 1;					// If effect is off, write
			iFormat = iValue ? CWF_STR : CWF_VAL;	//  a 0; else no value
			if(!PutCtrlWord(iFormat,
				rgiszEffects[i], iValue))
					goto CleanUp;
		}
	}

	if(yOffset != _CF._yOffset)						// Change in base line 
	{												// position 
		yOffset /= 10;								// Default going to up
		i_sz = i_up;
		iFormat = CWF_VAL;
		if(yOffset < 0)								// Make that down
		{
			i_sz = i_dn;
			yOffset = -yOffset;
		}
		if(!PutCtrlWord(iFormat, i_sz, yOffset))
			goto CleanUp;
	}

	if (pCF->_bPitchAndFamily != _CF._bPitchAndFamily || // Change in font
		pCF->_bCharSet		  != _CF._bCharSet		  ||
		pCF->_iFont			  != _CF._iFont)
	{
		iValue = LookupFont(pCF);
		if(iValue < 0 || !PutCtrlWord(CWF_VAL, i_f, iValue))
			goto CleanUp;

		// RichEdit encodes the current direction in bCharSet, but Word likes
		// to know explicitly, so output the appropriate choice of \rtlch or
		// \ltrch if the direction changes
		BOOL fRTLCharSet = IsRTLCharSet(pCF->_bCharSet);

		if (fRTLCharSet != IsRTLCharSet(_CF._bCharSet) &&
			!PutCtrlWord(CWF_STR, fRTLCharSet ? i_rtlch : i_ltrch))
		{
			goto CleanUp;
		}
	}

	if (pCF->_yHeight != _CF._yHeight)					// Change in font size
	{
		iValue = (pCF->_yHeight + (pCF->_yHeight > 0 ? 5 : -5))/10;
		if(!PutCtrlWord(CWF_VAL, i_fs, iValue))
			goto CleanUp;
	}

	_CF = *pCF;									// Update previous CCharFormat

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteParaFormat(prtp)
 *
 *	@mfunc
 *		Write out attributes specified by the CParaFormat <p pPF> relative
 *		to para defaults (probably produces smaller output than relative to
 *		previous para format and let's you redefine tabs -- no RTF kill
 *		tab command	except \\pard)
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteParaFormat(
	const CRchTxtPtr * prtp)	//@parm Ptr to rich-text ptr at current cp
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteParaFormat");

	Assert(_ped);

	//if(!_fRangeHasEOP)							// Don't write para info if
	//	return _ecParseError;					//  range has no EOPs

	const CParaFormat * pPFPrev = _pPF;
	const CParaFormat * pPF = _pPF = prtp->GetPF();
	BOOL	fInTable = pPF->InTable();
	LONG	c;					  				// Temporary count
	LONG	cTab = pPF->_bTabCount;
	DWORD	dwEffects;
	DWORD	dwRule	= pPF->_bLineSpacingRule;
	LONG	dy		= pPF->_dyLineSpacing;
	LONG	i_t, i, j, k;
	LONG	tabAlign, tabLead, tabPos;
	LONG	lDocDefaultTab = _ped->GetDefaultTab();
	const LONG *prgxTabs = NULL;

	if(!lDocDefaultTab)
		lDocDefaultTab = lDefaultTab;

	CheckInTable(FALSE);
	if(fInTable)
		cTab = 0;								// Suppress \tab output

	AssertSz(cTab >= 0 && cTab <= MAX_TAB_STOPS,
		"CRTFW::WriteParaFormat: illegal cTabCount");

	// EVIL HACK ALERT! - Exchange's IMC keys on the \protect tag when it does
	//	its reply-ticking for mail being sent to Internet recipients.  
	//	Paragraphs following a \pard and containing a \protect tag are 
	//	reply-ticked, so we must ensure that each \pard in a protected range
	//	is followed by a \protect tag.

	if (_CF._dwEffects & CFE_PROTECTED && !PutCtrlWord(CWF_VAL, i_protect, 0) ||
		!PutCtrlWord(CWF_STR, i_pard) ||			// Reset para attributes
		_CF._dwEffects & CFE_PROTECTED && !PutCtrlWord(CWF_STR, i_protect))
	{
		goto CleanUp;
	}

	if(fInTable)
	{
		if(_fRangeHasEOP && !PutCtrlWord(CWF_STR, i_intbl))
			goto CleanUp;
	}
	else if(PutBorders(FALSE))
		goto CleanUp;

	if(pPF->_wShadingStyle)
	{
		i = pPF->_wShadingStyle & 15;				// Shading patterns
		j = (pPF->_wShadingStyle >> 6) & 31;			// Shading forecolor
		k = pPF->_wShadingStyle >> 11;				// Shading backcolor
		if (i && i <= CSHADINGSTYLES &&
			!PutCtrlWord(CWF_STR, rgiszShadingStyles[i - 1]) ||
			j && !PutCtrlWord(CWF_VAL, i_cfpat, LookupColor(g_Colors[j-1]) + 1) ||
			k && !PutCtrlWord(CWF_VAL, i_cbpat, LookupColor(g_Colors[k-1]) + 1))
		{
			goto CleanUp;
		}
	}
	if(pPF->_wShadingWeight && !PutCtrlWord(CWF_VAL, i_shading, pPF->_wShadingWeight))
		goto CleanUp;

	// Paragraph numbering
	_fBullet = _fBulletPending = FALSE;
	_nNumber = pPF->UpdateNumber(_nNumber, pPFPrev);

	if(pPF->_wNumbering)							// Write numbering info
	{
		LONG iFont = _symbolFont;
		WORD wStyle = pPF->_wNumberingStyle & 0xF00;

		if(pPF->IsListNumbered())
		{
			const CCharFormat *pCF;
			WCHAR szNumber[CCHMAXNUMTOSTR];

			CTxtPtr		  rpTX(prtp->_rpTX);
			CFormatRunPtr rpCF(prtp->_rpCF);

			rpCF.AdvanceCp(rpTX.FindEOP(tomForward));
			rpCF.AdjustBackward();
			pCF = _ped->GetCharFormat(rpCF.GetFormat());
			iFont = LookupFont(pCF);
			if(iFont < 0)
			{
				iFont = 0;
				TRACEERRORSZ("CWRTFW::WriteParaFormat: illegal bullet font");
			}
			_nFont = iFont;
			// TODO: make the following smarter, i.e., may need to increment
			// _nNumber instead of resetting it to 1.
			_cpg = GetCodePage(pCF->_bCharSet);

			i = 0;
			if(pPF->_wNumbering <= tomListNumberAsUCRoman)
				i = pPF->_wNumbering - tomListNumberAsArabic;

			WCHAR ch = (wStyle == PFNS_PARENS || wStyle == PFNS_PAREN) ? ')'
					 : (wStyle == PFNS_PERIOD) ? '.' : 0;
			if(wStyle != PFNS_NONUMBER)			  // Unless number suppressed
			{									  //  write \pntext group
				pPF->NumToStr(szNumber, _nNumber, fRtfWrite);
				if (!printF(szBeginNumberGroup, iFont) ||
					WritePcData(szNumber, _cpg, FALSE) ||	
					!printF(szEndNumberGroup))
				{
					goto CleanUp;
				}
			}
			j = pPF->_wNumberingStyle & 3;
			if (!printF(szBeginNumberFmt,
						wStyle == PFNS_NONUMBER ? "cont" : "body",
						iFont, pPF->_wNumberingTab,
						pPF->_wNumberingStart)				||
				IN_RANGE(1, j, 2) && !PutCtrlWord(CWF_STR,
								j == 1 ? i_pnqc : i_pnqr)	||
				!PutCtrlWord(CWF_STR, rgiszNumberStyle[i])	||
				wStyle == PFNS_PARENS && !printF(szpntxtb)	||
				ch && !printF(szpntxta, ch)					||
				!printF(szEndGroupCRLF))
			{
				goto CleanUp;
			}
		}
		else
		{
			if (!printF(szBulletGroup, iFont) ||
				!printF(szBulletFmt,
						wStyle == PFNS_NONUMBER ? "cont" : "blt",
						iFont, pPF->_wNumberingTab))
			{
				goto CleanUp;
			}
		}
		_fBullet = TRUE;
	}

	dwEffects = pPF->_wEffects & ((1 << CPFEFFECTS) - 1);
	if (_ped->IsBiDi() && !(dwEffects & PFE_RTLPARA) &&
		!PutCtrlWord(CWF_STR, i_ltrpar))		//ltrpar attribute
	{
		goto CleanUp;
	}

	for(c = CPFEFFECTS; dwEffects && c--;		// Output PARAFORMAT2 effects
		dwEffects >>= 1)	
	{
		// rgiszPFEffects[] contains PF effect keywords in the
		//  order max PFE_xx to min PFE-xx

		AssertSz(rgiszPFEffects[2] == i_hyphpar,
			"CRTFWrite::WriteParaFormat(): rgiszPFEffects is out-of-sync with PFE_XXX");
		// \hyphpar has opposite logic to our PFE_DONOTHYPHEN so we emit
		// \hyphpar0 to toggle the property off

		if (dwEffects & 1 &&
			!PutCtrlWord((c == 2) ? CWF_VAL : CWF_STR, rgiszPFEffects[c], 0))
		{
			goto CleanUp;
		}				
	}
	
	// Put out para indents. RTF first indent = -PF.dxOffset
	// RTF left indent = PF.dxStartIndent + PF.dxOffset

	if(IsHeadingStyle(pPF->_sStyle) && !PutCtrlWord(CWF_VAL, i_s, -pPF->_sStyle-1))
		goto CleanUp;
		
	if(!fInTable &&
	   (pPF->_dxOffset &&
		!PutCtrlWord(CWF_VAL, i_fi, -pPF->_dxOffset)	||
		pPF->_dxStartIndent + pPF->_dxOffset &&
		!PutCtrlWord(CWF_VAL, (pPF->IsRtlPara())
						? i_ri : i_li, pPF->_dxStartIndent + pPF->_dxOffset) ||
		pPF->_dxRightIndent	  &&
		!PutCtrlWord(CWF_VAL, (pPF->IsRtlPara())
						? i_li : i_ri, pPF->_dxRightIndent)	||
		pPF->_dySpaceBefore	  &&
		!PutCtrlWord(CWF_VAL, i_sb, pPF->_dySpaceBefore) ||
		pPF->_dySpaceAfter	  &&
		!PutCtrlWord(CWF_VAL, i_sa, pPF->_dySpaceAfter)))
	{
		goto CleanUp;
	}

	if(dwRule)									// Special line spacing active
	{
		i = 0;									// Default "At Least" or
		if (dwRule == tomLineSpaceExactly)		//  "Exactly" line spacing
			dy = -abs(dy);						// Use negative for "Exactly"

		else if(dwRule == tomLineSpaceMultiple)	// RichEdit uses 20 units/line
		{										// RTF uses 240 units/line
			i++;
			dy *= 12;							
		}

		else if (dwRule != tomLineSpaceAtLeast && dy > 0)
		{
			i++;								// Multiple line spacing
			if (dwRule <= tomLineSpaceDouble)	// 240 units per line
				dy = 120 * (dwRule + 2);
		}
		if (!PutCtrlWord(CWF_VAL, i_sl, dy) ||
			!PutCtrlWord(CWF_VAL, i_slmult, i))
		{
			goto CleanUp;
		}
	}

	if (!fInTable && IN_RANGE(PFA_RIGHT, pPF->_bAlignment, PFA_JUSTIFY) &&
		!PutCtrlWord(CWF_STR, rgiszAlignment[pPF->_bAlignment - 1]))
	{
		goto CleanUp;
	}

	prgxTabs = pPF->GetTabs();
	for (i = 0; i < cTab; i++)
	{
		pPF->GetTab(i, &tabPos, &tabAlign, &tabLead, prgxTabs);
		AssertSz (tabAlign <= tomAlignBar && tabLead <= 5,
			"CRTFWrite::WriteParaFormat: illegal tab leader/alignment");

		i_t = i_tb;								// Default \tb (bar tab)
		if (tabAlign != tomAlignBar)			// It isn't a bar tab
		{
			i_t = i_tx;							// Use \tx for tabPos
			if (tabAlign &&						// Put nonleft alignment
				!PutCtrlWord(CWF_STR, rgiszTabAlign[tabAlign-1]))
			{
				goto CleanUp;
			}
		}
		if (tabLead &&							// Put nonzero tab leader
			!PutCtrlWord(CWF_STR, rgiszTabLead[tabLead-1]) ||
			!PutCtrlWord(CWF_VAL, i_t, tabPos))
		{
			goto CleanUp;
		}
	}

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteText(cwch, lpcwstr, nCodePage, fIsDBCS)
 *
 *	@mfunc
 *		Write out <p cwch> chars from the Unicode text string <p lpcwstr> taking care to
 *		escape any special chars.  The Unicode text string is scanned for characters which
 *		map directly to RTF strings, and the surrounding chunks of Unicode are written
 *		by calling WriteTextChunk.
 *
 *	@rdesc
 *		EC	The error code
 */
EC CRTFWrite::WriteText(
	LONG		cwch,		//@parm # chars in buffer
	LPCWSTR 	lpcwstr,	//@parm Pointer to text
	INT			nCodePage,	//@parm Code page to use to convert to DBCS
	BOOL		fIsDBCS)	//@parm If TRUE, lpcwstr is DBCS string 
							//		stuffed into a WSTR
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteText");

	WCHAR *pwchScan;
	WCHAR *pwchStart;

	if(_fBulletPending)
	{
		_fBulletPending = FALSE;
		if(!_nNumber)
		{
			if(!printF(szBulletGroup, _symbolFont))
				goto CleanUp;
		}
		else if(!_pPF->IsNumberSuppressed())
		{
			WCHAR szNumber[CCHMAXNUMTOSTR];
			_pPF->NumToStr(szNumber, ++_nNumber, fRtfWrite);
			if (!printF(szBeginNumberGroup, _nFont) ||
				WritePcData(szNumber, _cpg, FALSE)	||
				!printF(szEndNumberGroup))
			{
				goto CleanUp;
			}
		}
	}
	if(_fCheckInTable)
	{
		CheckInTable(TRUE);
		if(_ecParseError)
			goto CleanUp;
	}

	pwchScan = const_cast<LPWSTR>(lpcwstr);
	pwchStart = pwchScan;
	if(_CF._bCharSet == SYMBOL_CHARSET)
	{
		pwchScan += cwch;
		cwch = 0;
	}

	// Step through the Unicode buffer, weeding out characters that have  
	// known translations to RTF strings
	while(cwch-- > 0)
	{
		WCHAR	wch = *pwchScan;

		// If this is a string for which the MultiByteToUnicode conversion
		// failed, the buffer will be filled with ANSI bytes stuffed into
		// wchar's (one per).  In this case, we don't want to map trail bytes
		// to RTF strings.
		if(fIsDBCS && GetTrailBytesCount(wch, nCodePage) && nCodePage != CP_UTF8)
		{
			// If we have more characters in the buffer, then this is the
			// DBC pair.  Otherwise, treat it as single character.
			if(cwch > 0)
			{
				cwch--;
				pwchScan += 2;
				continue;
			}
		}

		// if the char is one for which there is an appropriate RTF string
		// write the preceding chars and output the RTF string

		if(!IN_RANGE(' ', wch, 'Z') &&
		   !IN_RANGE('a', wch, 'z') &&
		   !IN_RANGE(chOptionalHyphen + 1, wch, ENSPACE - 1) &&
		   wch <= BULLET &&
		   MapsToRTFKeywordW(wch))
		{
			if (pwchScan != pwchStart &&
				WriteTextChunk(pwchScan - pwchStart, pwchStart, nCodePage, 
									fIsDBCS))
			{
				goto CleanUp;
			}

			// map the char(s) to the RTF string
			int cwchUsed = MapToRTFKeyword(pwchScan, cwch, MAPTOKWD_UNICODE);

			cwch -= cwchUsed;
			pwchScan += cwchUsed;

			// start of next run of unprocessed chars is one past current char
			pwchStart = pwchScan + 1;
			if(cwch && _fCheckInTable)
			{
				_fCheckInTable = FALSE;
				if(!PutCtrlWord(CWF_STR, i_intbl))
					goto CleanUp;
			}
		}
		pwchScan++;
	}

	// write the last chunk
	if (pwchScan != pwchStart &&
		WriteTextChunk(pwchScan - pwchStart, pwchStart, nCodePage, fIsDBCS))
	{
		goto CleanUp;
	}

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteTextChunk(cwch, lpcwstr, nCodePage, fIsDBCS)
 *
 *	@mfunc
 *		Write out <p cwch> chars from the Unicode text string <p lpcwstr> taking care to
 *		escape any special chars.  Unicode chars which cannot be converted to
 *		DBCS chars using the supplied codepage, <p nCodePage>, are written using the
 *		\u RTF tag.
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteTextChunk(
	LONG		cwch,					//@parm # chars in buffer
	LPCWSTR 	lpcwstr,				//@parm Pointer to text
	INT			nCodePage,				//@parm code page to use to convert to DBCS
	BOOL		fIsDBCS)				//@parm indicates whether lpcwstr is a Unicode string
										//		or a DBCS string stuffed into a WSTR
{
	// FUTURE(BradO):  There is alot of commonality b/t this routine and
	//	WritePcData.  We should re-examine these routines and consider 
	//	combining them into a common routine.

	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteTextChunk");

	BYTE 	b;
	LONG	cbAnsi;
	LONG	cbAnsiBufferSize;
	LONG	cbChar;
	UINT	ch;
	BOOL 	fMissingCodePage = FALSE;
	BOOL	fMultiByte;
	BOOL 	fUsedDefault = FALSE;
	BYTE *	pbAnsi;
	BYTE *	pbAnsiBuffer;

	// When WideCharToMultiByte fails to convert a char, the following default
	// char is used as a placeholder in the string being converted
	const char chToDBCSDefault = 0;

	// Allocate temp buffer for ANSI text we convert to
	cbAnsiBufferSize = cachBufferMost * (nCodePage == CP_UTF8 ? 3 : MB_LEN_MAX);
	if (!_pbAnsiBuffer)
	{
		// If the code page was CP_UTF8, it will always be CP_UTF8 for this instance
		_pbAnsiBuffer = (BYTE *)PvAlloc(cbAnsiBufferSize, GMEM_FIXED);
		if (!_pbAnsiBuffer)
			goto RAMError;
	}
	pbAnsiBuffer = _pbAnsiBuffer;

	// Convert Unicode (or fIsDBCS) buffer to ANSI 
	if(fIsDBCS)
	{
		// Supply some bogus code page which will force direct conversion
		// from wchar to bytes (losing high byte of wchar).
		// Also, don't want to use default char replacement in this case.
		cbAnsi = WCTMB(INVALID_CODEPAGE, 0, lpcwstr, cwch, 
						(char *)pbAnsiBuffer, cbAnsiBufferSize,
						NULL, NULL, NULL);
	}
	else
	{
		cbAnsi = WCTMB(nCodePage, 0, lpcwstr, cwch, 
						(char *)pbAnsiBuffer, cbAnsiBufferSize,
						&chToDBCSDefault, &fUsedDefault,
						&fMissingCodePage);
	}
	Assert(cbAnsi > 0);

	pbAnsi = pbAnsiBuffer;
	fMultiByte = (cbAnsi > cwch) || fIsDBCS || fMissingCodePage;

	while (!_ecParseError && cbAnsi-- > 0)
	{
		b = *pbAnsi;
		ch = *lpcwstr;

		// Compare ASCII chars to their Unicode counterparts to check
		// that we're in sync
		AssertSz(cwch <= 0 || ch > 127 || b == ch, 
			"CRTFWrite::WriteText: Unicode and DBCS strings out of sync");

		// If _fNCRForNonASCII, output the \uN tag for all nonASCII chars.
		// This is useful because many Unicode chars that aren't in the
		// target codepage are converted by WideCharToMultiByte() to some
		// "best match char" for the codepage, e.g., alpha (0x3B1) converts
		// to 'a' for cpg 1252.
		//
		// For NT 5, we use WC_NO_BEST_FIT_CHARS, which causes our regular
		// algorithm to output \uN values whenever the system cannot convert
		// a character correctly. This still requires readers that can handle
		// multicodepage RTF, which is problematic for some RTF-to-HTML
		// converters.
		if(!IN_RANGE(' ', b, 'z') && MapsToRTFKeywordA(b))
		{
			int cchUsed = MapToRTFKeyword(pbAnsi, cbAnsi, MAPTOKWD_ANSI);
			cbAnsi -= cchUsed;
			pbAnsi += cchUsed;
			lpcwstr += cchUsed;
			cwch -= cchUsed;
		}
		else if(nCodePage == CP_UTF8)
		{
			PutChar(b);								// Output 1st byte in any
			if(b >= 0xC0)							//  case. At least 2-byte
			{										// At least 2-byte lead
				pbAnsi++;							//  byte, so output a
				Assert(cbAnsi && IN_RANGE(0x80, *pbAnsi, 0xBF));
				cbAnsi--;							//  trail byte
				PutChar(*pbAnsi);
				if(b >= 0xE0)						// 3-byte lead byte, so
				{									//  output another trail
					pbAnsi++;						//  byte
					Assert(cbAnsi && IN_RANGE(0x80, *pbAnsi, 0xBF));
					cbAnsi--;
					PutChar(*pbAnsi);
				}
			}
		}
		else
		{
			cbChar = fMultiByte && cbAnsi && GetTrailBytesCount(b, nCodePage)
				   ? 2 : 1;
			if(ch >= 0x80 && !fIsDBCS && _fNCRForNonASCII && nCodePage != CP_SYMBOL)
			{									// Output /uN for nonASCII
				if(cbChar != _cbCharLast)
				{
					_cbCharLast = cbChar;		// cb to follow /uN
					if(!PutCtrlWord(CWF_VAL, i_uc, cbChar))
						goto CleanUp;
				}
				if(!PutCtrlWord(CWF_VAL, i_u, ch))
					goto CleanUp;
				Assert(chToDBCSDefault != '?');
				if(fUsedDefault)				// Don't output another /uN
				{								//  below
					b = '?';					
					_fNeedDelimeter = FALSE;
				}
			}
			if(cbChar == 2)
			{
				pbAnsi++;						// Output DBCS pair
				cbAnsi--;
				if(fIsDBCS)
				{
					lpcwstr++;
					cwch--;
				}
				printF(szEscape2CharFmt, b, *pbAnsi);
			}
			else 
			{
				if(b == chToDBCSDefault && fUsedDefault)
				{
					// WideCharToMultiByte() couldn't complete a conversion so it
					// used the default char we provided (0) used as a placeholder.
					// In this case we want to output the original Unicode char.
					if(!PutCtrlWord(CWF_VAL, i_u, (cwch > 0 ? ch : TEXT('?'))))
						goto CleanUp;

					_fNeedDelimeter = FALSE;
					if(!PutChar('?'))
						goto CleanUp;
				}
				else if(!IN_RANGE(32, b, 127))
					printF(szEscapeCharFmt, b);

				else
					PutChar(b);
 			}
		}
		pbAnsi++;
		lpcwstr++;
		cwch--;
	}
	goto CleanUp;

RAMError:
	_ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecNoMemory;

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteInfo()
 *
 *	@mfunc
 *		Write out Far East specific data.
 *
 *	@rdesc
 *		EC				The error code
 */
EC CRTFWrite::WriteInfo()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteInfo");

	// TODO(BradO):  Ultimately it would be nice to set some kind of
	//	fRTFFE bit to determine whether to write \info stuff.  For now,
	//	we rely on the fact that lchars and fchars info actually exists
	//	to determine whether to write out the \info group.

#ifdef UNDER_WORK
	if (!(_dwFlags & fRTFFE)	||					// Start doc area
		!PutCtrlWord(CWF_GRP, i_info)	||
		!printF("{\\horzdoc}"))
			goto CleanUp;

	// Write out punctuation character info

	CHAR	sz[PUNCT_MAX];
	if(UsVGetPunct(_ped->lpPunctObj, PC_FOLLOWING, sz, sizeof(sz))
					> PUNCT_MAX - 2)
		goto CleanUp;

	if(!Puts("{\\*\\fchars") || WritePcData(sz) || !PutChar(chEndGroup))
		goto CleanUp;
	
	if(UsVGetPunct(ped->lpPunctObj, PC_LEADING, sz, sizeof(sz)) > PUNCT_MAX+2)
		goto CleanUp;

	if(!Puts("{\\*\\lchars") || WritePcData(sz) || !PutChar(chEndGroup))
		goto CleanUp;

	Puts(szEndGroupCRLF);							// End info group

#endif

	LPSTR lpstrLeading = NULL;
	LPSTR lpstrFollowing = NULL;

	// If either succeeds (but evaluate both)
	if(((_ped->GetLeadingPunct(&lpstrLeading) == NOERROR) +
		(_ped->GetFollowingPunct(&lpstrFollowing) == NOERROR)) &&
		(lpstrLeading || lpstrFollowing))
	{
		if (!PutCtrlWord(CWF_GRP, i_info) ||
			!Puts(szHorzdocGroup, sizeof(szHorzdocGroup) - 1))
		{
			goto CleanUp;
		}
		if (lpstrLeading &&
			(!PutCtrlWord(CWF_AST, i_lchars) || 
			 !Puts(lpstrLeading, strlen(lpstrLeading)) ||
			 !PutChar(chEndGroup)))
		{
			goto CleanUp;
		}
		if (lpstrFollowing &&
			(!PutCtrlWord(CWF_AST, i_fchars) || 
			 !Puts(lpstrFollowing, strlen(lpstrFollowing)) ||
			 !PutChar(chEndGroup)))
		{
			goto CleanUp;
		}
		Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF) - 1);	// End info group
	}

CleanUp:
	return _ecParseError;
}

/*
 *	CRTFWrite::WriteRtf()
 *
 *	@mfunc
 *		Write range _prg to output stream _pes.
 *
 *	@rdesc
 *		LONG	Number of chars inserted into text; 0 means none were
 *				inserted, OR an error occurred.
 */
LONG CRTFWrite::WriteRtf()
{
	TRACEBEGIN(TRCSUBSYSRTFW, TRCSCOPEINTERN, "CRTFWrite::WriteRtf");

	LONG			cch, cchBuffer;
	LONG			cchCF, cchPF;
	LONG			cchT;
	LONG			cpMin, cpMost;
	BOOL 			fOutputEndGroup;
	LONG			i, j;
	LONG			lDocDefaultTab;
	TCHAR *			pch;
	TCHAR *			pchBuffer;
	CTxtEdit *		ped = _ped;
	CDocInfo *		pDocInfo = ped->GetDocInfo();
	CRchTxtPtr		rtp(*_prg);
	WORD			wCodePage = CP_ACP;

	AssertSz(_prg && _pes, "CRTFW::WriteRtf: improper initialization");

	cch = _prg->GetRange(cpMin, cpMost);		// Get rtp = cpMin, cch > 0
	rtp.SetCp(cpMin);

	_fRangeHasEOP = _prg->fHasEOP();			// Maintained for Selection

	if(!_prg->IsSel())							// Validate range for RTF
	{											//  writing. Don't write
		CPFRunPtr rp(rtp);						//  partial table row unless
		CTxtPtr tp(rtp._rpTX);					//  no CELLs are included
		LONG	Results;

		_fRangeHasEOP = tp.IsAtEOP();
		if(tp.FindEOP(cch, &Results))			// Need to get CELL info too
			 _fRangeHasEOP = TRUE;

		if(rtp.InTable())
		{
			tp.SetCp(cpMin);						
			if(!_fRangeHasEOP)					// Partial row
			{
				if(Results & FEOP_CELL)			// Has 1 or more CELLs
				{
					while(tp.GetCp() < cpMost)	// Stop at first CELL
					{
						if(tp.GetChar() == CELL)
						{
							cch = tp.GetCp() - cpMin;
							break;
						}
						tp.AdvanceCp(1);
					}
				}
			}
			else if(!tp.IsAfterEOP())   
			{									// Move back to start of row
				rtp.Advance(tp.FindEOP(tomBackward));
				cch += cpMin - rtp.GetCp();
			}
		}
		if(_fRangeHasEOP)						// Check cpMost for table
		{
			rp.AdvanceCp(cpMost - cpMin);		// Go to cpMost
			if(rp.InTable())
			{
				tp.SetCp(cpMost);
				cch += tp.FindEOP(tomForward);	// Include whole row
			}
		}
	}

	// Allocate buffers for text we pick up and for RTF output
	pchBuffer = (TCHAR *) PvAlloc(cachBufferMost * (sizeof(TCHAR) + 1) + 1,
								 GMEM_FIXED);	// Final 1 is for debug
	if(!pchBuffer)
	{
		fOutputEndGroup = FALSE;
		goto RAMError;
	}
	_pchRTFBuffer = (CHAR *)(pchBuffer + cachBufferMost);

	_pchRTFEnd = _pchRTFBuffer;				// Initialize RTF buffer ptr
	_cchBufferOut = 0;						//  and character count
	_cchOut = 0;							//  and character output

	// Determine the \ansicpgN value
	if(!pDocInfo)
	{
		fOutputEndGroup = TRUE;
		goto RAMError;
	}

	BOOL fNameIsDBCS;
	if (BuildTables(rtp._rpCF, rtp._rpPF, cch, fNameIsDBCS))
		goto CleanUp;

	wCodePage = (_dwFlags & SF_USECODEPAGE)
			  ? HIWORD(_dwFlags) : pDocInfo->wCpg;

	if (fNameIsDBCS && wCodePage == CP_UTF8)
	{
		// Cannot have UTF8 if we have any run containing broken DBCS.
		// Default back to regular rtf
		wCodePage = pDocInfo->wCpg;
		_dwFlags &= ~SF_USECODEPAGE;
	}

	// Start RTF with \rtfN, \urtfN, or \pwdN group
	i =	(_dwFlags & SF_RTFVAL) >> 16;
	if (!PutCtrlWord(CWF_GRV,
			(wCodePage == CP_UTF8) ? i_urtf :
			(_dwFlags & SFF_PWD)   ? i_pwd  : i_rtf, i + 1) ||
		ped->IsBiDi() && !Puts("\\fbidis", 7) ||
		!PutCtrlWord(CWF_STR, i_ansi)) 
	{
		goto CleanUpNoEndGroup;
	}

	if (wCodePage != tomInvalidCpg && wCodePage != CP_ACP &&
		!PutCtrlWord(CWF_VAL, i_ansicpg, wCodePage == CP_UTF8 ? pDocInfo->wCpg : wCodePage))
	{
		goto CleanUp;
	}

	if(!printF(szDefaultFont))
		goto CleanUp;

	LCID	lcid;
	LANGID	langid;

	if (_ped->GetDefaultLCID(&lcid) == NOERROR && 
		lcid != tomInvalidLCID && (langid = LANGIDFROMLCID(lcid)) &&
		!PutCtrlWord(CWF_VAL, i_deflang, langid))
	{
		goto CleanUp;
	}

	if (_ped->GetDefaultLCIDFE(&lcid) == NOERROR && 
		lcid != tomInvalidLCID && (langid = LANGIDFROMLCID(lcid)) &&
		!PutCtrlWord(CWF_VAL, i_deflangfe, langid))
	{
		goto CleanUp;
	}

	LONG	lDocType;
	_ped->GetDocumentType(&lDocType);
	if (lDocType && _ped->IsBiDi() &&
		!PutCtrlWord(CWF_STR, lDocType == DT_RTLDOC ? i_rtldoc : i_ltrdoc))
	{
		goto CleanUp;
	}

	lDocDefaultTab = pDocInfo->dwDefaultTabStop;
	if(!lDocDefaultTab)
		lDocDefaultTab = lDefaultTab;

	if (lDocDefaultTab != 720 && !PutCtrlWord(CWF_VAL, i_deftab, lDocDefaultTab) ||
		WriteFontTable() || WriteColorTable())
	{
		goto CleanUp;
	}

	if(_nHeadingStyle)
	{
		if(!PutCtrlWord(CWF_GRP, i_stylesheet) || !printF(szNormalStyle))
			goto CleanUp;
		
		for(i = 1; i < -_nHeadingStyle; i++)
		{
			if(!printF(szHeadingStyle, i, i))
				goto CleanUp;
		}
		Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF) - 1); // End font table group
	}
	
	LRESULT lres;
	_ped->GetViewKind(&lres);
	_ped->GetViewScale(&j);
	if (WriteInfo() ||
		_fRangeHasEOP && !PutCtrlWord(CWF_VAL, i_viewkind, lres) ||
		(_dwFlags & SFF_PERSISTVIEWSCALE) && j != 100 &&
		!PutCtrlWord(CWF_VAL, i_viewscale, j))
	{
		goto CleanUp;
	}

	// Write Unicode character byte count for use by entire document (since
	// we don't use \plain's and since \ucN behaves as a char formatting tag,
	// we're safe outputting it only once).
	if(!PutCtrlWord(CWF_VAL, i_uc, iUnicodeCChDefault))
		goto CleanUp;

	while (cch > 0)
	{
		// Get next run of chars with same para formatting
		cchPF = rtp.GetCchLeftRunPF();
		cchPF = min(cchPF, cch);

		AssertSz(cchPF, "CRTFW::WriteRtf: Empty para format run!");

		if(WriteParaFormat(&rtp))			// Write paragraph formatting
			goto CleanUp;

		while (cchPF > 0)
		{
			// Get next run of characters with same char formatting
			cchCF = rtp.GetCchLeftRunCF();
			cchCF = min(cchCF, cchPF);
			AssertSz(cchCF, "CRTFW::WriteRtf: Empty char format run!");

			const CCharFormat *	pCF = rtp.GetCF();

			if (WriteCharFormat(pCF))		// Write char attributes
				goto CleanUp;

			INT nCodePage = CP_UTF8;
			if(!IsUTF8)
			{
				if(IsPrivateCharSet(pCF->_bCharSet))
					nCodePage = 1252;		// Force \uN's
				else
				{
					nCodePage = GetCodePage(pCF->_bCharSet);
					if(nCodePage == CP_ACP && (_dwFlags & SF_USECODEPAGE))
						nCodePage = HIWORD(_dwFlags);
				}
			}

			while (cchCF > 0)
			{
				cchBuffer = min(cachBufferMost, cchCF);
				// FUTURE: since this routine only reads the backing store
				// and GetText only reads it, we can avoid allocating the
				// buffer and use CTxtPtr::GetPch() directly as in
				// CMeasurer::Measure()
				cchBuffer = rtp._rpTX.GetText(cchBuffer, pchBuffer);
				pch  = pchBuffer;
				cchT = cchBuffer;  
				if(cchT > 0)					
				{								
					TCHAR * pchWork = pch;
					LONG    cchWork = cchT;
					LONG	cchTWork;
					LONG	cp = rtp.GetCp();

					while (cchWork >0)
					{
						cchT = cchWork ;
						pch = pchWork;
						while (cchWork > 0 )	// search for objects
						{
							if(*pchWork++ == WCH_EMBEDDING) 
								break;			// Will write out object
							cchWork--;
						}

						cchTWork = cchT - cchWork;
						if(cchTWork)			// write text before object
						{							
							if(WriteText(cchTWork, pch, nCodePage, 
									(pCF->_dwEffects & CFE_RUNISDBCS)))
							{
								goto CleanUp;
							}
						}
						cp += cchTWork;
						if(cchWork > 0)			// there is an object
						{
							COleObject *pobj;

							Assert(_ped->GetObjectMgr());

							pobj = _ped->GetObjectMgr()->GetObjectFromCp(cp);
							if(!pobj)
								goto CleanUp;

							// First, commit the object to make sure the pres. 
							// caches, etc. are up-to-date.  Don't worry 
							// about errors here.

							pobj->SafeSaveObject();

							if(_fIncludeObjects) 
								WriteObject(cp, pobj);

							else if(!Puts(szObjPosHolder, sizeof(szObjPosHolder) - 1))
								goto CleanUp;

							cp++;
							cchWork--;
						}
					}
				}
				rtp.Advance(cchBuffer);
				cchCF	-= cchBuffer;
				cchPF	-= cchBuffer;
				cch		-= cchBuffer;
			}
		}
	}

CleanUp:
	// End RTF group
	Puts(szEndGroupCRLF, sizeof(szEndGroupCRLF));
	FlushBuffer();

CleanUpNoEndGroup:
	FreePv(pchBuffer);

	if (_ecParseError != ecNoError)
	{
		TRACEERRSZSC("CRTFW::WriteRtf()", _ecParseError);
		Tracef(TRCSEVERR, "Writing error: %s", rgszParseError[_ecParseError]);
		
		if(!_pes->dwError)						// Make error code OLE-like
			_pes->dwError = -abs(_ecParseError);
		_cchOut = 0;
	}
	return _cchOut;

RAMError:
	ped->GetCallMgr()->SetOutOfMemory();
	_ecParseError = ecNoMemory;

	if(fOutputEndGroup)
		goto CleanUp;

	goto CleanUpNoEndGroup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\textsrv2.h ===
/*	@doc EXTERNAL
 *
 *	@module TEXTSRV2.H  Text Service Interface |
 *	
 *	Define new private interface between the Text Services component and the host
 *
 *	History: <nl>
 *		8/1/95	ricksa	Revised interface definition
 *      7/9/99  joseogl Split off from textserv,h because ITextHost2 is undocumented
 */

#ifndef _TEXTSRV2_H
#define _TEXTSRV2_H

EXTERN_C const IID IID_ITextHost2;

/*
 *	class ITextHost2
 *
 *	@class	An optional extension to ITextHost which provides functionality
 *			necessary to allow TextServices to embed OLE objects
 */
class ITextHost2 : public ITextHost
{
public:					//@cmember Is a double click in the message queue?
	virtual BOOL		TxIsDoubleClickPending() = 0; 
						//@cmember Get the overall window for this control	 
	virtual HRESULT		TxGetWindow(HWND *phwnd) = 0;
						//@cmember Set control window to foreground
	virtual HRESULT		TxSetForegroundWindow() = 0;
						//@cmember Set control window to foreground
	virtual HPALETTE	TxGetPalette() = 0;
						//@cmember Get FE flags
	virtual HRESULT		TxGetFEFlags(LONG *pFlags) = 0;
						//@cmember Routes the cursor change to the winhost
	virtual HCURSOR		TxSetCursor2(HCURSOR hcur, BOOL bText) = 0;
						//@cmember Notification that text services is freed
	virtual void		TxFreeTextServicesNotification() = 0;
						//@cmember Get Edit Style flags
	virtual HRESULT		TxGetEditStyle(DWORD dwItem, DWORD *pdwData) = 0;
						//@cmember Get Window Style bits
	virtual HRESULT		TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle) = 0;
};

// Various flags for TxGetEditStyle data
#define TXES_ISDIALOG		1
#endif // _TEXTSRV2_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\textserv.cpp ===
/*
 *  @doc EXTERNAL
 *
 *  @module TEXTSERV.CPP    -- Text Services Implementation |
 *
 *  Original Author: <nl>
 *      Rick Sailor
 *
 *  History: <nl>
 *      8/1/95  ricksa  Created and documented
 *      10/95   murrays Further doc and simplifications
 *
 *  Documentation is generated straight from the code.  The following
 *  date/time stamp indicates the version of code from which the
 *  the documentation was generated.
 *
 *  $Header: /richedit/src/textserv.cpp 53    11/15/95 2:39p Ricksa $
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dispprt.h"
#include "_dispml.h"
#include "_dispsl.h"
#include "_select.h"
#include "_text.h"
#include "_runptr.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_rtext.h"
#include "_urlsup.h"
#include "_magelln.h"
#include "_ols.h"
#include "_clasfyc.h"

#ifndef OBJID_NATIVEOM
#define OBJID_NATIVEOM 0xFFFFFFF0
#endif

// By turning on the PROFILE_TS compiler directive, you tell IceCap2.0
// to turn on profiling for only ITextServices API's.  Typically only
// used during profiling work.
//#define PROFILE_TS
#ifdef PROFILE_TS
#include <icapexp.h>

class CapProfile
{
public:
    CapProfile() { StartCAP(); }
    ~CapProfile() { StopCAP(); }
};

#define START_PROFILING     CapProfile capprf;
#else
#define START_PROFILING
#endif //PROFILE_TS

ASSERTDATA

// Macros to get mouse coordinates out of a message
// need to cast to SHORT first for sign extension
#define MOUSEX  ((INT)(SHORT)LOWORD(lparam))
#define MOUSEY  ((INT)(SHORT)HIWORD(lparam))

LONG ValidateTextRange(TEXTRANGE *pstrg);

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
    ITextServices *pts,
    HDC hdc,
    LONG lZoomNumerator,
    LONG lZoomDenominator,
    LONG yPixelsPerInch,
    LONG *pxAveWidth,
    LONG *pxOverhang,
    LONG *pxUnderhang);

// if there's an active object being dragged around, on WM_PAINT we always
// try to reposition it to there it should be. A not-so-well-behaved object
// my generate another WM_PAINT message in response to that, even if it actually
// did not move. So we limit our number of attempts to reposition it and reset
// this counter every time a mouse moves.
// The corresponding field is declared as :2, so don't try to bump it up
// without allocating more bits!!
#define MAX_ACTIVE_OBJ_POS_TRIES (3)


///////////////////////////// Helper Functions ///////////////////////////////////
/*
 *  ConvertDrawDCMapping(hdcDraw)
 *
 *  @func
 *      Put screen DC in MM_TEXT mapping mode.
 */
void ConvertDrawDCMapping(
    HDC hdcDraw)        //@parm HDC to draw on
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "ConvertDrawDCMapping");

    SaveDC(hdcDraw);
    SetViewportOrgEx(hdcDraw, 0, 0, NULL);
    SetWindowOrgEx(hdcDraw, 0, 0, NULL);
    SetMapMode(hdcDraw, MM_TEXT);
}

/*
 *  BOOL CTxtEdit::LoadMsgFilter(msg, wparam, lparam)
 *
 *  @func
 *      Check if we should load the IME message filter
 *
 *  @rdesc
 *      TRUE - Load it
 *      FALSE - Don't load
 */
BOOL CTxtEdit::LoadMsgFilter(
    UINT    msg,                //@parm Message ID
    WPARAM  wparam,             //@parm Message wparam
    LPARAM  lparam)             //@parm Message lparam
{
    //TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::LoadMsgFilter");

    // For the first ever message, we want to check if
    // our client has created AIMM object for current thread
    if (!_fCheckAIMM)
    {
        DWORD   dwThreadId;
        BOOL    fLoadAimm = FALSE;

        _fCheckAIMM = 1;

        if (W32->fUseAimm())                            // Ini file say use Aimm
            fLoadAimm = TRUE;

        else if (dwThreadId = GetCurrentThreadId())
        {
            char szBuf[20];

            sprintf(szBuf, "AIMM:%08x", dwThreadId);

            if (FindAtomA(szBuf))                       // Atom presented, load Aimm
                fLoadAimm = TRUE;
        }

        if (fLoadAimm)
        {
            HWND    hWnd;

            TxGetWindow( &hWnd );

            if (hWnd)
                PostMessage(hWnd, EM_SETEDITSTYLE, SES_USEAIMM, SES_USEAIMM);
        }
    }

    switch (msg)
    {
        case WM_KEYDOWN:
        case WM_SYSKEYDOWN:
            if ( (WORD) wparam == VK_PROCESSKEY )
                return TRUE;
            break;

        case WM_INPUTLANGCHANGE:
            if (IsFELCID((WORD)(lparam)))
                return TRUE;
            break;

        case EM_SETEDITSTYLE:
            if((lparam & (SES_USEAIMM | SES_NOIME)) ||
                (wparam & (SES_USEAIMM | SES_NOIME)))
                return TRUE;
            break;

        case EM_RECONVERSION:
        case WM_IME_NOTIFY:
        case WM_IME_REQUEST:
        case WM_IME_STARTCOMPOSITION:
        case EM_GETIMEOPTIONS:
        case EM_SETIMEOPTIONS:
        case EM_SETIMECOLOR:
        case EM_GETIMECOLOR:
        case WM_IME_CHAR:
            return TRUE;

        case EM_SETLANGOPTIONS:
            if (lparam & (IMF_IMEALWAYSSENDNOTIFY | IMF_IMECANCELCOMPLETE))
                return TRUE;
            break;

        default:
            if (msg)
            {
                if (msg == MSIMEReconvertMsg || msg == MSIMEDocFeedMsg
                    || msg == MSIMEQueryPositionMsg)
                    return TRUE;
            }
            break;

    }

    return FALSE;
}

/*
 *  CTxtEdit::FormatAndPrint (hdcDraw, hicTargetDev, ptd, lprcBounds,
 *                            lprcWBounds)
 *  @mfunc
 *      Format and Print data in control
 *
 *  @rdesc
 *      S_OK - everything worked
 *      E_FAIL - unexpected failure occurred
 */
HRESULT CTxtEdit::FormatAndPrint(
    HDC hdcDraw,            //@parm HDC to draw on
    HDC hicTargetDev,       //@parm Input information context if any
    DVTARGETDEVICE *ptd,    //@parm Device target information
    RECT *lprcBounds,       //@parm Rectangle to measure
    RECT *lprcWBounds)      //@parm Metafile information
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::FormatAndPrint");

    // Put client rectangle in format structure
    FORMATRANGE fr;
    fr.rc = *lprcBounds;

    // Get number of device units per inch
    LONG xPerInch;
    LONG yPerInch;

    if (NULL == lprcWBounds)
    {
        xPerInch = GetDeviceCaps(hdcDraw, LOGPIXELSX);
        yPerInch = GetDeviceCaps(hdcDraw, LOGPIXELSY);
    }
    else
    {
        //Forms ^3 draws using screen resolution, while OLE specifies HIMETRIC
        xPerInch = fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
        yPerInch = fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

        SetWindowOrgEx(hdcDraw, lprcWBounds->left, lprcWBounds->top, NULL);
        SetWindowExtEx(hdcDraw, lprcWBounds->right, lprcWBounds->bottom, NULL);
    }


    // Convert rectangle into TWIPS
    fr.rc.left = MulDiv(fr.rc.left, LX_PER_INCH, xPerInch);
    fr.rc.top = MulDiv(fr.rc.top, LY_PER_INCH, yPerInch);
    fr.rc.right = MulDiv(fr.rc.right, LX_PER_INCH, xPerInch);
    fr.rc.bottom = MulDiv(fr.rc.bottom, LY_PER_INCH, yPerInch);

    // Use message based printing code to do our printing for us
    fr.hdc = hdcDraw;
    fr.hdcTarget = hicTargetDev;
    fr.rcPage = fr.rc;
    fr.chrg.cpMin = _pdp->GetFirstVisibleCp();
    fr.chrg.cpMost = -1;

    // Assume this is all going to work
    HRESULT hr = S_OK;

    SPrintControl prtcon;
    prtcon._fDoPrint = TRUE;
    prtcon._fPrintFromDraw = TRUE;

    // Print control
    if(OnFormatRange(&fr, prtcon, TRUE) == -1)
    {
        // For some reason the control could not be printed
        hr = E_FAIL;
    }

    return hr;
}

/*
 *  CTxtEdit::RectChangeHelper (pdi, dwDrawAspect, lindex, pvAspect, ptd,
 *                              hdcDraw, hicTargetDev, lprcClient, prcLocal)
 *  @func
 *      Format and Print data in the control
 *
 *  @rdesc
 *      S_OK - everything worked
 *      E_INVALIDARG - client parameter is invalid
 *
 *  @devnote
 *      Caller must release the DC from the display object.
 */
HRESULT CTxtEdit::RectChangeHelper(
    CDrawInfo *pdi,         //@parm Draw information memory
    DWORD    dwDrawAspect,  //@parm Draw aspect
    LONG     lindex,        //@parm Currently unused
    void *   pvAspect,      //@parm Info for drawing optimizations (OCX 96)
    DVTARGETDEVICE *ptd,    //@parm Info on target device
    HDC      hdcDraw,       //@parm Rendering device context
    HDC      hicTargetDev,  //@parm Target information context
    const RECT ** pprcClient,   //@parm New client rectangle
    RECT *   prcLocal)      //@parm Rect to use if previous parm is NULL
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEINTERN, "CTxtEdit::RectChangeHelper");

    HRESULT hr = S_OK;
    BOOL fRestore = FALSE;

    // We assume that if client's rectangle is supplied, it has changed.
    if(pprcClient && *pprcClient)
    {
        // Set up information context if necessary
        HDC hicLocal = NULL;

        // Did they give us a ptd without a hic?
        if(!hicTargetDev && ptd)
        {
            // Create information context for device information,
            // since it wasn't supplied
            hicLocal = CreateIC(
                (TCHAR *)((BYTE *) ptd + ptd->tdDriverNameOffset),
                (TCHAR *)((BYTE *) ptd + ptd->tdDeviceNameOffset),
                (TCHAR *)((BYTE *) ptd + ptd->tdPortNameOffset),
                (DEVMODE *)((BYTE *)  ptd + ptd->tdExtDevmodeOffset));
            if(!hicLocal)
                return E_FAIL;            // Couldn't create it

            hicTargetDev = hicLocal;
        }

        *prcLocal = **pprcClient;           // Define *prcLocal in any case

        // Force DC in MM_TEXT
        if (GetMapMode(hdcDraw) != MM_TEXT &&
            GetDeviceCaps(hdcDraw, TECHNOLOGY) != DT_METAFILE)
        {
            fRestore = TRUE;

            // Convert input parameters to new mapping
            WinLPtoDP(hdcDraw, (POINT *)prcLocal, 2);

            *pprcClient = prcLocal;

            // Convert HDC to new mapping
            ConvertDrawDCMapping(hdcDraw);
        }

        _pdp->SetDC(hdcDraw);           // Set the DC
        _pdp->SetDrawInfo(              // Set the draw info
            pdi,
            dwDrawAspect,
            lindex,
            pvAspect,
            ptd,
            hicTargetDev);

        _pdp->ReDrawOnRectChange(hicTargetDev, *pprcClient);

        if(fRestore)                    // Put DC back into correct
            RestoreDC(hdcDraw, -1);     //  mapping mode

        if(hicLocal)                    // Clean up info context if we
            DeleteDC(hicLocal);         //  created one
    }
    else if (pprcClient && _fInPlaceActive)
    {
        // We can figure out what the client rectangle is.
        TxGetClientRect(prcLocal);
        *pprcClient = prcLocal;
    }
    else                                // If not inplace active, a RECT
        hr = E_INVALIDARG;              //  must be supplied

    return hr;
}

/*
 *  CTxtEdit::SetText (pstr, flags, CodePage)
 *
 *  @mfunc  sets the text in the document, clearing out any existing
 *          text
 *
 *  @rdesc  HRESULT
 */
HRESULT CTxtEdit::SetText(
    LPCWSTR       pstr,     //@parm Text to set
    DWORD         flags,    //@parm 0 or more ST_xxx's
    LONG          CodePage, //@parm CodePage
    IUndoBuilder *publdr,   //@parm Optional place to put undo events
    LRESULT *     plres)    //@parm Optional place to return cch added
{
    CCallMgr    callmgr(this);
    BOOL        fSel = flags & ST_SELECTION;
    BOOL        fSetTextMax = TRUE;
    CTxtRange   rg(this, 0, -GetTextLength());  // Select whole story
    CTxtRange * prg = &rg;
    LRESULT     lres = 0;
    CFreezeDisplay fd(_pdp);
    CCharFormat CF;
    BOOL        fSetCF = FALSE;

    // NOTE: WM_SETTEXT is the only message using flags == ST_CHECKPROTECTION.
    // This is sent in via ANSIWndProc().  Do we need another flag to indicate
    // WM_SETTEXT or is this check good enough?  This only affect 1.0 mode.
    BOOL        f10WM_SETTEXT = flags & ST_10WM_SETTEXT;

    if(plres)
        *plres = 0;

    if(fSel)                    // Set selected text
    {
        if(!_psel)
        {
            Beep();
            return E_FAIL;
        }
        //bug fix: 6498 - we need to know if scroll position is at bottom before
        //inserting text
        if (Get10Mode())
        {
            LONG nMin, nMax, nPos, nPage;
            BOOL nEnable;
            TxGetVScroll(&nMin, &nMax, &nPos, &nPage, &nEnable);
            if (nEnable)
                _psel->SetAutoVScroll((nMax - nPage - 3) <= nPos);
        }

        prg = _psel;
    }
    else
    {
        _dwCharFlags &= 0xFF;           // No chars, so kill char flags
        if (!IsRich())
        {
            // Deleting all text from Plain text, we want to
            // go back to the -1 format
            prg->Set_iCF(-1);
            prg->SetUseiFormat(TRUE);
        }
        else
            _dwCharFlags |= fBELOWX40;  // For final EOP
    }

    if (flags & ST_CHECKPROTECTION &&
        IsProtectedRange(WM_SETTEXT, 0, (LPARAM)pstr, prg))
    {
        return E_ACCESSDENIED;
    }

    // 1.0 COMPATABILITY
    // 1.0 didn't scroll to seleection if text is inserted via EM_REPLACESEL and
    // fHideSelection is FALSE;
    BOOL    fUpdateCaret = !(Get10Mode() && (flags & ST_10REPLACESEL) && fHideSelection() && !_psel->GetAutoVScroll());

    if(!(flags & ST_KEEPUNDO))
    {

        if(IsRich() && !fSel)
        {
            if (f10WM_SETTEXT)
            {
                // If pstr is empty string, retain format at the end of current text
                // If pstr is not empty string, retain format at cp==1
                // Note: prg->_rpCF is already at SetRun(0,0)
                CFormatRunPtr rp(prg->_rpCF);

                if (!pstr || *(LPBYTE)pstr == '\0')
                {
                    LONG cchAdjusted = GetAdjustedTextLength() - 1;

                    if (cchAdjusted > 0)
                        rp.AdvanceCp(cchAdjusted);
                }

                CF = *(GetCharFormat(rp.GetFormat()));
                fSetCF = TRUE;

                prg->SetText(NULL);     // delete all the text first
            }

            // SetText causing all formatting to return to the default. We use
            // the notification system to remove the formatting. This is
            // particularly important for the final EOP which cannot be deleted.

            // Notify every interested party that they should dump their formatting
            _nm.NotifyPreReplaceRange(NULL, CONVERT_TO_PLAIN, 0, 0, 0, 0);

            // Tell document to dump its format runs
            _story.DeleteFormatRuns();

            if (fSetCF)
                prg->SetCharFormat(&CF, 0, NULL, CFM_ALL, 0);
        }

        publdr = NULL;
        if(_pundo)
            _pundo->ClearAll();

        if(_predo)
            _predo->ClearAll();

        // If we are re-entered, there may be anti-events higher up the
        // chain.  Grab the undo builder and clear things away if necessary.
        CGenUndoBuilder undobldr(this, 0);
        undobldr.Discard();
    }
    if(publdr)
        publdr->StopGroupTyping();

    // need to reinit zoomin variables if entire text is being replaced
    if (!fSel)
        InitDocInfo();


    LONG lStreamFormat = IsRTF((char *)pstr) ? SF_RTF : 0;

    if(pstr && (CodePage != 1200 || lStreamFormat))
    {
        LONG cch = strlen((LPSTR)pstr);
        LONG ch = *(LPBYTE)pstr;

        if(ch < 128 && fSel && cch == 1)
        {
            lres = 1;
            fSetTextMax = FALSE;
            TxSetMaxToMaxText(1);
            _psel->PutChar(ch, 0, publdr);
        }
        else if(cch == 2 && ch == CR && *((LPSTR)pstr + 1) == LF)
        {
            lres = 2;
            fSetTextMax = FALSE;
            TxSetMaxToMaxText(2);
            _psel->InsertEOP(publdr);
        }
        else
        {
            READHGLOBAL rhg = {(LPSTR)pstr, cch};
            EDITSTREAM  es = {(DWORD_PTR)&rhg, S_OK, ReadHGlobal};
            HCURSOR     hcur = NULL;

            // Want wait cursor to display sooner
            bool fSetCursor = rhg.cbLeft > NUMPASTECHARSWAITCURSOR;
            if(fSetCursor)
                hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));

            if (CodePage <= 0)
                CodePage = (CodePage == 0) ? GetACP() : GetDefaultCodePage(EM_SETTEXTEX);

            if(!lStreamFormat)
                lStreamFormat = SF_TEXT;

            lStreamFormat |= SF_USECODEPAGE | (CodePage << 16);

            if(fSel)
                lStreamFormat |= SFF_SELECTION;

            lres = _ldte.LoadFromEs(prg, lStreamFormat, &es, FALSE, publdr);
            if(fSetCursor)
                SetCursor(hcur);

            if(es.dwError != NOERROR)
                return (HRESULT)es.dwError;
        }
    }
    else
        lres = prg->CleanseAndReplaceRange(-1, pstr, FALSE, publdr, NULL, NULL, RR_ITMZ_UNICODEBIDI);

    if (_fOutlineView)
    {
        // Outline view must have formatting.
        _psel->Check_rpPF();
    }

    if(!lres && pstr && (!lStreamFormat && *pstr != '\0' ||
        lStreamFormat && *(char *)pstr != '\0'))
    {
        // There was an input string but for some reason there was no update.
        return E_FAIL;
    }

    if(_psel)
    {
        if(fSel)
            _psel->Update(fUpdateCaret);
        else
        {
            // Setting the text means a new document so if there is a selection
            // turn it into an insertion point at the beginning of the document.
            _psel->ClearPrevSel();
            _psel->Set(0, 0);

            // Since the text is being completely replaced and all formatting
            // is being lost, let's go back to the default format for the
            // selection.
            if (!f10WM_SETTEXT)
                _psel->Set_iCF(-1);
            else if (fSetCF)
                _psel->SetCharFormat(&CF, 0, NULL, CFM_ALL, 0);

            if(_fFocus || _psel->IsParaRTL())
            {
                // Update caret to reflect new postion
                _psel->UpdateCaret(fUpdateCaret);
            }
        }
    }

    // If we've replaced the entire document, the control isn't
    // really "modified" anymore.  This is necessary to match
    // the Windows MLE behavior.  However, since RichEdit 1.0
    // did _not_ do this (they left fModified to be TRUE), we
    // only do this for RichEdit 2.0 and later.

    if(!Get10Mode() && !publdr && !fSel)
        _fModified = FALSE;

    _fSaved = FALSE;                        // ITextDocument isn't Saved

    // Adjust text limit if necessary
    if (fSetTextMax)
        TxSetMaxToMaxText();

    if(plres)
        *plres = fSel ? lres : 1;

    return S_OK;
}

/////////////////////////// ITextServices Methods ////////////////////////////////

// External IME Message Filter Interface factory
void CreateIMEMessageFilter(ITextMsgFilter **ppNewFilter);

/*
 *  @doc EXTERNAL
 *
 *  CTxtEdit::TxSendMessage (msg, wparam, lparam, plresult)
 *
 *  @mfunc
 *      Used by window host to forward messages sent to its window to the
 *      text services.
 *
 *  @rdesc
 *      NOERROR Message was processed, and some action taken <nl>
 *      S_FALSE Message was not processed.  Typically indicates that caller
 *              should process message, maybe by calling DefWindowProc <nl>
 *      S_MSG_KEYIGNORED Message processed, but no action was taken <nl>
 *      E_OUTOFMEMORY <nl>
 *
 *  @comm
 *      Note that two return values are passed back from this function.
 *      <p plresult> is the return value that should be passed back from a
 *      window proc.  However, in some cases, the returned LRESULT does not
 *      contain enough information.  For example, to implement cursoring
 *      around controls, it's useful to know if a keystroke (such as right
 *      arrow) was processed, but ignored (e.g. the caret is already at the
 *      rightmost position in the the text).  In these cases, extra
 *      information may be returned via the returned HRESULT.
 *
 *      WM_CHAR and WM_KEYDOWN should return S_MSG_KEYIGNORED when a key or
 *      char has been recognized but had no effect given the current state,
 *      e.g., a VK_RIGHT key when the insertion point is already at the end of
 *      the document). This is used by Forms3 to pass the key up the visual
 *      hierarchy, so that for example, focus moves to the next control in the
 *      TAB order.
 *
 *      This includes the following cases:
 *
 *      1. Any key trying to move the insertion point beyond the end of the
 *      document; or before the begining of the document.
 *
 *      2. Any key trying to move the insertion point beyond the last line or
 *      before the first line.
 *
 *      3. Any insertion of character (WM_CHAR) that would move the insertion
 *      point past the maximum length of the control.
 */
HRESULT CTxtEdit::TxSendMessage (
    UINT    msg,        //@parm Message id
    WPARAM  wparam,     //@parm WPARAM from window's message
    LPARAM  lparam,     //@parm LPARAM from window's message
    LRESULT *plresult)  //@parm Where to put message's return LRESULT
{
    TRACEBEGINPARAM(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxSendMessage", msg);

    CObjectMgr *pobjmgr;
    HRESULT     hr = NOERROR;
    LRESULT     lres = 0;
    CCallMgr    callmgr(this);

    if ( CW32System::_MSMouseRoller == msg )                    // map Magellan msg.
    {
        // map this message to WM_MOUSEWHEEL
        // In these cases the driver doesn't set the key state properly so
        // we have to do it ourselves
        short zdelta = (short)(long)wparam;
        short kstate = 0;
        if (GetKeyboardFlag(CTRL, VK_CONTROL))
            kstate |= MK_CONTROL;
        if (GetKeyboardFlag(SHIFT, VK_SHIFT))
            kstate |= MK_SHIFT;

        wparam = MAKELONG(kstate, zdelta);
        msg = WM_MOUSEWHEEL;
    }

    if (_pMsgFilter)
    {
PassMsg:
        hr = _pMsgFilter->HandleMessage(&msg, &wparam, &lparam, &lres);
        if (hr == S_OK)                 // Message has been handled.
        {
            if(plresult)
                *plresult = lres;

            return S_OK;
        }
        hr = S_OK;                      // Reset
    }
    else if (LoadMsgFilter(msg, wparam, lparam))
    {
        HWND hwnd = NULL;
        if (_fInOurHost)
        {
            // If not in Forms^3 we can get the window from our host.
            // For Forms^3 we will use NULL for the desktop Window and pray
            TxGetWindow( &hwnd );
        }
        ITextMsgFilter *pNewFilter;
        CreateIMEMessageFilter(&pNewFilter);
        if (pNewFilter)
        {
            pNewFilter->AttachDocument( hwnd, (ITextDocument2 *) this);
            AttachMsgFilter(pNewFilter);
            goto PassMsg;
        }
    }

    START_PROFILING

    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(this, UB_AUTOCOMMIT, &publdr);

#ifdef MACPORTREMOVEIT
// PowerMac's cannot set breakpoints on a running application and have
// no way to stop the running appliation.This code allows one to
// stop the executable when the user holds down the option key and
// a break point has been set in the indicated spot below. -jOn

    BOOL fMacBreak = GetAsyncKeyState(VK_OPTION)<0;// Is user holding OPTION?

    if(fMacBreak)               // any old statement will due.
        fMacBreak = TRUE;       // Set a break point here for stopping the Mac.

#endif // MACPORTREMOVE

    switch(msg)
    {
    case EM_CANPASTE:
        // we don't check for protection here, as RichEdit 1.0
        // doesn't
        lres = _ldte.CanPaste(NULL, (CLIPFORMAT) wparam, RECO_PASTE);
        break;

    case EM_CANUNDO:
        if(_pundo)
            lres = _pundo->CanUndo();
        break;

    case EM_CANREDO:
        if(_predo)
            lres = _predo->CanUndo();
        break;

    case EM_GETUNDONAME:
        if(_pundo)
            lres = _pundo->GetNameIDFromAE((void*)wparam);
        break;

    case EM_GETREDONAME:
        if(_predo)
            lres = _predo->GetNameIDFromAE((void*)wparam);
        break;

    case EM_STOPGROUPTYPING:
        if(_pundo)
        {
            // we'll only stop group typing iff wparam
            // is zero (meaning stop regardless) _or_ if
            // wparam matches the merge anti event.
            //
            // This feature allows clients to say that only
            // a specific anti-event should close out it's
            // "fuzzy" state.  Note that currently, only the
            // merge anti-event has this fuzzy state.

            if(!wparam || (IAntiEvent *)wparam == _pundo->GetMergeAntiEvent())
                _pundo->StopGroupTyping();
        }
        break;

    case WM_CHAR:
        if(GetKeyboardFlags() & (ALTNUMPAD | HOTEURO))
        {
			if(GetKeyboardFlags() & ALTNUMPAD)
			{
				CW32System::WM_CHAR_INFO wmci;
				wmci._fAccumulate = FALSE;
				W32->AnsiFilter(msg, wparam, lparam, (void *)&wmci);
			}
			else
			{
				// We have handled the Euro, just eat this WM_CHAR
				ResetKeyboardFlag(HOTEURO);
				break;
			}
        }                               // Fall thru to WM_IME_CHAR		

    case WM_IME_CHAR:                   // 2 byte character, usually FE.
        lres = hr = OnTxChar((WORD) wparam, (DWORD) lparam, publdr);
		ResetKeyboardFlag(HOTEURO);
        break;

    case WM_USER + 39:                  // For backward compat with NT 3.51
    case EM_CHARFROMPOS:
        hr = TxCharFromPos((LPPOINT)lparam, &lres);
        break;

#ifndef NOMLKEYBOARD
    case WM_INPUTLANGCHANGE:
        if (_fSingleCodePage)
        {
            // See if the charset for the specified keyboard is supported by
            // the single code page we support. If we don't have a _pDocInfo,
            // assume the code page is the system code page. We will always
            // support the ANSI charset, as all code pages contain at least
            // a large portion of this charset (the ASCII block).
            wparam = (!wparam || wparam == GetCharSet(_pDocInfo ?
                        _pDocInfo->wCpg : GetSystemDefaultCodePage()));
        }
        goto update_kbd;

    case WM_INPUTLANGCHANGEREQUEST:
        // If the SingleCodePage option is set, then we must have a
        // "good" code page to go to; if not, just eat this message.
        //
        // This will prevent folks from typing French and Greek
        // on the same edit control, which is useful for certain
        // kinds of backward compatibility scenarios.
        //
        // HACK ALERT!  the documentation on WM_INPUTLANGCHANGEREQUEST
        // is wrong.  It turns out that _only_ the low bit of wparam
        // indicates whether or not the new keyboard can be considered
        // as the same code page.

        if (_fSingleCodePage && !(wparam & 1))
        {
            // The lowest bit check is not reliable in some platforms e.g. Viet OSR2
            // since it doesnt allow English kbd to match system charset (bug #6365).

            wparam = PRIMARYLANGID(LOWORD(lparam)) == LANG_ENGLISH &&
                     IN_RANGE (SUBLANG_ENGLISH_US, SUBLANGID(LOWORD(lparam)), SUBLANG_ENGLISH_UK);
        }

update_kbd:
        if(!_fSingleCodePage || (wparam & 1))
        {
            // Update our idea of current keyboard layout
            W32->RefreshKeyboardLayout();

            if(GetKeyboardFlags() & CTRL && GetKeyboardFlags() & SHIFT)
                SetKeyboardFlag(LETAFTERSHIFT);

            if (GetSel()->CheckChangeFont(
                    (HKL)lparam,
                    ConvertLanguageIDtoCodePage(LOWORD(lparam))))
            {
                hr = S_FALSE;   // cause default window to allow kb switch.
            }
        }
        break;
#endif

    case WM_CLEAR:
        OnClear(publdr);
        break;

    case WM_CONTEXTMENU:
        hr = OnContextMenu(lparam);
        break;

    case WM_COPY:
    case WM_CUT:
        lres = hr = CutOrCopySelection(msg, wparam, lparam, publdr);
        break;

    case WM_RENDERFORMAT:
        lres = hr = _ldte.RenderClipboardFormat(wparam);
        break;

    case WM_RENDERALLFORMATS:
        lres = hr = _ldte.RenderAllClipboardFormats();
        break;

    case WM_DESTROYCLIPBOARD:
        lres = hr = _ldte.DestroyClipboard();
        break;

    case EM_DISPLAYBAND:
        if (fInplaceActive())
        {
            OnDisplayBand((const RECT *) lparam, FALSE);
            lres = 1;
        }
        else
            hr = OLE_E_INVALIDRECT;
        break;

#ifndef NODROPFILES
    case WM_DROPFILES:
        OnDropFiles((HANDLE) wparam);
        break;
#endif

    case EM_EMPTYUNDOBUFFER:
        ClearUndo(publdr);
        break;

    case WM_ERASEBKGND:
        lres = 1;               // We handle background erase during painting
        break;

    case EM_EXGETSEL:                       // Has cp output parameter
        OnExGetSel((CHARRANGE *)lparam);
        break;

    case EM_FINDTEXT:                       // Has cp input/output parms
    case EM_FINDTEXTW:                      // Has cp input/output parms
    case EM_FINDTEXTEX:                     // Has cp input/output parms
    case EM_FINDTEXTEXW:                    // Has cp input/output parms
        lres = OnFindText(msg, (DWORD)wparam, (FINDTEXTEX *)lparam);
        break;

    case EM_FINDWORDBREAK:                  // Has cp input/output parms
        hr = TxFindWordBreak((INT)wparam, (LONG)lparam, &lres);
        break;

    case EM_FORMATRANGE:                    // Has cp input/output parms
        if(fInplaceActive())
        {
            SPrintControl prtcon;
            prtcon._fDoPrint = (wparam) ? TRUE : FALSE;
            lres = OnFormatRange((FORMATRANGE *) lparam, prtcon);
        }
        else
            hr = OLE_E_INVALIDRECT;
        break;

    case EM_GETTYPOGRAPHYOPTIONS:
        lres = _bTypography;
        break;

    case EM_GETBIDIOPTIONS:
        if(lparam && ((BIDIOPTIONS *)lparam)->cbSize == sizeof(BIDIOPTIONS))
        {
            ((BIDIOPTIONS *)lparam)->wMask =
                BOM_NEUTRALOVERRIDE | BOM_CONTEXTREADING | BOM_CONTEXTALIGNMENT;
            ((BIDIOPTIONS *)lparam)->wEffects =
                (_fNeutralOverride ? BOE_NEUTRALOVERRIDE : 0) |
                (_nContextDir   == CTX_NONE ? 0 : BOE_CONTEXTREADING) |
                (_nContextAlign == CTX_NONE ? 0 : BOE_CONTEXTALIGNMENT);
        }
        break;

    case EM_GETCHARFORMAT:
        lres = OnGetCharFormat((CHARFORMAT2 *)lparam, wparam);
        break;

    case EM_GETCODEPAGE:
        lres = GetDefaultCodePage((UINT)wparam);
        break;

    case EM_GETFIRSTVISIBLELINE:
        if (fInplaceActive())
            lres = _pdp->GetFirstVisibleLine();
        else
            hr = OLE_E_INVALIDRECT;
        break;

    case EM_GETLIMITTEXT:                   // Has cp output parameter (sort of)
        lres = TxGetMaxLength();            // Ignore unless testing screams
        break;

    case EM_GETLINE:
        if(fInplaceActive())
        {
            lres = _pdp->GetLineText((LONG)wparam, (TCHAR *)lparam,
                                (LONG) (*(WORD *) lparam));
        }
        else
            hr = OLE_E_INVALIDRECT;
        break;

    case EM_GETLINECOUNT:
        hr = TxGetLineCount(&lres);
        break;

    case EM_GETMODIFY:              // RichEdit 1.0 returned -1 if _fModified
        lres = -(LONG)_fModified;   //  is TRUE (go figure). So for backward
        break;                      //  compatibility, we do too :-(

    case EM_GETOLEINTERFACE:
        if(lparam)
        {
            if (wparam == 0x065737777)      // 'AIMM'
                W32->GetAimmObject((IUnknown **)(lparam));
            else
            {
                *(IRichEditOle **)lparam = (IRichEditOle *)this;
                AddRef();
            }
        }
        lres = TRUE;
        break;

    case EM_GETSCROLLPOS:
        {
            POINT *point = (POINT *)lparam;
            point->x = _pdp->GetXScroll();
            point->y = _pdp->GetYScroll();
            point->y = _pdp->ConvertYPosToScrollPos(point->y);
            lres = 1;
        }
        break;

    case EM_SETOLECALLBACK:
        hr = E_FAIL;
        if(lparam)
        {
            pobjmgr = GetObjectMgr();
            if(pobjmgr)
            {
                pobjmgr->SetRECallback((IRichEditOleCallback *)lparam);
                lres = TRUE;
                hr = NOERROR;
            }
        }
        break;

    case EM_GETPARAFORMAT:
        lres = OnGetParaFormat((PARAFORMAT2 *)lparam, wparam);
        break;

    case EM_GETSEL:                         // Has cp output parameter
        lres = OnGetSel((LONG*)wparam, (LONG*)lparam);
        break;

    case EM_GETSELTEXT:
        lres = OnGetSelText((TCHAR *)lparam);
        break;

    case WM_GETTEXT:
        {
            GETTEXTEX gt;

            gt.cb = wparam * 2;
            gt.flags = GT_USECRLF;
            gt.codepage = 1200;
            gt.lpDefaultChar = NULL;
            gt.lpUsedDefChar = NULL;

            lres = GetTextEx(&gt, (TCHAR *)lparam);
        }
        break;

    case WM_GETTEXTLENGTH:                  // Has cp output parameter
        {
            GETTEXTLENGTHEX gtl;

            gtl.flags = GTL_NUMCHARS | GTL_PRECISE | GTL_USECRLF;
            gtl.codepage = 1200;

            lres = GetTextLengthEx(&gtl);
        }
        break;

    case EM_GETTEXTEX:
        lres = GetTextEx((GETTEXTEX *)wparam, (TCHAR *)lparam);
        break;

    case EM_GETTEXTLENGTHEX:                // Has cp output parameter
        lres = GetTextLengthEx((GETTEXTLENGTHEX *)wparam);
        break;

    case EM_GETTEXTRANGE:                   // Has cp input parameter
    {
        TEXTRANGE * const ptr = (TEXTRANGE *)lparam;
        LONG              cch = ValidateTextRange(ptr);

        // Only copy if there's something to copy and destination is valid
        if(cch)
        {
            LONG cpMin  = GetCpFromAcp(ptr->chrg.cpMin);
            if(cch < 0)                     // Get text character count
                cch = GetTextLength();      //  because caller wants it all
            else                             // + 1 is for terminating 0
                cch = GetCpFromAcp(ptr->chrg.cpMost) - cpMin + 1;

            if(!IsBadWritePtr(ptr->lpstrText, cch * sizeof(TCHAR)))
                lres = GetTextRange(cpMin, cch, ptr->lpstrText);
        }
    }
        break;

    case EM_GETWORDBREAKPROC:
        // Client can only use either WordBreakProc or ExWordBreakProc
        // Return NULL if ExWordBreakProc is being used.
        if (!_fExWordBreakProc)
            lres = OnGetWordBreakProc();
        break;

    case EM_GETWORDBREAKPROCEX:
        // Return ExWordBreakProc if it is being used.
        if (_fExWordBreakProc)
            lres = OnGetWordBreakProc();
        break;

    case EM_GETZOOM:
        if(wparam && lparam)
        {
            *(unsigned *)wparam = GetZoomNumerator();
            *(unsigned *)lparam = GetZoomDenominator();
            lres = 1;
        }
        break;

    case EM_HIDESELECTION:
        if (Get10Mode() && lparam)
            _fHideSelection = !!wparam;

        if(!lparam || !_fFocus)
            lres = OnHideSelectionChange((BOOL)wparam);
        break;

    case WM_HSCROLL:
        hr = TxHScroll(LOWORD(wparam), HIWORD(wparam));
        break;

    case WM_KEYDOWN:
        hr = OnTxKeyDown((WORD) wparam, (DWORD) lparam, publdr);
        break;

    case WM_KEYUP:
        if(wparam == VK_APPS)
            HandleKbdContextMenu();
        else                            // Else don't say we processed
            hr = S_FALSE;               //  message

        W32->_fLRMorRLM = 0;
        if(wparam == VK_CONTROL || wparam == VK_SHIFT)
        {
            // If a BiDi control, no strong-context behavior, both a ctrl
            // and a shift key are pressed and no letter has been typed
            // after the Ctrl and Shift keys have been pressed, then the
            // selected paragraphs are set to RTL/LTR direction for the
            // right/left Shift key, respectively. The keyboard and caret
            // are also matched to this direction, and an alignment
            // notification is sent.
            DWORD dwFlags = GetKeyboardFlags();

            if (IsBiDi() && !IsStrongContext(_nContextDir) &&
                !IsStrongContext(_nContextAlign) &&
                (dwFlags & CTRL) && (dwFlags & SHIFT) &&
                // IsBiDiKbdInstalled() &&      // Do we want this???
                !(dwFlags & LETAFTERSHIFT))
            {
                CParaFormat PF;
                PF._wEffects = (dwFlags & RSHIFT) ? PFE_RTLPARA : 0;

                OnSetParaFormat(0, &PF, publdr, PFM_RTLPARA | PFM_PARAFORMAT);
                TxNotify(PF._wEffects ? EN_ALIGNRTL : EN_ALIGNLTR, 0);
            }
            if(wparam == VK_CONTROL)
                lparam = (HIWORD(lparam) & KF_EXTENDED) ? RCTRL : LCTRL;
            else
            {
                lparam = (LOBYTE(HIWORD(lparam)) == 0x36) ? RSHIFT : LSHIFT;
                if(GetKeyState(VK_SHIFT) >= 0)  // Ensure both shifts are off
                    lparam = SHIFT;             //  (potential Win95 problem)
            }
            ResetKeyboardFlag(lparam | LETAFTERSHIFT | HOTEURO);
        }
        else if(wparam == VK_MENU)
            ResetKeyboardFlag((HIWORD(lparam) & KF_EXTENDED) ? (RALT | HOTEURO) : (LALT | HOTEURO));
        break;

    case WM_KILLFOCUS:
        lres = OnKillFocus();
        break;

    case WM_LBUTTONDBLCLK:
        hr = OnTxLButtonDblClk(MOUSEX, MOUSEY, (WORD) wparam);
        break;

    case WM_LBUTTONDOWN:
        if(_fEatLeftDown)
        {
            TxSetFocus();
            _fEatLeftDown = FALSE;
        }
        else
            hr = OnTxLButtonDown(MOUSEX, MOUSEY, (WORD) wparam);
        break;

    case WM_LBUTTONUP:
        hr = OnTxLButtonUp(MOUSEX, MOUSEY, (WORD) wparam, LB_RELEASECAPTURE | LB_FLUSHNOTIFY);
        break;

#if !defined(NOMAGELLAN)
    case WM_MBUTTONDBLCLK:                      // Magellan zmouse scroll
    case WM_NCMBUTTONDOWN:                      //  support commandeers middle
    case WM_MBUTTONDOWN:                        //  button.
        OnTxMButtonDown(MOUSEX, MOUSEY, (WORD) wparam);
        break;

    case WM_MBUTTONUP:
        OnTxMButtonUp(MOUSEX, MOUSEY, (WORD) wparam);
        break;

    case WM_MOUSEWHEEL:                     // Magellan zmouse scroll n lines.
        lres = HandleMouseWheel(wparam, lparam);
        break;
#endif

    case EM_LINEFROMCHAR:                   // Has cp input parameter
        lparam = wparam;                    // Fall thru to EM_EXLINEFROMCHAR

    case EM_EXLINEFROMCHAR:                 // Has cp input parameter
        hr = TxLineFromCp((LONG)lparam, &lres);
        break;

    case EM_LINEINDEX:                      // Has cp output parameter
        hr = TxLineIndex((LONG)wparam, &lres);
        break;

    case EM_LINELENGTH:                     // Has cp input/output parameters
        hr = TxLineLength((LONG)wparam, &lres);
        break;

    case EM_LINESCROLL:                     // Has cp input parameter (cch)
        // Documentation says the line to scroll to should be relative to the current top line.
        // Richedit 2.0 based it on an absolute position.  We're breaking richedit 2.0 compatibility
        // to go back to the documentation specification and to match what riched 1.0 originally
        // did
        hr   = TxLineScroll((LONG)lparam, (LONG)wparam);// but not curr impl
        lres = _pdp->IsMultiLine();
        break;

#ifndef PEGASUS
    case WM_MOUSEACTIVATE:
        lres = MA_ACTIVATE;
        // If the window that currently has focus is part of our "application",
        // then don't eat the mouse click.  Otherwise, if it's from another
        // app, the user is probably trying to swap apps, so eat the mouse
        // down message and let our host app get a chance to come to the
        // foreground.
        if (!(IsChild((HWND)wparam, GetFocus()) ||
            (wparam && (HWND)wparam == GetFocus())))
        {
            _fEatLeftDown = TRUE;
        }
        hr = S_FALSE;       // pass WM_MOUSEACTIVATE message to DefWindProc
        break;
#endif

    case WM_MOUSEMOVE:
        // We reset the "number of tries to put an active object
        //  in place" count here
        _cActiveObjPosTries = MAX_ACTIVE_OBJ_POS_TRIES;
        hr = OnTxMouseMove(MOUSEX, MOUSEY, (WORD)wparam, publdr);
        break;

    case EM_OUTLINE:
    {
        CFreezeDisplay cfd(_pdp);

        if(wparam == EMO_GETVIEWMODE)
        {
            hr = GetViewKind(&lres);
            break;
        }

        CTxtSelection * psel = GetSelNC();

        if(!_pdp->IsMultiLine() || !IsRich() || !psel)  // Control must be rich,
            break;                                  //  multiline and active

        if(wparam == EMO_ENTER || wparam == EMO_EXIT)
        {
            hr = SetViewKind(wparam == EMO_ENTER ? VM_OUTLINE : VM_NORMAL);
            lres = !hr;
            break;
        }

        if(!IsInOutlineView() || !IsntProtectedOrReadOnly(msg, wparam, lparam))
            break;

        CTxtRange rg(*psel);

        switch(wparam)
        {
            case EMO_PROMOTE:
                hr = rg.Promote(lparam, publdr);
                psel->Update_iFormat(-1);
                psel->Update(FALSE);
                break;

            case EMO_EXPAND:
                hr = rg.ExpandOutline((short)LOWORD(lparam),
                                      HIWORD(lparam) == EMO_EXPANDDOCUMENT);
                break;

            case EMO_MOVESELECTION:
                hr = MoveSelection(lparam, publdr);
                psel->Update(TRUE);
                break;

            default:
//              TraceMessage("Unknown outline function received\r\n");
                break;
        };
        lres = !hr;
        _fModified = TRUE;
    }
        break;

    case WM_PASTE:
    case EM_PASTESPECIAL:
        if(IsntProtectedOrReadOnly(msg, wparam, lparam))
        {
            CTxtSelection *psel = GetSel();

            hr = PasteDataObjectToRange(NULL, psel,
                (CLIPFORMAT) wparam, (REPASTESPECIAL *)lparam, publdr,
                PDOR_NONE);
        }
        break;

    case WM_USER + 38:                  // For backward compat with NT 3.51
    case EM_POSFROMCHAR:                // Has cp input parameter
        // RichEdit 2.x used wparam instead of lparam for the cp and ignored
        // wparam, unlike RE 1.0 and the Win32 documentation (sigh!). We fix
        // this, but are compatible with RE 2.x for cp's whose values
        // correspond to invalid write ptr's.
        if(IsBadWritePtr((LPPOINT)wparam, sizeof(POINT)))
        {
            // Invalid write ptr, so assume incorrect RE 2.0 params
            // TODO: enable following Assert when msgtest gets updated
            //AssertSz(FALSE,
            //  "EM_POSFROMCHAR: wparam is illegal ptr, assuming cp value");
            POINT pt;
            hr = TxPosFromChar((LONG)wparam, &pt);
            lres = SUCCEEDED(hr) ? MAKELONG(pt.x, pt.y) : -1;
        }
        else
            hr = TxPosFromChar((LONG)lparam, (LPPOINT)wparam);
        break;

#ifndef PEGASUS
    case WM_RBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONUP:
        // Give client a chance to handle these messages,
        // if we are over a link
        if(HandleLinkNotification(msg, wparam, lparam))
            break;

        if(msg == WM_RBUTTONUP)
            hr = OnTxRButtonUp(MOUSEX, MOUSEY, (WORD) wparam, RB_DEFAULT);

        else if( msg == WM_RBUTTONDOWN)
            hr = OnTxRButtonDown(MOUSEX, MOUSEY, (WORD) wparam);

        break;
#endif

    case EM_REPLACESEL:
        wparam = wparam ? ST_CHECKPROTECTION | ST_SELECTION | ST_KEEPUNDO
                        : ST_CHECKPROTECTION | ST_SELECTION;
        hr = SetText((LPTSTR)lparam, wparam, 1200, publdr, &lres);
        break;

    case EM_REQUESTRESIZE:
        hr = _pdp->RequestResize();
        break;

    case EM_SCROLL:
        // TxVScroll returns the number of lines scrolled;
        // this info should be returned in lres
        lres = TxVScroll((WORD)wparam, 0);
        break;

    case EM_SCROLLCARET:
        OnScrollCaret();
        break;

    case EM_SELECTIONTYPE:
    {
        SELCHANGE selchg;

        GetSel()->SetSelectionInfo(&selchg);
        lres = selchg.seltyp;
    }
        break;

    case EM_SETTYPOGRAPHYOPTIONS:
        // Don't allow typography options for password & accelerator instances
        hr = OnSetTypographyOptions(wparam, lparam);
        lres = (hr == S_OK);
        break;

    case EM_SETBIDIOPTIONS:
        if(lparam && !IsRich())
        {
            WORD wMask = ((BIDIOPTIONS *)lparam)->wMask;
            WORD wEffects = (_fNeutralOverride ? BOE_NEUTRALOVERRIDE : 0) |
                            (_nContextDir   == CTX_NONE ? 0 : BOE_CONTEXTREADING) |
                            (_nContextAlign == CTX_NONE ? 0 : BOE_CONTEXTALIGNMENT);

            wEffects &= ~wMask;
            wEffects |= (wMask & ((BIDIOPTIONS *)lparam)->wEffects);
            if (_fNeutralOverride != !!(wEffects & BOE_NEUTRALOVERRIDE))
            {
                _fNeutralOverride = !_fNeutralOverride;
                if (!_pdp->IsPrinter())             // Refresh display
                {
                    _pdp->InvalidateRecalc();
                    TxInvalidateRect(NULL, FALSE);
                }
            }
            _nContextDir   = (WORD)((wEffects & BOE_CONTEXTREADING)   ? CTX_NEUTRAL : CTX_NONE);
            _nContextAlign = (WORD)((wEffects & BOE_CONTEXTALIGNMENT) ? CTX_NEUTRAL : CTX_NONE);
            if(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE)
            {
                SetContextDirection(TRUE);
                Assert(_nContextDir != CTX_NONE || _nContextAlign != CTX_NONE);
            }
        }
        break;

    case WM_SETFOCUS:
        hr = OnSetFocus();
        break;

    case EM_SETFONTSIZE:
        lres = OnSetFontSize(LONG(wparam), publdr);
        break;

    case EM_SETMODIFY:
        _fModified = wparam != 0;

#ifdef  LATER
        if (!_fModified)
            ObFreezeFrames();
#endif                      // LATER
        break;

    case EM_SETSCROLLPOS:
        {
            POINT *pPoint = (POINT*)lparam;
            _pdp->ScrollView(pPoint->x, pPoint->y, FALSE, TRUE);
            lres = 1;
        }
        break;

    case EM_EXSETSEL:
        // EM_EXSETSEL duplicates the functionality of the 32-bit EM_SETSEL
        // and exists purely for backward compatibility with Win16. We just
        // repackage the params and fall thru to EM_SETSEL
        wparam = (WPARAM)((CHARRANGE *)lparam)->cpMin;
        lparam = (LPARAM)((CHARRANGE *)lparam)->cpMost;

        // FALL-THROUGH to EM_SETSEL!!!

    case EM_SETSEL:
        lres = OnSetSel((LONG)wparam, (LONG)lparam);
        break;

    // INCREDIBLY EVIL HACK ALERT!!!!!  Win95's dialog manager doesn't even
    // pretend to be 32 bits despite the best attempts of our marketing dudes.
    // WM_USER + 1 is the old Win3.0 EM_SETSEL in which the selection range
    // was packed into the lparam.
    //
    // Sometimes (like tabbing through a dialog), Win95 will send us the 16
    // bit EM_SETSEL message, so process it here.
    case (WM_USER + 1):
        lres = OnSetSel(LOWORD(lparam), HIWORD(lparam));
        break;

    case EM_SETTARGETDEVICE:
        // Keep width sane so that LXtoDX works OK at least for displays
        // Note that 0x7fffff = 485 feet! This keeps LXtoDX working provided
        // _xPerInch < 257 (it's typically 96 for displays). For more
        // generality, we'd need to use 64-bit arithmetic (see LXtoDX).
        lparam = min(lparam, (LPARAM)0x7fffff);
        lres = _pdp->SetMainTargetDC((HDC)wparam, (LONG)lparam);
        break;

    case EM_SETTEXTEX:
        hr = SetText((LPTSTR)lparam, ((SETTEXTEX *)wparam)->flags,
                                     ((SETTEXTEX *)wparam)->codepage, publdr, &lres);
        break;

    case WM_SETTEXT:
        hr = SetText((LPTSTR)lparam, ST_CHECKPROTECTION, wparam ? wparam : 1200, publdr, &lres);
        break;

    case EM_SETWORDBREAKPROC:
        _fExWordBreakProc = 0;
        _pfnWB = (EDITWORDBREAKPROC) lparam;
        break;

    case EM_SETWORDBREAKPROCEX:
        // We don't support this API in 2.0 and greater because we pass
        // UNICODE text to the callback function.  Therefore there
        // are no benefits to this API.  Exists for 1.0 backward
        // compatibility only.
        if (Get10Mode())
        {
            _fExWordBreakProc = 1;

            // This is a bit deceiving, but lparam is a EDITWORDBREAKPROCEX but the compiler
            // will generate an error if you try to type cast the l-value
            _pfnWB = (EDITWORDBREAKPROC) lparam;
        }
        break;


    case WM_SYSCHAR:
        lres = hr = OnTxSysChar((WORD)wparam, (DWORD)lparam, publdr);
        if(hr == S_OK)
            break;
        goto def;

    case WM_SYSKEYUP:
        if(IN_RANGE(VK_SHIFT, wparam, VK_MENU))
            ResetKeyboardFlag(GetKbdFlags((WORD)wparam, (DWORD)lparam));

        if (IN_RANGE(VK_NUMPAD0, wparam, VK_NUMPAD9)  ||
            wparam == VK_CLEAR || wparam == VK_INSERT ||
            IN_RANGE(VK_PRIOR, wparam, VK_DOWN))
        {
            // Collect AltNumPad number to word around NT 4 bug and
            // generalize to any Unicode value (in decimal, ugh!)
            const static BYTE VkeyNumbers[] = {VK_NUMPAD9, VK_NUMPAD3, VK_NUMPAD1,
                VK_NUMPAD7, VK_NUMPAD4, VK_NUMPAD8, VK_NUMPAD6, VK_NUMPAD2, 0, 0,
                0, 0, VK_NUMPAD0};
                                            // Flag Alt NumPad char typed to
            SetKeyboardFlag(ALTNUMPAD);     //  distinguish hiANSI from lead
            if(!IN_RANGE(VK_NUMPAD0, wparam, VK_NUMPAD9)) // byte in Win3.1 IME
            {                               // Collect AltNumPad number
                if(wparam == VK_CLEAR)      // NumLock not active: translate
                    wparam = VK_NUMPAD5;    //  to digit codes
                else
                    wparam = VkeyNumbers[wparam - VK_PRIOR];
            }
            WORD wNum = GetKeyPadNumber();
            if(!wNum && wparam == VK_NUMPAD0)
                SetKeyboardFlag(ALT0);      // Flag that 0 is first digit
            SetKeyPadNumber(10*wNum + wparam - VK_NUMPAD0);
        }
        goto def;

    case WM_SYSKEYDOWN:
        if(OnTxSysKeyDown(wparam, lparam, publdr) == S_OK)
        {
            lres = TRUE;
            break;
        }
        goto def;

    case WM_TIMER:
        OnTxTimer((UINT)wparam);
        goto def;

    case EM_UNDO:
    case WM_UNDO:
        if (_pundo && !_fReadOnly && _fUseUndo)
        {
            hr = PopAndExecuteAntiEvent(_pundo, (void*)wparam);
            if(hr == NOERROR)
                lres = TRUE;
        }
        break;

    case EM_REDO:
        if(_predo && !_fReadOnly && _fUseUndo)
        {
            hr = PopAndExecuteAntiEvent(_predo, (void*)wparam);
            if(hr == NOERROR)
                lres = TRUE;
        }
        break;

    case EM_SETUNDOLIMIT:
        lres = HandleSetUndoLimit((DWORD)wparam);
        break;

    case WM_VSCROLL:
        // TxVScroll returns the number of lines scrolled;
        // WM_VSCROLL doesn't care about that info however.
        Assert(lres == 0);
        Assert(hr == NOERROR);
        TxVScroll(LOWORD(wparam), HIWORD(wparam));
        break;

    // Old stuff that's no longer supported
    case EM_FMTLINES:               // Controls returning CRCRLFs for soft
                                    //  line breaks in EM_GETTEXT. Could
                                    //  implement
    case WM_GETFONT:                // Can support but have to hang onto a
                                    //  default HFONT. CCcs has an _hfont, but
                                    //  need to be sure default font is in
                                    //  cache at time of return
    case EM_GETHANDLE:              // Not supported by Win95 32-bit MLE either
    case EM_SETHANDLE:              // Not supported by Win95 32-bit MLE either
#ifdef DEBUG
        TRACEINFOSZ("Homey don't play dat");
#endif
        break;

    case EM_SETTABSTOPS:
    {
        // this message only works for multi-line edit controls
        if(!_pdp->IsMultiLine())
            break;

        // perform some validation checks
        Assert(lparam || !wparam);
        LPDWORD prgdwdlgCoord = (LPDWORD)lparam;
        if (wparam && (!prgdwdlgCoord || !(*prgdwdlgCoord)))
            break;
        AssertSz(wparam <= MAX_TAB_STOPS, "Tab stop count beyond maximum allowed");
        if (wparam > MAX_TAB_STOPS)
            wparam = MAX_TAB_STOPS;

        PARAFORMAT2 pf;
        ZeroMemory(&pf, sizeof(PARAFORMAT2));
        pf.cbSize = sizeof(PARAFORMAT2);

        // contains the average width for the default font
        LONG lAvgWidth;

        //Average char width based on default font
        HDC hdc = _phost->TxGetDC();
        GetECDefaultHeightAndWidth(this, hdc, 1, 1,
            W32->GetYPerInchScreenDC(), &lAvgWidth, NULL, NULL);
        _phost->TxReleaseDC(hdc);

        Assert(lAvgWidth);

        //According to documenation wparam == 1 means the tab settings
        //will be set at incremental positions *prgdwdlgCoord and wparam == 0
        //the tab settings will be set at the default incremental position 32 (dialog coord)
        long lTab = (wparam) ? *prgdwdlgCoord : 32;
        long nCt = (wparam <= 1) ? MAX_TAB_STOPS : (signed)wparam;
        for (int i = 0; i < nCt; i++)
        {
            long lval;
            lval = (wparam <= 1) ? ((i+1) * lTab) : *prgdwdlgCoord;
            pf.rgxTabs[i] = MulDiv(MulDiv(lval, lAvgWidth, 4), 1440, W32->GetXPerInchScreenDC());
            prgdwdlgCoord++;
        }

        // Set the default paragraph formatting
        pf.cTabCount = nCt;
        pf.dwMask = PFM_TABSTOPS;
        CParaFormat PF;
        PF.Set(&pf);

        // Need to turn off group typing just like the selection would.
        if (publdr)
        {
            publdr->StopGroupTyping();
        }

        lres = OnSetParaFormat(SPF_SETDEFAULT, &PF, publdr, PFM_TABSTOPS | PFM_PARAFORMAT);
        GetTabsCache()->Release(PF._iTabs);
        break;
    }

    case EM_SETCHARFORMAT:
    {
        CHARFORMAT2 *pCF2     = (CHARFORMAT2 *)lparam;
        UINT         CodePage = 1200;
        DWORD        dwMask   = pCF2->dwMask;
        DWORD        dwMask2  = 0;

        if(!IsValidCharFormatW(pCF2))
        {
            if(!IsValidCharFormatA((CHARFORMAT2A *)lparam))
                break;
            if(dwMask & CFM_FACE)           // Need to convert to Unicode
                CodePage = GetDefaultCodePage(EM_SETCHARFORMAT);
        }

        if(Get10Mode() && (dwMask & CFM_SIZE) && (pCF2->yHeight <= 0))
        {
            // 1.0 has a hack where if the height is being set and it is
            // negative, then the height field is ignored.
            dwMask &= ~CFM_SIZE;
        }

        if (pCF2->cbSize == sizeof(CHARFORMATW) ||
            pCF2->cbSize == sizeof(CHARFORMATA))
        {
            // Restrict specifications to CHARFORMAT parameters. If the
            // host isn't our Windows host, we allow this to include the
            // CHARFORMAT2 disabled effect, since Forms^3 wanted that effect
            // but wasn't willing to use CHARFORMAT2 (even tho they asked
            // for it...)
            dwMask &= fInOurHost() ? CFM_ALL : (CFM_ALL | CFM_DISABLED);
            dwMask2 = CFM2_CHARFORMAT;      // Tell callees that CHARFORMAT
        }                                   //  was used

        CCharFormat CF;                     // Transfer external CHARFORMAT(2)
        CF.Set(pCF2, CodePage);             //  parms to internal CCharFormat
        lres = OnSetCharFormat(wparam, &CF, publdr, dwMask, dwMask2);
        break;
    }
    case WM_SETFONT:
        lres = OnSetFont((HFONT)wparam);
        break;

    case EM_SETPARAFORMAT:
    {
        PARAFORMAT2 *pPF2 = (PARAFORMAT2 *)lparam;

        if(!IsValidParaFormat(pPF2))
            break;

        DWORD dwMask = pPF2->dwMask;

        // Two more things to validate: (1) We don't let an applications set
        // up tables and (2) Tabs coming from applications must be valid.
        if (dwMask & (PFM_TABLE | PFM_OUTLINELEVEL | PFM_COLLAPSED))
        {
            // Trying to set up a table or outline view
            break;
        }

        if ((dwMask & PFM_TABSTOPS) && (pPF2->cTabCount != 0))
        {
            // Make sure all submitted tabstops make sense.
            int iMax = min(MAX_TAB_STOPS, pPF2->cTabCount);

            for (int i = 0; i < iMax; i++)
            {
                // Make sure that tab stops make sense - make sure alignment
                // is valid.
                if (GetTabAlign(pPF2->rgxTabs[i]) > tomAlignBar)
                {
                    // Invalid alignment.
                    break;
                }
            }

            if (i != iMax)
            {
                // Found error in validation loop so we are done.
                break;
            }
        }

        if(pPF2->cbSize == sizeof(PARAFORMAT))
        {
            dwMask &= PFM_ALL;              // Restrict to PARAFORMAT parms
            dwMask |= PFM_PARAFORMAT;       // Tell callees that PARAFORMAT
        }                                   //  was used

        CParaFormat PF;                     // Transfer external PARAFORMAT(2)
        PF.Set(pPF2);                       //  parms to internal CParaFormat
        lres = OnSetParaFormat(wparam, &PF, publdr, dwMask);
        GetTabsCache()->Release(PF._iTabs);
        break;
    }

    case EM_SETZOOM:
        if ((unsigned)(wparam | lparam) < 65536 && (!(wparam | lparam) ||
             (LONG)wparam < (lparam << 6) && lparam < (LONG)(wparam << 6)))
        {
            // Only get here if
            // 1) 0 <= wparam <= 65535 and 0 <= lparam <= 65535, and
            // 2) either wparam = lparam = 0 (which turns off zooming by this
            // message) or 1/64 < (zoom factor given by wparam/lparam) < 64.
            SetZoomNumerator(wparam);
            SetZoomDenominator(lparam);
            _pdp->UpdateView();
            lres = 1;
        }
        break;

    case EM_STREAMIN:
    case EM_STREAMOUT:
    {
        CTxtRange   rg(this, 0, -GetTextLength());
        CTxtRange * prg = &rg;              // Default whole doc

        wparam = W32->ValidateStreamWparam(wparam);
        if(wparam & SFF_SELECTION)          // Save to current selection
        {
            prg = (CTxtRange *)GetSel();
            AssertSz(prg,
                "EM_STREAMIN/OUT: requested selection doesn't exist");
        }
        else
        {
            // If we are not streaming into the selection, then we are
            // "loading" the entire file; this is not an undo-able operation,
            // so set the undo builder to NULL and get rid of the current
            // undo stacks
            publdr = NULL;
            ClearUndo(&undobldr);
            if(msg == EM_STREAMIN)
            {
                // Clear away the file info if necessary
                if(!(wparam & SFF_KEEPDOCINFO))
                    CloseFile(FALSE);
            }
        }

        if(msg == EM_STREAMIN)
        {
            // If we are going to be loading an entire file, we only
            // want to check "normal' protection; we can ignore the
            // fIsDBCS protection.  This does mean that somebody
            // can do an "insert file" and break apart a DBCS combo,
            // but we'll have to live with that.  Outlook uses
            // RTF streaming in many different places, so the strong
            // fIsDBCS protection breaks them.
            if ((_dwEventMask & ENM_PROTECTED) &&
                prg->IsProtected(0) == CTxtRange::PROTECTED_ASK &&
                QueryUseProtection(prg, msg, wparam, lparam))
            {
                Beep();
                Assert(lres == 0);
                break;
            }

            // Freeze the display before loading
            CFreezeDisplay fd(_pdp);

            lres = _ldte.LoadFromEs(prg, wparam, (EDITSTREAM *)lparam,
                                    FALSE, publdr);

            if (_fOutlineView)
            {
                // Outline view must have formatting.
                _psel->Check_rpPF();
            }

            if (_fFocus)
            {
                // Update caret but delay till display is thawed and do so only
                // if we have the focus. If we do this all the time we get wierd
                // scrolling effects such as scrolling to the beginning of a
                // document when the focus is set. See bug #1649 for repro of
                // wierd effects.
                _pdp->SaveUpdateCaret(TRUE);
            }
        }
        else
            lres = _ldte.SaveToEs  (prg, wparam, (EDITSTREAM *)lparam);
        break;
    }

#ifndef PEGASUS
    case WM_SYSCOLORCHANGE:
        TxInvalidateRect(NULL, FALSE);
        break;
#endif

    // debug stuff
#ifdef DEBUG
    case EM_DBGPED:
        OnDumpPed();
        break;
#endif                  // DEBUG

    case EM_SETEVENTMASK:
        lres = _dwEventMask;                // Set up to return value before
        _dwEventMask = (DWORD)lparam;       //  the change

        if (lparam & ENM_REQUESTRESIZE)
        {
            // We need to update the display just in case it changes.
            _pdp->UpdateView();
        }
        break;

    case EM_GETEVENTMASK:
        lres = _dwEventMask;
        break;

    case EM_GETTHUMB:
        LONG Pos;
        BOOL fIsEnabled;

        if (TxGetVScroll(NULL, NULL, &Pos, NULL, &fIsEnabled) == S_OK
            && fIsEnabled)
        {
            lres = Pos;
        }
        break;

    case EM_SETLANGOPTIONS:
        _fAutoFont           = (lparam & IMF_AUTOFONT) != 0;
        _fAutoKeyboard       = (lparam & IMF_AUTOKEYBOARD) != 0;
        _fAutoFontSizeAdjust = (lparam & IMF_AUTOFONTSIZEADJUST) != 0;
        _fDualFont           = (lparam & IMF_DUALFONT) != 0;
        _fUIFont             = (lparam & IMF_UIFONTS) != 0;
        lres = 1;
        break;

    case EM_GETLANGOPTIONS:
        if(_fAutoFont)
            lres |= IMF_AUTOFONT;
        if(_fAutoKeyboard)
            lres |= IMF_AUTOKEYBOARD;
        if(_fAutoFontSizeAdjust)
            lres |= IMF_AUTOFONTSIZEADJUST;
        if(_fDualFont)
            lres |= IMF_DUALFONT;
        if(_fUIFont)
            lres |= IMF_UIFONTS;
        break;

    case EM_SETEDITSTYLE:
        if (!Get10Mode())   // Not support in 1.0 mode
        {
            DWORD dwEditStyle = _bEditStyle & ~lparam;  // Kill current flag values
            dwEditStyle |= wparam & lparam;             // Or in new values

            // Certain bits aren't switchable
            dwEditStyle |= ((_fSystemEditMode) ? SES_EMULATESYSEDIT : 0);
            _bEditStyle = (WORD)dwEditStyle;

            // There are certain things which we won't allow user to reset, ie SES_EMULATESYSEDIT.
            // So reset everything and except for the SES_EMULATESYSEDIT
            if(wparam & SES_EMULATESYSEDIT)
            {
                if(SUCCEEDED(HandleSetTextMode(TM_SINGLELEVELUNDO | TM_PLAINTEXT)))
                {
                    // SES_EMULATESYSEDIT implies SES_BEEPONMAXTEXT
                    _fSystemEditBeep = TRUE;
                }
                else
                    _fSystemEditMode = FALSE;
            }

            if(wparam & SES_BIDI)
                OrCharFlags(fBIDI, publdr);

            _fLowerCase = !_fUpperCase && (dwEditStyle & SES_LOWERCASE);

        }                                           // Fall thru to EM_GETEDITSTYLE
                                                    //  to return _bEditStyle
    case EM_GETEDITSTYLE:
        if (!Get10Mode())   // Not support in 1.0 mode
            lres |= _bEditStyle;    // Some EditStyles have been filled in Cmsgflt
        break;

    case EM_SETTEXTMODE:
        // 1.0 mode does not supported EM_SETTEXTMODE
        if (!Get10Mode())
            lres = HandleSetTextMode(wparam);
        break;

    case EM_GETTEXTMODE:
        lres = IsRich() ? TM_RICHTEXT : TM_PLAINTEXT;

        lres |= (_pundo && ((CUndoStack *)_pundo)->GetSingleLevelMode())
             ? TM_SINGLELEVELUNDO : TM_MULTILEVELUNDO;

        lres |= _fSingleCodePage ? TM_SINGLECODEPAGE : TM_MULTICODEPAGE;
        break;

    case EM_LIMITTEXT:
        lparam = wparam;

        // Intentionally fall through. These messages are duplicates.

    case EM_EXLIMITTEXT:                    // Has cp input parameter (sort of)
        if(!lparam)                         // We ignore translation between
        {                                   //  acp and cp
            // 0 means set the control to the maximum size. However, because
            // 1.0 set this to 64K will keep this the same value so as not to
            // surprise anyone. Apps are free to set the value to be above 64K.
            lparam = (LPARAM)cResetTextMax;
        }
        if (Get10Mode())
        {
            // 1.0 used a signed variable to hold the length of the string.  So
            // if lparam is negative then just set lparam to zero to emulate
            // 1.0 behavior
            if ((LONG)lparam < 0)
                lparam = 0;
        }
        _cchTextMost = (LONG)lparam;
        break;

    case EM_AUTOURLDETECT:
//      if(!_fRich)
//          hr = lres = E_FAIL;

        if(lparam || (wparam | 1) != 1)
        {
            hr = lres = E_INVALIDARG;
            break;
        }
        if(wparam == TRUE && !_pdetecturl)
        {
            _pdetecturl = new CDetectURL(this);
            if(!_pdetecturl)
                hr = lres = E_OUTOFMEMORY;
        }
        else if(!wparam && _pdetecturl)
        {
            delete _pdetecturl;
            _pdetecturl = NULL;
        }
        break;

    case EM_GETAUTOURLDETECT:
        Assert(lres == 0 && hr == NOERROR);
        if(_pdetecturl)
            lres = TRUE;
        break;

    case WM_SIZE:
        // We reset the "number of tries to put an active object
        // in place" count here
        _cActiveObjPosTries = MAX_ACTIVE_OBJ_POS_TRIES;
        hr = S_FALSE;
        break;

    case WM_SETTINGCHANGE:
        // System parameters have changed.  We need to update them.
        // Note : Since we don't protect access to system parameters
        // with locks, it may be possible for some instances to not
        // see the changes immediately
        lres = 0;
        W32->InitSysParams(TRUE);

        if (W32->GetDigitSubstitutionMode() != DIGITS_NOTIMPL)
            OrCharFlags(fDIGITSHAPE, publdr);

        break;

    case EM_CONVPOSITION:
        if (wparam)
            lres = GetCpFromAcp(lparam);
        else
            lres = GetAcpFromCp(lparam);
        break;

#ifndef NOACCESSIBILITY
    case WM_GETOBJECT:
        // We need to expose the TOM interface for Accessibility by
        // calling LresultFromObject when lparam == OBJID_NATIVEOM
        if (lparam == OBJID_NATIVEOM)
        {
            IUnknown* punk;
            QueryInterface(IID_IUnknown, (void**)&punk);
            Assert(punk);
            lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
            punk->Release();
            break;
        }
#endif

    default:
def:    hr = S_FALSE;
        break;
    }

    if(plresult)
        *plresult = lres;

    // TODO: FOR TESTING AIMM
    if (hr == S_FALSE && fHaveAIMM)
    {
        HWND hWnd;

        TxGetWindow(&hWnd);
        hr = CallAIMMDefaultWndProc(hWnd, msg, wparam, lparam, plresult);
    }
    return hr;
}

/*
 *  CTxtEdit::TxDraw (dwDrawAspect, lindex, pvAspect, ptd, hdcDraw,
 *                    hicTargetDev, lprcBounds, lprcWBounds, lprcUpdate,
 *                    pfnContinue, dwContinue)
 *
 *  @mfunc  Draws the text services object
 *
 *  @rdesc  HRESULT (typically S_OK).
 *
 *  @comm
 *
 *  This method renders the Text Services. It accepts the same parameters
 *  as the corresponding IViewObject::Draw method in OLE, with the extra
 *  <p lprcUpdate > parameter. It can be used while the host is inactive
 *  or active (in-place).
 *
 *  If dwDrawAspect is DVASPECT_CONTENT, this method should render a screen
 *  image of the text content to the hdcDraw device context. The hicTargetDev
 *  and ptd parameters give information on the target device context if any
 *  (usually a printer).
 *
 *  The lprcClient parameter gives the rectangle to render to, also called
 *  "client rectangle". This rectangle represents the position and extents
 *  of the entire image of the Text Services to be drawn. It is expressed in
 *  the logical coordinate system of hdcDraw. This parameter can only be NULL
 *  if the control is active. In that case, Text Services should render the
 *  in-place active view (which client rectangle can be obtained by calling
 *  TxGetClientRect on the host).
 *
 *  The lprcUpdate parameter, if not NULL, gives the rectangle to update
 *  inside that client rectangle. It is given in the logical coordinate system
 *  of hdcDraw. If NULL, the entire client rectangle should be painted.
 *
 *  Text Services should render with the appropriate zooming factor, which
 *  can be obtained from the client rect and the native size given by
 *  ITextHost::TxGetExtent. For more information, see ITextHost::TxGetExtent.
 *
 *  If the drawing aspect is DVASPECT_DOCPRINT, the TxDraw method can assume
 *  that it is rendering to the printer. In that case, hdcDraw is the printer
 *  device context. TxDraw should still render the lprcBounds rectangle,
 *  starting at the current scrolling position. TS can make optimization for
 *  rendering to the printer (like not painting the background color if white)
 *  and certain screen specific elements (such as the selection) should not be
 *  rendered.
 *
 *  General comments on OLE hosts and TxDraw (and TxSetCursor, TxQueryHitPoint):
 *
 *  OLE hosts can call the TxDraw method at any time with any rendering DC or
 *  client rectangle. All an inactive OLE object has on a permanent basis is
 *  a himetric extent. It gets the rectangle in which to render only via the
 *  IViewObject::Draw call and this rectangle is valid only for the scope of
 *  that method. In fact, the same control can be rendered consecutively in
 *  different rectangles and different DCs for example because it is displayed
 *  simultaneously in different views on the screen.
 *
 *  The client rectangle and DC passed to TxDraw should normally not be cached.
 *  However, this would force Text Services to recalc lines for every single
 *  draw, which would lead to terrible performance. So it is likely that Text
 *  Services will actually cache some information computed for a specific
 *  client rectangle and DC (such as the line breaks for example). On the
 *  next call to TxDraw, however, the validity of the cached information
 *  should be checked before it gets used, and updated information should be
 *  regenerated if necessary.
 *
 *  When the control is in-place active, the problem is even more complex
 *  since TxDraw can still be called to render other views than the in-place
 *  active one. In other words, the client rectangle passed to TxDraw may
 *  not be the same as the active view one (passed to OnTxInPlaceActivate
 *  and obtained via TxGetClientRect on the host).The the host specifies
 *  what view they wish to display based on the lViewId parameter. If the
 *  value for lViewId is TXTVIEW_ACTIVE, the view referred to is the inplace
 *  active view. TXTVIEW_INACTIVE means some other view such as a print
 *  preview or even printing itself. It is important to note that
 *  TXTVIEW_INACTIVE views may not have scroll bars.
 *
 *  The same comments apply to TxSetCursor and TxQueryHitPoint, discussed
 *  in the following sections.
 */
HRESULT CTxtEdit::TxDraw(
    DWORD    dwDrawAspect,  //@parm Draw aspect
    LONG     lindex,        //@parm Currently unused
    void *   pvAspect,      //@parm Info for drawing optimizations (OCX 96)
    DVTARGETDEVICE *ptd,    //@parm Info on target device
    HDC      hdcDraw,       //@parm Rendering device context
    HDC      hicTargetDev,  //@parm Target information context
    LPCRECTL lprcBounds,    //@parm Bounding (client) rectangle
    LPCRECTL lprcWBounds,   //@parm Clipping rect for metafiles
    LPRECT   lprcUpdate,    //@parm Dirty rectangle inside lprcBounds
    BOOL (CALLBACK * pfnContinue) (DWORD), //@parm Callback for interupting
                            //      long display (currently unused)
    DWORD    dwContinue,    //@parm Parameter to pass to pfnContinue function
    LONG     lViewId)       //@parm View identifier
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxDraw");

    HRESULT hr;

	// JMO : FUTURE : We should do sometning about reentrant draws sometime.
	// If we do that may procide a simpler fix for RAID bug 7212.

#if !defined(NOMAGELLAN)
    CMagellanBMPStateWrap bmpOff(*this, hdcDraw);
#endif

    // These are rect's are used if we convert the the input parameters if we
    // convert the HDC's mapping mode. The idea here is we avoid changing our
    // clients memory.
    RECTL rcLocalBounds;
    RECTL rcLocalWBounds;
    RECT rcLocalUpdate;
    CCallMgr callmgr(this);

    START_PROFILING

    // If the display is frozen, don't let ourselves draw.  This is a pretty
    // hoaky re-entrancy check.
    // FUTURE (alexgo/ricksa): be better about this.
    if(TXTVIEW_ACTIVE == lViewId && _pdp->IsFrozen())
    {
        _pdp->SetNeedRedisplayOnThaw(TRUE);
        TRACEINFOSZ("Forcing a redisplay on thaw");
        return E_UNEXPECTED;
    }

    if(dwDrawAspect != DVASPECT_CONTENT && dwDrawAspect != DVASPECT_DOCPRINT)
    {
        // We don't support the aspect requested
        return DV_E_DVASPECT;
    }

    if(!lprcBounds && !_fInPlaceActive || hicTargetDev && !ptd)
    {
        // If we are not inplace active we must have a client rectangle
        return E_INVALIDARG;
    }

    HDC hicLocal = NULL;

    // Did they give us a ptd without a hic?
    if(!hicTargetDev && ptd)
    {
        // Create and information context for the device information
        // since it wasn't supplied.
        hicLocal = CreateIC(
            (TCHAR *)((BYTE *) ptd + ptd->tdDriverNameOffset),
            (TCHAR *)((BYTE *) ptd + ptd->tdDeviceNameOffset),
            (TCHAR *)((BYTE *) ptd + ptd->tdPortNameOffset),
            (DEVMODE *)((BYTE *)  ptd + ptd->tdExtDevmodeOffset));
        if(!hicLocal)
            return E_FAIL;                     // Couldn't create it

        hicTargetDev = hicLocal;
    }

    BOOL fRestore = FALSE;

    // Force DC in MM_TEXT
    if(GetMapMode(hdcDraw) != MM_TEXT &&
       GetDeviceCaps(hdcDraw, TECHNOLOGY) != DT_METAFILE)
    {
        fRestore = TRUE;

        // Convert input parameters to new mapping.
        if(lprcBounds)
        {
            rcLocalBounds = *lprcBounds;
            lprcBounds = &rcLocalBounds;
            WinLPtoDP(hdcDraw, (POINT *)lprcBounds, 2);
        }

        if(lprcWBounds)
        {
            rcLocalWBounds = *lprcWBounds;
            lprcWBounds = &rcLocalWBounds;
            WinLPtoDP(hdcDraw, (POINT *)lprcWBounds, 2);
        }

        if(lprcUpdate)
        {
            rcLocalUpdate = *lprcUpdate;
            lprcUpdate = &rcLocalUpdate;
            WinLPtoDP(hdcDraw, (POINT *)lprcUpdate, 2);
        }
        // Convert HDC to new mapping
        ConvertDrawDCMapping(hdcDraw);
    }

    // Preallocate the memory so the set cannnot fail and we don't
    // have to use the heap. Note that all clean up is handled
    // outside of this object. Also note that we don't assign any
    // information here because we may not use this structure. If
    // recursion is happening we will use the top level structure.
    CDrawInfo di(this);

    _pdp->SetDrawInfo(
        &di,
        dwDrawAspect,
        lindex,
        pvAspect,
        ptd,
        hicTargetDev);

    // We use our main display object if we are the active view (which is
    // indicate by the supplied client rectangle) or if the object is
    // inactive and the ptd is NULL. We assume that the ptd being NULL means
    // that the display request is for the screen and not for a print or
    // print preview.
    if(TXTVIEW_ACTIVE == lViewId || !ptd)
    {
        hr = S_FALSE;

        // The main display object draws active views and tries to draw
        // inactive views if the control is not active.
        if (!lprcWBounds &&
            ( fInplaceActive() && TXTVIEW_ACTIVE   == lViewId ||
             !fInplaceActive() && TXTVIEW_INACTIVE == lViewId))
        {
            hr = _pdp->Draw(hdcDraw, hicTargetDev,  // We aren't interruptable
                (RECT *)lprcBounds,                 //  drawing to screen, so
                (RECT *)lprcWBounds,                //  why pretend?
                lprcUpdate, NULL, 0);
        }

        if(S_FALSE == hr)
        {
            // This is an inactive view for which the cached state
            // does not match the input request so we make a special
            // object to do the drawing.
            CDisplay *pdp = _pdp->Clone();
            if(pdp)
            {
                // Force recalc - this tells Draw to draw no matter what
                pdp->InvalidateRecalc();
                hr = pdp->Draw(hdcDraw, hicTargetDev, // Do the draw
                    (RECT *)lprcBounds,
                    (RECT *)lprcWBounds,
                    lprcUpdate, NULL, 0);
            }
            delete pdp;
        }
    }
    else
    {
        // Make a copy so that we can update it
        RECT rcForPrint = *((RECT *)lprcBounds);

        // We want data both formatted and printed
        hr = FormatAndPrint(hdcDraw, hicTargetDev, ptd, &rcForPrint,
                (RECT*)lprcWBounds);

        struct SPrintControl prtcon;

        // This call to OnFormatRange simply cleans up printer object
        OnFormatRange(NULL, prtcon);
    }

    _pdp->ReleaseDrawInfo();

    if(fRestore)                        // Put DC back into correct mapping mode
        RestoreDC(hdcDraw, -1);

    if(hicLocal)                        // Clean up information context
        DeleteDC(hicLocal);             //  if we created one

    // An active OLE object might have been dragged/scrolled away
    // from where it belongs. We need to put it back.
    // The _cActiveObjPosTries guards us from an indefinite looop here
    // (OnReposition may post another paint message, and so on)
    // We only do this when we were notified of a position or size change
    COleObject* poleobjActive;
    if (HasObjects() && _cActiveObjPosTries &&
        (poleobjActive = GetObjectMgr()->GetInPlaceActiveObject()))
    {
        // Reduce number of tries
        _cActiveObjPosTries--;

        // BUG FIX 6073
        // Only fetch the extent if the object view size or position
        // has changed
        // Get new object size (we might have resized it,
        // and we don't want to lose that!!)
        if (poleobjActive->GetViewChanged())
        {
            poleobjActive->FetchObjectExtents();
            poleobjActive->ResetViewChanged();
        }


        // Get right coordinates for object
        poleobjActive->ResetPosRect();

        // and put it there!!
        poleobjActive->OnReposition(0, 0);
    }
    return hr;
}

/*
 *  CTxtEdit::TxGetHScroll (plMin, plMax, plPos, plPage, pfEnabled)
 *
 *  @mfunc
 *      Get horizontal scroll bar state information
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::TxGetHScroll(
    LONG *plMin,        //@parm Minimum scroll position
    LONG *plMax,        //@parm Maximum scroll position
    LONG *plPos,        //@parm Current scroll position
    LONG *plPage,       //@parm View width in pixels
    BOOL *pfEnabled)    //@parm Whether horizonatl scrolling is enabled.
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetHScroll");

    START_PROFILING

    if(plMin)
        *plMin = 0;

    if(plMax)
        *plMax = _pdp->GetScrollRange(SB_HORZ);

    if(plPos)
        *plPos = _pdp->GetXScroll();

    if(plPage)
        *plPage = _pdp->GetViewWidth();

    // CDisplay::_fHScrollEnabled may be TRUE when not in-place active
    // because it has a dual meaning: 1) need Horiz scroll bars, and 2)
    // CDisplay::_xScroll is allowed for ES_AUTOHSCROLL even with no
    // horizontal scrollbar.  The latter can turn on _fHScrollEnabled when
    // the control is active and when the control goes inactive, it stays
    // on, so we say it's off to keep Forms^3 from displaying a horizontal
    // scroll bar. We probably should have two flags: _fHScrollEnabled and
    // _fHScrollbarEnabled, but for now, we stick with one.  No such problem
    // for vertical case, since vertical scrolling always uses a scrollbar.
    if(pfEnabled)
        *pfEnabled = _fInPlaceActive ? _pdp->IsHScrollEnabled() : 0;

    return S_OK;
}

/*
 *  CTxtEdit::TxGetVScroll (plMin, plMax, plPos, plPage, pfEnabled)
 *
 *  @mfunc
 *      Get vertical scroll bar state information
 *
 *  @rdesc
 *      HRESULT = S_OK
 */
HRESULT CTxtEdit::TxGetVScroll(
    LONG *plMin,        //@parm Minimum scroll position
    LONG *plMax,        //@parm Maximum scroll position
    LONG *plPos,        //@parm Current scroll position
    LONG *plPage,       //@parm Height of view in pixels
    BOOL *pfEnabled)    //@parm Whether vertical scroll bar is enabled.
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetVScroll");

    if(plMin)
        *plMin = 0;

    if(plMax)
        *plMax = _pdp->GetScrollRange(SB_VERT);

    if(plPos)
    {
        *plPos = _pdp->GetYScroll();
        *plPos = _pdp->ConvertYPosToScrollPos(*plPos);
    }

    if(plPage)
    {
        *plPage = _pdp->GetViewHeight();
        *plPage = _pdp->ConvertYPosToScrollPos(*plPage);
    }

    if(pfEnabled)
        *pfEnabled = _pdp->IsVScrollEnabled();

    return S_OK;
}

/*
 *  CTxtEdit::OnTxSetCursor (dwDrawAspect, lindex, pvAspect, ptd, hdcDraw,
 *                           hicTargetDev, lprcClient, x, y)
 *  @mfunc
 *      Notification for text services to set the cursor
 *
 *  @rdesc
 *      HRESULT = FAILED(RectChangeHelper()) ? E_INVALIDARG : S_OK
 *
 *  @comm
 *      Text Services may remeasure as a result of this call in
 *      order to determine the correct cursor.  The correct
 *      cursor will be set via ITextHost::TxSetCursor
 *
 *      More details:
 *
 *      The lprcClient parameter is the client rectangle of the view of the
 *      control over which the mouse cursor is. It is in device coordinates
 *      of the containing window in the same way the WM_SIZE message is. This
 *      may not be the view that was rendered last. Furthermore, if the control
 *      is in-place active, this may not be the view currently being active.
 *      As a consequence, Text Services should check this rectangle against
 *      its current caches values and determine whether recalcing the lines
 *      is necessary or not. The zoom factor should be included in this
 *      computation.
 *
 *      This method should only be called for screen views of the control.
 *      Therefore the DC is not passed in but should be assumed to be a screen
 *      DC.
 *
 *      The x and y parameters hold the cursor position in the same coordinate
 *      system as lprcClient, i.e., the client coordinates of the containing
 *      window.
 */
HRESULT CTxtEdit::OnTxSetCursor (
    DWORD   dwDrawAspect,   //@parm Draw aspect
    LONG    lindex,         //@parm Currently unused
    void *  pvAspect,       //@parm Info for drawing optimizations (OCX 96)
    DVTARGETDEVICE *ptd,    //@parm Info on target device
    HDC     hdcDraw,        //@parm Rendering device context
    HDC     hicTargetDev,   //@parm Target information context
    LPCRECT lprcClient,     //@parm Control's client rectangle
    INT     x,              //@parm x position of cursor
    INT     y)              //@parm y position of cursor
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxSetCursor");

    CCallMgr callmgr(this);
    BOOL     fText = FALSE;
    HITTEST  Hit;
    RECT     rcClient;
    CDrawInfo di(this);
    START_PROFILING

    if(FAILED(RectChangeHelper(&di, dwDrawAspect, lindex, pvAspect, ptd,
                               hdcDraw, hicTargetDev, &lprcClient, &rcClient)))
    {
        return E_INVALIDARG;
    }

    // Set the cursor
    CTxtSelection * const psel = GetSel();
    HCURSOR hcurNew = _hcurArrow;           // Default using system arrow
    POINT   pt = {x, y};
    BOOL    fInLink = FALSE;

    if(PtInRect(&rcClient, pt))
    {
        // Find out what the cursor is pointing at
        _pdp->CpFromPoint(pt, lprcClient, NULL, NULL, FALSE, &Hit);

        if(Hit == HT_LeftOfText)
            hcurNew = _hcurSelBar;

        // This is a bit strange, but RichEdit 1.0 does this--give client a
        // chance to handle cursor itself if we are over a link.
        else if(Hit == HT_Link)
        {
            if(HandleLinkNotification(WM_SETCURSOR, 0,
                MAKELPARAM(pt.x, pt.y), &fInLink))
            {
                return NOERROR;
            }
            hcurNew = _hcurHand;
        }
        else if(Hit != HT_Nothing && Hit != HT_OutlineSymbol && Hit != HT_BulletArea)
        {
            if(!psel || !psel->PointInSel(pt, lprcClient) || _fDisableDrag)
            {
                hcurNew = (Hit == HT_Italic) ? _hcurItalic : _hcurIBeam;
                fText = TRUE;
            }

            // If we have an object manager and if there is a selected object,
            // check for hits on the frame handles.
            if(_pobjmgr)
            {
                COleObject *pobjselect = _pobjmgr->GetSingleSelect();
                if(pobjselect)
                {
                    // Handle hits on frame handles.
                    LPTSTR  idcur   = pobjselect->CheckForHandleHit(pt);
                    HCURSOR hcurObj = W32->GetSizeCursor(idcur);
                    if(hcurObj)
                        hcurNew = hcurObj;
                }
            }
        }
    }
    _phost->TxSetCursor(hcurNew, fText);    // Tell host to set cursor
    if(hdcDraw)                             // Release DC if we got it
        _pdp->ResetDC();

    _pdp->ReleaseDrawInfo();
    return S_OK;
}

/*
 *  CTxtEdit::TxQueryHitPoint (dwDrawAspect, lindex, pvAspect, ptd, hdcDraw,
 *                              hicTargetDev, lprcClient, x, y, pHitResult)
 *  @mfunc
 *      Returns whether point is within text services rectangle
 *
 *  @rdesc
 *      HRESULT
 *
 *  @comm
 *      This method allows the host to implement transparent hit-testing
 *      on text.
 *
 *      The lprcClient parameter is the client rectangle in device coordinates
 *      of the view on which hit testing is performed.
 *
 *      The pt parameter hold the position of the cursor in the same
 *      coordinate system as the lprcClient rectangle (the client
 *      coordinates of the containing window).
 *
 *      Same general comments about client rectangle and DC as for
 *      TxSetCursor apply.
 *
 *      pHitResult returns one of the following values: <nl>
 *
 *      TXTHITRESULT_NOHIT       Hit was outside client rectangle. <nl>
 *      TXTHITRESULT_HIT         Point was inside client rectangle and over
 *                               either text or an opaque background.
 *      TXTHITRESULT_TRANSPARENT Point was inside client rectangle with a
 *                               transparent background and not over text.
 *      TXTHITRESULT_CLOSE       Hit was close to an opaque area.
 *
 *      Refer to the Windowless OLE Control spec for more details on
 *      these return values and how they should be determined.
 */
HRESULT CTxtEdit::TxQueryHitPoint(
    DWORD   dwDrawAspect,   //@parm Draw aspect
    LONG    lindex,         //@parm Currently unused
    void *  pvAspect,       //@parm Info for drawing optimizations (OCX 96)
    DVTARGETDEVICE *ptd,    //@parm Info on target device
    HDC     hdcDraw,        //@parm Rendering device context
    HDC     hicTargetDev,   //@parm Target information context
    LPCRECT lprcClient,     //@parm Control's client rectangle
    INT     x,              //@parm x coordinate to check
    INT     y,              //@parm y coordinate to check
    DWORD * pHitResult)     //@parm Result of hit test see TXTHITRESULT
                            //      enumeration for valid values
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxQueryHitPoint");

    RECT     rcClient;
    CCallMgr callmgr(this);
    CDrawInfo di(this);

    START_PROFILING

    if (FAILED(RectChangeHelper(&di, dwDrawAspect, lindex, pvAspect, ptd,
        hdcDraw, hicTargetDev, &lprcClient, &rcClient)))
    {
        return E_INVALIDARG;
    }

    HRESULT hr;
    POINT   pt = {x, y};

    if(!_fTransparent)
    {
        *pHitResult = TXTHITRESULT_HIT;
        hr = S_OK;
    }
    else
        hr = _pdp->TransparentHitTest(hdcDraw, lprcClient, pt, pHitResult);

    // Release DC if we got it
    if(hdcDraw)
        _pdp->ResetDC();

    _pdp->ReleaseDrawInfo();
    return hr;
}

/*
 *  CTxtEdit::OnTxInPlaceActivate (prcClient)
 *
 *  @mfunc
 *      Notifies text services that this control is inplace active
 *
 *  @rdesc
 *      S_OK - successfully activated object <nl>
 *      E_FAIL - could not activate object due to error. <nl>
 *
 *  @comm
 *      When transitioning directly from a non-active state to the UI-active
 *      state, the host should call OnTxInPlaceActivate first and then
 *      OnTxUIActivate. Similarly, when transitioning from the UI-active
 *      state to a non active state, the host should call OnTxUIDeactivate
 *      first and then OnTxInPlaceDeactivate.
 *
 *      OnTxInPlaceActivate takes the client rectangle of the view being
 *      activated as a parameter. This rectangle is given in client coordinate
 *      of the containing window. It is the same as would be obtained by
 *      calling TxGetClientRect on the host.
 *
 *      UI-activation is different from getting the focus. To let Text
 *      Services know that the control is getting or losing focus, the
 *      host will send WM_SETFOCUS and WM_KILLFOCUS messages. Note that a
 *      windowless host will pass NULL as the wParam (window that lost the
 *      focus) for these messages.
 *
 *      As a reminder, inplace activation typically refers to an embedded
 *      object "running inplace" (for regular controls && embeddings, it
 *      would have a window to draw in, for example).  UI active means that
 *      an object currently has the 'editing focus'.  Specifically, things
 *      like menus and toolbars on the container may also contain elements
 *      from the UI active control/embedding.  There can only be one
 *      UI active control at any given time, while many can be inplace active
 *      at once.
 */
HRESULT CTxtEdit::OnTxInPlaceActivate(
    const RECT *prcClient)  //@parm Control's client rectangle
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxInPlaceActivate");

    RECT rcView;
    HDC hdc;
    BOOL fSucceeded = TRUE;
    CCallMgr callmgr(this);

    START_PROFILING

    // Needs to set here for further TxGetDC() to work
    _fInPlaceActive = TRUE;

    // Set rendering DC to be the screen
    hdc = TxGetDC();
    if(!hdc)
        goto err;

    // Tell display that it is active
    _pdp->SetActiveFlag(TRUE);
    _pdp->SetDC(hdc);

    // Compute view rect from passsed in client rect
    _pdp->GetViewRect(rcView, prcClient);

    // Recalc/update view
    _pdp->RecalcView(rcView);

    // Get selection.  Otherwise, if SetFocus is called later without
    // selection, then the Selection state is not set correctly.
    GetSel();
    if(_pdp->GetViewWidth())
    {
        // Get selection if we can
        if(_psel)                       // Set the caret
            _psel->Update(FALSE);
        else                            // Couldn't create selection,
            fSucceeded = FALSE;         //  so fail activation
    }

    // Release the DC
    TxReleaseDC(hdc);
    _pdp->SetDC(NULL);

    // If getting the selection worked we are home free
    if(fSucceeded)
        return S_OK;

err:
    _fInPlaceActive = FALSE;
    return E_FAIL;
}

/*
 *  CTxtEdit::OnTxInPlaceDeactivate()
 *
 *  @mfunc  Notifies text services that this is no longer in place active.
 *
 *  @rdesc  S_OK
 *
 *  @comm   See OnTxInPlaceActivate for a detailed description of
 *  activation/deactivation.
 *
 *  @xref <mf CTxtEdit::OnTxInPlaceActivate>
 *
 */
HRESULT CTxtEdit::OnTxInPlaceDeactivate()
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxInPlaceDeactivate");

    START_PROFILING

    // Get properties that affect whether we will discard the selection
    DWORD dwBits;

    // Tell display that it is not longer active
    _pdp->SetActiveFlag(FALSE);

    // Because we are inactive, this will tell any background recalc going
    // on to stop.
    _pdp->StepBackgroundRecalc();

    _phost->TxGetPropertyBits(TXTBIT_HIDESELECTION | TXTBIT_SAVESELECTION,
        &dwBits);

    // If we don't want to save the selection and we want to hide it while
    // inactive, then we discard our selection
    if(!(dwBits & TXTBIT_SAVESELECTION) && (dwBits & TXTBIT_HIDESELECTION))
        DiscardSelection();

    _fInPlaceActive = FALSE;
    return S_OK;
}

/*
 *  CTxtEdit::OnTxUIActivate()
 *
 *  @mfunc  Informs text services that the control is now UI active.
 *
 *  @rdesc  S_OK
 *
 *  @comm   See OnTxInPlaceActivate for a detailed description of
 *  activation/deactivation.
 *
 *  @xref <mf CTxtEdit::OnTxInPlaceActivate>
 *
 *
 */
HRESULT CTxtEdit::OnTxUIActivate()
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxUIActivate");

    return S_OK;
}

/*
 *  CTxtEdit::OnTxUIDeactivate()
 *
 *  @mfunc  Informs text services that the control is now UI deactive.
 *
 *  @rdesc  S_OK
 *
 *  @comm   See OnTxInPlaceActivate for a detailed description of
 *  activation/deactivation.
 *
 *  @xref <mf CTxtEdit::OnTxInPlaceActivate>
 *
 */
HRESULT CTxtEdit::OnTxUIDeactivate()
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxUIDeactivate");

    return S_OK;
}

/*
 *  CTxtEdit::TxGetText (pbstrText)
 *
 *  @mfunc  Returns all of the UNICODE plain text in the control as an
 *          OLE BSTR.
 *
 *  @rdesc
 *      S_OK - Text successfully returned in the output argument <nl>
 *      E_INVALIDARG - invalid BSTR pointer passed in. <nl>
 *      E_OUTOFMEMORY - could not allocate memory for copy of the text <nl>
 *
 *  @comm   The caller takes ownership of the returned BSTR.  WM_GETTEXT
 *          and TOM ITextRange::GetText are alternate techniques for
 *          retrieving plain text data.
 *
 *          If there is no text in the control, no BSTR will be allocated
 *          and NULL will be returned.
 *
 *          The returned text will NOT necessarily be NULL terminated.
 */
HRESULT CTxtEdit::TxGetText(
    BSTR *pbstrText )   //@parm where to return an allocated BSTR
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetText");

    CTxtPtr     tp(this, 0);
    CCallMgr callmgr(this);

    START_PROFILING

    if(!pbstrText)
        return E_INVALIDARG;

    const LONG cch = GetTextLength();

    if(cch <= 0)
    {
        *pbstrText = 0;
        return S_OK;
    }
    *pbstrText = SysAllocStringLen(NULL, cch);
    if(!*pbstrText)
    {
        GetCallMgr()->SetOutOfMemory();
        return E_OUTOFMEMORY;
    }

    tp.GetText(cch, *pbstrText);
    return S_OK;
}

/*
 *  CTxtEdit::TxSetText (pszText)
 *
 *  @mfunc  Sets all of the text in the control
 *
 *  @rdesc
 *      S_OK - text was successfully set    <nl>
 *      E_FAIL - text could not be updated. <nl>
 *
 *  @comm
 *      This method should be used with care; it essentially re-initializes
 *      the text engine with some new data; any previous data and formatting
 *      information will be LOST, including undo information.
 *
 *      If previous data has been copied to the clipboard, that data will be
 *      rendered completely to the clipboard (via OleFlushClipboard) before
 *      it is discarded.
 *
 *      This method is NOT undo-able.
 *
 *      Two alternate approaches to setting text are WM_SETTEXT and TOM
 *      ITextRange::SetText.
 *
 *  @xref
 *      <mf CTxtRange::SetText>
 */
HRESULT CTxtEdit::TxSetText(
    LPCTSTR pszText)        //@parm String to replace the current text with
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxSetText");

    START_PROFILING

    return SetText(pszText, ST_CHECKPROTECTION, 1200);
}

/*
 *  CTxtEdit::TxGetCurTargetX (px)
 *
 *  @mfunc
 *      Get the target x position of the caret
 *
 *  @rdesc
 *      HRESULT with possible values:
 *
 *      S_OK         - x position of the caret returned <nl>
 *      E_FAIL       - There is no selection <nl>
 *      E_INVALIDARG - Input argument is invalid <nl>
 *
 *  @comm
 *      This method is useful for implementing up-down cursoring
 *      through a conceptual vertical line.  To illustrate this feature,
 *      consider setting the insertion point at, say, column 20 in a
 *      text editor.  Now cursor up and down--notice that wherever possible,
 *      the editor tries to put the insertion point as close to column 20
 *      as it can for the current line.  Column 20 is thus the "target" column
 *      for the insertion point.
 *
 *      Users would like to have this same capability when cursoring through
 *      Forms; however, as other controls don't necessarily share the same
 *      notion of column position, the target caret position is expressed simply
 *      as an x-coordinate on the display (in *client* coordinates).
 */
HRESULT CTxtEdit::TxGetCurTargetX(
    LONG *px)           //@parm the x location in client coordinates
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetCurTargetX");

    START_PROFILING
    CTxtSelection *psel = GetSel();

    if(!psel)
        return E_FAIL;

    if(!px)
        return E_INVALIDARG;

    *px = psel->GetXCaretReally();
    return S_OK;
}

/*
 *  CTxtEdit::TxGetBaseLinePos(pBaseLinePos)
 *
 *  @mfunc  Get the base line position of the first visible line, in pixels,
 *  relative the TS client rectangle. Needed for aligning controls on their
 *  baselines.
 *
 *  @rdesc  HRESULT = E_NOTIMPL
 */
HRESULT CTxtEdit::TxGetBaseLinePos(
    LONG *pBaseLinePos)     //@parm Where to return baseline position
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetBaseLinePos");

    return E_NOTIMPL;
}

/*
 *  CTxtEdit::TxGetNaturalSize (dwAspect, hdcDraw, hicTargetDev, ptd, dwMode,
 *                              psizelExtent, pwidth, pheight)
 *
 *  @mfunc  Allow control to be resized so it fits content appropriately
 *
 *  @rdesc  S_OK            <nl>
 *          E_INVALIDARG    <nl>
 *          E_FAIL  Unable to determine correct size    <nl>
 *          E_OUTOFMEMORY   <nl>
 *
 *  @comm
 *
 *  The first 4 parameters are similar to equivalent parameters in
 *  TxDraw and give the same information. In the case TS needs to
 *  recalc lines, it should use these values the same ways as in
 *  TxDraw.
 *
 *  <p pWidth> and <p pHeight> are IN/OUT parameters. The host passes the
 *  "tentative" width and height of the client rectangle for the text object
 *  and Text Services will compare these values against its current cached
 *  state, and if different should recalc lines. Then it will compute
 *  and return the natural size. As spec-ed currently, the host can ask for 2
 *  different kinds of natural sizes:
 *
 *  TXTNS_FITTOCONTENT: the entire text should be formatted to the
 *  width that is passed in.Then Text Services return the height of
 *  the entire text and the width of the widest line. Note that this
 *  option ignores any paragraph formatting such as centering and
 *  only returns the raw size for the text.
 *
 *  TXTNS_ROUNDTOLINE: returns the integral height of the number of lines that
 *  will fit in the input height rounded to the next full line boundary.
 *
 *  Note that passed and returned width and height correspond to
 *  the *client* rectangle in client units.
 *
 *
 *  BACKGROUND
 *  Here is a quick description of the features mentioned above:
 *
 *  FITTOCONTEXT: Normally happens when the user double clicks one
 *  of the control grab handles. Sizes the control to the "optimal"
 *  size to fit the entire content. Should accomodate the height of
 *  the entire text and the width of the widest line.
 *
 *  ROUNDTOLINE (Integral height): if this property is set, when the
 *  user resizes the control, it snaps to heights that allow an
 *  integral number of lines to be displayed (no line will be clipped).
 */
HRESULT CTxtEdit::TxGetNaturalSize(
    DWORD   dwAspect,   //@parm Aspect for drawing.  Values taken from OLE's
                        //      DVASPECT enumeration
    HDC     hdcDraw,    //@parm DC into which drawing would occur
    HDC hicTargetDev,   //@parm DC for which text should be formatted, i.e.,
                        //      for WYSIWYG
    DVTARGETDEVICE *ptd,//@parm More info on the target device
    DWORD   dwMode,     //@parm Type of fitting requested.  Either
                        //      TXTNS_FITTOCONTENT or TXTNS_ROUNDTOLINE
    const SIZEL *psizelExtent,//@parm Size of extent to use for zooming
    LONG *  pwidth,     //@parm Width for such a fitting [in,out]
    LONG *  pheight)    //@parm Height for such a fitting [in,out]
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetNaturalSize");

    HRESULT hr;
    CCallMgr callmgr(this);

    START_PROFILING

    if(dwAspect != DVASPECT_CONTENT && dwAspect != DVASPECT_DOCPRINT)
    {
        // We don't support the aspect requested
        return DV_E_DVASPECT;
    }

    if (hicTargetDev && !ptd ||
        dwMode != TXTNS_FITTOCONTENT && dwMode != TXTNS_ROUNDTOLINE ||
        !pwidth || !pheight)
    {
        // Either and information context is provided without the device
        // target or the mode is not valid or the width was not provided
        // or the height was not provided. In short, the input parameters
        // are not valid so tell the caller.
        return E_INVALIDARG;
    }

    if(!psizelExtent->cy)
    {
        // No extent for control, so just return 0
        *pwidth = 0;
        *pheight = 0;
        return S_OK;
    }

    HDC hicLocal = NULL;

    // Did they give us a ptd without a hic?
    if(!hicTargetDev && ptd)
    {
        // Create and information context for the device information
        // since it wasn't supplied.
        hicLocal = CreateIC(
            (TCHAR *)((BYTE *) ptd + ptd->tdDriverNameOffset),
            (TCHAR *)((BYTE *) ptd + ptd->tdDeviceNameOffset),
            (TCHAR *)((BYTE *) ptd + ptd->tdPortNameOffset),
            (DEVMODE *)((BYTE *)  ptd + ptd->tdExtDevmodeOffset));

        if(!hicLocal)
            return E_FAIL;              // Couldn't create it

        hicTargetDev = hicLocal;
    }

    // Assume that we need to change mapping modes. Note that we need to be
    // in MM_TEXT because our measuring assumes this is so.
    BOOL fRestore = FALSE;

    // Convenient place to put height & width for converting them to
    // device units.
    POINT pt;
    pt.x = *pwidth;
    pt.y = *pheight;

    // WARNING: From this point on we expect to execute this routine clear
    // through so that the DC state can be reset if we set it and because
    // we reset the extents so that the zoom factor can be calculated
    // appropriately for this call. Therefore, be very careful about
    // any return statements you might want to add.

    // force DC in MM_TEXT
    if(GetMapMode(hdcDraw) != MM_TEXT &&
        GetDeviceCaps(hdcDraw, TECHNOLOGY) != DT_METAFILE)
    {
        WinLPtoDP(hdcDraw, &pt, 1);         // Convert to device units
        fRestore = TRUE;                    // Remember that DC got converted
        ConvertDrawDCMapping(hdcDraw);
    }

    // Set the extent information needed for zooming
    _pdp->SetTempZoomDenominator(psizelExtent->cy);

    if(TXTNS_ROUNDTOLINE == dwMode)
    {
        // Round to fit simply calculates the
        hr = _pdp->RoundToLine(hdcDraw, pt.x, &pt.y);
    }
    else
    {
        // Get natural size for entire presentation
        // Allocate memory for the draw information
        CDrawInfo di(this);

        // Set up the drawing parameters
        _pdp->SetDrawInfo(
            &di,
            dwAspect,
            -1,
            NULL,
            ptd,
            hicTargetDev);

        // Set the Draw DC
        _pdp->SetDC(hdcDraw);

        // Tell display to figure size needed for this display
        hr = _pdp->GetNaturalSize(hdcDraw, hicTargetDev, dwMode, &pt.x, &pt.y);

        _pdp->ResetDC();                // Restore state
        _pdp->ReleaseDrawInfo();
    }

    if(fRestore)                        // Put DC back into correct
        RestoreDC(hdcDraw, -1);         //  mapping mode

    if(SUCCEEDED(hr))                   // Set return values if this worked
    {
        if(fRestore)
        {
            // Convert return value back to input logical units if we
            // converted them to use them.
            DPtoLP(hdcDraw, &pt, 1);
        }
        *pwidth = pt.x;                 // Update return values
        *pheight = pt.y;
    }

    if(hicLocal)                        // Clean up info context
        DeleteDC(hicLocal);             //  if we created one

    _pdp->ResetTempZoomDenominator();   // Reset temporary zoom factor

    return hr;
#else
    return 0;
#endif
}

/*
 *  CTxtEdit::TxGetDropTarget (ppDropTarget)
 *
 *  @mfunc  Get the drop target for the text control
 *
 *  @rdesc
 *      S_OK - Got drop target successfully <nl>
 *      E_OUTOFMEMORY - Could not create drop target <nl>
 *
 *  @comm
 *      The caller (host) is responsible for calling Register/Revoke
 *      DragDrop and for calling IUnknown::Release on the returned
 *      drop target when done.
 */
HRESULT CTxtEdit::TxGetDropTarget(
    IDropTarget **ppDropTarget) //@parm Where to put pointer to drop target
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetDropTarget");

    HRESULT hr;
    CCallMgr callmgr(this);

    START_PROFILING

    hr = _ldte.GetDropTarget(ppDropTarget);
    if(hr == NOERROR)
        (*ppDropTarget)->AddRef();
    return hr;
#else
    return 0;
#endif
}

/*
 *  CTxtEdit::OnTxPropertyBitsChange (dwMask, dwBits)
 *
 *  @mfunc  Set properties that can be represented by bits.
 *
 *  @rdesc  HRESULT
 *
 *  @comm   The following property bits are understood: <nl>
 *
 *      TXTBIT_RICHTEXT             <nl>
 *      TXTBIT_MULTILINE            <nl>
 *      TXTBIT_READONLY             <nl>
 *      TXTBIT_SHOWACCELERATOR      <nl>
 *      TXTBIT_USEPASSWORD          <nl>
 *      TXTBIT_HIDESELECTION        <nl>
 *      TXTBIT_SAVESELECTION        <nl>
 *      TXTBIT_AUTOWORDSEL          <nl>
 *      TXTBIT_AUTOSIZE             <nl>
 *      TXTBIT_VERTICAL             <nl>
 *      TXTBIT_SELECTIONBAR         <nl>
 *      TXTBIT_WORDWRAP             <nl>
 *
 *      TXTBIT_CLIENTRECTCHANGE     <nl>
 *      TXTBIT_VIEWINSETCHANGE      <nl>
 *      TXTBIT_BACKSTYLECHANGE      <nl>
 *      TXTBIT_MAXLENGTHCHANGE      <nl>
 *      TXTBIT_SCROLLBARCHANGE      <nl>
 *      TXTBIT_CHARFORMATCHANGE     <nl>
 *      TXTBIT_PARAFORMATCHANGE     <nl>
 *      TXTBIT_ALLOWBEEP            <nl>
 *      TXTBIT_EXTENTCHANGE         <nl>
 *
 *  A brief description of each property follows:
 *
 *
 *  Client rectangle (TXTBIT_CLIENTRECTCHANGE):
 *
 *  The rectangle the Text Services are responsible for painting
 *  and managing. The host will rely on the Text Services for painting
 *  that area. Text Services must not paint or invalidate areas outside of
 *  that rectangle.
 *
 *  The host will forward mouse messages to the Text Services whenever the
 *  cursor is over this rectangle.
 *
 *  This rectangle is expressed in client coordinates of the containing window.
 *
 *  IMPORTANT: this property cannot be queried from the host when it is
 *  inactive. The TxGetClientRect method will fail if called at inactive time.
 *
 *
 *  View inset (TXTBIT_VIEWINSETCHANGE):
 *
 *  This is the amount of space on each side between the client rectangle and
 *  the view rectangle. The view rectangle (also called Formating rectangle)
 *  is the rectangle the text should be formatted in.
 *
 *  The view insets are is passed in a RECT structure but this is not really
 *  a rectangle. It should be treated as 4 independent values to substract
 *  on each side of the client rectangle to figure the view rectangle.
 *
 *  The view insets are passed in himetrics so that they do not depend on
 *  the client rectangle and the rendering DC.
 *
 *  View insets can be negative on either side of the client rectangle,
 *  leading to a bigger view rectangle than the client rectangle. The text
 *  should then be clipped to the client rectangle. If the view rectangle
 *  is wider than the client rectangle, then the host may add a horizontal
 *  scrollbar to the control.
 *
 *  Single line Text Services ignore the right boundary of the view rectangle
 *  when formatting text.
 *
 *  The view inset is available from the host at all times, active or
 *  inactive.
 *
 *
 *  Backstyle (TXTBIT_BACKSTYLECHANGE):
 *
 *  The style of the background of the client rectangle. Can be either of
 *  the following values: <nl>
 *      #define TXTBACK_TRANSPARENT     0 <nl>
 *      #define TXTBACK_SOLID           1 <nl>
 *
 *  Values for this property are similar to VB4 values for the same property.
 *
 *
 *  MaxLength (TXTBIT_MAXLENGTHCHANGE):
 *
 *  The maximum length the text can have. Text Services should reject
 *  character insertion and  pasted text when this maximum is reached.
 *  TxSetText however should still accept (and set) text longer than the
 *  maximum length. This is because this method is used for binding and
 *  it is critical to maintain the integrity of the data the control
 *  is bound to.
 *
 *
 *  Scrollbar (TXTBIT_SCROLLBARCHANGE):
 *
 *  This property indicates which scollbar is present and whether scollbars
 *  are hidden or disabled when scrolling is impossible. It also controls
 *  auto-scrolling when the insertion point gets off the client rectangle.
 *
 *  This is a DWORD where bits are layed out as in the system window style.
 *  Possible bits are:
 *  WS_HSCROLL              // control has horizontal scrollbar <nl>
 *  WS_VSCROLL              // control has vertical scrollbar <nl>
 *  ES_AUTOVSCROLL          // auto-scroll horizontally <nl>
 *  ES_AUTOVSCROLL          // auto-scroll vertically <nl>
 *  ES_DISABLENOSCROLL      // scrollbar should be disabled when scrolling
 *                             impossible <nl>
 *
 *  Default CHARFORMAT (TXTBIT_CHARFORMATCHANGE):
 *
 *  The CHARFORMAT or CHARFORMAT2 used for default character-format runs,
 *  i.e., those not explicitly formatted via the selection or TOM methods.

 *
 *  Default PARAFORMAT (TXTBIT_PARAFORMATCHANGE):
 *
 *  The PARAFORMAT or PARAFORMAT2 used for default paragraph-format runs,
 *  i.e., those not explicitly formatted via the selection or TOM methods.
 *
 *
 *  TXTBIT_ALLOWBEEP:
 *
 *  TXTBIT_EXTENTCHANGE:
 *
 *
 *  TXTBIT_RICHTEXT:
 *
 *  Whether the Text Services should be in Rich-Text mode or not.  This
 *  principally affects how editing commands are applied.  For example,
 *  applying bold to some text in a plain edit control makes all of the
 *  text bold, rather than just the selected text in a rich text control.
 *
 *  Note that if there is either undo state or the object has any text,
 *  the attempt to change this bit will be ignored.
 *
 *
 *  TXTBIT_MULTILINE:
 *
 *  If this property is FALSE, Text Services should not process the CR
 *  key and truncate any incoming text containing hard line breaks just
 *  before the first line break. It is OK to also truncate text set via
 *  TxSetText (meaning, it is the responsibility of the host to not use a s
 *  single line control when bound to a multi-line field).
 *
 *  If this property is TRUE, Text Services should work in multiline mode.
 *  The TXTBIT_WORDWRAP can be used to know whether to wrap the lines to
 *  the view rectangle or clip them.
 *
 *
 *  TXTBIT_READONLY:
 *
 *  If this property is TRUE, Text Services should not accept any editing
 *  change via the user interface. However, they should still accept
 *  programmatic changes via EM_SETTEXT, EM_REPLACETEXT and TxSetText.
 *
 *  In read only mode, the user should still be able to move the
 *  insertion point, select text and carry out other non content modifying
 *  operations such as Copy.
 *
 *
 *  TXTBIT_SHOWACCELERATOR:
 *
 *  Refer to the "Accelerator" section for details about this property.
 *
 *
 *  TXTBIT_USEPASSWORD:
 *
 *  If this property is TRUE, the Text Services should show the entire
 *  text using the character obtained by TxGetPasswordChar.
 *
 *  The notification on this property may mean two different things:
 *   The password character changed,
 *   The password character was not used before and is used now
 *  (or vice versa).
 *
 *
 *  TXTBIT_HIDESELECTION:
 *
 *  If this property is TRUE, Text Services should hide the selection
 *  when the control is inactive. If it is FALSE, the selection, if any,
 *  should still be displayed when the control is inactive.
 *
 *  If TRUE, this property implies TXTBIT_SAVESELECTION = TRUE.
 *
 *
 *  TXTBIT_SAVESELECTION:
 *
 *  If this property is TRUE, Text Services should remember the
 *  boundaries of the selection when the control goes inactive. If FALSE,
 *  it is not necessary to remember the selection when the control goes
 *  inactive. It can be reset to start = 0, length = 0 when the control
 *  goes active again.
 *
 *  This property is used by hosts for which it is not necessary to
 *  remember the selection when inactive.
 *
 *
 *  TXTBIT_AUTOWORDSEL:
 *
 *  This property turns the AutoWordSelect feature on or off.
 *
 *
 *  TXTBIT_AUTOSIZE:
 *
 *  This property turns the AutoSize feature on or off. Refer to the
 *  "AutoSize" section for more details.
 *
 *
 *  TXTBIT_VERTICAL:
 *
 *  This property turns on vertical writing. Used for FE support.
 *  Details TBD.
 *
 *
 *  TXTBIT_WORDWRAP:
 *
 *  If this property is TRUE and MultiLine is also TRUE, then Text Services
 *  should wrap the line to the view rectangle. If this property is FALSE,
 *  the lines should not be wrapped but clipped. The right side of the
 *  view rectangle should be ignored.
 *
 *  If the MultiLine property is off, this property has no effect.
 *
 *
 *  TXTBIT_LINESELECTION:
 *
 *  This property turns on or off the Line Selection feature. This feature
 *  enable the user to select lines or paragraph by placing the mouse cursor
 *  over a "line selection" area on the left of the control. The cursor is
 *  displayed as a NE arrow in that area. If the Line Selection feature is
 *  off, that area should not be shown.
 *
 */
HRESULT CTxtEdit::OnTxPropertyBitsChange(
    DWORD dwMask,           //@parm Bits representing properties to be changed
    DWORD dwBits)           //@parm New values for bit properties
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::OnTxPropertyBitsChange");

    HRESULT hr = E_FAIL;
    DWORD dwLoopMask = dwMask;
    CCallMgr callmgr(this);

    START_PROFILING

    for (int i = 0; (i < MAX_PROPERTY_BITS) && (dwLoopMask != 0);
        i++, dwLoopMask >>= 1)
    {
        if (dwLoopMask & 1)
        {
            hr = (this->*_fnpPropChg[i])((dwBits & (1 << i)) != 0);
            if (FAILED(hr))
                return hr;
        }
    }
    return S_OK;
}

/*
 *  CTxtEdit::TxGetCachedSize (pdwWidth, pdwHeight)
 *
 *  @mfunc
 *      Returns the cached drawing size (if any) that text services
 *      is using.  Typically, this will be the size of the last client
 *      rect used in TxDraw, TxSetCursor, etc., although it is not
 *      guaranteed to be.
 *
 *  @rdesc
 *      HRESULT
 *
 *  @comm
 *      This information is provided to allow the host to potentially
 *      perform various optimizations, amongst other things.
 */
HRESULT CTxtEdit::TxGetCachedSize(
    DWORD *pdwWidth,    //@parm Where to put width (in client coords)
    DWORD *pdwHeight)   //@parm Where to put height (in client coords)
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CTxtEdit::TxGetCachedSize");

    return _pdp->GetCachedSize(pdwHeight, pdwWidth);
}

// Forward declaration of initialization helper.
// These really should be in some header file.  But which?
// Currently the definitions are in dxfrobj.cpp and font.cpp
void RegisterFETCs();
void InitFontCache();

/*
 *  CreateTextServices (punkOuter, phost, ppserv)
 *
 *  @func
 *      Create an instance of the RichEdit Engine.  This engine supports the
 *      ITextServices and Microsoft Text Object Model (TOM) interfaces.
 *
 *  @rdesc
 *      S_OK - New text services instance created successfully. <nl>
 *      E_INVALIDARG - An invalid argument was passed in. <nl>
 *      E_OUTOFMEMORY - Memory for text services object could not be allocated. <nl>
 *      E_FAIL - Text services could not be initialized
 *
 *  @comm
 *      Text Services may be created as a standard OLE aggregated object.
 *      Callers should follow standard OLE32 rules for dealing with
 *      aggregated objects and caching interface pointers obtained via
 *      QueryInterface from the private IUnknown.
 */
STDAPI CreateTextServices(
    IUnknown *punkOuter,    //@parm Outer unknown, may be NULL
    ITextHost *phost,       //@parm Client's ITextHost implementation; must be
                            //      valid
    IUnknown **ppUnk)       //@parm Private IUnknown of text services engine
{
    TRACEBEGIN(TRCSUBSYSTS, TRCSCOPEEXTERN, "CreateTextServices");

    static bool fOnce = FALSE;

    if (!fOnce) {
        CLock lock;
        fOnce = TRUE;
        W32->InitSysParams();
        W32->InitPreferredFontInfo();
        RegisterFETCs();                    // Register new clipboard formats
        CreateFormatCaches();               // Create global format caches
        if ( !InitKinsokuClassify() )
        {
            // Init tables for classifying Unicode chars.
            return E_FAIL;
        }
        InitFontCache();
    }

    if(!ppUnk)
        return E_INVALIDARG;

    CTxtEdit *ped = new CTxtEdit((ITextHost2*)phost, punkOuter);
    if(!ped)
        return E_OUTOFMEMORY;

    if(ped->Init(NULL))
    {
        *ppUnk = ped->GetPrivateIUnknown();
        return S_OK;
    }
    delete ped;
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\text.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module TEXT.C -- CTxtPtr implementation |
 *	
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		6/25/95		alexgo	cleanup and reorganization (use run pointers now)
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_text.h"
#include "_edit.h"
#include "_antievt.h"
#include "_clasfyc.h"
#include "_txtbrk.h"


ASSERTDATA

//-----------------------------Internal functions--------------------------------
// Text Block management
static void TxDivideInsertion(LONG cch, LONG ichBlock, LONG cchAfter,
			LONG *pcchFirst, LONG *pcchLast);

/*
 *	IsWhiteSpace(ch)
 *
 *	@func
 *		Used to determine if ch is an EOP char (see IsEOP() for definition),
 *		TAB or blank. This function is used in identifying sentence start
 *		and end.
 *
 *	@rdesc
 *		TRUE if ch is whitespace
 */
BOOL IsWhiteSpace(unsigned ch)
{
	return ch == ' ' || IN_RANGE(CELL, ch, CR) || (ch | 1) == PS;
}

/*
 *	IsSentenceTerminator(ch)
 *
 *	@func
 *		Used to determine if ch is a standard sentence terminator character,
 *		namely, '?', '.', or '!'
 *
 *	@rdesc
 *		TRUE if ch is a question mark, period, or exclamation point.
 */
BOOL IsSentenceTerminator(unsigned ch)
{
	return ch == '?' || ch == '.' || ch == '!';		// Std sentence delimiters
}


// ===========================  Invariant stuff  ==================================================

#define DEBUG_CLASSNAME CTxtPtr
#include "_invar.h"

// ===============================  CTxtPtr  ======================================================

#ifdef DEBUG

/*
 *	CTxtPtr::Invariant
 *
 *	@mfunc	invariant check
 */
BOOL CTxtPtr::Invariant() const
{
	static LONG	numTests = 0;
	numTests++;				// Counts how many times we've been called

	// Make sure _cp is within range
	Assert(_cp >= 0);

	LONG cchValid;
	*(LONG_PTR *)&_pchCp = (LONG_PTR)GetPch(cchValid);

	CRunPtrBase::Invariant();

	if(IsValid())
	{
		// We use less than or equals here so that we can be an insertion
		// point at the *end* of the currently existing text.
		Assert(_cp <= GetTextLength());

		// Make sure all the blocks are consistent...
		Assert(GetTextLength() == ((CTxtArray *)_pRuns)->Invariant());
		Assert(_cp == CRunPtrBase::CalculateCp());
	}
	else
	{
		Assert(_ich == 0);
	}

	return TRUE;
}

/*
 *	CTxtPtr::MoveGapToEndOfBlock ()
 *	
 *	@mfunc
 *		Function to move buffer gap to current block end to aid in debugging
 */
void CTxtPtr::MoveGapToEndOfBlock () const
{
 	CTxtBlk *ptb = GetRun(0);
	ptb->MoveGap(ptb->_cch);				// Move gaps to end of cur block
}

#endif	// DEBUG


/*
 *	CTxtPtr::CTxtPtr(ped, cp)
 *
 *	@mfunc	constructor
 */
CTxtPtr::CTxtPtr (
	CTxtEdit *ped,		//@parm	Ptr to CTxtEdit instance
	LONG	  cp)		//@parm cp to set the pointer to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::CTxtPtr");

	_ped = ped;
	_cp = 0;
	SetRunArray((CRunArray *) &ped->GetTxtStory()->_TxtArray);
	if(IsValid())
		_cp = BindToCp(cp);
}

/*
 *	CTxtPtr::CTxtPtr(&tp)
 *
 *	@mfunc	Copy Constructor
 */
CTxtPtr::CTxtPtr (
	const CTxtPtr &tp)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::CTxtPtr");

	// copy all the values over
	*this = tp;
}	

/*
 *	CTxtPtr::GetTextLength()
 *	
 *	@mfunc
 *		Return count of characters in the story pointed to by this
 *		text ptr.  Includes the story's final CR in the count
 *
 *	@rdesc
 *		cch for the story pointed to by this text ptr
 *
 *	@devnote
 *		This method returns 0 if the text ptr is a zombie, a state
 *		identified by _ped = NULL.
 */
LONG CTxtPtr::GetTextLength() const
{
	return _ped ? ((CTxtArray *)_pRuns)->_cchText : 0;
}

/*
 *	CTxtPtr::GetChar()
 *	
 *	@mfunc
 *		Return character at this text pointer, NULL if text pointer is at
 *		end of text
 *
 *	@rdesc
 *		Character at this text ptr
 */
TCHAR CTxtPtr::GetChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetChar");

	LONG		 cchValid;
	const TCHAR *pch = GetPch(cchValid);

	return pch ? *pch : 0;
}

/*
 *	CTxtPtr::GetPrevChar()
 *	
 *	@mfunc
 *		Return character just before this text pointer, NULL if text pointer
 *		beginning of text
 *
 *	@rdesc
 *		Character just before this text ptr
 */
TCHAR CTxtPtr::GetPrevChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPrevChar");

	LONG		 cchValid;
	const TCHAR *pch = GetPchReverse(cchValid);

	return pch ? *(pch - 1) : 0;
}

/*
 *	CTxtPtr::GetPch(&cchValid)
 *	
 *	@mfunc
 *		return a character pointer to the text at this text pointer
 *
 *	@rdesc
 *		a pointer to an array of characters.  May be NULL.  If non-null,
 *		then cchValid is guaranteed to be at least 1
 */
const TCHAR * CTxtPtr::GetPch(
	LONG & 	cchValid) const	//@parm	Count of chars for which ptr is valid
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPch");
							//		returned pointer is valid
	LONG		ich = _ich;
	TCHAR *		pchBase;
	CTxtBlk *	ptb = IsValid() ? GetRun(0) : NULL;

	cchValid = 0;						// Default nothing valid
	if(!ptb)
		return NULL;

	// If we're at the edge of a run, grab the next run or
	// stay at the current run.

	if(_ich == ptb->_cch)
	{
		if(_iRun < Count() - 1)
		{
			// set us to the next text block
			ptb = GetRun(1);
			ich = 0;
		}
		else							// At very end of text:
			return NULL;				//  just return NULL
	}

	AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
		"CTxtPtr::GetPch(): _ich bigger than block");

	pchBase = ptb->_pch + ich;


	// Check to see if we need to skip over gap.  Recall that
	// the game may come anywhere in the middle of a block,
	// so if the current ich (note, no underscore, we want
	// the active ich) is beyond the gap, then recompute pchBase
	// by adding in the size of the block.
	//
	// cchValid will then be the number of characters left in
	// the text block (or _cch - ich)

	if(CbOfCch(ich) >= ptb->_ibGap)
	{
		pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;
		cchValid = ptb->_cch - ich;
	}
	else
	{
		// We're valid until the buffer gap (or see below).
		cchValid = CchOfCb(ptb->_ibGap) - ich;
	}

	AssertSz(cchValid > 0 && GetCp() + cchValid <= GetTextLength(),
		"CTxtPtr::GetPch: illegal cchValid");
	return pchBase;
}

/*
 *	CTxtPtr::GetPchReverse(&cchValidReverse, pcchValid)
 *	
 *	@mfunc
 *		return a character pointer to the text at this text pointer
 *		adjusted so that there are some characters valid *behind* the
 *		pointer.
 *
 *	@rdesc
 *		a pointer to an array of characters.  May be NULL.  If non-null,
 *		then cchValidReverse is guaranteed to be at least 1
 */
const TCHAR * CTxtPtr::GetPchReverse(
	LONG & 	cchValidReverse,		//@parm	length for reverse
	LONG *	pcchValid)				//@parm length forward
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPchReverse");

	_TEST_INVARIANT_

	LONG		cchTemp;
	LONG		ich = _ich;
	TCHAR *		pchBase;
	CTxtBlk *	ptb = IsValid() ? GetRun(0) : NULL;

	cchValidReverse = 0;				// Default no valid chars in run
	if(!ptb)
		return NULL;

	// If we're at the edge of a run, grab the previous run or
	// stay at the current run.
	if(!_ich)
	{
		if(_iRun)
		{
			ptb = GetRun(-1);			// Go to next text block
			ich = ptb->_cch;
		}
		else							// At start of text:
			return NULL;				//  just return NULL
	}

	AssertSz(CbOfCch(ich) <= ptb->_cbBlock,
		"CTxtPtr::GetPchReverse(): _ich bigger than block");

	pchBase = ptb->_pch + ich;

	// Check to see if we need to skip over gap.  Recall that
	// the game may come anywhere in the middle of a block,
	// so if the current ich (note, no underscore, we want
	// the active ich) is at least one char past the gap, then recompute
	// pchBase by adding the size of the gap (so that it's after
	// the gap).  This differs from GetPch(), which works forward and
	// wants pchBase to include the gap size if ich is at the gap, let
	// alone one or more chars past it.
	//
	// Also figure out the count of valid characters.  It's
	// either the count of characters from the beginning of the
	// text block, i.e. ich, or the count of characters from the
	// end of the buffer gap.

	cchValidReverse = ich;					// Default for ich <= gap offset
	cchTemp = ich - CchOfCb(ptb->_ibGap);	// Calculate displacement
	if(cchTemp > 0)							// Positive: pchBase is after gap
	{
		cchValidReverse = cchTemp;
		pchBase += CchOfCb(ptb->_cbBlock) - ptb->_cch;	// Add in gap size
	}
	if(pcchValid)							// if client needs forward length
	{
		if(cchTemp > 0)
			cchTemp = ich - ptb->_cch;
		else
			cchTemp = -cchTemp;

		*pcchValid = cchTemp;
	}

	AssertSz(cchValidReverse > 0 && GetCp() - cchValidReverse >= 0,
		"CTxtPtr::GetPchReverse: illegal cchValidReverse");
	return pchBase;
}

/*
 *	CTxtPtr::BindToCp(cp)
 *
 *	@mfunc
 *		set cached _cp = cp (or nearest valid value)
 *
 *	@rdesc
 *		_cp actually set
 *
 *	@comm
 *		This method overrides CRunPtrBase::BindToCp to keep _cp up to date
 *		correctly.
 *
 *	@devnote
 *		Do *not* call this method when high performance is needed; use
 *		AdvanceCp() instead, which advances from 0 or from the cached
 *		_cp, depending on which is closer.
 */
LONG CTxtPtr::BindToCp(
	LONG	cp)			//@parm	char position to bind to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::BindToCp");

	_cp = CRunPtrBase::BindToCp(cp);

	// We want to be able to use this routine to fix up things so we don't
	// check invariants on entry.
	_TEST_INVARIANT_
	return _cp;
}


/*
 *	CTxtPtr::SetCp(cp)
 *
 *	@mfunc
 *		'efficiently' sets cp by advancing from current position or from 0,
 *		depending on which is closer
 *
 *	@rdesc
 *		cp actually set to
 */
LONG CTxtPtr::SetCp(
	LONG	cp)		//@parm char position to set to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::SetCp");

	AdvanceCp(cp - _cp);
	return _cp;
}

/*
 *	CTxtPtr::AdvanceCp(cch)
 *
 *	@mfunc
 *		Advance cp by cch characters
 *
 *	@rdesc
 *		Actual number of characters advanced by
 *
 *	@comm
 *		We override CRunPtrBase::AdvanceCp so that the cached _cp value
 *		can be correctly updated and so that the advance can be made
 *		from the cached _cp or from 0, depending on which is closer.
 *
 *	@devnote
 *		It's also easy to bind at the end of the story. So an improved
 *		optimization would bind there if 2*(_cp + cch) > _cp + text length.
 */
LONG CTxtPtr::AdvanceCp(
	LONG cch)			// @parm count of chars to advance by
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::AdvanceCp");

	if(!IsValid())							// No runs yet, so don't go
		return 0;							//  anywhere

	const LONG	cpSave = _cp;				// Save entry _cp
	LONG		cp = cpSave + cch;			// Requested target cp (maybe < 0)

	if(cp < cpSave/2)						// Closer to 0 than cached cp
	{
		cp = max(cp, 0);					// Don't undershoot
		_cp = CRunPtrBase::BindToCp(cp);
	}
	else
		_cp += CRunPtrBase::AdvanceCp(cch);	//  exist

	// NB! the invariant check needs to come at the end; we may be
	// moving 'this' text pointer in order to make it valid again
	// (for the floating range mechanism).

	_TEST_INVARIANT_
	return _cp - cpSave;					// cch this CTxtPtr moved
}

/*
 *	CTxtPtr::GetText(cch, pch)
 *	
 *	@mfunc
 *		get a range of cch characters starting at this text ptr. A literal
 *		copy is made, i.e., with no CR -> CRLF and WCH_EMBEDDING -> ' '
 *		translations.  For these translations, see CTxtPtr::GetPlainText()
 *	
 *	@rdesc
 *		count of characters actually copied
 *
 *  @comm
 *		Doesn't change this text ptr
 */
LONG CTxtPtr::GetText(
	LONG	cch, 			//@parm Count of characters to get
	TCHAR *	pch)			//@parm Buffer to copy the text into
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetText");

	LONG cchSave = cch;
	LONG cchValid;
	const TCHAR *pchRead;
	CTxtPtr tp(*this);

	_TEST_INVARIANT_

	// Use tp to read valid blocks of text until all the requested
	// text is read or until the end of story is reached.
	while( cch )
	{
		pchRead = tp.GetPch(cchValid);
		if(!pchRead)					// No more text
			break;

		cchValid = min(cchValid, cch);
		CopyMemory(pch, pchRead, cchValid*sizeof(TCHAR));
		pch += cchValid;
		cch -= cchValid;
		tp.AdvanceCp(cchValid);
	}
	return cchSave - cch;
}

/*
 *	OverRideNeutralChar(ch)
 *	
 *	@mfunc
 *		Helper for overriding BiDi neutral character classification.
 *		Option is used in Access Expression Builder.
 *	
 *	@rdesc
 *		Modified character or unmodified input character
 */
WCHAR OverRideNeutralChar(WCHAR ch)
{
	if (ch < '!' || ch > '}')
		return ch;

	if (IN_RANGE('!', ch, '>'))
	{
		// True for !"#&'()*+,-./:;<=>
		if ((0x00000001 << (ch - TEXT(' '))) & 0x7C00FFCE)
			ch = 'a';
	}

	if (IN_RANGE('[', ch, '^') || ch == '{' ||  ch == '}')
	{
		// True for [/]^{}
		ch = 'a';
	}

	return ch;
}

/*
 *	CTxtPtr::GetTextForUsp(cch, pch)
 *	
 *	@mfunc
 *		get a range of cch characters starting at this text ptr. A literal
 *		copy is made, with translation to fool Uniscribe classification
 *	
 *	@rdesc
 *		count of characters actually copied
 *
 *  @comm
 *		Doesn't change this text ptr
 */
LONG CTxtPtr::GetTextForUsp(
	LONG	cch, 				//@parm Count of characters to get
	TCHAR *	pch,				//@parm Buffer to copy the text into
	BOOL	fNeutralOverride)	//@parm Neutral override option
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetTextForUsp");

	LONG cchSave = cch;
	LONG cchValid;
	const TCHAR *pchRead;
	CTxtPtr tp(*this);
	int i;
	TCHAR xltchar;

	_TEST_INVARIANT_

	// Use tp to read valid blocks of text until all the requested
	// text is read or until the end of story is reached.
	while( cch )
	{
		pchRead = tp.GetPch(cchValid);
		if(!pchRead)					// No more text
			break;

		cchValid = min(cchValid, cch);

		if (!fNeutralOverride)
		{
			for (i = 0; i < cchValid; i++)
			{
				xltchar = pchRead[i];
				if (IN_RANGE('#', xltchar, '-'))
				{
					/* #$+- */
					if ((0x1 << (xltchar - '#')) & 0x503)
						xltchar = '@';
				}
				pch[i] = xltchar;
			}
		}
		else
		{
			for (i = 0; i < cchValid; i++)
			{
				pch[i] = OverRideNeutralChar(pchRead[i]);
			}
		}

		pch += cchValid;
		cch -= cchValid;
		tp.AdvanceCp(cchValid);
	}
	return cchSave - cch;
}

/*
 *	CTxtPtr::GetPlainText(cchBuff, pch, cpMost, fTextize, fAdjustCRLF)
 *	
 *	@mfunc
 *		Copy up to cchBuff characters or up to cpMost, whichever comes
 *		first, translating lone CRs into CRLFs.  Move this text ptr just
 *		past the last character processed.  If fTextize, copy up to but
 *		not including the first WCH_EMBEDDING char. If not fTextize,
 *		replace	WCH_EMBEDDING by a blank since RichEdit 1.0 does.
 *	
 *	@rdesc
 *		Count of characters copied
 *
 *  @comm
 *		An important feature is that this text ptr is moved just past the
 *		last char copied.  In this way, the caller can conveniently read
 *		out plain text in bufferfuls of up to cch chars, which is useful for
 *		stream I/O.  This routine won't copy the final CR even if cpMost
 *		is beyond it.
 */
LONG CTxtPtr::GetPlainText(
	LONG	cchBuff,		//@parm Buffer cch
	TCHAR *	pch,			//@parm Buffer to copy text into
	LONG	cpMost,			//@parm Largest cp to get
	BOOL	fTextize,		//@parm True if break on WCH_EMBEDDING
	BOOL	fAdjustCRLF)	//@parm TRUE to call AdjustCpCRLF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::GetPlainText");

	LONG		 cch = cchBuff;				// Countdown counter
	LONG		 cchValid;					// Valid ptr cch
	LONG		 cchT;						// Temporary cch
	unsigned	 ch;						// Current char
	const TCHAR *pchRead;					// Backing-store ptr

	_TEST_INVARIANT_

	if(fAdjustCRLF)
		AdjustCpCRLF();						// Be sure we start on an EOP bdy

	LONG cchText = _ped->GetAdjustedTextLength();
	cpMost = min(cpMost, cchText);			// Don't write final CR
	if(GetCp() >= cpMost)
		return 0;

	while(cch > 0)							// While room in buffer
	{
		if(!(pchRead = GetPch(cchValid)))	// No more chars available
			break;							//  so we're out of here
		
		cchT = GetCp() + cchValid - cpMost;
		if(cchT > 0)						// Don't overshoot
		{
			cchValid -= cchT;
			if(cchValid <= 0)
				break;						// Nothing left before cpMost
		}

		for(cchT = 0; cch > 0 && cchT < cchValid; cchT++, cch--)
		{
			ch = *pch++ = *pchRead++;		// Copy next char (but don't
			if(IsASCIIEOP(ch) && !_ped->Get10Mode() && ch != FF)	//  count it yet)
			{
				AdvanceCp(cchT);			// Move up to CR
				if(cch < 2)					// No room for LF, so don't				
					goto done;				//  count CR either
											// Bypass EOP w/o worrying about
				cchT = AdvanceCpCRLF();		//  buffer gaps and blocks
				if(cchT > 2)				// Translate CRCRLF to ' '
				{							// Usually copied count exceeds
					Assert(cchT == 3);		//  internal count, but CRCRLFs
					*(pch - 1) = ' ';		//  reduce the relative increase:
				}							//  NB: error for EM_GETTEXTLENGTHEX
				else						// CRLF or lone CR
				{							// Store LF in both cases for
					*(pch - 1) = CR;		// Be sure it's a CR not a VT,
#ifndef MACPORT								//  FF, or lone LF
					*pch++ = LF;			// Windows. No LF for Mac
					cch--;					// One less for target buffer
#endif
				}
				cch--;						// CR (or ' ') copied
				cchT = 0;					// Don't AdvanceCp() more below
				break;						// Go get new pchRead & cchValid
			}
			else if(ch == WCH_EMBEDDING)	// Object lives here
			{
				if(fTextize)				// Break on WCH_EMBEDDING
				{
					AdvanceCp(cchT);		// Move this text ptr up to
					goto done;				//  WCH_EMBEDDING and return
				}
				*(pch - 1) = ' ';			// Replace embedding char by ' '
			}								//  since RichEdit 1.0 does
		}
		AdvanceCp(cchT);
	}

done:
	return cchBuff - cch;
}

/*
 *	CTxtPtr::AdvanceCpCRLF()
 *	
 *	@mfunc
 *		Advance text pointer by one character, safely advancing
 *		over CRLF, CRCRLF, and UTF-16 combinations
 *	
 *	@rdesc
 *		Number of characters text pointer has been moved by
 *
 */
LONG CTxtPtr::AdvanceCpCRLF(
	BOOL	fMulticharAdvance)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::AdvanceCpCRLF");

	_TEST_INVARIANT_

	LONG	cp;
	LONG	cpSave	= _cp;
	TCHAR	ch		= GetChar();		// Char on entry
	TCHAR	ch1		= NextChar();		// Advance to and get next char
	BOOL	fTwoCRs = FALSE;
	BOOL	fCombiningMark = FALSE;

	if(ch == CR)
	{
		if(ch1 == CR && _cp < GetTextLength())
		{
			fTwoCRs = TRUE;				// Need at least 3 chars to
			ch1 = NextChar();			//  have CRCRLF at end
		}
		if(ch1 == LF)
			AdvanceCp(1);				// Bypass CRLF
		else if(fTwoCRs)
			AdvanceCp(-1);				// Only bypass one CR of two

		AssertSz(_ped->fUseCRLF() || _cp == cpSave + 1,
			"CTxtPtr::AdvanceCpCRLF: EOP isn't a single char");
	}

	// Handle Unicode UTF-16 surrogates
	if(IN_RANGE(0xD800, ch, 0xDBFF))	// Started on UTF-16 lead word
	{
		if (IN_RANGE(0xDC00, ch1, 0xDFFF))
			AdvanceCp(1);					// Bypass UTF-16 trail word
		else
			AssertSz(FALSE, "CTxtPtr::AdvanceCpCRLF: illegal Unicode surrogate combo");
	}

	if (fMulticharAdvance)
	{
		while(IN_RANGE(0x300, ch1, 0x36F))	// Bypass combining diacritical marks
		{
			fCombiningMark = TRUE;
			cp = _cp;
			ch1 = NextChar();
			if (_cp == cp)
				break;
		}
	}

	LONG cch = _cp - cpSave;
	AssertSz(!cch || cch == 1 || fCombiningMark ||
			 cch == 2 && IN_RANGE(0xD800, ch, 0xDBFF) ||
			 (_ped->fUseCRLF() && GetPrevChar() == LF &&
				(cch == 2 || cch == 3 && fTwoCRs)),
		"CTxtPtr::AdvanceCpCRLF(): Illegal multichar");

	return cch;				// # chars bypassed
}

/*
 *	CTxtPtr::NextChar()
 *	
 *	@mfunc
 *		Increment this text ptr and return char it points at
 *	
 *	@rdesc
 *		Next char
 */
TCHAR CTxtPtr::NextChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::NextChar");

	_TEST_INVARIANT_

 	AdvanceCp(1);
	return GetChar();
}

/*
 *	CTxtPtr::PrevChar()
 *	
 *	@mfunc
 *		Decrement this text ptr and return char it points at
 *	
 *	@rdesc
 *		Previous char
 */
TCHAR CTxtPtr::PrevChar()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::PrevChar");

	_TEST_INVARIANT_

	return AdvanceCp(-1) ? GetChar() : 0;
}

/*
 *	CTxtPtr::BackupCpCRLF(fDiacriticCheck)
 *	
 *	@mfunc
 *		Backup text pointer by one character, safely backing up
 *		over CRLF, CRCRLF, and UTF-16 combinations
 *	
 *	@rdesc
 *		Number of characters text pointer has been moved by
 *
 */
LONG CTxtPtr::BackupCpCRLF(
	BOOL fMulticharBackup)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::BackupCpCRLF");

	_TEST_INVARIANT_

	LONG  cpSave = _cp;
	WCHAR ch	 = PrevChar();			// Advance to and get previous char


	if(fMulticharBackup)
	{									// Bypass combining diacritical marks
		while(IN_RANGE(0x300, ch, 0x36F))
			ch = PrevChar();
	}

	// Handle Unicode UTF-16 surrogates
	if(_cp && IN_RANGE(0xDC00, ch, 0xDFFF))
	{
		ch = PrevChar();
		if (!IN_RANGE(0xD800, ch, 0xDBFF))
		{
			AssertSz(FALSE, "CTxtPtr::BackupCpCRLF: illegal Unicode surrogate combo");
			ch = NextChar();
		}
	}

	if (ch == LF &&					 	// Try to back up 1 char in any case
		(_cp && PrevChar() != CR ||		// If LF, does prev char = CR?
		 _cp && PrevChar() != CR))		// If so, does its prev char = CR?
	{									//  (CRLF at BOD checks CR twice; OK)
		AdvanceCp(1);					// Backed up too far
	}

	AssertSz( _cp == cpSave ||
			  ch == LF && GetChar() == CR ||
			  !(ch == LF || fMulticharBackup &&
							(IN_RANGE(0x300, ch, 0x36F) ||
							 IN_RANGE(0xDC00, ch, 0xDFFF) && IN_RANGE(0xD800, GetPrevChar(), 0xDBFF)) ),
			 "CTxtPtr::BackupCpCRLF(): Illegal multichar");

	return _cp - cpSave;				// - # chars this CTxtPtr moved
}

/*
 *	CTxtPtr::AdjustCpCRLF()
 *	
 *	@mfunc
 *		Adjust the position of this text pointer to the beginning of a CRLF,
 *		CRCRLF, or UTF-16 combination if it is in the middle of such a
 *		combination
 *	
 *	@rdesc
 *		Number of characters text pointer has been moved by
 *
 *	@future
 *		Adjust to beginning of sequence containing Unicode combining marks
 */
LONG CTxtPtr::AdjustCpCRLF()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::AdjustCpCRLF");

	_TEST_INVARIANT_

	LONG	 cpSave = _cp;
	unsigned ch		= GetChar();

	// Handle Unicode UTF-16 surrogates
	if(IN_RANGE(0xDC00, ch, 0xDFFF))	// Landed on UTF-16 trail word
	{
		AdvanceCp(-1);					// Backup to UTF-16 lead word
		AssertSz(IN_RANGE(0xD800, GetChar(), 0xDBFF),
			"CTxtPtr::AdvanceCpCRLF: illegal Unicode surrogate combo");
		return -1;
	}

	if(!IsASCIIEOP(ch))							// Early out
		return 0;

	if(ch == LF && cpSave && PrevChar() != CR)	// Landed on LF not preceded
	{											//  by CR, so go back to LF
		AdvanceCp(1);							// Else on CR of CRLF or
	}											//  second CR of CRCRLF

	// Note: since we replace all CRCRLFs by blanks on input, the following
	// code is probably archaic
	if(GetChar() == CR)							// Land on a CR of CRLF or
	{											//  second CR of CRCRLF?
		CTxtPtr tp(*this);

		if(tp.NextChar() == LF)
		{
			tp.AdvanceCp(-2);					// First CR of CRCRLF ?
			if(tp.GetChar() == CR)				// Yes or CRLF is at start of
				AdvanceCp(-1);					//  story. Try to back up over
		}										//  CR (If at BOS, no effect)
	}
	return _cp - cpSave;
}

/*
 *	CTxtPtr::IsAtEOP()
 *	
 *	@mfunc
 *		Return TRUE iff this text pointer is at an end-of-paragraph mark
 *	
 *	@rdesc
 *		TRUE if at EOP
 *
 *	@devnote
 *		End of paragraph marks for RichEdit 1.0 and the MLE can be CRLF
 *		and CRCRLF.  For RichEdit 2.0, EOPs can also be CR, VT (0xB - Shift-
 *		Enter), and FF (0xC - page break or form feed).
 */
BOOL CTxtPtr::IsAtEOP()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAtEOP");

	_TEST_INVARIANT_

	unsigned ch = GetChar();

	if(IsASCIIEOP(ch))							// See if LF <= ch <= CR
	{											// Clone tp in case
		CTxtPtr tp(*this);						//  AdjustCpCRLF moves
		return !tp.AdjustCpCRLF();				// Return TRUE unless in
	}											//  middle of CRLF or CRCRLF
	return (ch | 1) == PS;						// Allow Unicode 0x2028/9 also
}

/*
 *	CTxtPtr::IsAfterEOP()
 *	
 *	@mfunc
 *		Return TRUE iff this text pointer is just after an end-of-paragraph
 *		mark
 *	
 *	@rdesc
 *		TRUE iff text ptr follows an EOP mark
 */
BOOL CTxtPtr::IsAfterEOP()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAfterEOP");

	_TEST_INVARIANT_

	if(IsASCIIEOP(GetChar()))
	{
		CTxtPtr tp(*this);					// If in middle of CRLF
		if(tp.AdjustCpCRLF())				//  or CRCRLF, return FALSE
			return FALSE;
	}
	return IsEOP(GetPrevChar());			// After EOP if after Unicode
}								   			//  PS or LF, VT, FF, or CR

// Needed for CTxtPtr::ReplaceRange() and InsertRange()
#if cchGapInitial < 1
#error "cchGapInitial must be at least one"
#endif

/*
 *	CTxtPtr::MoveWhile(cch, chFirst, chLast, fInRange)
 *	
 *	@mfunc
 *		Move this text ptr 1) to first char (fInRange ? in range : not in range)
 *		chFirst thru chLast or 2) cch chars, which ever comes first.  Return
 *		count of chars left in run on return. E.g., chFirst = 0, chLast = 0x7F
 *		and fInRange = TRUE	breaks on first nonASCII char.
 *	
 *	@rdesc
 *		cch left in run on return
 */
LONG CTxtPtr::MoveWhile(
	LONG  cchRun,	//@parm Max cch to check
	WCHAR chFirst,	//@parm First ch in range
	WCHAR chLast,	//@parm Last ch in range
	BOOL  fInRange)	//@parm break on non0/0 high byte for TRUE/FALSE
{
	LONG  cch;
	LONG  i;
	const WCHAR *pch;

	while(cchRun)
	{
		pch = GetPch(cch);
		cch = min(cch, cchRun);
		for(i = 0; i < cch; i++)
		{
			if(IN_RANGE(chFirst, *pch++, chLast) ^ fInRange)
			{
				AdvanceCp(i);		// Advance to 1st char with 0/non0 masked
				return cchRun - i;	//  value
			}
		}
		cchRun -= cch;
		AdvanceCp(cch);				// Advance to next txt bdy
	}
	return 0;
}

/*
 *	CTxtPtr::FindWordBreak(action, cpMost)
 *	
 *	@mfunc
 *		Find a word break and move this text pointer to it.
 *
 *	@rdesc
 *		Offset from cp of the word break
 */
LONG CTxtPtr::FindWordBreak(
	INT		action,		//@parm See TxWordBreakProc header
	LONG	cpMost)		//@parm Limiting character position
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindWordBreak");

	_TEST_INVARIANT_

	const INT			breakBufSize = 16;
	LONG				bufferSize;
	LONG				cch;
	LONG				cchBuffer;
	LONG				cchChunk;
	LONG				cchText = GetTextLength();
	TCHAR				ch = GetChar();
	TCHAR				pchBreakBuf[breakBufSize];
	LONG				cpSave = _cp;				// For calculating break pt
	LONG				ichBreak;
	TCHAR *				pBuf;
	TCHAR const *		pch;
	LONG				t;							// Temp for abs() macro
	BOOL				b10ModeWordBreak = (_ped->Get10Mode() && _ped->_pfnWB);

	if(action == WB_CLASSIFY || action == WB_ISDELIMITER)
		return ch ? _ped->TxWordBreakProc(&ch, 0, CbOfCch(1), action, GetCp()) : 0;

	if(action & 1)									// Searching forward
	{												// Easiest to handle EOPs			
		if(action == WB_MOVEWORDRIGHT && IsEOP(ch))	//  explicitly (spanning
		{											//  a class can go too
			AdjustCpCRLF();							//  far). Go to end of
			AdvanceCpCRLF();						//  EOP "word"
			goto done;
		}
													// Calc. max search
		if((DWORD)cpMost > (DWORD)cchText)			// Bounds check: get < 0
			cpMost = cchText;						//  as well as too big
		cch = cpMost - _cp;

		while(cch > 0)
		{											// The independent buffer
			cchBuffer = min(cch, breakBufSize - 1);	//  avoids gaps in BS
			cch -= bufferSize = cchBuffer;
			pBuf = pchBreakBuf;						// Fill buffer forward

			// Grab the first character in reverse for fnWB that require 2
			// chars. Note, we play with _ich to get single char fnWB
			// to ignore this character.			 							
			pch = GetPchReverse(cchChunk);
			*pBuf++ = (cchChunk ? *(pch - 1) : L' ');

			while ( cchBuffer )						// Finish filling
			{
				pch = GetPch(cchChunk);
				if (!cchChunk) { Assert(0); break; }

				cchChunk = min(cchBuffer, cchChunk);
				AdvanceCp(cchChunk);
				wcsncpy(pBuf, pch, cchChunk);
				pBuf += cchChunk;
				cchBuffer -= cchChunk;
			}
			ichBreak = _ped->TxWordBreakProc(pchBreakBuf, 1,		// Find the break
						CbOfCch(bufferSize+1), action, GetCp()-bufferSize, GetCp()-bufferSize) - 1;

			// in 1.0 mode some apps will return 0 implying the current cp position is a valid break point
			if (ichBreak == -1 && b10ModeWordBreak)
				ichBreak = 0;

			// Apparently, some fnWBs return ambiguous results						
			if(ichBreak >= 0 && ichBreak <= bufferSize)
			{
				// Ambiguous break pt?
				// Due to the imprecise nature of the word break proc spec,
				// we've reached an ambiguous condition where we don't know
				// if this is really a break, or just the end of the data.
				// By backing up or going forward by 2, we'll know for sure.
				// NOTE: we'll always be able to advance or go back by 2
				// because we guarantee that when !cch that we have
				// at least breakBufSize (16) characters in the data stream.
				if (ichBreak < bufferSize || !cch)
				{
					AdvanceCp( ichBreak - bufferSize );
					break;
				}

				// Need to recalc break pt to disambiguate
				t = AdvanceCp(ichBreak - bufferSize - 2);	// abs() is a
				cch += abs(t);						//  macro
			}
		}
	}
	else	// REVERSE - code dup based on EliK "streams" concept.
	{
		if(!_cp)									// Can't go anywhere
			return 0;

		if(action == WB_MOVEWORDLEFT)				// Easiest to handle EOPs			
		{											//  here
			if(IsASCIIEOP(ch) && AdjustCpCRLF())	// In middle of a CRLF or
				goto done;							//  CRCRLF "word"
			ch = PrevChar();						// Check if previous char
			if(IsEOP(ch))							//  is an EOP char
			{
				if(ch == LF)						// Backspace to start of
					AdjustCpCRLF();					//  CRLF and CRCRLF
				goto done;
			}
			AdvanceCp(1);							// Move back to start char
		}
													// Calc. max search
		if((DWORD)cpMost > (DWORD)_cp)				// Bounds check (also
			cpMost = _cp;							//  handles cpMost < 0)
		cch = cpMost;

		while(cch > 0)
		{											// The independent buffer
			cchBuffer = min(cch, breakBufSize - 1);	//  avoids gaps in BS
			cch -= bufferSize = cchBuffer;
			pBuf = pchBreakBuf + cchBuffer;			// Fill from the end.

			// Grab the first character forward for fnWB that require 2 chars.
			// Note: we play with _ich to get single char fnWB to ignore this
			// character.
			pch = GetPch(cchChunk);
			if ( !cchChunk ) pch = L" ";			// Any break char
			*pBuf = *pch;

			while ( cchBuffer > 0 )					// Fill rest of buffer
			{										//  before going in reverse
				pch = GetPchReverse(cchChunk );
				if (!cchChunk) { Assert(0); break; }

				cchChunk = min(cchBuffer, cchChunk);
				AdvanceCp(-cchChunk);
				pch -= cchChunk;
				pBuf -= cchChunk;
				wcsncpy(pBuf, pch, cchChunk);
				cchBuffer -= cchChunk;
			}
													// Get break left.
			ichBreak = _ped->TxWordBreakProc(pchBreakBuf, bufferSize,
							 CbOfCch(bufferSize+1), action, GetCp(), GetCp()+bufferSize);
			
			// in 1.0 mode some apps will return 0 implying the current cp position is a valid break point
			if (ichBreak == 0 && b10ModeWordBreak)
				ichBreak = bufferSize;

			// Apparently, some fnWBs return ambiguous results
			if(ichBreak >= 0 && ichBreak <= bufferSize)
			{										// Ambiguous break pt?
				// NOTE: when going in reverse, we have >= bufsize - 1
				//  because there is a break-after char (hyphen).
				if ( ichBreak > 0 || !cch )
				{
					AdvanceCp(ichBreak);			// Move _cp to break point.
					break;
				}													
				cch += AdvanceCp(2 + ichBreak);		// Need to recalc break pt
			}										//  to disambiguate.
		}
	}

done:
	return _cp - cpSave;							// Offset of where to break
}

/*
 *	CTxtPtr::TranslateRange(cch, CodePage, fSymbolCharSet, publdr)
 *
 *	@mfunc
 *		Translate a range of text at this text pointer to...
 *	
 *	@rdesc
 *		Count of new characters added (should be same as count replaced)
 *	
 *	@devnote
 *		Moves this text pointer to end of replaced text.
 *		May move text block and formatting arrays.
 */
LONG CTxtPtr::TranslateRange(
	LONG		  cch,				//@parm length of range to translate
	UINT		  CodePage,			//@parm CodePage for MBTWC or WCTMB
	BOOL		  fSymbolCharSet,	//@parm Target charset
	IUndoBuilder *publdr)			//@parm Undo bldr to receive antievents
{
	CTempWcharBuf twcb;
	CTempCharBuf tcb;

	UINT	ch;
	BOOL	fAllASCII = TRUE;
	BOOL	fNoCodePage;
	BOOL	fUsedDef;	//@parm Out parm to receive whether default char used
	LONG	i;
	char *	pastr = tcb.GetBuf(cch);
	WCHAR *	pstr  = twcb.GetBuf(cch);
	WCHAR * pstrT = pstr;

	i = GetText(cch, pstr);
	Assert(i == cch);

	if(fSymbolCharSet)					// Target is SYMBOL_CHARSET
	{
		WCTMB(CodePage, 0, pstr, cch, pastr, cch, "\0", &fUsedDef,
			  &fNoCodePage, FALSE);
		if(fNoCodePage)
			return cch;
		for(; i && *pastr; i--)			// Break if conversion failed
		{								//  (NULL default char used)
			if(*pstr >= 128)
				fAllASCII = FALSE;
			*pstr++ = *(BYTE *)pastr++;
		}
		cch -= i;
		if(fAllASCII)
			return cch;
	}
	else								// Target isn't SYMBOL_CHARSET
	{
		while(i--)
		{
			ch = *pstr++;				// Source is SYMBOL_CHARSET, so
			*pastr++ = (char)ch;		//  all chars should be < 256
			if(ch >= 128)				// In any event, truncate to BYTE
				fAllASCII = FALSE;
		}								
		if(fAllASCII)					// All ASCII, so no conversion needed
			return cch;

		MBTWC(CodePage, 0, pastr - cch, cch, pstrT, cch, &fNoCodePage);
		if(fNoCodePage)
			return cch;
	}
	return ReplaceRange(cch, cch, pstrT, publdr, NULL, NULL);
}

/*
 *	CTxtPtr::ReplaceRange(cchOld, cchNew, *pch, publdr, paeCF, paePF)
 *	
 *	@mfunc
 *		replace a range of text at this text pointer.
 *	
 *	@rdesc
 *		count of new characters added
 *	
 *	@comm	SideEffects: <nl>
 *		moves this text pointer to end of replaced text <nl>
 *		moves text block array <nl>
 */
LONG CTxtPtr::ReplaceRange(
	LONG cchOld, 				//@parm length of range to replace
								// (<lt> 0 means to end of text)
	LONG cchNew, 				//@parm length of replacement text
	TCHAR const *pch, 			//@parm replacement text
	IUndoBuilder *publdr,		//@parm if non-NULL, where to put an
								// anti-event for this action
	IAntiEvent *paeCF,			//@parm char format AE
	IAntiEvent *paePF )			//@parm paragraph formatting AE
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::ReplaceRange");

	_TEST_INVARIANT_

	LONG cchAdded = 0;
	LONG cchInBlock;
	LONG cchNewInBlock;

	if(cchOld < 0)
		cchOld = GetTextLength() - _cp;

	if(publdr)
		HandleReplaceRangeUndo( cchOld, cchNew, publdr, paeCF, paePF);

	// Blocks involving replacement

	while(cchOld > 0 && cchNew > 0)
	{	
		CTxtBlk *ptb = GetRun(0);

		// cchOld should never be nonzero if the text run is empty
		AssertSz(ptb,
			"CTxtPtr::Replace() - Pointer to text block is NULL !");

		ptb->MoveGap(_ich);
		cchInBlock = min(cchOld, ptb->_cch - _ich);
		if(cchInBlock > 0)
		{
			cchOld			-= cchInBlock;
			ptb->_cch		-= cchInBlock;
			((CTxtArray *)_pRuns)->_cchText	-= cchInBlock;
		}
		cchNewInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;

		// if there's room for a gap, leave one
		if(cchNewInBlock > cchGapInitial)
			cchNewInBlock -= cchGapInitial;

		if(cchNewInBlock > cchNew)
			cchNewInBlock = cchNew;

		if(cchNewInBlock > 0)
		{
			CopyMemory(ptb->_pch + _ich, pch, CbOfCch(cchNewInBlock));
			cchNew			-= cchNewInBlock;
			_cp				+= cchNewInBlock;
			_ich			+= cchNewInBlock;
			pch				+= cchNewInBlock;
			cchAdded		+= cchNewInBlock;
			ptb->_cch		+= cchNewInBlock;
			ptb->_ibGap		+= CbOfCch(cchNewInBlock);
			((CTxtArray *)_pRuns)->_cchText	+= cchNewInBlock;
		}
	   	if(_iRun >= Count() - 1 || !cchOld )
		   	break;

		// Go to next block
		_iRun++;
   		_ich = 0;
	}

	if(cchNew > 0)
		cchAdded += InsertRange(cchNew, pch);

	else if(cchOld > 0)
		DeleteRange(cchOld);
	
	return cchAdded;
}

/*
 *	CTxtPtr::HandleReplaceRangeUndo (cchOld, cchNew, pch, publdr)
 *
 *	@mfunc
 *		worker function for ReplaceRange.  Figures out what will happen in
 *		the replace range call and creates the appropriate anti-events
 *
 *	@devnote
 *		We first check to see if our replace range data can be merged into
 *		an existing anti-event.  If it can, then we just return.
 *		Otherwise, we copy the deleted characters into an allocated buffer
 *		and then create a ReplaceRange anti-event.
 *
 *		In order to handle ordering problems between formatting and text
 *		anti-events (that is, text needs to exist before formatting can
 *		be applied), we have any formatting anti-events passed to us first.
 */
void CTxtPtr::HandleReplaceRangeUndo(
	LONG			cchOld, //@parm Count of characters to delete
	LONG			cchNew, //@parm Count of new characters to add
	IUndoBuilder *	publdr,	//@parm Undo builder to receive anti-event
	IAntiEvent *	paeCF,	//@parm char formatting AE
	IAntiEvent *	paePF )	//@parm paragraph formatting AE
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::HandleReplaceRangeUndo");

	_TEST_INVARIANT_

	IAntiEvent *pae = publdr->GetTopAntiEvent();
	TCHAR *		pch = NULL;

	if(pae)
	{
		SimpleReplaceRange	sr;
		sr.cpMin = _cp;
		sr.cpMax = _cp + cchNew;
		sr.cchDel = cchOld;
	
		if(pae->MergeData(MD_SIMPLE_REPLACERANGE, &sr) == NOERROR)
		{
			// If the data was merged successfully, then we do
			// not need these anti-events
			if(paeCF)
				DestroyAEList(paeCF);

			if(paePF)
				DestroyAEList(paePF);

			// we've done everything we need to.
			return;
		}
	}

	// Allocate a buffer and grab the soon-to-be deleted
	// text (if necessary)

	if( cchOld > 0 )
	{
		pch = new TCHAR[cchOld];
		if( pch )
			GetText(cchOld, pch);
		else
			cchOld = 0;
	}

	// The new range will exist from our current position plus
	// cchNew (because everything in cchOld gets deleted)

	pae = gAEDispenser.CreateReplaceRangeAE(_ped, _cp, _cp + cchNew,
			cchOld, pch, paeCF, paePF);

	if( !pae )
		delete pch;

	if( pae )
		publdr->AddAntiEvent(pae);
}

/*
 *	CTxtPtr::InsertRange(cch, pch)
 *	
 *	@mfunc
 *		Insert a range of characters at this text pointer			
 *	
 *	@rdesc
 *		Count of characters successfully inserted
 *	
 *	@comm Side Effects: <nl>
 *		moves this text pointer to end of inserted text <nl>
 *		moves the text block array <nl>
 */
LONG CTxtPtr::InsertRange (
	LONG cch, 				//@parm length of text to insert
	TCHAR const *pch)		//@parm text to insert
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::InsertRange");

	_TEST_INVARIANT_

	LONG cchSave = cch;
	LONG cchInBlock;
	LONG cchFirst;
	LONG cchLast = 0;
	LONG ctbNew;
	CTxtBlk *ptb;
	
	// Ensure text array is allocated
	if(!Count())
	{
		LONG	cbSize = -1;

		// If we don't have any blocks, allocate first block to be big enuf
		// for the inserted text *only* if it's smaller than the normal block
		// size. This allows us to be used efficiently as a display engine
		// for small amounts of text.

		if(cch < CchOfCb(cbBlockInitial))
			cbSize = CbOfCch(cch);

		if(!((CTxtArray *)_pRuns)->AddBlock(0, cbSize))
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto done;
		}
	}

	ptb = GetRun(0);
	cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
	AssertSz(ptb->_cbBlock <= cbBlockMost, "block too big");

	// try and resize without splitting...
	if(cch > cchInBlock &&
		cch <= cchInBlock + CchOfCb(cbBlockMost - ptb->_cbBlock))
	{
		if( !ptb->ResizeBlock(min(cbBlockMost,
				CbOfCch(ptb->_cch + cch + cchGapInitial))) )
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto done;
		}
		cchInBlock = CchOfCb(ptb->_cbBlock) - ptb->_cch;
	}
	if(cch <= cchInBlock)
	{
		// all fits into block without any hassle

		ptb->MoveGap(_ich);
		CopyMemory(ptb->_pch + _ich, pch, CbOfCch(cch));
		_cp				+= cch;					// *this points at end of
		_ich			+= cch;					//  insertion
		ptb->_cch		+= cch;
		((CTxtArray *)_pRuns)->_cchText	+= cch;
		ptb->_ibGap		+= CbOfCch(cch);

		return cch;
	}

	// won't all fit in this block

	// figure out best division into blocks
	TxDivideInsertion(cch, _ich, ptb->_cch - _ich,&cchFirst, &cchLast);

	// Subtract cchLast up front so return value isn't negative
	// if SplitBlock() fails
	cch -= cchLast;	// don't include last block in count for middle blocks

	// split block containing insertion point

	// ***** moves _prgtb ***** //
	if(!((CTxtArray *)_pRuns)->SplitBlock(_iRun, _ich, cchFirst, cchLast,
		_ped->IsStreaming()))
	{
		_ped->GetCallMgr()->SetOutOfMemory();
		goto done;
	}
	ptb = GetRun(0);			// recompute ptb after (*_pRuns) moves

	// copy into first block (first half of split)
	if(cchFirst > 0)
	{
		AssertSz(ptb->_ibGap == CbOfCch(_ich), "split first gap in wrong place");
		AssertSz(cchFirst <= CchOfCb(ptb->_cbBlock) - ptb->_cch, "split first not big enough");

		CopyMemory(ptb->_pch + _ich, pch, CbOfCch(cchFirst));
		cch				-= cchFirst;
		pch				+= cchFirst;
		_ich			+= cchFirst;
		ptb->_cch		+= cchFirst;
		((CTxtArray *)_pRuns)->_cchText	+= cchFirst;
		ptb->_ibGap		+= CbOfCch(cchFirst);
	}

	// copy into middle blocks
	// FUTURE: (jonmat) I increased the size for how large a split block
	// could be and this seems to increase the performance, we should test
	// the block size difference on a retail build, however. 5/15/1995
	ctbNew = cch / cchBlkInsertmGapI /* cchBlkInitmGapI */;
	if(ctbNew <= 0 && cch > 0)
		ctbNew = 1;
	for(; ctbNew > 0; ctbNew--)
	{
		cchInBlock = cch / ctbNew;
		AssertSz(cchInBlock > 0, "nothing to put into block");

		// ***** moves _prgtb ***** //
		if(!((CTxtArray *)_pRuns)->AddBlock(++_iRun,
			CbOfCch(cchInBlock + cchGapInitial)))
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			BindToCp(_cp);	//force a rebind;
			goto done;
		}
		// NOTE: next line intentionally advances ptb to next CTxtBlk

		ptb = GetRun(0);
		AssertSz(ptb->_ibGap == 0, "New block not added correctly");

		CopyMemory(ptb->_pch, pch, CbOfCch(cchInBlock));
		cch				-= cchInBlock;
		pch				+= cchInBlock;
		_ich			= cchInBlock;
		ptb->_cch		= cchInBlock;
		((CTxtArray *)_pRuns)->_cchText	+= cchInBlock;
		ptb->_ibGap		= CbOfCch(cchInBlock);
	}
	AssertSz(cch == 0, "Didn't use up all text");

	// copy into last block (second half of split)
	if(cchLast > 0)
	{
		AssertSz(_iRun < Count()-1, "no last block");
		ptb = Elem(++_iRun);
		AssertSz(ptb->_ibGap == 0,	"split last gap in wrong place");
		AssertSz(cchLast <= CchOfCb(ptb->_cbBlock) - ptb->_cch,
									"split last not big enuf");

		CopyMemory(ptb->_pch, pch, CbOfCch(cchLast));
		// don't subtract cchLast from cch; it's already been done
		_ich			= cchLast;
		ptb->_cch		+= cchLast;
		((CTxtArray *)_pRuns)->_cchText	+= cchLast;
		ptb->_ibGap		= CbOfCch(cchLast);
		cchLast = 0;						// Inserted all requested chars
	}

done:
	AssertSz(cch + cchLast >= 0, "we should have inserted some characters");
	AssertSz(cch + cchLast <= cchSave, "don't insert more than was asked for");

	cch = cchSave - cch - cchLast;			// # chars successfully inserted
	_cp += cch;

	AssertSz (GetTextLength() ==
				((CTxtArray *)_pRuns)->CalcTextLength(),
				"CTxtPtr::InsertRange(): _pRuns->_cchText messed up !");
	return cch;
}

/*
 *	TxDivideInsertion(cch, ichBlock, cchAfter, pcchFirst, pcchLast)
 *	
 *	@func
 *		Find best way to distribute an insertion	
 *	
 *	@rdesc
 *		nothing
 */
static void TxDivideInsertion(
	LONG cch, 				//@parm length of text to insert
	LONG ichBlock, 			//@parm offset within block to insert text
	LONG cchAfter,			//@parm length of text after insertion in block
	LONG *pcchFirst, 		//@parm exit: length of text to put in first block
	LONG *pcchLast)			//@parm exit: length of text to put in last block
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "TxDivideInsertion");

	LONG cchFirst = max(0, cchBlkCombmGapI - ichBlock);
	LONG cchLast  = max(0, cchBlkCombmGapI - cchAfter);
	LONG cchPartial;
	LONG cchT;

	// Fill first and last blocks to min block size if possible

	cchFirst = min(cch, cchFirst);
	cch		-= cchFirst;
	cchLast = min(cch, cchLast);
	cch		-= cchLast;

	// How much is left over when we divide up the rest?
	cchPartial = cch % cchBlkInsertmGapI;
	if(cchPartial > 0)
	{
		// Fit as much as the leftover as possible in the first and last
		// w/o growing the first and last over cbBlockInitial
		cchT		= max(0, cchBlkInsertmGapI - ichBlock - cchFirst);
		cchT		= min(cchT, cchPartial);
		cchFirst	+= cchT;
		cch			-= cchT;
		cchPartial	-= cchT;
		if(cchPartial > 0)
		{
			cchT	= max(0, cchBlkInsertmGapI - cchAfter - cchLast);
			cchT	= min(cchT, cchPartial);
			cchLast	+= cchT;
		}
	}
	*pcchFirst = cchFirst;
	*pcchLast = cchLast;
}

/*
 *	CTxtPtr::DeleteRange(cch)
 *	
 *	@mfunc
 *		Delete cch characters starting at this text pointer		
 *	
 *	@rdesc
 *		nothing
 *	
 *	@comm Side Effects:	<nl>
 *		moves text block array
 */
void CTxtPtr::DeleteRange(
	LONG cch)		//@parm length of text to delete
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::DeleteRange");

	_TEST_INVARIANT_

	LONG		cchInBlock;
	LONG		ctbDel = 0;					// Default no blocks to delete
	LONG		itb;
	CTxtBlk *	ptb = GetRun(0);

	AssertSz(ptb,
		"CTxtPtr::DeleteRange: want to delete, but no text blocks");

	if (cch > GetTextLength() - _cp)	// Don't delete beyond end of story
		cch = GetTextLength() - _cp;

	((CTxtArray *)_pRuns)->_cchText -= cch;

	// remove from first block
	ptb->MoveGap(_ich);
	cchInBlock = min(cch, ptb->_cch - _ich);
	cch -= cchInBlock;
	ptb->_cch -= cchInBlock;

#ifdef DEBUG
	((CTxtArray *)_pRuns)->Invariant();
#endif // DEBUG


	for(itb = ptb->_cch ? _iRun + 1 : _iRun;
			cch && cch >= Elem(itb)->_cch; ctbDel++, itb++)
	{
		// More to go: scan for complete blocks to remove
		cch -= Elem(itb)->_cch;
	}

	if(ctbDel)
	{
		// ***** moves (*_pRuns) ***** //
		itb -= ctbDel;
		((CTxtArray *)_pRuns)->RemoveBlocks(itb, ctbDel);
	}

	// Remove from last block
	if(cch > 0)
	{
		ptb = Elem(itb);
		AssertSz(cch < ptb->_cch, "last block too small");
		ptb->MoveGap(0);
		ptb->_cch -= cch;
#ifdef DEBUG
		((CTxtArray *)_pRuns)->Invariant();
#endif // DEBUG

	}
	((CTxtArray *)_pRuns)->CombineBlocks(_iRun);

	if(_iRun >= Count() || !Elem(_iRun)->_cch)
		BindToCp(_cp);					// Empty block: force tp rebind

	AssertSz (GetTextLength() ==
				((CTxtArray *)_pRuns)->CalcTextLength(),
				"CTxtPtr::DeleteRange(): _pRuns->_cchText messed up !");
}

/*
 *	CTxtPtr::FindText (cpMost, dwFlags, pch, cch)
 *
 *	@mfunc
 *		Find the text string <p pch> of length <p cch> starting at this
 *		text pointer. If found, move this text pointer to the end of the
 *		matched string and return the cp of the first character of the matched
 *		string.  If not found, return -1 and don't change this text ptr.
 *	
 *	@rdesc
 *		character position of first match
 *		<lt> 0 if no match
 */
LONG CTxtPtr::FindText (
	LONG		 cpLimit, 	//@parm Limit of search or <lt> 0 for end of text
	DWORD		 dwFlags, 	//@parm FR_MATCHCASE	case must match <nl>
							//		FR_WHOLEWORD	match must be a whole word
	const TCHAR *pch,		//@parm Text to find
	LONG		 cch)		//@parm Length of text to find
{
	LONG cpFirst, cpLast;
	CTxtFinder tf;

	if(tf.FindText(*this, cpLimit, dwFlags, pch, cch, cpFirst, cpLast))
	{
		// Set text ptr to char just after last char in found string
		SetCp(cpLast + 1);

		// Return cp of first char in found string
		return cpFirst;
	}
	return -1;
}

/*
 *	CTxtPtr::FindOrSkipWhiteSpaces (cchMax, pdwResult, fAdvance, fSkip)
 *	
 *	@mfunc
 *		Find a whitespace or a non-whitespace character (skip all whitespaces).
 *
 *	@rdesc
 *		Signed number of character this ptr was moved by the operation.
 *		In case of moving backward, the return position was already adjusted forward
 *		so the caller doesnt need to.
 */
LONG CTxtPtr::FindOrSkipWhiteSpaces (
	LONG 		cchMax, 			//@parm Max signed count of char to search
	DWORD		dwFlags,			//@parm Input flags
	DWORD* 		pdwResult)			//@parm Flag set if found
{
	const TCHAR*	pch;
	CTxtPtr			tp(*this);
	LONG			iDir = cchMax < 0 ? -1 : 1;
	LONG			cpSave = _cp;
	LONG			cchChunk, cch = 0;
	DWORD			dwResult = 0;
	BOOL 			(*pfnIsWhite)(unsigned) = IsWhiteSpace;

	if (dwFlags & FWS_BOUNDTOPARA)
		pfnIsWhite = IsEOP;

	if (cchMax < 0)
		cchMax = -cchMax;

	while (cchMax > 0 && !dwResult)
	{
		pch = iDir > 0 ? tp.GetPch(cch) : tp.GetPchReverse(cch);

		if (!pch)
			break;						// No text available

		if (iDir < 0)
			pch--;						// Going backward, point at previous char

		cch = min(cch, cchMax);
	
		for(cchChunk = cch; cch > 0; cch--, pch += iDir)
		{
			if ((dwFlags & FWS_SKIP) ^ pfnIsWhite(*pch))
			{
				dwResult++;
				break;
			}
		}
		cchChunk -= cch;
		cchMax -= cchChunk;

		tp.AdvanceCp(iDir * cchChunk);	// advance to next chunk
	}
	
	if (pdwResult)
		*pdwResult = dwResult;

	cch = tp.GetCp() - cpSave;

	if (dwFlags & FWS_ADVANCECP)
		AdvanceCp(cch);					// Auto advance if requested

	return cch;
}

/*
 *	CTxtPtr::FindWhiteSpaceBound (cchMin, cpStart, cpEnd)
 *	
 *	@mfunc
 *		Figure the smallest boundary that covers cchMin and limited by
 *		whitespaces (included CR/LF). This is how it works.
 *
 *      Text:           xxx  xxx  xxx  xxx  xxx
 *      cp + cchMin:             xxxxx
 *      Boundary:            xxxxxxxxxxxxx
 *		
 */
LONG CTxtPtr::FindWhiteSpaceBound (
	LONG 		cchMin, 			// @parm Minimum char count to be covered
	LONG& 		cpStart, 			// @parm Boundary start
	LONG& 		cpEnd,				// @parm Boundary end
	DWORD		dwFlags)			// @parm Input flags
{
	CTxtPtr			tp(*this);
	LONG			cch	= tp.GetTextLength();
	LONG			cp	= _cp;

	Assert (cp + cchMin <= cch);

	cpStart = cpEnd	= cp;
	cpEnd	+= max(2, cchMin);			// make sure it covers minimum requirement.
	cpEnd	= min(cpEnd, cch);			// but not too many


	dwFlags &= FWS_BOUNDTOPARA;


	// Figure nearest upper bound
	//
	tp.SetCp(cpEnd);
	cpEnd += tp.FindOrSkipWhiteSpaces(cch - cpEnd, dwFlags | FWS_ADVANCECP);			// find a whitespaces
	cpEnd += tp.FindOrSkipWhiteSpaces(cch - cpEnd, dwFlags | FWS_ADVANCECP | FWS_SKIP);	// skip whitespaces
	if (!(dwFlags & FWS_BOUNDTOPARA))
		cpEnd += tp.FindOrSkipWhiteSpaces(cch - cpEnd, dwFlags | FWS_ADVANCECP);		// find a whitespace


	// Figure nearest lower bound
	//
	tp.SetCp(cpStart);
	cpStart += tp.FindOrSkipWhiteSpaces(-cpStart, dwFlags | FWS_ADVANCECP);				// find a whitespace
	cpStart += tp.FindOrSkipWhiteSpaces(-cpStart, dwFlags | FWS_ADVANCECP | FWS_SKIP);	// skip whitespaces
	if (!(dwFlags & FWS_BOUNDTOPARA))
		cpStart += tp.FindOrSkipWhiteSpaces(-cpStart, dwFlags | FWS_ADVANCECP);			// find a whitespace

	Assert (cpStart <= cpEnd && cpEnd - cpStart >= cchMin);
	
	return cpEnd - cpStart;
}


/*
 *	CTxtPtr::FindEOP(cchMax, pResults)
 *	
 *	@mfunc
 *		Find EOP mark in a range within cchMax chars from this text pointer
 *		and position *this after it.  If no EOP is found and cchMax is not
 *		enough to reach the start or end of the story, leave this text ptr
 *		alone and return 0.  If no EOP is found and cchMax is sufficient to
 *		reach the start or end of the story, position this text ptr at the
 *		beginning/end of document (BOD/EOD) for cchMax <lt>/<gt> 0,
 *		respectively, that is, BOD and EOD are treated as a BOP and an EOP,
 *		respectively.	
 *
 *	@rdesc
 *		Return cch this text ptr is moved. Return in *pResults whether a CELL
 *		or EOP was found.  The low byte gives the cch of the EOP if moving
 *		forward (else it's just 1).
 *
 *	@devnote
 *		This function assumes that this text ptr isn't in middle of a CRLF
 *		or CRCRLF (found only in RichEdit 1.0 compatibility mode).  Changing
 *		the for loop could speed up ITextRange MoveUntil/While substantially.
 */
LONG CTxtPtr::FindEOP (
	LONG  cchMax,		//@parm Max signed count of chars to search
	LONG *pResults)		//@parm Flags saying if EOP and CELL are found
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindEOP");

	LONG		cch = 0, cchStart;			// cch's for scans
	unsigned	ch;							// Current char
	LONG		cpSave	= _cp;				// Save _cp for returning delta
	LONG		iDir	= 1;				// Default forward motion
	const TCHAR*pch;						// Used to walk text chunks
	LONG		Results = 0;				// Nothing found yet
	CTxtPtr		tp(*this);					// tp to search text with

	if(cchMax < 0)							// Backward search
	{
		iDir = -1;							// Backward motion
		cchMax = -cchMax;					// Make max count positive
		cch = tp.AdjustCpCRLF();			// If in middle of CRLF or
		if(!cch && IsAfterEOP())			//  CRCRLF, or follow any EOP,
			cch = tp.BackupCpCRLF();		//  backup before EOP
		cchMax += cch;
	}

	while(cchMax > 0)						// Scan until get out of search
	{										//  range or match an EOP
		pch = iDir > 0						// Point pch at contiguous text
			? tp.GetPch(cch)				//  chunk going forward or
			: tp.GetPchReverse(cch);		//  going backward

		if(!pch)							// No more text to search
			break;

		if(iDir < 0)						// Going backward, point at
			pch--;							//  previous char

		cch = min(cch, cchMax);				// Limit scan to cchMax chars
		for(cchStart = cch; cch; cch--)		// Scan chunk for EOP
		{
			ch = *pch;
			if(ch == CELL)
				Results |= FEOP_CELL;		// Note that CELL was found

			if(IsEOP(ch))					// Note that EOP was found
			{								// Going forward, cch may = 0
				Results |= FEOP_EOP;		
				break;
			}
			pch += iDir;
		}
		cchStart -= cch;					// Get cch of chars passed by
		cchMax -= cchStart;					// Update cchMax

		AssertSz(iDir > 0 && GetCp() + cchStart <= GetTextLength() ||
				 iDir < 0 && GetCp() - cchStart >= 0,
			"CTxtPtr::FindEOP: illegal advance");

		tp.AdvanceCp(iDir*cchStart);		// Update tp
		if(Results & FEOP_EOP)				// Found an EOP
			break;
	}										// Continue with next chunk

	LONG cp = tp.GetCp();

	if ((Results & FEOP_EOP) || !cp ||		// Found EOP or cp is at story
		cp == GetTextLength())				//  beginning or end
	{										
		SetCp(cp);							// Set _cp = tp._cp
		if(iDir > 0)						// Going forward, put ptr just
			Results = (Results & ~255) | AdvanceCpCRLF();//  after EOP (going
	}										//  back, is already after EOP)
	if(pResults)							// Report whether EOP and CELL
		*pResults = Results;				//  were found

	return _cp - cpSave;					// Return cch this tp moved
}

/*
 *	CTxtPtr::FindBOSentence(cch)
 *	
 *	@mfunc
 *		Find beginning of sentence in a range within cch chars from this text
 *		pointer and	position *this at it.  If no sentence beginning is found,
 *		position *this at beginning of document (BOD) for cch <lt> 0 and
 *		leave *this unchanged for cch >= 0.
 *
 *	@rdesc
 *		Count of chars moved *this moves
 *
 *	@comm
 *		This routine defines a sentence as a character string that ends with
 *		period followed by at least one whitespace character or the EOD.  This
 *		should be replacable so that other kinds of sentence endings can be
 *		used.  This routine also matches initials like "M. " as sentences.
 *		We could eliminate those by requiring that sentences don't end with
 *		a word consisting of a single capital character.  Similarly, common
 *		abbreviations like "Mr." could be bypassed.  To allow a sentence to
 *		end with these "words", two blanks following a period could be used
 *		to mean an unconditional end of sentence.
 */
LONG CTxtPtr::FindBOSentence (
	LONG cch)			//@parm max signed count of chars to search
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindBOSentence");

	_TEST_INVARIANT_

	LONG	cchWhite = 0;						// No whitespace chars yet
	LONG	cp;
	LONG	cpSave	 = _cp;						// Save value for return
	BOOL	fST;								// TRUE if sent terminator
	LONG	iDir	 = cch > 0 ? 1 : -1;		// AdvanceCp() increment
	CTxtPtr	tp(*this);							// tp to search with

	if(iDir > 0)								// If going forward in white
		while(IsWhiteSpace(tp.GetChar()) &&		//  space, backup to 1st non
				tp.AdvanceCp(-1)) ;				//  whitespace char (in case
												//  inside sentence ending)
	while(iDir > 0 || tp.AdvanceCp(-1))			// Need to back up if finding
	{											//  backward
		for(fST = FALSE; cch; cch -= iDir)		// Find sentence terminator
		{
			fST = IsSentenceTerminator(tp.GetChar());
			if(fST || !tp.AdvanceCp(iDir))
				break;
		}
		if(!fST)								// If FALSE, we	ran out of
			break;								//  chars

		while(IsWhiteSpace(tp.NextChar()) && cch)
		{										// Bypass a span of blank
			cchWhite++;							//  chars
			cch--;
		}

		if(cchWhite && (cch >= 0 || tp._cp < cpSave))// Matched new sentence
			break;								//  break

		if(cch < 0)								// Searching backward
		{
			tp.AdvanceCp(-cchWhite - 1);		// Back up to terminator
			cch += cchWhite + 1;				// Fewer chars to search
		}
		cchWhite = 0;							// No whitespace yet for next
	}											//  iteration

	cp = tp._cp;
	if(cchWhite || !cp || cp == GetTextLength())// If sentence found or got
		SetCp(cp);								//  start/end of story, set
												//  _cp to tp's
	return _cp - cpSave;						// Tell caller cch moved
}

/*
 *	CTxtPtr::IsAtBOSentence()
 *	
 *	@mfunc
 *		Return TRUE iff *this is at the beginning of a sentence (BOS) as
 *		defined in the description of the FindBOSentence(cch) routine
 *
 *	@rdesc
 *		TRUE iff this text ptr is at the beginning of a sentence
 */
BOOL CTxtPtr::IsAtBOSentence()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAtBOSentence");

	if(!_cp)									// Beginning of story is an
		return TRUE;							//  unconditional beginning
												//  of sentence
	unsigned ch = GetChar();

	if (IsWhiteSpace(ch) ||						// Proper sentences don't
		IsSentenceTerminator(ch))				//  start with whitespace or
	{											//  sentence terminators
		return FALSE;
	}
												
	LONG	cchWhite;
	CTxtPtr tp(*this);							// tp to walk preceding chars

	for(cchWhite = 0;							// Backspace over possible
		IsWhiteSpace(ch = tp.PrevChar());		//  span of whitespace chars
		cchWhite++) ;

	return cchWhite && IsSentenceTerminator(ch);
}

/*
 *	CTxtPtr::IsAtBOWord()
 *	
 *	@mfunc
 *		Return TRUE iff *this is at the beginning of a word, that is,
 *		_cp = 0 or the char at _cp is an EOP, or
 *		FindWordBreak(WB_MOVEWORDRIGHT) would break at _cp.
 *
 *	@rdesc
 *		TRUE iff this text ptr is at the beginning of a Word
 */
BOOL CTxtPtr::IsAtBOWord()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::IsAtBOWord");

	if(!_cp || IsAtEOP())					// Story beginning is also
		return TRUE;						//  a word beginning

	CTxtPtr tp(*this);
	tp.AdvanceCp(-1);
	tp.FindWordBreak(WB_MOVEWORDRIGHT);
	return _cp == tp._cp;
}

/*
 *	CTxtPtr::FindExact(cchMax, pch)
 *	
 *	@mfunc
 *		Find exact text match for null-terminated string pch in a range
 *		starting at this text pointer. Position this just after matched
 *		string and return cp at start of string, i.e., same as FindText().
 *	
 *	@rdesc
 *		Return cp of first char in matched string and *this pointing at cp
 *		just following matched string.  Return -1 if no match
 *
 *	@comm
 *		Much faster than FindText, but still a simple search, i.e., could
 *		be improved.
 *
 *		FindText can delegate to this search for search strings in which
 *		each char can only match itself.
 */
LONG CTxtPtr::FindExact (
	LONG	cchMax,		//@parm signed max # of chars to search
	TCHAR *	pch)		//@parm ptr to null-terminated string to find exactly
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::FindExact");

	_TEST_INVARIANT_

	LONG	cch, cchStart;
	LONG	cchValid;
	LONG	cchText = GetTextLength();
	LONG	cpMatch;
	LONG	iDir = 1;						// Default for forward search
	const TCHAR	*pc;
	CTxtPtr	tp(*this);						// tp to search text with

	if(!*pch)
		return -1;							// Signal null string not found

	if(cchMax < 0)							// Backward search
	{
		iDir = -1;
		cchMax = -cchMax;					// Make count positive
	}

	while(cchMax > 0)
	{
		if(iDir > 0)
		{
			if(tp.GetCp() >= cchText)	// Can't go further
				break;
			pc  = tp.GetPch(cchValid);		// Characters we can search w/o
			cch = cchValid; 				//  encountering block end/gap,
		}									//  i.e., stay within text chunk
		else
		{
			if(!tp.GetCp())					// Can't back up any more
				break;
			tp.AdvanceCp(-1);
			pc  = tp.GetPchReverse(cchValid);
			cch = cchValid + 1;
		}

		cch = min(cch, cchMax);
		if(!cch || !pc)
			break;							// No more text to search

		for(cchStart = cch;					// Find first char
			cch && *pch != *pc; cch--)		// Most execution time is spent
		{									//  in this loop going forward or
			pc += iDir;						//  backward. x86 rep scasb/scasw
		}									//  are faster

		cchStart -= cch;
		cchMax	 -= cchStart;				// Update cchMax
		tp.AdvanceCp( iDir*(cchStart));		// Update tp

		if(cch && *pch == *pc)				// Matched first char
		{									// See if matches up to null
			cpMatch = tp.GetCp();			// Save cp of matched first char
			cch = cchMax;
			for(pc = pch;					// Try to match rest of string
				cch && *++pc==tp.NextChar();// Note: this match goes forward
				cch--) ;					//  for both values of iDir
			if(!cch)
				break;						// Not enuf chars for string

			if(!*pc)						// Matched null-terminated string
			{								//  *pch. Set this tp just after
				SetCp(tp.GetCp());			//  matched string and return cp
				return cpMatch;				//  at start
			}
			tp.SetCp(cpMatch + iDir);		// Move to char just following or
		}									//  preceding matched first char
	}										// Up-to-date tp: continue search

	return -1;								// Signal string not found
}

/*
 *	CTxtPtr::NextCharCount(&cch)
 *
 *	@mfunc
 *		Helper function for getting next char and decrementing abs(*pcch)
 *
 *	@rdesc
 *		Next char
 */
TCHAR CTxtPtr::NextCharCount (
	LONG& cch)					//@parm count to use and decrement
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPtr::NextCharCount");

	LONG	iDelta = (cch > 0) ? 1 : -1;

	if(!cch || !AdvanceCp(iDelta))
		return 0;

	cch -= iDelta;							// Count down or up
	return GetChar();						// Return char at _cp
}

/*
 *	CTxtPtr::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie by NULLing out its _ped member
 */
void CTxtPtr::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtPtr::Zombie");

	_ped = NULL;
	_cp = 0;
	SetToNull();
}

/*
 *	CTxtIStream::CTxtIStream(tp, iDir)
 *
 *	@mfunc
 *		Creates from the textptr, <p tp>, a character input stream with which
 *		to retrieve characters starting from the cp of the <p tp> and proceeding
 *		in the direction indicated by <p iDir>.
 */
CTxtIStream::CTxtIStream(
	const CTxtPtr &tp,
	int iDir
) : CTxtPtr(tp)
{
	_pfnGetChar = (iDir == DIR_FWD ?
				   &CTxtIStream::GetNextChar : &CTxtIStream::GetPrevChar);
	_cch = 0;
	_pch = NULL;
}

/*
 * 	CTxtIStream::GetNextChar()
 *
 *	@mfunc
 *		Returns the next character in the text stream.
 *		Ensures that at least one valid character exists in _pch and then returns
 *		the next character in _pch.
 *
 * 	@rdesc
 *		TCHAR	the next character in the character input stream
 *				0, if end of text stream
 */
TCHAR CTxtIStream::GetNextChar()
{
	if(!_cch)
		FillPchFwd();

	if(_cch)
	{
		_cch--;
		return *_pch++;
	}
	return 0;
}

/*
 * 	CTxtIStream::GetPrevChar()
 *
 *	@mfunc
 *		Returns the next character in the text stream, where the direction of the
 *		stream is reverse.
 *		Ensures that at least one valid character exists in _pch and then returns
 *		the next character in _pch.  Here, _pch points to the end of a string
 *		containing _cch valid characters.
 *
 * 	@rdesc
 *		TCHAR	the next character in the character input stream (travelling backwards
 *				along the string pointed to by _pch)
 *				0, if end of text stream
 */
TCHAR CTxtIStream::GetPrevChar()
{
	if(!_cch)
		FillPchRev();

	if(_cch)
	{
		_cch--;
		return *(--_pch);
	}
	return 0;
}


/*
 *	CTxtIStream::FillPchFwd()
 *
 *	@mfunc
 *		Gets the next run of characters and advances the cp of this CTxtPtr (base
 *		class) just past the run.
 *		This ensures enough chars in _pch to facilitate the next _cch calls to
 *		GetNextChar().
 */
void CTxtIStream::FillPchFwd()
{
	_pch = GetPch(_cch);
	AdvanceCp(_cch);
}

/*
 *	CTxtIStream::FillPchRev()
 *
 *	@mfunc
 *		Gets the run of characters preceding the one previously pointed to by _pch
 * 		and advances the cp of this CTxtPtr (base class) to the beginning of the run.
 *		This ensures enough chars in _pch to facilitate the next _cch calls to
 *		GetPrevChar().
 */
void CTxtIStream::FillPchRev()
{
	_pch = GetPchReverse(_cch);

	AdvanceCp(-_cch);
}

/*
 *	CTxtFinder::FindText (cpMost, dwFlags, pch, cchToFind)
 *
 *	@mfunc
 *		Find the text string <p pch> of length <p cchToFind> starting at this
 *		text pointer. If found, <p cpFirst> and <p cpLast> are set to
 *		the cp's of the first and last characters in the matched string (wrt tp).
 *		If not found, return FALSE.
 *	
 *	@rdesc
 *		TRUE	string matched.  First char at tp.GetCp() + cchOffFirst.
 *					Last char at tp.GetCp() + cchOffLast.
 *		FALSE	string not found.
 */
BOOL CTxtPtr::CTxtFinder::FindText (
	const CTxtPtr &tp,
	LONG		cpLimit, 	//@parm Limit of search or <lt> 0 for end of text
	DWORD		dwFlags, 	//@parm FR_MATCHCASE	case must match <nl>
							//		FR_WHOLEWORD	match must be a whole word
	const TCHAR *pchToFind, //@parm Text to search for
	LONG cchToFind,			//@parm Count of chars to search for
	LONG &cpFirst,			//@parm If string found, returns cp (wrt tp) of first char
	LONG &cpLast)			//@parm If string found, returns cp (wrt tp) of last char
{
	if(!cchToFind)
		return FALSE;

	_fSearchForward = dwFlags & FR_DOWN;

	// Calculate max number of chars we must search for pchToFind
	if(_fSearchForward)
	{
		const LONG cchText = tp.GetTextLength();
			
		if((DWORD)cpLimit > (DWORD)cchText)		// NB: catches cpLimit < 0 too
			cpLimit = cchText;

		_cchToSearch = cpLimit - tp.GetCp();
	}
	else
	{
		if((DWORD)cpLimit > (DWORD)tp.GetCp())	// NB: catches cpLimit < 0 too
			cpLimit = 0;

		_cchToSearch = tp.GetCp() - cpLimit;
	}

	if(cchToFind > _cchToSearch)
	{
		// Not enough chars in requested direction within which
		// to find string
		return FALSE;
	}

	const BOOL fWholeWord = dwFlags & FR_WHOLEWORD;

	_fIgnoreCase	 = !(dwFlags & FR_MATCHCASE);
	_fMatchAlefhamza = dwFlags & FR_MATCHALEFHAMZA;
	_fMatchKashida	 = dwFlags & FR_MATCHKASHIDA;
	_fMatchDiac		 = dwFlags & FR_MATCHDIAC;

	typedef LONG (CTxtPtr::CTxtFinder::*PFNMATCHSTRING)(TCHAR const *pchToFind,
											LONG cchToFind,
											CTxtIStream &tistr);

	// Setup function pointer appropriate for this type of search
	CTxtEdit*	   ped = tp._ped;
	PFNMATCHSTRING pfnMatchString;

#define MATCHARABICSPECIALS	(FR_MATCHALEFHAMZA | FR_MATCHKASHIDA | FR_MATCHDIAC)
	// If match all Arabic special characters exactly, then use simpler
	// MatchString routine.  If ignore any and BiDi text exists, use
	// MatchStringBiDi.
	pfnMatchString = (ped->IsBiDi() &&
						(dwFlags & MATCHARABICSPECIALS) != MATCHARABICSPECIALS)
				   ? &CTxtFinder::MatchStringBiDi
				   : &CTxtFinder::MatchString;

	_iDirection = _fSearchForward ? 1 : -1;

	BOOL fFound = FALSE;
	TCHAR chFirst = _fSearchForward ? *pchToFind : pchToFind[cchToFind - 1];
	const TCHAR *pchRemaining = _fSearchForward ?
		&pchToFind[1] : &pchToFind[cchToFind - 2];
	LONG cchRead;
	LONG cchReadToFirst = 0;
	LONG cchReadToLast;
	CTxtIStream tistr(tp,
					  _fSearchForward ? CTxtIStream::DIR_FWD : CTxtIStream::DIR_REV);

	while((cchRead = FindChar(chFirst, tistr)) != -1)
	{
		cchReadToFirst += cchRead;

		if(cchToFind == 1)					// Only one char in string - we've matched it!
		{			
			if (_iDirection > 0)			// Searching forward
			{
				Assert(tp.GetCp() + cchReadToFirst - 1 >= 0);
				cpLast = cpFirst = tp.GetCp() + cchReadToFirst - 1;
			}
			else							// Searching backward
			{
				Assert(tp.GetCp() - cchReadToFirst >= 0);
				cpLast = cpFirst = tp.GetCp() - cchReadToFirst;
			}
			fFound = TRUE;
		}
		else
		{
			// Check if this first char begins a match of string
			CTxtIStream tistrT(tistr);
			cchRead = (this->*pfnMatchString)(pchRemaining, cchToFind - 1, tistrT);
			if(cchRead != -1)
			{
				cchReadToLast = cchReadToFirst + cchRead;
			
				if (_iDirection > 0)			// Searching forward
				{					
					Assert(tp.GetCp() + cchReadToFirst - 1 >= 0);
					Assert(tp.GetCp() + cchReadToLast - 1 >= 0);

					cpFirst = tp.GetCp() + cchReadToFirst - 1;
					cpLast = tp.GetCp() + cchReadToLast - 1;
				}
				else							// Searching backward
				{					
					Assert(tp.GetCp() - cchReadToFirst >= 0);
					Assert(tp.GetCp() - cchReadToLast >= 0);

					cpFirst = tp.GetCp() - cchReadToFirst;
					cpLast = tp.GetCp() - cchReadToLast;
				}

				fFound = TRUE;
			}
		}
		
		if(fFound)
		{
			Assert(cpLast < tp.GetTextLength());
			
			if(!fWholeWord)
				break;
			
			// Check if matched string is whole word
			
			LONG cchT;
			LONG cpBefore = (_fSearchForward ? cpFirst : cpLast) - 1;
			LONG cpAfter  = (_fSearchForward ? cpLast : cpFirst) + 1;

			if((cpBefore < 0 ||
				(ped->TxWordBreakProc(const_cast<LPTSTR>(CTxtPtr(tp._ped, cpBefore).GetPch(cchT)),
					   0,
					   sizeof(TCHAR),
					   WB_CLASSIFY, cpBefore) & WBF_CLASS) ||
				ped->_pbrk && ped->_pbrk->CanBreakCp(BRK_WORD, cpBefore + 1))

				&&

			   (cpAfter >= tp.GetTextLength() ||
				(ped->TxWordBreakProc(const_cast<LPTSTR>(CTxtPtr(tp._ped, cpAfter).GetPch(cchT)),
					   0,
					   sizeof(TCHAR),
					   WB_CLASSIFY, cpAfter) & WBF_CLASS) ||
				ped->_pbrk && ped->_pbrk->CanBreakCp(BRK_WORD, cpAfter)))
			{
				break;
			}
			else
				fFound = FALSE;
		}
	}

	if(fFound && !_fSearchForward)
	{
		// For search backwards, first and last are juxtaposed
		LONG cpTemp = cpFirst;

		cpFirst = cpLast;
		cpLast = cpTemp;
	}
	return fFound;
}

/*
 *	CTxtPtr::CTxtFinder::CharCompMatchCase(ch1, ch2)
 *
 *	@func	Character comparison function sensitive to case according to parms
 *			of current search.
 *
 *	@rdesc	TRUE iff characters are equal
 */
inline BOOL CTxtPtr::CTxtFinder::CharComp(
	TCHAR ch1,
	TCHAR ch2) const
{
    // We compare the characters ourselves if ignore case AND the character isn't a surrogate
    //
	return (_fIgnoreCase && !IN_RANGE(0xD800, ch1, 0xDFFF)) ? CharCompIgnoreCase(ch1, ch2) : (ch1 == ch2);
}

/*
 *	CTxtPtr::CTxtFinder::CharCompIgnoreCase(ch1, ch2)
 *
 *	@func	Character comparison function
 *
 *	@rdesc	TRUE iff characters are equal, ignoring case
 */
inline BOOL CTxtPtr::CTxtFinder::CharCompIgnoreCase(
	TCHAR ch1,
	TCHAR ch2) const
{
	return CompareString(LOCALE_USER_DEFAULT,
						 NORM_IGNORECASE | NORM_IGNOREWIDTH,
						 &ch1, 1, &ch2, 1) == 2;
}

/*
 *	CTxtPtr::CTxtFinder::FindChar(ch, tistr)
 *
 *	@mfunc
 *		Steps through the characters returned from <p tistr> until a character is
 *		found which matches ch or until _cchToSearch characters have been examined.
 *		If found, the return value indicates the number of chars read from <p tistr>.
 *		If not found, -1 is returned.
 *
 *	@rdesc
 *		-1,	if char not found
 * 		n, 	if char found.  n indicates number of chars read from <p tistr>
 *				to find the char
 */
LONG CTxtPtr::CTxtFinder::FindChar(
	TCHAR ch,
	CTxtIStream &tistr)
{
	LONG cchSave = _cchToSearch;

	while(_cchToSearch)
	{
		_cchToSearch--;

		TCHAR chComp = tistr.GetChar();

		if(CharComp(ch, chComp) ||
		   (!_fMatchAlefhamza && IsAlef(ch) && IsAlef(chComp)))
		{
			return cchSave - _cchToSearch;
		}
	}
	return -1;
}

/*
 *	CTxtPtr::CTxtFinder::MatchString(pchToFind, cchToFind, tistr)
 *
 *	@mfunc
 *		This method compares the characters returned from <p tistr> against those
 *		found in pchToFind.  If the string is found, the return value indicates
 *		how many characters were read from <p tistr> to match the string.
 *		If the string is not found, -1 is returned.
 *	
 *	@rdesc
 *		-1,	if string not found
 * 		n, 	if string found.  n indicates number of chars read from <p tistr>
 *				to find string
 */
LONG CTxtPtr::CTxtFinder::MatchString(
	const TCHAR *pchToFind,
	LONG cchToFind,
	CTxtIStream &tistr)
{
	if((DWORD)_cchToSearch < (DWORD)cchToFind)
		return -1;

	LONG cchT = cchToFind;

	while(cchT--)
	{
		if(!CharComp(*pchToFind, tistr.GetChar()))
			return -1;

		pchToFind += _iDirection;
	}
	return cchToFind;
}

/*
 *	CTxtPtr::CTxtFinder::MatchStringBiDi(pchToFind, cchToFind, tistr)
 *
 *	@mfunc
 *		This method compares the characters returned from <p tistr> against those
 *		found in pchToFind.  If the string is found, the return value indicates
 *		how many characters were read from <p tistr> to match the string.
 *		If the string is not found, -1 is returned.
 *		Kashida, diacritics and Alefs are matched/not matched according
 *		to the type of search requested.
 *	
 *	@rdesc
 *		-1,	if string not found
 * 		n, 	if string found.  n indicates number of chars read from <p tistr>
 *				to find string
 */
LONG CTxtPtr::CTxtFinder::MatchStringBiDi(
	const TCHAR *pchToFind,
	LONG		 cchToFind,
	CTxtIStream &tistr)
{
	if((DWORD)_cchToSearch < (DWORD)cchToFind)
		return -1;

	LONG cchRead = 0;

	while(cchToFind)
	{
		TCHAR chComp = tistr.GetChar();
		cchRead++;

		if(!CharComp(*pchToFind, chComp))
		{
			if (!_fMatchKashida && chComp == KASHIDA ||
				!_fMatchDiac && IsBiDiDiacritic(chComp))
			{
				continue;
			}
			if (!_fMatchAlefhamza &&
				IsAlef(*pchToFind) && IsAlef(chComp))
			{
				// Skip *pchToFind
			}
			else
				return -1;
		}
		pchToFind += _iDirection;
		cchToFind--;
	}
	return cchRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\tokens.cpp ===
/*
 *		tokens.cpp
 *
 *		The sorted table of strings and token values
 *
 *		Note: if you insert new keywords, be sure to insert the corresponding
 *		i_keyword in the i_xxx enum in tokens.h.  This enum defines the
 *		indices used by RTFWrit to output RTF control words.
 *
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "tokens.h"

extern const KEYWORD rgKeyword[] =
{
	{"adeff",		tokenDefaultBiDiFont},
	{"af",			tokenAssocFontSelect},
	{"animtext",	tokenAnimText},
	{"ansi",		tokenCharSetAnsi},
	{"ansicpg",		tokenAnsiCodePage},
	{"b",			tokenBold},
	{"bgbdiag",		tokenBckgrndBckDiag},
	{"bgcross",		tokenBckgrndCross},
	{"bgdcross",	tokenBckgrndDiagCross},
	{"bgdkbdiag",	tokenBckgrndDrkBckDiag},
	{"bgdkcross",	tokenBckgrndDrkCross},
	{"bgdkdcross",	tokenBckgrndDrkDiagCross},
	{"bgdkfdiag",	tokenBckgrndDrkFwdDiag},
	{"bgdkhoriz",	tokenBckgrndDrkHoriz},
	{"bgdkvert",	tokenBckgrndDrkVert},
	{"bgfdiag",		tokenBckgrndFwdDiag},
	{"bghoriz",		tokenBckgrndHoriz},
	{"bgvert",		tokenBckgrndVert},
	{"bin",			tokenBinaryData},
	{"blue",		tokenColorBlue},
	{"box",			tokenBox},
	{"brdrb",		tokenBorderBottom},
	{"brdrbar",		tokenBorderOutside},
	{"brdrbtw",		tokenBorderBetween},
	{"brdrcf",		tokenBorderColor},
	{"brdrdash",	tokenBorderDash},
	{"brdrdashsm",	tokenBorderDashSmall},
	{"brdrdb",		tokenBorderDouble},
	{"brdrdot",		tokenBorderDot},
	{"brdrhair",	tokenBorderHairline},
	{"brdrl",		tokenBorderLeft},
	{"brdrr",		tokenBorderRight},
	{"brdrs",		tokenBorderSingleThick},
	{"brdrsh",		tokenBorderShadow},
	{"brdrt",		tokenBorderTop},
	{"brdrth",		tokenBorderDoubleThick},
	{"brdrtriple",	tokenBorderTriple},
	{"brdrw",		tokenBorderWidth},
	{"brsp",		tokenBorderSpace},
	{"bullet",		BULLET},
	{"caps",		tokenCaps},
	{"cbpat",		tokenColorBckgrndPat},
	{"cell",		tokenCell},
	{"cellx",		tokenCellX},
	{"cf",			tokenColorForeground},
	{"cfpat",		tokenColorForgrndPat},
	{"clbrdrb",		tokenCellBorderBottom},
	{"clbrdrl",		tokenCellBorderLeft},
	{"clbrdrr",		tokenCellBorderRight},
	{"clbrdrt",		tokenCellBorderTop},
	{"collapsed",	tokenCollapsed},
	{"colortbl",	tokenColorTable},
	{"cpg",			tokenCodePage},
	{"cs",			tokenCharStyle},
	{"dbch",		tokenDBChars},
	{"deff",		tokenDefaultFont},
	{"deflang",		tokenDefaultLanguage},
	{"deflangfe",	tokenDefaultLanguageFE},
	{"deftab",		tokenDefaultTabWidth},
	{"deleted",		tokenDeleted},
	{"dibitmap",	tokenPictureWindowsDIB},
	{"disabled",	tokenDisabled},
	{"dn",			tokenDown},
	{"dropcapli",	tokenDropCapLines},
	{"embo",		tokenEmboss},
#if 1
	{"emdash",		'-'},
	{"emspace",		' '},
	{"endash",		'-'},
	{"enspace",		' '},
#else
	// FUTURE(BradO):  It turns out that we can't reliably
	//	display these Unicode characters for any particular
	//	font applied to them.  If we choose to do something
	//	more intelligent to ensure that these special chars
	//	are displayed regardless of the font applied, then
	//	we should re-enable this code (see Bug #3179).

	{"emdash",		EMDASH},
	{"emspace",		EMSPACE},
	{"endash",		ENDASH},
	{"enspace",		ENSPACE},
#endif
	{"expndtw",		tokenExpand},
	{"f",			tokenFontSelect},
	{"fbidi",		tokenFontFamilyBidi},
	{"fchars",		tokenFollowingPunct},
	{"fcharset",	tokenCharSet},
	{"fdecor",		tokenFontFamilyDecorative},
	{"fi",			tokenIndentFirst},
	{"field",		tokenField},
	{"fldinst",		tokenFieldInstruction},
	{"fldrslt",		tokenFieldResult},
	{"fmodern",		tokenFontFamilyModern},
	{"fname",		tokenRealFontName},
	{"fnil",		tokenFontFamilyDefault},
	{"fonttbl",		tokenFontTable},
	{"footer",		tokenNullDestination},
	{"footerf",		tokenNullDestination},
	{"footerl",		tokenNullDestination},
	{"footerr",		tokenNullDestination},
	{"footnote",	tokenNullDestination},
	{"fprq",		tokenPitch},
	{"froman",		tokenFontFamilyRoman},
	{"fs",			tokenFontSize},
	{"fscript",		tokenFontFamilyScript},
	{"fswiss",		tokenFontFamilySwiss},
	{"ftech",		tokenFontFamilyTechnical},
	{"ftncn",		tokenNullDestination},
	{"ftnsep",		tokenNullDestination},
	{"ftnsepc",		tokenNullDestination},
	{"green",		tokenColorGreen},
	{"header",		tokenNullDestination},
	{"headerf",		tokenNullDestination},
	{"headerl",		tokenNullDestination},
	{"headerr",		tokenNullDestination},
	{"highlight",	tokenColorBackground},
	{"hyphpar",		tokenHyphPar},
	{"i",			tokenItalic},
	{"impr",		tokenImprint},
	{"info",		tokenDocumentArea},
	{"intbl",		tokenInTable},
	{"keep",		tokenKeep},
	{"keepn",		tokenKeepNext},
	{"kerning",		tokenKerning},
	{"lang",		tokenLanguage},
	{"lchars",		tokenLeadingPunct},
	{"ldblquote",	LDBLQUOTE},
	{"li",			tokenIndentLeft},
	{"line",		tokenLineBreak},
	{"lnkd",		tokenLink},
	{"lquote",		LQUOTE},
	{"ltrch",		tokenLToRChars},
	{"ltrdoc",		tokenLToRDocument},
	{"ltrmark",		LTRMARK},
	{"ltrpar",		tokenLToRPara},
	{"macpict",		tokenPictureQuickDraw},
	{"noline",		tokenNoLineNumber},
	{"nosupersub",	tokenNoSuperSub},
	{"nowidctlpar", tokenNoWidCtlPar},  
	{"objattph",	tokenObjectPlaceholder},
	{"objautlink",	tokenObjectAutoLink},
	{"objclass",	tokenObjectClass},
	{"objcropb",	tokenCropBottom},
	{"objcropl",	tokenCropLeft},
	{"objcropr",	tokenCropRight},
	{"objcropt",	tokenCropTop},
	{"objdata",		tokenObjectData},
	{"object",		tokenObject},
	{"objemb",		tokenObjectEmbedded},
	{"objh",		tokenHeight},
	{"objicemb",	tokenObjectMacICEmbedder},
	{"objlink",		tokenObjectLink},
	{"objname",		tokenObjectName},
	{"objpub",		tokenObjectMacPublisher},
	{"objscalex",	tokenScaleX},
	{"objscaley",	tokenScaleY},
	{"objsetsize",	tokenObjectSetSize},
	{"objsub",		tokenObjectMacSubscriber},
	{"objw",		tokenWidth},
	{"outl",		tokenOutline},
	{"page",		tokenPage},
	{"pagebb",		tokenPageBreakBefore},
	{"par",			tokenEndParagraph},
	{"pard",		tokenParagraphDefault},
	{"piccropb",	tokenCropBottom},
	{"piccropl",	tokenCropLeft},
	{"piccropr",	tokenCropRight},
	{"piccropt",	tokenCropTop},
	{"pich",		tokenHeight},
	{"pichgoal",	tokenDesiredHeight},
	{"picscalex",	tokenScaleX},
	{"picscaley",	tokenScaleY},
	{"pict",		tokenPicture},
	{"picw",		tokenWidth},
	{"picwgoal",	tokenDesiredWidth},
	{"plain",		tokenCharacterDefault},
	{"pmmetafile",	tokenPictureOS2Metafile},
	{"pn",			tokenParaNum},
	{"pndec",		tokenParaNumDecimal},
	{"pnindent",	tokenParaNumIndent},
	{"pnlcltr",		tokenParaNumLCLetter},
	{"pnlcrm",		tokenParaNumLCRoman},
	{"pnlvlblt",	tokenParaNumBullet},
	{"pnlvlbody",	tokenParaNumBody},
	{"pnlvlcont",	tokenParaNumCont},
	{"pnqc",		tokenParaNumAlignCenter},
	{"pnqr",		tokenParaNumAlignRight},
	{"pnstart",		tokenParaNumStart},
	{"pntext",		tokenParaNumText},
	{"pntxta",		tokenParaNumAfter},
	{"pntxtb",		tokenParaNumBefore},
	{"pnucltr",		tokenParaNumUCLetter},
	{"pnucrm",		tokenParaNumUCRoman},
	{"protect",		tokenProtect},
	{"pwd",			tokenPocketWord},
	{"qc",			tokenAlignCenter},
	{"qj",			tokenAlignJustify},
	{"ql",			tokenAlignLeft},
	{"qr",			tokenAlignRight},
	{"rdblquote",	RDBLQUOTE},
	{"red",			tokenColorRed},
	{"result",		tokenObjectResult},
	{"revauth",		tokenRevAuthor},
	{"revised",		tokenRevised},
	{"ri",			tokenIndentRight},
	{"row",			tokenRow},
	{"rquote",		RQUOTE},
	{"rtf",			tokenRtf},
	{"rtlch",		tokenRToLChars},
	{"rtldoc",		tokenRToLDocument},
	{"rtlmark",		RTLMARK},
	{"rtlpar",		tokenRToLPara},
	{"s",			tokenStyle},
 	{"sa",			tokenSpaceAfter},
	{"sb",			tokenSpaceBefore},
	{"sbys",		tokenSideBySide},
	{"scaps",		tokenSmallCaps},
	{"sect",		tokenEndSection},
	{"sectd",		tokenSectionDefault},
	{"shad",		tokenShadow},
	{"shading",		tokenShading},
	{"sl",			tokenLineSpacing},
	{"slmult",		tokenLineSpacingRule},
	{"strike",		tokenStrikeOut},
	{"stylesheet",	tokenStyleSheet},
	{"sub",			tokenSubscript},
	{"super",		tokenSuperscript},
	{"tab",			9},
	{"tb",			tokenTabBar},
	{"tc",			tokenNullDestination},
	{"tldot",		tokenTabLeaderDots},
	{"tleq",		tokenTabLeaderEqual},
	{"tlhyph",		tokenTabLeaderHyphen},
	{"tlth",		tokenTabLeaderThick},
	{"tlul",		tokenTabLeaderUnderline},
	{"tqc",			tokenCenterTab},
	{"tqdec",		tokenDecimalTab},
	{"tqr",			tokenFlushRightTab},
	{"trbrdrb",		tokenBorderBottom},
	{"trbrdrl",		tokenBorderLeft},
	{"trbrdrr",		tokenBorderRight},
	{"trbrdrt",		tokenBorderTop},
	{"trgaph",		tokenCellHalfGap},
	{"trleft",		tokenRowLeft},
	{"trowd",		tokenRowDefault},
	{"trqc",		tokenRowAlignCenter},
	{"trqr",		tokenRowAlignRight},
	{"tx",			tokenTabPosition},
	{"u",			tokenUnicode},
	{"uc",			tokenUnicodeCharByteCount},
	{"ul",			tokenUnderline},
	{"uld",			tokenUnderlineDotted},
	{"uldash",		tokenUnderlineDash},
	{"uldashd",		tokenUnderlineDashDotted},
	{"uldashdd",	tokenUnderlineDashDotDotted},
	{"uldb",		tokenUnderlineDouble},
	{"ulhair",		tokenUnderlineHairline},
	{"ulnone",		tokenStopUnderline},
	{"ulth",		tokenUnderlineThick},
	{"ulw",			tokenUnderlineWord},
	{"ulwave",		tokenUnderlineWave},
	{"up",			tokenUp},
	{"urtf",		tokenURtf},
	{"v",			tokenHiddenText},
	{"viewkind",	tokenViewKind},
	{"viewscale",	tokenViewScale},
	{"wbitmap",		tokenPictureWindowsBitmap},
	{"wbmbitspixel",tokenBitmapBitsPerPixel},
	{"wbmplanes",	tokenBitmapNumPlanes},
	{"wbmwidthbytes",tokenBitmapWidthBytes},
	{"wmetafile",	tokenPictureWindowsMetafile},
	{"xe",			tokenNullDestination},
	{"zwj",			ZWJ},
	{"zwnj",		ZWNJ}
};

INT cKeywords = sizeof(rgKeyword) / sizeof(rgKeyword[0]);

extern const BYTE  szSymbolKeywords[] = "*:{}\\_|\r\n-~";

extern const TOKEN tokenSymbol[] =				// Keep in same order as szSymbolKeywords
{
	tokenOptionalDestination,		// *
	tokenIndexSubentry,				// :
	'{',							// {
	'}',							// }
	'\\',							// BSLASH
	'-',							// _ (nonbreaking hyphen; should be 0x2011)
	tokenFormulaCharacter,			// |
	tokenEndParagraph,				// CR
	tokenEndParagraph,				// LF
	0xAD,							// - (optional hyphen)
#if 1
	' '								// ~ (nonbreaking space)
#else
	// FUTURE(BradO):  It turns out that we can't reliably
	//	display these Unicode characters for any particular
	//	font applied to them.  If we choose to do something
	//	more intelligent to ensure that these special chars
	//	are displayed regardless of the font applied, then
	//	we should re-enable this code (see Bug #3179).

	0xa0							// ~ (nonbreaking space)
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\tomdoc.cpp ===
/*
 *	@doc TOM
 *
 *	@module tomdoc.cpp - Implement the ITextDocument interface on CTxtEdit |
 *	
 *		This module contains the implementation of the TOM ITextDocument
 *		class as well as the global TOM type-info routines
 *
 *	History: <nl>
 *		sep-95	MurrayS: stubs and auto-doc created <nl>
 *		nov-95	MurrayS: upgrade to top-level TOM interface
 *		dec-95	MurrayS: implemented file I/O methods
 *
 *	@future
 *		1. Implement Begin/EndEditCollection
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_range.h"
#include "_edit.h"
#include "_disp.h"
#include "_rtfconv.h"
#include "_select.h"
#include "_font.h"

ASSERTDATA

// TOM Type Info HRESULT and pointers
HRESULT		g_hrGetTypeInfo = NOERROR;
ITypeInfo *	g_pTypeInfoDoc;
ITypeInfo *	g_pTypeInfoSel;
ITypeInfo *	g_pTypeInfoFont;
ITypeInfo *	g_pTypeInfoPara;
ITypeLib  *	g_pTypeLib;

BYTE szUTF8BOM[] = {0xEF, 0xBB, 0xBF};		// UTF-8 for 0xFEFF

//------------------------ Global TOM Type Info Methods -----------------------------

/*
 *	GetTypeInfoPtrs()
 *
 *	@func
 *		Ensure that global TOM ITypeInfo ptrs are valid (else g_pTypeInfoDoc
 *		is NULL).  Return NOERROR immediately if g_pTypeInfoDoc is not NULL,
 *		i.e., type info ptrs are already valid.
 *
 *	@rdesc
 *		HRESULT = (success) ? NOERROR
 *				: (HRESULT from LoadTypeLib or GetTypeInfoOfGuid)
 *
 *	@comm
 *		This routine should be called by any routine that uses the global
 *		type info ptrs, e.g., IDispatch::GetTypeInfo(), GetIDsOfNames, and
 *		Invoke.  That way if noone is using the type library info, it doesn't
 *		have to be loaded.
 *
 */
HRESULT GetTypeInfoPtrs()
{
	HRESULT	hr;
	CLock	lock;							// Only one thread at a time...

	if(g_pTypeInfoDoc)						// Type info ptrs already valid
		return NOERROR;

	if(g_hrGetTypeInfo != NOERROR)			// Tried to get before and failed
		return g_hrGetTypeInfo;

	if (LoadRegTypeLib(LIBID_tom, 1, 0, LANG_NEUTRAL, &g_pTypeLib) != NOERROR)
	{
		hr = LoadTypeLib(OLESTR("RICHED20.DLL"), &g_pTypeLib);
		if(hr != NOERROR)
			goto err;
	}

	// Get ITypeInfo pointers with g_pTypeInfoDoc last
	hr = g_pTypeLib->GetTypeInfoOfGuid(IID_ITextSelection, &g_pTypeInfoSel);
	if(hr == NOERROR)
	{
	    g_pTypeLib->GetTypeInfoOfGuid(IID_ITextFont,	 &g_pTypeInfoFont);
		g_pTypeLib->GetTypeInfoOfGuid(IID_ITextPara,	 &g_pTypeInfoPara);
		g_pTypeLib->GetTypeInfoOfGuid(IID_ITextDocument, &g_pTypeInfoDoc);

		if(g_pTypeInfoFont && g_pTypeInfoPara && g_pTypeInfoDoc)
			return NOERROR;					// Got 'em all
	}
	hr = E_FAIL;

err:
	Assert("Error getting type info pointers");

	g_pTypeInfoDoc	= NULL;					// Type info ptrs not valid
	g_hrGetTypeInfo	= hr;					// Save HRESULT in case called
	return hr;								//  again
}

/*
 *	ReleaseTypeInfoPtrs()
 *
 *	@func
 *		Release TOM type info ptrs in case they have been defined.
 *		Called when RichEdit dll is being unloaded.
 */
void ReleaseTypeInfoPtrs()
{
	if(g_pTypeInfoDoc)
	{
		g_pTypeInfoDoc->Release();
		g_pTypeInfoSel->Release();
		g_pTypeInfoFont->Release();
		g_pTypeInfoPara->Release();
	}
	if(g_pTypeLib)
		g_pTypeLib->Release();
}

/*
 *	GetTypeInfo(iTypeInfo, &pTypeInfo, ppTypeInfo)
 *
 *	@func
 *		IDispatch helper function to check parameter validity and set
 *		*ppTypeInfo = pTypeInfo if OK
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT GetTypeInfo(
	UINT		iTypeInfo,		//@parm Index of type info to return
	ITypeInfo *&pTypeInfo,		//@parm Address of desired type info ptr
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetTypeInfo");

	if(!ppTypeInfo)
		return E_INVALIDARG;

	*ppTypeInfo = NULL;

	if(iTypeInfo > 1)
		return DISP_E_BADINDEX;

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr == NOERROR)
	{
		*ppTypeInfo = pTypeInfo;				// Have to use reference in
		pTypeInfo->AddRef();					//  case defined in this call
	}
	return hr;
}

/*
 *	MyRead(hfile, pbBuffer, cb, pcb)
 *
 *	@func
 *		Callback function for converting a file into an editstream for
 *		input.
 *
 *	@rdesc
 *		(DWORD)HRESULT
 */
DWORD CALLBACK MyRead(DWORD_PTR hfile, BYTE *pbBuffer, long cb, long *pcb)
{
	if(!hfile)								// No handle defined
		return (DWORD)E_FAIL;

	Assert(pcb);
	*pcb = 0;

	if(!ReadFile((HANDLE)hfile, (void *)pbBuffer, (DWORD)cb, (DWORD *)pcb, NULL))
		return HRESULT_FROM_WIN32(GetLastError());

	return (DWORD)NOERROR;
}

/*
 *	MyWrite(hfile, pbBuffer, cb, pcb)
 *
 *	@func
 *		Callback function for converting a file into an editstream for
 *		output.
 *
 *	@rdesc
 *		(DWORD)HRESULT
 */
DWORD CALLBACK MyWrite(DWORD_PTR hfile, BYTE *pbBuffer, long cb, long *pcb)
{
	if(!hfile)								// No handle defined
		return (DWORD)E_FAIL;

	Assert(pcb);
	*pcb = 0;

	if(!WriteFile((HANDLE)hfile, (void *)pbBuffer, (DWORD)cb, (DWORD *)pcb, NULL))
		return HRESULT_FROM_WIN32(GetLastError());

	return (DWORD)(*pcb ? NOERROR : E_FAIL);
}


//-----------------CTxtEdit IUnknown methods: see textserv.cpp -----------------------------


//------------------------ CTxtEdit IDispatch methods -------------------------

/*
 *	CTxtEdit::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT = (pcTypeInfo) ? NOERROR : E_INVALIDARG;
 */
STDMETHODIMP CTxtEdit::GetTypeInfoCount(
	UINT *pcTypeInfo)	//@parm Out parm to receive count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtEdit::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextDocument interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtEdit::GetTypeInfo(
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
 {
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoDoc, ppTypeInfo);
}

/*
 *	CTxtEdit::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for all TOM methods and properties
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		This routine tries to find DISPIDs using the type information for
 *		ITextDocument. If that fails, it asks the selection to find the
 *		DISPIDs.
 */
STDMETHODIMP CTxtEdit::GetIDsOfNames(
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	hr = g_pTypeInfoDoc->GetIDsOfNames(rgszNames, cNames, rgdispid);

	if(hr == NOERROR)							// Succeeded in finding an
		return NOERROR;							//  ITextDocument method

	IDispatch *pSel = (IDispatch *)GetSel();	// See if the selection knows
												//  the desired method
	if(!pSel)
		return hr;								// No selection

	return pSel->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
}

/*
 *	CTxtEdit::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke members for all TOM DISPIDs, i.e., for ITextDocument,
 *		ITextSelection, ITextRange, ITextFont, and ITextPara.  TOM DISPIDs
 *		for all but ITextDocument are delegated to the selection object.
 *
 *	@rdesc
 *		HRESULT
 *
 *	@devnote
 *		This routine trys to invoke ITextDocument members if the DISPID is
 *		in the range 0 thru 0xff.  It trys to invoke ITextSelection members if
 *		the DISPID is in the range 0x100 thru 0x4ff (this includes
 *		ITextSelection, ITextRange, ITextFont, and ITextPara).  It returns
 *		E_MEMBERNOTFOUND for DISPIDs outside these ranges.
 */
STDMETHODIMP CTxtEdit::Invoke(
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Invoke");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	if((DWORD)dispidMember < 0x100)				// ITextDocment method
		return g_pTypeInfoDoc->Invoke((IDispatch *)this, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);

	IDispatch *pSel = (IDispatch *)GetSel();	// See if the selection has
												//  the desired method
	if(pSel && (DWORD)dispidMember <= 0x4ff)
		return pSel->Invoke(dispidMember, riid, lcid, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);

	return DISP_E_MEMBERNOTFOUND;
}


//--------------------- ITextDocument Methods/Properties -----------------------

/*
 *	ITextDocument::BeginEditCollection()
 *
 *	@mfunc
 *		Method that turns on undo grouping
 *
 *	@rdesc
 *		HRESULT = (undo enabled) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::BeginEditCollection ()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::BeginEditCollection");

	return E_NOTIMPL;
}

/*
 *	ITextDocument::EndEditCollection() 
 *
 *	@mfunc
 *		Method that turns off undo grouping
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::EndEditCollection () 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::EndEditCollection");

	return E_NOTIMPL;
}

/*
 *	ITextDocument::Freeze(long *pValue) 
 *
 *	@mfunc
 *		Method to increment the freeze count. If this count is nonzero,
 *		screen updating is disabled.  This allows a sequence of editing
 *		operations to be performed without the performance loss and
 *		flicker of screen updating.  See Unfreeze() to decrement the
 *		freeze count.
 *
 *	@rdesc
 *		HRESULT = (screen updating disabled) ? NOERROR : S_FALSE
 *
 *	@todo
 *		What about APIs like EM_LINEFROMCHAR that don't yet know how to
 *		react to a frozen display?
 */
STDMETHODIMP CTxtEdit::Freeze (
	long *pCount)		//@parm Out parm to receive updated freeze count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Freeze");

	if(_pdp)
	{
		_pdp->Freeze();
		if(_pdp->IsFrozen())
			_cFreeze++;
		else
			_cFreeze = 0;
	}

	if(pCount)
		*pCount = _cFreeze;

	return _cFreeze ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument::GetDefaultTabStop (pValue) 
 *
 *	@mfunc
 *		Property get method that gets the default tab stop to be
 *		used whenever the explicit tabs don't extend far enough.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtEdit::GetDefaultTabStop (
	float *	pValue)		//@parm Out parm to receive default tab stop
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDefaultTabStop");

	if(!pValue)
		return E_INVALIDARG;
                                                                        
	const LONG lTab = GetDefaultTab();

	*pValue = TWIPS_TO_FPPTS(lTab);

	return NOERROR;
}

/*
 *	CTxtEdit::GetName (pName)
 *
 *	@mfunc
 *		Retrieve ITextDocument filename
 *
 *	@rdesc
 *		HRESULT = (!<p pName>) ? E_INVALIDARG :
 *				  (no name) ? S_FALSE :
 *				  (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
STDMETHODIMP CTxtEdit::GetName (
	BSTR * pName)		//@parm Out parm to receive filename
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetName");

	if(!pName)
		return E_INVALIDARG;

	*pName = NULL;
	if(!_pDocInfo || !_pDocInfo->pName)
		return S_FALSE;

	*pName = SysAllocString(_pDocInfo->pName);
	
	return *pName ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	ITextDocument::GetSaved (pValue) 
 *
 *	@mfunc
 *		Property get method that gets whether this instance has been
 *		saved, i.e., no changes since last save
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 *
 *	@comm
 *		Next time to aid C/C++ clients, we ought to make pValue optional
 *		and return S_FALSE if doc isn't saved, i.e., like our other
 *		boolean properties (see, e.g., ITextRange::IsEqual())
 */
STDMETHODIMP CTxtEdit::GetSaved (
	long *	pValue)		//@parm Out parm to receive Saved property
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetSaved");

	if(!pValue)
		return E_INVALIDARG;

	*pValue = _fSaved ? tomTrue : tomFalse;
	return NOERROR;
}

/*
 *	ITextDocument::GetSelection (ITextSelection **ppSel) 
 *
 *	@mfunc
 *		Property get method that gets the active selection. 
 *
 *	@rdesc
 *		HRESULT = (!ppSel) ? E_INVALIDARG :
 *				  (if active selection exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::GetSelection (
	ITextSelection **ppSel)	//@parm Out parm to receive selection pointer
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetSelection");

	if(!ppSel)
		return E_INVALIDARG;

	CTxtSelection *psel = GetSel();

	*ppSel = (ITextSelection *)psel;

	if( psel )
	{
		(*ppSel)->AddRef();
		return NOERROR;
	}

	return S_FALSE;
}

/*
 *	CTxtEdit::GetStoryCount(pCount)
 *
 *	@mfunc
 *		Get count of stories in this document.
 *
 *	@rdesc
 *		HRESULT = (!<p pCount>) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtEdit::GetStoryCount (
	LONG *pCount)		//@parm Out parm to receive count of stories
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetStoryCount");

	if(!pCount)
		return E_INVALIDARG;

	*pCount = 1;
	return NOERROR;
}

/*
 *	ITextDocument::GetStoryRanges(ITextStoryRanges **ppStories) 
 *
 *	@mfunc
 *		Property get method that gets the story collection object
 *		used to enumerate the stories in a document.  Only invoke this
 *		method if GetStoryCount() returns a value greater than one.
 *
 *	@rdesc
 *		HRESULT = (if Stories collection exists) ? NOERROR : E_NOTIMPL
 */
STDMETHODIMP CTxtEdit::GetStoryRanges (
	ITextStoryRanges **ppStories) 	//@parm Out parm to receive stories ptr
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetStoryRanges");

	return E_NOTIMPL;
}

/*
 *	ITextDocument::New() 
 *
 *	@mfunc
 *		Method that closes the current document and opens a document
 *		with a default name.  If changes have been made in the current
 *		document since the last save and document file information exists,
 *		the current document is saved.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::New ()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::New");

	CloseFile(TRUE);	 					// Save and close file
	return SetText(NULL, 0, 1200);
}

/*
 *	ITextDocument::Open(pVar, Flags, CodePage)
 *
 *	@mfunc
 *		Method that opens the document specified by pVar.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_OUTOFMEMORY
 *
 *	@future
 *		Handle IStream
 */
STDMETHODIMP CTxtEdit::Open (
	VARIANT *	pVar,		//@parm Filename or IStream
	long		Flags,		//@parm Read/write, create, and share flags
	long		CodePage)	//@parm Code page to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Open");

	LONG		cb;								// Byte count for RTF check
	EDITSTREAM	es		= {0, NOERROR, MyRead};
	BOOL		fReplaceSel = Flags & tomPasteFile;
	HCURSOR		hcur;
	LRESULT		lres;
	TCHAR		szType[10];

	if(!pVar || CodePage && CodePage != 1200 && !IsValidCodePage(CodePage))
		return E_INVALIDARG;					// IsValidCodePage(0) fails
												//  even tho CP_ACP = 0 (!)
	if((Flags & 0xf) >= tomHTML)				// RichEdit only handles auto,
		return E_NOTIMPL;						//  plain text, & RTF formats

	if(!fReplaceSel)							// If not replacing selection,
		New();									//  save current file and
												//  delete current text
	CDocInfo * pDocInfo = GetDocInfo();
	if(!pDocInfo)
		return E_OUTOFMEMORY;

	pDocInfo->wFlags = (WORD)(Flags & ~0xf0);	// Save flags (w/o creation)

	// Process access, share, and create flags
	DWORD dwAccess = (Flags & tomReadOnly)
		? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE);

	DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
	if(Flags & tomShareDenyRead)
		dwShare &= ~FILE_SHARE_READ;

	if(Flags & tomShareDenyWrite)
		dwShare &= ~FILE_SHARE_WRITE;

	DWORD dwCreate = (Flags >> 4) & 0xf;
	if(!dwCreate)								// Flags nibble 2 must contain
		dwCreate = OPEN_ALWAYS;					//  CreateFile's dwCreate

	if(pVar->vt == VT_BSTR && SysStringLen(pVar->bstrVal))
	{
		es.dwCookie = (DWORD_PTR)CreateFile(pVar->bstrVal, dwAccess, dwShare,
							 NULL, dwCreate, FILE_ATTRIBUTE_NORMAL, NULL);
		if((HANDLE)es.dwCookie == INVALID_HANDLE_VALUE)
			return HRESULT_FROM_WIN32(GetLastError());

		if(!fReplaceSel)						// If not replacing selection,
		{										//  allocate new pName
			pDocInfo->pName = SysAllocString(pVar->bstrVal);
			if (!pDocInfo->pName)
				return E_OUTOFMEMORY;
			pDocInfo->hFile = (HANDLE)es.dwCookie;
			pDocInfo->wFlags |= tomTruncateExisting;	// Setup Saves
		}
	}
	else
	{
		// FUTURE: check for IStream; if not, then fail
		return E_INVALIDARG;
	}

	Flags &= 0xf;								// Isolate conversion flags

	// Get first few bytes of file to check for RTF and Unicode BOM
	(*es.pfnCallback)(es.dwCookie, (LPBYTE)szType, 10, &cb);

	Flags = (!Flags || Flags == tomRTF) && IsRTF((char *)szType)
		  ? tomRTF : tomText;

	LONG j = 0;									// Default rewind to 0
	if (Flags == tomRTF)						// RTF
		Flags = SF_RTF;							// Setup EM_STREAMIN for RTF
	else
	{											// If it starts with
		Flags = SF_TEXT;						// Setup EM_STREAMIN for text
		if(cb > 1 && *(WORD *)szType == BOM)	//  Unicode byte-order mark
		{										//  (BOM) file is Unicode, so
			Flags = SF_TEXT | SF_UNICODE;		//  use Unicode code page and
			j = 2;								//  bypass the BOM. FUTURE:
		}										//  handle big endian too
		else if(cb > 2 && W32->IsUTF8BOM((BYTE *)szType))
		{
			Flags = SF_TEXT | SF_USECODEPAGE | (CP_UTF8 << 16);
			j = 3;
		}
		else if(CodePage == 1200)
			Flags = SF_TEXT | SF_UNICODE;

		else if(CodePage)
			Flags = SF_TEXT | SF_USECODEPAGE | (CodePage << 16);
	}

	SetFilePointer((HANDLE)es.dwCookie, j, NULL, FILE_BEGIN);	// Rewind

	if(fReplaceSel)
		Flags |= SFF_SELECTION;

	Flags |= SFF_KEEPDOCINFO;

	hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
	TxSendMessage(EM_STREAMIN, Flags, (LPARAM)&es, &lres);
	SetCursor(hcur);

	if(dwShare == (FILE_SHARE_READ | FILE_SHARE_WRITE) || fReplaceSel)
	{											// Full sharing or replaced
		CloseHandle((HANDLE)es.dwCookie);		//  selection, so close file
		if(!fReplaceSel)						// If replacing selection,
			pDocInfo->hFile = NULL;				//  leave _pDocInfo->hFile
	}
	_fSaved = fReplaceSel ? FALSE : TRUE;		// No changes yet unless
	return (HRESULT)es.dwError;
}

/*
 *	ITextDocument::Range(long cpFirst, long cpLim, ITextRange **ppRange)  
 *
 *	@mfunc
 *		Method that gets a text range on the active story of the document
 *
 *	@rdesc
 *		HRESULT = (!ppRange) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtEdit::Range (
	long cpFirst, 				//@parm	Non active end of new range
	long cpLim, 				//@parm Active end of new range
	ITextRange ** ppRange)		//@parm Out parm to receive range
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Range");

	if(!ppRange)
		return E_INVALIDARG;

	*ppRange = new CTxtRange(this, cpFirst, cpFirst - cpLim);
	
	if( *ppRange )
	{
		(*ppRange)->AddRef();		// CTxtRange() doesn't AddRef() because
		return NOERROR;				//  it's used internally for things
	}								//  besides TOM

	return E_OUTOFMEMORY;
}

/*
 *	ITextDocument::RangeFromPoint(long x, long y, ITextRange **ppRange) 
 *
 *	@mfunc
 *		Method that gets the degenerate range corresponding (at or nearest)
 *		to the point with the screen coordinates x and y.
 *
 *	@rdesc
 *		HRESULT = (!ppRange) ? E_INVALIDARG :
 *				  (if out of RAM) ? E_OUTOFMEMORY :
 *				  (if range exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::RangeFromPoint (
	long	x,				//@parm Horizontal coord of point to use
	long	y,				//@parm	Vertical   coord of point to use
	ITextRange **ppRange)	//@parm Out parm to receive range
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::RangeFromPoint");

	if(!ppRange)
		return E_INVALIDARG;

	*ppRange = (ITextRange *) new CTxtRange(this, 0, 0);

	if(!*ppRange)
		return E_OUTOFMEMORY;

	(*ppRange)->AddRef();				// CTxtRange() doesn't AddRef()
	return (*ppRange)->SetPoint(x, y, 0, 0);
}

/*
 *	ITextDocument::Redo(long Count, long *pCount) 
 *
 *	@mfunc
 *		Method to perform the redo operation Count times
 *
 *	@rdesc
 *		HRESULT = (if Count redos performed) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::Redo (
	long	Count,		//@parm Number of redo operations to perform
	long *	pCount)		//@parm Number of redo operations performed
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Redo");
	CCallMgr	callmgr(this);

	LONG i = 0;


	if (_predo && _fUseUndo)
	{
		// Freeze the display during the execution of the anti-events
		CFreezeDisplay fd(_pdp);

		for ( ; i < Count; i++)
			PopAndExecuteAntiEvent(_predo, 0);
	}

	if(pCount)
		*pCount = i;

	return i == Count ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument::Save(pVar, Flags, CodePage) 
 *
 *	@mfunc
 *		Method that saves this ITextDocument to the target pVar,
 *		which is a VARIANT that can be a filename, an IStream, or NULL.  If
 *		NULL, the filename given by this document's name is used.  It that,
 *		in turn, is NULL, the method fails.  If pVar specifies a filename,
 *		that name should replace the current Name property.
 *
 *	@rdesc
 *		HRESULT = (!pVar) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : E_FAIL
 *
 *	@devnote
 *		This routine can be called with NULL arguments
 */
STDMETHODIMP CTxtEdit::Save (
	VARIANT *	pVar,		//@parm Save target (filename or IStream)
	long		Flags,		//@parm Read/write, create, and share flags
	long		CodePage)	//@parm Code page to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Save");

	LONG		cb;			// Byte count for writing Unicode BOM
	EDITSTREAM	es		= {0, NOERROR, MyWrite};
	BOOL		fChange	= FALSE;				// No doc info change yet
	HCURSOR		hcur;
	CDocInfo *	pDocInfo = GetDocInfo();
	WORD		wBOM = BOM;

	if(CodePage && CodePage != 1200 && !IsValidCodePage(CodePage) ||
	   (DWORD)Flags > 0x1fff || Flags & tomReadOnly)
	{
		return E_INVALIDARG;
	}
	if((Flags & 0xf) >= tomHTML)				// RichEdit only handles auto,
		return E_NOTIMPL;						//  plain text, & RTF formats

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	if (pVar && pVar->vt == VT_BSTR &&			// Filename string
		pVar->bstrVal &&
		SysStringLen(pVar->bstrVal) &&			// NonNULL filename specified
		(!pDocInfo->pName ||
		 OLEstrcmp(pVar->bstrVal, pDocInfo->pName)))
	{											// Filename differs
		fChange = TRUE;							// Force write to new file
		CloseFile(FALSE);						// Close current file; no save
		pDocInfo->pName = SysAllocString(pVar->bstrVal);
		if(!pDocInfo->pName)
			return E_OUTOFMEMORY;
		pDocInfo->wFlags &= ~0xf0;				// Kill previous create mode
	}

	DWORD flags = pDocInfo->wFlags;
	if(!(Flags & 0xF))							// If convert flags are 0,									
		Flags |= flags & 0xF;					//  use values in doc info
	if(!(Flags & 0xF0))							// If create flags are 0,									
		Flags |= flags & 0xF0;					//  use values in doc info
	if(!(Flags & 0xF00))						// If share flags are 0,									
		Flags |= flags & 0xF00;					//  use values in doc info
	if(!CodePage)								// If code page is 0,
		CodePage = pDocInfo->wCpg;				//  use code page in doc info

	if((DWORD)Flags != flags ||					// If flags or code page	
	   (WORD)CodePage != pDocInfo->wCpg)		//  changed, force write
	{
		fChange = TRUE;
	}
	pDocInfo->wFlags = (WORD)Flags;				// Save flags

	// Yikes, nowhere to save.  bail-out now
	if(!_pDocInfo->pName)
		return E_FAIL;

	if(_fSaved && !fChange)						// No changes, so assume
		return NOERROR;							//  saved file is up to date

	DWORD dwShare = FILE_SHARE_READ | FILE_SHARE_WRITE;
	if(Flags & tomShareDenyRead)
		dwShare &= ~FILE_SHARE_READ;

	if(Flags & tomShareDenyWrite)
		dwShare &= ~FILE_SHARE_WRITE;

	DWORD dwCreate = (Flags >> 4) & 0xF;
	if(!dwCreate)
		dwCreate = CREATE_NEW;

	if(pDocInfo->hFile)
	{
		CloseHandle(pDocInfo->hFile);			// Close current file handle
		pDocInfo->hFile = NULL;
	}

	es.dwCookie = (DWORD_PTR)CreateFile(pDocInfo->pName, GENERIC_READ | GENERIC_WRITE, dwShare, NULL,
							dwCreate, FILE_ATTRIBUTE_NORMAL, NULL);
	if((HANDLE)es.dwCookie == INVALID_HANDLE_VALUE)
		return HRESULT_FROM_WIN32(GetLastError());

	pDocInfo->hFile = (HANDLE)es.dwCookie;

	Flags &= 0xF;								// Isolate conversion flags
	if(Flags == tomRTF)							// RTF
		Flags = SF_RTF;							// Setup EM_STREAMOUT for RTF
	else
	{											
		Flags = SF_TEXT;						// Setup EM_STREAMOUT for text
		if(CodePage == 1200 || CodePage == CP_UTF8)// If Unicode, start file with
		{										//  Unicode byte order mark
			LONG  j;
			BYTE *pb;							// FUTURE: generalize to handle
												//  big endian
			if(CodePage == CP_UTF8)
			{
				j = 3;
				pb = szUTF8BOM;
			}
			else
			{
				Flags = SF_TEXT | SF_UNICODE;
				j = 2;
				pb = (BYTE *)&wBOM;
			}
			(*es.pfnCallback)(es.dwCookie, pb, j, &cb);
		}
	}
	if(CodePage && CodePage != 1200)
		Flags |= SF_USECODEPAGE | (CodePage << 16);

	hcur = SetCursor(LoadCursor(NULL, IDC_WAIT));
	TxSendMessage(EM_STREAMOUT, Flags, (LPARAM)&es, NULL);
	SetCursor(hcur);

	if(dwShare == (FILE_SHARE_READ | FILE_SHARE_WRITE))
	{											// Full sharing, so close
		CloseHandle(pDocInfo->hFile);			//  current file handle
		pDocInfo->hFile = NULL;
	}
	_fSaved = TRUE;								// File is saved
	return (HRESULT)es.dwError;
}

/*
 *	ITextDocument::SetDefaultTabStop (Value) 
 *
 *	@mfunc
 *		Property set method that sets the default tab stop to be
 *		used whenever the explicit tabs don't extend far enough.
 *
 *	@rdesc
 *		HRESULT = (Value < 0) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtEdit::SetDefaultTabStop (
	float Value)		//@parm Out parm to receive default tab stop
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDefaultTabStop");

	if(Value <= 0)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->dwDefaultTabStop = FPPTS_TO_TWIPS(Value);
	return NOERROR;
}

/*
 *	ITextDocument::SetSaved (Value) 
 *
 *	@mfunc
 *		Property set method that sets whether this instance has been
 *		saved, i.e., no changes since last save
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::SetSaved (
	long	Value)		//@parm New value of Saved property
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetSaved");

	_fSaved = Value ? TRUE : FALSE;
	return NOERROR;
}

/*
 *	ITextDocument::Undo(Count, *pCount) 
 *
 *	@mfunc
 *		Method to perform the undo operation Count times or to control
 *		the nature of undo processing. Count = 0 stops undo processing
 *		and discards any saved undo states.  Count = -1 turns on undo
 *		processing with the default undo limit.  Count = tomSuspend
 *		suspends undo processing, but doesn't discard saved undo states,
 *		and Count = tomResume resumes undo processing with the undo states
 *		active when Count = tomSuspend was given.
 *
 *	@rdesc
 *		HRESULT = (if Count undos performed) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::Undo (
	long	Count,		//@parm Count of undo operations to perform
						//		0 stops undo processing
						//		-1 turns restores it
	long *	pCount)		//@parm Number of undo operations performed
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Undo");
	CCallMgr callmgr(this);

	LONG i = 0;

	if(_pundo && _fUseUndo)
	{
		// Freeze display during execution of anti-events
		CFreezeDisplay fd(_pdp);

		for ( ; i < Count; i++)					// Note: for Count <= 0,
			PopAndExecuteAntiEvent(_pundo, 0);	//  loop does nothing
	}

	if(pCount)
		*pCount = i;

	if(Count <= 0)							
		i = HandleSetUndoLimit(Count);

	return i == Count ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument::Unfreeze(pCount) 
 *
 *	@mfunc
 *		Method to decrement freeze count.  If this count goes to zero,
 *		screen updating is enabled.  This method cannot decrement the
 *		count below zero.
 *
 *	@rdesc
 *		HRESULT = (screen updating enabled) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		The display maintains its own private reference count which may
 *		temporarily exceed the reference count of this method.  So even
 *		if this method indicates that the display is unfrozen, it may be
 *		for a while longer.
 */
STDMETHODIMP CTxtEdit::Unfreeze (
	long *pCount)		//@parm Out parm to receive updated freeze count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Unfreeze");

	if(_cFreeze)
	{
		AssertSz(_pdp && _pdp->IsFrozen(),
			"CTxtEdit::Unfreeze: screen not frozen but expected to be");
		_cFreeze--;
		_pdp->Thaw();
	}

	if(pCount)
		*pCount = _cFreeze;

	return _cFreeze ? S_FALSE : NOERROR;
}

//----------------------- ITextDocument2 Methods -----------------------
/*
 *	ITextDocument2::AttachMsgFilter(pFilter) 
 *
 *	@mfunc
 *		Method to attach a new message filter to the edit instance.
 *      All window messages received by the edit instance will be forwarded
 *      to the message filter.  The message filter must be bound to the document
 *		before it can be used (Refer to the ITextMessageFilter API).
 *
 *	@rdesc
 *		HRESULT = filter succesfully attached ? NOERROR : QI failure.
 */
STDMETHODIMP CTxtEdit::AttachMsgFilter (
	IUnknown *pFilter)		//@parm the IUnknown for the new message filter
{
	ITextMsgFilter *pMsgFilter = NULL;

	HRESULT hr = pFilter->QueryInterface(IID_ITextMsgFilter, (void **)&pMsgFilter);
	if (SUCCEEDED(hr))
	{
		if (_pMsgFilter)
			_pMsgFilter->AttachMsgFilter(pMsgFilter);
		else
			_pMsgFilter = pMsgFilter;
	}
	return hr;
}

/*
 *	ITextDocument2::GetEffectColor(Index, pcr)
 *
 *	@mfunc
 *		Method to retrieve the COLORREF color used in special attribute
 *		displays.  The first 15 values are for special underline colors 1 - 15.
 *      Later we may define indices for other effects, e.g., URLs, strikeout.
 *		If an index between 1 and 15 hasn't been defined by an appropriate
 *		call to ITextDocument2:SetEffectColor(), the corresponding WORD
 *		default color value given by g_Colors[] is returned.
 *
 *	@rdesc
 *		HRESULT = (valid active color index)
 *				? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetEffectColor(
	long	  Index,		//@parm Which special color to get
	COLORREF *pcr)			//@parm Out parm for color
{
	if(!pcr)
		return E_INVALIDARG;

	if(!IN_RANGE(1, Index, 15))
	{
		*pcr = (COLORREF)tomUndefined;
		return E_INVALIDARG;
	}

	*pcr = g_Colors[Index];

	CDocInfo *pDoc = GetDocInfo();
	if(!pDoc)
		return E_OUTOFMEMORY;
	
	Index--;
	if (Index < pDoc->cColor &&
		pDoc->prgColor[Index] != (COLORREF)tomUndefined)
	{
		*pcr = pDoc->prgColor[Index];
	}
	return NOERROR;
}

/*
 *	ITextDocument2::SetEffectColor(Index, cr) 
 *
 *	@mfunc
 *		Method to save the Index'th special document color.  Indices
 *      1 - 15 are defined for underlining.  Later we may define
 *		indices for other effects, e.g., URLs, strikeout.
 *
 *	@rdesc
 *		HRESULT = (valid index)
 *				? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::SetEffectColor(
	long	 Index,			//@parm Which special color to set
	COLORREF cr)			//@parm Color to use
{
	CDocInfo *pDoc = GetDocInfo();
	if(!pDoc)
		return E_OUTOFMEMORY;

	Index--;
	if(!IN_RANGE(0, Index, 14))
		return E_INVALIDARG;

	if(Index >= pDoc->cColor)
	{
		LONG	  cColor   = (Index + 4) & ~3;		// Round up to 4
		COLORREF *prgColor = (COLORREF *)PvReAlloc(pDoc->prgColor,
												  cColor*sizeof(COLORREF));
		if(!prgColor)
			return E_OUTOFMEMORY;

		for(LONG i = pDoc->cColor; i < cColor; i++)
			prgColor[i] = (COLORREF)tomUndefined;

		pDoc->cColor   = (char)cColor;
		pDoc->prgColor = prgColor;
	}
	pDoc->prgColor[Index] = cr;	
	return NOERROR;
}

/*
 *	ITextDocument2::SetCaretType(CaretType) 
 *
 *	@mfunc
 *		Method to sllow programmatic control over the caret type.
 *      The form of the control is TBD as is its interaction with
 *      existing formatting (e.g. font size and italics).
 *
 *	@rdesc
 *		HRESULT = caret type is one we understand ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::SetCaretType(
	long CaretType)		//@parm specification of caret type to use
{
	// For now, just care about Korean block craet.
	if (CaretType == tomKoreanBlockCaret)
		_fKoreanBlockCaret = TRUE;
	else if (CaretType == tomNormalCaret)
		_fKoreanBlockCaret = FALSE;
	else
		return E_INVALIDARG;

	if (_psel && _psel->IsCaretShown() && _fFocus)
	{
		_psel->CreateCaret();
		TxShowCaret(TRUE);
	}
	return NOERROR;
}

/*
 *	ITextDocument2::GetCaretType(pCaretType)
 *
 *	@mfunc
 *		Method to retrieve the previously set caret type.
 *      TBD.  Can one get it without setting it?
 *
 *	@rdesc
 *		HRESULT = caret info OK ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetCaretType(
	long *pCaretType)		//@parm current caret type specification
{
	if (!pCaretType)
		return E_INVALIDARG;

	*pCaretType = _fKoreanBlockCaret ? tomKoreanBlockCaret : tomNormalCaret;
	return NOERROR;
}

/*
 *	ITextDocument2::GetImmContext(pContext) 
 *
 *	@mfunc
 *		Method to retrieve the IMM context from our host.
 *
 *	@rdesc
 *		HRESULT = ImmContext available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetImmContext(
	long *pContext)		//@parm Imm context
{
	if (!pContext)
		return E_INVALIDARG;

	*pContext = 0;

	if (!_fInOurHost)
	{
		// ask host for Imm Context
		HIMC hIMC = TxImmGetContext();
		
		*pContext = (long) hIMC;			
	}
	
	return *pContext ? NOERROR : S_FALSE;
}

/*
 *	ITextDocument2::ReleaseImmContext(Context) 
 *
 *	@mfunc
 *		Method to release the IMM context.
 *
 *	@rdesc
 *		HRESULT = ImmContext available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::ReleaseImmContext(
	long Context)		//@parm Imm context to be release
{
	if (!_fInOurHost)
	{
		// ask host to release Imm Context
		TxImmReleaseContext((HIMC)Context);
		
		return NOERROR;			
	}
	
	return S_FALSE;
}

/*
 *	ITextDocument2::GetPreferredFont(cp, lCodePage, lOption, lCurCodePage, lCurFontSize,
 *		,pFontName, pPitchAndFamily, pNewFontSize) 
 *
 *	@mfunc
 *		Method to retrieve the preferred font name and pitch and family at a 
 *		given cp and codepage.
 *
 *	@rdesc
 *		HRESULT = FontName available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetPreferredFont(
	long cp,				//@parm cp
	long lCodepage,			//@parm codepage preferred
	long lOption,			//@parm option for matching current font
	long lCurCodePage,		//@parm current codepage
	long lCurFontSize,		//@parm current font size
	BSTR *pFontName,		//@parm preferred fontname
	long *pPitchAndFamily,	//@parm pitch and family 
	long *plNewFontSize)	//@parm new font size preferred 
{
	if (!pFontName || !IN_RANGE(IGNORE_CURRENT_FONT, lOption, MATCH_FONT_SIG))
		return E_INVALIDARG;

	if (!IsAutoFont())		// EXIT if auto font is turned off
		return S_FALSE;

	CRchTxtPtr	rtp(this, 0);
	CCFRunPtr	rp(rtp);
	short		iFont;
	short		yHeight;
	BYTE		bPitchAndFamily;
	BYTE		bCharset = ANSI_CHARSET;

	rp.AdvanceCp(cp);
	if (rp.GetPreferredFontInfo(
			lCodepage,
			bCharset,
			iFont,
			yHeight,
			bPitchAndFamily,
			-1,
			lOption))
	{
		if (*pFontName)
			wcscpy(*pFontName, GetFontName((LONG)iFont));
		else
		{
			*pFontName = SysAllocString(GetFontName((LONG)iFont));
			if (!*pFontName)
				return E_OUTOFMEMORY;
		}

		if (pPitchAndFamily)
			*pPitchAndFamily = bPitchAndFamily;

		// Calc the new font size if needed
		if (plNewFontSize)
		{
			*plNewFontSize = lCurFontSize;
			if (_fAutoFontSizeAdjust && lCodepage != lCurCodePage)
				*plNewFontSize = yHeight / TWIPS_PER_POINT;			// Set the preferred size
		}

		return S_OK;
	}

	return E_FAIL;
}

/*
 *	ITextDocument2::GetNotificationMode( long *plMode ) 
 *
 *	@mfunc
 *		Method to retrieve the current notification mode.
 *
 *	@rdesc
 *		HRESULT = notification mode available ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetNotificationMode(
	long *plMode)		//@parm current notification mode
{
	if (!plMode)
		return E_INVALIDARG;

	*plMode = _fSuppressNotify ? tomFalse : tomTrue;

	return NOERROR;
}

/*
 *	ITextDocument2::SetNotificationMode(lMode) 
 *
 *	@mfunc
 *		Method to set the current notification mode.
 *
 *	@rdesc
 *		HRESULT = notification mode set ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::SetNotificationMode(
	long lMode)		//@parm new notification mode
{
	if (lMode == tomFalse)
		_fSuppressNotify = 1;
	else if  (lMode == tomTrue)
		_fSuppressNotify = 0;
	else
		return E_INVALIDARG;

	return NOERROR;
}

/*
 *	ITextDocument2::GetClientRect(Type, pLeft, pTop,pRight, pBottom ) 
 *
 *	@mfunc
 *		Method to retrieve the client rect and inset adjustment.
 *
 *	@rdesc
 *		HRESULT = notification mode set ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtEdit::GetClientRect(
	long Type,				//@parm option
	long *pLeft,			//@parm left
	long *pTop,				//@parm top
	long *pRight,			//@parm right
	long *pBottom)			//@parm bottom
{
	if (!pLeft || !pTop || !pRight || !pBottom)
		return E_INVALIDARG;
	
	RECT rcArea;
	TxGetClientRect(&rcArea); 
	
	if ( Type & tomIncludeInset )
	{
		// Ajdust veiw inset
		RECT rcInset;
		TxGetViewInset( &rcInset, NULL );
		rcArea.right 	-= rcInset.right;
		rcArea.bottom 	-= rcInset.bottom;
		rcArea.left 	+= rcInset.left;
		rcArea.top 		+= rcInset.top;
	}

	// Caller wants screen coordinates?
	if ( !(Type & tomClientCoord) )
	{
		POINT	ptTopLeft = {rcArea.left, rcArea.top};
		POINT	ptBottomRight = {rcArea.right, rcArea.bottom};

		if (!TxClientToScreen(&ptTopLeft) ||
			!TxClientToScreen(&ptBottomRight))
			return E_FAIL;			// It is unexpected for this to happen

		*pLeft		= ptTopLeft.x;
		*pTop		= ptTopLeft.y;
		*pRight		= ptBottomRight.x;
		*pBottom	= ptBottomRight.y;
	}
	else
	{
		*pLeft		= rcArea.left;
		*pTop		= rcArea.top;
		*pRight		= rcArea.right;
		*pBottom	= rcArea.bottom;
	}

	return NOERROR;
}

/*
 *	ITextDocument2::GetSelectionEx(ppSel) 
 *
 *	@mfunc
 *		Method to retrieve selection.
 *
 *	@rdesc
 *		HRESULT = selection ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtEdit::GetSelectionEx(
	ITextSelection **ppSel)			//@parm  Get Selection object
{	
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetSelectionEx");

	if (_fInPlaceActive)
		return GetSelection (ppSel);

	Assert("Getting selection while not active");

	if(!ppSel)
		return E_INVALIDARG;

	*ppSel = NULL;
	return S_FALSE;
}

/*
 *	ITextDocument2::GetWindow(phWnd) 
 *
 *	@mfunc
 *		Method to get the host window
 *
 *	@rdesc
 *		HRESULT = NOERROR if host return hWnd
 */
STDMETHODIMP CTxtEdit::GetWindow(
	long *phWnd)				//@parm hWnd
{
	if (!phWnd)
		return E_INVALIDARG;

	return TxGetWindow((HWND *)phWnd);
}

/*
 *	ITextDocument2::GetFEFlags(pFEFlags) 
 *
 *	@mfunc
 *		Method to get Host FE flags
 *
 *	@rdesc
 *		HRESULT = NOERROR if host returns FE Flags
 */
STDMETHODIMP CTxtEdit::GetFEFlags(
	long *pFEFlags)			//@parm FE Flags
{
	return TxGetFEFlags(pFEFlags);
}

/*
 *	ITextDocument2::UpdateWindow(void) 
 *
 *	@mfunc
 *		Method to update the RE window
 *
 *	@rdesc
 *		HRESULT = NOERROR 
 */
STDMETHODIMP CTxtEdit::UpdateWindow(void)
{
	TxUpdateWindow();
	return NOERROR;
}

/*
 *	ITextDocument2::CheckTextLimit(long cch, long *pcch) 
 *
 *	@mfunc
 *		Method to check if the count of characters to be added would
 *		exceed max. text limit.  If number of characters exced is return
 *		in pcch
 *
 *	@rdesc
 *		HRESULT = NOERROR 
 */
STDMETHODIMP CTxtEdit::CheckTextLimit(
	long cch,			//@parm count of characters to be added			
	long *pcch)			//@parm return the number of characters exced text limit
{
	if(!pcch)
		return E_INVALIDARG;

	if (_psel)
	{
		*pcch = 0;
		_psel->CheckTextLength(cch, pcch);
		return NOERROR;
	}
	
	return S_FALSE; 
}

/*
 *	ITextDocument2::IMEInProgress(lMode) 
 *
 *	@mfunc
 *		Method for IME message filter to inform client that IME composition
 *		is in progress.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::IMEInProgress(
	long lMode)		//@parm current IME composition status
{
	if (lMode == tomFalse)
		_fIMEInProgress = 0;
	else if  (lMode == tomTrue)
		_fIMEInProgress = 1;

	return NOERROR;
}

/*
 *	ITextDocument2::SysBeep(void) 
 *
 *	@mfunc
 *		Method to generate system beep.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::SysBeep(void)
{	
	Beep();
	return NOERROR;
}

/*
 *	ITextDocument2::Update(lMode) 
 *
 *	@mfunc
 *		Method for update the selection or caret.  If lMode is tomTrue, then
 *		scroll the caret into view.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::Update(
	long lMode)		//@parm current IME composition status
{
	if (!_psel)
		return S_FALSE;

	_psel->Update(lMode == tomTrue ? TRUE : FALSE);

	return NOERROR;
}

/*
 *	ITextDocument2::Notify(lNotify) 
 *
 *	@mfunc
 *		Method for notifying the host for certain IME events
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtEdit::Notify(
	long lNotify)		//@parm Notification code
{
	TxNotify(lNotify, NULL);

	return NOERROR;
}

//----------------------- ITextDocument Helper Functions -----------------------
/*
 *	CTxtEdit::CloseFile (bSave)
 *
 *	@mfunc
 *		Method that closes the current document. If changes have been made
 *		in the current document since the last save and document file
 *		information exists, the current document is saved.
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
HRESULT CTxtEdit::CloseFile (
	BOOL bSave)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::Close");

	CDocInfo *pDocInfo = _pDocInfo;

	if(pDocInfo)
	{
		if(bSave)									// Save current file if
			Save(NULL, 0, 0);						//  any changes made
	
		// FUTURE(BradO):  This code is very similar to the destructor code.
		// We have a problem here in that some of the CDocInfo information
		// should persist from Open to Close to Open (ex. default tab stop)
		// mixed with other per-Open/Close info.  A better job of abstracting
		// these two types of info would really clean up this code.

		if(pDocInfo->pName)
		{
			SysFreeString(pDocInfo->pName);			// Free filename BSTR
			pDocInfo->pName = NULL;
		}

		if(pDocInfo->hFile)
		{
			CloseHandle(pDocInfo->hFile);			// Close file if open
			pDocInfo->hFile = NULL;
		}
		pDocInfo->wFlags = 0;
		pDocInfo->wCpg = 0;

		pDocInfo->lcid = 0;
		pDocInfo->lcidfe = 0;

		if(pDocInfo->lpstrLeadingPunct)
		{
			FreePv(pDocInfo->lpstrLeadingPunct);
			pDocInfo->lpstrLeadingPunct = NULL;
		}

		if(pDocInfo->lpstrFollowingPunct)
		{
			FreePv(pDocInfo->lpstrFollowingPunct);
			pDocInfo->lpstrFollowingPunct = NULL;
		}
	}
	return NOERROR;
}

/*
 *	CTxtEdit::SetDefaultLCID (lcid) 
 *
 *	@mfunc
 *		Property set method that sets the default LCID
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		This property should be part of TOM
 */
HRESULT CTxtEdit::SetDefaultLCID (
	LCID lcid)		//@parm New default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDefaultLCID");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->lcid = lcid;
	return NOERROR;
}

/*
 *	CTxtEdit::GetDefaultLCID (pLCID) 
 *
 *	@mfunc
 *		Property get method that gets the default LCID
 *
 *	@rdesc
 *		HRESULT = (!pLCID) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtEdit::GetDefaultLCID (
	LCID *pLCID)		//@parm Out parm with default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDefaultLCID");

	if(!pLCID)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	*pLCID = _pDocInfo->lcid;
	return NOERROR;
}

/*
 *	CTxtEdit::SetDefaultLCIDFE (lcid) 
 *
 *	@mfunc
 *		Property set method that sets the default FE LCID
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		This property should be part of TOM
 */
HRESULT CTxtEdit::SetDefaultLCIDFE (
	LCID lcid)		//@parm New default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDefaultLCIDFE");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->lcidfe = lcid;
	return NOERROR;
}

/*
 *	CTxtEdit::GetDefaultLCIDFE (pLCID) 
 *
 *	@mfunc
 *		Property get method that gets the default FE LCID
 *
 *	@rdesc
 *		HRESULT = (!pLCID) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtEdit::GetDefaultLCIDFE (
	LCID *pLCID)		//@parm Out parm with default LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDefaultLCID");

	if(!pLCID)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	*pLCID = _pDocInfo->lcidfe;
	return NOERROR;
}

/*
 *	CTxtEdit::SetDocumentType(bDocType) 
 *
 *	@mfunc
 *		Property set method that sets the document's type (none-\ltrdoc-\rtldoc)
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
HRESULT CTxtEdit::SetDocumentType (
	LONG DocType)		//@parm New document-type value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetDocumentType");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	pDocInfo->bDocType = (BYTE)DocType;
	return NOERROR;
}

/*
 *	CTxtEdit::GetDocumentType (pDocType) 
 *
 *	@mfunc
 *		Property get method that gets the document type
 *
 *	@rdesc
 *		HRESULT = (!pDocType) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtEdit::GetDocumentType (
	LONG *pDocType)		//@parm Out parm with document type value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetDocumentType");

	if(!pDocType)
		return E_INVALIDARG;

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)								// Doc info doesn't exist
		return E_OUTOFMEMORY;

	*pDocType = _pDocInfo->bDocType;
	return NOERROR;
}

/*
 *	CTxtEdit::GetLeadingPunct (plpstrLeadingPunct)
 *
 *	@mfunc
 *		Retrieve leading kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (!<p plpstrLeadingPunct>) ? E_INVALIDARG :
 *				  (no leading punct) ? S_FALSE :
 *				  (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::GetLeadingPunct (
	LPSTR * plpstrLeadingPunct)		//@parm Out parm to receive leading 
								//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetLeadingPunct");

	if(!plpstrLeadingPunct)
		return E_INVALIDARG;

	*plpstrLeadingPunct = NULL;
	if(!_pDocInfo || !_pDocInfo->lpstrLeadingPunct)
		return S_FALSE;

	*plpstrLeadingPunct = _pDocInfo->lpstrLeadingPunct;
	
	return NOERROR;
}

/*
 *	CTxtEdit::SetLeadingPunct (lpstrLeadingPunct)
 *
 *	@mfunc
 *		Set leading kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::SetLeadingPunct (
	LPSTR lpstrLeadingPunct)	//@parm In parm containing leading 
								//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetLeadingPunct");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)
		return E_OUTOFMEMORY;

	if(pDocInfo->lpstrLeadingPunct)
		FreePv(pDocInfo->lpstrLeadingPunct);

	if(lpstrLeadingPunct && *lpstrLeadingPunct)
		pDocInfo->lpstrLeadingPunct = lpstrLeadingPunct;
	else
	{
		pDocInfo->lpstrLeadingPunct = NULL;
		return E_INVALIDARG;
	}
	return NOERROR;
}

/*
 *	CTxtEdit::GetFollowingPunct (plpstrFollowingPunct)
 *
 *	@mfunc
 *		Retrieve following kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (!<p plpstrFollowingPunct>) ? E_INVALIDARG :
 *				  (no following punct) ? S_FALSE :
 *				  (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::GetFollowingPunct (
	LPSTR * plpstrFollowingPunct)		//@parm Out parm to receive following 
								//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::GetFollowingPunct");

	if(!plpstrFollowingPunct)
		return E_INVALIDARG;

	*plpstrFollowingPunct = NULL;
	if(!_pDocInfo || !_pDocInfo->lpstrFollowingPunct)
		return S_FALSE;

	*plpstrFollowingPunct = _pDocInfo->lpstrFollowingPunct;
	
	return NOERROR;
}

/*
 *	CTxtEdit::SetFollowingPunct (lpstrFollowingPunct)
 *
 *	@mfunc
 *		Set following kinsoku punctuation for document
 *
 *	@rdesc
 *		HRESULT = (if not enough RAM) ? E_OUTOFMEMORY : NOERROR
 */
HRESULT CTxtEdit::SetFollowingPunct (
	LPSTR lpstrFollowingPunct)		//@parm In parm containing following 
									//	kinsoku punctuation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtEdit::SetFollowingPunct");

	CDocInfo *pDocInfo = GetDocInfo();

	if(!pDocInfo)
		return E_OUTOFMEMORY;

	if(pDocInfo->lpstrFollowingPunct)
		FreePv(pDocInfo->lpstrFollowingPunct);

	if(lpstrFollowingPunct && *lpstrFollowingPunct)
		pDocInfo->lpstrFollowingPunct = lpstrFollowingPunct;
	else
	{
		pDocInfo->lpstrFollowingPunct = NULL;
		return E_INVALIDARG;
	}
	return NOERROR;
}

/*
 *	CTxtEdit::InitDocInfo()
 *
 *	@mfunc	constructor for the docinfo class
 */
HRESULT CTxtEdit::InitDocInfo()
{
	_wZoomNumerator = _wZoomDenominator = 0;
	if(_pDocInfo)
	{
		_pDocInfo->InitDocInfo();
		return NOERROR;
	}

	return GetDocInfo() ? NOERROR : E_OUTOFMEMORY;
}


//----------------------- CDocInfo related Functions -----------------------
/*
 *	CDocInfo::InitDocInfo()
 *
 *	@mfunc	constructor for the docinfo class
 */
void CDocInfo::InitDocInfo()
{
	wCpg = (WORD)GetACP();
	lcid = GetSystemDefaultLCID();

	if(IsFELCID(lcid))
	{
		lcidfe = lcid;
		lcid = MAKELCID(sLanguageEnglishUS, SORT_DEFAULT);
	}

	dwDefaultTabStop = lDefaultTab;
	bDocType = 0;
}

/*
 *	CDocInfo::~CDocInfo
 *
 *	@mfunc	desctructor for the docinfo class
 */
CDocInfo::~CDocInfo()
{
	if( pName )
	{
		SysFreeString(pName);
		pName = NULL;
	}

	if( hFile )
	{
		CloseHandle(hFile);
		hFile = NULL;
	}

	FreePv(lpstrLeadingPunct);
	lpstrLeadingPunct = NULL;

	FreePv(lpstrFollowingPunct);
	lpstrFollowingPunct = NULL;

	FreePv(prgColor);
	prgColor = NULL;
}

/*
 *	CTxtEdit::GetDocInfo ()
 *
 *	@mfunc
 *		If _pDocInfo is NULL, equate it to a new CDocInfo.  In either case
 *		return _pDocInfo
 *
 *	@rdesc
 *		CTxtEdit::_pDocInfo, the ptr to the CDocInfo object
 */
CDocInfo * CTxtEdit::GetDocInfo()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtEdit::GetDocInfo");

	if (!_pDocInfo)
		_pDocInfo = new CDocInfo();

	// It is the caller's responsiblity to notice that an error occurred
	// in the allocation of the CDocInfo object.
	return _pDocInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\tokens.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _TOKENS.H -- All the tokens and then some |
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *		
 *	@devnote
 *		The Text Object Model (TOM) keywords come first followed by picture
 *		and object keywords.  The order within a group can matter, since it
 *		may be used to simplify the input process.  Token values <lt> 256
 *		(tokenMin) are used for target character Unicodes as are token values
 *		greater than tokenMax.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _TOKEN_H
#define _TOKEN_H

typedef	WORD	TOKEN;

/*
 *		Keyword --> Token table
 */
typedef struct _keyword
{
	CHAR *	szKeyword;				// The RTF keyword sans '\\'
	TOKEN	token;
} KEYWORD;


// @enum TOKENS | RichEdit RTF Control Word Tokens

enum TOKENS							// Keyword tokens
{
	// Tokens for internal use
	tokenMin = 256,					// Lower tokens treated as Unicode chars
	tokenText = tokenMin,			// A string of characters
	tokenASCIIText,					// A string of characters with values <= 0x7F
	tokenUnknownKeyword,			// A keyword we don't recognize
	tokenError,						// Error condition token
#ifdef UNUSED_TOKENS
	tokenUnknown,					// Unknown token
#endif
	tokenEOF,						// End-of-file token
	tokenStartGroup, 				// Start group token
	tokenEndGroup,					// End group token
	tokenObjectDataValue,			// Data for object 
	tokenPictureDataValue,			// Data for picture


	// RTF control word tokens from here to end of enumeration
	tokenURtf,						// @emem urtf
	tokenPocketWord,				// @emem pwd
	tokenRtf,						// @emem rtf
	tokenCharSetAnsi,				// @emem ansi
	tokenAnsiCodePage,				// @emem ansicpg
	tokenViewKind,					// @emem viewkind		
	tokenViewScale,					// @emem viewscale		

	tokenDefaultFont,				// @emem deff
	tokenDefaultBiDiFont,           // @emem adeff
	tokenDefaultLanguage,			// @emem deflang
	tokenDefaultLanguageFE,			// @emem deflangfe
	tokenDefaultTabWidth,			// @emem deftab
	tokenParagraphDefault,			// @emem pard
	tokenCharacterDefault,			// @emem plain


	// Fonts
	tokenFontTable,					// @emem fonttbl
	tokenFontSelect,				// @emem f
	tokenAssocFontSelect,			// @emem af
									//			Keep next 8 in order
	tokenFontFamilyDefault,			// @emem fnil
	tokenFontFamilyRoman,			// @emem froman
	tokenFontFamilySwiss,			// @emem fswiss
	tokenFontFamilyModern,			// @emem fmodern
	tokenFontFamilyScript,			// @emem fscript
	tokenFontFamilyDecorative,		// @emem fdecor
	tokenFontFamilyTechnical,		// @emem ftech
	tokenFontFamilyBidi,			// @emem fbidi

	tokenCharSet,					// @emem fcharset
	tokenPitch,						// @emem fprq
	tokenRealFontName,				// @emem fname
	tokenCodePage,					// @emem cpg
	tokenFontSize,					// @emem fs

	// Colors
	tokenColorTable,				// @emem colortbl
	tokenColorBackground,			// @emem highlight (used to be cb)
	tokenColorForeground,			// @emem cf
									//			Keep next 3 in order
	tokenColorRed,					// @emem red
	tokenColorGreen,				// @emem green
	tokenColorBlue,					// @emem blue


	// Character formatting						Keep next 15 effects in order
	tokenBold,						// @emem b
	tokenItalic,					// @emem i
	tokenUnderline,					// @emem ul
	tokenStrikeOut,					// @emem strike
	tokenProtect,					// @emem protect
	tokenLink,						// @emem link (check this...)
	tokenSmallCaps,					// @emem scaps
	tokenCaps,						// @emem caps
	tokenHiddenText,				// @emem v
	tokenOutline,					// @emem outl
	tokenShadow,					// @emem shad
	tokenEmboss,					// @emem embo
	tokenImprint,					// @emem impr
	tokenDisabled,					// @emem disabled
	tokenRevised,					// @emem revised

	tokenDeleted,					// @emem deleted

	tokenStopUnderline,				// @emem ulnone	Keep next 10 in order
	tokenUnderlineWord,				// @emem ulw	This thru uld are standard
	tokenUnderlineDouble,			// @emem uldb	 Word underlines
	tokenUnderlineDotted,			// @emem uld		
	tokenUnderlineDash,				// @emem uldash
	tokenUnderlineDashDotted,		// @emem uldashd	
	tokenUnderlineDashDotDotted,	// @emem uldashdd
	tokenUnderlineWave,				// @emem ulwave This down thru uldash are
	tokenUnderlineThick,			// @emem ulth	 for FE
	tokenUnderlineHairline,			// @emem ulhair

	tokenDown,						// @emem dn
	tokenUp,						// @emem up
									// 				Keep next 3 in order
	tokenSubscript,					// @emem sub
	tokenNoSuperSub,				// @emem nosupersub
	tokenSuperscript,				// @emem super

	tokenAnimText,					// @emem animtext
	tokenExpand,					// @emem expndtw
	tokenKerning,					// @emem kerning
	tokenLanguage,					// @emem lang
	tokenCharStyle,					// @emem cs

	// Paragraph Formatting
	tokenEndParagraph,				// @emem par
	tokenLineBreak,					// @emem line
	tokenIndentFirst,				// @emem fi
	tokenIndentLeft,				// @emem li
	tokenIndentRight,				// @emem ri
									//			Keep next 4 in order
	tokenAlignLeft,					// @emem ql		PFA_LEFT
	tokenAlignRight,				// @emem qr		PFA_RIGHT
	tokenAlignCenter,				// @emem qc		PFA_CENTER
	tokenAlignJustify,				// @emem qj		PFA_JUSTIFY

	tokenSpaceBefore,				// @emem sb
	tokenSpaceAfter,				// @emem sa
	tokenLineSpacing,				// @emem sl
	tokenLineSpacingRule,			// @emem slmult
	tokenDropCapLines,				// @emem dropcapli
	tokenStyle,						// @emem s

	tokenLToRPara,					// @emem ltrpar
	tokenBox,
									//			keep next 8 in order 
	tokenRToLPara,					// @emem rtlpar
	tokenKeep,						// @emem keep
	tokenKeepNext,					// @emem keepn
	tokenPageBreakBefore,			// @emem pagebb
	tokenNoLineNumber,				// @emem noline
	tokenNoWidCtlPar,				// @emem nowidctlpar
	tokenHyphPar,					// @emem hyphpar
	tokenSideBySide,				// @emem sbys
	tokenCollapsed,					// @emem collapsed
									// Keep following 8 together
	tokenBorderTop,					// @emem brdrt
	tokenBorderLeft,				// @emem brdrl
	tokenBorderBottom,				// @emem brdrb
	tokenBorderRight,				// @emem brdrr
	tokenCellBorderTop,				// @emem clbrdrt
	tokenCellBorderLeft,			// @emem clbrdrl
	tokenCellBorderBottom,			// @emem clbrdrb
	tokenCellBorderRight,			// @emem clbrdrr
									// Keep following 3 together
	tokenBorderShadow,				// @emem brdrsh
	tokenBorderBetween,				// @emem brdrbtw
	tokenBorderOutside,				// @emem brdrbar
									// Keep following 8 together
	tokenBorderDash,				// @emem brdrdash
	tokenBorderDashSmall,			// @emem brdrdashsm
	tokenBorderDouble,				// @emem brdrdb
	tokenBorderDot,					// @emem brdrdot
	tokenBorderHairline,			// @emem brdrhair
	tokenBorderSingleThick,			// @emem brdrs
	tokenBorderDoubleThick,			// @emem brdrth
	tokenBorderTriple,				// @emem brdrtriple

	tokenBorderColor,				// @emem brdrcf
	tokenBorderWidth,				// @emem brdrw
	tokenBorderSpace,				// @emem brsp

	tokenColorBckgrndPat,			// @emem cbpat
	tokenColorForgrndPat,			// @emem cfpat
	tokenShading,					// @emem shading
									//			keep next 12 in order
	tokenBckgrndBckDiag,			// @emem bgbdiag
	tokenBckgrndCross,				// @emem bgcross
	tokenBckgrndDiagCross,			// @emem bgdcross
	tokenBckgrndDrkBckDiag,			// @emem bgdkbdiag
	tokenBckgrndDrkCross,			// @emem bgdkcross
	tokenBckgrndDrkDiagCross,		// @emem bgdkdcross
	tokenBckgrndDrkFwdDiag,			// @emem bgdkfdiag
	tokenBckgrndDrkHoriz,			// @emem bgdkhoriz
	tokenBckgrndDrkVert,	   		// @emem bgdkvert
	tokenBckgrndFwdDiag,			// @emem bgfdiag
	tokenBckgrndHoriz,				// @emem bghoriz
	tokenBckgrndVert,				// @emem bgvert

	tokenTabPosition,				// @emem tx
	tokenTabBar,					// @emem tb
									//			keep next 5 in order 
	tokenTabLeaderDots,				// @emem tldot
	tokenTabLeaderHyphen,			// @emem tlhyph
	tokenTabLeaderUnderline,		// @emem tlul
	tokenTabLeaderThick,			// @emem tlth
	tokenTabLeaderEqual,			// @emem tleq
									//			keep next 4 in order 
	tokenCenterTab,					// @emem tqc
	tokenFlushRightTab,				// @emem tqr
	tokenDecimalTab,				// @emem tqdec

	tokenParaNum,					// @emem pn
	tokenParaNumIndent,				// @emem pnindent
	tokenParaNumBody,				// @emem pnlvlbody
	tokenParaNumCont,				// @emem pnlvlcont
	tokenParaNumAlignCenter,		// @emem pnqc
	tokenParaNumAlignRight,			// @emem pnqr
									//			keep next 6 in order
	tokenParaNumBullet,				// @emem pnlvlblt
	tokenParaNumDecimal,			// @emem pndec
	tokenParaNumLCLetter,			// @emem pnlcltr
	tokenParaNumUCLetter,			// @emem pnucltr
	tokenParaNumLCRoman,			// @emem pnlcrm
	tokenParaNumUCRoman,			// @emem pnucrm

	tokenParaNumText,				// @emem pntext
	tokenParaNumStart,				// @emem pnstart
	tokenParaNumAfter,				// @emem pntxta
	tokenParaNumBefore,				// @emem pntxtb

	tokenOptionalDestination,		// @emem *
	tokenField,						// @emem field
	tokenFieldResult,				// @emem fldrslt
	tokenFieldInstruction,			// @emem fldinst
	tokenStyleSheet,				// @emem stylesheet
	tokenEndSection,				// @emem sect
	tokenSectionDefault,			// @emem sectd
	tokenDocumentArea,				// @emem info

	// Tables
	tokenInTable,					// @emem intbl
	tokenCell,						// @emem cell
	tokenCellHalfGap,				// @emem trgaph
	tokenCellX,						// @emem cellx
	tokenRow,						// @emem row
	tokenRowDefault,				// @emem trowd
	tokenRowLeft,					// @emem trleft
	tokenRowAlignRight,				// @emem trqr	(trqc must follow trqr)
	tokenRowAlignCenter,			// @emem trqc

	tokenUnicode,					// @emem u
	tokenUnicodeCharByteCount,		// @emem uc

	// Special characters
	tokenFormulaCharacter,			// |
	tokenIndexSubentry,				// :


	tokenLToRChars,					// @emem ltrch
	tokenLToRDocument,				// @emem ltrdoc
	tokenDisplayLToR,				// @emem ltrmark	See also ltrpar
	tokenRToLChars,					// @emem rtlch
	tokenRToLDocument,				// @emem rtldoc
	tokenDisplayRToL,				// @emem rtlmark
	tokenZeroWidthJoiner,			// @emem zwj
	tokenZeroWidthNonJoiner,		// @emem zwnj
	tokenDBChars,					// @emem dbch

	//	T3J keywords
	tokenFollowingPunct,			// @emem fchars
	tokenLeadingPunct,				// @emem lchars

#ifdef FE
	tokenHorizontalRender,			// @emem horzdoc
	tokenVerticalRender,			// @emem vertdoc
	tokenNoOverflow,				// @emem nooverflow
	tokenNoWordBreak,				// @emem nocwrap
	tokenNoWordWrap,				// @emem nowwrap
#endif
	tokenPicture,					// @emem pict
	tokenObject,					// @emem object

	// Pictures						 				Keep next 4 in RECT order
	tokenPicFirst,
	tokenCropLeft = tokenPicFirst,	// @emem piccropl
	tokenCropTop,					// @emem piccropt
	tokenCropBottom,				// @emem piccropb
	tokenCropRight,					// @emem piccropr
	tokenHeight,					// @emem pich
	tokenWidth,						// @emem picw
	tokenScaleX,					// @emem picscalex
	tokenScaleY,					// @emem picscaley
	tokenDesiredHeight,				// @emem pichgoal
	tokenDesiredWidth,				// @emem picwgoal
									//				Keep next 3 in order
	tokenPictureWindowsBitmap,		// @emem wbitmap
	tokenPictureWindowsMetafile,	// @emem wmetafile
	tokenPictureWindowsDIB,			// @emem dibitmap

	tokenBinaryData,				// @emem bin
	tokenPictureQuickDraw,			// @emem macpict
	tokenPictureOS2Metafile,		// @emem pmmetafile
	tokenBitmapBitsPerPixel,		// @emem wbmbitspixel
	tokenBitmapNumPlanes,			// @emem wbmplanes
	tokenBitmapWidthBytes,			// @emem wbmwidthbytes


	// Objects
//	tokenCropLeft,					// @emem objcropl		(see // Pictures)
//	tokenCropTop,					// @emem objcropt
//	tokenCropRight,					// @emem objcropr
//	tokenCropBottom,				// @emem objcropb
//	tokenHeight,					// @emem objh
//	tokenWidth,						// @emem objw
//	tokenScaleX,					// @emem objscalex
//	tokenScaleY,					// @emem objscaley
									//				Keep next 3 in order
	tokenObjectEmbedded,			// @emem objemb
	tokenObjectLink,				// @emem objlink
	tokenObjectAutoLink,			// @emem objautlink

	tokenObjectClass,				// @emem objclass
	tokenObjectData,				// @emem objdata

	tokenObjectMacICEmbedder,		// @emem objicemb
	tokenObjectName,				// @emem objname
	tokenObjectMacPublisher,		// @emem objpub
	tokenObjectSetSize,				// @emem objsetsize
	tokenObjectMacSubscriber,		// @emem objsub
	tokenObjectResult,				// @emem result
	tokenObjLast = tokenObjectResult,

	// Document info and layout
	tokenRevAuthor,					// @emem revauth

#ifdef UNUSED_TOKENS
	tokenTimeSecond,				// @emem sec
	tokenTimeMinute,				// @emem min
	tokenTimeHour,					// @emem hr
	tokenTimeDay,					// @emem dy
	tokenTimeMonth,					// @emem mo
	tokenTimeYear,					// @emem yr
	tokenMarginLeft,				// @emem margl
	tokenMarginRight,				// @emem margr
	tokenSectionMarginLeft,			// @emem marglsxn
	tokenSectionMarginRight,		// @emem margrsxn
#endif

	tokenObjectPlaceholder,			// @emem objattph

	tokenPage,						// @emem page

	tokenNullDestination,			// @emem ??various??

	tokenMax						// Larger tokens treated as Unicode chars
};

// @enum TOKENINDEX | RTFWrite Indices into rgKeyword[]

enum TOKENINDEX						// rgKeyword[] indices
{									// MUST be in exact 1-to-1 with rgKeyword
	i_adeff,						//  entries (see tokens.c).  Names consist
	i_af,
	i_animtext,						
	i_ansi,
	i_ansicpg,						
	i_b,							
	i_bgbdiag,
	i_bgcross,
	i_bgdcross,
	i_bgdkbdiag,
	i_bgdkcross,
	i_bgdkdcross,
	i_bgdkfdiag,
	i_bgdkhoriz,
	i_bgdkvert,
	i_bgfdiag,
	i_bghoriz,
	i_bgvert,
	i_bin,
	i_blue,
	i_box,
	i_brdrb,
	i_brdrbar,
	i_brdrbtw,
	i_brdrcf,
	i_brdrdash,
	i_brdrdashsm,
	i_brdrdb,
	i_brdrdot,
	i_brdrhair,
	i_brdrl,
	i_brdrr,
	i_brdrs,
	i_brdrsh,
	i_brdrt,
	i_brdrth,
	i_brdrtriple,
	i_brdrw,
	i_brsp,
	i_bullet,
	i_caps,
	i_cbpat,
	i_cell,
	i_cellx,
	i_cf,
	i_cfpat,
	i_clbrdrb,
	i_clbrdrl,
	i_clbrdrr,
	i_clbrdrt,
	i_collapsed,
	i_colortbl,
	i_cpg,
	i_cs,
	i_dbch,
	i_deff,
	i_deflang,
	i_deflangfe,
	i_deftab,
	i_deleted,
	i_dibitmap,
	i_disabled,
	i_dn,
	i_dropcapli,
	i_embo,
	i_emdash,
	i_emspace,
	i_endash,
	i_enspace,
	i_expndtw,
	i_f,
	i_fbidi,
	i_fchars,
	i_fcharset,
	i_fdecor,
	i_fi,
	i_field,
	i_fldinst,
	i_fldrslt,
	i_fmodern,
	i_fname,
	i_fnil,
	i_fonttbl,
	i_footer,
	i_footerf,
	i_footerl,
	i_footerr,
	i_footnote,
	i_fprq,
	i_froman,
	i_fs,
	i_fscript,
	i_fswiss,
	i_ftech,
	i_ftncn,
	i_ftnsep,
	i_ftnsepc,
	i_green,
	i_header,
	i_headerf,
	i_headerl,
	i_headerr,
	i_highlight,
	i_hyphpar,
	i_i,
	i_impr,
	i_info,
	i_intbl,
	i_keep,
	i_keepn,
	i_kerning,
	i_lang,
	i_lchars,
	i_ldblquote,
	i_li,
	i_line,
	i_lnkd,
	i_lquote,
	i_ltrch,
	i_ltrdoc,
	i_ltrmark,
	i_ltrpar,
	i_macpict,
	i_noline,
	i_nosupersub,
	i_nowidctlpar,
	i_objattph,
	i_objautlink,
	i_objclass,
	i_objcropb,
	i_objcropl,
	i_objcropr,
	i_objcropt,
	i_objdata,
	i_object,
	i_objemb,
	i_objh,
	i_objicemb,
	i_objlink,
	i_objname,
	i_objpub,
	i_objscalex,
	i_objscaley,
	i_objsetsize,
	i_objsub,
	i_objw,
	i_outl,
	i_page,
	i_pagebb,
	i_par,
	i_pard,
	i_piccropb,
	i_piccropl,
	i_piccropr,
	i_piccropt,
	i_pich,
	i_pichgoal,
	i_picscalex,
	i_picscaley,
	i_pict,
	i_picw,
	i_picwgoal,
	i_plain,
	i_pmmetafile,
	i_pn,
	i_pndec,
	i_pnindent,
	i_pnlcltr,
	i_pnlcrm,
	i_pnlvlblt,
	i_pnlvlbody,
	i_pnlvlcont,
	i_pnqc,
	i_pnqr,
	i_pnstart,
	i_pntext,
	i_pntxta,
	i_pntxtb,
	i_pnucltr,
	i_pnucrm,
	i_protect,
	i_pwd,
	i_qc,
	i_qj,
	i_ql,
	i_qr,
	i_rdblquote,
	i_red,
	i_result,
	i_revauth,
	i_revised,
	i_ri,
	i_row,
	i_rquote,
	i_rtf,
	i_rtlch,
	i_rtldoc,
	i_rtlmark,
	i_rtlpar,
	i_s,
	i_sa,
	i_sb,
	i_sbys,
	i_scaps,
	i_sect,
	i_sectd,
	i_shad,
	i_shading,
	i_sl,
	i_slmult,
	i_strike,
	i_stylesheet,
	i_sub,
	i_super,
	i_tab,
	i_tb,
	i_tc,
	i_tldot,
	i_tleq,
	i_tlhyph,
	i_tlth,
	i_tlul,
	i_tqc,
	i_tqdec,
	i_tqr,
	i_trbrdrb,
	i_trbrdrl,
	i_trbrdrr,
	i_trbrdrt,
	i_trgaph,
	i_trleft,
	i_trowd,
	i_trqc,
	i_trqr,
	i_tx,
	i_u,
	i_uc,
	i_ul,
	i_uld,
	i_uldash,
	i_uldashd,
	i_uldashdd,
	i_uldb,
	i_ulhair,
	i_ulnone,
	i_ulth,
	i_ulw,
	i_ulwave,
	i_up,
	i_urtf,
	i_v,
	i_viewkind,
	i_viewscale,
	i_wbitmap,
	i_wbmbitspixel,
	i_wbmplanes,
	i_wbmwidthbytes,
	i_wmetafile,
	i_xe,
	i_zwj,
	i_zwnj,
	i_TokenIndexMax
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\tomfmt.cpp ===
/*
 *	@doc TOM
 *
 *	@module	tomfmt.cpp - Implement the CTxtFont and CTxtPara Classes |
 *	
 *		This module contains the implementation of the TOM ITextFont and
 *		ITextPara interfaces
 *
 *	History: <nl>
 *		11/8/95 - MurrayS: created
 *		5/96	- MurrayS: added zombie protection
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_tomfmt.h"
#include "_font.h"

ASSERTDATA

#define tomFloatUndefined	((float)(int)tomUndefined)

// Alignment translation vectors
const BYTE g_rgREtoTOMAlign[] =				// RichEdit to TOM
{
	// TODO: generalize TOM to handle new LineServices options
	tomAlignLeft, tomAlignLeft, tomAlignRight, tomAlignCenter, tomAlignJustify,
	tomAlignInterLetter, tomAlignScaled, tomAlignGlyphs, tomAlignSnapGrid
};

const BYTE g_rgTOMtoREAlign[] =				// TOM to RichEdit
{
	PFA_LEFT, PFA_CENTER, PFA_RIGHT, PFA_FULL_INTERWORD,
	PFA_FULL_INTERLETTER, PFA_FULL_SCALED, PFA_FULL_GLYPHS,
	PFA_SNAP_GRID
};

/*
 *	QueryInterface(riid, riid1, punk, ppv, fZombie)
 *
 *	@func
 *		QueryInterface punk for the ref IDs riid1, IID_IDispatch, and
 *		IID_IUnknown
 *
 *	@rdesc
 *		HRESULT = (!ppv) ? E_INVALIDARG :
 *				  (interface found) ? NOERROR : E_NOINTERFACE
 */
HRESULT QueryInterface (
	REFIID	  riid,		//@parm Reference to requested interface ID
	REFIID	  riid1,	//@parm Query for this, IDispatch, IUnknown
	IUnknown *punk,		//@parm Interface to query
	void **	  ppv,		//@parm Out parm to receive interface ptr
	BOOL	  fZombie)	//@parm If true, return CO_E_RELEASED
{
	if(!ppv)
		return E_INVALIDARG;

	*ppv = NULL;

	if(fZombie)							// Check for range zombie
		return CO_E_RELEASED;

	Assert(punk);

#ifndef PEGASUS
	if( IsEqualIID(riid, IID_IUnknown)   ||
		IsEqualIID(riid, IID_IDispatch)  ||
		IsEqualIID(riid, riid1) )
	{
		*ppv = punk;
		punk->AddRef();
		return NOERROR;
	}
#endif
	return E_NOINTERFACE;
}

//------------------------------- CTxtFont -------------------------------------

/*
 *	CTxtFont::CTxtFont(prg)
 *
 *	@mfunc
 *		Constructor
 */
CTxtFont::CTxtFont(CTxtRange *prg) : CTxtFormat(prg)
{
	Assert(!_dwMask);		// We assume that object is zeroed (new'd)
}


//------------------------- CTxtFont IUnknown Methods -------------------------------------

/*	CTxtFont::IUnknown methods
 *
 *		See tomDoc.cpp for comments
 */
STDMETHODIMP CTxtFont::QueryInterface (REFIID riid, void **ppv)
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::QueryInterface");

	return ::QueryInterface(riid, IID_ITextFont, this, ppv, IsZombie());
#else
	return 0;
#endif
}

STDMETHODIMP_(ULONG) CTxtFont::AddRef()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::AddRef");

 	return ++_cRefs;
}

STDMETHODIMP_(ULONG) CTxtFont::Release()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::Release");

	_cRefs--;

	if(!_cRefs)
	{
		delete this;
		return 0;
	}
	return _cRefs;
}


//------------------------- CTxtFont IDispatch Methods -------------------------------------

/*
 *	CTxtFont::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT = (pcTypeInfo) ? NOERROR : E_INVALIDARG;
 */
STDMETHODIMP CTxtFont::GetTypeInfoCount (
	UINT * pcTypeInfo)			//@parm Out parm to receive type-info count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtFont::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextFont interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtFont::GetTypeInfo (
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoFont, ppTypeInfo);
}

/*
 *	CTxtFont::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for ITextFont methods and properties
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtFont::GetIDsOfNames (
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	return g_pTypeInfoFont->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

/*
 *	CTxtFont::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke methods for the ITextFont interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtFont::Invoke (
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::Invoke");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;

	if(IsZombie())
		return CO_E_RELEASED;
				
	return g_pTypeInfoFont->Invoke(this, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);
}


//--------------------------- ITextFont Methods -------------------------------------

/*
 *	ITextFont::CanChange(long * pbCanChange) 
 *
 *	@mfunc
 *		Method that sets *pbCanChange = tomTrue if and only if the
 *		font can be changed.
 *
 *	@rdesc
 *		HRESULT = (can change char format) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtFont::CanChange (
	long *pbCanChange)		//@parm Out parm to receive boolean value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::CanChange");

	return CTxtFormat::CanChange(pbCanChange, CharFormat);
}

/*
 *	ITextFont::GetAllCaps(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the AllCaps state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetAllCaps (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetAllCaps");

	return EffectGetter(pValue, CFM_ALLCAPS);
}

/*
 *	ITextFont::GetAnimation(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the animation type as defined
 *		in the table below.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetAnimation (
	long *pValue)		//@parm Out parm to receive animation type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetAnimation");

	return GetParameter((long *)&_CF._bAnimation, CFM_ANIMATION, 1, pValue);
}

/*
 *	ITextFont::GetBackColor(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the background color.  The
 *		value is a Win32 COLORREF.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetBackColor (
	long *pValue)		//@parm Out parm to receive COLORREF value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetBackColor");

	HRESULT hr = EffectGetter(pValue, CFE_AUTOBACKCOLOR);

	if(hr != NOERROR || *pValue == tomUndefined)
		return hr;

	*pValue = (*pValue == tomFalse) ? _CF._crBackColor : tomAutoColor;
	return NOERROR;
}

/*
 *	ITextFont::GetBold(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the bold state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetBold (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetBold");

	return EffectGetter(pValue, CFM_BOLD);
}

/*
 *	ITextFont::GetDuplicate(ITextFont **ppFont) 
 *
 *	@mfunc
 *		Property get method that gets a clone of this character
 *		format object.
 *
 *	@rdesc
 *		HRESULT = (!ppFont) ? E_INVALIDARG :
 *				  (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtFont::GetDuplicate (
	ITextFont **ppFont)		//@parm Out parm to receive font clone
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetDuplicate");

	if(!ppFont)
		return E_INVALIDARG;

	*ppFont = NULL;

	if(IsZombie())
		return CO_E_RELEASED;

	CTxtFont *pFont = new CTxtFont(NULL);
	if(!pFont)
		return E_OUTOFMEMORY;

	if(_prg)
		UpdateFormat();

	pFont->_CF		= _CF;
	pFont->_dwMask  = _dwMask;
	*ppFont = pFont;
	return NOERROR;
}

/*
 *	ITextFont::GetEmboss(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the embossed state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetEmboss (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetEmboss");

	return EffectGetter(pValue, CFM_EMBOSS);
}

/*
 *	ITextFont::GetForeColor(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the foreground color.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetForeColor (
	long *pValue)		//@parm Out parm to receive COLORREF value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetForeColor");

	HRESULT hr = EffectGetter(pValue, CFE_AUTOCOLOR);

	if(hr != NOERROR || *pValue == tomUndefined)
		return hr;

	*pValue = (*pValue == tomFalse) ? _CF._crTextColor : tomAutoColor;
	return NOERROR;
}

/*
 *	ITextFont::GetHidden(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the hidden state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetHidden (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetHidden");

	return EffectGetter(pValue, CFM_HIDDEN);
}

/*
 *	ITextFont::GetEngrave(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the imprint state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetEngrave (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetEngrave");

	return EffectGetter(pValue, CFM_IMPRINT);
}

/*
 *	ITextFont::GetItalic(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the italic state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetItalic (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetItalic");

	return EffectGetter(pValue, CFM_ITALIC);
}

/*
 *	ITextFont::GetKerning(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the minimum kerning size,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 *
 *	@comm
 *		A kerning size of 0 turns off kerning, but an arbitrarily small
 *		value turns it on, e.g., 1.0, which is too small to see, let alone
 *		kern!
 */
STDMETHODIMP CTxtFont::GetKerning (
	float *pValue)		//@parm Out parm to receive minimum kerning size
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetKerning");

	return GetParameter((long *)&_CF._wKerning, CFM_KERNING, -2, (long *)pValue);
}

/*
 *	ITextFont::GetLanguageID(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the language ID (more
 *		generally LCID).
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetLanguageID (
	long *pValue)		//@parm Out parm to receive LCID value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetLanguageID");

	if (!pValue)
		return E_INVALIDARG;

	if ((*pValue & 0xF0000000) == tomCharset) 
	{
		UpdateFormat();

		// Sepcial case to get charset and pitchandfamily
		*pValue = (_CF._bPitchAndFamily << 8) + _CF._bCharSet;
		return NOERROR;
	}
	return GetParameter((long *)&_CF._lcid, CFM_LCID, 4, pValue);
}

/*
 *	ITextFont::GetName(BSTR *pbstr) 
 *
 *	@mfunc
 *		Property get method that gets the font name.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : 
 *				  (can allocate bstr) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::GetName (
	BSTR *pbstr)	//@parm Out parm to receive font name bstr
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetName");

	if(!pbstr)
		return E_INVALIDARG;

	*pbstr = NULL;

	HRESULT hr = UpdateFormat();			// If live Font object, update
											//  _CF to current _prg values
	if(hr != NOERROR)						// Attached to zombied range
		return hr;

	*pbstr = SysAllocString(GetFontName(_CF._iFont));

	return *pbstr ? NOERROR : E_OUTOFMEMORY;
}

/*
 *	ITextFont::GetOutline(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the outline state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetOutline (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetOutline");

	return EffectGetter(pValue, CFM_OUTLINE);
}

/*
 *	ITextFont::GetPosition(float *pValue) 
 *
 *	@mfunc
 *		Property get method that gets the character position
 *		relative to the baseline. The value is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT =  (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetPosition (
	float *pValue)		//@parm Out parm to receive relative vertical position
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetPosition");

	return GetParameter((long *)&_CF._yOffset, CFM_OFFSET, -2, (long *)pValue);
}

/*
 *	ITextFont::GetProtected(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the protected state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetProtected (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetProtected");

	return EffectGetter(pValue, CFM_PROTECTED);
}

/*
 *	ITextFont::GetShadow(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the shadow state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetShadow (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetShadow");

	return EffectGetter(pValue, CFM_SHADOW);
}

/*
 *	ITextFont::GetSize(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the font size, which is given
 *		in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSize (
	float *pValue)		//@parm Out parm to receive font size
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSize");

	return GetParameter((long *)&_CF._yHeight, CFM_SIZE, -2, (long *)pValue);
}

/*
 *	ITextFont::GetSmallCaps(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the SmallCaps state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSmallCaps (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSmallCaps");

	return EffectGetter(pValue, CFM_SMALLCAPS);
}

/*
 *	ITextFont::GetSpacing(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the intercharacter spacing,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSpacing (
	float *pValue)		//@parm Out parm to receive intercharacter spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSpacing");

	return GetParameter((long *)&_CF._sSpacing, CFM_SPACING, -2, (long *)pValue);
}

/*
 *	ITextFont::GetStrikeThrough(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the strikeout state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetStrikeThrough (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetStrikeThrough");

	return EffectGetter(pValue, CFM_STRIKEOUT);
}

/*
 *	ITextFont::GetStyle(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the character style handle for
 *		the characters in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtFont::GetStyle (
	long *pValue)		//@parm Out parm to receive character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetStyle");

	return GetParameter((long *)&_CF._sStyle, CFM_STYLE, 2, pValue);
}

/*
 *	ITextFont::GetSubscript(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the subscript state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSubscript (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSubscript");

	return EffectGetter(pValue, CFE_SUBSCRIPT);
}

/*
 *	ITextFont::GetSuperscript(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the superscript state.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetSuperscript (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetSuperscript");

	return EffectGetter(pValue, CFE_SUPERSCRIPT);
}

/*
 *	ITextFont::GetUnderline(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the underline style.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR
 */
STDMETHODIMP CTxtFont::GetUnderline (
	long *pValue)		//@parm Out parm to receive underline style
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetUnderline");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Font object, update
											//  _CF to current _prg values
	*pValue = 0;							// Default no underline

	if(!(_dwMask & CFM_UNDERLINE))			// It's a NINCH
		*pValue = tomUndefined;

	else if(_CF._dwEffects & CFM_UNDERLINE)
		*pValue = (LONG)_CF._bUnderlineType ? (LONG)_CF._bUnderlineType : tomTrue;

	return hr;
}

/*
 *	ITextFont::GetWeight(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the font weight for
 *		the characters in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtFont::GetWeight (
	long *pValue)		//@parm Out parm to receive character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::GetWeight");

	return GetParameter((long *)&_CF._wWeight, CFM_WEIGHT, 2, pValue);
}

/*
 *	ITextFont::IsEqual(ITextFont * pFont, long * pB) 
 *
 *	@mfunc
 *		Method that sets *<p pB> = tomTrue if this text font has the
 *		same properties as *<p pFont>.  For this to be true, *<p pFont> has to
 *		belong to the same TOM engine as the present one. The IsEqual()
 *		method should ignore entries for which either font object has a
 *		tomUndefined value.
 *
 *	@rdesc
 *		HRESULT = (equal objects) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		This implementation assumes that all properties are defined and that
 *		pFont belongs to RichEdit.  It would be nice to generalize this so
 *		that undefined properties are ignored in the comparison and so that
 *		pFont could belong to a different TOM engine.  This would help in
 *		using RichEdit Find dialogs to search for rich text in Word using
 *		TOM.
 */
STDMETHODIMP CTxtFont::IsEqual (
	ITextFont *	pFont,		//@parm ITextFont to compare to
	long *		pB)			//@parm Out parm to receive comparison result
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::IsEqual");

	if(pB)
		*pB = tomFalse;

	if(!IsSameVtables(this, pFont))
		return S_FALSE;

	HRESULT hr = UpdateFormat();			// Update _CFs in case they are
	if(hr != NOERROR)						//  attached to ranges
		return hr;

	CTxtFont *pF = (CTxtFont *)pFont;
	hr = pF->UpdateFormat();
	if(hr != NOERROR)
		return hr;

	// Ignore differences in CharSet, since TOM thinks all CharSets are Unicode!
	DWORD dwIgnore = (DWORD)(~CFM_CHARSET);

	if(!(_CF._dwEffects & CFE_UNDERLINE))	// If not underlining, ignore
		dwIgnore &= ~CFM_UNDERLINETYPE;		//  differences in underline type

	DWORD dwMask = pF->_dwMask & dwIgnore;

	if((_dwMask ^ dwMask) & dwIgnore)		// The masks have to be the same
		return S_FALSE;						//  for equality

	if(dwMask & _CF.Delta(&(pF->_CF),FALSE))// Any difference?
		return S_FALSE;						// Yes. *pB set equal to tomFalse above

	if(pB)
		*pB = tomTrue;

	return NOERROR;
#else
	return 0;
#endif
}			

/*
 *	ITextFont::Reset(long Value) 
 *
 *	@mfunc
 *		Method that resets the character formatting to the default
 *		values to 1) those defined by the RTF \plain control word (Value =
 *		tomDefault), and 2) all undefined values (Value = tomUndefined).
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::Reset (
	long Value)		//@parm Kind of reset (tomDefault or tomUndefined)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::Reset");

	HRESULT hr = CanChange(NULL);

	if(hr != NOERROR)								// Takes care of zombie
		return hr;									//  and protection

	if(Value == tomDefault)
	{
		if(_prg)
		{
			_CF = *_prg->GetPed()->GetCharFormat(-1);
			FormatSetter(CFM_ALL2);
		}
		else
			_CF.InitDefault(0);
		_dwMask = CFM_ALL2;
	}

	else if(Value == tomUndefined && !_prg)		// Only applicable
		_dwMask = 0;							//  for clones

	else if((Value | 1) == tomApplyLater)		// Set-method optimization
	{
		_fApplyLater = Value & 1;
		if(!_fApplyLater)						// Apply now
			FormatSetter(_dwMask);
	}
	else if((Value | 1) == tomCacheParms)		// Get-method optimization
	{
		_fCacheParms = FALSE;
		if(Value & 1)							// Cache parms now, but
		{										//  don't update on gets
			UpdateFormat();							
			_fCacheParms = TRUE;
		}
	}
	else
		return E_INVALIDARG;

	return NOERROR;
}

/*
 *	ITextFont::SetAllCaps(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the AllCaps state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetAllCaps (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetAllCaps");

	return EffectSetter(Value, CFM_ALLCAPS | CFM_SMALLCAPS, CFE_ALLCAPS);
}

/*
 *	ITextFont::SetAnimation(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the animation type
 *
 *	@rdesc
 *		HRESULT = (Value defined) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtFont::SetAnimation (
	long Value)		//@parm New animation type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetAnimation");

	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > tomAnimationMax)
		return E_INVALIDARG;

	return SetParameter((long *)&_CF._bAnimation, CFM_ANIMATION, 1, Value);
}

/*
 *	ITextFont::SetBackColor(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the background color according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 *	@devnote
 *		Legal values are tomUndefined, tomAutoColor (both negative) and
 *		in principle any positive values.  Currently wingdi.h only defines
 *		high bytes = 0, 1, 2, 4.  But more values might happen, so we only
 *		rule out negative values other than tomUndefined and tomAutoColor.
 */
STDMETHODIMP CTxtFont::SetBackColor (
	long Value )		//@parm New COLORREF value to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetBackColor");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	_CF._dwEffects |= CFE_AUTOBACKCOLOR;		// Default AutoBackColor
	if(Value != tomAutoColor)
	{
		if(Value < 0)
			return E_INVALIDARG;
		_CF._dwEffects &= ~CFE_AUTOBACKCOLOR;	// Turn off AutoBackColor
		_CF._crBackColor = (COLORREF)Value;		// Use new BackColor
	}
	
	return FormatSetter(CFM_BACKCOLOR);
}

/*
 *	ITextFont::SetBold(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the bold state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetBold (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetBold");

	return EffectSetter(Value, CFM_BOLD, CFE_BOLD);
}

/*
 *	ITextFont::SetDuplicate(ITextFont *pFont) 
 *
 *	@mfunc
 *		Property put method that sets this text font character
 *		formatting to that given by pFont.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetDuplicate(
	ITextFont *pFont) 		//@parm Font object to apply to this font object
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetDuplicate");

	DWORD		dwMask = 0;
	BSTR		bstr;
	CTxtRange *	prg;
	long		Value;
	float		x;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	if(IsSameVtables(this, pFont))			// If pFont belongs to this TOM
	{										//  engine, can cast and copy
		((CTxtFont *)pFont)->UpdateFormat();
		_CF = ((CTxtFont *)pFont)->_CF;
		dwMask = ((CTxtFont *)pFont)->_dwMask;// Use this mask in case this 			
	}										//  font is active
	else
	{										// Need to call pFont for all font
		prg = _prg;							//  properties
		_prg = NULL;						// Be sure it's a clone during
											//  transfer
		pFont->GetStyle(&Value);
		SetStyle(Value);

		pFont->GetAllCaps(&Value);
		SetAllCaps(Value);

		pFont->GetAnimation(&Value);
		SetAnimation(Value);

		pFont->GetBackColor(&Value);
		SetBackColor(Value);

		pFont->GetBold(&Value);
		SetBold(Value);

		pFont->GetEmboss(&Value);
		SetEmboss(Value);

		pFont->GetForeColor(&Value);
		SetForeColor(Value);

		pFont->GetHidden(&Value);
		SetHidden(Value);

		pFont->GetEngrave(&Value);
		SetEngrave(Value);

		pFont->GetItalic(&Value);
		SetItalic(Value);

		pFont->GetKerning(&x);
		SetKerning(x);

		pFont->GetLanguageID(&Value);
		SetLanguageID(Value);

		pFont->GetName(&bstr);
		SetName(bstr);
		SysFreeString(bstr);

		pFont->GetOutline(&Value);
		SetOutline(Value);

		pFont->GetPosition(&x);
		SetPosition(x);

		pFont->GetProtected(&Value);
		SetProtected(Value);

		pFont->GetShadow(&Value);
		SetShadow(Value);

		pFont->GetSize(&x);
		SetSize(x);

		pFont->GetSmallCaps(&Value);
		SetSmallCaps(Value);

		pFont->GetSpacing(&x);
		SetSpacing(x);

		pFont->GetStrikeThrough(&Value);
		SetStrikeThrough(Value);

		pFont->GetSubscript(&Value);
		SetSubscript(Value);

		pFont->GetSuperscript(&Value);
		SetSuperscript(Value);

		pFont->GetUnderline(&Value);
		SetUnderline(Value);

		_prg = prg;							// Restore original value
	}
	return FormatSetter(dwMask);			// Apply it unless !_prg
}

/*
 *	ITextFont::SetEmboss(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the embossed state according
 *		to the value given by Value
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetEmboss (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetEmboss");

	return EffectSetter(Value, CFM_EMBOSS, CFE_EMBOSS);
}

/*
 *	ITextFont::SetForeColor(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the foreground color according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetForeColor (
	long Value )		//@parm New COLORREF value to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetForeColor");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	_CF._dwEffects |= CFE_AUTOCOLOR;			// Default AutoColor
	if(Value != tomAutoColor)
	{
		if(Value < 0)
			return E_INVALIDARG;
		_CF._dwEffects &= ~CFE_AUTOCOLOR;		// Turn off AutoColor
		_CF._crTextColor = (COLORREF)Value;		// Use new TextColor
	}
	
	return FormatSetter(CFM_COLOR);
}

/*
 *	ITextFont::SetHidden(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the hidden state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetHidden (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetHidden");

	return EffectSetter(Value, CFM_HIDDEN, CFE_HIDDEN);
}

/*
 *	ITextFont::SetEngrave(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the imprint state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetEngrave (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetEngrave");

	return EffectSetter(Value, CFM_IMPRINT, CFE_IMPRINT);
}

/*
 *	ITextFont::SetItalic(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the italic state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetItalic (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetItalic");

	return EffectSetter(Value, CFM_ITALIC, CFE_ITALIC);
}

/*
 *	ITextFont::SetKerning(float Value) 
 *
 *	@mfunc
 *		Property set method that sets the minimum kerning size,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (Value < 0) ? E_INVALIDARG :
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetKerning (
	float Value)		//@parm New value of minimum kerning size
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetKerning");

	return SetParameter((long *)&_CF._wKerning, CFM_KERNING, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetLanguageID(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the language ID (more
 *		generally LCID) according to the value given by Value.  See
 *		GetLanguageID() for more information.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetLanguageID (
	long Value)		//@parm New LCID to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetLanguageID");

	if ((Value & 0xF0000000) == tomCharset) 
	{
		// Sepcial case to set charset and pitchandfamily
		_CF._bCharSet = (BYTE)Value;
		_CF._bPitchAndFamily = (BYTE)(Value >> 8);
		return FormatSetter(CFM_CHARSET);
	}
	return SetParameter((long *)&_CF._lcid, CFM_LCID, 4, Value);
}

/*
 *	ITextFont::SetName(BSTR Name) 
 *
 *	@mfunc
 *		Property put method that sets the font name to Name.
 *
 *	@rdesc
 *		HRESULT = (Name too long) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetName(
	BSTR Name)		//@parm New font name
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetName");

	LONG cch = SysStringLen(Name);

	if(cch > LF_FACESIZE)
		return E_INVALIDARG;

	if(!cch)									// NINCH
		return NOERROR;

	_CF._iFont = GetFontNameIndex(Name);
	_CF._bCharSet = GetFirstAvailCharSet(GetFontSignatureFromFace(_CF._iFont));

	return FormatSetter(CFM_FACE + CFM_CHARSET);
}

/*
 *	ITextFont::SetOutline(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the outline state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetOutline (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetOutline");

	return EffectSetter(Value, CFM_OUTLINE, CFE_OUTLINE);
}

/*
 *	ITextFont::SetPosition(float Value) 
 *
 *	@mfunc
 *		Property set method that sets the character position
 *		relative to the baseline. The value is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetPosition (
	float Value)		//@parm New value of relative vertical position
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetPosition");

	return SetParameter((long *)&_CF._yOffset, CFM_OFFSET, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetProtected(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the protected state according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtFont::SetProtected (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetProtected");

	return EffectSetter(Value, CFM_PROTECTED, CFE_PROTECTED);
}

/*
 *	ITextFont::SetShadow(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the shadow state according to
 *		the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetShadow (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetShadow");

	return EffectSetter(Value, CFM_SHADOW, CFE_SHADOW);
}

/*
 *	ITextFont::SetSize(float Value) 
 *
 *	@mfunc
 *		Property put method that sets the font size = Value (in
 *		floating-point points).
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSize (
	float Value)		//@parm New font size to use
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSize");

	return SetParameter((long *)&_CF._yHeight, CFM_SIZE, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetSmallCaps(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the SmallCaps state according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSmallCaps (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSmallCaps");

	return EffectSetter(Value, CFM_ALLCAPS | CFM_SMALLCAPS, CFE_SMALLCAPS);
}

/*
 *	ITextFont::SetSpacing(float Value) 
 *
 *	@mfunc
 *		Property set method that sets the intercharacter spacing,
 *		which is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSpacing (
	float Value)		//@parm New value of intercharacter spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSpacing");

	return SetParameter((long *)&_CF._sSpacing, CFM_SPACING, -2, *(long *)&Value);
}

/*
 *	ITextFont::SetStrikeThrough(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the StrikeThrough state
 *		according to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetStrikeThrough (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetStrikeThrough");

	return EffectSetter(Value, CFM_STRIKEOUT, CFE_STRIKEOUT);
}

/*
 *	ITextFont::SetStyle(long Value)
 *
 *	@mfunc
 *		Property put method that sets the character style handle for
 *		the characters in a range.  See GetStyle() for further discussion.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetStyle (
	long Value)		//@parm New character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetStyle");

	if(Value == tomUndefined)
		return NOERROR;

	if(Value < -32768 || Value > 32767)
		return E_INVALIDARG;

	return SetParameter((long *)&_CF._sStyle, CFM_STYLE, 2, Value);
}

/*
 *	ITextFont::SetSubscript(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the subscript state according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSubscript (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSubscript");

	return EffectSetter(Value, CFM_SUBSCRIPT | CFM_SUPERSCRIPT, CFE_SUBSCRIPT);
}

/*
 *	ITextFont::SetSuperscript(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the superscript state
 *		according to the value given by Value
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetSuperscript (
	long Value)		//@parm New value. Default value: tomToggle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetSuperscript");

	return EffectSetter(Value, CFM_SUBSCRIPT | CFM_SUPERSCRIPT, CFE_SUPERSCRIPT);
}

/*
 *	ITextFont::SetUnderline(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the underline style according
 *		to the value given by Value.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetUnderline (
	long Value)		//@parm New value of underline type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetUnderline");

	_CF._bUnderlineType = 0;					// Default no underline type
	if(Value < 0)								// tomTrue, tomUndefined, or
		return EffectSetter(Value, CFM_UNDERLINETYPE | CFM_UNDERLINE, CFE_UNDERLINE);

	if(Value > 255)								// Illegal underline type
		return E_INVALIDARG;

	_CF._bUnderlineType = (BYTE)Value;
	_CF._dwEffects &= ~CFM_UNDERLINE;			// Default underlining is off
	if(Value)
		_CF._dwEffects |= CFM_UNDERLINE;		// It's on
	
	return FormatSetter(CFM_UNDERLINETYPE + CFM_UNDERLINE);
}

/*
 *	ITextFont::SetWeight(long Value)
 *
 *	@mfunc
 *		Property put method that sets the font weight for
 *		the characters in a range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtFont::SetWeight (
	long Value)		//@parm New character style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFont::SetWeight");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	if((unsigned)Value > 900)					// Valid values satisfy:
		return E_INVALIDARG;					//  0 <= Value <= 900

	return SetParameter((long *)&_CF._wWeight, CFM_WEIGHT, 2, Value);
}


//------------------------------- CTxtPara ------------------------------------

/*
 *	CTxtPara::CTxtPara(prg)
 *
 *	@mfunc
 *		Constructor
 */
CTxtPara::CTxtPara(CTxtRange *prg) : CTxtFormat(prg)
{
	Assert(!_dwMask && !_PF._dwBorderColor); // We assume that object is zeroed (new'd)
	_PF._iTabs = -1;
}

/*
 *	CTxtPara::~CTxtPara()
 *
 *	@mfunc
 *		Destructor
 */
CTxtPara::~CTxtPara()
{
	Assert(_PF._iTabs == -1);
}


//------------------------- CTxtPara IUnknown Methods -------------------------------------

/*	CTxtPara::IUnknown methods
 *
 *		See tomdoc.cpp for comments
 */
STDMETHODIMP CTxtPara::QueryInterface (REFIID riid, void **ppv)
{
#ifndef PEGASUS
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::QueryInterface");

	return ::QueryInterface(riid, IID_ITextPara, this, ppv, IsZombie());
#else
	return 0;
#endif
}

STDMETHODIMP_(ULONG) CTxtPara::AddRef()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::AddRef");

 	return ++_cRefs;
}

STDMETHODIMP_(ULONG) CTxtPara::Release()
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::Release");

	_cRefs--;

	if(!_cRefs)
	{
		delete this;
		return 0;
	}
	return _cRefs;
}


//------------------------- CTxtPara IDispatch Methods -------------------------------------

/*
 *	CTxtPara::GetTypeInfoCount(pcTypeInfo)
 *
 *	@mfunc
 *		Get the number of TYPEINFO elements (1)
 *
 *	@rdesc
 *		HRESULT = (pcTypeInfo) ? NOERROR : E_INVALIDARG;
 */
STDMETHODIMP CTxtPara::GetTypeInfoCount (
	UINT * pcTypeInfo)			//@parm Out parm to receive type-info count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTypeInfoCount");

	if(!pcTypeInfo)
		return E_INVALIDARG;

	*pcTypeInfo = 1;
	return NOERROR;
}

/*
 *	CTxtPara::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *	@mfunc
 *		Return ptr to type information object for ITextPara interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtPara::GetTypeInfo (
	UINT		iTypeInfo,		//@parm Index of type info to return
	LCID		lcid,			//@parm Local ID of type info
	ITypeInfo **ppTypeInfo)		//@parm Out parm to receive type info
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTypeInfo");

	return ::GetTypeInfo(iTypeInfo, g_pTypeInfoPara, ppTypeInfo);
}

/*
 *	CTxtPara::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *	@mfunc
 *		Get DISPIDs for ITextPara methods and properties
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtPara::GetIDsOfNames (
	REFIID		riid,			//@parm Interface ID to interpret names for
	OLECHAR **	rgszNames,		//@parm Array of names to be mapped
	UINT		cNames,			//@parm Count of names to be mapped
	LCID		lcid,			//@parm Local ID to use for interpretation
	DISPID *	rgdispid)		//@parm Out parm to receive name mappings
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetIDsOfNames");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	return g_pTypeInfoPara->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

/*
 *	CTxtPara::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *					  pvarResult, pexcepinfo, puArgError)
 *	@mfunc
 *		Invoke methods for the ITextPara interface
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CTxtPara::Invoke (
	DISPID		dispidMember,	//@parm Identifies member function
	REFIID		riid,			//@parm Pointer to interface ID
	LCID		lcid,			//@parm Locale ID for interpretation
	USHORT		wFlags,			//@parm Flags describing context of call
	DISPPARAMS *pdispparams,	//@parm Ptr to method arguments
	VARIANT *	pvarResult,		//@parm Out parm for result (if not NULL)
	EXCEPINFO * pexcepinfo,		//@parm Out parm for exception info
	UINT *		puArgError)		//@parm Out parm for error
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::Invoke");

	HRESULT hr = GetTypeInfoPtrs();				// Ensure TypeInfo ptrs are OK
	if(hr != NOERROR)
		return hr;
		
	if(IsZombie())
		return CO_E_RELEASED;
				
	return g_pTypeInfoPara->Invoke(this, dispidMember, wFlags,
							 pdispparams, pvarResult, pexcepinfo, puArgError);
}

//------------------------ CTxtPara ITextPara Methods -------------------------------------

/*
 *	ITextPara::AddTab(float tbPos, long tbAlign, long tbLeader) 
 *
 *	@mfunc
 *		Method that adds a tab at the displacement tbPos, with type
 *		tbAlign, and leader style tbLeader.  The displacement is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::AddTab (
	float	tbPos,			//@parm New tab displacement
	long	tbAlign,		//@parm New tab type
	long	tbLeader)		//@parm New tab style
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::AddTab");

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(hr != NOERROR)
		return hr;							// Must be a zombie

	//This doesn't seem correct because it doesn't ever look at whether or not
	//we are in a table.
	hr = _PF.AddTab(FPPTS_TO_TWIPS(tbPos), tbAlign, tbLeader, FALSE, &_rgxTabs[0]);
	if(hr != NOERROR)
		return hr;

	return FormatSetter(PFM_TABSTOPS);
}

/*
 *	ITextPara::CanChange(long * pbCanChange) 
 *
 *	@mfunc
 *		Method that sets *pbCanChange = tomTrue if and only if the
 *		paragraph formatting can be changed.
 *
 *	@rdesc
 *		HRESULT = (can change char format) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::CanChange (
	long *pbCanChange)		//@parm Out parm to receive boolean value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::CanChange");

	return CTxtFormat::CanChange(pbCanChange, ParaFormat);
}

/*
 *	ITextPara::ClearAllTabs() 
 *
 *	@mfunc
 *		Method that clears all tabs, reverting to equally spaced
 *		tabs with the default tab spacing.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::ClearAllTabs() 
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::ClearAllTabs");

	_PF._bTabCount = 0;						// Signal to use default tab
	return FormatSetter(PFM_TABSTOPS);
}

/*
 *	ITextPara::DeleteTab(tbPos) 
 *
 *	@mfunc
 *		Delete any tab at the displacement tbPos.  This displacement is
 *		given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::DeleteTab (
	float tbPos)		//@parm Displacement at which tab should be deleted
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::DeleteTab");

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(hr != NOERROR)
		return hr;							// Must be a zombie

	hr = _PF.DeleteTab(FPPTS_TO_TWIPS(tbPos), &_rgxTabs[0]);
	return hr != NOERROR ? hr : FormatSetter(PFM_TABSTOPS);
}

/*
 *	ITextPara::GetAlignment(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the current paragraph
 *		alignment value
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetAlignment (
	long *pValue)		//@parm Out parm to receive paragraph alignment
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetAlignment");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(_PF._bAlignment > ARRAY_SIZE(g_rgREtoTOMAlign))	// Fix bogus value since
		_PF._bAlignment = 0;				//  array lookup can't use it

	*pValue = (_dwMask & PFM_ALIGNMENT)
			? (LONG)g_rgREtoTOMAlign[_PF._bAlignment] : tomUndefined;

	return hr;
}

/*
 *	ITextPara::GetHyphenation(long *pValue)
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		suppress hyphenation for the paragraph in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetHyphenation (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetHyphenation");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = EffectGetter(pValue, PFM_DONOTHYPHEN);

	//Oh well, Word inverted meaning after we shipped...
	if(*pValue == tomTrue)
		*pValue = tomFalse;

	else if(*pValue == tomFalse)
		*pValue = tomTrue;

	return hr;
}

/*
 *	ITextPara::GetDuplicate(ITextPara **ppPara) 
 *
 *	@mfunc
 *		Property get method that gets a clone of this text paragraph
 *		format object.
 *
 *	@rdesc
 *		HRESULT = (!ppPara) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::GetDuplicate (
	ITextPara **ppPara)		//@parm Out parm to receive ITextPara clone
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetDuplicate");

	if(!ppPara)
		return E_INVALIDARG;

	*ppPara = NULL;

	if(IsZombie())
		return CO_E_RELEASED;
				
	CTxtPara *pPara = new CTxtPara(NULL);	// NULL creates a clone
	if(!pPara)								//  (its _prg is NULL)
		return E_OUTOFMEMORY;

	if(_prg)
		UpdateFormat();

	*pPara  = *this;						// Copy value of this object
	pPara->_prg = NULL;						// It's not attached to a rg
	*ppPara = pPara;						// Return ptr to clone
	return NOERROR;
}

/*
 *	ITextPara::GetFirstLineIndent(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to indent the
 *		first line of a paragraph relative to the left indent, which is used
 *		for subsequent lines.  The amount is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetFirstLineIndent (
	float *pValue)		//@parm Out parm to receive first-line indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetFirstLineIndent");

	HRESULT hr = GetParameter(&_PF._dxOffset, PFM_OFFSET, -4, (long *)pValue);
	if(hr == NOERROR && *pValue != tomFloatUndefined)
		*pValue = -*pValue;						// Defined as negative of
	return hr;									//  RichEdit dxOffset
}

/*
 *	ITextPara::GetKeepTogether(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		keep the lines in a range together.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetKeepTogether (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetKeepTogether");

	return EffectGetter(pValue, PFM_KEEP);
}

/*
 *	ITextPara::GetKeepWithNext(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		keep the paragraphs in this range together.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetKeepWithNext (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetKeepWithNext");

	return EffectGetter(pValue, PFM_KEEPNEXT);
}

#define	PFM_LEFTINDENT (PFM_STARTINDENT + PFM_OFFSET)

/*
 *	ITextPara::GetLeftIndent(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to indent all
 *		but the first line of a paragraph.  The amount is given in
 *		floating-point points and is relative to the left margin.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 *
 *	@devnote
 *		For the TOM left indent to be defined, both the RichEdit start
 *		indent and the offset must be defined (see XOR and AND in *pValue
 *		code).
 */
STDMETHODIMP CTxtPara::GetLeftIndent (
	float *pValue)		//@parm Out parm to receive left indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetLeftIndent");

	if(!pValue)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	*pValue = ((_dwMask ^ PFM_LEFTINDENT) & PFM_LEFTINDENT)
			? tomFloatUndefined
			: TWIPS_TO_FPPTS(_PF._dxStartIndent + _PF._dxOffset);

	return hr;
}

/*
 *	ITextPara::GetLineSpacing(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the line spacing value, which
 *		is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetLineSpacing (
	float *pValue)		//@parm Out parm to receive line spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetLineSpacing");

	return GetParameter(&_PF._dyLineSpacing, PFM_LINESPACING, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetLineSpacingRule(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the line-spacing rule for this range
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetLineSpacingRule (
	long *pValue)		//@parm Out parm to receive line spacing rule
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetLineSpacingRule");

	return GetParameter((long *)&_PF._bLineSpacingRule, PFM_LINESPACING,
						1, pValue);
}

/*
 *	ITextPara::GetListAlignment(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the kind of bullet/numbering text
 *		alignment to use with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListAlignment(
	long * pValue)		//@parm Out parm to receive numbering alignment
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListAlignment");

	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, pValue);
	if(hr == NOERROR && *pValue != tomUndefined)
		*pValue &= 3;						// Kill all but alignment bits

	return hr;
}

/*
 *	ITextPara::GetListLevelIndex(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the list level index to use
 *		with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListLevelIndex(
	long * pValue)		//@parm Out parm to receive list level index
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListLevelIndex");

	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, pValue);
	if(hr == NOERROR)
		*pValue = (*pValue >> 4) & 0xf;		// Kill all but list level index
	return hr;
}

/*
 *	ITextPara::GetListStart(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the numbering start value to use
 *		with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListStart(
	long * pValue)			//@parm Out parm to receive numbering start value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListSpace");

	return GetParameter((long *)&_PF._wNumberingStart, PFM_NUMBERINGSTART, 2,
						pValue);
}

/*
 *	ITextPara::GetListTab(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the distance between the first indent
 *		and the start of text on the first line.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetListTab(
	float * pValue)			//@parm Out parm to receive list tab to text
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListTab");

	return GetParameter((long *)&_PF._wNumberingTab, PFM_NUMBERINGTAB, -2,
						(long *)pValue);
}

/*
 *	ITextPara::GetListType(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the type of list to use
 *		with paragraphs.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 *
 *	@devnote
 *		TOM's values are:
 *
 *		List Type		Value	Meaning
 *		tomNoList			0		Turn off paragraph numbering
 *		tomListBullet		1		default is bullet
 *		tomNumberAsArabic	2		0, 1, 2, ...
 *		tomNumberAsLCLetter	3		a, b, c, ...
 *		tomNumberAsUCLetter	4		A, B, C, ...
 *		tomNumberAsLCRoman	5		i, ii, iii, ...
 *		tomNumberAsUCRoman	6		I, II, III, ...
 *		tomNumberAsSequence	7		ListStart is 1st Unicode to use
 *
 *		Nibble 2 of _PF._wNumberingStyle says whether to number with trailing
 *		parenthesis, both parentheses, follow by period, or leave plain. This
 *		This nibble needs to be returned in nibble 4 of *pValue.
 */
STDMETHODIMP CTxtPara::GetListType (
	long *pValue)		//@parm Out parm to receive type of list
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetListType");

	HRESULT hr = GetParameter((long *)&_PF._wNumbering,
								PFM_NUMBERING, 2, pValue);

	// OR in Number style bits (see note above)
	if(hr == NOERROR && *pValue != tomUndefined) 
		*pValue |= (_PF._wNumberingStyle << 8) & 0xf0000;
	return hr;
}

/*
 *	ITextPara::GetNoLineNumber(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		suppress line numbering for the paragraphs in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetNoLineNumber (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetNoLineNumber");

	return EffectGetter(pValue, PFM_NOLINENUMBER);
}

/*
 *	ITextPara::GetPageBreakBefore(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		eject the page before the paragraphs in this range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetPageBreakBefore (
	long *pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetPageBreakBefore");

	return EffectGetter(pValue, PFM_PAGEBREAKBEFORE);
}

/*
 *	ITextPara::GetRightIndent(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to indent the
 *		right margin of a paragraph relative to the right margin.  The
 *		amount is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetRightIndent (
	float *pValue)		//@parm Out parm to receive right indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetRightIndent");

	return GetParameter(&_PF._dxRightIndent, PFM_RIGHTINDENT, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetSpaceAfter(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to space vertically
 *		after a paragraph.  The amount is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetSpaceAfter (
	float *pValue)		//@parm Out parm to receive space-after value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetSpaceAfter");

	return GetParameter(&_PF._dySpaceAfter, PFM_SPACEAFTER, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetSpaceBefore(float * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the amount used to space vertically
 *		before starting a paragraph.  The amount is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetSpaceBefore (
	float *pValue)		//@parm Out parm to receive space-before value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetSpaceBefore");

	return GetParameter(&_PF._dySpaceBefore, PFM_SPACEBEFORE, -4,
						(long *)pValue);
}

/*
 *	ITextPara::GetStyle(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the style handle for the
 *		paragraphs in this range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetStyle (
	long *	pValue)		//@parm Out parm to receive paragraph style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetStyle");

	return GetParameter((long *)&_PF._sStyle, PFM_STYLE, 2, pValue);
}

/*
 *	ITextPara::GetTab(long iTab, float *ptbPos, long *ptAlign, long *ptbLeader) 
 *
 *	@mfunc
 *		Method that gets tab parameters for the iTab th tab, that
 *		is, set *ptbPos, *ptbAlign, and *ptbLeader equal to the iTab th
 *		tab's displacement, alignment, and leader style, respectively. 
 *		iTab has special values defined in the table below.  The
 *		displacement is given in floating-point points.
 *
 *	@rdesc
 *		HRESULT = (!pdxptab || !ptbt || !pstyle || no iTab tab) ?
 *				  E_INVALIDARG : (exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::GetTab (
	long	iTab,			//@parm Index of tab to retrieve info for
	float *	ptbPos,			//@parm Out parm to receive tab displacement
	long *	ptbAlign,		//@parm Out parm to receive tab type
	long *	ptbLeader)		//@parm Out parm to receive tab style
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTab");

	if(!ptbPos || !ptbAlign || !ptbLeader)
		return E_INVALIDARG;

	*ptbAlign = *ptbLeader = 0;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	if(!(_dwMask & PFM_TABSTOPS))			// Tabs are undefined (more than
	{										//  one set of definitions)
		*ptbPos = tomFloatUndefined;
		return hr;
	}

	LONG dxTab = 0;							// Default 0 in case GetTab fails

	if(iTab < 0 && iTab >= tomTabBack)		// Save *ptbPos if it's supposed
		dxTab = FPPTS_TO_TWIPS(*ptbPos);	//  be used (in general might get
											//  floating-point error)
	hr = _PF.GetTab(iTab, &dxTab, ptbAlign, ptbLeader, &_rgxTabs[0]);
	*ptbPos = TWIPS_TO_FPPTS(dxTab);

	return (hr == NOERROR && !dxTab) ? S_FALSE : hr;
}

/*
 *	ITextPara::GetTabCount(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tab count.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetTabCount (
	long *	pValue)		//@parm Out parm to receive tab count
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetTabCount");

	return GetParameter((long *)&_PF._bTabCount, PFM_TABSTOPS, 1, pValue);
}

/*
 *	ITextPara::GetWidowControl(long * pValue) 
 *
 *	@mfunc
 *		Property get method that gets the tomBool for whether to
 *		control widows and orphans for the paragraphs in a range.
 *
 *	@rdesc
 *		HRESULT = (!pValue) ? E_INVALIDARG : NOERROR;
 */
STDMETHODIMP CTxtPara::GetWidowControl (
	long *	pValue)		//@parm Out parm to receive tomBool
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::GetWidowControl");

	return EffectGetter(pValue, PFM_NOWIDOWCONTROL);
}

/*
 *	ITextPara::IsEqual(ITextPara * pPara, long * pB) 
 *
 *	@mfunc
 *		Method that sets pB = tomTrue if this range has the same
 *		properties as *pPara. The IsEqual() method ignores entries for which
 *		either para object has a tomUndefined value.
 *
 *	@rdesc
 *		HRESULT = (equal objects) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtPara::IsEqual (
	ITextPara *	pPara,		//@parm ITextPara to compare to
	long *		pB)			//@parm Out parm to receive comparison result
{
#ifndef PEGASUS	
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::IsEqual");

	if(pB)
		*pB = tomFalse;

	if(!IsSameVtables(this, pPara))
		return S_FALSE;

	HRESULT hr = UpdateFormat();			// Update _PFs in case they are
	if(hr != NOERROR)						//  attached to ranges
		return hr;

	CTxtPara *pP = (CTxtPara *)pPara;
	hr = pP->UpdateFormat();
	if(hr != NOERROR)
		return hr;

	CParaFormat *pPF = &(pP->_PF); 
	DWORD		 dwMask = pP->_dwMask;		// Save mask

	if(_dwMask != dwMask)					// The two have to be the same
		return S_FALSE;						//  for equality

	if((dwMask & PFM_TABSTOPS) && _PF._bTabCount)
	{
		_PF._iTabs = GetTabsCache()->Cache(&_rgxTabs[0], _PF._bTabCount);
		if(pP != this)						// If comparing to self,
		{									//  don't AddRef twice
			pP->_PF._iTabs = GetTabsCache()->Cache(&pP->_rgxTabs[0],
												   pPF->_bTabCount);
		}
	}
	if(dwMask & _PF.Delta(pPF, FALSE))		// Any difference?
		hr = S_FALSE;						// Yes. *pB set equal to tomFalse above
	else if(pB)
		*pB = tomTrue;

	CheckTabsAddRef();
	pP->CheckTabsAddRef();

#endif
	return hr;
}

/*
 *	ITextPara::Reset(long Value) 
 *
 *	@mfunc
 *		Method that resets the paragraph formatting to the default
 *		values to 1) those defined by the RTF \pard control word (Value =
 *		tomDefault), and 2) all undefined values (Value = tomUndefined). 
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::Reset (
	long Value)		//@parm Kind of reset (tomDefault or tomUndefined)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::Reset");

	Assert(tomApplyLater == tomApplyNow + 1);

	HRESULT hr = CanChange(NULL);

	if(hr != NOERROR)								// Takes care of zombie
		return hr;									//  and protection

	if(Value == tomDefault)
	{
		if(_prg)
		{
			_PF = *_prg->GetPed()->GetParaFormat(-1);
			if(_PF._iTabs != -1)
			{
				const LONG *prgxTabs = _PF.GetTabs();
				_PF._iTabs = -1;
				for(LONG i = 0; i < _PF._bTabCount; i++)
					_rgxTabs[i] = prgxTabs[i];
			}
			FormatSetter(PFM_ALL2);
		}
		else
			_PF.InitDefault(0);
		_dwMask = PFM_ALL2;
	}
	else if(Value == tomUndefined && 			// Only applicable for clones
		(!_prg || _fApplyLater))				//  or delayed application
	{
		_dwMask = 0;							
	}
	else if((Value | 1) == tomApplyLater)		// Set-method optimization
	{
		_fApplyLater = Value & 1;
		if(!_fApplyLater)						// Apply now
			FormatSetter(_dwMask);
	}
	else if((Value | 1) == tomCacheParms)		// Get-method optimization
	{
		_fCacheParms = FALSE;
		if(Value & 1)							// Cache parms now, but
		{										//  don't update on gets
			UpdateFormat();							
			_fCacheParms = TRUE;
		}
	}
	else
		return E_INVALIDARG;

	return NOERROR;
}

/*
 *	ITextPara::SetAlignment(long Value) 
 *
 *	@mfunc
 *		Property put method that sets the paragraph alignment to Value
 *
 *	@rdesc
 *		HRESULT = (Value > 3) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetAlignment (
	long Value)		//@parm New paragraph alignment
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetAlignment");

	if(Value == tomUndefined)					// NINCH
		return NOERROR;

	if((DWORD)Value >= ARRAY_SIZE(g_rgTOMtoREAlign))
		return E_INVALIDARG;

	_PF._bAlignment = g_rgTOMtoREAlign[Value];
	
	return FormatSetter(PFM_ALIGNMENT);
}

/*
 *	ITextPara::SetHyphenation(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls the
 *		suppression of hyphenation for the paragraphs in the range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetHyphenation (
	long Value)		//@parm New tomBool for suppressing hyphenation
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetHyphenation");

	if(Value == tomTrue)			// Invert meaning for RichEdit
		Value = tomFalse;			// Word inverted it late in the game...

	else if (Value == tomFalse)
		Value = tomTrue;

	return EffectSetter(Value, PFM_DONOTHYPHEN);
}

/*
 *	ITextPara::SetDuplicate(ITextPara *pPara) 
 *
 *	@mfunc
 *		Property put method that applies the paragraph formatting of pPara
 *		to this para object.  Note that tomUndefined values in pPara have
 *		no effect (NINCH - NoInputNoCHange).
 *
 *	@rdesc
 *		HRESULT = (!pPara) ? E_INVALIDARG : 
 *				  (if success) ? NOERROR :
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetDuplicate (
	ITextPara *pPara)		//@parm New paragraph formatting
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetDuplicate");

	DWORD		dwMask = 0;
	long		iTab;
	CTxtRange *	prg;
	long		tbAlign;
	long		tbLeader;
	float		tbPos;
	long		Value;
	float		x, y, z;

	if(IsZombie())							// Check for range zombie
		return CO_E_RELEASED;

	if(IsSameVtables(this, pPara))			// If pPara belongs to this TOM
	{										//  engine, cast and copy
		((CTxtPara *)pPara)->UpdateFormat();// Since this TOM engine, can
		_PF = ((CTxtPara *)pPara)->_PF;		//  cast to a CTxtPara
		dwMask = ((CTxtPara *)pPara)->_dwMask;// Use this mask in case this 			
	}										//  para is active
	else
	{										// Need to call pFont for all para
		prg = _prg;							//  properties
		_prg = NULL;						// Turn into clone during transfer

		pPara->GetStyle(&Value);
		SetStyle(Value);

		pPara->GetAlignment(&Value);
		SetAlignment(Value);

		pPara->GetHyphenation(&Value);
		SetHyphenation(Value);

		pPara->GetKeepTogether(&Value);
		SetKeepTogether(Value);

		pPara->GetKeepWithNext(&Value);
		SetKeepWithNext(Value);

		pPara->GetFirstLineIndent(&x);
		pPara->GetLeftIndent (&y);
		pPara->GetRightIndent(&z);
		SetIndents(x, y, z);

		pPara->GetLineSpacingRule(&Value);
		pPara->GetLineSpacing(&y);
		SetLineSpacing(Value, y);

		pPara->GetNoLineNumber(&Value);
		SetNoLineNumber(Value);

		pPara->GetListAlignment(&Value);
		SetListAlignment(Value);

		pPara->GetListLevelIndex(&Value);
		SetListLevelIndex(Value);

		pPara->GetListStart(&Value);
		SetListStart(Value);

		pPara->GetListTab(&x);
		SetListTab(x);

		pPara->GetListType(&Value);
		SetListType(Value);

		pPara->GetPageBreakBefore(&Value);
		SetPageBreakBefore(Value);

		pPara->GetSpaceBefore(&y);
		SetSpaceBefore(y);

		pPara->GetSpaceAfter(&y);
		SetSpaceAfter(y);

		pPara->GetWidowControl(&Value);
		SetWidowControl(Value);

		ClearAllTabs();
		pPara->GetTabCount(&Value);
		for(iTab = 0; iTab < Value; iTab++)
		{
			pPara->GetTab(iTab, &tbPos, &tbAlign, &tbLeader);
			AddTab(tbPos, tbAlign, tbLeader);
		}
		_prg = prg;							// Restore original value
	}
	return FormatSetter(dwMask);			// Apply it unless !_prg
}

/*
 *	ITextPara::SetKeepTogether(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to keep the lines in a range together.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetKeepTogether (
	long Value)		//@parm New tomBool for keeping lines together
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetKeepTogether");

	return EffectSetter(Value, PFM_KEEP);
}

/*
 *	ITextPara::SetKeepWithNext(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to keep the paragraphs in a range together.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetKeepWithNext (
	long Value)		//@parm New tomBool for keeping paragraphs together
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetKeepWithNext");

	return EffectSetter(Value, PFM_KEEPNEXT);
}

/*
 *	ITextPara::SetIndents(float First, float Left, float Right) 
 *
 *	@mfunc
 *		Method that sets the left indent of all but the first line
 *		of a paragraph equal to Left and sets the displacement of the first
 *		line of a paragraph relative to the left indent equal to First.  The
 *		left indent value is relative to the left margin. You can also set
 *		the right indent by giving the optional Right parameter a value (the
 *		(default is tomUndefined).  All indents are given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_INVALIDARG
 */
STDMETHODIMP CTxtPara::SetIndents (
	float First,	//@parm New first indent (1st-line offset relative to left indent)
	float Left,		//@parm New left indent (left offset of all but 1st line)
	float Right)	//@parm New right indent (right offset of all lines)
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetIndents");

	DWORD	dwMask	= 0;
	LONG	j = (First != tomFloatUndefined) + (Left == tomFloatUndefined);

	if(IsZombie())
		return CO_E_RELEASED;

	if(j < 2)										// At least First or Left
	{												//  defined
		if(j == 1)									// Only one defined: need
			UpdateFormat();							//  current _PF._dxOffset

		if(First != tomFloatUndefined)
		{
			j = FPPTS_TO_TWIPS(First);				
	 		if(Left == tomFloatUndefined)			
			{
				_PF._dxStartIndent += _PF._dxOffset	// Cancel current offset
					+ j;							//  and add in new one
			}
			_PF._dxOffset = -j;						// Offset for all but 1st
			dwMask = PFM_OFFSET + PFM_STARTINDENT;	//  line
		} 
 		if(Left != tomFloatUndefined)
		{
			_PF._dxStartIndent =  FPPTS_TO_TWIPS(Left) - _PF._dxOffset;
			dwMask |= PFM_STARTINDENT;
		}
	}

	if(Right != tomFloatUndefined)
	{
		_PF._dxRightIndent = FPPTS_TO_TWIPS(Right);
		dwMask |= PFM_RIGHTINDENT;
	}

	return dwMask ? FormatSetter(dwMask) : NOERROR;
}

/*
 *	ITextPara::SetLineSpacing(long Rule, float Spacing) 
 *
 *	@mfunc
 *		Method that sets the paragraph line spacing rule to Rule and
 *		the line spacing to Spacing. If the line spacing rule treats the
 *		Spacing value as a linear dimension, then that dimension is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetLineSpacing (
	long	Rule,		//@parm Value of new line-spacing rule
	float	Spacing)	//@parm Value of new line spacing
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetLineSpacing");

 	LONG j = (Rule == tomUndefined) + (Spacing == tomFloatUndefined);

	if(j == 2)
		return NOERROR;

	if(j == 1 || (DWORD)Rule > 5 || Spacing < 0)
		return E_INVALIDARG;

	_PF._bLineSpacingRule = (BYTE)Rule;			// Default as if both are OK
	_PF._dyLineSpacing	 = (SHORT)FPPTS_TO_TWIPS(Spacing);

	return FormatSetter(PFM_LINESPACING);
}

/*
 *	ITextPara::SetListAlignment (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the kind of List alignment to be
 *		used for paragraphs.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListAlignment(
	long Value)		//@parm Value of new list alignment
{
	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > tomAlignRight)
		return E_INVALIDARG;

	long	Style;
	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, &Style);
	if(hr != NOERROR)
		return hr;

	return SetParameter((long *)&_PF._wNumberingStyle, PFM_NUMBERINGSTYLE,
						2, (Style & ~3) | (Value & 3));
}

/*
 *	ITextPara::SetListLevelIndex (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the kind of list level index to be
 *		used for paragraphs.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListLevelIndex(
	long Value)
{
	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > 15)
		return E_INVALIDARG;

	long	Style;
	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, &Style);
	if(hr != NOERROR)
		return hr;

	return SetParameter((long *)&_PF._wNumberingStyle, PFM_NUMBERINGSTYLE,
						2, (Style & ~0xf0) | (Value << 4));
}

/*
 *	ITextPara::SetListStart (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the starting number to use for
 *		paragraph numbering
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListStart(
	long Value)		//@parm New numbering start value
{
	if(Value == tomUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter((long *)&_PF._wNumberingStart, PFM_NUMBERINGSTART,
						2, Value);
}

/*
 *	ITextPara::SetListTab (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the distance between the first indent
 *		and the start of text on the first line.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListTab(
	float Value)		//@parm New numbering tab value
{
	if(Value == tomFloatUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter((long *)&_PF._wNumberingTab, PFM_NUMBERINGTAB,
						-2, *(long *)&Value);
}

/*
 *	ITextPara::SetListType (long Value) 
 *
 *	@mfunc
 *		Property put method that sets the kind of List to be
 *		used for paragraphs.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetListType (
	long Value)		//@parm New List code
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetListType");

	if(Value == tomUndefined)
		return NOERROR;

	if((unsigned)Value > 0xf0000)
		return E_INVALIDARG;

	long	Style;
	HRESULT hr = GetParameter((long *)&_PF._wNumberingStyle,
								PFM_NUMBERINGSTYLE, 2, &Style);
	if(hr != NOERROR)
		return hr;

	_PF._wNumbering		= (WORD)Value;
	_PF._wNumberingStyle = (WORD)((Style & ~0xf00) | ((Value >> 8) & 0xf00));

	return FormatSetter(PFM_NUMBERING | PFM_NUMBERINGSTYLE);
}

/*
 *	ITextPara::SetNoLineNumber (long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to suppress the numbering of paragraphs in a range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetNoLineNumber (
	long Value)		//@parm New tomBool for suppressing line numbering
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetNoLineNumber");

	return EffectSetter(Value, PFM_NOLINENUMBER);
}

/*
 *	ITextPara::SetPageBreakBefore (long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls
 *		whether to eject the page before each paragraph in a range.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetPageBreakBefore (
	long Value)		//@parm New tomBool for ejecting page before paragraphs
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetPageBreakBefore");

	return EffectSetter(Value, PFM_PAGEBREAKBEFORE);
}

/*
 *	ITextPara::SetRightIndent (float Value) 
 *
 *	@mfunc
 *		Property put method that sets the amount to indent the right
 *		margin of paragraph equal to Value, which is given in floating-point
 *		points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetRightIndent (
	float Value)		//@parm New right indent
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetRightIndent");

	return SetParameter(&_PF._dxRightIndent, PFM_RIGHTINDENT, -4,
						*(long *)&Value);
}

/*
 *	ITextPara::SetSpaceAfter(float Value) 
 *
 *	@mfunc
 *		Property put method that sets the amount to space vertically
 *		after finishing a paragraph equal to Value, which is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetSpaceAfter (
	float Value)		//@parm New space-after value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetSpaceAfter");

	if(Value == tomFloatUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter(&_PF._dySpaceAfter, PFM_SPACEAFTER, -4,
						*(long *)&Value);
}

/*
 *	ITextPara::SetSpaceBefore(float Value) 
 *
 *	@mfunc
 *		Property put method that sets the amount to space vertically
 *		before starting a paragraph equal to Value, which is given in
 *		floating-point points.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetSpaceBefore (
	float Value)		//@parm New space-before value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetSpaceBefore");

	if(Value == tomFloatUndefined)
		return NOERROR;

	if(Value < 0)
		return E_INVALIDARG;

	return SetParameter(&_PF._dySpaceBefore, PFM_SPACEBEFORE, -4,
						*(long *)&Value);
}

/*
 *	ITextPara::SetStyle(long Value)
 *
 *	@mfunc
 *		Property put method that sets the paragraph style handle for
 *		the paragraphs in a range.  See GetStyle() for further discussion.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetStyle (
	long Value)		//@parm New paragraph style handle
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetStyle");

 	if(Value == tomUndefined)
		return NOERROR;

	if(Value < -32768 || Value > 32767)
		return E_INVALIDARG;

	return SetParameter((long *)&_PF._sStyle, PFM_STYLE, 2, Value);
}

/*
 *	ITextPara::SetWidowControl(long Value)
 *
 *	@mfunc
 *		Property put method that sets the tomBool that controls the
 *		suppression of widows and orphans.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : 
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtPara::SetWidowControl (
	long Value)		//@parm New tomBool for suppressing widows and orphans
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtPara::SetWidowControl");

	return EffectSetter(Value, PFM_NOWIDOWCONTROL);
}


//----------------------------- CTxtFont Helpers -------------------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtFont::EffectGetter (ptomBool, dwMask)
 *
 *	@mfunc
 *		Set *<p ptomBool> = state of bit given by the bit mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (!<p ptomBool>) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtFont::EffectGetter (
	long *	ptomBool,		//@parm Out parm to receive tomBool
	DWORD	dwMask) 		//@parm Bit mask identifying effect to retrieve
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtFont::EffectGetter");

	if(!ptomBool)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Font object, update
											//  _CF to current _prg values
	*ptomBool = !(_dwMask		& dwMask) ? tomUndefined :
				(_CF._dwEffects & dwMask) ? tomTrue : tomFalse;
	
	return hr;
}

/*
 *	CTxtFont::EffectSetter (Value, dwMask, dwEffect)
 *
 *	@mfunc
 *		Mask off this range's effect bits identified by <p dwMask> and set
 *		effect bit given by <p dwEffect> equal to value given by <p Value>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT CTxtFont::EffectSetter (
	long 	Value,		//@parm Value to set effect bit to
	DWORD	dwMask, 	//@parm Bit mask identifying effect(s) to turn off
	DWORD	dwEffect)	//@parm Effect bit to set
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtFont::EffectSetter");

	if(Value == tomUndefined)					// Do nothing (NINCH)
		return NOERROR;

	if(Value == tomToggle)
	{
		if(_prg)								// If live Font object, update
		{										//  _CF.dwEffects for toggling
			if(_prg->IsZombie())
				return CO_E_RELEASED;

			LONG iFormat = _prg->_iFormat;		// Default iFormat for IP
			LONG cch	 = _prg->GetCch();

			if(cch)								// Range is nondegenerate
			{
				CFormatRunPtr rp(_prg->_rpCF);
				if(cch > 0)						// Get iFormat at cpFirst
					rp.AdvanceCp(-cch);
				iFormat = rp.GetFormat();
			}
			_CF._dwEffects = _prg->GetPed()->GetCharFormat(iFormat)->_dwEffects;
		}
		_CF._dwEffects ^= dwEffect;			// Toggle effect(s)
		if (dwMask != dwEffect)
		{
			// Need to turn off other bits that are not being toggle
			DWORD	dwTurnOff = dwMask ^ dwEffect;
			_CF._dwEffects &= ~dwTurnOff;
		}
	}
	else
	{
		_CF._dwEffects &= ~dwMask;				// Default effect(s) off
		if(Value)
		{
			if(Value != tomTrue)
				return E_INVALIDARG;
			_CF._dwEffects |= dwEffect;			// Turn an effect on
		}
	}
	return FormatSetter(dwMask);
}

/*
 *	CTxtFont::FormatSetter (dwMask)
 *
 *	@mfunc
 *		Set this CCharFormat or _prg's with mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 *				  (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
HRESULT CTxtFont::FormatSetter (
	DWORD	 dwMask)	//@parm Mask for value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtFont::FormatSetter");

	if(_prg && !_fApplyLater)
	{
		 HRESULT hr = _prg->CharFormatSetter(&_CF, dwMask);
		 if(hr != NOERROR)
			 return hr;
	}
	_dwMask |= dwMask;						// Collect data in font clone
	return NOERROR;
}

/*
 *	CTxtFont::GetParameter (pParm, dwMask, Type, pValue)
 *
 *	@mfunc
 *		If _prg is defined (not clone), update _CF to range value.
 *		Set *pValue = *pParm unless NINCHed, in which case set it to
 *		Type < 0 ? tomFloatUndefined : tomUndefined.  |Type| gives
 *		the byte length of the pParm field.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFont::GetParameter (
	long *	pParm,		//@parm Address of _CF member to get
	DWORD	dwMask,		//@parm _CF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long *	pValue)		//@parm Out parm to receive value
{
	UpdateFormat();							// If live Font object, update
											//  _CF to current _prg values
	return CTxtFormat::GetParameter(pParm, _dwMask & dwMask, Type, pValue);
}

/*
 *	CTxtFont::SetParameter (pParm, dwMask, Type, Value)
 *
 *	@mfunc
 *		Set parameter at address pParm with mask big dwMask to the value
 *		Value performing type conversions indicated by Type
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFont::SetParameter (
	long *	pParm,		//@parm Address of _CF member to get
	DWORD	dwMask,		//@parm _CF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long 	Value)		//@parm Out parm to receive value
{
	HRESULT hr = CTxtFormat::SetParameter(pParm, Type, Value);
	return hr == NOERROR ? FormatSetter(dwMask) : hr;	
}

/*
 *	CTxtFont::UpdateFormat ()
 *
 *	@mfunc
 *		Update format if this font object is attached to a live range.
 *		Set _dwMask = 0 if attached to zombied range.
 *
 *	@rdesc
 *		HRESULT = (attached to zombied range)
 *				? CO_E_RELEASED : NOERROR
 */
HRESULT CTxtFont::UpdateFormat ()
{
	if(_prg && !_fCacheParms)
	{
		if(_prg->IsZombie())
		{
			_dwMask = 0;					// Nothing defined
			return CO_E_RELEASED;
		}
		_dwMask = _prg->GetCharFormat(&_CF);
	}
	return NOERROR;
}


//----------------------------- CTxtPara Helpers -------------------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtPara::EffectGetter (ptomBool, dwMask)
 *
 *	@mfunc
 *		Set *<p ptomBool> = state of bit given by the bit mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (!<p ptomBool>) ? E_INVALIDARG : NOERROR
 */
HRESULT CTxtPara::EffectGetter (
	long *	ptomBool,		//@parm Out parm to receive tomBool
	DWORD	dwMask) 		//@parm Bit mask identifying effect to retrieve
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPara::EffectGetter");

	if(!ptomBool)
		return E_INVALIDARG;

	HRESULT hr = UpdateFormat();			// If live Para object, update
											//  _PF to current _prg values
	*ptomBool = !(_dwMask & dwMask) ? tomUndefined :
				(_PF._wEffects & (dwMask >> 16)) ? tomTrue : tomFalse;
	return hr;
}

/*
 *	CTxtPara::EffectSetter (Value, dwMask)
 *
 *	@mfunc
 *		Set this range's effect bit as given by <p dwMask> equal to value
 *		given by <p Value>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Note that the mask bits for paragraph effects are in the high word
 *		of _dwMask, but the effects are stored in the WORD _wEffects.
 */
HRESULT CTxtPara::EffectSetter (
	long 	Value,		//@parm Value to set effect bit to
	DWORD	dwMask) 	//@parm Bit mask identifying effect to set
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPara::EffectSetter");

	if(Value == tomUndefined)					// Do nothing (NINCH)
		return NOERROR;

	DWORD dwEffects = _PF._wEffects << 16;		// Move effects over to where
												//  mask is
	if(Value == tomToggle)
	{
		if(_prg)								// If live Para object, update
		{										//  _PF._wEffects for toggling
			if(_prg->IsZombie())
				return CO_E_RELEASED;

			_dwMask = _prg->GetParaFormat(&_PF);
			dwEffects = _PF._wEffects << 16;
			_PF._iTabs = -1;					// No interest in TABs here
		}
		if(_dwMask & dwMask)					// Effect is defined:
			dwEffects ^=  dwMask;				//  toggle it
		else									// Effect is NINCHed
			dwEffects &= ~dwMask;				// Turn it all off
	}
	else
	{
		dwEffects &= ~dwMask;					// Default effect off
		if(Value)
		{
			if(Value != tomTrue)
				return E_INVALIDARG;
			dwEffects |= dwMask;				// Turn it on
		}
	}

	_PF._wEffects = (WORD)(dwEffects >> 16);
	return FormatSetter(dwMask);
}

/*
 *	CTxtPara::FormatSetter (dwMask)
 *
 *	@mfunc
 *		Set this CParaFormat or _prg's with mask <p dwMask>
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT CTxtPara::FormatSetter (
	DWORD	 dwMask)	//@parm Mask for value
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtPara::FormatSetter");

	AssertSz(_PF._iTabs < 0,
		"CTxtPara::FormatSetter: illegal tabs index");

	if(_prg && !_fApplyLater)
	{
		if(dwMask & PFM_TABSTOPS)
			_PF._iTabs = GetTabsCache()->Cache(&_rgxTabs[0], _PF._bTabCount);

		HRESULT hr = _prg->ParaFormatSetter(&_PF, dwMask);
		CheckTabsAddRef();
		if(hr != NOERROR)
			return hr;
	}
	_dwMask |= dwMask;							// Collect data in para clone
	return NOERROR;
}

/*
 *	CTxtPara::GetParameter (pParm, dwMask, Type, pValue)
 *
 *	@mfunc
 *		If _prg is defined (not clone), update _PF to range value.
 *		Set *pValue = *pParm unless NINCHed, in which case set it to
 *		Type < 0 ? tomFloatUndefined : tomUndefined.  |Type| gives
 *		the byte length of the pParm field.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtPara::GetParameter (
	long *	pParm,		//@parm Address of _PF member to get
	DWORD	dwMask,		//@parm _PF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long *	pValue)		//@parm Out parm to receive value
{
	UpdateFormat();							// If live Para object, update
											//  _PF to current _prg values
	return CTxtFormat::GetParameter(pParm, _dwMask & dwMask, Type, pValue);
}

/*
 *	CTxtPara::SetParameter (pParm, dwMask, Type, Value)
 *
 *	@mfunc
 *		Set parameter at address pParm with mask big dwMask to the value
 *		Value performing type conversions indicated by Type
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtPara::SetParameter (
	long *	pParm,		//@parm Address of _PF member to get
	DWORD	dwMask,		//@parm _PF member mask for NINCH checking
	long	Type,		//@parm # bytes of parameter or 0 for float
	long 	Value)		//@parm Out parm to receive value
{
	HRESULT hr = CTxtFormat::SetParameter(pParm, Type, Value);
	return hr == NOERROR ? FormatSetter(dwMask) : hr;	
}

/*
 *	CTxtPara::CheckTabsAddRef ()
 *
 *	@mfunc
 *		Release Tabs reference
 */
void CTxtPara::CheckTabsAddRef()
{
	if(_PF._iTabs >= 0)
	{
		GetTabsCache()->Release(_PF._iTabs);
		_PF._iTabs = -1;
	}
}

/*
 *	CTxtPara::UpdateFormat ()
 *
 *	@mfunc
 *		Update format if this para object is attached to a live range.
 *		Set _dwMask = 0 if attached to zombied range.
 *
 *	@rdesc
 *		HRESULT = (attached to zombied range)
 *				? CO_E_RELEASED : NOERROR
 */
HRESULT CTxtPara::UpdateFormat ()
{
	if(_prg && !_fCacheParms)
	{
		if(_prg->IsZombie())
		{
			_dwMask = 0;					// Nothing defined
			return CO_E_RELEASED;
		}
		_dwMask = _prg->GetParaFormat(&_PF);
		if(_PF._iTabs >= 0)
		{
			CopyMemory(_rgxTabs, GetTabsCache()->Deref(_PF._iTabs),
					   _PF._bTabCount*sizeof(LONG));
			_PF._iTabs = -1;
		}
	}
	return NOERROR;
}

//---------------------------- CTxtFormat Methods --------------------------------

/*
 *	CTxtFormat::CTxtFormat(prg)
 *
 *	@mfunc
 *		Constructor
 */
CTxtFormat::CTxtFormat(CTxtRange *prg)
{
	_cRefs	= 1;
	_prg	= prg;					// NULL for clone
	if(prg)
		prg->AddRef();
}

/*
 *	CTxtFormat::~CTxtFormat()
 *
 *	@mfunc
 *		Destructor
 */
CTxtFormat::~CTxtFormat()
{
	if(_prg)
		_prg->Release();
}

/*
 *	CTxtFormat::CanChange (pbCanChange)
 *
 *	@func
 *		Set *<p pbCanChange> = tomTRUE iff this format object can be changed
 *
 *	@rdesc
 *		HRESULT = (can change format) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		This method is shared by ITextFont and ITextPara.  If pRange is NULL,
 *		the object is a clone, i.e., unattached to a CTxtRange
 */
HRESULT CTxtFormat::CanChange (
	long *pbCanChange,		//@parm Out parm to receive boolean value
	BOOL fPara)				//@parm If TRUE, formatting is paragraphs
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtFormat::CanChange");

	LONG fCanChange = tomTrue;
	
	if(_prg)
	{
		HRESULT hr = _prg->CanEdit(pbCanChange);
		if(hr != NOERROR)						// S_FALSE or CO_E_RELEASED
			return hr;

		if(!_prg->GetPed()->IsRich() && fPara)
			fCanChange = tomFalse;
	}
	if(pbCanChange)
		*pbCanChange = fCanChange;

	return fCanChange ? NOERROR : S_FALSE;
}

/*
 *	CTxtFormat::GetParameter (pParm, fDefined, Type, pValue)
 *
 *	@mfunc
 *		Set *pValue = *pLong unless NINCHed. Perform conversions specified by
 *		Type.  If Type > 0, it is treated as length of an unsigned integer,
 *		i.e., 1, 2, or 4 bytes.  If it is negative, the output is a float
 *		and the input has a length given by |Type|, so -2 converts a WORD
 *		into a float, unless dwMask = CFM_SPACING, in which case it converts
 *		a short into a float.  -4 converts a long into a float.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFormat::GetParameter (
	long *	pParm,		//@parm Ptr to _CF or _PF member to get
	DWORD	dwMask,		//@parm Nonzero iff defined
	long	Type,		//@parm # bytes of integer parameter or 0 for float
	long *	pValue)		//@parm Out parm to receive value
{
	if(!pValue)
		return E_INVALIDARG;

	Assert(pParm && sizeof(long) == 4 && sizeof(float) == 4);

	HRESULT hr = NOERROR;

	if(IsZombie())							// Check if attached to zombied
	{										//  range
		dwMask = 0;							// Nothing defined
		hr = CO_E_RELEASED;					// Setup return for following if
	}

	if(!dwMask)								// Parameter isn't defined
	{
		if(Type < 0)
			*(float *)pValue = tomFloatUndefined;
		else
			*pValue = tomUndefined;
		return hr;
	}

	long Value = *pParm;					// Default long value (Type = 4)
	switch(Type)							// Handle other cases
	{
	case 1:									// BYTE quantity
		Value &= 0xff;
		break;

	case 2:									// WORD quantity
		Value &= 0xffff;
		if(dwMask & (CFM_STYLE | PFM_STYLE))
			Value = *(SHORT *)pParm;		// Styles need sign extension
		break;

	case -2:								// float from WORD or SHORT
		Value &= 0xffff;					// Kill stuff above 16-bit data
		if(dwMask & (CFM_SPACING | CFM_SIZE	// Need sign extension for these
						| CFM_OFFSET))		//  (in high word, so don't
		{									//   conflict with PFM_xxx)
			Value = *(SHORT *)pParm;		// Fall thru to case -4
		}

	case -4:								// float value
		*(float *)&Value = TWIPS_TO_FPPTS(Value);
	}

	*pValue = Value;						// In all cases, return in a long
	return NOERROR;
}

/*
 *	CTxtFormat::SetParameter (pParm, fDefined, Type, Value)
 *
 *	@mfunc
 *		Set *pParm = Value unless NINCHed. Perform conversions specified by
 *		Type.  If Type > 0, it is treated as length of an unsigned integer,
 *		i.e., 1, 2, or 4 bytes.  If it is negative, the output is a float
 *		and the input has a length given by |Type|, so -2 converts a WORD
 *		into a float, unless dwMask = CFM_SPACING, in which case it converts
 *		a short into a float.  -4 converts a long into a float.
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : S_FALSE
 */
HRESULT	CTxtFormat::SetParameter (
	long *	pParm,		//@parm Ptr to _CF or _PF member to set
	long	Type,		//@parm # bytes of integer parameter or < 0 for float
	long 	Value)		//@parm New value for *pParm
{
	Assert(pParm);

	if(IsZombie())									// Check if attached to
		return CO_E_RELEASED;						//  zombied range

	if(Type > 0 && Value == tomUndefined)			// Undefined parameter
		return NOERROR;								// NINCH

	if(Type < 0)									// Value is a float
	{
		if(*(float *)&Value == tomFloatUndefined)	// Undefined parameter
			return NOERROR;							// NINCH
		Type = -Type;
		Value = FPPTS_TO_TWIPS(*(float *)&Value);	// Convert to a long
	}

	if(Type == 1)
	{
		if((DWORD)Value > 255)
			return E_INVALIDARG;
		*(BYTE *)pParm = (BYTE)Value;
	}
	else if(Type == 2)
	{
		if(Value < -32768 || Value > 65535)
			return E_INVALIDARG;					// Doesn't fit in 16 bits
		*(WORD *)pParm = (WORD)Value;
	}
	else
		*pParm = Value;

	return NOERROR;
}

/*
 *	CTxtFormat::IsTrue (f, pB)
 *
 *	@mfunc
 *		Return *<p pB> = tomTrue iff <p f> is nonzero and pB isn't NULL
 *
 *	@rdesc
 *		HRESULT = (f) ? NOERROR : S_FALSE
 */
HRESULT CTxtFormat::IsTrue(BOOL f, long *pB)
{
	if(pB)
		*pB = tomFalse;

	if(IsZombie())									// Check if attached to
		return CO_E_RELEASED;						//  zombied range

	if(f)
	{
		if(pB)
			*pB = tomTrue;
		return NOERROR;
	}

	return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\urlsup.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	URLSUP.CPP	URL detection support |
 *
 *	Author:	alexgo 4/3/96
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_urlsup.h"
#include "_m_undo.h"
#include "_select.h"
#include "_clasfyc.h"

ASSERTDATA

// Arrays for URL detection.  The first array is the protocols
// we support, followed by the "size" of the array.
// NB!! Do _not_ modify these arrays without first making sure
// that the code in ::IsURL is updated appropriately.


/*
FUTURE (keithcu)
We should generalize our support to recognize URLs of the following type:

Maybe we should do autocorrect so that:
keithcu@microsoft.com converts to mailto:keithcu@microsoft.com
Should we put this code in PutChar rather than here?

What about URLs of the form "seattle.sidewalk.com"? Word doesn't support this yet.
It is hard because do you look for the .com? What happens when .com, .edu, .gov,
etc. aren't the only suffixes anymore?

What about the interaction with notifications?
We should add support for purple text. CFE_LINKVISITED
*/

//Includes both types of URLs
const int MAXURLHDRSIZE	= 9;

//Most of these can just be passed right to the client--but some need a prefix.
//Can we automatically add that tag when it needs it?
const LPCWSTR rgszURL[] = {
	L"http:",
	L"file:",
	L"mailto:",
	L"ftp:",
	L"https:",
	L"gopher:",
	L"nntp:",
	L"prospero:",
	L"telnet:",
	L"news:",
	L"wais:",
	L"outlook:"
};
const char rgcchURL[] = {
	5,
	5,
	7,
	4,
	6,
	7,
	5,
	9,
	7,
	5,
	5,
	8
};

#define NUMURLHDR		sizeof(rgcchURL)

//
//The XXX. URLs
//
const LPCWSTR rgszDOTURL[] = {
	L"www.",
	L"ftp.",
};

const char rgcchDOTURL[] = {
	4,
	4,
};

#define NUMDOTURLHDR		sizeof(rgcchDOTURL)


inline BOOL IsURLWhiteSpace(WCHAR ch)
{
	if (IsWhiteSpace(ch))
		return TRUE;

	// See RAID 6304.  MSKK doesn't want CJK in URLs.  We do what we did in 2.0
	if ( ch >= 0x03000 && !IsKorean(ch) )
		return TRUE;

	INT iset = GetKinsokuClass(ch);
	return iset == 10 || (iset == 14 && ch != WCH_EMBEDDING);
}

/*
 *	CDetectURL::CDetectURL (ped)
 *
 *	@mfunc	constructor; registers this class in the notification manager.
 *
 *	@rdesc	void
 */
CDetectURL::CDetectURL(
	CTxtEdit *ped)		//@parm edit context to use
{
	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);

	_ped = ped;
}

/*
 *	CDetectURL::~CDetectURL
 *
 *	@mfunc	destructor; removes ths class from the notification manager
 */
CDetectURL::~CDetectURL()
{
	CNotifyMgr *pnm = _ped->GetNotifyMgr();

	if(pnm)
		pnm->Remove((ITxNotify *)this);
}

//
//	ITxNotify	methods
//

/*
 *	CDetectURL::OnPreRelaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax)
 *
 *	@mfunc	called before a change is made
 */
void CDetectURL::OnPreReplaceRange(
	LONG cp,			//@parm start of changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm #of chars added
	LONG cpFormatMin,	//@parm min cp of formatting change
	LONG cpFormatMax)	//@parm max cp of formatting change
{
	; // don't need to do anything here
}

/*
 *	CDetectURL::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax)
 *
 *	@mfunc	called after a change has been made to the backing store.  We
 *			simply need to accumulate all such changes
 */
void CDetectURL::OnPostReplaceRange(
	LONG cp,			//@parm start of changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm #of chars added
	LONG cpFormatMin,	//@parm min cp of formatting change
	LONG cpFormatMax)	//@parm max cp of formatting change
{
	// We don't need to worry about format changes; just data changes
	// to the backing store

	if(cp != CP_INFINITE)
	{
		Assert(cp != CONVERT_TO_PLAIN);
		_adc.UpdateRecalcRegion(cp, cchDel, cchNew);
	}
}

/*
 *	CDetectURL::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDetectURL::Zombie ()
{
}

/*
 *	CDetectURL::ScanAndUpdate(publdr)
 *
 *	@mfunc	scans the affect text, detecting new URL's and removing old ones.
 *
 *	@comm	The algorithm we use is straightforward: <nl>
 *
 *			1. find the update region and expand out to whitespace in either
 *			direction. <nl>
 *
 *			2. Scan through region word by word (where word is contiguous
 *			non-whitespace). 
 *			
 *			3. Strip these words off punctuation marks. This may be a bit 
 *			tricky as some of the punctuation may be part of the URL itself.
 *			We assume that generally it's not, and if it is, one has to enclose
 *			the URL in quotes, brackets or such. We stop stripping the 
 *			punctuation off the end as soon as we find the matching bracket.
 *			
 *			4. If it's a URL, enable the effects, if it's
 *			incorrectly labelled as a URL, disabled the effects.
 *
 *			Note that this algorithm will only remove
 */
void CDetectURL::ScanAndUpdate(
	IUndoBuilder *publdr)	//@parm undo context to use
{
	LONG		cpStart, cpEnd, cp;
	CTxtSelection *psel = _ped->GetSel();
	CTxtRange	rg(*psel);
	BOOL		fCleanedThisURL;
	BOOL		fCleanedSomeURL = FALSE;

	// Clear away some unnecessary features of the range that will
	// just slow us down.
	rg.SetIgnoreFormatUpdate(TRUE);
	rg._rpPF.SetToNull();
		
	if(!GetScanRegion(cpStart, cpEnd))
		return;

	rg.Set(cpStart, 0);

	while((cp = rg.GetCp()) < cpEnd)
	{
		Assert(rg.GetCch() == 0);
		
		LONG cchAdvance; 

		ExpandToURL(rg, cchAdvance);

		if(rg.GetCch() == 0)
			break;

		if(IsURL(rg))
		{
			SetURLEffects(rg, publdr);

			LONG cpNew = rg.GetCp() - rg.GetCch();

			// Anything before detected URL did not really belong to it
			if (rg.GetCp() > cp)
			{
				rg.Set(cp, cp - rg.GetCp());
				CheckAndCleanBogusURL(rg, fCleanedThisURL, publdr);
				fCleanedSomeURL |= fCleanedThisURL;
			}

			// Collapse to end of URL range so that ExpandToURL will
			// find next candidate.
			rg.Set(cpNew, 0);

			// skip to the end of word; this can't be another URL!
			cp = cpNew;
			cchAdvance = -MoveByDelimiters(rg._rpTX, 1, URL_STOPATWHITESPACE, 0);
		}

		if(cchAdvance)
		{	
			rg.Set(cp, cchAdvance);
			CheckAndCleanBogusURL(rg, fCleanedThisURL, publdr);
			fCleanedSomeURL |= fCleanedThisURL;

			// Collapse to end of scanned range so that ExpandToURL will
			// find next candidate.
			rg.Set(cp - cchAdvance, 0);
		}
	}

	// If we cleaned some URL, we might need to reset the default format
	if(fCleanedSomeURL && !psel->GetCch())
		psel->Update_iFormat(-1);
}

//
//	PRIVATE methods
//

/*
 *	CDetectURL::GetScanRegion (&rcpStart, &rcpEnd)
 *
 *	@mfunc	Gets the region of text to scan for new URLs by expanding the
 *			changed region to be bounded by whitespace
 *
 *	@rdesc	BOOL
 */
BOOL CDetectURL::GetScanRegion(
	LONG&	rcpStart,		//@parm where to put start of range
	LONG&	rcpEnd)			//@parm where to put end of range
{
	LONG		cp, cch;
	LONG		cchExpand;
	WCHAR		chBracket;
	CRchTxtPtr	rtp(_ped, 0);

	_adc.GetUpdateRegion(&cp, NULL, &cch);

	if(cp == CP_INFINITE)
		return FALSE;

	// First find start of region
	rtp.SetCp(cp);
	rcpStart = cp;
	rcpEnd = cp + cch;
	
	// Now let's see if we need to expand to the nearest quotation mark
	// we do if we have quotes in our region or we have the LINK bit set
	// on either side of the region that we might need or not need to clear
	BOOL fExpandToBrackets = (rcpEnd - rcpStart ? 
						      GetAngleBracket(rtp._rpTX, rcpEnd - rcpStart) : 0);

	BOOL fKeepGoing = TRUE;	
	while(fKeepGoing)
	{
		fKeepGoing = FALSE;

		// Expand left to the entire word
		rtp.SetCp(rcpStart);
		rcpStart += MoveByDelimiters(rtp._rpTX, -1, URL_STOPATWHITESPACE, 0);

		// Now the other end
		rtp.SetCp(rcpEnd);
		rcpEnd += MoveByDelimiters(rtp._rpTX, 1, URL_STOPATWHITESPACE, 0);

		// If we have LINK formatting around, we'll need to expand to nearest quotes
		rtp.SetCp(rcpStart);
		rtp._rpCF.AdjustBackward();
		fExpandToBrackets = fExpandToBrackets ||
						(_ped->GetCharFormat(rtp._rpCF.GetFormat())->_dwEffects & CFE_LINK);

		rtp.SetCp(rcpEnd);
		rtp._rpCF.AdjustForward();
		fExpandToBrackets = fExpandToBrackets || 
						(_ped->GetCharFormat(rtp._rpCF.GetFormat())->_dwEffects & CFE_LINK);

		if (fExpandToBrackets)
		// We have to expand to nearest angle brackets in both directions
		{
			rtp.SetCp(rcpStart);
			chBracket = LEFTANGLEBRACKET;
			cchExpand = MoveByDelimiters(rtp._rpTX, -1, URL_STOPATCHAR, &chBracket);
		
			// Did we really hit a bracket?	
			if(chBracket == LEFTANGLEBRACKET)
			{
				rcpStart += cchExpand;
				fKeepGoing = TRUE;
			}

			// Same thing, different direction
			rtp.SetCp(rcpEnd);
			chBracket = RIGHTANGLEBRACKET;
			cchExpand =  MoveByDelimiters(rtp._rpTX, 1, URL_STOPATCHAR, &chBracket);

			if(chBracket == RIGHTANGLEBRACKET)
			{
				rcpEnd += cchExpand;
				fKeepGoing = TRUE;
			}
			fExpandToBrackets = FALSE;
		}
	}
		
	LONG cchAdj = _ped->GetAdjustedTextLength();
	if(rcpEnd > cchAdj)
		rcpEnd = cchAdj;

	return TRUE;
}

/*
 *	CDetectURL::ExpandToURL(&rg, &cchAdvance)
 *
 *	@mfunc	skips white space and sets the range to the very next
 *			block of non-white space text. Strips this block off
 *			punctuation marks
 */
void CDetectURL::ExpandToURL(
	CTxtRange&	rg,	//@parm range to move
	LONG &cchAdvance//@parm how much to advance to the next URL from the current cp		
							)	
{
	LONG cp;
	LONG cch;

	Assert(rg.GetCch() == 0);

	cp = rg.GetCp();

	// Skip white space first, record the advance
	cp  -= (cchAdvance = -MoveByDelimiters(rg._rpTX, 1, 
							URL_EATWHITESPACE|URL_STOPATNONWHITESPACE, 0));
	rg.Set(cp, 0);

	// Strip off punctuation marks
	WCHAR chStopChar = URL_INVALID_DELIMITER;

	// Skip all punctuation from the beginning of the word
	LONG cchHead = MoveByDelimiters(rg._rpTX, 1, 
							URL_STOPATWHITESPACE|URL_STOPATNONPUNCT, 
							&chStopChar);

	// Now skip up to white space (i.e. expand to the end of the word).
	cch = MoveByDelimiters(rg._rpTX, 1, URL_STOPATWHITESPACE|URL_EATNONWHITESPACE, 0);
	
	// This is how much we want to advance to start loking for the next URL
	// if this does not turn out to be one: one word
	// We increment/decrement  the advance so we can accumulate changes in there
	cchAdvance -= cch;
	WCHAR chLeftDelimiter = chStopChar;

	// Check if anything left; if not, it's not interesting -- just return
	Assert(cchHead <= cch);
	if(cch == cchHead)
	{
		rg.Set(cp, -cch);
		return;
	}

	// Set to the end of range
	rg.Set(cp + cch, 0);
		
	//  Get the space after so we always clear white space between words
	//	cchAdvance -= MoveByDelimiters(rg._rpTX, 1, 
	//						URL_EATWHITESPACE|URL_STOPATNONWHITESPACE, 0);

	// and go back while skipping punctuation marks and not finding a match
	// to the left-side encloser

	chStopChar = BraceMatch(chStopChar);
	LONG cchTail = MoveByDelimiters(rg._rpTX, -1, 
							URL_STOPATWHITESPACE|URL_STOPATNONPUNCT|URL_STOPATCHAR, 
							&chStopChar);

	// Something should be left of the word, assert that
	Assert(cch - cchHead + cchTail > 0);

	if(chLeftDelimiter == LEFTANGLEBRACKET)
	{ 
		//If we stopped at a quote: go forward looking for the enclosing
		//quote, even if there are spaces.

		// move to the beginning
		rg.Set(cp + cchHead, 0);
		chStopChar = RIGHTANGLEBRACKET;
		if(GetAngleBracket(rg._rpTX) < 0) // closing bracket
		{
			LONG cchExtend = MoveByDelimiters(rg._rpTX, 1, URL_STOPATCHAR, &chStopChar);
			Assert(cchExtend <= URL_MAX_SIZE);

			// did we really get the closing bracket?
			if(chStopChar == RIGHTANGLEBRACKET)
			{
				rg.Set(cp + cchHead, -(cchExtend - 1));
				return;
			}
		}
		// Otherwise the quotes did not work out; fall through to
		// the general case
	}
	rg.Set(cp + cchHead, -(cch - cchHead + cchTail));
	return;
}

/*
 *	CDetectURL::IsURL(&rg)
 *
 *	@mfunc	if the range is over a URL, return TRUE.  We assume
 *			that the range has been preset to cover a block of non-white
 *			space text.
 *			
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL CDetectURL::IsURL(
	CTxtRange&	rg)		//@parm Range of text to check
{
	LONG i, j;
	TCHAR szBuf[MAXURLHDRSIZE + 1];
	LONG cch, rgcch;
	
	// make sure the active end is cpMin
	Assert(rg.GetCch() < 0);
	
	cch = rg._rpTX.GetText(MAXURLHDRSIZE, szBuf);
	szBuf[cch] = L'\0';
	rgcch = -rg.GetCch();

	//First, see if the word contains '\\' because that is a UNC
	//convention and its cheap to check.
	if (szBuf[0] == L'\\' && szBuf[1] == L'\\' && rgcch > 2)
		return TRUE;

	// Scan the buffer to see if we have one of ':.' since
	// all URLs must contain that.  wcsnicmp is a fairly expensive
	// call to be making frequently.
	for(i = 0; i < cch; i++)
	{
		switch (szBuf[i])
		{
		default:
			break;

		case '.':
		for(j = 0; j < NUMDOTURLHDR; j++)
		{
			// The strings must match _and_ we must have at least
			// one more character
			if(W32->wcsnicmp(szBuf, rgszDOTURL[j], rgcchDOTURL[j]) == 0)
				return rgcch > rgcchDOTURL[j];
		}
		return FALSE;

		case ':':
			for(j = 0; j < NUMURLHDR; j++)
			{
				if(W32->wcsnicmp(szBuf, rgszURL[j], rgcchURL[j]) == 0)
					return rgcch > rgcchURL[j];
			}
		return FALSE;
		}
	}
	return FALSE;
}

/*
 *	CDetectURL::SetURLEffects
 *
 *	@mfunc	sets URL effects for the given range.
 *
 *	@comm	The URL effects currently are blue text, underline, with 
 *			CFE_LINK.
 */
void CDetectURL::SetURLEffects(
	CTxtRange&	rg,			//@parm Range on which to set the effects
	IUndoBuilder *publdr)	//@parm Undo context to use
{
	CCharFormat CF;

	CF._dwEffects = CFE_LINK;

	// NB!  The undo system should have already figured out what should
	// happen with the selection by now.  We just want to modify the
	// formatting and not worry where the selection should go on undo/redo.
	rg.SetCharFormat(&CF, SCF_IGNORESELAE, publdr, CFM_LINK, CFM2_CHARFORMAT);
}

/*
 *	CDetectURL::CheckAndCleanBogusURL(rg, fDidClean, publdr)
 *
 *	@mfunc	checks the given range to see if it has CFE_LINK set,
 *			and if so, removes is.  We assume that the range is already
 *			_not_ a well-formed URL string.
 */
void CDetectURL::CheckAndCleanBogusURL(
	CTxtRange&	rg,			//@parm range to use
	BOOL	   &fDidClean,	//@parm return TRUE if we actually did some cleaning
	IUndoBuilder *publdr)	//@parm undo context to use
{
	LONG cch = -rg.GetCch();
	Assert(cch > 0);

	CCharFormat CF;
	CFormatRunPtr rp(rg._rpCF);

	fDidClean = FALSE;

	// If there are no format runs, nothing to do
	if(!rp.IsValid())
		return;

	rp.AdjustForward();
	// Run through the format runs in this range; if there is no
	// link bit set, then just return.
	while(cch > 0)
	{
		if(_ped->GetCharFormat(rp.GetFormat())->_dwEffects & CFE_LINK)
			break;

		cch -= rp.GetCchLeft();
		rp.NextRun();
	}

	// If there is no link bit set on any part of the range, just return	
	if(cch <= 0)
		return;

	// Uh-oh, it's a bogus link.  Turn off the link bit.
	fDidClean = TRUE;

	CF._dwEffects = 0;

	// NB!  The undo system should have already figured out what should
	// happen with the selection by now.  We just want to modify the
	// formatting and not worry where the selection should go on undo/redo.
	rg.SetCharFormat(&CF, SCF_IGNORESELAE, publdr, CFM_LINK, CFM2_CHARFORMAT);
}

/*
 *	CDetectURL::MoveByDelimiters(&tpRef, iDir, grfDelimeters, pchStopChar)
 *
 *	@mfunc	returns the signed number of characters until the next delimiter 
 *			character in the given direction.
 *
 *	@rdesc	signed number of characters until next delimite
 */
LONG CDetectURL::MoveByDelimiters(
	const CTxtPtr&	tpRef,		//@parm cp/tp to start looking from
	LONG iDir,					//@parm Direction to look, must be 1 or -1
	DWORD grfDelimiters,		//@parm Eat or stop at different types of
								// characters. Use one of URL_EATWHITESPACE,
								// URL_EATNONWHITESPACE, URL_STOPATWHITESPACE
								// URL_STOPATNONWHITESPACE, URL_STOPATPUNCT,
								// URL_STOPATNONPUNCT ot URL_STOPATCHAR
	WCHAR *pchStopChar)			// @parm Out: delimiter we stopped at
								// In: additional char that stops us
								// when URL_STOPATCHAR is specified
{
	LONG	cch = 0;
	LONG	cchMax = (grfDelimiters & URL_EATWHITESPACE)	// Use huge # if
				   ? tomForward : URL_MAX_SIZE;				//  eating whitesp
	LONG	cchvalid = 0;
	WCHAR chScanned = URL_INVALID_DELIMITER;
	LONG	i;
	const WCHAR *pch;
	CTxtPtr	tp(tpRef);

	// Determine the scan mode: do we stop at white space, at punctuation, 
	// at a stop character? 
	BOOL fWhiteSpace	= (0 != (grfDelimiters & URL_STOPATWHITESPACE));
	BOOL fNonWhiteSpace = (0 != (grfDelimiters & URL_STOPATNONWHITESPACE));
	BOOL fPunct			= (0 != (grfDelimiters & URL_STOPATPUNCT));
	BOOL fNonPunct		= (0 != (grfDelimiters & URL_STOPATNONPUNCT));
	BOOL fStopChar		= (0 != (grfDelimiters & URL_STOPATCHAR));

	Assert(iDir == 1 || iDir == -1);
	Assert(fWhiteSpace || fNonWhiteSpace || (!fPunct && !fNonPunct));
	Assert(!fStopChar || NULL != pchStopChar);

	// Break anyway if we scanned more than URL_MAX_SIZE chars
	for (LONG cchScanned = 0; cchScanned < cchMax;)
	{
		// Get the text
		if(iDir == 1)
		{
			i = 0;
			pch = tp.GetPch(cchvalid);
		}
		else
		{
			i = -1;
			pch = tp.GetPchReverse(cchvalid);
			// This is a bit odd, but basically compensates for	the
			// backwards loop running one-off from the forwards loop
			cchvalid++;
		}

		if(!pch)
			goto exit;

		// Loop until we hit a character within criteria.  Note that for
		// our purposes, the embedding character counts as whitespace.

		while(abs(i) < cchvalid  && cchScanned < cchMax
			&& (IsURLWhiteSpace(pch[i]) ? !fWhiteSpace : !fNonWhiteSpace)
			&& (IsURLDelimiter(pch[i]) ? !fPunct : !fNonPunct)
			&& !(fStopChar && (*pchStopChar == chScanned) && (chScanned != URL_INVALID_DELIMITER))
			&& ((chScanned != CR && chScanned != LF) || fNonWhiteSpace))
		{	
			chScanned = pch[i];
			i += iDir;
			++cchScanned;
		}

		// If we're going backwards, i will be off by one; adjust
		if(iDir == -1)
		{
			Assert(i < 0 && cchvalid > 0);
			i++;
			cchvalid--;
		}

		cch += i;
		if(abs(i) < cchvalid)
			break;
		tp.AdvanceCp(i);
	}

exit:	
	// Stop char parameter is present, fill it in
	// with the last character scanned and accepted
	if (pchStopChar)
		*pchStopChar = chScanned;

	return cch; 
}

/*
 *	CDetectURL::BraceMatch (chEnclosing)
 *
 *	@mfunc	returns the matching bracket to the one passed in.
 *			if the symbol passed in is not a bracket it returns 
 *			URL_INVALID_DELIMITER
 *
 *	@rdesc	returns bracket that matches chEnclosing
 */
WCHAR CDetectURL::BraceMatch(
	WCHAR chEnclosing)
{	
	// We're matching "standard" roman braces only. Thus only them may be used
	// to enclose URLs. This should be fine (after all, only Latin letters are allowed
	// inside URLs, right?).
	// I hope that the compiler converts this into some efficient code
	switch(chEnclosing)
	{
	case(TEXT('\"')): 
	case(TEXT('\'')): return chEnclosing;
	case(TEXT('(')): return TEXT(')');
	case(TEXT('<')): return TEXT('>');
	case(TEXT('[')): return TEXT(']');
	case(TEXT('{')): return TEXT('}');
	default: return URL_INVALID_DELIMITER;
	}
}

/*
 *	CDetectURL::GetAngleBracket	(&tpRef, cchMax)
 *
 *	@mfunc	Goes forward as long as the current paragraph 
 *			or URL_SCOPE_MAX not finding quotation marks and counts 
 *			those quotation marks
 *			returns their parity
 *
 *	@rdesc	LONG
 */
LONG CDetectURL::GetAngleBracket(
	CTxtPtr &tpRef,
	LONG	 cchMax)
{	
	CTxtPtr	tp(tpRef);
	LONG	cchvalid = 0;
	const WCHAR *pch;

	Assert (cchMax >= 0);

	if(!cchMax)
		cchMax = URL_MAX_SCOPE;

	// Break anyway if we scanned more than cchLimit chars
	for (LONG cchScanned = 0; cchScanned < cchMax; NULL)
	{
		pch = tp.GetPch(cchvalid);

		if(!cchvalid)
			return 0;
		
		for (LONG i = 0; (i < cchvalid); ++i)
		{
			if(pch[i] == CR || pch[i] == LF || cchScanned >= cchMax)
				return 0;

			if(pch[i] == LEFTANGLEBRACKET)
				return 1;

			if(pch[i] == RIGHTANGLEBRACKET)
				return -1;
			++cchScanned;
		}
		tp.AdvanceCp(i);
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\txtbrk.cpp ===
/*
 *		Text Breaker & Bit stream break array class implementation
 *		
 *		File:    txtbrk.cpp
 * 		Create:  Mar 29, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */


//#include "stdafx.h"
//#include "Array.h"

#include "_common.h"

#ifndef BITVIEW
#include "_frunptr.h"
#include "_range.h"
#include "_notmgr.h"
#endif
#include "_txtbrk.h"

CBreakArray::CBreakArray()
{
	_ibGap = 0;
	_cbGap = 0;
	_cbSize = 0;
	_cbBreak = 0;
}

inline ITEM* CBreakArray::Elem(LONG iel) const
{
	Assert(iel < Count());
	return iel < Count() ? CArray<ITEM>::Elem(iel) : NULL;
}

void CBreakArray::CheckArray ()
{
	if (!IsValid())
	{
		// Add the first element. This is required to be a sentinel.
		Add(1, NULL);
	}
}

// Remove <cchOld> and insert <cchNew> break items at <cp>
LONG CBreakArray::ReplaceBreak (
	LONG	cp, 				// insertion cp
	LONG	cchOld,				// number of break item to be deleted
	LONG	cchNew)				// number of break item to be inserted
{
	PUSH_STATE(cp, cchNew, REPLACER);

	if (!cchOld && cchNew)
		return VALIDATE(InsertBreak (cp, cchNew));
	if (cchOld && !cchNew)
		return VALIDATE(RemoveBreak (cp, cchOld));

	LONG	cRep = 0;		// number of new break inserted after replacing

	if (cchOld > cchNew)
	{
		cRep = RemoveBreak(cp+cchNew, cchOld-cchNew);
		ClearBreak(cp, cchNew);
	}
	else if (cchOld < cchNew)
	{
		cRep = InsertBreak(cp+cchOld, cchNew-cchOld);
		ClearBreak(cp, cchOld);
	}
	else if (cchNew)
    {
		ClearBreak(cp, cchNew);
	}
	return VALIDATE(cRep);
}


// Add <cch> break items at <cp>
// note: This routine assumes there is no gap left in the bit array
LONG CBreakArray::AddBreak(
	LONG	cp,
	LONG	cch)
{
	Assert (cp == _cbBreak);
	LONG	cchAdd = min(cch, _cbSize - _cbBreak);
	LONG	c;

	_cbBreak += cchAdd;
	cch -= cchAdd;
	if (cch > 0)
	{
		cp += cchAdd;
		c = (cch + RSIZE-1)/RSIZE;
		Insert (cp / RSIZE, c);
		_cbSize += c * RSIZE;
		_cbBreak += cch;
		cchAdd += cch;
	}
	return cchAdd;
}


// Insert <cch> break items at <cp>
// <detail see: bitrun.html>
LONG CBreakArray::InsertBreak (
	LONG	cp, 				// insertion point cp
	LONG	cch)				// number of break item to be inserted
{
	LONG	cIns = 0;			// number of break inserted
	ITEM	*peli, *pelj;
	LONG	cchSave = cch;

	PUSH_STATE(cp, cch, INSERTER);

	// Make sure we establish the array
	CheckArray();

	if (cp == _ibGap)
	{
		// The insertion takes place at the gap,
		// reposition and shrink the gap down
		for (cIns=0 ; cch > 0 && cIns < _cbGap; cIns++, cch--, cp++)
		{
			peli = Elem(cp / RSIZE);
			*peli &= ~(1<<(cp % RSIZE));
		}
		_cbGap -= cIns;
		_ibGap += cIns;
		_cbBreak += cIns;
	}
	else
	{
		// The insertion point is outside the gap,
		// Collapse the gap and go as normal.
		CollapseGap();
	}
	
	if (cch <= 0)
		return VALIDATE(cIns);

	if (cp == _cbBreak)
		return VALIDATE(cIns + AddBreak(cp, cch));

	Assert (_cbGap == 0 && cp < _cbBreak);

	LONG	cit = (cch+RSIZE-1) / RSIZE;
	LONG	i = cp / RSIZE;
	LONG	j;
	ITEM	uh, ul;				// H: high-mask after cp, L: low-mask before cp

	// Insert items
	Insert (i+1, cit);
	cIns += (cit * RSIZE);

	// Get the [i]
	peli = Elem(i);

	// Create the high/low mask & keep the masked values
	ul = MASK_LOW (-1, cp % RSIZE);
	uh = ~ul;
	ul &= *peli;
	uh &= *peli;

	// Reference the [j]
	j = i + cit;

	// Move L to [i]; move H to [j]
	*peli = ul;
	pelj = Elem(j);
	Assert (pelj);
	*pelj = uh;

	// Calculate gap position
	_ibGap = cp + (cch / RSIZE) * RSIZE;
	_cbGap = cit*RSIZE - cch;

	Assert(_cbGap < RSIZE && cIns - _cbGap == cchSave);

	_cbSize += (cIns - cchSave + cch);
	_cbBreak += cch;

	return VALIDATE(cIns - _cbGap);
}

// Remove <cch> break items at <cp>
// <detail see: bitrun.html>
LONG CBreakArray::RemoveBreak (
	LONG	cp, 				// deletion point cp
	LONG	cch)				// number of break item to be deleted
{
	Assert (IsValid() && cp + cch <= _cbBreak);

	PUSH_STATE(cp, cch, REMOVER);

	LONG	i = cp / RSIZE;
	LONG	j;
	LONG	cDel = 0;			// number of break deleted

	if (cp == _ibGap)
	{
		// The deletion takes place at the gap,
		// reposition and expand the gap
		cDel = cch;
		_cbGap += cch;
		_cbBreak -= cch;
		cch = 0;

		// Optimise the gap size:
		// Keep the gap small so we dont spend much time collapsing it.
		j = (_ibGap+_cbGap) / RSIZE - i - 1;
		if (j > 0)
		{
			Remove(i+1, j);
			_cbGap -= j * RSIZE;
			_cbSize -= j * RSIZE;
		}
	}
	else
	{
		// The deletion point is outside the gap,
		// Collapse the gap and go as normal.
		CollapseGap();
	}

	if (!cch)
		return VALIDATE(-cDel);

	LONG	cit = cch / RSIZE;
	ITEM	uh, ul;				// H: high-mask after cp, L: low-mask before cp
	ITEM	*peli, *pelj;

	j = (cp+cch) / RSIZE;

	// Get the [i] and [j]
	peli = Elem(i);
	pelj = Elem(j);

	// Create the high/low mask & keep the masked values
	ul = MASK_LOW (-1, cp % RSIZE);
	uh = ~MASK_LOW (-1, (cp+cch) % RSIZE);
	ul &= *peli;
	uh &= pelj ? *pelj : 0;

	// Remove <cch/RSIZE> items
	if (cit)
	{
		Remove(i, cit);
		cDel += (cit * RSIZE);
	}

	// Zero [i]
	peli = Elem(i);
	*peli = 0;

	// Reference the (new) [j]
	j -= cit;

	// Move H to [j]
	pelj = Elem(j);
	if (pelj)
		*pelj = uh;

	// Or L to [i]
	*peli |= ul;


	// Calculate gap position
	_ibGap = cp;
	_cbGap = cch % RSIZE;

	Assert(_cbGap < RSIZE && cDel + _cbGap == cch);

	_cbSize -= cDel;
	_cbBreak -= cch;

	return VALIDATE(-cDel - _cbGap);
}


// Determine if we can break between char[cp-1] and [cp]
BOOL CBreakArray::GetBreak (LONG cp)
{
	if (!IsValid() || cp >= _cbBreak)
		return FALSE;

	cp += cp < _ibGap ? 0 : _cbGap;

	if (cp / RSIZE < Count() - 1)
		return GetAt(cp / RSIZE) & (1<<(cp % RSIZE));
	return FALSE;
}

// Set break at cp, so it's breakable between char[cp-1] and [cp]
void CBreakArray::SetBreak (LONG cp, BOOL fOn)
{
	if (cp >= _cbBreak)
		return;

	CheckArray();

	cp += cp < _ibGap ? 0 : _cbGap;

	ITEM	*pel = Elem(cp / RSIZE);
	*pel = fOn ? *pel | (1<<(cp % RSIZE)) : *pel & ~(1<<(cp % RSIZE));
}

// Clear break in range <cch> start at position <cp>
void CBreakArray::ClearBreak (
	LONG	cp,
	LONG	cch)
{
	if (!cch)
		return;

	Assert (cch > 0 && cp < _cbBreak);
	CheckArray();

	cp += cp < _ibGap ? 0 : _cbGap;
	cch += cp < _ibGap && cp + cch > _ibGap ? _cbGap : 0;

	LONG 	i = cp / RSIZE;
	LONG	j = (cp+cch) / RSIZE;
	ITEM	uMaskl, uMaskh;
	ITEM	*pel;

	uMaskl = MASK_LOW(-1, cp % RSIZE);
	uMaskh = ~MASK_LOW(-1, (cp+cch) % RSIZE);

	if (i==j)
	{
		uMaskl |= uMaskh;
		uMaskh = uMaskl;
	}

	// clear first item
	pel = Elem(i);
	*pel &= uMaskl;
	
	if (uMaskh != (ITEM)-1)
	{
		// clear last item
		pel = Elem(j);
		*pel &= uMaskh;
	}

	// clear items in between
	i++;
	while (i < j)
	{
		pel = Elem(i);
		*pel = 0;
		i++;
	}
}

// Collapse the gap down to 0 using bit shifting
// (using the 'bits remove with shifting' algorithm)
//
LONG CBreakArray::CollapseGap ()
{
#ifdef BITVIEW
	_cCollapse++;
#endif
	if (_cbGap == 0)
		return 0;		// No gap

	PUSH_STATE(0, 0, COLLAPSER);

	LONG	cit = _cbGap / RSIZE;
	LONG	i = _ibGap / RSIZE;
	LONG	j = (_ibGap+_cbGap) / RSIZE;
	LONG	cDel = 0;			// number of break deleted
	ITEM	uh, ul;				// H: high-mask after cp, L: low-mask before cp
	ITEM	*peli, *pelj;

	Assert (IsValid());

	// Get the [i] and [j]
	peli = Elem(i);
	pelj = Elem(j);

	// Create the high/low mask & keep the masked values
	ul = MASK_LOW (-1, _ibGap % RSIZE);
	uh = ~MASK_LOW (-1, (_ibGap+_cbGap) % RSIZE);
	ul &= *peli;
	uh &= pelj ? *pelj : 0;

	// Remove items
	if (cit)
	{
		Remove(i, cit);
		cDel += (cit * RSIZE);
		_cbSize -= cDel;
		if (!_cbSize)
			return VALIDATE(cDel);
	}

	// Zero [i]
	peli = Elem(i);
	*peli = 0;

	// Reference the (new) [j]
	j -= cit;

	cit = Count() - 1;

	// Move H to [j]
	pelj = Elem(j);
	if (pelj)
		*pelj = uh;

	// Shifting bits down <cit-i> items starting@[i]
	ShDn(i, cit-i, _cbGap % RSIZE);
	cDel += (_cbGap % RSIZE);

	// Or L to [i]
	*peli |= ul;

	Assert (cit > 0 && cDel == _cbGap);

	_cbGap = 0;

	if (_cbSize - _cbBreak > RSIZE)
	{
		// The last item was shifted til empty.
		// No need to keep it around.
		Remove(cit-1, 1);
		_cbSize -= RSIZE;
	}

	return VALIDATE(0);
}

// Shifting <cel> dword n bits UPWARD
void CBreakArray::ShUp (LONG iel, LONG cel, LONG n)
{
	if (n < RSIZE)
	{
		ITEM	*pel;
		ITEM	uo;				// shifting overflow
		ITEM	ua = 0;			// shifting addendum
		ITEM	uMask = MASK_HIGH(-1, n);
	
		while (cel > 0)
		{
			pel = Elem(iel);
			Assert (pel);
			uo = (*pel & uMask) >> (RSIZE-n);
			*pel = (*pel << n) | ua;
			ua = uo;
			iel++;
			cel--;
		}
	}
}

// Shifting <cel> dword n bits DOWNWARD
void CBreakArray::ShDn (LONG iel, LONG cel, LONG n)
{
	if (n < RSIZE)
	{
		ITEM	*pel;
		ITEM	uo;				// shifting overflow
		ITEM	ua = 0;			// shifting addendum
		ITEM	uMask = MASK_LOW(-1, n);
	
		iel += cel-1;
		while (cel > 0)
		{
			pel = Elem(iel);
			Assert (pel);
			uo = (*pel & uMask) << (RSIZE-n);
			*pel = (*pel >> n) | ua;
			ua = uo;
			iel--;
			cel--;
		}
	}
}

#ifdef BVDEBUG
LONG CBreakArray::Validate (LONG cchRet)
{										
	Assert(_cbSize >= 0 && (Count() - 1)*RSIZE == _cbSize);
	Assert(_cbBreak - _s.cbBreak == cchRet);
	return cchRet;
}										

void CBreakArray::PushState (LONG cp, LONG cch, LONG who)
{
	_s.who = who;
	_s.ibGap = _ibGap;
	_s.cbGap = _cbGap;
	_s.cbSize = _cbSize;
	_s.cbBreak = _cbBreak;
	_s.cp = cp;
	_s.cch = cch;
}
#endif

#ifdef BITVIEW
LONG CBreakArray::SetCollapseCount ()
{
	LONG cc = _cCollapse;
	_cCollapse = 0;
	return cc;
}
#endif


#ifndef BITVIEW

/////// CTxtBreaker class implementation
//		
//
CTxtBreaker::CTxtBreaker(
	CTxtEdit*	ped)
{
	// Register ourself in the notification list
	// so we get notified when backing store changed.

	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);

	_ped = ped;
}

CTxtBreaker::~CTxtBreaker()
{
	CNotifyMgr *pnm = _ped->GetNotifyMgr();

	if(pnm)
		pnm->Remove((ITxNotify *)this);

	// Clear break arrays
	if (_pbrkWord)
	{
		_pbrkWord->Clear(AF_DELETEMEM);
		delete _pbrkWord;
	}
	if (_pbrkChar)
	{
		_pbrkChar->Clear(AF_DELETEMEM);
		delete _pbrkChar;
	}
}

// Adding the breaker
// return TRUE means we plug something in.
BOOL CTxtBreaker::AddBreaker(
	UINT		brkUnit)
{
	BOOL		fr = FALSE;
	CUniscribe* pusp = _ped->Getusp();

	if (pusp && pusp->IsValid())
	{
		// Initialize proper bit mask used to test breaking bits
		if (!_pbrkWord && (brkUnit & BRK_WORD))
		{
			_pbrkWord = new CBreakArray();
			Assert(_pbrkWord);
			if (_pbrkWord)
				fr = TRUE;
		}
		if (!_pbrkChar && (brkUnit & BRK_CLUSTER))
		{
			_pbrkChar = new CBreakArray();
			Assert(_pbrkChar);
			if (_pbrkChar)
				fr = TRUE;
		}
	}
	return fr;
}

// <devnote:> The "cluster" break array actually contains invert logic.
// This is for speed since it's likely to be a sparse array.
CTxtBreaker::CanBreakCp(
	BREAK_UNIT	brk, 	// kind of break
	LONG		cp)		// given cp
{
	Assert (brk != BRK_BOTH);
	if (brk == BRK_WORD && _pbrkWord)
		return _pbrkWord->GetBreak(cp);
	if (brk == BRK_CLUSTER && _pbrkChar)
		return !_pbrkChar->GetBreak(cp);
	return FALSE;
}

void CTxtBreaker::OnPreReplaceRange (
	LONG	cp,
	LONG	cchDel,
	LONG	cchNew,
	LONG	cpFormatMin,
	LONG	cpFormatMax)
{
#ifdef DEBUG
	if (_pbrkWord)
		Assert (_pbrkWord->GetCchBreak() == _ped->GetTextLength());
	if (_pbrkChar)
		Assert (_pbrkChar->GetCchBreak() == _ped->GetTextLength());
#endif
}


// Sync up the breaking result of each available breaker.
void CTxtBreaker::Refresh()
{
	CBreakArray*	pbrk = _pbrkWord;
	LONG			len = _ped->GetTextLength();

	for (int i=0; i<2; i++)
	{
		if (pbrk && pbrk->GetCchBreak())
		{
			// (temporarily) collapse the breaking result
			pbrk->RemoveBreak(0, len);
		}
		pbrk = _pbrkChar;
	}
	// Now announce the new coming text of the whole document.
	// (we recalculate both results at once here since the ScriptBreak returns
	// both kind of information in one call. No need to slow thing down by making 2 calls.)
	OnPostReplaceRange(0, 0, len, 0, 0);
}

	
// This method gets called once backing store changed.
// Produce correct breaking positions for the text range effected by the change.
//
void CTxtBreaker::OnPostReplaceRange (
	LONG	cp,
	LONG	cchDel,
	LONG	cchNew,
	LONG	cpFormatMin,
	LONG	cpFormatMax)
{
	if (!cchDel && !cchNew)
		return;

#ifdef DEBUG
	LONG	cchbrkw = _pbrkWord ? _pbrkWord->GetCchBreak() : 0;
	LONG	cchbrkc = _pbrkChar ? _pbrkChar->GetCchBreak() : 0;
#endif

	CTxtPtr			tp(_ped, cp);
	LONG			cpBreak = cp > 0 ? cp - 1 : 0;
	CBreakArray*	pSyncObj = NULL;		// Break object to retrieve sync point
	LONG			cBrks = 1, cBrksSave;
	BOOL			fStop = TRUE;			// default: looking for stop
	LONG			cpStart, cpEnd;

	
	// Figure a boundary limited by whitespaces
	tp.FindWhiteSpaceBound(cchNew, cpStart, cpEnd);


	Assert (_pbrkWord || _pbrkChar);

	// Use wordbreak array (if available) to figure sync point,
	// otherwise use cluster break array
	if (_pbrkWord)
	{
		pSyncObj = _pbrkWord;
		cBrks = CWORD_TILLSYNC;
	}
	else if (_pbrkChar)
	{
		pSyncObj = _pbrkChar;
		cBrks = CCLUSTER_TILLSYNC;
		
		// for perf reason, we kept cluster breaks in invert logic.
		// Logic TRUE in the array means "NOT A CLUSTER BREAK". The array is
		// like a sparse metric full of 0.
		fStop = FALSE;
	}

	// Figure sync point so we can go from there.
	cBrksSave = cBrks;
	while (pSyncObj && cpBreak > cpStart)
	{
		if (pSyncObj->GetBreak(cpBreak) == fStop)
			if (!cBrks--)
				break;
		cpBreak--;
	}

	cpStart = cpBreak;
	tp.SetCp(cpStart);

	cBrks = cBrksSave;

	// adjust the end boundary to the state of break array.
	cpEnd -= cchNew - cchDel;
	cpBreak = cp + cchDel;
	while (pSyncObj && cpBreak < cpEnd)
	{
		if (pSyncObj->GetBreak(cpBreak) == fStop)
			if (!cBrks--)
				break;
		cpBreak++;
	}
	cpEnd = cpBreak;

	// adjust the end boundary back to the state of the backing store.
	cpEnd -= cchDel - cchNew;

	Assert (cpStart >= 0 && cpEnd >= 0 && cpStart <= cpEnd);

	if (cpStart == cpEnd)
	{
		// This is deletion process
		if (_pbrkWord)
			_pbrkWord->ReplaceBreak(cp, cchDel, 0);
		if (_pbrkChar)
			_pbrkChar->ReplaceBreak(cp, cchDel, 0);
	}
	else
	{
		CUniscribe*					pusp;
		const SCRIPT_PROPERTIES*	psp;
		SCRIPT_ITEM*				pi;
		SCRIPT_LOGATTR*				pl;
		PUSP_CLIENT					pc = NULL;
		BYTE						pbBufIn[MAX_CLIENT_BUF];
		WCHAR*						pwchString;
		LONG						cchString = cpEnd - cpStart;
		int							cItems;

		// Now with the minimum range, we begin itemize and break the word/clusters.
		// :The process is per item basis.
	
		// prepare Uniscribe
		pusp = _ped->Getusp();
		if (!pusp)
		{
			// No Uniscribe instance allowed to be created.
			// We failed badly!
			Assert (FALSE);
			return;
		}
	
		// allocate temp buffer for itemization
		pusp->CreateClientStruc(pbBufIn, MAX_CLIENT_BUF, &pc, cchString, cli_Itemize | cli_Break);
		if (!pc)
			// nom!
			return;
	
		Assert (tp.GetCp() == cpStart);
	
		tp.GetText(cchString, pc->si->pwchString);

		if (pusp->ItemizeString (pc, 0, &cItems, pc->si->pwchString, cchString, 0) > 0)
		{
			// Prepare room in the break array(s) to put the break results
			if (_pbrkWord)
				_pbrkWord->ReplaceBreak (cp, cchDel, cchNew);
			if (_pbrkChar)
				_pbrkChar->ReplaceBreak (cp, cchDel, cchNew);
	
			// Initial working pointers
			pi = pc->si->psi;
			pwchString = pc->si->pwchString;
			pl = pc->sb->psla;
	
			for (int i=0; i < cItems; i++)
			{
				psp = pusp->GeteProp(pi[i].a.eScript);
				if (psp->fComplex &&
					(psp->fNeedsWordBreaking || psp->fNeedsCaretInfo))
				{
					// Break only the item needing text break
					if ( ScriptBreak(&pwchString[pi[i].iCharPos], pi[i+1].iCharPos - pi[i].iCharPos,
									&pi[i].a, pl) != S_OK )
					{
						TRACEWARNSZ ("Calling ScriptBreak FAILED!");
						break;
					}
					// Fill in the breaking result
					cp = cpStart + pi[i].iCharPos;
					for (int j = pi[i+1].iCharPos - pi[i].iCharPos - 1; j >= 0; j--)
					{
						if (_pbrkWord)
							_pbrkWord->SetBreak(cp+j, pl[j].fWordStop);
						if (_pbrkChar)
							_pbrkChar->SetBreak(cp+j, !pl[j].fCharStop);
					}
				}
				else
				{
					// Note: ClearBreak is faster than ZeroMemory the CArray::ArInsert()
					if (_pbrkWord)
						_pbrkWord->ClearBreak(cpStart + pi[i].iCharPos, pi[i+1].iCharPos - pi[i].iCharPos);
					if (_pbrkChar)
						_pbrkChar->ClearBreak(cpStart + pi[i].iCharPos, pi[i+1].iCharPos - pi[i].iCharPos);
				}
			}
		}
	
		if (pc && pbBufIn != (BYTE*)pc)
			delete pc;
	}

#ifdef DEBUG
	if (_pbrkWord)
		Assert (_pbrkWord->GetCchBreak() - cchbrkw == cchNew - cchDel);
	if (_pbrkChar)
		Assert (_pbrkChar->GetCchBreak() - cchbrkc == cchNew - cchDel);
#endif
}

#endif	// !BITVIEW
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\tomsel.cpp ===
/*
 *	@doc TOM
 *
 *	@module	tomsel.cpp - Implement the CTxtSelection Class |
 *	
 *		This module contains the TOM ITextSelection implementation for
 *		the selection object
 *
 *	History: <nl>
 *		5/24/95 - Alex Gounares: stubs <nl>
 *		8/95	- Murray Sargent: core implementation
 *
 *	@comm
 *		The "cursor-pad" functions (Left, Right, Up, Down, Home, End)
 *		are simple generalizations of the corresponding keystrokes and have
 *		to express the same UI.  Consequently they are typically not as
 *		efficient for moving the cursor around as ITextRange methods, which
 *		are designed for particular purposes.  This is especially true for
 *		counts larger than one.
 *
 *	@devnote
 *		All ITextSelection methods inherited from ITextRange are handled by
 *		the ITextRange methods, since they either don't affect the display of
 *		the selection (e.g., Get methods), or virtual methods are used that
 *		perform the appropriate updating of the selection on screen.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_select.h"
#include "_disp.h"
#include "_edit.h"

#define DEBUG_CLASSNAME CTxtSelection
#include "_invar.h"


//---------------------- CTxtSelection methods	------------------------------------

/*
 *	CTxtSelection::EndKey (Unit, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI End key, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = start of line/document for
 *		Ctrl key not being/being depressed.  Returns *<p pDelta> = count of
 *		characters active end is moved forward, i.e., a number >= 0.
 *
 *	@rdesc
 *		HRESULT =  (invalid Unit) ? E_INVALIDARG :
 *				   (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::EndKey (
	long  	Unit,			//@parm Unit to use
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive count of chars moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::EndKey");

	return Homer(Unit, Extend, pDelta, End);
}

/*
 *	CTxtSelection::GetFlags (pFlags)
 *
 *	@mfunc
 *		Set <p pFlags> = this text selection's flags
 *
 *	@rdesc
 *		HRESULT = (<p pFlags>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtSelection::GetFlags(
	long * pFlags) 		//@parm Out parm to receive selection flags
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::GetFlags");

	if(!pFlags)
		return E_INVALIDARG;

	if(IsZombie())	
	{
		*pFlags = tomSelStartActive | tomSelReplace;
		return CO_E_RELEASED;
	}

	DWORD	dwFlags = _cch <= 0;			// Store tomSelStartActive value

	if(_fCaretNotAtBOL)
		dwFlags |= tomSelAtEOL;

	if(GetPed()->_fOverstrike)
		dwFlags |= tomSelOvertype;

	if(GetPed()->_fFocus)
		dwFlags |= tomSelActive;

	*pFlags = dwFlags | tomSelReplace;		// tomSelReplace isn't optional

	return NOERROR;
}

/*
 *	CTxtSelection::GetSelectionType (pType)
 *
 *	@mfunc
 *		Set *pType = type of this text selection
 *
 *	@rdesc
 *		HRESULT = <p pType> ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtSelection::GetType(
	long * pType) 		//@parm Out parm to receive selection type
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::GetSelectionType");

	if(!pType)
		return E_INVALIDARG;

	*pType = !_cch ? tomSelectionIP
		   : (_cch == -1 && _rpTX.GetChar() == WCH_EMBEDDING ||
			  _cch ==  1 && GetPrevChar()   == WCH_EMBEDDING)
		   ? tomSelectionInlineShape : tomSelectionNormal;

	return IsZombie() ? CO_E_RELEASED : NOERROR;
}

/*
 *	CTxtSelection::HomeKey (Unit, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI Home key, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = start of line/document for
 *		Ctrl key not being/being depressed.  Returns *<p pDelta> = count of
 *		characters active end is moved forward, i.e., a number <= 0.
 *
 *	@rdesc
 *		HRESULT =  (invalid Unit) ? E_INVALIDARG :
 *				   (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::HomeKey (
	long  	Unit,			//@parm Unit to use
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive count of chars moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::HomeKey");
	
	return Homer(Unit, Extend, pDelta, Home);
}

/*
 *	CTxtSelection::MoveDown (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI Down arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomLine/tomParagraph for
 *		Ctrl key not being/being depressed. In addition, <p Unit> can equal
 *		tomWindow/tomWindowEnd for the Ctrl key not being/being depressed.
 *		This second pair emulates PgDn behavior.  The method returns
 *		*<p pDelta> = actual count of units moved.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveDown (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveDown");
 	return GeoMover(Unit, Count, Extend, pDelta, 3);
}

/*
 *	CTxtSelection::MoveLeft (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI left arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomChar/tomWord for Ctrl key
 *		not	being/being	depressed.  Returns *<p pDelta> = actual count of
 *		units moved
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveLeft (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveLeft");

	return GeoMover(Unit, Count, Extend, pDelta, 0);
}

/*
 *	CTxtSelection::MoveRight (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI right arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomChar/tomWord for Ctrl key
 *		not	being/being	depressed.  Returns *<p pDelta> = actual count of
 *		units moved
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveRight (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveRight");
	return GeoMover(Unit, Count, Extend, pDelta, 1);
}

/*
 *	CTxtSelection::MoveUp (Unit, Count, Extend, pDelta)
 *
 *	@mfunc
 *		Act as UI Up arrow, such that <p Extend> is TRUE corresponds to the
 *		Shift key being depressed and <p Unit> = tomLine/tomParagraph for
 *		Ctrl key not being/being depressed. In addition, <p Unit> can equal
 *		tomWindow/tomWindowEnd for the Ctrl key not being/being depressed.
 *		This second pair emulates PgUp behavior.  The method returns
 *		*<p pDelta> = actual count of units moved.
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtSelection::MoveUp (
	long  	Unit,			//@parm Unit to use
	long  	Count,			//@parm Number of Units to move
	long  	Extend,			//@parm Extend selection or go to IP
	long *	pDelta)			//@parm Out parm to receive actual count of
							//		Units moved
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::MoveUp");

	return GeoMover(Unit, Count, Extend, pDelta, 2);
}

/*
 *	CTxtSelection::SetFlags (Flags)
 *
 *	@mfunc
 *		Set this text selection's flags = Flags
 *
 *	@rdesc
 *		HRESULT = NOERROR
 *
 *	@comm
 *		RichEdit ignores tomSelReplace since it's always on
 */
STDMETHODIMP CTxtSelection::SetFlags(
	long Flags) 			//@parm New flag values
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::SetFlags");

	if(IsZombie())	
		return CO_E_RELEASED;

	_fCaretNotAtBOL			= (Flags & tomSelAtEOL) != 0;
	GetPed()->_fOverstrike	= (Flags & tomSelOvertype) != 0;

	if(!(Flags & tomSelStartActive) ^ (_cch > 0))
		FlipRange();

	if((Flags & tomSelActive) && !GetPed()->_fFocus)
		GetPed()->TxSetFocus();

	return NOERROR;
}

/*
 *	CTxtRange::SetPoint (x, y, Extend)
 *
 *	@mfunc
 *		Select text at or up through (depending on <p Extend>) the point
 *		(<p x>, <p y>).
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
STDMETHODIMP CTxtSelection::SetPoint (
	long	x,			//@parm Horizontal coord of point to select
	long	y,			//@parm	Vertical   coord of point to select
	long 	Extend) 	//@parm Whether to extend selection to point
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::SelectPoint");

	if(IsZombie())	
		return CO_E_RELEASED;

	CCallMgr	callmgr(GetPed());
	POINT		pt = {x, y};

	if(Extend)
		ExtendSelection (pt);
	else
		SetCaret(pt, FALSE);		

	return NOERROR;
}

/*
 *	CTxtSelection::TypeText (bstr)
 *
 *	@mfunc
 *		Type the string given by bstr at this selection as if someone typed it.
 *		This is similar to the underlying ITextRange::SetText() method, but is
 *		sensitive to the Ins/Ovr key state.
 *
 *	@rdesc
 *		HRESULT = !<p bstr> ? E_INVALIDARG :
 *				  (whole string typed) ? NOERROR : S_FALSE
 *	@comm
 *		This is faster than sending chars via SendMessage(), but it's slower
 *		than using ITextRange::SetText()
 */
STDMETHODIMP CTxtSelection::TypeText (
	BSTR bstr)				//@parm String to type into this selection
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::TypeText");

	if(!bstr)
		return E_INVALIDARG;

	if(IsZombie())	
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());

	if(!GetPed()->IsntProtectedOrReadOnly(WM_CHAR, 0, 0))
		return E_ACCESSDENIED;

	BOOL			fOver	= GetPed()->_fOverstrike;
	DWORD			iCount;
	OLECHAR *		pch		= bstr;
	IUndoBuilder *	publdr;
	CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);
	CFreezeDisplay	fd(_pdp);

	iCount = SysStringLen(bstr);
	
	for ( ; iCount && PutChar(*pch++, fOver, publdr); iCount--)
	{
		// Simulate one character input at a time
		undobldr.Done();
	}
	return iCount ? S_FALSE : NOERROR;
}


//--------------------- ITextSelection PRIVATE helper methods -----------------------------

/*
 *	@doc INTERNAL
 *
 *	CTxtSelection::GeoMover (Unit, Count, Extend, pDelta, iDir)
 *
 *	@mfunc
 *		Helper function to move active end <p Count> <p Unit>s geometrically
 *
 *		Extends range if <p Extend> is TRUE; else collapses range to Start if
 *		<p Count> <lt> 0 and to End if <p Count> <gt> 0.
 *
 *		Sets *<p pDelta> = count of Units moved
 *
 *		Used by ITextSelection::Left(), Right(), Up(), and Down()
 *
 *	@rdesc
 *		HRESULT = (if change) ? NOERROR : (if Unit supported) ? S_FALSE
 *			: E_NOTIMPL
 */
HRESULT CTxtSelection::GeoMover (
	long  		Unit,		//@parm Unit to use
	long  		Count,		//@parm Number of Units to move
	long 	 	Extend,		//@parm Extend selection or go to IP
	long *	  	pDelta,		//@parm Out parm to receive count of Units moved
	LONG	  	iDir)		//@parm Direction to move in if Count > 0
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtSelection::GeoMover");

	if(pDelta)							// Default no movement
		*pDelta = 0;

	if(IsZombie())	
		return CO_E_RELEASED;

	CCallMgr callmgr(GetPed());
	LONG	 CountSave = Count;
	LONG	 cp;
	LONG	 cUnit;
	LONG	 iDefUnit = (iDir & 0xfe) == 2 ? tomLine : tomCharacter;
	BOOL	 fCollapse = !Extend && _cch;
	BOOL	 fCtrl	 = Unit != iDefUnit;

	_fExtend = Extend != 0;

	if(Count < 0)
	{
		Count = -Count;
		iDir ^= 1;
	}
	
	if(iDefUnit == tomLine)				// Up or Down
	{
		if(Unit == tomScreen)
		{
			iDir ^= 6;					// Convert Up/Down to PgUp/PgDn
			fCtrl = FALSE;
		}
		else if(Unit == tomWindow)		// Go to top/bottom of window
		{
			iDir ^= 6;					// Convert Up/Down to PgUp/PgDn
			Count = 1;					// Be sure Count = 1
		}								// Leave fCtrl = 1
		else if(fCtrl && Unit != tomParagraph)
			return E_INVALIDARG;
	}
	else if(fCtrl && Unit != tomWord)
		return E_INVALIDARG;

	for (cUnit = Count; Count; Count--)
	{
		cp = GetCp();					// Save cp for comparison
		switch(iDir)					// iDir bit 0 inc/dec for 1/0
		{								// iDir values are chosen contiguously
		case 0:							//  to encourage compiler to use a
			Left(fCtrl);				//  jump table
			break;

		case 1:							// tomCharacter/tomWord OK here
			Right(fCtrl);
			break;

		case 2:							// tomLine/tomParagraph OK here
			Up(fCtrl);
			break;

		case 3:							// tomLine/tomParagraph OK here
			Down(fCtrl);
			break;

		case 4:							// tomWindow/tomScreen OK here
			PageUp(fCtrl);
			break;

		case 5:							// tomWindow/tomScreen OK here
			PageDown(fCtrl);
		}
		if(cp == GetCp() && !fCollapse)	// Didn't move or collapse
			break;						//  so we're done
		fCollapse = FALSE;				// Collapse counts as a Unit
	}

	cUnit -= Count;						// Count of Units moved
	if(CountSave < 0)
		cUnit = -cUnit;					// Negative Counts get negative results

	if(pDelta)
		*pDelta = cUnit;

	return cUnit ? NOERROR : S_FALSE;
}

/*
 *	CTxtSelection::Homer (Unit, Extend, pDelta, pfn)
 *
 *	@mfunc
 *		Helper function to move active end Home or End depending on pfn
 *
 *		Extends range if <p Extend> is TRUE; else collapses range to Start if
 *		<p Count> <lt> 0 and to End if <p Count> <gt> 0.
 *
 *		Sets *<p pDelta> = count of chars moved	forward
 *
 *		Used by ITextSelection::Home(), End()
 *
 *	@rdesc
 *		HRESULT =  (invalid Unit) ? E_INVALIDARG :
 *				   (if change) ? NOERROR : S_FALSE
 */
HRESULT CTxtSelection::Homer (
	long  	Unit,			//@parm Unit to use
	long 	Extend,			//@parm Extend selection or go to IP
	long *	pDelta,			//@parm Out parm to receive count of Units moved
	BOOL	(CTxtSelection::*pfn)(BOOL))	//@parm Direction to move in
{
	TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtSelection::Homer");

	if(pDelta)							// Default no movement
		*pDelta = 0;

	if(IsZombie())	
		return CO_E_RELEASED;

	if(Unit != tomLine && Unit != tomStory)
		return E_INVALIDARG;

	CCallMgr callmgr(GetPed());
	LONG	 cch = GetCp();

	_fExtend = Extend != 0;

	(this->*pfn)(Unit != tomLine);
	cch = GetCp() - cch;
	if(pDelta)
		*pDelta = cch;

	return cch ? NOERROR : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\tomrange.cpp ===
/*
 *  @doc TOM
 *
 *  @module TOMRANGE.CPP - Implement the CTxtRange Class |
 *  
 *      This module contains the implementation of the TOM ITextRange
 *      interface on the CTxtRange object
 *
 *  History: <nl>
 *      5/24/95 - Alex Gounares: stubs created <nl>
 *      8/95    - MurrayS: main implementation <nl>
 *      11/95   - MurrayS: upgrade to TOM spec of 12/10/95 <nl>
 *      5/96    - MurrayS: added zombie protection
 *
 *  @comm
 *      All ITextRange methods return HRESULTs.  If the method can move a
 *      range cp, the HRESULT is NOERROR if movement occurs and S_FALSE if
 *      no movement occurs.  These methods usually take a <p pDelta> argument
 *      that returns the count of characters or Units actually moved.  If this
 *      parameter is NULL, E_INVALIDARG is returned.  Other return values
 *      include E_NOTIMPL, e.g., for Unit values not implemented,
 *      E_OUTOFMEMORY, e.g., when allocations fail, and CO_E_RELEASED, when
 *      the CTxtEdit (_ped) to which the range is attached has been deleted.
 *
 *      For more complete documentation, please see tom.doc
 *
 *  @devnote
 *      All ptr parameters must be validated before use and all entry points
 *      need to check whether this range is a zombie.  These checks are
 *      done in one of three places: 1) immediately on entry to a function,
 *      2) immediately on entry to a helper function (e.g., private Mover()
 *      for the move methods), or 3) before storing the out value.
 *      Alternative 3) is used for optional return values, such as pDelta
 *      and pB.
 *
 *      To achieve a simple, efficient inheritance model, CTxtSelection
 *      inherits ITextSelection through CTxtRange.  Otherwise we'd have a
 *      diamond inheritance, since ITextSelection itself inherits from
 *      ITextRange. Diamond inheritance creates two copies of the multiply
 *      inherited class unless that class is inherited virtually. Virtual
 *      inheritance uses run-time base-offset tables and is slower and
 *      bigger.  To avoid such a mess, we include the extra ITextSelection
 *      methods in CTxtRange, with the intention that they'll never be called
 *      and therefore they return E_NOTIMPL. This is overridden for
 *      ITextSelection objects
 *
 *  @future
 *      1) Finder match ^p, etc.
 *      2) Fast GetEffects() method. Would speed up the myriad IsProtected()
 *         calls and be useful for getting other effects as well.
 *      3) Fast copies/pastes of RichEdit binary format. This can be done by
 *         creating a method to copy a range to a new CTxtStory and a method
 *         to insert a CTxtStory.
 *      4) Delayed rendering
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_select.h"
#include "_edit.h"
#include "_line.h"
#include "_frunptr.h"
#include "_tomfmt.h"
#include "_disp.h"
#include "_objmgr.h"
#include "_callmgr.h"
#include "_measure.h"

ASSERTDATA

#define DEBUG_CLASSNAME CTxtRange
#include "_invar.h"

HRESULT QueryInterface (REFIID riid, REFIID riid1, IUnknown *punk,
                        void **ppv, BOOL fZombie);


//----------------- CTxtRange (ITextRange) PUBLIC methods ----------------------------------

//----------------------- CTxtRange IUnknown Methods -------------------------------------

/*
 *  CTxtRange::QueryInterface (riid, ppv)
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      HRESULT = (!ppv) ? E_INVALIDARG :
 *                (interface found) ? NOERROR : E_NOINTERFACE
 */
STDMETHODIMP CTxtRange::QueryInterface (
    REFIID  riid,           //@parm Reference to requested interface ID
    void ** ppv)            //@parm Out parm to receive interface ptr
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::QueryInterface");

    REFIID riid1 = _fSel && IsEqualIID(riid, IID_ITextSelection)
                 ? IID_ITextSelection : IID_ITextRange;
#ifndef PEGASUS
    return ::QueryInterface(riid, riid1, this, ppv, IsZombie());
#else
    return 0;
#endif
}

/*
 *  CTxtRange::AddRef()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - incremented reference count
 */
STDMETHODIMP_(ULONG) CTxtRange::AddRef()
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::AddRef");

    return ++_cRefs;
}

/*
 *  CTxtRange::Release()
 *
 *  @mfunc
 *      IUnknown method
 *
 *  @rdesc
 *      ULONG - decremented reference count
 */
STDMETHODIMP_(ULONG) CTxtRange::Release()
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Release");

    _cRefs--;

    if(!_cRefs)
    {
        delete this;
        return 0;
    }

    Assert(_cRefs > 0);
    return _cRefs;
}


//------------------------ CTxtRange IDispatch Methods -------------------------------------

/*
 *  CTxtRange::GetTypeInfoCount(pcTypeInfo)
 *
 *  @mfunc
 *      Get the number of TYPEINFO elements (1)
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CTxtRange::GetTypeInfoCount (
    UINT * pcTypeInfo)          //@parm Out parm to receive type-info count
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetTypeInfoCount");

    if(!pcTypeInfo)
        return E_INVALIDARG;

    *pcTypeInfo = 1;
    return NOERROR;
}

/*
 *  CTxtRange::GetTypeInfo(iTypeInfo, lcid, ppTypeInfo)
 *
 *  @mfunc
 *      Return ptr to type information object for ITextSelection interface
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CTxtRange::GetTypeInfo (
    UINT        iTypeInfo,      //@parm Index of type info to return
    LCID        lcid,           //@parm Local ID of type info
    ITypeInfo **ppTypeInfo)     //@parm Out parm to receive type info
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetTypeInfo");

    return ::GetTypeInfo(iTypeInfo, g_pTypeInfoSel, ppTypeInfo);
}

/*
 *  CTxtRange::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid)
 *
 *  @mfunc
 *      Get DISPIDs for methods in the ITextSelection, ITextRange, ITextFont,
 *      and ITextPara interfaces
 *
 *  @rdesc
 *      HRESULT
 *
 *  @devnote
 *      If the ITextFont and ITextPara ever offer more methods than exposed
 *      in their type libraries, the code should delegate to the corresponding
 *      GetIDsOfNames. The current code only gets DISPIDs for the methods in
 *      type libraries, thereby not having to instantiate the objects.
 */
STDMETHODIMP CTxtRange::GetIDsOfNames (
    REFIID      riid,           //@parm Interface ID to interpret names for
    OLECHAR **  rgszNames,      //@parm Array of names to be mapped
    UINT        cNames,         //@parm Count of names to be mapped
    LCID        lcid,           //@parm Local ID to use for interpretation
    DISPID *    rgdispid)       //@parm Out parm to receive name mappings
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetIDsOfNames");

    HRESULT hr = GetTypeInfoPtrs();             // Ensure TypeInfo ptrs are OK
    if(hr != NOERROR)
        return hr;
        
    if(g_pTypeInfoSel->GetIDsOfNames(rgszNames, cNames, rgdispid) == NOERROR)
        return NOERROR;

    if(g_pTypeInfoFont->GetIDsOfNames(rgszNames, cNames, rgdispid) == NOERROR)
        return NOERROR;

    return g_pTypeInfoPara->GetIDsOfNames(rgszNames, cNames, rgdispid);
}

/*
 *  CTxtRange::Invoke(dispidMember, riid, lcid, wFlags, pdispparams,
 *                    pvarResult, pexcepinfo, puArgError)
 *  @mfunc
 *      Invoke methods for the ITextRange and ITextSelection objects, as
 *      well as for ITextFont and ITextPara interfaces on those objects.
 *
 *  @rdesc
 *      HRESULT
 */
STDMETHODIMP CTxtRange::Invoke (
    DISPID      dispidMember,   //@parm Identifies member function
    REFIID      riid,           //@parm Pointer to interface ID
    LCID        lcid,           //@parm Locale ID for interpretation
    USHORT      wFlags,         //@parm Flags describing context of call
    DISPPARAMS *pdispparams,    //@parm Ptr to method arguments
    VARIANT *   pvarResult,     //@parm Out parm for result (if not NULL)
    EXCEPINFO * pexcepinfo,     //@parm Out parm for exception info
    UINT *      puArgError)     //@parm Out parm for error
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Invoke");

    HRESULT hr = GetTypeInfoPtrs();         // Ensure TypeInfo ptrs are OK
    if(hr != NOERROR)
        return hr;
        
    if(IsZombie())
        return CO_E_RELEASED;

    IDispatch * pDispatch;
    ITypeInfo * pTypeInfo;

    if((DWORD)dispidMember <= 0x2ff)        // Include default (0), selection,
    {                                       //  and range DISPIDs
        pTypeInfo = g_pTypeInfoSel;
        pDispatch = this;
        AddRef();                           // Compensate for Release() below
    }
    else if((DWORD)dispidMember <= 0x3ff)   // 0x300 to 0x3ff: DISPIDs
    {                                       //  reserved for ITextFont
        pTypeInfo = g_pTypeInfoFont;
        hr = GetFont((ITextFont**)&pDispatch);
    }
    else if((DWORD)dispidMember <= 0x4ff)   // 0x400 to 0x4ff: DISPIDs
    {                                       //  reserved for ITextPara
        pTypeInfo = g_pTypeInfoPara;
        hr = GetPara((ITextPara **)&pDispatch);
    }
    else                                    // dispidMember is negative or
        return DISP_E_MEMBERNOTFOUND;       //  > 0x4ff, i.e., not TOM

    if(hr != NOERROR)                       // Couldn't instantiate ITextFont
        return hr;                          //  or ITextPara

    hr = pTypeInfo->Invoke(pDispatch, dispidMember, wFlags,
                             pdispparams, pvarResult, pexcepinfo, puArgError);
#ifndef PEGASUS
    pDispatch->Release();
#endif
    return hr;
}


//----------------------- ITextRange Methods/Properties ------------------------

/*
 *  CTxtRange::CanEdit (pB)
 *
 *  @mfunc
 *      Set *<p pB> = tomTrue iff this range can be edited and
 *      pB isn't NULL
 *
 *  @rdesc
 *      HRESULT = (can edit) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::CanEdit (
    long * pB)          //@parm Out parm to receive boolean value
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::CanEdit");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());
    return IsTrue(!WriteAccessDenied(), pB);
}

/*
 *  CTxtRange::CanPaste (pVar, long Format, pB)
 *
 *  @mfunc
 *      Set *<p pB> = tomTrue iff the data object <p pVar>->punkVal can be
 *      pasted into this range and pB isn't NULL.  If <p pVar> is NULL,
 *      use the clipboard instead.
 *
 *  @rdesc
 *      HRESULT = (can paste) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::CanPaste (
    VARIANT *   pVar,       //@parm Data object to paste
    long        Format,     //@parm Desired clipboard format
    long *      pB)         //@parm Out parm to receive boolean value
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::CanPaste");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr        callmgr(GetPed());
    HRESULT         hr;
    IDataObject *   pdo = NULL;             // Default clipboard

    if(pVar && pVar->vt == VT_UNKNOWN)
        pVar->punkVal->QueryInterface(IID_IDataObject, (void **)&pdo);

    hr = IsTrue(!WriteAccessDenied() &&
                (GetPed()->GetDTE()->CanPaste(pdo, (CLIPFORMAT)Format,
                 RECO_PASTE)), pB);
    if(pdo)
        pdo->Release();

    return hr;
#else
    return 0;
#endif
}

/*
 *  ITextRange::ChangeCase (long Type)
 *
 *  @mfunc
 *      Change the case of letters in this range according to Type:
 *
 *      tomSentenceCase = 0: capitalize first letter of each sentence
 *      tomLowerCase    = 1: change all letters to lower case
 *      tomUpperCase    = 2: change all letters to upper case
 *      tomTitleCase    = 3: capitalize the first letter of each word
 *      tomToggleCase   = 4: toggle the case of each letter
 *  
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::ChangeCase (
    long Type)      //@parm Type of case change. Default value: tomLower
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::ChangeCase");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);
    LONG            cpMin, cpMax;
    LONG            cch = GetRange(cpMin, cpMax);
    CRchTxtPtr      rtp(*this);

    undobldr.StopGroupTyping();

    rtp.SetCp(cpMin);
    return (rtp.ChangeCase(cch, Type, publdr)) ? NOERROR : S_FALSE;
}

/*
 *  CTxtRange::Collapse (bStart)
 *
 *  @mfunc
 *      Collapse this range into a degenerate point either at the
 *      the start (<p bStart> is nonzero or the end (<p bStart> = 0)
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::Collapse (
    long bStart)            //@parm Flag specifying end to collapse at
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Collapse");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(!_cch)                           // Already collapsed
        return S_FALSE;                 // Signal that no change occurred
        
    Collapser(bStart);
    Update(TRUE);                       // Update selection
    return NOERROR;                     // Signal that change occurred
}

/*
 *  CTxtRange::Copy (pVar)
 *
 *  @mfunc
 *      Copy the plain and/or rich text to a data object and return the
 *      object ptr in <p pVar>.  If <p pVar> is null, copy to the clipboard.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::Copy (
    VARIANT * pVar)             //@parm Out parm for data object
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Copy");

    if(IsZombie())
        return CO_E_RELEASED;

    CLightDTEngine * pldte = &GetPed()->_ldte;

    if(pVar && pVar->vt == (VT_UNKNOWN | VT_BYREF))
    {
        return pldte->RangeToDataObject(this, SF_TEXT | SF_RTF,
                                    (IDataObject **)pVar->ppunkVal);
    }
    return pldte->CopyRangeToClipboard(this);
#else
    return 0;
#endif
}

/*
 *  CTxtRange::Cut (pVar)
 *
 *  @mfunc
 *      Cut the plain and/or rich text to a data object and return the
 *      object ptr in <p pVar>.  If <p pVar> is null,
 *      cut to the clipboard.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::Cut (
    VARIANT * pVar)     //@parm Out parm for data object
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Cut");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    HRESULT hr = Copy(pVar);

    Replacer(0, NULL);
    return hr;
}

/*
 *  CTxtRange::Delete (Unit, Count, pDelta)
 *
 *  @mfunc
 *      If this range is nondegenerate, delete it along with |Count| - 1 Units
 *      in the direction specified by the sign of Count.  If this range is
 *      degenerate, delete Count Units.
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (all requested Units deleted) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::Delete (
    long    Unit,           //@parm Unit to use
    long    Count,          //@parm Number of chars to delete
    long *  pDelta)         //@parm Out parm to receive count of units deleted
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Delete");

    if(pDelta)
        *pDelta = 0;
    
    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    LONG    cchSave = _cch;                 // Remember initial count
    LONG    cchText = GetAdjustedTextLength();
    LONG    CountOrg = Count;
    LONG    cpMin, cpMost;
    LONG    cUnit = 0;                      // Default no Units
    MOVES   Mode = (Count >= 0) ? MOVE_END : MOVE_START;

    GetRange(cpMin, cpMost);
    if(cpMost > cchText)                    // Can't delete final CR. To get
    {                                       //  *pDelta right, handle here
        Set(cpMin, cpMin - cchText);        // Backup before CR & set active
        if(Count > 0)                       //  end at cpMin since there's
        {                                   //  nothing to delete forward
            Count = 0;
            if(!_cch)                       // Only collapsed selection of
                Mode = MOVE_IP;             //  final CR: set up nothing
        }                                   //  deleted (MOVE_IP = 0)
    }
    if(Count)
    {
        if((_cch ^ Mode) < 0)               // Be sure active end is in
            FlipRange();                    //  deletion direction
        if(cchSave)                         // Deleting nondegenerate range
            Count -= Mode;                  //  counts as one unit
        if(Mover(Unit, Count, &cUnit, Mode) // Try to expand range for
            == E_INVALIDARG)                //  remaining Count Units
        {
            if(pDelta)
                *pDelta = 0;
            return E_INVALIDARG;
        }
        if(GetCp() > cchText && cUnit > 0)  // Range includes final CR, which
        {                                   //  cannot be deleted. Reduce
            if(Unit == tomCharacter)        //  counts for some Units
                cUnit -= GetTextLength() - cchText;
            else if(Unit == tomWord)
                cUnit--;                    // An EOP qualifies as a tomWord
        }
    }

    if(cchSave)                             // Deleting nondegenerate range
        cUnit += Mode;                      //  counts as a Unit

    if(pDelta)
        *pDelta = cUnit;

    if(_cch)                                // Mover() may have changed _cch
    {                                       
        IUndoBuilder *  publdr;
        CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);

        if (publdr)
        {
            publdr->StopGroupTyping();
            publdr->SetNameID(UID_DELETE);
        }

        // FUTURE (murrays): the cchSave case should set up undo to
        // restore the original range, not the extended range resulting
        // when |CountOrg| > 1.  This could be done using two calls to
        // ReplaceRange(), one to delete the original range and one to
        // delete the rest
        SELRR selrr = !_fSel || cchSave ? SELRR_REMEMBERRANGE :
                      CountOrg > 0      ? SELRR_REMEMBERCPMIN :
                                          SELRR_REMEMBERENDIP;

        ReplaceRange(0, NULL, publdr, selrr);

        if (cUnit == CountOrg ||            // Delete(Unit,0,0)
            cUnit == 1 && !CountOrg)        //  deletes one "Unit", namely
        {                                   //  what's selected
            return NOERROR;                 // Signal everything deleted as
        }                                   //  requested
    }
    else if(cchSave)                        // Collapsed selection of final CR
    {                                       //  but didn't delete anything
        Update(TRUE);                       // Selection highlighting changed
    }
    return S_FALSE;                         // Less deleted than requested
}

/*
 *  CTxtRange::EndOf (Unit, Extend, pDelta)
 *
 *  @mfunc
 *      Move this range end(s) to end of the first overlapping Unit in
 *      the range.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 */
STDMETHODIMP CTxtRange::EndOf (
    long    Unit,           //@parm Unit to use
    long    Extend,         //@parm If true, leave other end alone
    long *  pDelta)         //@parm Count of chars that End is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::EndOf");

    CCallMgr    callmgr(GetPed());
    LONG        cpMost;

    HRESULT hr = Expander (Unit, Extend, pDelta, NULL, &cpMost);
    if(hr == NOERROR)
        Update(TRUE);                   // Update selection

    return hr;
}

/*
 *  CTxtRange::Expand (Unit, pDelta)
 *
 *  @mfunc
 *      Expand this range so that any partial Units it contains are
 *      completely contained.  If this range consists of one or more full
 *      Units, no change is made.  If this range is an insertion point at
 *      the beginning or within a Unit, Expand() expands this range to include
 *      that Unit.  If this range is an insertion point at the end of the
 *      story, Expand() tries to set this range to include the last Unit in
 *      the story.  The active end is always cpMost except for the last case.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 */
STDMETHODIMP CTxtRange::Expand (
    long    Unit,           //@parm Unit to expand range to
    long *  pDelta)         //@parm Out parm to receive count of chars added
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Expand");

    CCallMgr callmgr(GetPed());
    LONG     cpMin, cpMost;

    HRESULT hr = Expander (Unit, TRUE, pDelta, &cpMin, &cpMost);
    if(hr == NOERROR)
        Update(TRUE);                   // Update selection

    return hr;
}

/*
 *  CTxtRange::FindText (bstr, cch, Flags, pLength)
 *
 *  @mfunc
 *      If this range isn't an insertion point already, convert it into an
 *      insertion point at its End if <p cch> <gt> 0 and at its Start if
 *      <p cch> <lt> 0.  Then search up to <p cch> characters of the range
 *      looking for the string <p bstr> subject to the compare flags
 *      <p Flags>.  If <p cch> <gt> 0, the search is forward and if <p cch>
 *      <lt> 0 the search is backward.  If the string is found, the range
 *      limits are changed to be those of the matched string and *<p pLength>
 *      is set equal to the length of the string. If the string isn't found,
 *      the range remains unchanged and *<p pLength> is set equal to 0.
 *
 *  @rdesc
 *      HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Argument validation of the three Find methods is done by the helper
 *      function CTxtRange::Finder(bstr, cch, dwFlags, pDelta, fExtend, fFlip)
 */
STDMETHODIMP CTxtRange::FindText (
    BSTR    bstr,       //@parm String to find
    long    Count,      //@parm Max count of chars to search
    long    Flags,      //@parm Flags governing compares
    long *  pDelta)     //@parm Out parm to receive count of chars moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::FindText");

    return Finder(bstr, Count, Flags, pDelta, MOVE_IP);
}

/*
 *  CTxtRange::FindTextEnd (bstr, cch, Flags, pLength)
 *
 *  @mfunc
 *      Starting from this range's End, search up to <p cch> characters
 *      looking for the string <p bstr> subject to the compare flags
 *      <p Flags>.  If <p cch> <gt> 0, the search is forward and if <p cch>
 *      <lt> 0 the search is backward.  If the string is found, the range
 *      limits are changed to be those of the matched string and *<p pLength>
 *      is set equal to the length of the string. If the string isn't found,
 *      the range remains unchanged and *<p pLength> is set equal to 0.
 *
 *  @rdesc
 *      HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::FindTextEnd (
    BSTR    bstr,       //@parm String to find
    long    Count,      //@parm Max count of chars to search
    long    Flags,      //@parm Flags governing compares
    long *  pDelta)     //@parm Out parm to receive count of chars moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::FindTextEnd");

    return Finder(bstr, Count, Flags, pDelta, MOVE_END);
}

/*
 *  CTxtRange::FindTextStart (bstr, cch, Flags, pDelta)
 *
 *  @mfunc
 *      Starting from this range's Start, search up to <p cch> characters
 *      looking for the string <p bstr> subject to the compare flags
 *      <p Flags>.  If <p cch> <gt> 0, the search is forward and if <p cch>
 *      <lt> 0 the search is backward.  If the string is found, the range
 *      limits are changed to be those of the matched string and *<p pLength>
 *      is set equal to the length of the string. If the string isn't found,
 *      the range remains unchanged and *<p pLength> is set equal to 0.
 *
 *  @rdesc
 *      HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::FindTextStart (
    BSTR    bstr,       //@parm String to find
    long    Count,      //@parm Max count of chars to search
    long    Flags,      //@parm Flags governing compares
    long *  pDelta)     //@parm Out parm to receive count of chars moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::FindTextStart");

    return Finder(bstr, Count, Flags, pDelta, MOVE_START);
}

/*
 *  CTxtRange::GetChar (pChar)
 *
 *  @mfunc
 *      Set *<p pChar> equal to the character at cpFirst
 *
 *  @rdesc
 *      HRESULT = (<p pChar>) NOERROR ? E_INVALIDARG
 *
 *  @devnote
 *      This method is very handy for walking a range character by character
 *      from the Start. Accordingly, it's desirable that the active end
 *      is at the Start. We set this up for a range, since the API doesn't
 *      care which range end is active.  But we can't do this for a selection,
 *      since the selection API depends on the active end.
 */
STDMETHODIMP CTxtRange::GetChar (
    long * pChar)           //@parm Out parm for char
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetChar");

    HRESULT hr = GetLong(0, pChar);
    if(hr != NOERROR)
        return hr;

    if(_cch > 0)                            // Active end at cpMost (End)
    {
        if(_fSel)
        {
            CTxtPtr tp(_rpTX);              // For selection, can't change
            tp.AdvanceCp(-_cch);            //  active end
            *pChar = (long)(tp.GetChar());
            return NOERROR;
        }
        FlipRange();                        // For range, it's more efficient
    }                                       //  to work from cpFirst and API
    *(DWORD *)pChar = _rpTX.GetChar();      //  doesn't expose RichEdit active
                                            //  end
    return NOERROR;
}

/*
 *  CTxtRange::GetDuplicate (ppRange)
 *
 *  @mfunc
 *      Get a clone of this range object.  For example, you may want to
 *      create an insertion point to traverse a range, so you clone the
 *      range and then set the clone's cpLim equal to its cpFirst. A range
 *      is characterized by its cpFirst, cpLim, and the story it belongs to.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR :
 *                (<p ppRange>) ? E_OUTOFMEMORY : E_INVALIDARG
 *
 *  @comm
 *      Even if this range is a selection, the clone returned is still only
 *      a range.
 */
STDMETHODIMP CTxtRange::GetDuplicate (
    ITextRange ** ppRange)      //@parm Out parm to receive duplicate of range
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetDuplicate");

    HRESULT hr = GetLong(NULL, (LONG *)ppRange);
    if(hr != NOERROR)
        return hr;

    ITextRange *prg = new CTxtRange(*this);
    if(prg)
    {
        *ppRange = prg;
        prg->AddRef();
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}

/*
 *  ITextRange::GetEmbeddedObject (ppV)
 *
 *  @mfunc
 *      Property get method that gets a ptr to the object at cpFirst
 *
 *  @rdesc
 *      HRESULT = (!ppV) ? E_INVALIDARG :
 *                (object found) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::GetEmbeddedObject (
    IUnknown **ppV)         //@parm Out parm to receive embedded object
{
    HRESULT hr = GetLong(NULL, (LONG *)ppV);
    if(hr != NOERROR)
        return hr;
    
    if(GetObjectCount())
    {
        COleObject *pobj = GetPed()->_pobjmgr->GetObjectFromCp(GetCpMin());

        if(pobj && (*ppV = pobj->GetIUnknown()) != NULL)
        {
            (*ppV)->AddRef();
            return NOERROR;
        }
    }
    return S_FALSE;
}

/*
 *  CTxtRange::GetEnd (pcpLim)
 *
 *  @mfunc
 *      Get this range's End (cpMost) cp
 *
 *  @rdesc
 *      HRESULT = (<p pcpLim>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetEnd (
    long * pcpLim)          //@parm Out parm to receive End cp value
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetEnd");

    return GetLong(GetCpMost(), pcpLim);
}

/*
 *  CTxtRange::GetFont (ppFont)
 *
 *  @mfunc
 *      Get an ITextFont object with the character attributes of this range     
 *
 *  @rdesc
 *      HRESULT = <p ppFont> ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetFont (
    ITextFont ** ppFont)    //@parm Out parm to receive ITextFont object
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetFont");

    HRESULT hr = GetLong(NULL, (LONG *)ppFont);
    if(hr != NOERROR)
        return hr;

    *ppFont = (ITextFont *) new CTxtFont(this);
    return *ppFont ? NOERROR : E_OUTOFMEMORY;
}

/*
 *  CTxtRange::GetFormattedText (ppRange)
 *
 *  @mfunc
 *      Retrieves an ITextRange with this range's formatted text.
 *      If <p ppRange> is NULL, the clipboard is the target.
 *
 *  @rdesc
 *      HRESULT = (if success)  ? NOERROR :
 *                (<p ppRange>) ? E_OUTOFMEMORY : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetFormattedText (
    ITextRange ** ppRange)      //@parm Out parm to receive formatted text
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetFormattedText");

    return GetDuplicate(ppRange);
}

/*
 *  CTxtRange::GetIndex (Unit, pIndex)
 *
 *  @mfunc
 *      Set *<p pIndex> equal to the Unit number at this range's cpFirst
 *
 *  @rdesc
 *      HRESULT = (!<p pIndex>) ? E_INVALIDARG :
 *                (Unit not implemented) ? E_NOTIMPL :
 *                (Unit available) ? NOERROR : S_FALSE
 *  @future
 *      implement tomWindow?
 */
STDMETHODIMP CTxtRange::GetIndex (
    long    Unit,           //@parm Unit to index
    long *  pIndex)         //@parm Out parm to receive index value
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetIndex");

    HRESULT hr = GetLong(0, pIndex);
    if(hr != NOERROR)
        return hr;

    LONG      cp;
    LONG      cUnit = tomBackward;
    CTxtRange rg(*this);

    hr = rg.Expander(Unit, FALSE, NULL,         // Go to Start of Unit; else
                             &cp, NULL);        //  UnitCounter gives 1 extra
    if(FAILED(hr))
        return hr;                              // Unit not recognized

    LONG cch = rg.UnitCounter(Unit, cUnit, 0);
    
    if(cch == tomForward)                       // UnitCounter() doesn't know
        return E_NOTIMPL;                       //  Unit

    if(cch == tomBackward)                      // Unit not in story
        return S_FALSE;

    *pIndex = -cUnit + 1;                       // Make count positive and
                                                //  1-based
    return NOERROR;
}

/*
 *  CTxtRange::GetPara (ppPara)
 *
 *  @mfunc
 *      Get an ITextPara object with the paragraph attributes of this range     
 *
 *  @rdesc
 *      HRESULT = <p ppPara> ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetPara (
    ITextPara ** ppPara)    //@parm Out parm to receive ITextPara object
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetPara");

    HRESULT hr = GetLong(NULL, (LONG *)ppPara);
    if(hr != NOERROR)
        return hr;

    *ppPara = (ITextPara *) new CTxtPara(this);
    return *ppPara ? NOERROR : E_OUTOFMEMORY;
}

/*
 *  CTxtRange::GetPoint (px, py, Type)
 *
 *  @mfunc
 *      Get point for selection Start or End and intraline position
 *      as determined by <p Type>.
 *
 *  @rdesc
 *      HRESULT = (!<p px> or !<p py>) ? E_INVALIDARG :
 *                (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::GetPoint (
    long    Type,       //@parm Type of point
    long *  px,         //@parm Out parm for x coordinate
    long *  py)         //@parm Out parm for y coordinate
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtSelection::GetPoint");

    if(!px || !py)
        return E_INVALIDARG;

    *px = *py = 0;

    if(IsZombie())
        return CO_E_RELEASED;

    LONG        ili;
    BOOL        fAtEnd = _cch > 0;              // Default value for IP
    POINT       pt;
    CRchTxtPtr  rtp(*this);                     // Default active end
    CTxtEdit *  ped = GetPed();
    CDisplay *  pdp = ped->_pdp;                // Save indirections

    if(!pdp || !ped->fInplaceActive())
        return E_FAIL;                          // No display or not active
                                                // then we can do nothing.
    if(fAtEnd ^ !(Type & tomStart))             // Move tp to active end
        rtp.Advance(-_cch);

    ili = pdp->PointFromTp(rtp, NULL, fAtEnd, pt, NULL, Type & 0x1f);

    RECT rcView;                                // Verify return value makes
                                                // sense since PointFromTp
    pdp->GetViewRect(rcView, NULL);             // may return values outside
                                                // client rect
    rcView.bottom++;                            // Enlarge Rect to include
    rcView.right++;                             // bottom and right edges
    if(ili >= 0 && PtInRect(&rcView, pt))       // Function succeeded
    {
        // Caller wants screen coordinates?
        if ( !(Type & tomClientCoord) )
            ped->TxClientToScreen(&pt); 

        *px = pt.x;
        *py = pt.y;
        return NOERROR;
    }
    return S_FALSE;                             // Function failed
}

/*
 *  CTxtRange::GetStart (pcpFirst)
 *
 *  @mfunc
 *      Get this range's Start (cpMin) cp
 *
 *  @rdesc
 *      HRESULT = (<p pcpFirst>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetStart (
    long * pcpFirst)        //@parm Out parm to receive Start cp value
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetStart");

    return GetLong(GetCpMin(), pcpFirst);
}

/*
 *  CTxtRange::GetStoryLength (pcch)
 *
 *  @mfunc
 *      Set *<p pcch> = count of chars in this range's story
 *
 *  @rdesc
 *      HRESULT = (<p pcch>) ? NOERROR : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetStoryLength (
    long * pcch)        //@parm Out parm to get length of this range's story
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetStoryLength");

    return GetLong(GetTextLength(), pcch);
}

/*
 *  ITextRange::GetStoryType (pValue)
 *
 *  @mfunc
 *      Property get method that gets the type of this range's
 *      story.
 *
 *  @rdesc
 *      HRESULT = (pValue) NOERROR ? E_INVALIDARG
 */
STDMETHODIMP CTxtRange::GetStoryType (
    long *pValue)       //@parm Out parm to get type of this range's story
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetStoryType");

    return GetLong(tomUnknownStory, pValue);
}

/*
 *  CTxtRange::GetText (pbstr)
 *
 *  @mfunc
 *      Get plain text in this range. The Text property is the default
 *      property for ITextRange.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR :
 *                (!<p pbstr>) ? E_INVALIDARG : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::GetText (
    BSTR * pbstr)               //@parm Out parm to receive bstr
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetText");

    HRESULT hr = GetLong(NULL, (LONG *)pbstr);
    if(hr != NOERROR)
        return hr;

    if(!GetCch())
        return NOERROR;
        
    LONG cpMin, cpMost;
    LONG cch = GetRange(cpMin, cpMost);

    *pbstr = SysAllocStringLen(NULL, cch);
    if(!*pbstr)
        return E_OUTOFMEMORY;

    CTxtPtr tp(_rpTX);
    tp.SetCp(cpMin);
    tp.GetText( cch, (TCHAR*) * pbstr );
    return NOERROR;
}

/*
 *  CTxtRange::InRange (pRange, pB)
 *
 *  @mfunc
 *      Returns *<p pB> = tomTrue iff this range points within or at the same
 *      text as <p pRange> does
 *
 *  @rdesc
 *      HRESULT = (within range) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::InRange (
    ITextRange * pRange,        //@parm ITextRange to compare with
    long *       pB)            //@parm Out parm for comparison result
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::InRange");

    return IsTrue(Comparer(pRange), pB);
}


/*
 *  CTxtRange::InStory (pRange, pB)
 *
 *  @mfunc
 *      Return *pB = tomTrue iff this range's story is the same as
 *      <p pRange>'s
 *
 *  @rdesc
 *      HRESULT = (in story) ? NOERROR : S_FALSE
 *
 *  @future
 *      If RichEdit acquires the ability to have multiple stories and
 *      therefore ranges get a _story member, then compare that member
 *      instead of calling _rpTX.SameRuns().
 */
STDMETHODIMP CTxtRange::InStory (
    ITextRange *pRange,     //@parm ITextRange to query for private interface
    long *      pB)         //@parm Out parm to receive tomBool result
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::InStory");

    return IsTrue(IsSameVtables(this, pRange) &&        // Same vtables,
        _rpTX.SameRuns(&((CTxtRange *)pRange)->_rpTX),  //  same Runs
        pB);
#else
    return 0;
#endif
}

/*
 *  CTxtRange::IsEqual (pRange, pB)
 *
 *  @mfunc
 *      Returns *<p pB> = tomTrue iff this range points at the same text (cp's
 *      and story) as <p pRange> does and pB isn't NULL.
 *
 *  @rdesc
 *      HRESULT = (equal objects) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::IsEqual (
    ITextRange * pRange,        //@parm ITextRange to compare with
    long *       pB)            //@parm Out parm for comparison result
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::IsEqual");

    return IsTrue(Comparer(pRange) < 0, pB);
}

/*
 *  CTxtRange::Move (Unit, Count, pDelta)
 *
 *  @mfunc
 *      Move end(s) <p Count> <p Unit>'s, returning *<p pDelta> = # units
 *      actually moved. In general, this method converts a range into an
 *      insertion point if it isn't already, and moves the insertion point.
 *      If <p Count> <gt> 0, motion is forward toward the end of the story;
 *      if <p Count> <lt> 0, motion is backward toward the beginning.
 *      <p Count> = 0 moves cpFirst to the beginning of the <p Unit>
 *      containing cpFirst.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 *  @devnote
 *      Argument validation of the three Move methods is done by the helper
 *      function CTxtRange::Mover(Unit, Count, pDelta, Mode)
 */
STDMETHODIMP CTxtRange::Move (
    long    Unit,           //@parm Unit to use
    long    Count,          //@parm Number of Units to move
    long *  pDelta)         //@parm Out parm to receive actual count of
                            //      Units end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Move");
    CCallMgr    callmgr(GetPed());

    return Mover(Unit, Count, pDelta, MOVE_IP);
}

/*
 *  CTxtRange::MoveEnd (Unit, Count, pDelta)
 *
 *  @mfunc
 *      Move End end <p Count> <p Unit>'s, returning *<p pDelta> = # units
 *      actually moved
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 */
STDMETHODIMP CTxtRange::MoveEnd (
    long    Unit,           //@parm Unit to use
    long    Count,          //@parm Number of Units to move
    long *  pDelta)         //@parm Out parm to receive actual count of
                            //      Units end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveEnd");
    CCallMgr    callmgr(GetPed());

    return Mover(Unit, Count, pDelta, MOVE_END);
}

/*
 *  CTxtRange::MoveEndUntil (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Move the End just past all contiguous characters that are not found
 *      in the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveEndUntil (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveEndUntil");

    return Matcher(Cset, Count, pDelta, MOVE_END, MATCH_UNTIL);
}

/*
 *  CTxtRange::MoveEndWhile (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Move the End just past all contiguous characters that are found in
 *      the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveEndWhile (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveEndWhile");

    return Matcher(Cset, Count, pDelta, MOVE_END, MATCH_WHILE);
}

/*
 *  CTxtRange::MoveStart (Unit, Count, pDelta)
 *
 *  @mfunc
 *      Move Start end <p Count> <p Unit>'s, returning *<p pDelta> = # units
 *      actually moved
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit supported) ? S_FALSE : E_NOTIMPL
 */
STDMETHODIMP CTxtRange::MoveStart (
    long    Unit,           //@parm Unit to use
    long    Count,          //@parm Number of Units to move
    long *  pDelta)         //@parm Out parm to receive actual count of
                            //      Units end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveStart");
    CCallMgr    callmgr(GetPed());

    return Mover(Unit, Count, pDelta, MOVE_START);
}

/*
 *  CTxtRange::MoveStartUntil (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Move the Start just past all contiguous characters that are not found
 *      in the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveStartUntil (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveStartUntil");

    return Matcher(Cset, Count, pDelta, MOVE_START, MATCH_UNTIL);
}

/*
 *  CTxtRange::MoveStartWhile (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Move the Start just past all contiguous characters that are found in
 *      the set of characters specified by the VARIANT <p Cset> parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveStartWhile (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveStartWhile");

    return Matcher(Cset, Count, pDelta, MOVE_START, MATCH_WHILE);
}

/*
 *  CTxtRange::MoveUntil (Cset,Count, pDelta)
 *
 *  @mfunc
 *      Convert this range into an insertion point if it isn't already,
 *      and keep moving the insertion point until encountering any
 *      character in the set of characters specified by the VARIANT cset
 *      parameter.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::MoveUntil (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveUntil");
                            
    return Matcher(Cset, Count, pDelta, MOVE_IP, MATCH_UNTIL);
}

/*
 *  CTxtRange::MoveWhile (Cset, Count, pDelta)
 *
 *  @mfunc
 *      Convert this range into an insertion point if it isn't already,
 *      and keep moving the insertion point so long as (while) the
 *      characters past by are found in set of characters specified by
 *      the VARIANT cset parameter.  Such a contiguous set of characters
 *      is known as a span of characters.  The magnitude of the <p Count>
 *      parameter gives the maximum number of characters to move past and
 *      the sign of <p Count> specifies the direction to move in.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 *
 *  @devnote
 *      Argument validation of the MoveWhile and MoveUntil methods is done by
 *      the helper CTxtRange::Matcher (Cset, Count, pDelta, fExtend, fSpan)
 */
STDMETHODIMP CTxtRange::MoveWhile (
    VARIANT * Cset,             //@parm Character match set to use
    long      Count,            //@parm Max number of characters to move past
    long *    pDelta)           //@parm Out parm to receive actual count of
                                //      characters end is moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::MoveWhile");
                            
    return Matcher(Cset, Count, pDelta, MOVE_IP, MATCH_WHILE);
}

/*
 *  CTxtRange::Paste (pVar, ClipboardFormat)
 *
 *  @mfunc
 *      Paste the data object <p pVar> into this range.  If
 *      <p pVar> is null, paste from the clipboard.
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (if success) ? NOERROR : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::Paste (
    VARIANT *pVar,              //@parm Data object to paste
    long     ClipboardFormat)   //@parm Desired clipboard format
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Paste");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr        callmgr(GetPed());
    HRESULT         hr;
    IDataObject *   pdo = NULL;         // Default clipboard
    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    if(pVar)
        if (pVar->vt == VT_UNKNOWN)
            pVar->punkVal->QueryInterface(IID_IDataObject, (void **)&pdo);
        else if (pVar->vt == (VT_UNKNOWN | VT_BYREF))
            pdo = (IDataObject *)(*pVar->ppunkVal);

    hr = GetPed()->PasteDataObjectToRange (pdo, this,
        (WORD)ClipboardFormat, NULL, publdr, PDOR_NONE);

    if(pdo && pVar->vt == VT_UNKNOWN)
        pdo->Release();
    Update(TRUE);                       // Update selection
    return hr;
#else
    return 0;
#endif
}

/*
 *  ITextRange::ScrollIntoView(long Code)
 *
 *  @mfunc
 *      Method that scrolls this range into view according to the
 *      code Code defined below.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::ScrollIntoView (
    long Code)          //@parm Scroll code
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::ScrollIntoView");

    // Check for invalid bits
    if (Code & ~(tomStart + tomEnd + TA_LEFT + TA_TOP + TA_BOTTOM +
                TA_CENTER + TA_STARTOFLINE + TA_ENDOFLINE + TA_LOGICAL))
        return E_INVALIDARG;

    // Validate parameter
    long lCode = tomEnd;
    if (Code & tomStart)
        lCode = tomStart;

    Code &= ~tomStart;

    if(IsZombie())
        return CO_E_RELEASED;

    // Get local copy of ped to save some indirections.
    CTxtEdit *ped = GetPed();

    if (!ped->fInplaceActive())
    {
        // If the control is not active, we can't get the information
        // because no one knows what our client rect is.
        return E_FAIL;
    }

    // Get a local copy of display to save some indirections.
    CDisplay *pdp = ped->_pdp;

    if (pdp->IsFrozen())
    {
        return E_FAIL;
    }

    LONG cpStart;
    LONG cpForEnd;

    GetRange(cpStart, cpForEnd);

    // Get the view rectangle so we can compute the absolute x/y
    RECT rcView;
    pdp->GetViewRect(rcView, NULL);

    // Set up tp for PointFromTp call
    CRchTxtPtr rtp(*this);

    if(_cch > 0)
        rtp.Advance(-_cch);

    // Values used for making returned point locations absolute since
    // PointFromTp adjusts the point returned to be relative to the
    // display.
    const LONG xScrollAdj = pdp->GetXScroll() - rcView.left;
    const LONG yScrollAdj = pdp->GetYScroll() - rcView.top;

    // Get the left/top for the start
    BOOL     taMask = Code & TA_STARTOFLINE; //set beginning of line flag
    BOOL     fAtEnd = _cch ? TRUE : !rtp._rpTX.IsAfterEOP();
    POINT    ptStart;
    CLinePtr rpStart(pdp);
    LONG     iliStart = pdp->PointFromTp(rtp, NULL, _cch ? FALSE : fAtEnd,
                                         ptStart, &rpStart, (lCode == tomStart && Code) ?  Code :
                                         TA_TOP + TA_LEFT);
    ptStart.x += xScrollAdj;
    ptStart.y += yScrollAdj;

    // Get the right/bottom for the end
    rtp.SetCp(cpForEnd);

    POINT    ptEnd;
    CLinePtr rpEnd(pdp);
    LONG     iliEnd = pdp->PointFromTp(rtp, NULL, fAtEnd, ptEnd, &rpEnd,
                                       (lCode == tomEnd && Code) ?  Code :
                                       TA_BOTTOM + TA_RIGHT);
    ptEnd.x += xScrollAdj;
    ptEnd.y += yScrollAdj;

    //
    // Calculate the yScroll
    //

    // The basic idea is to display both the start and the end if possible. But
    // if it is not possible then display the requested end based on the input
    // parameter.

    LONG yHeightView = pdp->GetViewHeight();
    LONG yScroll;

    if (tomStart == lCode)
    {
        // Scroll the Start cp to the top of the view
        yScroll = ptStart.y;
    }
    else
    {
        // Scroll the End cp to the bottom of the view
        yScroll = ptEnd.y - yHeightView;
    }

    //
    // Calculate the X Scroll
    //

    // Default scroll to beginning of the line
    LONG xScroll = 0;

    // Make view local to save a number of indirections
    LONG xWidthView = pdp->GetViewWidth();

    if (iliStart == iliEnd)
    {
        // Entire selection is on the same line so we want to display as
        // much of it as is possible.
        LONG xWidthSel = ptEnd.x - ptStart.x;

        if (xWidthSel > xWidthView)
        {
            // Selection length is greater than display width
            if (tomStart == lCode)
            {
                // Show Start requested - just start from beginning
                // of selection
                xScroll = ptStart.x;
            }
            else
            {
                // Show end requested - show as much of selection as
                // possible, ending with last character in the
                // selection.
                xScroll = ptEnd.x - xWidthView;
            }
        }
        else if (xWidthSel < 0)
        {
            xWidthSel = -xWidthSel;
            if (xWidthSel > xWidthView)
            {
                if (tomStart == lCode)
                {
                    // Show Requested Start;
                    xScroll = max(0, ptStart.x - xWidthView);       
                }
                else
                {
                    xScroll = max(0, ptEnd.x - xWidthView);
                }
            }
            else if (ptEnd.x > xWidthView || ptStart.x > xWidthView)
            {
                // Check mask if position is outside the boundaries
                if (taMask)
                    xScroll = ptStart.x - xWidthView;
                else
                    xScroll = ptEnd.x - xWidthView;
            }       
        }
        else if (ptEnd.x > xWidthView || ptStart.x > xWidthView)
        {
            // Check mask if position is outside the boundaries
            if (taMask)
                xScroll = ptStart.x - xWidthView;
            else
                xScroll = ptEnd.x - xWidthView;
        }
    }   
    else
    {
        // Multiline selection. Display as much as possible of the requested
        // end's line.

        // Calc width of line
        LONG xWidthLine = (tomStart == lCode)
            ? rpStart->_xWidth + rpStart->_xLeft
            : rpEnd->_xWidth + rpEnd->_xLeft;


        // If line width is less than or equal to view, start at
        // 0 otherwise we need to adjust starting position to
        // show as much of the requested end's selection line
        // as possible.
        if(xWidthLine > xWidthView)
        {
            if(tomStart == lCode)
            {
                // Start end to be displayed

                if(xWidthLine - ptStart.x > xWidthView)
                {
                    // Selection is bigger than view, so start at beginning
                    // and display as much as possible.
                    xScroll = ptStart.x;
                }
                else
                {
                    // Remember that this is a multiline selection so the
                    // selection on this line goes from ptStart.x to the
                    // end of line. Since the selection width is less than
                    // the width of the view, we just back up the width
                    // of view to show the entire selection.
                    xScroll = xWidthLine - xWidthView;
                }
            }
            else
            {
                // Show the end of the selection. In the multiline case,
                // this goes from the beginning of the line to End. So
                // we only have to adjust if the End is beyond the view.
                if(ptEnd.x > xWidthView)
                {
                    // End beyond the view. Show as much as possible
                    // of the selection.
                    xScroll = ptEnd.x - xWidthView;
                }
            }
        }
    }

    // Do the scroll
    pdp->ScrollView(xScroll, yScroll, FALSE, FALSE);

    return S_OK;
#else
    return 0;
#endif
}

/*
 *  CTxtRange::Select ()
 *
 *  @mfunc
 *      Copy this range's cp's and story ptr to the active selection.
 *
 *  @rdesc
 *      HRESULT = (if selection exists) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::Select ()
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Select");

    if(IsZombie())
        return CO_E_RELEASED;

    CTxtSelection *pSel = GetPed()->GetSel();
    if(pSel)
    {
        LONG cpMin, cpMost;
        GetRange(cpMin, cpMost);
        pSel->SetRange(cpMin, cpMost);
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *  CTxtRange::SetChar (Char)
 *
 *  @mfunc
 *      Set char at cpFirst = <p Char>
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (char stored) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Special cases could be much faster, e.g., just overtype the plain-
 *      text backing store unless at EOD or EOR.  Code below uses a cloned
 *      range to handle all cases easily and preserve undo capability.
 */
STDMETHODIMP CTxtRange::SetChar (
    long Char)              //@parm New value for char at cpFirst
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetChar");
    
    if(IsZombie())
        return CO_E_RELEASED;

    CTxtEdit *      ped = GetPed();
    CCallMgr        callmgr(ped);
    TCHAR           ch = (TCHAR)Char;           // Avoid endian problems
    CTxtRange       rg(*this);
    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(ped, UB_AUTOCOMMIT, &publdr);
    CFreezeDisplay  fd(ped->_pdp);

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    if(!ped->_pdp->IsMultiLine() && IsEOP(Char))// EOPs are not allowed in
        return FALSE;                           //  single-line edit controls

    undobldr.StopGroupTyping();

    rg.Collapser(tomStart);                     // Collapse at cpMin
    rg.SetExtend(TRUE);                         // Setup to select
    rg.Advance(1);                              // Try to select char at IP
    ped->OrCharFlags(GetCharFlags(ch), publdr);
    if(rg.ReplaceRange(1, &ch, publdr, SELRR_REMEMBERRANGE))
    {
        Update(TRUE);                           // Update selection
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *  CTxtRange::SetEnd (cp)
 *
 *  @mfunc
 *      Set this range's End cp
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR : S_FALSE
 *
 *  @comm
 *      Note that setting this range's cpMost to <p cp> also sets cpMin to
 *      <p cp> if <p cp> < cpMin.
 */
STDMETHODIMP CTxtRange::SetEnd (
    long cp)                            //@parm Desired new End cp
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetEnd");

    if(IsZombie())
        return CO_E_RELEASED;

    LONG cpMin = GetCpMin();

    ValidateCp(cp);
    return SetRange(min(cpMin, cp), cp);        // Active end is End
}

/*
 *  CTxtRange::SetFont (pFont)
 *
 *  @mfunc
 *      Set this range's character attributes to those given by <p pFont>.
 *      This method is a "character format painter".
 *
 *  @rdesc
 *      HRESULT = (!pFont) ? E_INVALIDARG :
 *                (if success) ? NOERROR :
 *                (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::SetFont (
    ITextFont * pFont)  //@parm Font object with desired character formatting
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetFont");

    if(!pFont)
        return E_INVALIDARG;
    
    if(IsZombie())
        return CO_E_RELEASED;

    ITextFont *pFontApply = (ITextFont *) new CTxtFont(this);

    if(!pFontApply)
        return E_OUTOFMEMORY;

    HRESULT hr;
    if(*(LONG *)pFontApply == *(LONG *)pFont)       // If same vtable, use
        hr = CharFormatSetter(&((CTxtFont *)pFont)->_CF, //  its copy
                    ((CTxtFont *)pFont)->_dwMask);
    else                                            // Else copy
        hr = pFontApply->SetDuplicate(pFont);       //  to clone and apply

    pFontApply->Release();
    return hr;
}

/*
 *  CTxtRange::SetFormattedText (pRange)
 *
 *  @mfunc
 *      Replace this range's text with formatted text given by <p pRange>.
 *      If <p pRange> is NULL, paste from the clipboard.
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (if success) ? NOERROR : E_OUTOFMEMORY
 *
 *  @FUTURE
 *      Do this more efficiently if pRange points at a RichEdit range. This
 *      would also help with RichEdit D&D to RichEdit targets
 */
STDMETHODIMP CTxtRange::SetFormattedText (
    ITextRange * pRange)        //@parm Formatted text to replace this
                                // range's text
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetFormattedText");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());
    LONG        cpMin = GetCpMin();
    HRESULT     hr;
    IUnknown *  pdo = NULL;
    VARIANT     vr;

    if(!pRange)
        return NOERROR;                 // Nothing to paste

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    VariantInit(&vr);
    vr.vt = VT_UNKNOWN | VT_BYREF;
    vr.ppunkVal = &pdo;

    hr = pRange->Copy(&vr);
    if(hr == NOERROR)
    {
        hr = Paste(&vr, 0);
        pdo->Release();                 // Release the data object
        _cch = GetCp() - cpMin;         // Select the new text
    }
    return hr;
#else
    return 0;
#endif
}

/*
 *  CTxtRange::SetIndex (Unit, Index, Extend)
 *
 *  @mfunc
 *      If <p Extend> is zero, convert this range into an insertion point
 *      at the start of the <p Index>th <p Unit> in the current story. If
 *      <p Extend> is nonzero, set this range to consist of this unit. The
 *      start of the story corresponds to <p Index> = 0 for all units.
 *
 *      Positive indices are 1-based and index relative to the beginning of
 *      the story.  Negative indices are -1-based and index relative to the
 *      end of the story.  So an index of 1 refers to the first Unit in the
 *      story and an index of -1 refers to the last Unit in the story.
 *
 *  @rdesc
 *      HRESULT = (invalid index) ? E_INVALIDARG :
 *                (Unit not supported) ? E_NOTIMPL :
 *                (change) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Currently moves out <p Index> <p Unit>s from the start of the story.
 *      Might be faster to move from current position, but would need to know
 *      the current index.
 */
STDMETHODIMP CTxtRange::SetIndex (
    long    Unit,           //@parm Unit to index
    long    Index,          //@parm Index value to use
    long    Extend)         //@parm if nonzero, set range to <p Unit>
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetIndex");
    
    if(IsZombie())
        return CO_E_RELEASED;

    if(!Index)
        return E_INVALIDARG;

    CCallMgr    callmgr(GetPed());

    LONG      cchText = GetTextLength();
    CTxtRange rg(GetPed());                     // Create IP at cp = 0

    if(Index > 0)                               // Index going forward First
        Index--;                                //  Unit is at start of story
    else                                        // Index from end of story
        rg.Set(cchText, cchText);               //  selecting whole story

    LONG    cUnit;
    HRESULT hr = rg.Mover(Unit, Index, &cUnit, MOVE_END);
    if(FAILED(hr))
        return hr;

    if(Index != cUnit || rg.GetCp() == cchText) // No such index in story
        return E_INVALIDARG;

    rg._cch = 0;                                // Collapse at active end
                                                //  namely at cpMost
    LONG cpMin, cpMost;
    if(Extend)                                  // Select Index'th Unit
        rg.Expander(Unit, TRUE, NULL, &cpMin, &cpMost);

    if(Set(rg.GetCp(), rg._cch))                // Something changed
    {
        Update(TRUE);
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *  CTxtRange::SetPara (pPara)
 *
 *  @mfunc
 *      Set this range's paragraph attributes to those given by <p pPara>
 *      This method is a "Paragraph format painter".
 *
 *  @rdesc
 *      HRESULT = (!pPara) ? E_INVALIDARG :
 *                (if success) ? NOERROR :
 *                (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
STDMETHODIMP CTxtRange::SetPara (
    ITextPara * pPara)      //@parm Paragraph object with desired paragraph
{                           //      formatting
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetPara");

    if(!pPara)
        return E_INVALIDARG;

    if(IsZombie())
        return CO_E_RELEASED;

    ITextPara * pParaApply = (ITextPara *) new CTxtPara(this);

    if(!pParaApply)
        return E_OUTOFMEMORY;

    HRESULT hr;

    if(*(LONG *)pParaApply == *(LONG *)pPara)       // If same vtable, use
    {                                               //  its _PF
        hr = ParaFormatSetter(&((CTxtPara *)pPara)->_PF,
                    ((CTxtPara *)pPara)->_dwMask);
    }
    else                                            // Else copy
       hr = pParaApply->SetDuplicate(pPara);        //  to clone and apply

    pParaApply->Release();
    return hr;
}

/*
 *  CTxtRange::SetPoint (x, y, Type, Extend)
 *
 *  @mfunc
 *      Select text at or up through (depending on <p Extend>) the point
 *      (<p x>, <p y>).
 *
 *  @rdesc
 *      HRESULT = NOERROR
 */
STDMETHODIMP CTxtRange::SetPoint (
    long    x,          //@parm Horizontal coord of point to select
    long    y,          //@parm Vertical   coord of point to select
    long    Type,       //@parm Defines the end to extend if Extend != 0.
    long    Extend)     //@parm Whether to extend selection to point
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetPoint");

    if(IsZombie())
        return CO_E_RELEASED;

    // Copy the ped locally once to save some indirections
    CTxtEdit *ped = GetPed();
    CCallMgr  callmgr(ped);

    if(Type != tomStart && Type != tomEnd)
        return E_INVALIDARG;

    if(!ped->fInplaceActive())
    {
        // If we aren't inplace active we can't get a DC to
        // calculate the cp.
        return OLE_E_NOT_INPLACEACTIVE;
    }

    // Convert (x, y) from screen coordinates to client coordinates
    POINT pt = {x, y};
    // Caller specifies screen coordinates?
    if ( !(Type & tomClientCoord) )
        if(!ped->TxScreenToClient(&pt))
            return E_FAIL;          // It is unexpected for this to happen

    // Get cp for (x, y)
    LONG cpSel = ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, TRUE);
    if(cpSel == -1)
        return E_FAIL;          // It is highly unexpected for this to fail

    // Extend range as requested
    LONG cchForSel = 0;
    if(Extend)
    {
        LONG cpMin, cpMost;
        GetRange(cpMin, cpMost);
        if(Type == tomStart)
            cchForSel = cpSel - cpMin;
        else
            cchForSel = cpSel - cpMost;
    }

    // Update range
    Set(cpSel, cchForSel);
    return S_OK;
}

/*
 *  CTxtRange::SetRange (cp1, cp2)
 *
 *  @mfunc
 *      Set this range's ends
 *
 *  @rdesc
 *      HRESULT = (cp1 > cp2) ? E_INVALIDARG
 *              : (if change) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::SetRange (
    long cp1,       //@parm Char position for Start end
    long cp2)       //@parm Char position for End end
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetRange");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());
    LONG cpMin, cpMost;                 // Save starting cp's for
                                        //  change determination
    GetRange(cpMin, cpMost);
    ValidateCp(cp1);
    ValidateCp(cp2);

    Set(cp2, cp2 - cp1);
    GetRange(cp1, cp2);                 // See if either range end changed
    if(cp1 != cpMin || cp2 != cpMost)   //  (independent of active end)
    {
        Update(TRUE);                   // Update selection
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *  CTxtRange::SetStart (cp)
 *
 *  @mfunc
 *      Set this range's Start cp
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR : S_FALSE
 *
 *  @comm
 *      Note that setting this range's cpMin to <p cp> also sets cpMost to
 *      <p cp> if <p cp> > cpMost.
 */
STDMETHODIMP CTxtRange::SetStart (
    long cp)                            //@parm Desired new Start cp
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetStart");
    
    if(IsZombie())
        return CO_E_RELEASED;

    LONG cpMost = GetCpMost();

    ValidateCp(cp);
    return SetRange(max(cpMost, cp), cp);       // Active end is Start
}

/*
 *  CTxtRange::SetText (bstr)
 *
 *  @mfunc
 *      Replace text in this range by that given by <p bstr>.  If <p bstr>
 *      is NULL, delete text in range.
 *
 *  @rdesc
 *      HRESULT = (WriteAccessDenied) ? E_ACCESSDENIED :
 *                (if success) ? NOERROR : S_FALSE
 */
STDMETHODIMP CTxtRange::SetText (
    BSTR bstr)          //@parm Text to replace text in this range by
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetText");

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr callmgr(GetPed());

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    LONG cchNew = bstr ? SysStringLen(bstr) : 0;
    _cch = Replacer(cchNew, (TCHAR *)bstr, RR_ITMZ_UNICODEBIDI);    // Select the new text

    _TEST_INVARIANT_

    GetPed()->TxSetMaxToMaxText();

    return _cch == cchNew ? NOERROR : S_FALSE;
}

/*
 *  CTxtRange::StartOf (Unit, Extend, pDelta)
 *
 *  @mfunc
 *      Move this range end(s) to start of the first overlapping Unit in
 *      the range.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Unit> valid) ? S_FALSE : E_INVALIDARG
 */
STDMETHODIMP CTxtRange::StartOf (
    long    Unit,           //@parm Unit to use
    long    Extend,         //@parm If true, leave other end alone
    long *  pDelta)         //@parm Out parm to get count of chars that
                            //      StartOf moved
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::StartOf");

    CCallMgr callmgr(GetPed());
    LONG     cpMin;
    HRESULT  hr = Expander (Unit, Extend, pDelta, &cpMin, NULL);

    if(hr == NOERROR)
        Update(TRUE);                   // Update selection

    return hr;
}


//---------------------- CTxtRange ITextSelection stubs -----------------------------

// Dummy CTxtRange routines to simplify CTxtSelection inheritance hierarchy

STDMETHODIMP CTxtRange::GetFlags (long * pFlags)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetFlags");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::SetFlags (long Flags)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::SetFlags");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::GetType (long * pType)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::GetType");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveLeft (long Unit, long Count, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Left");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveRight (long Unit, long Count, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Right");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveUp (long Unit, long Count, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Up");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::MoveDown (long Unit, long Count, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::Down");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::HomeKey (long Unit, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::HomeKey");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::EndKey (long Unit, long Extend, long * pDelta)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::EndKey");
    return E_NOTIMPL;
}

STDMETHODIMP CTxtRange::TypeText (BSTR bstr)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEEXTERN, "CTxtRange::TypeText");
    return E_NOTIMPL;
}


//--------------------- ITextRange Private Helper Methods -----------------------------

/*
 *  @doc INTERNAL
 *
 *  CTxtRange::Collapser (bStart)
 *
 *  @mfunc
 *      Internal routine to collapse this range into a degenerate point
 *      either at the the start (<p bStart> is nonzero or the end
 *      (<p bStart> = 0)
 */
void CTxtRange::Collapser (
    long bStart)            //@parm Flag specifying end to collapse at
{
    TRACEBEGIN(TRCSUBSYSRANG, TRCSCOPEEXTERN, "CTxtRange::Collapser");

    if(bStart)                          // Collapse to Start
    {
        if(_cch > 0)
            FlipRange();                // Move active end to range Start
    }
    else                                // Collapse to End
    {
        if(_cch < 0)
            FlipRange();                // Move active end to range End

        const LONG cchText = GetAdjustedTextLength();

        if(GetCp() > cchText)           // IP can't follow final CR
            Set(cchText, 0);            //  so move it before
    }
    if(_cch)
        _fMoveBack = bStart != 0;
    _cch = 0;                           // Collapse this range
    _fSelHasEOP = FALSE;                // Insertion points don't have
    _fSelHasCell = FALSE;               //  EOPs or Cells

    if(_fSel)                           // Notify if selection changed
        GetPed()->GetCallMgr()->SetSelectionChanged();

    Update_iFormat(-1);                 // Make sure format is up to date
}

/*
 *  CTxtRange::Comparer(pRange)
 *
 *  @mfunc
 *      helper function for CTxtRange::InRange() and IsEqual()
 *
 *  @rdesc
 *      0 if not same story or if this range isn't contained by <p pRange>;
 *      -1 if ranges are equal; 1 if this range wholely contained in
 *      <p pRange>.
 *
 *  @comm
 *      Note that if this range is degenerate and *pRange is nondegenerate,
 *      this range is not included in *pRange if it's located at pRange's
 *      End position.
 */
LONG CTxtRange::Comparer (
    ITextRange * pRange)        //@parm ITextRange to compare with
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Comparer");

    LONG    cpMin, cpMost;
    LONG    Start, End;

    if(InStory(pRange, NULL) != NOERROR)    // If this range doesn't point at
        return 0;                           //  same story as pRange's,
                                            //  return 0
    GetRange(cpMin, cpMost);                // Get this range's cp's
    pRange->GetStart(&Start);               // Get pRange's cp's
    pRange->GetEnd(&End);
    if(cpMin == Start && cpMost == End)     // Exact match
        return -1;
    return cpMin >= Start && cpMost <= End && cpMin < End;
}

/*
 *  CTxtRange::Expander (Unit, fExtend, pDelta, pcpMin, pcpMost)
 *
 *  @mfunc
 *      Helper function that expands this range so that partial Units it
 *      contains are completely contained according to the out parameters
 *      pcpMin and pcpMost.  If pcpMin is not NULL, the range is expanded to
 *      the beginning of the Unit.  Similarly, if pcpMost is not NULL, the
 *      range is expanded to the end of the Unit. <p pDelta> is an out
 *      parameter that receives the number of chars added to the range.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if Unit valid) ? S_FALSE : E_INVALIDARG
 *
 *  @devnote
 *      Used by ITextRange::Expand(), StartOf(), and EndOf(). Both pcpMin and
 *      pcpMost are nonNULL for Expand().  pcpMin is NULL for EndOf() and
 *      pcpMost is NULL for StartOf().
 *
 *  @future
 *      Discontiguous Units. Expander should expand only to end of Unit,
 *      rather than to start of next Unit.
 */
HRESULT CTxtRange::Expander (
    long    Unit,       //@parm Unit to expand range to
    BOOL    fExtend,    //@parm Expand this range if TRUE
    LONG *  pDelta,     //@parm Out parm that receives chars added
    LONG *  pcpMin,     //@parm Out parm that receives new cpMin
    LONG *  pcpMost)    //@parm Out parm that receives new cpMost
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Expander");
    
    if(IsZombie())
        return CO_E_RELEASED;

    LONG    cch = 0;                        // Default no chars added
    LONG    cchRange;
    LONG    cchAdjustedText = GetAdjustedTextLength();
    LONG    cchText = GetTextLength();
    LONG    cp;
    LONG    cpMin, cpMost;
    BOOL    fUnitFound = TRUE;              // Most Units can be found
    LONG    cchCollapse;
    CDisplay *pdp;                          //  but tomObject maybe not

    GetRange(cpMin, cpMost);                // Save starting cp's
    if(pcpMin)                              // Default no change
    {
        *pcpMin = cpMin;
        AssertSz(!pcpMost || fExtend,
            "CTxtRange::Expander should extend if both pcpMin and pcpMost != 0");
    }
    if(pcpMost)
        *pcpMost = cpMost;
    if(pDelta)
        *pDelta = 0;

    if(Unit < 0)
    {
        // Valid attribute Units are high bit plus any combo of CFE_xxx.
        // CFE_REVISED is most significant value currently defined.
        if(Unit & ~(2*CFM_REVISED - 1 + 0x80000000))
            return E_NOTIMPL;
        FindAttributes(pcpMin, pcpMost, Unit);
    }
    else
    {
        switch(Unit)                        // Calculate new cp's
        {
        case tomObject:
            fUnitFound = FindObject(pcpMin, pcpMost);
            break;

        case tomCharacter:
            if (pcpMost && cpMin == cpMost &&// EndOf/Expand insertion point
                cpMost < cchText &&         //  with at least 1 more char
                (!cpMost || pcpMin))        //  at beginning of story or
            {                               //  Expand(), then
                (*pcpMost)++;               //  expand by one char
            }
            break;

        case tomCharFormat:
            _rpCF.FindRun (pcpMin, pcpMost, cpMin, _cch, cchText);
            break;

        case tomParaFormat:
            _rpPF.FindRun (pcpMin, pcpMost, cpMin, _cch, cchText);
            break;

        case tomWord:
            FindWord (pcpMin, pcpMost, FW_INCLUDE_TRAILING_WHITESPACE);
            break;

        case tomSentence:
            FindSentence (pcpMin, pcpMost);
            break;

        case tomCell:
            FindCell (pcpMin, pcpMost);
            break;

        case tomRow:
            _rpPF.AdjustForward();
            if(InTable())                   // In our simple table model,
                goto para;                  //  each row is a single para
            break;                          

        case tomLine:
            pdp = GetPed()->_pdp;
            if(pdp)                         // If this story has a display
            {                               //  use line array
                CLinePtr rp(pdp);
                cp = GetCp();
                pdp->WaitForRecalc(cp, -1);
                rp.RpSetCp(cp, FALSE);
                rp.FindRun (pcpMin, pcpMost, cpMin, _cch, cchText);
                break;
            }                               // Else fall thru to tomPara

        case tomParagraph:
    para:   FindParagraph(pcpMin, pcpMost);
            break;

        case tomWindow:
            fUnitFound = FindVisibleRange(pcpMin, pcpMost);
            break;

        case tomStory:
            if(pcpMin)
                *pcpMin = 0;
            if(pcpMost)
                *pcpMost = cchText;
            break;

        default:
            return E_NOTIMPL;
        }
    }
    if(!fUnitFound)
        return S_FALSE;

    cchCollapse = !fExtend && _cch;         // Collapse counts as a char
                                            // Note: Expand() has fExtend = 0
    if(pcpMin)
    {
        cch = cpMin - *pcpMin;              // Default positive cch for Expand
        cpMin = *pcpMin;
    }

    if(pcpMost)                             // EndOf() and Expand()
    {
        if(!fExtend)                        // Will be IP if not already
        {
            if(cpMost > cchAdjustedText)    // If we collapse (EndOf only),
                cchCollapse = -cchCollapse; //  it'll be before the final CR
            else
                *pcpMost = min(*pcpMost, cchAdjustedText);
        }
        cch += *pcpMost - cpMost;
        cp = cpMost = *pcpMost;
    }
    else                                    // StartOf()
    {
        cch = -cch;                         // Invert count
        cp = cpMin;                         // Active end at cpMin
        cchCollapse = -cchCollapse;         // Backward collapses count as -1
    }

    cch += cchCollapse;                     // Collapse counts as a char
    if(cch)                                 // One or both ends changed
    {
        cchRange = cpMost - cpMin;          // cch for EndOf() and Expand()
        if(!pcpMost)                        // Make negative for StartOf()
            cchRange = -cchRange;
        if(!fExtend)                        // We're not expanding (EndOf()
            cchRange = 0;                   //  or StartOf() call)
        if(Set(cp, cchRange))               // Set active end and signed cch
        {                                   // Something changed
            if(pDelta)                      // Report cch if caller cares
                *pDelta = cch;
            return NOERROR;
        }
    }
    
    return S_FALSE;                         // Report Unit found but no change
}

/*
 *  CTxtRange::Finder (bstr, Count, dwFlags, pDelta, Mode)
 *
 *  @mfunc
 *      Helper find function that moves active end up to <p cch> characters
 *      subject to compare flags <p Flags> and the <p Mode>, which has the
 *      following possible values:
 *
 *      1:  set this range's cpMost = cpMost of matched string
 *      0:  set this range's cp's equal to those of matched string
 *      -1: set this range's cpMin = cpMin of matched string
 *
 *      Return *<p pDelta> = # characters past.
 *
 *  @rdesc
 *      HRESULT = (if <p bstr> found) ? NOERROR : S_FALSE
 *
 *  @devnote
 *      Used by ITextRange::FindText(), FindTextStart() and FindTextEnd()
 */
HRESULT CTxtRange::Finder (
    BSTR    bstr,       //@parm String to find
    long    Count,      //@parm Max count of chars to search
    long    Flags,      //@parm Flags governing compares
    LONG *  pDelta,     //@parm Out parm to receive count of chars moved
    MOVES   Mode)       //@parm Governs setting of range wrt matched string
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Finder");

    if(!bstr)
        return S_FALSE;

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());

    LONG        cpMin, cpMost;
    LONG        cch = GetRange(cpMin, cpMost);  // Get this range's cp's
    LONG        cchBstr = SysStringLen(bstr);
    LONG        cchSave = _cch;
    LONG        cp, cpMatch, cpSave;
    LONG        cpStart = cpMost;               // Default Start cp to range
    CRchTxtPtr  rtp(*this);                     //  End

    if(Mode == MOVE_IP)                         // FindText(): Count = 0 is
    {                                           //  treated specially: if IP,
        if(!Count)                              //  compare string at IP; else
            Count = cch ? cch : cchBstr;        //  confine search to range
        if(Count > 0)                           // Forward searches start from
            cpStart = cpMin;                    //  beginning of range
    }
    else                                        // FindTextStart() or
    {                                           //   FindTextEnd()
        if(!Count)                              // Compare string at IP; else
            Count = cch ? -Mode*cch : cchBstr;  //  confine search to range
        if(Mode < 0)                            // Find from Start
            cpStart = cpMin;
    }

    cpSave = cpStart;                           // Save starting cp
    cp = cpStart + Count;                       // cp = limiting cp. Can be on
    cp = max(cp, 0);                            //  either side of cpStart
    Flags &= ~FR_DOWN;                          // Default search backward
    if(Count >= 0)                              // It's forward, so set
        Flags |= FR_DOWN;                       //  downward search bit

find:
    rtp.SetCp(cpStart);                         // Move to start of search
    cpMatch = rtp.FindText(cp, Flags, bstr, cchBstr);
    if (Mode == MOVE_IP && cpMatch == cpMin &&  // Ordinary Find matched
        rtp.GetCp() == cpMost)                  //  current range
    {
        Assert(cpStart == cpSave);              // (Can't loop twice)
        cpStart += Count > 0 ? 1 : -1;          // Move over one char
        goto find;                              //  and try again
    }

    if(cpMatch < 0)                             // Match failed
    {
        if(pDelta)                              // Return match string length
            *pDelta = 0;                        //  = 0
        return S_FALSE;                         // Signal no match
    }


    // Match succeeded: set new cp and cch for range, update selection (if
    // this range is a selection), send notifications, and return NOERROR

    cp = rtp.GetCp();                           // cp = cpMost of match string
    if(pDelta)                                  // Return match string length
        *pDelta = cchBstr;                      //  if caller wants to know

    cch = cp - cpMatch;                         // Default to select matched
                                                //  string (for MOVE_IP)
    if(Mode != MOVE_IP)                         // MOVE_START or MOVE_END
    {
        if(Mode == MOVE_START)                  // MOVE_START moves to start
            cp = cpMatch;                       //  of matched string
        cch = cp - cpSave;                      // Distance end moved
        if(!cchSave && (Mode ^ cch) < 0)        // If crossed ends of initial
            cch = 0;                            //  IP, use an IP
        else if(cchSave)                        // Initially nondegenerate
        {                                       //  range
            if((cchSave ^ Mode) < 0)            // If wrong end is active,
                cchSave = -cchSave;             //  fake a FlipRange to get
            cch += cchSave;                     //  new length
            if((cch ^ cchSave) < 0)             // If ends would cross,
                cch = 0;                        //  convert to insertion point
        }
    }
    if ((cp != GetCp() || cch != _cch)          // Active end and/or length of
        && Set(cp, cch))                        //  range changed
    {                                           // Use the new values
        Update(TRUE);                           // Update selection
    }
    return NOERROR;
}

/*
 *  CTxtRange::Matcher (Cset, Count, pDelta, fExtend, Match)
 *
 *  @mfunc
 *      Helper function to move active end up to <p cch> characters past
 *      all contiguous characters that are (<p Match> ? in : not in) the cset
 *      *<p pvar>.  If <p fExtend>, extend the range to include the characters
 *      past by. Return *<p pDelta> = # characters past by.
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Cset> valid) ? S_FALSE : E_INVALIDARG
 */
HRESULT CTxtRange::Matcher (
    VARIANT *   Cset,       //@parm Character match set
    long        Count,      //@parm Max cch to match
    long *      pDelta,     //@parm Out parm for cch moved
    MOVES       Mode,       //@parm MOVE_START (-1), MOVE_IP (0), MOVE_END (1)
    MATCHES     Match)      //@parm MATCH_WHILE spans Cset; else break on Cset
{
#ifndef PEGASUS
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Matcher");

    // This (and other) code assumes the following conditions:
    Assert(MOVE_START == -1 && MOVE_IP == 0 && MOVE_END == 1);
    Assert(MATCH_UNTIL == 0 && MATCH_WHILE == 1);
    Assert(sizeof(WORD) == 2);                      // 16-bit WORDs

    if(!Cset)
        return E_INVALIDARG;

    if(IsZombie())
        return CO_E_RELEASED;

    CCallMgr    callmgr(GetPed());
    LONG    cch;                                    // For cch moved
    TCHAR   ch;                                     // Current char
    LONG    count = Count;                          // Count down variable
    LONG    cpSave;                                 // To save initial cp
    WORD    ctype;                                  // CT_TYPEx info for ch
    long    Delta;                                  // Value for *pDelta
    BOOL    fInCset;                                // TRUE iff ch in Cset
    UINT    i, j;                                   // Handy indices
    LONG    iDir = (Count > 0) ? 1 : -1;            // Count increment
    long    lVal = Cset->lVal;
    TCHAR * pch;                                    // Used to walk BSTR Cset
    CTxtPtr tp(_rpTX);                              // tp to walk text with
    LONG    vt = Cset->vt;

    if(pDelta)                                      // Default neither motion
        *pDelta = 0;                                //  nor match

    if (Mode == MOVE_IP && (_cch ^ Count) < 0 ||    // Wrong active end:
        Mode != MOVE_IP && (_cch ^ Mode)  < 0)
    {
        tp.AdvanceCp(-_cch);                        //  go to other end
    }
    cpSave = tp.GetCp();                            // Save cp for checks

    if(Count > 0)                                   // If matching forward,
    {                                               //  get current char
        ch = tp.GetChar();
        count--;                                    // One less char to match
    }
    else                                            // If matching backward,
        ch = tp.NextCharCount(count);               //  start at previous char
                                                    
    if(!ch)                                         // At one end or other, so
        return S_FALSE;                             //  signal no match


    // Process built-in and explicit character sets
    if(vt & VT_BYREF)                               // VB passes VT_BYREF
    {                                               //  unless args are
        lVal = *Cset->plVal;                        //  enclosed in ()'s
        vt &= ~ VT_BYREF;
    }

    if(vt == VT_I2)                                 // Should be VT_I4, but
        lVal &= 0xffff;                             //  facilitate common cases

    // Built-in char set: either Unicode range or CT_CTYPEx
    if(vt == VT_I4 || vt == VT_I2)
    {
        i = lVal & 0xffff;                          // First code or CT mask
        j = lVal >> 16;                             // Size of range
        if(lVal < 0)                                // Unicode range Cset
        {                                           //  (sign bit is set)
            j &= 0x7fff;                            // Kill sign bit
            while (((BOOL)Match ^ (ch - i > j)) &&      // ch in range or not
                   (ch = tp.NextCharCount(count)))  // Another char available
                   ;                                // Note: count is passed
        }                                           //  by reference
        else                                        // CT_CTYPEx Cset
        {                                           // CT_CTYPEx is given by
            if(!j)                                  //  upper WORD of lVal
                j = CT_CTYPE1;                      // 0 defaults to CT_CTYPE1
            do
            {
                ctype = 0;                          // For each char, get
                                                    //  string type info
                W32->GetStringTypeEx(0, j, &ch, 1, &ctype);

                // Loop (up to |Count| - 1 times) as long as the characters
                // encountered are in the Cset (Match = MATCH_WHILE (=1)),
                // or as long as they are not  (Match = MATCH_UNTIL (=0)).

                fInCset = (j == CT_CTYPE2)          // CT_CTYPE2 values are
                        ? (ctype == i)              //  mutually exclusive;
                        : (ctype & i) != 0;         //  others can be combos

            } while ((Match ^ fInCset) == 0 &&
                     (ch = tp.NextCharCount(count)) != 0);
        }                                           // End of built-in Csets
    }                                               // End of Cset VT_I4

    // Explicit char set given by chars in Cset->bstrVal
    else if (Cset->vt == VT_BSTR)
    {
        //REVIEW (keithcu) What is going on here?
        if((DWORD_PTR)Cset->bstrVal < 0xfffff)      // Don't get fooled by
            return E_INVALIDARG;                    //  invalid vt values
        j = SysStringLen(Cset->bstrVal);
        do
        {                                           // Set i = 0 if ch isn't
            pch = Cset->bstrVal;                //  in set; this stops
            for(i = j;                              //  movement
                i && (ch != *pch++);                
                i--) ;
        
        // If we are doing a MATCH_WHILE routine then we only
        // continue while i > 0 becuase this indicates that we
        // found the char at the current cp in the CSet.  If
        // we were doing a MATCH_UNTIL then we should quit when
        // i != 0 becuase the current char was in the CSet.
        } while((Match == (i ? MATCH_WHILE : MATCH_UNTIL)) &&
            (ch = tp.NextCharCount(count)));        // Break if no more chars
    }                                               //  or ch not in set
    else
        return E_INVALIDARG;

    /* If MoveWhile, leave tp immediately after last matched char going
     * forward and at that char going backward (helps to think of tp
     * pointing in between chars).  If MoveUntil, leave tp at the char
     * going forward and just after that char going backward.
     *
     * E.g.: the code
     *
     *      r.MoveUntil   (C1_DIGIT, tomForward, NULL)
     *      r.MoveEndWhile(C1_DIGIT, tomForward, NULL)
     *
     * breaks at the first digit and selects the number going forward.
     * Similarly
     *
     *      r.MoveUntil     (C1_DIGIT, tomBackward, NULL)
     *      r.MoveStartWhile(C1_DIGIT, tomBackward, NULL)
     *
     * selects the number going backward.
     */
    count = (Match == MATCH_WHILE && !ch)           // If MoveWhile, move past
          ? iDir : 0;                               //  last matched char
    if(Count < 0)
        count++;
    tp.AdvanceCp(count);

    Delta = cch = 0;                                // Suppress motion unless
    if(Match == MATCH_WHILE || ch)                  //  match occurred
    {
        Delta = cch = tp.GetCp() - cpSave;          // Calculate distance moved
        if(Match == MATCH_UNTIL)                    // For MoveUntil methods,
            Delta += iDir;                          //  match counts as a char
    }

    if(pDelta)                                      // Report motion to caller
        *pDelta = Delta;                            //  if it wants to know

    // Handle cases for which range is changed
    if(cch || (Delta && _cch && Mode == MOVE_IP))
    {
        if (Mode == MOVE_IP ||                      // If move IP or asked to
            !_cch && (Mode ^ Count) < 0)            //  cross ends of initial
        {                                           //  IP, use an IP
            cch = 0;
        }
        else if(_cch)                               // Initially nondegenerate
        {                                           //  range
            if((_cch ^ Mode) < 0)                   // If wrong end is active,
                _cch = -_cch;                       //  fake a FlipRange (will
            cch += _cch;                            //  set cp shortly)
            if((cch ^ _cch) < 0)                    // If ends crossed, convert
                cch = 0;                            //  to insertion point
        }
        if(Set(tp.GetCp(), cch))                    // Set new range cp and cch
        {
            Update(TRUE);                           // Update selection
            return NOERROR;                         // Signal match occurred
        }
        return S_FALSE;
    }

    // No change in range. Return NOERROR iff match occurred for MOVE_UNTIL
    return Delta ? NOERROR : S_FALSE;
#else
    return 0;
#endif
}

/*
 *  CTxtRange::Mover (Unit, Count, pDelta, Mode)
 *
 *  @mfunc
 *      Helper function to move end(s) <p Count> <p Unit>s, which end(s)
 *      depending on Mode = MOVE_IP, MOVE_START, and MOVE_END.  Collapsing
 *      the range by using MOVE_IP counts as a Unit.
 *
 *      Extends range from End if <p Mode> = MOVE_END and from Start if
 *      <p Mode> = MOVE_START; else (MOVE_IP) it collapses range to Start if
 *      <p Count> <lt>= 0 and to End if <p Count> <gt> 0.
 *
 *      Sets *<p pDelta> = count of Units moved
 *
 *      Used by ITextRange::Delete(), Move(), MoveStart(), MoveEnd(),
 *      and SetIndex()
 *
 *  @rdesc
 *      HRESULT = (if change) ? NOERROR :
 *                (if <p Unit> valid) ? S_FALSE : E_INVALIDARG
 */
HRESULT CTxtRange::Mover (
    long    Unit,       //@parm Unit to use for moving active end
    long    Count,      //@parm Count of units to move active end
    long *  pDelta,     //@parm Out parm for count of units moved
    MOVES   Mode)       //@parm MOVE_START (-1), MOVE_IP (0), MOVE_END (1)
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Mover");

    if(pDelta)
        *pDelta = 0;                            // Default no units moved

    if(IsZombie())
        return CO_E_RELEASED;

    LONG      cch;
    LONG      cchAdj = GetAdjustedTextLength();
    LONG      cchMax = 0;                       // Default full story limits
    LONG      cp;
    LONG      cpMost = GetCpMost();
    LONG      cUnitCollapse = 0;
    HRESULT   hr = NOERROR;
    CTxtRange rg(*this);                        // Use a copy to look around

    if(pDelta)
        *pDelta = 0;                            // Default no units moved

    if(_cch && Count)                           // Nondegenerate range
    {
        if(Mode == MOVE_IP)                     // Insertion point: will
        {                                       //  collapse range if Unit is
            if((Count ^ rg._cch) < 0)           //  defined. Go to correct end
                rg.FlipRange();
            if(Count > 0)
            {
                if(cpMost > cchAdj)
                {
                    cUnitCollapse = -1;         // Collapse before final CR
                    Count = 0;                  // No more motion
                }
                else
                {   //               Extend pDelta pcpMin pcpMost
                    hr = rg.Expander(Unit, FALSE, NULL, NULL, &cp);
                    cUnitCollapse = 1;          // Collapse counts as a Unit
                    Count--;                    // One less Unit to count
                }
            }
            else
            {
                hr = rg.Expander(Unit, FALSE, NULL, &cp, NULL);
                cUnitCollapse = -1;
                Count++;
            }
            if(FAILED(hr))
                return hr;
        }
        else if((Mode ^ rg._cch) < 0)           // MOVE_START or MOVE_END
            rg.FlipRange();                     // Go to Start or End
    }

    if(Count > 0 && Mode != MOVE_END)           // Moving IP or Start forward
    {
        cchMax = cchAdj - rg.GetCp();           // Can't pass final CR
        if(cchMax <= 0)                         // Already at or past it
        {                                       // Only count comes from
            Count = cUnitCollapse;              //  possible collapse
            cp = cchAdj;                        // Put active end at cchAdj
            cch = (Mode == MOVE_START && cpMost > cchAdj)
                ? cp - cpMost : 0;
            goto set;
        }
    }

    cch = rg.UnitCounter(Unit, Count, cchMax);  // Count off Count Units

    if(cch == tomForward)                       // Unit not implemented
        return E_NOTIMPL;
    
    if(cch == tomBackward)                      // Unit not available, e.g.,
        return S_FALSE;                         //  tomObject and no objects

    Count += cUnitCollapse;                     // Add a Unit if collapse
    if(!Count)                                  // Nothing changed, so quit
        return S_FALSE;

    if (Mode == MOVE_IP ||                      // MOVE_IP or
        !_cch && (Mode ^ Count) < 0)            //  initial IP end cross
    {
        cch = 0;                                // New range is degenerate
    }
    else if(_cch)                               // MOVE_START or MOVE_END
    {                                           //  with nondegenerate range
        if((_cch ^ Mode) < 0)                   // Make _cch correspond to end
            _cch = -_cch;                       //  that moved
        cch += _cch;                            // Possible new range length
        if((cch ^ _cch) < 0)                    // Nondegenerate end cross
            cch = 0;                            // Use IP
    }
    cp = rg.GetCp();

set:
    if(Set(cp, cch))                            // Attempt to set new range
    {                                           // Something changed
        if(pDelta)                              // Report count of units
            *pDelta = Count;                    //  advanced
        Update(TRUE);                           // Update selection
        return NOERROR;
    }
    return S_FALSE;
}

/*
 *
 *  CTxtRange::Replacer (cchNew, *pch)
 *  
 *  @mfunc
 *      Replace this range's using CHARFORMAT _iFormat and updating other
 *      text runs as needed.
 *
 *      Same as CTxtRange::CleanseAndReplaceRange(cchNew, *pch, publdr),
 *      except creates its own undo builder.
 *  
 *  @rdesc
 *      cch of text actually pasted
 *  
 *  @devnote
 *      moves this text pointer to end of replaced text and
 *      may move text block and formatting arrays
 */
LONG CTxtRange::Replacer (
    LONG            cchNew,     //@parm Length of replacement text
    TCHAR const *   pch,        //@parm Replacement text
    DWORD           dwFlags)    //@parm ReplaceRange flags
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::Replacer");

    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(GetPed(), UB_AUTOCOMMIT, &publdr);

    undobldr.StopGroupTyping();

    // Note: we don't check the limit on text here. Right now, this
    // is only called by Delete and SetText so this is OK. However,
    // we might want to reinvestigate this latter if this is called
    // by anything else.
    return CleanseAndReplaceRange(cchNew, pch, FALSE, publdr, NULL, NULL, dwFlags);
}

/*
 *  CTxtRange::CharFormatSetter (pCF)
 *
 *  @mfunc
 *      Helper function that's the same as CTxtRange::SetCharFormat(), but
 *      adds undo building, and notification.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : S_FALSE
 *                (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
HRESULT CTxtRange::CharFormatSetter (
    const CCharFormat *pCF, //@parm CCharFormat to fill with results
    DWORD         dwMask)   //@parm CHARFORMAT2 mask
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::CharFormatSetter");

    if(IsZombie())
        return CO_E_RELEASED;

    CTxtEdit *ped = GetPed();
    CCallMgr        callmgr(ped);
    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(ped, UB_AUTOCOMMIT, &publdr);

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    undobldr.StopGroupTyping();
    return SetCharFormat(pCF, FALSE, publdr, dwMask, 0);
}

/*
 *  CTxtRange::ParaFormatSetter (pPF, dwMask)
 *
 *  @mfunc
 *      Helper function that's the same as CTxtRange::SetParaFormat(), but
 *      adds protection checking, undo building, and notification.
 *
 *  @rdesc
 *      HRESULT = (if success) ? NOERROR : S_FALSE
 *                (protected) ? E_ACCESSDENIED : E_OUTOFMEMORY
 */
HRESULT CTxtRange::ParaFormatSetter (
    const CParaFormat *pPF, //@parm CParaFormat to fill with results
    DWORD           dwMask) //@parm Mask to use
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::ParaFormatSetter");

    if(IsZombie())
        return CO_E_RELEASED;

    CTxtEdit *ped = GetPed();
    CCallMgr        callmgr(ped);
    IUndoBuilder *  publdr;
    CGenUndoBuilder undobldr(ped, UB_AUTOCOMMIT, &publdr);

    if(WriteAccessDenied())
        return E_ACCESSDENIED;

    undobldr.StopGroupTyping();
    // In RichEdit 3.0, we don't support setting tables
    if(GetPF()->InTable())
        dwMask &= ~PFM_TABSTOPS;
    return SetParaFormat(pPF, publdr, dwMask & ~PFM_TABLE);
}

/*
 *  CTxtRange::WriteAccessDenied()
 *
 *  @mfunc
 *      Returns TRUE iff at least part of the range is protected and the
 *      owner chooses to enforce it
 *
 *  @rdesc
 *      TRUE iff write access to range is denied
 */
BOOL CTxtRange::WriteAccessDenied ()
{
    TRACEBEGIN(TRCSUBSYSTOM, TRCSCOPEINTERN, "CTxtRange::WriteAccessDenied");

    int       iProt;
    CTxtEdit *ped = GetPed();

    if (ped && ped->TxGetReadOnly() ||
        ((iProt = IsProtected(-1)) == PROTECTED_YES ||
        (iProt == PROTECTED_ASK && ped->IsProtectionCheckingEnabled() &&
         ped->QueryUseProtection(this, 0, 0, 0))))
    // N.B.  the preceding if statement assumes that IsProtected returns a tri-value
    {
        return TRUE;
    }

    return FALSE;
}

/*
 *  CTxtRange::IsTrue (f, pB)
 *
 *  @mfunc
 *      Return *<p pB> = tomTrue iff <p f> is nonzero and pB isn't NULL
 *
 *  @rdesc
 *      HRESULT = (f) ? NOERROR : S_FALSE
 */
HRESULT CTxtRange::IsTrue(BOOL f, long *pB)
{
    if(pB)
        *pB = tomFalse;
    
    if(IsZombie())
        return CO_E_RELEASED;

    if(f)
    {
        if(pB)
            *pB = tomTrue;
        return NOERROR;
    }

    return S_FALSE;
}

/*
 *  CTxtRange::GetLong (lValue, pLong)
 *
 *  @mfunc
 *      Return *pLong = lValue provided pLong isn't NULL and this range
 *      isn't a zombie
 *
 *  @rdesc
 *      HRESULT = (zombie) ? CO_E_RELEASED :
 *                (pLong) ? NOERROR : E_INVALIDARG
 */
HRESULT CTxtRange::GetLong (
    LONG lValue,        //@parm Long value to return
    long *pLong)        //@parm Out parm to receive long value
{
    if(IsZombie())
        return CO_E_RELEASED;   
    
    _TEST_INVARIANT_

    if(!pLong)
        return E_INVALIDARG;

    *pLong = lValue;



    return NOERROR;
}

/*
 *  IsSameVtables (punk1, punk2)
 *
 *  @mfunc
 *      Returns true if punk1 has same vtable as punk2
 *
 *  @rdesc
 *      TRUE iff punk1 has same vtable as punk2
 */
BOOL IsSameVtables(IUnknown *punk1, IUnknown *punk2)
{
    return punk1 && punk2 && *(long *)punk1 == *(long *)punk2;
}

/*
 *  FPPTS_TO_TWIPS (x)
 *
 *  @mfunc
 *      Returns 20*x, i.e., the number of twips corresponding to
 *      x given in floating-point points.  The value is rounded.
 *
 *  @rdesc
 *      x converted to twips
 */
long FPPTS_TO_TWIPS(
    float x)
{
    return 20*x + ((x >= 0) ? 0.5 : -0.5);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\uspi.cpp ===
/*
 *		Uniscribe interface (& related classes) class implementation
 *		
 *		File:    uspi.cpp
 * 		Create:  Jan 10, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_font.h"
#include "_frunptr.h"
#include "_select.h"
#include "_measure.h"
#include "_uspi.h"

CUniscribe* 	g_pusp = NULL;
int				g_cMaxScript = 0x100;


// initial dummy script properties (= SCRIPT_UNDEFINED)
static const SCRIPT_PROPERTIES 	g_propUndef 	= { LANG_NEUTRAL, FALSE, FALSE, FALSE, FALSE, 0 };
static const SCRIPT_PROPERTIES*	g_pPropUndef[1]	= { &g_propUndef };

CUniscribe::CUniscribe ()
{
	// Initialize digit substitution info
	ApplyDigitSubstitution(W32->GetDigitSubstitutionMode());

	// Get maximum number of scripts supported
	ScriptGetProperties(NULL, &g_cMaxScript);
}

// Test the OS if it does any complex script.
// REVIEW (keithcu) What if it only supports indic, but not the other ones?
BOOL IsSupportedOS()
{
	BOOL	fSupport = !OnWin95FE();
	int		rguCodePage[] = {1255, 1256, 874};
	BYTE	rgbch[] = {0xe0, 0xd3, 0xa1};
	WCHAR	rgwch[] = {0x05d0, 0x0633, 0x0e01};
	WCHAR	wch;
	int	   	i = 0;

	if (fSupport)
	{
		for (;i < 3; i++)
		{
			if (MBTWC(rguCodePage[i], 0, (LPCSTR)&rgbch[i], 1, (LPWSTR)&wch, 1, NULL) > 0 &&
				wch == rgwch[i])
				break;			// support either Arabic, Hebrew or Thai
		}
	}
	return fSupport && i < 3;
}

// Prepare information for digit substitution
// return: Native digit script (shapine engine) ID.
//
WORD CUniscribe::ApplyDigitSubstitution(BYTE bDigitSubstMode)
{
	_wesNationalDigit = 0;

	// Remember national digits script ID if substitution mode is not None
	if (bDigitSubstMode != DIGITS_NOTIMPL && bDigitSubstMode != DIGITS_NONE)
	{
		WCHAR			chZero = 0x0030;
		int				cItems;
		SCRIPT_ITEM		si[2];
		SCRIPT_CONTROL	sc = {0};
		SCRIPT_STATE	ss = {0};

		// force national digit mode
		sc.uDefaultLanguage   = GetNationalDigitLanguage(GetThreadLocale());
		ss.fDigitSubstitute   = TRUE;
		sc.fContextDigits     = FALSE;

		if (SUCCEEDED(ScriptItemize(&chZero, 1, 2, &sc, &ss, (SCRIPT_ITEM*)&si, (int*)&cItems)))
			_wesNationalDigit = si[0].a.eScript;
	}
	return _wesNationalDigit;
}


// Some locales may have its own traditional (native) digit and national standard digit
// recognised by a standard body and adopted by NLSAPI. The example is that Nepali(India)
// has its own digit but the India standard uses Hindi digit as the national digit.
//
DWORD CUniscribe::GetNationalDigitLanguage(LCID lcid)
{
	DWORD	dwDigitLang = PRIMARYLANGID(LANGIDFROMLCID(lcid));

	if (W32->OnWinNT5())
	{
		WCHAR	rgwstrDigit[20];

		if (GetLocaleInfoW(lcid, LOCALE_SNATIVEDIGITS, rgwstrDigit, ARRAY_SIZE(rgwstrDigit)))
		{
			// Steal this from Uniscribe (build 0231)

			switch (rgwstrDigit[1])
			{
				case 0x0661: dwDigitLang = LANG_ARABIC;    break;
				case 0x06F1: dwDigitLang = LANG_FARSI;     break;
				case 0x0e51: dwDigitLang = LANG_THAI;      break;
				case 0x0967: dwDigitLang = LANG_HINDI;     break;
				case 0x09e7: dwDigitLang = LANG_BENGALI;   break;
				case 0x0a67: dwDigitLang = LANG_PUNJABI;   break;
				case 0x0ae7: dwDigitLang = LANG_GUJARATI;  break;
				case 0x0b67: dwDigitLang = LANG_ORIYA;     break;
				case 0x0be7: dwDigitLang = LANG_TAMIL;     break;
				case 0x0c67: dwDigitLang = LANG_TELUGU;    break;
				case 0x0ce7: dwDigitLang = LANG_KANNADA;   break;
				case 0x0d67: dwDigitLang = LANG_MALAYALAM; break;
				case 0x0f21: dwDigitLang = LANG_TIBETAN;   break;
				case 0x0ed1: dwDigitLang = LANG_LAO;       break;
			}
		}
	}

	return dwDigitLang;
}


CUniscribe::~CUniscribe ()
{
	if (_pFSM)
	{
		delete _pFSM;
	}
}


/***** High level services *****/


// Tokenize string and run Unicode Bidi algorithm if requested.
// return : =<0 - error
//			>0  - number of complex script tokens
//
int CUniscribe::ItemizeString (
	USP_CLIENT* pc,					// in: Working structure
	WORD		uInitLevel,			// in: Initial Bidi level
	int*        pcItems,			// out: Count of items generated
	WCHAR*		pwchString,			// in: Input string
	int			cch,				// in: Number of character to itemize
	BOOL        fUnicodeBiDi,		// in: TRUE - Use UnicodeBidi
	WORD		wLangId)			// in: (optional) Dominant language preference
{
	Assert (pc && pc->si && pcItems && pwchString && cch > 0 && cch <= pc->si->cchString);

	USP_CLIENT_SI*  pc_si = pc->si;
	SCRIPT_ITEM*    psi = pc_si->psi;
	SCRIPT_CONTROL	sc = {0};
	SCRIPT_STATE	ss = {0};
	SCRIPT_CONTROL*	psc;
	SCRIPT_STATE*	pss;
	HRESULT         hr;
	int             cItems = 0;

	if (fUnicodeBiDi)
	{
		psc = &sc;
		pss = &ss;

		if (wLangId == LANG_NEUTRAL)
			wLangId = PRIMARYLANGID(LANGIDFROMLCID(GetThreadLocale()));

		// (preitemize:) set up initial state
		psc->uDefaultLanguage = wLangId;
		
		// For Arabic Office's compatibility.
		// We enable fArabicNumContext if the dominant language is Arabic.
		//
		if (psc->uDefaultLanguage == LANG_ARABIC)
			pss->fArabicNumContext = uInitLevel & 1;

		pss->uBidiLevel         = uInitLevel;
		// Leave digit substitution to None since we do it ourself.
		// pss->fDigitSubstitute   = FALSE;
		// psc->fContextDigits     = FALSE;
	}
	else
	{
		psc = NULL;
		pss = NULL;
	}

	// begin real work
	hr = ScriptItemize(pwchString, cch, cch+1, psc, pss, psi, (int*)&cItems);

	return SUCCEEDED(hr) ? *pcItems = cItems : 0;
}


// Produce a shaped string (glyph array), taking care of font association and measurer's CF update
//
// Success can require 3 calls to Shape():
// 1. Returns E_PENDING (script cache doesn't contain the glyphing information)
// 2. Return USP_E_SCRIPT_NOT_IN_FONT --the HFONT doesn't contain the script needed to do the glyphing
// 3. Hopefully success, but may return again if the fallback font doesn't exist, but we quit anyway.
int CUniscribe::ShapeString (
	PLSRUN					plsrun,		// in: The first run to be shaped
	SCRIPT_ANALYSIS*        psa, 		// in: Analysis of the run to be shaped
	CMeasurer*              pme, 		// in: Measurer points to start cp of the run
	const WCHAR*            pwch, 		// in: String to be shaped
	int                     cch,		// in: Count of chars
	WORD*&                  pwgi, 		// out: Reference to glyph indices array
	WORD*                   pwlc, 		// out: Logical cluster array
	SCRIPT_VISATTR*&        psva)		// out: Reference to glyph's attribute array
{
	AssertSz (plsrun && psa && pme && pwch, "ShapeString failed: Invalid params");

	HRESULT     hr = S_OK;
	HRESULT		hrLastError = S_OK;
	HDC         hdc = NULL;
	HFONT		hOrgFont = NULL;
	int         cGlyphs;
	int			cchAdd = 0;
	CCcs	    *pccsSave = pme->Check_pccs();
	int			nAttempt = 8;	// Maximum attempt to realloc glyph buffer to shape a string

	// make sure that we have proper font cache ready to use
	if (!pme->_pccs)
		return 0;
	
	if (psa->fNoGlyphIndex)
		// If no glyph processing, hdc must be around.
        hdc = PrepareShapeDC(pme, E_PENDING, hOrgFont);

	// prepare glyph buffer
	if (!CacheAllocGlyphBuffers(cch, cGlyphs, pwgi, psva))
		return 0;

	do
	{
		hr = ScriptShape(hdc, &pme->_pccs->_sc, pwch, cch, cGlyphs, psa, pwgi, pwlc, psva, &cGlyphs);

		if (SUCCEEDED(hr))
			break;

		// Error handling...

		switch (hr)
		{
			case E_PENDING:
			case USP_E_SCRIPT_NOT_IN_FONT:

				if (hr == hrLastError)
					nAttempt = 0;		// We encounter the same error twice.
				else
				{
					hdc = PrepareShapeDC(pme, hr, hOrgFont);
					hrLastError = hr;
				}
				break;

			case E_OUTOFMEMORY:

				// (#6773)Indic shaping engine could produce glyphs more than we could hold.
				//
				cchAdd += 16;
				if (CacheAllocGlyphBuffers(cch + cchAdd, cGlyphs, pwgi, psva))
				{
					nAttempt--;
					break;
				}
				
			default:
				nAttempt = 0;
				//AssertSz(FALSE, "Shaping fails with invalid error or we run out of memory.");
				break;
		}

	} while (nAttempt > 0);


	// restore hdc's original font
	if (hdc && hOrgFont)
		SelectObject(hdc, hOrgFont);

	if (pme->_pccs != pccsSave)
		plsrun->SetFallback(SUCCEEDED(hr));

	return SUCCEEDED(hr) ? cGlyphs : 0;
}

// Place a string and take care of font association and measurer's CF update
//
// This is called right after ShapeString.
int CUniscribe::PlaceString(
	PLSRUN					plsrun,		// in: The first run to be shaped
	SCRIPT_ANALYSIS*        psa, 		// in: Analysis of the run to be shaped
	CMeasurer*              pme,        // in: Measurer points to start cp of the run
	const WORD*             pcwgi,      // in: Glyph indices array
	int                     cgi,		// in: Count of input glyphs
	const SCRIPT_VISATTR*   psva, 		// in: Glyph's attribute array
	int*                    pgdx,		// out: Glyph's advanced width array
	GOFFSET*                pgduv,		// out: Glyph's offset array
	ABC*                    pABC)       // out: Run's dimension
{
	AssertSz (plsrun && psa && pme && pcwgi, "PlaceString failed: Invalid params");

	HRESULT     hr = S_OK;
	HRESULT		hrLastError = S_OK;
	HDC         hdc = NULL;
	HFONT		hOrgFont = NULL;
	int			nAttempt = 1;

	pme->Check_pccs();
	pme->ApplyFontCache(plsrun->IsFallback());

	// make sure that we have proper font cache ready to use
	if (!pme->_pccs)
		return 0;

	if (psa->fNoGlyphIndex)
		// If no glyph processing, hdc must be around.
        hdc = PrepareShapeDC(pme, E_PENDING, hOrgFont);

	do
	{
		hr = ScriptPlace(hdc, &pme->_pccs->_sc, pcwgi, cgi, psva, psa, pgdx, pgduv, pABC);

		if (SUCCEEDED(hr))
			break;

		// Error handling...

		switch (hr)
		{
			case E_PENDING:

				if (hr == hrLastError)
					nAttempt = 0;		// We encounter the same error twice.
				else
				{
					hdc = PrepareShapeDC(pme, hr, hOrgFont);
					hrLastError = hr;
				}
				break;

			default:
				nAttempt = 0;
				//AssertSz(FALSE, "Placing fails with invalid error.");
				break;
		}

	} while (nAttempt > 0);


	// restore hdc's original font
	if (hdc && hOrgFont)
		SelectObject(hdc, hOrgFont);

	return SUCCEEDED(hr) ? cgi : 0;
}

// Placing given string results in logical width array,
// the result array would be used to record WMF metafile.
//
int CUniscribe::PlaceMetafileString (
	PLSRUN					plsrun,		// in: The first run to be shaped
	CMeasurer*              pme,        // in: Measurer points to start cp of the run
	const WCHAR*			pwch,		// in: Input codepoint string
	int						cch,		// in: Character count
	PINT*					ppiDx)		// out: Pointer to logical widths array
{
	AssertSz (pme && pwch && ppiDx, "PlaceMetafileString failed: Invalid params");

	if (W32->OnWinNT4() || W32->OnWin9xThai())
	{
		// MET NT40 has bug in lpdx justification so i doesnt playback the lpdx very nicely.
		// Thai Win9x simply cannot handle fancy lpdx values generated by Uniscribe.
		// We workaround both cases here by metafiling no lpdx and let the system reconstructs
		// it from scratch during playback time.

		// =FUTURE= If we do line justification. We need more sophisticated work here
		// basically to reconstruct the OS preferred type of lpdx.
		//
		*ppiDx = NULL;
		return cch;
	}

	HRESULT     	hr = S_OK;
	PUSP_CLIENT		pc = NULL;
	int*			piDx;			// result logical width array
	int				cgi = 0;
	BYTE			pbBufIn[MAX_CLIENT_BUF];
	SCRIPT_ANALYSIS	sa = plsrun->_a;
	BOOL			fVisualGlyphDx = sa.fRTL && W32->OnWin9x() && W32->OnBiDiOS();


	// Get static buffer for logical widths array
	if (!(piDx = GetWidthBuffer(cch)))
		return 0;

	CreateClientStruc(pbBufIn, MAX_CLIENT_BUF, &pc, cch, cli_ShapePlace);
	if (!pc)
		return 0;

	PUSP_CLIENT_SSP	pcssp = pc->ssp;
		
	if (fVisualGlyphDx)
		sa.fLogicalOrder = FALSE;	// shaping result in visual order

	// Shape string
	if (cgi = ShapeString(plsrun, &sa, pme, pwch, (int)cch, pcssp->pwgi, pcssp->pcluster, pcssp->psva))
	{
		// then place it...
		if (cgi == PlaceString(plsrun, &sa, pme, pcssp->pwgi, cgi, pcssp->psva, pcssp->pidx, pcssp->pgoffset, NULL))
		{
			if (fVisualGlyphDx)
			{
				// Workaround BiDi Win9x's lpdx handling
				// It assumes ExtTextOut's dx array is glyph width in visual order

				Assert (cgi <= cch); // glyph count never exceeds character count in BiDi
				CopyMemory (piDx, pcssp->pidx, min(cgi, cch)*sizeof(int));
			}
			else
			{
				// Map visual glyph widths to logical widths
				hr = ScriptGetLogicalWidths(&sa, cch, cgi, pcssp->pidx, pcssp->pcluster, pcssp->psva, piDx);
			}
		}
	}

	// result
	*ppiDx = piDx;

	if (pc && pbBufIn != (BYTE*)pc)
		FreePv(pc);

	return SUCCEEDED(hr) ? cgi : 0;
}



/***** Helper functions *****/


// Retrieve the BidiLevel FSM
const CBiDiFSM* CUniscribe::GetFSM ()
{
	if (!_pFSM)
	{
		_pFSM = new CBiDiFSM(this);
		if (_pFSM && !_pFSM->Init())
		{
			delete _pFSM;
		}
	}
	return _pFSM;
}


// Prepare the shapeable font ready to dc for a given script
//
// USP_E_SCRIPT_NOT_IN_FONT - complex scripts font association
// E_PENDING 				- prepare dc with current font selected
//
HDC CUniscribe::PrepareShapeDC (
    CMeasurer*		pme,        // in: Measurer points to start cp of the run
    HRESULT			hrReq,      // in: Error code to react
	HFONT&			hOrgFont)	// in/out: Original font of the shape DC
{
    Assert (pme);
	
	HDC		hdc = NULL;
	HFONT	hOldFont;

	switch (hrReq)
	{
		case USP_E_SCRIPT_NOT_IN_FONT:
			{
				pme->ApplyFontCache(fTrue);
#ifdef DEBUG
				if (pme->_pccs)
					Tracef(TRCSEVWARN, "USP_E_SCRIPT_NOT_IN_FONT: charset %d applied", pme->_pccs->_bCharSet);
#endif
			}
			
		default:
			if (pme->_pccs)
			{
				hdc = pme->_pccs->_hdc;
				hOldFont = (HFONT)SelectObject(hdc, pme->_pccs->_hfont);

				if (!hOrgFont)
					hOrgFont = hOldFont;
			}
	}

    return hdc;
}

const SCRIPT_PROPERTIES* CUniscribe::GeteProp (WORD eScript)
{
	if (!_ppProp)
	{
		if (!SUCCEEDED(ScriptGetProperties(&_ppProp, NULL)) || !_ppProp)
			_ppProp = g_pPropUndef;
	}
	if (_ppProp == g_pPropUndef || eScript >= (WORD)g_cMaxScript)
		eScript = 0;

	return _ppProp[eScript];
}

// Figure proper charset to use for complex script.
// The resulted charset can be either actual or virtual (internal) GDI charset used by given script
BOOL CUniscribe::GetComplexCharSet(
	const SCRIPT_PROPERTIES* 	psp,				// Uniscribe script's properties 			
	BYTE						bCharSetDefault,	// -1 format's charset
	BYTE&						bCharSetOut)		// out: Charset to use
{
	Assert(psp);

	BYTE	bCharSet = !psp->fCDM ? psp->bCharSet : GetCDMCharSet(bCharSetDefault);
	BOOL 	fr = psp->fComplex && !psp->fControl;

	if (fr)
	{
		bCharSetOut = 	IN_RANGE(ANSI_CHARSET, bCharSet, DEFAULT_CHARSET) ?
						GetCharSet(ConvertLanguageIDtoCodePage(psp->langid), NULL) :
						bCharSet;
	}
	return fr;
}

// Figure out the charset to use for CDM run
//
BYTE CUniscribe::GetCDMCharSet(BYTE bCharSetDefault)
{
	if (!_bCharSetCDM)
	{

		_bCharSetCDM = (bCharSetDefault == VIETNAMESE_CHARSET ||
						W32->GetPreferredKbd(VIET_INDEX) ||
						GetCharSet(GetLocaleCodePage(), NULL) == VIETNAMESE_CHARSET ||
						GetCharSet(GetACP(), NULL) == VIETNAMESE_CHARSET) ? VIETNAMESE_CHARSET : DEFAULT_CHARSET;
	}
	return _bCharSetCDM;
}

BYTE CUniscribe::GetRtlCharSet(CTxtEdit* ped)
{
	if (!_bCharSetRtl)
	{
		// First, try default charset
		DWORD	dwCharFlags;
		BYTE	bCharSet = ped->GetCharFormat(-1)->_bCharSet;

		if (!IN_RANGE(HEBREW_CHARSET, bCharSet, ARABIC_CHARSET))
		{
			// then the system charset
			bCharSet = GetCharSet(GetACP(), NULL);
	
			if (!IN_RANGE(HEBREW_CHARSET, bCharSet, ARABIC_CHARSET))
			{
				// then the content
				dwCharFlags = ped->GetCharFlags() & (fARABIC | fHEBREW);

				if (dwCharFlags == fARABIC)
					bCharSet = ARABIC_CHARSET;
				else if(dwCharFlags == fHEBREW)
					bCharSet = HEBREW_CHARSET;
				else
				{
					// and last chance with the first found loaded Bidi kbd
					if (W32->GetPreferredKbd(HEBREW_INDEX))
						bCharSet = HEBREW_CHARSET;
					else
						// Even if we cant find Arabic, we have to assume it here.
						bCharSet = ARABIC_CHARSET;
				}
			}
		}
		Assert(IsBiDiCharSet(bCharSet));
		_bCharSetRtl = bCharSet;
	}
	return _bCharSetRtl;
}


// Substitute digit shaper in plsrun if needed
//
void CUniscribe::SubstituteDigitShaper (
	PLSRUN		plsrun,
	CMeasurer*	pme)
{
	Assert(plsrun && pme);

	CTxtEdit*	ped = pme->GetPed();
	WORD		wScript;

	if (GeteProp(plsrun->_a.eScript)->fNumeric)
	{
		wScript = plsrun->_pCF->_wScript;		// reset it before

		switch (W32->GetDigitSubstitutionMode())
		{
		case DIGITS_CTX:
			{
				if (ped->IsRich())
				{
					// Context mode simply means the charset of the kbd for richtext.
					if (!IsBiDiCharSet(ped->GetCharFormat(pme->_rpCF.GetFormat())->_bCharSet))
						break;
				}
				else
				{
					// Digit follows directionality of preceding run for plain text
					CFormatRunPtr	rp(pme->_rpCF);
					Assert(rp.IsValid());

					if (rp.PrevRun())
					{
						if (!IsBiDiCharSet(ped->GetCharFormat(rp.GetFormat())->_bCharSet))
							break;
					}
					else
					{
						// No preceding run, looking for the paragraph direction
						if (!pme->Get_pPF()->IsRtlPara())
							break;
					}
				}
				// otherwise, fall thru...
			}
		case DIGITS_NATIONAL:
			wScript = _wesNationalDigit;
		default:
			break;
		}

		// Update all linked runs
		while (plsrun)
		{
			plsrun->_a.eScript = wScript;		// assign proper shaping engine to digits
			plsrun = plsrun->_pNext;
		}
	}
}
	

/***** Uniscribe entry point *****/


// memory allocator
//
BOOL CUniscribe::CreateClientStruc (
	BYTE*           pbBufIn,
	LONG            cbBufIn,
	PUSP_CLIENT*    ppc,
	LONG            cchString,
	DWORD           dwMask)
{
	Assert(ppc && pbBufIn);

	if (!ppc)
		return FALSE;

	*ppc = NULL;

	if (cchString == 0)
		cchString = 1;		// simplify caller's logic

	LONG        i;
	LONG        cbSize;
	PBYTE       pbBlock;

	// ScriptItemize's
	//
	PVOID       pvString;
	PVOID       pvsi;

	// ScriptBreak's
	//
	PVOID       pvsla;

	// ScriptShape & Place's
	//
	PVOID       pvwgi;
	PVOID		pvsva;
	PVOID		pvcluster;
	PVOID		pvidx;
	PVOID		pvgoffset;

	// subtable ptrs
	//
	PUSP_CLIENT_SI      pc_si;
	PUSP_CLIENT_SB      pc_sb;
	PUSP_CLIENT_SSP		pc_ssp;


#define RQ_COUNT    	12

	BUF_REQ     brq[RQ_COUNT] =
	{
		// table and subtable blocks
		//
		{ sizeof(USP_CLIENT),                                                             1, (void**)ppc},
		{ sizeof(USP_CLIENT_SI),    dwMask & cli_Itemize    ? 1                         : 0, (void**)&pc_si},
		{ sizeof(USP_CLIENT_SB),    dwMask & cli_Break      ? 1                         : 0, (void**)&pc_sb},
		{ sizeof(USP_CLIENT_SSP),   dwMask & cli_ShapePlace ? 1                         : 0, (void**)&pc_ssp},

		// data blocks
		//
		{ sizeof(WCHAR),            dwMask & cli_string     ? cchString + 1             : 0, &pvString},
		{ sizeof(SCRIPT_ITEM),      dwMask & cli_psi        ? cchString + 1             : 0, &pvsi},
		{ sizeof(SCRIPT_LOGATTR),   dwMask & cli_psla       ? cchString + 1             : 0, &pvsla},
		{ sizeof(WORD),				dwMask & cli_pwgi       ? GLYPH_COUNT(cchString+1)	: 0, &pvwgi},
		{ sizeof(SCRIPT_VISATTR),   dwMask & cli_psva       ? GLYPH_COUNT(cchString+1)	: 0, &pvsva},
		{ sizeof(WORD),				dwMask & cli_pcluster   ? cchString + 1				: 0, &pvcluster},
		{ sizeof(int),				dwMask & cli_pidx       ? GLYPH_COUNT(cchString+1)	: 0, &pvidx},
		{ sizeof(GOFFSET),			dwMask & cli_pgoffset   ? GLYPH_COUNT(cchString+1)	: 0, &pvgoffset},
	};

	// count total buffer size in byte (WORD aligned)
	//
	for (i=0, cbSize=0; i < RQ_COUNT; i++)
	{
		cbSize += ALIGN(brq[i].size * brq[i].c);
	}

	// allocate the whole buffer at once
	//
	if (cbSize > cbBufIn)
	{
		pbBlock = (PBYTE)PvAlloc(cbSize, 0);
	}
	else
	{
		pbBlock = pbBufIn;
	}

	if (!pbBlock)
	{
		//
		// memory management failed!
		//
		TRACEERRORSZ("Allocation failed in CreateClientStruc!\n");
		*ppc = NULL;
		return FALSE;
	}

	
	// clear the main table
	ZeroMemory (pbBlock, sizeof(USP_CLIENT));


	// assign ptrs in buffer request structure
	//
	for (i=0; i < RQ_COUNT; i++)
	{
		if (brq[i].c > 0)
		{
			*brq[i].ppv = pbBlock;
			pbBlock += ALIGN(brq[i].size * brq[i].c);
		}
		else
		{
			*brq[i].ppv = NULL;
		}
	}

	Assert(((PBYTE)(*ppc)+cbSize == pbBlock));

	// fill in data block ptrs in subtable
	//
	if (pc_si)
	{
		pc_si->pwchString   = (WCHAR*)          pvString;
		pc_si->cchString    =                   cchString;
		pc_si->psi          = (SCRIPT_ITEM*)    pvsi;
	}

	if (pc_sb)
	{
		pc_sb->psla         = (SCRIPT_LOGATTR*) pvsla;
	}

	if (pc_ssp)
	{
		pc_ssp->pwgi		= (WORD*) 			pvwgi;
		pc_ssp->psva		= (SCRIPT_VISATTR*)	pvsva;
		pc_ssp->pcluster	= (WORD*) 			pvcluster;
		pc_ssp->pidx		= (int*)			pvidx;
		pc_ssp->pgoffset	= (GOFFSET*)		pvgoffset;
	}

	// fill in subtable ptrs in header table
	//
	(*ppc)->si              = (PUSP_CLIENT_SI)  pc_si;
	(*ppc)->sb              = (PUSP_CLIENT_SB)  pc_sb;
	(*ppc)->ssp             = (PUSP_CLIENT_SSP) pc_ssp;

	return TRUE;
}


///////	CBidiFSM class implementation
//
//		Create: Worachai Chaoweeraprasit(wchao), Jan 29, 1998
//

CBiDiFSM::~CBiDiFSM ()
{
	FreePv(_pStart);
}


INPUT_CLASS CBiDiFSM::InputClass (
	const CCharFormat*	pcCF,
	CTxtPtr*			ptp,
	LONG				cchRun) const
{
	if (!_pusp->IsValid() || !pcCF || pcCF->_wScript == SCRIPT_WHITE)
		return chGround;

	const SCRIPT_PROPERTIES* psp = _pusp->GeteProp(pcCF->_wScript);
	BYTE 	bCharSet = pcCF->_bCharSet;

	if (psp->fControl)
	{
		if (cchRun == 1)
			switch (ptp->GetChar())				// single-char run
			{
				case LTRMARK: return chLTR;		// \ltrmark
				case RTLMARK: return chRTL;		// \rtlmark
			}
		return chGround;
	}

	if (IsSymbolOrOEM(bCharSet) || IsFECharSet(bCharSet) || pcCF->_dwEffects & CFE_RUNISDBCS)
		return chLTR;

	if (psp->fNumeric)
		// Numeric digits
		return IsBiDiCharSet(psp->bCharSet) || IsBiDiCharSet(bCharSet) ? digitRTL : digitLTR;

	// RTL if it's RTL script or its format charset is RTL and NOT a simplified script
	return IsBiDiCharSet(psp->bCharSet) || pcCF->_wScript && IsBiDiCharSet(bCharSet) ? chRTL : chLTR;
}

// The FSM generates run's embedding level based on given base level and puts it
// in CFormatRun. LsFetchRun is the client using this result.
//
#ifdef DEBUG
//#define DEBUG_LEVEL
#endif

#ifdef DEBUG_LEVEL
void DebugLevel (CBiDiFSMCell* pCell)
{
	Tracef(TRCSEVNONE, "%d,", pCell->_level._value);
}
#else
#define DebugLevel(x)
#endif

HRESULT CBiDiFSM::RunFSM (
	CRchTxtPtr*			prtp,				// in: text pointer to start run
	LONG				cRuns,				// in: number of FSM run
	LONG				cRunsStart,			// in: number of start run
	BYTE				bBaseLevel) const	// in: base level
{
	Assert (prtp->_rpCF.IsValid() && cRuns > 0);

	CRchTxtPtr				rtp(*prtp);
	const CCharFormat*      pCF;
	LONG					cchRun;
	LONG					cRunsAll = cRuns + cRunsStart;
	CBiDiFSMCell*           pCell;
	USHORT                  ucState = bBaseLevel ? S_X * NUM_FSM_INPUTS : 0;
	BOOL					fNext = TRUE;


	// loop thru FSM
	for (; fNext && cRunsAll > 0; cRunsAll--, fNext = !!rtp.Advance(cchRun))
	{
		cchRun = rtp.GetCchLeftRunCF();
	
		pCF = rtp.GetPed()->GetCharFormat(rtp._rpCF.GetFormat());
	
		ucState += InputClass(pCF, &rtp._rpTX, cchRun);

		pCell = &_pStart[ucState];

		// set level to FSM runs
		if (cRunsAll <= cRuns)
			rtp._rpCF.SetLevel (pCell->_level);

		DebugLevel(pCell);

		ucState = pCell->_uNext;	// next state
	}

	return S_OK;
}

// Construct the BiDi embedding level FSM (FSM details see bidifsm2.html)
// :FSM's size = NUM_FSM_INPUTS * NUM_FSM_STATES * sizeof(CBiDiFSMCell) = 6*5*4 = 120 bytes
//
BOOL CBiDiFSM::Init()
{
	CBiDiFSMCell*   pCell;
	int             i;

	// Build the Bidi FSM

	_nState = NUM_FSM_STATES;
	_nInput = NUM_FSM_INPUTS;

	pCell = (CBiDiFSMCell*)PvAlloc(NUM_FSM_STATES * NUM_FSM_INPUTS * sizeof(CBiDiFSMCell), 0);

	if (!pCell)
		return FALSE;	// unable to create FSM!

	_pStart = pCell;


	CBiDiLevel		lvlZero		= {0,0};
	CBiDiLevel		lvlOne  	= {1,0};
	CBiDiLevel		lvlTwo  	= {2,0};
	CBiDiLevel		lvlTwoStart	= {2,1};


	// State A(0): LTR char in LTR para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_B * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_C * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlZero, 0); break;
		}
	}
	// State B(1): RTL char in LTR para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_B * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_C * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlZero, 0); break;
		}
	}
	// State C(2): RTL number run in LTR para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_B * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlZero, 0); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_C * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlZero, 0); break;
		}
	}
	// State X(1): RTL char in RTL para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_Z * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
		}
	}
	// State Y(2): LTR char in RTL para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlTwo, S_Y * NUM_FSM_INPUTS); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwoStart, S_Z * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
		}
	}
	// State Z(2): RTL number in RTL para
	//
	for (i=0; i < NUM_FSM_INPUTS; i++, pCell++)
	{
		switch (i)
		{
			case chLTR:
				SetFSMCell(pCell, &lvlTwoStart, S_Y * NUM_FSM_INPUTS); break;
			case chRTL:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
			case digitLTR:
				SetFSMCell(pCell, &lvlTwoStart, S_Y * NUM_FSM_INPUTS); break;
			case digitRTL:
				SetFSMCell(pCell, &lvlTwo, S_Z * NUM_FSM_INPUTS); break;
			case chGround:
				SetFSMCell(pCell, &lvlOne, S_X * NUM_FSM_INPUTS); break;
		}
	}

	AssertSz(&pCell[-(NUM_FSM_STATES * NUM_FSM_INPUTS)] == _pStart, "Bidi FSM incomplete constructed!");

	return TRUE;
}


///////	CCallbackBufferBase class implementation
//

void* CBufferBase::GetPtr(int cel)
{
	if (_cElem < cel)
	{
		cel += celAdvance;

		_p = PvReAlloc(_p, cel * _cbElem);
		if (!_p)
			return NULL;
		ZeroMemory(_p, cel * _cbElem);
		_cElem = cel;
	}
	return _p;
}

void CBufferBase::Release()
{
	if (_p)
		FreePv(_p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\uuid.cpp ===
/*	
 *	UUID.C
 *
 *	Purpose:
 *		provide definitions for locally used GUID's
 *
 *	Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"

//set these two GUIDs up for export in our file

#undef IID_RichEditOle
#undef IID_IRichEditOleCallback
DEFINE_GUID(IID_IRichEditOle,         0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback, 0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

#undef DEFINE_GUID
#undef DEFINE_OLEGUID

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    const IID name \
        = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


DEFINE_OLEGUID(IID_IDispatch,				0x00020400, 0, 0);
DEFINE_OLEGUID(IID_IUnknown,				0x00000000, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);
DEFINE_OLEGUID(IID_IViewObject,	 			0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IViewObject2,			0x00000127, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,				0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IOleClientSite, 			0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,				0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,			0x00000119, 0, 0);
DEFINE_OLEGUID(IID_IOleLink,	 			0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,	 			0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleObject, 				0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,			0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,	   	0x00000113, 0, 0);
DEFINE_GUID(IID_IRichEditOle,				0x00020D00, 0, 0, 0xC0,0,0,0,0,0,0,0x46);
DEFINE_GUID(IID_IRichEditOleCallback,		0x00020D03, 0, 0, 0xC0,0,0,0,0,0,0,0x46);

DEFINE_OLEGUID(CLSID_Picture_EnhMetafile,	0x00000319, 0, 0);
DEFINE_OLEGUID(CLSID_StaticMetafile,		0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_StaticDib,				0x00000316, 0, 0); 			


// REMARK: presumably TOM should have official MS GUIDs
// To make pre-compiled headers work better, we just copy the
// guid definitions here.  Make sure they don't change!

DEFINE_GUID(LIBID_tom,			0x8CC497C9,	0xA1DF,0x11ce,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextDocument,	0x8CC497C0,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextSelection,	0x8CC497C1,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextRange,		0x8CC497C2,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextFont,		0x8CC497C3,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextPara,		0x8CC497C4,	0xA1DF,0x11CE,0x80,0x98,0x00,0xAA,
											0x00,0x47,0xBE,0x5D);
DEFINE_GUID(IID_ITextMsgFilter,	0xA3787420, 0x4267,0x11D1,0x88,0x3A,0x3C,0x8B,
											0x00,0xC1,0x00,0x00);
DEFINE_GUID(IID_ITextDocument2,	0x01C25500,	0x4268,0x11D1,0x88,0x3A,0x3C,0x8B,
											0x00,0xC1,0x00,0x00);


// Accessibility stuff
// We need to define this as EXTERN_C since the DEFINE_GUID macro removes the EXTERN_C
//
EXTERN_C DEFINE_GUID(IID_IAccessible,		0x618736e0, 0x3c3d, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);
EXTERN_C DEFINE_GUID(LIBID_Accessibility,	0x1ea4dbf0, 0x3c3b, 0x11cf, 0x81, 0x0c, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71);											
EXTERN_C DEFINE_OLEGUID(IID_IEnumVARIANT,	0x00020404, 0x0000, 0x0000);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\util.cpp ===
/*
 *	UTIL.C
 *
 *	Purpose:
 *		Implementation of various useful utility functions
 *
 *	Author:
 *		alexgo (4/25/95)
 */

#include "_common.h"
#include "_rtfconv.h"

ASSERTDATA

// Author revision color table
const COLORREF rgcrRevisions[] =
{
        RGB(0, 0, 255),
        RGB(0, 128, 0),
        RGB(255, 0, 0),
        RGB(0, 128, 128),
        RGB(128, 0, 128),
        RGB(0, 0, 128),
        RGB(128, 0, 0),
        RGB(255, 0, 255)
};

#if REVMASK != 7
#pragma message ("WARNING, Revision mask not equal to table!");
#endif 



/*
 *	DuplicateHGlobal
 *
 *	Purpose:
 *		duplicates the passed in hglobal
 */

HGLOBAL DuplicateHGlobal( HGLOBAL hglobal )
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "DuplicateHGlobal");

	UINT	flags;
	DWORD	size;
	HGLOBAL hNew;
	BYTE *	pSrc;
	BYTE *	pDest;

	if( hglobal == NULL )
	{
		return NULL;
	}

	flags = GlobalFlags(hglobal);
	size = GlobalSize(hglobal);
	hNew = GlobalAlloc(flags, size);

	if( hNew )
	{
		pDest = (BYTE *)GlobalLock(hNew);
		pSrc = (BYTE *)GlobalLock(hglobal);

		if( pDest == NULL || pSrc == NULL )
		{
			GlobalUnlock(hNew);
			GlobalUnlock(hglobal);
			GlobalFree(hNew);

			return NULL;
		}

		memcpy(pDest, pSrc, size);

		GlobalUnlock(hNew);
		GlobalUnlock(hglobal);
	}

	return hNew;
}

/*
 *	CountMatchingBits (*pA, *pB, n)
 *
 *	@mfunc
 *		Count matching bit fields
 *
 *	@comm
 *		This is used to help decide how good the match is between
 *		code page bit fields. Mainly for KB/font switching support.
 *
 *	Author:
 *		Jon Matousek
 */
INT CountMatchingBits(
	const DWORD *pA,	//@parm Array A to be matched
	const DWORD *pB,	//@parm Array B to be matched
	INT			 n)		//@parm # DWORDs to be matched
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CountMatchingBits");
							//0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F
	static INT	bitCount[] = {0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4 };
	INT			c = 0;				// Bit count to return
	DWORD		matchBits;			// Next DWORD match

	while(n--)
	{
		//matchBits = ~(*pA++ ^ *pB++);			// 1 and 0's
		matchBits = *pA++ & *pB++;				// 1 only
		for( ; matchBits; matchBits >>= 4)		// Early out
			c += bitCount[matchBits & 15];
	}
	return c;
}

//
//	Object Stabilization classes
//

//+-------------------------------------------------------------------------
//
//  Member:		CSafeRefCount::CSafeRefCount
//
//  Synopsis: 	constructor for the safe ref count class
//
//  Effects:
//
//  Arguments:	none
//
//  Requires: 	
//
//  Returns: 	none
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CSafeRefCount::CSafeRefCount()
{
	m_cRefs = 0;
	m_cNest = 0;
	m_fInDelete = FALSE;
    m_fForceZombie = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::CSafeRefCount (virtual)
//
//  Synopsis:	
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

CSafeRefCount::~CSafeRefCount()
{
	Assert(m_cRefs == 0 && m_cNest == 0 && m_fInDelete == TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::SafeAddRef
//
//  Synopsis:	increments the reference count on the object
//
//  Effects:
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns: 	ULONG -- the reference count after the increment
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	increments the reference count.
//
//  History:    dd-mmm-yy Author    Comment
//   			28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::SafeAddRef()
{
	m_cRefs++;

	//AssertSz(m_fInDelete == FALSE, "AddRef called on deleted object!");

	// this *could* be really bad.  If we are deleting the object,
	// it means that during the destructor, somebody made an outgoing
	// call eventually ended up with another addref to ourselves
	// (even though	all pointers to us had been 'Released').
	//
	// this is usually caused by code like the following:
	//	m_pFoo->Release();
	//	m_pFoo = NULL;
	//
	// If the the Release may cause Foo to be deleted, which may cause
	// the object to get re-entered during Foo's destructor.  However,
	// 'this' object has not yet set m_pFoo to NULL, so it may
	// try to continue to use m_pFoo.
	//
	// However, the May '94 aggregation rules REQUIRE this behaviour
	// In your destructor, you have to addref the outer unknown before
	// releasing cached interface pointers on your aggregatee.  We
	// can't put an assert here because we do this all the time now.
	//

	return m_cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::SafeRelease
//
//  Synopsis:	decrements the reference count on the object
//
//  Effects: 	May delete the object!
//
//  Arguments:
//
//  Requires:
//
//  Returns:	ULONG -- the reference count after decrement
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm: 	decrements the reference count.  If the reference count
//				is zero AND the nest count is zero AND we are not currently
//				trying to delete our object, then it is safe to delete.
//
//  History:    dd-mmm-yy Author    Comment
//				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::SafeRelease()
{
	ULONG	cRefs;

	if( m_cRefs > 0 )
	{
		cRefs = --m_cRefs;

		if( m_cRefs == 0 && m_cNest == 0 && m_fInDelete == FALSE )
		{
			m_fInDelete = TRUE;
			delete this;
		}
	}
	else
	{
 		// somebody is releasing a non-addrefed pointer!!
		AssertSz(0, "Release called on a non-addref'ed pointer!\n");

		cRefs = 0;
	}

	return cRefs;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::IncrementNestCount
//
//  Synopsis: 	increments the nesting count of the object
//
//  Effects:
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns: 	ULONG; the nesting count after increment
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:	The nesting count is the count of how many times an
//		an object has been re-entered.  For example, suppose
//		somebody calls pFoo->Bar1(), which makes some calls that
//		eventually call pFoo->Bar2();.  On entrace to Bar2, the
//		nest count of the object should be 2 (since the invocation
//		of Bar1 is still on the stack above us).
//
//		It is important to keep track of the nest count so we do
//		not accidentally delete ourselves during a nested invocation.
//		If we did, then when the stack unwinds to the original
//		top level call, it could try to access a non-existent member
//		variable and crash.
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::IncrementNestCount()
{

#ifdef DEBUG
	if( m_fInDelete )
	{
		TRACEWARNSZ("WARNING: CSafeRefCount, object "
			"re-entered during delete!\n");
	}
#endif

	m_cNest++;

	return m_cNest;
}

//+-------------------------------------------------------------------------
//
//  Member: 	CSafeRefCount::DecrementNestCount
//
//  Synopsis: 	decrements the nesting count and deletes the object
//				(if necessary)
//
//  Effects: 	may delete 'this' object!
//
//  Arguments: 	none
//
//  Requires:
//
//  Returns:	ULONG, the nesting count after decrement
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:	decrements the nesting count.  If the nesting count is zero
//				AND the reference count is zero AND we are not currently
//				trying to delete ourselves, then delete 'this' object
//
//  History:    dd-mmm-yy Author    Comment
//				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

ULONG CSafeRefCount::DecrementNestCount()
{
	ULONG	cNest;

	if( m_cNest > 0 )
	{
		cNest = --m_cNest;

		if( m_cRefs == 0 && m_cNest == 0 && m_fInDelete == FALSE )
		{
			m_fInDelete = TRUE;
			delete this;
		}
	}
	else
	{
 		// somebody forget to increment the nest count!!
		AssertSz(0, "Unbalanced nest count!!");

		cNest = 0;
	}

	return cNest;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CSafeRefCount::IsZombie
//
//  Synopsis: 	determines whether or not the object is in a zombie state
//				(i.e. all references gone, but we are still on the stack
//				somewhere).
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns: 	TRUE if in a zombie state
//				FALSE otherwise
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:  If we are in the middle of a delete, or if the ref count
//				is zero and the nest count is greater than zero, then we
//				are a zombie
//
//  History:    dd-mmm-yy Author    Comment
// 				28-Jul-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

BOOL CSafeRefCount::IsZombie()
{
	BOOL	fIsZombie;

	if( (m_cRefs == 0 && m_cNest > 0) || m_fInDelete == TRUE
	    || m_fForceZombie == TRUE)
	{
		fIsZombie = TRUE;
	}
	else
	{
		fIsZombie = FALSE;
	}

	return fIsZombie;
}

//+-------------------------------------------------------------------------
//
//  Member:  	CSafeRefCount::Zombie
//
//  Synopsis: 	Forces the object into a zombie state.  This is called
//              when the object is still around but shouldn't be. It
//              flags us so we behave safely while we are in this state.
//
//  Effects:
//
//  Arguments:	none
//
//  Requires:
//
//  Returns:    none
//
//  Signals:
//
//  Modifies:
//
//  Derivation:
//
//  Algorithm:
//
//  History:
//
//  Notes:
//
//--------------------------------------------------------------------------

VOID CSafeRefCount::Zombie()
{
    m_fForceZombie = TRUE;
}

/* OleStdSwitchDisplayAspect
**
**	@mfunc
**    Switch the currently cached display aspect between DVASPECT_ICON
**    and DVASPECT_CONTENT.
**
**    NOTE: when setting up icon aspect, any currently cached content
**    cache is discarded and any advise connections for content aspect
**    are broken.
**
**	@rdesc
**      S_OK -- new display aspect setup successfully
**      E_INVALIDARG -- IOleCache interface is NOT supported (this is
**                  required).
**      <other SCODE> -- any SCODE that can be returned by
**                  IOleCache::Cache method.
**      NOTE: if an error occurs then the current display aspect and
**            cache contents unchanged.
*/
HRESULT OleStdSwitchDisplayAspect(
		LPOLEOBJECT             lpOleObj,
		LPDWORD                 lpdwCurAspect,
		DWORD                   dwNewAspect,
		HGLOBAL                 hMetaPict,
		BOOL                    fDeleteOldAspect,
		BOOL                    fSetupViewAdvise,
		LPADVISESINK            lpAdviseSink,
		BOOL FAR*               lpfMustUpdate)
{
#ifndef PEGASUS
   LPOLECACHE      lpOleCache = NULL;
   LPVIEWOBJECT    lpViewObj = NULL;
   LPENUMSTATDATA  lpEnumStatData = NULL;
   STATDATA        StatData;
   FORMATETC       FmtEtc;
   STGMEDIUM       Medium;
   DWORD           dwAdvf;
   DWORD           dwNewConnection;
   DWORD           dwOldAspect = *lpdwCurAspect;
   HRESULT         hrErr;

   if (lpfMustUpdate)
      *lpfMustUpdate = FALSE;

   if (hrErr =
	   lpOleObj->QueryInterface(IID_IOleCache, (void**)&lpOleCache))
   {
	   return hrErr;
   }

   // Setup new cache with the new aspect
   FmtEtc.cfFormat = 0;     // whatever is needed to draw
   FmtEtc.ptd      = NULL;
   FmtEtc.dwAspect = dwNewAspect;
   FmtEtc.lindex   = -1;
   FmtEtc.tymed    = TYMED_NULL;

   /* NOTE: if we are setting up Icon aspect with a custom icon
   **    then we do not want DataAdvise notifications to ever change
   **    the contents of the data cache. thus we set up a NODATA
   **    advise connection. otherwise we set up a standard DataAdvise
   **    connection.
   */
   if (dwNewAspect == DVASPECT_ICON && hMetaPict)
      dwAdvf = ADVF_NODATA;
   else
      dwAdvf = ADVF_PRIMEFIRST;

   hrErr = lpOleCache->Cache(
         (LPFORMATETC)&FmtEtc,
         dwAdvf,
         (LPDWORD)&dwNewConnection
   );

   if (! SUCCEEDED(hrErr)) {
      lpOleCache->Release();
      return hrErr;
   }

   *lpdwCurAspect = dwNewAspect;

   /* NOTE: if we are setting up Icon aspect with a custom icon,
   **    then stuff the icon into the cache. otherwise the cache must
   **    be forced to be updated. set the *lpfMustUpdate flag to tell
   **    caller to force the object to Run so that the cache will be
   **    updated.
   */
   if (dwNewAspect == DVASPECT_ICON && hMetaPict) {

      FmtEtc.cfFormat = CF_METAFILEPICT;
      FmtEtc.ptd      = NULL;
      FmtEtc.dwAspect = DVASPECT_ICON;
      FmtEtc.lindex   = -1;
      FmtEtc.tymed    = TYMED_MFPICT;

      Medium.tymed            = TYMED_MFPICT;
      Medium.hGlobal        = hMetaPict;
      Medium.pUnkForRelease   = NULL;

      hrErr = lpOleCache->SetData(
            (LPFORMATETC)&FmtEtc,
            (LPSTGMEDIUM)&Medium,
            FALSE   /* fRelease */
      );
   } else {
      if (lpfMustUpdate)
         *lpfMustUpdate = TRUE;
   }

   if (fSetupViewAdvise && lpAdviseSink) {
      /* NOTE: re-establish the ViewAdvise connection */
      lpOleObj->QueryInterface(IID_IViewObject, (void**)&lpViewObj);

      if (lpViewObj) {

         lpViewObj->SetAdvise(
               dwNewAspect,
               0,
               lpAdviseSink
         );

         lpViewObj->Release();
      }
   }

   /* NOTE: remove any existing caches that are set up for the old
   **    display aspect. It WOULD be possible to retain the caches set
   **    up for the old aspect, but this would increase the storage
   **    space required for the object and possibly require additional
   **    overhead to maintain the unused cachaes. For these reasons the
   **    strategy to delete the previous caches is prefered. if it is a
   **    requirement to quickly switch between Icon and Content
   **    display, then it would be better to keep both aspect caches.
   */

   if (fDeleteOldAspect) {
      hrErr = lpOleCache->EnumCache(
            (LPENUMSTATDATA FAR*)&lpEnumStatData
      );

      while(hrErr == NOERROR) {
         hrErr = lpEnumStatData->Next(
               1,
               (LPSTATDATA)&StatData,
               NULL
         );
         if (hrErr != NOERROR)
            break;              // DONE! no more caches.

         if (StatData.formatetc.dwAspect == dwOldAspect) {

            // Remove previous cache with old aspect
            lpOleCache->Uncache(StatData.dwConnection);
         }
      }

      if (lpEnumStatData)
         lpEnumStatData->Release();
   }

   if (lpOleCache)
      lpOleCache->Release();
#endif
   return NOERROR;
}

/*
 *	ObjectReadSiteFlags
 *
 *	@mfunc
 *		Read the dwFlags, dwUser, & dvaspect bytes from a container
 *		specific stream.
 *
 *	Arguments:
 *		preobj			The REOBJ in which to copy the flags.
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT ObjectReadSiteFlags(REOBJECT * preobj)
{
	HRESULT hr = NOERROR;
#ifndef PEGASUS
	LPSTREAM pstm = NULL;
	OLECHAR StreamName[] = OLESTR("RichEditFlags");


	// Make sure we have a storage to read from
	if (!preobj->pstg)
		return E_INVALIDARG;

	// Open the stream
	if (hr = preobj->pstg->OpenStream(StreamName, 0, STGM_READ |
										STGM_SHARE_EXCLUSIVE, 0, &pstm))
	{
		goto Cleanup;
	}

	if ((hr = pstm->Read(&preobj->dwFlags,
							sizeof(preobj->dwFlags), NULL)) ||
		(hr = pstm->Read(&preobj->dwUser,
							 sizeof(preobj->dwUser), NULL)) ||
		(hr = pstm->Read(&preobj->dvaspect,
								 sizeof(preobj->dvaspect), NULL)))
	{
		goto Cleanup;
	}

Cleanup:
	if (pstm)
		pstm->Release();
#endif
	return hr;
}

//Used for EnumMetafileCheckIcon & FIsIconMetafilePict
typedef	struct _walkmetafile
{
	BOOL	fAND;
	BOOL	fPastIcon;
	BOOL 	fHasIcon;
} WALKMETAFILE;

static CHAR szIconOnly[] = "IconOnly";

/*
 * EnumMetafileCheckIcon
 *
 * @mfunc
 *	Stripped down version of EnumMetafileExtractIcon and
 *	EnumMetafileExtractIconSource from the OLE2UI library.
 *
 *  EnumMetaFile callback function that walks a metafile looking for
 *  StretchBlt (3.1) and BitBlt (3.0) records.  We expect to see two
 *  of them, the first being the AND mask and the second being the XOR
 *  data. 
 *
 *	Once we find the icon, we confirm this find by looking for the "IconOnly"
 *	comment block found in standard OLE iconic metafiles.
 *
 *  Arguments:
 *		hDC             HDC into which the metafile should be played.
 *		phTable         HANDLETABLE FAR * providing handles selected into the DC.
 *		pMFR            METARECORD FAR * giving the enumerated record.
 *		pIE             LPICONEXTRACT providing the destination buffer and length.
 *
 * @rdesc
 *  int             0 to stop enumeration, 1 to continue.
 */

int CALLBACK EnumMetafileCheckIcon(HDC hdc, HANDLETABLE *phTable,
											METARECORD *pMFR, int cObj,
											LPARAM lparam)
{
#ifndef PEGASUS
	WALKMETAFILE *		pwmf = (WALKMETAFILE *) lparam;

	switch (pMFR->rdFunction)
	{
	case META_DIBBITBLT:			// Win30
	case META_DIBSTRETCHBLT:		// Win31
		// If this is the first pass (pIE->fAND==TRUE) then save the memory
		// of the AND bits for the next pass.

		if (pwmf->fAND)
			pwmf->fAND = FALSE;
		else
			pwmf->fPastIcon = TRUE;
		break;

	case META_ESCAPE:
		if (pwmf->fPastIcon &&
			pMFR->rdParm[0] == MFCOMMENT &&
			!lstrcmpiA(szIconOnly, (LPSTR)&pMFR->rdParm[2]))
		{
			pwmf->fHasIcon = TRUE;
			return 0;
		}
		break;
	}
#endif
	return 1;
}

/*
 *	FIsIconMetafilePict
 *
 *	@mfunc
 *		Detect whether the metafile contains an iconic presentation. We do this
 *		by getting a screen DC and walking the metafile records until we find
 *		the landmarks denoting an icon.
 *
 *		Arguments:
 *			hmfp			The metafile to test
 *
 *	@rdesc
 *		BOOL			TRUE if the metafile contains an iconic view
 */
BOOL FIsIconMetafilePict(HGLOBAL hmfp)
{
#ifndef PEGASUS
	LPMETAFILEPICT	pmfp;
	WALKMETAFILE	wmf = { 0 };
	HDC				hdc;

	wmf.fAND = TRUE;
	if (!hmfp || !(pmfp = (LPMETAFILEPICT)GlobalLock(hmfp)))
		goto CleanUp;

	// We get information back in the ICONEXTRACT structure.
	hdc = GetDC(NULL);
	EnumMetaFile(hdc, pmfp->hMF, EnumMetafileCheckIcon, (LPARAM) &wmf);
	ReleaseDC(NULL, hdc);
	GlobalUnlock(hmfp);

CleanUp:
	return wmf.fHasIcon;
#else
	return TRUE;
#endif
}

/*
 * AllocObjectDescriptor
 *
 * Purpose:
 *  Allocated and fills an OBJECTDESCRIPTOR structure.
 *
 * Parameters:
 *  clsID           CLSID to store.
 *  dwAspect        DWORD with the display aspect
 *  pszl            LPSIZEL (optional) if the object is being scaled in
 *                  its container, then the container should pass the
 *                  extents that it is using to display the object.
 *  ptl             POINTL from upper-left corner of object where
 *                  mouse went down for use with Drag & Drop.
 *  dwMisc          DWORD containing MiscStatus flags
 *  pszName         LPTSTR naming the object to copy
 *  pszSrc          LPTSTR identifying the source of the object.
 *
 * Return Value:
 *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure.
 */

/*
 * AllocObjectDescriptor
 *
 * Purpose:
 *  Allocated and fills an OBJECTDESCRIPTOR structure.
 *
 * Parameters:
 *  clsID           CLSID to store.
 *  dwAspect        DWORD with the display aspect
 *  pszl            LPSIZEL (optional) if the object is being scaled in
 *                  its container, then the container should pass the
 *                  extents that it is using to display the object.
 *  ptl             POINTL from upper-left corner of object where
 *                  mouse went down for use with Drag & Drop.
 *  dwMisc          DWORD containing MiscStatus flags
 *  pszName         LPTSTR naming the object to copy
 *  pszSrc          LPTSTR identifying the source of the object.
 *
 * Return Value:
 *  HBGLOBAL         Handle to OBJECTDESCRIPTOR structure.
 */
static HGLOBAL AllocObjectDescriptor(
	CLSID clsID,
	DWORD dwAspect,
	SIZEL szl,
	POINTL ptl,
	DWORD dwMisc,
	LPTSTR pszName,
	LPTSTR pszSrc)
{
#ifndef PEGASUS
    HGLOBAL              hMem=NULL;
    LPOBJECTDESCRIPTOR   pOD;
    DWORD                cb, cbStruct;
    DWORD                cchName, cchSrc;

	cchName=wcslen(pszName)+1;

    if (NULL!=pszSrc)
        cchSrc=wcslen(pszSrc)+1;
    else
        {
        cchSrc=cchName;
        pszSrc=pszName;
        }

    /*
     * Note:  CFSTR_OBJECTDESCRIPTOR is an ANSI structure.
     * That means strings in it must be ANSI.  OLE will do
     * internal conversions back to Unicode as necessary,
     * but we have to put ANSI strings in it ourselves.
     */
    cbStruct=sizeof(OBJECTDESCRIPTOR);
    cb=cbStruct+(sizeof(WCHAR)*(cchName+cchSrc));   //HACK

    hMem=GlobalAlloc(GHND, cb);

    if (NULL==hMem)
        return NULL;

    pOD=(LPOBJECTDESCRIPTOR)GlobalLock(hMem);

    pOD->cbSize=cb;
    pOD->clsid=clsID;
    pOD->dwDrawAspect=dwAspect;
    pOD->sizel=szl;
    pOD->pointl=ptl;
    pOD->dwStatus=dwMisc;

    if (pszName)
        {
        pOD->dwFullUserTypeName=cbStruct;
       wcscpy((LPTSTR)((LPBYTE)pOD+pOD->dwFullUserTypeName)
            , pszName);
        }
    else
        pOD->dwFullUserTypeName=0;  //No string

    if (pszSrc)
        {
        pOD->dwSrcOfCopy=cbStruct+(cchName*sizeof(WCHAR));

        wcscpy((LPTSTR)((LPBYTE)pOD+pOD->dwSrcOfCopy), pszSrc);
        }
    else
        pOD->dwSrcOfCopy=0;  //No string

    GlobalUnlock(hMem);
    return hMem;
#else
	return NULL;
#endif
}

HGLOBAL OleGetObjectDescriptorDataFromOleObject(
	LPOLEOBJECT pObj,
	DWORD       dwAspect,
	POINTL      ptl,
	LPSIZEL     pszl
)
{
#ifndef PEGASUS
    CLSID           clsID;
    LPTSTR          pszName=NULL;
    LPTSTR          pszSrc=NULL;
   BOOL            fLink=FALSE;
    IOleLink       *pLink;
    TCHAR           szName[512];
    DWORD           dwMisc=0;
    SIZEL           szl = {0,0};
    HGLOBAL         hMem;
    HRESULT         hr;
    
    
    if (SUCCEEDED(pObj->QueryInterface(IID_IOleLink
        , (void **)&pLink)))
        fLink=TRUE;

    if (FAILED(pObj->GetUserClassID(&clsID)))
		ZeroMemory(&clsID, sizeof(CLSID));

    //Get user string, expand to "Linked %s" if this is link
    pObj->GetUserType(USERCLASSTYPE_FULL, &pszName);
    if (fLink && NULL!=pszName)
	{
		// NB!! we do these two lines of code below instead
		// wcscat because we don't use wcscat anywhere else
		// in the product at the moment.  The string "Linked "
		// should never change either.
		wcscpy(szName, TEXT("Linked "));
		wcscpy(&(szName[7]), pszName);
	}
    else if (pszName)
       wcscpy(szName, pszName);
	else
		szName[0] = 0;
 
	CoTaskMemFree(pszName);

   /*
     * Get the source name of this object using either the
     * link display name (for link) or a moniker display
     * name.
     */

    if (fLink)
		{
        hr=pLink->GetSourceDisplayName(&pszSrc);
		}
    else
        {
        IMoniker   *pmk;

        hr=pObj->GetMoniker(OLEGETMONIKER_TEMPFORUSER
            , OLEWHICHMK_OBJFULL, &pmk);

        if (SUCCEEDED(hr))
            {
            IBindCtx  *pbc;
            CreateBindCtx(0, &pbc);

            pmk->GetDisplayName(pbc, NULL, &pszSrc);
            pbc->Release();
            pmk->Release();
            }
        }

    if (fLink)
        pLink->Release();

    //Get MiscStatus bits
    hr=pObj->GetMiscStatus(dwAspect, &dwMisc);

    if (pszl)
    {
        szl.cx = pszl->cx;
        szl.cy = pszl->cy;
    }
    //Get OBJECTDESCRIPTOR
    hMem=AllocObjectDescriptor(clsID, dwAspect, szl, ptl, dwMisc, szName, pszSrc);

    CoTaskMemFree(pszSrc);

    return hMem;
#else
	return NULL;
#endif
}

/*
 * OleStdGetMetafilePictFromOleObject()
 *
 * @mfunc:
 *  Generate a MetafilePict from the OLE object.
 *  Parameters:
 *		lpOleObj        LPOLEOBJECT pointer to OLE Object 
 *		dwDrawAspect    DWORD   Display Aspect of object
 *		lpSizelHim      SIZEL   (optional) If the object is being scaled in its
 *                  container, then the container should pass the extents 
 *                  that it is using to display the object. 
 *                  May be NULL if the object is NOT being scaled. in this
 *                  case, IViewObject2::GetExtent will be called to get the
 *                  extents from the object.
 *  ptd             TARGETDEVICE FAR*   (optional) target device to render
 *                  metafile for. May be NULL.
 *
 * @rdesc
 *    HANDLE    -- handle of allocated METAFILEPICT
 */
HANDLE OleStdGetMetafilePictFromOleObject(
        LPOLEOBJECT         lpOleObj,
        DWORD               dwDrawAspect,
        LPSIZEL             lpSizelHim,
        DVTARGETDEVICE FAR* ptd
)
{
#ifndef PEGASUS
    LPVIEWOBJECT2 lpViewObj2 = NULL;
    HDC hDC;
    HMETAFILE hmf;
    HANDLE hMetaPict;
    LPMETAFILEPICT lpPict;
    RECT rcHim;
    RECTL rclHim;
    SIZEL sizelHim;
    HRESULT hrErr;
    SIZE size;
    POINT point;
	LPOLECACHE polecache = NULL;
	LPDATAOBJECT pdataobj = NULL;
	FORMATETC fetc;
	STGMEDIUM med;

	// First try the easy way,
	// pull out the cache's version of things.
	ZeroMemory(&fetc, sizeof(FORMATETC));
	fetc.dwAspect = dwDrawAspect;
	fetc.cfFormat = CF_METAFILEPICT;
	fetc.lindex = -1;
	fetc.tymed = TYMED_MFPICT;
	ZeroMemory(&med, sizeof(STGMEDIUM));
	hMetaPict = NULL;

	if (!lpOleObj->QueryInterface(IID_IOleCache, (void **)&polecache) &&
		!polecache->QueryInterface(IID_IDataObject, (void **)&pdataobj) &&
		!pdataobj->GetData(&fetc, &med))
	{
		hMetaPict = OleDuplicateData(med.hGlobal, CF_METAFILEPICT, 0);
		ReleaseStgMedium(&med);
	}

	if (pdataobj)
	{
		pdataobj->Release();
	}

	if (polecache)
	{
		polecache->Release();
	}

	// If all this failed, fall back to the hard way and draw the object
	// into a metafile.
	if (hMetaPict)
		return hMetaPict;

    if (lpOleObj->QueryInterface(IID_IViewObject2, (void **)&lpViewObj2))
        return NULL;

    // Get SIZEL
    if (lpSizelHim) {
        // Use extents passed by the caller
        sizelHim = *lpSizelHim;
    } else {
        // Get the current extents from the object
        hrErr = lpViewObj2->GetExtent(
					dwDrawAspect,
					-1,     /*lindex*/
					ptd,    /*ptd*/
					(LPSIZEL)&sizelHim);
        if (hrErr != NOERROR)
            sizelHim.cx = sizelHim.cy = 0;
    }

    hDC = CreateMetaFileA(NULL);

    rclHim.left     = 0;
    rclHim.top      = 0;
    rclHim.right    = sizelHim.cx;
    rclHim.bottom   = sizelHim.cy;

    rcHim.left      = (int)rclHim.left;
    rcHim.top       = (int)rclHim.top;
    rcHim.right     = (int)rclHim.right;
    rcHim.bottom    = (int)rclHim.bottom;

    SetWindowOrgEx(hDC, rcHim.left, rcHim.top, &point);
    SetWindowExtEx(hDC, rcHim.right-rcHim.left, rcHim.bottom-rcHim.top,&size);

    hrErr = lpViewObj2->Draw(
            dwDrawAspect,
            -1,
            NULL,
            ptd,
            NULL,
            hDC,
            (LPRECTL)&rclHim,
            (LPRECTL)&rclHim,
            NULL,
            0
    );

    lpViewObj2->Release();

    hmf = CloseMetaFile(hDC);

    if (hrErr != NOERROR) {
		TRACEERRORHR(hrErr);
		hMetaPict = NULL;
    }
	else
	{
    	hMetaPict = GlobalAlloc(GHND|GMEM_SHARE, sizeof(METAFILEPICT));

    	if (hMetaPict && (lpPict = (LPMETAFILEPICT)GlobalLock(hMetaPict))){
        	lpPict->hMF  = hmf;
        	lpPict->xExt = (int)sizelHim.cx ;
        	lpPict->yExt = (int)sizelHim.cy ;
        	lpPict->mm   = MM_ANISOTROPIC;
        	GlobalUnlock(hMetaPict);
    	}
	}

	if (!hMetaPict)
		DeleteMetaFile(hmf);

    return hMetaPict;
#else
	return NULL;
#endif
}

/*
 * OleUIDrawShading
 *
 * Purpose:
 *  Shade the object when it is in in-place editing. Borders are drawn
 *  on the Object rectangle. The right and bottom edge of the rectangle
 *  are excluded in the drawing.
 *
 * Parameters:
 *  lpRect      Dimensions of Container Object
 *  hdc         HDC for drawing
 *
 * Return Value: null
 *
 */
void OleUIDrawShading(LPRECT lpRect, HDC hdc)
{
#ifndef PEGASUS
    HBRUSH  hbr;
    HBRUSH  hbrOld;
    HBITMAP hbm;
    RECT    rc;
    WORD    wHatchBmp[] = {0x11, 0x22, 0x44, 0x88, 0x11, 0x22, 0x44, 0x88};
    COLORREF cvText;
    COLORREF cvBk;

    hbm = CreateBitmap(8, 8, 1, 1, wHatchBmp);
    hbr = CreatePatternBrush(hbm);
    hbrOld = (HBRUSH)SelectObject(hdc, hbr);

    rc = *lpRect;

    cvText = SetTextColor(hdc, RGB(255, 255, 255));
    cvBk = SetBkColor(hdc, RGB(0, 0, 0));
    PatBlt(hdc, rc.left, rc.top, rc.right-rc.left, rc.bottom-rc.top,
            0x00A000C9L /* DPa */ );

    SetTextColor(hdc, cvText);
    SetBkColor(hdc, cvBk);
    SelectObject(hdc, hbrOld);
    DeleteObject(hbr);
    DeleteObject(hbm);
#endif
}



/*
 *	OleSaveSiteFlags
 *
 *	Purpose:
 *		Save the dwFlags and dwUser bytes into a container specific stream
 *
 *	Arguments:
 *		pstg			The storage to save to
 *		pobsite			The site from where to copy the flags
 *
 *	Returns:
 *		None.
 */
VOID OleSaveSiteFlags(LPSTORAGE pstg, DWORD dwFlags, DWORD dwUser, DWORD dvAspect)
{
#ifndef PEGASUS
	HRESULT hr;
	LPSTREAM pstm = NULL;
	static const OLECHAR szSiteFlagsStm[] = OLESTR("RichEditFlags");

	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "OleSaveSiteFlags");

	// Create/overwrite the stream
	AssertSz(pstg, "Invalid storage");
	if (hr = pstg->CreateStream(szSiteFlagsStm, STGM_READWRITE | STGM_CREATE | STGM_SHARE_EXCLUSIVE,
							    0, 0, &pstm))
	{
		TraceError("OleSaveSiteFlags", GetScode(hr));
		goto Cleanup;
	}

	//$ FUTURE: Put a version stamp

	// Write out the values
	//$ BUG: byte order
	if ((hr = pstm->Write(&dwFlags, sizeof(dwFlags), NULL)) ||
		(hr = pstm->Write(&dwUser, sizeof(dwUser), NULL)) ||
		(hr = pstm->Write(&dvAspect, sizeof(dvAspect), NULL)))
	{
		TraceError("OleSaveSiteFlags", GetScode(hr));
		//$ FUTURE: Wipe the data to make this operation all or nothing
		goto Cleanup;
	}

Cleanup:
    if (pstm)
        pstm->Release();
#endif	
}



/*
 *	AppendString ( szInput, szAppendStr, dBuffSize, dByteUsed )
 *
 *	Purpose:
 *		Append new string to original string. Check for size of buffer
 *	and re-allocate a large buffer is necessary
 *
 *	Arguments:
 *		szInput			Original String 
 *		szAppendStr		String to be appended to szInput 
 *		dBuffSize		Byte size of the buffer for szInput
 *		dByteUsed		Byte used in the buffer for szInput
 *
 *	Returns:
 *		INT		The error code
 */
INT AppendString( 
	BYTE ** szInput, 
	BYTE * szAppendStr,
	int	* dBuffSize,
	int * dByteUsed)
{
	BYTE	*pch;
	int		cchAppendStr;

	pch = *szInput;

	// check if we have enough space to append the new string
	cchAppendStr = strlen( (char *)szAppendStr );
	
	if ( cchAppendStr + *dByteUsed >= *dBuffSize )
	{
		// re-alloc a bigger buffer
		int cchNewSize = *dBuffSize + cchAppendStr + 32;
		
		pch = (BYTE *)PvReAlloc( *szInput, cchNewSize );
	
		if ( !pch )
		{
			return ( ecNoMemory );
		}

		*dBuffSize = cchNewSize;
		*szInput = pch;
	}

	pch += *dByteUsed;
	*dByteUsed += cchAppendStr;

	while (*pch++ = *szAppendStr++);	
	
	return ecNoError;
}

/*
 *	CTempBuf::Init
 *
 *	@mfunc	Set object to its initial state using the stack buffer
 *
 */
void CTempBuf::Init()
{
	_pv = (void *) &_chBuf[0];
	_cb = MAX_STACK_BUF;
}

/*
 *	CTempBuf::FreeBuf
 *
 *	@mfunc	Free an allocated buffer if there is one
 *
 */
void CTempBuf::FreeBuf()
{
	if (_pv != &_chBuf[0])
	{
		delete _pv;
	}
}

/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer for temporary use
 *
 *	@rdesc	Pointer to buffer if one could be allocated otherwise NULL.
 *
 *
 */
void *CTempBuf::GetBuf(
	LONG cb)				//@parm Size of buffer needed in bytes
{
	if (_cb >= cb)
	{
		// Currently allocated buffer is big enough so use it
		return _pv;
	}

	// Free our current buffer
	FreeBuf();

	// Allocate a new buffer if we can
	_pv = new BYTE[cb];

	if (NULL == _pv)
	{
		// Could not allocate a buffer so reset to our initial state and
		// return NULL.
		Init();
		return NULL;
	}

	// Store the size of our new buffer.
	_cb = cb;

	// Returnt he pointer to the buffer.
	return _pv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\w32sys.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	w32sys.cpp - thin layer over Win32 services
 *	
 *	History: <nl>
 *		1/22/97 joseogl Created
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

// This prevents the "W32->" prefix from being prepended to our identifiers.

#define W32SYS_CPP

#include "_common.h"
#include "_host.h"
#include "_font.h"
#include "_edit.h"
#include <malloc.h>

// Include the appropriate implementation.
#if defined(PEGASUS)
#include "w32wince.cpp"
#else
#include "w32win32.cpp"
#endif

ASSERTDATA

/*
 *	@struct CPGCHAR |
 *		Locally used variable that contains code-page and char-set info
 */
typedef struct _cpgcharset
{
	INT			nCodePage;				// @field Code page
	BYTE		bCharSet;				// @field Character set
	DWORD		dwFontSig;				// @field Font signature bits
} CPGCHAR;

static const CPGCHAR rgCpgCharSet[NCHARSETS] =
{
	{1252,	ANSI_CHARSET,			fLATIN1>>8}, // fLATIN1 has 3 bits
	{0,		DEFAULT_CHARSET,		0x00000000}, // Not reliably implemented...
	{CP_SYMBOL,SYMBOL_CHARSET,		0x00004000}, // No trans, except WORD -> BYTE
	{437,	PC437_CHARSET,			0x00000000}, // United States IBM
	{850,	OEM_CHARSET,			0x00000400}, // IBM Multilingual
	{1250,	EASTEUROPE_CHARSET,		0x00000002}, // Eastern Europe
	{1255,	HEBREW_CHARSET,			0x00000020}, // Hebrew
	{1256,  ARABIC_CHARSET,			0x00000040}, // Arabic
	{932,	SHIFTJIS_CHARSET,		0x00020000}, // Japanese
	{1251,	RUSSIAN_CHARSET,		0x00000004}, // Russian
	{936,	GB2312_CHARSET,			0x00040000}, // PRC
	{949,	HANGEUL_CHARSET,		0x00080000}, // Hangul
	{1361,	JOHAB_CHARSET,			0x00000000}, // JOHAB
	{950,	CHINESEBIG5_CHARSET,	0x00100000}, // Chinese
	{1253,	GREEK_CHARSET,			0x00000008}, // Greek
	{1254,	TURKISH_CHARSET,		0x00000010}, // Turkish
	{1257,	BALTIC_CHARSET,			0x00000080}, // Estonia, Lithuania, Latvia
	{1258,	VIETNAMESE_CHARSET,		0x00000100}, // Vietnamese
	{874,	THAI_CHARSET,			0x00010000}, // Thai
	{CP_DEVANAGARI,DEVANAGARI_CHARSET,0x00200000}, // Devanagari
	{CP_TAMIL, TAMIL_CHARSET,		0x00400000}, // Tamil
	{CP_GEORGIAN, GEORGIAN_CHARSET,	0x00800000}, // Georgian
	{CP_ARMENIAN, ARMENIAN_CHARSET,	0x00000200}, // Armenian
	{10000,	MAC_CHARSET,			0x00000000}	 // Most popular Mac (English, etc.)
};

#define cCpgCharSet ARRAY_SIZE(rgCpgCharSet)

#define	LANG_TAIWAN	 MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL)

const WORD CodePageTable[] = {
/* CodePage		  PLID	primary language
   ------------------------------------- */
	   0,		// 00 -	undefined
	1256,		// 01 - Arabic
	1251,		// 02 - Bulgarian
	1252,		// 03 - Catalan
	 950,		// 04 - Taiwan (Hong Kong, PRC, and Singapore are 936)
	1250,		// 05 - Czech
	1252,		// 06 - Danish
	1252,		// 07 - German
	1253,		// 08 - Greek
	1252,		// 09 - English
	1252,		// 0a - Spanish
	1252,		// 0b - Finnish
	1252,		// 0c - French
	1255,		// 0d - Hebrew
	1250,		// 0e - Hungarian
	1252,		// 0f - Icelandic
	1252,		// 10 - Italian
	 932,		// 11 - Japan
	 949,		// 12 - Korea
	1252,		// 13 - Dutch
	1252,		// 14 - Norwegian
	1250,		// 15 - Polish
	1252,		// 16 - Portuguese
	   0,		// 17 -	Rhaeto-Romanic
	1250,		// 18 - Romanian
	1251,		// 19 - Russian
	1250,		// 1a -	Croatian
	1250,		// 1b - Slovak
	1250,		// 1c -	Albanian
	1252,		// 1d - Swedish
	 874,		// 1e - Thai
	1254,		// 1f - Turkish
	1256,		// 20 -	Urdu
	1252,		// 21 - Indonesian
	1251,		// 22 - Ukranian
	1251,		// 23 - Byelorussian
	1250,		// 24 -	Slovenian
	1257,		// 25 - Estonia
	1257,		// 26 - Latvian
	1257,		// 27 - Lithuanian
	   0,		// 28 -	Tajik - Tajikistan (undefined)
	1256,		// 29 - Farsi
	1258,		// 2a -	Vietnanese
	CP_ARMENIAN,// 2b -	Armenian (Unicode only)
	1254,		// 2c -	Azeri (Latin, can be Cyrillic...)
	1252,		// 2d - Basque
	   0,		// 2e - Sorbian
	1251,		// 2f - FYRO Macedonian
	1252,		// 30 - Sutu
	1252,		// 31 - Tsonga
	1252,		// 32 - Tswana
	1252,		// 33 - Venda
	1252,		// 34 - Xhosa
	1252,		// 35 - Zulu
	1252,		// 36 - Africaans
	CP_GEORGIAN,// 37 - Georgian (Unicode only)
	1252,		// 38 - Faerose
	CP_DEVANAGARI,// 39 - Hindi (Indic)
	1252,		// 3a - Maltese
	1252,		// 3b - Sami
	1252,		// 3c - Gaelic
	1255,		// 3d - Yiddish
	1252,		// 3e - Malaysian
	1251,		// 3f - Kazakh
	1252,		// 40 -	Kirghiz
	1252,		// 41 - Swahili
	1252,		// 42 - Turkmen
	1254,		// 43 - Uzbek (Latin, can be Cyrillic...)
	1251		// 44 - Tatar
				// 45 - Bengali (Indic)
				// 46 - Punjabi(Gurmukhi) (Indic)
				// 47 - Gujarati (Indic)
				// 48 - Oriya (Indic)
				// 49 - Tamil (Indic)
				// 4a - Telugu (Indic)
				// 4b - Kannada (Indic)
				// 4c - Malayalam (Indic)
				// 4d - Assamese (Indic)
				// 4e - Marathi (Indic)
				// 4f - Sanskrit (Indic)
				// 50*  Mongolian - Mongolia
				// 51*  Tibetan - Tibet
				// 52*  Welsh - Wales
				// 53*  Khmer - Cambodia
				// 54*  Lao - Lao
				// 55*  Burmese - Mayanmar
				// 56*  Gallego - Portugal
				// 57 - Konkani (Indic)
				// 58*  Manipuri (Indic)
				// 59*  Sindhi (Indic)
				// 5a
				// 5b
				// 5c
				// 5d
				// 5e
				// 5f
				// 60*  Kashmiri
				// 61*  Nepali - Nepal
				// 62*  Frisian - Netherlands
				// 63*  Pashto - Afghanistan
};

#define nCodePageTable	ARRAY_SIZE(CodePageTable)
#define lidAzeriCyrillic 0x82C
#define lidSerbianCyrillic 0xC1A
#define lidUzbekCyrillic 0x843

// Our interface pointer
CW32System *W32;

CW32System::CW32System( )
{
	if(GetVersion(&_dwPlatformId, &_dwMajorVersion, &_dwMinorVersion))
	{
		_fHaveAIMM = FALSE;
		_fHaveIMMEShare = FALSE;
		_fHaveIMMProcs = FALSE;
		_pIMEShare = NULL;
		_icr3DDarkShadow = COLOR_WINDOWFRAME;
		if(_dwMajorVersion >= VERS4)
			_icr3DDarkShadow = COLOR_3DDKSHADOW;
	}

	_syslcid = GetSystemDefaultLCID();
	_ACP = ::GetACP();

    // BUG FIX #6089
    // we need this for backward compatibility of mouse wheel
    _MSMouseRoller = RegisterWindowMessageA(MSH_MOUSEWHEEL);

	// Register private messages for MSIME98	
	_MSIMEMouseMsg = RegisterWindowMessageA("MSIMEMouseOperation");
	_MSIMEDocFeedMsg = RegisterWindowMessageA("MSIMEDocumentFeed");	
	_MSIMEQueryPositionMsg = RegisterWindowMessageA("MSIMEQueryPosition");	
	_MSIMEServiceMsg = RegisterWindowMessageA("MSIMEService");

	// get MSIME Reconvert private messages unless we are running in NT5
	if (_dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ||
		(_dwPlatformId == VER_PLATFORM_WIN32_NT && _dwMajorVersion <= 4))
	{
		_MSIMEReconvertMsg = RegisterWindowMessageA("MSIMEReconvert");
		_MSIMEReconvertRequestMsg = RegisterWindowMessageA("MSIMEReconvertRequest");

	}
	else
	{
		_MSIMEReconvertMsg = 0;			// private message for reconversion
		_MSIMEReconvertRequestMsg = 0;	// private message for reconversion request
	}
}

CW32System::~CW32System()
{
	FreeIME();	
	FreeOle();
	if (_hdcScreen)
		DeleteDC(_hdcScreen);
}

///////////////////////////////  Memory  and CRT utility functions  /////////////////////////////////
extern "C" {

#ifdef NOCRTOBJS

// Havinf these functions defined here helps eliminate the dependency on the CRT
// Some function definitions copied from CRT sources.
// Typically, it is better to get the objs for these objects from the CRT
// without dragging in the whole thing.

/***
*int memcmp(buf1, buf2, count) - compare memory for lexical order
*
*Purpose:
*       Compares count bytes of memory starting at buf1 and buf2
*       and find if equal or which one is first in lexical order.
*
*Entry:
*       void *buf1, *buf2 - pointers to memory sections to compare
*       size_t count - length of sections to compare
*
*Exit:
*       returns < 0 if buf1 < buf2
*       returns  0  if buf1 == buf2
*       returns > 0 if buf1 > buf2
*
*Exceptions:
*
*******************************************************************************/

int __cdecl memcmp (
        const void * buf1,
        const void * buf2,
        size_t count
        )
{
        if (!count)
                return(0);

        while ( --count && *(char *)buf1 == *(char *)buf2 ) {
                buf1 = (char *)buf1 + 1;
                buf2 = (char *)buf2 + 1;
        }

        return( *((unsigned char *)buf1) - *((unsigned char *)buf2) );
}

/***
*char *memset(dst, val, count) - sets "count" bytes at "dst" to "val"
*
*Purpose:
*       Sets the first "count" bytes of the memory starting
*       at "dst" to the character value "val".
*
*Entry:
*       void *dst - pointer to memory to fill with val
*       int val   - value to put in dst bytes
*       size_t count - number of bytes of dst to fill
*
*Exit:
*       returns dst, with filled bytes
*
*Exceptions:
*
*******************************************************************************/

void * __cdecl memset (
        void *dst,
        int val,
        size_t count
        )
{
        void *start = dst;

        while (count--) {
                *(char *)dst = (char)val;
                dst = (char *)dst + 1;
        }

        return(start);
}

/***
*memcpy - Copy source buffer to destination buffer
*
*Purpose:
*       memcpy() copies a source memory buffer to a destination memory buffer.
*       This routine does NOT recognize overlapping buffers, and thus can lead
*       to propogation.
*
*       For cases where propogation must be avoided, memmove() must be used.
*
*Entry:
*       void *dst = pointer to destination buffer
*       const void *src = pointer to source buffer
*       size_t count = number of bytes to copy
*
*Exit:
*       Returns a pointer to the destination buffer
*
*Exceptions:
*******************************************************************************/

void * __cdecl memcpy (
        void * dst,
        const void * src,
        size_t count
        )
{
        void * ret = dst;

        /*
         * copy from lower addresses to higher addresses
         */
        while (count--) {
                *(char *)dst = *(char *)src;
                dst = (char *)dst + 1;
                src = (char *)src + 1;
        }

        return(ret);
}

void * __cdecl memmove(void *dst, const void *src, size_t count)
{
	void * ret = dst;

	if (dst <= src || (char *)dst >= ((char *)src + count)) {
		/*
         * Non-Overlapping Buffers
         * copy from lower addresses to higher addresses
         */
         while (count--) {
			*(char *)dst = *(char *)src;
            dst = (char *)dst + 1;
            src = (char *)src + 1;
         }
	}
    else
	{
		/*
         * Overlapping Buffers
         * copy from higher addresses to lower addresses
         */
        dst = (char *)dst + count - 1;
        src = (char *)src + count - 1;

        while (count--) {
			*(char *)dst = *(char *)src;
            dst = (char *)dst - 1;
            src = (char *)src - 1;
        }
	}

	return(ret);
}

/***
*strlen - return the length of a null-terminated string
*
*Purpose:
*       Finds the length in bytes of the given string, not including
*       the final null character.
*
*Entry:
*       const char * str - string whose length is to be computed
*
*Exit:
*       length of the string "str", exclusive of the final null byte
*
*Exceptions:
*
*******************************************************************************/

size_t __cdecl strlen (
        const char * str
        )
{
        const char *eos = str;

        while( *eos++ ) ;

        return( (int)(eos - str - 1) );
}

#endif

#ifdef DEBUG

// These functions are only used for RTF logging

/***
*strcmp - compare two strings, returning less than, equal to, or greater than
*
*Purpose:
*       STRCMP compares two strings and returns an integer
*       to indicate whether the first is less than the second, the two are
*       equal, or whether the first is greater than the second.
*
*       Comparison is done byte by byte on an UNSIGNED basis, which is to
*       say that Null (0) is less than any other character (1-255).
*
*Entry:
*       const char * src - string for left-hand side of comparison
*       const char * dst - string for right-hand side of comparison
*
*Exit:
*       returns -1 if src <  dst
*       returns  0 if src == dst
*       returns +1 if src >  dst
*
*Exceptions:
*
*******************************************************************************/

int __cdecl strcmp (
        const char * src,
        const char * dst
        )
{
        int ret = 0 ;

        while( ! (ret = *(unsigned char *)src - *(unsigned char *)dst) && *dst)
                ++src, ++dst;

        if ( ret < 0 )
                ret = -1 ;
        else if ( ret > 0 )
                ret = 1 ;

        return( ret );
}

/***
*char *strcat(dst, src) - concatenate (append) one string to another
*
*Purpose:
*       Concatenates src onto the end of dest.  Assumes enough
*       space in dest.
*
*Entry:
*       char *dst - string to which "src" is to be appended
*       const char *src - string to be appended to the end of "dst"
*
*Exit:
*       The address of "dst"
*
*Exceptions:
*
*******************************************************************************/

char * __cdecl strcat (
        char * dst,
        const char * src
        )
{
        char * cp = dst;

        while( *cp )
                cp++;                   /* find end of dst */

        while( *cp++ = *src++ ) ;       /* Copy src to end of dst */

        return( dst );                  /* return dst */

}

#endif

// This function in the runtime traps virtial base calls
int __cdecl _purecall()
{
	MessageBox(NULL,TEXT("Fatal Error : Vrtual base call in RichEdit"),NULL, MB_OK);
	PostQuitMessage (0);
	return 0;
}

// To avoid brionging in floating point lib
extern int _fltused = 1;

} // end of extern "C" block

size_t CW32System::wcslen(const wchar_t *wcs)
{
        const wchar_t *eos = wcs;

        while( *eos++ ) ;

        return( (size_t)(eos - wcs - 1) );
}

wchar_t * CW32System::wcscpy(wchar_t * dst, const wchar_t * src)
{
        wchar_t * cp = dst;

        while( *cp++ = *src++ )
                ;               /* Copy src over dst */

        return( dst );
}

int CW32System::wcscmp(const wchar_t * src, const wchar_t * dst)
{
	int ret = 0;

	while( ! (ret = (int)(*src - *dst)) && *dst)
		++src, ++dst;

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}

int CW32System::wcsicmp(const wchar_t * src, const wchar_t * dst)
{
	int ret = 0;
	wchar_t s,d;
	
	do
	{
		s = ((*src <= L'Z') && (*dst >= L'A'))
			? *src - L'A' + L'a'
			: *src;
		d = ((*dst <= L'Z') && (*dst >= L'A'))
			? *dst - L'A' + L'a'
			: *dst;
		src++;
		dst++;
	} while (!(ret = (int)(s - d)) && d);

	if ( ret < 0 )
		ret = -1 ;
	else if ( ret > 0 )
		ret = 1 ;

	return( ret );
}

wchar_t * CW32System::wcsncpy (wchar_t * dest, const wchar_t * source, size_t count)
{
	wchar_t *start = dest;
	
	while (count && (*dest++ = *source++))	  /* copy string */
		count--;
	
	if (count)								/* pad out with zeroes */
		while (--count)
			*dest++ = L'\0';
		
	return(start);
}

int CW32System::wcsnicmp (const wchar_t * first, const wchar_t * last, size_t count)
{
	wchar_t f,l;
	int result = 0;
	
	if ( count ) {
		do {
			f = ((*first <= L'Z') && (*first >= L'A'))
				? *first - L'A' + L'a'
				: *first;
			l = ((*last <= L'Z') && (*last >= L'A'))
				? *last - L'A' + L'a'
				: *last;
			first++;
			last++;
		} while ( (--count) && f && (f == l) );
		result = (int)(f - l);
	}
	return result;
}

unsigned long CW32System::strtoul(const char *nptr)
{
	const char *p;
	char c;
	unsigned long number;
	unsigned digval;
	unsigned long maxval;
	
	p = nptr;                       /* p is our scanning pointer */
	number = 0;                     /* start with zero */
	
	c = *p++;                       /* read char */
	while ( c == ' ' || c == '\t' )
		c = *p++;               /* skip whitespace */
	
	if (c == '-') {
		return 0;
	}
		
	/* if our number exceeds this, we will overflow on multiply */
	maxval = ULONG_MAX / 10;
	
	for (;;) {      /* exit in middle of loop */
		/* convert c to value */
		digval = (unsigned char) c;
		if ( digval >= '0' && digval <= '9' )
			digval = c - '0';
		else
			return number;
		
		/* we now need to compute number = number * base + digval,
		but we need to know if overflow occured.  This requires
		a tricky pre-check. */
		
		if (number < maxval || (number == maxval &&
			(unsigned long)digval <= ULONG_MAX % 10)) {
			/* we won't overflow, go ahead and multiply */
			number = number * 10 + digval;
		}
		else
			return 0;
		
		c = *p++;               /* read next digit */
	}
}


// CW32System static members
BOOL	CW32System::_fLRMorRLM;
BOOL	CW32System::_fHaveIMMProcs;
BOOL	CW32System::_fHaveIMMEShare;
BOOL	CW32System::_fHaveAIMM;
UINT	CW32System::_fRegisteredXBox;
DWORD	CW32System::_dwPlatformId;
LCID	CW32System::_syslcid;
DWORD	CW32System::_dwMajorVersion;
DWORD	CW32System::_dwMinorVersion;
INT		CW32System::_icr3DDarkShadow;
UINT	CW32System::_MSIMEMouseMsg;	
UINT	CW32System::_MSIMEReconvertMsg;
UINT	CW32System::_MSIMEReconvertRequestMsg;	
UINT	CW32System::_MSIMEDocFeedMsg;
UINT	CW32System::_MSIMEQueryPositionMsg;
UINT	CW32System::_MSIMEServiceMsg;
UINT	CW32System::_MSMouseRoller;
HDC		CW32System::_hdcScreen;
CIMEShare* CW32System::_pIMEShare;

// CW32System static system parameter members
BOOL	CW32System::_fSysParamsOk;
BOOL 	CW32System::_fUsePalette;
INT 	CW32System::_xWidthSys;
INT 	CW32System::_yHeightSys;
INT		CW32System::_ySysFontLeading;
LONG 	CW32System::_xPerInchScreenDC;
LONG 	CW32System::_yPerInchScreenDC;
INT		CW32System::_cxBorder;
INT		CW32System::_cyBorder;
INT		CW32System::_cxVScroll;
INT		CW32System::_cyHScroll;
LONG 	CW32System::_dxSelBar;
INT		CW32System::_cxDoubleClk;
INT		CW32System::_cyDoubleClk;	
INT		CW32System::_DCT;
WORD	CW32System::_nScrollInset;
WORD	CW32System::_nScrollDelay;
WORD	CW32System::_nScrollInterval;
WORD	CW32System::_nScrollHAmount;
WORD	CW32System::_nScrollVAmount;
WORD	CW32System::_nDragDelay;
WORD	CW32System::_nDragMinDist;
WORD	CW32System::_wDeadKey;
WORD	CW32System::_wKeyboardFlags;
WORD	CW32System::_wNumKeyPad;
WORD	CW32System::_fFEFontInfo;
BYTE	CW32System::_bDigitSubstMode;
BYTE	CW32System::_bSysCharSet;
HCURSOR CW32System::_hcurSizeNS;
HCURSOR CW32System::_hcurSizeWE;
HCURSOR CW32System::_hcurSizeNWSE;
HCURSOR CW32System::_hcurSizeNESW;
LONG	CW32System::_cLineScroll;
HFONT	CW32System::_hSystemFont;
HKL		CW32System::_hklCurrent;
HKL		CW32System::_hkl[NCHARSETS];
INT		CW32System::_sysiniflags;
UINT	CW32System::_ACP;

DWORD	CW32System::_cRefs;


/*
 *  CW32System::MbcsFromUnicode(pstr, cch, pwstr, cwch, codepage, flags)
 *
 *  @mfunc
 *		Converts a string to MBCS from Unicode. If cwch equals -1, the string
 *		is assumed to be NULL terminated.  -1 is supplied as a default argument.
 *
 *	@rdesc
 *		If [pstr] is NULL or [cch] is 0, 0 is returned.  Otherwise, the number
 *		of characters converted, including the terminating NULL, is returned
 *		(note that converting the empty string will return 1).  If the
 *		conversion fails, 0 is returned.
 *
 *	@devnote
 *		Modifies pstr
 */
int CW32System::MbcsFromUnicode(
	LPSTR	pstr,		//@parm Buffer for MBCS string
	int		cch,		//@parm Size of MBCS buffer, incl space for NULL terminator
	LPCWSTR pwstr,		//@parm Unicode string to convert
	int		cwch,		//@parm # chars in Unicode string, incl NULL terminator
	UINT	codepage,	//@parm Code page to use (CP_ACP is default)
	UN_FLAGS flags)		//@parm Indicates if WCH_EMBEDDING should be handled specially
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CW32System::MbcsFromUnicode");

	LONG			i;
	LPWSTR			pwstrtemp;
	CTempWcharBuf	twcb;

    Assert(cch >= 0 && pwstr && (cwch == -1 || cwch > 0));

    if(!pstr || !cch)
        return 0;

	// If we have to convert WCH_EMBEDDINGs, scan through and turn
	// them into spaces.  This is necessary for richedit1.0 compatibity,
	// as WideCharToMultiByte will turn WCH_EMBEDDING into a '?'
	if(flags == UN_CONVERT_WCH_EMBEDDING)
	{
		if(cwch == -1)
			cwch = wcslen(pwstr) + 1;

		pwstrtemp = twcb.GetBuf(cwch);
		if(pwstrtemp)
		{
			for(i = 0; i < cwch; i++)
			{
				pwstrtemp[i] = pwstr[i];

				if(pwstr[i] == WCH_EMBEDDING)
					pwstrtemp[i] = L' ';
			}
			pwstr = pwstrtemp;
		}
	}
    return WCTMB(codepage, 0, pwstr, cwch, pstr, cch, NULL, NULL, NULL);
}

/*
 *  CW32System::UnicodeFromMbcs(pwstr, cwch, pstr, cch,	uiCodePage)
 *
 *	@mfunc
 *		Converts a string to Unicode from MBCS.  If cch equals -1, the string
 *		is assumed to be NULL terminated.  -1 is supplied as a default
 *		argument.
 *
 *	@rdesc
 *		If [pwstr] is NULL or [cwch] is 0, 0 is returned.  Otherwise,
 *		the number of characters converted, including the terminating
 *		NULL, is returned (note that converting the empty string will
 *		return 1).  If the conversion fails, 0 is returned.
 *
 *	@devnote
 *		Modifies:   [pwstr]
 */
int CW32System::UnicodeFromMbcs(
	LPWSTR	pwstr,		//@parm Buffer for Unicode string
	int		cwch,		//@parm Size of Unicode buffer, incl space for NULL terminator
	LPCSTR	pstr,		//@parm MBCS string to convert
	int		cch,		//@parm # chars in MBCS string, incl NULL terminator
	UINT	uiCodePage)	//@parm Code page to use (CP_ACP is default)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CW32System::UnicodeFromMbcs");

    Assert(pstr && cwch >= 0 && (cch == -1 || cch >= 0));

    if(!pwstr || !cwch)
        return 0;

	if(cch >= 3 && IsUTF8BOM((BYTE *)pstr))
	{
		uiCodePage = CP_UTF8;				// UTF-8 BOM file
		cch -= 3;							// Eat the BOM
		pstr += 3;
	}
    return MBTWC(uiCodePage, 0, pstr, cch, pwstr, cwch, NULL);
}

/*
 *	CW32System::TextHGlobalAtoW (hglobalA)
 *
 *	@func
 *		translates a unicode string contained in an hglobal and
 *		wraps the ansi version in another hglobal
 *
 *	@devnote
 *		does *not* free the incoming hglobal
 */
HGLOBAL	CW32System::TextHGlobalAtoW(HGLOBAL hglobalA)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CW32System::TextHGlobalAtoW");

	if(!hglobalA)
		return NULL;

	HGLOBAL hnew;
	LPSTR	pstr = (LPSTR)GlobalLock(hglobalA);
	DWORD	dwSize = GlobalSize(hglobalA);
	LONG	cbSize = (dwSize + 1) * sizeof(WCHAR);
	
    hnew = GlobalAlloc(GMEM_FIXED, cbSize);
	if(hnew)
	{
		LPWSTR pwstr = (LPWSTR)GlobalLock(hnew);
		UnicodeFromMbcs(pwstr, dwSize + 1, pstr);
		GlobalUnlock(hnew);		
	}
	GlobalUnlock(hglobalA);
	return hnew;
}

/*
 *	CW32System::TextHGlobalWtoA(hglobalW)
 *
 *	@func
 *		converts a unicode text hglobal into a newly allocated
 *		allocated hglobal with ANSI data
 *
 *	@devnote
 *		does *NOT* free the incoming hglobal
 */
HGLOBAL CW32System::TextHGlobalWtoA(
	HGLOBAL hglobalW )
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CW32System::TextHGlobalWtoA");

	if(!hglobalW)
		return NULL;

	HGLOBAL hnew = NULL;
	LPWSTR 	pwstr = (LPWSTR)GlobalLock(hglobalW);
	DWORD	dwSize = GlobalSize(hglobalW);
	LONG	cbSize = (dwSize * 2) * sizeof(CHAR);
	hnew = GlobalAlloc(GMEM_FIXED, cbSize);

	if( hnew )
	{
		LPSTR pstr = (LPSTR)GlobalLock(hnew);
		MbcsFromUnicode(pstr, cbSize, pwstr );
		GlobalUnlock(hnew);
	}
	GlobalUnlock(hglobalW);
	return hnew;
}	

/*
 *	CW32System::ConvertLanguageIDtoCodePage (lid)
 *
 *	@mfunc		Maps a language ID to a Code Page
 *
 *	@rdesc		returns Code Page
 *
 *	@devnote:
 *		This routine takes advantage of the fact that except for Chinese,
 *		the code page is determined uniquely by the primary language ID,
 *		which is given by the low-order 10 bits of the lcid.
 *
 *		The WORD CodePageTable could be replaced by a BYTE with the addition
 *		of a couple of if's and the BYTE table replaced by a nibble table
 *		with the addition of a shift and a mask.  Since the table is only
 *		96 bytes long, it seems that the simplicity of using actual code page
 *		values is worth the extra bytes.
 */
UINT CW32System::ConvertLanguageIDtoCodePage(
	WORD lid)				//@parm Language ID to map to code page
{
	UINT j = PRIMARYLANGID(lid);			// j = primary language (PLID)

	if(j >= LANG_CROATIAN)					// PLID = 0x1a
	{
		if (lid == lidSerbianCyrillic ||	// Special case for LID = 0xc1a
			lid == lidAzeriCyrillic	  ||
			lid == lidUzbekCyrillic)
		{
			return 1251;					// Use Cyrillic code page
		}

		if(j >= nCodePageTable)				// Most languages above table
		{									//  take 1252
			if (j == 0x57 || j == 0x61 || IN_RANGE(0x4e, j, 0x4f))
				return CP_DEVANAGARI;	

			if (j == 0x49)
				return CP_TAMIL;

			return 1252;
		}
	}

	j = CodePageTable[j];					// Translate PLID to code page

	if(j != 950 || lid == LANG_TAIWAN)		// All but China (except for Taiwan)
		return j;

	return 936;								// Hong Kong SAR, Singapore, and PRC
}

/*
 *	CW32System::GetLocaleLCID ()
 *
 *	@mfunc		Maps an LCID for thread to a Code Page
 *
 *	@rdesc		returns Code Page
 */
LCID CW32System::GetLocaleLCID()
{
	return GetThreadLocale();
}

/*
 *	CW32System::GetLocaleCodePage ()
 *
 *	@mfunc		Maps an LCID for thread to a Code Page
 *
 *	@rdesc		returns Code Page
 */
UINT CW32System::GetLocaleCodePage()
{
#ifdef DEBUG
	UINT cpg = W32->DebugDefaultCpg();
	if (cpg)
		return cpg;
#endif
	return W32->ConvertLanguageIDtoCodePage(GetThreadLocale());
}

/*
 *	CW32System::GetKeyboardLCID ()
 *
 *	@mfunc		Gets LCID for keyboard active on current thread
 *
 *	@rdesc		returns Code Page
 */
LCID CW32System::GetKeyboardLCID(DWORD dwMakeAPICall)
{
	return (WORD)GetKeyboardLayout(dwMakeAPICall);
}

/*
 *	CW32System::GetKeyboardCodePage ()
 *
 *	@mfunc		Gets Code Page for keyboard active on current thread
 *
 *	@rdesc		returns Code Page
 */
UINT CW32System::GetKeyboardCodePage(DWORD dwMakeAPICall)
{
	return W32->ConvertLanguageIDtoCodePage((WORD)GetKeyboardLayout(dwMakeAPICall));
}

/*
 *	CW32System::InitKeyboardFlags ()
 *
 *	@mfunc
 *		Initializes keyboard flags. Used when control gains focus. Note that
 *		Win95 doesn't support VK_RSHIFT, so if either shift key is pressed
 *		when focus is regained, it'll be assumed to be the left shift.
 */
void CW32System::InitKeyboardFlags()
{
	_wKeyboardFlags = 0;
	if(GetKeyState(VK_SHIFT) < 0)
		SetKeyboardFlag(GetKeyState(VK_RSHIFT) < 0 ? RSHIFT : LSHIFT);
}

/*
 *	CW32System::GetKeyboardFlag (dwKeyMask, wKey)
 *
 *	@mfunc
 *		Return whether wKey is depressed. Check with OS for agreement.
 *		If OS says it isn't depressed, reset our internal flags. In
 *		any event, return TRUE/FALSE in agreement with the system (bad
 *		client may have eaten keystrokes, thereby destabilizing our
 *		internal keyboard state.
 *
 *	@rdesc
 *		TRUE iff wKey is depressed
 */
BOOL CW32System::GetKeyboardFlag (
	WORD dwKeyMask,	//@parm _wKeyboardFlags mask like ALT, CTRL, or SHIFT
	WORD wKey)		//@parm VK_xxx like VK_MENU, VK_CONTROL, or VK_SHIFT
{
	BOOL fFlag = (GetKeyboardFlags() & dwKeyMask) != 0;

	if(fFlag ^ ((GetKeyState(wKey) & 0x8000) != 0))
	{	
		// System doesn't agree with our internal state
		// (bad client ate a WM_KEYDOWN)
		if(fFlag)
		{
			ResetKeyboardFlag(dwKeyMask);
			return FALSE;					
		}
		// Don't set an internal _wKeyboardFlag since we check for it
		// anyhow and client might not send WM_KEYUP either
		return TRUE;
	}							
	return fFlag;
}

/*
 *	CW32System::IsAlef(ch)
 *
 *	@func
 *		Used to determine if base character is a Arabic-type Alef.
 *
 *	@rdesc
 *		TRUE iff the base character is an Arabic-type Alef.
 *
 *	@comm
 *		AlefWithMaddaAbove, AlefWithHamzaAbove, AlefWithHamzaBelow,
 *		and Alef are valid matches.
 */
BOOL CW32System::IsAlef(
	TCHAR ch)
{
	return IN_RANGE(0x622, ch, 0x627) && ch != 0x624 && ch != 0x626;
}

/*
 *	CW32System::IsBiDiLcid(lcid)
 *
 *	@func
 *		Return TRUE if lcid corresponds to an RTL language
 *
 *	@rdesc
 *		TRUE if lcid corresponds to an RTL language
 */
BOOL CW32System::IsBiDiLcid(
	LCID lcid)
{
	return
		PRIMARYLANGID(lcid) == LANG_ARABIC ||
		PRIMARYLANGID(lcid) == LANG_HEBREW ||
		PRIMARYLANGID(lcid) == LANG_URDU ||
		PRIMARYLANGID(lcid) == LANG_FARSI;
}

/*
 *	CW32System::IsIndicLcid(lcid)
 *
 *	@func
 *		Return TRUE if lcid corresponds to an Indic language
 *
 *	@rdesc
 *		TRUE if lcid corresponds to an Indic language
 */
BOOL CW32System::IsIndicLcid(
	LCID lcid)
{
	WORD	wLangId = PRIMARYLANGID(lcid);
	
	return
		wLangId == LANG_HINDI 	||
		wLangId == LANG_KONKANI ||
		wLangId == LANG_NEPALI 	||
		IN_RANGE(LANG_BENGALI, wLangId, LANG_SANSKRIT);
}

/*
 *	CW32System::IsIndicKbdInstalled()
 *
 *	@func
 *		Return TRUE if any Indic kbd installed
 */
bool CW32System::IsIndicKbdInstalled()
{
	for (int i = INDIC_FIRSTINDEX; i <= INDIC_LASTINDEX; i++)
		if (_hkl[i] != 0)
			return true;
	return false;
}

/*
 *	CW32System::IsComplexScriptLcid(lcid)
 *
 *	@func
 *		Return TRUE if lcid corresponds to any complex script locales
 *
 */
BOOL CW32System::IsComplexScriptLcid(
	LCID lcid)
{
	return	IsBiDiLcid(lcid) ||
			PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_THAI ||
			PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_VIETNAMESE ||
			IsIndicLcid(lcid);
}

/*
 *	CW32System::IsBiDiDiacritic(ch)
 *
 *	@func	Used to determine if character is a Arabic or Hebrew diacritic.
 *
 *  @rdesc  TRUE iff character is a diacritic
 */
BOOL CW32System::IsBiDiDiacritic(
	TCHAR ch)
{
	return IN_RANGE(0x64B, ch, 0x670) && (ch <= 0x652 || ch == 0x670) ||	// Arabic
		   IN_RANGE(0x591, ch, 0x5C4) && (ch != 0x5A2 && ch != 0x5BA &&		// Hebrew
				ch != 0x5BE && ch != 0x5C0 && ch != 0x5C3);					
}


/*
 *	CW32System::IsVietCdmSequenceValid(ch1, ch2)
 *
 *	@mfunc
 *		Check if ch2 can follow ch1 in case ch2 is a combining diacritic mark (CDM).
 *		Main use is for Vietnamese users (Chau Vu provides the logic below).
 *
 *	@rdesc
 *		TRUE if ch2 can follow ch1
 */
BOOL CW32System::IsVietCdmSequenceValid(
	WCHAR ch1,
	WCHAR ch2)
{
	if (!IN_RANGE(0x300, ch2, 0x323) ||		// Fast out
		!IN_RANGE(0x300, ch2, 0x301) && ch2 != 0x303 && ch2 != 0x309 && ch2 != 0x323)
	{
		return TRUE;						// Not Vietnamese tone mark
	}
	//									  		
	static const BYTE vowels[] = {0xF4, 0xEA, 0xE2, 'y', 'u', 'o', 'i', 'e', 'a'};

	for(int i = ARRAY_SIZE(vowels); i--; )
		if((ch1 | 0x20) == vowels[i])		// Vietnamese tone mark follows
			return TRUE;					//  vowel

	return IN_RANGE(0x102, ch1, 0x103) ||	// A-breve, a-breve
		   IN_RANGE(0x1A0, ch1, 0x1A1) ||	// O-horn,  o-horn
		   IN_RANGE(0x1AF, ch1, 0x1B0);		// U-horn,  u-horn
}

/*
 *  CW32System::IsFELCID(lcid)
 *
 *	@mfunc
 *		Returns TRUE iff lcid is for a East Asian country/region.
 *
 *	@rdesc
 *		TRUE iff lcid is for a East Asian country/region.
 */
bool CW32System::IsFELCID(
	LCID lcid)
{
	switch(PRIMARYLANGID(LANGIDFROMLCID(lcid)))
	{
		case LANG_CHINESE:
		case LANG_JAPANESE:
		case LANG_KOREAN:
			return true;
	}
	return false;
}

/*
 *  CW32System::IsFECharSet(bCharSet)
 *
 *	@mfunc
 *		Returns TRUE iff charset may be for a East Asian country/region.
 *
 *	@rdesc
 *		TRUE iff charset may be for a East Asian country/region.
 *
 */
BOOL CW32System::IsFECharSet(
	BYTE bCharSet)
{
	switch(bCharSet)
	{
		case CHINESEBIG5_CHARSET:
		case SHIFTJIS_CHARSET:
		case HANGEUL_CHARSET:
		case JOHAB_CHARSET:
		case GB2312_CHARSET:
			return TRUE;
	}

	return FALSE;
}

/*
 *  CW32System::Is8BitCodePage(CodePage)
 *
 *	@mfunc
 *		Returns TRUE iff the codepage is 8-bit
 */
BOOL CW32System::Is8BitCodePage(
	unsigned CodePage)
{
	if(!CodePage)
		CodePage = GetACP();

	return IN_RANGE(1250, CodePage, 1258) || CodePage == 874;
}

/*
 *  CW32System::IsFECodePageFont(dwFontCodePageSig)
 *
 *	@mfunc
 *		Returns TRUE iff the font codepage signature reveals only East Asian support
 */
BOOL CW32System::IsFECodePageFont(
	DWORD dwFontCodePageSig)
{
	DWORD	dwFE 	= 0x001e0000;	// Shift-JIS + PRC + Hangeul + Taiwan
	DWORD	dwOthers = 0x000101fc;	// The rest of the world except for Latin-1 and Latin-2

	return (dwFontCodePageSig & dwFE) && !(dwFontCodePageSig & dwOthers);
}

/*
 *  CW32System::IsRTLChar(ch)
 *
 *	@mfunc
 *		Returns TRUE iff ch Arabic or Hebrew
 *
 *	@rdesc
 *		TRUE iff ch is Arabic or Hebrew
 */
BOOL IsRTLChar(
	TCHAR	ch)
{
	// Remark: what about Arabic Presentation Forms?
	//  (0xFB50 - 0xFDFF, 0xFE70 - 0xFEFF)

	return IN_RANGE(0x590, ch, 0x6FF) || ch == RTLMARK;
}

/*
 *  CW32System::IsRTLCharSet(bCharSet)
 *
 *	@mfunc
 *		Returns TRUE iff charset is Arabic or Hebrew
 *
 *	@rdesc
 *		TRUE iff charset may be for Arabic or Hebrew
 */
BOOL CW32System::IsRTLCharSet(
	BYTE bCharSet)
{
	return IN_RANGE(HEBREW_CHARSET, bCharSet, ARABIC_CHARSET);
}

/*
 *	CW32System::IsZWG(ch, bCharSet)
 *
 *	@mfunc
 *		Determines whether a single-byte character is a zero-width glyph
 *		or not. Requires a charset.
 *
 *	@rdesc
 *		TRUE if the character is a zero-width glyph, FALSE otherwise.
 */
BOOL CW32System::IsZWG(
	char ch,
	BYTE bCharSet)
{
	if(IN_RANGE(0x9D, ch, 0x9E))
		return bCharSet == ARABIC_CHARSET;

	if(IN_RANGE(0xFD, ch, 0xFE))
		return IN_RANGE(HEBREW_CHARSET, bCharSet, ARABIC_CHARSET);

	return FALSE;
}

typedef struct {
	WCHAR codepoint;
	WORD  CharFlags;
	BYTE  runlength;
} Data_125X;

/*
 *  CW32System::GetCharFlags125x(ch)
 *
 *	@mfunc
 *		Returns char flags for ch as defined in rgCpgCharSet for 125x
 *		codepages. Bit 0: 1252, bit 1: 1250, bit 2: 1251, else bit x:
 *		125x (for 1253 - 1258).
 *
 *	@rdesc
 *		125x char flags for ch
 */
DWORD CW32System::GetCharFlags125x(
	WCHAR	ch)			//@parm Char to examine
{
	static const WORD rgCpgMask[] = {
		0x1FF,		// 0xA0
		0x131,		// 0xA1
		0x1F1,		// 0xA2
		0x1F9,		// 0xA3
		0x1DF,		// 0xA4
		0x179,		// 0xA5
		0x1FF,		// 0xA6
		0x1FF,		// 0xA7
		0x1FB,		// 0xA8
		0x1FF,		// 0xA9
		0x111,		// 0xAA
		0x1FF,		// 0xAB
		0x1FF,		// 0xAC
		0x1FF,		// 0xAD
		0x1FF,		// 0xAE
		0x1F1,		// 0xAF
		0x1FF,		// 0xB0
		0x1FF,		// 0xB1
		0x1F9,		// 0xB2
		0x1F9,		// 0xB3
		0x1F3,		// 0xB4
		0x1FF,		// 0xB5
		0x1FF,		// 0xB6
		0x1FF,		// 0xB7
		0x1F3,		// 0xB8
		0x1F1,		// 0xB9
		0x111,		// 0xBA
		0x1FF,		// 0xBB
		0x1F1,		// 0xBC
		0x1F9,		// 0xBD
		0x1F1,		// 0xBE
		0x131,		// 0xBF
		0x111,		// 0xC0
		0x113,		// 0xC1
		0x113,		// 0xC2
		0x011,		// 0xC3
		0x193,		// 0xC4
		0x191,		// 0xC5
		0x191,		// 0xC6
		0x113,		// 0xC7
		0x111,		// 0xC8
		0x193,		// 0xC9
		0x111,		// 0xCA
		0x113,		// 0xCB
		0x011,		// 0xCC
		0x113,		// 0xCD
		0x113,		// 0xCE
		0x111,		// 0xCF
		0x001,		// 0xD0
		0x111,		// 0xD1
		0x011,		// 0xD2
		0x193,		// 0xD3
		0x113,		// 0xD4
		0x091,		// 0xD5
		0x193,		// 0xD6
		0x1F3,		// 0xD7
		0x191,		// 0xD8
		0x111,		// 0xD9
		0x113,		// 0xDA
		0x111,		// 0xDB
		0x193,		// 0xDC
		0x003,		// 0xDD
		0x001,		// 0xDE
		0x193,		// 0xDF
		0x151,		// 0xE0
		0x113,		// 0xE1
		0x153,		// 0xE2
		0x011,		// 0xE3
		0x193,		// 0xE4
		0x191,		// 0xE5
		0x191,		// 0xE6
		0x153,		// 0xE7
		0x151,		// 0xE8
		0x1D3,		// 0xE9
		0x151,		// 0xEA
		0x153,		// 0xEB
		0x011,		// 0xEC
		0x113,		// 0xED
		0x153,		// 0xEE
		0x151,		// 0xEF
		0x001,		// 0xF0
		0x111,		// 0xF1
		0x011,		// 0xF2
		0x193,		// 0xF3
		0x153,		// 0xF4
		0x091,		// 0xF5
		0x193,		// 0xF6
		0x1F3,		// 0xF7
		0x191,		// 0xF8
		0x151,		// 0xF9
		0x113,		// 0xFA
		0x151,		// 0xFB
		0x1D3,		// 0xFC
		0x003,		// 0xFD
		0x001,		// 0xFE
		0x111		// 0xFF
	};
	static const Data_125X Table_125X[] = {
		{ 0x100, 0x080,  2},
		{ 0x102, 0x102,  2},
		{ 0x104, 0x082,  4},
		{ 0x10c, 0x082,  2},
		{ 0x10e, 0x002,  2},
		{ 0x110, 0x102,  2},
		{ 0x112, 0x080,  2},
		{ 0x116, 0x080,  2},
		{ 0x118, 0x082,  2},
		{ 0x11a, 0x002,  2},
		{ 0x11e, 0x010,  2},
		{ 0x122, 0x080,  2},
		{ 0x12a, 0x080,  2},
		{ 0x12e, 0x080,  2},
		{ 0x130, 0x010,  2},
		{ 0x136, 0x080,  2},
		{ 0x139, 0x002,  2},
		{ 0x13b, 0x080,  2},
		{ 0x13d, 0x002,  2},
		{ 0x141, 0x082,  4},
		{ 0x145, 0x080,  2},
		{ 0x147, 0x002,  2},
		{ 0x14c, 0x080,  2},
		{ 0x150, 0x002,  2},
		{ 0x152, 0x151,  2},
		{ 0x154, 0x002,  2},
		{ 0x156, 0x080,  2},
		{ 0x158, 0x002,  2},
		{ 0x15a, 0x082,  2},
		{ 0x15e, 0x012,  2},
		{ 0x160, 0x093,  2},
		{ 0x162, 0x002,  4},
		{ 0x16a, 0x080,  2},
		{ 0x16e, 0x002,  4},
		{ 0x172, 0x080,  2},
		{ 0x178, 0x111,  1},
		{ 0x179, 0x082,  4},
		{ 0x17d, 0x083,  2},
		{ 0x192, 0x179,  1},
		{ 0x1A0, 0x100,  2},
		{ 0x1AF, 0x100,  2},
		{ 0x2c6, 0x171,  1},
		{ 0x2c7, 0x082,  1},
		{ 0x2d8, 0x002,  1},
		{ 0x2d9, 0x082,  1},
		{ 0x2db, 0x082,  1},
		{ 0x2dc, 0x131,  1},
		{ 0x2dd, 0x002,  1},
		{ 0x300, 0x100,  2},
		{ 0x303, 0x100,  1},
		{ 0x309, 0x100,  1},
		{ 0x323, 0x100,  1},
		{ 0x384, 0x008,  3},
		{ 0x388, 0x008,  3},
		{ 0x38c, 0x008,  1},
		{ 0x38e, 0x008, 20},
		{ 0x3a3, 0x008, 44},
		{ 0x401, 0x004, 12},
		{ 0x40e, 0x004, 66},
		{ 0x451, 0x004, 12},
		{ 0x45e, 0x004,  2},
		{ 0x490, 0x004,  2},
		{ 0x5b0, 0x020, 20},
		{ 0x5d0, 0x020, 27},
		{ 0x5F0, 0x020,  5},
		{ 0x60c, 0x040,  1},
		{ 0x61b, 0x040,  1},
		{ 0x61f, 0x040,  1},
		{ 0x621, 0x040, 26},
		{ 0x640, 0x040, 19},
		{ 0x679, 0x040,  1},
		{ 0x67e, 0x040,  1},
		{ 0x686, 0x040,  1},
		{ 0x688, 0x040,  1},
		{ 0x691, 0x040,  1},
		{ 0x698, 0x040,  1},
		{ 0x6a9, 0x040,  1},
		{ 0x6af, 0x040,  1},
		{ 0x6ba, 0x040,  1},
		{ 0x6be, 0x040,  1},
		{ 0x6c1, 0x040,  1},
		{ 0x6d2, 0x040,  1},
		{0x200c, 0x040,  2},
		{0x200e, 0x060,  2},
		{0x2013, 0x1ff,  2},
		{0x2015, 0x008,  1},
		{0x2018, 0x1ff,  3},
		{0x201c, 0x1ff,  3},
		{0x2020, 0x1ff,  3},
		{0x2026, 0x1ff,  1},
		{0x2030, 0x1ff,  1},
		{0x2039, 0x1ff,  2},
		{0x20AA, 0x020,  1},
		{0x20AB, 0x100,  1},
		{0x20AC, 0x1ff,  1},
		{0x2116, 0x004,  1},
		{0x2122, 0x1ff,  1}
	};

	// Easy check for ASCII
	if(ch <= 0x7f)
		return 0x1ff00;

	// Easy check for missing codes
	if(ch > 0x2122)
		return 0;

	if(IN_RANGE(0xA0, ch, 0xFF))
		return rgCpgMask[ch - 0xA0] << 8;

	// Perform binary search to find entry in table
	int low = 0;
	int high = ARRAY_SIZE(Table_125X) - 1;
	int middle;
	int midval;
	int runlength;
	
	while(low <= high)
	{
		middle = (high + low) / 2;
		midval = Table_125X[middle].codepoint;
		if(midval > ch)
			high = middle - 1;
		else
			low = middle + 1;
	
		runlength = Table_125X[middle].runlength;
		if(ch >= midval && ch <= midval + runlength - 1)
			return Table_125X[middle].CharFlags << 8;
	}
	return 0;
}

/*
 *	CW32System::IsUTF8BOM(pstr)
 *
 *	@mfunc
 *		Return TRUE if pstr points at a UTF-8 BOM
 *
 *	@rdesc
 *		TRUE iff pstr points at a UTF-8 BOM
 */
BOOL CW32System::IsUTF8BOM(
	BYTE *pstr)
{
	BYTE *pstrUtf8BOM = szUTF8BOM;

	for(LONG i = 3; i--; )
		if(*pstr++ != *pstrUtf8BOM++)
			return FALSE;
	return TRUE;
}

/*
 *	CW32System::GetTrailBytesCount(ach, cpg)
 *
 *	@mfunc
 *		Returns number of trail bytes iff the byte ach is a lead byte for the code page cpg.
 *
 *	@rdesc
 *		count of trail bytes if ach is lead byte for cpg
 *
 *	@comm
 *		This is needed to support CP_UTF8 as well as DBC.
 *		This function potentially doesn't support as many code pages as the
 *		Win32 IsDBCSLeadByte() function (and it might not be as up-to-date).
 *		An AssertSz() is included to compare the results when the code page
 *		is supported by the system.
 *
 *		Reference: \\sparrow\sysnls\cptable\win95. See code-page txt files
 *		in subdirectories windows\txt and others\txt.
 */
int CW32System::GetTrailBytesCount(BYTE ach, UINT cpg)
{

	if(ach < 0x81)									// Smallest known lead
		return 0;									//  byte = 0x81:
													//  early out
	
	BOOL	bDBLeadByte = FALSE;					// Variable to check
													//  result with system
													//  ifdef DEBUG

	if (cpg == CP_UTF8)
	{
		int	cTrailBytes = 0;						// Number of trail bytes for CP_UTF8(0 - 3)
		
		if (ach >= 0x0F0)							// Handle 4-byte form for 16 UTF-16 planes
			cTrailBytes = 3;						// above the BMP) expect:
													// 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
		else if (ach >= 0x0E0)						// Need at least 3 bytes of form
			cTrailBytes = 2;						// 1110bbbb 10bbbbbb 10bbbbbb
		else if (ach >= 0x0C0)						// Need at least 2 bytes of form
			cTrailBytes = 1;						// 110bbbbb 10bbbbbb

		return cTrailBytes;
	}
	else if(cpg > 950)								
	{
		if(cpg < 1361)								// E.g., the 125x's are
			return 0;								//  SBCSs: early out

		else if(cpg == 1361)								// Korean Johab
			bDBLeadByte = IN_RANGE(0x84, ach, 0xd3) ||		// 0x84 <= ach <= 0xd3
				   IN_RANGE(0xd8, ach, 0xde) ||				// 0xd8 <= ach <= 0xde
				   IN_RANGE(0xe0, ach, 0xf9);				// 0xe0 <= ach <= 0xf9

		else if(cpg == 10001)						// Mac Japanese
			goto JIS;

		else if(cpg == 10002)						// Mac Trad Chinese (Big5)
			bDBLeadByte = ach <= 0xfe;

		else if(cpg == 10003)						// Mac Korean
			bDBLeadByte = IN_RANGE(0xa1, ach, 0xac) ||		// 0xa1 <= ach <= 0xac
				   IN_RANGE(0xb0, ach, 0xc8) ||		// 0xb0 <= ach <= 0xc8
				   IN_RANGE(0xca, ach, 0xfd);		// 0xca <= ach <= 0xfd

		else if(cpg == 10008)						// Mac Simplified Chinese
			bDBLeadByte = IN_RANGE(0xa1, ach, 0xa9) ||		// 0xa1 <= ach <= 0xa9
				   IN_RANGE(0xb0, ach, 0xf7);		// 0xb0 <= ach <= 0xf7
	}
	else if (cpg >= 932)							// cpg <= 950
	{
		if(cpg == 950 || cpg == 949 || cpg == 936)	// Chinese (Taiwan, HK),
			bDBLeadByte = ach <= 0xfe;						//  Korean Ext Wansung,
													//  PRC GBK: 0x81 - 0xfe
		else if(cpg == 932)							// Japanese
JIS:		bDBLeadByte = ach <= 0x9f || IN_RANGE(0xe0, ach, 0xfc);
	}

	#ifdef DEBUG
	TCHAR	ch;
	static	BYTE asz[2] = {0xe0, 0xe0};				// All code pages above

	// if cpg == 0, fRet will FALSE but IsDBCSLeadByteEx may succeed.
	if ( cpg && cpg != CP_SYMBOL && cpg != CP_UTF8)
	{
		// If system supports cpg, then fRet should agree with system result
		AssertSz(MultiByteToWideChar(cpg, 0, (char *)asz, 2, &ch, 1) <= 0 ||
			bDBLeadByte == IsDBCSLeadByteEx(cpg, ach),
			"bDBLeadByte differs from IsDBCSLeadByteEx()");
	}
	#endif

	return bDBLeadByte ? 1 : 0;
}

/*
 *	CW32System::GetGdiCharSet(bCharSet)
 *
 *	@func
 *		Map CHARFORMAT charset to GDI charset (charset used in CreateFont)
 */
BYTE CW32System::GetGdiCharSet(BYTE	bCharSet)
{
	return IsPrivateCharSet(bCharSet) ? DEFAULT_CHARSET : bCharSet;
}

/*
 *	CW32System::GetCharSet(nCP, pScriptIndex)
 *
 *	@func
 *		Get character set for code page <p nCP>. Also returns script index
 *		in *pScriptIndex
 *
 *	@rdesc
 *		CharSet for code page <p nCP>
 */
BYTE CW32System::GetCharSet(
	INT  nCP,				//@parm Code page or index
	int *pScriptIndex)		//@parm Out parm to receive index
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "GetCharSet");

	if(nCP < NCHARSETS)					// nCP is already an index
	{
		nCP = max(nCP, 0);
		if(pScriptIndex)
			*pScriptIndex = nCP;
		return rgCpgCharSet[nCP].bCharSet;
	}

	const CPGCHAR *	pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet; i++, ++pcpgchar)
	{
		if(pcpgchar->nCodePage == nCP)
			break;
	}
	if(i == cCpgCharSet)
		i = -1;

	if (pScriptIndex)
		*pScriptIndex = i;

	return i >= 0 ? pcpgchar->bCharSet : 0;
}

/*
 *	CW32System::MatchFECharSet(dwCharInfo, dwFontSig)
 *
 *	@func
 *		Get a FE character set for a FE char
 *
 *	@rdesc
 *		CharSet
 */
BYTE CW32System::MatchFECharSet(
	DWORD  dwCharInfo,		//@parm Char Info
	DWORD  dwFontSig)		//@parm Font Signature
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::MatchFECharSet");

	// Convert Font Signature to our internal char info
	dwFontSig = (dwFontSig << 8) & ~0x00ffff;

	// Get rid of lower word
	dwCharInfo &= ~0x00ffff;

	if (dwCharInfo & dwFontSig & (fKANA | fCHINESE | fHANGUL | fBIG5)) // Perfect match
		goto Exit;											

	if (!(dwFontSig & (fKANA | fCHINESE | fHANGUL | fBIG5)))	// Not a FE font
		goto Exit;

	if (dwCharInfo & (fCHINESE | fBIG5))
	{
		if (dwFontSig & fBIG5)
			return CHINESEBIG5_CHARSET;
		if (dwFontSig & fHANGUL)
			return HANGEUL_CHARSET;
		if (dwFontSig & fKANA)
			return SHIFTJIS_CHARSET;
	}

Exit:
	return GetCharSet(W32->ScriptIndexFromFontSig(dwCharInfo >> 8), NULL);
}

/*
 *	CW32System::GetCodePage(bCharSet)
 *
 *	@func
 *		Get code page for character set <p bCharSet>
 *
 *	@rdesc
 *		Code page for character set <p bCharSet>
 */
INT CW32System::GetCodePage(
	BYTE bCharSet)		//@parm CharSet
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "GetCodePage");

	const CPGCHAR *pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet ; i++, ++pcpgchar)
	{
		if (pcpgchar->bCharSet == bCharSet)
			return pcpgchar->nCodePage;
	}
	return 0;
}

/*
 *	CW32System::GetFontSig(wCharSet)
 *
 *	@func
 *		Get font signature bits for character set <p wCharSet>. If
 *		wCharSet > 256, treat as a codepage
 *
 *	@rdesc
 *		Font signature mask for character set (or codepage) <p bCharSet>
 */
DWORD CW32System::GetFontSig(
	WORD wCharSet)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::GetFontSig");

	const CPGCHAR *	pcpgchar = rgCpgCharSet;
	BOOL fCodePage = wCharSet > 255;

	for (int i = 0; i < cCpgCharSet; i++)
	{
		if(wCharSet == (WORD)(fCodePage ? pcpgchar->nCodePage : pcpgchar->bCharSet))
			return pcpgchar->dwFontSig;
		++pcpgchar;
	}
	return 0;
}

/*
 *	CW32System::GetFirstAvailCharSet(DWORD dwFontSig)
 *
 *	@func
 *		Get first available charset from font signature bits
 */
BYTE CW32System::GetFirstAvailCharSet(
	DWORD dwFontSig)
{
	const CPGCHAR *	pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet; i++)
	{
		if(pcpgchar->dwFontSig & dwFontSig)
			return pcpgchar->bCharSet;
		++pcpgchar;
	}
	return ANSI_CHARSET;
}

/*
 *	CW32System::GetFontSigFromScript(iScript)
 *
 *	@func
 *		Get font signature bits for script <p iScript>
 *
 *	@rdesc
 *		Font signature mask for script <p iScript>
 */
DWORD CW32System::GetFontSigFromScript(
	int iScript)
{
	return rgCpgCharSet[iScript].dwFontSig;
}

/*
 *	CW32System::ScriptIndexFromFontSig(dwFontSig)
 *
 *	@func
 *		Get script index from font signature
 *
 *	@rdesc
 *		Script index from font signature <p dwFontSig>
 *
 *	@devnote
 *		Linear search
 */
LONG CW32System::ScriptIndexFromFontSig(
	DWORD dwFontSig)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::ScriptIndexFromFontSig");

	const CPGCHAR *pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet; i++, ++pcpgchar)
	{
		if(pcpgchar->dwFontSig == dwFontSig)
			return i;
	}
	return -1;								// Not found
}

/*
 *	CW32System::ScriptIndexFromCharSet(bCharSet)
 *
 *	@func
 *		Get script index from bCharSet
 *
 *	@rdesc
 *		Script index character set <p bCharSet>
 *
 *	@devnote
 *		Linear search
 */
LONG CW32System::ScriptIndexFromCharSet(
	BYTE bCharSet)
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::ScriptIndexFromCharSet");

	const CPGCHAR *pcpgchar = rgCpgCharSet;

	for (int i = 0; i < cCpgCharSet; i++, ++pcpgchar)
	{
		if(pcpgchar->bCharSet == bCharSet)
			return i;
	}
	return -1;								// Not found
}

/*
 *	CW32System::IsCharSetValid(bCharSet)
 *
 *	@func
 *		Return TRUE iff <p bCharSet> is a valid character set index
 *
 *	@rdesc
 *		TRUE iff <p bCharSet> is a valid character set index
 */
BOOL CW32System::IsCharSetValid(
	BYTE bCharSet)		//@parm CharSet
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::IsCharSetValid");

	return ScriptIndexFromCharSet(bCharSet) >= 0;
}

/*
 *	CW32System::GetScreenDC(void)
 *
 *	@mfunc
 *	Returns you a default screen DC which richedit caches for its lifetime.
 *
 *	Note, you need to serialize access to DCs, so make sure its used in the
 *	renderer and measurer or otherwise protected by a CLock.
 *
 *	@rdesc
 *		Screen HDC if succeeded.
 */
HDC	CW32System::GetScreenDC()
{
	if (!_hdcScreen)
		_hdcScreen = CreateIC(L"DISPLAY", NULL, NULL, NULL);;

	//Verify DC validity
	Assert(GetDeviceCaps(_hdcScreen, LOGPIXELSX));

	return _hdcScreen;
}

/*
 *	CW32System::GetTextMetrics(hdc, &lf, &tm)
 *
 *	@mfunc
 *		CreateFontIndirect(lf), select into hdc, and get TEXTMETRICS
 *
 *	@rdesc
 *		TRUE if succeeded and selected facename is same as lf.lfFaceName
 */
BOOL CW32System::GetTextMetrics(
	HDC			hdc,
	LOGFONT &	lf,
	TEXTMETRIC &tm)
{
	HFONT hfont = CreateFontIndirect(&lf);
	if(!hfont)
		return FALSE;

	HFONT hfontOld = SelectFont(hdc, hfont);
	WCHAR szFaceName[LF_FACESIZE + 1];

	BOOL  fRet = GetTextFace(hdc, LF_FACESIZE, szFaceName) &&
				 !wcsicmp(lf.lfFaceName, szFaceName) &&
				  W32->GetTextMetrics(hdc, &tm);

	SelectFont(hdc, hfontOld);
	DeleteObject(hfont);
	return fRet;
}

/*
 *	CW32System::ValidateStreamWparam(wparam)
 *
 *	@mfunc
 *		Examine lparam to see if hiword is a valid codepage. If not set it
 *		to 0 and turn off SF_USECODEPAGE flag
 *
 *	@rdesc
 *		Validated lparam
 */
WPARAM CW32System::ValidateStreamWparam(
	WPARAM wparam)		//@parm EM_STREAMIN/OUT wparam
{
	TRACEBEGIN(TRCSUBSYSRTFR, TRCSCOPEINTERN, "CW32System::ValidateStreamWparam");

	if ((wparam & SF_USECODEPAGE) && !IsValidCodePage(HIWORD(wparam)) &&
		HIWORD(wparam) != CP_UTF8)
	{
		// Invalid codepage, so reset codepage parameters
		wparam &= 0xFFFF & ~SF_USECODEPAGE;
	}
	return wparam;
}

/*
 *	CW32System::MECharClass(ch)
 *
 *	@func
 *		return ME character type for purposes of CharSet stamping.  Values
 *		are:
 *
 *		0: Arabic (specific RTL)
 *		1: Hebrew (specific RTL)
 *		2: RTL (generic RTL, e.g., RTL mark)
 *		3: LTR
 *		4: EOP or start/end of text
 *		5: ASCII digit
 *		6: punctuation and neutrals
 *
 *	@rdesc
 *		ME character class
 */
CC CW32System::MECharClass(
	TCHAR	ch)
{
	AssertSz(CC_NEUTRAL > CC_ASCIIDIGIT && CC_ASCIIDIGIT > CC_EOP &&
			 CC_EOP > CC_LTR && CC_LTR > CC_RTL && CC_RTL > CC_ARABIC,
		"CW32System::MECharClass: invalid CC values");

	// Work down Unicode values from large to small. Use nested if
	// statements to reduce the number executed.

	// Remark: what about Arabic Presentation Forms?
	//  (0xFB50 - 0xFDFF, 0xFE70 - 0xFEFF)

	if(ch >= 0x700)
	{
		if(IN_RANGE(ENQUAD, ch, RTLMARK))
		{								// ENQUAD thru RTLMARK
			if(ch == RTLMARK)			// Maybe add more Unicode general
				return CC_RTL;			//  punctuation?

			if(IN_RANGE(ZWNJ, ch, ZWJ))	// ZWNJ & ZWJ are handled as Arabic,
				return CC_ARABIC;		//  even though they actually shouldn't
										//  affect layout.
			if(ch < ZWNJ)
				return CC_NEUTRAL;		// Various blanks are neutral
		}
		return CC_LTR;
	}

	if(ch >= 0x40)
	{
		if(ch >= 0x590)
			return (ch >= 0x600) ? CC_ARABIC : CC_HEBREW;

		if(IN_RANGE(0x7B, (ch | 0x20), 0x7F) || ch == 0x60 || ch == 0x40)
			return CC_NEUTRAL;			// [\]^_{|}~`@

		return CC_LTR;
	}

	if(ch >= 0x20)
	{
		if(IN_RANGE(0x30, ch, 0x39))
			return CC_ASCIIDIGIT;

		return CC_NEUTRAL;
	}

	Assert(ch < 0x20);
	if((1 << ch) & 0x00003201) /* IsASCIIEOP(ch) || ch == TAB || !ch */
		return CC_EOP;
		
	return CC_LTR;	
}

/*
 *	CW32System::ScriptIndexFromChar (ch)
 *
 *	@mfunc
 *		Returns index into CharSet/CodePage table rgCpgCharSet corresponding
 *		to the Unicode character ch provided such an assignment is
 *		reasonably unambiguous, that is, the currently assigned Unicode
 *		characters in various ranges have Windows code-page equivalents.
 *		Ambiguous or impossible assignments return UNKNOWN_INDEX, which
 *		means that the character can only be represented by Unicode in this
 *		simple model.  Note that the UNKNOWN_INDEX, HAN_INDEX, and FE_INDEX
 *		are negative values, i.e., they imply further processing to figure
 *		out what (if any) charset index to use.  Other indices may also
 *		require run processing, such as the blank in BiDi text.  We need
 *		to mark our right-to-left runs with an Arabic or Hebrew char set,
 *		while we mark left-to-right runs with a left-to-right char set.
 *
 *		If the index has the FE_FLAG bit set, then the character is some kind
 *		of FE "DBCS" character, like a Han, Kana, or Hangul character.
 *		FE_INDEX, HAN_INDEX, HANGUL_INDEX, and SHIFTJIS_INDEX all have this
 *		flag set.
 *
 *	@rdesc
 *		Script index in low word, and possible some extra flags, like
 *		FE_FLAG in high word
 */
LONG CW32System::ScriptIndexFromChar(
	TCHAR ch)		//@parm Unicode character to examine
{
	if(ch < 256)
		return ANSI_INDEX;

	if(ch < 0x700)
	{
		if(ch >= 0x600)
			return ARABIC_INDEX;

		if(ch > 0x590)
			return HEBREW_INDEX;

		if(ch < 0x500)
		{
			if(ch >= 0x400)
				return RUSSIAN_INDEX;

			if(ch >= 0x370)
				return GREEK_INDEX;
		}
	}
	else if(ch < 0x2500)
	{	
		if(IN_RANGE(0xE00, ch, 0xE7F))	// Thai
			return THAI_INDEX;
	}
	else if(ch < 0xAC00)
	{
		if(ch >= 0x3400)				// CJK Ideographs
			return HAN_INDEX;

		if(ch >= 0x3100)
			return FE_INDEX;

		if(ch > 0x3040)					// Katakana and Hiragana
			return SHIFTJIS_INDEX;

		if(ch >= 0x3000)
			return FE_INDEX;
	}
	else if(ch < 0xD800)
		return HANGUL_INDEX;

	else if(ch > 0xFF00)
	{
		if(ch < 0xFF65)					// Fullwidth ASCII and halfwidth
			return HAN_INDEX;			//  CJK punctuation

		if(ch < 0xFFA0)					// Halfwidth Katakana
			return SHIFTJIS_INDEX;

		if(ch < 0xFFE0)					// Halfwidth Jamo
			return HANGUL_INDEX;

		if(ch < 0xFFEF)					// Fullwidth punctuation and currency
			return HAN_INDEX;			//  signs; halfwidth forms, arrows
	}									//  and shapes
	return UNKNOWN_INDEX;
}

/*
 *	CW32System::MBTWC (CodePage, dwFlags, pstrMB, cchMB, pstrWC, cchWC, pfNoCodePage)
 *
 *	@mfunc
 *		Convert MultiByte (MB) string pstrMB of length cchMB to WideChar (WC)
 *		string pstrWC of length cchWC according to the flags dwFlags and code
 *		page CodePage.  If CodePage = SYMBOL_CODEPAGE
 *		(usually for SYMBOL_CHARSET strings),
 *		convert each byte in pstrMB to a wide char with a zero high byte
 *		and a low byte equal to the MultiByte string byte, i.e., no
 *		translation other than a zero extend into the high byte.  Else call
 *		the Win32 MultiByteToWideChar() function.
 *
 *	@rdesc
 *		Count of characters converted
 */
int CW32System::MBTWC(
	INT		CodePage,	//@parm Code page to use for conversion
	DWORD	dwFlags,	//@parm Flags to guide conversion
	LPCSTR	pstrMB,		//@parm MultiByte string to convert to WideChar
	int		cchMB,		//@parm Count of chars (bytes) in pstrMB or -1
	LPWSTR	pstrWC,		//@parm WideChar string to receive converted chars
	int		cchWC,		//@parm Max count for pstrWC or 0 to get cch needed
	LPBOOL 	pfNoCodePage) //@parm Out parm to receive whether code page is on system
{
	BOOL	fNoCodePage = FALSE;			// Default code page is on OS
	int		cch = -1;

	if(CodePage == CP_UTF8)
	{
		DWORD ch,ch1;

		for(cch = 0; cchMB--; )
		{
			ch = ch1 = *(BYTE *)pstrMB++;
			Assert(ch < 256);
			if(ch > 127 && cchMB && IN_RANGE(0x80, *(BYTE *)pstrMB, 0xBF))
			{
				// Need at least 2 bytes of form 110bbbbb 10bbbbbb
				ch1 = ((ch1 & 0x1F) << 6) + (*pstrMB++ & 0x3F);
				cchMB--;
				if(ch >= 0xE0 && cchMB && IN_RANGE(0x80, *(BYTE *)pstrMB, 0xBF))
				{
					// Need at least 3 bytes of form 1110bbbb 10bbbbbb 10bbbbbb
					ch1 = (ch1 << 6) + (*pstrMB++ & 0x3F);
					cchMB--;
					if (ch >= 0xF0 && cchMB && IN_RANGE(0x80, *(BYTE *)pstrMB, 0xBF))
					{
						// Handle 4-byte form for 16 UTF-16 planes above the
						// BMP) expect: 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb
						ch1 = ((ch1 & 0x7FFF) << 6) + (*(BYTE *)pstrMB++ & 0x3F)
							- 0x10000;			// Subtract offset for BMP
						if(ch1 <= 0xFFFFF)		// Fits in 20 bits
						{
							cch++;				// Two 16-bit surrogate codes
							if(cch < cchWC)
								*pstrWC++ = UTF16_LEAD + (ch1 >> 10);
							ch1 = (ch1 & 0x3FF) + UTF16_TRAIL;
							cchMB--;
						}
						else ch1 = '?';
					}
				}
			}
			cch++;
			if(cch < cchWC)
				*pstrWC++ = ch1;
			if(!ch)
				break;
		}
	}
	else if(CodePage != CP_SYMBOL)			// Not SYMBOL_CHARSET
	{
		fNoCodePage = TRUE;					// Default codepage isn't on OS
		if(CodePage >= 0)					// Might be..
		{
			cch = MultiByteToWideChar(
				CodePage, dwFlags, pstrMB, cchMB, pstrWC, cchWC);
			if(cch > 0)
				fNoCodePage = FALSE;		// Codepage is on OS
		}
	}
	if(pfNoCodePage)
		*pfNoCodePage = fNoCodePage;

	if(cch <= 0)
	{			
		// SYMBOL_CHARSET or conversion failed: bytes -> words with
		//  high bytes of 0.  Return count for full conversion

		if(cchWC <= 0)					
			return cchMB >= 0 ? cchMB : (strlen(pstrMB) + 1);

		int cchMBMax = cchMB;

		if(cchMB < 0)					// If negative, use NULL termination
			cchMBMax = tomForward;			//  of pstrMB

		cchMBMax = min(cchMBMax, cchWC);

		for(cch = 0; (cchMB < 0 ? *pstrMB : 1) && cch < cchMBMax; cch++)
		{
			*pstrWC++ = (unsigned char)*pstrMB++;
		}
		
		// NULL-terminate the WC string if the MB string was NULL-terminated,
		// and if there is room in the WC buffer.
		if(cchMB < 0 && cch < cchWC)
		{
			*pstrWC = 0;
			cch++;
		}
	}
	return cch;
}

/*
 *	CW32System::WCTMB (CodePage, dwFlags, pstrWC, cchWC, pstrMB, cchMB,
 *					   pchDefault, pfUsedDef, pfNoCodePage, fTestCodePage)
 *
 *	@mfunc
 *		Convert WideChar (WC) string pstrWC of length cchWC to MultiByte (MB)
 *		string pstrMB of length cchMB according to the flags dwFlags and code
 *		page CodePage.  If CodePage = SYMBOL_CODEPAGE
 *		(usually for SYMBOL_CHARSET strings),
 *		convert each character in pstrWC to a byte, discarding the high byte.
 *		Else call the Win32 WideCharToMultiByte() function.
 *
 *	@rdesc
 *		Count of bytes stored in target string pstrMB
 */
int CW32System::WCTMB(
	INT		CodePage,	//@parm Code page to use for conversion
	DWORD	dwFlags,	//@parm Flags to guide conversion
	LPCWSTR	pstrWC,		//@parm WideChar string to convert
	int		cchWC,		//@parm Count for pstrWC or -1 to use NULL termination
	LPSTR	pstrMB,		//@parm MultiByte string to receive converted chars
	int		cchMB,		//@parm Count of chars (bytes) in pstrMB or 0
	LPCSTR	pchDefault,	//@parm Default char to use if conversion fails
	LPBOOL	pfUsedDef,	//@parm Out parm to receive whether default char used
	LPBOOL 	pfNoCodePage, //@parm Out parm to receive whether code page is on system
	BOOL	fTestCodePage)//@parm Test CodePage could handle the pstrWC
{
	int		cch = -1;						// No chars converted yet
	BOOL	fNoCodePage = FALSE;			// Default code page is on OS

	if(pfUsedDef)							// Default that all chars can be
		*pfUsedDef = FALSE;					//  converted

#ifndef WC_NO_BEST_FIT_CHARS
#define WC_NO_BEST_FIT_CHARS	0x400
#endif

	if (_dwPlatformId == VER_PLATFORM_WIN32_NT &&
		_dwMajorVersion > 4 && !dwFlags)
	{
		dwFlags = WC_NO_BEST_FIT_CHARS;
	}

	if(CodePage == CP_UTF8)					// Convert to UTF8 since OS
	{										// doesn't (pre NT 5.0)
		unsigned ch;
		cch = 0;							// No converted bytes yet
		while(cchWC--)
		{
			ch = *pstrWC++;					// Get Unicode char
			if(ch <= 127)					// It's ASCII
			{
				cch++;
				if(cch < cchMB)
					*pstrMB++ = ch;			// One more converted byte
				if(!ch)						// Quit on NULL termination
					break;
				continue;
			}
			if(ch <= 0x7FF)					// Need 2 bytes of form:
			{								//  110bbbbb 10bbbbbb
				cch += 2;
				if(cch < cchMB)				// Store lead byte
					*pstrMB++ = 0xC0 + (ch >> 6);
			}
			else if(IN_RANGE(UTF16_LEAD, ch, 0xDBFF))
			{								// Unicode surrogate pair
				cch += 4;					// Need 4 bytes of form:
				if(cch < cchMB)				//  11110bbb 10bbbbbb 10bbbbbb
				{							//  10bbbbbb
					AssertSz(IN_RANGE(UTF16_TRAIL, *pstrWC, 0xDFFF),
						"CW32System::WCTMB: illegal surrogate pair");
					cchWC--;
					ch = ((ch & 0x3FF) << 10) + (*pstrWC++ & 0x3FF) + 0x10000;
					*pstrMB++ = 0xF0 + (ch >> 18);
					*pstrMB++ = 0x80 + (ch >> 12 & 0x3F);
					*pstrMB++ = 0x80 + (ch >> 6  & 0x3F);
				}
			}
			else							// Need 3 bytes of form:
			{								//  1110bbbb 10bbbbbb
				cch += 3;					//  10bbbbbb
				if(cch < cchMB)				// Store lead byte followed by
				{							//  first trail byte
					*pstrMB++ = 0xE0 + (ch >> 12);
					*pstrMB++ = 0x80 + (ch >> 6 & 0x3F);
				}
			}
			if(cch < cchMB)					// Store final UTF-8 byte
				*pstrMB++ = 0x80 + (ch & 0x3F);
		}
	}
	else if(CodePage != CP_SYMBOL)
	{
		fNoCodePage = TRUE;					// Default codepage not on OS
		if(CodePage >= 0)					// Might be...
		{
			cch = WideCharToMultiByte(CodePage, dwFlags,
					pstrWC, cchWC, pstrMB, cchMB, pchDefault, pfUsedDef);
			if(cch > 0)
				fNoCodePage = FALSE;		// Found codepage on system
		}
	}
	if(pfNoCodePage)
		*pfNoCodePage = fNoCodePage;

	// Early exit if we are just testing for CodePage
	if (fTestCodePage)
		return cch;

	// SYMBOL_CHARSET, fIsDBCS or conversion failed: low bytes of words ->
	//  bytes
	if(cch <= 0)
	{									
		// Return multibyte count for full conversion. cchWC is correct for
		// single-byte charsets like the 125x's
		if(cchMB <= 0)
		{
			return cchWC >= 0 ? cchWC : wcslen(pstrWC);
		}

		char chDefault = 0;
		BOOL fUseDefaultChar = (pfUsedDef || pchDefault) && CodePage != CP_SYMBOL;

		if(fUseDefaultChar)
		{
			// determine a default char for our home-grown conversion
			if(pchDefault)
			{
				chDefault = *pchDefault;
			}
			else
			{
				static char chSysDef = 0;
				static BOOL fGotSysDef = FALSE;

				// 0x2022 is a math symbol with no conversion to ANSI
				const WCHAR szCantConvert[] = { 0x2022 };
				BOOL fUsedDef;

				if(!fGotSysDef)
				{
					fGotSysDef = TRUE;

					if(!(WideCharToMultiByte
							(CP_ACP, 0, szCantConvert, 1, &chSysDef, 1, NULL,
										&fUsedDef) == 1 && fUsedDef))
					{
						AssertSz(0, "WCTMB():  Unable to determine what the "
									"system uses as its default replacement "
									"character.");
						chSysDef = '?';
					}
				}
				chDefault = chSysDef;
			}
		}

		int cchWCMax = cchWC;

		// If negative, use NULL termination of pstrMB
		if(cchWC < 0)
		{
			cchWCMax = tomForward;
		}

		cchWCMax = min(cchWCMax, cchMB);

		for(cch = 0; (cchWC < 0 ? *pstrWC : 1) && cch < cchWCMax; cch++)
		{
			// TODO(BradO):  Should this be 0x7F in some conversion cases?
			if(fUseDefaultChar && *pstrWC > 0xFF)
			{
				if(pfUsedDef)
				{
					*pfUsedDef = TRUE;
				}
				*pstrMB = chDefault;
			}
			else
			{
				*pstrMB = (BYTE)*pstrWC;
			}
			pstrMB++;
			pstrWC++;
		}

		if(cchWC < 0 && cch < cchMB)
		{
			*pstrMB = 0;
			cch++;
		}
	}
	return cch;
}
/*
 *	CW32System::VerifyFEString(cpg, pstrWC, cchWC, fTestInputCpg)
 *
 *	@mfunc
 *		Verify if the input cpg can handle the pstrWC.
 *		If not, select another FE cpg.
 *
 *	@rdesc
 *		New CodePage for the pstrWC
 */
#define NUMBER_OF_CHARS	64
	
int CW32System::VerifyFEString(
	INT		cpg,			//@parm cpg to format the pstrWC
	LPCWSTR	pstrWC,			//@parm WideChar string to test
	int		cchWC,			//@parm Count for pstrWC
	BOOL	fTestInputCpg)	//@parm test the input cpg only
{
	if (cchWC <=0)
		return cpg;

	int				cpgNew = cpg;
	BOOL			fUsedDef;
	int				cchMB = cchWC * sizeof(WCHAR);
	CTempCharBuf	tcb;
	char			*pstrMB = tcb.GetBuf(cchMB);
	CTempWcharBuf	twcb;
	WCHAR			*pstrWchar = twcb.GetBuf(cchWC);						
	static			int	aiCpg[4] =
		{ CP_JAPAN, CP_KOREAN, CP_CHINESE_TRAD, CP_CHINESE_SIM };	

	if (pstrMB)
	{
		int	cchConverted = WCTMB(cpg, 0, pstrWC, cchWC, pstrMB, cchMB, NULL,
				&fUsedDef, NULL, TRUE);

		if (cchConverted > 0 && !fUsedDef && IsFEFontInSystem(cpg))	
		{
			cchConverted = MBTWC(cpg, 0, pstrMB, cchConverted, pstrWchar, cchWC, NULL);

			if (cchConverted == cchWC && memcmp(pstrWC, pstrWchar, cchMB) == 0)			
				goto Exit;					// Found it
		}		
		
		if (fTestInputCpg)				// Only need to test the input cpg			
			cpgNew = -1;				// Indicate cpg doesn't support the string
		else
		{
			// If no conversion or if the default character is used or
			// no such FE font in system,
			// it means that this cpg may not be the right choice.
			// Let's try other FE cpg.
			for (int i=0; i < 4; i++)
			{
				if (cpg != aiCpg[i])
				{
					cchConverted = WCTMB(aiCpg[i], 0, pstrWC, cchWC, pstrMB, cchMB, NULL,
						&fUsedDef, NULL, TRUE);

					if (cchConverted > 0 && !fUsedDef && IsFEFontInSystem(aiCpg[i]))	
					{
						cchConverted = MBTWC(aiCpg[i], 0, pstrMB, cchConverted, pstrWchar, cchWC, NULL);

						if (cchConverted == cchWC && memcmp(pstrWC, pstrWchar, cchMB) == 0)	
						{
							cpgNew = aiCpg[i];	// Found it
							break;
						}
					}
				}
			}
		}
	}			

Exit:

	return cpgNew;
}

int __cdecl CW32System::sprintf(char * buff, char *fmt, ...)
{
	va_list	marker;

	va_start(marker, fmt);
	int cb = W32->WvsprintfA(0x07FFFFFFF, buff, fmt, marker);
	va_end(marker);

	return cb;
}

//NOTE: Keep this at the end because we want any allocations in w32sys.cpp to be validated
//just like the rest of RichEdit.
///////////////////////////////  Memory mamagement  /////////////////////////////////

#ifdef DEBUG
#undef PvAlloc
#undef PvReAlloc
#undef FreePv
#undef new

MST vrgmst[100];

typedef struct tagPVH //PV Header
{
	char	*szFile;
	int		line;
	tagPVH	*ppvhNext;
	int		cbAlloc;	//On Win'95, the size returned is not the size allocated.
	int		magicPvh;	//Should be last
} PVH;
#define cbPvh (sizeof(PVH))

typedef struct //PV Tail
{
	int		magicPvt; //Must be first
} PVT;

#define cbPvt (sizeof(PVT))
#define cbPvDebug (cbPvh + cbPvt)

void *vpHead = 0;

/*
 *	CW32System::UpdateMst(void)
 *
 *	@mfunc Fills up the vrgmst structure with summary information about our memory
 *	usage.
 *
 *	@rdesc
 *		void
 */
void UpdateMst(void)
{
	W32->ZeroMemory(vrgmst, sizeof(vrgmst));

	PVH		*ppvh;
	MST		*pmst;

	ppvh = (PVH*) vpHead;

	while (ppvh != 0)
	{
		pmst = vrgmst;

		//Look for entry in list...
		while (pmst->szFile)
		{
			if (strcmp(pmst->szFile, ppvh->szFile) == 0)
			{
				pmst->cbAlloc += ppvh->cbAlloc;
				break;
			}
			pmst++;
		}

		if (pmst->szFile == 0)
		{
			pmst->szFile = ppvh->szFile;
			pmst->cbAlloc = ppvh->cbAlloc;
		}

		ppvh = ppvh->ppvhNext;
	}
}

/*
 *	PvDebugValidate(void)
 *
 *	@func Verifies the the node is proper.  Pass in a pointer to the users data
 *	(after the header node.)
 *
 *	@rdesc
 *		void
 */
void PvDebugValidate(void *pv)
{
	PVH	*ppvh;
	PVT *ppvt;

	ppvh = (PVH*) ((char*) pv - cbPvh);
	ppvt = (PVT*) ((char*) pv + ppvh->cbAlloc);

	AssertSz(ppvh->magicPvh == 0x12345678, "PvDebugValidate: header bytes are corrupt");
	AssertSz(ppvt->magicPvt == 0xfedcba98, "PvDebugValidate: tail bytes are corrupt");
}

/*
 *	CW32System::PvSet(pv, szFile, line)
 *
 *	@mfunc Sets a different module and line number for
 *
 *	@rdesc
 *		void
 */
void CW32System::PvSet(void *pv, char *szFile, int line)
{
	if (pv == 0)
		return;

	PvDebugValidate(pv);
	PVH *ppvh = (PVH*) ((char*) pv - cbPvh);

	ppvh->szFile = szFile;
	ppvh->line = line;
}
/*
 *	CW32System::PvAllocDebug(cb, uiMemFlags, szFile, line)
 *
 *	@mfunc Allocates a generic (void*) pointer. This is a debug only routine which
 *	tracks the allocation.
 *
 *	@rdesc
 *		void
 */
void* CW32System::PvAllocDebug(ULONG cb, UINT uiMemFlags, char *szFile, int line)
{
	void	*pv;

	pv = PvAlloc(cb + cbPvDebug, uiMemFlags);
	if (!pv)
		return 0;

	PVH	*ppvh;
	PVT *ppvt;

	ppvt = (PVT*) ((char*) pv + cb + cbPvh);
	ppvh = (PVH*) pv;

	ZeroMemory(ppvh, sizeof(PVH));
	ppvh->magicPvh = 0x12345678;
	ppvt->magicPvt = 0xfedcba98;
	ppvh->szFile = szFile;
	ppvh->line = line;
	ppvh->cbAlloc = cb;

	ppvh->ppvhNext = (PVH*) vpHead;
	vpHead = pv;

	return (char*) pv + cbPvh;
}

/*
 *	CW32System::PvReAllocDebug(pv, cb, szFile, line)
 *
 *	@mfunc ReAllocates a generic (void*) pointer. This is a debug only routine which
 *	tracks the allocation.
 *
 *	@rdesc
 *		void
 */
void* CW32System::PvReAllocDebug(void *pv, ULONG cb, char *szFile, int line)
{
	void	*pvNew;
	PVH	*ppvh, *ppvhHead, *ppvhTail;
	PVT *ppvt;
	ppvh = (PVH*) ((char*) pv - cbPvh);

	if (!pv)
		return PvAllocDebug(cb, 0, szFile, line);

	PvDebugValidate(pv);

	pvNew = PvReAlloc((char*) pv - cbPvh, cb + cbPvDebug);

	if (!pvNew)
		return 0;

	ppvt = (PVT*) ((char*) pvNew + cb + cbPvh);
	ppvh = (PVH*) pvNew;
	ppvh->cbAlloc = cb;

	//Put the new trailer bytes in.
	ppvt->magicPvt = 0xfedcba98;

	//Make the pointer list up to date again
	if (pv != pvNew)
	{
		ppvhTail = 0;
		ppvhHead = (PVH*) vpHead;

		while ((char*)ppvhHead != (char*)pv - cbPvh)
		{
			AssertSz(ppvhHead, "entry not found in list.");
			ppvhTail = ppvhHead;
			ppvhHead = (PVH*) ppvhHead->ppvhNext;
		}

		if (ppvhTail == 0)
			vpHead = pvNew;
		else
			ppvhTail->ppvhNext = (PVH*) pvNew;
	}

	return (char*) pvNew + cbPvh;
}

/*
 *	CW32System::FreePvDebug(pv)
 *
 *	@mfunc Returns a pointer when you are done with it.
 *
 *	@rdesc
 *		void
 */
void CW32System::FreePvDebug(void *pv)
{
	if (!pv)
		return;

	PvDebugValidate(pv);

	PVH	*ppvhHead, *ppvhTail, *ppvh;

	AssertSz(vpHead, "Deleting from empty free list.");

	ppvh = (PVH*) ((char*) pv - cbPvh);
	
	//Search and remove the entry from the list
	ppvhTail = 0;
	ppvhHead = (PVH*) vpHead;

	while ((char*) ppvhHead != ((char*) pv - cbPvh))
	{
		AssertSz(ppvhHead, "entry not found in list.");
		ppvhTail = ppvhHead;
		ppvhHead = (PVH*) ppvhHead->ppvhNext;
	}

	if (ppvhTail == 0)
		vpHead = ppvhHead->ppvhNext;
	else
		ppvhTail->ppvhNext = ppvhHead->ppvhNext;

	FreePv((char*) pv - cbPvh);
}

/*
 *	CatchLeaks(void)
 *
 *	@func Displays any memory leaks in a dialog box.
 *
 *	@rdesc
 *		void
 */
void CatchLeaks(void)
{
	PVH		*ppvh;
	char szLeak[512];

	ppvh = (PVH*) vpHead;
	while (ppvh != 0)
	{
		wsprintfA(szLeak, "Memory Leak of %d bytes: -- File: %s, Line: %d", ppvh->cbAlloc, ppvh->szFile, ppvh->line);
	    if (NULL != pfnAssert)
		{
			// if we have an assert hook, give the user a chance to process the leak message
			if (pfnAssert(szLeak, ppvh->szFile, &ppvh->line))
			{
				// hook returned true, show the message box
				MessageBoxA(NULL, szLeak, "", MB_OK);				
			}
		}
		else
		{
			MessageBoxA(NULL, szLeak, "", MB_OK);
		}
		ppvh = ppvh->ppvhNext;
	}
}

void* _cdecl operator new (size_t size, char *szFile, int line)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "new");

	return W32->PvAllocDebug(size, GMEM_ZEROINIT, szFile, line);
}

void _cdecl operator delete (void* pv)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "delete");

	W32->FreePvDebug(pv);
}

#else //DEBUG

void* _cdecl operator new (size_t size)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "new");

	return W32->PvAlloc(size, GMEM_ZEROINIT);
}

void _cdecl operator delete (void* pv)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "delete");

	W32->FreePv(pv);
}

#endif //DEBUG


/*
 *	PvAlloc (cbBuf, uiMemFlags)
 *
 *	@mfunc	memory allocation.  Similar to GlobalAlloc.
 *
 *	@comm	The only flag of interest is GMEM_ZEROINIT, which
 *			specifies that memory should be zeroed after allocation.
 */
PVOID CW32System::PvAlloc(
	ULONG	cbBuf, 			//@parm	Count of bytes to allocate
	UINT	uiMemFlags)		//@parm Flags controlling allocation
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "PvAlloc");
	
	void * pv = LocalAlloc(LMEM_FIXED, cbBuf);

	if( pv && (uiMemFlags & GMEM_ZEROINIT) )
		ZeroMemory(pv, cbBuf);
	
	return pv;
}

/*
 *	PvReAlloc	(pvBuf, cbBuf)
 *
 *	@mfunc	memory reallocation.
 *
 */
PVOID CW32System::PvReAlloc(
	PVOID	pvBuf, 		//@parm Buffer to reallocate
	DWORD	cbBuf)		//@parm New size of buffer
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "PvReAlloc");

	if(pvBuf)
		return LocalReAlloc(pvBuf, cbBuf, LMEM_MOVEABLE);

	return LocalAlloc(LMEM_FIXED, cbBuf);
}

/*
 *	FreePv (pvBuf)
 *
 *	@mfunc	frees memory
 *
 *	@rdesc	void
 */
void CW32System::FreePv(
	PVOID pvBuf)		//@parm Buffer to free
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "FreePv");

	if(pvBuf)
		LocalFree(pvBuf);
}


/*
 *	Mirroring API (only in BiDi Win98 and NT5 upward)
 *
 *	@mfunc	Get/Set DC mirroring effect
 *
 */

DWORD WINAPI GetLayoutStub(HDC hdc)
{
	return 0;
}

DWORD WINAPI SetLayoutStub(HDC hdc, DWORD dwLayout)
{
	return 0;
}

DWORD WINAPI GetLayoutInit(HDC hdc)
{
	CLock		lock;
	HINSTANCE	hMod = ::GetModuleHandleA("GDI32.DLL");
	Assert(hMod);

	W32->_pfnGetLayout = (PFN_GETLAYOUT)GetProcAddress(hMod, "GetLayout");

	if (!W32->_pfnGetLayout)
		W32->_pfnGetLayout = &GetLayoutStub;

	return W32->_pfnGetLayout(hdc);
}

DWORD WINAPI SetLayoutInit(HDC hdc, DWORD dwLayout)
{
	CLock		lock;
	HINSTANCE	hMod = ::GetModuleHandleA("GDI32.DLL");
	Assert(hMod);

	W32->_pfnSetLayout = (PFN_SETLAYOUT)GetProcAddress(hMod, "SetLayout");

	if (!W32->_pfnSetLayout)
		W32->_pfnSetLayout = &SetLayoutStub;

	return W32->_pfnSetLayout(hdc, dwLayout);
}

PFN_GETLAYOUT	CW32System::_pfnGetLayout = &GetLayoutInit;
PFN_SETLAYOUT	CW32System::_pfnSetLayout = &SetLayoutInit;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_array.h ===
/*	@doc INTERNAL
 *
 *	@module _ARRAY.H  Generic Array Class |
 *	
 *	This module declares a generic array class for constant sized
 *	elements (although the elements themselves may be of any size).
 *
 *	Original Author: <nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95	alexgo	Cleanup and Commenting
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _ARRAY_H
#define _ARRAY_H

class CFormatRunPtr;

/*
 *	ArrayFlag
 *
 *	@enum	Defines flags used with the array class
 */
enum tagArrayFlag
{
	AF_KEEPMEM		= 1,	//@emem Don't delete any memory 
	AF_DELETEMEM	= 2,	//@emem Delete as much memory as possible
};

//@type ArrayFlag | flags controlling the usage of generic arrays 
//(and specifically how memory is handled)
typedef enum tagArrayFlag ArrayFlag;


/*
 *	CArrayBase
 *	
 * 	@class	The CArrayBase class implements a generic array class.  It should
 *	never be used directly; use the type-safe template, <c CArray>, instead.
 *
 *	@devnote There are exactly two legal states for an array: empty or not.
 *	If an array is empty, the following must be true:
 *
 *		<md CArrayBase::_prgel> == NULL; <nl>
 *		<md CArrayBase::_cel> == 0; <nl>
 *		<md CArrayBase::_celMax> == 0;
 *
 *	Otherwise, the following must be true:
 *
 *		<md CArrayBase::_prgel> != NULL; <nl>
 *		<md CArrayBase::_cel> <lt>= <md CArrayBase::_celMax>; <nl>
 *		<md CArrayBase::_celMax> <gt> 0;
 *
 *	
 *	An array starts empty, transitions to not-empty as elements are inserted
 *  and will transistion back to empty if all of the array elements are 
 *	removed.
 *
 */
class CArrayBase
{
//@access Public Methods
public:

#ifdef DEBUG
	BOOL	Invariant() const;		//@cmember Validates state consistentency
	void*	Elem(LONG iel) const;	//@cmember Get ptr to <p iel>'th run
#else
	void*	Elem(LONG iel) const {return _prgel + iel*_cbElem;}
#endif
	
	CArrayBase (LONG cbElem);		//@cmember Constructor
	~CArrayBase () {Clear(AF_DELETEMEM);}

	void 	Clear (ArrayFlag flag);	//@cmember Delete all runs in array
	LONG 	Count() const {return _cel;}//@cmember Get count of runs in array
									//@cmember Remove <p celFree> runs from
									// array, starting at run <p ielFirst>
	void 	Remove(LONG ielFirst, LONG celFree);
									//@cmember Replace runs <p iel> through
									// <p iel+cel-1> with runs from <p par>
	BOOL	Replace (LONG iel, LONG cel, CArrayBase *par);
	
	LONG 	Size() const {return _cbElem;}//@cmember Get size of a run			

//@access Protected Methods
protected:
	void* 	ArAdd (LONG cel, LONG *pielIns);	//@cmember Add <p cel> runs
	void* 	ArInsert(LONG iel, LONG celIns);	//@cmember Insert <p celIns>
												// runs

//@access Protected Data
protected:
	char*	_prgel;		//@cmember Pointer to actual array data
	LONG 	_cel;	  	//@cmember Count of used entries in array
	LONG	_celMax;	//@cmember Count of allocated entries in array
	LONG	_cbElem;	//@cmember Byte count of an individual array element
};

/*
 *	CArray
 *
 *	@class
 *		An inline template class providing type-safe access to CArrayBase
 *
 *	@tcarg class | ELEM | the class or struct to be used as array elements
 */

template <class ELEM> 
class CArray : public CArrayBase
{
//@access Public Methods
public:
	
	CArray ()								//@cmember Constructor
		: CArrayBase(sizeof(ELEM))
	{}
	
	ELEM *	Elem(LONG iel) const			//@cmember Get ptr to <p iel>'th
	{										// element
		return (ELEM *)CArrayBase::Elem(iel);
	}
	
	ELEM& 	GetAt(LONG iel) const			//@cmember Get <p iel>'th element
	{
		return *(ELEM *)CArrayBase::Elem(iel);
	}
	
	ELEM* 	Add (LONG cel, LONG *pielIns)	//@cmember Adds <p cel> elements						
	{										// to end of array
		return (ELEM*)ArAdd(cel, pielIns);
	}

	ELEM* 	Insert (LONG iel, LONG celIns)	//@cmember Insert <p celIns>
	{										// elements at index <p iel>
		return (ELEM*)ArInsert(iel, celIns);
	}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_antievt.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _ANTIEVT.H |
 *
 *
 *	Purpose:
 *		Class declarations for common anti-event objects
 *
 *	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef __ANTIEVT_H__
#define __ANTIEVT_H__

#include "_frunptr.h"

class CTxtEdit;
class CAntiEventDispenser;
class COleObject;


/*
 *	CBaseAE
 *
 *	@class
 *		Base anti-event that manages a linked list of anti-events
 *
 */
class CBaseAE : public IAntiEvent
{
//@access Public Methods
public:
	virtual void Destroy();						//@cmember Destroy
												//@cmember Undo			
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr );
	virtual HRESULT MergeData( DWORD dwDataType, void *pdata);	//@cmember
												// Merges undo data into the
												// current context.
	virtual void OnCommit( CTxtEdit *ped );		//@cmember Called when AE is
												// committed to undo stack
	virtual	void SetNext( IAntiEvent *pNext );	//@cmember	Sets next AE
	virtual IAntiEvent *GetNext();				//@cmember	Gets next AE

//@access Protected Methods
protected:
	// CBaseAE should only exist as a parent class
	CBaseAE();									//@cmember Constructor
	~CBaseAE(){;}

//@access Private Methods and Data
private:
	IAntiEvent *	_pnext;						//@cmember Pointer to the next
												//AntiEvent
};

/*
 *	CReplaceRangeAE
 *
 *	@class
 *		an anti-event object than undoes a CTxtPtr::ReplaceRange
 *		operation
 *
 *	@base	public | CBaseAE
 */
class CReplaceRangeAE: public CBaseAE
{
//@access Public Methods
public:
	// IAntiEvent methods
	virtual void Destroy();						//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr);		
	virtual HRESULT MergeData( DWORD dwDataType, void *pdata);	//@cmember
												// Merges undo data into the
												// current context

//@access Private methods and data
private:
												//@cmember Constructor
	CReplaceRangeAE(LONG cpMin, LONG cpMax, LONG cchDel, TCHAR *pchDel,
			IAntiEvent *paeCF, IAntiEvent *paePF);
	~CReplaceRangeAE();							//@cmember Destructor

	LONG		_cpMin;							//@cmember cp delete start
	LONG		_cpMax;							//@cmember cp delete end
	LONG		_cchDel;						//@cmember #of chars to insert
	TCHAR *		_pchDel;						//@cmember chars to insert
	IAntiEvent *_paeCF;							//@cmember charformat AE
	IAntiEvent *_paePF;							//@cmember par format AE

	friend class CAntiEventDispenser;
};

/*
 *	CReplaceFormattingAE
 *
 *	@class
 *		an anti-event object than undoes replacing multiple char formats
 *
 *	@base	public |  CBaseAE
 */
class CReplaceFormattingAE: public CBaseAE
{
//@access	Public methods
public:
	//
	// IAntiEvent methods
	//
	virtual void Destroy( void );				//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr);

//@access	Private Methods and Data
private:
												//@cmember Constructor
	CReplaceFormattingAE(CTxtEdit* ped, CFormatRunPtr &rp, LONG cch, IFormatCache *pf, BOOL fPara);

	~CReplaceFormattingAE();					//@cmember Destuctor

	LONG		_cp;							//@cmember cp where formatting
												// should start
	LONG		_cRuns;							//@cmember # of format runs
	CFormatRun  *_prgRuns;						//@cmember format runs
	BOOL		_fPara;							//@cmember if TRUE, then
												// formatting is paragraph fmt

	friend class CAntiEventDispenser;
};

/*
 *	CReplaceObjectAE
 *
 *	@class
 *		an anti-event object that undoes the deletion of an object
 *
 *	@base public | CBaseAE
 */
class CReplaceObjectAE : public CBaseAE
{
//@access	Public methods
public:
	//
	//	IAntiEvent methods
	//
	virtual void Destroy(void);					//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);
	virtual void OnCommit(CTxtEdit *ped);		//@cmember called when
												// committed
private:
	CReplaceObjectAE(COleObject *pobj);			//@cmember Constructor
	~CReplaceObjectAE();						//@cmember Destructor

	COleObject *	_pobj;						//@cmember pointer to the
												// deleted object
	BOOL			_fUndoInvoked;				//@cmember undo was invoked
												// on this object.
	
	friend class CAntiEventDispenser;
};

/*
 *	CResizeObjectAE
 *
 *	@class
 *		an anti-event object that undoes the resizing of an object
 *
 *	@base public | CBaseAE
 */
class CResizeObjectAE : public CBaseAE
{
//@access	Public methods
public:
	//
	//	IAntiEvent methods
	//
	virtual void Destroy(void);					//@cmember Destroy
												//@cmember Undo
	virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);
	virtual void OnCommit(CTxtEdit *ped);		//@cmember called when
												// committed
private:
	CResizeObjectAE(COleObject *pobj,			//@cmember Constructor
		            RECT rcPos);				
	~CResizeObjectAE();							//@cmember Destructor

	COleObject *	_pobj;						//@cmember pointer to the
												// deleted object
	RECT			_rcPos;						//@cmember The old object
												// position/size rectangle
	BOOL			_fUndoInvoked;				//@cmember undo was invoked
												// on this object.
	
	friend class CAntiEventDispenser;
};

/*
 *  CSelectionAE
 *
 *  @class
 *      an anti-event object to restore a selection
 *
 *  @base public | CBaseAE
 */
class CSelectionAE : public CBaseAE
{
//@access   Public methods
public:
    //
    //  IAntiEvent methods
    //
    virtual void Destroy(void);                 //@cmember Destroy
                                                //@cmember Undo
    virtual HRESULT Undo(CTxtEdit *ped, IUndoBuilder *publdr);
    virtual HRESULT MergeData( DWORD dwDataType, void *pdata);  //@cmember
                                                // Merges undo data into the
                                                // current context

private:
                                                //@cmember Constructor
    CSelectionAE(LONG cp, LONG cch, LONG cpNext, LONG cchNext);
    ~CSelectionAE();                            //@cmember Destructor

    LONG        _cp;                            //@cmember Active end
    LONG        _cch;                           //@cmember Signed extension
	LONG		_cpNext;						//@cmember Next active end
	LONG		_cchNext;						//@cmember Next extension

    friend class CAntiEventDispenser;
};

/*
 *	CAntiEventDispenser
 *
 *	@class
 *		creates anti events and caches them intelligently to provide
 *		for efficient multi-level undo
 */
class CAntiEventDispenser
{
//@access	Public methods
public:
	// no memory mgmt routines; the dispenser is global

												//@cmember text antievent
	IAntiEvent * CreateReplaceRangeAE( CTxtEdit *ped, LONG cpMin,
					LONG cpMax, LONG cchDel, TCHAR *pchDel,
					IAntiEvent *paeCF, IAntiEvent *paePF );
												//@cmember formatting AE
	IAntiEvent * CreateReplaceFormattingAE( CTxtEdit *ped,
					CFormatRunPtr &rp, LONG cch,
					IFormatCache *pf, BOOL fPara );
												//@cmember Object AE
	IAntiEvent * CreateReplaceObjectAE(CTxtEdit *ped, COleObject *pobj);
												//@cmember Object AE
	IAntiEvent * CreateResizeObjectAE(CTxtEdit *ped, COleObject *pobj, RECT rcPos);
												//@cmember Selection AE
	IAntiEvent * CreateSelectionAE(CTxtEdit *ped, LONG cp, LONG cch,
					LONG cpNext, LONG cchNext);

private:

	// FUTURE (alexgo): we'll want to maintain an allocation cache of
	// anti-events
};

// NB!! Global variable.

extern class CAntiEventDispenser gAEDispenser;

#endif // !__ANTIEVNT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\w32win32.cpp ===
/*
 *	Unicode <--> MultiByte conversions, OLE, and other system functions
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#include <objbase.h>	// CoCreateInstance define
#include "aimm.h"		// AIMM i/f
#include "aimm_i.c"		// AIMM CLSID etc

#include "_font.h"
#include "_uspi.h"
#define MAX_HKLS 256			// It will be a while before we have more KBs

static HINSTANCE g_hOleAut32 = NULL;
static HINSTANCE g_hOle32 = NULL;

#ifndef NOACCESSIBILITY 
static HINSTANCE g_hAcc = NULL;
static HINSTANCE g_hUser32 = NULL;
#endif

class CIMM32_PROC
{
public:
	void *ImmGetCompositionStringA;
	void *ImmGetCompositionStringW;
	void *ImmGetContext;
	void *ImmSetCompositionFontA;
	void *ImmSetCompositionWindow;
	void *ImmReleaseContext;
	void *ImmGetProperty;
	void *ImmGetCandidateWindow;
	void *ImmSetCandidateWindow;
	void *ImmNotifyIME;
	void *ImmAssociateContext;
	void *ImmGetVirtualKey;
	void *ImmEscapeA;
	void *ImmEscapeW;
	void *ImmGetOpenStatus;
	void *ImmSetOpenStatus;
	void *ImmGetConversionStatus;
	void *ImmSetConversionStatus;
	void *ImmGetDefaultIMEWnd;
	void *ImmSetCompositionStringW;
};
static CIMM32_PROC	g_IMM32Proc;

class CIMESHARE_PROC
{
public:
	void *FSupportSty;
	void *PIMEStyleFromAttr;
	void *PColorStyleTextFromIMEStyle;
	void *PColorStyleBackFromIMEStyle;
	void *FBoldIMEStyle;
	void *FItalicIMEStyle;
	void *FUlIMEStyle;
	void *IdUlIMEStyle;
	void *RGBFromIMEColorStyle;
};
static CIMESHARE_PROC	g_IMEShareProc;

class COLEAUT32_PROC
{
public:
	void *LoadRegTypeLib;
	void *LoadTypeLib;
	void *LoadTypeLibEx;
	void *SysAllocString;
	void *SysAllocStringLen;
	void *SysFreeString;
	void *SysStringLen;
	void *VariantInit;
};
static COLEAUT32_PROC	g_OleAut32Proc;

class COLE32_PROC
{
public:
	void *OleCreateFromData;
	void *CoTaskMemFree;
	void *CreateBindCtx;
	void *OleDuplicateData;
	void *CoTreatAsClass;
	void *ProgIDFromCLSID;
	void *OleConvertIStorageToOLESTREAM;
	void *OleConvertIStorageToOLESTREAMEx;
	void *OleSave;
	void *StgCreateDocfileOnILockBytes;
	void *CreateILockBytesOnHGlobal;
	void *OleCreateLinkToFile;
	void *CoTaskMemAlloc;
	void *CoTaskMemRealloc;
	void *OleInitialize;
	void *OleUninitialize;
	void *OleSetClipboard;
	void *OleFlushClipboard;
	void *OleIsCurrentClipboard;
	void *DoDragDrop;
	void *OleGetClipboard;
	void *RegisterDragDrop;
	void *OleCreateLinkFromData;
	void *OleCreateStaticFromData;
	void *OleDraw;
	void *OleSetContainedObject;
	void *CoDisconnectObject;
	void *WriteFmtUserTypeStg;
	void *WriteClassStg;
	void *SetConvertStg;
	void *ReadFmtUserTypeStg;
	void *ReadClassStg;
	void *OleRun;
	void *RevokeDragDrop;
	void *CreateStreamOnHGlobal;
	void *GetHGlobalFromStream;
	void *OleCreateDefaultHandler;
	void *CLSIDFromProgID;
	void *OleConvertOLESTREAMToIStorage;
	void *OleLoad;
	void *ReleaseStgMedium;
	void *CoCreateInstance;
};
static COLE32_PROC	g_Ole32Proc;

class CConvertStr
{
public:
    operator char *();

protected:
    CConvertStr();
    ~CConvertStr();
    void Free();

    LPSTR   _pstr;
    char    _ach[MAX_PATH * 2];
};

inline CConvertStr::operator char *()
{
    return _pstr;
}

inline CConvertStr::CConvertStr()
{
    _pstr = NULL;
}

inline CConvertStr::~CConvertStr()
{
    Free();
}

class CStrIn : public CConvertStr
{
public:
    CStrIn(LPCWSTR pwstr, UINT CodePage = CP_ACP);
    CStrIn(LPCWSTR pwstr, int cwch, UINT CodePage = CP_ACP);
    int strlen();

protected:
    CStrIn();
    void Init(LPCWSTR pwstr, int cwch, UINT CodePage = CP_ACP);

    int _cchLen;
};

inline CStrIn::CStrIn()
{
}

inline int CStrIn::strlen()
{
    return _cchLen;
}

class CStrOut : public CConvertStr
{
public:
    CStrOut(LPWSTR pwstr, int cwchBuf);
    ~CStrOut();

    int     BufSize();
    int     Convert();

private:
    LPWSTR  _pwstr;
    int     _cwchBuf;
};

inline int CStrOut::BufSize()
{
    return _cwchBuf * 2;
}

//
//	Multi-Byte ---> Unicode conversion
//

class CStrOutW : public CConvertStrW
{
public:
    CStrOutW(LPSTR pstr, int cchBuf, UINT uiCodePage);
    ~CStrOutW();

    int     BufSize();
    int     Convert();

private:

    LPSTR  	_pstr;
    int     _cchBuf;
	UINT	_uiCodePage;
};

inline int CStrOutW::BufSize()
{
    return _cchBuf;
}

DWORD CW32System::AddRef()
{
	return ++_cRefs;
}

DWORD CW32System::Release()
{
	DWORD culRefs =	--_cRefs;

	if(culRefs == 0)
	{
		FreeIME();
		if (g_hOle32)
		{
			EnterCriticalSection(&g_CriticalSection);
			OleUninitialize();
			FreeLibrary(g_hOle32);
			g_hOle32 = NULL;
			memset(&g_Ole32Proc, 0, sizeof(g_Ole32Proc));
 			LeaveCriticalSection(&g_CriticalSection);
		}
	}
	return culRefs;
}

ATOM WINAPI CW32System::RegisterREClass(
	const WNDCLASSW *lpWndClass,
	const char *szAnsiClassName,
	WNDPROC AnsiWndProc
)
{
	WNDCLASSA wc;
	ATOM atom;

	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "RegisterREClass");
	// First register the normal window class.
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
	{
		atom = ::RegisterClass(lpWndClass); 
		if (!atom && GetLastError() == ERROR_CLASS_ALREADY_EXISTS)
			atom = FindAtom(lpWndClass->lpszClassName);
	}
	else
	{
		// On WIndows 95 we need to convert the window class name.
		CStrIn strMenuName(lpWndClass->lpszMenuName);
		CStrIn strClassName(lpWndClass->lpszClassName);
		Assert(sizeof(wc) == sizeof(*lpWndClass));
		memcpy(&wc, lpWndClass, sizeof(wc));
		wc.lpszMenuName = strMenuName;
		wc.lpszClassName = strClassName;
		
		atom = ::RegisterClassA(&wc);		
		if (!atom && GetLastError() == ERROR_CLASS_ALREADY_EXISTS)
			atom = FindAtomA(wc.lpszClassName);
	}
	
	if (!atom || !szAnsiClassName)
		return atom;		

	// Now REgister the ANSI window class name i.e. RICHEDIT20A
	wc.style = lpWndClass->style;
	wc.cbClsExtra = lpWndClass->cbClsExtra;
	wc.cbWndExtra = lpWndClass->cbWndExtra;
	wc.hInstance = lpWndClass->hInstance;
	wc.hIcon = lpWndClass->hIcon;
	wc.hCursor = lpWndClass->hIcon;
	wc.hbrBackground = lpWndClass->hbrBackground;
	wc.lpszMenuName = NULL;
	wc.lpfnWndProc = AnsiWndProc;
	wc.lpszClassName = szAnsiClassName;

	atom = ::RegisterClassA(&wc);
	if (!atom && GetLastError() == ERROR_CLASS_ALREADY_EXISTS)
		atom = FindAtomA(szAnsiClassName);
		
	return atom;
}

LONG ValidateTextRange(TEXTRANGE *pstrg);

LRESULT CW32System::ANSIWndProc(
	HWND	hwnd,
	UINT	msg,
	WPARAM	wparam,
	LPARAM	lparam,
	BOOL	fIs10Mode)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichEditANSIWndProc");

	#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
	#endif	// DEBUG

	LRESULT	lres;

	switch( msg )
	{

	case EM_REPLACESEL:
	case WM_SETTEXT:
	{	
		SETTEXTEX st = {ST_CHECKPROTECTION, 0};
		if(msg == EM_REPLACESEL)
		{
			st.flags = wparam ? ST_CHECKPROTECTION | ST_SELECTION | ST_KEEPUNDO | ST_10REPLACESEL
							  :	ST_CHECKPROTECTION | ST_SELECTION | ST_10REPLACESEL;
		}
		else if (fIs10Mode)
			st.flags |= ST_10WM_SETTEXT;		// 1.0 Mode WM_SETTEXT

		return RichEditWndProc(hwnd, EM_SETTEXTEX, (WPARAM)&st, lparam);
	}

	case EM_FINDTEXT:
	case EM_FINDTEXTEX:
		{
			// We cheat a little here because FINDTEXT and FINDTEXTEX overlap
			// with the exception of the extra out param chrgText in FINDTEXTEX
			FINDTEXTEXW ftexw;
			FINDTEXTA *pfta = (FINDTEXTA *)lparam;
			CStrInW strinw(pfta->lpstrText, W32->GetKeyboardCodePage());

			ftexw.chrg = pfta->chrg;
			ftexw.lpstrText = (WCHAR *)strinw;

			lres = RichEditWndProc(hwnd, msg, wparam, (LPARAM)&ftexw);
			
			if(msg == EM_FINDTEXTEX)
			{
				// In the FINDTEXTEX case, the extra field in the
				// FINDTEXTEX data structure is an out parameter indicating
				// the range where the text was found.  Update the 'real'
				// [in, out] parameter accordingly.	
				((FINDTEXTEXA *)lparam)->chrgText = ftexw.chrgText;
			}
			return lres;
		}
		break;				

	case EM_GETSELTEXT:
		{
			GETTEXTEX gt;
			const char chDefault = ' ';

			gt.cb = (unsigned)-1;			// Client claims to have enuf room		
			gt.flags = GT_SELECTION;		// Get selected text
			gt.codepage = (unsigned)-1;		// Use default CCharFormat codepage
			gt.lpDefaultChar = &chDefault;	// Translate other chars into blanks
			gt.lpUsedDefChar = NULL;

			return RichEditWndProc(hwnd, EM_GETTEXTEX, (WPARAM)&gt, lparam);
		}
		break;

	// case WM_GETTEXT:	Handled by Ansi filter

	// case WM_GETTEXTLENGTH: Handled by Ansi filter

	case EM_GETTEXTRANGE:
		{
			TEXTRANGEA *ptrg = (TEXTRANGEA *)lparam;

            LONG clInBuffer = ValidateTextRange((TEXTRANGEW *) ptrg);

            // If size is -1, this means that the size required is the total
            // size of the the text.
            if(-1 == clInBuffer)
            {
                // We can get this length either by digging the data out of the
                // various structures below us or we can take advantage of the
                // WM_GETTEXTLENGTH message. The first might be slightly 
                // faster but the second definitely save code size. So we
                // will go with the second.
                clInBuffer = SendMessage(hwnd, WM_GETTEXTLENGTH, 0, 0);
            }

            if(0 == clInBuffer)
            {
                // The buffer was invalid for some reason or there was not data
                // to copy. In any case, we are done.
                return 0;
            }

            // Verify that the output buffer is big enough.
            if(IsBadWritePtr(ptrg->lpstrText, clInBuffer + 1))
            {
                // Not enough space so don't copy any
                return 0;
            }

			// For EM_GETTEXTRANGE case, we again don't know how big the
			// incoming buffer is, only that it should be *at least* as
			// great as cpMax - cpMin in the text range structure.  We also
			// know that anything *bigger* than (cpMax - cpMin)*2 bytes is
			// uncessary.  So we'll just assume that it's "big enough"
			// and let WideCharToMultiByte scribble as much as it needs.
			// Memory shortages are the caller's responsibility (courtesy
			// of the RichEdit 1.0 design).
			
			CStrOutW stroutw(ptrg->lpstrText, (clInBuffer + 1) * sizeof(WCHAR), 
							 RichEditWndProc(hwnd, EM_GETCODEPAGE, 0, 0));
			TEXTRANGEW trgw;
			trgw.chrg = ptrg->chrg;
			trgw.lpstrText = (WCHAR *)stroutw;

			RichEditWndProc(hwnd, EM_GETTEXTRANGE, wparam, (LPARAM)&trgw);
			
			return stroutw.Convert();	// Return count of BYTEs converted
		}

	case EM_GETLINE:
		{
			// The size is indicated by the first word of the memory pointed
			// to by lparam
			WORD size = *(WORD *)lparam;
			CStrOutW stroutw((char *)lparam, (DWORD)size,
							 RichEditWndProc(hwnd, EM_GETCODEPAGE, 0, 0));
			WCHAR *pwsz = (WCHAR *)stroutw;
			*(WORD *)pwsz = size;

			lres = RichEditWndProc(hwnd, msg, wparam, (LPARAM)pwsz);

			if (lres < size)
				*(pwsz+lres) = L'\0';		// EM_GETLINE does not return NULL-terminated string.
			LONG cach = stroutw.Convert();
			// Note: should probably return cach for 3.0 too, i.e.,
			// just like EM_GETTEXTRANGE above
			return fIs10Mode ? cach : lres;	// If 1.0, return count of BYTEs converted
		}

#ifdef DEBUG
	case WM_NCCREATE:
	case WM_CREATE:
		// These messages should be handled higher up so let everyone
		// know we got to the wrong place!
		AssertSz(FALSE, "CW32System::ANSIWndProc got WM_CREATE or WM_NCCREATE");
		break;

#endif // DEBUG

	}
	return RichEditWndProc(hwnd, msg, wparam, lparam);
}

// Note that AnsiFilter could be refined so that we could get rid
// of the ANSI window proc.
void CW32System::AnsiFilter(
	UINT &	msg,
	WPARAM &wparam,
	LPARAM lparam,
	void *pvoid,
	BOOL f10Mode
)
{
	GETTEXTEX *pgt;
	GETTEXTLENGTHEX *pgtl;
	WM_CHAR_INFO *pwmci;
	bool fAltNumPad = (GetKeyboardFlags() & ALTNUMPAD) != 0;
	UINT cpg = GetKeyboardCodePage(0xFFFFFFFF);

	switch (msg)
	{
		case WM_CHAR:
			pwmci = (WM_CHAR_INFO *) pvoid;
			pwmci->_fTrailByte = false;
			pwmci->_fLeadByte = false;
			pwmci->_fIMEChar = false;
			if (pwmci->_fAccumulate) {
				// We could do some validation here.
				pwmci->_fTrailByte = true;
				return;
			}
			// WM_CHAR > 256 on Win95; assumed to be Unicode

			if(fAltNumPad)
			{
				DWORD Number = GetKeyPadNumber();
				if(Number >= 256 || GetKeyboardFlags() & ALT0)
				{
					wparam = Number;
					if(!IN_RANGE(1250, cpg, 1258))	// Use 1252 for DBCS
						cpg = 1252;					//  codepages
				}
			}

			if(IN_RANGE(128, wparam, 255))
			{							
				bool fShift = (GetKeyboardFlags() & SHIFT) != 0;
				bool fCtrl  = (GetKeyboardFlags() & CTRL)  != 0;

				// If fAltNumPad is set, wparam is HiAnsi
				// If Shift + Alt + Ctrl, it is repeat event from Win3.1 IME
				if ((!fAltNumPad || (fShift && fCtrl)) && GetTrailBytesCount((BYTE) wparam, cpg))
				{
					pwmci->_fLeadByte = true;
					return;
				}
				WPARAM	wparamNew = 0;
				switch ( cpg )
				{				
					case CP_JAPAN:
						// for Japanese codepage, need to translate SBC if KANA mode is on					 
						if ((GetKeyState(VK_KANA) & 1) || f10Mode)		
							break;
						// If not in KANA mode, then fall thru to use 1252 codepage...
					case CP_KOREAN:
					case CP_CHINESE_TRAD:
					case CP_CHINESE_SIM:
						// use English codepage since there is no HiAnsi conversion for
						// FE systems
						cpg = 1252;
						break;				
				}

				if (cpg == 1252 && !IN_RANGE(0x80, wparam, 0x9f))
					return;

				// Convert single byte WM_CHAR messages to Unicode
				if(UnicodeFromMbcs((LPWSTR)&wparamNew, 1, (char *)&wparam, 1,
					cpg) == 1 )
				{
					wparam = wparamNew;
					if (fAltNumPad)
						SetKeyPadNumber(wparam);
				}
			}
			else if(lparam == 1 && _dwPlatformId == VER_PLATFORM_WIN32_NT &&
				wparam > 256 && !fAltNumPad)
			{		
				// On WinNT s/w generated WM_CHAR, this should be WM_IME_CHAR message
				// for some Chinese Level 2 IME.
				if ( cpg == CP_CHINESE_SIM || cpg == CP_CHINESE_TRAD )
				{
					BYTE	bTrailByte = wparam >> 8;
					BYTE	bLeadByte = wparam;
					wparam =  (bLeadByte << 8) | bTrailByte;
					pwmci->_fIMEChar = true;
				}
			}
			return;

		case WM_GETTEXT:
			// EVIL HACK ALERT: on Win95, WM_GETTEXT should always be treated
			// as an ANSI message.
			pgt = (GETTEXTEX *) pvoid;
			pgt->cb = wparam;
			pgt->flags = GT_USECRLF;
			pgt->codepage = 0;
			pgt->lpDefaultChar = NULL;
			pgt->lpUsedDefChar = NULL;
			msg = EM_GETTEXTEX;
			wparam = (WPARAM) pgt;
			return;

		case WM_GETTEXTLENGTH:
			// EVIL HACK ALERT: on Win95, WM_GETEXTLENGTH should always
			// be treated an ANSI message because some old apps will send
			// this message to arbitrary windows (e.g., accessibility aps)
			pgtl = (GETTEXTLENGTHEX *) pvoid;
			pgtl->flags = GTL_NUMBYTES | GTL_PRECISE | GTL_USECRLF;
			pgtl->codepage = 0;
			msg = EM_GETTEXTLENGTHEX;
			wparam = (WPARAM) pgtl;
			return;
	}
}


HGLOBAL WINAPI CW32System::GlobalAlloc( UINT uFlags, DWORD dwBytes )
{
	return ::GlobalAlloc( uFlags, dwBytes );
}

HGLOBAL WINAPI CW32System::GlobalFree( HGLOBAL hMem )
{
	return hMem ? ::GlobalFree( hMem ) : NULL;
}

UINT WINAPI CW32System::GlobalFlags( HGLOBAL hMem )
{
	return ::GlobalFlags( hMem );
}

HGLOBAL WINAPI CW32System::GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags )
{
	return ::GlobalReAlloc( hMem, dwBytes, uFlags );
}

DWORD WINAPI CW32System::GlobalSize( HGLOBAL hMem )
{
	return ::GlobalSize( hMem );
}

LPVOID WINAPI CW32System::GlobalLock( HGLOBAL hMem )
{
	return ::GlobalLock( hMem );
}

HGLOBAL WINAPI CW32System::GlobalHandle( LPCVOID pMem )
{
	return ::GlobalHandle( pMem );
}

BOOL WINAPI CW32System::GlobalUnlock( HGLOBAL hMem )
{
	return ::GlobalUnlock( hMem );
}

/*
 *	CW32System::CheckChangeKeyboardLayout (bCharSet)
 *
 *	@mfunc
 *		Change keyboard for new charset, or charset at new character position.
 *
 *	@rdesc
 *		Keyboard hkl selected. 0 if failed to find keyboard
 *
 *	@comm
 *		Using only the currently loaded KBs, locate one that will support
 *		bCharSet. This is called anytime a character format	change occurs,
 *		or the caret position changes.
 *
 *	@devnote
 *		The current KB is preferred. If a previous association was made,
 *		see if the KB is still loaded in the system and if so use it.
 *		Otherwise, locate a suitable KB, preferring KB's that have
 *		the same charset ID as their default, preferred charset. If no
 *		match can be found, nothing changes.
 */
HKL CW32System::CheckChangeKeyboardLayout(
	BYTE bCharSet)
{
	return ActivateKeyboard(ScriptIndexFromCharSet(bCharSet));
}

HKL CW32System::GetKeyboardLayout (
	DWORD dwThreadID)
{
	if(dwThreadID == 0x0FFFFFFFF)
		RefreshKeyboardLayout();

	return _hklCurrent;
}

/*
 *	CW32System::RefreshKeyboardLayout ()
 *
 *	@mfunc
 *		Update _hklCurrent with current keyboard layout and update
 *		entry for corresponding script.
 */
void CW32System::RefreshKeyboardLayout ()
{
	INT iScript;

	_hklCurrent = ::GetKeyboardLayout(0);
	GetCharSet(ConvertLanguageIDtoCodePage(PRIMARYLANGID(_hklCurrent)), &iScript);
	SetPreferredKbd(iScript, _hklCurrent);
}

/*
 *	CW32System::ActivateKeyboard (iScript)
 *
 *	@mfunc
 *		Change keyboard to that for iScript
 *
 *	@rdesc
 *		Keyboard hkl selected. 0 if no keyboard assigned to iScript
 */
HKL CW32System::ActivateKeyboard(
	LONG iScript)
{
	HKL hkl = 0;
	if((unsigned)iScript < NCHARSETS)
	{
		hkl = GetPreferredKbd(iScript);

		if(hkl && hkl != _hklCurrent && ActivateKeyboardLayout(hkl, 0))
			_hklCurrent = hkl;
	}
	return hkl;
}

/*
 *	CW32System::FindDirectionalKeyboard (fRTL)
 *
 *	@mfunc
 *		Find first keyboard with direction given by fRTL
 *
 *	@rdesc
 *		HKL of keyboard selected. 0 if no keyboard for direction given by fRTL
 */
HKL CW32System::FindDirectionalKeyboard(
	BOOL fRTL)
{
	Assert(ARABIC_INDEX == (HEBREW_INDEX | 1));
	int iKB;

	if(fRTL)
	{
		GetCharSet(GetACP(), &iKB);
		if(!IN_RANGE(HEBREW_INDEX, iKB, ARABIC_INDEX))
			iKB = _hkl[HEBREW_INDEX] ? HEBREW_INDEX :
				  _hkl[ARABIC_INDEX] ? ARABIC_INDEX : -1;
	}
	else
		for(iKB = 0;
			iKB < NCHARSETS && (!_hkl[iKB] || IN_RANGE(HEBREW_INDEX, iKB, ARABIC_INDEX));
			iKB++)
				;
	return ActivateKeyboard(iKB);
}

enum DLL_ENUM{
	DLL_OLEAUT32,
	DLL_OLE32,
	
#ifndef NOACCESSIBILITY 
	DLL_ACC,
	DLL_USER32
#endif
};

static void SetProcAddr(
	void * & pfunc,
	DLL_ENUM which,
	char *	 fname )
{
	HINSTANCE hdll = NULL;
	EnterCriticalSection(&g_CriticalSection);
	if (pfunc == NULL)
	{
		switch (which)
		{
		case DLL_OLEAUT32:
			if (g_hOleAut32 == NULL)
				g_hOleAut32 = W32->LoadLibrary(L"oleaut32.dll" );

			hdll = g_hOleAut32;
			break;

		case DLL_OLE32:
			if (g_hOle32 == NULL)
			{
				g_hOle32 = W32->LoadLibrary(L"ole32.dll");
				CW32System::OleInitialize(NULL);
			}
			hdll = g_hOle32;
			break;

#ifndef NOACCESSIBILITY 
		case DLL_ACC:
			if (g_hAcc == NULL)
				g_hAcc = W32->LoadLibrary(L"oleacc.dll");
			hdll = g_hAcc;
			break;

		case DLL_USER32:
			if (g_hUser32 == NULL)
				g_hUser32 = W32->LoadLibrary(L"user32.dll");
			hdll = g_hUser32;
			break;
#endif			
		}
        Assert(hdll != NULL || which == DLL_USER32);
		pfunc = GetProcAddress( hdll, fname );
	}
	AssertSz(pfunc != NULL || which == DLL_USER32, fname);
 	LeaveCriticalSection(&g_CriticalSection);
}

void CW32System::FreeOle()
{
	if (g_hOleAut32 || g_hOle32) {
		EnterCriticalSection(&g_CriticalSection);
		if (g_hOleAut32 != NULL && FreeLibrary(g_hOleAut32)) {
			g_hOleAut32 = NULL;
			memset(&g_OleAut32Proc, 0, sizeof(g_OleAut32Proc));
		}
		if (g_hOle32 != NULL && FreeLibrary(g_hOle32)) {
			g_hOle32 = NULL;
			memset(&g_Ole32Proc, 0, sizeof(g_Ole32Proc));
		}
 		LeaveCriticalSection(&g_CriticalSection);
	}
}

enum IME_DLL_ENUM{
	DLL_IMM32,
	DLL_IMESHARE
};

static HINSTANCE hIMM32 = NULL;
static HINSTANCE hIMEShare = NULL;

static void SetIMEProcAddr( void * &pfunc, IME_DLL_ENUM which, char * fname )
{
	HINSTANCE hdll = NULL;
	EnterCriticalSection(&g_CriticalSection);
	if (pfunc == NULL)
	{
		switch (which) {
		case DLL_IMM32 :
			if (hIMM32 == NULL)
				hIMM32 = W32->LoadLibrary(L"imm32.dll" );
			Assert( hIMM32 != NULL );
			hdll = hIMM32;
			break;
		case DLL_IMESHARE :
			if (hIMEShare == NULL)
				hIMEShare = W32->LoadLibrary(L"imeshare.dll" );
			else if (hIMEShare == (HINSTANCE)INVALID_HANDLE_VALUE)
				goto Exit;

			hdll = hIMEShare;

			// set to invalid handle if we have tried loading it.
			// this is to avoid loading it again and again in case
			// imeshare.dll is not in the system.
			if (hIMEShare == NULL)
				hIMEShare = (HINSTANCE)INVALID_HANDLE_VALUE;

			break;
		}
		if (hdll)
		{
			pfunc = GetProcAddress( hdll, fname );
			Assert(pfunc != NULL );
		}
	}
Exit:
 	LeaveCriticalSection(&g_CriticalSection);
}

static IActiveIMMApp *pAIMM = (IActiveIMMApp *) NULL;

typedef IMESHAREAPI void (IMECDECL*FEND_CAST)(void);
void CW32System::FreeIME()
{
	if (hIMM32 || hIMEShare || pAIMM) {
		EnterCriticalSection(&g_CriticalSection);
		if (hIMM32 != NULL && FreeLibrary(hIMM32)) {
			hIMM32 = NULL;
			memset(&g_IMM32Proc, 0, sizeof(g_IMM32Proc));
		}
		if (hIMEShare != NULL && hIMEShare != (HINSTANCE)INVALID_HANDLE_VALUE) {
			// clean up IMMShare before leaving
			if ( _pIMEShare )
			{
				_pIMEShare->FDeleteIMEShare();
				_pIMEShare = NULL;
			}
			else
			{
				// This is old IMEShare, end it the old way
				void *pEndIMEShareFunc;
				pEndIMEShareFunc = GetProcAddress( hIMEShare, "EndIMEShare" );
				if (pEndIMEShareFunc)
				{
					( (FEND_CAST)pEndIMEShareFunc)();
				}
			}
			FreeLibrary(hIMEShare);
			hIMEShare = NULL;
			memset(&g_IMEShareProc, 0, sizeof(g_IMEShareProc));
		}
		if (pAIMM != (IActiveIMMApp *)NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
		{
			pAIMM->Release();
			pAIMM = (IActiveIMMApp *)NULL;
		}
		_fHaveAIMM = FALSE;
		_fHaveIMMEShare = FALSE;
		_fHaveIMMProcs = FALSE;
 		LeaveCriticalSection(&g_CriticalSection);
	}
}


// return TRUE if we load AIMM
BOOL CW32System::LoadAIMM()
{
	HRESULT	hResult;

	// return if AIMM has been loaded
	if (_fHaveAIMM)
		return TRUE;

	if (pAIMM == (IActiveIMMApp *)INVALID_HANDLE_VALUE)
		return FALSE;

	EnterCriticalSection(&g_CriticalSection);

	// load if it has not been loaded
	// Try with new W2K/COM+ CLSCTX_NO_CODE_DOWNLOAD flag
	hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM,
		NULL, CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD, IID_IActiveIMMApp, (LPVOID *)&pAIMM);

	if (hResult == E_INVALIDARG)	// Try again if CLSCTX_NO_CODE_DOWNLOAD not support
		hResult = CW32System::CoCreateInstance(CLSID_CActiveIMM,
			NULL, CLSCTX_INPROC_SERVER, IID_IActiveIMMApp, (LPVOID *)&pAIMM);

	_fHaveAIMM = TRUE;
	if (FAILED(hResult))
	{	
		_fHaveAIMM = FALSE;
		pAIMM = (IActiveIMMApp *)INVALID_HANDLE_VALUE;	
	}
	LeaveCriticalSection(&g_CriticalSection);

	return _fHaveAIMM;
}

// Return the Aimm object and AddRef()
BOOL CW32System::GetAimmObject(IUnknown **ppAimm)
{

	*ppAimm = NULL;

	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		pAIMM->AddRef();
		*ppAimm = pAIMM;
		return TRUE;
	}

	return FALSE;
}


// return TRUE if we have IMEShare in system
// else return FALSE

typedef IMESHAREAPI BOOL (IMECDECL*FINIT_CAST)(void);
typedef IMESHAREAPI CIMEShare *  (IMECDECL*FPIME_CAST)(void);
BOOL CW32System::HaveIMEShare()
{
	// return if IMEShare has been loaded
	if (_fHaveIMMEShare)
		return TRUE;

	if (hIMEShare == (HINSTANCE)INVALID_HANDLE_VALUE)
		return FALSE;

	EnterCriticalSection(&g_CriticalSection);

	// load if it has not been loaded
	hIMEShare = W32->LoadLibrary(L"imeshare.dll");
	
	_fHaveIMMEShare = TRUE;
	// load fail, setup INVALID_HANDLE_VALUE
	if (hIMEShare == NULL)
	{
		hIMEShare = (HINSTANCE)INVALID_HANDLE_VALUE;
		_fHaveIMMEShare = FALSE;
	}
	else
	{
		// get the new IMEshare object and init the DLL
		void *pPIMEShareCreate;
		pPIMEShareCreate = GetProcAddress( hIMEShare, "PIMEShareCreate" );

		if (pPIMEShareCreate)
		{
			_pIMEShare = ( (FPIME_CAST)pPIMEShareCreate) ();
			
			if ( _pIMEShare == NULL )
				_fHaveIMMEShare = FALSE;
			else
			{
				// Setup underline styles that RE supports
				for (int i = IMESTY_UL_MIN; i <= IMESTY_UL_MAX; i++)
				{
					if (i == 2004 || i == 2007 || i == 2008 ||
						i == 2009 || i == 2010)			// Obsolete styles
						continue;
    
					_pIMEShare->FSupportSty(i, i);
				}
			}
		}
		else
		{
			// This is old IMEShare, init it the old way
			void *pInitFunc;
			pInitFunc = GetProcAddress( hIMEShare, "FInitIMEShare" );
			if (pInitFunc)
			{
				_fHaveIMMEShare = ( (FINIT_CAST)pInitFunc)();
			}
			else
				// init failed, forget it
				_fHaveIMMEShare = FALSE;
		}

		if (_fHaveIMMEShare == FALSE)
		{
			// Init failed, forget it
			FreeLibrary(hIMEShare);
			hIMEShare = (HINSTANCE)INVALID_HANDLE_VALUE;
		}
	}
	
	LeaveCriticalSection(&g_CriticalSection);

	return _fHaveIMMEShare;
}

BOOL CW32System::getIMEShareObject(CIMEShare **ppIMEShare)
{
	*ppIMEShare = _pIMEShare;

	return (_pIMEShare != NULL);
}

HRESULT CW32System::AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		LRESULT	localLRes;

		hResult = pAIMM->OnDefWindowProc(hWnd, msg, wparam, lparam, &localLRes);

		if (hResult == S_OK)
		{
			*plres = localLRes;
			return S_OK;
		}
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMGetCodePage(HKL hKL, UINT *uCodePage)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->GetCodePageA(hKL, uCodePage);

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMActivate(BOOL fRestoreLayout)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->Activate(fRestoreLayout);

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMDeactivate(void)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->Deactivate();

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

HRESULT CW32System::AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize)
{
	if (pAIMM != NULL && pAIMM != (IActiveIMMApp *)INVALID_HANDLE_VALUE)
	{
		HRESULT hResult;
		hResult = pAIMM->FilterClientWindows(aaClassList, uSize);

		if (SUCCEEDED(hResult))
			return S_OK;
	}
	return S_FALSE;
}

#define RE_OLEAUTAPI(name) 		DECLSPEC_IMPORT HRESULT (STDAPICALLTYPE *name)
#define RE_OLEAUTAPI_(type, name) 	DECLSPEC_IMPORT type (STDAPICALLTYPE *name)

typedef RE_OLEAUTAPI(LRTL_CAST)(REFGUID, WORD, WORD, LCID, ITypeLib **);
HRESULT CW32System::LoadRegTypeLib (
	REFGUID rguid,
	WORD wmajor,
	WORD wminor,
	LCID lcid,
	ITypeLib ** pptlib
)
{
	if (g_OleAut32Proc.LoadRegTypeLib == NULL)
		SetProcAddr( g_OleAut32Proc.LoadRegTypeLib, DLL_OLEAUT32, "LoadRegTypeLib" );
	return ((LRTL_CAST)g_OleAut32Proc.LoadRegTypeLib)(rguid, wmajor, wminor, lcid, pptlib);
}

typedef RE_OLEAUTAPI(LTL_CAST)(const OLECHAR *, ITypeLib **);
HRESULT CW32System::LoadTypeLib ( const OLECHAR *szfile, ITypeLib **pptlib )
{
	if (g_OleAut32Proc.LoadTypeLib == NULL)
		SetProcAddr( g_OleAut32Proc.LoadTypeLib, DLL_OLEAUT32, "LoadTypeLib" );
	return ((LTL_CAST)g_OleAut32Proc.LoadTypeLib)(szfile, pptlib);
}

typedef RE_OLEAUTAPI(LTLEX_CAST)(const OLECHAR *, REGKIND, ITypeLib **);
HRESULT CW32System::LoadTypeLibEx ( const OLECHAR *szfile, REGKIND regkind, ITypeLib **pptlib )
{
	if (g_OleAut32Proc.LoadTypeLibEx == NULL)
		SetProcAddr( g_OleAut32Proc.LoadTypeLibEx, DLL_OLEAUT32, "LoadTypeLibEx" );

	return ((LTLEX_CAST)g_OleAut32Proc.LoadTypeLibEx)(szfile, regkind, pptlib);
}

typedef RE_OLEAUTAPI_(BSTR, SAS_CAST)(const OLECHAR *);
BSTR CW32System::SysAllocString ( const OLECHAR * sz )
{
	if (g_OleAut32Proc.SysAllocString == NULL)
		SetProcAddr( g_OleAut32Proc.SysAllocString, DLL_OLEAUT32, "SysAllocString" );
	return ((SAS_CAST)g_OleAut32Proc.SysAllocString)(sz);
}

typedef RE_OLEAUTAPI_(BSTR, SASL_CAST)(const OLECHAR *, UINT);
BSTR CW32System::SysAllocStringLen ( const OLECHAR *pch, UINT cch )
{
	if (g_OleAut32Proc.SysAllocStringLen == NULL)
		SetProcAddr( g_OleAut32Proc.SysAllocStringLen, DLL_OLEAUT32, "SysAllocStringLen" );
	return ((SASL_CAST)g_OleAut32Proc.SysAllocStringLen)(pch, cch);
}

typedef RE_OLEAUTAPI_(void, SFS_CAST)(BSTR);
void CW32System::SysFreeString ( BSTR bstr )
{
	if (g_OleAut32Proc.SysFreeString == NULL)
		SetProcAddr( g_OleAut32Proc.SysFreeString, DLL_OLEAUT32, "SysFreeString" );
	((SFS_CAST)g_OleAut32Proc.SysFreeString)(bstr);
}

typedef RE_OLEAUTAPI_(UINT, SSL_CAST)(BSTR);
UINT CW32System::SysStringLen ( BSTR bstr )
{
	if (g_OleAut32Proc.SysStringLen == NULL)
		SetProcAddr( g_OleAut32Proc.SysStringLen, DLL_OLEAUT32, "SysStringLen" );
	return ((SSL_CAST)g_OleAut32Proc.SysStringLen)(bstr);
}

typedef RE_OLEAUTAPI_(void, VI_CAST)(VARIANTARG *);
void CW32System::VariantInit ( VARIANTARG * pvarg )
{
	if (g_OleAut32Proc.VariantInit == NULL)
		SetProcAddr( g_OleAut32Proc.VariantInit, DLL_OLEAUT32, "VariantInit" );
	((VI_CAST)g_OleAut32Proc.VariantInit)(pvarg);
}

#define RE_OLE32API(name)		DECLSPEC_IMPORT	HRESULT (STDAPICALLTYPE *name)
#define RE_OLE32API_(type, name) DECLSPEC_IMPORT type (STDAPICALLTYPE *name)

typedef RE_OLE32API(OCFD_CAST)(LPDATAOBJECT, REFIID, DWORD, 
							   LPFORMATETC, LPOLECLIENTSITE,
							   LPSTORAGE, void **);
HRESULT CW32System::OleCreateFromData (
	LPDATAOBJECT pDataObj,
	REFIID riid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	LPOLECLIENTSITE pClientSite,
	LPSTORAGE pStg,
	void **ppvObj
)
{
	if (g_Ole32Proc.OleCreateFromData == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateFromData, DLL_OLE32, "OleCreateFromData" );
	return ((OCFD_CAST)g_Ole32Proc.OleCreateFromData)(pDataObj, riid, renderopt, pfetc, pClientSite, pStg, ppvObj);
}

typedef RE_OLE32API_(void, CTMF_CAST)(LPVOID);
void CW32System::CoTaskMemFree ( LPVOID pv )
{
	if (g_Ole32Proc.CoTaskMemFree == NULL)
		SetProcAddr( g_Ole32Proc.CoTaskMemFree, DLL_OLE32, "CoTaskMemFree" );
	((CTMF_CAST)g_Ole32Proc.CoTaskMemFree)(pv);
}

typedef RE_OLE32API(CBC_CAST)(DWORD, LPBC *);
HRESULT CW32System::CreateBindCtx ( DWORD reserved, LPBC * ppbc )
{
	if (g_Ole32Proc.CreateBindCtx == NULL)
		SetProcAddr( g_Ole32Proc.CreateBindCtx, DLL_OLE32, "CreateBindCtx" );
	return ((CBC_CAST)g_Ole32Proc.CreateBindCtx)(reserved, ppbc);
}

typedef RE_OLE32API_(HANDLE, ODD_CAST)(HANDLE, CLIPFORMAT, UINT);
HANDLE CW32System::OleDuplicateData ( HANDLE hSrc, CLIPFORMAT cfFormat, UINT uFlags )
{
	if (g_Ole32Proc.OleDuplicateData == NULL)
		SetProcAddr( g_Ole32Proc.OleDuplicateData, DLL_OLE32, "OleDuplicateData" );
	return ((ODD_CAST)g_Ole32Proc.OleDuplicateData)(hSrc, cfFormat, uFlags);
}

typedef RE_OLE32API(CTAC_CAST)(REFCLSID, REFCLSID);
HRESULT CW32System::CoTreatAsClass ( REFCLSID clsidold, REFCLSID clsidnew )
{
	if (g_Ole32Proc.CoTreatAsClass == NULL)
		SetProcAddr( g_Ole32Proc.CoTreatAsClass, DLL_OLE32, "CoTreatAsClass" );
	return ((CTAC_CAST)g_Ole32Proc.CoTreatAsClass)(clsidold, clsidnew);
}

typedef RE_OLE32API(PIFC_CAST)(REFCLSID, LPOLESTR *);
HRESULT CW32System::ProgIDFromCLSID ( REFCLSID clsid, LPOLESTR * lplpszProgId )
{
	if (g_Ole32Proc.ProgIDFromCLSID == NULL)
		SetProcAddr( g_Ole32Proc.ProgIDFromCLSID, DLL_OLE32, "ProgIDFromCLSID" );
	return ((PIFC_CAST)g_Ole32Proc.ProgIDFromCLSID)(clsid, lplpszProgId);
}

typedef RE_OLE32API(OCITO_CAST)(LPSTORAGE, LPOLESTREAM);
HRESULT CW32System::OleConvertIStorageToOLESTREAM ( LPSTORAGE pstg, LPOLESTREAM lpolestream)
{
	if (g_Ole32Proc.OleConvertIStorageToOLESTREAM == NULL)
		SetProcAddr( g_Ole32Proc.OleConvertIStorageToOLESTREAM, DLL_OLE32, "OleConvertIStorageToOLESTREAM" );
	return ((OCITO_CAST)g_Ole32Proc.OleConvertIStorageToOLESTREAM)(pstg, lpolestream);
}

typedef RE_OLE32API(OCITOX_CAST)(LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM);
HRESULT CW32System::OleConvertIStorageToOLESTREAMEx (
	LPSTORAGE pstg,
	CLIPFORMAT cf,
	LONG lwidth,
	LONG lheight,
	DWORD dwsize,
	LPSTGMEDIUM pmedium,
	LPOLESTREAM lpolestream
)
{
	if (g_Ole32Proc.OleConvertIStorageToOLESTREAMEx == NULL)
		SetProcAddr( g_Ole32Proc.OleConvertIStorageToOLESTREAMEx, DLL_OLE32, "OleConvertIStorageToOLESTREAMEx" );
	return ((OCITOX_CAST)g_Ole32Proc.OleConvertIStorageToOLESTREAMEx)
		(pstg,cf, lwidth, lheight, dwsize, pmedium, lpolestream);
}

typedef RE_OLE32API(OS_CAST)(LPPERSISTSTORAGE, LPSTORAGE, BOOL);
HRESULT CW32System::OleSave ( LPPERSISTSTORAGE pPS, LPSTORAGE pstg, BOOL fSameAsLoad )
{
	if (g_Ole32Proc.OleSave == NULL)
		SetProcAddr( g_Ole32Proc.OleSave, DLL_OLE32, "OleSave" );
	return ((OS_CAST)g_Ole32Proc.OleSave)(pPS, pstg, fSameAsLoad);
}

typedef RE_OLE32API(SCDOI_CAST)(ILockBytes *, DWORD, DWORD, IStorage **);
HRESULT CW32System::StgCreateDocfileOnILockBytes (
	ILockBytes *plkbyt,
	DWORD grfmode,
	DWORD res,
	IStorage **ppstg
)
{
	if (g_Ole32Proc.StgCreateDocfileOnILockBytes == NULL)
		SetProcAddr( g_Ole32Proc.StgCreateDocfileOnILockBytes, DLL_OLE32, "StgCreateDocfileOnILockBytes" );
	return ((SCDOI_CAST)g_Ole32Proc.StgCreateDocfileOnILockBytes)(plkbyt, grfmode, res, ppstg);
}

typedef RE_OLE32API(CIOH_CAST)(HGLOBAL, BOOL, ILockBytes **);
HRESULT CW32System::CreateILockBytesOnHGlobal ( HGLOBAL hGlobal, BOOL fDel, ILockBytes **pplkbyt )
{
	if (g_Ole32Proc.CreateILockBytesOnHGlobal == NULL)
		SetProcAddr( g_Ole32Proc.CreateILockBytesOnHGlobal, DLL_OLE32, "CreateILockBytesOnHGlobal" );
	return ((CIOH_CAST)g_Ole32Proc.CreateILockBytesOnHGlobal)(hGlobal, fDel, pplkbyt);
}

typedef RE_OLE32API(OCLTF_CAST)(LPCOLESTR, REFIID, DWORD, LPFORMATETC,
								LPOLECLIENTSITE, LPSTORAGE, void **);
HRESULT CW32System::OleCreateLinkToFile( 
	LPCOLESTR pstr,
	REFIID rid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	LPOLECLIENTSITE psite,
	LPSTORAGE pstg, 
	void **ppstg
)
{
	if (g_Ole32Proc.OleCreateLinkToFile == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateLinkToFile, DLL_OLE32, "OleCreateLinkToFile" );
	return ((OCLTF_CAST)g_Ole32Proc.OleCreateLinkToFile)(pstr, rid, renderopt, pfetc, psite, pstg, ppstg);
}

typedef RE_OLE32API_(LPVOID, CTMA_CAST)(ULONG);
LPVOID CW32System::CoTaskMemAlloc ( ULONG cb )
{
	if (g_Ole32Proc.CoTaskMemAlloc == NULL)
		SetProcAddr( g_Ole32Proc.CoTaskMemAlloc, DLL_OLE32, "CoTaskMemAlloc" );
	return ((CTMA_CAST)g_Ole32Proc.CoTaskMemAlloc)(cb);
}

typedef RE_OLE32API_(LPVOID, CTMR_CAST)(LPVOID, ULONG);
LPVOID CW32System::CoTaskMemRealloc ( LPVOID pv, ULONG cv)
{
	if (g_Ole32Proc.CoTaskMemRealloc == NULL)
		SetProcAddr( g_Ole32Proc.CoTaskMemRealloc, DLL_OLE32, "CoTaskMemRealloc" );
	return ((CTMR_CAST)g_Ole32Proc.CoTaskMemRealloc)(pv, cv);
}

typedef RE_OLE32API(OI_CAST)(LPVOID);
HRESULT CW32System::OleInitialize ( LPVOID pvres )
{
	if (g_Ole32Proc.OleInitialize == NULL)
		SetProcAddr( g_Ole32Proc.OleInitialize, DLL_OLE32, "OleInitialize" );
	return ((OI_CAST)g_Ole32Proc.OleInitialize)(pvres);
}

typedef RE_OLE32API_(void, OUI_CAST)( void );
void CW32System::OleUninitialize ( void )
{
	if (g_Ole32Proc.OleUninitialize == NULL)
		SetProcAddr( g_Ole32Proc.OleUninitialize, DLL_OLE32, "OleUninitialize" );
	((OUI_CAST)g_Ole32Proc.OleUninitialize)();
}

typedef RE_OLE32API(OSC_CAST)(IDataObject *);
HRESULT CW32System::OleSetClipboard ( IDataObject *pdo )
{
	if (g_Ole32Proc.OleSetClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleSetClipboard, DLL_OLE32, "OleSetClipboard" );
	return ((OSC_CAST)g_Ole32Proc.OleSetClipboard)(pdo);
}

typedef RE_OLE32API(OFC_CAST)(void);
HRESULT CW32System::OleFlushClipboard ( void )
{
	if (g_Ole32Proc.OleFlushClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleFlushClipboard, DLL_OLE32, "OleFlushClipboard" );
	return ((OFC_CAST)g_Ole32Proc.OleFlushClipboard)();
}

typedef RE_OLE32API(OICC_CAST)(IDataObject *);
HRESULT CW32System::OleIsCurrentClipboard ( IDataObject *pdo )
{
	if (g_Ole32Proc.OleIsCurrentClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleIsCurrentClipboard, DLL_OLE32, "OleIsCurrentClipboard" );
	return ((OICC_CAST)g_Ole32Proc.OleIsCurrentClipboard)(pdo);
}

typedef RE_OLE32API(DDD_CAST)(IDataObject *, IDropSource *,
			DWORD, DWORD *);
HRESULT CW32System::DoDragDrop ( IDataObject *pdo, IDropSource *pds, DWORD dweffect, DWORD *pdweffect )
{
	if (g_Ole32Proc.DoDragDrop == NULL)
		SetProcAddr( g_Ole32Proc.DoDragDrop, DLL_OLE32, "DoDragDrop" );
	return ((DDD_CAST)g_Ole32Proc.DoDragDrop)(pdo, pds, dweffect, pdweffect);
}

typedef RE_OLE32API(OGC_CAST)(IDataObject **);
HRESULT CW32System::OleGetClipboard ( IDataObject **ppdo )
{
	if (g_Ole32Proc.OleGetClipboard == NULL)
		SetProcAddr( g_Ole32Proc.OleGetClipboard, DLL_OLE32, "OleGetClipboard" );
	return ((OGC_CAST)g_Ole32Proc.OleGetClipboard)(ppdo);
}

typedef RE_OLE32API(RDD_CAST)(HWND, IDropTarget *);
HRESULT CW32System::RegisterDragDrop ( HWND hwnd, IDropTarget *pdt )
{
	if (g_Ole32Proc.RegisterDragDrop == NULL)
		SetProcAddr( g_Ole32Proc.RegisterDragDrop, DLL_OLE32, "RegisterDragDrop" );
	return ((RDD_CAST)g_Ole32Proc.RegisterDragDrop)(hwnd, pdt);
}

typedef RE_OLE32API(OCLFD_CAST)(IDataObject *, REFIID, DWORD,
								LPFORMATETC, IOleClientSite *,
								IStorage *, void **);
HRESULT CW32System::OleCreateLinkFromData (
	IDataObject *pdo,
	REFIID rid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	IOleClientSite *psite,
	IStorage *pstg,
	void **ppv
)
{
	if (g_Ole32Proc.OleCreateLinkFromData == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateLinkFromData, DLL_OLE32, "OleCreateLinkFromData" );
	return ((OCLFD_CAST)g_Ole32Proc.OleCreateLinkFromData)
		(pdo, rid, renderopt, pfetc, psite, pstg, ppv);
}

typedef RE_OLE32API(OCSFD_CAST)(IDataObject *, REFIID, DWORD,
								LPFORMATETC, IOleClientSite *,
								IStorage *, void **);
HRESULT CW32System::OleCreateStaticFromData (
	IDataObject *pdo,
	REFIID rid,
	DWORD renderopt,
	LPFORMATETC pfetc,
	IOleClientSite *psite,
	IStorage *pstg,
	void **ppv
)
{
	if (g_Ole32Proc.OleCreateStaticFromData == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateStaticFromData, DLL_OLE32, "OleCreateStaticFromData" );
	return ((OCSFD_CAST)g_Ole32Proc.OleCreateStaticFromData)
		(pdo, rid, renderopt, pfetc, psite, pstg, ppv);
}

typedef RE_OLE32API(OD_CAST)(IUnknown *, DWORD, HDC, LPCRECT);
HRESULT CW32System::OleDraw ( IUnknown *punk, DWORD dwAspect, HDC hdc, LPCRECT prect )
{
	if (g_Ole32Proc.OleDraw == NULL)
		SetProcAddr( g_Ole32Proc.OleDraw, DLL_OLE32, "OleDraw" );
	return ((OD_CAST)g_Ole32Proc.OleDraw)(punk, dwAspect, hdc, prect);
}

typedef RE_OLE32API(OSCO_CAST)(IUnknown *, BOOL);
HRESULT CW32System::OleSetContainedObject ( IUnknown *punk, BOOL fContained )
{
	if (g_Ole32Proc.OleSetContainedObject == NULL)
		SetProcAddr( g_Ole32Proc.OleSetContainedObject, DLL_OLE32, "OleSetContainedObject" );
	return ((OSCO_CAST)g_Ole32Proc.OleSetContainedObject)(punk, fContained);
}

typedef RE_OLE32API(CDO_CAST)(IUnknown *, DWORD);
HRESULT CW32System::CoDisconnectObject ( IUnknown *punk, DWORD dwres )
{
	if (g_Ole32Proc.CoDisconnectObject == NULL)
		SetProcAddr( g_Ole32Proc.CoDisconnectObject, DLL_OLE32, "CoDisconnectObject" );
	return ((CDO_CAST)g_Ole32Proc.CoDisconnectObject)(punk, dwres);
}

typedef RE_OLE32API(WFUTS_CAST)(IStorage *, CLIPFORMAT, LPOLESTR);
HRESULT CW32System::WriteFmtUserTypeStg ( IStorage *pstg, CLIPFORMAT cf, LPOLESTR pstr)
{
	if (g_Ole32Proc.WriteFmtUserTypeStg == NULL)
		SetProcAddr( g_Ole32Proc.WriteFmtUserTypeStg, DLL_OLE32, "WriteFmtUserTypeStg" );
	return ((WFUTS_CAST)g_Ole32Proc.WriteFmtUserTypeStg)(pstg, cf, pstr);
}

typedef RE_OLE32API(WCS_CAST)(IStorage *, REFCLSID);
HRESULT CW32System::WriteClassStg ( IStorage *pstg, REFCLSID rid )
{
	if (g_Ole32Proc.WriteClassStg == NULL)
		SetProcAddr( g_Ole32Proc.WriteClassStg, DLL_OLE32, "WriteClassStg" );
	return ((WCS_CAST)g_Ole32Proc.WriteClassStg)(pstg, rid);
}

typedef RE_OLE32API(SCS_CAST)(IStorage *, BOOL);
HRESULT CW32System::SetConvertStg ( IStorage *pstg, BOOL fConv )
{
	if (g_Ole32Proc.SetConvertStg == NULL)
		SetProcAddr( g_Ole32Proc.SetConvertStg, DLL_OLE32, "SetConvertStg" );
	return ((SCS_CAST)g_Ole32Proc.SetConvertStg)(pstg, fConv);
}

typedef RE_OLE32API(RFUTS_CAST)(IStorage *, CLIPFORMAT *, LPOLESTR *);
HRESULT CW32System::ReadFmtUserTypeStg ( IStorage *pstg, CLIPFORMAT *pcf, LPOLESTR *pstr )
{
	if (g_Ole32Proc.ReadFmtUserTypeStg == NULL)
		SetProcAddr( g_Ole32Proc.ReadFmtUserTypeStg, DLL_OLE32, "ReadFmtUserTypeStg" );
	return ((RFUTS_CAST)g_Ole32Proc.ReadFmtUserTypeStg)(pstg, pcf, pstr);
}

typedef RE_OLE32API(RCS_CAST)(IStorage *, CLSID *);
HRESULT CW32System::ReadClassStg ( IStorage *pstg, CLSID *pclsid )
{
	if (g_Ole32Proc.ReadClassStg == NULL)
		SetProcAddr( g_Ole32Proc.ReadClassStg, DLL_OLE32, "ReadClassStg" );
	return ((RCS_CAST)g_Ole32Proc.ReadClassStg)(pstg, pclsid);
}

typedef RE_OLE32API(OR_CAST)(IUnknown *);
HRESULT CW32System::OleRun ( IUnknown *punk )
{
	if (g_Ole32Proc.OleRun == NULL)
		SetProcAddr( g_Ole32Proc.OleRun, DLL_OLE32, "OleRun" );
	return ((OR_CAST)g_Ole32Proc.OleRun)(punk);
}

typedef RE_OLE32API(RevDD_CAST)(HWND);
HRESULT CW32System::RevokeDragDrop ( HWND hwnd )
{
	if (g_Ole32Proc.RevokeDragDrop == NULL)
		SetProcAddr( g_Ole32Proc.RevokeDragDrop, DLL_OLE32, "RevokeDragDrop" );
	return ((RevDD_CAST)g_Ole32Proc.RevokeDragDrop)(hwnd);
}

typedef RE_OLE32API(CSOH_CAST)(HGLOBAL, BOOL, IStream **);
HRESULT CW32System::CreateStreamOnHGlobal ( HGLOBAL hglobal, BOOL fDel, IStream **ppstrm )
{
	if (g_Ole32Proc.CreateStreamOnHGlobal == NULL)
		SetProcAddr( g_Ole32Proc.CreateStreamOnHGlobal, DLL_OLE32, "CreateStreamOnHGlobal" );
	return ((CSOH_CAST)g_Ole32Proc.CreateStreamOnHGlobal)(hglobal, fDel, ppstrm);
}

typedef RE_OLE32API(GHFS_CAST)(IStream *, HGLOBAL *);
HRESULT CW32System::GetHGlobalFromStream ( IStream *pstrm, HGLOBAL *phglobal )
{
	if (g_Ole32Proc.GetHGlobalFromStream == NULL)
		SetProcAddr( g_Ole32Proc.GetHGlobalFromStream, DLL_OLE32, "GetHGlobalFromStream" );
	return ((GHFS_CAST)g_Ole32Proc.GetHGlobalFromStream)(pstrm, phglobal);
}

typedef RE_OLE32API(OCDH_CAST)(REFCLSID, IUnknown *, REFIID, void **);
HRESULT CW32System::OleCreateDefaultHandler (
	REFCLSID clsid,
	IUnknown *punk,
	REFIID riid,
	void **ppv
)
{
	if (g_Ole32Proc.OleCreateDefaultHandler == NULL)
		SetProcAddr( g_Ole32Proc.OleCreateDefaultHandler, DLL_OLE32, "OleCreateDefaultHandler" );
	return ((OCDH_CAST)g_Ole32Proc.OleCreateDefaultHandler)(clsid, punk, riid, ppv);
}

typedef RE_OLE32API(CFPI_CAST)(LPCOLESTR, LPCLSID);
HRESULT CW32System::CLSIDFromProgID ( LPCOLESTR pstr, LPCLSID pclsid )
{
	if (g_Ole32Proc.CLSIDFromProgID == NULL)
		SetProcAddr( g_Ole32Proc.CLSIDFromProgID, DLL_OLE32, "CLSIDFromProgID" );
	return ((CFPI_CAST)g_Ole32Proc.CLSIDFromProgID)(pstr, pclsid);
}

typedef RE_OLE32API(OCOTI_CAST)(LPOLESTREAM, IStorage *, 
								const DVTARGETDEVICE *);
HRESULT CW32System::OleConvertOLESTREAMToIStorage (
	LPOLESTREAM pstrm,
	IStorage *pstg,
	const DVTARGETDEVICE *ptd
)
{
	if (g_Ole32Proc.OleConvertOLESTREAMToIStorage == NULL)
		SetProcAddr( g_Ole32Proc.OleConvertOLESTREAMToIStorage, DLL_OLE32, "OleConvertOLESTREAMToIStorage" );
	return ((OCOTI_CAST)g_Ole32Proc.OleConvertOLESTREAMToIStorage)(pstrm, pstg, ptd);
}

typedef RE_OLE32API(OL_CAST)(IStorage *, REFIID, IOleClientSite *, void **);
HRESULT CW32System::OleLoad ( 
	IStorage *pstg,
	REFIID riid,
	IOleClientSite *psite,
	void **ppv
)
{
	if (g_Ole32Proc.OleLoad == NULL)
		SetProcAddr( g_Ole32Proc.OleLoad, DLL_OLE32, "OleLoad" );
	return ((OL_CAST)g_Ole32Proc.OleLoad)(pstg, riid, psite, ppv);
}

typedef RE_OLE32API(RSM_CAST)(LPSTGMEDIUM);
HRESULT CW32System::ReleaseStgMedium ( LPSTGMEDIUM pmedium )
{
	if (g_Ole32Proc.ReleaseStgMedium == NULL)
		SetProcAddr( g_Ole32Proc.ReleaseStgMedium, DLL_OLE32, "ReleaseStgMedium" );
	return ((RSM_CAST)g_Ole32Proc.ReleaseStgMedium)(pmedium);
}

typedef RE_OLE32API(CCI_CAST)(REFCLSID, LPUNKNOWN, DWORD, REFIID, LPVOID);
HRESULT CW32System::CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
		DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
	if (g_Ole32Proc.CoCreateInstance == NULL)
		SetProcAddr( g_Ole32Proc.CoCreateInstance, DLL_OLE32, "CoCreateInstance" );
	return ((CCI_CAST)g_Ole32Proc.CoCreateInstance)(rclsid, pUnknown, dwClsContext, riid, ppv);
}

BOOL CW32System::ImmInitialize( void )
{
	// MAC Only function.
	return FALSE;
}

void CW32System::ImmTerminate( void )
{
	// MAC only function.
	return;
}

#ifndef NOACCESSIBILITY

typedef HRESULT (WINAPI *ACC_VC_CAST)(VARIANTARG FAR*, VARIANTARG FAR*);
HRESULT CW32System::VariantCopy(VARIANTARG FAR*  pvargDest, VARIANTARG FAR*  pvargSrc)
{
    static void *pVariantCopy = NULL;
	if (pVariantCopy == NULL)
		SetProcAddr( pVariantCopy, DLL_OLEAUT32, "VariantCopy" );
	if (pVariantCopy)
		return ((ACC_VC_CAST)pVariantCopy)(pvargDest, pvargSrc);

    return (E_NOINTERFACE);
}

typedef LRESULT (WINAPI *ACC_LFO_CAST)(REFIID, WPARAM, LPUNKNOWN);
LRESULT CW32System::LResultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk)
{
	static void *pLResultFromObject = NULL;
	if (pLResultFromObject == NULL)
		SetProcAddr( pLResultFromObject, DLL_ACC, "LresultFromObject" );
	if (pLResultFromObject)
		return ((ACC_LFO_CAST)pLResultFromObject)(riid, wParam, punk);
	return E_NOINTERFACE;
}

typedef HRESULT (WINAPI *ACC_AOFW_CAST)(HWND, DWORD, REFIID, void **);
HRESULT CW32System::AccessibleObjectFromWindow (HWND hWnd, DWORD dwID, REFIID riidInterface, void ** ppvObject)
{
    static void *pAccessibleObjectFromWindow = NULL;
	if (pAccessibleObjectFromWindow == NULL)
		SetProcAddr( pAccessibleObjectFromWindow, DLL_ACC, "AccessibleObjectFromWindow" );
	if (pAccessibleObjectFromWindow)
		return ((ACC_AOFW_CAST)pAccessibleObjectFromWindow)(hWnd, dwID, riidInterface, ppvObject);
    return (E_NOINTERFACE);
}

typedef BOOL (WINAPI *ACC_BI_CAST)(BOOL);
BOOL CW32System::BlockInput (BOOL fBlock)
{
    static void *pBlockInput = NULL;
	if (pBlockInput == NULL)
		SetProcAddr( pBlockInput, DLL_USER32, "BlockInput" );
	if (pBlockInput)
		return ((ACC_BI_CAST)pBlockInput)(fBlock);

    return FALSE;
}

typedef UINT (WINAPI *ACC_SI_CAST)(UINT, LPINPUT, int);
UINT CW32System::SendInput (UINT nInputs, LPINPUT pInputs, int cbSize)
{
    static void *pSendInput = NULL;
	if (pSendInput == NULL)
		SetProcAddr( pSendInput, DLL_USER32, "SendInput" );
	if (pSendInput)
		return ((ACC_SI_CAST)pSendInput)(nInputs, pInputs, cbSize);

    return 0;
}

typedef VOID (WINAPI *ACC_NWE_CAST)(DWORD, HWND, LONG, LONG);
VOID CW32System::NotifyWinEvent(DWORD dwEvent, HWND hWnd, LONG lObjectType, LONG lObjectId)
{
	static void *pNotfiyWinEvent = NULL;
	if (pNotfiyWinEvent == INVALID_HANDLE_VALUE)
		return;

	if (pNotfiyWinEvent == NULL)
		SetProcAddr( pNotfiyWinEvent, DLL_USER32, "NotifyWinEvent" );
	if (pNotfiyWinEvent)
		((ACC_NWE_CAST)pNotfiyWinEvent)(dwEvent, hWnd, lObjectType, lObjectId);
	else 
		pNotfiyWinEvent = INVALID_HANDLE_VALUE;

}

#endif

typedef LONG (WINAPI*IGCSA_CAST)(HIMC, DWORD, LPVOID, DWORD);
LONG CW32System::ImmGetCompositionStringA ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPVOID lpBuf, 
	DWORD dwBufLen,
	BOOL bAimmActivated)
{	
	if (bAimmActivated)
	{
		HRESULT hResult;
		LONG	lCopied = 0;
	
		hResult = pAIMM->GetCompositionStringA(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);
				
		return (SUCCEEDED(hResult) ? lCopied : 0);
	}

	if (g_IMM32Proc.ImmGetCompositionStringA == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetCompositionStringA, DLL_IMM32, "ImmGetCompositionStringA" );
	return ((IGCSA_CAST)g_IMM32Proc.ImmGetCompositionStringA)(hIMC, dwIndex, lpBuf, dwBufLen);
}

typedef LONG (WINAPI*IGCSW_CAST)(HIMC, DWORD, LPVOID, DWORD);
LONG CW32System::ImmGetCompositionStringW ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPVOID lpBuf, 
	DWORD dwBufLen,
	BOOL bAimmActivated)
{	
	if (bAimmActivated)
	{
		HRESULT hResult;
		LONG	lCopied = 0;
	
		hResult = pAIMM->GetCompositionStringW(hIMC, dwIndex, dwBufLen, &lCopied, lpBuf);
				
		return (SUCCEEDED(hResult) ? lCopied : 0);
	}

	if (g_IMM32Proc.ImmGetCompositionStringW == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetCompositionStringW, DLL_IMM32, "ImmGetCompositionStringW" );
	return ((IGCSW_CAST)g_IMM32Proc.ImmGetCompositionStringW)(hIMC, dwIndex, lpBuf, dwBufLen);
}

typedef HIMC (WINAPI*IGC_CAST)(HWND);
HIMC CW32System::ImmGetContext ( HWND hWnd )
{
	if (IsAIMMLoaded())
	{
		HRESULT hResult;
		HIMC	hIMC = 0;
	
		hResult = pAIMM->GetContext(hWnd, &hIMC);
				
		return (SUCCEEDED(hResult) ? hIMC : 0);
	}

	if (g_IMM32Proc.ImmGetContext == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetContext, DLL_IMM32, "ImmGetContext" );
	return ((IGC_CAST)g_IMM32Proc.ImmGetContext)(hWnd);
}

typedef BOOL (WINAPI*ISCFA_CAST)(HIMC, LPLOGFONTA);
BOOL CW32System::ImmSetCompositionFontA ( 
	HIMC hIMC, 
	LPLOGFONTA lpLogFontA,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->SetCompositionFontA(hIMC, lpLogFontA);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetCompositionFontA == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCompositionFontA, DLL_IMM32, "ImmSetCompositionFontA" );
	return ((ISCFA_CAST)g_IMM32Proc.ImmSetCompositionFontA)(hIMC, lpLogFontA);
}

typedef BOOL (WINAPI*ISCW_CAST)(HIMC, LPCOMPOSITIONFORM);
BOOL CW32System::ImmSetCompositionWindow ( 
	HIMC hIMC, 
	LPCOMPOSITIONFORM lpCompForm,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->SetCompositionWindow(hIMC, lpCompForm);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetCompositionWindow == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCompositionWindow, DLL_IMM32, "ImmSetCompositionWindow" );
	return ((ISCW_CAST)g_IMM32Proc.ImmSetCompositionWindow)(hIMC, lpCompForm);
}

typedef BOOL (WINAPI*IRC_CAST)(HWND, HIMC);
BOOL CW32System::ImmReleaseContext ( 
	HWND hWnd, 
	HIMC hIMC)
{
	if (IsAIMMLoaded())
	{
		HRESULT hResult;
	
		hResult = pAIMM->ReleaseContext(hWnd, hIMC);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmReleaseContext == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmReleaseContext, DLL_IMM32, "ImmReleaseContext" );
	return ((IRC_CAST)g_IMM32Proc.ImmReleaseContext)(hWnd, hIMC);
}

typedef DWORD (WINAPI*IGP_CAST)(HKL, DWORD);
DWORD CW32System::ImmGetProperty ( 
	HKL hKL, 
	DWORD dwIndex,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		DWORD	dwProperties=0;
	
		hResult = pAIMM->GetProperty(hKL, dwIndex, &dwProperties);
				
		return (SUCCEEDED(hResult) ? dwProperties : 0);
	}

	if (g_IMM32Proc.ImmGetProperty == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetProperty, DLL_IMM32, "ImmGetProperty" );
	return ((IGP_CAST)g_IMM32Proc.ImmGetProperty)(hKL, dwIndex);
}

typedef BOOL (WINAPI*IGCW_CAST)(HIMC, DWORD, LPCANDIDATEFORM);
BOOL CW32System::ImmGetCandidateWindow ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPCANDIDATEFORM lpCandidate,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->GetCandidateWindow(hIMC, dwIndex, lpCandidate);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmGetCandidateWindow == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetCandidateWindow, DLL_IMM32, "ImmGetCandidateWindow" );
	return ((IGCW_CAST)g_IMM32Proc.ImmGetCandidateWindow)(hIMC, dwIndex, lpCandidate);
}

typedef BOOL (WINAPI*ISCAW_CAST)(HIMC, LPCANDIDATEFORM);
BOOL CW32System::ImmSetCandidateWindow ( 
	HIMC hIMC, 
	LPCANDIDATEFORM lpCandidate ,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->SetCandidateWindow(hIMC, lpCandidate);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetCandidateWindow == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCandidateWindow, DLL_IMM32, "ImmSetCandidateWindow" );
	return ((ISCAW_CAST)g_IMM32Proc.ImmSetCandidateWindow)(hIMC, lpCandidate);
}

typedef BOOL (WINAPI*INIME_CAST)(HIMC, DWORD, DWORD, DWORD);
BOOL CW32System::ImmNotifyIME ( 
	HIMC hIMC, 
	DWORD dwAction, 
	DWORD dwIndex, 
	DWORD dwValue,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
	
		hResult = pAIMM->NotifyIME(hIMC, dwAction, dwIndex, dwValue);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmNotifyIME == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmNotifyIME, DLL_IMM32, "ImmNotifyIME" );
	return ((INIME_CAST)g_IMM32Proc.ImmNotifyIME)(hIMC, dwAction, dwIndex, dwValue);
}

typedef HIMC (WINAPI*IAC_CAST)(HWND, HIMC);
HIMC CW32System::ImmAssociateContext ( 
	HWND hWnd, 
	HIMC hIMC,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		HIMC	hPreviousIMC=0;

		hResult = pAIMM->AssociateContext(hWnd, hIMC, &hPreviousIMC);
				
		return (SUCCEEDED(hResult) ? hPreviousIMC : 0);
	}

	if (g_IMM32Proc.ImmAssociateContext == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmAssociateContext, DLL_IMM32, "ImmAssociateContext" );
	return ((IAC_CAST)g_IMM32Proc.ImmAssociateContext)(hWnd, hIMC);
}

typedef UINT (WINAPI*IGVK_CAST)(HWND);
UINT CW32System::ImmGetVirtualKey ( 
	HWND hWnd,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		UINT	uVirtualKey=0;

		hResult = pAIMM->GetVirtualKey(hWnd, &uVirtualKey);
				
		return (SUCCEEDED(hResult) ? uVirtualKey : 0);
	}

	if (g_IMM32Proc.ImmGetVirtualKey == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetVirtualKey, DLL_IMM32, "ImmGetVirtualKey" );
	return ((IGVK_CAST)g_IMM32Proc.ImmGetVirtualKey)(hWnd);
}

// NOTE: We only use ImmEscape for IME_ESC_HANJA_MODE.
// Need to fix up if other methods are used.
typedef HIMC (WINAPI*IES_CAST)(HKL, HIMC, UINT, LPVOID );
HIMC CW32System::ImmEscape ( 
	HKL hKL, 
	HIMC hIMC, 
	UINT uEscape, 
	LPVOID lpData,
	BOOL bAimmActivated)
{
	char		szaHangeul[3] = {0, 0, 0};

	// Aimm only support A version..
	if (!OnWin9x() && !bAimmActivated)
		goto USE_W_VERSION;

	if (MbcsFromUnicode(szaHangeul, sizeof(szaHangeul),
		(LPCWSTR)lpData, 1, CP_KOREAN, UN_NOOBJECTS) <= 0)
		return FALSE;

	if (bAimmActivated)
	{
		HRESULT hResult;
		LRESULT lResult=0;

		hResult = pAIMM->EscapeA(hKL, hIMC, uEscape, (LPVOID)szaHangeul, &lResult);
				
		return (SUCCEEDED(hResult) ? (HIMC)lResult : 0);
	}

	if (g_IMM32Proc.ImmEscapeA == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmEscapeA, DLL_IMM32, "ImmEscapeA" );
	return ((IES_CAST)g_IMM32Proc.ImmEscapeA)(hKL, hIMC, uEscape, (LPVOID)szaHangeul);

USE_W_VERSION:
	if (g_IMM32Proc.ImmEscapeW == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmEscapeW, DLL_IMM32, "ImmEscapeW" );
	return ((IES_CAST)g_IMM32Proc.ImmEscapeW)(hKL, hIMC, uEscape, lpData);
}

typedef BOOL (WINAPI*IGOS_CAST)(HIMC);
BOOL CW32System::ImmGetOpenStatus ( 
	HIMC hIMC,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		
		// AIMM is returning S_OK for OpenStatus == TRUE.
		hResult = pAIMM->GetOpenStatus(hIMC);
				
		return (hResult == S_OK);
	}

	if (g_IMM32Proc.ImmGetOpenStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetOpenStatus, DLL_IMM32, "ImmGetOpenStatus" );
	return ((IGOS_CAST)g_IMM32Proc.ImmGetOpenStatus)(hIMC);
}

typedef BOOL (WINAPI*ISOS_CAST)(HIMC, BOOL);
BOOL CW32System::ImmSetOpenStatus ( 
	HIMC hIMC, 
	BOOL fOpen,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->SetOpenStatus(hIMC, fOpen);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetOpenStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetOpenStatus, DLL_IMM32, "ImmSetOpenStatus" );
	return ((ISOS_CAST)g_IMM32Proc.ImmSetOpenStatus)(hIMC, fOpen);
}

typedef BOOL (WINAPI*IGCS_CAST)(HIMC , LPDWORD , LPDWORD );
BOOL CW32System::ImmGetConversionStatus ( 
	HIMC hIMC, 
	LPDWORD pdwConversion, 
	LPDWORD pdwSentence,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->GetConversionStatus(hIMC, pdwConversion, pdwSentence);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmGetConversionStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetConversionStatus, DLL_IMM32, "ImmGetConversionStatus" );
	return ((IGCS_CAST)g_IMM32Proc.ImmGetConversionStatus)(hIMC, pdwConversion, pdwSentence);
}

typedef BOOL (WINAPI*ISCS_CAST)(HIMC , DWORD , DWORD );
BOOL CW32System::ImmSetConversionStatus ( 
	HIMC hIMC, 
	DWORD dwConversion, 
	DWORD dwSentence,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;

		hResult = pAIMM->SetConversionStatus(hIMC, dwConversion, dwSentence);
				
		return (SUCCEEDED(hResult));
	}

	if (g_IMM32Proc.ImmSetConversionStatus == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetConversionStatus, DLL_IMM32, "ImmSetConversionStatus" );
	return ((ISCS_CAST)g_IMM32Proc.ImmSetConversionStatus)(hIMC, dwConversion, dwSentence);
}

typedef HWND (WINAPI*IGDW_CAST)( HWND );
HWND CW32System::ImmGetDefaultIMEWnd (  
	HWND hWnd,
	BOOL bAimmActivated)
{
	if (bAimmActivated)
	{
		HRESULT hResult;
		HWND	hIMEWnd;

		hResult = pAIMM->GetDefaultIMEWnd(hWnd, &hIMEWnd);
				
		return SUCCEEDED(hResult) ? hIMEWnd : NULL;
	}

	if (g_IMM32Proc.ImmGetDefaultIMEWnd == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmGetDefaultIMEWnd, DLL_IMM32, "ImmGetDefaultIMEWnd" );
	return ((IGDW_CAST)g_IMM32Proc.ImmGetDefaultIMEWnd)(hWnd);
}

typedef BOOL (WINAPI*ISCSW_CAST)(HIMC, DWORD, LPVOID, DWORD, LPVOID, DWORD);
BOOL CW32System::ImmSetCompositionStringW ( 
	HIMC hIMC, 
	DWORD dwIndex, 
	LPVOID lpBuf, 
	DWORD dwBufLen,
	LPVOID lpRead,
	DWORD dwReadLen)
{
	if (g_IMM32Proc.ImmSetCompositionStringW == NULL)
		SetIMEProcAddr( g_IMM32Proc.ImmSetCompositionStringW, DLL_IMM32, "ImmSetCompositionStringW" );
	return ((ISCSW_CAST)g_IMM32Proc.ImmSetCompositionStringW)(hIMC, dwIndex, lpBuf, dwBufLen, lpRead, dwReadLen);
}

typedef IMESHAREAPI BOOL (*FSS_CAST)(UINT, UINT);
BOOL CW32System::FSupportSty ( UINT uSty, UINT uStyAltered)
{
	if (g_IMEShareProc.FSupportSty == NULL)
		SetIMEProcAddr( g_IMEShareProc.FSupportSty, DLL_IMESHARE, "FSupportSty" );
	return ((FSS_CAST)g_IMEShareProc.FSupportSty)(uSty, uStyAltered);
}

typedef IMESHAREAPI const IMESTYLE * (IMECDECL*PISFA_CAST)(const UINT);
const IMESTYLE * CW32System::PIMEStyleFromAttr ( const UINT uAttr)
{
	if (g_IMEShareProc.PIMEStyleFromAttr == NULL)
		SetIMEProcAddr( g_IMEShareProc.PIMEStyleFromAttr, DLL_IMESHARE, "PIMEStyleFromAttr" );
	return ((PISFA_CAST)g_IMEShareProc.PIMEStyleFromAttr)( uAttr );
}

typedef IMESHAREAPI const IMECOLORSTY * (IMECDECL*PCSTFIS_CAST)(const IMESTYLE *);
const IMECOLORSTY * CW32System::PColorStyleTextFromIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.PColorStyleTextFromIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.PColorStyleTextFromIMEStyle, DLL_IMESHARE, "PColorStyleTextFromIMEStyle" );
	return ((PCSTFIS_CAST)g_IMEShareProc.PColorStyleTextFromIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI const IMECOLORSTY * (IMECDECL*PCSBFIS_CAST)(const IMESTYLE *);
const IMECOLORSTY * CW32System::PColorStyleBackFromIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.PColorStyleBackFromIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.PColorStyleBackFromIMEStyle, DLL_IMESHARE, "PColorStyleBackFromIMEStyle" );
	return ((PCSBFIS_CAST)g_IMEShareProc.PColorStyleBackFromIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI BOOL (IMECDECL*FBIS_CAST)(const IMESTYLE *);
BOOL CW32System::FBoldIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.FBoldIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.FBoldIMEStyle, DLL_IMESHARE, "FBoldIMEStyle" );
	return ((FBIS_CAST)g_IMEShareProc.FBoldIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI BOOL (IMECDECL*FIIS_CAST)(const IMESTYLE * );
BOOL CW32System::FItalicIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.FItalicIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.FItalicIMEStyle, DLL_IMESHARE, "FItalicIMEStyle" );
	return ((FIIS_CAST)g_IMEShareProc.FItalicIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI BOOL (IMECDECL*FUIS_CAST)(const IMESTYLE *);
BOOL CW32System::FUlIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.FUlIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.FUlIMEStyle, DLL_IMESHARE, "FUlIMEStyle" );
	return ((FUIS_CAST)g_IMEShareProc.FUlIMEStyle)( pIMEStyle );
}

typedef IMESHAREAPI UINT (IMECDECL*IUIS_CAST)(const IMESTYLE *);
UINT CW32System::IdUlIMEStyle ( const IMESTYLE * pIMEStyle)
{
	if (g_IMEShareProc.IdUlIMEStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.IdUlIMEStyle, DLL_IMESHARE, "IdUlIMEStyle" );
	return ((IUIS_CAST)g_IMEShareProc.IdUlIMEStyle)( pIMEStyle );;
}

typedef IMESHAREAPI COLORREF (IMECDECL*RFICS_CAST)(const IMECOLORSTY *);
COLORREF CW32System::RGBFromIMEColorStyle ( const IMECOLORSTY * pColorStyle )
{
	if (g_IMEShareProc.RGBFromIMEColorStyle == NULL)
		SetIMEProcAddr( g_IMEShareProc.RGBFromIMEColorStyle, DLL_IMESHARE, "RGBFromIMEColorStyle" );
	return ((RFICS_CAST)g_IMEShareProc.RGBFromIMEColorStyle)( pColorStyle );
}

CONVERTMODE WINAPI CW32System::DetermineConvertMode( HDC hdc, BYTE tmCharSet )
{
	CONVERTMODE cm = CVT_NONE;

	// Some fonts have problems under Win95 with the GetCharWidthW call; this
	// is a simple heuristic to determine if this problem exists.
	if (OnWin9x())
	{
		INT		widthA, widthW;
		BOOL	fResA, fResW;

		// FE font on Non-FE Win95 cannot use
		// GetCharWidthW and ExtTextOutW
		if(IsFECharSet(tmCharSet) && OnWin95FE())
			// always use ANSI call for DBC fonts.
			cm = CVT_WCTMB;
		else
		{
			fResA = GetCharWidthA( hdc, ' ', ' ', &widthA );
			fResW = GetCharWidthW( hdc, L' ', L' ', &widthW );
			if ( fResA && fResW && widthA != widthW )
				cm = CVT_WCTMB;
			else
			{
				fResA = GetCharWidthA( hdc, 'a', 'a', &widthA );
				fResW = GetCharWidthW( hdc, L'a', L'a', &widthW );
				if ( fResA && fResW && widthA != widthW )
					cm = CVT_WCTMB;
			}
		}
	}
	return cm;
}

void WINAPI CW32System::CalcUnderlineInfo(HDC hdc, CCcs *pcccs, TEXTMETRIC *ptm )
{
	OUTLINETEXTMETRICA *potm;
	unsigned cb;
	CTempBuf tb;

	if (ptm->tmPitchAndFamily & TMPF_TRUETYPE)
	{
		cb = GetOutlineTextMetricsA(hdc, 0, NULL);

		if ((cb != 0) 
			&& ((potm = (OUTLINETEXTMETRICA *) tb.GetBuf(cb)) != NULL)
			&& GetOutlineTextMetricsA(hdc, cb, potm))
		{
			pcccs->_dyULOffset = -potm->otmsUnderscorePosition;
			pcccs->_dyULWidth = (short) max(1, potm->otmsUnderscoreSize);
			pcccs->_dySOOffset = -potm->otmsStrikeoutPosition;
			pcccs->_dySOWidth = (short) max(1, (int)potm->otmsStrikeoutSize);
			return;
		}
	}

	// Default calculation of size of underline
	SHORT dyDescent = pcccs->_yDescent;

	if (0 == dyDescent)
	{
		dyDescent = pcccs->_yHeight >> 3;
	}

	pcccs->_dyULWidth = (short) max(1, dyDescent / 4);
	pcccs->_dyULOffset = (dyDescent - 3 * pcccs->_dyULWidth + 1) / 2;

	if ((0 == pcccs->_dyULOffset) && (dyDescent > 1))
	{
		pcccs->_dyULOffset = 1;
	}

	pcccs->_dySOOffset = -ptm->tmAscent / 3;
	pcccs->_dySOWidth = pcccs->_dyULWidth;

	return;
}

BOOL WINAPI CW32System::ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG )
{
	return ::ShowScrollBar( hWnd, wBar, bShow );
}

BOOL WINAPI CW32System::EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows )
{
	return ::EnableScrollBar( hWnd, wSBflags, wArrows );
}

/*
 * 	ReExtTextOutW(uiCodePage, hdc, x, y, fuOptions, lprc, lpString, cch ,lpDx, uiCodePage)
 *
 *	@mfunc
 *		Patch around the Win95 FE bug and MetaFile problem.		
 *
 *	@rdesc
 *		Returns whatever ExtTextOut returns
 */
BOOL ReExtTextOutW(
    HDC hdc,					//@parm handle to device context 
    int xp,						//@parm x-coordinate of reference point 
    int yp,						//@parm y-coordinate of reference point 
    UINT fuOptions,				//@parm text-output options 
    CONST RECT *lprect,			//@parm optional clipping and/or opaquing rectangle 
    const WCHAR *lpwchString,	//@parm points to string 
    UINT cchCount,				//@parm number of characters in string 
    CONST INT *lpDx,			//@parm Ptr to array of intercharacter spacing values
	UINT uiCodePage)			//@parm CodePage for converting to Ansi
{
	// This is a portion of Word code adapted for our needs. 
	// This is a work around for Win95FE bugs that cause GPFs in GDI if multiple
	// characters above Unicode 0x7F are passed to ExtTextOutW.

	// Also, when uiCodePage is non-zero, we want to output all characters using
	// ExtTextOutA - each character at a time.

	Assert(lpDx);
	int		cch;
	const WCHAR *lpwchT = lpwchString;
	const WCHAR *lpwchStart = lpwchT;
	const WCHAR *lpwchEnd = lpwchString + cchCount;

	CONST int *lpdxpCur;
	BOOL	fRet = 0;

	while (lpwchT < lpwchEnd)
	{
		// characters less than 0x007F do not need special treatment
		// we output then in contiguous runs
		if (*lpwchT > 0x007F || uiCodePage)
		{
			if ((cch = lpwchT - lpwchStart) > 0)
			{
				lpdxpCur = lpDx + (lpwchStart - lpwchString);

				// Output the run of chars less than 0x7F
				fRet = ExtTextOutW(hdc, xp, yp, fuOptions, lprect, lpwchStart, cch, lpdxpCur);
				if (!fRet)
					return fRet;

				fuOptions &= ~ETO_OPAQUE; // Don't erase mutliple times!!!

				// Advance
				while (cch--)
					xp += *lpdxpCur++;
					
				lpwchStart = lpwchT;
			}

			// Output chars above 0x7F one at a time to prevent Win95 FE GPF
			lpdxpCur = lpDx + (lpwchStart - lpwchString);
			if (uiCodePage)
			{

				// Need to convert to Ansi and use ExtTextOutA
				char	chAnsi[2];
				
				int	cbConv = WideCharToMultiByte(uiCodePage, 0, lpwchStart, 1, 
					chAnsi, 2, NULL, NULL);
				
				if (cbConv <= 0)
				{
					chAnsi[0] = '?';
					cbConv = 1;
				}

				fRet = ExtTextOutA(hdc, xp, yp, fuOptions, lprect, chAnsi, cbConv, lpdxpCur);
			}
			else
				fRet = ExtTextOutW(hdc, xp, yp, fuOptions, lprect, lpwchStart, 1, lpdxpCur);

			if (!fRet)
				return fRet;

			fuOptions &= ~ETO_OPAQUE; // Don't erase multiple times!!!

			// Advance
			if (lpdxpCur)
				xp += *lpdxpCur;

			lpwchStart++;
		}

		lpwchT++;
	}

	// output the final run; also, if we were called with cchCount == 0,
	// make a call here to erase the rectangle
	if ((cch = lpwchT - lpwchStart) > 0 || !cchCount)
		fRet = ExtTextOutW(hdc, xp, yp, fuOptions, lprect, lpwchStart, cch, lpDx + (lpwchStart - lpwchString));
	
	return fRet;	
}

void WINAPI CW32System::REExtTextOut(
	CONVERTMODE cm,
	UINT uiCodePage,
	HDC hdc,
	int x,
	int y,
	UINT fuOptions,
	CONST RECT *lprc,
	const WCHAR *lpString,
	UINT cch,
	CONST INT *lpDx,
	BOOL  FEFontOnNonFEWin9x
)
{
	bool	fConvert = false;
	BOOL	fForceGdiFont = FALSE;
	HFONT	hfont = NULL, hfontCur = NULL;

	// In order to get the EURO character to print, we need to force the
	// printer to use the glyphs inside GDI
	if(lpString[0] == EURO && 
	   (GetDeviceCaps(hdc, TECHNOLOGY) != DT_RASDISPLAY || W32->IsEnhancedMetafileDC(hdc)))
	{
		fForceGdiFont = TRUE;
		hfontCur = SelectFont(hdc, GetStockObject(ANSI_VAR_FONT));
		LOGFONT lf;
		GetObject(hfontCur, sizeof(LOGFONT), &lf);
		lf.lfOutPrecision = OnWin9x() ? OUT_TT_ONLY_PRECIS : OUT_SCREEN_OUTLINE_PRECIS;
		hfont = CreateFontIndirect(&lf);
		SelectObject(hdc, hfont);
	}

	if(OnWin9x())
	{
		// To get around some Win95 printer device problems with ExtTextOutW,
		// use ExtTextOutA if string is ASCII or if it's 1252 and any
		// nonASCII chars are between 0xA0 and 0xFF.
		for(UINT i = 0;
			i < cch &&
			(lpString[i] <= 0x7F ||
			 IN_RANGE(0xA0, lpString[i], 0xFF) && uiCodePage == 1252);
			i++)
				;
		if(i == cch) 				// All ASCII or ANSI: setup to truncate
		{							//  to low byte and use ExtTextOutA
			cm = CVT_LOWBYTE;
			fConvert = true;
		}
	}

	if (fConvert || !FEFontOnNonFEWin9x && cm != CVT_NONE)		
	{
		if (cm == CVT_WCTMB)
		{
			if (IsFECodePage(uiCodePage))
			{
				if (OnWinNTNonFE() || (OnWin9x() && !OnWin95()))
				{
					// On NonFE NT4 and Win98, we need to textout each char using
					// ExtTextOutA
					ReExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx, uiCodePage);
					goto LExit;
				}
			}			
		}

		// Need to convert and use ExtTextOutA
		CTempCharBuf tcb;
		CTempBuf	 tDx;
		
		// Double the buffer size 
		int cbString = (cm == CVT_LOWBYTE) ? cch : cch * 2;
			
		// String buffer for converted string - allocate on the stack 
		char *psz = tcb.GetBuf(cbString);
		INT	 *pTempDx = NULL;
		
		if (NULL == psz)
		{
			// Could not allocate buffer
			goto LExit;
		}
			
		int cbConv = 0;
			
		if(cm == CVT_WCTMB)
		{
			cbConv = WideCharToMultiByte(uiCodePage, 0, lpString, cch, 
				psz, cbString, NULL, NULL);
				
			if(!cbConv)
			{
				// The conversion failed for one reason or another.  We should
				// make every effort to use WCTMB before we fall back to
				// taking the low-byte of every wchar (below), otherwise we
				// risk dropping the high-bytes and displaying garbage.
					
				// Use the cpg from the font, since the uiCodePage passed is
				//	the requested codepage and the font-mapper may very well
				//	have mapped to a different one.
				TEXTMETRIC tm;
					
				uiCodePage = (GetTextMetrics(hdc, &tm) && 
					tm.tmCharSet != DEFAULT_CHARSET &&
					(UINT)GetCodePage(tm.tmCharSet) != uiCodePage) ?
					GetCodePage(tm.tmCharSet) : 1252;
					
				cbConv = WideCharToMultiByte(uiCodePage, 0, lpString, cch, 
					psz, cbString, NULL, NULL);
			}

			if (cbConv > 0 && lpDx)
			{
				pTempDx = (INT *)tDx.GetBuf(cbConv * sizeof(INT));
				
				if (pTempDx)
				{
					// Repack lpDx to handle DBC
					INT		*pDx = pTempDx;
					CONST INT*pInputDx = lpDx;
					char	*pTempChar = psz;
					INT		cNumBytes = cbConv;

					while (cNumBytes > 0)
					{
						cNumBytes--;

						if (GetTrailBytesCount(*pTempChar++, uiCodePage))
						{
							*pDx++ = *pInputDx++;						
							*pDx++ = 0;
							cNumBytes--;
							pTempChar++;
						}
						else
							*pDx++ = *pInputDx++;
					}
				}
			}
		}
		else
		{
			Assert(cm == CVT_LOWBYTE);
			// drop through and convert using only low-bytes of WCHAR's
		}
			
			// WCTMB failed OR cm == CVT_LOWBYTE
		if(!cbConv)							// Convert WCHARs to CHARs
		{									
			// FUTURE:  We come here for both SYMBOL_CHARSET fonts and for
			// DBCS bytes stuffed into wchar's (one byte per wchar) when
			// the requested code page is not installed on the machine and
			// the MBTWC fails. Instead, we could have another conversion
			// mode that collects each DBCS char as a single wchar and then
			// remaps to a DBCS string for ExtTextOutA. This would allow us
			// to display text if the system has the right font even tho it
			// doesn't have the right cpg.
				
			// If we are converting this WCHAR buffer in this manner
			// (by taking only the low-byte's of the WCHAR's), it is 
			// because:
			// 	1) cm == CVT_LOWBYTE
			//	2) WCTMB above failed for some reason or another.  It may
			// 		be the case that the string is entirely ASCII in which
			//		case dropping the high-bytes is not a big deal (otherwise
			//		we assert).
		
			cbConv = cch;
				
			while(cch--)
			{
#ifdef DEBUG
				if (uiCodePage != CP_SYMBOL && lpString[cch] > 0xFF)
					Tracef(TRCSEVWARN, "Non-zero high-byte WCHAR: %x", lpString[cch]);
#endif
				psz[cch] = lpString[cch];
			}
		}		
		::ExtTextOutA(hdc, x, y, fuOptions, lprc, psz, cbConv, pTempDx ? pTempDx : lpDx);
		goto LExit;
	}

	if (OnWin9xFE() || FEFontOnNonFEWin9x)
		ReExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx, 0);
	else
		::ExtTextOutW(hdc, x, y, fuOptions, lprc, lpString, cch, lpDx);	

LExit:
	if (fForceGdiFont)
	{
		SelectObject(hdc, hfontCur);
		SideAssert(DeleteObject(hfont));
	}
}

void WINAPI CW32System::REGetCharWidth(
	HDC		hdc,
	WCHAR	ch,
	SHORT *	pWidth,
	UINT	cpg,	
	SHORT	xOverhang,
	INT		iDefWidth)
{
	BOOL	fForceGdiFont = FALSE;
	HFONT	hfont = NULL, hfontCur = NULL;
	int		iwidth;

	*pWidth = 0;
	if ((cpg == CP_SYMBOL || ch <= 127) && ::GetCharWidthA(hdc, ch, ch, &iwidth))
	{
		*pWidth = (SHORT)iwidth;
		goto Done;
	}

	if(ch == EURO && (GetDeviceCaps(hdc, TECHNOLOGY) != DT_RASDISPLAY || W32->IsEnhancedMetafileDC(hdc)))
	{
		fForceGdiFont = TRUE;
		hfontCur = SelectFont(hdc, GetStockObject(ANSI_VAR_FONT));
		LOGFONT lf;
		GetObject(hfontCur, sizeof(LOGFONT), &lf);
		lf.lfOutPrecision = OnWin9x() ? OUT_TT_ONLY_PRECIS : OUT_SCREEN_OUTLINE_PRECIS;
		hfont = CreateFontIndirect(&lf);
		SelectObject(hdc, hfont);
	}

	// For most workarounds, we will use the workarounds on all the OSs.
	// We only use specific workaround is MBTWC conversion is needed.

	// This is a workaround for Win95 FE bugs
	// FUTURE (keithcu) This logic could be simplified.
	if (OnWin95() && !IN_RANGE(0x80, ch, 0xFF) &&			// Not high ANSI?
		(cpg == CP_CHINESE_TRAD || cpg == CP_CHINESE_SIM))	// Chinese CodePage?
	{
		int numOfDBCS = 0;
		::GetCharWidthW(hdc, 0x4e00, 0x4e00, &iwidth);
		*pWidth = (SHORT)iwidth;
		if (IN_RANGE(0x4e00, ch, 0x9fff))
			goto Done;
			
		// Use WCTMB heuristic
		char	ansiChar[2];
		BOOL	bDefCharUsed = FALSE;
		numOfDBCS = ::WideCharToMultiByte( cpg, 0, &ch, 1, ansiChar, 2, NULL, &bDefCharUsed);

		WORD wDBCS = (BYTE)ansiChar[0];
		
		if (2 == numOfDBCS)
			wDBCS = (BYTE)ansiChar[0] << 8 | (BYTE)ansiChar[1];
		
		if (numOfDBCS > 0 && ::GetCharWidthA( hdc, wDBCS, wDBCS, &iwidth))
		{
			*pWidth = (SHORT)iwidth;
			goto Done;
		}
	}

	//Win '95 GPFs if you pass in 0xFFFF
	if (ch == 0xFFFF)
		ch = 0xFFFE;

	if (::GetCharWidthW(hdc, ch, ch, &iwidth))
		*pWidth = (SHORT)iwidth;

	if(fForceGdiFont)
	{
		SelectObject(hdc, hfontCur);
		SideAssert(DeleteObject(hfont));
	}

Done:
	*pWidth	-= xOverhang;
	if (0 >= *pWidth)
	{
		// Sometimes GetCharWidth will return a zero length for small
		// characters. When this happens we will use the default width
		// for the font if that is non-zero otherwise we just us 1 because
		// this is the smallest valid value.

		// This code can also be triggered if the overhang is bigger than the
		// width returned by the OS call to get the character width.		
		if (0 == iDefWidth)
			*pWidth = 1;
		else
			*pWidth = (SHORT)iDefWidth;
	}
}

BOOL WINAPI CW32System::IsEnhancedMetafileDC( HDC hDC )
{
	BOOL	fEMFDC = FALSE;
	DWORD	dwObjectType;
	
	dwObjectType = ::GetObjectType( hDC );

	if ( OBJ_ENHMETADC == dwObjectType || OBJ_ENHMETAFILE == dwObjectType )
		fEMFDC = TRUE;
	else if ( OnWin95() && OBJ_DC == dwObjectType )
	{
		// HACK Alert,  Enhanced Metafile DC does not support any Escape function
		// and shoudl return 0.
		int	iEscapeFuction = QUERYESCSUPPORT;

		if ( Escape( hDC, QUERYESCSUPPORT, sizeof(int), (LPCSTR)&iEscapeFuction, NULL) == 0 )
			fEMFDC = TRUE;
	}	

	return fEMFDC;
}


HPALETTE WINAPI CW32System::ManagePalette(
	HDC hdc,
	CONST LOGPALETTE *plogpal,
	HPALETTE &hpalOld,
	HPALETTE &hpalNew
)
{
	if (hpalNew == NULL)
	{
		hpalNew = ::CreatePalette(plogpal);
		if (hpalNew != NULL)
		{
			hpalOld = ::SelectPalette(hdc, hpalNew, TRUE);
			::RealizePalette(hdc);
		}
	}
	else
	{
		// A new palette was created previously and we are restoring the old one
		::SelectPalette(hdc, hpalOld, TRUE);
		::RealizePalette(hdc);
		DeleteObject(hpalNew);
		hpalNew = NULL;
	}
	return hpalNew;
}

int WINAPI CW32System::GetMapMode(HDC hdc)
{
	return ::GetMapMode(hdc);
}

BOOL WINAPI CW32System::WinLPtoDP(HDC hdc, LPPOINT lppoints, int nCount)
{
	return ::LPtoDP(hdc, lppoints, nCount);
}

long WINAPI CW32System::WvsprintfA( LONG cbBuf, LPSTR szBuf, LPCSTR szFmt, va_list arglist )
{
	LONG cb;
	cb = ::wvsprintfA( szBuf, szFmt, arglist );
	Assert(cb < cbBuf);
	return cb;
}

int WINAPI CW32System::MulDiv(int nNumber, int nNumerator, int nDenominator)
{
	if ((nNumerator && nNumerator == nDenominator) || (nDenominator && !nNumber))
		return nNumber;
	return ::MulDiv(nNumber, nNumerator, nDenominator);
}

/*
 *	GetFacePriorityCharSet(WCHAR* szFaceName)
 *
 *	@func
 *		return charset *really* supported by given facename
 */
int CALLBACK GetFacePriCharSetProc (
	ENUMLOGFONTEX	*lpelfe,
	NEWTEXTMETRIC	*lpntm,
	int				iFontType,
	LPARAM			lParam)
{
	Assert (lParam);
	*(BYTE*)lParam = lpntm->tmCharSet;
	return 0;
}

void CW32System::GetFacePriCharSet(HDC hdc, LOGFONT* plf)
{
	::EnumFontFamiliesEx(hdc, plf, (FONTENUMPROC)GetFacePriCharSetProc, (LPARAM)&plf->lfCharSet, 0);
}


/*
 *	CW32System::ReadRegDigitSubstitionMode(void)
 *
 *	@mfunc
 *		Get the digit substitution mode (available on BiDi/Thai platforms)
 *
 *	@rdesc
 *		0 - Context (digit shape follows preceding run or CHARFORMAT's charset
 *		1 - None (digits always show as European digit shape)
 *		2 - National (digits always show as user locale's native shape)
 */
BYTE CW32System::ReadRegDigitSubstitutionMode()
{
	HKEY	hk;
	DWORD	keyDataType;
	DWORD	dwDataSize;
	BYTE	rgbValue[2];
	BYTE	bDigitMode;

	bDigitMode = DIGITS_NOTIMPL;			// assume "Not Implemented"

	// Perform platform check before reading registry
	if (!OnWin9xFE() && !OnWinNTFE() && 
		 IsComplexScriptLcid(GetThreadLocale()))
	{
		if(RegOpenKeyExA(HKEY_CURRENT_USER,
						"Control Panel\\International",
						0,		// reserved
						KEY_QUERY_VALUE,
						&hk) == ERROR_SUCCESS)
		{
			dwDataSize = 2;
			if (RegQueryValueExA(hk,
								"NumShape",
								NULL,		// reserved
								&keyDataType,
								(LPBYTE) &rgbValue,
								&dwDataSize) == ERROR_SUCCESS)
			{
				if (rgbValue[0] > 0x2f)
					bDigitMode = rgbValue[0] - 0x30 + 1;
				if (bDigitMode > DIGITS_NATIONAL)
					bDigitMode = DIGITS_NONE;
			}
			RegCloseKey(hk);
		}
	}
	return bDigitMode;
}

#ifdef DEBUG
/*
 *	TestGetCharFlags125x(iFirst, iLast)
 *
 *	@func
 *		Unit test function for GetCharFlags125x(). Assert if GetCharFlags125x()
 *		claims that any char in	Unicode range iFirst thru iLast 1) should
 *		roundtrip multibyte conversion using a codepage in the range 1250-1258
 *		when it	doesn't, or 2) shouldn't roundtrip when it does.
 */
BOOL TestGetCharFlags125x(
	int iFirst, 
	int iLast) 
{
	LONG	cch  = iLast - iFirst + 1;
	LONG	i;
	Assert(cch <= 0x700 - 0xA0);

	char 	rgach[0x700 - 0xA0];
	WCHAR	rgch [0x700 - 0xA0];
	WCHAR *	pch;

	for(i = iFirst, pch = rgch; i <= iLast;  pch++, i++)
		*pch = (WCHAR)i;

	for(int CodePage = 1250; CodePage <= 1258; CodePage++)
	{
		if(cch != WideCharToMultiByte(CodePage, 0, rgch, cch, rgach, cch, "\0", NULL) ||
		   cch != MultiByteToWideChar(CodePage, 0, rgach, cch, rgch, cch))
		{
			continue;				// Missing code page
		}
		//							 1250 1251 1252 1253  1254  1255  1256  1257   1258
		const static WORD rgMask[] = {0x2, 0x4, 0x1, 0x8, 0x10, 0x20, 0x40, 0x80, 0x100};

		DWORD dwMask = rgMask[CodePage - 1250] << 8;

		for(i = iFirst, pch = rgch; i <= iLast; pch++, i++)
		{
			AssertSz(!((*pch != (WCHAR)i) ^ !(W32->GetCharFlags125x(i) & dwMask)),
				"GetCharFlags125x() failure");
			*pch = (WCHAR)i;	// Restore value
		}
	}
	return TRUE;				// Above AssertSz() reports any errors
}
#endif

/*
 *	CW32System::InitSysParams(fUpdate)
 *
 *	@mfunc
 *		This method is used to initialize certain system wide parameters that
 *      that are used in richedit.  This can also be used as an update method
 *      if we ever handle system parameter change notifications.  The update
 *		parameter id provided for this purpose.	Also note that if we ever support
 *		SysParam updating, we may have to protect access with locks.
 */
void CW32System::InitSysParams(BOOL fUpdate)
{
	TRACEBEGIN(TRCSUBSYSUTIL, TRCSCOPEINTERN, "CW32System::InitSysParams");
	CLock lock;


	if (!_fSysParamsOk || fUpdate)
	{
		_fSysParamsOk = TRUE;
		
		const LONG dxSelBarDefaultSize = 8;
		HDC hdc = GetScreenDC();
		HFONT hfontOld;
		TEXTMETRIC tm;

		_xPerInchScreenDC = GetDeviceCaps(hdc, LOGPIXELSX); 
		if (_xPerInchScreenDC == 0)
			_xPerInchScreenDC = 0x60;
		_yPerInchScreenDC = GetDeviceCaps(hdc, LOGPIXELSY);
		if (_yPerInchScreenDC == 0)
			_yPerInchScreenDC = 0x60;
		int cPalette = GetDeviceCaps(hdc, SIZEPALETTE);

		// 256 colors is where we seem to need to use the palette.
		if (256 == cPalette)
		{
			_fUsePalette = TRUE;
		}

		// calculate a himetric selection bar for the window's host.
		_dxSelBar = W32->DXtoHimetricX(dxSelBarDefaultSize, _xPerInchScreenDC);

		RefreshKeyboardLayout();
		_hSystemFont = (HFONT)GetStockObject(SYSTEM_FONT);
		hfontOld = SelectFont(hdc, _hSystemFont);
		if(hfontOld)
		{
			W32->GetTextMetrics(hdc, &tm);
			_xWidthSys = (INT) tm.tmAveCharWidth;
			_yHeightSys = (INT) tm.tmHeight;
			_ySysFontLeading = (INT) tm.tmInternalLeading;
			_bSysCharSet = tm.tmCharSet;

			SelectFont(hdc, hfontOld);
		}

		_nScrollInset = (WORD)GetProfileIntA("windows", "ScrollInset",
			DD_DEFSCROLLINSET);
		_nDragDelay = (WORD)GetProfileIntA("windows", "DragDelay",
			DD_DEFDRAGDELAY);
		_nDragMinDist = (WORD)GetProfileIntA("windows", "DragMinDist",
			DD_DEFDRAGMINDIST);
		_nScrollDelay = (WORD)GetProfileIntA("windows", "ScrollDelay",
			DD_DEFSCROLLDELAY);
		_nScrollInterval = (WORD)GetProfileIntA("windows", "ScrollInterval",
			DD_DEFSCROLLINTERVAL);
	    _nScrollVAmount = (WORD)(GetYPerInchScreenDC()*DEFSCROLLVAMOUNT)/100;
	    _nScrollHAmount = (GetXPerInchScreenDC()*DEFSCROLLHAMOUNT)/100;

		_cxBorder	= GetSystemMetrics(SM_CXBORDER);	// Unsizable window border
		_cyBorder	= GetSystemMetrics(SM_CYBORDER);	//  widths
		_cxVScroll	= GetSystemMetrics(SM_CXVSCROLL);	//  dimensions
		_cyHScroll	= GetSystemMetrics(SM_CYHSCROLL);	//

		_cxDoubleClk	= GetSystemMetrics(SM_CXDOUBLECLK);
		_cyDoubleClk	= GetSystemMetrics(SM_CYDOUBLECLK);
		_DCT			= GetDoubleClickTime();
		_sysiniflags	= ::GetProfileIntA("richedit30", "flags", 0);

#ifdef DEBUG
		if(OnWinNT5() && (_sysiniflags & SYSINI_DEBUGGCF125X))
		{
			TestGetCharFlags125x(0xA0, 0x6FF);
			TestGetCharFlags125x(0x2000, 0x2122);
		}
#endif

		_bDigitSubstMode = ReadRegDigitSubstitutionMode();
		if (g_pusp)
			g_pusp->ApplyDigitSubstitution(_bDigitSubstMode);
	}
}

/*
 *	CW32System::GetSizeCursor(void)
 *
 *	@mfunc
 *		Get the sizing cursor (double arrow) specified by
 *		the resource id.  If the cursors are not loaded
 *		load them and cache them.
 *		parameters:
 *			idcur - cursor resource id.
 *
 *	@rdesc
 *		Handle to cursor or null if failure. Returns NULL if
 *		idcur is null.
 */
HCURSOR CW32System::GetSizeCursor(
	LPTSTR idcur)
{
	if(!idcur )
		return NULL;

	//If any cursor isn't loaded, try loading it.
	if(!_hcurSizeNS)
		_hcurSizeNS = LoadCursor(NULL, IDC_SIZENS);

	if(!_hcurSizeWE)
		_hcurSizeWE = LoadCursor(NULL, IDC_SIZEWE);

	if(!_hcurSizeNWSE)
		_hcurSizeNWSE = LoadCursor(NULL, IDC_SIZENWSE);

	if(!_hcurSizeNESW)
		_hcurSizeNESW = LoadCursor(NULL, IDC_SIZENESW);
	
	//Return cursor corresponding to id passed in.
	if(idcur == IDC_SIZENS && _hcurSizeNS)
		return _hcurSizeNS;

	if(idcur == IDC_SIZEWE && _hcurSizeWE)
		return _hcurSizeWE;

	if(idcur == IDC_SIZENWSE && _hcurSizeNWSE)
		return _hcurSizeNWSE;

	if(idcur == IDC_SIZENESW && _hcurSizeNESW)
		return _hcurSizeNESW;

	AssertSz(FALSE, "Failure loading sizing cursor.");

	return NULL;
}

/*
 *	CW32System:GetRollerLineScrollCount()
 *
 *	@mfunc	returns the number of lines to scroll with a roller mouse wheel.
 *			-1 means scroll by pages
 *
 *	@devnote We have to do different things for different platforms; NT4.0 has
 *			built in support for this functionality.
 */

/* excerpt from new winuser.h for calls to SystemParametersInfo */
#ifndef SPI_GETWHEELSCROLLLINES
#define SPI_GETWHEELSCROLLLINES   104
#endif

LONG CW32System::GetRollerLineScrollCount()
{
	if( _cLineScroll == 0 )
	{
#ifndef _WIN64
		HKEY hdlKey;
		DWORD keyDataType;
		CHAR charData[128];
		DWORD  dwDataBufSize;

		 // Fall back Value
		_cLineScroll = 0;

		// Read registry directly for Windows 95 & WinNT3.51, if WinNT 4.0 
		// and above then use SystemParametersInfo
		if((OnWin95()) || (_dwPlatformId == VER_PLATFORM_WIN32_NT) && (_dwMajorVersion < 4))
		{
			// Read registry directly
			if ( RegOpenKeyExA(HKEY_CURRENT_USER, 
						"Control Panel\\Desktop", 
						0,
						KEY_QUERY_VALUE,
						&hdlKey) == ERROR_SUCCESS )
			{
				dwDataBufSize = sizeof(charData);
				if ( RegQueryValueExA(hdlKey, 
							  "WheelScrollLines",
							  NULL,  // reserved
							  &keyDataType,
							  (LPBYTE) &charData,
							  &dwDataBufSize) == ERROR_SUCCESS )
				{
					_cLineScroll = W32->strtoul( charData );   //String representation
				}
			}			
			else
			{
			    // We didn't find line scroll count in the registery.  Check for a Mouse
			    // Wheel window and query the window how many lines to scroll
			    static UINT idWheelSupport = RegisterWindowMessageA(MSH_WHEELSUPPORT);
			    static UINT idScrollLine = RegisterWindowMessageA(MSH_SCROLL_LINES);
			    HWND hwndMsWheel = FindWindowA(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);
			    if (hwndMsWheel && SendMessageA(hwndMsWheel, idWheelSupport, 0, 0))
			        _cLineScroll = SendMessageA(hwndMsWheel, idScrollLine, 0, 0);
			}
			RegCloseKey(hdlKey);
		}
		else if ( (_dwPlatformId == VER_PLATFORM_WIN32_NT) &&
             (_dwMajorVersion >= 4) || OnWin9x())
#endif //_WIN64     
		{
			//call this function if on NT4 or Win98 (NOTE: it isn't sufficient to use
			//OnWin9x() to determine if we are on a win98 system but since the 
			//previous if stmt checks to see if we are in a win95 system OnWin9x
			//can be use)
			SystemParametersInfoA(SPI_GETWHEELSCROLLLINES, 0, &_cLineScroll, 0);
		}
	}

	return _cLineScroll;
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::CStrIn
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline these functions or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrIn::CStrIn(LPCWSTR pwstr, UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrIn::CStrIn");

    Init(pwstr, -1, CodePage);
}

CStrIn::CStrIn(LPCWSTR pwstr, int cwch, UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrIn::CStrIn");

    Init(pwstr, cwch, CodePage);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrIn::Init
//
//  Synopsis:   Converts a LPWSTR function argument to a LPSTR.
//
//  Arguments:  [pwstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cwch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrIn::Init(
	LPCWSTR pwstr,
	int		cwch,
	UINT	CodePage)	//@parm Code page to use (CP_ACP is default)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrIn::Init");

    int cchBufReq;

    _cchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD((DWORD_PTR)pwstr) == 0)
    {
        _pstr = (LPSTR) pwstr;
        return;
    }

    Assert(cwch == -1 || cwch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cchLen = W32->MbcsFromUnicode(_ach, ARRAY_SIZE(_ach), pwstr, cwch, CodePage);

    if (_cchLen > 0)
    {
        if(_ach[_cchLen-1] == 0)
            _cchLen--;                // account for terminator
        _pstr = _ach;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    TRACEINFOSZ("CStrIn: Allocating buffer for wrapped function argument.");

    cchBufReq = WideCharToMultiByte(
            CP_ACP, 0, pwstr, cwch, NULL, 0,  NULL, NULL);

    Assert(cchBufReq > 0);
    _pstr = new char[cchBufReq];
    if (!_pstr)
    {
        // On failure, the argument will point to the empty string.
        TRACEINFOSZ("CStrIn: No heap space for wrapped function argument.");
        _ach[0] = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pstr));
    _cchLen = -1 + W32->MbcsFromUnicode(_pstr, cchBufReq, pwstr, cwch);

    Assert(_cchLen >= 0);
}



//+---------------------------------------------------------------------------
//
//  Class:      CStrInMulti (CStrIn)
//
//  Purpose:    Converts multiple strings which are terminated by two NULLs,
//              e.g. "Foo\0Bar\0\0"
//
//----------------------------------------------------------------------------

class CStrInMulti : public CStrIn
{
public:
    CStrInMulti(LPCWSTR pwstr, UINT CodePage);
};



//+---------------------------------------------------------------------------
//
//  Member:     CStrInMulti::CStrInMulti
//
//  Synopsis:   Converts mulitple LPWSTRs to a multiple LPSTRs.
//
//  Arguments:  [pwstr] -- The strings to convert.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

CStrInMulti::CStrInMulti(
	LPCWSTR pwstr,
	UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInMulti::CStrInMulti");

    LPCWSTR pwstrT;

    // We don't handle atoms because we don't need to.
    Assert(HIWORD((DWORD_PTR)pwstr));

    //
    // Count number of characters to convert.
    //

    pwstrT = pwstr;
    if (pwstr)
    {
        do {
            while (*pwstrT++)
                ;

        } while (*pwstrT++);
    }

    Init(pwstr, pwstrT - pwstr, CodePage);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::CStrOut
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pwstr]   -- The Unicode buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cwchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOut::CStrOut(LPWSTR pwstr, int cwchBuf)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOut::CStrOut");

    Assert(cwchBuf >= 0);

    _pwstr = pwstr;
    _cwchBuf = cwchBuf;

    if (!pwstr)
    {
        Assert(cwchBuf == 0);
        _pstr = NULL;
        return;
    }

    Assert(HIWORD((DWORD_PTR)pwstr));

    // Initialize buffer in case Windows API returns an error.
    _ach[0] = 0;

    // Use preallocated buffer if big enough.
    if (cwchBuf * 2 <= ARRAY_SIZE(_ach))
    {
        _pstr = _ach;
        return;
    }

    // Allocate buffer.
    TRACEINFOSZ("CStrOut: Allocating buffer for wrapped function argument.");
    _pstr = new char[cwchBuf * 2];
    if (!_pstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        TRACEINFOSZ("CStrOut: No heap space for wrapped function argument.");
        Assert(cwchBuf > 0);
        _pwstr[0] = 0;
        _cwchBuf = 0;
        _pstr = _ach;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pstr));
    _pstr[0] = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::Convert
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//----------------------------------------------------------------------------

int
CStrOut::Convert()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOut::Convert");

    int cch;

    if (!_pstr)
        return 0;

    cch = MultiByteToWideChar(CP_ACP, 0, _pstr, -1, _pwstr, _cwchBuf);
    Assert(cch > 0 || _cwchBuf == 0);

    Free();

	if (cch > 0 && cch <= _cwchBuf && _pwstr[cch-1] == L'\0')
		cch--;

    return cch;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOut::~CStrOut
//
//  Synopsis:   Converts the buffer from MBCS to Unicode.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both Convert() and CConvertStr::~CConvertStr will be called
//              inline.
//
//----------------------------------------------------------------------------

CStrOut::~CStrOut()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOut::~CStrOut");

    Convert();
}


//
//	MultiByte --> UNICODE routins
//

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStr::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStr::Free()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CConvertStr::Free");

    if (_pstr != _ach && HIWORD((DWORD_PTR)_pstr) != 0)
    {
        delete [] _pstr;
    }

    _pstr = NULL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CConvertStrW::Free
//
//  Synopsis:   Frees string if alloc'd and initializes to NULL.
//
//----------------------------------------------------------------------------

void
CConvertStrW::Free()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CConvertStrW::Free");

    if (_pwstr != _awch && HIWORD((DWORD_PTR)_pwstr) != 0 )
    {
        delete [] _pwstr;
    }

    _pwstr = NULL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::CStrInW
//
//  Synopsis:   Inits the class.
//
//  NOTE:       Don't inline these functions or you'll increase code size
//              by pushing -1 on the stack for each call.
//
//----------------------------------------------------------------------------

CStrInW::CStrInW(LPCSTR pstr)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::CStrInW");

    Init(pstr, -1, CP_ACP);
}

CStrInW::CStrInW(LPCSTR pstr, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::CStrInW");

    Init(pstr, -1, uiCodePage);
}

CStrInW::CStrInW(LPCSTR pstr, int cch, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::CStrInW");

    Init(pstr, cch, uiCodePage);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrInW::Init
//
//  Synopsis:   Converts a LPSTR function argument to a LPWSTR.
//
//  Arguments:  [pstr] -- The function argument.  May be NULL or an atom
//                              (HIWORD(pwstr) == 0).
//
//              [cch]  -- The number of characters in the string to
//                          convert.  If -1, the string is assumed to be
//                          NULL terminated and its length is calculated.
//
//  Modifies:   [this]
//
//----------------------------------------------------------------------------

void
CStrInW::Init(LPCSTR pstr, int cch, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrInW::Init");

    int cchBufReq;

    _cwchLen = 0;

    // Check if string is NULL or an atom.
    if (HIWORD((DWORD_PTR)pstr) == 0)
    {
        _pwstr = (LPWSTR) pstr;
        return;
    }

    Assert(cch == -1 || cch > 0);

    //
    // Convert string to preallocated buffer, and return if successful.
    //

    _cwchLen = MultiByteToWideChar(
            uiCodePage, 0, pstr, cch, _awch, ARRAY_SIZE(_awch));

    if (_cwchLen > 0)
    {
        if(_awch[_cwchLen-1] == 0)
            _cwchLen--;                // account for terminator
        _pwstr = _awch;
        return;
    }

    //
    // Alloc space on heap for buffer.
    //

    TRACEINFOSZ("CStrInW: Allocating buffer for wrapped function argument.");

    cchBufReq = MultiByteToWideChar(
            CP_ACP, 0, pstr, cch, NULL, 0);

    Assert(cchBufReq > 0);
    _pwstr = new WCHAR[cchBufReq];
    if (!_pwstr)
    {
        // On failure, the argument will point to the empty string.
        TRACEINFOSZ("CStrInW: No heap space for wrapped function argument.");
        _awch[0] = 0;
        _pwstr = _awch;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pwstr));
    _cwchLen = -1 + MultiByteToWideChar(
            uiCodePage, 0, pstr, cch, _pwstr, cchBufReq);
    Assert(_cwchLen >= 0);
}


//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::CStrOutW
//
//  Synopsis:   Allocates enough space for an out buffer.
//
//  Arguments:  [pstr]   -- The ansi buffer to convert to when destroyed.
//                              May be NULL.
//
//              [cchBuf] -- The size of the buffer in characters.
//
//  Modifies:   [this].
//
//----------------------------------------------------------------------------

CStrOutW::CStrOutW(LPSTR pstr, int cchBuf, UINT uiCodePage)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOutW::CStrOutW");

    Assert(cchBuf >= 0);

    _pstr = pstr;
    _cchBuf = cchBuf;
	_uiCodePage = uiCodePage;

    if (!pstr)
    {
        Assert(cchBuf == 0);
        _pwstr = NULL;
        return;
    }

    Assert(HIWORD((DWORD_PTR)pstr));

    // Initialize buffer in case Windows API returns an error.
    _awch[0] = 0;

    // Use preallocated buffer if big enough.
    if (cchBuf <= ARRAY_SIZE(_awch))
    {
        _pwstr = _awch;
        return;
    }

    // Allocate buffer.
    TRACEINFOSZ("CStrOutW: Allocating buffer for wrapped function argument.");
    _pwstr = new WCHAR[cchBuf * 2];
    if (!_pwstr)
    {
        //
        // On failure, the argument will point to a zero-sized buffer initialized
        // to the empty string.  This should cause the Windows API to fail.
        //

        TRACEINFOSZ("CStrOutW: No heap space for wrapped function argument.");
        Assert(cchBuf > 0);
        _pstr[0] = 0;
        _cchBuf = 0;
        _pwstr = _awch;
        return;
    }

    Assert(HIWORD((DWORD_PTR)_pwstr));
    _pwstr[0] = 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::Convert
//
//  Synopsis:   Converts the buffer from Unicode to MBCS
//
//----------------------------------------------------------------------------

int
CStrOutW::Convert()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOutW::Convert");

    int cch;

    if (!_pwstr)
        return 0;

	int cchBuf = _cchBuf;

	cch = W32->MbcsFromUnicode(_pstr, cchBuf, _pwstr, -1, _uiCodePage);
    
	Free();
	if (cch > 0 && cch <= _cchBuf && _pstr[cch-1] == '\0')
		cch--;

    return cch;
}



//+---------------------------------------------------------------------------
//
//  Member:     CStrOutW::~CStrOutW
//
//  Synopsis:   Converts the buffer from Unicode to MBCS.
//
//  Note:       Don't inline this function, or you'll increase code size as
//              both Convert() and CConvertStr::~CConvertStr will be called
//              inline.
//
//----------------------------------------------------------------------------

CStrOutW::~CStrOutW()
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CStrOutW::~CStrOutW");

    Convert();
}

BOOL CW32System::GetVersion(
	DWORD *pdwPlatformId,
	DWORD *pdwMajorVersion,
	DWORD *pdwMinorVersion
)
{
	OSVERSIONINFOA osv;
	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
	*pdwPlatformId = 0;
	*pdwMajorVersion = 0;
	if (::GetVersionExA(&osv))
	{
		*pdwPlatformId = osv.dwPlatformId;
		*pdwMajorVersion = osv.dwMajorVersion;
		*pdwMinorVersion = osv.dwMinorVersion;
		return TRUE;
	}
	return FALSE;
}

BOOL CW32System::GetStringTypes(
	LCID	lcid,
	LPCTSTR lpSrcStr,
	int		cchSrc,
	LPWORD	lpCharType1,
	LPWORD	lpCharType3)
{
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
	{
		if(::GetStringTypeExW(lcid, CT_CTYPE1, lpSrcStr, cchSrc, lpCharType1))
			return ::GetStringTypeExW(lcid, CT_CTYPE3, lpSrcStr, cchSrc, lpCharType3);
		return FALSE;
	}

    CStrIn  str(lpSrcStr, cchSrc, ConvertLanguageIDtoCodePage(lcid));
	LONG	cch = str.strlen();

	if(::GetStringTypeExA(lcid, CT_CTYPE1, str, cch, lpCharType1))
		return ::GetStringTypeExA(lcid, CT_CTYPE3, str, cch, lpCharType3);
	return FALSE;
}

BOOL WINAPI CW32System::GetStringTypeEx(
	LCID	lcid,
	DWORD	dwInfoType,
	LPCTSTR lpSrcStr,
	int		cchSrc,
	LPWORD	lpCharType
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetStringTypeEx");
	
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetStringTypeExW(lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType);   

    CStrIn  str(lpSrcStr, cchSrc);
    return GetStringTypeExA(lcid, dwInfoType, str, str.strlen(), lpCharType);   
}

typedef LPSTR (CALLBACK *FnCharChangeCase)(LPSTR);

static LPWSTR CharChangeCase(LPWSTR pwstr, FnCharChangeCase pfn)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharChangeCaseWrap");

    if (HIWORD((DWORD_PTR)pwstr) == 0)
    {
        LPSTR   pstr=0;
		int		retCode;
		char	DBChar[3];

        retCode = W32->MbcsFromUnicode((LPSTR) &pstr, sizeof(pstr), (LPWSTR) &pwstr, 1);
        Assert(HIWORD((DWORD_PTR)pstr) == 0);
		if (retCode == 2)
		{
			// This is a DBC, use string
			DWORD	iTemp = (DWORD)((DWORD_PTR)pstr);
			DBChar[0] = char(iTemp & 0x0ff);
			DBChar[1] = char(iTemp >> 8);
			DBChar[2] = 0;
			pstr = (*pfn)(DBChar);
			W32->UnicodeFromMbcs((LPWSTR) &pwstr, sizeof(pwstr) / sizeof(WCHAR), (LPSTR)DBChar, 2);
		}
		else
		{
			pstr = (*pfn)(pstr);
			W32->UnicodeFromMbcs((LPWSTR) &pwstr, sizeof(pwstr) / sizeof(WCHAR), (LPSTR) &pstr);
		}
		Assert(HIWORD((DWORD_PTR)pwstr) == 0);
	}
    else
    {
        CStrOut strOut(pwstr, W32->wcslen(pwstr));
        W32->MbcsFromUnicode(strOut, strOut.BufSize(), pwstr);
        (*pfn)(strOut);
    }
    return pwstr;
}

LPWSTR WINAPI CW32System::CharLower(LPWSTR pwstr)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLower");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CharLowerW(pwstr);
    return CharChangeCase(pwstr, CharLowerA);
}

DWORD WINAPI CW32System::CharLowerBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLowerBuff");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CharLowerBuffW(pwstr, cchLength);
	LPWSTR lpBuffer = pwstr;
	for (DWORD pos = 0; pos < cchLength; pos++, lpBuffer++)
		*lpBuffer =  (WCHAR)CharChangeCase((LPWSTR)*lpBuffer, CharLowerA);
	return pos;
}

DWORD WINAPI CW32System::CharUpperBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharUpperBuff");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CharUpperBuffW(pwstr, cchLength);
	LPWSTR lpBuffer = pwstr;
	for (DWORD pos = 0; pos < cchLength; pos++, lpBuffer++)
		*lpBuffer =  (WCHAR)CharChangeCase((LPWSTR)*lpBuffer, CharUpperA);
	return pos;
}

typedef HDC (CALLBACK *FnCreateHDCA)(LPCSTR, LPCSTR, LPCSTR, CONST DEVMODEA *);

static HDC WINAPI CreateHDCAux(
	LPCWSTR             lpszDriver,
	LPCWSTR             lpszDevice,
	LPCWSTR             lpszOutput,
	CONST DEVMODEW *    lpInitData,
	FnCreateHDCA        pfn
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateHDCWrap");

    DEVMODEA    devmode;
    CStrIn      strDriver(lpszDriver);
    CStrIn      strDevice(lpszDevice);
    CStrIn      strOutput(lpszOutput);

	if ( lpInitData )
	{
		// converting DEVMODEW to DEVMODEA

		int byteCount;

		// copying the data between the two strings members
		byteCount = (char *)&(devmode.dmFormName) 
			- (char *)&(devmode.dmSpecVersion);
	    memcpy(&(devmode.dmSpecVersion), 
			&(lpInitData->dmSpecVersion), 
			byteCount);

		// copying the data after the second string member
 		byteCount = (char *)((char *)&devmode + sizeof(DEVMODEA)) 
			- (char *)&(devmode.dmLogPixels);
	    memcpy(&(devmode.dmLogPixels), 
			&(lpInitData->dmLogPixels), 
			byteCount);

		// converting the two strings members
		W32->MbcsFromUnicode((CHAR *)devmode.dmDeviceName, CCHDEVICENAME, lpInitData->dmDeviceName);
		W32->MbcsFromUnicode((CHAR *)devmode.dmFormName, CCHFORMNAME, lpInitData->dmFormName);
	}

    return (*pfn)(strDriver, strDevice, strOutput, 
		lpInitData ? &devmode : NULL);
}

HDC WINAPI CW32System::CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateIC");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CreateICW( lpszDriver, lpszDevice, lpszOutput, lpInitData );
    return CreateHDCAux(lpszDriver, lpszDevice, lpszOutput, lpInitData, CreateICA);
}

HANDLE WINAPI CW32System::CreateFile(
	LPCWSTR                 lpFileName,
	DWORD                   dwDesiredAccess,
	DWORD                   dwShareMode,
	LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
	DWORD                   dwCreationDisposition,
	DWORD                   dwFlagsAndAttributes,
	HANDLE                  hTemplateFile
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFile");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CreateFileW(lpFileName,
							dwDesiredAccess,
							dwShareMode,
							lpSecurityAttributes,
							dwCreationDisposition,
							dwFlagsAndAttributes,
							hTemplateFile);

    CStrIn  str(lpFileName);
    return ::CreateFileA(
            str,
            dwDesiredAccess,
            dwShareMode,
            lpSecurityAttributes,
            dwCreationDisposition,
            dwFlagsAndAttributes,
            hTemplateFile);
}

HFONT WINAPI CW32System::CreateFontIndirect(CONST LOGFONTW * plfw)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFontIndirect");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CreateFontIndirectW(plfw);
    LOGFONTA  lfa;
    HFONT     hFont;

    memcpy(&lfa, plfw, offsetof(LOGFONTA, lfFaceName));
    MbcsFromUnicode(lfa.lfFaceName, ARRAY_SIZE(lfa.lfFaceName), plfw->lfFaceName,
		-1, CP_ACP, UN_NOOBJECTS);
    hFont = ::CreateFontIndirectA(&lfa);
    return hFont;
}

int WINAPI CW32System::CompareString ( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cch1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cch2 			// size, in bytes or characters, of second string  
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CompareString");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::CompareStringW(Locale, dwCmpFlags, lpString1, cch1, lpString2, cch2);

    CStrIn      str1(lpString1, cch1);
    CStrIn      str2(lpString2, cch2);

	return CompareStringA(
		Locale,
		dwCmpFlags,
		str1,
		str1.strlen(),
		str2,
		str2.strlen()
		);
}

LRESULT WINAPI CW32System::DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "DefWindowProcWrap");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::DefWindowProcW(hWnd, msg, wParam, lParam);
	return ::DefWindowProcA(hWnd, msg, wParam, lParam);
}

int WINAPI CW32System::GetObject(HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetObject");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetObjectW( hgdiObj, cbBuffer, lpvObj);

    int nRet;

    if(cbBuffer != sizeof(LOGFONTW) || !lpvObj)
    {
        nRet = ::GetObjectA(hgdiObj, cbBuffer, lpvObj);
        if(nRet == sizeof(LOGFONTA))
        {
            nRet = sizeof(LOGFONTW);
        }
    }
    else
    {
        LOGFONTA lfa;

        nRet = ::GetObjectA(hgdiObj, sizeof(lfa), &lfa);

        if(nRet > 0)
        {
            memcpy(lpvObj, &lfa, offsetof(LOGFONTW, lfFaceName));
            UnicodeFromMbcs(((LOGFONTW*)lpvObj)->lfFaceName, ARRAY_SIZE(((LOGFONTW*)lpvObj)->lfFaceName),
                            lfa.lfFaceName, -1);
            nRet = sizeof(LOGFONTW);
        }
    }

    return nRet;
}

DWORD APIENTRY CW32System::GetProfileSection(
	LPCWSTR lpAppName,
	LPWSTR lpReturnedString,
	DWORD nSize
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetProfileSection");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetProfileSectionW( lpAppName, lpReturnedString, nSize );

	CStrIn 	strAppName(lpAppName);

	// we can't use CStrOut here, since the returned string contains a set of
	// strings delimited by single-NULL's and terminated by a double-NULL
	char *pszReturnedString;

	pszReturnedString = new char[nSize];
	Assert(pszReturnedString);

	DWORD cch = ::GetProfileSectionA(strAppName, pszReturnedString, nSize);

	if(cch)
	{
		cch = MultiByteToWideChar(CP_ACP, 0, pszReturnedString, cch, 
								lpReturnedString, nSize);
	}

	delete pszReturnedString;
	return cch;
}

BOOL APIENTRY CW32System::GetTextExtentPoint32(
	HDC     hdc,
	LPCWSTR pwsz,
	int     cb,
	LPSIZE  pSize
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextExtentPoint32");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetTextExtentPoint32W( hdc, pwsz, cb, pSize );
     CStrIn str(pwsz);
     return ::GetTextExtentPoint32A(hdc, str, cb, pSize);
}

int WINAPI CW32System::GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextFace");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetTextFaceW( hdc, cch, lpFaceName );
    CStrOut str(lpFaceName, cch);
    ::GetTextFaceA(hdc, str.BufSize(), str);
    return str.Convert();
}

BOOL WINAPI CW32System::GetTextMetrics(HDC hdc, LPTEXTMETRICW lptm)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextMetrics");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetTextMetricsW( hdc, lptm);

   BOOL         ret;
   TEXTMETRICA  tm;

   ret = ::GetTextMetricsA(hdc, &tm);

    if (ret)
    {
        lptm->tmHeight              = tm.tmHeight;
        lptm->tmAscent              = tm.tmAscent;
        lptm->tmDescent             = tm.tmDescent;
        lptm->tmInternalLeading     = tm.tmInternalLeading;
        lptm->tmExternalLeading     = tm.tmExternalLeading;
        lptm->tmAveCharWidth        = tm.tmAveCharWidth;
        lptm->tmMaxCharWidth        = tm.tmMaxCharWidth;
        lptm->tmWeight              = tm.tmWeight;
        lptm->tmOverhang            = tm.tmOverhang;
        lptm->tmDigitizedAspectX    = tm.tmDigitizedAspectX;
        lptm->tmDigitizedAspectY    = tm.tmDigitizedAspectY;
        lptm->tmItalic              = tm.tmItalic;
        lptm->tmUnderlined          = tm.tmUnderlined;
        lptm->tmStruckOut           = tm.tmStruckOut;
        lptm->tmPitchAndFamily      = tm.tmPitchAndFamily;
        lptm->tmCharSet             = tm.tmCharSet;

        UnicodeFromMbcs(&lptm->tmFirstChar, 1, (LPSTR) &tm.tmFirstChar, 1);
        UnicodeFromMbcs(&lptm->tmLastChar, 1, (LPSTR) &tm.tmLastChar, 1);
        UnicodeFromMbcs(&lptm->tmDefaultChar, 1, (LPSTR) &tm.tmDefaultChar, 1);
        UnicodeFromMbcs(&lptm->tmBreakChar, 1, (LPSTR) &tm.tmBreakChar, 1);
    }

    return ret;
}

LONG WINAPI CW32System::GetWindowLong(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLong");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetWindowLongW(hWnd, nIndex);
	return ::GetWindowLongA(hWnd, nIndex);
}

LONG_PTR WINAPI CW32System::GetWindowLongPtr(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLongPtr");
#ifdef _WIN64
	return GetWindowLongPtrW(hWnd, nIndex);
#else
	return GetWindowLong(hWnd, nIndex);
#endif
}

DWORD WINAPI CW32System::GetClassLong(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetClassLong");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetClassLongW(hWnd, nIndex);
	return ::GetClassLongA(hWnd, nIndex);
}

HBITMAP WINAPI CW32System::LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadBitmap");
    Assert(HIWORD((DWORD_PTR)lpBitmapName) == 0);
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::LoadBitmapW(hInstance, lpBitmapName);
    return ::LoadBitmapA(hInstance, (LPCSTR) lpBitmapName);
}

HCURSOR WINAPI CW32System::LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadCursor");
    Assert(HIWORD((DWORD_PTR)lpCursorName) == 0);
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::LoadCursorW(hInstance, lpCursorName);
    return ::LoadCursorA(hInstance, (LPCSTR) lpCursorName);
}

HINSTANCE WINAPI CW32System::LoadLibrary(LPCWSTR lpLibFileName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadLibrary");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::LoadLibraryW(lpLibFileName);
    CStrIn  str(lpLibFileName);
    return ::LoadLibraryA(str);
}

LRESULT WINAPI CW32System::SendMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SendMessage");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId && ::IsWindowUnicode(hWnd))
		return ::SendMessageW(hWnd, Msg, wParam, lParam);

	// We never need Ansi to Unicode translation in our use of SendMessage
	// Our list boxes always use Unicode.
    switch (Msg)
    {
	// We don't want to translate these!
	// case LB_ADDSTRING:
    // case LB_INSERTSTRING:
    // case CB_ADDSTRING:
    // case CB_SELECTSTRING:
    // case CB_INSERTSTRING:
    // case LB_GETTEXT:
    // case CB_GETLBTEXT:

    case WM_GETTEXT:
		{
		   CStrOut str((LPWSTR)lParam, (int)wParam);
			::SendMessageA(hWnd, Msg, str.BufSize(), (LPARAM)(LPSTR)str);
			return str.Convert();
		}
		break;

    case WM_SETTEXT:
    case EM_REPLACESEL:
        Assert(FALSE);		// We never send these.  Dead code?
		break;

    case EM_SETPASSWORDCHAR:
        Assert(FALSE);		// We never send these.  Dead code?
		break;
    }
	return ::SendMessageA(hWnd, Msg, wParam, lParam);
}

LONG WINAPI CW32System::SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLong");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::SetWindowLongW(hWnd, nIndex, dwNewLong);
    return ::SetWindowLongA(hWnd, nIndex, dwNewLong);
}

LONG WINAPI CW32System::SetWindowLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLongPtr");
#ifdef _WIN64
	return ::SetWindowLongPtrW(hWnd, nIndex, dwNewLong);
#else
	return SetWindowLong(hWnd, nIndex, dwNewLong);
#endif
}

BOOL WINAPI CW32System::PostMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PostMessage");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::PostMessageW(hWnd, Msg, wParam, lParam);
    return ::PostMessageA(hWnd, Msg, wParam, lParam);
}

BOOL WINAPI CW32System::UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "UnregisterClass");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::UnregisterClassW( lpClassName, hInstance);
    CStrIn  str(lpClassName);
    return ::UnregisterClassA(str, hInstance);
}

int WINAPI CW32System::lstrcmp(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmp");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::lstrcmpW(lpString1, lpString2);
    return W32->wcscmp(lpString1, lpString2);
}

int WINAPI CW32System::lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmpi");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::lstrcmpiW(lpString1, lpString2);

	// Fall back on the simple minded CRT algortihm
	// The CRT actually has two paths.  This is the simple one
	const wchar_t * dst = lpString1;
    const wchar_t * src = lpString2;
	wchar_t f,l;
	
	do	{
		f = ((*dst <= L'Z') && (*dst >= L'A'))
			? *dst + L'a' - L'A'
			: *dst;
		l = ((*src <= L'Z') && (*src >= L'A'))
			? *src + L'a' - L'A'
			: *src;
		dst++;
		src++;
	} while ( (f) && (f == l) );
	
	return (int)(f - l);
}

BOOL WINAPI CW32System::PeekMessage(
	LPMSG   lpMsg,
    HWND    hWnd,
    UINT    wMsgFilterMin,
    UINT    wMsgFilterMax,
    UINT    wRemoveMsg
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PeekMessage");
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
    return ::PeekMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

DWORD WINAPI CW32System::GetModuleFileName(
	HMODULE hModule,
	LPWSTR lpFilename,
	DWORD nSize
)
{
	if (VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId)
		return ::GetModuleFileNameW(hModule, lpFilename, nSize);
    CStrOut  strout(lpFilename, nSize);
    DWORD res = ::GetModuleFileNameA(hModule, strout, nSize);
	strout.Convert();
	return res; 
}


// The high bits of _yHeightUI & _yHeightOther are being used to check if
// font is installed in the system
#define NEED_TO_CHECK_FONT 0x080
struct PreferredFontInfo
{
	BYTE _bPitchAndFamilyUI;
	BYTE _yHeightUI;
	SHORT _iFontUI;
	BYTE _bPitchAndFamilyOther;
	BYTE _yHeightOther;
	SHORT _iFontOther;
};

PreferredFontInfo g_pfinfo[NCHARSETS];

void CW32System::InitPreferredFontInfo()
{
	// For UI case, we will use Word9 UI fonts
	// For Non-UI case, we will use Word9 default email fonts
	
	short iFont;
	UINT  uSysDefCodePage = GetSystemDefaultCodePage();

	// Japanese Init
	static const WCHAR lpUIJapanFontName[] = L"MS UI Gothic";
	static const WCHAR lpOthJapanFontName[]
		= {0xFF2D,0xFF33,0x0020,0xFF30,0x30B4,0x30B7,0x30C3,0x30AF, 0};
	static const WCHAR lpOthJapanFontNameEUC[] = L"MS PGothic";

	iFont = GetFontNameIndex( lpUIJapanFontName );
	SetPreferredFontInfo( CP_JAPAN, true, iFont, 9 | NEED_TO_CHECK_FONT, 17 );
	if (uSysDefCodePage == CP_JAPAN)
		iFont = GetFontNameIndex( lpOthJapanFontName );
	else
		iFont = GetFontNameIndex( lpOthJapanFontNameEUC );
	SetPreferredFontInfo( CP_JAPAN, false, iFont, 10 | NEED_TO_CHECK_FONT, 17 );

	// Korean Init
	static const WCHAR lpUIKoreanFontName[] = {0xAD74, 0xB9BC, 0};
	static const WCHAR lpUIKoreanFontNameEUC[] = L"Gulim";
	
	if (uSysDefCodePage == CP_KOREAN)
		iFont = GetFontNameIndex( lpUIKoreanFontName );		
	else
		iFont = GetFontNameIndex( lpUIKoreanFontNameEUC );

	SetPreferredFontInfo( CP_KOREAN, true, iFont, 9 | NEED_TO_CHECK_FONT, 49 );
	SetPreferredFontInfo( CP_KOREAN, false, iFont, 9 | NEED_TO_CHECK_FONT, 49 );

	// Traditional Chinese Init
	static const WCHAR lpUITChineseFontName[]	= {0x65B0, 0x7D30, 0x660E, 0x9AD4, 0};
	static const WCHAR lpUITChineseFontNameEUC[] = L"PMingLiU";
	iFont = GetFontNameIndex(uSysDefCodePage == CP_CHINESE_TRAD
							 ? lpUITChineseFontName : lpUITChineseFontNameEUC);
	SetPreferredFontInfo( CP_CHINESE_TRAD, true, iFont, 9 | NEED_TO_CHECK_FONT, 54 );
	SetPreferredFontInfo( CP_CHINESE_TRAD, false, iFont, 9 | NEED_TO_CHECK_FONT, 54 );

	// Simplified Chinese Init
	static const WCHAR lpUISChineseFontName[] = {0x5B8B, 0x4F53, 0};
	static const WCHAR lpUISChineseFontNameEUC[] = L"SimSun";
	iFont = GetFontNameIndex(uSysDefCodePage == CP_CHINESE_SIM
							 ? lpUISChineseFontName : lpUISChineseFontNameEUC);
	SetPreferredFontInfo( CP_CHINESE_SIM, true,  iFont,  9 | NEED_TO_CHECK_FONT, 54 );
	SetPreferredFontInfo( CP_CHINESE_SIM, false, iFont, 10 | NEED_TO_CHECK_FONT, 54 );

	// English Init
	iFont = GetFontNameIndex( szTahoma );
	SetPreferredFontInfo(1252, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	iFont = GetFontNameIndex( szArial );
	SetPreferredFontInfo(1252, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );

	// SYMBOL_CHARSET
	iFont = GetFontNameIndex( szWingdings );
	SetPreferredFontInfo(CP_SYMBOL, true,  iFont, 8,  DEFAULT_PITCH | FF_DONTCARE);
	SetPreferredFontInfo(CP_SYMBOL, false, iFont, 10, DEFAULT_PITCH | FF_DONTCARE);
	
	// Vietnamese Init
	iFont = GetFontNameIndex( szTahoma );
	SetPreferredFontInfo(1258, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	iFont = GetFontNameIndex( szArial );
	SetPreferredFontInfo(1258, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );

	// Thai Init
	if (OnWinNT5())
		iFont = GetFontNameIndex( szMicrosSansSerif );
	else 
		iFont = GetFontNameIndex( szTahoma );

	SetPreferredFontInfo(874, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	iFont = GetFontNameIndex( szCordiaNew );
	SetPreferredFontInfo(874, false, iFont, 14, DEFAULT_PITCH | FF_SWISS );

	// Devanagari Init
	iFont = GetFontNameIndex( szMangal );
	SetPreferredFontInfo(CP_DEVANAGARI, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(CP_DEVANAGARI, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );

	// Tamil Init
	iFont = GetFontNameIndex( szLatha );
	SetPreferredFontInfo(CP_TAMIL, true, iFont, 8, DEFAULT_PITCH | FF_SWISS );
	SetPreferredFontInfo(CP_TAMIL, false, iFont, 10, DEFAULT_PITCH | FF_SWISS );

	// Georgian and Armenian Init
	if(OnWinNT5())
	{
		iFont = GetFontNameIndex(szArialUnicode);
		SetPreferredFontInfo(CP_GEORGIAN, true,  iFont,  8, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(CP_GEORGIAN, false, iFont, 10, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(CP_ARMENIAN, true,  iFont,  8, DEFAULT_PITCH | FF_SWISS);
		SetPreferredFontInfo(CP_ARMENIAN, false, iFont, 10, DEFAULT_PITCH | FF_SWISS);
	}
	_fFEFontInfo = FEDATA_NOT_INIT;

	// Check installed keyboard layouts
	CheckInstalledKeyboards();
}

void CW32System::CheckInstalledKeyboards()
{
	HKL	 rghkl[MAX_HKLS];
    INT	 cLayouts = ::GetKeyboardLayoutList(MAX_HKLS, rghkl);		 	
	LONG cpg;
	INT  iScript;

	for(INT i = 0; i < cLayouts; i++)
  	{
		cpg = ConvertLanguageIDtoCodePage(PRIMARYLANGID(rghkl[i]));
		GetCharSet(cpg, &iScript);			// Get script index
 		if(iScript >= 0)
			SetPreferredKbd(iScript, rghkl[i]);
   	}
}

bool CW32System::SetPreferredFontInfo(
	int cpg,
	bool fUIFont,
	SHORT iFont,
	BYTE yHeight,
	BYTE bPitchAndFamily
)
{
	int iPFI;
	CLock lock;

	GetCharSet(	cpg, &iPFI );

	if (iPFI == -1)
		return false;

	if (fUIFont)
	{
		g_pfinfo[iPFI]._bPitchAndFamilyUI = bPitchAndFamily;
		g_pfinfo[iPFI]._yHeightUI = yHeight;
		g_pfinfo[iPFI]._iFontUI = iFont;
	}
	else
	{
		g_pfinfo[iPFI]._bPitchAndFamilyOther = bPitchAndFamily;
		g_pfinfo[iPFI]._yHeightOther = yHeight;
		g_pfinfo[iPFI]._iFontOther = iFont;
	}
	SetFontLegitimateSize(iFont, fUIFont, yHeight & ~NEED_TO_CHECK_FONT, cpg);

	return true;
}

bool CW32System::GetPreferredFontInfo(
	int cpg,
	bool fUIFont,
	SHORT& iFont,
	BYTE& yHeight,
	BYTE& bPitchAndFamily
)
{
	int iPFI;

	if (GetCharSet(	cpg, &iPFI ) && (iPFI == -1))
		return false;

	if (g_pfinfo[iPFI]._iFontUI == 0)
	{
		/* No entry.  Try default */
		iPFI = 0;
	}

	if (fUIFont)
	{
		bPitchAndFamily = g_pfinfo[iPFI]._bPitchAndFamilyUI;
		yHeight = g_pfinfo[iPFI]._yHeightUI;
		iFont = g_pfinfo[iPFI]._iFontUI;
	}
	else
	{
		bPitchAndFamily = g_pfinfo[iPFI]._bPitchAndFamilyOther;
		yHeight = g_pfinfo[iPFI]._yHeightOther;
		iFont = g_pfinfo[iPFI]._iFontOther;
	}
	
	if (yHeight & NEED_TO_CHECK_FONT)
	{
		// Check if the preferred font is installed in the system.
		CLock lock;

		HDC hDC = GetScreenDC();

		// Turn off the checkfont bit
		yHeight &= ~NEED_TO_CHECK_FONT;

		if (fUIFont)
			g_pfinfo[iPFI]._yHeightUI &= ~NEED_TO_CHECK_FONT;
		else
			g_pfinfo[iPFI]._yHeightOther &= ~NEED_TO_CHECK_FONT;
		
		if (hDC)
		{
			const short *pFontIndex = fUIFont ? &g_pfinfo[iPFI]._iFontUI : &g_pfinfo[iPFI]._iFontOther;
			if (IsFontAvail( hDC, cpg, fUIFont, (short *)pFontIndex))
				iFont = *pFontIndex;
				
		}
	}

	return true;
}

/*
 *	CW32System::GetPreferredFontHeight(
 *		bool	fUIFont,
 *		BYTE	bOrgCharSet, 
 *		BYTE	bNewCharSet, 
 *		SHORT	yOrgHeight)
 *
 *
 *	@mfunc
 *		called when we need the default font size when changing from one charset to another.
 *
 *	@rdesc
 *		The preferred default font size in TWIP if the Original height is same as the
 *		original charset default font size.  Otherwise, it will return the Original height.
 *
 */
SHORT  CW32System::GetPreferredFontHeight(	
	bool	fUIFont,
	BYTE	bOrgCharSet, 
	BYTE	bNewCharSet, 
	SHORT	yOrgHeight
)
{
	BYTE	yOrgPreferredHeight;
	LONG	idxOrgFont = ScriptIndexFromCharSet(bOrgCharSet);
	LONG	idxNewFont = ScriptIndexFromCharSet(bNewCharSet);

	// No entry, forget it
	if (idxOrgFont == -1 || idxNewFont == -1)
		return yOrgHeight;

	yOrgPreferredHeight = fUIFont ? 
		g_pfinfo[idxOrgFont]._yHeightUI : g_pfinfo[idxOrgFont]._yHeightOther;
			
	// Get New Preferred Height
	if (yOrgPreferredHeight && yOrgPreferredHeight == yOrgHeight/TWIPS_PER_POINT)
	{
		BYTE yNewHeight = (fUIFont ? 
			g_pfinfo[idxNewFont]._yHeightUI : g_pfinfo[idxNewFont]._yHeightOther);

		if (yNewHeight)
			return yNewHeight * TWIPS_PER_POINT;
	}
		
	return yOrgHeight;
}

/*
 *	CW32System::CheckInstalledFEFonts()
 *
 *
 *	@mfunc
 *		called when building FE fonts installed and User default LCID info
 *
 *	@devnote
 *		This information is necessary when we want to classify Chinese characters
 *		and Full-width characters.
 *
 */
void CW32System::CheckInstalledFEFonts()
{
	UINT	uUserCodepage;
	CLock	cLock;
	HDC hDC = GetScreenDC();

	_fFEFontInfo = 0;
	
	uUserCodepage = ConvertLanguageIDtoCodePage(::GetUserDefaultLCID());
	if (!IsFECodePage(uUserCodepage))
		uUserCodepage = GetACP();

	switch (uUserCodepage)
	{
		case CP_JAPAN:
			_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_JPN | JPN_FONT_AVAILABLE);
			break;

		case CP_KOREAN:
			_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_KOR | KOR_FONT_AVAILABLE);
			break;

		case CP_CHINESE_TRAD:
			_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_BIG5 | BIG5_FONT_AVAILABLE);
			break;

		case CP_CHINESE_SIM:
			_fFEFontInfo |= (FEUSER_LCID | FEUSER_CP_GB | GB_FONT_AVAILABLE);
			break;
	}

	if (hDC)
	{
		if (!(_fFEFontInfo & JPN_FONT_AVAILABLE) && IsFontAvail(hDC, CP_JAPAN))
			_fFEFontInfo |= JPN_FONT_AVAILABLE;

		if (!(_fFEFontInfo & KOR_FONT_AVAILABLE) && IsFontAvail(hDC, CP_KOREAN))
			_fFEFontInfo |= KOR_FONT_AVAILABLE;

		if (!(_fFEFontInfo & BIG5_FONT_AVAILABLE) && IsFontAvail(hDC, CP_CHINESE_TRAD))
			_fFEFontInfo |= BIG5_FONT_AVAILABLE;

		if (!(_fFEFontInfo & GB_FONT_AVAILABLE) && IsFontAvail(hDC, CP_CHINESE_SIM))
			_fFEFontInfo |= GB_FONT_AVAILABLE;
	}

}
/*
 *	CW32System::IsFEFontInSystem( cpg )
 *
 *
 *	@mfunc
 *		check if there is any FE font installed for the given codepage
 *
 *	@devnote
 *		This information is necessary when we want to classify Chinese characters
 *		and Full-width characters.
 *
 */
bool CW32System::IsFEFontInSystem(int cpg)
{
	int fFontExist = 0;

	if (_fFEFontInfo == FEDATA_NOT_INIT)
	{
		CLock	Lock;

		// Look for FE fonts in the system
		CheckInstalledFEFonts();
	}

	// Check if font for the codepage is in the system	
	switch (cpg)
	{
	case CP_JAPAN:
		fFontExist = _fFEFontInfo & JPN_FONT_AVAILABLE;
		break;
		
	case CP_KOREAN:
		fFontExist = _fFEFontInfo & KOR_FONT_AVAILABLE;
		break;

	case CP_CHINESE_TRAD:
		fFontExist = _fFEFontInfo & BIG5_FONT_AVAILABLE;
		break;

	case CP_CHINESE_SIM:
		fFontExist = _fFEFontInfo & GB_FONT_AVAILABLE;
		break;
	}
	
	return (fFontExist != 0);
}

/*
 *	CW32System::IsFontAvail( HDC hDC, int cpg, bool	fUIFont, short *piFontIndex )
 *
 *
 *	@mfunc
 *		called when checking if a font (UI or non-UI) is installed for a given codepage
 *
 *	@devnote
 *		We will try to create the font and verify the charset of the font
 *		actually created.  If the fontname index is supplied, we will check
 *		if the requested font is installed. If the name from GDI is different,
 *		the GDI font index will be returned in piFontIndex.
 *
 *	@rdesc
 *		true if a font that supports the given codepage is available.
 */
bool CW32System::IsFontAvail(
	HDC		hDC,				//@parm	Screen hDC
	int		cpg,				//@parm cpg	
	bool	fUIFont,			//@parm UI font?
	short	*piFontIndex)		//@parm Font Name Index (default = NULL)
{
	LOGFONTW	lf;
	HFONT		hfont;
	bool		retCode = false;
	int			iPFI;
	BYTE		bCharSet;

	if ((bCharSet = GetCharSet(cpg, &iPFI)) && (iPFI == -1))
		return false;

	ZeroMemory(&lf, sizeof(lf));
    
	// We want GDI to find a font that will support this charset 
	// Unspecified entries in LOGFONT will be either default or don't care.
	lf.lfCharSet = bCharSet; 
	
	if (fUIFont)
	{
		lf.lfHeight = g_pfinfo[iPFI]._yHeightUI;
		lf.lfPitchAndFamily = g_pfinfo[iPFI]._bPitchAndFamilyUI;
		wcscpy(lf.lfFaceName, GetFontName((LONG)(g_pfinfo[iPFI]._iFontUI)));
	}
	else
	{
		lf.lfHeight = g_pfinfo[iPFI]._yHeightOther;
		lf.lfPitchAndFamily = g_pfinfo[iPFI]._bPitchAndFamilyOther;
		wcscpy(lf.lfFaceName, GetFontName((LONG)(g_pfinfo[iPFI]._iFontOther)));
	}

	hfont = CreateFontIndirect(&lf);
    
	if(hfont)
    {
		TEXTMETRIC tm;

		HFONT hfontOld = SelectFont(hDC, hfont);
					
		if (GetTextMetrics(hDC, &tm) && tm.tmCharSet == bCharSet)
		{
			retCode = true;

			if (piFontIndex)
			{
				const WCHAR	*pszFontName = GetFontName(*piFontIndex);

				if (pszFontName)
				{ 
					WCHAR szNewFaceName[LF_FACESIZE];
					
					// Check if GDI gives us the same font name
					szNewFaceName[0] = L'\0';
					GetTextFace(hDC, LF_FACESIZE, szNewFaceName);
					if (szNewFaceName[0] && wcsicmp(pszFontName, szNewFaceName))
						*piFontIndex = GetFontNameIndex(szNewFaceName);	// Different name					
				}
			}
		}

		SelectFont(hDC, hfontOld);
		DeleteObject(hfont);
	}

	return retCode;
}

/*
 *	CW32System::GetFEFontInfo( void  )
 *
 *
 *	@mfunc
 *		called when classifying Chinese characters and Full-width characters
 *
 *	@devnote
 *		Chinese characters and Full-width characters can be in any
 *		of the four FE codepages.  We want to classfy them according to the 
 *		User default LCID and which FE fonts are installed in the system.
 *
 *	@rdesc
 *		Codepage for the character.
 */
UINT CW32System::GetFEFontInfo()
{
	int	iDefUserCodepage = -1;

	if (_fFEFontInfo == FEDATA_NOT_INIT)
	{
		CLock	Lock;

		// Check if FE fonts are available in the system
		CheckInstalledFEFonts();
	}

	if (_fFEFontInfo & FEUSER_LCID)
		iDefUserCodepage = (_fFEFontInfo & FEUSER_CODEPAGE);

	if (iDefUserCodepage == FEUSER_CP_BIG5)
		return CP_CHINESE_TRAD;

	if (iDefUserCodepage == FEUSER_CP_GB)
		return CP_CHINESE_SIM;	
	
	if (iDefUserCodepage == FEUSER_CP_JPN)
		return CP_JAPAN;

	if (iDefUserCodepage == FEUSER_CP_KOR)		
		return CP_KOREAN;

	// Check which font is available and return the corresponding codepage
	// We check for Simplified Chinese first since it contains more Chinese
	// characters than Traditional Chinese.
	if (_fFEFontInfo & GB_FONT_AVAILABLE)
		return CP_CHINESE_SIM;

	if (_fFEFontInfo & BIG5_FONT_AVAILABLE)
		return CP_CHINESE_TRAD;

	if (_fFEFontInfo & JPN_FONT_AVAILABLE)
		return CP_JAPAN;

	if (_fFEFontInfo & KOR_FONT_AVAILABLE)
		return CP_KOREAN;

	return CP_CHINESE_SIM;				// Well, no FE font, tough luck.
}

/*
 *	CW32System::IsDiacriticOrKashida(ch, wC3Type)
 *
 *	@mfunc
 *		Return TRUE if ch or wC3Type reveals that ch is a nonspacing
 *		diacritic or a kashida. Because Win9x GetStringTypeExW isn't
 *		implemented, we use range checks for Win9x.
 *
 *	@rdesc
 *		True if ch or wC3Type reveals that ch is a nonspacing diacritic
 */
BOOL CW32System::IsDiacriticOrKashida(
	WCHAR ch,		//@parm On Win9x, check ranges for ch
	WORD  wC3Type)	//@parm On WinNT, use C3-type check
{
	if(VER_PLATFORM_WIN32_WINDOWS != _dwPlatformId && wC3Type)
		return wC3Type & (C3_DIACRITIC | C3_NONSPACING | C3_VOWELMARK | C3_KASHIDA);

	if(!IN_RANGE(0x300, ch, 0xe50))		// Combining diacritics of interest
		return FALSE;					//  fall in this range

	return IN_RANGE(0x300, ch, 0x36F) || IsDiacritic(ch) || IsBiDiKashida(ch);
}

/*
 *	CW32System::IsDiacritic(ch)
 *
 *	@mfunc
 *		Return TRUE if ch falls in BiDi, Thai, Devanagari or Tamil diacritic range.
 */
BOOL CW32System::IsDiacritic(
	WCHAR ch)
{
	// BiDi
	if (IsBiDiDiacritic(ch))
		return TRUE;

	// Thai
	if (IN_RANGE(0xe31, ch, 0xe4e))
		return 	IN_RANGE(0x0e47, ch, 0x0e4e) || IN_RANGE(0x0e34, ch, 0x0e3a) || ch == 0x0e31;

	// Devanagari
	if (IN_RANGE(0x0902, ch, 0x0963))
		return 	IN_RANGE(0x0941, ch, 0x0948) || IN_RANGE(0x0951, ch, 0x0954) || ch == 0x094d ||		
				IN_RANGE(0x0962, ch, 0x0963) || IN_RANGE(0x0901, ch, 0x0902) || ch == 0x093c;

	// Tamil
	if (IN_RANGE(0x0b82, ch, 0x0bcd))
		return 	ch == 0x0bcd || ch == 0x0bc0 || ch == 0x0b82;

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\win2mac.cpp ===
//----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       win2mac.cpp
//
//  Contents:   All functions that are not implemented for the Macintosh
//              Stubs are coded so that we can link cleanly.
//
//----------------------------------------------------------------------------

#ifndef PEGASUS
#include "_common.h"
#include <mbstring.h>
#include "stdio.h"

#if defined(MACPORT) && defined(UNICODE)

#include <macname1.h>
#include <quickdraw.h>
#include <macname2.h>

AssertData

//----------------------------------------------------------------------------
//
//	Mac wrapper functions  
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
//
//  Function:   MacCLSIDFromProgID
//
//----------------------------------------------------------------------------
#undef CLSIDFromProgID
STDAPI MacCLSIDFromProgID (LPCWSTR lpszProgID, LPCLSID lpclsid)
{
	CStrIn str(lpszProgID);
	return CLSIDFromProgID((LPOLESTR)str, lpclsid);
}

//----------------------------------------------------------------------------
//
//  Function:   MacCoTaskMemAlloc
//
//----------------------------------------------------------------------------
STDAPI_(LPVOID) MacCoTaskMemAlloc(ULONG cb)
{
	IMalloc		*pIMalloc = NULL;
	HRESULT		hr;
	HGLOBAL		pMem = NULL;

	hr = CoGetMalloc ( MEMCTX_TASK, &pIMalloc);
	if (hr)
	{
		goto Cleanup; 
	}

	pMem = pIMalloc->Alloc(cb);

Cleanup:
	if(	pIMalloc )
		pIMalloc->Release();
    return (LPVOID)pMem;

}

//----------------------------------------------------------------------------
//
//  Function:   MacCoTaskMemFree
//
//----------------------------------------------------------------------------
STDAPI_(void)   MacCoTaskMemFree(LPVOID pv)
{
	IMalloc		*pIMalloc = NULL;
	HRESULT		hr;
	HGLOBAL		pMem = NULL;

	hr = CoGetMalloc ( MEMCTX_TASK, &pIMalloc);
	if (hr)
	{
		goto Cleanup; 
	}
	pIMalloc->Free(pv);

Cleanup:
	if(	pIMalloc )
		pIMalloc->Release();

}
//----------------------------------------------------------------------------
//
//  Function:   MacCoTaskMemRealloc
//
//----------------------------------------------------------------------------
STDAPI_(LPVOID) MacCoTaskMemRealloc(LPVOID pv, ULONG cb)
{
	IMalloc		*pIMalloc = NULL;
	HRESULT		hr;
	HGLOBAL		pMem = NULL;

	hr = CoGetMalloc ( MEMCTX_TASK, &pIMalloc);
	if (hr)
	{
		goto Cleanup; 
	}

	pMem = pIMalloc->Realloc(pv,cb);

Cleanup:
	if(	pIMalloc )
		pIMalloc->Release();
    return (LPVOID)pMem;

}

//----------------------------------------------------------------------------
//
//  Function:   MacGetCurrentObject
//
//----------------------------------------------------------------------------
HGDIOBJ WINAPI MacGetCurrentObject(HDC	hdc,   // handle of device context
                                   UINT uObjectType)  // object-type identifier
{
    // GetCurrentObject is not supported under wlm, so we always simulate failure
    // by returning NULL
    return NULL;
}

//----------------------------------------------------------------------------
// NOTE WELL: GetDoubleClickTime() maps to GetDblTime() in the VC++ 4.0 header
//			  file MSDEV\MAC\INCLUDE\MACOS\EVENTS.H. The only problem is that
//			  GetDblTime() returns the count in "Ticks" (1/60th second) and
//			  we want milliseconds (0.001 sec). This should be fixed when the
//			  bug in the VC4 header file is fixed. - DAS 1/16/96
//----------------------------------------------------------------------------
UINT MacGetDoubleClickTime()
{
	return MulDiv(100,GetDblTime(),6);
}

//----------------------------------------------------------------------------
//
//  Function:   MacGetMetaFileBitsEx
//
//----------------------------------------------------------------------------
UINT WINAPI MacGetMetaFileBitsEx(HMETAFILE  hmf,    UINT  nSize,    LPVOID  lpvData   )
{
    Assert (0 && "GetMetaFileBitsEx is not implemented for Macintosh");

    return NULL;
}

//----------------------------------------------------------------------------
//
//  Function:   MacIsValidCodePage
//
//----------------------------------------------------------------------------
WINBASEAPI BOOL WINAPI MacIsValidCodePage(UINT  CodePage)
{
    return TRUE;
}

//----------------------------------------------------------------------------
//
//  Function:   MacOleDraw
//
//----------------------------------------------------------------------------
#undef OleDraw
STDAPI MacOleDraw(
    IUnknown * pUnk,	//Points to the view object to be drawn
    DWORD dwAspect,		//Specifies how the object is to be represented
    HDC hdcDraw,		//Identifies the device context on which to draw
    LPCRECT lprcBounds	//Specifies the rectangle in which the object is drawn
   )	
{
    Rect rect;
	HRESULT ret;
    GrafPtr grafptr = CheckoutPort(hdcDraw, CA_NONE);
    Assert(grafptr);

    rect.top    = lprcBounds->top;
    rect.bottom = lprcBounds->bottom;
    rect.left   = lprcBounds->left;
    rect.right  = lprcBounds->right;

	ret = OleDraw(pUnk, dwAspect, grafptr,  &rect);

    CheckinPort(hdcDraw, CA_ALL);
	return ret;
}	

//----------------------------------------------------------------------------
//
//  Function:   MacProgIDFromCLSID
//
//----------------------------------------------------------------------------
#undef ProgIDFromCLSID
STDAPI MacProgIDFromCLSID (REFCLSID clsid, LPWSTR FAR* lplpszProgID)
{
	CStrIn str(*lplpszProgID);
	return ProgIDFromCLSID(clsid, (LPSTR FAR*)&str);
}

//-------------------------------------------------------------------------
//
//  Function:   MacRichEditWndProc
//
//  Synopsis:   This is the Mac WndProc callback function.  
//
//  Arguments:  HWND hwnd, 
//				UINT msg, 
//				WPARAM wparam,
//				LPARAM lparam
//
//  Returns:    LRESULT
//
//  Notes:		The function processes the messages, then often calls
//				the normal PC callback function (RichEditANSIWndProc);
//				
//
//-------------------------------------------------------------------------
LRESULT  CALLBACK MacRichEditWndProc(
		HWND hwnd, 
		UINT msg, 
		WPARAM wparam,
		LPARAM lparam)
{
	TRACEBEGINPARAM(TRCSUBSYSHOST, TRCSCOPEINTERN, "MacRichEditWndProc", msg);


	switch( msg )
	{
	
		
		case WM_MACINTOSH:
		{
			if (LOWORD(wparam) == WLM_SETMENUBAR)     
				return TRUE;	// dont change the menu bar
		}
		break;

		case WM_LBUTTONDOWN:
		case WM_LBUTTONUP:
		case WM_LBUTTONDBLCLK:
		{
			MacSimulateMouseButtons(msg,wparam);
		}
		break;

 		case WM_KEYDOWN:
 		case WM_KEYUP:
		{
			MacSimulateKey(msg,wparam);
		}
		break;

		case WM_SIZE:
		//case WM_SETFOCUS:
		//case WM_SYSCOLORCHANGE:
		//case WM_MOVE:
		//case WM_MACINTOSH:
		{
			return DefWindowProc(hwnd, msg, wparam, lparam);
		}
		break;

		case WM_CHAR:
		{
			return RichEditWndProc(hwnd, msg, wparam, lparam);
		}
		break;
		default:
			return RichEditANSIWndProc(hwnd, msg, wparam, lparam);

	}
	return RichEditANSIWndProc(hwnd, msg, wparam, lparam);
}

//----------------------------------------------------------------------------
//
//  Function:   MacSelectPalette
//
//----------------------------------------------------------------------------
HPALETTE WINAPI MacSelectPalette(HDC hdc, HPALETTE hpal, BOOL bForceBackground)
{
	if (hpal)
		return ::SelectPalette(hdc,hpal,bForceBackground);
	else
		return NULL;
}

//----------------------------------------------------------------------------
//
//  Function:   MacportSetCursor
//
//----------------------------------------------------------------------------
HCURSOR MacportSetCursor(HCURSOR  hCursor)
{
    if (hCursor)
		return SetCursor(hCursor);
	else
	{
		ObscureCursor();
		return NULL;
	}
}
//----------------------------------------------------------------------------
//
//  Function:   MacSetMetaFileBitsEx
//
//----------------------------------------------------------------------------
HMETAFILE WINAPI MacSetMetaFileBitsEx(UINT  nSize,CONST BYTE *  lpData )
{
    Assert (0 && "SetMetaFileBitsEx is not implemented for Macintosh");
	
    return NULL;

}

//-------------------------------------------------------------------------
//
//  Function:   MacSimulateKey
//
//  Synopsis:   Simulates menu enabler keys for the mac
//
//  Arguments:  [msg]
//              [wParam]
//
//  Returns:    UINT
//
//  Notes:      The key is changed to accommodate the mac.
//				
//
//-------------------------------------------------------------------------

UINT MacSimulateKey (UINT& msg, WPARAM& wParam)
{
    BYTE rgbKeyState[256];

    GetKeyboardState(rgbKeyState);

	if (rgbKeyState[VK_CONTROL])        
	{
		rgbKeyState[VK_CONTROL] = 0;   
	}

	SetKeyboardState(rgbKeyState);
    
    return msg;
}

//-------------------------------------------------------------------------
//
//  Function:   MacSimulateMouseButtons
//
//  Synopsis:   Simulates the right and middle mouse Windows buttons.
//
//  Arguments:  [msg]
//              [wParam]
//
//  Returns:    UINT
//
//  Notes:      The right mouse is simulated by CTRL (or COMMAND) click.  The
//              middle mouse is simulated by SHIFT click.  Because CTRL is already
//              in use the CTRL click is simulated using the OPTION key.
//
//              The command key is used the same as the control key because
//              WLM likes to pick up the CTRL mouse as a user break.  This makes
//              debugging the right mouse simulation very difficult.
//
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
typedef struct tagUISim    
	{
    UINT msg;
    UINT wParam;
    BYTE control;	// Value for VK_CONTROL key state
    BYTE menu;		// Value for VK_MENU key state
    } UISim;
//-------------------------------------------------------------------------

UINT MacSimulateMouseButtons (UINT& msg, WPARAM& wParam)
{
    BYTE rgbKeyState[256];
    WORD stateIndex = 0;

    UISim UISim[] =                                                //  8    4     2     1
    {                                                                    // cmd shift ctrl option
        WM_LBUTTONDOWN, MK_LBUTTON,                       0x00, 0x00,    //  -    -     -     -
        WM_LBUTTONDOWN, MK_LBUTTON|MK_CONTROL,            0x80, 0x00,    //  -    -     -     x
        WM_RBUTTONDOWN, MK_RBUTTON,                       0x00, 0x00,    //  -    -     x     -
        WM_RBUTTONDOWN, MK_RBUTTON|MK_CONTROL,            0x80, 0x00,    //  -    -     x     x
        WM_MBUTTONDOWN, MK_MBUTTON,                       0x00, 0x00,    //  -    x     -     -
        WM_MBUTTONDOWN, MK_MBUTTON|MK_CONTROL,            0x80, 0x00,    //  -    x     -     x
        WM_RBUTTONDOWN, MK_RBUTTON|MK_MBUTTON,            0x00, 0x00,    //  -    x     x     -
        WM_RBUTTONDOWN, MK_RBUTTON|MK_MBUTTON|MK_CONTROL, 0x80, 0x00,    //  -    x     x     x
        WM_LBUTTONDOWN, MK_LBUTTON,                       0x00, 0x10,    //  x    -     -     -
        WM_LBUTTONDOWN, MK_LBUTTON|MK_CONTROL,            0x80, 0x10,    //  x    -     -     x
        WM_RBUTTONDOWN, MK_RBUTTON,                       0x00, 0x10,    //  x    -     x     -
        WM_RBUTTONDOWN, MK_RBUTTON|MK_CONTROL,            0x80, 0x10,    //  x    -     x     x
        WM_MBUTTONDOWN, MK_MBUTTON,                       0x00, 0x10,    //  x    x     -     -
        WM_MBUTTONDOWN, MK_MBUTTON|MK_CONTROL,            0x80, 0x10,    //  x    x     -     x
        WM_RBUTTONDOWN, MK_RBUTTON|MK_MBUTTON,            0x00, 0x10,    //  x    x     x     -
        WM_RBUTTONDOWN, MK_RBUTTON|MK_MBUTTON|MK_CONTROL, 0x80, 0x10     //  x    x     x     x
    };



		// Determine which keys were pressed, and clean out the state variables

		GetKeyboardState(rgbKeyState);

		if (rgbKeyState[VK_OPTION])
		{
		   rgbKeyState[VK_OPTION] = 0;     // Clear key state
		   stateIndex |= 0x01;             // Set option key bit in index
		}

		if (rgbKeyState[VK_CONTROL])
		{
			rgbKeyState[VK_CONTROL] = 0;    // Clear key state
			stateIndex |= 0x02;             // Set control key bit in index
		}

		if (rgbKeyState[VK_COMMAND])        // Use command key like control key due to WLM debug issues
		{
			rgbKeyState[VK_COMMAND] = 0;    // Clear key state
			stateIndex |= 0x08;             // Set command key bit in index
		}

		if (rgbKeyState[VK_SHIFT])
		{
			rgbKeyState[VK_SHIFT] = 0;      // Clear key state
		    stateIndex |= 0x04;             // Set shift key bit in index
		}

		// Now set the return values

		if (stateIndex)         // Only do this is the mouse is being simulated
		{
		   msg     = (msg - WM_LBUTTONDOWN) + UISim[stateIndex].msg;
		   wParam  = UISim[stateIndex].wParam;

		   rgbKeyState[VK_CONTROL] = UISim[stateIndex].control;
		   rgbKeyState[VK_MENU] = UISim[stateIndex].menu;
		   SetKeyboardState(rgbKeyState);
		}
    return msg;
}

//----------------------------------------------------------------------------
//
//  Function:   MacSysAllocStringLen
//
//----------------------------------------------------------------------------
STDAPI_(BSTR) MacSysAllocStringLen(LPCWSTR  lpStringW, UINT lenChars)
{

	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SysAllocStringLenMac");

	int		lenStrBytes;
	LPSTR	lpStringMB;

	if ((lpStringW) && (*lpStringW != NULL))
		{
		lenStrBytes = MsoWideCharToMultiByte(CP_ACP,0,lpStringW,lenChars,NULL,NULL,NULL,NULL);
		lpStringMB = (LPSTR)CoTaskMemAlloc( lenStrBytes + sizeof(INT) );
		memcpy(lpStringMB, &lenStrBytes, sizeof(INT));	//copy BSTR lenghth in integer before BSTR
		lpStringMB += sizeof(INT);
		MsoWideCharToMultiByte(CP_ACP,0,lpStringW,lenChars,lpStringMB,lenStrBytes,NULL,NULL);
	}
	else
	{
		// note that in every case so far used on RichEdit the first parm is NULL
		// so no way to determine how big to make the buffer
		// therefore making it the lenghth of a unicode buffer - max size it could be for mbcs 

		lenStrBytes = lenChars*sizeof(WCHAR);
	
		lpStringMB = (LPSTR)CoTaskMemAlloc( lenStrBytes + sizeof(INT) );
		// not sure if this should be lenChars or lenStrBytes
		// note that lenStrBytes is wchar lenghth - the max length it could be for mbcs 
		// memcpy(lpStringMB, &lenStrBytes, sizeof(INT));	//copy BSTR lenghth in integer before BSTR
		memcpy(lpStringMB, &lenChars, sizeof(INT));	//copy BSTR lenghth in integer before BSTR
		lpStringMB += sizeof(INT);
	}
	return	(BSTR)lpStringMB;
}

//----------------------------------------------------------------------------
//
//  Function:   MacWordSwapLong
//
//----------------------------------------------------------------------------
ULONG MacWordSwapLong ( ULONG ul)
{

    WORD w1,w2;

    w1 = (WORD)ul;
    w2 = (WORD)(ul>>16);

    return (((ULONG)w1)<<16) | w2;
}



#endif	//MACPORT

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\w32wince.cpp ===
// Windows CE implementations of W32 Interfaces.

// The following function is needed only because a Windows CE dll must have at least one export

__declspec(dllexport) void Useless( void )
{
	return;
}

LONG ValidateTextRange(TEXTRANGE *pstrg);

ATOM WINAPI CW32System::RegisterREClass(
	const WNDCLASSW *lpWndClass,
	const char *szAnsiClassName,
	WNDPROC AnsiWndProc
)
{
	// On Windows CE we don't do anything with ANSI window class
	return ::RegisterClass(lpWndClass);
}

LRESULT CW32System::ANSIWndProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
	// Should never be used in WinCE
	#pragma message ("Review : Incomplete")
	return 0;
}

HGLOBAL WINAPI CW32System::GlobalAlloc( UINT uFlags, DWORD dwBytes )
{
#ifdef TARGET_NT
	return ::GlobalAlloc( uFlags, dwBytes);
#else
	return LocalAlloc( uFlags & GMEM_ZEROINIT, dwBytes );
#endif
}

HGLOBAL WINAPI CW32System::GlobalFree( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalFree( hMem );
#else
	return LocalFree( hMem );
#endif
}

UINT WINAPI CW32System::GlobalFlags( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalFlags( hMem );
#else
	return LocalFlags( hMem );
#endif
}

HGLOBAL WINAPI CW32System::GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags )
{
#ifdef TARGET_NT
	return ::GlobalReAlloc(hMem, dwBytes, uFlags);
#else
	return LocalReAlloc( hMem, dwBytes, uFlags );
#endif
}

DWORD WINAPI CW32System::GlobalSize( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalSize( hMem );
#else
	return LocalSize( hMem );
#endif
}

LPVOID WINAPI CW32System::GlobalLock( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalLock( hMem );
#else
	return LocalLock( hMem );
#endif
}

HGLOBAL WINAPI CW32System::GlobalHandle( LPCVOID pMem )
{
#ifdef TARGET_NT
	return ::GlobalHandle( pMem );
#else
	return LocalHandle( pMem );
#endif
}

BOOL WINAPI CW32System::GlobalUnlock( HGLOBAL hMem )
{
#ifdef TARGET_NT
	return ::GlobalUnlock( hMem );
#else
	return LocalUnlock( hMem );
#endif
}

BOOL WINAPI CW32System::REGetCharWidth(
	HDC hdc,
	UINT iChar,
	LPINT pAns,
	UINT		// For Windows CE the code page is not used
				//  as the A version is not called.
)
{
	int i;
	SIZE size;
    TCHAR buff[2];

	buff[0] = iChar;
	buff[1] = 0;

    if (GetTextExtentExPoint(hdc, buff, 1, 32000, &i, (LPINT)pAns, &size))
	{
		// pWidthData->width	-= xOverhang;		// Don't need since we use
													//  GetTextExtentPoint32()
		return TRUE;
	}

    return FALSE;
}

BOOL WINAPI CW32System::REExtTextOut(
	CONVERTMODE cm,
	UINT uiCodePage,
	HDC hdc,
	int x,
	int y,
	UINT fuOptions,
	CONST RECT *lprc,
	const WCHAR *lpString,
	UINT cbCount,
	CONST INT *lpDx,
	BOOL  FEFontOnNonFEWin95
)
{
	#pragma message ("Review : Incomplete")
	return ExtTextOut(hdc, x, y, fuOptions, lprc, lpString, cbCount, lpDx);
}

CONVERTMODE WINAPI CW32System::DetermineConvertMode( BYTE tmCharSet )
{
	#pragma message ("Review : Incomplete")
	return CVT_NONE;
}

void WINAPI CW32System::CalcUnderlineInfo( CCcs *pcccs, TEXTMETRIC *ptm )
{
	// Default calculation of size of underline
	// Implements a heuristic in the absence of better font information.
	SHORT dyDescent = pcccs->_yDescent;

	if (0 == dyDescent)
	{
		dyDescent = pcccs->_yHeight >> 3;
	}

	pcccs->_dyULWidth = max(1, dyDescent / 4);
	pcccs->_dyULOffset = (dyDescent - 3 * pcccs->_dyULWidth + 1) / 2;

	if ((0 == pcccs->_dyULOffset) && (dyDescent > 1))
	{
		pcccs->_dyULOffset = 1;
	}

	pcccs->_dySOOffset = -ptm->tmAscent / 3;
	pcccs->_dySOWidth = pcccs->_dyULWidth;

	return;
}

BOOL WINAPI CW32System::ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG nMax )
{
	SCROLLINFO si;
	Assert(wBar == SB_VERT || wBar == SB_HORZ);
	W32->ZeroMemory(&si, sizeof(SCROLLINFO));
	
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_RANGE | SIF_DISABLENOSCROLL;
	if (bShow)
	{
		si.nMax = nMax;
	}
	::SetScrollInfo(hWnd, wBar, &si, TRUE);
	return TRUE;
}

BOOL WINAPI CW32System::EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows )
{
	BOOL fEnable = TRUE;
	BOOL fApi;
	SCROLLINFO si;

	Assert (wSBflags == SB_VERT || wSBflags == SB_HORZ);
	if (wArrows == ESB_DISABLE_BOTH)
	{
		fEnable = FALSE;
	}
	// Get the current scroll range
	W32->ZeroMemory(&si, sizeof(SCROLLINFO));
	si.cbSize = sizeof(SCROLLINFO);
	si.fMask = SIF_RANGE;
	fApi = ::GetScrollInfo(hWnd, wSBflags, &si);
	if (fApi && !fEnable)
	{
		si.fMask = SIF_RANGE | SIF_DISABLENOSCROLL;
		si.nMin = 0;
		si.nMax = 0;
	}
	if (fApi) ::SetScrollInfo(hWnd, wSBflags, &si, TRUE);
	return fApi ? TRUE : FALSE;
}

BOOL WINAPI CW32System::IsEnhancedMetafileDC( HDC )
{
	// No enhanced metafile
	return FALSE;
}

UINT WINAPI CW32System::GetTextAlign(HDC hdc)
{
	// Review :: SHould we set last error?
	return GDI_ERROR;
}

UINT WINAPI CW32System::SetTextAlign(HDC hdc, UINT uAlign)
{
	// Review :: SHould we set last error?
	return GDI_ERROR;
}

UINT WINAPI CW32System::InvertRect(HDC hdc, CONST RECT *prc)
{
    HBITMAP hbm, hbmOld;
    HDC     hdcMem;
    int     nHeight, nWidth;

    nWidth = prc->right-prc->left;
    nHeight = prc->bottom-prc->top;

    hdcMem = CreateCompatibleDC(hdc);
    hbm = CreateCompatibleBitmap(hdc, nWidth, nHeight);
    hbmOld = (HBITMAP) SelectObject(hdcMem, hbm);

    BitBlt(hdcMem, 0, 0, nWidth, nHeight, hdc, prc->left, prc->top,
            SRCCOPY);

    FillRect(hdc, prc, (HBRUSH)GetStockObject(WHITE_BRUSH));

    BitBlt(hdc, prc->left, prc->top, nWidth,
                nHeight, hdcMem, 0, 0, SRCINVERT);

    SelectObject(hdcMem, hbmOld);
    DeleteDC(hdcMem);
    DeleteObject(hbm);
    return TRUE;
}

HPALETTE WINAPI CW32System::ManagePalette(
	HDC,
	CONST LOGPALETTE *,
	HPALETTE &,
	HPALETTE &
)
{
	// No op for Windows CE
	return NULL;
}

int WINAPI CW32System::GetMapMode(HDC)
{
	// Only MM Text supported on Win CE
	return MM_TEXT;
}

BOOL WINAPI CW32System::WinLPtoDP(HDC, LPPOINT, int)
{
	// This is not available on Win CE
	return 0;
}

long WINAPI CW32System::WvsprintfA( LONG cbBuf, LPSTR pszBuf, LPCSTR pszFmt, va_list arglist )
{
	WCHAR wszBuf[64];
	WCHAR wszFmt[64];
	WCHAR *pwszBuf = wszBuf;
	WCHAR *pwszFmt = wszFmt;
	Assert(cbBuf < 64);
	while (*pszFmt)
	{
		*pwszFmt++ = *pszFmt++;
		if (*(pwszFmt - 1) == '%')
		{
			Assert(*pszFmt == 's' || *pszFmt == 'd' || *pszFmt == '0' || *pszFmt == 'c');
			if (*pszFmt == 's')
			{
				*pwszFmt++ = 'h';
			}
		}
	}
	*pwszFmt = 0;
	LONG cw = wvsprintf( wszBuf, wszFmt, arglist );
	while (*pszBuf++ = *pwszBuf++);
	Assert(cw < cbBuf);
	return cw;
}

int WINAPI CW32System::MulDiv(int nNumber, int nNumerator, int nDenominator)
{
	// Special handling for Win CE
	// Must be careful to not cause divide by zero
	// Note that overflow on the multiplication is not handled
	// Hopefully that is not a problem for RichEdit use
	// Added Guy's fix up for rounding.

	// Conservative check to see if multiplication will overflow.
	if (IN_RANGE(_I16_MIN, nNumber, _I16_MAX) &&
		IN_RANGE(_I16_MIN, nNumerator, _I16_MAX))
	{
		return nDenominator ? ((nNumber * nNumerator) + (nDenominator / 2)) / nDenominator  : -1;
	}

	__int64 NNumber = nNumber;
	__int64 NNumerator = nNumerator;
	__int64 NDenominator = nDenominator;

	return NDenominator ? ((NNumber * NNumerator) + (NDenominator / 2)) / NDenominator  : -1;
}

void CW32System::GetFacePriCharSet(HDC hdc, LOGFONT* plf)
{
	plf->lfCharSet = 0;
}

void CW32System::CheckChangeKeyboardLayout ( CTxtSelection *psel, BOOL fChangedFont )
{
	#pragma message ("Review : Incomplete")
	return;
}

void CW32System::CheckChangeFont (
	CTxtSelection *psel,
	CTxtEdit * const ped,
	BOOL fEnableReassign,	// @parm Do we enable CTRL key?
	const WORD lcID,		// @parm LCID from WM_ message
	UINT cpg  				// @parm code page to use (could be ANSI for far east with IME off)
)
{
	#pragma message ("Review : Incomplete")
	return;
}

HKL CW32System::GetKeyboardLayout ( DWORD )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

HRESULT CW32System::LoadRegTypeLib ( REFGUID, WORD, WORD, LCID, ITypeLib ** )
{
	return E_NOTIMPL;
}

HRESULT CW32System::LoadTypeLib ( const OLECHAR *, ITypeLib ** )
{
	return E_NOTIMPL;
}

BSTR CW32System::SysAllocString ( const OLECHAR * )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

BSTR CW32System::SysAllocStringLen ( const OLECHAR *, UINT )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

void CW32System::SysFreeString ( BSTR )
{
	#pragma message ("Review : Incomplete")
	return;
}

UINT CW32System::SysStringLen ( BSTR )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

void CW32System::VariantInit ( VARIANTARG * )
{
	#pragma message ("Review : Incomplete")
	return;
}

HRESULT CW32System::OleCreateFromData ( LPDATAOBJECT, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

void CW32System::CoTaskMemFree ( LPVOID )
{
	#pragma message ("Review : Incomplete")
	return;
}

HRESULT CW32System::CreateBindCtx ( DWORD, LPBC * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HANDLE CW32System::OleDuplicateData ( HANDLE, CLIPFORMAT, UINT )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

HRESULT CW32System::CoTreatAsClass ( REFCLSID, REFCLSID )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::ProgIDFromCLSID ( REFCLSID, LPOLESTR * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleConvertIStorageToOLESTREAM ( LPSTORAGE, LPOLESTREAM )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleConvertIStorageToOLESTREAMEx ( LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleSave ( LPPERSISTSTORAGE, LPSTORAGE, BOOL )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::StgCreateDocfileOnILockBytes ( ILockBytes *, DWORD, DWORD, IStorage ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::CreateILockBytesOnHGlobal ( HGLOBAL, BOOL, ILockBytes ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleCreateLinkToFile ( LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

LPVOID CW32System::CoTaskMemAlloc ( ULONG )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

LPVOID CW32System::CoTaskMemRealloc ( LPVOID, ULONG )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

HRESULT CW32System::OleInitialize ( LPVOID )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

void CW32System::OleUninitialize ( )
{
	#pragma message ("Review : Incomplete")
	return;
}

HRESULT CW32System::OleSetClipboard ( IDataObject * )
{
	return E_NOTIMPL;
}

HRESULT CW32System::OleFlushClipboard ( )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleIsCurrentClipboard ( IDataObject * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::DoDragDrop ( IDataObject *, IDropSource *, DWORD, DWORD * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleGetClipboard ( IDataObject ** )
{
	return E_NOTIMPL;
}

HRESULT CW32System::RegisterDragDrop ( HWND, IDropTarget * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleCreateLinkFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleCreateStaticFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleDraw ( IUnknown *, DWORD, HDC, LPCRECT )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleSetContainedObject ( IUnknown *, BOOL )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::CoDisconnectObject ( IUnknown *, DWORD )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::WriteFmtUserTypeStg ( IStorage *, CLIPFORMAT, LPOLESTR )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::WriteClassStg ( IStorage *, REFCLSID )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::SetConvertStg ( IStorage *, BOOL )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::ReadFmtUserTypeStg ( IStorage *, CLIPFORMAT *, LPOLESTR * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::ReadClassStg ( IStorage *pstg, CLSID * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleRun ( IUnknown * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::RevokeDragDrop ( HWND )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::CreateStreamOnHGlobal ( HGLOBAL, BOOL, IStream ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::GetHGlobalFromStream ( IStream *pstm, HGLOBAL * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleCreateDefaultHandler ( REFCLSID, IUnknown *, REFIID, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::CLSIDFromProgID ( LPCOLESTR, LPCLSID )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleConvertOLESTREAMToIStorage ( LPOLESTREAM, IStorage *, const DVTARGETDEVICE * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::OleLoad ( IStorage *, REFIID, IOleClientSite *, void ** )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HRESULT CW32System::ReleaseStgMedium ( LPSTGMEDIUM pstgmed)
{
	#pragma message ("Review : Incomplete")

	// we don't use anything other than TYMED_HGLOBAL currently.
	if (pstgmed && (pstgmed->tymed == TYMED_HGLOBAL)) {
		::LocalFree(pstgmed->hGlobal);
	}

	return 0;
}

HRESULT CW32System::CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
		DWORD dwClsContext, REFIID riid, LPVOID *ppv)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

void CW32System::FreeOle()
{
	#pragma message ("Review : Incomplete")
}

void CW32System::FreeIME()
{
	#pragma message ("Review : Incomplete")
}

BOOL CW32System::HaveAIMM()
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::HaveIMEShare()
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::getIMEShareObject(CIMEShare **ppIMEShare)
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

LRESULT CW32System::AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

LRESULT CW32System::AIMMGetCodePage(HKL hKL, UINT *uCodePage)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

LRESULT CW32System::AIMMActivate(BOOL fRestoreLayout)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

LRESULT CW32System::AIMMDeactivate(void)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

LRESULT CW32System::AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize)
{
	#pragma message ("Review : Incomplete")
	return S_FALSE;
}

BOOL CW32System::ImmInitialize( void )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

void CW32System::ImmTerminate( void )
{
	#pragma message ("Review : Incomplete")
	return;
}

LONG CW32System::ImmGetCompositionStringA ( HIMC, DWORD, LPVOID, DWORD )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HIMC CW32System::ImmGetContext ( HWND )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

BOOL CW32System::ImmSetCompositionFontA ( HIMC, LPLOGFONTA )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::ImmSetCompositionWindow ( HIMC, LPCOMPOSITIONFORM )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::ImmReleaseContext ( HWND, HIMC )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

DWORD CW32System::ImmGetProperty ( HKL, DWORD )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

BOOL CW32System::ImmGetCandidateWindow ( HIMC, DWORD, LPCANDIDATEFORM )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::ImmSetCandidateWindow ( HIMC, LPCANDIDATEFORM )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::ImmNotifyIME ( HIMC, DWORD, DWORD, DWORD )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

HIMC CW32System::ImmAssociateContext ( HWND, HIMC )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

UINT CW32System::ImmGetVirtualKey ( HWND )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HIMC CW32System::ImmEscape ( HKL, HIMC, UINT, LPVOID )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

LONG CW32System::ImmGetOpenStatus ( HIMC )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

BOOL CW32System::ImmGetConversionStatus ( HIMC, LPDWORD, LPDWORD )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

HWND CW32System::ImmGetDefaultIMEWnd ( HWND )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

BOOL CW32System::FSupportSty ( UINT, UINT )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

const IMESTYLE * CW32System::PIMEStyleFromAttr ( const UINT )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

const IMECOLORSTY * CW32System::PColorStyleTextFromIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

const IMECOLORSTY * CW32System::PColorStyleBackFromIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return NULL;
}

BOOL CW32System::FBoldIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::FItalicIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

BOOL CW32System::FUlIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return FALSE;
}

UINT CW32System::IdUlIMEStyle ( const IMESTYLE * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

COLORREF CW32System::RGBFromIMEColorStyle ( const IMECOLORSTY * )
{
	#pragma message ("Review : Incomplete")
	return 0;
}

BOOL CW32System::GetVersion(
	DWORD *pdwPlatformId,
	DWORD *pdwMajorVersion
)
{
	OSVERSIONINFO osv;
	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	*pdwPlatformId = 0;
	*pdwMajorVersion = 0;
	if (GetVersionEx(&osv))
	{
		*pdwPlatformId = osv.dwPlatformId;
		*pdwMajorVersion = osv.dwMajorVersion;
		return TRUE;
	}
	return FALSE;
}

BOOL WINAPI CW32System::GetStringTypeEx(
	LCID lcid,
	DWORD dwInfoType,
	LPCTSTR lpSrcStr,
	int cchSrc,
	LPWORD lpCharType
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetStringTypeEx");
	return ::GetStringTypeExW(lcid, dwInfoType, lpSrcStr, cchSrc, lpCharType);   
}

LPWSTR WINAPI CW32System::CharLower(LPWSTR pwstr)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLowerWrap");
    return ::CharLowerW(pwstr);
}

DWORD WINAPI CW32System::CharLowerBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharLowerBuffWrap");
	return ::CharLowerBuffW(pwstr, cchLength);
}

DWORD WINAPI CW32System::CharUpperBuff(LPWSTR pwstr, DWORD cchLength)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CharUpperBuffWrap");
	return ::CharUpperBuffW(pwstr, cchLength);
}

HDC WINAPI CW32System::CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateIC");
	return ::CreateDCW( lpszDriver, lpszDevice, lpszOutput, lpInitData);
}

HANDLE WINAPI CW32System::CreateFile(
	LPCWSTR                 lpFileName,
	DWORD                   dwDesiredAccess,
	DWORD                   dwShareMode,
	LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
	DWORD                   dwCreationDisposition,
	DWORD                   dwFlagsAndAttributes,
	HANDLE                  hTemplateFile
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFile");
	return ::CreateFileW(lpFileName,
						dwDesiredAccess,
						dwShareMode,
						lpSecurityAttributes,
						dwCreationDisposition,
						dwFlagsAndAttributes,
						hTemplateFile);
}

HFONT WINAPI CW32System::CreateFontIndirect(CONST LOGFONTW * plfw)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CreateFontIndirect");
	return ::CreateFontIndirectW(plfw);
}

int WINAPI CW32System::CompareString ( 
	LCID  Locale,			// locale identifier 
	DWORD  dwCmpFlags,		// comparison-style options 
	LPCWSTR  lpString1,		// pointer to first string 
	int  cchCount1,			// size, in bytes or characters, of first string 
	LPCWSTR  lpString2,		// pointer to second string 
	int  cchCount2 			// size, in bytes or characters, of second string  
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "CompareString");
	return ::CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
}

LRESULT WINAPI CW32System::DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "DefWindowProc");
	return ::DefWindowProcW(hWnd, msg, wParam, lParam);
}

int WINAPI CW32System::GetObject(HGDIOBJ hgdiObj, int cbBuffer, LPVOID lpvObj)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetObject");
	return ::GetObjectW( hgdiObj, cbBuffer, lpvObj );
}

DWORD APIENTRY CW32System::GetProfileSection(
	LPCWSTR ,
	LPWSTR ,
	DWORD
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetProfileSection");
	// Not available on Win CE
	return 0;
}

int WINAPI CW32System::GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextFaceWrap");
	return ::GetTextFaceW( hdc, cch, lpFaceName );
}

BOOL WINAPI CW32System::GetTextMetrics(HDC hdc, LPTEXTMETRICW lptm)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetTextMetrics");
	return ::GetTextMetricsW( hdc, lptm);
}

LONG WINAPI CW32System::GetWindowLong(HWND hWnd, int nIndex)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetWindowLong");
    return ::GetWindowLongW(hWnd, nIndex);
}

DWORD WINAPI CW32System::GetClassLong(HWND hWnd, int nIndex)
{
	#pragma message ("Review : Incomplete")
	return 0;
}

HBITMAP WINAPI CW32System::LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadBitmap");
    Assert(HIWORD(lpBitmapName) == 0);
    return ::LoadBitmapW(hInstance, lpBitmapName);
}

HCURSOR WINAPI CW32System::LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadCursor");
    Assert(HIWORD(lpCursorName) == 0);
 	
	return (HCURSOR)lpCursorName;
}

HINSTANCE WINAPI CW32System::LoadLibrary(LPCWSTR lpLibFileName)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "LoadLibrary");
    return ::LoadLibraryW(lpLibFileName);
}

LRESULT WINAPI CW32System::SendMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SendMessage");
    return ::SendMessageW(hWnd, Msg, wParam, lParam);
}

LONG WINAPI CW32System::SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "SetWindowLongWrap");
    return ::SetWindowLongW(hWnd, nIndex, dwNewLong);
}

BOOL WINAPI CW32System::PostMessage(
	HWND    hWnd,
    UINT    Msg,
    WPARAM  wParam,
    LPARAM  lParam
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PostMessage");
	return ::PostMessageW(hWnd, Msg, wParam, lParam);
}

BOOL WINAPI CW32System::UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "UnregisterClass");
	return ::UnregisterClassW( lpClassName, hInstance);
}

int WINAPI CW32System::lstrcmp(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmp");
	return ::lstrcmpW(lpString1, lpString2);
}

int WINAPI CW32System::lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "lstrcmpi");
	return ::lstrcmpiW(lpString1, lpString2);
}

BOOL WINAPI CW32System::PeekMessage(
	LPMSG   lpMsg,
    HWND    hWnd,
    UINT    wMsgFilterMin,
    UINT    wMsgFilterMax,
    UINT    wRemoveMsg
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "PeekMessage");
    return ::PeekMessageW(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg);
}

DWORD WINAPI CW32System::GetModuleFileName(
	HMODULE hModule,
	LPWSTR lpFilename,
	DWORD nSize
)
{
	TRACEBEGIN(TRCSUBSYSWRAP, TRCSCOPEINTERN, "GetModuleFileName");
	// On Windows CE we will always be known as riched20.dll
	CopyMemory(lpFilename, TEXT("riched20.dll"), sizeof(TEXT("riched20.dll")));
	return sizeof(TEXT("riched20.dll"))/sizeof(WCHAR) - 1;
}

BOOL WINAPI CW32System::GetCursorPos(
	POINT *ppt
)
{
	DWORD	dw;
	
	dw = GetMessagePos();
	ppt->x = LOWORD(dw);
	ppt->y = HIWORD(dw);
	return TRUE;
}

#pragma message("JMO : Need to add Win CE version of InitSysParam!")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\winresrc.h ===
/*++ BUILD Version: 0001     Increment this if a change has global effects

Copyright (c) 1990-1996  Microsoft Corporation

Module Name:

    winresrc.h

Abstract:

    This module defines the 32-Bit Windows resource codes.

Revision History:

--*/

#ifndef _WINRESRC_
#define _WINRESRC_



/*
 * ShowWindow() Commands
 */
#define SW_HIDE             0
#define SW_SHOWNORMAL       1
#define SW_NORMAL           1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE         3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW             5
#define SW_MINIMIZE         6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA           8
#define SW_RESTORE          9
#define SW_SHOWDEFAULT      10
#define SW_MAX              10

/*
 * Old ShowWindow() Commands
 */
#define HIDE_WINDOW         0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

/*
 * Identifiers for the WM_SHOWWINDOW message
 */
#define SW_PARENTCLOSING    1
#define SW_OTHERZOOM        2
#define SW_PARENTOPENING    3
#define SW_OTHERUNZOOM      4


/*
 * Virtual Keys, Standard Set
 */
#define VK_LBUTTON        0x01
#define VK_RBUTTON        0x02
#define VK_CANCEL         0x03
#define VK_MBUTTON        0x04    /* NOT contiguous with L & RBUTTON */

#define VK_BACK           0x08
#define VK_TAB            0x09

#define VK_CLEAR          0x0C
#define VK_RETURN         0x0D

#define VK_SHIFT          0x10
#define VK_CONTROL        0x11
#define VK_MENU           0x12
#define VK_PAUSE          0x13
#define VK_CAPITAL        0x14


#define VK_ESCAPE         0x1B

#define VK_SPACE          0x20
#define VK_PRIOR          0x21
#define VK_NEXT           0x22
#define VK_END            0x23
#define VK_HOME           0x24
#define VK_LEFT           0x25
#define VK_UP             0x26
#define VK_RIGHT          0x27
#define VK_DOWN           0x28
#define VK_SELECT         0x29
#define VK_PRINT          0x2A
#define VK_EXECUTE        0x2B
#define VK_SNAPSHOT       0x2C
#define VK_INSERT         0x2D
#define VK_DELETE         0x2E
#define VK_HELP           0x2F

/* VK_0 thru VK_9 are the same as ASCII '0' thru '9' (0x30 - 0x39) */
/* VK_A thru VK_Z are the same as ASCII 'A' thru 'Z' (0x41 - 0x5A) */

#define VK_LWIN           0x5B
#define VK_RWIN           0x5C
#define VK_APPS           0x5D

#define VK_NUMPAD0        0x60
#define VK_NUMPAD1        0x61
#define VK_NUMPAD2        0x62
#define VK_NUMPAD3        0x63
#define VK_NUMPAD4        0x64
#define VK_NUMPAD5        0x65
#define VK_NUMPAD6        0x66
#define VK_NUMPAD7        0x67
#define VK_NUMPAD8        0x68
#define VK_NUMPAD9        0x69
#define VK_MULTIPLY       0x6A
#define VK_ADD            0x6B
#define VK_SEPARATOR      0x6C
#define VK_SUBTRACT       0x6D
#define VK_DECIMAL        0x6E
#define VK_DIVIDE         0x6F
#define VK_F1             0x70
#define VK_F2             0x71
#define VK_F3             0x72
#define VK_F4             0x73
#define VK_F5             0x74
#define VK_F6             0x75
#define VK_F7             0x76
#define VK_F8             0x77
#define VK_F9             0x78
#define VK_F10            0x79
#define VK_F11            0x7A
#define VK_F12            0x7B
#define VK_F13            0x7C
#define VK_F14            0x7D
#define VK_F15            0x7E
#define VK_F16            0x7F
#define VK_F17            0x80
#define VK_F18            0x81
#define VK_F19            0x82
#define VK_F20            0x83
#define VK_F21            0x84
#define VK_F22            0x85
#define VK_F23            0x86
#define VK_F24            0x87

#define VK_NUMLOCK        0x90
#define VK_SCROLL         0x91

/*
 * VK_L* & VK_R* - left and right Alt, Ctrl and Shift virtual keys.
 * Used only as parameters to GetAsyncKeyState() and GetKeyState().
 * No other API or message will distinguish left and right keys in this way.
 */
#define VK_LSHIFT         0xA0
#define VK_RSHIFT         0xA1
#define VK_LCONTROL       0xA2
#define VK_RCONTROL       0xA3
#define VK_LMENU          0xA4
#define VK_RMENU          0xA5

#if(WINVER >= 0x0400)
#define VK_PROCESSKEY     0xE5
#endif /* WINVER >= 0x0400 */

#define VK_ATTN           0xF6
#define VK_CRSEL          0xF7
#define VK_EXSEL          0xF8
#define VK_EREOF          0xF9
#define VK_PLAY           0xFA
#define VK_ZOOM           0xFB
#define VK_NONAME         0xFC
#define VK_PA1            0xFD
#define VK_OEM_CLEAR      0xFE


/*
 * Window Messages
 */

#define WM_NULL                         0x0000
#define WM_CREATE                       0x0001
#define WM_DESTROY                      0x0002
#define WM_MOVE                         0x0003
#define WM_SIZE                         0x0005

#define WM_ACTIVATE                     0x0006
/*
 * WM_ACTIVATE state values
 */
#define     WA_INACTIVE     0
#define     WA_ACTIVE       1
#define     WA_CLICKACTIVE  2

#define WM_SETFOCUS                     0x0007
#define WM_KILLFOCUS                    0x0008
#define WM_ENABLE                       0x000A
#define WM_SETREDRAW                    0x000B
#define WM_SETTEXT                      0x000C
#define WM_GETTEXT                      0x000D
#define WM_GETTEXTLENGTH                0x000E
#define WM_PAINT                        0x000F
#define WM_CLOSE                        0x0010
#define WM_QUERYENDSESSION              0x0011
#define WM_QUIT                         0x0012
#define WM_QUERYOPEN                    0x0013
#define WM_ERASEBKGND                   0x0014
#define WM_SYSCOLORCHANGE               0x0015
#define WM_ENDSESSION                   0x0016
#define WM_SHOWWINDOW                   0x0018
#define WM_WININICHANGE                 0x001A
#if(WINVER >= 0x0400)
#define WM_SETTINGCHANGE                WM_WININICHANGE
#endif /* WINVER >= 0x0400 */


#define WM_DEVMODECHANGE                0x001B
#define WM_ACTIVATEAPP                  0x001C
#define WM_FONTCHANGE                   0x001D
#define WM_TIMECHANGE                   0x001E
#define WM_CANCELMODE                   0x001F
#define WM_SETCURSOR                    0x0020
#define WM_MOUSEACTIVATE                0x0021
#define WM_CHILDACTIVATE                0x0022
#define WM_QUEUESYNC                    0x0023

#define WM_GETMINMAXINFO                0x0024
#define WM_PAINTICON                    0x0026
#define WM_ICONERASEBKGND               0x0027
#define WM_NEXTDLGCTL                   0x0028
#define WM_SPOOLERSTATUS                0x002A
#define WM_DRAWITEM                     0x002B
#define WM_MEASUREITEM                  0x002C
#define WM_DELETEITEM                   0x002D
#define WM_VKEYTOITEM                   0x002E
#define WM_CHARTOITEM                   0x002F
#define WM_SETFONT                      0x0030
#define WM_GETFONT                      0x0031
#define WM_SETHOTKEY                    0x0032
#define WM_GETHOTKEY                    0x0033
#define WM_QUERYDRAGICON                0x0037
#define WM_COMPAREITEM                  0x0039

#define WM_COMPACTING                   0x0041
#define WM_COMMNOTIFY                   0x0044  /* no longer suported */
#define WM_WINDOWPOSCHANGING            0x0046
#define WM_WINDOWPOSCHANGED             0x0047

#define WM_POWER                        0x0048
/*
 * wParam for WM_POWER window message and DRV_POWER driver notification
 */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3

#define WM_COPYDATA                     0x004A
#define WM_CANCELJOURNAL                0x004B


#if(WINVER >= 0x0400)
#define WM_NOTIFY                       0x004E
#define WM_INPUTLANGCHANGEREQUEST       0x0050
#define WM_INPUTLANGCHANGE              0x0051
#define WM_TCARD                        0x0052
#define WM_HELP                         0x0053
#define WM_USERCHANGED                  0x0054
#define WM_NOTIFYFORMAT                 0x0055

#define NFR_ANSI                             1
#define NFR_UNICODE                          2
#define NF_QUERY                             3
#define NF_REQUERY                           4

#define WM_CONTEXTMENU                  0x007B
#define WM_STYLECHANGING                0x007C
#define WM_STYLECHANGED                 0x007D
#define WM_DISPLAYCHANGE                0x007E
#define WM_GETICON                      0x007F
#define WM_SETICON                      0x0080
#endif /* WINVER >= 0x0400 */


#define WM_NCCREATE                     0x0081
#define WM_NCDESTROY                    0x0082
#define WM_NCCALCSIZE                   0x0083
#define WM_NCHITTEST                    0x0084
#define WM_NCPAINT                      0x0085
#define WM_NCACTIVATE                   0x0086
#define WM_GETDLGCODE                   0x0087

#define WM_NCMOUSEMOVE                  0x00A0
#define WM_NCLBUTTONDOWN                0x00A1
#define WM_NCLBUTTONUP                  0x00A2
#define WM_NCLBUTTONDBLCLK              0x00A3
#define WM_NCRBUTTONDOWN                0x00A4
#define WM_NCRBUTTONUP                  0x00A5
#define WM_NCRBUTTONDBLCLK              0x00A6
#define WM_NCMBUTTONDOWN                0x00A7
#define WM_NCMBUTTONUP                  0x00A8
#define WM_NCMBUTTONDBLCLK              0x00A9

#define WM_KEYFIRST                     0x0100
#define WM_KEYDOWN                      0x0100
#define WM_KEYUP                        0x0101
#define WM_CHAR                         0x0102
#define WM_DEADCHAR                     0x0103
#define WM_SYSKEYDOWN                   0x0104
#define WM_SYSKEYUP                     0x0105
#define WM_SYSCHAR                      0x0106
#define WM_SYSDEADCHAR                  0x0107
#define WM_KEYLAST                      0x0108

#if(WINVER >= 0x0400)
#define WM_IME_STARTCOMPOSITION         0x010D
#define WM_IME_ENDCOMPOSITION           0x010E
#define WM_IME_COMPOSITION              0x010F
#define WM_IME_KEYLAST                  0x010F
#endif /* WINVER >= 0x0400 */

#define WM_INITDIALOG                   0x0110
#define WM_COMMAND                      0x0111
#define WM_SYSCOMMAND                   0x0112
#define WM_TIMER                        0x0113
#define WM_HSCROLL                      0x0114
#define WM_VSCROLL                      0x0115
#define WM_INITMENU                     0x0116
#define WM_INITMENUPOPUP                0x0117
#define WM_MENUSELECT                   0x011F
#define WM_MENUCHAR                     0x0120
#define WM_ENTERIDLE                    0x0121

#define WM_CTLCOLORMSGBOX               0x0132
#define WM_CTLCOLOREDIT                 0x0133
#define WM_CTLCOLORLISTBOX              0x0134
#define WM_CTLCOLORBTN                  0x0135
#define WM_CTLCOLORDLG                  0x0136
#define WM_CTLCOLORSCROLLBAR            0x0137
#define WM_CTLCOLORSTATIC               0x0138



#define WM_MOUSEFIRST                   0x0200
#define WM_MOUSEMOVE                    0x0200
#define WM_LBUTTONDOWN                  0x0201
#define WM_LBUTTONUP                    0x0202
#define WM_LBUTTONDBLCLK                0x0203
#define WM_RBUTTONDOWN                  0x0204
#define WM_RBUTTONUP                    0x0205
#define WM_RBUTTONDBLCLK                0x0206
#define WM_MBUTTONDOWN                  0x0207
#define WM_MBUTTONUP                    0x0208
#define WM_MBUTTONDBLCLK                0x0209
#if(_WIN32_WINNT >= 0x0400)
#define WM_MOUSEWHEEL                   0x020A
#endif /* _WIN32_WINNT >= 0x0400 */
#if (_WIN32_WINNT < 0x0400)
#define WM_MOUSELAST                    0x0209
#else
#define WM_MOUSELAST                    0x020A
#endif /* if (_WIN32_WINNT < 0x0400) */

#if(_WIN32_WINNT >= 0x0400)
#define WHEEL_DELTA                     120     /* Value for rolling one detent */
#endif /* _WIN32_WINNT >= 0x0400 */
#if(_WIN32_WINNT >= 0x0400)
#define WHEEL_PAGESCROLL                (UINT_MAX) /* Scroll one page */
#endif /* _WIN32_WINNT >= 0x0400 */

#define WM_PARENTNOTIFY                 0x0210
#define MENULOOP_WINDOW                 0
#define MENULOOP_POPUP                  1
#define WM_ENTERMENULOOP                0x0211
#define WM_EXITMENULOOP                 0x0212

#if(WINVER >= 0x0400)
#define WM_NEXTMENU                     0x0213
#define WM_SIZING                       0x0214
#define WM_CAPTURECHANGED               0x0215
#define WM_MOVING                       0x0216
#define WM_POWERBROADCAST               0x0218
#define WM_DEVICECHANGE                 0x0219

#define WM_IME_SETCONTEXT               0x0281
#define WM_IME_NOTIFY                   0x0282
#define WM_IME_CONTROL                  0x0283
#define WM_IME_COMPOSITIONFULL          0x0284
#define WM_IME_SELECT                   0x0285
#define WM_IME_CHAR                     0x0286
#define WM_IME_KEYDOWN                  0x0290
#define WM_IME_KEYUP                    0x0291
#endif /* WINVER >= 0x0400 */

#define WM_MDICREATE                    0x0220
#define WM_MDIDESTROY                   0x0221
#define WM_MDIACTIVATE                  0x0222
#define WM_MDIRESTORE                   0x0223
#define WM_MDINEXT                      0x0224
#define WM_MDIMAXIMIZE                  0x0225
#define WM_MDITILE                      0x0226
#define WM_MDICASCADE                   0x0227
#define WM_MDIICONARRANGE               0x0228
#define WM_MDIGETACTIVE                 0x0229



#define WM_MDISETMENU                   0x0230
#define WM_ENTERSIZEMOVE                0x0231
#define WM_EXITSIZEMOVE                 0x0232
#define WM_DROPFILES                    0x0233
#define WM_MDIREFRESHMENU               0x0234


#if(_WIN32_WINNT >= 0x0400)
#define WM_MOUSEHOVER                   0x02A1
#define WM_MOUSELEAVE                   0x02A3
#endif /* _WIN32_WINNT >= 0x0400 */

#define WM_CUT                          0x0300
#define WM_COPY                         0x0301
#define WM_PASTE                        0x0302
#define WM_CLEAR                        0x0303
#define WM_UNDO                         0x0304
#define WM_RENDERFORMAT                 0x0305
#define WM_RENDERALLFORMATS             0x0306
#define WM_DESTROYCLIPBOARD             0x0307
#define WM_DRAWCLIPBOARD                0x0308
#define WM_PAINTCLIPBOARD               0x0309
#define WM_VSCROLLCLIPBOARD             0x030A
#define WM_SIZECLIPBOARD                0x030B
#define WM_ASKCBFORMATNAME              0x030C
#define WM_CHANGECBCHAIN                0x030D
#define WM_HSCROLLCLIPBOARD             0x030E
#define WM_QUERYNEWPALETTE              0x030F
#define WM_PALETTEISCHANGING            0x0310
#define WM_PALETTECHANGED               0x0311
#define WM_HOTKEY                       0x0312

#if(WINVER >= 0x0400)
#define WM_PRINT                        0x0317
#define WM_PRINTCLIENT                  0x0318

#define WM_HANDHELDFIRST                0x0358
#define WM_HANDHELDLAST                 0x035F

#define WM_AFXFIRST                     0x0360
#define WM_AFXLAST                      0x037F
#endif /* WINVER >= 0x0400 */

#define WM_PENWINFIRST                  0x0380
#define WM_PENWINLAST                   0x038F




#if(WINVER >= 0x0400)
#define WM_APP                          0x8000
#endif /* WINVER >= 0x0400 */






/*
 * NOTE: All Message Numbers below 0x0400 are RESERVED.
 *
 * Private Window Messages Start Here:
 */
#define WM_USER                         0x0400

#if(WINVER >= 0x0400)

/*  wParam for WM_SIZING message  */
#define WMSZ_LEFT           1
#define WMSZ_RIGHT          2
#define WMSZ_TOP            3
#define WMSZ_TOPLEFT        4
#define WMSZ_TOPRIGHT       5
#define WMSZ_BOTTOM         6
#define WMSZ_BOTTOMLEFT     7
#define WMSZ_BOTTOMRIGHT    8
#endif /* WINVER >= 0x0400 */

#ifndef NONCMESSAGES

/*
 * WM_SYNCTASK Commands
 */
#define ST_BEGINSWP         0
#define ST_ENDSWP           1

/*
 * WM_NCHITTEST and MOUSEHOOKSTRUCT Mouse Position Codes
 */
#define HTERROR             (-2)
#define HTTRANSPARENT       (-1)
#define HTNOWHERE           0
#define HTCLIENT            1
#define HTCAPTION           2
#define HTSYSMENU           3
#define HTGROWBOX           4
#define HTSIZE              HTGROWBOX
#define HTMENU              5
#define HTHSCROLL           6
#define HTVSCROLL           7
#define HTMINBUTTON         8
#define HTMAXBUTTON         9
#define HTLEFT              10
#define HTRIGHT             11
#define HTTOP               12
#define HTTOPLEFT           13
#define HTTOPRIGHT          14
#define HTBOTTOM            15
#define HTBOTTOMLEFT        16
#define HTBOTTOMRIGHT       17
#define HTBORDER            18
#define HTREDUCE            HTMINBUTTON
#define HTZOOM              HTMAXBUTTON
#define HTSIZEFIRST         HTLEFT
#define HTSIZELAST          HTBOTTOMRIGHT
#if(WINVER >= 0x0400)
#define HTOBJECT            19
#define HTCLOSE             20
#define HTHELP              21
#endif /* WINVER >= 0x0400 */

/*
 * SendMessageTimeout values
 */
#define SMTO_NORMAL         0x0000
#define SMTO_BLOCK          0x0001
#define SMTO_ABORTIFHUNG    0x0002

#endif /* !NONCMESSAGES */

/*
 * WM_MOUSEACTIVATE Return Codes
 */
#define MA_ACTIVATE         1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE       3
#define MA_NOACTIVATEANDEAT 4

/*
 * WM_SETICON / WM_GETICON Type Codes
 */
#define ICON_SMALL          0
#define ICON_BIG            1


/*
 * WM_SIZE message wParam values
 */
#define SIZE_RESTORED       0
#define SIZE_MINIMIZED      1
#define SIZE_MAXIMIZED      2
#define SIZE_MAXSHOW        3
#define SIZE_MAXHIDE        4

/*
 * Obsolete constant names
 */
#define SIZENORMAL          SIZE_RESTORED
#define SIZEICONIC          SIZE_MINIMIZED
#define SIZEFULLSCREEN      SIZE_MAXIMIZED
#define SIZEZOOMSHOW        SIZE_MAXSHOW
#define SIZEZOOMHIDE        SIZE_MAXHIDE

/*
 * WM_NCCALCSIZE "window valid rect" return values
 */
#define WVR_ALIGNTOP        0x0010
#define WVR_ALIGNLEFT       0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT      0x0080
#define WVR_HREDRAW         0x0100
#define WVR_VREDRAW         0x0200
#define WVR_REDRAW         (WVR_HREDRAW | \
                            WVR_VREDRAW)
#define WVR_VALIDRECTS      0x0400


#ifndef NOKEYSTATES

/*
 * Key State Masks for Mouse Messages
 */
#define MK_LBUTTON          0x0001
#define MK_RBUTTON          0x0002
#define MK_SHIFT            0x0004
#define MK_CONTROL          0x0008
#define MK_MBUTTON          0x0010

#endif /* !NOKEYSTATES */

#if(_WIN32_WINNT >= 0x0400)
#ifndef NOTRACKMOUSEEVENT

#define TME_HOVER       0x00000001
#define TME_LEAVE       0x00000002
#define TME_QUERY       0x40000000
#define TME_CANCEL      0x80000000


#define HOVER_DEFAULT   0xFFFFFFFF

#endif /* !NOTRACKMOUSEEVENT */
#endif /* _WIN32_WINNT >= 0x0400 */


/*
 * Window Styles
 */
#define WS_OVERLAPPED       0x00000000L
#define WS_POPUP            0x80000000L
#define WS_CHILD            0x40000000L
#define WS_MINIMIZE         0x20000000L
#define WS_VISIBLE          0x10000000L
#define WS_DISABLED         0x08000000L
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L
#define WS_MAXIMIZE         0x01000000L
#define WS_CAPTION          0x00C00000L     /* WS_BORDER | WS_DLGFRAME  */
#define WS_BORDER           0x00800000L
#define WS_DLGFRAME         0x00400000L
#define WS_VSCROLL          0x00200000L
#define WS_HSCROLL          0x00100000L
#define WS_SYSMENU          0x00080000L
#define WS_THICKFRAME       0x00040000L
#define WS_GROUP            0x00020000L
#define WS_TABSTOP          0x00010000L

#define WS_MINIMIZEBOX      0x00020000L
#define WS_MAXIMIZEBOX      0x00010000L

#define WS_TILED            WS_OVERLAPPED
#define WS_ICONIC           WS_MINIMIZE
#define WS_SIZEBOX          WS_THICKFRAME
#define WS_TILEDWINDOW      WS_OVERLAPPEDWINDOW

/*
 * Common Window Styles
 */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED     | \
                             WS_CAPTION        | \
                             WS_SYSMENU        | \
                             WS_THICKFRAME     | \
                             WS_MINIMIZEBOX    | \
                             WS_MAXIMIZEBOX)

#define WS_POPUPWINDOW      (WS_POPUP          | \
                             WS_BORDER         | \
                             WS_SYSMENU)

#define WS_CHILDWINDOW      (WS_CHILD)

/*
 * Extended Window Styles
 */
#define WS_EX_DLGMODALFRAME     0x00000001L
#define WS_EX_NOPARENTNOTIFY    0x00000004L
#define WS_EX_TOPMOST           0x00000008L
#define WS_EX_ACCEPTFILES       0x00000010L
#define WS_EX_TRANSPARENT       0x00000020L
#if(WINVER >= 0x0400)
#define WS_EX_MDICHILD          0x00000040L
#define WS_EX_TOOLWINDOW        0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L
#define WS_EX_CONTEXTHELP       0x00000400L

#define WS_EX_RIGHT             0x00001000L
#define WS_EX_LEFT              0x00000000L
#define WS_EX_RTLREADING        0x00002000L
#define WS_EX_LTRREADING        0x00000000L
#define WS_EX_LEFTSCROLLBAR     0x00004000L
#define WS_EX_RIGHTSCROLLBAR    0x00000000L

#define WS_EX_CONTROLPARENT     0x00010000L
#define WS_EX_STATICEDGE        0x00020000L
#define WS_EX_APPWINDOW         0x00040000L


#define WS_EX_OVERLAPPEDWINDOW  (WS_EX_WINDOWEDGE | WS_EX_CLIENTEDGE)
#define WS_EX_PALETTEWINDOW     (WS_EX_WINDOWEDGE | WS_EX_TOOLWINDOW | WS_EX_TOPMOST)

#endif /* WINVER >= 0x0400 */



/*
 * Class styles
 */
#define CS_VREDRAW          0x0001
#define CS_HREDRAW          0x0002
#define CS_KEYCVTWINDOW     0x0004
#define CS_DBLCLKS          0x0008
#define CS_OWNDC            0x0020
#define CS_CLASSDC          0x0040
#define CS_PARENTDC         0x0080
#define CS_NOKEYCVT         0x0100
#define CS_NOCLOSE          0x0200
#define CS_SAVEBITS         0x0800
#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000
#define CS_GLOBALCLASS      0x4000

#if(WINVER >= 0x0400)
#define CS_IME              0x00010000
#endif /* WINVER >= 0x0400 */



/*
 * Predefined Clipboard Formats
 */
#define CF_TEXT             1
#define CF_BITMAP           2
#define CF_METAFILEPICT     3
#define CF_SYLK             4
#define CF_DIF              5
#define CF_TIFF             6
#define CF_OEMTEXT          7
#define CF_DIB              8
#define CF_PALETTE          9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12
#define CF_UNICODETEXT      13
#define CF_ENHMETAFILE      14
#if(WINVER >= 0x0400)
#define CF_HDROP            15
#define CF_LOCALE           16
#define CF_MAX              17
#endif /* WINVER >= 0x0400 */

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT          0x0081
#define CF_DSPBITMAP        0x0082
#define CF_DSPMETAFILEPICT  0x0083
#define CF_DSPENHMETAFILE   0x008E

/*
 * "Private" formats don't get GlobalFree()'d
 */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST      0x02FF

/*
 * "GDIOBJ" formats do get DeleteObject()'d
 */
#define CF_GDIOBJFIRST      0x0300
#define CF_GDIOBJLAST       0x03FF


/* ;win40  -- A lot of MF_* flags have been renamed as MFT_* and MFS_* flags */
/*
 * Menu flags for Add/Check/EnableMenuItem()
 */
#define MF_INSERT           0x00000000L
#define MF_CHANGE           0x00000080L
#define MF_APPEND           0x00000100L
#define MF_DELETE           0x00000200L
#define MF_REMOVE           0x00001000L

#define MF_BYCOMMAND        0x00000000L
#define MF_BYPOSITION       0x00000400L

#define MF_SEPARATOR        0x00000800L

#define MF_ENABLED          0x00000000L
#define MF_GRAYED           0x00000001L
#define MF_DISABLED         0x00000002L

#define MF_UNCHECKED        0x00000000L
#define MF_CHECKED          0x00000008L
#define MF_USECHECKBITMAPS  0x00000200L

#define MF_STRING           0x00000000L
#define MF_BITMAP           0x00000004L
#define MF_OWNERDRAW        0x00000100L

#define MF_POPUP            0x00000010L
#define MF_MENUBARBREAK     0x00000020L
#define MF_MENUBREAK        0x00000040L

#define MF_UNHILITE         0x00000000L
#define MF_HILITE           0x00000080L

#if(WINVER >= 0x0400)
#define MF_DEFAULT          0x00001000L
#endif /* WINVER >= 0x0400 */
#define MF_SYSMENU          0x00002000L
#define MF_HELP             0x00004000L
#if(WINVER >= 0x0400)
#define MF_RIGHTJUSTIFY     0x00004000L
#endif /* WINVER >= 0x0400 */

#define MF_MOUSESELECT      0x00008000L
#if(WINVER >= 0x0400)
#define MF_END              0x00000080L  /* Obsolete -- only used by old RES files */
#endif /* WINVER >= 0x0400 */


#if(WINVER >= 0x0400)
#define MFT_STRING          MF_STRING
#define MFT_BITMAP          MF_BITMAP
#define MFT_MENUBARBREAK    MF_MENUBARBREAK
#define MFT_MENUBREAK       MF_MENUBREAK
#define MFT_OWNERDRAW       MF_OWNERDRAW
#define MFT_RADIOCHECK      0x00000200L
#define MFT_SEPARATOR       MF_SEPARATOR
#define MFT_RIGHTORDER      0x00002000L
#define MFT_RIGHTJUSTIFY    MF_RIGHTJUSTIFY

/* Menu flags for Add/Check/EnableMenuItem() */
#define MFS_GRAYED          0x00000003L
#define MFS_DISABLED        MFS_GRAYED
#define MFS_CHECKED         MF_CHECKED
#define MFS_HILITE          MF_HILITE
#define MFS_ENABLED         MF_ENABLED
#define MFS_UNCHECKED       MF_UNCHECKED
#define MFS_UNHILITE        MF_UNHILITE
#define MFS_DEFAULT         MF_DEFAULT



#endif /* WINVER >= 0x0400 */

#define MF_END             0x00000080L          
/*
 * System Menu Command Values
 */
#define SC_SIZE         0xF000
#define SC_MOVE         0xF010
#define SC_MINIMIZE     0xF020
#define SC_MAXIMIZE     0xF030
#define SC_NEXTWINDOW   0xF040
#define SC_PREVWINDOW   0xF050
#define SC_CLOSE        0xF060
#define SC_VSCROLL      0xF070
#define SC_HSCROLL      0xF080
#define SC_MOUSEMENU    0xF090
#define SC_KEYMENU      0xF100
#define SC_ARRANGE      0xF110
#define SC_RESTORE      0xF120
#define SC_TASKLIST     0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150
#if(WINVER >= 0x0400)
#define SC_DEFAULT      0xF160
#define SC_MONITORPOWER 0xF170
#define SC_CONTEXTHELP  0xF180
#define SC_SEPARATOR    0xF00F
#endif /* WINVER >= 0x0400 */
/*
 * Obsolete names
 */
#define SC_ICON         SC_MINIMIZE
#define SC_ZOOM         SC_MAXIMIZE


/*
 * OEM Resource Ordinal Numbers
 */
#define OBM_CLOSE           32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#define OBM_UPARROWI        32737
#define OBM_DNARROWI        32736
#define OBM_RGARROWI        32735
#define OBM_LFARROWI        32734

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL          32512
#define OCR_IBEAM           32513
#define OCR_WAIT            32514
#define OCR_CROSS           32515
#define OCR_UP              32516
#define OCR_SIZE            32640   /* OBSOLETE: use OCR_SIZEALL */
#define OCR_ICON            32641   /* OBSOLETE: use OCR_NORMAL */
#define OCR_SIZENWSE        32642
#define OCR_SIZENESW        32643
#define OCR_SIZEWE          32644
#define OCR_SIZENS          32645
#define OCR_SIZEALL         32646
#define OCR_ICOCUR          32647   /* OBSOLETE: use OIC_WINLOGO */
#define OCR_NO              32648
#if(WINVER >= 0x0400)
#define OCR_APPSTARTING     32650
#endif /* WINVER >= 0x0400 */



#define OIC_SAMPLE          32512
#define OIC_HAND            32513
#define OIC_QUES            32514
#define OIC_BANG            32515
#define OIC_NOTE            32516
#if(WINVER >= 0x0400)
#define OIC_WINLOGO         32517
#define OIC_WARNING         OIC_BANG
#define OIC_ERROR           OIC_HAND
#define OIC_INFORMATION     OIC_NOTE
#endif /* WINVER >= 0x0400 */


/*
 * Standard Icon IDs
 */
#ifdef RC_INVOKED
#define IDI_APPLICATION     32512
#define IDI_HAND            32513
#define IDI_QUESTION        32514
#define IDI_EXCLAMATION     32515
#define IDI_ASTERISK        32516
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         32517
#endif /* WINVER >= 0x0400 */
#else
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND            MAKEINTRESOURCE(32513)
#define IDI_QUESTION        MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK        MAKEINTRESOURCE(32516)
#if(WINVER >= 0x0400)
#define IDI_WINLOGO         MAKEINTRESOURCE(32517)
#endif /* WINVER >= 0x0400 */
#endif /* RC_INVOKED */

#if(WINVER >= 0x0400)
#define IDI_WARNING     IDI_EXCLAMATION
#define IDI_ERROR       IDI_HAND
#define IDI_INFORMATION IDI_ASTERISK
#endif /* WINVER >= 0x0400 */


/*
 * Dialog Box Command IDs
 */
#define IDOK                1
#define IDCANCEL            2
#define IDABORT             3
#define IDRETRY             4
#define IDIGNORE            5
#define IDYES               6
#define IDNO                7
#if(WINVER >= 0x0400)
#define IDCLOSE         8
#define IDHELP          9
#endif /* WINVER >= 0x0400 */


/*
 * Edit Control Styles
 */
#define ES_LEFT             0x0000L
#define ES_CENTER           0x0001L
#define ES_RIGHT            0x0002L
#define ES_MULTILINE        0x0004L
#define ES_UPPERCASE        0x0008L
#define ES_LOWERCASE        0x0010L
#define ES_PASSWORD         0x0020L
#define ES_AUTOVSCROLL      0x0040L
#define ES_AUTOHSCROLL      0x0080L
#define ES_NOHIDESEL        0x0100L
#define ES_OEMCONVERT       0x0400L
#define ES_READONLY         0x0800L
#define ES_WANTRETURN       0x1000L
#if(WINVER >= 0x0400)
#define ES_NUMBER           0x2000L
#endif /* WINVER >= 0x0400 */


/*
 * Edit Control Messages
 */
#define EM_GETSEL               0x00B0
#define EM_SETSEL               0x00B1
#define EM_GETRECT              0x00B2
#define EM_SETRECT              0x00B3
#define EM_SETRECTNP            0x00B4
#define EM_SCROLL               0x00B5
#define EM_LINESCROLL           0x00B6
#define EM_SCROLLCARET          0x00B7
#define EM_GETMODIFY            0x00B8
#define EM_SETMODIFY            0x00B9
#define EM_GETLINECOUNT         0x00BA
#define EM_LINEINDEX            0x00BB
#define EM_SETHANDLE            0x00BC
#define EM_GETHANDLE            0x00BD
#define EM_GETTHUMB             0x00BE
#define EM_LINELENGTH           0x00C1
#define EM_REPLACESEL           0x00C2
#define EM_GETLINE              0x00C4
#define EM_LIMITTEXT            0x00C5
#define EM_CANUNDO              0x00C6
#define EM_UNDO                 0x00C7
#define EM_FMTLINES             0x00C8
#define EM_LINEFROMCHAR         0x00C9
#define EM_SETTABSTOPS          0x00CB
#define EM_SETPASSWORDCHAR      0x00CC
#define EM_EMPTYUNDOBUFFER      0x00CD
#define EM_GETFIRSTVISIBLELINE  0x00CE
#define EM_SETREADONLY          0x00CF
#define EM_SETWORDBREAKPROC     0x00D0
#define EM_GETWORDBREAKPROC     0x00D1
#define EM_GETPASSWORDCHAR      0x00D2
#if(WINVER >= 0x0400)
#define EM_SETMARGINS           0x00D3
#define EM_GETMARGINS           0x00D4
#define EM_SETLIMITTEXT         EM_LIMITTEXT   /* ;win40 Name change */
#define EM_GETLIMITTEXT         0x00D5
#define EM_POSFROMCHAR          0x00D6
#define EM_CHARFROMPOS          0x00D7
#endif /* WINVER >= 0x0400 */



/*
 * Button Control Styles
 */
#define BS_PUSHBUTTON       0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX         0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON      0x00000004L
#define BS_3STATE           0x00000005L
#define BS_AUTO3STATE       0x00000006L
#define BS_GROUPBOX         0x00000007L
#define BS_USERBUTTON       0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW        0x0000000BL
#define BS_LEFTTEXT         0x00000020L
#if(WINVER >= 0x0400)
#define BS_TEXT             0x00000000L
#define BS_ICON             0x00000040L
#define BS_BITMAP           0x00000080L
#define BS_LEFT             0x00000100L
#define BS_RIGHT            0x00000200L
#define BS_CENTER           0x00000300L
#define BS_TOP              0x00000400L
#define BS_BOTTOM           0x00000800L
#define BS_VCENTER          0x00000C00L
#define BS_PUSHLIKE         0x00001000L
#define BS_MULTILINE        0x00002000L
#define BS_NOTIFY           0x00004000L
#define BS_FLAT             0x00008000L
#define BS_RIGHTBUTTON      BS_LEFTTEXT
#endif /* WINVER >= 0x0400 */


/*
 * User Button Notification Codes
 */
#define BN_CLICKED          0
#define BN_PAINT            1
#define BN_HILITE           2
#define BN_UNHILITE         3
#define BN_DISABLE          4
#define BN_DOUBLECLICKED    5
#if(WINVER >= 0x0400)
#define BN_PUSHED           BN_HILITE
#define BN_UNPUSHED         BN_UNHILITE
#define BN_DBLCLK           BN_DOUBLECLICKED
#define BN_SETFOCUS         6
#define BN_KILLFOCUS        7
#endif /* WINVER >= 0x0400 */

/*
 * Button Control Messages
 */
#define BM_GETCHECK        0x00F0
#define BM_SETCHECK        0x00F1
#define BM_GETSTATE        0x00F2
#define BM_SETSTATE        0x00F3
#define BM_SETSTYLE        0x00F4
#if(WINVER >= 0x0400)
#define BM_CLICK           0x00F5
#define BM_GETIMAGE        0x00F6
#define BM_SETIMAGE        0x00F7

#define BST_UNCHECKED      0x0000
#define BST_CHECKED        0x0001
#define BST_INDETERMINATE  0x0002
#define BST_PUSHED         0x0004
#define BST_FOCUS          0x0008
#endif /* WINVER >= 0x0400 */

/*
 * Static Control Constants
 */
#define SS_LEFT             0x00000000L
#define SS_CENTER           0x00000001L
#define SS_RIGHT            0x00000002L
#define SS_ICON             0x00000003L
#define SS_BLACKRECT        0x00000004L
#define SS_GRAYRECT         0x00000005L
#define SS_WHITERECT        0x00000006L
#define SS_BLACKFRAME       0x00000007L
#define SS_GRAYFRAME        0x00000008L
#define SS_WHITEFRAME       0x00000009L
#define SS_USERITEM         0x0000000AL
#define SS_SIMPLE           0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#if(WINVER >= 0x0400)
#define SS_OWNERDRAW        0x0000000DL
#define SS_BITMAP           0x0000000EL
#define SS_ENHMETAFILE      0x0000000FL
#define SS_ETCHEDHORZ       0x00000010L
#define SS_ETCHEDVERT       0x00000011L
#define SS_ETCHEDFRAME      0x00000012L
#define SS_TYPEMASK         0x0000001FL
#endif /* WINVER >= 0x0400 */
#define SS_NOPREFIX         0x00000080L /* Don't do "&" character translation */
#if(WINVER >= 0x0400)
#define SS_NOTIFY           0x00000100L
#define SS_CENTERIMAGE      0x00000200L
#define SS_RIGHTJUST        0x00000400L
#define SS_REALSIZEIMAGE    0x00000800L
#define SS_SUNKEN           0x00001000L
#define SS_ENDELLIPSIS      0x00004000L
#define SS_PATHELLIPSIS     0x00008000L
#define SS_WORDELLIPSIS     0x0000C000L
#define SS_ELLIPSISMASK     0x0000C000L
#endif /* WINVER >= 0x0400 */


/*
 * Dialog Styles
 */
#define DS_ABSALIGN         0x01L
#define DS_SYSMODAL         0x02L
#define DS_LOCALEDIT        0x20L   /* Edit items get Local storage. */
#define DS_SETFONT          0x40L   /* User specified font for Dlg controls */
#define DS_MODALFRAME       0x80L   /* Can be combined with WS_CAPTION  */
#define DS_NOIDLEMSG        0x100L  /* WM_ENTERIDLE message will not be sent */
#define DS_SETFOREGROUND    0x200L  /* not in win3.1 */



#if(WINVER >= 0x0400)
#define DS_3DLOOK           0x0004L
#define DS_FIXEDSYS         0x0008L
#define DS_NOFAILCREATE     0x0010L
#define DS_CONTROL          0x0400L
#define DS_CENTER           0x0800L
#define DS_CENTERMOUSE      0x1000L
#define DS_CONTEXTHELP      0x2000L


#endif /* WINVER >= 0x0400 */


/*
 * Listbox Styles
 */
#define LBS_NOTIFY            0x0001L
#define LBS_SORT              0x0002L
#define LBS_NOREDRAW          0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL       0x0800L
#define LBS_DISABLENOSCROLL   0x1000L
#define LBS_NODATA            0x2000L
#if(WINVER >= 0x0400)
#define LBS_NOSEL             0x4000L
#endif /* WINVER >= 0x0400 */
#define LBS_STANDARD          (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)


/*
 * Combo Box styles
 */
#define CBS_SIMPLE            0x0001L
#define CBS_DROPDOWN          0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#define CBS_DISABLENOSCROLL   0x0800L
#if(WINVER >= 0x0400)
#define CBS_UPPERCASE           0x2000L
#define CBS_LOWERCASE           0x4000L
#endif /* WINVER >= 0x0400 */


/*
 * Scroll Bar Styles
 */
#define SBS_HORZ                    0x0000L
#define SBS_VERT                    0x0001L
#define SBS_TOPALIGN                0x0002L
#define SBS_LEFTALIGN               0x0002L
#define SBS_BOTTOMALIGN             0x0004L
#define SBS_RIGHTALIGN              0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN     0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX                 0x0008L
#if(WINVER >= 0x0400)
#define SBS_SIZEGRIP                0x0010L
#endif /* WINVER >= 0x0400 */


/*
 * Commands to pass to WinHelp()
 */
#define HELP_CONTEXT      0x0001L  /* Display topic in ulTopic */
#define HELP_QUIT         0x0002L  /* Terminate help */
#define HELP_INDEX        0x0003L  /* Display index */
#define HELP_CONTENTS     0x0003L
#define HELP_HELPONHELP   0x0004L  /* Display help on using help */
#define HELP_SETINDEX     0x0005L  /* Set current Index for multi index help */
#define HELP_SETCONTENTS  0x0005L
#define HELP_CONTEXTPOPUP 0x0008L
#define HELP_FORCEFILE    0x0009L
#define HELP_KEY          0x0101L  /* Display topic for keyword in offabData */
#define HELP_COMMAND      0x0102L
#define HELP_PARTIALKEY   0x0105L
#define HELP_MULTIKEY     0x0201L
#define HELP_SETWINPOS    0x0203L
#if(WINVER >= 0x0400)
#define HELP_CONTEXTMENU  0x000a
#define HELP_FINDER       0x000b
#define HELP_WM_HELP      0x000c
#define HELP_SETPOPUP_POS 0x000d

#define HELP_TCARD              0x8000
#define HELP_TCARD_DATA         0x0010
#define HELP_TCARD_OTHER_CALLER 0x0011

// These are in winhelp.h in Win95.
#define IDH_NO_HELP                     28440
#define IDH_MISSING_CONTEXT             28441 // Control doesn't have matching help context
#define IDH_GENERIC_HELP_BUTTON         28442 // Property sheet help button
#define IDH_OK                          28443
#define IDH_CANCEL                      28444
#define IDH_HELP                        28445

#endif /* WINVER >= 0x0400 */







#define HDS_HORZ                0x00000000
#define HDS_BUTTONS             0x00000002
#define HDS_HIDDEN              0x00000008


#define TTS_ALWAYSTIP           0x01
#define TTS_NOPREFIX            0x02


#define SBARS_SIZEGRIP          0x0100


#define TBS_AUTOTICKS           0x0001
#define TBS_VERT                0x0002
#define TBS_HORZ                0x0000
#define TBS_TOP                 0x0004
#define TBS_BOTTOM              0x0000
#define TBS_LEFT                0x0004
#define TBS_RIGHT               0x0000
#define TBS_BOTH                0x0008
#define TBS_NOTICKS             0x0010
#define TBS_ENABLESELRANGE      0x0020
#define TBS_FIXEDLENGTH         0x0040
#define TBS_NOTHUMB             0x0080


#define UDS_WRAP                0x0001
#define UDS_SETBUDDYINT         0x0002
#define UDS_ALIGNRIGHT          0x0004
#define UDS_ALIGNLEFT           0x0008
#define UDS_AUTOBUDDY           0x0010
#define UDS_ARROWKEYS           0x0020
#define UDS_HORZ                0x0040
#define UDS_NOTHOUSANDS         0x0080


//====== COMMON CONTROL STYLES ================================================

#define CCS_TOP                 0x00000001L
#define CCS_NOMOVEY             0x00000002L
#define CCS_BOTTOM              0x00000003L
#define CCS_NORESIZE            0x00000004L
#define CCS_NOPARENTALIGN       0x00000008L
#define CCS_ADJUSTABLE          0x00000020L
#define CCS_NODIVIDER           0x00000040L


#define LVS_ICON                0x0000
#define LVS_REPORT              0x0001
#define LVS_SMALLICON           0x0002
#define LVS_LIST                0x0003
#define LVS_TYPEMASK            0x0003
#define LVS_SINGLESEL           0x0004
#define LVS_SHOWSELALWAYS       0x0008
#define LVS_SORTASCENDING       0x0010
#define LVS_SORTDESCENDING      0x0020
#define LVS_SHAREIMAGELISTS     0x0040
#define LVS_NOLABELWRAP         0x0080
#define LVS_AUTOARRANGE         0x0100
#define LVS_EDITLABELS          0x0200
#define LVS_OWNERDATA           0x1000
#define LVS_NOSCROLL            0x2000

#define LVS_TYPESTYLEMASK       0xfc00

#define LVS_ALIGNTOP            0x0000
#define LVS_ALIGNLEFT           0x0800
#define LVS_ALIGNMASK           0x0c00

#define LVS_OWNERDRAWFIXED      0x0400
#define LVS_NOCOLUMNHEADER      0x4000
#define LVS_NOSORTHEADER        0x8000


#define TVS_HASBUTTONS          0x0001
#define TVS_HASLINES            0x0002
#define TVS_LINESATROOT         0x0004
#define TVS_EDITLABELS          0x0008
#define TVS_DISABLEDRAGDROP     0x0010
#define TVS_SHOWSELALWAYS       0x0020


#define TCS_FORCEICONLEFT       0x0010
#define TCS_FORCELABELLEFT      0x0020
#define TCS_TABS                0x0000
#define TCS_BUTTONS             0x0100
#define TCS_SINGLELINE          0x0000
#define TCS_MULTILINE           0x0200
#define TCS_RIGHTJUSTIFY        0x0000
#define TCS_FIXEDWIDTH          0x0400
#define TCS_RAGGEDRIGHT         0x0800
#define TCS_FOCUSONBUTTONDOWN   0x1000
#define TCS_OWNERDRAWFIXED      0x2000
#define TCS_TOOLTIPS            0x4000
#define TCS_FOCUSNEVER          0x8000


#define ACS_CENTER              0x0001
#define ACS_TRANSPARENT         0x0002
#define ACS_AUTOPLAY            0x0004









#define WM_DDE_FIRST	    0x03E0
#define WM_DDE_INITIATE     (WM_DDE_FIRST)
#define WM_DDE_TERMINATE    (WM_DDE_FIRST+1)
#define WM_DDE_ADVISE	    (WM_DDE_FIRST+2)
#define WM_DDE_UNADVISE     (WM_DDE_FIRST+3)
#define WM_DDE_ACK	        (WM_DDE_FIRST+4)
#define WM_DDE_DATA	        (WM_DDE_FIRST+5)
#define WM_DDE_REQUEST	    (WM_DDE_FIRST+6)
#define WM_DDE_POKE	        (WM_DDE_FIRST+7)
#define WM_DDE_EXECUTE	    (WM_DDE_FIRST+8)
#define WM_DDE_LAST	        (WM_DDE_FIRST+8)





#ifdef  UNICODE                     
#define __TEXT(quote) L##quote      
#else   /* UNICODE */               
#define __TEXT(quote) quote         
#endif /* UNICODE */                
#define TEXT(quote) __TEXT(quote)   

//
//  Language IDs.
//
//  The following two combinations of primary language ID and
//  sublanguage ID have special semantics:
//
//    Primary Language ID   Sublanguage ID      Result
//    -------------------   ---------------     ------------------------
//    LANG_NEUTRAL          SUBLANG_NEUTRAL     Language neutral
//    LANG_NEUTRAL          SUBLANG_DEFAULT     User default language
//    LANG_NEUTRAL          SUBLANG_SYS_DEFAULT System default language
//

//
//  Primary language IDs.
//

#define LANG_NEUTRAL                     0x00

#define LANG_AFRIKAANS                   0x36
#define LANG_ALBANIAN                    0x1c
#define LANG_ARABIC                      0x01
#define LANG_BASQUE                      0x2d
#define LANG_BELARUSIAN                  0x23
#define LANG_BULGARIAN                   0x02
#define LANG_CATALAN                     0x03
#define LANG_CHINESE                     0x04
#define LANG_CROATIAN                    0x1a
#define LANG_CZECH                       0x05
#define LANG_DANISH                      0x06
#define LANG_DUTCH                       0x13
#define LANG_ENGLISH                     0x09
#define LANG_ESTONIAN                    0x25
#define LANG_FAEROESE                    0x38
#define LANG_FARSI                       0x29
#define LANG_FINNISH                     0x0b
#define LANG_FRENCH                      0x0c
#define LANG_GERMAN                      0x07
#define LANG_GREEK                       0x08
#define LANG_HEBREW                      0x0d
#define LANG_HUNGARIAN                   0x0e
#define LANG_ICELANDIC                   0x0f
#define LANG_INDONESIAN                  0x21
#define LANG_ITALIAN                     0x10
#define LANG_JAPANESE                    0x11
#define LANG_KOREAN                      0x12
#define LANG_LATVIAN                     0x26
#define LANG_LITHUANIAN                  0x27
#define LANG_NORWEGIAN                   0x14
#define LANG_POLISH                      0x15
#define LANG_PORTUGUESE                  0x16
#define LANG_ROMANIAN                    0x18
#define LANG_RUSSIAN                     0x19
#define LANG_SERBIAN                     0x1a
#define LANG_SLOVAK                      0x1b
#define LANG_SLOVENIAN                   0x24
#define LANG_SPANISH                     0x0a
#define LANG_SWEDISH                     0x1d
#define LANG_THAI                        0x1e
#define LANG_TURKISH                     0x1f
#define LANG_UKRAINIAN                   0x22
#define LANG_VIETNAMESE                  0x2a

//
//  Sublanguage IDs.
//
//  The name immediately following SUBLANG_ dictates which primary
//  language ID that sublanguage ID can be combined with to form a
//  valid language ID.
//

#define SUBLANG_NEUTRAL                  0x00    // language neutral
#define SUBLANG_DEFAULT                  0x01    // user default
#define SUBLANG_SYS_DEFAULT              0x02    // system default

#define SUBLANG_ARABIC_SAUDI_ARABIA      0x01    // Arabic (Saudi Arabia)
#define SUBLANG_ARABIC_IRAQ              0x02    // Arabic (Iraq)
#define SUBLANG_ARABIC_EGYPT             0x03    // Arabic (Egypt)
#define SUBLANG_ARABIC_LIBYA             0x04    // Arabic (Libya)
#define SUBLANG_ARABIC_ALGERIA           0x05    // Arabic (Algeria)
#define SUBLANG_ARABIC_MOROCCO           0x06    // Arabic (Morocco)
#define SUBLANG_ARABIC_TUNISIA           0x07    // Arabic (Tunisia)
#define SUBLANG_ARABIC_OMAN              0x08    // Arabic (Oman)
#define SUBLANG_ARABIC_YEMEN             0x09    // Arabic (Yemen)
#define SUBLANG_ARABIC_SYRIA             0x0a    // Arabic (Syria)
#define SUBLANG_ARABIC_JORDAN            0x0b    // Arabic (Jordan)
#define SUBLANG_ARABIC_LEBANON           0x0c    // Arabic (Lebanon)
#define SUBLANG_ARABIC_KUWAIT            0x0d    // Arabic (Kuwait)
#define SUBLANG_ARABIC_UAE               0x0e    // Arabic (U.A.E)
#define SUBLANG_ARABIC_BAHRAIN           0x0f    // Arabic (Bahrain)
#define SUBLANG_ARABIC_QATAR             0x10    // Arabic (Qatar)
#define SUBLANG_CHINESE_TRADITIONAL      0x01    // Chinese (Taiwan)
#define SUBLANG_CHINESE_SIMPLIFIED       0x02    // Chinese (PR China)
#define SUBLANG_CHINESE_HONGKONG         0x03    // Chinese (Hong Kong SAR)
#define SUBLANG_CHINESE_SINGAPORE        0x04    // Chinese (Singapore)
#define SUBLANG_DUTCH                    0x01    // Dutch
#define SUBLANG_DUTCH_BELGIAN            0x02    // Dutch (Belgian)
#define SUBLANG_ENGLISH_US               0x01    // English (USA)
#define SUBLANG_ENGLISH_UK               0x02    // English (UK)
#define SUBLANG_ENGLISH_AUS              0x03    // English (Australian)
#define SUBLANG_ENGLISH_CAN              0x04    // English (Canadian)
#define SUBLANG_ENGLISH_NZ               0x05    // English (New Zealand)
#define SUBLANG_ENGLISH_EIRE             0x06    // English (Irish)
#define SUBLANG_ENGLISH_SOUTH_AFRICA     0x07    // English (South Africa)
#define SUBLANG_ENGLISH_JAMAICA          0x08    // English (Jamaica)
#define SUBLANG_ENGLISH_CARIBBEAN        0x09    // English (Caribbean)
#define SUBLANG_ENGLISH_BELIZE           0x0a    // English (Belize)
#define SUBLANG_ENGLISH_TRINIDAD         0x0b    // English (Trinidad)
#define SUBLANG_FRENCH                   0x01    // French
#define SUBLANG_FRENCH_BELGIAN           0x02    // French (Belgian)
#define SUBLANG_FRENCH_CANADIAN          0x03    // French (Canadian)
#define SUBLANG_FRENCH_SWISS             0x04    // French (Swiss)
#define SUBLANG_FRENCH_LUXEMBOURG        0x05    // French (Luxembourg)
#define SUBLANG_GERMAN                   0x01    // German
#define SUBLANG_GERMAN_SWISS             0x02    // German (Swiss)
#define SUBLANG_GERMAN_AUSTRIAN          0x03    // German (Austrian)
#define SUBLANG_GERMAN_LUXEMBOURG        0x04    // German (Luxembourg)
#define SUBLANG_GERMAN_LIECHTENSTEIN     0x05    // German (Liechtenstein)
#define SUBLANG_ITALIAN                  0x01    // Italian
#define SUBLANG_ITALIAN_SWISS            0x02    // Italian (Swiss)
#define SUBLANG_KOREAN                   0x01    // Korean (Extended Wansung)
#define SUBLANG_KOREAN_JOHAB             0x02    // Korean (Johab)
#define SUBLANG_NORWEGIAN_BOKMAL         0x01    // Norwegian (Bokmal)
#define SUBLANG_NORWEGIAN_NYNORSK        0x02    // Norwegian (Nynorsk)
#define SUBLANG_PORTUGUESE               0x02    // Portuguese
#define SUBLANG_PORTUGUESE_BRAZILIAN     0x01    // Portuguese (Brazilian)
#define SUBLANG_SERBIAN_LATIN            0x02    // Serbian (Latin)
#define SUBLANG_SERBIAN_CYRILLIC         0x03    // Serbian (Cyrillic)
#define SUBLANG_SPANISH                  0x01    // Spanish (Castilian)
#define SUBLANG_SPANISH_MEXICAN          0x02    // Spanish (Mexican)
#define SUBLANG_SPANISH_MODERN           0x03    // Spanish (Modern)
#define SUBLANG_SPANISH_GUATEMALA        0x04    // Spanish (Guatemala)
#define SUBLANG_SPANISH_COSTA_RICA       0x05    // Spanish (Costa Rica)
#define SUBLANG_SPANISH_PANAMA           0x06    // Spanish (Panama)
#define SUBLANG_SPANISH_DOMINICAN_REPUBLIC 0x07  // Spanish (Dominican Republic)
#define SUBLANG_SPANISH_VENEZUELA        0x08    // Spanish (Venezuela)
#define SUBLANG_SPANISH_COLOMBIA         0x09    // Spanish (Colombia)
#define SUBLANG_SPANISH_PERU             0x0a    // Spanish (Peru)
#define SUBLANG_SPANISH_ARGENTINA        0x0b    // Spanish (Argentina)
#define SUBLANG_SPANISH_ECUADOR          0x0c    // Spanish (Ecuador)
#define SUBLANG_SPANISH_CHILE            0x0d    // Spanish (Chile)
#define SUBLANG_SPANISH_URUGUAY          0x0e    // Spanish (Uruguay)
#define SUBLANG_SPANISH_PARAGUAY         0x0f    // Spanish (Paraguay)
#define SUBLANG_SPANISH_BOLIVIA          0x10    // Spanish (Bolivia)
#define SUBLANG_SPANISH_EL_SALVADOR      0x11    // Spanish (El Salvador)
#define SUBLANG_SPANISH_HONDURAS         0x12    // Spanish (Honduras)
#define SUBLANG_SPANISH_NICARAGUA        0x13    // Spanish (Nicaragua)
#define SUBLANG_SPANISH_PUERTO_RICO      0x14    // Spanish (Puerto Rico)
#define SUBLANG_SWEDISH                  0x01    // Swedish
#define SUBLANG_SWEDISH_FINLAND          0x02    // Swedish (Finland)

//
//  Sorting IDs.
//

#define SORT_DEFAULT                     0x0     // sorting default

#define SORT_JAPANESE_XJIS               0x0     // Japanese XJIS order
#define SORT_JAPANESE_UNICODE            0x1     // Japanese Unicode order

#define SORT_CHINESE_BIG5                0x0     // Chinese BIG5 order
#define SORT_CHINESE_PRCP                0x0     // PRC Chinese Phonetic order
#define SORT_CHINESE_UNICODE             0x1     // Chinese Unicode order
#define SORT_CHINESE_PRC                 0x2     // PRC Chinese Stroke Count order

#define SORT_KOREAN_KSC                  0x0     // Korean KSC order
#define SORT_KOREAN_UNICODE              0x1     // Korean Unicode order

#define SORT_GERMAN_PHONE_BOOK           0x1     // German Phone Book order

#ifndef UNDER_CE
#include <dlgs.h>
#include <winver.h>
#endif

#endif /* _WINRESRC_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_cbhost.h ===
/*	@doc INTERNAL
 *
 *	@module _CBHOST.H  Combobox Host for Window's Rich Edit Control |
 *	
 *
 *	Original Author: <nl>
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/30/98	v-jerrki	created
 */
#ifndef _CBHOST_H
#define _CBHOST_H

#include "_host.h"
#define CB_LISTBOXID	1000
#define CB_EDITBOXID	1001

#define ITEM_MSG_DRAWLIST	1
#define ITEM_MSG_DRAWCOMBO	2
#define ITEM_MSG_DELETE		3


class CCmbBxWinHost : public CTxtWinHost
{
friend LRESULT CALLBACK RichComboBoxWndProc(HWND, UINT, WPARAM, LPARAM);

public:
	typedef enum {						// enumeration determining type of combo box
		kSimple = 1,
		kDropDown = 2,
		kDropDownList = 3
	} Combotype;

#ifndef ACCESSIBILITY
public:
	// -----------------------------
	//	IUnknown interface
	// -----------------------------
    virtual HRESULT 		WINAPI QueryInterface(REFIID riid, void **ppvObject);
#endif
	
public:
	unsigned int	_fRightAlign:1;		// Determines if the combo box should be right aligned
	unsigned int 	_fListVisible:1;	// Determines if list is visible
	unsigned int	_fOwnerDraw:1;		// owner draw combo box
	unsigned int	_fFocus:1;			// do we have the focus?
	unsigned int 	_fMousedown:1;		// if the left button was down
	unsigned int	_fVisible:1;		// window is visible
	unsigned int	_fEnabled:1;		// window is enabled
	unsigned int	_fNoIntegralHeight:1; // no integral height
	unsigned int	_fCapture:1;		// determines if the combo box has mouse cursor captured or not
	unsigned int 	_fResizing:1;		// flag to indicate we are resizing the window
	unsigned int	_fExtendedUI:1;		// flag indicating if extended ui is used
	unsigned int	_fLBCBMessage:1;	// flag indicating the message is LBCB_TRACKING
	unsigned int	_fIgnoreChange:1;	// flag indicating there was an internal change of text in
										// the edit control
	unsigned int	_fIgnoreUpdate:1;	// flag indicating if we should ignore the update flag, we need
										// this flag because there will be cases where updateWindow is
										// needed but we don't want to fire the notification

	HWND			_hwndList;			// window handle of listbox
	HCURSOR			_hcurOld;			// handle to the mouse cursor
	
protected:
	RECT			_rcWindow;			// rect of window which the combo box was created with
	RECT			_rcButton;			// rect of button
	RECT			_rcList;			// rect of listbox

										// we have to have a minimum inset for either the right or left
										// to account for the button for the combo box
	int				_dxRInset;			// minimum right inset
	int				_dxLInset;			// minimum left inset

	int				_dxROffset;			// indents for right and left these values should be used
	int 			_dxLOffset;			// with _dxRInset/_dxLInset to properly calculate the indents

	int				_dyFont;			// Height of the current font, may not necessarily be the system font
	int				_dyEdit;			// height of items

	int				_cyCombo;			// Height of the combo box
	int				_cxCombo;			// Width of the combo box
	int				_cyList;			// Height of the listbox

	long			_nCursor;			// last selected cursor -2 by default
	BOOL			_bSelOk;			// used to help in determining what kind of notification to give

	UINT			_idCtrl;			// ID of control	
	Combotype		_cbType;			// current combo box style
	CLstBxWinHost*	_plbHost;			// pointer to listbox host

protected:

	// Draws the combo button
	void DrawButton(HDC hdc, BOOL bDown);

	// Sets the edit controls text to item of the list box
	void AutoUpdateEdit(int i);

	// Hilite the edit control
	void HiliteEdit(BOOL bSelect);

	// resizes the list box
	void SetDropSize(RECT* prc);

	// set the edit size
	void SetSizeEdit(int nLeft, int nTop, int nRight, int nBottom);

public:
	// Constructor / Destructor
	CCmbBxWinHost();
	virtual ~CCmbBxWinHost();

	// initialization function
	virtual BOOL Init(HWND,	const CREATESTRUCT *);

	// Window creation/destruction
	static 	LRESULT OnNCCreate(HWND hwnd, const CREATESTRUCT *pcs);
	static 	void OnNCDestroy(CCmbBxWinHost *ped);
	virtual LRESULT OnCreate(const CREATESTRUCT *pcs);

	// Edit control Text helper functions
	LRESULT GetEditText(LPTSTR szStr, int nSize);
	LRESULT GetTextLength();

	// Draws the focus rect for the edit control
	void DrawEditFocus(HDC);

	// Sets the text in the edit control to the text of the current item in the
	// list box
	void UpdateEditBox();

	// selects the item which has the same text string as the edit control
	int UpdateListBox(BOOL);

	// hides the listbox
	BOOL HideListBox(BOOL, BOOL);

	// shows the list box
	void ShowListBox(BOOL);

	// Used as a way for the listbox to communicate to the combo box about a selection
	void SetSelectionInfo(BOOL bOk, int nIdx);

	// Update the window but don't send the notification
	void UpdateCbWindow()
	{
		_fIgnoreUpdate = 1;
		TxViewChange(TRUE);
		_fIgnoreUpdate = 0;
	}
	
	/////////////////////////////// message handlers /////////////////////////////////

	// Richedit message
	LRESULT OnSetTextEx(WPARAM wparam, LPARAM lparam);
	 
	// Keyboard messages
	virtual LRESULT	OnKeyDown(WORD vKey, DWORD dwFlags);
	virtual LRESULT	OnChar(WORD vKey, DWORD dwFlags);
	virtual LRESULT OnSyskeyDown(WORD vKey, DWORD dwFlags);

	// mouse messages
	LRESULT OnLButtonUp(WPARAM wparam, LPARAM lparam);
	LRESULT OnMouseMove(WPARAM wparam, LPARAM lparam);
	LRESULT OnMouseWheel(WPARAM wparam, LPARAM lparam);
	LRESULT OnSetCursor(WPARAM wparam, LPARAM lparam);
	LRESULT OnLButtonDown(WPARAM wparam, LPARAM lparam);

	// focus messages
	LRESULT OnSetFocus(WPARAM wparam, LPARAM lparam);
	LRESULT OnKillFocus(WPARAM wparam, LPARAM lparam);
	LRESULT OnCaptureChanged(WPARAM wparam, LPARAM lparam);

	// window messages
	LRESULT OnPaint(WPARAM, LPARAM);
	HRESULT OnCommand(WPARAM wparam, LPARAM lparam);	
	LRESULT OnSize(WPARAM wparam, LPARAM lparam);
	LRESULT OnGetDlgCode(WPARAM wparam, LPARAM lparam);
	LRESULT OnEnable(WPARAM wparam, LPARAM lparam);

	//@cmember Notify host of events
	virtual HRESULT	TxNotify(DWORD iNotify, void *pv);

	//@cmember Changes the mouse cursor
	virtual HCURSOR	 TxSetCursor2(HCURSOR hcur, BOOL bText) 
	{ return (hcur) ? ::SetCursor(hcur) : ::GetCursor();}

	///////////////////////// combo box message handlers ////////////////////////////
	// Calculates the rect's and height's of all the controls
	BOOL CbCalcControlRects(RECT* prc, BOOL bCalcChange);	

	// Retrieves the item height for either the edit or list box
	LRESULT CbGetItemHeight(BOOL bEdit);

	// sets the item height for either the edit or list box
	LRESULT CbSetItemHeight(BOOL bEdit, int nHeight);	

	// sets extendedUI mode
	LRESULT CbSetExtendedUI(BOOL bExtendedUI);

	// retrieves the current extendedUI mode
	LRESULT CbGetExtendedUI() const {return _fExtendedUI;}

	// forwards the WM_DRAWITEM, WM_DELETEITEM messages to the parent window
	LRESULT CbMessageItemHandler(HDC, int, WPARAM, LPARAM);

#ifndef NOACCESSIBILITY
	////////////////////////// IAccessible Methods /////////////////////////////////
	HRESULT	InitTypeInfo();
	
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);    
    STDMETHOD(get_accChildCount)(long *pcountChildren);    
    STDMETHOD(get_accChild)(VARIANT varChild, IDispatch **ppdispChild);    
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);    
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);    
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);     
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);    
    STDMETHOD(get_accFocus)(VARIANT *pvarChild);    
    STDMETHOD(get_accSelection)(VARIANT *pvarChildren);    
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);    
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);    
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);    
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);    
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChild);    
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
#endif // NOACCESSIBILITY

};


#endif // _CBHOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_callmgr.h ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	_CALLMGR.H	CCallMgr declaration |
 *
 *	Purpose:  The call manager controls various aspects of
 *		a client call chain, including re-entrancy management,
 *		undo contexts, and change notifications.
 *
 *	Author:	<nl>
 *		alexgo 2/8/96
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#ifndef _CALLMGR_H
#define _CALLMGR_H

class CTxtEdit;
class CCallMgr;

#include "textserv.h"

enum CompName
{
	COMP_UNDOBUILDER	= 1,	// currently, these two are only compatible
	COMP_REDOBUILDER	= 2,	// with CGenUndoBuilder undo contexts
	COMP_UNDOGUARD		= 3,
	COMP_SELPHASEADJUSTER = 4
};

/*
 *	IReEntrantComponent
 *
 *	@class	A base class/interface for objects that want to work with the call
 *			manager for special re-entrancy requirements.
 *
 *			This class is similar in spirit to ITxNotify, thus, it contains
 *			private data only accessible to CCallMgr
 */
class IReEntrantComponent
{
	friend class CCallMgr;

//@access	Public Data
public:
	virtual void OnEnterContext() = 0;		//@cmember Called when a 
											// context is entered
//@access	Private Data
private:
	CompName				_idName;		//@cmember Name for this component
	IReEntrantComponent *	_pnext;			//@cmember Next one in list
};
		
/*
 *
 *	CCallMgr
 *
 *	@class	A stack-based class to handle re-entrancy and notification
 *			management.  CCallMgr's are created on the stack on every
 *			important entry point.  If one already exists (i.e. the
 *			edit control has been re-entered), the Call Manager will 
 *			adjust appropriately.
 */

class CCallMgr
{
	friend class CGenUndoBuilder;

//@access	Public Methods
public:
	// Notification Methods
	void SetChangeEvent(CHANGETYPE fType);	//@cmember Something changed
	void ClearChangeEvent();				//@cmember Ignore change
											//@cmember Did something change?
	BOOL GetChangeEvent()	{return _pPrevcallmgr ? 
								_pPrevcallmgr->GetChangeEvent() : _fChange;}
	BOOL GetMaxText()		{return _pPrevcallmgr ? 
								_pPrevcallmgr->GetMaxText() : _fMaxText;}
	BOOL GetOutOfMemory()	{return _pPrevcallmgr ? 
								_pPrevcallmgr->GetOutOfMemory() : _fOutOfMemory;}
	void SetNewUndo();						//@cmember New undo action added
	void SetNewRedo();						//@cmember New redo action added
	void SetMaxText();						//@cmember Max text length reached
	void SetSelectionChanged();				//@cmember Selection changed
	void SetOutOfMemory();					//@cmember Out of memory hit
	void SetInProtected(BOOL f);			//@cmember Set if in protected
											//		 notification callback
	BOOL GetInProtected();					//@cmember Get InProtected flag

	// SubSystem Management methods
											//@cmember Register a component
											// for this call context
	void RegisterComponent(IReEntrantComponent *pcomp, CompName name);
											//@cmember Revoke a component from
											//		this call context
	void RevokeComponent(IReEntrantComponent *pcomp);
	
	IReEntrantComponent *GetComponent(CompName name);//@cmember Get registered
											//		component by name

	// General Methods
	BOOL IsReEntered() { return !!_pPrevcallmgr;} //@cmember Return TRUE if
											//		in a re-entrant state
	BOOL IsZombie() { return !_ped;}		//@cmember Zombie call

	// Constructor/Destructor
	CCallMgr(CTxtEdit *ped);				//@cmember constructor
	~CCallMgr();							//@cmember destructor


//@access	Private Methods and data
private:

	void SendAllNotifications();			//@cmember Flush any cached 
											// notifications 
	void NotifyEnterContext();				//@cmember Notify registered 
											// components of a new context.

	CTxtEdit *		_ped;					//@cmember Current edit context
	CCallMgr *		_pPrevcallmgr;			//@cmember Next highest call mgr
	IReEntrantComponent *_pcomplist;		//@cmember List of components
											// registered for this call context

	unsigned long	_fTextChanged	:1;		//@cmember Text changed
	unsigned long	_fChange		:1;		//@cmember Generic change
	unsigned long	_fNewUndo		:1;		//@cmember New undo action added
	unsigned long	_fNewRedo		:1;		//@cmember New redo action added
	unsigned long	_fMaxText		:1;		//@cmember Max text length reached
	unsigned long	_fSelChanged	:1;		//@cmember Selection changed
	unsigned long	_fOutOfMemory	:1;		//@cmember Out of memory

	unsigned long	_fInProtected	:1;		//@cmember if in EN_PROTECTED not.
};

#endif // _CALLMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_clasfyc.h ===
/*
 *	@doc
 *
 *	@module _clasfyc.H -- character classification |
 *	
 *	Authors: <nl>
 *		Jon Matousek
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef _CLASFYC_H
#define _CLASFYC_H

extern const INT g_cKinsokuCategories;

void BatchClassify(const WCHAR *ch, INT cch, WORD *pcType3,
				   INT *kinsokuClassifications, WORD *pwRes);
BOOL CanBreak(INT class1, INT class2);
WORD ClassifyChar(TCHAR ch);
INT	 GetKinsokuClass(WCHAR ch);
BOOL InitKinsokuClassify();
BOOL IsSameClass(WORD currType1, WORD startType1,
				 WORD currType3, WORD startType3);
BOOL IsURLDelimiter(WCHAR ch);
void UninitKinsokuClassify();

#define MAX_CLASSIFY_CHARS (256L)

#define	brkclsQuote			0
#define	brkclsOpen			1
#define	brkclsClose			2
#define	brkclsGlueA			3
#define	brkclsExclaInterr	4
#define	brkclsSlash			6
#define	brkclsInseparable	7
#define	brkclsPrefix		8
#define	brkclsPostfix		9
#define	brkclsNoStartIdeo	10
#define	brkclsIdeographic	11
#define	brkclsNumeral		12
#define	brkclsSpaceN		14
#define	brkclsAlpha			15

// Korean Unicode ranges
#define IsKoreanJamo(ch)	IN_RANGE(0x1100, ch, 0x11FF)
#define IsKorean(ch)		IN_RANGE(0xAC00, ch, 0xD7FF)

// Thai Unicode range
#define IsThai(ch)			IN_RANGE(0x0E00, ch, 0x0E7F)

// -FUTURE- This should be moved to richedit.h
#define WBF_KOREAN			0x0080
#define WBF_WORDBREAKAFTER	0x0400		// Break word after this character (for language such as Thai)



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_common.h ===
/*
 *	_COMMON.H
 *	
 *	Purpose:
 *		RICHEDIT private common definitions
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _COMMON_H
#define _COMMON_H

// REVIEW macro.
//
#define __LINE(l)   #l
#define __LINE_(l)  __LINE(l)
#define _LINE_      __LINE_(__LINE__)
#define REVIEW  __FILE__ "("  __LINE_(__LINE__) ") : "

#pragma message ("Compiling Common.H")

#ifdef NT
	#ifndef WINNT
	#define WINNT
	#endif
#endif

#define _UNICODE

#ifndef STRICT
#define STRICT
#endif

#define NOSHELLDEBUG			//disables asserts in shell.h

#include <limits.h>
#if defined(DEBUG) && !defined(PEGASUS)
#include <stdio.h>
#endif

#define WINVER 0x0500

#include <windows.h>
#include <windowsx.h>
#include <winable.h>

#ifndef MACPORT
#include "imm.h"
#else
#include <tchar.h>
#include "wlmimm.h"
#endif	//MACPORT

/*
 *	Types
 */
#include <ourtypes.h>

// for the benefit of the outside world, richedit.h uses cpMax instead
// of cpMost. I highly prefer cpMost
#ifdef cpMax
#error "cpMax hack won't work"
#endif

#define cpMax cpMost
#include <richedit.h>
#include <richole.h>
#undef cpMax

#include "_debug.h"

// Return TRUE if LF <= ch <= CR. NB: ch must be unsigned;
// TCHAR and unsigned short give wrong results!
#define IN_RANGE(n1, b, n2)		((unsigned)((b) - (n1)) <= unsigned((n2) - (n1)))

#define IsASCIIDigit(b)		IN_RANGE('0', b, '9')
#define IsASCIIEOP(ch)		IN_RANGE(LF, ch, CR)
#define IsZerowidthCharacter(ch) IN_RANGE(ZWSP, ch, RTLMARK)


// disable
//         4710 : function not inlined
//         4512 : assignment operator not generated
//         4201 : nameless struct union
//         4100 : unreferenced formal;
//		   4706 : assignment within conditional expression (oould be bad, but common)
//		   4127 : conditional expression is constant (if (1))
//		   4242 : truncation warning
//         4244 : truncation warning

#pragma warning (disable : 4710 4512 4201 4100 4127 4706 4242 4244)

#pragma warning(3:4121)   // structure is sensitive to alignment
#pragma warning(3:4130)   // logical operation on address of string constant
#pragma warning(3:4132)   // const object should be initialized
#pragma warning(3:4509)   // use of SEH with destructor

// Our Win32 wrapper class
#include "_w32sys.h"

#include "resource.h"

// Use explicit ASCII values for LF and CR, since MAC compilers
// interchange values of '\r' and '\n'
#define	LF			10
#define	CR			13
#define FF			12
#define TAB			TEXT('\t')
//#define CELL		7
#define CELL		TAB
#define EURO		0x20AC
#define VT			TEXT('\v')
#define	PS			0x2029
#define SOFTHYPHEN	0xAD

#define BOM			0xFEFF
#define BULLET		0x2022
#define EMDASH		0x2014
#define EMSPACE		0x2003
#define ENDASH		0x2013
#define	ENQUAD		0x2000
#define ENSPACE		0x2002
#define KASHIDA		0x0640
#define LDBLQUOTE	0x201c
#define LQUOTE		0x2018
#define LTRMARK		0x200E
#define RDBLQUOTE	0x201D
#define RQUOTE		0x2019
#define RTLMARK		0x200F
#define SOFTHYPHEN	0xAD
#define	UTF16		0xDC00
#define	UTF16_LEAD	0xD800
#define	UTF16_TRAIL	0xDC00
#define ZWSP		0x200B
#define ZWJ			0x200D
#define ZWNJ		0x200C


/*
 *	IsEOP(ch)
 *
 *	@func
 *		Used to determine if ch is an EOP char, i.e., CR, LF, VT, FF, PS, or
 *		LS (Unicode paragraph/line separator). For speed, this function is
 *		inlined.
 *
 *	@rdesc
 *		TRUE if ch is an end-of-paragraph char
 */
__inline BOOL IsEOP(unsigned ch)
{
	return IN_RANGE(LF, ch, CR) || (ch | 1) == PS;
}

BOOL	IsRTF(char *pstr);

#include <tom.h>
#define CP_INFINITE tomForward

#include "zmouse.h"
#include "stddef.h"
#include "_util.h"

#ifdef DEBUG
#define EM_DBGPED (WM_USER + 150)
#endif

#define EM_GETCODEPAGE	(WM_USER + 151)

// MIN

#ifdef min
#undef min
#endif
#define __min(a,b)    (((a) < (b)) ? (a) : (b))

inline int     min(int     v1, int     v2)	{return __min(v1, v2);}
inline UINT    min(UINT    v1, UINT    v2)	{return __min(v1, v2);}
inline float   min(float   v1, float   v2)	{return __min(v1, v2);}
inline double  min(double  v1, double  v2)	{return __min(v1, v2);}
inline __int64 min(__int64 v1, __int64 v2)	{return __min(v1, v2);}

// MAX

#ifdef max
#undef max
#endif
#define __max(a,b)    (((a) > (b)) ? (a) : (b))

inline int     max(int     v1, int     v2)	{return __max(v1, v2);}
inline UINT    max(UINT    v1, UINT    v2)	{return __max(v1, v2);}
inline float   max(float   v1, float   v2)	{return __max(v1, v2);}
inline double  max(double  v1, double  v2)	{return __max(v1, v2);}
inline __int64 max(__int64 v1, __int64 v2)	{return __max(v1, v2);}

// ABS

#ifdef abs
#undef abs
#endif
#define __abs(a)    (((a) < 0) ? 0 - (a) : (a))

#pragma function(abs)
inline int __cdecl abs(int	   v)	{return __abs(v);}
// The abs val of a UINT is just that number. If we were to pass the value on to
// the __abs macro we'd get a warning because (a) < 0 will always be false. This
// fix allows us to compile cleanly *and* keep the same behavior as before.
inline UINT    abs(UINT    v)	{return v;}
inline float   abs(float   v)	{return __abs(v);}
inline double  abs(double  v)   {return __abs(v);}
inline __int64 abs(__int64 v)	{return __abs(v);}

#define ARRAY_SIZE(x)   (sizeof(x) / sizeof(x[0]))

#include "_cfpf.h"

// Interesting OS versions
#define VERS4		4

// conversions between byte and character counts
#define CbOfCch(_x) ((_x) * 2)
#define CchOfCb(_x) ((_x) / 2)

#define cKinsokuCategories	16

#define OLEstrcmp	wcscmp
#define OLEstrcpy	wcscpy
#define OLEsprintf	wsprintf
#define OLEstrlen	wcslen

// index (window long) of the PED
#define ibPed 0

#define RETID_BGND_RECALC	0x01af
#define RETID_AUTOSCROLL	0x01b0
#define RETID_SMOOTHSCROLL	0x01b1
#define RETID_DRAGDROP		0x01b2
#define RETID_MAGELLANTRACK	0x01b3

// Count of characters in CRLF marker
#define cchCRLF 2
#define cchCR	1

// RichEdit 1.0 uses a CRLF for an EOD marker
#define	CCH_EOD_10			2
// RichEdit 2.0 uses a simple CR for the EOD marker
#define CCH_EOD_20			1

extern const TCHAR szCRLF[];
extern const TCHAR szCR[];

extern HINSTANCE hinstRE;		// DLL instance

#include <shellapi.h>

#ifndef MACPORT
  #ifdef DUAL_FORMATETC
  #undef DUAL_FORMATETC
  #endif
  #define DUAL_FORMATETC FORMATETC
#endif

#include "WIN2MAC.h"

extern "C"
{
	LRESULT CALLBACK RichEditWndProc(HWND, UINT, WPARAM, LPARAM);
	LRESULT CALLBACK RichEditANSIWndProc(HWND, UINT, WPARAM, LPARAM);
}

// Multi-Threading support
extern CRITICAL_SECTION g_CriticalSection;

// a class to simplify critical section management
class CLock
{
public:
	CLock()
	{
		EnterCriticalSection(&g_CriticalSection);
	}
	~CLock()
	{
		LeaveCriticalSection(&g_CriticalSection);
	}
};

enum HITTEST
{
	HT_Undefined = 0,	// Hit hasn't been determined
	HT_Nothing,
	HT_OutlineSymbol,
	HT_LeftOfText,
	HT_BulletArea,
	HT_RightOfText,

	HT_Text,			// All hits are in text from HT_Text on so
	HT_Link,			//  if(hit >= HT_Text) identifies text of some kind
	HT_Italic,
	HT_Object
};

#define ST_CHECKPROTECTION		0x8000
#define ST_10REPLACESEL			0x10000000
#define ST_10WM_SETTEXT			0x20000000

/* REListbox1.0 Window Class. */
// For Windows CE to avaoid possible conflicts on WIn95.
#define CELISTBOX_CLASSA	"REListBoxCEA"
#define CELISTBOX_CLASSW	L"REListBoxCEW"

#ifndef MACPORT
#define LISTBOX_CLASSW		L"REListBox20W"
#define COMBOBOX_CLASSW		L"REComboBox20W"
#else	/*----------------------MACPORT */
#define LISTBOX_CLASSW		TEXT("REListBox20W")	/* MACPORT change */
#define COMBOBOX_CLASSW		TEXT("REComboBox20W")	/* MACPORT change */
#endif /* MACPORT  */

#ifdef DEBUG
//Debug api for dumping CTxtStory arrays.
extern "C" {
extern void DumpDoc(void *);
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_cmsgflt.h ===
// Forward declarations
class CIme;

class CTextMsgFilter : public ITextMsgFilter
{
public :
	HRESULT STDMETHODCALLTYPE QueryInterface( 
		REFIID riid,
		void **ppvObject);
	ULONG STDMETHODCALLTYPE AddRef( void);
	ULONG STDMETHODCALLTYPE Release( void);
	HRESULT STDMETHODCALLTYPE AttachDocument( HWND hwnd, ITextDocument2 *pTextDoc);
	HRESULT STDMETHODCALLTYPE HandleMessage( 
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres);
	HRESULT STDMETHODCALLTYPE AttachMsgFilter( ITextMsgFilter *pMsgFilter);

	~CTextMsgFilter();

	BOOL	IsIMEComposition()	{ return (_ime != NULL);};
	BOOL	GetTxSelection();

	CIme	*_ime;					// non-NULL when IME composition active
	HWND	_hwnd;	
	UINT	_uKeyBoardCodePage;		// current keyboard codepage
	UINT	_uSystemCodePage;		// system codepage

	WORD	_fIMECancelComplete		:1;		// If aborting IME, cancel comp string, else complete
	WORD	_fUnicodeIME			:1;		// TRUE if Unicode IME
	WORD	_fIMEAlwaysNotify		:1;		// Send Notification during IME undetermined string
	WORD	_fHangulToHanja			:1;		// TRUE during Hangul to Hanja conversion
	WORD	_fOvertypeMode			:1;		// TRUE if overtype mode is on. 
	WORD	_fMSIME					:1;		// TRUE if MSIME98 or later
	WORD	_fUsingAIMM				:1;		// TRUE if AIMM is activated
	WORD	_fUnicodeWindow			:1;		// TRUE if Unicode Window
	WORD	_fForceEnable			:1;		// TRUE if Force Enable on Focus
	WORD	_fForceActivate			:1;		// TRUE if Force Activate on Focus
	WORD	_fForceRemember			:1;		// TRUE if Force Remember
	WORD	_fIMEEnable				:1;		// TRUE if IME was enable before
	WORD	_fRE10Mode				:1;		// TRUE if running in RE1.0 Mode

	// Support for SETIMEOPTIONS:
	DWORD	_fIMEConversion;				// for Force Remember use
	DWORD	_fIMESentence;					// for Force Remember use
	HKL		_fIMEHKL;						// for Force Remember use

	long	_cpReconvertStart;				// use during reconversion
	long	_cpReconvertEnd;				// use during reconversion
	long	_lFEFlags;						// For FE setting (ES_NOIME, ES_SELFIME)	

	COMPCOLOR			_crComp[4];			// Support 1.0 mode composition color
	ITextDocument2		*_pTextDoc;	
	ITextSelection		*_pTextSel;	

private:
	ULONG				_crefs;

	ITextMsgFilter *	_pFilter;

	HIMC				_hIMCContext;

	// private methods 
	HRESULT	OnWMChar(
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres);

	HRESULT	OnWMIMEChar(
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres);

	HRESULT	OnIMEReconvert( 
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres,
		BOOL	fUnicode);

	BOOL CheckIMEChange(
		LPRECONVERTSTRING	lpRCS,
		long				cpParaStart, 
		long				cpParaEnd,
		long				cpMin,
		long				cpMax,
		BOOL				fUnicode);

	HRESULT	OnIMEQueryPos( 
		UINT *pmsg,
        WPARAM *pwparam,
		LPARAM *plparam,
		LRESULT *plres,
		BOOL	fUnicode);

	void CheckIMEType( HKL hKL );

	HRESULT InputFEChar( WCHAR wchFEChar );

	void	OnSetFocus();
	void	OnKillFocus();

	LRESULT	OnSetIMEOptions(WPARAM wparam, LPARAM lparam);
	LRESULT	OnGetIMEOptions();
	void	SetupIMEOptions();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_cfpf.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _CFPF.H	-- RichEdit CCharFormat and CParaFormat Classes |
 *
 *	These classes are derived from the RichEdit 1.0 CHARFORMAT and PARAFORMAT
 *	structures and are the RichEdit 2.0 internal versions of these structures.
 *	Member functions (like Copy()) that use external (API) CHARFORMATs and
 *	PARAFORMATs need to check the <p cbSize> value to see what members are
 *	defined.  Default values that yield RichEdit 1.0 behavior should be stored
 *	for RichEdit 1.0 format structures, e.g., so that the renderer doesn't do
 *	anomalous things with random RichEdit 2.0 format values.  Generally the
 *	appropriate default value is 0.
 *
 *	All character and paragraph format measurements are in twips.  Undefined
 *	mask and effect bits are reserved and must be 0 to be compatible with
 *	future versions.
 *
 *	Effects that appear with an asterisk (*) are stored, but won't be
 *	displayed by RichEdit 2.0.  They are place holders for TOM and/or Word
 *	compatibility.
 *
 *	Note: these structures are much bigger than they need to be for internal
 *	use especially if we use SHORTs instead of LONGs for dimensions and
 *	the tab and font info are accessed via ptrs.  Nevertheless, in view of our
 *	tight delivery schedule, RichEdit 2.0 uses the classes below.
 *
 *	History:
 *		9/1995	-- MurrayS: Created
 *		11/1995 -- MurrayS: Extended to full Word97 FormatFont/Format/Para
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _CFPF_H
#define _CFPF_H

#define	TABS

SHORT	Get16BitTwips(LONG dy);
LONG	GetUsableFontHeight(LONG ySrcHeight, LONG lPointChange);
BOOL	IsValidCharFormatW(const CHARFORMATW *	pCF);
BOOL	IsValidCharFormatA(const CHARFORMATA *	pCFA);
BOOL	IsValidParaFormat (const PARAFORMAT *	pPF);

// CParaFormat Style enums and defines (maybe move to richedit.h?)
enum STYLES
{
	STYLE_NORMAL	= -1,
	STYLE_HEADING_1	= -2,
	STYLE_HEADING_9	= -10
};

#define	NHSTYLES				9			// # of heading styles
#define	STYLE_COMMAND			0x8000
#define TWIPS_PER_POINT			20

#define IsHeadingStyle(Style)	(Style <= STYLE_HEADING_1 && \
								 Style >= STYLE_HEADING_9)
#define IsKnownStyle(Style)		(IsHeadingStyle(Style) || Style == STYLE_NORMAL)
#define IsStyleCommand(Style)	((Style & 0xFF00) == STYLE_COMMAND)

#define CCHMAXNUMTOSTR			13			// Enuf for 4 billion + parens + null term

typedef struct _styleformat
{
	BYTE	bEffects;
	BYTE	bHeight;
} STYLEFORMAT;

/*
 *	Tab Structure Template
 *
 *	To help keep the size of the tab array small, we use the two high nibbles
 *	of the tab LONG entries in rgxTabs[] to give the tab type and tab leader
 *	(style) values.  The measurer and renderer need to ignore (or implement)
 *	these nibbles.  We also need to be sure that the compiler does something
 *	rational with this idea...
 */

typedef struct tagTab
{
	DWORD	tbPos		: 24;	// 24-bit unsigned tab displacement
	DWORD	tbAlign		: 4;	// 4-bit tab type  (see enum PFTABTYPE)
	DWORD	tbLeader	: 4;	// 4-bit tab style (see enum PFTABSTYLE)
} TABTEMPLATE;

enum PFTABTYPE					// Same as tomAlignLeft, tomAlignCenter,
{								//  tomAlignRight, tomAlignDecimal, tomAlignBar
	PFT_LEFT = 0,				// ordinary tab
	PFT_CENTER,					// center tab
	PFT_RIGHT,					// right-justified tab
	PFT_DECIMAL,				// decimal tab
	PFT_BAR						// Word bar tab (vertical bar)
};

enum PFTABSTYLE					// Same as tomSpaces, tomDots, tomDashes,
{								//  tomLines
	PFTL_NONE = 0,				// no leader
	PFTL_DOTS,					// dotted
	PFTL_DASH,					// dashed
	PFTL_UNDERLINE,				// underlined
	PFTL_THICK,					// thick line
	PFTL_EQUAL					// double line
};

#define PFT_DEFAULT		0xff000000

// Effect flags beyond CHARFORMAT2. Go in high word of CCharFormat::_dwEffects
// which aren't used in CHARFORMAT2 (except for CFE_AUTOCOLOR: 0x40000000,
// CFE_AUTOBACKCOLOR: 0x04000000, CFE_SUBSCRIPT: 0x00010000, and
// CFE_SUPERSCRIPT: 0x00020000), since they overlap	with noneffect parms.
// Use corresponding high-word bits in dwMask2 to access.  Be careful not
// to define new effects that conflict with CFE_AUTOCOLOR, CFE_AUTOBACKCOLOR,
// CFE_SUBSCRIPT, or CFE_SUPERSCRIPT.

//		CFE_SUBSCRIPT		0x00010000			// Defined in richedit.h
//		CFE_SUPERSCRIPT		0x00020000			// Defined in richedit.h
#define CFM2_RUNISDBCS		0x00040000			// Says run is DBCS put 
#define CFE_RUNISDBCS		CFM2_RUNISDBCS		//  into Unicode buffer

#define CFM2_FACENAMEISDBCS	0x00080000			// Says szFaceName is DBCS 
#define CFE_FACENAMEISDBCS	CFM2_FACENAMEISDBCS	//  put into Unicode buffer

#define CFM2_TRUETYPEONLY	0x00100000			// Says that font matching
#define CFE_TRUETYPEONLY	CFM2_TRUETYPEONLY	//  CF should be TrueType

#define	CFM2_DELETED		0x00200000			// Says text was deleted
#define	CFE_DELETED			CFM2_DELETED		//  (roundtrips \deleted)

//		CFE_AUTOBACKCOLOR	0x04000000			// Defined in richedit.h
//		CFE_AUTOCOLOR		0x40000000			// Defined in richedit.h

#define CFM2_CHARFORMAT		0x00008000			// Noneffect mask flags
#define CFM2_USABLEFONT 	0x00004000			// EM_SETFONTSIZE functionality
#define CFM2_SCRIPT			0x00002000			// Uniscribe's script ID
#define	CFM2_NOCHARSETCHECK	0x00001000			// Suppress CharSet check
#define CFM2_HOLDITEMIZE	0x00000800			// Hold off Itemization
#define CFM2_ADJUSTFONTSIZE	0x00000400			// Font size adjustment (SAMECHARSET case only)
#define CFM2_UIFONT			0x00000200			// UI Font (SAMECHARSET case only)
#define CFM2_MATCHFONT		0x00000100			// Match font to charset

/*
 *	CCharFormat
 *
 *	@class
 *		Collects character format methods along with data members
 *		corresponding to CHARFORMAT2.  Only 10 DWORDs are used, whereas
 *		CHARFORMAT2 has 30.  Some bits in the high word of _dwEffects
 *		are used for additional effects, since only CFE_AUTOCOLOR,
 *		CFE_AUTOBACKCOLOR, CFE_SUBSCRIPT, and CFE_SUPERSCRIPT are used
 *		by CHARFORMAT2 (the associated mask bits for the others are used
 *		for noneffect parameters, such as yHeight).
 *
 *	@devnote
 *		Could add extra data for round tripping more RTF info. This data
 *		wouldn't be exposed at the API level (other than via RTF).
 *		The order below is optimized for transfer to CHARFORMAT and for
 *		early out on font lookup, i.e., the most common 2 DWORDs are the
 *		first 2.
 */

class CCharFormat
{
public:
	DWORD		_dwEffects;			// CFE_xxx effects
	BYTE		_bCharSet;			// CharSet
	BYTE		_bPitchAndFamily;	// Pitch and Family
	SHORT		_iFont;				// Index into FONTNAME table
	SHORT		_yHeight;			// Font height
	SHORT		_yOffset;			// Vertical offset from baseline
	COLORREF	_crTextColor;		// Foreground color

	WORD		_wWeight;			// Font weight (LOGFONT value)
	SHORT		_sSpacing;			// Amount to space between letters
	COLORREF	_crBackColor;		// Background color
	LCID		_lcid;				// Locale ID
	SHORT		_sStyle;			// Style handle
	WORD		_wKerning;			// Twip size above which to kern char pair
	BYTE		_bUnderlineType;	// Underline type
	BYTE		_bAnimation;		// Animated text like marching ants 
	BYTE		_bRevAuthor;		// Revision author index
	BYTE		_bReserved;			// Need to 0 this before storing in array
	WORD		_wScript;			// Uniscribe's script ID
	WORD		_wCodePageSave;		// Previous codepage for SYMBOL_CHARSET

	CCharFormat() {}
													//@cmember Apply *<p pCF>
	HRESULT	Apply (const CCharFormat *pCF,			//  to this CCharFormat
				   DWORD dwMask, DWORD dwMask2);
	void	ApplyDefaultStyle (LONG Style);

	BOOL	Compare	(const CCharFormat *pCF) const;	//@cmember Compare this CF
													//  to *<p pCF>
	DWORD	Delta (CCharFormat *pCF,				//@cmember Get difference
				   BOOL fCHARFORMAT) const;			//  mask between this and
													//  *<p pCF>
	BOOL	fSetStyle(DWORD dwMask, DWORD dwMask2) const;
	void	Get (CHARFORMAT2 *pCF, UINT CodePage) const;//@cmember Copies this to
													//	CHARFORMAT pCF
	HRESULT	InitDefault (HFONT hfont);				//@cmember Initialize using
													//  font info from <p hfont>
	void	Set(const CHARFORMAT2 *pCF, UINT CodePage);//@cmember Copy *<p pCF> 
													//  to this CF
};

// NB: don't define the following bit some other way in richedit.h unless you
// implement some other way to say that only PARAFORMAT parms are specified
#define PFM_PARAFORMAT	0x20000000					// Only PARAFORMAT parms used

/*
 *	CParaFormat
 *
 *	@class
 *		Collects related paragraph formatting methods and data
 *
 *	@devnote
 *		Could add extra data for round tripping more RTF and TOM info
 */
class CParaFormat
{
public:
	WORD	_wNumbering;
	WORD	_wEffects;
	LONG	_dxStartIndent;
	LONG	_dxRightIndent;
	LONG	_dxOffset;
	BYTE	_bAlignment;
	BYTE	_bTabCount;
	SHORT	_iTabs;					// Tabs index in CTabs cache
 	LONG	_dySpaceBefore;			// Vertical spacing before para
	LONG	_dySpaceAfter;			// Vertical spacing after para
	LONG	_dyLineSpacing;			// Line spacing depending on Rule	
	SHORT	_sStyle;				// Style handle						
	BYTE	_bLineSpacingRule;		// Rule for line spacing (see tom.doc)
	BYTE	_bOutlineLevel;			// Outline Level					
	WORD	_wShadingWeight;		// Shading in hundredths of a per cent
	WORD	_wShadingStyle;			// Byte 0: style, nib 2: cfpat, 3: cbpat
	WORD	_wNumberingStart;		// Starting value for numbering		
	WORD	_wNumberingStyle;		// Alignment, Roman/Arabic, (), ), ., etc.
	WORD	_wNumberingTab;			// Space bet 1st indent and 1st-line text
	WORD	_wBorderSpace;			// Border-text spaces (nbl/bdr in pts)
	WORD	_wBorderWidth;			// Pen widths (nbl/bdr in half twips)	
	WORD	_wBorders;				// Border styles (nibble/border)	
	DWORD	_dwBorderColor;			// Colors/attribs

	CParaFormat() {}
													//@cmember Add tab at
	HRESULT	AddTab (LONG tabPos, LONG tabType,		// position <p tabPos>
					LONG tabStyle, BOOL fInTable,
					LONG *prgxTabs);
	HRESULT	Apply(const CParaFormat *pPF, DWORD dwMask);//@cmember Apply *<p pPF>
													//  to this CParaFormat
	void	ApplyDefaultStyle (LONG Style);
	HRESULT	DeleteTab(LONG tabPos, LONG *prgxTabs);	//@cmember Delete tab at
													//  <p tabPos>
	DWORD	Delta (CParaFormat *pPF,				//@cmember Set difference
				   BOOL fPARAFORMAT) const;			//  mask between this and
													//  *<p pPF>
	BOOL	fSetStyle(DWORD dwMask) const;
	void	Get (PARAFORMAT2 *pPF2) const;			//@cmember Copy this PF to
													//  *<p pPF>
	char	GetOutlineLevel(){return _bOutlineLevel;}
													//@cmember Get tab position
	HRESULT	GetTab (long iTab, long *pdxptab,		// type, and style
					long *ptbt, long *pstyle,
					const LONG *prgxTabs) const;
	
	const LONG *GetTabs () const;					//@cmember Get ptr to tab array
	BOOL	HandleStyle(LONG Mode);					//@cmember Handle sStyle
													//@cmember Initialize this
	HRESULT	InitDefault (WORD wDefEffects);			//  PF to default values

	BOOL	IsRtlPara() const		{return _wEffects & PFE_RTLPARA;}
	BOOL	InTable() const			{return (_wEffects & PFE_TABLE) != 0;}
	BOOL	IsListNumbered() const	{return IN_RANGE(tomListNumberAsArabic,
												 _wNumbering,
												 tomListNumberAsSequence);}
	BOOL	IsNumberSuppressed() const
					{return (_wNumberingStyle & 0xF00) == PFNS_NONUMBER;}

	LONG	NumToStr(TCHAR *pch, LONG n, DWORD grf = 0) const;
													//@cmember Copy *<p pPF>
	void	Set (const PARAFORMAT2 *pPF2);			//  to this PF
	LONG	UpdateNumber (LONG n, const CParaFormat *pPF) const;

#ifdef DEBUG

	void	ValidateTabs();

#endif // DEBUG
};													 

#define fRtfWrite	 0x1
#define fIndicDigits 0x2

#define	GetTabPos(tab)		((tab) & 0xffffff)
#define	GetTabAlign(tab)	(((tab) >> 24) & 0xf)
#define	GetTabLdr(tab)		((tab) >> 28)

/*
 *	CTabs
 *
 *	@class
 *		CFixArray element for tab and cell arrays
 */
class CTabs
{
public:
	LONG _cTab;					// Count of tabs
	LONG *_prgxTabs;			// Ptr to tab array
};

#endif

/*	FUTURE: Possible Table Storage Layout:
 *
 *	A table could be stored as a sequence of paragraphs with special
 *	characteristics. Each table row starts with a table-row paragraph whose
 *	properties identify the row properties: alignment, StartIndent, line
 *	spacing, line spacing rule, PFE_KEEP and PFE_RTLPARA bits, and border
 *	info, which all work the same way for the row that they work for an
 *	ordinary paragraph.  The offset	field gives the half-gap space between
 *	cells in the row.  A table-row paragraph is identified by the PFM_TABLE
 *	mask field equal to PFE_ROWSTART.
 */


BOOL IsValidTwip(LONG dl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_coleobj.h ===
/*
 *	@doc	INTERNAL
 *
 *	@module	_COLEOBJ.H		The OLE Object management class | 
 *
 *	Author:	alexgo 10/24/95
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef __COLEOBJ_H__
#define __COLEOBJ_H__

#include "_notmgr.h"

#ifdef LINESERVICES
extern "C" {
#include "plsdnode.h"
}
#endif

class CDisplay;
class CDevDesc;
class CTxtEdit;
class IUndoBuilder;

/* 
 *	COleObject
 *
 *	@class	This class manages an individual OLE object embedding.
 *
 */

class COleObject :  public IOleClientSite, public IOleInPlaceSite, 
					public IAdviseSink, public CSafeRefCount, public ITxNotify
{
//@access Public methods
public:
	//
	// IUnknown methods
	//

	STDMETHOD(QueryInterface)(REFIID riid, void **pv);
	STDMETHOD_(ULONG, AddRef)(void);
	STDMETHOD_(ULONG, Release)(void);
	
	//
	// IOleClientSite methods
	//
	
	STDMETHOD(SaveObject)(void);
	STDMETHOD(GetMoniker)(DWORD dwAssign, DWORD dwWhichMoniker,
							IMoniker **ppmk);
	STDMETHOD(GetContainer)(IOleContainer **ppContainer);
	STDMETHOD(ShowObject)(void);
	STDMETHOD(OnShowWindow)(BOOL fShow);
	STDMETHOD(RequestNewObjectLayout)(void);

	//
	//	IOleInPlaceSite methods
	//
	STDMETHOD(GetWindow)(HWND *phwnd);
	STDMETHOD(ContextSensitiveHelp)(BOOL fEnterMode);
	STDMETHOD(CanInPlaceActivate)(void);
	STDMETHOD(OnInPlaceActivate)(void);
	STDMETHOD(OnUIActivate)(void);
	STDMETHOD(GetWindowContext)(IOleInPlaceFrame **ppFrame,
							IOleInPlaceUIWindow **ppDoc, LPRECT lprcPosRect,
							LPRECT lprcClipRect, 
							LPOLEINPLACEFRAMEINFO lpFrameInfo);
	STDMETHOD(Scroll)(SIZE scrollExtant);
	STDMETHOD(OnUIDeactivate)(BOOL fUndoable);
	STDMETHOD(OnInPlaceDeactivate)(void);
	STDMETHOD(DiscardUndoState)(void);
	STDMETHOD(DeactivateAndUndo)(void);
	STDMETHOD(OnPosRectChange)(LPCRECT lprcPosRect);

	//
	// IAdviseSink methods
	//

	STDMETHOD_(void, OnDataChange)(FORMATETC *pfetc, STGMEDIUM *pmedium);
	STDMETHOD_(void, OnViewChange)(DWORD dwAspect, LONG lindex);
	STDMETHOD_(void, OnRename)(IMoniker *pmk);
	STDMETHOD_(void, OnSave)(void);
	STDMETHOD_(void, OnClose)(void);

	//
	//	ITxNotify methods
	//
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax);
    virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax);
	virtual void	Zombie();

	//
	//	internal public methods
	//

			COleObject(CTxtEdit *ped);	//@cmember Constructor
	LONG	GetCp()		{return _cp;}	//@cmember Get cp for this object
	CTxtEdit *GetPed()	{return _ped;}	//@cmember Get ped for this object
										//@cmember Fill out the REOBJECT struct
	HRESULT	GetObjectData(REOBJECT *preobj, DWORD dwFlags);
	BOOL	IsLink();					//@cmember returns TRUE if the object
										// is a link object.
										//@cmember Initialize from the given
										// object data
	HRESULT InitFromREOBJECT(LONG cp, REOBJECT *preobj);
										//@cmember Measures the object (no outgoing calls)
	void MeasureObj(long dypInch, long dxpInch, LONG & xWidth, LONG & yAscent, LONG & yDescent, SHORT yDescentFont);
										//@cmember Draws the object
	void	DrawObj(const CDisplay *pdp, long dypInch, long dxpInch, HDC hdc, BOOL fMetafile, POINT *ppt, RECT *prcRender,
					LONG yBaselineLine, LONG yDescentMaxCur);
										//@cmember Handle the object being
										// deleted from the backing store
	void	Delete(IUndoBuilder *publdr);
	void	Restore();					//@cmember restore an object into
										// the backing store
										//@cmember Force a close on the
										// object
	void	Close(DWORD dwSaveOption);
										//@cmember Zombie the object.
    void    MakeZombie(void);
										//@cmember Activate the object
	BOOL	ActivateObj(UINT uiMsg,	WPARAM wParam, LPARAM lParam);
	HRESULT	DeActivateObj(void);		//@cmember Aeactivate the object
										//@cmember Set individual selection
										//state of object

	RECT *	GetPosRect()				//@cmember return the position rect
				{ return &_rcPos; }

	void ResetPosRect(LONG *pAdjust = NULL);

	void FetchObjectExtents(void);//@cmember Gets the size of the object
									//@cmember return REO_SELECTED state
	BOOL	GetREOSELECTED(void) {return (_pi.dwFlags & REO_SELECTED);}
										//@cmember set REO_SELECTED state
	void	SetREOSELECTED(BOOL fSelect);
								//@cmember checks for hits on frame handles
	LPTSTR	CheckForHandleHit(const POINT &pt);
								//@cmember handle object resize
	BOOL    HandleResize(const POINT &pt);
								//@cmember sets object size
	void    Resize(const RECT &rcNew);
								//@cmember update _sizel
	void	ResetSizel(const SIZEL &sizel)
						{_sizel = sizel;}
								//@cmember called when object position changes
	void    OnReposition( LONG dx, LONG dy );
								//@cmember gets objects IUnknown
	IUnknown *	GetIUnknown(void) {return _punkobj;}
								//@cmember converts to the specified class
	HRESULT	Convert(REFCLSID rclsidNew, LPCSTR lpstrUserTypeNew);
								//@cmember activate as the specified class
	HRESULT	ActivateAs(REFCLSID rclsid, REFCLSID rclsidAs);
								//@cmember set aspect to use
	void	SetDvaspect(DWORD dvaspect);
								//@cmember get current aspect
	DWORD	GetDvaspect()
				{ return _pi.dvaspect; }
								//@cmember see IPersistStore::HandsOffStorage
	void	HandsOffStorage(void);
								//@cmember see IPersistStore::SaveCompleted
	void	SaveCompleted(LPSTORAGE lpstg);
								//@cmember set REO_LINKAVAILABLE flag
	HRESULT SetLinkAvailable(BOOL fAvailable);
								//@cmember Used for textize support
	LONG	WriteTextInfoToEditStream(EDITSTREAM *pes);
								//@cmember Scroll this object if appropriate
	void	ScrollObject(LONG dx, LONG dy, LPCRECT prcScroll);

								//@cmember guard the position rectangle
								// from bad updates
	void	EnableGuardPosRect()	{_fGuardPosRect = TRUE;}
								//@cmember clear the guard bit
	void	DisableGuardPosRect()	{_fGuardPosRect = FALSE;}
								//@cmember set the _hdata member
	void    SetHdata(HGLOBAL hg)	{_hdata = hg;}
								//@cmember get the _hdata member

	void	GetSizel(SIZEL &sizel)	{sizel = _sizel;}
								//&cmember gets the _sizel member

	DWORD	GetFlags()	{return  _pi.dwFlags;}
								//&cmember gets the _sizel member
	DWORD	GetUser()	{return  _pi.dwUser;}
								//&cmember gets the _sizel member
	DWORD	GetAspect()	{return  _pi.dvaspect;}
								//&cmember gets the _sizel member

	// For internal use without reentering undo system.
	STDMETHOD(SafeSaveObject)(void);

	HGLOBAL GetHdata()				{return _hdata;}
	struct ImageInfo
	{
		LONG	xScale, yScale;		// @field scaling percentage along axes
		SHORT	xExtGoal, yExtGoal;	// @field desired dimensions in twips for pictures
		SHORT	cBytesPerLine;		// @field # bytes per raster line, if bitmap
	};
								//@cmember set the _pimageinfo member
	void    SetImageInfo(struct ImageInfo *pim)	{_pimageinfo = pim;}
								//@cmember get the _pimageinfo member
	ImageInfo *GetImageInfo()				{return _pimageinfo;}

#ifdef DEBUG
	void    DbgDump(DWORD id);
#endif
	BOOL	GetViewChanged()	{return _fViewChange;}
	void	ResetViewChanged()	{_fViewChange = FALSE;}

//@access Private methods and data
private:
	virtual ~COleObject();		//@cmember Destructor

	void SavePrivateState(void);//@cmember Saves private information
	HRESULT ConnectObject(void);//@cmember setup advises, etc.
	void DisconnectObject(void);//@cmember tear down advises, etc.
	void CleanupState(void);	//@cmember cleans up our member data, etc.
								//@cmember draws frame around object
	void DrawFrame(const CDisplay *pdp, HDC hdc, RECT* prc);
								//@cmember helper to draw frame handles
	void DrawHandle(HDC hdc, int x, int y);
								//@cmember helper to check for hit on a handle
	void CreateDib(HDC hdc);
								//@cmember helper to create DIB for WinCE bitmaps
	void DrawDib(HDC hdc, RECT *prc);
								//@cmember helper to draw WinCE bitmaps
	BOOL InHandle(int x, int y, const POINT &pt);
								//@cmember to restablish rectangle position
	enum { SE_NOTACTIVATING, SE_ACTIVATING };  // used by SetExtent to indicate
												// the context of the SetExtent call
								//@cmember Attempts to set object extents
	HRESULT SetExtent(int iActivating);

	CTxtEdit *		_ped;		//@cmember edit context for this object
	IUnknown *		_punkobj;	//@cmember pointer to the objects IUnknown.
	IStorage *		_pstg;		//@cmember storage for the object
	RECT	 		_rcPos	;	//@cmember position rect in client coords
	SIZEL			_sizel;		//@cmember cached "real" size of the object
	LONG			_cp;		//@cmember position of this object
	DWORD			_dwConn;	//@cmember advise connection cookie
	HGLOBAL			_hdata;
	HBITMAP			_hdib;
	ImageInfo *		_pimageinfo;

	struct PersistedInfo
	{
		DWORD	dwFlags;		//@cmember see richole.h
		DWORD	dwUser;			//@cmember user defined
		DWORD	dvaspect;		//@cmember from the DVASPECT enumeration
	};

	PersistedInfo	_pi;

	SHORT	_dxyFrame;			//@cmember Object frame width
	DWORD	_fInPlaceActive:1;	//@cmember inplace active?
	DWORD	_fInUndo:1;			//@cmember in the undo stack?
	DWORD	_fIsWordArt2:1;		//@cmember Is this object a WordArt 2.0
								// object? (need to do hacks for it)
	DWORD 	_fIsPaintBrush:1;	//@cmember Is this object a PaintBrush
								// object? (need to do hacks for it)
	DWORD	_fPBUseLocalSizel:1;	
								//@cmember Signals that SetExtent
								// for a PaintBrush object failed and that
								// _sizel is an accurate indication of object size
	DWORD   _fDraw:1;			//@cmember Should object be drawn?
	DWORD	_fSetExtent:1;		//@cmember Does SetExtent need to be called
								   //when activating.
	DWORD	_fGuardPosRect:1;	//@cmember Guards position rect from updating
	DWORD	_fDeactivateCalled:1;//@cmember Whether deactivate has been called.
	DWORD	_fAspectChanged:1;	//@cmember Forces FetchObjectExtents to call through when aspect changes
	DWORD	_fViewChange:1;		//@cmember flag to indicate size of object changed

	DWORD	_fActivateCalled:1;	//@member Are we in the middle of the activation sequence?

#ifdef LINESERVICES
public:
	PLSDNODE _plsdnTop;			//@cmember Ptr to LS display node
#endif
};

#endif // __COLEOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_debug.h ===
/*
 *	_DEBUG.H
 *	
 *	Purpose:
 *		RICHEDIT debugging support--commented out in ship builds
 *
 *	History: <nl>
 *		7/29/98	KeithCu Wrote it stealing much from Rich Arneson's code
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _DEBUG_H
#define _DEBUG_H

#define DllExport __declspec(dllexport)

#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)

#define	ASSERTDATA		static char _szFile[] = __FILE__;

BOOL WINAPI DebugMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved);

#else	// DEBUG

#define	ASSERTDATA

#define DebugMain(hDll, dwReason, lpReserved)

#endif	// DEBUG, else


#if !defined(MACPORT) && (defined(DEBUG) || defined(_RELEASE_ASSERTS_))

//This is the buffer length used for building messages
#define MAXDEBUGSTRLEN (MAX_PATH + MAX_PATH)

#ifndef _RELEASE_ASSERTS_
//The following constants are used to specify and interpret
//packed values in the DWORD flags parameter passed to TraceMsg.
//Each of these is held in a 4-bit field in the DWORD.

//Subsystem field values
#define TRCSUBSYSNONE   0x0
#define TRCSUBSYSDISP   0x1
#define TRCSUBSYSWRAP   0x2
#define TRCSUBSYSEDIT   0x3
#define TRCSUBSYSTS     0x4
#define TRCSUBSYSTOM    0x5
#define TRCSUBSYSOLE    0x6
#define TRCSUBSYSBACK   0x7
#define TRCSUBSYSSEL    0x8
#define TRCSUBSYSHOST   0x9
#define TRCSUBSYSDTE    0xa
#define TRCSUBSYSUNDO   0xb
#define TRCSUBSYSRANG   0xc
#define TRCSUBSYSUTIL   0xd
#define TRCSUBSYSNOTM   0xe
#define TRCSUBSYSRTFR   0xf
#define TRCSUBSYSRTFW   0x10
#define TRCSUBSYSPRT    0x11
#define TRCSUBSYSFE     0x12
#define TRCSUBSYSFONT	0x13

//Severity field values
#define TRCSEVNONE      0x0
#define TRCSEVWARN      0x1
#define TRCSEVERR       0x2
#define TRCSEVASSERT    0x3
#define TRCSEVINFO      0x4
#define TRCSEVMEM       0x5

//Scope field values
#define TRCSCOPENONE    0x0
#define TRCSCOPEEXTERN  0x1
#define TRCSCOPEINTERN  0x2

//Data field values
#define TRCDATANONE     0x0
#define TRCDATAHRESULT  0x1
#define TRCDATASTRING   0x2
#define TRCDATAPARAM    0x3
#define TRCDATADEFAULT  0x4

#endif //!_RELEASE_ASSERTS_

//Debug option flags.  See the macros in this header for setting and testing
//these option flags.
#define OPTUSEDEFAULTS  0x00000001  //Use defaults from win.ini 
                                    //(used only with InitDebugServices).
#define OPTLOGGINGON    0x00000008  //Logging of trace output
#define OPTVERBOSEON    0x00000010  //Subsys, Scope & PID/TID
#define OPTINFOON       0x00000020  //Informational messages
#define OPTTRACEON      0x00000040  //All function tracing on
#define OPTTRACEEXT     0x00000080  //Function tracing only for external functions
#define OPTMEMORYON     0x00000100  //Memory alloc/free tracing on

//no tracing for release with asserts
#ifndef _RELEASE_ASSERTS_
//The following options allow tracing to be enabled for one or more
//specific subsystems.  If OPTTRACEON is set, these will have no effect.
//if OPTTRACEEXT is set, they will enable tracing for all functions in
//the designated subsystem in addition to external functions.
//The SETOPT and ISOPTSET macros should be used for setting and checking
//these options.  INITDEBUGSERVICES can also be used.
#define OPTTRACEDISP    0x00001000  //Function tracing for Display subsystem
#define OPTTRACEWRAP    0x00002000  //Function tracing for Wrapper subsystem
#define OPTTRACEEDIT    0x00004000  //Function tracing for Edit subsystem
#define OPTTRACETS      0x00008000  //Function tracing for TextServices subsystem
#define OPTTRACETOM     0x00010000  //Function tracing for TOM subsystem
#define OPTTRACEOLE     0x00020000  //Function tracing for OLE support subsystem
#define OPTTRACEBACK    0x00040000  //Function tracing for Backing Store subsystem
#define OPTTRACESEL     0x00080000  //Function tracing for Selection subsystem
#define OPTTRACEHOST    0x00100000  //Function tracing for WinHost subsystem
#define OPTTRACEDTE     0x00200000  //Function tracing for DataXfer subsystem
#define OPTTRACEUNDO    0x00400000  //Function tracing for Muli-undo subsystem
#define OPTTRACERANG    0x00800000  //Function tracing for Range subsystem
#define OPTTRACEUTIL    0x01000000  //Function tracing for Utility subsystem
#define OPTTRACENOTM    0x02000000  //Function tracing for Notification Mgr subsystem
#define OPTTRACERTFR    0x04000000  //Function tracing for RTF reader subsystem
#define OPTTRACERTFW    0x08000000  //Function tracing for RTF writer subsystem
#define OPTTRACEPRT     0x10000000  //Function tracing for Printing subsystem
#define OPTTRACEFE      0x20000000  //Function tracing for Far East subsystem
#define OPTTRACEFONT    0x40000000  //Function tracing for Font Cache

//Union for handling tracing flags
//This union is used to decode the
//packed DWORD passed to TraceMsg.
typedef union
{
    struct
    {
        unsigned uData2         :4;
        unsigned uData1         :4;
        unsigned uScope         :4;
        unsigned uSeverity      :4;
        unsigned uSubSystem     :8;
        unsigned uUnused1       :4;
        unsigned uUnused2       :4;
    }       fields;
    DWORD   dw;
} TrcFlags;


//Exported classes and functions.
//Generally, these should not be used directly by the user.
//They should be used via the macros defined in this header.
//This helps to ensure that the parameter lists are well
//formed and keeps references to them from showing up in
//in non-debug builds.

//This class is used to implement the function Entry/Exit
//tracing. By declaring it on the stack at the beginning
//of a function, Entry and Exit messages are automatically
//generated by the constructor and destructor.
class CTrace
{
    public:
        CTrace(DWORD, DWORD, DWORD, LPSTR);
        ~CTrace();

    private:
        TrcFlags trcf;
        char szFileName[MAXDEBUGSTRLEN];
        char szFuncName[80];
};

extern DWORD dwDebugOptions;
extern void SetLogging(BOOL);
void Tracef(DWORD, LPSTR szFmt, ...);
void TraceError(LPSTR sz, LONG sc);

#endif //!_RELEASE_ASSERTS_


typedef BOOL (CALLBACK * PFNASSERTHOOK)(LPSTR, LPSTR, int*);
typedef BOOL (CALLBACK * PFNTRACEHOOK)(DWORD*, DWORD*, DWORD*, LPSTR, int*);
extern PFNTRACEHOOK pfnTrace;
extern PFNASSERTHOOK pfnAssert;
void AssertSzFn(LPSTR, LPSTR, int);
void TraceMsg(DWORD, DWORD, DWORD, LPSTR, int);
DllExport void WINAPI InitDebugServices(DWORD, PFNASSERTHOOK, PFNTRACEHOOK);


//Assert based on boolean f.
#define Assert(f)           AssertSz((f), NULL)

//Assert based on boolean f in debug, resolve to f in non-debug.
#define SideAssert(f)       AssertSz((f), NULL)

//Assert based on boolean f and use string sz in assert message.
#define AssertSz(f, sz)     (!(f) ? AssertSzFn(sz, __FILE__, __LINE__) : 0);

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETASSERTFN(pfn)      (pfnAssert = (pfn))    

//The following macros provide access to the debug services in this dll.
//Assert macros pop a dialog.  Trace macros output to debug output and
//logfile if enabled.

//Macro for InitDebugServices
#define INITDEBUGSERVICES(f, pfnA, pfnT) InitDebugServices(f, pfnA, pfnT)

//This is a utility macro for internal use.  The user should not need this.
#define MAKEFLAGS(ss, sv, sc, d1, d2) ((ss << 16) + (sv << 12) + (sc << 8)\
            + (d1 << 4) + (d2))

#ifndef _RELEASE_ASSERTS_
//Assert only on debug builds, not on _RELEASE_ASSERTS_ builds
//This is for asserts that contain debug only code
#ifndef AssertNr
#define AssertNr(f)         AssertSz((f), NULL)
#endif

#ifndef AssertNrSz
#define AssertNrSz(f, sz)     (!(f) ? AssertSzFn(sz, __FILE__, __LINE__) : 0);
#endif


//Macro for TraceError
#define TRACEERRSZSC(sz, sc) TraceError(sz, sc)

//Warning based on GetLastError or default message if no last error.
#define TRACEWARN           TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)
//Error based on GetLastError or default message if no last error.
#define TRACEERROR          TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATADEFAULT, TRCDATANONE),\
                                (DWORD)0, (DWORD)0, __FILE__, __LINE__)

//Warning based on HRESULT hr
#define TRACEWARNHR(hr)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)

//Test for a failure HR && warn
#define TESTANDTRACEHR(hr)	if( hr < 0 ) { TRACEWARNHR(hr); }

//Error based on HRESULT hr
#define TRACEERRORHR(hr)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATAHRESULT, TRCDATANONE),\
                                (DWORD)(hr), (DWORD)0, __FILE__, __LINE__)

//Warning using string sz
#define TRACEWARNSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__, __LINE__)

//Trace based on Assert, user passes file name and line
#define TRACEASSERT(szFile, iLine)     TraceMsg (MAKEFLAGS(TRCSUBSYSNONE,\
												TRCSEVASSERT, TRCSCOPENONE,\
												TRCDATANONE, TRCDATANONE),\
												(DWORD)0, (DWORD)0, szFile, iLine)

//Trace based on Assert, user passes file name and line
#define TRACEASSERTSZ(sz, szFile, iLine)     TraceMsg (MAKEFLAGS(TRCSUBSYSNONE,\
												TRCSEVASSERT, TRCSCOPENONE,\
												TRCDATASTRING, TRCDATANONE),\
												(DWORD)(DWORD_PTR)sz, (DWORD)0, szFile, iLine)
//Error using string sz
#define TRACEERRORSZ(sz)    TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__, __LINE__)

//Error using string sz
#define TRACEINFOSZ(sz)     TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVINFO,\
                                TRCSCOPENONE, TRCDATASTRING, TRCDATANONE),\
                                (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__, __LINE__)

//Initiate tracing.  This declares an instance of the CTtrace class
//on the stack.  Subsystem (ss), Scope (sc), and the function name
//(sz) must be specifed.  ss and sc are specified using the macros
//defined in this header (i.e. - TRCSUBSYSTOM, TRCSCOPEEXTERN, etc.).
//sz can be a static string.
#define TRACEBEGIN(ss, sc, sz)  CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATANONE),\
                                    (DWORD)(DWORD_PTR)(sz), (DWORD)0, __FILE__)

//Same as TRACEBEGIN but it takes the additional param which is interpreted
//by TraceMsg as a Text Message request.
#define TRACEBEGINPARAM(ss, sc, sz, param) \
                                CTrace trc(MAKEFLAGS((ss), TRCSEVNONE,\
                                    (sc), TRCDATASTRING, TRCDATAPARAM),\
                                    (DWORD)(DWORD_PTR)(sz), (DWORD)(param), __FILE__)

//Set logging to on (f = TRUE) or off (f = FALSE)
#define SETLOGGING(f)       SetLogging(f)

//Set output of process & thread IDs to on (f = TRUE) or off (f = FALSE)
#define SETVERBOSE(f)       ((f) ? (dwDebugOptions |= OPTVERBOSEON) :\
                            (dwDebugOptions &= ~OPTVERBOSEON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETINFO(f)          ((f) ? (dwDebugOptions |= OPTINFOON) :\
                            (dwDebugOptions &= ~OPTINFOON))

//Set information messages to on (f = TRUE) or off (f = FALSE)
#define SETMEMORY(f)          ((f) ? (dwDebugOptions |= OPTMEMORYON) :\
                            (dwDebugOptions &= ~OPTMEMORYON))

//Set tracing for all functions to on (f = TRUE) or off (f = FALSE).
//If this is set to "on", external and subsystem level tracing
//has no effect since all function traces are enabled. If it is off,
//external and subsystem level tracing remain in whatever state they
//have been set to.
#define SETTRACING(f)       ((f) ? (dwDebugOptions |= OPTTRACEON) :\
                            (dwDebugOptions &= ~OPTTRACEON))

//Set tracing for EXTERNAL scope calls only to on (f = TRUE)
//or off (f = FALSE).  This is only effective if OPTTRACEON has not
//been set.
#define SETTRACEEXT(f)      ((f) ? (dwDebugOptions |= OPTTRACEEXT) :\
                            (dwDebugOptions &= ~OPTTRACEEXT))

//This macro turns all function tracing off.
#define SETALLTRACEOFF      (dwDebugOptions &= ~(OPTTRACEEXT | OPTTRACEON | 0xfffff000))

//This macro sets a given option or options (if they are or'ed together)
//to on (f = TRUE), or off (f = FALSE).  It cannot be used to set logging.
#define SETOPT(opt, f)      ((f) ? (dwDebugOptions |= (opt)) :\
                            (dwDebugOptions &= (~(opt))))
                             
//This macro determines the state of a given option.
#define ISOPTSET(opt)       ((opt) & dwDebugOptions)

//Set an assert or trace hook function.  The function specified will be called
//before the default functionality executes. Pointers to all parameters are passed
//to the hook to allow it to modify them.  If the hook function returns false,
//default functionality is terminated.  If the hook function returns true, default
//functionality continues with the potentially modified parameters.  pfn can
//be NULL (default functionality only).
#define SETTRACEFN(pfn)      (pfnTrace = (pfn))    

//The following option tests are explicitly defined for convenience.
#define fLogging            (OPTLOGGINGON & dwDebugOptions)
#define fVerbose            (OPTVERBOSEON & dwDebugOptions)
#define fInfo               (OPTINFOON & dwDebugOptions)
#define fTrace              (OPTTRACEON & dwDebugOptions)
#define fTraceExt           (OPTTRACEEXT & dwDebugOptions)


#else //_RELEASE_ASSERTS_
//Functions not used by release build with asserts
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define Tracef	;/##/
#define TRACEERRSZSC(sz, sc)
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEASSERT(szFile, iLine)
#define TRACEASSERTSZ(sz, szFile, iLine)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETTRACEFN(pfn)

#define TraceError(_sz, _sc)  // MACPORT ADDED THIS - TraceError


#endif //_RELEASE_ASSERTS_

#else //DEBUG,_RELEASE_ASSERTS_

#define Tracef	;/##/
#define INITDEBUGSERVICES(f, pfnA, pfnT)
#define TRACEERRSZSC(sz, sc)
#ifndef Assert
#define Assert(f)
#endif
#ifndef SideAssert
#define SideAssert(f) (f)
#endif
#ifndef AssertSz
#define AssertSz(f, sz)
#endif
#ifndef AssertNr
#define AssertNr(f)
#endif
#ifndef AssertNrSz
#define AssertNrSz(f, sz)
#endif
#define TRACEWARN
#define TRACEERROR
#define TRACEWARNHR(hr)
#define TESTANDTRACEHR(hr)
#define TRACEERRORHR(hr)
#define TRACEWARNSZ(sz)
#define TRACEASSERT(szFile, iLine)
#define TRACEASSERTSZ(sz, szFile, iLine)
#define TRACEERRORSZ(sz)
#define TRACEINFOSZ(sz)
#define TRACEBEGIN(ss, sc, sz)
#define TRACEBEGINPARAM(ss, sc, sz, param)
#define SETLOGGING(f)
#define SETVERBOSE(f)
#define SETINFO(f)
#define SETMEMORY(f)
#define SETTRACING(f)
#define SETTRACEEXT(f)
#define SETALLTRACEOFF
#define SETOPT(opt, f)
#define ISOPTSET(opt)
#define SETASSERTFN(pfn)
#define SETTRACEFN(pfn)

#define AssertSzFn(sz, __FILE__, __LINE__)  // MACPORT ADDED THIS - Dbug32AssertSzFn
#define TraceError(_sz, _sc)  // MACPORT ADDED THIS - TraceError

#endif

#endif //DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_devdsc.h ===
/*
 *	_DEVDSC.H
 *	
 *	Purpose:
 *		CDevDesc (Device Descriptor) class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 */

#ifndef _DEVDSC_H
#define _DEVDSC_H


class CTxtEdit;

// device descriptor
class CDevDesc
{
	friend class CMeasurer;
protected:
	CTxtEdit * _ped;        // used to GetDC and ReleaseDC
	
	HDC 	_hdc;			// hdc for rendering device
	BOOL	_fMetafile;		// Is this device a metafile.

	SHORT	_dxpInch;		// device units per horizontal "inch"
	SHORT	_dypInch;		// device units per vertical "inch"

	HDC		GetScreenDC () const;
	void	ReleaseScreenDC (HDC hdc) const;

public:
	CDevDesc(CTxtEdit * ped)
	{
		_fMetafile = FALSE;
		_ped = ped;
		_dxpInch = 0;
		_hdc = NULL;
		_dypInch = 0;
	}

    // Test validity of device descriptor 
    // (whether SetDC has been properly called)
    BOOL    IsValid() const         {return _dxpInch != 0 && _dypInch != 0;}

	BOOL 	IsMetafile() const
	{
		if(!_hdc)
			return FALSE;

		return _fMetafile;
	}

	
	BOOL	SetDC(HDC hdc, LONG dxpInch = -1, LONG dypInch = -1);

	void	SetMetafileDC(
				HDC hdcMetafile, 
				LONG xMeasurePerInch,
				LONG yMeasurePerInch);

	void 	ResetDC() { SetDC(NULL); }

	//REVIEW (keithcu) GetScreenDC/ReleaseScreenDC needed?
	HDC	 	GetDC() const
	{
		if(_hdc)
			return _hdc;
		return GetScreenDC();
	}

	void	ReleaseDC(HDC hdc) const
	{
		if(!_hdc)
			ReleaseScreenDC(hdc);
	}

	// Methods for converting between pixels and himetric
	LONG 	HimetricXtoDX(LONG xHimetric) const { return W32->HimetricXtoDX(xHimetric, _dxpInch); }
	LONG 	HimetricYtoDY(LONG yHimetric) const { return W32->HimetricYtoDY(yHimetric, _dypInch); }
	LONG	DXtoHimetricX(LONG dx)  const { return W32->DXtoHimetricX(dx, _dxpInch); }
	LONG	DYtoHimetricY(LONG dy) const { return W32->DYtoHimetricY(dy, _dypInch); }

	LONG 	DXtoLX(LONG x) const;
	LONG 	DYtoLY(LONG y) const;
	void 	DPtoLP(POINT &ptDest, const POINT &ptSrc) const;
	void 	DRtoLR(RECT &rcDest, const RECT &rcSrc) const;
	
#ifdef DEBUG
	LONG	LXtoDX(LONG x) const;
	LONG	LYtoDY(LONG y) const;
#else
	LONG	LXtoDX(LONG x) const	{return ((x * _dxpInch) + LX_PER_INCH / 2) / LX_PER_INCH;}
	LONG	LYtoDY(LONG y) const	{return ((y * _dypInch) + LY_PER_INCH / 2) / LY_PER_INCH;}
#endif
	void 	LPtoDP(POINT &ptDest, const POINT &ptSrc) const;
	void 	LRtoDR(RECT &rcDest, const RECT &rcSrc) const;

	BOOL 	SameDevice(const CDevDesc *pdd) const
	{
		return (_dxpInch == pdd->_dxpInch) && (_dypInch == pdd->_dypInch)
			? TRUE : FALSE;
	}

	LONG	ConvertXToDev(LONG x, const CDevDesc *pdd) const
	{
		return MulDiv(x, _dxpInch, pdd->_dxpInch);
	}

	LONG	ConvertYToDev(LONG y, const CDevDesc *pdd) const
	{
		return MulDiv(y, _dypInch, pdd->_dxpInch);
	}

	// Assignment
	CDevDesc& 	operator = (const CDevDesc& dd)
	{
		_hdc = dd._hdc;
		_dxpInch = dd._dxpInch;
		_dypInch = dd._dypInch;
		return *this;
	}

	// Compares two device descriptors
	BOOL 	operator == (const CDevDesc& dd) const
	{
		return 	_hdc == dd._hdc;
	}

	BOOL 	operator != (const CDevDesc& dd) const
	{
		return !(*this == dd);
	}

	LONG	GetDxpInch() const
	{
		AssertSz(_dxpInch != 0, "CDevDesc::GetDxpInch_dxpInch is 0");
		return _dxpInch;
	}

	LONG	GetDypInch() const
	{
		AssertSz(_dypInch != 0, "CDevDesc::GetDypInch _dypInch is 0");
		return _dypInch;
	}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_devstk.h ===
/*
 *	_DEVSTK.H
 *	
 *	Purpose:
 *		CDevState - handle access to device descriptor
 *	
 *	Authors:
 *		Rick Sailor
 */

#ifndef _DEVSTK_H_
#define _DEVSTK_H_


class CTxtEdit;
class CDrawInfo;

// device descriptor
class CDevState
{
public:
						CDevState(CTxtEdit * ped);

						~CDevState();

    					BOOL    IsValid() const;

						BOOL 	IsMetafile() const;

						BOOL	SetDrawInfo(
									DWORD dwDrawAspect,
									LONG lindex,
									const DVTARGETDEVICE *_ptd,
									HDC hdcDraw,
									HDC hicTargetDev);

						BOOL	SetDC(HDC hdc);

	void 				ResetDrawInfo();

	HDC					GetTargetDD();

	HDC	 				GetRenderDD();

	void				ReleaseDC();

	BOOL				SameDrawAndTargetDevice();

	LONG				ConvertXToTarget(LONG xPixels);

	LONG				ConvertXToDraw(LONG xPixels);

	LONG				ConvertYToDraw(LONG yPixels);

protected:

	CTxtEdit * 			_ped;        // used to GetDC and ReleaseDC

	CDrawInfo *			_pdd;

	HDC					_hicMainTarget;
	
};

#ifndef DEBUG
#include	<_devstki.h>
#endif // DEBUG


#endif // _DEVSTK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_dfreeze.h ===
/*	@doc INTERNAL
 *
 *	@module _DFREEZE.H  Classes handle freezing the display |
 *	
 *	This module declares class used by logic to handle freezing the display
 *
 *	History: <nl>
 *		2/8/96	ricksa	Created
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _DFREEZE_H
#define _DFREEZE_H

/*
 *	CAccumDisplayChanges
 *	
 * 	@class	This class is used to accumulate of all update to the display so
 *			so that at a later time the display can ask to be updated to 
 *			reflect all the previous updates.
 */
class CAccumDisplayChanges
{
//@access Public Methods
public:
				CAccumDisplayChanges();		//@cmember Constructor

				~CAccumDisplayChanges();	//@cmember Destructor

	void		AddRef();					//@cmember Add a reference

	LONG		Release();					//@cmember Release a reference

	void		UpdateRecalcRegion(			//@cmember Update the region 
					LONG cp,				// for recalc
					LONG cchDel,
					LONG cchNew);

	void		GetUpdateRegion(			//@cmember Get the update 
					LONG *pcpStart,			// region
					LONG *pcchNew,
					LONG *pcchDel,
					BOOL *pfUpdateCaret = NULL,
					BOOL *pfScrollIntoView = NULL,
					BOOL *pfRedisplayOnThaw = NULL);

	void		SaveUpdateCaret(			//@cmember Save update
					BOOL fScrollIntoView);	// caret state

	void		SetNeedRedisplayOnThaw(BOOL fNeedRedisplay)
	{
		_fNeedRedisplay = fNeedRedisplay;
	}
//@access Private Data
private:

	LONG		_cRefs;						//@cmember Reference count

	LONG		_cpMin;						//@cmember Min cp of change w.r.t.
											// original text array

	LONG		_cpMax;						//@cmember Max cp of change w.r.t.
											// original text array

	LONG		_delta;						//@cmember net # of chars changed

	BOOL		_fUpdateCaret:1;			//@cmember Whether update
											// caret required

	BOOL		_fScrollIntoView:1;			//@cmember first parm to 

	BOOL		_fNeedRedisplay:1;			//@cmember redisplay entire control on thaw
};

/*
 *	CAccumDisplayChanges::CAccumDisplayChanges()
 *
 *	@mfunc
 *		Initialize object for accumulating display changes
 */
inline CAccumDisplayChanges::CAccumDisplayChanges() 
	: _cRefs(1), _cpMin(CP_INFINITE), _fUpdateCaret(FALSE)
{
	// Header does all the work
}

/*
 *	CAccumDisplayChanges::~CAccumDisplayChanges()
 *
 *	@mfunc
 *		Free object
 *
 *	@devnote:
 *		This only serves a purpose in debug mode
 *
 */
inline CAccumDisplayChanges::~CAccumDisplayChanges()
{
	// Nothing to clean up
}

/*
 *	CAccumDisplayChanges::~CAccumDisplayChanges()
 *
 *	@mfunc
 *		Add another reference to this object
 */
inline void CAccumDisplayChanges::AddRef()
{
	++_cRefs;
}

/*
 *	CAccumDisplayChanges::Release()
 *
 *	@mfunc
 *		Release a reference to this object
 *
 *	@rdesc
 *		0 - no more references
 *		~0 - there are still outstanding references
 *
 *	@devnote:
 *		If 0 is returned the information should be retrieved from
 *		this object and passed on to the display so that it can
 *		update itself.
 *
 */
inline LONG CAccumDisplayChanges::Release()
{
	// When the reference count is 0, it is time to update the display.
	return --_cRefs;	
}

/*
 *	CAccumDisplayChanges::SaveUpdateCaret()
 *
 *	@mfunc
 *		Save parameters for update caret
 */
inline void CAccumDisplayChanges::SaveUpdateCaret(
	BOOL fScrollIntoView)		//@parm First parm for UpdateCaret
{
	_fUpdateCaret = TRUE;

	if (!_fScrollIntoView)
		_fScrollIntoView = fScrollIntoView;
}

#endif // _DFREEZE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_devstki.h ===
INLINE	CDevDesc::CDevDesc(CTxtEdit * ped) : _ped(ped), _pdd(NULL)
{
	// Header does the work
}

INLINE BOOL CDevDesc::IsValid() const         
{
	return _pdd != NULL;
}

INLINE HDC CDevDesc::GetRenderDC()
{
	HDC hdc = NULL;

	if (NULL == _pdd)
	{
		// We don't already have on so try to get one. This is only valid when
		// we are inplace active.
		SetDrawInfo(
			DVA_ASPECT
			-1,
			NULL,
			NULL,
			hicTarget);
	}

	if (_pdd != NULL)
	{
		hdc = _pdd->GetDC();
	}

	return hdc;
}

INLINE HDC CDevDesc::GetTargetDC()
{
	if (_pdd != NULL)
	{
		return _pdd->GetTargetDC();
	}

	if (NULL != _hicMainTarget)
	{
		return _hicMainTarget;
	}

	return GetRenderDC();
}

INLINE void	CDevDesc::ResetDrawInfo()
{
	// We shouldn't reset 
	Assert
	CDrawInfo *pdd = _pdd;
	_pdd = _pdd->Pop();
	delete pdd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_disp.h ===
/*
 *  _DISP.H
 *  
 *  Purpose:
 *		DISP class
 *  
 *  Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _DISP_H
#define _DISP_H

#include "_devdsc.h"
#include "_line.h"
#include "_edit.h"

class CDisplay;
class CLed;
class CLinePtr;
class CTxtStory;
class CTxtEdit;
class CRchTxtPtr;
class CTxtRange;
class CTxtSelection;

#define INVALID_ZOOM_DENOMINATOR 0

// Auto scroll timing
#define cmsecScrollDelay	500
#define cmsecScrollInterval	50


class CDrawInfo;

// ============================  CLed  ====================================
// Line Edit Descriptor - describes impact of an edit on line breaks

class CLed
{
public:
	LONG _cpFirst;			// cp of first affected line
	LONG _iliFirst;			// index of first affected line
	LONG _yFirst;			// y offset of first affected line

	LONG _cpMatchOld;		// pre-edit cp of first matched line
	LONG _iliMatchOld;		// pre-edit index of first matched line
	LONG _yMatchOld;		// pre-edit y offset of first matched line

	LONG _cpMatchNew;		// post-edit cp of first matched line
	LONG _iliMatchNew;		// post-edit index of first matched line
	LONG _yMatchNew;		// post-edit y offset of bottom of first matched line
	LONG _yMatchNewTop;		// post-edit y offset of top of first matched line

public:
	CLed();
	
	void	SetMax(const CDisplay * const pdp);
};

inline CLed::CLed()
{
#ifdef DEBUG
	// We set this invalid so that we can assert on it in debug builds.
	_yMatchNewTop = -1;

#endif // DEBUG
}

// An enumeration describing the various display actions we can perform on the selection
enum SELDISPLAYACTION
{
	selSetHiLite,
	selSetNormal,
	selUpdateHiLite,
	selUpdateNormal
};

class CDispDim
{
public:
	CDispDim(){ZeroMemory(this, sizeof(*this));}
	LONG	dx;
	DWORD	lstflow;
};

// Forward declaration to prevent recursion of definitions
class CAccumDisplayChanges;

// ==========================  CDisplay  ====================================
// Display - keeps track of line breaks for a device.
// All measurements are in pixels on rendering device,
// EXCEPT xWidthMax and yHeightMax, which are in twips.

class CDisplay : public CDevDesc, public ITxNotify
{
	friend class CLinePtr;
	friend class CLed;

#ifdef DEBUG
public:
	BOOL Invariant ( void ) const;
private:
#endif

public:
	// Average char width of system font
	static INT GetXWidthSys() { return W32->GetXWidthSys(); }

	// Height of system font
	static INT GetYHeightSys() { return W32->GetYHeightSys(); }

private:
	static DWORD _dwTimeScrollNext; // time for next scroll step
	static DWORD _dwScrollLast;	// last scroll action
	
	CDrawInfo *	 _pdi;			// Draw info parameters

protected:
	CAccumDisplayChanges *_padc;	// Accumulated display changes if frozen

	DWORD	_fBgndRecalc		:1; // Background recalc is running
	DWORD	_fDeferUpdateScrollBar:1; // Currently deferring updating scroll bars
	DWORD	_fHScrollEnabled	:1; // Horizontal scrolling enabled
	DWORD	_fInBkgndRecalc		:1; // Avoid reentrant background recalc
	DWORD	_fLineRecalcErr		:1; // Error occured during background recalc
	DWORD	_fNoUpdateView		:1; // Don't update visible view
	DWORD	_fWordWrap			:1; // Word wrap text
	DWORD	_fNeedRecalc		:1; // Recalc line is needed
	DWORD	_fRecalcDone		:1; // Is line recalc done ?
	DWORD	_fViewChanged		:1; // Visible view rect has changed since last Draw
	DWORD	_fUpdateScrollBarDeferred:1;// scroll bars need to be updated
	DWORD	_fVScrollEnabled	:1; // vertical scrolling enabled
	DWORD	_fUpdateCaret		:1; // Whether Draw needs to update cursor
	DWORD	_fActive			:1; // Whether this display is active
	DWORD	_fRectInvalid		:1; // Entire client rectangle has been 
									// invalidated. Used only in SL. Put
									// here, as usual, to save space
	DWORD	_fSmoothVScroll		:1;	// Timer for smooth scrolling installed
	DWORD	_fFinishSmoothVScroll:1;// TRUE if we're winding down the current smooth scroll
	DWORD	_fMultiLine			:1;	// TRUE iff this CDisplay is multiline

	SHORT   _xWidthView;	  		// View rect width
	LONG	_yHeightView;	 		// View rect height
	LONG	_yHeightClient;   		// Height of client rect unmodified by inset.

	LONG	_xScroll;		 		// Horizontal scroll position of visible view

	LONG	_lTempZoomDenominator;	// Zoom for GetNaturalSize
	LONG	_cpFirstVisible;		// cp at start of first visible line

 	// Smooth scroll support.
	int		_smoothYDelta;			// Current # pixels * 1000 to smooth scroll by
	int		_continuedSmoothYDelta;	// At end of 1 smooth scroll cycle, start new with this
	int		_nextSmoothVScroll;		// Fractional amount not yet smooth scrolled
	int		_totalSmoothVScroll;	// Remaining # of device units to smooth scroll
	int		_continuedSmoothVScroll;// At end of 1 smooth scroll cycle, start new with this

private:
	void 	UpdateViewRectState(const RECT *prcClient);	

protected:
	LONG	GetSelBarInPixels();
	
	friend class CLinePtr;

	LONG			SetClientHeight(LONG yNewClientHeight);
	virtual void	InitLinePtr ( CLinePtr & ) = 0;
	
	// Line break recalc.
	virtual BOOL	RecalcView(BOOL fUpdateScrollBars, RECT* prc = NULL) = 0;

	// Rendering
	virtual void	Render(const RECT &rcView, const RECT &rcRender) = 0;

	// Scrollbar
	virtual BOOL	UpdateScrollBar(INT nBar, BOOL fUpdateRange = FALSE) = 0;
	void			GetViewDim(LONG& widthView, LONG& heightView);
	void			SetCpFirstVisible(LONG cp)		{_cpFirstVisible = cp;};
	LONG			ConvertScrollToXPos(LONG xPos);
	LONG			ConvertXPosToScrollPos(LONG xPos);
	virtual LONG	GetMaxXScroll() const = 0;

public:
	virtual	LONG	ConvertYPosToScrollPos(LONG yPos);

			CDisplay (CTxtEdit* ped);
	virtual CDisplay::~CDisplay();

	virtual BOOL	Init();
			void	InitFromDisplay(const CDisplay *pdp);

	// Device context management
	virtual BOOL	SetMainTargetDC(HDC hdc, LONG xWidthMax);
	virtual BOOL	SetTargetDC( HDC hdc, LONG dxpInch = -1, LONG dypInch = -1);

	// Getting properties
			CTxtEdit*		GetPed() const			{ return _ped;}
			CTxtStory*		GetStory() const		{ return _ped->GetTxtStory();}
			const CDevDesc*	GetDdRender() const		{ return this;}
	virtual const CDevDesc*	GetDdTarget() const		{ return NULL; }
			const CDevDesc*	GetTargetDev() const;
	
	virtual BOOL	IsMain() const = 0;
	virtual BOOL	IsPrinter() const;
			BOOL	IsRecalcDone() const			{ return _fRecalcDone;}
			BOOL	IsMultiLine() const				{ return _fMultiLine;}
			BOOL	IsTransparent() const			{ return _ped->IsTransparent();}
	virtual BOOL	GetWordWrap() const;
			void	SetWordWrap(BOOL fNoWrap);

			HRESULT	GetCachedSize(DWORD *pdwWidth, DWORD *pdwHeight);


	// maximum height and width
	virtual LONG	GetMaxWidth() const = 0;
	virtual LONG	GetMaxHeight() const = 0;
	virtual LONG 	GetMaxPixelWidth() const = 0;

	// Width, height and line count (all text)
	virtual LONG	GetWidth() const = 0;
	virtual LONG	GetHeight() const = 0;
	virtual LONG	GetResizeHeight() const = 0;
	virtual LONG	LineCount() const = 0;

	// View rectangle
			void	GetViewRect(RECT &rcView, LPCRECT prcClient = NULL);
			LONG	GetViewWidth() const			{ return _xWidthView;}
			LONG	GetViewHeight() const			{ return _yHeightView;}

	// Visible view properties
	virtual LONG	GetCliVisible(
						LONG *pcpMostVisible = NULL,
						BOOL fLastCharOfLastVisible = FALSE) const = 0;

			LONG	GetFirstVisibleCp() const		{return _cpFirstVisible;};
	virtual LONG	GetFirstVisibleLine() const = 0;

	// Line info
	virtual LONG	GetLineText(LONG ili, TCHAR *pchBuff, LONG cchMost) = 0;
	virtual LONG	CpFromLine(LONG ili, LONG *pyLine = NULL) = 0;
	
	virtual LONG	LineFromCp(LONG cp, BOOL fAtEnd) = 0;

	// Point <-> cp conversion
	virtual LONG	CpFromPoint(POINT pt, 
						const RECT *prcClient,
						CRchTxtPtr * const ptp, 
						CLinePtr * const prp, 
						BOOL fAllowEOL,
						HITTEST *pHit = NULL,
						CDispDim *pdispdim = NULL,
						LONG *pcpActual = NULL) = 0;

	virtual LONG	PointFromTp (
						const CRchTxtPtr &tp, 
						const RECT *prcClient,
						BOOL fAtEnd,	
						POINT &pt,
						CLinePtr * const prp, 
						UINT taMode,
						CDispDim *pdispdim = NULL) = 0;

	// View recalc and updating
			void	SetUpdateCaret()		{_fUpdateCaret = TRUE;}
			void	SetViewChanged()		{_fViewChanged = TRUE;}
			void	InvalidateRecalc()		{_fNeedRecalc = TRUE;}
			BOOL	RecalcView (const RECT &rcView, RECT* prcClient = NULL);
			BOOL	UpdateView();
	virtual BOOL	UpdateView(const CRchTxtPtr &tpFirst, LONG cchOld, LONG cchNew) = 0;

	// Rendering
			HRESULT Draw(HDC hicTargetDev,
						 HDC hdcDraw,
						 LPCRECT prcClient,
						 LPCRECT prcWBounds,
						 LPCRECT prcUpdate,
						 BOOL (CALLBACK * pfnContinue) (DWORD),
						 DWORD dwContinue);

	// Background recalc
	virtual void	StepBackgroundRecalc();
	virtual BOOL	WaitForRecalc(LONG cpMax, LONG yMax);
	virtual BOOL	WaitForRecalcIli(LONG ili);
	virtual BOOL	WaitForRecalcView();

	// Scrolling 
			LONG	GetXScroll() const			  {return _xScroll;} 
	virtual LONG	GetYScroll() const			  {return 0;}
			void	HScroll(WORD wCode, LONG xPos);
	virtual LRESULT VScroll(WORD wCode, LONG yPos);
	virtual void	LineScroll(LONG cli, LONG cch);
	virtual void	FractionalScrollView ( LONG yDelta );
	virtual void	ScrollToLineStart(LONG iDirection);
	virtual LONG	CalcYLineScrollDelta ( LONG cli, BOOL fFractionalFirst );
			BOOL	DragScroll(const POINT * ppt);	 // outside of client rect.
			BOOL	AutoScroll( POINT pt, const WORD xScrollInset, const WORD yScrollInset );
	virtual BOOL	ScrollView(LONG xScroll, LONG yScroll, BOOL fTracking, BOOL fFractionalScroll) = 0;
	virtual	LONG	AdjustToDisplayLastLine(LONG yBase,	LONG yScroll);

     // Smooth Scrolling 
			void	SmoothVScroll ( int direction, WORD cLines, int speedNum, int speedDenom, BOOL fMouseRoller );
			void	SmoothVScrollUpdate();
			BOOL	CheckInstallSmoothVScroll();
			void	CheckRemoveSmoothVScroll();
			void	FinishSmoothVScroll();
			BOOL	IsSmoothVScolling() { return _fSmoothVScroll; }

	// Scrollbars
	virtual LONG	GetScrollRange(INT nBar) const;
			BOOL	IsHScrollEnabled();
			BOOL	IsVScrollEnabled() {return _fVScrollEnabled; }

	// Resizing
			void	OnClientRectChange(const RECT &rcClient);
			void	OnViewRectChange(const RECT &rcView);
			HRESULT RequestResize();

	// Selection 
	virtual BOOL	InvertRange(LONG cp,
		                        LONG cch,
								SELDISPLAYACTION selAction) = 0;

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight) = 0;

	LONG			GetZoomDenominator() const;
	LONG			GetZoomNumerator() const;
	LONG			Zoom(LONG x) const;
	LONG			UnZoom(LONG x) const;

	LONG		 	HimetricXtoDX(LONG xHimetric) const;
	LONG		 	HimetricYtoDY(LONG yHimetric) const;
	LONG			DXtoHimetricX(LONG dx)  const;
	LONG			DYtoHimetricY(LONG dy) const;

	void 			ReDrawOnRectChange(HDC hicTarget, const RECT *prcClient);

	HRESULT 		TransparentHitTest(
						HDC hdc,
						LPCRECT prcClient,
						POINT pt,
						DWORD *pHitResult);

	HRESULT 		RoundToLine(HDC hdc, LONG width, LONG *pheight);
	void			SetTempZoomDenominator(LONG lZoomDenominator)
					{ 
						_lTempZoomDenominator = lZoomDenominator;
					}
	LONG			GetTempZoomDenominator()
					{ 
						return _lTempZoomDenominator;
					}
	void			ResetTempZoomDenominator() 
					{ 
						_lTempZoomDenominator = INVALID_ZOOM_DENOMINATOR;
					}
	void			SetDrawInfo(
						CDrawInfo *pdi, 
						DWORD dwDrawAspect,	//@parm draw aspect
						LONG  lindex,		//@parm currently unused
						void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
						DVTARGETDEVICE *ptd,//@parm information on target device								
						HDC hicTargetDev);	//@parm	target information context

	void			ReleaseDrawInfo();
	void 			ResetDrawInfo(const CDisplay *pdp);
	DWORD 			GetDrawAspect() const;
	LONG 			GetLindex() const;
	void *			GetAspect() const;
	DVTARGETDEVICE *GetPtd() const;
	void			SetActiveFlag(BOOL fActive) { _fActive = fActive; }
	BOOL			IsActive()	{ return _fActive; }
	virtual CDisplay *Clone() const = 0;

	// Support for freezing the display
	BOOL			IsFrozen();
	void			SaveUpdateCaret(BOOL fScrollIntoView);
	void			Freeze();
	void			SetNeedRedisplayOnThaw(BOOL fNeedRedisplay);
	void			Thaw();

	//
	// ITxNotify Interface
	//
	virtual void 	OnPreReplaceRange( 
						LONG cp, 
						LONG cchDel, 
						LONG cchNew,
						LONG cpFormatMin, LONG cpFormatMax);

	virtual void 	OnPostReplaceRange( 
						LONG cp, 
						LONG cchDel, 
						LONG cchNew,
						LONG cpFormatMin, 
						LONG cpFormatMax);

	virtual void	Zombie();
};

// Defines the draw info class. It is included here to prevent loops
// in dependencies that would require no inlining for functions dealing
// with this
#include	"_drwinfo.h"

/*
 *	CDisplay::ResetDrawInfo
 *
 *	@mfunc	Sets draw info using different display
 *
 *	@rdesc	void
 *
 */
inline void CDisplay::ResetDrawInfo(
	const CDisplay *pdp)	//@parm Display to use for draw information
{
	_pdi = pdp->_pdi;
}

/*
 *	CDisplay::ResetDrawInfo
 *
 *	@mfunc	Gets lindex as passed most recently from the host.
 *
 *	@rdesc	draw aspect
 *
 */
inline DWORD CDisplay::GetDrawAspect() const
{
	return _pdi ? _pdi->GetDrawAspect() : DVASPECT_CONTENT; 
}

/*
 *	CDisplay::GetLindex
 *
 *	@mfunc	Gets lindex as passed most recently from the host.
 *
 *	@rdesc	lindex
 *
 */
inline LONG CDisplay::GetLindex() const
{
	return _pdi ? _pdi->GetLindex() : -1; 
}

/*
 *	CDisplay::GetAspect
 *
 *	@mfunc	Gets aspect as passed most recently from the host.
 *
 *	@rdesc	Aspect data
 *
 */
inline void *CDisplay::GetAspect() const
{
	return _pdi ? _pdi->GetAspect() : NULL; 
}

/*
 *	CDisplay::GetPtd
 *
 *	@mfunc	Gets device target as passed most recently from the host.
 *
 *	@rdesc	DVTARGETDEVICE or NULL
 *
 */
inline DVTARGETDEVICE *CDisplay::GetPtd() const
{
	return _pdi ? _pdi->GetPtd() : NULL; 
}

/*
 *	CDisplay::IsFrozen
 *
 *	@mfunc	Return whether display is currently frozen
 *
 *	@rdesc	
 *		TRUE - display is frozen <nl>
 *		FALSE - display is not frozen
 *
 */
inline BOOL CDisplay::IsFrozen()
{
	return _padc != NULL;
}

/*
 *	CFreezeDisplay
 *	
 * 	@class	This class is used to freeze and guranatee that the display
 *			unfreeze a display when it passes out of its context.
 *
 *
 */
class CFreezeDisplay
{
public:	
						CFreezeDisplay(CDisplay *pdp); //@cmember Constructor Freezes

						~CFreezeDisplay();			//@cmember Destructor - Thaws

private:

	CDisplay *			_pdp;						//@cmember Display to freeze
};

/*
 *	CFreezeDisplay::CFreezeDisplay()
 *
 *	@mfunc
 *		Initialize object and tell the input display to freeze
 */
inline CFreezeDisplay::CFreezeDisplay(CDisplay *pdp) : _pdp(pdp)
{
	pdp->Freeze();
}

/*
 *	CFreezeDisplay::CFreezeDisplay()
 *
 *	@mfunc
 *		Free object and tell display to thaw.
 */
inline CFreezeDisplay::~CFreezeDisplay()
{
	_pdp->Thaw();
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_dispml.h ===
/*
 *  _DISPML.H
 *  
 *  Purpose:
 *      CDisplayML class. Multi-line display.
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Murray Sargent
 */

#ifndef _DISPML_H
#define _DISPML_H

#include "_disp.h"


class CDisplayML : public CDisplay, public CLineArray
{
public: 

#ifdef DEBUG
	BOOL	Invariant(void) const;
#endif 

    friend class CLinePtr;
    friend class CLed;
	friend BOOL CTxtEdit::OnDisplayBand(const RECT *prc, BOOL fPrintFromDraw);
	friend class CDisplayPrinter;

private:
    LONG _cpCalcMax;        // last cp for which line breaks have been calc'd + 1
    LONG _yCalcMax;         // height of calculated lines
    LONG _cpWait;           // cp WaitForRecalc() is waiting for (or < 0)
    LONG _yWait;            // y WaitForRecalc() is waiting for (or < 0)

    LONG  _yScroll;         // vertical scroll position of visible view
    LONG  _dyFirstVisible;  // offset from top of view to first visible line
    LONG  _iliFirstVisible; // index of first visible line

    LONG _xWidthMax;        // max width of this display (in log unit)
    LONG _yHeightMax;       // max height of this display (-1 for infinite)
    LONG _xWidth;           // width of longest calculated line
    LONG _yHeight;          // sum of heights of calculated lines
    LONG _cpMin;            // first character in display

    CDevDesc *_pddTarget;     // target device (if any).

	unsigned long _fInRecalcScrollBars:1;	// we're trying to recalc scroll
											// bars
    
private:
    // Helpers
            void    InitVars();
			void 	RecalcScrollBars();
			LONG	ConvertScrollToYPos(LONG yPos);
			LONG	GetMaxYScroll() const;
			BOOL	CreateEmptyLine();
			LONG	CalcScrollHeight(LONG yHeight) const;
			void	RebindFirstVisible();

    // Line breaking
            BOOL    RecalcLines(BOOL fWait = FALSE);
            BOOL    RecalcLines(const CRchTxtPtr &tpFirst, LONG cchOld, LONG cchNew,
                        BOOL fBackground, BOOL fWait, CLed *pled);
            BOOL    RecalcSingleLine(CLed *pled);
            LONG    CalcDisplayWidth();

    // Rendering
    virtual void    Render(const RECT &rcView, const RECT &rcRender);

    // Scrolling and scroller bars
            void    DeferUpdateScrollBar();
            BOOL    DoDeferredUpdateScrollBar();
    virtual BOOL    UpdateScrollBar(INT nBar, BOOL fUpdateRange = FALSE );

protected:

	virtual LONG	GetMaxXScroll() const;

public:
 	virtual	LONG	ConvertYPosToScrollPos(LONG yPos);

           CDisplayML (CTxtEdit* ped);
    virtual CDisplayML::~CDisplayML();

    virtual BOOL    Init();

    // Device context management
    virtual BOOL    SetMainTargetDC(HDC hdc, LONG xWidthMax);
    virtual BOOL    SetTargetDC(HDC hdc, LONG dxpInch = -1, LONG dypInch = -1);

    // Getting properties
    virtual void    InitLinePtr ( CLinePtr & );
    virtual const	CDevDesc*     GetDdTarget() const       {return _pddTarget;}
    
    virtual BOOL    IsMain() const							{return TRUE;}
			BOOL	IsInOutlineView() const					{return _ped->IsInOutlineView();}
	
    // maximum height and width
    virtual LONG    GetMaxWidth() const                     {return _xWidthMax;}
    virtual LONG    GetMaxHeight() const                    {return 0;}
	virtual LONG	GetMaxPixelWidth() const;

    // Width, height and line count (of all text)
    virtual LONG    GetWidth() const                        {return _xWidth;}
    virtual LONG    GetHeight() const                       {return _yHeight;}
	virtual LONG	GetResizeHeight() const;
    virtual LONG    LineCount() const;

    // Visible view properties
    virtual LONG    GetCliVisible(
						LONG *pcpMostVisible = NULL,
						BOOL fLastCharOfLastVisible = FALSE) const;

    virtual LONG    GetFirstVisibleLine() const             {return _iliFirstVisible;}
    
    // Line info
    virtual LONG    GetLineText(LONG ili, TCHAR *pchBuff, LONG cchMost);
    virtual LONG    CpFromLine(LONG ili, LONG *pyLine = NULL);
			LONG    YposFromLine(LONG ili);
    virtual LONG    LineFromYpos(LONG yPos, LONG *pyLine = NULL, LONG *pcpFirst = NULL);
    virtual LONG    LineFromCp(LONG cp, BOOL fAtEnd) ;

    // Point <-> cp conversion
    virtual LONG    CpFromPoint(
    					POINT pt, 
						const RECT *prcClient,
    					CRchTxtPtr * const ptp, 
    					CLinePtr * const prp, 
    					BOOL fAllowEOL,
						HITTEST *pHit = NULL,
						CDispDim *pdispdim = NULL,
						LONG *pcpActual = NULL);

    virtual LONG    PointFromTp (
						const CRchTxtPtr &tp, 
						const RECT *prcClient,
						BOOL fAtEnd,	
						POINT &pt,
						CLinePtr * const prp, 
						UINT taMode,
						CDispDim *pdispdim = NULL);

    // Line break recalc
			BOOL    StartBackgroundRecalc();
    virtual VOID    StepBackgroundRecalc();
    virtual BOOL    RecalcView(BOOL fUpdateScrollBars, RECT* prc = NULL);
    virtual BOOL    WaitForRecalc(LONG cpMax, LONG yMax);
    virtual BOOL    WaitForRecalcIli(LONG ili);
    virtual BOOL    WaitForRecalcView();

    // Complete updating (recalc + rendering)
    virtual BOOL    UpdateView(const CRchTxtPtr &tpFirst, LONG cchOld, LONG cchNew);

    // Scrolling 
    virtual LRESULT VScroll(WORD wCode, LONG xPos);
    virtual VOID    LineScroll(LONG cli, LONG cch);
	virtual VOID	FractionalScrollView ( LONG yDelta );
	virtual VOID	ScrollToLineStart(LONG iDirection);
	virtual LONG	CalcYLineScrollDelta ( LONG cli, BOOL fFractionalFirst );
    virtual BOOL    ScrollView(LONG xScroll, LONG yScroll, BOOL fTracking, BOOL fFractionalScroll);
    virtual LONG    GetYScroll() const;
    virtual LONG    GetScrollRange(INT nBar) const;
	virtual	LONG	AdjustToDisplayLastLine(LONG yBase,	LONG yScroll);

    // Selection 
    virtual BOOL    InvertRange(LONG cp, LONG cch, SELDISPLAYACTION selAction);

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight);

    // Misc. methods
            void    FindParagraph(LONG cpMin, LONG cpMost, LONG *pcpMin, LONG *pcpMost);

	virtual CDisplay *Clone() const;

#ifdef DEBUG
            void    CheckLineArray() const;
            void    DumpLines(LONG iliFirst, LONG cli);
            void    CheckView();
			BOOL	VerifyFirstVisible(LONG *pHeight = NULL);
#endif
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_dispprt.h ===
/*
 *  _DISPPRT.H
 *  
 *  Purpose:
 *      CDisplayPrinter class. Multi-line display for printing.
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Jon Matousek
 */

#ifndef _DISPPRT_H
#define _DISPPRT_H

#include "_dispml.h"


class CDisplayPrinter : public CDisplayML
{
public:
					CDisplayPrinter (
						CTxtEdit* ped, 
						HDC hdc, 
						LONG x, 
						LONG y, 
						SPrintControl prtcon);

    virtual BOOL    IsMain() const { return FALSE; }

	inline RECT 	GetPrintView( void ) { return rcPrintView; }
	inline void 	SetPrintView( const RECT & rc ) { rcPrintView = rc; }

	inline RECT		GetPrintPage(void) { return _rcPrintPage;}
	inline void		SetPrintPage(const RECT &rc) {_rcPrintPage = rc;}

    // Format range support
    LONG    		FormatRange(LONG cpFirst, LONG cpMost, BOOL fWidowOrphanControl);

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight);

	virtual BOOL	IsPrinter() const;

	void			SetPrintDimensions(RECT *prc);


protected:

	RECT			rcPrintView;	// for supporting client driven printer banding.
	RECT			_rcPrintPage;	// the entire page size

	SPrintControl	_prtcon;		// Control print behavior
	LONG			_cpForNumber;	// cp of cached number.
	WORD			_wNumber;		// Cached value of paragraph number
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_doc.h ===
/*
 *  @doc INTERNAL
 *
 *  @module _DOC.H  CTxtStory declaration |
 *  
 *  Purpose:
 *      Encapsulate the plain-text document data (text blocks, cchText)
 *  
 *  Original Authors: <nl>
 *      Christian Fortini <nl>
 *      Murray Sargent <nl>
 *
 *  History: <nl>
 *      6/25/95 alexgo  commented and cleaned up
 *
 */

#ifndef _DOC_H
#define _DOC_H

#include "_array.h"

#define cbBlockCombine  CbOfCch(3072)
#define cbBlockMost     CbOfCch(49152)
#define cbBlockInitial  CbOfCch(4096)
#define cchGapInitial   128
#define cchBlkCombmGapI (CchOfCb(cbBlockCombine) - cchGapInitial)
#define cchBlkInitmGapI (CchOfCb(cbBlockInitial) - cchGapInitial)

#define cchBlkInsertmGapI   (CchOfCb(cbBlockInitial)*5 - cchGapInitial)

class CDisplay;
class CTxtPtr;
class CTxtArray;

/*
 *  CTxtRun
 *
 *  @class  Formalizes a run of text. A range of text with same attribute,
 * (see CFmtDesc) or within the same line (see CLine), etc. Runs are kept
 * in arrays (see CArray) and are pointed to by CRunPtr's of various kinds.
 * In general the character position of a run is computed by summing the
 * length of all preceding runs, altho it may be possible to start from
 * some other cp, e.g., for CLines, from CDisplay::_cpFirstVisible.
 */

class CTxtRun
{
//@access Public Methods and Data
public:
    CTxtRun()   {_cch = 0;}         //@cmember Constructor
    LONG _cch;                      //@cmember Count of characters in run
};

/*
 *  CTxtBlk
 *
 *  @class  A text block; a chunk of UNICODE text with a buffer gap to allow
 *  for easy insertions and deletions.
 *
 *  @base   protected | CTxtRun
 *
 *  @devnote    A text block may have four states: <nl>
 *      NULL:   No data allocated for the block <nl>
 *              <md CTxtBlk::_pch> == NULL  <nl>
 *              <md CTxtRun::_cch> == 0     <nl>
 *              <md CTxtBlk::_ibGap> == 0   <nl>
 *              <md CTxtBlk::_cbBlock> == 0 <nl>
 *
 *      empty:  All of the available space is a buffer gap <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> == 0     <nl>
 *              <md CTxtBlk::_ibGap> == 0   <nl>
 *              <md CTxtBlk::_cbBlock> <gt>= 0  <nl>
 *
 *      normal: There is both data and a buffer gap <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> != 0     <nl>
 *              <md CTxtBlk::_ibGap> != 0   <nl>
 *              <md CTxtBlk::_cbBlock> <gt>= 0  <nl>
 *      
 *      full:   The buffer gap is of zero size <nl>
 *              <md CTxtBlk::_pch> != NULL  <nl>
 *              <md CTxtRun::_cch> <gt>= 0  <nl>
 *              <md CTxtBlk::_ibGap> <gt> 0 <nl>
 *              <md CTxtBlk::_cbBlock> == _cch * sizeof(WCHAR) <nl>
 *
 *  The position of the buffer gap is given by _ibGap.  With _cch and _cbBlock,
 *  it's possible to figure out the *size* of the gap by simply calculating:
 *  <nl>
 *      size = _cbBlock - (_cch * sizeof(character))
 *
 */

class CTxtBlk : public CTxtRun
{
    friend class CTxtPtr;
    friend class CTxtArray;

//@access Protected Methods
protected:
                                    //@cmember  Constructor
    CTxtBlk()   {InitBlock(0);}
                                    //@cmember  Destructor
    ~CTxtBlk()  {FreeBlock();}

                                    //@cmember  Initializes the block to the
                                    //# of bytes given by <p cb>    
    BOOL    InitBlock(LONG cb);
                                    //@cmember  Sets a block to the NULL state
    VOID    FreeBlock();
                                    //@cmember  Moves the buffer gap in a
                                    //block 
    VOID    MoveGap(LONG ichGap);
                                    //@cmember  Resizes a block to <p cbNew>
                                    //bytes
    BOOL    ResizeBlock(LONG cbNew);

//@access Private Data
private:
                                    //@cmember  Pointer to the text data
    WCHAR   *_pch;          
                                    //@cmember  BYTE offset of the gap
    LONG    _ibGap;         
                                    //@cmember  size of the block in bytes
    LONG    _cbBlock;       
};


/*
 *  CTxtArray
 *
 *  @class  A dynamic array of <c CTxtBlk> classes
 *
 *  @base public | CArray<lt>CTxtBlk<gt>
 */
class CTxtArray : public CArray<CTxtBlk>
{
    friend class CTxtPtr;
    friend class CTxtStory;

//@access   Public methods
public:
#ifdef DEBUG
                                    //@cmember  Invariant support
    BOOL Invariant() const;
#endif  // DEBUG
                                    //@cmember  Constructor
    CTxtArray();
                                    //@cmember  Destructor
    ~CTxtArray();
                                    //@cmember  Gets the total number of
                                    //characters in the array.
    LONG    CalcTextLength() const;

    // Get access to cached CCharFormat and CParaFormat structures
    const CCharFormat*  GetCharFormat(LONG iCF);
    const CParaFormat*  GetParaFormat(LONG iPF);

    LONG    Get_iCF()           {return _iCF;}
    LONG    Get_iPF()           {return _iPF;}
    void    Set_iCF(LONG iCF)   {_iCF = (SHORT)iCF;}
    void    Set_iPF(LONG iPF)   {_iPF = (SHORT)iPF;}

//@access Private methods
private:
                                    //@cmember  Adds cb blocks
    BOOL    AddBlock(LONG itbNew, LONG cb);
                                    //@cmember  Removes ctbDel blocks
    void    RemoveBlocks(LONG itbFirst, LONG ctbDel);
                                    //@cmember  Combines blocks adjacent to itb
    void    CombineBlocks(LONG itb);
                                    //@cmember  Splits a block
    BOOL    SplitBlock(LONG itb, LONG ichSplit, LONG cchFirst,
                LONG cchLast, BOOL fStreaming);
                                    //@cmember  Shrinks all blocks to minimal
                                    //          size
    void    ShrinkBlocks();     
                                    //@cmember  Copies chunk of text into
                                    //          location given
    LONG    GetChunk(TCHAR **ppch, LONG cch, TCHAR *pchChunk, LONG cchCopy) const;

    LONG    _cchText;               //@cmember Total text character count
    SHORT   _iCF;                   //@cmember Default CCharFormat index
    SHORT   _iPF;
};


class CBiDiLevel
{
public:
    BOOL operator == (const CBiDiLevel& level) const
    {
        return _value == level._value && _fStart == level._fStart;
    }
    BOOL operator != (const CBiDiLevel& level) const
    {
        return _value != level._value || _fStart != level._fStart;
    }

    BYTE    _value;             // embedding level (0..15)
    BYTE    _fStart :1;         // start a new level e.g. "{{abc}{123}}"
};

/*
 *  CFormatRun
 *
 *  @class  A run of like formatted text, where the format is indicated by an
 *  and index into a format table
 *
 *  @base   protected | CTxtRun
 */
class CFormatRun : public CTxtRun
{
//@access   Public Methods
public:
    friend class CFormatRunPtr;
    friend class CTxtRange;
    friend class CRchTxtPtr;

    BOOL SameFormat(CFormatRun* pRun)
    {
        return  _iFormat == pRun->_iFormat &&
                _level._value == pRun->_level._value &&
                _level._fStart == pRun->_level._fStart;
    }

    short   _iFormat;           //@cmember index of CHARFORMAT/PARAFORMAT struct
    CBiDiLevel _level;          //@cmember BiDi level
};

//@type CFormatRuns | An array of CFormatRun classes
typedef CArray<CFormatRun> CFormatRuns;


/*
 *  CTxtStory
 *
 *  @class
 *      The text "Document".  Maintains the state information related to the
 *      actual data of a document (such as text, formatting information, etc.)
 */

class CTxtStory
{
    friend class CTxtPtr;
    friend class CRchTxtPtr;
    friend class CReplaceFormattingAE;

//@access Public Methods
public:
    CTxtStory();                //@cmember  Constructor
    ~CTxtStory();               //@cmember  Destructor

                                //@cmember  Get total text length
    LONG GetTextLength() const
        {return _TxtArray._cchText;}

                                //@cmember  Get Paragraph Formatting runs
    CFormatRuns *GetPFRuns()    {return _pPFRuns;}
                                //@cmember  Get Character Formatting runs
    CFormatRuns *GetCFRuns()    {return _pCFRuns;}
                                
    void DeleteFormatRuns();    //@cmember  Converts to plain text from rich

    const CCharFormat*  GetCharFormat(LONG iCF)
                            {return _TxtArray.GetCharFormat(iCF);}
    const CParaFormat*  GetParaFormat(LONG iPF)
                            {return _TxtArray.GetParaFormat(iPF);}

    LONG Get_iCF()          {return _TxtArray.Get_iCF();}
    LONG Get_iPF()          {return _TxtArray.Get_iPF();}
    void Set_iCF(LONG iCF)  {_TxtArray.Set_iCF(iCF);}
    void Set_iPF(LONG iPF)  {_TxtArray.Set_iPF(iPF);}

#ifdef DEBUG
    void DbgDumpStory(void);    // Debug story dump member
#endif

//@access   Private Data
private:
    CTxtArray       _TxtArray;  //@cmember  Plain-text runs
    CFormatRuns *   _pCFRuns;   //@cmember  Ptr to Character-Formatting runs
    CFormatRuns *   _pPFRuns;   //@cmember  Ptr to Paragraph-Formatting runs
};

#endif      // ifndef _DOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_dte.h ===
/*
 *	_DTE.H
 *
 *	Purpose:
 *		Interface declaration for IDataTransferEngine
 *		there is typically one data transfer engine per
 *		CTxtEdit instance
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	NB!  THIS FILE IS NOW OBSOLETE
 */

#ifndef __DTE_H__
#define __DTE_H__

#include "_m_undo.h"

class CTxtRange;
class CTxtEdit;

/*
 *	DataObjectInfo
 *
 *	Purpose:
 *		enumeration of bit flags used to indicate what operations
 *		are possible from a given data object.
 */

typedef enum tagDataObjectInfo
{
	DOI_NONE			= 0,
	DOI_CANUSETOM		= 1,	// TOM<-->TOM optimized data transfers
	DOI_CANPASTEPLAIN	= 2,	// plain text pasting available
	DOI_CANPASTERICH	= 4, 	// rich text pasting available  
	DOI_CANPASTEOLE		= 8,	// object may be pasted as an OLE embedding
								// (note that this flag may be combined with
								// others). 
} DataObjectInfo;

/*
 *	IDataTransferEngine
 *
 *	Purpose:
 *		provides clipboard, drag drop, and data object data transfer
 *		capabilities.  Each implementation will provide a different 
 *		level of functionality (e.g. OLE vs no-OLE)
 */
class IDataTransferEngine
{
public:
	// memory mgmt

	virtual void Destroy() = 0;

	// clipboard operations

	virtual HRESULT CopyRangeToClipboard( CTxtRange *prg ) = 0;
	virtual HRESULT CutRangeToClipboard( CTxtRange *prg, 
						IUndoBuilder *publdr ) = 0;
	virtual HRESULT PasteClipboardToRange( CTxtRange *prg, 
						IUndoBuilder *publdr ) = 0;
	virtual BOOL 	CanPaste( CTxtRange *prg, CLIPFORMAT cf) = 0;

	// data object operations

	virtual HRESULT RangeToDataObject( CTxtRange *prg, LONG lStreamFormat,
									IDataObject **ppdo) = 0;
	virtual HRESULT PasteDataObjectToRange( IDataObject *pdo,
						CTxtRange *prg, IUndoBuilder *publdr) = 0;

	virtual HRESULT GetDataObjectInfo( IDataObject *pdo, DWORD *pDOIFlags ) = 0;
	
	// drag drop operations
	
	virtual HRESULT GetDropTarget( IDropTarget **ppDropTarget ) = 0;
	virtual HRESULT StartDrag( CTxtRange *prg, IUndoBuilder *publdr) = 0;

	// file i/o

	virtual LONG LoadFromEs( CTxtRange *prg, LONG lStreamFormat,
							 EDITSTREAM *pes, IUndoBuilder *publdr) = 0;
	virtual LONG SaveToEs(	 CTxtRange *prg, LONG lStreamFormat,
							 EDITSTREAM *pes ) = 0;

	// converstion routines

	virtual HGLOBAL AnsiPlainTextFromRange( CTxtRange *prg ) = 0;
	virtual HGLOBAL UnicodePlainTextFromRange( CTxtRange *prg ) = 0;

};

#endif // !__DTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_dragdrp.h ===
/*
 *	_DRAGDRP.H
 *
 *	Purpose:
 *		class declarations for Richedit's OLE drop target and drop source
 *		objects.
 *
 *	Author:
 *		alexgo (4/28/95)
 *
 */

#ifndef __DRAGDRP_H__
#define __DRAGDRP_H__

#include	"_osdc.h"

// DWORD packed flag values.  These are assigned values such that they can
// be or'd with DataObjectInfo flags and not conflict.  We are, in effect,
// overriding the DataObjectInfo flags.
#define DF_CLIENTCONTROL	0x80000000	// QueryAcceptData says the client
										// will handle this drop.
#define DF_CANDROP			0x40000000  // We can handle the drop
#define DF_OVERSOURCE       0x20000000  // Drop target is within source range.
#define DF_RIGHTMOUSEDRAG	0x10000000	// doing a right mouse drag drop


// forward declaration.
class CCallMgr;


#define	WIDTH_DROPCARET 1
#define	DEFAULT_DROPCARET_MAXHEIGHT 32

/*
 *	CDropCaret
 *
 *	Purpose:
 *		provides a caret for the location that drop will occur
 */
class CDropCaret
{
public:

					CDropCaret(CTxtEdit *ped);

					~CDropCaret();

	BOOL			Init();

	void			DrawCaret(LONG cpCur);

	void			HideCaret();

	void			ShowCaret();

	void			CancelRestoreCaretArea();

	BOOL			NoCaret();

private:

	CTxtEdit *		_ped;

	HDC				_hdcWindow;

	LONG			_yPixelsPerInch;

	LONG			_yHeight;

	LONG			_yHeightMax;

	POINT			_ptCaret;

	COffScreenDC	_osdc;
};

/*
 *	CDropCaret::CancelRestoreCaretArea
 *
 *	Purpose:
 *		Tell object not to restore area where caret was.
 *
 *	@devnote:
 *		When we drop we don't want to restore the old caret area
 *		since that is no longer correct.
 *
 */
inline void CDropCaret::CancelRestoreCaretArea()
{
	_yHeight = -1;
}


/*
 *	CDropCaret::NoCaret
 *
 *	Purpose:
 *		Tell whether caret has been turned off
 *
 */
inline BOOL CDropCaret::NoCaret()
{
	return -1 == _yHeight;
}


/*
 *	CDropSource
 *
 *	Purpose:
 *		provides drag drop feedback
 */

class CDropSource : public IDropSource
{
public:
	// IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropSource methods
    STDMETHOD(QueryContinueDrag)(BOOL fEscapePressed, DWORD grfKeyState);
    STDMETHOD(GiveFeedback)(DWORD dwEffect);

	CDropSource();

private:
	// NOTE: private destructor, may not be allocated on the stack as 
	// this would break OLE's current object liveness rules
	~CDropSource();

	ULONG		_crefs;
};

/*
 *	CDropTarget
 *
 *	Purpose:
 *		an OLE drop-target object; provides a place for text to be "dropped"
 *
 */

class CDropTarget : public IDropTarget
{
public:
	// IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDropTarget methods
    STDMETHOD(DragEnter)(IDataObject *pdo, DWORD grfKeyState,
            POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)();
    STDMETHOD(Drop)(IDataObject *pdo, DWORD grfKeyState, POINTL pt,
           	DWORD *pdwEffect);
	
	
	CDropTarget(CTxtEdit *ped);

	// this method is used during drag drop to cache important information
	void SetDragInfo( IUndoBuilder *publdr, LONG cpMin, LONG cpMax );
	void Zombie();		//@cmember Nulls out the state of this object
						
	BOOL fInDrag();		//@cmember Tells whether another app is dragging
						// over us.

private:
	// this class is used in CDropTarget::Drop to clean up at the end
	// of the call.
	class CDropCleanup
	{
	public:
		CDropCleanup( CDropTarget *pdt )
		{	
			_pdt = pdt;
		}

		~CDropCleanup()
		{
			delete _pdt->_pcallmgr;
			_pdt->_pcallmgr = NULL;
			delete _pdt->_pdrgcrt;
			_pdt->_pdrgcrt = NULL;
		}
	private:
		CDropTarget *	_pdt;
	};

	friend class CDropCleanup;

	// NOTE: private destructor, may not be allocated on the stack as 
	// this would break OLE's current object liveness rules

	~CDropTarget();

	void UpdateEffect(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
	void DrawFeedback(void);
	void ConvertScreenPtToClientPt( POINTL *pptScreen, POINT *pptClient );
	HRESULT HandleRightMouseDrop(IDataObject *pdo, POINTL ptl);

	ULONG		_crefs;
	DWORD		_dwFlags;	// DataObjectInfo cache (e.g. DOI_CANPASTEPLAIN)
							// and other flags.
	CTxtEdit *	_ped;
	CCallMgr *	_pcallmgr;	// The call manager used during a drag drop operation.

	// cached information for drag drop operations
	IUndoBuilder *_publdr;	// the undo builder for the drag operation
	LONG		_cpMin;		// the min and max cp's for the range that is
	LONG		_cpMost;	//   being dragged so we can disable drag-onto-yourself!
	LONG		_cpSel;		// active end and length for selection *before*
	LONG		_cchSel;	//	 drag drop op occured (so we can restore it)
	LONG		_cpCur;		// the cp that the mouse is currently over
	CDropCaret *_pdrgcrt;	// Object that implements the drop caret
};


/*
 *	CDropTarget::fInDrag ()
 *
 *	Purpose:
 *		Tells interested parties whether a drag operation is occurring
 *
 */
inline BOOL CDropTarget::fInDrag()
{
	return _pcallmgr != NULL;
}

#endif // !__DRAGDRP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_dispsl.h ===
/*
 *  _DISPML.H
 *  
 *  Purpose:
 *      CDisplaySL class. Single-line display.
 *  
 *  Authors:
 *      Eric Vasilik
 */

#ifndef _DISPSL_H
#define _DISPSL_H

#include "_disp.h"

// Forward declaration
class CTxtSelection;

class CDisplaySL : public CDisplay, private CLine
{
public:

    CDisplaySL ( CTxtEdit* ped );
    
protected:


    // The following are pure functions from the base

    // Helpers
    virtual BOOL Init();
    void InitVars();
    
    // Line breaking
    BOOL RecalcLine();

    // Rendering
    virtual VOID Render(const RECT &rcView, const RECT &rcRender);
    
    // Scrolling and scroller bars
    virtual BOOL UpdateScrollBar(INT nBar, BOOL fUpdateRange = FALSE);
    virtual LONG GetScrollRange(INT nBar) const;
    
    // Getting properties
    virtual void InitLinePtr ( CLinePtr & plp );
    virtual BOOL IsMain() const;
    
    // maximum height and width
    virtual LONG GetMaxWidth() const;
    virtual LONG GetMaxHeight() const;
	virtual LONG GetMaxPixelWidth() const;

    // Width, height and line count (of all text)
    virtual LONG GetWidth() const;
    virtual LONG GetHeight() const;
	virtual LONG GetResizeHeight() const;
    virtual LONG LineCount() const;

    // Visible view properties
    virtual LONG GetCliVisible(
					LONG *pcpMostVisible = NULL,
					BOOL fLastCharOfLastVisible = FALSE) const;

    virtual LONG GetFirstVisibleLine() const;

    // Line info
    virtual LONG GetLineText(LONG ili, TCHAR *pchBuff, LONG cchMost);
    virtual LONG CpFromLine(LONG ili, LONG *pyLine = NULL);
    virtual LONG LineFromCp(LONG cp, BOOL fAtEnd);
    
    // Point <-> cp conversion
    virtual LONG CpFromPoint(
    				POINT pt, 
					const RECT *prcClient,
    				CRchTxtPtr * const ptp, 
    				CLinePtr * const prp, 
    				BOOL fAllowEOL,
					HITTEST *pHit = NULL,
					CDispDim *pdispdim = 0,
					LONG *pcpActual = NULL);

    virtual LONG PointFromTp (
					const CRchTxtPtr &tp, 
					const RECT *prcClient,
					BOOL fAtEnd, 
					POINT &pt,
					CLinePtr * const prp, 
					UINT taMode,
					CDispDim *pdispdim = 0);

    // Line break recalc
    virtual BOOL RecalcView(BOOL fUpdateScrollBars, RECT* prc = NULL);
    virtual BOOL WaitForRecalcIli(LONG ili);

    // Complete updating (recalc + rendering)
    virtual BOOL UpdateView(const CRchTxtPtr &tpFirst, LONG cchOld, LONG cchNew);

    // Scrolling 
    virtual BOOL ScrollView(LONG xScroll, LONG yScroll, BOOL fTracking, BOOL fFractionalScroll);
    
    // Selection 
    virtual BOOL InvertRange(LONG cp, LONG cch, SELDISPLAYACTION selAction);

	// Natural size calculation
	virtual HRESULT	GetNaturalSize(
						HDC hdcDraw,
						HDC hicTarget,
						DWORD dwMode,
						LONG *pwidth,
						LONG *pheight);

    virtual BOOL    GetWordWrap() const;

	virtual CDisplay *Clone() const;

	virtual LONG	GetMaxXScroll() const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_edit.h ===
/*  _EDIT.H
 *
 *  Purpose:
 *      Base classes for rich-text manipulation
 *
 *  Authors:
 *      Christian Fortini
 *      Murray Sargent (and many others)
 *
 *  Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _EDIT_H
#define _EDIT_H

#include "textserv.h"
#include "textsrv2.h"
#include "_ldte.h"
#include "_m_undo.h"
#include "_notmgr.h"
#include "_doc.h"
#include "_objmgr.h"
#include "_cfpf.h"
#include "_callmgr.h"
#include "_magelln.h"

// Forward declarations
class CRchTxtPtr;
class CTxtSelection;
class CTxtStory;
class CTxtUndo;
class CMeasurer;
class CRenderer;
class CDisplay;
class CDisplayPrinter;
class CDrawInfo;
class CDetectURL;
class CUniscribe;
class CTxtBreaker;

// Macro for finding parent "this" of embedded class. If this turns out to be
// globally useful we should move it to _common.h.
#define GETPPARENT(pmemb, struc, membname) (\
                (struc FAR *)(((char FAR *)(pmemb))-offsetof(struc, membname)))

// These wonderful constants are for backward compatibility. They are the
// sizes used for initialization and reset in RichEdit 1.0
const LONG cInitTextMax  = (32 * 1024) - 1;
const LONG cResetTextMax = (64 * 1024);

extern DWORD CALLBACK ReadHGlobal (DWORD_PTR dwCookie, LPBYTE pbBuff, LONG cb, LONG *pcb);
extern DWORD GetKbdFlags(WORD vkey, DWORD dwFlags);

extern BYTE szUTF8BOM[];
extern WORD g_wFlags;                               // Toggled by Ctrl-"
#define KF_SMARTQUOTES  0x0001                      // Enable smart quotes
#define SmartQuotesEnabled()    (g_wFlags & KF_SMARTQUOTES)

struct SPrintControl
{
    union
    {
        DWORD       _dwAllFlags;                // Make it easy to set all flags at once.
        struct
        {
            ULONG   _fDoPrint:1;                // Whether actual print is required
            ULONG   _fPrintFromDraw:1;          // Whether draw is being used to print
        };
    };

    SPrintControl(void) { _dwAllFlags = 0; }
};

enum DOCUMENTTYPE
{
    DT_LTRDOC   = 1,            // DT_LTRDOC and DT_RTLDOC are mutually
    DT_RTLDOC   = 2,            //  exclusive
};

// Context rule settings.
// Optimally, these would be an enum, but we run into sign extension glitchs
// sticking an enum into a 2-bit field.
#define CTX_NONE    0       // No context direction/alignment.
#define CTX_NEUTRAL 1       // No strong characters in the control, direction/alignment follows keyboard.
#define CTX_LTR     2       // LTR direction/alignment (first strong character is LTR)
#define CTX_RTL     3       // RTL direction/alignment (first strong character is RTL)

#define IsStrongContext(x)  (x >= CTX_LTR)

class CDocInfo                  // Contains ITextDocument info
{
public:
    BSTR    pName;              // Document filename
    HANDLE  hFile;              // Handle used unless full file sharing
    WORD    wFlags;             // Open, share, create, and save flags
    WORD    wCpg;               // Code page
    LONG    dwDefaultTabStop;   // TOM settable default tab stop
    LCID    lcid;               // Document lcid (for RTF \deflang)
    LCID    lcidfe;             // Document FE lcid (for RTF \deflangfe)
    LPSTR   lpstrLeadingPunct;  // Leading kinsoku characters
    LPSTR   lpstrFollowingPunct;// Following kinsoku characters
    COLORREF *prgColor;         // Special color array
    char    cColor;             // Allocated count of colors in pColor
    BYTE    bDocType;           // 0-1-2: export none-\ltrdoc-\rtldoc
                                // If 0x80 or'd in, PWD instead of RTF
    BYTE    bCaretType;         // Caret type

    CDocInfo() {InitDocInfo();} // constructor
    ~CDocInfo();                // destructor

    void    InitDocInfo();
};

const DWORD tomInvalidCpg = 0xFFFF;
const DWORD tomInvalidLCID = 0xFFFE;

// This depends on the number of property bits defined in textserv.h. However, this is
// for private use by the text services so it is defined here.
#define MAX_PROPERTY_BITS   21
#define SPF_SETDEFAULT      4

// IDispatch global declarations
extern ITypeInfo *  g_pTypeInfoDoc;
extern ITypeInfo *  g_pTypeInfoSel;
extern ITypeInfo *  g_pTypeInfoFont;
extern ITypeInfo *  g_pTypeInfoPara;
HRESULT GetTypeInfoPtrs();
HRESULT GetTypeInfo(UINT iTypeInfo, ITypeInfo *&pTypeInfo,
                            ITypeInfo **ppTypeInfo);

BOOL IsSameVtables(IUnknown *punk1, IUnknown *punk2);

// Map from keyboard to font. (converse is handled in font.cpp)
typedef struct _kbdFont
{
    WORD    iKbd;
    SHORT   iCF;
} KBDFONT;

DWORD GetCharFlags(DWORD ch, BYTE bDefaultCharset = 0);
CUniscribe* GetUniscribe(void);

#define fBIDI                1
#define fDIGITSHAPE          2

#define fSURROGATE  0x00000010      // (0x10 - 0x80 No fontbind supported)
#define fUNIC_CTRL  0x00000020

/*  The font signature low DWORD has the bit definitions (note: SDK 98
    has Thai - Chinese off by one bit compared to FS_xxx defs in wingdi.h)

    0 1252 Latin 1
    1 1250 Latin 2: Eastern Europe
    2 1251 Cyrillic
    3 1253 Greek
    4 1254 Turkish
    5 1255 Hebrew
    6 1256 Arabic
    7 1257 Baltic
    8 1258 Vietnamese
    9 - 15 Reserved for ANSI
    16 874 Thai
    17 932 JIS/Japan
    18 936 Chinese: Simplified chars--PRC, Hong Kong, Singapore
    19 949 Korean Unified Hangul Code (Hangul TongHabHyung Code)
    20 950 Chinese: Traditional chars--Taiwan

    We define bit masks which are similar to the values above shifted over
    one byte (add 8) to make room for _dwCharFlags
*/
#define fHILATIN1   0x00000100
#define fLATIN2     0x00000200
#define fCYRILLIC   0x00000400
#define fGREEK      0x00000800

#define fTURKISH    0x00001000
#define fHEBREW     0x00002000
#define fARABIC     0x00004000
#define fBALTIC     0x00008000

#define fVIETNAMESE 0x00010000
#define fARMENIAN   0x00020000
#define fOEM        0x00040000
#define fCOMBINING  0x00080000

#define fASCIIUPR   0x00100000      // ASCII 0x40-0x7F
#define fBELOWX40   0x00200000      // ASCII 0x00-0x3F
#define fSYMBOL     0x00400000
#define fOTHER      0x00800000

#define fTHAI       0x01000000
#define fKANA       0x02000000
#define fCHINESE    0x04000000      // Simplified Chinese
#define fHANGUL     0x08000000
#define fBIG5       0x10000000      // Traditional Chinese

#define fDEVANAGARI 0x20000000
#define fTAMIL      0x40000000
#define fGEORGIAN   0x80000000

#define fASCII      (fASCIIUPR | fBELOWX40)
#define fLATIN1     (fASCII | fHILATIN1)
#define fFE         (fKANA | fCHINESE | fBIG5 | fHANGUL)
#define fABOVEX7FF  (fTHAI | fFE | fDEVANAGARI | fTAMIL | fOTHER)
#define fLATIN      (fHILATIN1 | fLATIN2 | fTURKISH | fBALTIC | fVIETNAMESE)

#define fNEEDWORDBREAK      fTHAI
#define fNEEDCHARBREAK      (fTHAI | fDEVANAGARI | fTAMIL)
#define fNEEDCSSEQCHECK     (fTHAI | fDEVANAGARI | fTAMIL)
#define fCOMPLEX_SCRIPT     (fBIDI | fARABIC | fHEBREW | fTHAI | fDEVANAGARI | fTAMIL | fCOMBINING | fDIGITSHAPE | fSURROGATE)

#define RB_DEFAULT      0x00000000  // perform default behavior
#define RB_NOSELCHECK   0x00000001  // for OnTxRButtonUp, bypass pt in selection check
#define RB_FORCEINSEL   0x00000002  // force point into selection (used by keyboard to get context menus)

// flags for OnTxLButtonUp
#define LB_RELEASECAPTURE   0x00000001  // Force release mouse capture
#define LB_FLUSHNOTIFY      0x00000002  // 1.0 mode force selection change notification if selChange is cached

enum AccentIndices
{
    ACCENT_GRAVE = 1,
    ACCENT_ACUTE,
    ACCENT_CARET,
    ACCENT_TILDE,
    ACCENT_UMLAUT,
    ACCENT_CEDILLA
};

#define KBD_CHAR    2       // Must be a bit value > 1

// ==================================  CTxtEdit  ============================================
// Outer most class for a Text Control.

class CTxtEdit : public ITextServices, public IRichEditOle, public ITextDocument2
{
public:
    friend class CCallMgr;
    friend class CMagellanBMPStateWrap;

    CTxtEdit(ITextHost2 *phost, IUnknown *punkOuter);
     ~CTxtEdit ();

    // Initialization
    BOOL        Init(const RECT *prcClient);

    // A helper function
    LONG GetTextLength() const  {return _story.GetTextLength();}
    LONG GetAdjustedTextLength();

    // Access to ActiveObject members

    IUnknown *      GetPrivateIUnknown()    { return &_unk; }
    CLightDTEngine *GetDTE()                { return &_ldte; }

    IUndoMgr *      GetUndoMgr()            { return _pundo; }
    IUndoMgr *      GetRedoMgr()            { return _predo; }
    IUndoMgr *      CreateUndoMgr(DWORD dwLim, USFlags flags);
    CCallMgr *      GetCallMgr()            {
                                                Assert(_pcallmgr);
                                                return _pcallmgr;
                                            }

    CObjectMgr *    GetObjectMgr();
                    // the callback is provided by the client
                    // to help with OLE support
    BOOL            HasObjects()            {return !!_pobjmgr;}
    IRichEditOleCallback *GetRECallback()
        { return _pobjmgr ? _pobjmgr->GetRECallback() : NULL; }
    LRESULT         HandleSetUndoLimit(LONG Count);
    LRESULT         HandleSetTextMode(DWORD mode);

    CNotifyMgr *    GetNotifyMgr();

    CDetectURL *    GetDetectURL()          {return _pdetecturl;}

    CUniscribe *    Getusp() const          {return GetUniscribe();}

#if !defined(NOMAGELLAN)
    CMagellan       mouse;
    LRESULT         HandleMouseWheel(WPARAM wparam, LPARAM lparam);
#endif

    // Misc helpers
    LONG            GetAcpFromCp(LONG cp, BOOL fPrecise=0);
    LONG            GetCpFromAcp(LONG acp, BOOL fPrecise=0);
    BOOL            Get10Mode() const           {return _f10Mode;}
    LONG            GetCpAccelerator() const    {return _cpAccelerator;}
    short           GetFreezeCount() const      {return _cFreeze;}

    BOOL            fCpMap() const              {return _f10Mode;}
    BOOL            fInOurHost() const          {return _fInOurHost;}
    BOOL            fInplaceActive() const      {return _fInPlaceActive;}
    BOOL            fHideSelection() const      {return _fHideSelection;}
    BOOL            fXltCRCRLFtoCR() const      {return _fXltCRCRLFtoCR;}
    BOOL            fUsePassword() const        {return _fUsePassword;}
    BOOL            fUseCRLF() const            {return _f10Mode;}
    BOOL            fUseLineServices() const    {return _bTypography & TO_ADVANCEDTYPOGRAPHY;}
    BOOL            fUseSimpleLineBreak() const {return (_bTypography & TO_SIMPLELINEBREAK) != 0;}
    BOOL            IsAutoFont() const          {return _fAutoFont;};
    BOOL            IsAutoKeyboard() const      {return _fAutoKeyboard;};
    BOOL            IsAutoFontSizeAdjust() const{return _fAutoFontSizeAdjust;};
    BOOL            IsBiDi() const              {return (_dwCharFlags & fBIDI) != 0;}
    BOOL            IsComplexScript() const     {return _dwCharFlags & fCOMPLEX_SCRIPT;}
    BOOL            IsFE() const                {return (_dwCharFlags & fFE) != 0;}
    BOOL            IsInOutlineView() const     {return _fOutlineView;}
    BOOL            IsMouseDown() const         {return _fMouseDown;}
    BOOL            IsRich() const              {return _fRich;}
    BOOL            IsLeftScrollbar() const;
    BOOL            IsSelectionBarRight() const {return IsLeftScrollbar(); }
    void            SetfSelChangeCharFormat()   {_fSelChangeCharFormat = TRUE; }
    BOOL            DelayChangeNotification()   {return _f10DeferChangeNotify;}
    BOOL            GetOOMNotified()            {return _fOOMNotified;}


    void    SetOOMNotified(BOOL ff)
            {
                Assert(ff == 1 || ff == 0);
                _fOOMNotified = ff;
            }


    //plain-text controls always use the UIFont
    bool            fUseUIFont() const          {return !_fRich || _fUIFont;}
    BOOL            IsTransparent()             {return _fTransparent;}

    LONG            GetZoomNumerator() const    {return _wZoomNumerator;}
    LONG            GetZoomDenominator() const  {return _wZoomDenominator;}
    void            SetZoomNumerator(LONG x)    {_wZoomNumerator = (WORD)x;}
    void            SetZoomDenominator(LONG x)  {_wZoomDenominator = (WORD)x;}
    DWORD           GetCpFirstStrong()          {return _cpFirstStrong;}
    void            SetReleaseHost();
    DWORD           GetCharFlags() const        {return _dwCharFlags;}
    void            OrCharFlags(DWORD dwFlags, IUndoBuilder* publdr = NULL);
    void            Beep();
    void            HandleKbdContextMenu();
    void            Set10Mode();
    void            SetContextDirection(BOOL fUseKbd = FALSE);
    void            ItemizeDoc(IUndoBuilder* publdr = NULL, LONG cchRange = -1);
    HRESULT         UpdateAccelerator();
    HRESULT         UpdateOutline();
    HRESULT         MoveSelection(LPARAM lparam, IUndoBuilder *publdr);
    HRESULT         PopAndExecuteAntiEvent(IUndoMgr *pundomgr, void *pAE);

    HRESULT         CutOrCopySelection(UINT msg, WPARAM wparam, LPARAM lparam,
                                       IUndoBuilder *publdr);

    HRESULT         PasteDataObjectToRange(
                        IDataObject *pdo,
                        CTxtRange *prg,
                        CLIPFORMAT cf,
                        REPASTESPECIAL *rps,
                        IUndoBuilder *publdr,
                        DWORD dwFlags );

    // Story access
    CTxtStory * GetTxtStory () {return &_story;}

    // Get access to cached CCharFormat and CParaFormat structures
    const CCharFormat*  GetCharFormat(LONG iCF)
                            {return _story.GetCharFormat(iCF);}
    const CParaFormat*  GetParaFormat(LONG iPF)
                            {return _story.GetParaFormat(iPF);}

    LONG        Get_iCF()           {return _story.Get_iCF();}
    LONG        Get_iPF()           {return _story.Get_iPF();}
    void        Set_iCF(LONG iCF)   {_story.Set_iCF(iCF);}
    void        Set_iPF(LONG iPF)   {_story.Set_iPF(iPF);}

    HRESULT     HandleStyle(CCharFormat *pCFTarget, const CCharFormat *pCF,
                            DWORD dwMask, DWORD dwMask2);
    HRESULT     HandleStyle(CParaFormat *pPFTarget, const CParaFormat *pPF,
                            DWORD dwMask);

    // Get host interface pointer
    ITextHost2 *GetHost() {return _phost;}

    // Helper for getting CDocInfo ptr and creating it if NULL
    CDocInfo *  GetDocInfo();
    HRESULT     InitDocInfo();

    LONG        GetDefaultTab()
                    {return _pDocInfo ? _pDocInfo->dwDefaultTabStop : lDefaultTab;};
    HRESULT     SetDefaultLCID   (LCID lcid);
    HRESULT     GetDefaultLCID   (LCID *pLCID);
    HRESULT     SetDefaultLCIDFE (LCID lcid);
    HRESULT     GetDefaultLCIDFE (LCID *pLCID);
    HRESULT     SetDocumentType  (LONG DocType);
    HRESULT     GetDocumentType  (LONG *pDocType);
    HRESULT     GetFollowingPunct(LPSTR *plpstrFollowingPunct);
    HRESULT     SetFollowingPunct(LPSTR lpstrFollowingPunct);
    HRESULT     GetLeadingPunct  (LPSTR *plpstrLeadingPunct);
    HRESULT     SetLeadingPunct  (LPSTR lpstrLeadingPunct);
    HRESULT     GetViewKind      (LRESULT *plres);
    HRESULT     SetViewKind      (long Value);
    HRESULT     GetViewScale     (long *pValue);
    HRESULT     SetViewScale     (long Value);

    // Notification Management Methods.  In principle, these methods
    // could form a separate class, but for space savings, they are part
    // of the CTxtEdit class

    HRESULT     TxNotify(DWORD iNotify, void *pv);  //@cmember General-purpose
                                                    // notification
    void        SendScrollEvent(DWORD iNotify);     //@cmember Send scroll
                                                    //  event
    void        SendUpdateEvent();                  //@cmember Send EN_UPDATE
                                                    //  event
                                                    //@cmember Use EN_PROTECTED
    BOOL        QueryUseProtection( CTxtRange *prg, //  to query protection
                    UINT msg,WPARAM wparam, LPARAM lparam);//  usage
                                                    //@cmember Indicates whether
                                                    // protection checking enabled
    BOOL        IsProtectionCheckingEnabled()
                    {return !!(_dwEventMask & ENM_PROTECTED);}

    // FUTURE (alexgo): maybe we can use just one method :-)
    BOOL        IsntProtectedOrReadOnly(UINT msg, WPARAM wparam, LPARAM lparam);

    BOOL        IsProtected(UINT msg, WPARAM wparam, LPARAM lparam);
    BOOL        IsProtectedRange(UINT msg, WPARAM wparam, LPARAM lparam, CTxtRange *prg);

    void        SetStreaming(BOOL flag) {_fStreaming = flag;}
    BOOL        IsStreaming()           {return _fStreaming;}

    DWORD       GetEventMask(){return _dwEventMask;}//@cmember Get event mask
                                                    //@cmember Handles EN_LINK
    BOOL        HandleLinkNotification(UINT msg, WPARAM wparam, LPARAM lparam,
                    BOOL *pfInLink = NULL);

    HRESULT     CloseFile (BOOL bSave);

    // Helper for determine when to load message filter
    BOOL LoadMsgFilter (UINT msg, WPARAM wparam, LPARAM lparam);

    //--------------------------------------------------------------
    // Inline proxies to ITextHost methods
    //--------------------------------------------------------------

    // Persisted properties (persisted by the host)
    // Get methods: called by the Text Services component to get
    // the value of a given persisted property

    // FUTURE (alexgo) !! some of these need to get cleaned up

    BOOL        TxGetAutoSize() const;
    BOOL        TxGetAutoWordSel() const;
    COLORREF    TxGetBackColor() const          {return _phost->TxGetSysColor(COLOR_WINDOW);}
    TXTBACKSTYLE TxGetBackStyle() const;
    HRESULT     TxGetDefaultCharFormat(CCharFormat *pCF, DWORD &dwMask);

    void        TxGetClientRect(LPRECT prc) const {_phost->TxGetClientRect(prc);}
    HRESULT     TxGetExtent(SIZEL *psizelExtents)
                    {return _phost->TxGetExtent(psizelExtents);}
    COLORREF    TxGetForeColor() const          {return _phost->TxGetSysColor(COLOR_WINDOWTEXT);}
    DWORD       TxGetMaxLength() const;
    void        TxSetMaxToMaxText(LONG cExtra = 0);
    BOOL        TxGetModified() const           {return _fModified;}
    HRESULT     TxGetDefaultParaFormat(CParaFormat *pPF);
    TCHAR       TxGetPasswordChar() const;
    BOOL        TxGetReadOnly() const           {return _fReadOnly;}
    BOOL        TxGetSaveSelection() const;
    DWORD       TxGetScrollBars() const ;
    LONG        TxGetSelectionBarWidth() const;
    void        TxGetViewInset(LPRECT prc, CDisplay *pdp) const;
    BOOL        TxGetWordWrap() const;

    BOOL        TxClientToScreen (LPPOINT lppt) {return _phost->TxClientToScreen(lppt); }
    BOOL        TxScreenToClient (LPPOINT lppt) {return _phost->TxScreenToClient(lppt); }


    //  ITextServices 2 wrappers
    BOOL        TxIsDoubleClickPending();
    HRESULT     TxGetWindow(HWND *phwnd);
    HRESULT     TxSetForegroundWindow();
    HPALETTE    TxGetPalette();
    HRESULT     TxGetFEFlags(LONG *pFEFlags);

    // Allowed only when in in-place
    // The host will fail if not in-place
    HDC         TxGetDC()               {return _phost->TxGetDC();}
    INT         TxReleaseDC(HDC hdc)    {return _phost->TxReleaseDC(hdc);}

    // Helper functions for metafile support
    INT         TxReleaseMeasureDC( HDC hMeasureDC );

    void        TxUpdateWindow()
                {
                    _phost->TxViewChange(_fInPlaceActive ? TRUE : FALSE);
                }
    void        TxScrollWindowEx (INT dx, INT dy, LPCRECT lprcScroll, LPCRECT lprcClip,
                                HRGN hrgnUpdate, LPRECT lprcUpdate, UINT fuScroll);

    void        TxSetCapture(BOOL fCapture)
                                        {_phost->TxSetCapture(fCapture);}
    void        TxSetFocus()
                                        {_phost->TxSetFocus();}

    // Allowed any-time

    BOOL        TxShowScrollBar(INT fnBar, BOOL fShow)
                                        {return _phost->TxShowScrollBar(fnBar, fShow);}
    BOOL        TxEnableScrollBar (INT fuSBFlags, INT fuArrowFlags)
                                        {return _phost->TxEnableScrollBar(fuSBFlags, fuArrowFlags);}
    BOOL        TxSetScrollRange(INT fnBar, LONG nMinPos, INT nMaxPos, BOOL fRedraw)
                                        {return _phost->TxSetScrollRange(fnBar, nMinPos, nMaxPos, fRedraw);}
    BOOL        TxSetScrollPos (INT fnBar, INT nPos, BOOL fRedraw)
                                        {return _phost->TxSetScrollPos(fnBar, nPos, fRedraw);}
    void        TxInvalidateRect(const LPRECT prc, BOOL fMode)
                                        {_phost->TxInvalidateRect(prc, fMode);}
    BOOL        TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight)
                                        {return _phost->TxCreateCaret(hbmp, xWidth, yHeight);}
    BOOL        TxShowCaret(BOOL fShow)
                                        {return _phost->TxShowCaret(fShow);}
    BOOL        TxSetCaretPos(INT x, INT y)
                                        {return _phost->TxSetCaretPos(x, y);}
    BOOL        TxSetTimer(UINT idTimer, UINT uTimeout)
                                        {return _phost->TxSetTimer(idTimer, uTimeout);}
    void        TxKillTimer(UINT idTimer)
                                        {_phost->TxKillTimer(idTimer);}
    COLORREF    TxGetSysColor(int nIndex){ return _phost->TxGetSysColor(nIndex);}

    int         TxWordBreakProc(TCHAR* pch, INT ich, INT cb, INT action, LONG cpStart, LONG cp = -1);

    // IME
    HIMC        TxImmGetContext()       {return _phost->TxImmGetContext();}
    void        TxImmReleaseContext(HIMC himc)
                                        {_phost->TxImmReleaseContext( himc );}

    // Selection access
    CTxtSelection *GetSel();
    CTxtSelection *GetSelNC() { return _psel; }
    LONG    GetSelMin() const;
    LONG    GetSelMost() const;
    void    GetSelRangeForRender(LONG *pcpSelMin, LONG *pcpSelMost);
    void    DiscardSelection();


    // Property Change Helpers
    HRESULT OnRichEditChange(BOOL fFlag);
    HRESULT OnTxMultiLineChange(BOOL fMultiLine);
    HRESULT OnTxReadOnlyChange(BOOL fReadOnly);
    HRESULT OnShowAccelerator(BOOL fPropertyFlag);
    HRESULT OnUsePassword(BOOL fPropertyFlag);
    HRESULT OnTxHideSelectionChange(BOOL fHideSelection);
    HRESULT OnSaveSelection(BOOL fPropertyFlag);
    HRESULT OnAutoWordSel(BOOL fPropertyFlag);
    HRESULT OnTxVerticalChange(BOOL fVertical);
    HRESULT NeedViewUpdate(BOOL fPropertyFlag);
    HRESULT OnWordWrapChange(BOOL fPropertyFlag);
    HRESULT OnAllowBeep(BOOL fPropertyFlag);
    HRESULT OnDisableDrag(BOOL fPropertyFlag);
    HRESULT OnTxBackStyleChange(BOOL fPropertyFlag);
    HRESULT OnMaxLengthChange(BOOL fPropertyFlag);
    HRESULT OnCharFormatChange(BOOL fPropertyFlag);
    HRESULT OnParaFormatChange(BOOL fPropertyFlag);
    HRESULT OnClientRectChange(BOOL fPropertyFlag);
    HRESULT OnScrollChange(BOOL fProperyFlag);
    HRESULT OnSetTypographyOptions(WPARAM wparam, LPARAM lparam);
    HRESULT OnHideSelectionChange(BOOL fHideSelection);

    // Helpers
    HRESULT TxCharFromPos(LPPOINT ppt, LRESULT *pacp);
    HRESULT OnTxUsePasswordChange(BOOL fUsePassword);
    HRESULT FormatAndPrint(
                HDC hdcDraw,
                HDC hicTargetDev,
                DVTARGETDEVICE *ptd,
                RECT *lprcBounds,
                RECT *lprcWBounds);

    HRESULT RectChangeHelper(
                CDrawInfo *pdi,
                DWORD dwDrawAspect,
                LONG  lindex,
                void *pvAspect,
                DVTARGETDEVICE *ptd,
                HDC hdcDraw,
                HDC hicTargetDev,
                const RECT **pprcClient,
                RECT *prcLocal);

    //
    // PUBLIC INTERFACE METHODS
    //

    // -----------------------------
    //  IUnknown interface
    // -----------------------------

    virtual HRESULT     WINAPI QueryInterface(REFIID riid, void **ppvObject);
    virtual ULONG       WINAPI AddRef(void);
    virtual ULONG       WINAPI Release(void);

    //--------------------------------------------------------------
    // ITextServices methods
    //--------------------------------------------------------------
    //@cmember Generic Send Message interface
    virtual HRESULT     TxSendMessage(
                            UINT msg,
                            WPARAM wparam,
                            LPARAM lparam,
                            LRESULT *plresult);

    //@cmember Rendering
    virtual HRESULT     TxDraw(
                            DWORD dwDrawAspect,     // draw aspect
                            LONG  lindex,           // currently unused
                            void * pvAspect,        // info for drawing
                                                    // optimizations (OCX 96)
                            DVTARGETDEVICE * ptd,   // information on target
                                                    // device                               '
                            HDC hdcDraw,            // rendering device context
                            HDC hicTargetDev,       // target information
                                                    // context
                            LPCRECTL lprcBounds,    // bounding (client)
                                                    // rectangle
                            LPCRECTL lprcWBounds,   // clipping rect for
                                                    // metafiles
                            LPRECT lprcUpdate,      // dirty rectange insde
                                                    // lprcBounds
                            BOOL (CALLBACK * pfnContinue) (DWORD), // for
                                                    // interupting
                            DWORD dwContinue,       // long displays (currently
                                                    // unused)
                            LONG lViewID);          // Specifies view to redraw

    //@cmember Horizontal scrollbar support
    virtual HRESULT     TxGetHScroll(
                            LONG *plMin,
                            LONG *plMax,
                            LONG *plPos,
                            LONG *plPage,
                            BOOL * pfEnabled );

    //@cmember Horizontal scrollbar support
    virtual HRESULT     TxGetVScroll(
                            LONG *plMin,
                            LONG *plMax,
                            LONG *plPos,
                            LONG *plPage,
                            BOOL * pfEnabled );

    //@cmember Setcursor
    virtual HRESULT     OnTxSetCursor(
                            DWORD dwDrawAspect,     // draw aspect
                            LONG  lindex,           // currently unused
                            void * pvAspect,        // info for drawing
                                                    // optimizations (OCX 96)
                            DVTARGETDEVICE * ptd,   // information on target
                                                    // device                               '
                            HDC hdcDraw,            // rendering device context
                            HDC hicTargetDev,       // target information
                                                    // context
                            LPCRECT lprcClient,
                            INT x,
                            INT y);

    //@cmember Hit-test
    virtual HRESULT     TxQueryHitPoint(
                            DWORD dwDrawAspect,     // draw aspect
                            LONG  lindex,           // currently unused
                            void * pvAspect,        // info for drawing
                                                    // optimizations (OCX 96)
                            DVTARGETDEVICE * ptd,   // information on target
                                                    // device                               '
                            HDC hdcDraw,            // rendering device context
                            HDC hicTargetDev,       // target information
                                                    // context
                            LPCRECT lprcClient,
                            INT x,
                            INT y,
                            DWORD * pHitResult);

    //@member Inplace activate notification
    virtual HRESULT     OnTxInPlaceActivate(const RECT *prcClient);

    //@member Inplace deactivate notification
    virtual HRESULT     OnTxInPlaceDeactivate();

    //@member UI activate notification
    virtual HRESULT     OnTxUIActivate();

    //@member UI deactivate notification
    virtual HRESULT     OnTxUIDeactivate();

    //@member Get text in control
    virtual HRESULT     TxGetText(BSTR *pbstrText);

    //@member Set text in control
    virtual HRESULT     TxSetText(LPCTSTR pszText);

    //@member Get x position of
    virtual HRESULT     TxGetCurTargetX(LONG *);
    //@member Get baseline position
    virtual HRESULT     TxGetBaseLinePos(LONG *);

    //@member Get Size to fit / Natural size
    virtual HRESULT     TxGetNaturalSize(
                            DWORD dwAspect,
                            HDC hdcDraw,
                            HDC hicTargetDev,
                            DVTARGETDEVICE *ptd,
                            DWORD dwMode,
                            const SIZEL *psizelExtent,
                            LONG *pwidth,
                            LONG *pheight);

    //@member Drag & drop
    virtual HRESULT     TxGetDropTarget( IDropTarget **ppDropTarget );

    //@member Bulk bit property change notifications
    virtual HRESULT     OnTxPropertyBitsChange(DWORD dwMask, DWORD dwBits);

    //@cmember Fetch the cached drawing size
    virtual HRESULT     TxGetCachedSize(DWORD *pdwWidth, DWORD *pdwHeight);

    //  IDispatch methods

    STDMETHOD(GetTypeInfoCount)( UINT * pctinfo);

    STDMETHOD(GetTypeInfo)(

      UINT itinfo,
      LCID lcid,
      ITypeInfo **pptinfo);

    STDMETHOD(GetIDsOfNames)(

      REFIID riid,
      OLECHAR **rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid);

    STDMETHOD(Invoke)(

      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pdispparams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr);


    // ITextDocument2 methods
    STDMETHOD(GetName)(BSTR *pName);
    STDMETHOD(GetSelection)(ITextSelection **ppSel);
    STDMETHOD(GetStoryCount)(long *pCount);
    STDMETHOD(GetStoryRanges)(ITextStoryRanges **ppStories);
    STDMETHOD(GetSaved)(long *pValue);
    STDMETHOD(SetSaved)(long Value);
    STDMETHOD(GetDefaultTabStop)(float *pValue);
    STDMETHOD(SetDefaultTabStop)(float Value);
    STDMETHOD(New)();
    STDMETHOD(Open)(VARIANT *pVar, long Flags, long CodePage);
    STDMETHOD(Save)(VARIANT *pVar, long Flags, long CodePage);
    STDMETHOD(Freeze)(long *pCount);
    STDMETHOD(Unfreeze)(long *pCount);
    STDMETHOD(BeginEditCollection)();
    STDMETHOD(EndEditCollection)();
    STDMETHOD(Undo)(long Count, long *prop);
    STDMETHOD(Redo)(long Count, long *prop);
    STDMETHOD(Range)(long cpFirst, long cpLim, ITextRange ** ppRange);
    STDMETHOD(RangeFromPoint)(long x, long y, ITextRange **ppRange);
    STDMETHOD(AttachMsgFilter)(IUnknown *pFilter);
    STDMETHOD(GetEffectColor)( long Index, COLORREF *pcr);
    STDMETHOD(SetEffectColor)( long Index, COLORREF cr);
    STDMETHOD(GetCaretType)( long *pCaretType);
    STDMETHOD(SetCaretType)( long CaretType);
    STDMETHOD(GetImmContext)( long *pContext);
    STDMETHOD(ReleaseImmContext)( long Context);
    STDMETHOD(GetPreferredFont)( long cp, long CodePage, long lOption, long curCodepage,
        long curFontSize, BSTR *pFontName, long *pPitchAndFamily, long *pNewFontSize);
    STDMETHOD(GetNotificationMode)( long *plMode);
    STDMETHOD(SetNotificationMode)( long lMode);
    STDMETHOD(GetClientRect)( long Type, long *pLeft, long *pTop, long *pRight, long *pBottom);
    STDMETHOD(GetSelectionEx)(ITextSelection **ppSel);
    STDMETHOD(GetWindow)( long *phWnd );
    STDMETHOD(GetFEFlags)( long *pFlags );
    STDMETHOD(UpdateWindow)( void );
    STDMETHOD(CheckTextLimit)( long cch, long *pcch );
    STDMETHOD(IMEInProgress)( long lMode );
    STDMETHOD(SysBeep)( void );
    STDMETHOD(Update)( long lMode );
    STDMETHOD(Notify)( long lNotify );

    // IRichEditOle methods
    STDMETHOD(GetClientSite) ( LPOLECLIENTSITE  *lplpolesite);
    STDMETHOD_(LONG,GetObjectCount) (THIS);
    STDMETHOD_(LONG,GetLinkCount) (THIS);
    STDMETHOD(GetObject) ( LONG iob, REOBJECT  *lpreobject,
                          DWORD dwFlags);
    STDMETHOD(InsertObject) ( REOBJECT  *lpreobject);
    STDMETHOD(ConvertObject) ( LONG iob, REFCLSID rclsidNew,
                              LPCSTR lpstrUserTypeNew);
    STDMETHOD(ActivateAs) ( REFCLSID rclsid, REFCLSID rclsidAs);
    STDMETHOD(SetHostNames) ( LPCSTR lpstrContainerApp,
                             LPCSTR lpstrContainerObj);
    STDMETHOD(SetLinkAvailable) ( LONG iob, BOOL fAvailable);
    STDMETHOD(SetDvaspect) ( LONG iob, DWORD dvaspect);
    STDMETHOD(HandsOffStorage) ( LONG iob);
    STDMETHOD(SaveCompleted) ( LONG iob, LPSTORAGE lpstg);
    STDMETHOD(InPlaceDeactivate) (THIS);
    STDMETHOD(ContextSensitiveHelp) ( BOOL fEnterMode);
    STDMETHOD(GetClipboardData) ( CHARRANGE  *lpchrg, DWORD reco,
                                    LPDATAOBJECT  *lplpdataobj);
    STDMETHOD(ImportDataObject) ( LPDATAOBJECT lpdataobj,
                                    CLIPFORMAT cf, HGLOBAL hMetaPict);


private:

    // Get/Set text helpers
    LONG    GetTextRange(LONG cpFirst, LONG cch, TCHAR *pch);
    LONG    GetTextEx(GETTEXTEX *pgt, TCHAR *pch);
    LONG    GetTextLengthEx(GETTEXTLENGTHEX *pgtl);

    //--------------------------------------------------------------
    // WinProc dispatch methods
    // Internally called by the WinProc
    //--------------------------------------------------------------

    // Keyboard
    HRESULT OnTxKeyDown       (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxChar          (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxSysChar       (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxSysKeyDown    (WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxSpecialKeyDown(WORD vkey, DWORD dwFlags, IUndoBuilder *publdr);

    // Mouse
    HRESULT OnTxLButtonDblClk(INT x, INT y, DWORD dwFlags);
    HRESULT OnTxLButtonDown  (INT x, INT y, DWORD dwFlags);
    HRESULT OnTxLButtonUp    (INT x, INT y, DWORD dwFlags, int ffOptions);
    HRESULT OnTxRButtonDown  (INT x, INT y, DWORD dwFlags);
    HRESULT OnTxRButtonUp    (INT x, INT y, DWORD dwFlags, int ffOptions);
    HRESULT OnTxMouseMove    (INT x, INT y, DWORD dwFlags, IUndoBuilder *publdr);
    HRESULT OnTxMButtonDown  (INT x, INT y, DWORD dwFlags);
    HRESULT OnTxMButtonUp    (INT x, INT y, DWORD dwFlags);
    HCURSOR TxSetCursor(HCURSOR hcur, BOOL bText)
    {
        return (_phost && _fInOurHost) ? (_phost)->TxSetCursor2(hcur, bText) :
                ::SetCursor(hcur);
    }

    // Timer
    HRESULT OnTxTimer(UINT idTimer);
    void CheckInstallContinuousScroll ();
    void CheckRemoveContinuousScroll ();

    // Scrolling
    HRESULT TxHScroll(WORD wCode, int xPos);
    LRESULT TxVScroll(WORD wCode, int yPos);
    HRESULT TxLineScroll(LONG cli, LONG cach);

    // Magellan mouse scrolling
    BOOL StopMagellanScroll();

    // Paint, size message
    LRESULT OnSize(HWND hwnd, WORD fwSizeType, int nWidth, int nHeight);

    // Selection commands
    LRESULT OnGetSelText(TCHAR *psz);
    LRESULT OnGetSel(LONG *pacpMin, LONG *pacpMost);
    LRESULT OnSetSel(LONG acpMin, LONG acpMost);
    void    OnExGetSel(CHARRANGE *pcr);

    // Editing commands
    void    OnClear(IUndoBuilder *publdr);

    // Format range related commands
    LRESULT OnFormatRange(FORMATRANGE *pfr, SPrintControl prtcon, BOOL fSetupDC = FALSE);

    BOOL    OnDisplayBand(const RECT *prc, BOOL fPrintFromDraw);

    // Scrolling commands
    void    OnScrollCaret();

    // Focus messages
    LRESULT OnSetFocus();
    LRESULT OnKillFocus();

    // System notifications
    HRESULT OnContextMenu(LPARAM lparam);

    // Get/Set other properties commands
    LRESULT OnFindText(UINT msg, DWORD flags, FINDTEXTEX *pftex);
    LRESULT OnGetWordBreakProc();
    LRESULT OnSetWordBreakProc();

    // Richedit stuff

    LRESULT OnGetCharFormat(CHARFORMAT2 *pCF2, DWORD dwFlags);
    LRESULT OnGetParaFormat(PARAFORMAT2 *pPF2, DWORD dwFlags);
    LRESULT OnSetCharFormat(WPARAM wparam, CCharFormat *pCF, IUndoBuilder *publdr,
                            DWORD dwMask, DWORD dwMask2);
    LRESULT OnSetParaFormat(WPARAM wparam, CParaFormat *pPF, IUndoBuilder *publdr,
                            DWORD dwMask);
    LRESULT OnSetFont(HFONT hfont);
    LRESULT OnSetFontSize(LONG yPoint, IUndoBuilder *publdr);

    LRESULT OnDropFiles(HANDLE hDropFiles);

    // Other services
    HRESULT TxPosFromChar(LONG acp, LPPOINT ppt);
    HRESULT TxGetLineCount(LRESULT *plres);
    HRESULT TxLineFromCp(LONG acp, LRESULT *plres);
    HRESULT TxLineLength(LONG acp, LRESULT *plres);
    HRESULT TxLineIndex (LONG ili, LRESULT *plres);
    HRESULT TxFindText(DWORD flags, LONG acpMin, LONG acpMost, const WCHAR *pch,
                       LONG *pacpMin, LONG *pacpMost);
    HRESULT TxFindWordBreak(INT nFunction, LONG acp, LRESULT *plres);

    HRESULT SetText(LPCWSTR pwszText, DWORD flags, LONG CodePage,
                    IUndoBuilder *publdr = NULL, LRESULT *plres = NULL);
    LONG    GetDefaultCodePage(UINT msg);


    // Other miscelleneous
#ifdef DEBUG
    void    OnDumpPed();
#endif

    COleObject * ObjectFromIOB(LONG iob);

    // Only when the selection is going away should this value be NULLed. We
    // use SelectionNull function rather than CTxtSelection::~CTxtSelection
    // to avoid circular dependencies.
    friend void SelectionNull(CTxtEdit *ped);
    void    SetSelectionToNull()
            {if(_fFocus)
                DestroyCaret();
                _psel = NULL;
            }

    // Helper for converting a rich text object to plain text.
    void HandleRichToPlainConversion();

    // Helper for clearing the undo buffers.
    void ClearUndo(IUndoBuilder *publdr);

    // Helper for setting the automatic EOP
    void SetRichDocEndEOP(LONG cchToReplace);

#ifndef MACPORT
    // Helper for OnDropFiles.  Not present on the Macintosh
    LRESULT CTxtEdit::InsertFromFile ( LPCTSTR lpFile );
#endif
//
//  Data Members
//

public:
    static DWORD        _dwTickDblClick;    // time of last double-click
    static POINT        _ptDblClick;        // position of last double-click

    static HCURSOR      _hcurArrow;
//  static HCURSOR      _hcurCross;         // OutlineSymbol drag not impl
    static HCURSOR      _hcurHand;
    static HCURSOR      _hcurIBeam;
    static HCURSOR      _hcurItalic;
    static HCURSOR      _hcurSelBar;

    typedef HRESULT (CTxtEdit::*FNPPROPCHG)(BOOL fPropFlag);

    static FNPPROPCHG   _fnpPropChg[MAX_PROPERTY_BITS];

    // Only wrapper functions should use this member...
    ITextHost2*         _phost;     // host

    // word break procedure
    EDITWORDBREAKPROC   _pfnWB;     // word break procedure

    // display subsystem
    CDisplay *          _pdp;       // display
    CDisplayPrinter *   _pdpPrinter;// display for printer

    // undo
    IUndoMgr *          _pundo;     // the undo stack
    IUndoMgr *          _predo;     // the redo stack

    // data transfer
    CLightDTEngine      _ldte;      // the data transfer engine

    CNotifyMgr          _nm;        // the notification manager (for floating

    // OLE support
    CObjectMgr *        _pobjmgr;   // handles most high-level OLE stuff

    // Re-entrancy && Notification Management
    CCallMgr *          _pcallmgr;

    // URL detection
    CDetectURL *        _pdetecturl;// manages auto-detection of URL strings

    CDocInfo *          _pDocInfo;  // Document info (name, flags, code page)

    CTxtBreaker *       _pbrk;      // text-breaker object

    DWORD               _dwEventMask;           // Event mask

    union
    {
      DWORD _dwFlags;               // All together now
      struct
      {

#define TXTBITS (TXTBIT_RICHTEXT      | \
                 TXTBIT_READONLY      | \
                 TXTBIT_USEPASSWORD   | \
                 TXTBIT_HIDESELECTION | \
                 TXTBIT_VERTICAL      | \
                 TXTBIT_ALLOWBEEP    | \
                 TXTBIT_DISABLEDRAG   )

        //  State information. Flags in TXTBITS must appear in same bit
        //  positions as the following (saves code in Init())

        //  TXTBIT_RICHTEXT         0   _fRich
        //  TXTBIT_MULTILINE        1
        //  TXTBIT_READONLY         2   _fReadOnly
        //  TXTBIT_SHOWACCELERATOR  3
        //  TXTBIT_USEPASSWORD      4   _fUsePassword
        //  TXTBIT_HIDESELECTION    5   _fHideSelection
        //  TXTBIT_SAVESELECTION    6
        //  TXTBIT_AUTOWORDSEL      7
        //  TXTBIT_VERTICAL         8
        //  TXTBIT_SELECTIONBAR     9
        //  TXTBIT_WORDWRAP         10
        //  TXTBIT_ALLOWBEEP        11  _fAllowBeep
        //  TXTBIT_DISABLEDRAG      12  _fDisableDrag
        //  TXTBIT_VIEWINSETCHANGE  13
        //  TXTBIT_BACKSTYLECHANGE  14
        //  TXTBIT_MAXLENGTHCHANGE  15
        //  TXTBIT_SCROLLBARCHANGE  16
        //  TXTBIT_CHARFORMATCHANGE 17
        //  TXTBIT_PARAFORMATCHANGE 18
        //  TXTBIT_EXTENTCHANGE     19
        //  TXTBIT_CLIENTRECTCHANGE 20

#ifdef MACPORT
//NOTE: Different BIT ordering on the MAC requires that we flip the following bit fields.
//      This is because they are unioned with _dwFlags which is bit compared using the
//      TXTBIT_xxx flags
//      IMPORTANT: For Mac, all 32 bits must be filled out, else they'll be shifted.

        DWORD   _fUpdateSelection   :1; // 31: If true, update sel at level 0
        DWORD   _fDragged           :1; // 30: Was the selection actually dragged?
        DWORD   _fKoreanBlockCaret  :1; // 29: Display Korean block caret during Kor IME
        DWORD   _fCheckAIMM         :1; // 28: if FALSE check if client has loaded AIMM
        DWORD   _fInOurHost         :1; // 27: Whether we are in our host
        DWORD   _fSaved             :1; // 26: ITextDocument Saved property
        DWORD   _fHost2             :1; // 25: TRUE iff _phost is a phost2
        DWORD   _fMButtonCapture    :1; // 24: captured mButton down.
        DWORD   _fContinuousScroll  :1; // 23: We have a timer running to support scrolling.

        // Font binding (see also _fAutoFontSizeAdjust)
        DWORD   _fAutoKeyboard      :1; // 22: auto switching keyboard
        DWORD   _fAutoFont          :1; // 21: auto switching font

        // Miscellaneous bits
        DWORD   _fUseUndo           :1; // 20: Only set to zero if undo limit is 0
        DWORD   _f10Mode            :1; // 19: Use Richedit10 behavior

        DWORD   _fRichPrevAccel     :1; // 18: Rich state previous to accelerator
        DWORD   _fWantDrag          :1; // 17: Want to initiate drag & drop
        DWORD   _fStreaming         :1; // 16: Currently streaming text in or out
        DWORD   _fScrollCaretOnFocus:1; // 15: Scroll caret into view on set focus
        DWORD   _fModified          :1; // 14: Control text has been modified
        DWORD   _fIconic            :1; // 13: Control/parent window is iconized
        DWORD   _fDisableDrag       :1; // 12: Disable Drag
        DWORD   _fAllowBeep         :1; // 11: Allow beep at doc boundaries
        DWORD   _fTransparent       :1; // 10: Background transparency
        DWORD   _fMouseDown         :1; // 9: One mouse button is current down
        DWORD   _fEatLeftDown       :1; // 8: Eat the next left down?
        DWORD   _fFocus             :1; // 7: Control has keyboard focus
        DWORD   _fOverstrike        :1; // 6: Overstrike mode vs insert mode
        DWORD   _fHideSelection     :1; // 5: Hide selection when inactive
        DWORD   _fUsePassword       :1; // 4: Whether to use password char
        DWORD   _fInPlaceActive     :1; // 3: Control is in place active
        DWORD   _fReadOnly          :1; // 2: Control is read only
        DWORD   _fCapture           :1; // 1: Control has mouse capture
        DWORD   _fRich              :1; // 0: Use rich-text formatting

#else

        DWORD   _fRich              :1; // 0: Use rich-text formatting
        DWORD   _fCapture           :1; // 1: Control has mouse capture
        DWORD   _fReadOnly          :1; // 2: Control is read only
        DWORD   _fInPlaceActive     :1; // 3: Control is in place active
        DWORD   _fUsePassword       :1; // 4: Whether to use password char
        DWORD   _fHideSelection     :1; // 5: Hide selection when inactive
        DWORD   _fOverstrike        :1; // 6: Overstrike mode vs insert mode
        DWORD   _fFocus             :1; // 7: Control has keyboard focus
        DWORD   _fEatLeftDown       :1; // 8: Eat the next left down?
        DWORD   _fMouseDown         :1; // 9: One mouse button is current down
        DWORD   _fTransparent       :1; // 10: Background transparency
        DWORD   _fAllowBeep         :1; // 11: Allow beep at doc boundaries
        DWORD   _fDisableDrag       :1; // 12: Disable Drag

        DWORD   _fIconic            :1; // 13: Control/parent window is iconized
        DWORD   _fModified          :1; // 14: Control text has been modified
        DWORD   _fScrollCaretOnFocus:1; // 15: Scroll caret into view on set focus
        DWORD   _fStreaming         :1; // 16: Currently streaming text in or out
        DWORD   _fWantDrag          :1; // 17: Want to initiate drag & drop
        DWORD   _fRichPrevAccel     :1; // 18: Rich state previous to accelerator

        // Miscellaneous bits
        DWORD   _f10Mode            :1; // 19: Use Richedit10 behavior
        DWORD   _fUseUndo           :1; // 20: Only set to zero if undo limit is 0

        // Font binding (see also _fAutoFontSizeAdjust)
        DWORD   _fAutoFont          :1; // 21: auto switching font
        DWORD   _fAutoKeyboard      :1; // 22: auto switching keyboard

        DWORD   _fContinuousScroll  :1; // 23: Timer runs to support scrolling
        DWORD   _fMButtonCapture    :1; // 24: captured mButton down
        DWORD   _fHost2             :1; // 25: TRUE iff _phost is a phost2
        DWORD   _fSaved             :1; // 26: ITextDocument Saved property
        DWORD   _fInOurHost         :1; // 27: Whether we are in our host
        DWORD   _fCheckAIMM         :1; // 28: if FALSE check if client has loaded AIMM
        DWORD   _fKoreanBlockCaret  :1; // 29: Display Korean block caret during Kor IME

        // Drag/Drop UI refinement.
        DWORD   _fDragged           :1; // 30: Was the selection actually dragged?
        DWORD   _fUpdateSelection   :1; // 31: If true, update sel at level 0
#endif
      };
    };

#define CD_LTR  2
#define CD_RTL  3

    WORD        _nContextDir        :2; // 0: no context; else CD_LTR or CD_RTL
    WORD        _nContextAlign      :2; // Current context alignment; default CTX_NONE
    WORD        _fNeutralOverride   :1; // Override direction of neutrals for layout
    WORD        _fSuppressNotify    :1; // Don't send SelChange Notification if True

    WORD        _cActiveObjPosTries :2; // Counter protecting against infinite repaint
                                        // loop when trying to put dragged-away
                                        // in-place active object where it belongs

    WORD        _fSingleCodePage    :1; // If TRUE, only allow single code page
                                        // (currently doesn't check streaming...)
    WORD        _fSelfDestruct      :1; // This CTxtEdit is selfdestructing
    WORD        _fAutoFontSizeAdjust:1; // Auto switching font size adjust

    // Miscellaneous bits used for BiDi input
    WORD        _fHbrCaps           :1; // Initialization of state of hebrew and caps lock status

    WORD        _fActivateKbdOnFocus:1; // Activate new kbd layout on WM_SETFOCUS
    WORD        _fOutlineView       :1; // Outline view is active

    // More IME bit
    WORD        _fIMEInProgress     :1; // TRUE if IME composition is in progress

    // Shutdown bit
    WORD        _fReleaseHost       :1; // TRUE if edit control needs to release host in
                                        // edit control destructor.

    union
    {
        WORD    _bEditStyle;
        struct
        {
            WORD    _fSystemEditMode    :1; //     1: Behave more like sys edit
            WORD    _fSystemEditBeep    :1; //     2: Beep when system edit does
            WORD    _fExtendBackColor   :1; //     4: Extend BkClr to margin
            WORD    _fUnusedEditStyle1  :1; //     8: SES_MAPCPS not used
            WORD    _fUnusedEditStyle2  :1; //    16: SES_EMULATE10 not used
            WORD    _fUnusedEditStyle3  :1; //    32: SES_USECRLF not used
            WORD    _fUnusedEditStyle4  :1; //    64: SES_USEAIMM handled in cmsgflt
            WORD    _fUnusedEditStyle5  :1; //   128: SES_NOIME handled in cmsgflt
            WORD    _fUnusedEditStyle6  :1; //   256: SES_ALLOWBEEPS not used
            WORD    _fUpperCase         :1; //   512: Convert all input to upper case
            WORD    _fLowerCase         :1; //  1024: Convert all input to lower case
            WORD    _fNoInputSequenceChk:1; //  2048: Disable ISCheck
            WORD    _fBiDi              :1; //  4096: Set Bidi document
            WORD    _fScrollCPOnKillFocus:1;//  8192: Scroll to cp=0 upon Kill focus
            WORD    _fXltCRCRLFtoCR     :1; // 16384: Translate CRCRLF to CR instead of ' '
            WORD    _fUnUsedEditStyle   :1; // 32768: Unused
        };
    };

    WORD        _fOOMNotified           :1; // flag determining if a OOM notification was already sent
    WORD        _fDualFont              :1; // Dual font support for FE typing
                                            //  Default = TRUE
    WORD        _fUIFont                :1; // If TRUE, use UI font
    WORD        _fItemizePending        :1; // Updated range hasn't been itemized
    WORD        _fSelChangeCharFormat   :1; // TRUE if the selection has been used to change
                                            // the character format of a specific set of
                                            // characters. The purpose of this has to do with
                                            // maintaining the illusion of having a default
                                            // charformat on machines whose default language
                                            // is a complex script i.e. Arabic. The idea is
                                            // that all EM_SETCHARFORMAT messages that would
                                            // just update the default format, are converted
                                            // to SCF_ALL so that all the text has the change
                                            // applied to it. Bug 5462 caused this change.
                                            // (a-rsail).
    WORD        _fExWordBreakProc       :1; // detemines which WordbreakProc Callback to use
                                            // Extended or regular
    WORD        _f10DeferChangeNotify   :1; // 1.0 mode immulation, defer selection change
                                            // notification until the mouse is up
    WORD        _fUnUsed                :9; // Available for use

    DWORD       _dwCharFlags;           // Char flags for text in control

private:
    SHORT       _cpAccelerator;         // Range for accelerator
    BYTE        _bTypography;           // Typography options
    BYTE        _bMouseFlags;           // CTRL, Mouse buttons, SHIFT
    SHORT       _cFreeze;               // Freeze count
    WORD        _wZoomNumerator;
    WORD        _wZoomDenominator;

    // Have to have mouse point on a per-instance basis to handle
    // simultaneous scrolling of two or more controls.
    // TODO: convert this back to DWORD from whence it came (lparam)
    POINT       _mousePt;               // Last known mouse position.

    // NOTE: the int's can be switched to SHORTs, since pixels are used and
    // 32768 pixels is a mighty big screen!

    DWORD       _cchTextMost;           // Maximum allowed text

    DWORD       _cpFirstStrong;         // cp of first strong directional character.
                                        // used for plain text controls whose direcitonality
                                        // depends on text input into the control.


    friend class CRchTxtPtr;

    IUnknown *  _punk;                  // IUnknown to use

    class CUnknown : public IUnknown
    {
        friend class CCallMgr;
    private:

        DWORD   _cRefs;                 // Reference count

    public:

        void    Init() {_cRefs = 1; }

        HRESULT WINAPI QueryInterface(REFIID riid, void **ppvObj);
        ULONG WINAPI    AddRef();
        ULONG WINAPI Release();
    };

    friend class CUnknown;

    CUnknown            _unk;               // Object that implements IUnknown
    CTxtStory           _story;
    CTxtSelection *     _psel;              // Selection object
    ITextMsgFilter *    _pMsgFilter;        // Pointer to message filter.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_drwinfo.h ===
/*	@doc INTERNAL
 *
 *	@module _DRWINFO.H  Class to hold draw parameters |
 *	
 *	This declares a class that is used to hold parameters passed from
 *	the host for drawing.
 *
 *	Original Author: <nl>
 *		Rick Sailor
 *
 *	History: <nl>
 *		11/01/95	ricksa	created
 */
#ifndef _DRWINFO_H_
#define _DRWINFO_H_

/*
 *	CArrayBase
 *	
 * 	@class	This class serves as a holder for all the parameters to a draw
 *	except currently the HDC. Access to these parameters will actually come
 *	through the display class.
 *
 *	@devnote Although each operation that takes the parameters for drawing
 *	will create one of these objects, the display keeps only one of these
 *	objects because it will only use the last set of drawing parameters to
 *	draw with. The depth count is used to tell draw whether it is appropriate
 *	to draw or not.
 *
 */
class CDrawInfo
{
//@access Public Methods
public:
						CDrawInfo(CTxtEdit *ped);	//@cmember Initialize object

	void				Init(						//@cmember Fills object 
													//with draw data.
							DWORD dwDrawAspect,	
							LONG  lindex,		
							void *pvAspect,		
							DVTARGETDEVICE *ptd,
							HDC hicTargetDev);	

	DWORD				Release();					//@cmember Dec's ref count

	const CDevDesc *	GetTargetDD();				//@cmember Gets target device

	DWORD				GetDrawDepth() const;		//@cmember Gets depth count

	DWORD 				GetDrawAspect() const;		//@cmember Gets Draw aspect

	LONG 				GetLindex() const;			//@cmember Gets lindex

	void *				GetAspect() const;			//@cmember Gets aspect

	DVTARGETDEVICE *	GetPtd() const;				//@cmember Gets target device
				   									// descriptor.
//@access Private Data
private:

	DWORD				_dwDepth;					//@cmember Max number of
													// users of this information

	DWORD				_cRefs;						//@cmember Number of current
													// users

	CDevDesc			_ddTarget;					//@cmember target device
													// (if any).

	DWORD 				_dwDrawAspect;				//@cmember draw aspect

	LONG  				_lindex;					//@cmember lindex

	void *				_pvAspect;					//@cmember aspect

	DVTARGETDEVICE *	_ptd;						//@cmember target device data
};

/*
 *	CDrawInfo::CDrawInfo
 *
 *	@mfunc	Initializes structure with base required information
 *
 *	@rdesc	Initialized object
 *
 *	@devnote This serves two purposes: (1) CDevDesc requires the ped to 
 *	initalize correctly and (2) We need to make sure that the ref counts
 *	are set to zero since this is created on the stack.
 *	
 */
inline CDrawInfo::CDrawInfo(
	CTxtEdit *ped) 		//@parm Edit object used by the target device
	: _ddTarget(ped), _dwDepth(0), _cRefs(0)							   
{
	// Header does the work
}

/*
 *	CDrawInfo::Init
 *
 *	@mfunc	Initializes object with drawing data
 *
 *	@rdesc	void
 *
 *	@devnote This is separated from the constructor because the display
 * 	only uses one copy of this object so the display may initialize
 *	a different object than the one constructed.
 */
inline void CDrawInfo::Init(
	DWORD dwDrawAspect,	//@parm draw aspect
	LONG  lindex,		//@parm currently unused
	void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,//@parm information on target device								
	HDC hicTargetDev)	//@parm	target information context
{
	_dwDepth++;
	_cRefs++;
	_dwDrawAspect = dwDrawAspect;
	_lindex = lindex;
	_pvAspect = pvAspect;
	_ptd = ptd;

	if (hicTargetDev != NULL)
	{
		_ddTarget.SetDC(hicTargetDev);	
	}
}


/*
 *	CDrawInfo::Release
 *
 *	@mfunc	Decrements the reference count
 *
 *	@rdesc	Number of outstanding references to this object
 *
 *	@devnote This is used by the display to tell the display when it can NULL
 * 	its pointer to the display object.
 */
inline DWORD CDrawInfo::Release()
{

	AssertSz((_cRefs != 0), "CDrawInfo::Release invalid");
	return --_cRefs;	
}


/*
 *	CDrawInfo::GetTargetDD
 *
 *	@mfunc	Get pointer to target device
 *
 *	@rdesc	Returns pointer to target device if there is one
 *
 */
inline const CDevDesc *CDrawInfo::GetTargetDD()
{
	return (_ddTarget.IsValid())
		? &_ddTarget 
		: NULL;
}

/*
 *	CDrawInfo::GetDrawDepth
 *
 *	@mfunc	Get number of uses of this object
 *
 *	@rdesc	Number of uses of this object
 *
 *	@devnote This allows the draw routine to determine if a recursive draw
 *	occurred.
 *
 */
inline DWORD CDrawInfo::GetDrawDepth() const
{
	return _dwDepth;
}

/*
 *	CDrawInfo::GetDrawAspect
 *
 *	@mfunc	Get the draw aspect passed in on draw
 *
 *	@rdesc	Returns draw aspect
 *
 */
inline DWORD CDrawInfo::GetDrawAspect() const
{
	return _dwDrawAspect; 
}

/*
 *	CDrawInfo::GetLindex
 *
 *	@mfunc	Gets lindex passed from host
 *
 *	@rdesc	lindex passed from host
 *
 */
inline LONG CDrawInfo::GetLindex() const
{
	return _lindex; 
}

/*
 *	CDrawInfo::GetAspect
 *
 *	@mfunc	Gets pointer to aspect passed from host
 *
 *	@rdesc	Returns pointer to aspect structure
 *
 *	@devnote this is data is currently not defined.
 *
 */
inline void *CDrawInfo::GetAspect() const
{
	return _pvAspect; 
}

/*
 *	CDrawInfo::GetPtd
 *
 *	@mfunc	Get device target data from host
 *
 *	@rdesc	Returns pointer to device target data
 *
 */
inline DVTARGETDEVICE *CDrawInfo::GetPtd() const
{
	return _ptd; 
}

#endif // _DRWINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_font.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _FONT.H -- Declaration of classes comprising font caching |
 *	
 *	Purpose:
 *		Font cache
 *	
 *	Owner: <nl>
 *		David R. Fulmer (original RE 1.0 code)<nl>
 *		Christian Fortini (initial conversion to C++)<nl>
 *		Jon Matousek <nl>
 *
 *	History: <nl>
 *		8/6/95		jonmat Devised dynamic expanding cache for widths.
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef _FONT_H
#define _FONT_H

// Forwards
class CFontCache;
class CDevDesc;
class CDisplay;
// =============================  CCcs  ========================
// CCcs - caches font metrics and character size for one font

#define DEFAULTCACHESIZE	0			// size - 1
#define INITIALCACHESIZE	7			// size - 1 = 7; 2^n-1; size = 8
#define PERFCHECKEPOCH		64			// If changed, you must recalc
										//  and change COLLISION_SHIFT below.

#define COLLISION_SHIFT		3			// log(PERFCHECKEPOCH) / log(2) - 3

static const INT maxCacheSize = 511;

SHORT GetFontNameIndex(const WCHAR *pFontName);
BYTE  GetFontLegitimateSize(LONG iFont, BOOL fUIFont, int cpg);
BOOL  SetFontLegitimateSize(LONG iFont, BOOL fUIFont, BYTE bSize, int cpg);
const WCHAR *GetFontName(LONG iFont);
UINT  GetTextCharsetInfoPri(HDC hdc, FONTSIGNATURE* pcsi, DWORD dwFlags);
DWORD GetFontSignatureFromFace(int ifont, DWORD* pdwFontSig = NULL);
void  FreeFontNames();

enum FONTINDEX
{
	IFONT_ARIAL		= 0,
	IFONT_TMSNEWRMN	= 1,
	IFONT_SYMBOL	= 2,
	IFONT_SYSTEM	= 3
};

typedef unsigned int CCSHASHKEY;

extern const WCHAR *szArial;
extern const WCHAR *szTimesNewRoman;
extern const WCHAR *szSymbol;
extern const WCHAR *szSystem;
extern const WCHAR *szWingdings;

//Not automatically added to font table
extern const WCHAR *szMicrosSansSerif;
extern const WCHAR *szMSSansSerif;
extern const WCHAR *szMangal;
extern const WCHAR *szLatha;
extern const WCHAR *szCordiaNew;
extern const WCHAR *szTahoma;
extern const WCHAR *szArialUnicode;

/*
 *	CWidthCache
 *
 *	@class	Lightweight Unicode width cache.
 *
 *	@devnote Initial size is 52 bytes, 1st step is 100, and exponentially
 *			growing (currently) to 4660 bytes; NOTE, this can be reduced
 *			to 28, 60 and 3100 bytes if shorts are used and appropriate
 *			guarantees are placed on the range of width values.
 *
 *	Owner: <nl>
 *		Jon Matousek (jonmat) <nl>
 */
class CWidthCache
{
//@access	Private methods and data
private:
						
	INT		_cacheSize;			//@cmember	size is total cache slots - 1.

	INT		_cacheUsed;			//@cmember	for statistics, num slots in use.
	INT		_collisions;		//@cmember	for statistics, num fetches required.
	INT		_accesses;			//@cmember	for statistics, total num accesses.
	BOOL	_fMaxPerformance;	//@cmember	for statistics, TRUE if grown to max.

	struct CacheEntry
	{
		WCHAR	ch;
		SHORT	width;
	};

	SHORT	_dxpHangul;
	SHORT	_dxpHan;
							//@cmember	default storage for widths.
	CacheEntry	_defaultWidthCache[DEFAULTCACHESIZE+1];
							//@cmember	pointers to storage for widths.
	CacheEntry *(_pWidthCache);

	inline BOOL	FLookasideCharacter(WCHAR ch)
	{
		if (ch < 0x4E00)
			return FALSE;

		if (IN_RANGE(0x4E00, ch, 0x9FFF) ||		// CJK ideograph
			 IN_RANGE(0xF900, ch, 0xFAFF) ||	// CJK compatibility ideograph
			 IN_RANGE(0xAC00, ch, 0xD7FF))		// Hangul
			 return TRUE;

		return FALSE;
	}

	void FetchLookasideWidth(WCHAR ch, LONG &dxp)
	{
		BOOL fHangul = IN_RANGE(0xAC00, ch, 0xD7FF);

		dxp = fHangul ? _dxpHangul : _dxpHan;
	}

							//@cmember	Get location where width is stored.
	inline CacheEntry * GetEntry( const WCHAR ch )
				{	// logical & is really a MOD, as all of the bits
					// of cacheSize are turned on; the value of cacheSize is
					// required to be of the form 2^n-1.
					return &_pWidthCache[ ch & _cacheSize ];
				}

							//@cmember	See if cache is performing within spec.
	void	CheckPerformance();
							//@cmember	Increase width cache size.
	BOOL	GrowCache( CacheEntry **widthCache, INT *cacheSize, INT *cacheUsed);

	//@access Public Methods
	public:
							//@cmember	Called before GetWidth
	BOOL	CheckWidth (const WCHAR ch, LONG &dxp);
							//@cmember	Fetch width if CheckWidth ret FALSE.
	BOOL	FillWidth (
				HDC hdc,
				const WCHAR ch,
				const SHORT xOverhang,
				LONG &dxp,
				UINT uiCodePage,
				INT iDefWidth);

							//@cmember	Fetch char width.
	INT		GetWidth(const WCHAR ch);
	
	void	Free();			//@cmember	Recycle width cache

	CWidthCache();			//@cmember	Construct width cache
	~CWidthCache();			//@cmember	Free dynamic mem
};


class CCcs
{
	friend class CFontCache;

private:
	CCSHASHKEY _ccshashkey;	// Hash key
	DWORD 	_dwAge;			// for LRU algorithm
	SHORT	_iFont;			// Index into FONTNAME table
	SHORT	_cRefs;			// ref. count

	class CWidthCache _widths;

public:
	DWORD	_dwFontSig;		// Flags from low 32 bits of FONTSIGNATURE fsCsb member

	HDC		_hdc;			// HDC font is selected into
	HFONT 	_hfont;			// Windows font handle
	void*	_sc;			// A handle to the Uniscribe glyph width/font cmap information

	//REVIEW (keithcu) We should make these into at least 24 bit or possibly 32 bit values,
	//or at least use unsigned values so that we don't overflow as easily.
	SHORT	_yHeightRequest;// Font height requested (logical units)
	SHORT	_yHeight;		// Total height of char cell (logical units)
	SHORT 	_yDescent;		// Distance from baseline to char cell bottom (logical units)

	SHORT	_xAveCharWidth;	// Average character width in logical units
	SHORT 	_xOverhangAdjust;// Overhang for synthesized fonts in logical units
	SHORT	_xOverhang;		// Font overhang.
	SHORT	_xUnderhang;	// Font underhang.

	SHORT	_dyULOffset;	// Underline offset
	SHORT	_dyULWidth;		// Underline width
	SHORT	_dySOOffset;	// Strikeout offset
	SHORT	_dySOWidth;		// Strikeout width

	SHORT	_yOffsetSuperscript; //Amount raised if superscipt (positive)
	SHORT	_yOffsetSubscript;//Amount lowered if subscript (negative)

	USHORT	_weight;		// Font weight
	USHORT	_wCodePage;		// Font code page

	BYTE	_bCharSetRequest; //Requested charset
	BYTE	_bCharSet;		// Font CharSet
	BYTE	_bCMDefault;	// Used in calculation of _bConvertMode
	BYTE	_bConvertMode;	// CONVERTMODE: CVT_NONE, CVT_WCTMB, CVT_LOWBYTE
	BYTE	_bPitchAndFamily;// Font pitch and family

	BYTE 	_fValid:1;		// CCcs is valid
	BYTE	_fFixPitchFont:1;// Font has fixed character width
	BYTE	_fItalic:1;		// Font is italic
	BYTE	_fFECharSet:1;	// Font has FE charset
	BYTE	_fForceTrueType:1;// Font has been forced to be truetype

private:

    BOOL    Compare (const CCharFormat * const pCF, HDC hdc);
    BOOL    MakeFont(const CCharFormat * const pCF);
	void 	DestroyFont();
	BOOL	GetMetrics(WCHAR *szNewFaceName = 0);
	HFONT	GetFontWithMetrics(LOGFONT *plf, WCHAR* szNewFaceName);
	BOOL	FillWidth(WCHAR ch, LONG &dxp);

public:
	CCcs ()		{_fValid = FALSE;}
	~CCcs ()	{if(_fValid) Free();}

	void GetOffset(const CCharFormat * const pCF, LONG dypInch,
				   LONG *pyOffset, LONG *pyAdjust);

	BOOL 	Init(const CCharFormat * const pCF);
	void 	Free();
	void 	AddRef() 				{_cRefs++;}
	void 	Release() 				{if(_cRefs) _cRefs--;}

	BOOL	Include(WCHAR ch, LONG &dxp)
	{
		if(!_widths.CheckWidth(ch, dxp))
			return FillWidth(ch, dxp);
		return TRUE;
	}
	BYTE	BestCharSet(BYTE bCharSet, BYTE bCharSetDefault, int fFontMatching);

	SHORT	AdjustFEHeight(BOOL fAjdust)
	{
		return ((fAjdust && _fFECharSet) ? MulDiv(_yHeight, 15, 100) : 0);
	}
};


// FONTINFO cache

typedef union
{
	WORD	wFlags;
	struct
	{
		WORD	fCached			:1;		// Font signature was already cached
		WORD	fBadFaceName	:1;		// Face is junk or doesnt exist in the system
		WORD	fTrueType		:1;		// Font is TrueType
		WORD	fBitmap			:1;		// Font is Bitmap
		WORD	fNonBiDiAscii	:1;		// Font is non-BiDi, single charset and support ASCII
		WORD	fScaleByCpg		:1;		// Scale the font based on given codepage
		WORD	fThaiDTP		:1;		// Thai DTP font
	};
} FONTINFO_FLAGS;

typedef struct
{
	const WCHAR 	*szFontName;
	DWORD 			dwFontSig; 			// font signature
	BYTE			bSizeUI;			// UI font legitimate size (in point)
	BYTE			bSizeNonUI;			// Non-UI font legitimate size
	FONTINFO_FLAGS	ff;					// flags
} FONTINFO;



// =============================  CFontCache  =====================================================
// CFontCache - maintains up to FONTCACHESIZE font caches

class CFontCache
{
	friend class CCcs;

private:
	CCcs	_rgccs[FONTCACHESIZE];
	DWORD 	_dwAgeNext;
	struct {
		CCSHASHKEY	ccshashkey;
		CCcs		*pccs;
	} quickHashSearch[CCSHASHSEARCHSIZE+1];

private:
	CCcs* 	GrabInitNewCcs(const CCharFormat * const pCF, HDC hdc);
	CCSHASHKEY MakeHashKey(const CCharFormat *pCF);
public:
	void Init();

	CCcs*	GetCcs(const CCharFormat * const pCF, const LONG dypInch, HDC hdc = 0, BOOL fForceTrueType = 0);
	FONTINFO_FLAGS	GetInfoFlags(int ifont);
};

extern CFontCache & fc();			// font cache manager

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_dxfrobj.h ===
/*
 *	_DXFROBJ.H
 *
 *	Purpose:
 *		Class declaration for an OLE data transfer object (for use in
 *		drag drop and clipboard operations)
 *
 *	Author:
 *		alexgo (4/25/95)
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef __DXFEROBJ_H__
#define __DXFEROBJ_H__

class CTxtRange;

EXTERN_C const IID IID_IRichEditDO;

/*
 *	CDataTransferObj
 *
 *	Purpose:
 *		holds a "snapshot" of some rich-text data that can be used
 *		for drag drop or clipboard operations
 *
 *	Notes:
 *		FUTURE (alexgo): add in support for TOM<-->TOM optimized data
 *		transfers
 */

class CDataTransferObj : public IDataObject, public ITxNotify
{
public:

	// IUnknown methods
    STDMETHOD(QueryInterface)(REFIID riid, void ** ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

	// IDataObject methods
    STDMETHOD(DAdvise)( FORMATETC * pFormatetc, DWORD advf,
    		IAdviseSink *pAdvSink, DWORD *pdwConnection);
    STDMETHOD(DUnadvise)( DWORD dwConnection);
    STDMETHOD(EnumDAdvise)( IEnumSTATDATA ** ppenumAdvise);
    STDMETHOD(EnumFormatEtc)( DWORD dwDirection,
            IEnumFORMATETC **ppenumFormatEtc);
    STDMETHOD(GetCanonicalFormatEtc)( FORMATETC *pformatetc,
            FORMATETC *pformatetcOut);
    STDMETHOD(GetData)( FORMATETC *pformatetcIn, STGMEDIUM *pmedium );
    STDMETHOD(GetDataHere)( FORMATETC *pformatetc, STGMEDIUM *pmedium);
    STDMETHOD(QueryGetData)( FORMATETC *pformatetc );
    STDMETHOD(SetData)( FORMATETC *pformatetc, STGMEDIUM *pmedium,
            BOOL fRelease);

	// ITxNotify methods
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax);
    virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                        LONG cpFormatMin, LONG cpFormatMax);
	virtual void	Zombie();

	static	CDataTransferObj * Create(CTxtEdit *ped, CTxtRange *prg, LONG lStreamFormat);

private:
	// NOTE: private cons/destructor, may not be allocated on the stack as 
	// this would break OLE's current object liveness rules
	CDataTransferObj(CTxtEdit *ped);
	~CDataTransferObj();

	BOOL		IsZombie() {return !_ped;}

	ULONG		_crefs;
	ULONG		_cTotal;		// total number of formats supported
	FORMATETC *	_prgFormats;	// the array of supported formats
	LONG		_lStreamFormat; // Stream format to use in Rtf conversion

	// for 1.0 compatability
	DWORD	_dwFlags;
	DWORD	_dwUser;
	DWORD	_dvaspect;

	enum TEXTKIND
	{
		tPlain,
		tRtf,
		tRtfUtf8,
		tRtfNCRforNonASCII
	};

	HGLOBAL     TextToHglobal( HGLOBAL &hText, TEXTKIND tKind );
	LPSTORAGE	GetDataForEmbeddedObject( LPOLEOBJECT pOleObj, LPSTORAGE lpstgdest );
	HGLOBAL		GetDataForObjectDescriptor(	LPOLEOBJECT pOleObj, DWORD dwAspect, SIZEL* psizel );

public:
	CTxtEdit *		_ped;
	HGLOBAL			_hPlainText;	// handle to the plain UNICODE text
	HGLOBAL			_hRtfText;		// handle to the RTF UNICODE text
	HGLOBAL			_hRtfUtf8;		// Handle to UTF8 encoding of RTF
	HGLOBAL			_hRtfNCRforNonASCII;	// Handle to NCRforNonASCII encoding of RTF
	IOleObject *	_pOleObj;		// Embedded Object
	LPSTORAGE		_pObjStg;		// Embedded object data
	HGLOBAL			_hObjDesc;		// Embedded object descriptor
	HMETAFILE		_hMFPict;		// Embedded object metafile
	LONG			_cch;			// number of "characters" in the this
									// dxfer object
	LONG			_cpMin;			// Starting cp for this dxfer object
	LONG			_cObjs;			// number of objects in this dxfer object.
};

/*
 *	class CEnumFormatEtc
 *
 *	Purpose:
 *		implements a generic format enumerator for IDataObject
 */

class CEnumFormatEtc : public IEnumFORMATETC
{
public:
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    STDMETHOD(Next) (ULONG celt, FORMATETC *rgelt,
            ULONG *pceltFetched);
    STDMETHOD(Skip) (ULONG celt);
    STDMETHOD(Reset) (void);
    STDMETHOD(Clone) (IEnumFORMATETC **ppenum);

    static HRESULT Create(FORMATETC *prgFormats, DWORD cFormats, 
    			IEnumFORMATETC **ppenum);

private:

	CEnumFormatEtc();
	~CEnumFormatEtc();

	ULONG		_crefs;
    ULONG       _iCurrent; 	// current clipboard format
    ULONG       _cTotal;   	// total number of formats
    FORMATETC * _prgFormats; // array of available formats
};


//
//	Some globally useful FORMATETCs

extern FORMATETC g_rgFETC[];
extern const DWORD g_rgDOI[];
#define CFETC	17						// Dimension of g_rgFETC[]

enum FETCINDEX							// Keep in sync with g_rgFETC[]
{
	iRtfUtf8,							// RTF in UTF8 encoding
	iRtfFETC,							// RTF
	iRtfNCRforNonASCII,					// RTF with NCR for nonASCII
	iEmbObj,							// Embedded Object
	iEmbSrc,							// Embed Source
	iObtDesc,							// Object Descriptor
	iLnkSrc,							// Link Source
	iMfPict,							// Metafile
	iDIB,								// DIB
	iBitmap,							// Bitmap
	iRtfNoObjs,							// RTF with no objects
	iUnicodeFETC,						// Unicode plain text
	iAnsiFETC,							// ANSI plain text
	iFilename,							// Filename
	iRtfAsTextFETC,						// Pastes RTF as text
	iTxtObj,							// Richedit Text
	iRichEdit							// RichEdit Text w/formatting
};

#define cf_RICHEDIT			 g_rgFETC[iRichEdit].cfFormat
#define cf_EMBEDDEDOBJECT	 g_rgFETC[iEmbObj].cfFormat
#define cf_EMBEDSOURCE		 g_rgFETC[iEmbSrc].cfFormat
#define cf_OBJECTDESCRIPTOR	 g_rgFETC[iObtDesc].cfFormat
#define cf_LINKSOURCE		 g_rgFETC[iLnkSrc].cfFormat
#define cf_RTF				 g_rgFETC[iRtfFETC].cfFormat
#define cf_RTFUTF8			 g_rgFETC[iRtfUtf8].cfFormat
#define cf_RTFNCRFORNONASCII g_rgFETC[iRtfNCRforNonASCII].cfFormat
#define cf_RTFNOOBJS		 g_rgFETC[iRtfNoObjs].cfFormat
#define cf_TEXTOBJECT		 g_rgFETC[iTxtObj].cfFormat
#define cf_RTFASTEXT		 g_rgFETC[iRtfAsTextFETC].cfFormat
#define cf_FILENAME			 g_rgFETC[iFilename].cfFormat

#endif // !__DXFROBJ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_frunptr.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _FRUNPTR.H  -- CFormatRunPtr class declaration |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini <nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		06-25-95	alexgo	cleanup and commenting
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _FRUNPTR_H
#define _FRUNPTR_H

#include "_array.h"
#include "_text.h"
#include "_runptr.h"
#include "_format.h"

#define	CharFormat 0
#define	ParaFormat 1


typedef enum {
	IGNORE_CURRENT_FONT = 0,
	MATCH_CURRENT_CHARSET = 1,
	MATCH_FONT_SIG = 2,
	MATCH_ASCII = 4
} FONT_MATCHING;

/*
 *	CFormatRunPtr
 *
 *	@class	A Run pointer over an array of CFormatRun structures.
 *	This pointer understands how to add remove character/paragraph
 *	formatting
 *
 *	@base	public | CRunPtr<lt>CFormatRun<gt>
 *
 *	@devnote	The format run pointer has one extra interesting state
 *				transistion beyond the normal CRunPtrBase transistions.
 *
 *				If this run pointer is in the NULL state, then InitRuns may
 *				be used to create or fetch the correct run array for the
 *				run pointer.  Note that if a run array is already allocated
 *				it will be simply be fetched and used.  This allows us to
 *				treat unitialized run pointers the same as run pointers to
 *				an uninitialized document.
 *				@xref See also <mf CFormatRunPtr::InitRuns>
 */
class CFormatRunPtr : public CRunPtr<CFormatRun>
{
	friend class CRchTxtPtr;
	friend class CTxtRange;
	friend class CReplaceFormattingAE;
	friend class CUniscribe;

//@access Public Methods
public:
#ifdef DEBUG
	BOOL	Invariant(void) const;			//@cmember	Invariant tests
#endif
								
	CFormatRunPtr(const CFormatRunPtr &rp)	//@cmember	Copy Constructor
		: CRunPtr<CFormatRun>((CRunPtrBase&)rp) {}
								
	CFormatRunPtr(CFormatRuns *pfr)			//@cmember	Constructor
		: CRunPtr<CFormatRun>((CRunArray *)pfr) {}
								
	short	GetFormat() const;			//@cmember	Get current format index

	void	SetLevel (CBiDiLevel& level);		//@cmember Set run's embedding level
	
	BYTE	GetLevel (CBiDiLevel* pLevel = NULL);//@cmember Get run's embedding level

	BOOL	SameLevel (CFormatRunPtr* prp)
	{
		return !(IsValid() && GetRun(0)->_level._value != prp->GetRun(0)->_level._value);
	}

	BOOL	SameLevel (BYTE	bLevel)
	{
		return !(IsValid() && GetRun(0)->_level._value != bLevel);
	}

//@access Private Methods
private:
								//@cmember Format Run Array management
	BOOL	InitRuns(LONG ich, LONG cch, CFormatRuns **ppfrs);
								//@cmember Formatting replacement
	void	Delete(LONG cch, IFormatCache *pf, LONG cchMove);
								//@cmember Formatting insertion
	LONG	InsertFormat(LONG cch, LONG iformat, IFormatCache *pf);
								//@cmember Merge two adjacent formatting runs
	void	MergeRuns(LONG iRun, IFormatCache *pf);
								//@cmember Split run
	void	SplitFormat(IFormatCache *pf);
								//@cmember Sets the format for the current run
	LONG	SetFormat(LONG ifmt, LONG cch, IFormatCache *pf, CBiDiLevel* pLevel = NULL);
								//@cmember Extends formatting from previous run
	void	AdjustFormatting(LONG cch, IFormatCache *pf);
								//@cmember Remove <p cRun>
	void 	Remove (LONG cRun, IFormatCache *pf);
};


enum MASKOP
{
	MO_OR = 0,
	MO_AND,
	MO_EXACT
};

class CTxtEdit;

class CCFRunPtr : public CFormatRunPtr
{
	friend class CRchTxtPtr;
	friend class CTxtRange;

public:
	CTxtEdit *_ped;

	CCFRunPtr(const CRchTxtPtr &rtp);	//@cmember	Copy Constructor
	CCFRunPtr(const CFormatRunPtr &rp, CTxtEdit *ped);

	BOOL	IsHidden()	{return IsMask(CFE_HIDDEN);}
	BOOL	IsMask(DWORD dwMask, MASKOP mo = MO_OR);

	BOOL	IsInHidden();		//@cmember True if in hidden text
	LONG	FindUnhidden();		//@cmember Find nearest unhidden CF
	LONG	FindUnhiddenBackward();//@cmember Find previous unhidden CF
	LONG	FindUnhiddenForward();//@cmember Find previous unhidden CF

	int		MatchFormatSignature(const CCharFormat* pCF, int iScript, int fMatchCurrent, DWORD* pdwFontSig = NULL);

	//@member Get font info for code page
	bool GetPreferredFontInfo(
		int cpg,
		BYTE&  bCharSet,
		SHORT& iFont,
		SHORT& yHeight,
		BYTE& bPitchAndFamily,
		int	iFormat,
		int iMatchCurrent = MATCH_FONT_SIG
	);
};

class CPFRunPtr : public CFormatRunPtr
{
	friend class CRchTxtPtr;
	friend class CTxtRange;

public:
	CTxtEdit *_ped;

	CPFRunPtr(const CRchTxtPtr &rtp);	//@cmember	Copy Constructor
								//@cmember Find Heading before cpMost
	LONG	FindHeading(LONG cch, LONG& lHeading);
	BOOL	InTable();			//@cmember True if paraformat is in table
	BOOL	IsCollapsed();		//@cmember True if paraformat is collapsed
	LONG	FindExpanded();		//@cmember Find nearest expanded PF
	LONG	FindExpandedBackward();//@cmember Find previous expanded PF
	LONG	FindExpandedForward();//@cmember Find next expanded PF
	LONG	GetOutlineLevel();	//@cmember Get outline level
	LONG	GetStyle();			//@cmember Get style
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_host.h ===
/*	@doc INTERNAL
 *
 *	@module _HOST.H  Text Host for Window's Rich Edit Control |
 *	
 *
 *	Original Author: <nl>
 *		Christian Fortini
 *		Murray Sargent
 *
 *	History: <nl>
 *		8/1/95	ricksa	Revised interface definition
 */
#ifndef _HOST_H
#define _HOST_H

#include "textserv.h"
#include "textsrv2.h"
#include "dynarray.hxx"

#ifndef NOACCESSIBILITY
// UNDONE:
//	Need to include this file int the project
#include "oleacc.h"
#endif

/*
 *	TXTEFFECT
 *
 *	@enum	Defines different background styles control
 */
enum TXTEFFECT {
	TXTEFFECT_NONE = 0,				//@emem	no special backgoround effect
	TXTEFFECT_SUNKEN,				//@emem	draw a "sunken 3-D" look
};


// @doc EXTERNAL

// ============================  CTxtWinHost  ================================================
// Implement the windowed version of the Plain Text control

/*
 *	CTxtWinHost
 *	
 * 	@class	Text Host for Window's Rich Edit Control implementation class
 *
 */
class CTxtWinHost : public ITextHost2
#ifndef NOACCESSIBILITY
	, public IAccessible
#endif
{

public:
	HWND		_hwnd;					// control window
	HWND		_hwndParent;			// parent window

	ITextServices	*_pserv;			// pointer to Text Services object

	ULONG		_crefs;					// reference count

// Properties

	DWORD		_dwStyle;				// style bits
	DWORD		_dwExStyle;				// extended style bits

	unsigned	_fBorder			:1;	// control has border
	unsigned	_fInBottomless		:1;	// inside bottomless callback
	unsigned	_fInDialogBox		:1;	// control is in a dialog box
	unsigned	_fEnableAutoWordSel	:1;	// enable Word style auto word selection?
	unsigned	_fIconic			:1;	// control window is iconic
	unsigned	_fHidden			:1;	// control window is hidden
	unsigned	_fNotSysBkgnd		:1;	// not using system background color
	unsigned	_fWindowLocked		:1;	// window is locked (no update)
	unsigned	_fRegisteredForDrop	:1; // whether host has registered for drop
	unsigned	_fVisible			:1;	// Whether window is visible or not.
	unsigned	_fResized			:1;	// resized while hidden
	unsigned	_fDisabled			:1;	// Window is disabled.
	unsigned	_fKeyMaskSet		:1;	// if ENM_KEYEVENTS has been set
	unsigned	_fMouseMaskSet		:1;	// if ENM_MOUSEEVENTS has been set
	unsigned	_fScrollMaskSet		:1;	// if ENM_SCROLLEVENTS has been set
	unsigned	_fUseSpecialSetSel	:1; // TRUE = use EM_SETSEL hack to not select
										// empty controls to make dialog boxes work.
	unsigned	_fEmSetRectCalled	:1;	// TRUE - application called EM_SETRECT
	unsigned	_fAccumulateDBC		:1;	// TRUE - need to cumulate ytes from 2 WM_CHAR msgs
										// we are in this mode when we receive VK_PROCESSKEY
	unsigned	_fANSIwindow		:1;	// TRUE - window created as "RichEdit20A"
	unsigned	_fTextServiceFree	:1;	// TRUE - Text Services freed at shutdown.
	COLORREF 	_crBackground;			// background color
    RECT        _rcViewInset;           // view rect inset /r client rect

	HIMC		_oldhimc;				// previous IME Context
	// TODO: the following could be a two-bit field as part of the unsigned field above
	DWORD		_usIMEMode;				// mode of IME operation
										// either 0 or ES_SELFIME or ES_NOIME
	HPALETTE	_hpal;					// Logical palette to use.

	TCHAR		_chPassword;			// Password char. If null, no password
	TCHAR		_chLeadByte;			// use when we are in _fAccumulateDBC mode
	SHORT		_sWidth;				// Last client width given by WM_SIZE
	char		_yInset;
	char		_xInset;
	CTxtWinHost	*_pnextdel;

public:
	// Initialization
	virtual BOOL Init(
					HWND hwnd,
					const CREATESTRUCT *pcs,
					BOOL fIsAnsi,
					BOOL fIs10Mode);

	void	SetScrollBarsForWmEnable(BOOL fEnable);


	void	OnSetMargins(
				DWORD fwMargin,
				DWORD xLeft,
				DWORD xRight);

	virtual void	SetScrollInfo(
				INT fnBar,
				BOOL fRedraw);

	// helpers
	HRESULT	CreateTextServices();
	void *	CreateNmhdr(UINT uiCode, LONG cb);
	void	HostRevokeDragDrop(void);
	void	HostRegisterDragDrop();
	void	DrawSunkenBorder(HWND hwnd, HDC hdc);
	void    OnSunkenWindowPosChanging(HWND hwnd, WINDOWPOS *pwndpos);
	LRESULT OnSize(HWND hwnd, WORD fwSizeType, int nWidth, int nHeight);
	virtual TXTEFFECT TxGetEffects() const;
	HRESULT	OnTxVisibleChange(BOOL fVisible);
	void	SetDefaultInset();
	BOOL	IsTransparentMode()
	{
		return (_dwExStyle & WS_EX_TRANSPARENT);
	}

	// Keyboard messages
	virtual LRESULT	OnKeyDown(WORD vKey, DWORD dwFlags);
	virtual LRESULT	OnChar(WORD vKey, DWORD dwFlags);
	
	// System notifications
	virtual void 	OnSysColorChange();
	virtual LRESULT OnGetDlgCode(WPARAM wparam, LPARAM lparam);

	// Other messages
	LRESULT OnGetOptions() const;
	void	OnSetOptions(WORD wOp, DWORD eco);
	void	OnSetReadOnly(BOOL fReadOnly);
	void	OnGetRect(LPRECT prc);
	void	OnSetRect(LPRECT prc, BOOL fNewBehavior, BOOL fRedraw);


public:
	CTxtWinHost();
	virtual ~CTxtWinHost();
	void	Shutdown();

	// Window creation/destruction
	static 	CTxtWinHost *OnNCCreate(
						HWND hwnd,
						const CREATESTRUCT *pcs,
						BOOL fIsAnsi,
						BOOL fIs10Mode);

	static 	void 	OnNCDestroy(CTxtWinHost *ped);
	virtual LRESULT OnCreate(const CREATESTRUCT *pcs);

	// -----------------------------
	//	IUnknown interface
	// -----------------------------

    virtual HRESULT 		WINAPI QueryInterface(REFIID riid, void **ppvObject);
    virtual ULONG 			WINAPI AddRef(void);
    virtual ULONG 			WINAPI Release(void);

	// -----------------------------
	//	ITextHost interface
	// -----------------------------
	//@cmember Get the DC for the host
	virtual HDC 		TxGetDC();

	//@cmember Release the DC gotten from the host
	virtual INT			TxReleaseDC(HDC hdc);
	
	//@cmember Show the scroll bar
	virtual BOOL 		TxShowScrollBar(INT fnBar, BOOL fShow);

	//@cmember Enable the scroll bar
	virtual BOOL 		TxEnableScrollBar (INT fuSBFlags, INT fuArrowflags);

	//@cmember Set the scroll range
	virtual BOOL 		TxSetScrollRange(
							INT fnBar,
							LONG nMinPos,
							INT nMaxPos,
							BOOL fRedraw);

	//@cmember Set the scroll position
	virtual BOOL 		TxSetScrollPos (INT fnBar, INT nPos, BOOL fRedraw);

	//@cmember InvalidateRect
	virtual void		TxInvalidateRect(LPCRECT prc, BOOL fMode);

	//@cmember Send a WM_PAINT to the window
	virtual void 		TxViewChange(BOOL fUpdate);
	
	//@cmember Create the caret
	virtual BOOL		TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight);

	//@cmember Show the caret
	virtual BOOL		TxShowCaret(BOOL fShow);

	//@cmember Set the caret position
	virtual BOOL		TxSetCaretPos(INT x, INT y);

	//@cmember Create a timer with the specified timeout
	virtual BOOL 		TxSetTimer(UINT idTimer, UINT uTimeout);

	//@cmember Destroy a timer
	virtual void 		TxKillTimer(UINT idTimer);

	//@cmember Scroll the content of the specified window's client area
	virtual void		TxScrollWindowEx (
							INT dx,
							INT dy,
							LPCRECT lprcScroll,
							LPCRECT lprcClip,
							HRGN hrgnUpdate,
							LPRECT lprcUpdate,
							UINT fuScroll);
	
	//@cmember Get mouse capture
	virtual void		TxSetCapture(BOOL fCapture);

	//@cmember Set the focus to the text window
	virtual void		TxSetFocus();

	//@cmember Establish a new cursor shape
	virtual void		TxSetCursor(HCURSOR hcur, BOOL fText);

	//@cmember Changes the mouse cursor
	virtual HCURSOR		TxSetCursor2(HCURSOR hcur, BOOL bText) { return ::SetCursor(hcur);}

	//@cmember Notification that text services is freed
	virtual void		TxFreeTextServicesNotification();

	//@cmember Converts screen coordinates of a specified point to the client coordinates
	virtual BOOL 		TxScreenToClient (LPPOINT lppt);

	//@cmember Converts the client coordinates of a specified point to screen coordinates
	virtual BOOL		TxClientToScreen (LPPOINT lppt);

	//@cmember Request host to activate text services
	virtual HRESULT		TxActivate( LONG * plOldState );

	//@cmember Request host to deactivate text services
   	virtual HRESULT		TxDeactivate( LONG lNewState );

	//@cmember Retrieves the coordinates of a window's client area
	virtual HRESULT		TxGetClientRect(LPRECT prc);

	//@cmember Get the view rectangle relative to the inset
	virtual HRESULT		TxGetViewInset(LPRECT prc);

	//@cmember Get the default character format for the text
	virtual HRESULT 	TxGetCharFormat(const CHARFORMAT **ppCF );

	//@cmember Get the default paragraph format for the text
	virtual HRESULT		TxGetParaFormat(const PARAFORMAT **ppPF);

	//@cmember Get the background color for the window
	virtual COLORREF	TxGetSysColor(int nIndex);

	//@cmember Get the background (either opaque or transparent)
	virtual HRESULT		TxGetBackStyle(TXTBACKSTYLE *pstyle);

	//@cmember Get the maximum length for the text
	virtual HRESULT		TxGetMaxLength(DWORD *plength);

	//@cmember Get the bits representing requested scroll bars for the window
	virtual HRESULT		TxGetScrollBars(DWORD *pdwScrollBar);

	//@cmember Get the character to display for password input
	virtual HRESULT		TxGetPasswordChar(TCHAR *pch);

	//@cmember Get the accelerator character
	virtual HRESULT		TxGetAcceleratorPos(LONG *pcp);

	//@cmember Get the native size
    virtual HRESULT		TxGetExtent(LPSIZEL lpExtent);

	//@cmember Notify host that default character format has changed
	virtual HRESULT 	OnTxCharFormatChange (const CHARFORMAT * pcf);

	//@cmember Notify host that default paragraph format has changed
	virtual HRESULT		OnTxParaFormatChange (const PARAFORMAT * ppf);

	//@cmember Bulk access to bit properties
	virtual HRESULT		TxGetPropertyBits(DWORD dwMask, DWORD *pdwBits);

	//@cmember Notify host of events
	virtual HRESULT		TxNotify(DWORD iNotify, void *pv);

	// FE Support Routines for handling the Input Method Context
//#ifdef WIN95_IME
	virtual HIMC		TxImmGetContext(void);
	virtual void		TxImmReleaseContext(HIMC himc);
//#endif

	//@cmember Returns HIMETRIC size of the control bar.
	virtual HRESULT		TxGetSelectionBarWidth (LONG *lSelBarWidth);

	// ITextHost2 methods
	virtual BOOL		TxIsDoubleClickPending();
	virtual HRESULT		TxGetWindow(HWND *phwnd);
	virtual HRESULT		TxSetForegroundWindow();
	virtual HPALETTE	TxGetPalette();
	virtual HRESULT		TxGetFEFlags(LONG *pFlags);
	virtual HRESULT		TxGetEditStyle(DWORD dwItem, DWORD *pdwData);
	virtual HRESULT		TxGetWindowStyles(DWORD *pdwStyle, DWORD *pdwExStyle);

#ifndef NOACCESSIBILITY
	ITypeInfo	*_pTypeInfo;

	virtual HRESULT	InitTypeInfo() {return E_NOTIMPL;}
	
	////////////////////////// IDispatch Methods /////////////////////////////////
	STDMETHOD(GetTypeInfoCount)(UINT __RPC_FAR *pctinfo);
	STDMETHOD(GetTypeInfo)(UINT iTInfo, LCID lcid, ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR __RPC_FAR *rgszNames, UINT cNames,
            				 LCID lcid, DISPID __RPC_FAR *rgDispId);
	STDMETHOD(Invoke)(DISPID dispIdMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS __RPC_FAR *pDispParams,
					  VARIANT __RPC_FAR *pVarResult, EXCEPINFO __RPC_FAR *pExcepInfo, UINT __RPC_FAR *puArgErr);

	////////////////////////// IAccessible Methods /////////////////////////////////
    STDMETHOD(get_accParent)(IDispatch **ppdispParent) {return S_FALSE;}
    STDMETHOD(get_accChildCount)(long *pcountChildren)	{return S_FALSE;}
    STDMETHOD(get_accChild)(VARIANT varChild, IDispatch **ppdispChild) {return S_FALSE;}
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName) {return S_FALSE;}
    STDMETHOD(get_accValue)(VARIANT varChild, BSTR *pszValue) {return S_FALSE;}
    STDMETHOD(get_accDescription)(VARIANT varChild, BSTR *pszDescription) {return S_FALSE;}
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole) {return S_FALSE;}
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState) {return S_FALSE;}
    STDMETHOD(get_accHelp)(VARIANT varChild, BSTR *pszHelp) {return S_FALSE;}
    STDMETHOD(get_accHelpTopic)(BSTR *pszHelpFile, VARIANT varChild, long *pidTopic) {return S_FALSE;}
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut) {return S_FALSE;}
    STDMETHOD(get_accFocus)(VARIANT *pvarChild) {return S_FALSE;}
    STDMETHOD(get_accSelection)(VARIANT *pvarChildren) {return S_FALSE;}
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction) {return S_FALSE;}
    STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild) {return S_FALSE;}
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild)
    								{return S_FALSE;}
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt) {return S_FALSE;}
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChild) {return S_FALSE;}
    STDMETHOD(accDoDefaultAction)(VARIANT varChild) {return S_FALSE;}
    STDMETHOD(put_accName)(VARIANT varChild, BSTR szName) {return S_FALSE;}
    STDMETHOD(put_accValue)(VARIANT varChild, BSTR szValue) {return S_FALSE;}
#endif // NOACCESSIBILITY

};

// Work around some client's (MSN chat) problems with host deletions.
void DeleteDanglingHosts();

#define LBS_COMBOBOX    0x8000L
#define LBCB_TRACKING	WM_USER+2
#define LBCBM_PREPARE	1
#define LBCBM_START		2
#define LBCBM_END		3

// mask for LBCBM messages
#define LBCBM_PREPARE_SETFOCUS 1
#define LBCBM_PREPARE_SAVECURSOR 2


class CLbData
{
public:
	unsigned _fSelected	:1;		// indicates if the item has been selected	
	long	_dwData;			// Item data
};

struct CHARSORTINFO
{
	WCHAR*	str;
	int		sz;
};

#define CHECKNOERROR(x) if (NOERROR != x) goto CleanExit

class CCmbBxWinHost;
class CLstBxWinHost : public CTxtWinHost
{
public:
	typedef enum {					
		//kNoSel = 0,					//LBS_NOSEL
		kSingle = 1,					//LBS_SIMPLE
		kMultiple = 2,					//LBS_MULTIPLESEL
		kExtended = 3,					//LBS_EXTENDEDSEL
		kCombo = 8						//Combo box
	} Listtype;

#ifndef ACCESSIBILITY
public:
	// -----------------------------
	//	IUnknown interface
	// -----------------------------

    virtual HRESULT 		WINAPI QueryInterface(REFIID riid, void **ppvObject);
#endif
	
private:
	short _cWheelDelta;					//contains the delta values for mouse wheels
	int _nTopIdx;						//the item index at the top of list
										//Do not touch this unless you know what you are doing!!
public:
	unsigned int _fOwnerDraw	:1;		//indicates if list box is owner draw
	unsigned int _fSort			:1;		//determines if the list should be sorted
	unsigned int _fNoIntegralHeight :1;	//indicates if the size of the listbox should be readjusted according
										//how many items can be fully displayed
	unsigned int _fDisableScroll:1;		//indicates if scroll bar should be displayed at all times
	unsigned int _fNotify		:1;		//notifies parent dialog of activities done in list box.
	unsigned int _fSingleSel 	:1;		// Indicates the list box is a single selection item
	unsigned int _fMouseDown 	:1;		// Indicates if the mouse is down
	unsigned int _fFocus 		:1;		// determines if the control has focus
	unsigned int _fCapture		:1;		// determines if mouse capture is set
	unsigned int _fSearching  	:1;		// indicates if we are in type searching mode
	unsigned int _fDblClick		:1;		// flag indicating double click was received
	unsigned int _fNoResize		:1;		// internal flag to tell us if we should ignore resize messages
	unsigned int _fNotifyWinEvt	:1;		// Indicates only Notify Win Event (ACCESSIBILITY use)

	Listtype _fLstType;					//indicates current type of list box or combo box

#ifndef NOACCESSIBILITY
	DWORD	_dwWinEvent;				// Win Event code (ACCESSIBILITY use)
	int		_nAccessibleIdx;			// Index (ACCESSIBILITY use)
#endif

protected:

	UINT		_idCtrl;				// control's unique id
	COLORREF _crSelFore;				//Selected Forground color
	COLORREF _crSelBack;				//Selected Background color
	COLORREF _crDefFore;				//Default Forground color
	COLORREF _crDefBack;				//Default Background color

	RECT	_rcViewport;				//drawable area for the items
	long _nyFont;						// Font pixel size in y direction
	long _nyItem;						//Height of the items in the list box
	
	int _nViewSize;						//number of items which is viewable at the same time

	int _nCount;						//Number of items in the list box
	int _nAnchor;						//Indicates the top selected item
										//NOTE:
										//  In a single sel list box only _nCursor is used
	int _nCursor;						//Indicates the current item which has the focus

	int _nOldCursor;					//The old cursor position for combo boxes

	int _stvidx;						// This is for a hack to workaround a bug when the display
										// is frozen ITextRange doesn't cache to scroll change

	int _nidxSearch;					// Number of characters in search string
	WCHAR*	_pwszSearch;				// pointer to allocated string
	CDynamicArray<CLbData> _rgData;		// Array/link list of the item data
	LPARAM	_nPrevMousePos;				// Last position from Mousemove message
	CCmbBxWinHost*	_pcbHost;			// pointer to combo box win host

protected:
	// Changes the background color
	BOOL SetColors(DWORD, DWORD, long, long);

	// Makes sure the top item is displayed at the top of the view
	BOOL ScrollToView(long nTop);

	// Sets the requested item to be at the top of the viewable space
	BOOL SetTopViewableItem(long);

	// Searches if a given index qualifies as a match
	BOOL FindString(long idx, LPCTSTR szSearch, BOOL bExact);

	// helper function for the OnMouseMove function
	void MouseMoveHelper(int, BOOL);

	// Set the height of each item in the list box in the given range
	int SetItemsHeight(int,BOOL);

	
public:
	CLstBxWinHost();
	virtual ~CLstBxWinHost();

	void ResizeInset();
	// initialization function
	virtual BOOL Init(HWND,	const CREATESTRUCT *);

	// calculates the height of each item
	void UpdateViewArea();

	// Window creation/destruction
	static 	LRESULT OnNCCreate(HWND hwnd, const CREATESTRUCT *pcs);
	static 	void OnNCDestroy(CLstBxWinHost *ped);
	virtual LRESULT OnCreate(const CREATESTRUCT *pcs);

	////////////////////////// helper functions ////////////////////////////////////
	static wchar_t * wcscat(wchar_t * dst, const wchar_t * src)
	{
        wchar_t * cp = dst;
		while(*cp) cp++;		 // find null character in first string
        while( *cp++ = *src++ ); // Copy src over dst
        return( dst );
	}

	// given a source string the destination string contains a sorted version
	// separated by <CR>
	int SortInsertList(WCHAR* pszDst, WCHAR* pszSrc);

	// Sets the indents for the listbox
	BOOL SetListIndent(int fLeftIndent);

	// Equivalent to CompareString except int is a reference to an item index
	int CompareIndex(LPCTSTR szInsert, int nIndex);
	
	// Returns the position a string should be in a sorted list
	int GetSortedPosition(LPCTSTR, int, int);

	// Updates the system color settings
	void UpdateSysColors();
	
	// Inits search string
	void InitSearch();
	
	// Prevents the window from updating itself
	inline void Freeze();

	// Frees the window to update itself
	inline void Unfreeze();

	// Retrieves the range give the top and bottom index
	BOOL GetRange(long, long, ITextRange**);	

	// Inserts the string at the requested index
	BOOL InsertString(long, LPCTSTR);

	// Removes the string from the listbox
	BOOL RemoveString(long, long);

	// Retrieves the string at the requested index
	long GetString(long, PWCHAR);

	// Deselects all the items in the list box
	BOOL ResetContent();

	// Retrieves the nearest valid item from a given point
	int GetItemFromPoint(const POINT *);

	// Tells if a given points is within the listbox's rect
	BOOL PointInRect(const POINT *);

	// Sets the cursor position and draws the rect
	void SetCursor(HDC, int, BOOL);

	// Recalulates the height so no partial text will be displayed
	BOOL RecalcHeight(int, int);

	// returns of listbox is single selection
	inline BOOL IsSingleSelection() const {return _fSingleSel;}
	
	// Returns the current top index
	inline long GetTopIndex() const { return _nTopIdx;}
	
	// Checks if the mouse has been captured
	inline BOOL GetCapture() const { return _fCapture;}

	// return the item count
	inline int GetCount() const	{return _nCount;}

	// returns the anchor position
	inline int GetAnchor() const {return _nAnchor;}

	// returns the cursor position
	inline int GetCursor() const {return _nCursor;}

	// returns the viewsize
	inline int GetViewSize() const {return _nViewSize;}

	// returns the font height
	inline int GetFontHeight() const {return _nyFont;}

	// returns the item height
	inline int GetItemHeight() const {return _nyItem;}

	// returns the displays freeze count
	inline short FreezeCount() const;

	// initialize mouse wheel variable to zero
	inline void InitWheelDelta() { _cWheelDelta = 0;}

	inline BOOL IsItemViewable(long x) const
	{
		return (GetTopIndex() <= x && (x - GetTopIndex()) * _nyItem < _rcViewport.bottom);
	}

	// Determines if index is selected
	inline BOOL IsSelected(long nIdx)
	{
#ifdef _DEBUG
		Assert(nIdx < -1 || _nCount <= nIdx);
		if (nIdx < -1 || _nCount <= nIdx) return FALSE;
#endif
		if (nIdx < 0)
			return FALSE;
		else
			return _rgData[nIdx]._fSelected;
	}

	// Returns the ItemData of a given index
	inline long GetData(long nIdx)
	{		
		return _rgData.Get(nIdx)._dwData;
	}

	// Returns TRUE if point is within the client area of listbox

	/////////////////////ListBox Message Handling functions /////////////////////////
	// Set the height of the items in the list box
	BOOL LbSetItemHeight(int nHeight);
	
	// Set the selection state for the items in the range
	BOOL LbSetSelection(long, long, int, long, long);

	// Sets the requested item to be at the top of the list box
	long LbSetTopIndex(long);

	// Makes sure the requested index is visible
	BOOL LbShowIndex(long, BOOL);

	// Retrieves the index give a string and starting position
	long LbFindString(long, LPCTSTR, BOOL);	

	// Inserts the string at the requested location
	long LbInsertString(long, LPCTSTR);

	// Range to delete
	long LbDeleteString(long, long);

	// Sets the Item data
	void LbSetItemData(long, long, long);

	// returns the item rect of a given index
	BOOL LbGetItemRect(int, RECT*);

	// Notifies parent when an item is deleted
	void LbDeleteItemNotify(int, int);
	
	// Owner draw function
	void LbDrawItemNotify(HDC, int, UINT, UINT);

	// used to insert a list of strings rather than individually
	int LbBatchInsert(WCHAR* psz);

	///////////////////////// Message Map functions //////////////////////////////
	// if subclassed then make these functions virtual

	// Handles the WM_MOUSEMOVE message
	LRESULT OnMouseWheel(WPARAM, LPARAM);
	
	// Handles the WM_LBUTTONDOWN message
	LRESULT OnLButtonDown(WPARAM wparam, LPARAM lparam);

	// Handles the WM_MOUSEMOVE message
	LRESULT OnMouseMove(WPARAM, LPARAM);

	// Handles the WM_LBUTTONUP message
	LRESULT OnLButtonUp(WPARAM, LPARAM, int ff = 0);

	// Handles the WM_VSCROLL message
	LRESULT OnVScroll(WPARAM, LPARAM);

	// Handles the WM_TIMER message
	LRESULT OnTimer(WPARAM, LPARAM);

	// Handles the WM_KEYDOWN message
	LRESULT OnKeyDown(WPARAM, LPARAM, int);
	
	// Hanldes the WM_CAPTURECHANGED message
	LRESULT OnCaptureChanged(WPARAM, LPARAM);

	// Handles the WM_CHAR message
	virtual LRESULT	OnChar(WORD, DWORD);

	// Handles the WM_SYSCOLORCHANGE message
	virtual void OnSysColorChange();

	// Handles the WM_SETCURSOR message
	LRESULT OnSetCursor();

	//////////////////////////// overridden Tx fn's ////////////////////////////////
	//@cmember Get the bits representing requested scroll bars for the window
	virtual HRESULT	TxGetScrollBars(DWORD *pdwScrollBar);
	
	//@cmember Bulk access to bit properties
	virtual HRESULT	TxGetPropertyBits(DWORD, DWORD *);

	virtual TXTEFFECT TxGetEffects() const;

	//@cmember Notify host of events
	virtual HRESULT	TxNotify(DWORD iNotify, void *pv);

		//@cmember Show the scroll bar
	virtual BOOL TxShowScrollBar(INT fnBar, BOOL fShow);

	//@cmember Enable the scroll bar
	virtual BOOL TxEnableScrollBar (INT fuSBFlags, INT fuArrowflags);

	//@cmember Show the caret
	virtual BOOL TxShowCaret(BOOL fShow) {return TRUE;}

		//@cmember Create the caret
	virtual BOOL TxCreateCaret(HBITMAP hbmp, INT xWidth, INT yHeight) {return FALSE;}

	//@cmember Set the scroll range
	virtual void SetScrollInfo(INT, BOOL);

	/////////////////////////// Combobox helper fn's ///////////////////////////////
	void OnCBTracking(WPARAM, LPARAM);

	static int QSort(CHARSORTINFO rg[], int nStart, int nEnd);


#ifndef NOACCESSIBILITY
	HRESULT	InitTypeInfo();

	////////////////////////// IAccessible Methods /////////////////////////////////
    STDMETHOD(get_accParent)(IDispatch **ppdispParent);
    STDMETHOD(get_accName)(VARIANT varChild, BSTR *pszName);
    STDMETHOD(get_accChildCount)(long *pcountChildren);
    STDMETHOD(get_accRole)(VARIANT varChild, VARIANT *pvarRole);
    STDMETHOD(get_accState)(VARIANT varChild, VARIANT *pvarState);
    STDMETHOD(get_accKeyboardShortcut)(VARIANT varChild, BSTR *pszKeyboardShortcut);
    STDMETHOD(get_accFocus)(VARIANT *pvarChild);
    STDMETHOD(get_accSelection)(VARIANT *pvarChildren);
    STDMETHOD(get_accDefaultAction)(VARIANT varChild, BSTR *pszDefaultAction);
   	STDMETHOD(accSelect)(long flagsSelect, VARIANT varChild);
    STDMETHOD(accLocation)(long *pxLeft, long *pyTop, long *pcxWidth, long *pcyHeight, VARIANT varChild);
    STDMETHOD(accNavigate)(long navDir, VARIANT varStart, VARIANT *pvarEndUpAt);
    STDMETHOD(accHitTest)(long xLeft, long yTop, VARIANT *pvarChild);
    STDMETHOD(accDoDefaultAction)(VARIANT varChild);
#endif // NOACCESSIBILITY
};

#ifndef NOACCESSIBILITY
// --------------------------------------------------------------------------
//
//  Although CListBoxSelection() is based off of IEnumVARIANT.
//	It will hand back the proper IDs so you can pass them to the real
//	listbox parent object.
//
// --------------------------------------------------------------------------
class CListBoxSelection : public IEnumVARIANT
{
    public:
        // IUnknown
        virtual STDMETHODIMP            QueryInterface(REFIID, void**);
        virtual STDMETHODIMP_(ULONG)    AddRef(void);
        virtual STDMETHODIMP_(ULONG)    Release(void);

        // IEnumVARIANT
        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum);

        CListBoxSelection(int, int, LPINT);
        ~CListBoxSelection();

    protected:
        int     _cRef;
        int     _idChildCur;
        int     _cSel;
        LPINT   _piSel;
};
#endif

#ifndef DEBUG
#define AttCheckRunTotals(_fCF)
#define AttCheckPFRuns(_fCF)
#endif

#define ECO_STYLES (ECO_AUTOVSCROLL | ECO_AUTOHSCROLL | ECO_NOHIDESEL | \
						ECO_READONLY | ECO_WANTRETURN | ECO_SAVESEL | \
						ECO_SELECTIONBAR | ES_NOIME | ES_SELFIME )

#endif // _HOST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_ime.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _ime.h -- support for IME APIs |
 *	
 *	Purpose:
 *		Most everything to do with FE composition string editing passes
 *		through here.
 *	
 *	Authors: <nl>
 *		Jon Matousek  <nl>
 *		Justin Voskuhl  <nl>
 *		Hon Wah Chan  <nl>
 * 
 *	History: <nl>
 *		10/18/1995		jonmat	Cleaned up level 2 code and converted it into
 *								a class hierarchy supporting level 3.
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 *
 */								 

#ifndef _IME_H
#define _IME_H


class CTextMsgFilter;

// defines for IME Level 2 and 3
#define	IME_LEVEL_2		2
#define IME_LEVEL_3		3
#define IME_PROTECTED	4

/*
 *	IME
 *
 *	@class	base class for IME support.
 *
 *	@devnote
 *		For level 2, at caret IMEs, the IME will draw a window directly over the text giving the
 *		impression that the text is being processed by the application--this is called pseudo inline.
 *		All UI is handled by the IME. This mode is currenlty bypassed in favor of level 3 true inline (TI);
 *		however, it would be trivial to allow a user preference to select this mode. Some IMEs may have
 *		a "special" UI, in which case level 3 TI is *NOT* used, necessitating level 2.
 *
 *		For level 2, near caret IMEs, the IME will draw a very small and obvious window near the current
 *		caret position in the document. This currently occurs for PRC(?) and Taiwan.
 *		All UI is handled by the IME.
 *
 *		For level 3, at caret IMEs, the composition string is drawn by the application, which is called
 *		true inline, bypassing the level 2 "composition window".
 *		Currently, we allow the IME to support all remaining UI *except* drawing of the composition string.
 */
class CIme
{
	friend LRESULT OnGetIMECompositionMode ( CTextMsgFilter &TextMsgFilter );
	friend HRESULT CompositionStringGlue ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
	friend HRESULT EndCompositionGlue ( CTextMsgFilter &TextMsgFilter, BOOL fForceDelete);
	friend void CheckDestroyIME ( CTextMsgFilter &TextMsgFilter );


	//@access	Protected data
	protected:
	short	_imeLevel;								//@cmember IME Level 2 or 3
	short	_cIgnoreIMECharMsg;						//@cmember Level 2 IME use to eat WM_IME_CHAR message
	short	_fIgnoreEndComposition;					//@cmember ignore the next End Composition message
	short	_fIMETerminated;						//@cmember indicate this IME has been terminated
	short	_fSkipFirstOvertype;					//@cmember skip first overtype if selection is 
													//	deleted on StartComposition

	//@access	Public methods
	public:
	
	virtual ~CIme() {};

	INT		_compMessageRefCount;					//@cmember so as not to delete if recursed.
	short	_fDestroy;								//@cmember set when object wishes to be deleted.
													//@cmember	Handle WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter ) = 0;
													//@cmember	Handle WM_IME_COMPOSITION and WM_IME_ENDCOMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter ) = 0;
													//@cmember	Handle post WM_IME_CHAR	to update comp window.
	virtual void PostIMEChar( CTextMsgFilter &TextMsgFilter ) = 0;

													//@cmember	Handle WM_IME_NOTIFY
	virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fCCompWindow ) = 0;

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg ) = 0;

	enum TerminateMode
	{ 
			TERMINATE_NORMAL = 1,
			TERMINATE_FORCECANCEL = 2
	};

	void	TerminateIMEComposition(CTextMsgFilter &TextMsgFilter,
				CIme::TerminateMode mode);			//@cmember	Terminate current IME composition session.
	
													//@cmember	check if we need to ignore WM_IME_CHAR messages
	BOOL	IgnoreIMECharMsg() { return _cIgnoreIMECharMsg > 0; }
													//@cmember	skip WM_IME_CHAR message
	void	SkipIMECharMsg() { _cIgnoreIMECharMsg--; }
													//@cmember	accept WM_IME_CHAR message
	void	AcceptIMECharMsg() { _cIgnoreIMECharMsg = 0; }

	static	void	CheckKeyboardFontMatching ( long cp, CTextMsgFilter &TextMsgFilter, ITextFont *pTextFont );	//@cmember	Check current font/keyboard matching.	

	BOOL	IsTerminated ()							//@cmember	Return _fIMETerminated
	{
		return _fIMETerminated; 
	}

	INT		GetIMELevel () 							//@cmember	Return the current IME level.
	{
		return _imeLevel;
	}


	

	//@access	Protected methods



	protected:										//@cmember	Get composition string, convert to unicode.
	
	static INT GetCompositionStringInfo( HIMC hIMC, DWORD dwIndex, WCHAR *uniCompStr, INT cchUniCompStr, BYTE *attrib, INT cbAttrib, LONG *cursorCP, LONG *cchAttrib, UINT kbCodePage, BOOL bUnicodeIME, BOOL bUsingAimm );
	static HRESULT CheckInsertResultString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter, short *pcch = NULL );


	void	SetCompositionFont ( CTextMsgFilter &TextMsgFilter, ITextFont *pTextFont );	//@cmember	Setup for level 2 and 3 composition and candidate window's font.
	void	SetCompositionForm ( CTextMsgFilter &TextMsgFilter );	//@cmember	Setup for level 2 IME composition window's position.


};

/*
 *	IME_Lev2
 *
 *	@class	Level 2 IME support.
 *
 */
class CIme_Lev2 : public CIme 
{

	//@access	Public methods
	public:											//@cmember	Handle level 2 WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 2 WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle post WM_IME_CHAR	to update comp window.
	virtual void PostIMEChar( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 2 WM_IME_NOTIFY
	virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fIgnore );

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg )
		{return FALSE;}

	CIme_Lev2( CTextMsgFilter &TextMsgFilter );
	virtual ~CIme_Lev2();

	ITextFont	*_pTextFont;						//@cmember  base format	

};

/*
 *	IME_PROTECTED
 *
 *	@class	IME_PROTECTED
 *
 */
class CIme_Protected : public CIme 
{
	//@access	Public methods
	public:											//@cmember	Handle level 2 WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter )
		{_imeLevel	= IME_PROTECTED; return S_OK;}
													//@cmember	Handle level 2 WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle post WM_IME_CHAR	to update comp window.
	virtual void PostIMEChar( CTextMsgFilter &TextMsgFilter )
		{}
													//@cmember	Handle level 2 WM_IME_NOTIFY
	virtual HRESULT IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fIgnore )
		{return S_FALSE;}
	
	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg )
		{return FALSE;}

};

/*
 *	IME_Lev3
 *
 *	@class	Level 3 IME support.
 *
 */
class CIme_Lev3 : public CIme_Lev2 
{
	//@access	Private data
	private:										

	//@access	Protected data
	protected:
	long	_ichStart;								//@cmember	maintain starting ich.
	long	_cchCompStr;							//@cmember	maintain composition string's cch.

	short	_sIMESuportMouse;						//@cmember IME mouse support
	WPARAM	_wParamBefore;							//@cmember Previous wParam sent to IME
	HWND	_hwndIME;								//@cmember current IME hWnd

	long	_crTextColor;							//@cmember current font text color
	long	_crBkColor;								//@cmember current font background color

	// Helper function
													//@cmember get imeshare color for the attribute
	COLORREF GetIMEShareColor(CIMEShare *pIMEShare, DWORD dwAttribute, DWORD dwProperty);	

	//@access	Public methods
	public:											//@cmember	Handle level 3 WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 3 WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle level 3 WM_IME_NOTIFY
	virtual HRESULT	IMENotify (const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter, BOOL fCCompWindow );

	void			SetCompositionStyle ( CTextMsgFilter &TextMsgFilter, UINT attribute, ITextFont *pTextFont );

	CIme_Lev3( CTextMsgFilter &TextMsgFilter );
	virtual ~CIme_Lev3() {};

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg );
	virtual BOOL	IMESupportMouse ( CTextMsgFilter &TextMsgFilter );

	public:

	short		_fUpdateWindow;						//@cmember Update Window after closing CandidateWindow

	long GetIMECompositionStart()
	{ return _ichStart; }

	long GetIMECompositionLen()
	{ return _cchCompStr; }

};

/*
 *	Special IME_Lev3 for Korean Hangeul -> Hanja conversion
 *
 *	@class	Hangual IME support.
 *
 */
class CIme_HangeulToHanja : public CIme_Lev3 
{
	//@access	Private data
	private:

	public:		
	CIme_HangeulToHanja( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle Hangeul WM_IME_STARTCOMPOSITION
	virtual HRESULT StartComposition ( CTextMsgFilter &TextMsgFilter );
													//@cmember	Handle Hangeul WM_IME_COMPOSITION
	virtual HRESULT CompositionString ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );

	virtual BOOL	IMEMouseOperation ( CTextMsgFilter &TextMsgFilter, UINT	msg )
		{return FALSE;}
};

// Glue functions to call the respective methods of an IME object stored in the ed.
HRESULT StartCompositionGlue ( CTextMsgFilter &TextMsgFilter  );
HRESULT CompositionStringGlue ( const LPARAM lparam, CTextMsgFilter &TextMsgFilter );
HRESULT EndCompositionGlue ( CTextMsgFilter &TextMsgFilter, BOOL fForceDelete);
void	PostIMECharGlue ( CTextMsgFilter &TextMsgFilter );
HRESULT IMENotifyGlue ( const WPARAM wparam, const LPARAM lparam, CTextMsgFilter &TextMsgFilter ); // @parm the containing text edit.
HRESULT	IMEMouseCheck(CTextMsgFilter &TextMsgFilter, UINT *pmsg, WPARAM *pwparam, LPARAM *plparam, LRESULT *plres);

// IME helper functions.
void	IMECompositionFull ( CTextMsgFilter &TextMsgFilter );
LRESULT	OnGetIMECompositionMode ( CTextMsgFilter &TextMsgFilter ); 
BOOL	IMECheckGetInvertRange(CTextMsgFilter *ed, LONG &, LONG &);
void	CheckDestroyIME ( CTextMsgFilter &TextMsgFilter );
BOOL	IMEHangeulToHanja ( CTextMsgFilter &TextMsgFilter );
BOOL	IMEMessage ( CTextMsgFilter &TextMsgFilter, UINT uMsg, 
					WPARAM wParam, LPARAM lParam, BOOL bPostMessage );
HIMC	LocalGetImmContext ( CTextMsgFilter &TextMsgFilter );
void	LocalReleaseImmContext ( CTextMsgFilter &TextMsgFilter, HIMC hIMC );

long	IMEShareToTomUL ( UINT ulID );

#endif // define _IME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_ldte.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _LDTE.H - Lighweight Data Transfer Engine |
 *
 *		Declaration for CLightDTEngine class
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef __LDTE_H__
#define __LDTE_H__

#include "_m_undo.h"
#include "_dragdrp.h"

class CTxtRange;
class CTxtEdit;

/*
 *	DataObjectInfo
 *
 *	Purpose:
 *		enumeration of bit flags used to indicate what operations
 *		are possible from a given data object.
 */

typedef enum tagDataObjectInfo
{
	DOI_NONE			= 0,
	DOI_CANUSETOM		= 1,	// TOM<-->TOM optimized data transfers
	DOI_CANPASTEPLAIN	= 2,	// plain text pasting available
	DOI_CANPASTERICH	= 4, 	// rich text pasting available 
	DOI_CANPASTEOLE		= 8,	// object may be pasted as an OLE embedding
								// (note that this flag may be combined with
								// others). 
} DataObjectInfo;

class CLightDTEngine;

typedef struct _READHGLOBAL
{								// Used by RtfHGlobalToRange()
	LPSTR	ptext;				// ANSI string remaining to be read
	LONG	cbLeft;				// Bytes remaining (might exceed string len)
} READHGLOBAL;

typedef struct _WRITEHGLOBAL
{								// Used by RtfHGlobalToRange()
	HGLOBAL	hglobal;
	LONG	cch;				// Count of ASCII chars written (a cb)
	LONG	cb;					// Count of bytes in hglobal
} WRITEHGLOBAL;

// the following macro (should be an in-line function...) defines
// the formula by which in-memory buffers will grow. It is exponential
// (sort of "if we needed this much memory, chances are we'll need at
// least as much more) but the actual growth factor should be played with
// to achieve better performance across most common scenarios
#define GROW_BUFFER(cbCurrentSize, cbRequestedGrowth)  (ULONG)max(2*(cbCurrentSize), (cbCurrentSize) + 2*(cbRequestedGrowth))

//DWORD packed flags for PasteDataObjectToRange.  Make sure new values
//are assigned such that flags can be or'd together.
#define PDOR_NONE		0x00000000 //No flags
#define PDOR_NOQUERY	0x00000001 //Do not call QueryAcceptData
#define PDOR_DROP		0x00000002 //This is a drop operation

class CLightDTEngine
{
public:
	CLightDTEngine();

	~CLightDTEngine();

	void Init(CTxtEdit * ped);

	void ReleaseDropTarget();

	void Destroy();

	// clipboard
	HRESULT CopyRangeToClipboard( CTxtRange *prg );
	HRESULT CutRangeToClipboard(  CTxtRange *prg, 
										IUndoBuilder *publdr );
	DWORD	CanPaste( IDataObject *pdo, CLIPFORMAT cf, DWORD flags );

	void	FlushClipboard(void);

	// data object
	HRESULT RangeToDataObject( CTxtRange *prg, LONG lStreamFormat,
										IDataObject **ppdo );
	HRESULT PasteDataObjectToRange( IDataObject *pdo, CTxtRange *prg, 
									CLIPFORMAT cf, REPASTESPECIAL *rps,
									IUndoBuilder *publdr, DWORD dwFlags );
	HRESULT CreateOleObjFromDataObj( IDataObject *pdo, CTxtRange *prg, 
									 REPASTESPECIAL *rps, INT iFormatEtc,
									 IUndoBuilder *publdr );

	// drag drop
	HRESULT GetDropTarget( IDropTarget **ppDropTarget );
	HRESULT StartDrag( CTxtSelection *psel, IUndoBuilder *publdr );
	BOOL fInDrag();

	// file I/O
	LONG LoadFromEs( CTxtRange *prg, LONG lStreamFormat, EDITSTREAM *pes, 
							 BOOL fTestLimit, IUndoBuilder *publdr);
	LONG SaveToEs(	 CTxtRange *prg, LONG lStreamFormat,
							 EDITSTREAM *pes );

	// conversion routines
	HGLOBAL AnsiPlainTextFromRange( CTxtRange *prg );
	HGLOBAL UnicodePlainTextFromRange( CTxtRange *prg );
	HGLOBAL RtfFromRange( CTxtRange *prg, LONG lStreamFormat );

	// direct clipboard support
	HRESULT RenderClipboardFormat(WPARAM wFmt);
	HRESULT RenderAllClipboardFormats();
	HRESULT DestroyClipboard();

	LONG 	ReadPlainText( CTxtRange *prg, EDITSTREAM *pes, BOOL fTestLimit,
								IUndoBuilder *publdr, LONG lStreamFormat);
protected:

	LONG	WritePlainText( CTxtRange *prg, EDITSTREAM *pes, LONG lStreamFormat);
	HRESULT HGlobalToRange(DWORD dwFormatIndex, HGLOBAL hGlobal, LPTSTR ptext,
									CTxtRange *prg,	IUndoBuilder *	publdr);
	HRESULT DIBToRange(HGLOBAL hGlobal,	CTxtRange *prg,	IUndoBuilder *	publdr);
	LONG	GetStreamCodePage(LONG lStreamFormat);

	CTxtEdit *		_ped;
	CDropTarget *	_pdt;		// the current drop target
	IDataObject *	_pdo;		// data object that may be on the clipboard.
	BYTE			_fUseLimit;	// Whether to use limit text in calculation
								// Note: if we need more flags do the bit 
								// field thing.
	BYTE			_fOleless;  // Ole clipboard support?
};

/*
 *	CLightDTEngine::Init (ped)
 *
 *	@mfunc
 *		initializes the object
 */
inline void CLightDTEngine::Init(
	CTxtEdit *ped)					// @parm text 
{
	_ped = ped;
}

/*
 *	CLightDTEngine::ReleaseDropTarget (ped)
 *
 *	@mfunc
 *		Releases the drop target if there is one.
 */
inline void CLightDTEngine::ReleaseDropTarget()
{
	if (_pdt)
	{
		_pdt->Release();
		_pdt = NULL;
	}
}

/*
 *	CLightDTEngine::fInDrag ()
 *
 *	@mfunc
 *		Tells whether a drag operation is occuring
 */
inline BOOL CLightDTEngine::fInDrag()
{
	return (_pdt != NULL) ? _pdt->fInDrag() : FALSE;
}

#endif // !__LDTE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_invar.h ===
/*
 *
 *
 *	_INVAR.H
 *	
 *	Purpose:
 *		Template class designed to call parameterized object's Invariant().
 *
 *	Overview (see also, usage):
 *		1)	declare and define a public const function BOOL Invariant( void ) in your class, with #ifdef DEBUG.
 *		2)	in the source: #define DEBUG_CLASSNAME to be the name of the class you're debugging.
 *		3)	followed by #include "_invar.h"
 *		4)	For every method you wish to check Invariants,
 *			insert the _TEST_INVARIANT_ macro once, usually at the beginning of a routine.
 *			OPTIONAL: You may optionally use the _TEST_INVARIANT_ON (x) to call x's Invariant directly.
 *
 *	Notes:
 *		Invariants are designed to be called at the beginning and upon exit of a routine, 
 *		testing the consistent properties of an object which remain invariant--always the same.
 *
 *		Functions may temporarily make an object inconsistent during their execution.
 *		A generalized invariant test should not be called during these inconsistent times;
 *		if there is a need for a function, which checks invariants, to be called during
 *		an inconsistent object state, a solution will need to be designed--the current design
 *		does not facilitate this.
 *
 *		Because it is entirely possible for an Invariant() function to recurse on itself
 *		causing a stack overflow, the template explicitly prevents this from happening.
 *		The template also prevents invariant-checking during the processing of Assert(),
 *		preventing another type of recursion.
 *
 *		Currently Invariant() returns a BOOL, as I think this allows for it to be called
 *		from the QuickWatch window under VC++2.0. TRUE indicates that the invariant executed
 *		normally.
 *
 *	Usage:
 *		-the _invariant.h header should only be included in source files. An error will occur
 *			if included in another header file. This is to prevent multiple #define DEBUG_CLASSNAME.
 *		-Typical #include into a source file looks like this:
			#define DEBUG_CLASSNAME ClassName
			#include "_invar.h"
 *		-Typical definition of a class' Invariant() method looks like this:
			#ifdef DEBUG
				public:
				BOOL Invariant( void ) const;
				protected:
			#endif	// DEBUG
 *		-Typical declaration of Invariant() looks like this:
			#ifdef DEBUG

			BOOL
			ClassName::Invariant( void ) const
			{
				static LONG	numTests = 0;
				numTests++;				// how many times we've been called.

				// do mega-assert checking here.

				return TRUE;
			}

			#endif	// DEBUG
 *
 *
 *		
 *	
 *	Author:
 *		Jon Matousek (jonmat) 5/04/1995
 *
 *		Any problems? Please let me know.
 */

#ifndef _INVARIANT_H

#define _INVARIANT_H

#ifndef DEBUG_CLASSNAME
prior to including _invariant.h file, you must define DEBUG_CLASSNAME
to be the name of the class for which you are making Invariant() calls.
#endif


#ifdef DEBUG

template < class T >
class InvariantDebug
{
	public:
	InvariantDebug	( const T & t) : _t(t)
 	{
		static volatile BOOL fRecurse = FALSE;

		if ( fRecurse )	return;		/* Don't allow recursion.*/
		
		fRecurse = TRUE;

		_t.Invariant();

		fRecurse = FALSE;
	}

	~InvariantDebug	()
	{
		static volatile BOOL fRecurse = FALSE;

		if ( fRecurse )	return;		/* Don't allow recursion.*/
		
		fRecurse = TRUE;

		_t.Invariant();

		fRecurse = FALSE;
	}

	private:
	 const T &_t;
};

typedef InvariantDebug<DEBUG_CLASSNAME> DoInvariant;

#define _TEST_INVARIANT_ DoInvariant __invariant_tester( *this );
#define _TEST_INVARIANT_ON(x) \
					{\
						static volatile BOOL fRecurse = FALSE;\
						if (FALSE == fRecurse )\
						{\
							fRecurse = TRUE;\
							(x).Invariant();\
							fRecurse = FALSE;\
						}\
					}

#else	// DEBUG

#define _TEST_INVARIANT_
#define _TEST_INVARIANT_ON(x)

#endif	// DEBUG


	// code that should be at the start and end of all Invariant() methods.

#else	// INVARIANT_H

	This file should only be included once per source file. jonmat

#endif	// INVARIANT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_format.h ===
/*
 *	_FORMAT.H
 *	
 *	Purpose:
 *		CCharFormatArray and CParaFormatArray
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _FORMAT_H
#define _FORMAT_H

#include "textserv.h"

#define celGrow     8
#define FLBIT		0x80000000

//+-----------------------------------------------------------------------
// 	Interface IFormatCache
// 	Interface ICharFormatCache
// 	Interface IParaFormatCache
//
//	Format caches - Used by the host to manage the cache of CHARFORMAT
// 	and PARAFORMAT structures.  Note that these interfaces DON'T derive from
//  IUnknown
//------------------------------------------------------------------------

interface IFormatCache
{
	virtual LONG		AddRef(LONG iFormat) = 0;
	virtual LONG	 	Release(LONG iFormat) = 0;
	virtual void		Destroy() = 0;
};

template <class FORMAT>
interface ITextFormatCache : public IFormatCache
{
	virtual HRESULT 	Cache(const FORMAT *pFormat, LONG *piFormat) = 0;
	virtual HRESULT		Deref(LONG iFormat, const FORMAT **ppFormat) const = 0;
};

interface ICharFormatCache : public ITextFormatCache<CCharFormat>
{
};

interface IParaFormatCache : public ITextFormatCache<CParaFormat>
{
};

void	ReleaseFormats(LONG iCF, LONG iPF);

HRESULT	CreateFormatCaches();
HRESULT	DestroyFormatCaches();


// ===========================  CFixArray  =================================

// This array class ensures stability of the indexes. Elements are freed by
// inserting them in a free list, and the array is never shrunk.
// The first UINT of ELEM is used to store the index of next element in the
// free list.

class CFixArrayBase
{
private:
	char*	_prgel;			// array of elements
	LONG 	_cel;			// total count of elements (including free ones)
	LONG	_ielFirstFree; 	// - first free element
	LONG 	_cbElem;		// size of each element

public:
	CFixArrayBase (LONG cbElem);
	~CFixArrayBase ()				{Free();}

	void*	Elem(LONG iel) const	{return _prgel + iel * _cbElem;}
	LONG 	Count() const			{return _cel;}

	LONG 	Add ();
	void 	Free (LONG ielFirst);
	void 	Free ();

	HRESULT	Deref  (LONG iel, const void **ppel) const;
	LONG	AddRef (LONG iel);
	LONG	Release(LONG iel);
	HRESULT	Cache  (const void *pel, LONG *piel);

#ifdef DEBUG
	void CheckFreeChainFn(LPSTR szFile, INT nLine); 
#endif

protected:
	LONG &	RefCount(LONG iel);

private:
	LONG	Find   (const void *pel);
};

template <class ELEM> 
class CFixArray : public CFixArrayBase
{
public:
	CFixArray () : CFixArrayBase (sizeof(ELEM)) 	{}
											//@cmember Get ptr to <p iel>'th
	ELEM *	Elem(LONG iel) const			// element
			{return (ELEM *)CFixArrayBase::Elem(iel);}

protected:									//@cmember Get ptr to <p iel>'th
	LONG &	RefCount(LONG iel)				// ref count
			{return CFixArrayBase::RefCount(iel);}
};

#ifdef DEBUG
#define CheckFreeChain()\
			CheckFreeChainFn(__FILE__, __LINE__)
#else
#define CheckFreeChain()
#endif // DEBUG


//================================  CCharFormatArray  ==============================

class CCharFormatArray : public CFixArray<CCharFormat>, public ICharFormatCache
{
protected:
	LONG 	Find(const CCharFormat *pCF);

public:
	CCharFormatArray() : CFixArray<CCharFormat>()	{}

	// ICharFormatCache
	virtual HRESULT		Cache(const CCharFormat *pCF, LONG *piCF);
	virtual HRESULT		Deref(LONG iCF, const CCharFormat **ppCF) const;
	virtual LONG	 	AddRef(LONG iCF);
	virtual LONG	 	Release(LONG iCF);
	virtual void		Destroy();
};


//===============================  CParaFormatArray  ==================================

class CParaFormatArray : public CFixArray<CParaFormat>, public IParaFormatCache
{
protected:	
	LONG 	Find(const CParaFormat *pPF);

public:
	CParaFormatArray() : CFixArray<CParaFormat>()	{}

	// IParaFormatCache
	virtual HRESULT 	Cache(const CParaFormat *pPF, LONG *piPF);
	virtual HRESULT		Deref(LONG iPF, const CParaFormat **ppPF) const;
	virtual LONG	 	AddRef(LONG iPF);
	virtual LONG	 	Release(LONG iPF);
	virtual void		Destroy();
};


//===============================  CTabsArray  ==================================

class CTabsArray : public CFixArray<CTabs>
{
protected:	
	LONG 		Find(const LONG *prgxTabs, LONG cTab);

public:
	CTabsArray() : CFixArray<CTabs>()	{}
	~CTabsArray();

	LONG 		Cache(const LONG *prgxTabs, LONG cTab);
	const LONG *Deref(LONG iTabs) const;

	LONG	 	AddRef (LONG iTabs);
	LONG	 	Release(LONG iTabs);
};

// Access to the format caches
ICharFormatCache *GetCharFormatCache();
IParaFormatCache *GetParaFormatCache();
CTabsArray		 *GetTabsCache();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_line.h ===
/*
 *	_LINE.H
 *	
 *	Purpose:
 *		CLine class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#ifndef _LINE_H
#define _LINE_H

#include "_runptr.h"

class CDisplay;
class CMeasurer;
class CRenderer;
class CDispDim;

// ============================	 CLine	=====================================
// line - keeps track of a line of text
// All metrics are in rendering device units

class CLine : public CTxtRun
{
public:
	LONG	_xLeft;			// Line left position (line indent + line shift)
	LONG	_xWidth;		// Line width not incl _xLeft, trailing whitespace
	SHORT	_yHeight;		// Line height
	SHORT	_yDescent;		// Distance from baseline to bottom of line
	SHORT	_xLineOverhang;	// Overhang for the line. 
	WORD	_cchWhite;		// Count of white chars at end of line

	BYTE	_cchEOP;		// Count of EOP chars; 0 if no EOP this line
	BYTE	_bFlags;		// Flags defined below

	BYTE	_bNumber;		// Abstract paragraph number (0 is unnumbered)
	BYTE	_nHeading:4;	// Heading level (0 if not heading)
	BYTE	_fCollapsed:1;	// TRUE if line is collapsed
	BYTE	_fNextInTable:1;// TRUE if next line is in table

public:
	CLine ()	{}
	
	// !!!!! CLine should not have any virtual methods !!!!!!

	// The "big four" line methods: measure, render, CchFromXpos, XposFromCch 
	BOOL Measure (CMeasurer& me, LONG cchMax, LONG xWidth,
				 UINT uiFlags, CLine *pliTarget = NULL);
	BOOL Render (CRenderer& re);

	LONG CchFromXpos(CMeasurer& me, POINT pt, CDispDim *pdispdim = NULL,
					 HITTEST *pHit = NULL, LONG *pcpActual = NULL) const;
	LONG XposFromCch(CMeasurer& me, LONG cchMax, UINT taMode,
					 CDispDim *pdispdim = NULL, LONG *pdy = NULL) const;

	// Helper functions
	LONG GetHeight () const;
	void Init ()					{ZeroMemory(this, sizeof(CLine));}
	BOOL IsEqual (CLine& li);
};

// Line flags
#define fliHasEOP			0x0001		// True if ends with CR or LF
#define fliHasSpecialChars	0x0002		// Has special characters (Euro, etc.)
#define fliHasTabs			0x0004		// set if tabs, *not* iff tabs
#define fliHasOle			0x0008
#define fliFirstInPara		0x0010
#define fliUseOffScreenDC	0x0020		// Line needs to be rendered off
										//  screen to handle change in fonts
#define fliOffScreenOnce	0x0040		// Only render off screen once. Used
										//  for rendering 1st line of an edit
#define fliHasSurrogates	0x0080		// Has Unicode surrogate chars


// ==========================  CLineArray  ===================================
// Array of lines

typedef CArray<CLine>	CLineArray;

// ==========================  CLinePtr	 ===================================
// Maintains position in a array of lines

class CLinePtr : public CRunPtr<CLine>
{
protected:
	CDisplay *	_pdp;
	CLine *		_pLine;	

public:
	CLinePtr (CDisplay *pdp);
	CLinePtr (CLinePtr& rp) : CRunPtr<CLine> (rp)	{}

	void Init ( CLine & );
	void Init ( CLineArray & );
    
	// Alternate initializer
	void 	RpSet(LONG iRun, LONG ich);

	// Direct cast to a run index
	operator LONG() const			{return _iRun;}

	// Get the run index (line number)
	LONG GetLineIndex(void)			{return _iRun;}
	LONG GetAdjustedLineLength();

	LONG GetIch() const				{return _ich;}
	LONG GetCchLeft() const;

	// Dereferencing
	BOOL	IsValid(); 
	CLine *	operator ->() const;		
    CLine &	operator *() const;      
	CLine & operator [](LONG dRun);
	CLine * GetLine() const;
	WORD	GetNumber();
	WORD	GetHeading()	{return GetLine()->_nHeading;}
    
	// Pointer arithmetic
	BOOL	operator --(int);
	BOOL	operator ++(int);

	// Character position control
	LONG	RpGetIch() const		{return _ich;}
	BOOL	RpAdvanceCp(LONG cch);
	BOOL	RpSetCp(LONG cp, BOOL fAtEnd);
    BOOL	OperatorPostDeltaSL(LONG Delta);
    BOOL	RpAdvanceCpSL(LONG cch);

	// Array management 
    // These should assert, but gotta be here
    
    // Strictly speaking, these members should never be called for the single
    // line case.  The base class better assert
    
	void Remove (LONG cRun)
    {
        CRunPtr<CLine>::Remove(cRun);
    }

	BOOL Replace(LONG cRun, CArrayBase *parRun)
    {
        return CRunPtr<CLine>::Replace(cRun,parRun);
    }
	
	// Assignment from a run index
	CRunPtrBase& operator =(LONG iRun) {SetRun(iRun, 0); return *this;}

	LONG	FindParagraph(BOOL fForward);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_ls.h ===
/*
 *  _LS.H
 *  
 *  Purpose:
 *		Line Services wrapper object class used to connect RichEdit with
 *		Line Services.
 *  
 *  Author:
 *		Murray Sargent
 *
 *	Copyright (c) 1997-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _LS_H
#define _LS_H

extern "C" {
#define ols COls
#define lsrun CLsrun
#define lscontext CLineServices
#include "lscbk.h"
#include "lsdnfin.h"
#include "lsdnset.h"
#include "lstxtcfg.h"
#include "lsimeth.h"
#include "plsline.h"
#include "lslinfo.h"
#include "lschp.h"
#include "lspap.h"
#include "plspap.h"
#include "lstxm.h"
#include "lsdevres.h"
#include "lscontxt.h"
#include "lscrline.h"
#include "lsqline.h"
#include "lssetdoc.h"
#include "lsdsply.h"
#include "heights.h"
#include "lsstinfo.H"
#include "lsulinfo.H"
#include "plsstinf.h"
#include "plsulinf.h"
#include "plstabs.h"
#include "lstabs.h"
#include "robj.h"
#include "ruby.h"
#include "tatenak.h"
#include "warichu.h"
#include "lsffi.h"
#include "lstfset.h"
#include "lsqsinfo.h"
#include "lscell.h"
}

struct CLineServices
{
public:

LSERR WINAPI CreateLine(LSCP cp, long duaWidth,
						BREAKREC *pBreakRecIn,  DWORD cBreakRecIn, DWORD cMaxOut,
						BREAKREC *pBreakRecOut, DWORD *pcBreakRecOut,
						LSLINFO* plsinfo, PLSLINE* pplsline)
				{return LsCreateLine(this, cp, duaWidth,
							pBreakRecIn,  cBreakRecIn, cMaxOut,
							pBreakRecOut, pcBreakRecOut,
							plsinfo, pplsline);}


LSERR WINAPI SetBreaking(DWORD cLsBrk, const LSBRK* rgLsBrk,
					DWORD cKinsokuCat, const BYTE *prgbrkpairsKinsoku)

				{return LsSetBreaking(this, cLsBrk, rgLsBrk,
								cKinsokuCat, prgbrkpairsKinsoku);}

LSERR WINAPI SetDoc(BOOL fDisplay, BOOL fEqualRes, const LSDEVRES* plsdevres)
				{return LsSetDoc(this, fDisplay, fEqualRes, plsdevres);}

LSERR WINAPI DestroyLine(PLSLINE plsline)
				{return LsDestroyLine(this, plsline);}

LSERR WINAPI dnFinishRegular(LSDCP cp, PLSRUN plsrun, PCLSCHP pclschp, PDOBJ pdobj, PCOBJDIM pcobjdim)
				{return LsdnFinishRegular(this, cp, plsrun, pclschp, pdobj, pcobjdim);}

LSERR WINAPI dnQueryObjDimRange(PLSDNODE plsdnode1, PLSDNODE plsdnode2, POBJDIM pobjdim)
				{return LsdnQueryObjDimRange(this, plsdnode1, plsdnode2, pobjdim);}
 
LSERR WINAPI dnSetRigidDup(PLSDNODE plsdnode, LONG dup)
				{return LsdnSetRigidDup(this, plsdnode, dup);}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_m_undo.h ===
/*
 *	_M_UNDO.H
 *
 *	Purpose:
 *		declares multi-level undo interfaces and classes
 *
 *	Author:
 *		alexgo  3/25/95
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef __M_UNDO_H__
#define __M_UNDO_H__

#include "_callmgr.h"

// Forward declaration to get around dependency cycle
class CTxtEdit;
class IUndoBuilder;

/*
 *	MergeDataTypes
 *
 *	@enum	Tags indicating the different data types that can be
 *			sent in IAntiEvent::MergeData
 */
enum MergeDataTypes
{
	MD_SIMPLE_REPLACERANGE	= 1,	//@emem a simple replace range; 
									//usually just typing or backspace
	MD_SELECTIONRANGE		= 2		//@emem the selection location
};

/*
 *	SimpleReplaceRange
 *
 *	@stuct	SimpleReplaceRange | has the data from a replace range operation
 *			*except* for any deleted characters.  If we don't have to save
 *			the deleted characters, we don't.
 */
struct SimpleReplaceRange
{
	LONG	cpMin;		//@field	cpMin of new text
	LONG	cpMax;		//@field	cpMax of new text
	LONG	cchDel;		//@field 	number of characters deleted
};

/*
 *	SELAEFLAGS
 *
 *	@enum	Flags to control how the selection range info should be treated
 */
enum SELAE
{
	SELAE_MERGE = 1,
	SELAE_FORCEREPLACE	= 2
};

/*
 *	SelRange
 *
 *	@struct SelRange | has the data for a selection's location _and_ the 
 *			information needed to generate an undo action for the selection
 *			placement
 *	
 *	@comm	-1 may be used to NO-OP any field
 */
struct SelRange
{
	LONG	cp;			//@field	Active end
	LONG	cch;		//@field	Signed extension
	LONG	cpNext;		//@field	cp for the inverse of this action
	LONG	cchNext;	//@field	Extension for the inverse of this action
	SELAE	flags;		//@field	Controls how this info is interpreted
};

/*
 *	IAntiEvent
 *
 *	Purpose:
 *		AntiEvents undo 'normal' events, like typing a character
 */

class IAntiEvent 
{
public:
	virtual void Destroy( void ) = 0;

	// It should be noted that CTxtEdit * here is really just a general
	// closure, i.e. it could be expressed by void *.  However, since
	// this interface is currently just used internally, I've opted
	// to use the extra type-checking.  alexgo
	virtual HRESULT Undo( CTxtEdit *ped, IUndoBuilder *publdr ) = 0;

	// This method will let us merge in arbitrary data for things like
	// group typing
	virtual HRESULT MergeData( DWORD dwDataType, void *pdata) = 0;

	// This method is called when anti-event is committed to undo stack.
	// Allows us to handle re-entrancy better for OLE objects.
	virtual void OnCommit(CTxtEdit *ped) = 0;

	// These two methods allow AntiEvents to be chained together in
	// a linked list
	virtual	void SetNext( IAntiEvent *pNext ) = 0;
	virtual IAntiEvent *GetNext( void ) = 0;
protected:
	~IAntiEvent() {;}
};

/*
 *	IUndoMgr
 *
 *	Purpose:
 *		interface for managing "stacks" of anti-events
 */

class IUndoMgr
{
public:
	virtual void Destroy( void ) = 0;
	virtual DWORD SetUndoLimit( DWORD dwLim ) = 0;
	virtual DWORD GetUndoLimit( ) = 0;
	virtual HRESULT PushAntiEvent( UNDONAMEID idName, IAntiEvent *pae ) = 0;
	virtual HRESULT PopAndExecuteAntiEvent( void* pAE) = 0;
	virtual UNDONAMEID GetNameIDFromAE( void *pAE) = 0;
	virtual IAntiEvent *GetMergeAntiEvent( void ) = 0;
	virtual void* GetTopAECookie( void ) = 0;
	virtual	void ClearAll() = 0;
	virtual BOOL CanUndo() = 0;
	virtual void StartGroupTyping() = 0;
	virtual void StopGroupTyping() = 0;

protected:
	~IUndoMgr() {;}
};

/*
 *	USFlags
 *
 *	@enum
 *		flags affecting the behaviour of Undo stacks
 */

enum USFlags
{
	US_UNDO				= 1,	//@emem regular undo stack
	US_REDO				= 2		//@emem	Undo stack is for REDO functionality
};
	
/*
 *	CUndoStack
 *	
 *	@class
 *		manages a stack of anti-events.  These anti-events are kept in
 *		a resizable ring buffer.  exports the IUndoMgr interface
 */

class CUndoStack : public IUndoMgr
{
//@access	Public Methods
public:
	virtual void Destroy( void );				//@cmember Destroy
	virtual DWORD SetUndoLimit( DWORD dwLim );	//@cmember Set item limit
	virtual DWORD GetUndoLimit();
	virtual HRESULT PushAntiEvent(UNDONAMEID idName, IAntiEvent *pae); //@cmember
												// add an AE to the stack
	virtual HRESULT PopAndExecuteAntiEvent( void *pAE); //@cmember 
												// execute the most recent anti
												// event or up to dwDoToCookie
	virtual UNDONAMEID GetNameIDFromAE( void *pAE);//@cmember Get
												//name of the given AE
	virtual IAntiEvent *GetMergeAntiEvent( void ); //@cmember get the most
												//recent AE of the merge state
	virtual void* GetTopAECookie( void );	 	//@cmember get a cookie for the
												//top AE

	virtual	void ClearAll();					//@cmember delete all AEs
	virtual BOOL CanUndo();						//@cmember something to undo?
	virtual void StartGroupTyping();			//@cmember starts group typing
	virtual void StopGroupTyping();				//@cmember stops group typing

	// Public methods; not part of IUndoMgr
	HRESULT	EnableSingleLevelMode();			//@cmember RE1.0 undo mode
	void	DisableSingleLevelMode();			//@cmember back to RE2.0 mode
												//@cmember are we in 1.0 mode?
	BOOL	GetSingleLevelMode() { return _fSingleLevelMode; }

	CUndoStack( CTxtEdit *ped, DWORD & rdwLim, USFlags flags );

private:
	~CUndoStack();

	struct UndoAction
	{
		IAntiEvent *	pae;
		UNDONAMEID		id;
	};

	void Next( void );							//@cmember advances by 1		
	void Prev( void );							//@cmember advances by -1
	DWORD GetPrev( void );						//@cmember get previous index
												//@cmember TRUE iff cookie
												// ae in in ae list 
	BOOL IsCookieInList( IAntiEvent *pae, IAntiEvent *paeCookie);
												//@cmember transfer this object to
												// a new stack
	void TransferToNewBuffer(UndoAction *prgnew, DWORD dwLimNew);

	UndoAction *_prgActions;					//@cmember The list of AEs

	DWORD 		_dwLim;							//@cmember the undo limit
	DWORD		_index;							//@cmember current index
	CTxtEdit *	_ped;							//@cmember Big Papa

	unsigned long	_fGroupTyping	: 1;		//@cmember Group Typing flag
	unsigned long	_fMerge			: 1;		//@cmember Merge flag
	unsigned long	_fRedo			: 1;		//@cmember Stack is the redo
												// stack.
	unsigned long	_fSingleLevelMode :1;		//@cmember Indicates if single
												// level undo mode is on. Valid
												// only for the undo stack
												// but not the redo stack
};

/*
 *	IUndoBuilder
 *
 *	Purpose:
 *		provides a closure for collecting a sequence of anti-events (such
 *		as all of the anti-events involved in doing an intra-edit drag-move
 *		operation.
 */

class IUndoBuilder
{
public:
	// Names anti-event collection
	virtual void SetNameID( UNDONAMEID idName ) = 0;

	// Adds a new anti-event to the collection
	virtual HRESULT AddAntiEvent( IAntiEvent *pae ) = 0;

	// Gets top most anti-event in this undo context.  This method
	// is useful for grouped typing (merging anti-events)
	virtual IAntiEvent *GetTopAntiEvent( ) = 0;

	// Commits anti-event collection
	virtual HRESULT Done( void ) = 0;

	// Get rid of any anti-events that have been collected.
	virtual void Discard( void ) = 0;

	// Notify that a group-typing session should start (forwarded
	// to the undo manager)
	virtual void StartGroupTyping() = 0;

	// Notify that a group-typing session should stop (forwarded
	// to the undo manager)
	virtual void StopGroupTyping() = 0;
};  

/*
 *	UBFlags
 *
 *	@enum
 *		flags affecting the behaviour of Undo builders
 */

enum UBFlags
{
	UB_AUTOCOMMIT		= 1,	//@emem call IUndoBuilder::Done before delete
	UB_REDO				= 2,	//@emem	Undo builder is for REDO functionality
	UB_DONTFLUSHREDO	= 4		//@emem don't flush redo stack when adding
								// anti-events to the undo stack
};

/*
 *	CGenUndoBuilder
 *
 *	@class
 *		A general purpose undo builder.  It can be easily allocated and freed
 *		on the stack and simply puts new anti-events at the beginning of an
 *		anti-event linked list.  NO attempt is made to optimize or reorder
 *		anti-events.
 */

class CGenUndoBuilder : public IUndoBuilder, public IReEntrantComponent
{
//@access	Public methods
public:
	virtual void SetNameID( UNDONAMEID idName );	//@cmember set the name
	virtual HRESULT AddAntiEvent(IAntiEvent *pae);	//@cmember add an AE
	virtual IAntiEvent *GetTopAntiEvent( );			//@cmember get top AE
	virtual HRESULT Done( void );					//@cmember Commit AEs
	virtual void Discard( void );					//@cmember Discard AEs
	virtual void StartGroupTyping(void);			//@cmember start GT
	virtual void StopGroupTyping(void);				//@cmember stop GT

	CGenUndoBuilder(CTxtEdit *ped, DWORD flags,		//@cmember Constructor
					IUndoBuilder **ppubldr = NULL);
	~CGenUndoBuilder( );							//@cmember Destructor

	// IReEntrantComponent methods
	virtual void OnEnterContext() {;}				//@cmember reentered notify

//@access	Private methods
private:
	IUndoBuilder *	_publdrPrev;					//@cmember Ptr to undobldr
													//		   higher in stack
	IUndoMgr *		_pundo;							//@cmember Ptr to undo mgr
	CTxtEdit *		_ped;							//@cmember Ptr to edit contxt
	UNDONAMEID		_idName;						//@cmember current name
	IAntiEvent *	_pfirstae;						//@cmember AE list
	UINT			_fAutoCommit:1;					//@cmember AutoCommit on?
	UINT			_fStartGroupTyping:1;			//@cmember GroupTyping on?
	UINT			_fRedo:1;						//@cmember UB destination is
													// the redo stack
	UINT			_fDontFlushRedo:1;				//@cmember Don't flush redo
													// stack; i.e. we are
													// invoking a redo action
	UINT			_fInactive:1;					//@cmember TRUE if undo enabled
};


/*
 *	CUndoStackGuard
 *
 *	@class
 *		A stack based class which helps manage re-entrancy for the undo stack.
 */
class CUndoStackGuard : public IReEntrantComponent
{
//@access	Public Methods
public:
	virtual void OnEnterContext();					//@cmember reentered notify

	CUndoStackGuard(CTxtEdit *ped);					//@cmember Constructor
	~CUndoStackGuard();								//@cmember Destructor

													//@cmember Execute the undo
													// actions in <p pae>
	HRESULT SafeUndo(IAntiEvent *pae, IUndoBuilder *publdr);
	BOOL	WasReEntered()  { return _fReEntered; }	//@cmember return the 
													// re-entered flag

//@access	Private Data
private:
	CTxtEdit *				_ped;					//@cmember Edit context
	volatile IAntiEvent *	_paeNext;				//@cmember Loop index for
													// the ae's
	volatile HRESULT		_hr;					//@cmember Cached hr
	IUndoBuilder *			_publdr;				//@cmember Undo/redo
													// context
	BOOL					_fReEntered;			//@cmember Have we been
													// been re-entered?
};

// Helper Functions. 

// Loop through a chain of anti-events and destroy them
void DestroyAEList(IAntiEvent *pae);

// Loop through a chain of anti-events and call OnCommit
void CommitAEList(IAntiEvent *pae, CTxtEdit *ped);

// Handles merging and/or creation of selection anti-event info
HRESULT HandleSelectionAEInfo(CTxtEdit *ped, IUndoBuilder *publdr, 
			LONG cp, LONG cch, LONG cpNext, LONG cchNext, SELAE flags);

#endif // !__M_UNDO_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_notmgr.h ===
/*
 *	_NOTMGR.H
 *
 *	Purpose:
 *		Notification Manager declarations
 *
 *	Author:
 *		AlexGo	6/5/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _NOTMGR_H_
#define _NOTMGR_H_

// forward declaration
class CNotifyMgr;

// Set cp to this to signal that the control has converted from rich to plain.
const DWORD CONVERT_TO_PLAIN = 0xFFFFFFFE;


/*
 *	ITxNotify
 *
 *	Purpose:
 *		a notification sink for events happening to the backing store,
 *		used by the Notification Manager
 */
class ITxNotify
{
public:
	virtual void OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
					LONG cpFormatMin, LONG cpFormatMax ) = 0;
	virtual void OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
					LONG cpFormatMin, LONG cpFormatMax ) = 0;
	virtual void Zombie() = 0;

private:
	ITxNotify *	_pnext;

	friend class CNotifyMgr;	// so it can manipulate _pnext
};


/*
 *	CNotifyMgr
 *
 *	Purpose:
 *		the general notification manager; keeps track of all interested 
 *		notification sinks
 */

class CNotifyMgr
{
public:
	void Add( ITxNotify *pITN );
	void Remove( ITxNotify *pITN );
	void NotifyPreReplaceRange( ITxNotify *pITNignore, LONG cp, LONG cchDel, 
			LONG cchNew, LONG cpFormatMin, LONG cpFormatMax );
	void NotifyPostReplaceRange( ITxNotify *pITNignore, LONG cp, LONG cchDel, 
			LONG cchNew, LONG cpFormatMin, LONG cpFormatMax );

	CNotifyMgr();
	~CNotifyMgr();

private:

	ITxNotify *	_pitnlist;
};

#endif //_NOTMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_measure.h ===
/*
 *	_MEASURE.H
 *	
 *	Purpose:
 *		CMeasurer class
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 */

#ifndef _MEASURE_H
#define _MEASURE_H

#include "_rtext.h"
#include "_line.h"
#include "_disp.h"

#ifdef LINESERVICES
#include "_ols.h"
#endif

class CCcs;
class CDevDesc;
class CPartialUpdate;
class CUniscribe;

const short BITMAP_WIDTH_SUBTEXT = 4;
const short BITMAP_HEIGHT_SUBTEXT = 4;

const short BITMAP_WIDTH_HEADING = 10;
const short BITMAP_HEIGHT_HEADING = 10;

#define TA_STARTOFLINE	32768
#define TA_ENDOFLINE	16384
#define TA_LOGICAL		8192

// ===========================  CMeasurer  ===============================
// CMeasurer - specialized rich text pointer used to compute text metrics.
// All metrics are computed and stored in device units for the device
// indicated by _pdd.
class CMeasurer : public CRchTxtPtr
{
	friend class CDisplay;
	friend class CDisplayML;
	friend class CDisplayPrinter;
	friend class CDisplaySL;
	friend class CLine;
	friend struct COls;
	friend class CUniscribe;

public:
	CMeasurer (const CDisplay* const pdp);
	CMeasurer (const CDisplay* const pdp, const CRchTxtPtr &rtp);
	virtual ~CMeasurer();

	const CDisplay* GetPdp() const 		{return _pdp;}

	void 	AdjustLineHeight();
	LONG	GetDyrInch()				{return _dyrInch;}
	LONG	GetDxrInch()				{return _dxrInch;}

	LONG	GetDypInch()				{return _dypInch;}
	LONG	GetDxpInch()				{return _dxpInch;}

#ifdef LINESERVICES
	COls *	GetPols(CMeasurer **ppme);
	CUniscribe* Getusp() const { return GetPed()->Getusp(); }
#endif

	CCcs*	GetCcs(const CCharFormat *pCF);
	CCcs*	GetCcsFontFallback(const CCharFormat *pCF);
	CCcs*	ApplyFontCache(BOOL fFallback);
	
	void	CheckLineHeight();
	CCcs *	Check_pccs(BOOL fBullet = FALSE);
	LONG	GetNumber() const			{return _wNumber;}
	WCHAR	GetPasswordChar() const		{return _chPassword;}
	const CParaFormat *Get_pPF()		{return _pPF;}
	LONG	GetCch() const				{return _li._cch;}
	void	SetCch(LONG cch)			{_li._cch = cch;}
	CLine & GetLine(void)				{return _li;}
	HITTEST	HitTest(LONG x);

	BOOL	fFirstInPara() const		{return _li._bFlags & fliFirstInPara;}
	BOOL	fUseLineServices() const	{return GetPed()->fUseLineServices();}
	BOOL	IsRenderer() const			{return _fRenderer;}
	LONG	LXtoDX(LONG x);
	LONG	LYtoDY(LONG y);

	void	NewLine(BOOL fFirstInPara);
	void	NewLine(const CLine &li);
	LONG    MeasureLeftIndent();
	LONG	MeasureRightIndent();
	LONG 	MeasureLineShift();
	LONG	MeasureText(LONG cch);
	BOOL 	MeasureLine(
					LONG cchMax,
					LONG xWidthMax,
					UINT uiFlags, 
					CLine* pliTarget = NULL);
	LONG	MeasureTab(unsigned ch);
	void	SetNumber(WORD wNumber);
	void	UpdatePF()					{_pPF = GetPF();}
	LONG	XFromU(LONG u);
	LONG	UFromX(LONG x);
	CCcs*	GetCcsBullet(CCharFormat *pcfRet);
	void	SetUseTargetDevice(BOOL fUseTargetDevice);
	BOOL	FUseTargetDevice(void)		{return _fTarget || _dypInch == _dyrInch;}
	BOOL	fAdjustFELineHt()			{return _fAdjustFELineHt;}
	void	SetGlyphing(BOOL fGlyphing);

protected:
	void	Init(const CDisplay *pdp);
	LONG 	Measure(LONG xWidthMax, LONG cchMax, UINT uiFlags);
	LONG	MeasureBullet();
	LONG	GetBullet(WCHAR *pch, CCcs *pccs, LONG *pxWidth);

	BOOL	FormatIsChanged();
	void	ResetCachediFormat();
	LONG	DXtoLX(LONG x);	

private:
    void 	RecalcLineHeight(CCcs *,
			const CCharFormat * const pCF);	// Helper to recalc max line height
	LONG	MaxWidth();					// Helper for calc max width

protected:
		  CLine		_li;			// Line we are measuring

	const CDevDesc*	_pddReference;	// Reference device
		  LONG		_dyrInch;		// Resolution of reference device
		  LONG		_dxrInch;

	const CDisplay*	_pdp;			// Display we are operating in
		  LONG		_dypInch;		// Resolution of presentation device
		  LONG		_dxpInch;

		  CCcs*		_pccs;			// Current font cache
		  const CParaFormat *_pPF;	// Current CParaFormat

		  SHORT		_xAddLast;		// Last char considered but unused for line
		  WCHAR		_chPassword;	// Password character if any
		  WORD		_wNumber;		// Number offset
		  SHORT		_iFormat;		// Current format
		  BYTE		_dtRef;			// Device Caps technology for reference device
		  BYTE		_dtPres;		// Device Caps technology for presentation device
		  BYTE		_fRenderer:1;	// 0/1 for CMeasurer/CRenderer, resp.
		  BYTE		_fTarget:1;		// TRUE if we are supposed to be using
									//  reference metrics for laying out text
		  BYTE	_fAdjustFELineHt:1;	// TRUE if we need to adjust line height
									//	 for FE run
		  BYTE		_fFallback:1;	// Current font cache is fallback font
		  BYTE		_fGlyphing:1;	// In the process of creating glyphs
};


// Values for uiFlags in MeasureLine()
#define MEASURE_FIRSTINPARA 	0x0001
#define MEASURE_BREAKATWORD 	0x0002
#define MEASURE_BREAKBEFOREWIDTH 0x0004	// Breaks at character before target width
#define MEASURE_IGNOREOFFSET	0x0008
#define MEASURE_DONTINIT		0x0020


// Returned error codes for Measure(), MeasureText(), MeasureLine()
#define MRET_FAILED		-1
#define MRET_NOWIDTH	-2

inline BOOL CMeasurer::FormatIsChanged()
{
	return !_pccs || _iFormat != _rpCF.GetFormat() || _fFallback;
}

inline void CMeasurer::ResetCachediFormat()
{
	_iFormat = _rpCF.GetFormat();
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_magelln.h ===
/*
 *	@doc
 *
 *	@module _MAGELLN.H -- Declaration of class to handle Magellan mouse. |
 *	
 *	Authors: <nl>
 *		Jon Matousek 
 *
 *	Copyright (c) 1995-1996 Microsoft Corporation. All rights reserved.
 */

#if !defined(_MAGELLN_H) && !defined(NOMAGELLAN)	// Win NT/95 only class.
#define _MAGELLN_H

#include "_edit.h"


// All of the knobs for magellan mouse scrolling.

const LONG	DEAD_ZONE_TWIPS			= 60;	// 3 pixels normally
const DWORD FAST_ROLL_SCROLL_TRANSITION_TICKS = 900;  // in mili seconds.
const INT FASTER_ROLL1_COUNT		= 5;
const INT FASTER_ROLL2_COUNT		= 10;

const WORD SMOOTH_ROLL_CLINES		= 2;	// multiples of rolls for roll1, roll2.
const int SMOOTH_ROLL_NUM			= 1;
const int SMOOTH_ROLL_DENOM			= 3;

class CMagellan {

	friend class CMagellanBMPStateWrap;

private:
	VOID CheckInstallMagellanTrackTimer (CTxtEdit &ed);
	VOID CheckRemoveMagellanUpdaterTimer (CTxtEdit &ed);
	BOOL InvertMagellanDownBMP ( CDisplay *pdp, BOOL fTurnOn, HDC repaintDC );

	WORD		_fMagellanBitMapOn	:1;	// TRUE if the MDOWN bitmap is displayed.
	WORD		_fMButtonScroll		:1;	// Auto scrolling initiated via magellan-mouse.
	WORD		_fLastScrollWasRoll	:1;	// scroll will be wither roll or mdown.

 	SHORT		_ID_currMDownBMP;		// Resource ID of _MagellanMDownBMP.
	HBITMAP		_MagellanMDownBMP;		// Loaded BMP
	POINT		_zMouseScrollStartPt;	// Magellan mouse's start scroll pt.



public:

	BOOL MagellanStartMButtonScroll ( CTxtEdit &ed, POINT mDownPt );
	VOID MagellanEndMButtonScroll ( CTxtEdit &ed );
	VOID MagellanRollScroll ( CDisplay *pdp, int direction, WORD cLines, int speedNum, int speedDenom, BOOL fAdditive );
	VOID TrackUpdateMagellanMButtonDown ( CTxtEdit &ed, POINT mousePt);

	BOOL IsAutoScrolling() {return _fMButtonScroll;}
	BOOL ContinueMButtonScroll(INT x, INT y) {return (_zMouseScrollStartPt.x == x && _zMouseScrollStartPt.y == y);}

	~CMagellan() { Assert( !_MagellanMDownBMP && !_fMButtonScroll /* client state problems? */); }

};

class CMagellanBMPStateWrap {
private:
	BOOL _fMagellanState;
	HDC _repaintDC;
	CTxtEdit &_ed;
public:
	CMagellanBMPStateWrap(CTxtEdit &ed, HDC repaintDC);
	~CMagellanBMPStateWrap();
};

#endif // _MAGELLN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_osdc.h ===
/*	@doc INTERNAL
 *
 *	@module _OSDC.H  Off Screen DC class |
 *	
 *	Define class for off screen DC
 *
 *	Original Author: <nl>
 *		Ricksa
 *
 *	History: <nl>
 *		1/11/96	ricksa	Created
 *
 *	Copyright (c) 1996-1998, Microsoft Corporation. All rights reserved.
 */
#ifndef __OSDC_H__
#define __OSDC_H__

/*
 *	COffScreenDC
 *	
 * 	@class	The COffScreenDC is a helper that creates, fills and destroys
 *			an off screen DC and its bitmaps.
 *
 */
class COffScreenDC
{
//@access Public Methods
public:
									//@cmember Constructor - create null object.
				COffScreenDC()		{_hdc = NULL;}

									//@cmember Destructor - clean up allocated 
									// resources if any.
				~COffScreenDC()		{FreeData();}
	
									//@cmember Initialize data based on input DC
	HDC			Init(HDC hdc, LONG xWidth, LONG yHeight, COLORREF crBackground);

									//@cmember Get DC for offscreen rendering
	HDC			GetDC()		{return _hdc;}
									//@cmember Fill bitmap associated with off
									// screen rendering with background color.
	void		FillBitmap(LONG xWidth, LONG yHeight);

									//@cmember Render off screen bitmap to hdc
	void		RenderBitMap(HDC hdc, LONG xLeft, LONG yTop, LONG xWidth, LONG yHeight);

									//@cmember Get a copy of a bitmap from hdc
	BOOL		Get(HDC hdc, LONG xLeft, LONG yTop, LONG xWidth, LONG yHeight);

									//@cmember Reallocate bitmap for render
	BOOL		Realloc(LONG xWidth, LONG yHeight);

									//@cmember Select in a palette
	void		SelectPalette(HPALETTE hpa);

//@access Private Methods
private:
									//@cmember Free all data associated with object
	void		FreeData();

//@access Private Data 
private:
	HDC			_hdc;		//@cmember HDC for off screen DC
	HBITMAP		_hbmpOld;	//@cmember bitmap when DC created
	HBITMAP		_hbmp;		//@cmember compatible bitmap for render
	HPALETTE	_hpalOld;	//@cmember palette used by DC
};

/*
 *	COffScreenDC::FillBitmap (xWidth, yHeight)
 *
 *	@mfunc	
 *		Fill bitmap
 */
inline void COffScreenDC::FillBitmap(
	LONG xWidth,		//@parm Width to fill with background color
	LONG yHeight)		//@parm height to fill with background color
{
	// Erase background
	RECT rcClient;
	rcClient.top = rcClient.left = 0;
	rcClient.right = xWidth;
	rcClient.bottom = yHeight;
	ExtTextOut(_hdc, 0, 0, ETO_OPAQUE, &rcClient, NULL, 0, NULL);
}

/*
 *	COffScreenDC::RenderBitMap(hdc, xLeft, yTop, xWidth, yHeight)
 *
 *	@mfunc	
 *		Render bitmap to input DC
 */
inline void COffScreenDC::RenderBitMap(
	HDC  hdc,			//@parm HDC to render to
	LONG xLeft,			//@parm left position to start render
	LONG yTop,			//@parm top top position to start render
	LONG xWidth,		//@parm width to render
	LONG yHeight)		//@parm height to render
{
	BitBlt(hdc, xLeft, yTop, xWidth, yHeight, _hdc, 0, 0, SRCCOPY);
}
	
/*
 *	COffScreenDC::Get(hdc, xLeft, yTop, xWidth, yHeight)
 *
 *	@mfunc	
 *		Get a copy of a bitmap from another DC
 *
 *	@rdesc
 *		TRUE - succeeded
 *		FALSE - Failed
 */
inline BOOL COffScreenDC::Get(
	HDC  hdc,			//@parm HDC to copy from
	LONG xLeft,			//@parm left position of source bitmap
	LONG yTop,			//@parm top top position of source bitmap
	LONG xWidth,		//@parm width of bitmap
	LONG yHeight)		//@parm height to bitmap
{
	return BitBlt(_hdc, 0, 0, xWidth, yHeight, hdc, xLeft, yTop, SRCCOPY);
}

#endif __OSDC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_ols.h ===
/*
 *  _OLS.H
 *  
 *  Purpose:
 *		COls Line Services object class used to connect RichEdit with
 *		Line Services.
 *  
 *  Authors:
 *		Original RichEdit LineServices code: Rick Sailor
 *		Murray Sargent
 *
 *	Copyright (c) 1997-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _OLS_H
#define _OLS_H

#include "_common.h"
#include "_ls.h"
#include "_cfpf.h"
#include "usp10.h"

#define CP_BULLET			0x80000000

// ===============================  CLsrun =====================================
// CLsrun - LineServices run structure
struct CLsrun
{
	LONG				_cp;	// the starting cp of the run
	const CCharFormat*	_pCF;	// pointer to the character formatting
	struct CLsrun*		_pNext;	// next linked (shaped together) run
	SCRIPT_ANALYSIS		_a;		// run's analysis (will be 0 if non-complex script)
private:
	BYTE		_fSelected:1;	// Is this run selected?
	BYTE		_fFallback:1;	// Is font fallback applied?
public:
	void	SetSelected(BOOL fSelected) {_fSelected = fSelected;}
	BOOL	IsSelected();
	BOOL	IsBullet() {return _cp & CP_BULLET;}
	void	SetFallback(BOOL fFallback) {_fFallback = fFallback;}
	BOOL	IsFallback() {return _fFallback;}
};

// ===============================  CLsrunChunk =====================================
// CLsrunChunk - Manages a chunk of PLSRUNs
class CLsrunChunk
{
public:
	PLSRUN _prglsrun;
	int		_cel;
};

// ===============================  COls  =====================================
// COls - LineServices object class

class CTxtEdit;
class CMeasurer;
class CDispDim;

struct COls
{
public:
	CMeasurer *_pme;				// Active CMeasurer or CRenderer
	PLSLINE	   _plsline;			// Line cache
	LONG	   _cp;					// cpMin for _plsline
	const CDisplay *_pdp;			// Current Display object, used to determine if display
									// object changed without receiving focus messages
	LONG		_xWidth;			// Width of line to be formatted

	BOOL		_fCheckFit;			// See if the line will fit, but formatting left justified
									// into an infinitely long line.

	CArray<long> _rgcp;				// Array for CP mapping
	CArray<CLsrunChunk> _rglsrunChunk;	// Array of ClsrunChunks


	// Note: might be better to alloc the following only if needed
	LSTBD _rgTab[MAX_TAB_STOPS];	// Buffer used by pfnFetchTabs
	WCHAR _szAnm[CCHMAXNUMTOSTR + 4];//numbering + braces + space + end character
	WCHAR _rgchTemp[64];			// Temporary buffer for passwords and allcaps, etc.
	int			_cchAnm;			// cch in use
	CCharFormat _CFBullet;			// Character formatting for anm run
	LONG		_cEmit;				// Brace emitting protection (0 - balance)

	COls() {}
	~COls();

	//CP matching, reverser brace support
	LONG GetCpLsFromCpRe(LONG cpRe);
	LONG GetCpReFromCpLs(LONG cpLs);
	LONG BracesBeforeCp(LONG cpLs);
	BOOL AddBraceCp(LONG cpLs);

	PLSRUN CreatePlsrun(void);

	BOOL SetLsChp(DWORD dwObjId, PLSRUN plsrun, PLSCHP plschp);
	BOOL SetRun(PLSRUN plsrun);
	PLSRUN GetPlsrun(LONG cp, const CCharFormat *pCF, BOOL fAutoNumber);
	LSERR WINAPI FetchAnmRun(long cp, LPCWSTR *plpwchRun, DWORD *pcchRun,
							 BOOL *pfHidden, PLSCHP plsChp, PLSRUN *pplsrun);
	void	CchFromXpos(POINT pt, CDispDim *pdispdim, LONG *pcpActual);
	void	CreateOrGetLine();
	void	DestroyLine(CDisplay *pdp);
	HRESULT	Init(CMeasurer *pme); 
	BOOL	MeasureLine(LONG xWidth, CLine *pliTarget);
	LONG	MeasureText(LONG cch, UINT taMode, CDispDim *pdispdim);
	BOOL	RenderLine(CLine &li);
	CMeasurer * GetMeasurer() {return _pme;}
	CRenderer * GetRenderer() {return (CRenderer*) _pme;}

	void	SetMeasurer(CMeasurer *pme)	{_pme = pme;}
};

extern COls* g_pols;
extern const LSIMETHODS vlsimethodsOle;
extern CLineServices *g_plsc;		// LineServices Context

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_range.h ===
/*
 *	@doc
 *
 *	@module _RANGE.H -- CTxtRange Class |
 *	
 *		This class implements the internal text range and the TOM ITextRange
 *	
 *	Authors: <nl>
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *		Alex Gounares (floating ranges, etc.)
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _RANGE_H
#define _RANGE_H

#include "_text.h"
#include "_m_undo.h"
#include "_rtext.h"
#include "_edit.h"
#include "_uspi.h"

long	FPPTS_TO_TWIPS(float x);
#define TWIPS_TO_FPPTS(x) (((float)(x)) * (float)0.05)

class CTxtEdit;
class CTxtFont;

/*
 *	SELRR
 *
 *	@enum	flags used to control how ReplaceRange (RR) should generate
 *			selection anti-events
 */
enum SELRR
{
	SELRR_IGNORE		= 0,
    SELRR_REMEMBERRANGE = 1,
    SELRR_REMEMBERCPMIN = 2,
    SELRR_REMEMBERENDIP = 3
};

/*
 *	FINDWORD_TYPE
 *
 *	@enum	defines the different cases for finding a word
 */
enum FINDWORD_TYPE {
	FW_EXACT	= 1,		//@emem	Finds the word exactly (no extra chars)
	FW_INCLUDE_TRAILING_WHITESPACE = 2,	//@emem find the word plus the
							// following whitespace (ala double-clicking)
};

enum MOVES
{
	MOVE_START = -1,
	MOVE_IP = 0,
	MOVE_END = 1,
};

enum MATCHES
{
	MATCH_UNTIL = 0,
	MATCH_WHILE = 1
};

enum EOPADJUST
{
	NONEWCHARS = 0,
	NEWCHARS = 1
};


// Substring's input flags
#define SUBSTR_INSPANCHARSET		1
#define SUBSTR_INSPANBLOCK			2

// Substring's output charflags
#define SUBSTR_OUTCCLTR				1
#define SUBSTR_OUTCCRTL				2

class CCharFlags
{
public:
	BYTE	_bFirstStrong;			// flag for first strong character
	BYTE	_bContaining;			// flags for all presented characters
};


#define	SCF_IGNORESELAE	0x80000000
#define SCF_IGNORENOTIFY 0x40000000	// use it with real caution! Caller must do it itself.

/*
 *	CTxtRange
 *	
 * 	@class
 *		The CTxtRange class implements RichEdit's text range, which is the
 *		main conduit through which changes are made to the document.
 *		The range inherits from the rich-text ptr, adding a signed length
 *		insertion-point char-format index, and a ref count for use when
 *		instantiated as a TOM ITextRange.  The range object also contains
 *		a flag that reveals whether the range is a selection (with associated
 *		screen behavior) or just a simple range.  This distinction is used
 *		to simplify some of the code.
 *
 *		Some methods are virtual to allow CTxtSelection objects to facilitate
 *		UI features and selection updating.
 *
 *		See tom.doc for lots of discussion on range and selection objects and
 *		on all methods in ITextRange, ITextSelection, ITextFont, and ITextPara.
 */
class CTxtRange : public ITextSelection, public CRchTxtPtr
{
	friend CTxtFont;

//@access Protected Data
protected:
	LONG	_cch;			//@cmember # chars in range. _cch > 0 for active
							//			end at range end (cpMost)
	LONG	_cRefs;			//@cmember ITextRange/ITextSelection ref count

	short	_iFormat;		//@cmember Character format for degenerate range

	union
	{
	  WORD _wFlags;			// All together now
	  struct
	  {
		WORD  _fExtend :1;		//@cmember True iff Advance methods should
								//  	   leave "other" end unchanged
		WORD  _fSel :1;			//@cmember True iff this is a CTxtSelection
		WORD  _fDragProtection :1;	//@cmember True is this range should think
								//	it's protected.  Set by drag/drop code
		WORD  _fDontUpdateFmt:1;//@cmember Don't update _iFormat
		WORD  _fDualFontMode:1;	//@cmember Set during dual font mode
		WORD  _fUseiFormat:1;	//@cmember Use iFormat when replacing
								// a non-degenerate range
		WORD  _fMoveBack:1;		//@cmember TRUE if last change moved backward
		WORD  _fSelHasEOP:1;	//@cmember TRUE if Sel has EOP
		WORD  _fSelHasCell:1;	//@cmember TRUE if Sel CELL	found looking for EOP
		WORD  _fUseBackwardPFFmt:1;	//@cmember Use backward PF format
	  };
	};

//@access Public methods
public:

#ifdef DEBUG
	BOOL	Invariant( void ) const;
#endif // DEBUG

	CTxtRange(const CTxtRange &rg);
	CTxtRange(CTxtEdit *ped, LONG cp = 0, LONG cch = 0);
	CTxtRange(CRchTxtPtr &rtp, LONG cch = 0);
	virtual	~CTxtRange();

	virtual CRchTxtPtr& 	operator =(const CRchTxtPtr &rtp);
	virtual CTxtRange&		operator =(const CTxtRange &rp);

	// ITxNotify methods
										//@cmember Handles notifications
	virtual void OnPreReplaceRange(		//  prior to ReplaceRange calls
				LONG cp, LONG cchDel, LONG cchNew,
				LONG cpFormatMin, LONG cpFormatMax);
										//@cmember Handles notifications for
	virtual void OnPostReplaceRange(	//  floating range and display updates
				LONG cp, LONG cchDel, LONG cchNew,
				LONG cpFormatMin, LONG cpFormatMax);
	virtual	void Zombie();				//@cmember Convert range into zombie

	void	SetIgnoreFormatUpdate(BOOL fUpdate) { _fDontUpdateFmt = fUpdate; }

	void	SetDualFontMode(BOOL fDualFontMode) {_fDualFontMode = fDualFontMode; }

	// Internal cp/cch methods
    LONG 	GetCch (void) const			//@cmember Get signed character count
				{return _cch;}
	BOOL	IsSel()						{return _fSel;}
	BOOL	fHasCell() const			{return _fSelHasCell;}
	BOOL	fHasEOP() const				{return _fSelHasEOP;}
    BOOL 	CpInRange (LONG cp) const;	//@cmember Says if cp is in this range
	BOOL	CheckTextLength (LONG cch, LONG *pcch = NULL);	//@cmember Says if cch chars can fit
	LONG	CheckChange(LONG cpSave);	//@cmember Used after _cp change to set
										//  selection-changed flag, choose _cch
										 //@cmember In outline mode, maintain _fSelHasEOP
	BOOL	CheckIfSelHasEOP(LONG cpSave, LONG cchSave);
	BOOL	IsInputSequenceValid(WCHAR* pwch, LONG cch, BOOL fOver, BOOL* pfBaseChar = NULL);//@cmember TRUE for valid sequence

	// GetRange() is faster than calling GetCpMin() and GetCpMost();
    LONG    GetCpMin () const;			//@cmember Get cp of first char in range
    LONG    GetCpMost () const;			//@cmember Get cp just beyond last char in range
										//@cmember Get range ends and count
	LONG	GetRange (LONG& cpMin, LONG& cpMost) const;
    BOOL	Set(LONG cp, LONG cch);
	LONG	SetCp(LONG cp);
    void 	SetExtend(unsigned f)			{_fExtend = f;}
	LONG	GetAdjustedTextLength() const
				{return GetPed()->GetAdjustedTextLength();}

	// Range specific methods
	LONG	Advance(LONG cch);	
	void 	Collapser(long fStart);
	void 	FlipRange();
	LONG 	CleanseAndReplaceRange (LONG cchS, WCHAR const *pchS, BOOL fTestLimit,
				IUndoBuilder *publdr, WCHAR *pchD = NULL, LONG* pcchMove = NULL, DWORD dwFlags = 0);
	LONG	CheckLimitReplaceRange (LONG cch, WCHAR const *pch,
				BOOL fTestLimit, IUndoBuilder *publdr, DWORD dwCharFlags,
				LONG *pcchMove, LONG cpFirst, int iMatchCurrent, DWORD dwFlags);
	HRESULT	HexToUnicode (IUndoBuilder *publdr);
	HRESULT	UnicodeToHex (IUndoBuilder *publdr);
	void	Delete(IUndoBuilder *publdr, SELRR selaemode);
	void	DeleteTerminatingEOP(IUndoBuilder *publdr);
	BOOL	AdjustEndEOP (EOPADJUST NewChars);

	// Outline management
	void	CheckOutlineLevel(IUndoBuilder *publdr);
	HRESULT	ExpandOutline  (LONG Level, BOOL fWholeDocument);
	HRESULT	OutlineExpander(LONG Level, BOOL fWholeDocument);
	HRESULT	Promote		   (LPARAM lparam, IUndoBuilder *publdr);

	// ReplaceRange must be virtual since the callers of
	// CLightDTEngine::CutRangeToClipboard() cast CTxtSelection* to CTxtRange*
	virtual	LONG 	ReplaceRange(LONG cchNew, TCHAR const *pch, IUndoBuilder *publdr,
						SELRR selaemode, LONG *pcchMove = NULL, DWORD dwFlags = 0);
	virtual	BOOL 	Update(BOOL fScrollIntoView);

	// Rich-text methods
	enum { PROTECTED_YES, PROTECTED_NO, PROTECTED_ASK };

	// Get/Set Char/Para Format methods
	void 	Update_iFormat(LONG iFmtDefault);
	DWORD	GetCharSetMask(BOOL fUseDocFormat = FALSE);	//@cmember Get range charset mask
	LONG	Get_iCF();						//@cmember Get range CF index
	LONG	Get_iFormat() {return _iFormat;}//@cmember Get _iFormat for quick peek
	LONG	GetiFormat() const;
    BOOL	Set_iCF(LONG iFormat);			//@cmember Set range CF index
	LONG	Get_iPF();						//@cmember Get active end PF index
	int		IsProtected(LONG iDirection);	//@cmember Is range protected?
	BOOL	IsZombie() {return !GetPed();}	//@cmember Is range zombied?
	BOOL	WriteAccessDenied ();
	DWORD	GetCharFormat(CCharFormat *pCF, DWORD flags = 0) const;
	DWORD	GetParaFormat(CParaFormat *pPF, DWORD flags = 0) const;
	void	SetDragProtection(BOOL fSet)	// Convinces range it's protected
				{_fDragProtection = fSet;}	//  w/o modifying backing store
	HRESULT	CharFormatSetter (const CCharFormat *pCF, DWORD dwMask);
	HRESULT	ParaFormatSetter (const CParaFormat *pPF, DWORD dwMask);

	HRESULT	SetCharFormat(const CCharFormat *pCF, DWORD flags,
						  IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaFormat(const CParaFormat *pPF,
						  IUndoBuilder *publdr, DWORD dwMask);
	HRESULT	SetParaStyle (const CParaFormat *pPF,
						  IUndoBuilder *publdr, DWORD dwMask);
											//@cmember Format range CharSets
	// Complex script feature :- Itemization
	BOOL	ItemizeRuns(IUndoBuilder *publdr, BOOL fUnicodeBiDi = FALSE, BOOL fUseCtxLevel = FALSE);
	HRESULT BiDiLevelFromFSM (const CBiDiFSM* pfsm);
	LONG	GetRunsPF (CRchTxtPtr* prtp, CFormatRunPtr* prpPF, LONG& cchLeft);
#ifdef DEBUG
	void	DebugFont (void);
#endif

	// Find enclosing unit methods
	HRESULT	Expander		(long Unit, BOOL fExtend, LONG *pDelta,
							 LONG *pcpMin, LONG *pcpMost);
	void	FindAttributes	(LONG *pcpMin, LONG *pcpMost, LONG Unit) const;
	void	FindCell		(LONG *pcpMin, LONG *pcpMost) const;
    BOOL    FindObject		(LONG *pcpMin, LONG *pcpMost) const;
    void    FindParagraph	(LONG *pcpMin, LONG *pcpMost) const;
    void    FindSentence	(LONG *pcpMin, LONG *pcpMost) const;
	BOOL	FindVisibleRange(LONG *pcpMin, LONG *pcpMost) const;
    void    FindWord		(LONG *pcpMin, LONG *pcpMost,
								FINDWORD_TYPE type)const;

	LONG	AdvanceCRLF();
	LONG	BackupCRLF(BOOL fDiacriticCheck = TRUE);
	LONG    FindWordBreak(INT action);
	LONG	SnapToCluster(INT iDirection = 0);

	void	ValidateRange();

	void	SetUseiFormat(BOOL fUseiFormat) {_fUseiFormat = fUseiFormat;}

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

    // ITextRange methods
    STDMETHODIMP GetText (BSTR *pbstr);
    STDMETHODIMP SetText (BSTR bstr);
    STDMETHODIMP GetChar (long *pch);
    STDMETHODIMP SetChar (long ch);
    STDMETHODIMP GetDuplicate (ITextRange **ppRange);
    STDMETHODIMP GetFormattedText (ITextRange **ppRange);
    STDMETHODIMP SetFormattedText (ITextRange *pRange);
    STDMETHODIMP GetStart (long *pcpFirst);
    STDMETHODIMP SetStart (long cpFirst);
    STDMETHODIMP GetEnd (long *pcpLim);
    STDMETHODIMP SetEnd (long cpLim);
    STDMETHODIMP GetFont (ITextFont **pFont);
    STDMETHODIMP SetFont (ITextFont *pFont);
    STDMETHODIMP GetPara (ITextPara **pPara);
    STDMETHODIMP SetPara (ITextPara *pPara);
    STDMETHODIMP GetStoryLength (long *pcch);
    STDMETHODIMP GetStoryType (long *pValue);
    STDMETHODIMP Collapse (long bStart);
    STDMETHODIMP Expand (long Unit, long *pDelta);
    STDMETHODIMP GetIndex (long Unit, long *pIndex);
    STDMETHODIMP SetIndex (long Unit, long Index, long Extend);
    STDMETHODIMP SetRange (long cpActive, long cpOther);
    STDMETHODIMP InRange (ITextRange * pRange, long *pb);
    STDMETHODIMP InStory (ITextRange * pRange, long *pb);
    STDMETHODIMP IsEqual (ITextRange * pRange, long *pb);
    STDMETHODIMP Select ();
    STDMETHODIMP StartOf (long Unit, long Extend, long * pDelta);
    STDMETHODIMP EndOf (long Unit, long Extend, long * pDelta);
    STDMETHODIMP Move (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveStart (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveEnd (long Unit, long Count, long * pDelta);
    STDMETHODIMP MoveWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveStartWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveEndWhile (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveUntil (VARIANT FAR* Cset, long Count, long * pDelta);
    STDMETHODIMP MoveStartUntil (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP MoveEndUntil (VARIANT * Cset, long Count, long * pDelta);
    STDMETHODIMP FindText (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP FindTextStart (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP FindTextEnd (BSTR bstr, long cch, long Flags, long * pLength);
    STDMETHODIMP Delete (long Unit, long Count, long * pDelta);
    STDMETHODIMP Cut (VARIANT * ppIDataObject);
    STDMETHODIMP Copy (VARIANT * ppIDataObject);
    STDMETHODIMP Paste (VARIANT * pIDataObject, long Format);
    STDMETHODIMP CanPaste (VARIANT * pIDataObject, long Format, long * pb);
    STDMETHODIMP CanEdit (long * pbCanEdit);
    STDMETHODIMP ChangeCase (long Type);
    STDMETHODIMP GetPoint (long Type, long * px, long * py);
    STDMETHODIMP SetPoint (long x, long y, long Type, long Extend);
    STDMETHODIMP ScrollIntoView (long Value);
    STDMETHODIMP GetEmbeddedObject (IUnknown ** ppv);


    // ITextSelection methods
    STDMETHODIMP GetFlags (long * pFlags) ;
    STDMETHODIMP SetFlags (long Flags) ;
    STDMETHODIMP GetType  (long * pType) ;
	STDMETHODIMP MoveLeft (long Unit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveRight(long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveUp   (long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP MoveDown (long pUnit, long Count, long Extend,
						   long *pDelta) ;
	STDMETHODIMP HomeKey  (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP EndKey   (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP TypeText (BSTR bstr) ;


//@access Private ITextRange helper methods
private:
	void	RangeValidateCp (LONG cp, LONG cch);
	LONG	Comparer (ITextRange * pv);
	LONG	SpanSubstring (CUniscribe* pusp, CFormatRunPtr* pcrp, WCHAR* pwchString,
						LONG cchString, WORD& uSubStrLevel, DWORD dwInFlags, CCharFlags* pCharflags,
						WORD& wBiDiLangId);
	HRESULT EndSetter(LONG cp, BOOL fOther);
	HRESULT Finder	 (BSTR bstr, long Count, long Flags, LONG *pDelta,
						MOVES Mode);
	HRESULT GetLong  (LONG lValue, long *pLong);
	HRESULT	IsTrue	 (BOOL f, long *pB);
	HRESULT Matcher	 (VARIANT *Cset, long Count, LONG *pDelta, MOVES Mode,
						MATCHES Match);
	HRESULT	Mover	 (long Unit, long Count, LONG *pDelta, MOVES Mode);
	HRESULT	Replacer (LONG cchNew, TCHAR const *pch, DWORD dwFlags = 0);

	LONG	CalcTextLenNotInRange();
};



// Useful Unicode range definitions for use with MoveWhile/Until methods

#define	CodeRange(n, m)	0x8000000 | ((m) - (n)) << 16 | n

#define	CR_ASCII		CodeRange(0x0, 0x7f)
#define	CR_ANSI			CodeRange(0x0, 0xff)
#define	CR_ASCIIPrint	CodeRange(0x20, 0x7e)
#define	CR_Latin1		CodeRange(0x20, 0xff)
#define	CR_Latin1Supp	CodeRange(0xa0, 0xff)
#define	CR_LatinXA		CodeRange(0x100, 0x17f)
#define	CR_LatinXB		CodeRange(0x180, 0x24f)
#define	CR_IPAX			CodeRange(0x250, 0x2af)
#define	CR_SpaceMod		CodeRange(0x2b0, 0x2ff)
#define	CR_Combining	CodeRange(0x300, 0x36f)
#define	CR_Greek		CodeRange(0x370, 0x3ff)
#define	CR_BasicGreek	CodeRange(0x370, 0x3cf)
#define	CR_GreekSymbols	CodeRange(0x3d0, 0x3ff)
#define	CR_Cyrillic		CodeRange(0x400, 0x4ff)
#define	CR_Armenian		CodeRange(0x530, 0x58f)
#define	CR_Hebrew		CodeRange(0x590, 0x5ff)
#define	CR_BasicHebrew	CodeRange(0x5d0, 0x5ea)
#define	CR_HebrewXA		CodeRange(0x590, 0x5cf)
#define	CR_HebrewXB		CodeRange(0x5eb, 0x5ff)
#define	CR_Arabic		CodeRange(0x600, 0x6ff)
#define	CR_BasicArabic	CodeRange(0x600, 0x652)
#define	CR_ArabicX		CodeRange(0x653, 0x6ff)
#define	CR_Devengari	CodeRange(0x900, 0x97f)
#define	CR_Bengali		CodeRange(0x980, 0x9ff)
#define	CR_Gurmukhi		CodeRange(0xa00, 0xa7f)
#define	CR_Gujarati		CodeRange(0xa80, 0xaff)
#define	CR_Oriya		CodeRange(0xb00, 0xb7f)
#define	CR_Tamil		CodeRange(0xb80, 0xbff)
#define	CR_Teluga		CodeRange(0xc00, 0xc7f)
#define	CR_Kannada		CodeRange(0xc80, 0xcff)
#define	CR_Malayalam	CodeRange(0xd00, 0xd7f)
#define	CR_Thai 		CodeRange(0xe00, 0xe7f)
#define	CR_Lao  		CodeRange(0xe80, 0xeff)
#define	CR_GeorgianX	CodeRange(0x10a0, 0xa0cf)
#define	CR_BascGeorgian	CodeRange(0x10d0, 0x10ff)
#define	CR_Hanguljamo	CodeRange(0x1100, 0x11ff)
#define	CR_LatinXAdd	CodeRange(0x1e00, 0x1eff)
#define	CR_GreekX		CodeRange(0x1f00, 0x1fff)
#define	CR_GenPunct		CodeRange(0x2000, 0x206f)
#define	CR_SuperScript	CodeRange(0x2070, 0x207f)
#define	CR_SubScript	CodeRange(0x2080, 0x208f)
#define	CR_SubSuperScrp	CodeRange(0x2070, 0x209f)
#define	CR_Currency		CodeRange(0x20a0, 0x20cf)
#define	CR_CombMarkSym	CodeRange(0x20d0, 0x20ff)
#define	CR_LetterLike	CodeRange(0x2100, 0x214f)
#define	CR_NumberForms	CodeRange(0x2150, 0x218f)
#define	CR_Arrows		CodeRange(0x2190, 0x21ff)
#define	CR_MathOps		CodeRange(0x2200, 0x22ff)
#define	CR_MiscTech		CodeRange(0x2300, 0x23ff)
#define	CR_CtrlPictures	CodeRange(0x2400, 0x243f)
#define	CR_OptCharRecog	CodeRange(0x2440, 0x245f)
#define	CR_EnclAlphaNum	CodeRange(0x2460, 0x24ff)
#define	CR_BoxDrawing	CodeRange(0x2500, 0x257f)
#define	CR_BlockElement	CodeRange(0x2580, 0x259f)
#define	CR_GeometShapes	CodeRange(0x25a0, 0x25ff)
#define	CR_MiscSymbols	CodeRange(0x2600, 0x26ff)
#define	CR_Dingbats		CodeRange(0x2700, 0x27bf)
#define	CR_CJKSymPunct	CodeRange(0x3000, 0x303f)
#define	CR_Hiragana		CodeRange(0x3040, 0x309f)
#define	CR_Katakana		CodeRange(0x30a0, 0x30ff)
#define	CR_Bopomofo		CodeRange(0x3100, 0x312f)
#define	CR_HangulJamo	CodeRange(0x3130, 0x318f)
#define	CR_CJLMisc		CodeRange(0x3190, 0x319f)
#define	CR_EnclCJK		CodeRange(0x3200, 0x32ff)
#define	CR_CJKCompatibl	CodeRange(0x3300, 0x33ff)
#define	CR_Hangul		CodeRange(0x3400, 0x3d2d)
#define	CR_HangulA		CodeRange(0x3d2e, 0x44b7)
#define	CR_HangulB		CodeRange(0x44b8, 0x4dff)
#define	CR_CJKIdeograph	CodeRange(0x4e00, 0x9fff)
#define	CR_PrivateUse	CodeRange(0xe000, 0xf800)
#define	CR_CJKCompIdeog	CodeRange(0xf900, 0xfaff)
#define	CR_AlphaPres	CodeRange(0xfb00, 0xfb4f)
#define	CR_ArabicPresA	CodeRange(0xfb50, 0xfdff)
#define	CR_CombHalfMark	CodeRange(0xfe20, 0xfe2f)
#define	CR_CJKCompForm	CodeRange(0xfe30, 0xfe4f)
#define	CR_SmallFormVar	CodeRange(0xfe50, 0xfe6f)
#define	CR_ArabicPresB	CodeRange(0xfe70, 0xfefe)
#define	CR_HalfFullForm	CodeRange(0xff00, 0xffef)
#define	CR_Specials		CodeRange(0xfff0, 0xfffd)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_objmgr.h ===
/*
 *  @doc    INTERNAL
 *
 *  @module _objmgr.h   Class declaration for the object manager class |
 *
 *  Author: alexgo 11/4/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */
#ifndef __OBJMGR_H__
#define __OBJMGR_H__

#include "_coleobj.h"
#include "_array.h"
#include "_m_undo.h"

class CTxtEdit;

/*
 *	@enum	return values for HandleClick
 */	
enum ClickStatus
{
	CLICK_IGNORED			= 0,
	CLICK_OBJDEACTIVATED	= 1,
	CLICK_SHOULDDRAG		= 2,
	CLICK_OBJSELECTED		= 3
};

typedef CArray<COleObject *> ObjectArray;

/*
 *	CObjectMgr
 *
 *	@class	keeps track of a collection of OLE embedded objects as well as
 *			various state tidbits
 */
class CObjectMgr
{
public:
	LONG			GetObjectCount(); 			//@cmember count # of objects 
	LONG			GetLinkCount();				//@cmember count # of links
	COleObject *	GetObjectFromCp(LONG cp);	//@cmember fetch object ptr
	COleObject *	GetObjectFromIndex(LONG index); //@cmember fetch obj ptr
												//@cmember insert object
	HRESULT			InsertObject(LONG cp, REOBJECT *preobj, 
						IUndoBuilder *publdr);
												//@cmember re-inserts the given
												// object
	HRESULT			RestoreObject(COleObject *pobj);

	IRichEditOleCallback *GetRECallback()		//@cmember return the callback
					{return _precall;}
												//@cmember set the OLE callback
	void			SetRECallback(IRichEditOleCallback *precall);			
												//@cmember sets a temporary flag
												// indicating whether or not
												// a UI update is pending.
	void			SetShowUIPending(BOOL fPending)
												{_fShowUIPending = fPending;}

	BOOL			GetShowUIPending()			//@cmember get _fShowUIPending
												{return _fShowUIPending;}
										   		//@cmember sets the inplace
												// active object
	void			SetInPlaceActiveObject(COleObject *pobj)
												{ _pobjactive = pobj; }
	COleObject *	GetInPlaceActiveObject()	//@cmember get the active obj
												{ return _pobjactive; }
	BOOL			GetHelpMode()				//@cmember in help mode?
												{ return _fInHelpMode; }
	void			SetHelpMode(BOOL fHelp)		//@cmember set the help mode
												{ _fInHelpMode = fHelp; }
												//@cmember Set the host names
	HRESULT			SetHostNames(LPWSTR pszApp, LPWSTR pszDoc);
	LPWSTR			GetAppName()				//@cmember get the app name
												{ return _pszApp; }
	LPWSTR			GetDocName()				//@cmember get the doc name
												{ return _pszDoc; }
												//@cmember activate an object
												//if appropriate
	BOOL			HandleDoubleClick(CTxtEdit *ped, const POINT &pt, 
							DWORD flags);
												//@cmember an object may be
												// selected or de-activated.
	ClickStatus		HandleClick(CTxtEdit *ped, const POINT &pt);
												//@cmember an object may be
												// selected or deselected.
	void			HandleSingleSelect(CTxtEdit *ped, LONG cp, BOOL fHiLite);
												//@cmember an object is
												// being selected by itself.
	COleObject *	GetSingleSelect(void)		{return _pobjselect;}
												//@cmember Count cObject
	LONG			CountObjects(LONG& rcObject,// objects up to cchMax
						LONG cp);				// chars away

												//@cmember Handles the deletion
												// of objects.
	void			ReplaceRange(LONG cp, LONG cchDel,
						IUndoBuilder *publdr);
												//@cmember Count the number
												//of objects in a range.
	LONG			CountObjectsInRange(LONG cpMin, LONG cpMost);
												//@cmember Get the first
												//object in a range.
	COleObject *	GetFirstObjectInRange(LONG cpMin, LONG cpMost);
								//@cmember activate objects of one class as
								//as another
	HRESULT ActivateObjectsAs(REFCLSID rclsid, REFCLSID rclsidAs);

												//@cmember inform objects
												// that scrolling has 
												// occured.
	void			ScrollObjects(LONG dx, LONG dy, LPCRECT prcScroll);

	LONG FindIndexForCp(LONG cp);	//@cmember does a binary search for cp
									//@cmember find an object near a point

#ifdef DEBUG
	void			DbgDump(void);
#endif

	CObjectMgr();								//@cmember constructor
	~CObjectMgr();								//@cmember destructor

private:
	ObjectArray		_objarray;		//@cmember	Array of embedded objects
	LONG			_lastindex;		//@cmember	Last index used 
									// (lookup optimization)
	IRichEditOleCallback *_precall;	//@cmember	Callback for various OLE 
									// operations.
	COleObject *	_pobjactive;	//@cmember	Object that is currently
									// inplace active 
	COleObject *	_pobjselect;	//@cmember	Object that is currently
									// individually selected (not active)
	LPWSTR		_pszApp;			//@cmember 	Name of app
	LPWSTR		_pszDoc;			//@cmember 	Name of "document"

	unsigned int	_fShowUIPending:1;//@cmember a UI update is pending
	unsigned int	_fInHelpMode:1;	//@cmember in context sensitive help mode?
};

#endif  //__OBJMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_rtfwrit.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFWRIT.H -- RichEdit RTF Writer Class Definition |
 *
 *	Description:
 *		This file contains the type declarations used by the RTF writer
 *		for the RICHEDIT control
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 */
#ifndef __RTFWRIT_H
#define __RTFWRIT_H

#include "_rtfconv.h"
extern const KEYWORD rgKeyword[];

#define PUNCT_MAX	1024


class CRTFWrite ;


class RTFWRITEOLESTREAM : public OLESTREAM
{
	OLESTREAMVTBL OLEStreamVtbl;	// @member - memory for  OLESTREAMVTBL
public:
	 CRTFWrite *Writer;				// @cmember CRTFwriter to use

	RTFWRITEOLESTREAM::RTFWRITEOLESTREAM ()
	{
		lpstbl = & OLEStreamVtbl ;
	}		
};

enum									// Control-Word-Format indices
{
	CWF_STR, CWF_VAL, CWF_GRP, CWF_AST, CWF_GRV
};

#define chEndGroup RBRACE

/*
 *	CRTFWrite
 *
 *	@class	RTF writer class.
 *
 *	@base	public | CRTFConverter
 *
 */
class CRTFWrite : public CRTFConverter
{
private:
	LONG		_cchBufferOut;			//@cmember # chars in output buffer
	LONG		_cchOut;				//@cmember Total # chars put out
	LONG		_cbCharLast;			//@cmember # bytes in char last written
	BYTE		_fBullet;				//@cmember Currently in a bulleted style
	BYTE		_fBulletPending;		//@cmember Set if next output should bull
	BYTE		_fNeedDelimeter;		//@cmember Set if next char must be nonalphanumeric
	BYTE        _fIncludeObjects;       //@cmember Set if objects should be included in stream
	BYTE		_fCheckInTable;			//@cmember If set and in table, output intbl stuff
	BYTE		_fRangeHasEOP;			//@cmember Set if _prg has EOP
	BYTE		_fNCRForNonASCII;		//@cmember Put /uN for nonASCII
	char *		_pchRTFBuffer;			//@cmember Ptr to RTF write buffer
	BYTE *		_pbAnsiBuffer;			//@cmember Ptr to buffer used for conversion
	char *		_pchRTFEnd;				//@cmember Ptr to RTF-write-buffer end
	LONG		_symbolFont;			//@cmember Font number of Symbol used by Bullet style
	RTFWRITEOLESTREAM RTFWriteOLEStream;//@cmember RTFWRITEOLESTREAM to use
	LONG		_nHeadingStyle;			//@cmember Deepest heading # found
	LONG		_nNumber;				//@cmember Current number in para (1-based)
	LONG		_nFont;					//@cmember Current number font index
	LONG		_cpg;					//@cmember Current number code page
	const CParaFormat *_pPF;			//@cmember Current para format

										// @cmember Build font/color tables
	EC			BuildTables		(CFormatRunPtr& rpCF, CFormatRunPtr &rpPF,
								LONG cch, BOOL& fNameIsDBCS);
	inline void		CheckDelimeter()		// @cmember	Put ' ' if need delimeter
	{
		if(_fNeedDelimeter)
		{
			_fNeedDelimeter = FALSE;
			PutChar(' ');
		}
	};

	BOOL		CheckInTable	(BOOL fPutIntbl);
										// @cmember Stream out output buffer
	BOOL		FlushBuffer		();
										// @cmember Get index of <p colorref>
	LONG		LookupColor		(COLORREF colorref);
										// @cmember Get font index for <p pCF>
	LONG		LookupFont		(CCharFormat const * pCF);
										// @cmember "printf" to output buffer
	BOOL _cdecl printF			(CONST CHAR * szFmt, ...);
										// @cmember Put char <p ch> in output buffer
	EC			PutBorders		(BOOL fInTable);
	BOOL		PutChar			(CHAR ch);
										// @cmember Put control word <p iCtrl> with value <p iValue> into output buffer
	BOOL		PutCtrlWord		(LONG iFormat, LONG iCtrl, LONG iValue = 0);
										// @cmember Put string <p sz> in output buffer
	BOOL		Puts			(CHAR const * sz, LONG cb);
										// @cmember Write char format <p pCF>
	EC			WriteCharFormat	(const CCharFormat *pCF);
	EC			WriteColorTable	();		// @cmember Write color table
	EC			WriteFontTable	();		// @cmember Write font table
	EC			WriteInfo		();		// @cmember Write document info
										// @cmember Write para format <p pPF>
	EC			WriteParaFormat	(const CRchTxtPtr * prtp);
										// @cmember Write PC data <p szData>
	EC			WritePcData		(const TCHAR * szData, INT nCodePage = CP_ACP, BOOL fIsDBCS = FALSE );
										// @cmember Write <p cch> chars of text <p pch>
	EC			WriteText(LONG cwch, LPCWSTR lpcwstr, INT nCodePage, BOOL fIsDBCS);
	EC			WriteTextChunk(LONG cwch, LPCWSTR lpcwstr, INT nCodePage, BOOL fIsDBCS);


// OBJECT
	EC			WriteObject		(LONG cp, COleObject *pobj);
	BOOL		GetRtfObjectMetafilePict(HGLOBAL hmfp, RTFOBJECT &rtfobject, SIZEL &sizelGoal);
	BOOL		GetRtfObject(REOBJECT &reobject, RTFOBJECT &rtfobject);
	EC			WriteRtfObject(RTFOBJECT & rtfOb, BOOL fPicture);
	BOOL		ObjectWriteToEditstream(REOBJECT &reObject, RTFOBJECT &rtfobject);
	EC			WritePicture(REOBJECT &reObject,RTFOBJECT  &rtfObject);
	EC			WriteDib(REOBJECT &reObject,RTFOBJECT  &rtfObject);

	enum 		{ MAPTOKWD_ANSI, MAPTOKWD_UNICODE };
	inline BOOL	MapsToRTFKeywordW(WCHAR wch);
	inline BOOL	MapsToRTFKeywordA(char ch);
	int 		MapToRTFKeyword(void *pv, int cch, int iCharEncoding);

public:
											// @cmember Constructor
	CRTFWrite(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags);
	~CRTFWrite() {FreePv(_pbAnsiBuffer);}	// @cmember Destructor

	LONG		WriteRtf();				// @cmember Main write entry used by
										//  CLiteDTEngine
	LONG		WriteData		(BYTE * pbBuffer, LONG cbBuffer);
	LONG		WriteBinData	(BYTE * pbBuffer, LONG cbBuffer);

};										


#endif // __RTFWRIT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_render.h ===
/*
 *	_RENDER.H
 *	
 *	Purpose:
 *		CRenderer class
 *	
 *	Authors:
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _RENDER_H
#define _RENDER_H

#include "_measure.h"
#include "_rtext.h"
#include "_osdc.h"

BOOL IsTooSimilar(COLORREF cr1, COLORREF cr2);

class CDisplay;

// ==========================  CRenderer  ==================================
// CRenderer - specialized text pointer used for rendering text

class CRenderer : public CMeasurer
{
	friend struct COls;
	friend struct CLsrun;
	friend LSERR OlsDrawGlyphs(POLS,PLSRUN,BOOL,BOOL,PCGINDEX,const int*,const int*,PGOFFSET,PGPROP,
		PCEXPTYPE,DWORD,LSTFLOW,UINT,const POINT*,PCHEIGHTS,long,long,const RECT*);

private:
    RECT        _rcView;			// View rect (_hdc logical coords)
    RECT        _rcRender;			// Rendered rect (_hdc logical coords)
    RECT        _rc;				// Running clip/erase rect (_hdc logical coords)
    LONG        _xWidthLine;		// Total width of line
	LONG		_cpAccelerator;		// Accelerator cp if any (-1 if none).

	COLORREF	_crBackground;		// Default background color
	COLORREF	_crForeDisabled;	// Foreground color for disabled text
	COLORREF	_crShadowDisabled;	// Shadow color for disabled text
	COLORREF	_crTextColor;		// Default text color

	COLORREF	_crCurBackground;	// Current background color
	COLORREF	_crCurTextColor;	// Current text color

	COffScreenDC _osdc;				// Manager for off screen DC
	HDC			_hdc;

	union
	{
	  DWORD		_dwFlags;			// All together now
	  struct
	  {
		DWORD	_fDisabled:1;		// Draw text with disabled effects?
		DWORD	_fErase:1;	    	// Erase background (non transparent)
    	DWORD	_fSelected:1;   	// Render run with selection colors
		DWORD	_fLastChunk:1;		// Rendering last chunk
		DWORD	_fSelectToEOL:1;	// Whether selection runs to end of line
		DWORD	_fUseOffScreenDC:1;	// Using off screen DC
		DWORD	_fRenderSelection:1;// Render selection?
		DWORD	_fBackgroundColor:1;// Some text in the line has non-default 
									// background color.
		DWORD	_fEnhancedMetafileDC:1;	// Use ExtTextOutA to hack around all
										// sort of Win95FE EMF or font problems
		DWORD	_fFEFontOnNonFEWin9x:1; // have to use ExtTextOutW even for EMF.
		DWORD	_fSelectedPrev:1;	// TRUE if prev run selected
		DWORD	_fStrikeOut:1;		// TRUE if current run is struckout
	  };
	};

	LOGPALETTE *_plogpalette;
	POINT	 	_ptCur;				// Current rendering position on screen
	BYTE		_bUnderlineType;	// Underline type
	BYTE		_bUnderlineClrIdx;	// Underline color index (0 uses text color)

			void	Init();			// Initialize most members to zero

			void	UpdatePalette(COleObject *pobj);

			void	RenderText(const WCHAR* pch, LONG cch);

			BOOL	SetNewFont();
		
			BOOL 	RenderChunk(LONG &cchChunk, const WCHAR *pszToRender, LONG cch);
			LONG	RenderTabs(LONG cchChunk);
			BOOL	RenderBullet();

public:
	CRenderer (const CDisplay * const pdp);
	CRenderer (const CDisplay * const pdp, const CRchTxtPtr &rtp);
	~CRenderer (){}

	        void    operator =(const CLine& li)     {*(CLine*)this = li;}

			void	RenderExtTextOut(LONG x, LONG y, UINT fuOptions, RECT *prc, PCWSTR pch, UINT cch, const INT *rgdxp);
			void	SetSelected(BOOL f)				{_fSelected = f;}
			BOOL	fBackgroundColor() const		{return _fBackgroundColor;}
			BOOL	fUseOffScreenDC() const			{return _fUseOffScreenDC;}
			COLORREF GetTextColor(const CCharFormat *pCF);
			void	SetTextColor(COLORREF cr);

			void	SetCurPoint(const POINT &pt)	{_ptCur = pt;}
	const	POINT&	GetCurPoint() const				{return _ptCur;}

			void	SetClipRect(void);
            void    SetClipLeftRight(LONG xWidth);
			BOOL	RenderStartLine();
	const	RECT&	GetClipRect() const				{return _rc;}
			HDC		GetDC()	const					{return _hdc;}

			BOOL	StartRender(
						const RECT &rcView, 
						const RECT &rcRender,
						const LONG yHeightBitmap);

			void	EndRender();
			void	EndRenderLine(HDC hdcSave, LONG xAdj, LONG yAdj, LONG x);
			void	FillRectWithColor(RECT *prc, COLORREF cr);
			void 	NewLine (const CLine &li);
			BOOL	RenderLine(CLine &li);
			void	RenderOffScreenBitmap(HDC hdc, LONG yAdj, LONG xAdj);
			BOOL	RenderOutlineSymbol();
			void	RenderStrikeOut(LONG xStart, LONG yStart,
									LONG xWidth, LONG yThickness);
			void	RenderUnderline(LONG xStart, LONG yStart,
									LONG xWidth, LONG yThickness);
			void	SetFontAndColor(const CCharFormat *pCF);
			HDC		SetUpOffScreenDC(LONG& xAdj, LONG& yAdj);
			void	SetupUnderline(LONG UnderlineType);
	 CONVERTMODE	GetConvertMode();
	 BOOL			fFEFontOnNonFEWin9x()			{return _fFEFontOnNonFEWin9x;}
	 BOOL			UseXOR(COLORREF cr)						
	 				{
	 					return GetPed()->Get10Mode() || (_crBackground != ::GetSysColor(COLOR_WINDOW) && _crBackground == cr);
	 				}
};

/*
 * 	BottomOfRender (rcView, rcRender)
 *
 *	@mfunc
 *		Calculate maximum logical unit to render.
 *
 *	@rdesc
 *		Maximum pixel to render
 *
 *	@devnote
 *		This function exists to allow the renderer and dispml to be able
 *		to calculate the maximum pixel for rendering in exactly the same
 *		way.
 */
inline LONG BottomOfRender(const RECT& rcView, const RECT& rcRender)
{
	return min(rcView.bottom, rcRender.bottom);
}		

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_rtfconv.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFCONV.H -- RichEdit RTF Converter Base Class Definition |
 *
 *	Description:
 *		This file contains the type declarations used by both the RTF reader
 *		and writer for the RICHEDIT control
 *
 *	Authors: <nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFCONV_H
#define __RTFCONV_H

#include "_edit.h"
#include "_array.h"
#include "_range.h"
#include "_rtext.h"
#include "tokens.h"

extern const KEYWORD rgKeyword[];

// Convert between Twips and Himetric
// Ratio is 1440 twips/in, 2540 him/in, therefore 1440/2540 = 72/127 him/twips
// Use muldiv() to include rounding and 64-bit intermediate result
#define TwipsFromHimetric(_hm)	MulDiv(_hm, 72, 127)
#define HimetricFromTwips(_tw)	MulDiv(_tw, 127, 72)

#define	LBRACE	TEXT('{')
#define	BSLASH	TEXT('\\')
#define	RBRACE	TEXT('}')
#define ZERO	TEXT('0')

// Character property bits like an ASCII-only ANSI C LC_CTYPE types
#define fUC			0x01		// A-Z
#define	fLC			0x02		// a-z
#define fDG			0x04		// 0-9
#define	fSP			0x08		// Space chars
#define	fPN			0x10		// Punctuation chars
#define fCT			0x20		// Control chars
#define	fBL			0x40		// Blank chars
#define fHX			0x80		// 0-9, a-f, or A-F

#define	fAlpha		(fUC + fLC)
#define	fAlphaNum	(fAlpha + fDG)

extern const BYTE rgbCharClass[256];

#define Classify(_ch)		(rgbCharClass[_ch])
#define IsLC(_ch)			((Classify(_ch) & fLC))
#define IsAlpha(_ch)		((Classify(_ch) & fAlpha))
#define IsDigit(_ch)		((Classify(_ch) & fDG))
#define IsXDigit(_ch)		((Classify(_ch) & fHX))
#define IsAlphaNum(_ch) 	((Classify(_ch) & fAlphaNum))
#define IsAlphaNumBlank(_ch) ((Classify(_ch) & (fAlphaNum + fBL)))

template <class T> unsigned int DiffPtrs(T *pA, T *pB)
{
	return pA - pB;
}

//#define DiffPtrs(_pA, _pB, _type) ((UINT) (((_type *) (_pA)) - ((_type *) (_pB))))

extern INT  cKeywords;
extern const COLORREF g_Colors[];
extern const char szEndGroupCRLF[];

#define szaCRLF		(BYTE *)&szEndGroupCRLF[1]

/*
 *		Converter Error Codes
 */
enum
{
	ecNoError = 0,						// Success
	ecCantUnicode,
	ecColorTableOverflow,
	ecExpectingRtfKeyword,
	ecExpectingStartGroup,
	ecFontTableOverflow,
	ecGeneralFailure,
	ecKeywordTooLong,
	ecLexInitFailed,
	ecNoMemory,
	ecParserBusy,
	ecPutCharFailed,
	ecStackOverflow,
	ecStackUnderflow,
	ecUnexpectedChar,
	ecUnexpectedEOF,
	ecUnexpectedToken,
	ecUnGetCharFailed,
	ecTextMax,
	ecStreamOutObj,
	ecStreamInObj,
	ecTruncateAtCRLF,
	ecFormatCache,
	ecLastError							// Total error messages
};

typedef	INT	EC;

/*
 *	@struct RTFOBJECT |
 *		Object data transfer structure
 */
typedef struct _rtfobject
{
	SHORT	sType;				// @field object type (ROT_*)
	SHORT	sPictureType;		// @field specific type of sPicture
	SHORT	cBitsPerPixel;		// @field # bits per pixel, if bitmap
	SHORT	cColorPlanes;		// @field # color planes, if bitmap
	SHORT	cBytesPerLine;		// @field # bytes per raster line, if bitmap
	BOOL	fSetSize;			// @field Let client tell server the size
	LONG	xExt, yExt;			// @field dimensions in pixels for pictures, twips for
								//	for objects
	LONG	xScale, yScale;		// @field scaling percentage along axes
	SHORT	xExtGoal, yExtGoal;	// @field desired dimensions in twips for pictures
	RECT	rectCrop;			// @field cropping information in twips
	TCHAR *	szClass;			// @field object class
	TCHAR *	szName;				// @field object name

	// On RTF generation
	LONG	xExtPict, yExtPict;	// @field metafile dimensions
	LPBYTE	pbResult;			// metafile depiction of the object
	ULONG	cbResult;
} RTFOBJECT;

/*
 *	@enum ROTYPE | The values for OBJECT.sType
 *
 *		Keep this in sync with rgszROT in rtfwrit.c
 */
enum ROTYPE
{
	ROT_Bitmap,					// @emem Bitmap
	ROT_Metafile,				// @emem Metafile
	ROT_DIB,					// @emem Device-Independent Bitmap

	ROT_Embedded,				// @emem Embedded Object
	ROT_Link,					// @emem Linked Object
	ROT_AutoLink,				// @emem Autolink
	ROT_MacEdition				// @emem Mac object
};


/*
 *		DEFINE's
 */
#define cachBufferMost		4096
#define	cachTextMax			( 512 + 1 )
#define	cachKeywordMax		( 32 + 1 )
#define	cachParamMax		( 11 + 1 )
#define cFooChunk			8

// Characters to give to RichEdit
#define	chNonBreakingSpace		160
#define	chOptionalHyphen		173


#if	( cachTextMax - 1 ) % 2 == 1
#error "cachTextMax  - 1 MUST be even"
#endif

#if ( cachParamMax - 1 ) < 11
#error "cachParamMax MUST be >= 11"
#endif

/*
 * Some RTF defaults
 */
#ifdef NEVER
// we don't care about margins, just indents
#define dxDefaultLeftMargin		1800
#define dxDefaultRightMargin	1800

#else
#define dxDefaultLeftMargin		0
#define dxDefaultRightMargin	0
#endif

// next two in half points
#define	yDefaultFontSize		( 12 * 2 )
#define dyDefaultSuperscript	6

#define RESERVED_FONT_HANDLES	0x800

/*
 *	@struct TEXTFONT |
 *		text font structure
 */
typedef struct _textfont
{
	SHORT		sHandle;				// @field RTF input font handle
	BYTE		bCharSet;				// @field Font character set
	BYTE		bPitchAndFamily;		// @field Font family
	SHORT		iFont;					// @field Font name index
	TCHAR		szName[LF_FACESIZE+1];	// @field Font name
	SHORT		sCodePage;				// @field Code page for font 
										// 			(INVALID_CODEPAGE == not set)
	BYTE		fNameIsDBCS;			// @field Indicates if szName is DBCS stuffed into Unicode buffer
	BYTE		fCpgFromSystem;			// @field Indicates is cpg was 
										// 			retrieved from system based
										//			on font name.
} TEXTFONT;

/*
 *		Global variables for the scope of the entire parser/reader
 */
#ifdef DEBUG
extern CHAR *		rgszParseError[];
extern CHAR *		szDest[];
#endif

#define cchMaxNumText 16

// tagged font info
typedef struct _tfi
{
	TCHAR *szNormalName;
	TCHAR *szTaggedName;
	BYTE bCharSet;
} TFI;

typedef CArray<TEXTFONT> TEXTFONTS;
typedef CArray<COLORREF> COLORREFS;

const short INVALID_CODEPAGE = -1;
const short INVALID_LANGUAGE = -1;

// default value for \ucN tag
const int iUnicodeCChDefault = 1;

/*
 *	CRTFConverter
 *
 *	@class	RTF converter base class used by CRTFRead and CRTFWrite
 */
class CRTFConverter
{
//@access Protected Data Members
protected:
	TEXTFONTS	_fonts;				// @cmember Font table
	COLORREFS	_colors;			// @cmember Color table
	EC			_ecParseError;		// @cmember Error code
	CTxtEdit *	_ped;				// @cmember CTxtEdit
	CTxtRange *	_prg;				// @cmember CTxtRange to replace/write from
	EDITSTREAM *_pes;				// @cmember EDITSTREAM to use
	DWORD		_dwFlags;			// @cmember See #defines below
	CCharFormat	_CF;				// @cmember Character formatting info
	BYTE		_bCharSet;			// @cmember Converter char set (ANSI, UTF7, UTF8)

	static TFI *_rgtfi;				// @cmember Pointer to the first font substitute record
	static INT _ctfi;				// @cmember Number of the font substitute records
	static TCHAR *_pchFontSubInfo;	// @cmember Font strings for substitutions

//@access Protected Functions
	void ReadFontSubInfo(void);

	enum PARSEFONTNAME { PFN_SUCCESS, PFN_FAIL, PFN_EOF };
	PARSEFONTNAME ParseFontName(TCHAR *pchBuf,
							TCHAR *pchBufMax,
							TCHAR chDelimiter,
							TCHAR **pszName,
							BYTE &bCharSet,
							BOOL &fSetCharSet,
							TCHAR **ppchBufNew) const;
	BOOL FontSubstitute(TCHAR *szTaggedName, 
						TCHAR *szNormalName, 
						BYTE *pbCharSet);
	BOOL FindTaggedFont(const TCHAR *szNormalName, BYTE bCharSet, TCHAR **ppchTaggedName);	 
									// @cmember	Find font name with additional special tag 
									// corresponding to szNormalName & bCharSet
	BOOL IsTaggedFont(const TCHAR *szName, BYTE *pbCharSet, TCHAR **ppchNormalName);
								   	// @cmember Figure out is szName font name with additional tag
								   	// corresponding to pbCharSet

//@access Public Functions

public:
	CRTFConverter(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags, BOOL fRead);
	inline ~CRTFConverter();
	static void FreeFontSubInfo();

protected:
#if defined(DEBUG) && !defined(MACPORT)
	// for capturing RTF as its read from or written to a file
	HANDLE _hfileCapture;
#endif
};

#define	fRTFNoObjs	1
#define	fRTFFE	8					// Check this

#define IsUTF8	((_dwFlags & (0xFFFF0000 | SF_USECODEPAGE)) \
					 == ((CP_UTF8 << 16) | SF_USECODEPAGE))

/*
 *	CRTFConverter::CRTFConverter()
 *
 *	@mfunc
 *		RTF Converter constructor
 */
inline CRTFConverter::~CRTFConverter()
{
#if defined(DEBUG) && !defined(MACPORT)
	if(_hfileCapture)
	{
		CloseHandle(_hfileCapture);
		_hfileCapture = NULL;
	}
#endif
}

#endif // __RTFCONV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_runptr.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RUNPTR.H -- Text run and run pointer class defintion |
 *	
 *	Original Author:	<nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95	alexgo	Commenting and Cleanup
 *
 *	Copyright (c) 1995-1997 Microsoft Corporation. All rights reserved.
 */

#ifndef _RUNPTR_H
#define _RUNPTR_H

#include "_array.h"
#include "_doc.h"

typedef CArray<CTxtRun> CRunArray;

/*
 *	CRunPtrBase
 *
 *	@class	Base run pointer functionality.  Keeps a position within an array
 *  	of text runs.
 *
 *	@devnote	Run pointers go through three different possible states :
 *
 *	NULL:	there is no data and no array (frequently a startup condition) <nl>
 *			<mf CRunPtrBase::SetRunArray> will transition from this state to 
 *			the Empty state.  It is typically up to the derived class to
 *			define when that method should be called. IsValid() fails. <nl>
 *
 *			<md CRunPtrBase::_pRuns> == NULL <nl>
 *			<md CRunPtrBase::_iRun> == 0 <nl>
 *			<md CRunPtrBase::_ich> == 0 <nl>
 *
 *	Empty:	an array class exists, but there is no data (can happen if all 
 *			of the elements in the array are deleted).  IsValid() fails.<nl>
 *	 		<md CRunPtrBase::_pRuns> != NULL <nl>
 *			<md CRunPtrBase::_iRun> == 0 <nl>
 *			<md CRunPtrBase::_ich> <gt>= 0 <nl>
 *			<md CRunPtrBase::_pRuns-<gt>Count()> == 0 <nl>
 *
 *	Normal:	the array class exists and has data; IsValid() succeeds and
 *			<md CRunPtrBase::_pRuns-<gt>Elem[] is defined <nl>
 *			<md CRunPtrBase::_pRuns> != NULL <nl>
 *			<md CRunPtrBase::_iRun> >= 0 <nl>
 *			<md CRunPtrBase::_ich> >= 0 <nl>
 *			<md _pRuns>-<gt>Count() > 0 <nl>		
 *	
 *	Note that in order to support the empty and normal states, the actual 
 *	array element at <md CRunPtrBase::_iRun> must be explicitly fetched in
 *	any method that may need it.
 *
 *	Currently, there is no way to transition to the NULL state from any of
 *  the other states.  If we needed to, we could support that by explicitly 
 *	fetching the array from the document on demand.
 *
 *	Note that only <md CRunPtrBase::_iRun> is kept.  We could also keep 
 * 	a pointer to the actual run (i.e. _pRun).  Earlier versions of this
 *	engine did in fact do this.  I've opted to not do this for several
 *	reasons: <nl>
 *		1. If IsValid(), _pRun is *always* available by calling Elem(_iRun).
 * 		Therefore, there is nominally no need to keep both _iRun and _pRun.<nl>
 *		2. Run pointers are typically used to either just move around
 *		and then fetch data or move and fetch data every time (like during 
 *		a measuring loop).  In the former case, there is no need to always
 *		bind _pRun; you can just do it on demand.  In the latter case, the
 *		two models are equivalent.  
 */

class CRunPtrBase
{
	friend class CDisplayML;
	friend class CDisplaySL;

//@access Public methods
public:

#ifdef DEBUG
	BOOL	Invariant() const;				//@cmember	Invariant tests
	void	ValidatePtr(void *pRun) const;	//@cmember	Validate <p pRun>
	LONG 	CalcTextLength() const;			//@cmember  Get total cch in runs
#define	VALIDATE_PTR(pRun)	ValidatePtr(pRun)

#else
#define	VALIDATE_PTR(pRun)
#endif // DEBUG

	CRunPtrBase(CRunArray *pRuns);			//@cmember	Constructor
	CRunPtrBase(CRunPtrBase& rp);			//@cmember	Constructor

	// Run Control
	void	SetRunArray(CRunArray *pRuns)	//@cmember Set run array for this
	{										// run ptr
		_pRuns = pRuns;
	}
	BOOL 	SetRun(LONG iRun, LONG ich);	//@cmember Set this runptr to run
											// <p iRun> & char offset <p ich>
	BOOL	NextRun();						//@cmember Advance to next run
	BOOL	PrevRun();						//@cmember Go back to prev run
	BOOL	ChgRun(LONG cRun)				//@cmember Move <p cRun> runs
	{										// returning TRUE if successful
		return SetRun(_iRun + cRun, 0);
	}	
											//@cmember Count <p cRun> runs 
	LONG	CountRuns(LONG &cRun,			// returning cch counted and
				LONG cchMax,				// updating <p cRun>
				LONG cp,
				LONG cchText) const;
											//@cmember Find run range limits
	void	FindRun (LONG *pcpMin,
				LONG *pcpMost, LONG cpMin, LONG cch, LONG cchText) const;

	CTxtRun * GetRun(LONG cRun) const;		//@cmember Retrieve run element at 
											// offset <p cRun> from this run
	LONG	Count() const					//@cmember	Get count of runs
	{
		return _pRuns->Count();
	}
	BOOL	SameRuns(CRunPtrBase *prp)		//@cmember Return TRUE iff same runs
	{
		return _pRuns == prp->_pRuns;
	}
	BOOL	SameRun(CRunPtrBase *prp)
	{
		return SameRuns(prp) && _iRun == prp->_iRun;
	}

	// Character position control
	LONG 	BindToCp(LONG cp);	//@cmember	Set cp for this run ptr = <p cp>
	LONG 	CalculateCp() const;//@cmember	Add _cch's up to _iRun, _ich
	LONG	AdvanceCp(LONG cch);//@cmember	Advance cp by <p cch> chars

	void 	AdjustBackward();	//@cmember	If on the edge of two runs, 
								// adjust to end of left (previous) run
	void	AdjustForward();	//@cmember	If at the edge of two runs,
								// adjust to start of right (next) run
	LONG 	GetIch() const		//@cmember	Return <md CRunPtrBase::_ich>
				{Assert(IsValid()); return _ich;}
	LONG	GetCchLeft() const;	//@cmember	Return GetRun(0)->_cch - GetIch()								
	BOOL	IsValid() const;	//@cmember	Return FALSE if run ptr is in
								// empty or NULL states.  TRUE otherwise
	void	SetToNull();		//@cmember	Clears data from run pointer

//@access Protected Data
protected:
	CRunArray *	_pRuns;	    	//@cmember	Pointer to CTxtRun array
	LONG 		_iRun;  	    //@cmember	Index of current run in array
	LONG 		_ich;		    //@cmember	Char offset inside current run
};


/*
 *	CRunPtr	(template)
 *
 *	@class	a template over CRunPtrBase allowing for type-safe versions of
 *		run pointers
 * 
 *	@tcarg	class 	| CElem | run array class to be used
 *
 *	@base	public | CRunPtrBase
 */
template <class CElem>
class CRunPtr : public CRunPtrBase
{
public:
	CRunPtr (void)								//@cmember	Constructor
		: CRunPtrBase (0) {}
	CRunPtr (CRunArray *pRuns)					//@cmember	Constructor
		: CRunPtrBase (pRuns) {}
	CRunPtr (CRunPtrBase& rp)					//@cmember	Constructor
		: CRunPtrBase (rp) {}

	// Array management 
										
	CElem *	Add (LONG cRun, LONG *pielIns)	//@cmember Add <p cRun> 	
	{											// elements at end of array
		return (CElem *)_pRuns->Add(cRun, pielIns);
	}
										
	CElem *	Insert (LONG cRun)					//@cmember Insert <p cRun>
	{											// elements at current pos
		return (CElem *)_pRuns->Insert(_iRun, cRun);
	}
										
	void 	Remove (LONG cRun)	//@cmember Remove <p cRun>
	{											// elements at current pos
		_pRuns->Remove (_iRun, cRun);
	}
										//@cmember	Replace <p cRun> elements
										// at current position with those
										// from <p parRun>
	BOOL 	Replace (LONG cRun, CArrayBase *parRun)
	{
		return _pRuns->Replace(_iRun, cRun, parRun);
	}

	CElem *	Elem(LONG iRun) const		//@cmember	Get ptr to run <p iRun>
	{
		return (CElem *)_pRuns->Elem(iRun);
	}
										
	CElem *	GetRun(LONG cRun) const		//@cmember	Get ptr <p cRun> runs
	{									//  away from current run
		return Elem(_iRun + cRun);
	}

	void	IncPtr(CElem *&pRun) const	//@cmember	Increment ptr <p pRun>
	{
		VALIDATE_PTR(pRun);				// Allow invalid ptr after ++ for
		pRun++;							//  for loops
	}
										
	CElem *	GetPtr(CElem *pRun, LONG cRun) const//@cmember Get ptr <p cRun>
	{											// runs away from ptr <p pRun>
		VALIDATE_PTR(pRun + cRun);
		return pRun + cRun;
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_rtflog.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFLOG.H -- RichEdit RTF Log Class Definition |
 *
 *		This file contains the class declarations for an RTF log class
 *		which can be used to track the hit counts of RTF tags encountered
 *		by the RTF reader
 *
 *	Authors:<nl>
 *		Created for RichEdit 2.0:	Brad Olenick 
 *
 *	Copyright (c) 1995-1996, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFLOG_H
#define __RTFLOG_H

#include "tokens.h"	

extern INT cKeywords;

class CRTFLog
{
public:
	typedef size_t INDEX;
	typedef INDEX *PINDEX;
	typedef DWORD ELEMENT;
	typedef ELEMENT *PELEMENT;

	CRTFLog();				//@cmember CRTFLog constructor
	inline ~CRTFLog();		//@cmember CRTFLog destructor

	BOOL FInit() const 
		{ return _rgdwHits ? TRUE : FALSE; }	//@cmember Determines whether object is init'd

	INDEX ISize() const 
		{ return cKeywords; }			//@cmember Number of elements in log

	inline BOOL AddAt(INDEX i);					//@cmember Increment hit count for element at index i
	inline BOOL AddAt(LPCSTR lpcstrKeyword);	//@cmember Increment hit count for RTF keyword 	
	inline BOOL AddAt(TOKEN token);				//@cmember Increment hit count for RTF token

	inline ELEMENT GetAt(INDEX i) const
		{ return (*this)[i]; }											//@cmember Get hit count for element i
	inline BOOL GetAt(LPCSTR lpcstrKeyword, PELEMENT pelemCount) const;	//@cmember Get hit count for RTF keyword
	inline BOOL GetAt(TOKEN token, PELEMENT pelemCount) const;			//@cmember Get hit count for RTF token

	void Reset();						//@cmember Reset all hit count values to 0

	UINT UGetWindowMsg() const;			//@cmember Get window msg ID used for log change notifications

private:
	// we manage all updates through AddAt to 
	// facilitate change notifications
	ELEMENT &operator[](INDEX);				//@cmember Access element i for l-value
	const ELEMENT &operator[](INDEX) const;	//@cmember Access element i for r-value

	LPCSTR LpcstrLogFilename() const;	//@cmember Get name of log filename

	BOOL IIndexOfKeyword(LPCSTR lpcstrKeyword, PINDEX pi) const;	//@cmember Get log index for keyword
	BOOL IIndexOfToken(TOKEN token, PINDEX pi) const;				//@cmember Get log index for token

	void ChangeNotify(INDEX i) const
		{ 
			PostMessage(HWND_BROADCAST, UGetWindowMsg(), i, 0);
		}	//@cmember Notify clients of change to element i
	void ChangeNotifyAll() const 
		{ ChangeNotify(ISize() + 1); }						//@cmember Notify clients of log refresh

	HANDLE _hfm;		//@cmember Handle to file mapping
	HANDLE _hfile;		//@cmember Handle to file behind file mapping
	PELEMENT _rgdwHits;	//@cmember Handle to view of file mapping
	UINT _uMsg;			//@cmember Window msg ID for change notifications
};


/*
 *	CRTFLog::~CRTFLog
 *	
 *	@mfunc
 *		Destructor - cleans up memory-mapped file and underlying resources
 *
 */
inline CRTFLog::~CRTFLog()
{
	if(_rgdwHits)
	{
		UnmapViewOfFile(_rgdwHits);
	}

	if(_hfm)
	{
		CloseHandle(_hfm);
	}

	if(_hfile)
	{
		CloseHandle(_hfile);
	}
}


/*
 *	CRTFLog::AddAt(INDEX i)
 *	
 *	@mfunc
 *		Increments the hit count for log element, i, and
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(INDEX i)
{
	(*this)[i]++;

	// change notification
	ChangeNotify(i);

	return TRUE;
}


/*
 *	CRTFLog::AddAt(LPCSTR lpcstrKeyword)
 *	
 *	@mfunc
 *		Increments the hit count for log element corresponding
 *		to the RTF keyword, lpcstrKeyword, and 
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(LPCSTR lpcstrKeyword)
{
	INDEX i;

	if(!IIndexOfKeyword(lpcstrKeyword, &i))
	{
		return FALSE;
	}

	return AddAt(i);
}


/*
 *	CRTFLog::AddAt(TOKEN token)
 *	
 *	@mfunc
 *		Increments the hit count for log element corresponding
 *		to the RTF token, token, and 
 *		notifies clients of the change
 *
 *	@rdesc
 *		BOOL			whether the increment was successful
 */
inline BOOL CRTFLog::AddAt(TOKEN token)
{
	INDEX i;

	if(!IIndexOfToken(token, &i))
	{
		return FALSE;
	}

	return AddAt((INDEX)i);
}


/*
 *	CRTFLog::GetAt(LPCSTR lpcstKeyword, PELEMENT pelemCount)
 *	
 *	@mfunc
 *		Gets the hit count for log element corresponding to the
 *		RTF keyword, lpcstrKeywor
 *
 *	@rdesc
 *		BOOL		indicates whether a hit count was found for the element
 */
inline BOOL CRTFLog::GetAt(LPCSTR lpcstrKeyword, PELEMENT pelemCount) const
{
	INDEX i;
	
	if(!IIndexOfKeyword(lpcstrKeyword, &i))
	{
		return FALSE;
	}

	if(pelemCount)
	{
		*pelemCount = (*this)[i];
	}

	return TRUE;
}
	

/*
 *	CRTFLog::GetAt(LPCSTR lpcstKeyword, PELEMENT pelemCount)
 *	
 *	@mfunc
 *		Gets the hit count for log element corresponding to the
 *		RTF token, token
 *
 *	@rdesc
 *		BOOL		indicates whether a hit count was found for the element
 */
inline BOOL CRTFLog::GetAt(TOKEN token, PELEMENT pelemCount) const
{
	INDEX i;
	
	if(!IIndexOfToken(token, &i))
	{
		return FALSE;
	}

	if(pelemCount)
	{
		*pelemCount = (*this)[i];
	}

	return TRUE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_rtfread.h ===
/*
 *	@doc INTERNAL
 *
 *	@module _RTFREAD.H -- RichEdit RTF Reader Class Definition |
 *
 *		This file contains the type declarations used by the RTF reader
 *		for the RICHEDIT control
 *
 *	Authors:<nl>
 *		Original RichEdit 1.0 RTF converter: Anthony Francisco <nl>
 *		Conversion to C++ and RichEdit 2.0:  Murray Sargent
 *
 *	@devnote
 *		All sz's in the RTF*.? files refer to a LPSTRs, not LPTSTRs, unless
 *		noted as a szUnicode.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#ifndef __RTFREAD_H
#define __RTFREAD_H

#include "_rtfconv.h"

// TODO: Implement RTF tag logging for the Mac
#if defined(DEBUG) && !defined(MACPORT)
#include "_rtflog.h"
#endif

typedef SHORT	ALIGN;

/*
 *		Destinations of the stuff we may read in while parsing
 */
enum
{
	destRTF,
	destColorTable,
	destFontTable,
	destBinary,
	destObject,
	destObjectClass,
	destObjectName,
	destObjectData,		  // keep next two together
	destPicture,
	destField,
	destFieldResult,
	destFieldInstruction,
	destParaNumbering,
	destParaNumText,
	destRealFontName,
	destFollowingPunct,
	destLeadingPunct,
	destDocumentArea,
	destNULL,
	destStyleSheet
};


/*
 *		Super or subscripting state
 */
enum
{
	sSub = -1,
	sNoSuperSub,
	sSuper
};

/*
 *	@struct STATE | 
 *		Structure to save current reader state
 */
struct STATE
{
	SHORT		sLanguage;				//@field Font information
	SHORT		iCF;					//@field CF index at LBRACE

	// Miscellaneous flags
	unsigned	fInTable		 : 1;	//@field Are we parsing a table cell ?
	unsigned	fBullet			 : 1;	//@field group is a \\pn bullet group
	unsigned	fRealFontName	 : 1;	//@field found a real font name when parsing
	unsigned	fExplicitLang	 : 1;	//@field language explicitly declared
	unsigned	fFieldInst		 : 1;	//@field \fldinst being processed
	unsigned	fFieldRslt		 : 1;	//@field \fldrslt being processed or processed

	// BiDi flags
	unsigned	fRightToLeftPara : 1;	//@field Para text going right to left ?
	unsigned	fZeroWidthJoiner : 1;	//@field Zero Width Joiner ?

	unsigned	frtlch			 : 1;	//@field Are we going right to left ?
	unsigned	fltrch			 : 1;	//@field Are we going right to left ?
	unsigned	fdbch			 : 1;	//@field DBCS run ?
	

	// xchg 12370: keep numbering indent separate
	SHORT		sIndentNumbering;		//@field numbering indent
	SHORT		sDest;					//@field Current destination
	int			nCodePage;				//@field Current code page

	WORD		cbSkipForUnicodeMax;	//@field Bytes to skip after \uN is read

	// Scratch pad variables
	TEXTFONT *	ptf;					//@field Ptr to font table entry to fill
	BYTE		bRed;					//@field Color table red entry
	BYTE		bGreen;					//@field Color table green entry
	BYTE		bBlue;					//@field Color table blue entry
	STATE * 	pstateNext;				//@field Next state on stack
	STATE * 	pstatePrev;				//@field Previous state on stack

	CParaFormat *pPF;					//@field PF for the state to which 
										//	delta's are applied
	DWORD		dwMaskPF;

	STATE(LONG CodePage) {nCodePage = CodePage;}

										//@cmember Adds or applies PF to state's PF
	BOOL AddPF(const CParaFormat &PF,
				LONG lDocType, DWORD dwMask);
	void DeletePF();					//@cmember Deletes PF for state
	void SetCodePage(LONG CodePage);
};

class CRTFRead ;
class COleObject;


class RTFREADOLESTREAM : public OLESTREAM
{
	OLESTREAMVTBL OLEStreamVtbl;	// @member - memory for  OLESTREAMVTBL
public:
	 CRTFRead *Reader;				// @cmember EDITSTREAM to use

	RTFREADOLESTREAM::RTFREADOLESTREAM ()
	{
		lpstbl = & OLEStreamVtbl ;
	}		
};

#define	NSTYLES		(NHSTYLES + 1)
/*
 *	CRTFRead
 *
 *	@class	RichEdit RTF reader class.
 *
 *	@base	public | CRTFConverter
 *
 */
class CRTFRead : public CRTFConverter
{

//@access Private Methods and Data
	// Lexical analyzer outputs
	LONG		_iParam;				//@cmember Control-word parameter
	TOKEN		_token;					//@cmember Current control-word token
	TOKEN		_tokenLast;				//@cmember Previous token
	BYTE *		_szText;				//@cmember Current BYTE text string
	BYTE		_szParam[cachParamMax];	//@cmember Current parameter string

	// Used for reading in
	BYTE		_rgStyles[NSTYLES];		//@cmember Style handle table
	SHORT		_Style;					//@cmember Current style handle
	LONG		_cbBinLeft;				//@cmember cb of bin data left to read
	BYTE *		_pchRTFBuffer;			//@cmember Buffer for GetChar()
	BYTE *		_pchRTFCurrent;			//@cmember Current position in buffer
	BYTE *		_pchRTFEnd;				//@cmember End of buffer
	BYTE *		_pchHexCurr;			//@cmember Current position within
										//  _szText when reading object data
	INT			_nStackDepth;			//@cmember Stack depth
	STATE *		_pstateStackTop;		//@cmember Stack top
	STATE *		_pstateLast;			//@cmember Last STATE allocated
	LONG		_cpThisPara;			//@cmember Start of current paragraph

	DWORD		_dwMaskCF;				//@cmember Character format mask
	DWORD		_dwMaskCF2;				//@cmember Character format mask 2
	CParaFormat	_PF;					//@cmember Paragraph format changes
	DWORD		_dwMaskPF;				//@cmember Paragraph format mask

	LONG		_cTab;					//@cmember Count of defined tabs
	LONG		_dxCell;				//@cmember Half space betw table cells
	LONG		_cCell;					//@cmember Count of cells in table row
	LONG		_iCell;					//@cmember Current cell in table row 
	LONG		_rgxCell[MAX_TAB_STOPS];//@cmember Cell right boundaries
	LONG		_xRowOffset;			//@cmember Row offset to ensure rows fall along left margin
	DWORD		_dwBorderColor;			//@cmember Border colors
	WORD		_wBorders;				//@cmember Border styles
	WORD		_wBorderSpace;			//@cmember Border/text spaces
	WORD		_wBorderWidth;			//@cmember Border widths
	SHORT		_iTabsTable;			//@cmember _iTabs used by last table
	
	COleObject *_pobj;					//@cmember Pointer to our object

	union
	{
	  DWORD		_dwFlagsUnion;			// All together now
	  struct
	  {
		WORD	_fFailedPrevObj	 : 1;	//@cmember Fail to get prev object ?
		WORD	_fNeedIcon		 : 1;	//@cmember Objects needs an icon pres
		WORD	_fNeedPres		 : 1;	//@cmember Use stored presenation.
		WORD	_fGetColorYet	 : 1;	//@cmember used for AutoColor detect
		WORD	_fRightToLeftDoc : 1;	//@cmember Document is R to L ?
		WORD	_fReadDefFont	 : 1;	//@cmember True if we've read a default
										// 		   font from RTF input
		WORD	_fHyperlinkField : 1;	//@cmember TRUE if handling HYPERLINK field
		WORD	_fSeenFontTable	 : 1;	//@cmember True if \fonttbl	processed 
		WORD	_fCharSet		 : 1;	//@cmember True if \fcharset processed
		WORD    _fNoRTFtoken     : 1;   //@cmember True in 1.0 mode if \rtf hasn't been seen
		WORD	_fInTable		 : 1;	//@cmember True if pasting into table
		BYTE	_bDocType;				//@cmember Document Type
	  };
	};

	SHORT		_sDefaultFont;			//@cmember Default font to use
	SHORT       _sDefaultBiDiFont;      //@cmemeber Default Bidi font to use
	SHORT		_sDefaultLanguage;		//@cmember Default language to use
	SHORT		_sDefaultLanguageFE;	//@cmember Default FE language to use

	SHORT		_sDefaultTabWidth;		//@cmember Default tabwidth to use
	BYTE		_bAlignment;			//@cmember Alignment for tables
	BYTE		_bInstFieldCharSet;		//@cmember charset of for HYPERLINK inst field

	BYTE *		_szSymbolFieldResult;   //@cmember Buffer for SYMBOL field result
	CCharFormat _FieldCF;				//@cmember Formatting for field result
	int			_nFieldCodePage;
	DWORD		_dwMaskFieldCF;			//@cmember Character format mask for _FieldCF
	DWORD		_dwMaskFieldCF2;		//@cmember Character format mask 2 for _FieldCF
	TEXTFONT *	_ptfField;
	BOOL		_fRestoreFieldFormat;	//@cmember Indicates if the caced format was restored
	TCHAR		_szNumText[cchMaxNumText];	//@cmember Scratch pad for numbered lists

	int			_nCodePage;				//@cmember default codepage (RTF-read-level)
	int			_cchUsedNumText;		//@cmember space used in szNumText

	BYTE *		_szHyperlinkFldinst;	//@cmember Hyperlink Fldinst string	buffer
	int			_cchHyperlinkFldinst;	//@cmember size of Hyperlink Fldinst string	buffer
	int			_cchHyperlinkFldinstUsed;	//@cmember space used in Hyperlink Fldinst string buffer

	BYTE *		_szHyperlinkFldrslt;	//@cmember Hyperlink Fldrslt string	buffer	
	int			_cchHyperlinkFldrslt;	//@cmember size of Hyperlink Fldrslt string	buffer
	int			_cchHyperlinkFldrsltUsed;	//@cmember space used in Hyperlink Fldrslt string buffer

	RTFOBJECT *	_prtfObject;			//@cmember Ptr to RTF Object
	RTFREADOLESTREAM RTFReadOLEStream;	//@cmember RTFREADOLESTREAM to use

	TCHAR *		_szUnicode;				//@cmember String to hold Unicoded chars
	LONG		_cchUnicode;			//@cmember Size of _szUnicode in WCHARs
	DWORD		_cchMax;				//@cmember Max cch that can still be inserted
	LONG		_cpFirst;				//@cmember Starting cp for insertion

	// Object attachment placeholder list
	LONG *		_pcpObPos;
	int			_cobPosFree;
	int 		_cobPos;

	WORD		_wNumberingStyle;		//@cmember Numbering style to use
	WORD		_cbSkipForUnicode; 		//@cmember Bytes to skip after \uN
	BYTE		_bTabType;				//@cmember left/right/center/deciml/bar tab
	BYTE		_bTabLeader;			//@cmember none/dotted/dashed/underline
	BYTE		_bBorder;				//@cmember Current border segment
	BYTE		_bCellBrdrWdths;		//@cmember Current cell border widths

	BYTE		_bBiDiCharSet;			//@cmember Default system's charset

	// Lexical Analyzer Functions
	void	DeinitLex();				//@cmember Release lexer storage
	BOOL	InitLex();					//@cmember Alloc lexer storage
	EC		SkipToEndOfGroup();			//@cmember Skip to matching }
	TOKEN	TokenFindKeyword(BYTE *szKeyword);	//@cmember Find _token for szKeyword
	TOKEN	TokenGetHex();				//@cmember Get next byte from hex input
	TOKEN	TokenGetKeyword();			//@cmember Get next control word
	TOKEN	TokenGetText(BYTE ch);		//@cmember Get text in between ctrl words
	TOKEN	TokenGetToken();			//@cmember Get next {, }, \\, or text
	BOOL 	FInDocTextDest() const;		//@cmember Is reader in document text destination

	// Input Functions
	LONG	FillBuffer();				//@cmember Fill input buffer
	BYTE	GetChar();					//@cmember Return char from input buffer
	BYTE	GetHex();					//@cmember Get next hex value from input
	BYTE	GetHexSkipCRLF();			//@cmember Get next hex value from input
	void	ReadFontName(STATE *pstate, int iAllASCII);//@cmember Copy font name into state
	BOOL	UngetChar();				//@cmember Decrement input buffer ptr
	BOOL	UngetChar(UINT cch);		//@cmember Decrement input buffer ptr 'cch' times

	// Reader Functions
	EC		AddText(TCHAR *pch, LONG cch, BOOL fNumber);//@cmember Insert text into range
	void	Apply_CF();					//@cmember Apply _CF changes
	void	Apply_PF();					//@cmember Apply _PF changes
	COLORREF GetColor(DWORD dwMask);	//@cmember Get color _iParam for mask
	LONG	GetStandardColorIndex();	//@cmember Get std index <-> _iparam
	EC		HandleChar(WORD ch);		//@cmember Insert single Unicode
	EC		HandleEndGroup();			//@cmember Handle }
	EC		HandleEndOfPara();			//@cmember Insert EOP into range
	EC		HandleStartGroup();			//@cmember Handle {
	enum { CONTAINS_NONASCII, ALL_ASCII };
	EC		HandleText(BYTE *szText, int iAllASCII, LONG cchText = -1);//@cmember Insert szText into range
	EC		HandleToken();				//@cmember Grand _token switchboard
	void	SelectCurrentFont(INT iFont);//@cmember Select font <p iFont>
	void	SetPlain(STATE *pstate);	//@cmember Setup _CF for \plain
	EC		HandleFieldInstruction();	//@cmember	Handle field instruction
	EC		HandleFieldSymbolInstruction(BYTE *pch);	//@cmember	Handle specific SYMBOL field instruction
	EC		HandleFieldHyperlink(BYTE *pch); //@cmember	Handle hyperlink field instruction
	EC		HandleFieldSymbolFont(BYTE *pch); //@cmember Handle \\f "Facename" in symbol
	void	HandleFieldEndGroup();			//@cmember Handle Field End Group

	// Object functions
	EC		HexToByte(BYTE *rgchHex, BYTE *pb);
	void	FreeRtfObject();
	EC		StrAlloc(TCHAR ** ppsz, BYTE * sz);
	BOOL	ObjectReadFromEditStream(void);
	BOOL	StaticObjectReadFromEditStream(int cb = 0);
	BOOL	ObjectReadSiteFlags( REOBJECT * preobj);
	
	void	SetBorderParm(WORD& Parm, LONG Value);
	BOOL 	CpgInfoFromFaceName(TEXTFONT *ptf);	//@cmember Determines 
										// charset/cpg based on TEXTFONT::szName

//@access Public Methods
public:
		//@cmember RTF reader constructor
	CRTFRead(CTxtRange *prg, EDITSTREAM *pes, DWORD dwFlags);
	inline ~CRTFRead();					//@cmember CRTFRead destructor

	LONG	ReadRtf();					//@cmember Main Entry to RTF reader

	LONG	ReadData(BYTE *pbBuffer, LONG cbBuffer); // todo friend
	LONG	ReadBinaryData(BYTE *pbBuffer, LONG cbBuffer);
	LONG	SkipBinaryData(LONG cbSkip);
	LONG	ReadRawText(char	**pszRawText);				//@cmember Read in raw text

// Member functions/data to test coverage of RTF reader
#if defined(DEBUG)
public:
	void TestParserCoverage();
private:
	CHAR *PszKeywordFromToken(TOKEN token);
	BOOL FTokIsSymbol(TOKEN tok);
	BOOL FTokFailsCoverageTest(TOKEN tok);

	BOOL _fTestingParserCoverage;

private:
	// member data for RTF tag logging
	CRTFLog *_prtflg;
#endif //DEBUG
};

/*
 *	PointsToFontHeight(cHalfPoints)
 *
 *	@func
 *		Convert half points to font heights
 *
 *	@parm int |
 *		sPointSize |		Font height in half points
 *
 *	@rdesc
 *		LONG				The corresponding CCharFormat.yHeight value
 */
#define PointsToFontHeight(cHalfPoints) (((LONG) cHalfPoints) * 10)


/*
 *	CRTFRead::~CRTFRead
 *
 *	@mdesc
 *		Destructor 
 *
 */
inline CRTFRead::~CRTFRead()
{
// TODO: Implement RTF tag logging for the Mac and WinCE
#if defined(DEBUG) && !defined(MACPORT)	&& !defined(PEGASUS)
	if(_prtflg)
	{
		delete _prtflg;
		_prtflg = NULL;
	}
#endif
}
#endif // __RTFREAD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_select.h ===
/*
 *	SELECT.C
 *	
 *	Purpose:
 *		CTxtSelection class
 *	
 *	Owner:
 *		David R. Fulmer (original code)
 *		Christian Fortini
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _SELECT_H
#define _SELECT_H

#include "_range.h"
#include "_m_undo.h"

// amount of time, in milisecs, before pending characters force a display update
#define ticksPendingUpdate 100	// 100 mili secs ~ display at least 10 characters per second.

class CDisplay;
class CLinePtr;

typedef enum
{
	smNone,
	smWord,
	smLine,
	smPara
} SELMODE;

enum
{
	CARET_NONE	= 0,
	CARET_CUSTOM = 1,
	CARET_BIDI = 2,
	CARET_THAI = 4,
	CARET_INDIC = 8
};

class CTxtSelection : public CTxtRange
{
#ifdef DEBUG
public:
	BOOL Invariant( void ) const; // Invariant checking.
#endif // DEBUG

//@access Protected Data
protected:
	CDisplay	*_pdp;			// display this selection belong to

	LONG	_cpSel;				// active end of displayed selection
	LONG	_cchSel;			// length of displayed selection

	LONG 	_xCaret;			// caret x on screen
	LONG 	_yCaret;			// caret y on screen 
	LONG 	_xCaretReally;		// real caret x (/r start of line) for vertical moves
	INT 	_yHeightCaret;		// caret height

	union
	{
	  DWORD _dwFlags;			// All together now
	  struct
	  {
	   DWORD _fCaretNotAtBOL:1;	// If at BOL, show caret at prev EOL
	   DWORD _fDeferUpdate	:1;	// Defer updating selection/caret on screen
	   DWORD _fInAutoWordSel:1;	// Current selection used auto word sel
	   DWORD _fShowCaret	:1;	// Show caret on screen
	   DWORD _fShowSelection:1;	// Show selection on screen

	   DWORD _fIsChar		:1;	// Currently adding a single char
	   DWORD _fObSelected	:1;	// An embedded object is selected
	   DWORD _fAutoSelectAborted : 1; // Whether auto word selection is aborted
	   DWORD _fCaretCreated	:1;	// Caret has been created
	   DWORD _fNoKeyboardUpdate :1; // Keyboard is not updated while in UpdateCaret()
	   DWORD _fEOP			:1;	// InsertEOP() has been called
	   DWORD _fHomeOrEnd	:1;	// Home or End key is being processed
	   DWORD _fAutoVScroll	:1;	// 1.0 specific: flag indicating autoscrolling should be applied
	   DWORD _fForceScrollCaret:1; // 1.0 specific: force craet to scroll
	  };
	};
	
	SELMODE	_SelMode;			// 0 none, 1 Word, 2 Line, 3 Paragraph
	DWORD	_ticksPending;		// Count of chars inserted without UpdateWindow
	LONG 	_cpAnchor;			// Initial anchor for auto word select
	LONG	_cpAnchorMin;		// Initial selection cpMin/cpMost for select
	LONG	_cpAnchorMost;		//  modes
	LONG 	_cpWordMin;			// Start of anchor word in word select mode
	LONG 	_cpWordMost;		// End   of anchor word in word select mode
	LONG	_cpWordPrev;		// Previous anchor word end

	HBITMAP	_hbmpCaret;			// Used for funky carets, like BiDi/ital carets
	DWORD	_dwCaretInfo;		// Current caret info used to avoid new create

//@access Public Methods
public:
	CTxtSelection(CDisplay * const pdp);
	~CTxtSelection();

	CRchTxtPtr&	operator =(const CRchTxtPtr& rtp);
	CTxtRange&  operator =(const CTxtRange &rg);

	// Set the display
	void	SetDisplay(CDisplay *pdp) { _pdp = pdp; }

	// Information for Selection Change notification

	void 	SetSelectionInfo(SELCHANGE *pselchg);

	// Replacement
	LONG	ReplaceRange(LONG cchNew, TCHAR const *pch, 
						IUndoBuilder *publdr, SELRR fCreateAE, LONG* pcchMove = NULL, DWORD dwFlags = 0);

	// Info for recalc line / UpdateView
	void	ClearCchPending()			{_ticksPending = 0;}
	LONG	GetScrSelMin() const		{return min(_cpSel, _cpSel - _cchSel);}
	LONG	GetScrSelMost() const		{return max(_cpSel, _cpSel - _cchSel);}
	BOOL	PuttingChar() const			{return _fIsChar;}

	// General updating
	virtual	BOOL 	Update(BOOL fScrollIntoView);

	BOOL	DeferUpdate()			
				{const BOOL fRet = _fDeferUpdate; _fDeferUpdate = TRUE; return fRet;}
	BOOL	DoDeferedUpdate(BOOL fScrollIntoView)		
				{_fDeferUpdate = FALSE; return Update(fScrollIntoView);}

	void SetAutoVScroll(BOOL bAuto) {_fAutoVScroll = bAuto;}
	BOOL GetAutoVScroll()	{return _fAutoVScroll;}

	void SetForceScrollCaret(BOOL bAuto) {_fForceScrollCaret = bAuto;}
	BOOL GetForceScrollCaret() {return _fForceScrollCaret;}

	// method used by selection anti-event for out-of-phase updates
	void	SetDelayedSelectionRange(LONG cp, LONG cch);
	void	StopGroupTyping();

	// Caret management
	BOOL	CaretNotAtBOL() const;
	void	CreateCaret();
	void	DeleteCaretBitmap(BOOL fReset);
	INT		GetCaretHt()				{return _yHeightCaret;}
	LONG	GetXCaretReally();
	LONG	GetXCaret()	const			{return _xCaret;}
	LONG	GetYCaret()	const			{return _yCaret;}
	BOOL 	IsCaretInView() const;
	BOOL 	IsCaretShown() const		{return _fShowCaret && !_cch;}
	LONG	LineLength(LONG *pcp) const;
	BOOL	SetXPosition(LONG xCaret, CLinePtr& rp);
	BOOL 	ShowCaret(BOOL fShow);
	BOOL 	UpdateCaret(BOOL fScrollIntoView, BOOL fForceCaret = FALSE);
	BOOL	GetCaretPoint(RECT &rcClient, POINT &pt, CLinePtr *prp, BOOL fBeforeCp);
	BOOL	MatchKeyboardToPara();

	// Selection management
	void	ClearPrevSel()				{ _cpSel = 0; _cchSel = 0; }
	BOOL	GetShowSelection()			{return _fShowSelection;}
	BOOL	ScrollWindowful(WPARAM wparam);
	void 	SetSelection(LONG cpFirst, LONG cpMost);
	BOOL	ShowSelection(BOOL fShow);
	void	Beep()						{GetPed()->Beep();}

	// Selection with the mouse
	void 	CancelModes	(BOOL fAutoWordSel = FALSE);
	void 	ExtendSelection(const POINT pt);
	BOOL	PointInSel	(const POINT pt, const RECT *prcClient,
						 HITTEST Hit = HT_Undefined) const;
	void 	SelectAll	();
	void 	SelectUnit	(const POINT pt, LONG Unit);
	void 	SelectWord	(const POINT pt);
 	void 	SetCaret	(const POINT pt, BOOL fUpdate = TRUE);

	// Keyboard movements
	BOOL 	Left	(BOOL fCtrl);
	BOOL	Right	(BOOL fCtrl);
	BOOL	Up		(BOOL fCtrl);
	BOOL	Down	(BOOL fCtrl);
	BOOL	Home	(BOOL fCtrl);
	BOOL	End		(BOOL fCtrl);
	BOOL	PageUp	(BOOL fCtrl);
	BOOL	PageDown(BOOL fCtrl);

	// Editing
	BOOL	BypassHiddenText(LONG iDir);
	BOOL	PutChar	 (TCHAR ch, DWORD dwFlags, IUndoBuilder *publdr);
	void	SetIsChar(BOOL);
	void	CheckUpdateWindow();
	void	CheckTableSelection();
	BOOL	InsertEOP(IUndoBuilder *publdr, WCHAR ch = 0);
	
	// Keyboard switching support.
	void	CheckChangeKeyboardLayout();
	bool	CheckChangeFont (const HKL hkl, UINT cp, LONG iSelFormat = 0, DWORD dwCharFlag = 0);
	UINT	CheckSynchCharSet(DWORD dwCharFlag = 0);

	// from CTxtRange
	BOOL	Delete  (DWORD flags, IUndoBuilder *publdr);
	BOOL	Backspace(BOOL fCtrl, IUndoBuilder *publdr);

	const CParaFormat* GetPF();

	// note that the parameters are different than CTxtRange::SetCharFormat
	// intentionally; the selection has extra options available to it.
	HRESULT	SetCharFormat(const CCharFormat *pCF, DWORD flags,  
									IUndoBuilder *publdr, DWORD dwMask, DWORD dwMask2);
	HRESULT	SetParaFormat(const CParaFormat *pPF,
									IUndoBuilder *publdr, DWORD dwMask);

	// Auto word selection helper
	void	InitClickForAutWordSel(const POINT pt);

	// dual font helper for CTxtSelection::PutChar
	void	SetupDualFont();

	// IUnknown and IDispatch methods handled by CTxtRange methods

	// ITextRange methods can use ITextRange methods directly, since
	// they either don't modify the display of the selection (get methods), or
	// they have appropriate virtual character to call on selection functions.

	// ITextSelection methods
	STDMETHODIMP GetFlags (long *pFlags) ;
	STDMETHODIMP SetFlags (long Flags) ;
	STDMETHODIMP GetType  (long *pType) ;
	STDMETHODIMP MoveLeft (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveRight(long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveUp	  (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP MoveDown (long pUnit, long Count, long Extend,
									   long *pDelta) ;
	STDMETHODIMP HomeKey  (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP EndKey   (long pUnit, long Extend, long *pDelta) ;
	STDMETHODIMP TypeText (BSTR bstr) ;
	STDMETHODIMP SetPoint (long x, long y, long Extend) ;

//@access Protected Methods
protected:

	// Protected update method
	void	UpdateSelection();

	// Protected caret management method
	INT 	GetCaretHeight(INT *pyDescent) const;

	HRESULT	GeoMover (long Unit, long Count, long Extend,
					  long *pDelta, LONG iDir);
	HRESULT Homer	 (long Unit, long Extend, long *pDelta,
					  BOOL (CTxtSelection::*pfn)(BOOL));

	// Auto Select Word Helpers
	void	UpdateForAutoWord();
	void	AutoSelGoBackWord(
				LONG *pcpToUpdate,
				int iDirToPrevWord,
				int	iDirToNextWord);

	void	ExtendToWordBreak(BOOL fAfterEOP, INT iDir);
	BOOL	CheckPlainTextFinalEOP();

};

/*
 *	CSelPhaseAdjuster
 *
 *	@class	This class is put on the stack and used to temporarily hold
 *			selection cp values until the control is "stable" (and thus,
 *			we can safely set the selection
 */
class CSelPhaseAdjuster : public IReEntrantComponent
{
//@access	Public methods
public:

	// IReEntrantComponent methods

	virtual	void OnEnterContext()	{;}		//@cmember re-entered notify

	CSelPhaseAdjuster(CTxtEdit *ped);		//@cmember constructor
	~CSelPhaseAdjuster();					//@cmember destructor

	void CacheRange(LONG cp, LONG cch);		//@cmember stores the sel range

//@access	Private data
private:
	CTxtEdit *		_ped;					//@cmember edit context
	LONG			_cp;					//@cmember sel active end to set
	LONG			_cch;					//@cmember sel extension
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_rtext.h ===
/*
 *	_RTEXT.H
 *	
 *	Purpose:
 *		Base classes for rich-text manipulation
 *	
 *	Authors:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *
 */

#ifndef _RTEXT_H
#define _RTEXT_H

#include "_edit.h"
#include "_array.h"
#include "_doc.h"
#include "_text.h"
#include "_runptr.h"
#include "_frunptr.h"
#include "_notmgr.h"



//#pragma warning(disable: 4250)	

#define yHeightCharMost	32760

class CTxtEdit;
class CTxtRange;
class CRchTxtPtr;

// ReplaceRange's flags
enum
{
	RR_ITMZ_NOUNICODEBIDI	= 0,
	RR_ITMZ_UNICODEBIDI		= 1,
	RR_ITMZ_NONE			= 2,
									//the following bits should be exclusive
	RR_NO_EOR_CHECK			= 8		//flag indicating not to perform end-of-row check,
};

extern BOOL IsWhiteSpace(unsigned ch);

// ==============================  CRchTxtPtr  =====================================================
// Keeps physical positions corresponding to text character position (cp)
// within current text block, formatting runs, objects, unknown RTF runs,
// and floating ranges.

class CRchTxtPtr : public ITxNotify
{
public:

#ifdef DEBUG
    BOOL Invariant( void ) const;
	int m_InvariantCheckInterval;
#endif  // DEBUG

	CTxtPtr			_rpTX;		// rp in the plain text array
	CFormatRunPtr	_rpCF;		// rp in character format runs
	CFormatRunPtr	_rpPF;		// rp in paragraph format runs

// Useful constructors

	CRchTxtPtr(CTxtEdit *ped);
	CRchTxtPtr(CTxtEdit *ped, LONG cp);
	CRchTxtPtr(const CRchTxtPtr& rtp);
	CRchTxtPtr(const CDisplay * pdp);

	virtual CRchTxtPtr& operator =(const CRchTxtPtr& rtp)
	{
		_rpTX._ped = rtp._rpTX._ped;
		SetCp(rtp.GetCp());
		return *this;
	}

	LONG 	Advance(LONG cch);
	LONG	AdvanceCRLF();
	LONG	BackupCRLF(BOOL fDiacriticCheck = TRUE);
	LONG	SnapToCluster(INT iDirection = 0);
	LONG	SetCp( LONG cp);
	void	BindToCp(LONG cp);
	void	CheckFormatRuns();
	LONG	GetCp() const			{ return _rpTX.GetCp(); }
	LONG	GetTextLength() const	{ return _rpTX.GetTextLength(); }
	LONG	GetObjectCount() const	{ return GetPed()->GetObjectCount(); }
	CTxtEdit *GetPed() const		{ return _rpTX._ped; }
	const TCHAR * GetPch(LONG &cchvalid) { return _rpTX.GetPch(cchvalid); }
	TCHAR 	GetChar()				{ return _rpTX.GetChar(); }
	TCHAR 	GetPrevChar()			{ return _rpTX.GetPrevChar(); }
	void	ValidateCp(LONG &cp) const;
	LONG	GetParaNumber() const;
	LONG	GetCachFromCch(LONG cch);
	LONG	GetCchFromCach(LONG cach);

	// Text manipulation methods

	// Range operations
	LONG	ReplaceRange(LONG cchOld, LONG cchNew, TCHAR const *pch,
						 IUndoBuilder *publdr, LONG iFormat,
						 LONG *pcchMove = NULL, DWORD dwFlags = 0);
	BOOL 	ItemizeReplaceRange(LONG cchUpdate, LONG cchMove,
						IUndoBuilder *publdr, BOOL fUnicodeBidi = FALSE);
	BOOL	ChangeCase(LONG cch, LONG Type, IUndoBuilder *publdr);
	LONG	UnitCounter (LONG iUnit, LONG &	cUnit, LONG cchMax);
	void	ExtendFormattingCRLF();
	LONG	ExpandRangeFormatting(LONG cchRange, LONG cchMove, LONG& cchAdvance);

	// Search and word-break support
	LONG	FindText(LONG cpMax, DWORD dwFlags, TCHAR const *pch,
					 LONG cchToFind);
	LONG	FindWordBreak(INT action, LONG cpMost = -1);

	// Text-run management
	LONG 	GetIchRunCF();
	LONG	GetIchRunPF();
	LONG 	GetCchRunCF();
	LONG 	GetCchLeftRunCF();
	LONG 	GetCchLeftRunPF();
	
	// Character & paragraph format retrieval
	const CCharFormat* GetCF() const;
	const CParaFormat* GetPF() const;

	BOOL	IsCollapsed() const	{return (GetPF()->_wEffects & PFE_COLLAPSED) != 0;}
	BOOL	IsHidden() const	{return (GetCF()->_dwEffects & CFE_HIDDEN)   != 0;}
	BOOL	InTable() const		{return (GetPF()->_wEffects & PFE_TABLE)     != 0;}
	BOOL	IsParaRTL() const	{return (GetPF()->_wEffects & PFE_RTLPARA)   != 0;}

    // ITxNotify methods
    virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
    					LONG cpFormatMin, LONG cpFormatMax) { ; }
	virtual void 	OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
						LONG cpFormatMin, LONG cpFormatMax) { ; }
	virtual void	Zombie();

	BOOL	Check_rpCF();
	BOOL	Check_rpPF();

protected:
	BOOL 	AdvanceRunPtrs(LONG cp);
	void	InitRunPtrs();
	BOOL	IsRich();
	bool  	fUseUIFont() const {return GetPed()->fUseUIFont();}
	BOOL	IsInOutlineView() const {return GetPed()->IsInOutlineView();}
	void	SetRunPtrs(LONG cp, LONG cpFrom);

private:
	LONG	ReplaceRangeFormatting(LONG cchOld, LONG cchNew, LONG iFormat,
							IUndoBuilder *publdr,
							IAntiEvent **ppaeCF, IAntiEvent **ppaePF,
							LONG cchMove, LONG cchPrevEOP, LONG cchNextEOP,
							LONG cchSaveBefore = 0, LONG cchSaveAfter = 0);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_tomdoc.h ===
/*
 *	@doc TOM
 *
 *	@module _tomdoc.H -- CTxtDoc Class |
 *	
 *		This class implements the TOM ITextDocument interface
 *	
 *	@devnote
 *		This class depends on the internal RichEdit CTxtStory class, but is
 *		separate, that is, a CTxtDoc has a ptr to the internal CTxtStory,
 *		rather than CTxtDoc deriving from ITextDocument.  This choice
 *		was made so that edit control instances that don't use the
 *		ITextDocument interface don't have to have the extra vtable ptr.
 *
 *		When this class is destroyed, it doesn't destroy the internal
 *		CTxtStory object (CTxtEdit::_pdoc).  However the TOM client's
 *		perception is that the document is no longer in memory, so the internal
 *		document should be cleared.  It's the client's responsibility to save
 *		the document, if desired, before releasing it.
 *
 *	@future
 *		Generalize so that CTxtDoc can handle multiple CTxtStory's.
 */

#ifndef _tomdoc_H
#define _tomdoc_H

#include "_range.h"

class CTxtDoc : public ITextDocument
{
//@access Public methods
public:
	CTxtDoc(CTxtEdit *ped);

    // IUnknown methods
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDispatch methods
    STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
    STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
    STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
    STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

    // ITextDocument methods
	STDMETHODIMP GetName (BSTR * pName);		//@cmember Get document filename
	STDMETHODIMP GetCount (long *pCount);		//@cmember Get count of stories in document
	STDMETHODIMP _NewEnum(IEnumRange **ppenum);	//@cmember Get stories enumerator
	STDMETHODIMP Item (long Index, ITextRange **pprange);//@cmember Get <p Index>th story
	STDMETHODIMP Save (VARIANT * pVar);			//@cmember Save this document
	STDMETHODIMP BeginEditCollection ();		//@cmember Turn on undo grouping
	STDMETHODIMP EndEditCollection ();			//@cmember Turn off undo grouping

//@access Private data
private:
	CTxtEdit *		_ped;		//@cmember CTxtEdit this belongs to
	TCHAR *			_pName;		//@cmember Filename of document
	LONG			_cRefs;		//@cmember Reference count
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_undoid.h ===
/*
 *	_undoid.h
 *
 *	Purpose:
 *		Undo ID defintions.  These ID's are used to lookup string names
 *		in our resources for the various undo operations
 *
 *	Author:
 *		AlexGo  4/13/95
 */

#ifndef __UNDOID_H__
#define __UNDOID_H__

//
//	typing operations
//

#define UID_TYPING			1
#define	UID_REPLACESEL		2
#define UID_DELETE			3

//
//	data transfer operations
//

#define	UID_DRAGDROP		4
#define UID_CUT				5
#define UID_PASTE			6
#define UID_LOAD			7

#endif // __UNDOID_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_tomfmt.h ===
/*
 *	@doc
 *
 *	@module _tomfmt.h -- CTxtFont and CTxtPara Classes |
 *	
 *		This class implements the TOM ITextFont and ITextPara interfaces
 *	
 *	Author: <nl>
 *		Murray Sargent
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _tomformat_H
#define _tomformat_H

#include "_range.h"

extern const BYTE g_rgREtoTOMAlign[];

// CTxtFormat: base class for CTxtFont and CTxtPara

class CTxtFormat
{
protected:
	CTxtFormat(CTxtRange *prg);
	~CTxtFormat();

	long		_cRefs;
	CTxtRange *	_prg;

	HRESULT	CanChange(long *pBool, BOOL fPara);
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, long Type, long Value);
	HRESULT	IsTrue		 (BOOL f, long *pB);
	BOOL	IsZombie()	 {return _prg && _prg->IsZombie();}
};


class CTxtFont : public ITextFont, CTxtFormat
{
	friend	CTxtRange;

	CCharFormat	_CF;
	DWORD		_dwMask;			// CHARFORMAT2 mask
	union
	{
	  DWORD _dwFlags;				// All together now
	  struct
	  {
		DWORD _fApplyLater : 1;		// Delay call to _prg->CharFormatSetter()
		DWORD _fCacheParms : 1;		// Update _CF now but not on GetXs
	  };
	};

public:
	CTxtFont(CTxtRange *prg);

	// IUnknown methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch methods
	STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
	STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
	STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

	// ITextFont methods
	STDMETHODIMP GetDuplicate(ITextFont **ppFont);
	STDMETHODIMP SetDuplicate(ITextFont *pFont);
	STDMETHODIMP CanChange(long *pB);
	STDMETHODIMP IsEqual(ITextFont *pFont, long *pB);
	STDMETHODIMP Reset(long Value);
	STDMETHODIMP GetStyle(long *pValue);
	STDMETHODIMP SetStyle(long Value);
	STDMETHODIMP GetAllCaps(long *pValue);
	STDMETHODIMP SetAllCaps(long Value);
	STDMETHODIMP GetAnimation(long *pValue);
	STDMETHODIMP SetAnimation(long Value);
	STDMETHODIMP GetBackColor(long *pValue);
	STDMETHODIMP SetBackColor(long Value);
	STDMETHODIMP GetBold(long *pValue);
	STDMETHODIMP SetBold(long Value);
	STDMETHODIMP GetEmboss(long *pValue);
	STDMETHODIMP SetEmboss(long Value);
	STDMETHODIMP GetForeColor(long *pValue);
	STDMETHODIMP SetForeColor(long Value);
	STDMETHODIMP GetHidden(long *pValue);
	STDMETHODIMP SetHidden(long Value);
	STDMETHODIMP GetEngrave(long *pValue);
	STDMETHODIMP SetEngrave(long Value);
	STDMETHODIMP GetItalic(long *pValue);
	STDMETHODIMP SetItalic(long Value);
	STDMETHODIMP GetKerning(float *pValue);
	STDMETHODIMP SetKerning(float Value);
	STDMETHODIMP GetLanguageID(long *pValue);
	STDMETHODIMP SetLanguageID(long Value);
	STDMETHODIMP GetName(BSTR *pbstr);
	STDMETHODIMP SetName(BSTR bstr);
	STDMETHODIMP GetOutline(long *pValue);
	STDMETHODIMP SetOutline(long Value);
	STDMETHODIMP GetPosition(float *pValue);
	STDMETHODIMP SetPosition(float Value);
	STDMETHODIMP GetProtected(long *pValue);
	STDMETHODIMP SetProtected(long Value);
	STDMETHODIMP GetShadow(long *pValue);
	STDMETHODIMP SetShadow(long Value);
	STDMETHODIMP GetSize(float *pValue);
	STDMETHODIMP SetSize(float Value);
	STDMETHODIMP GetSmallCaps(long *pValue);
	STDMETHODIMP SetSmallCaps(long Value);
	STDMETHODIMP GetSpacing(float *pValue);
	STDMETHODIMP SetSpacing(float Value);
	STDMETHODIMP GetStrikeThrough(long *pValue);
	STDMETHODIMP SetStrikeThrough(long Value);
	STDMETHODIMP GetSubscript(long *pValue);
	STDMETHODIMP SetSubscript(long Value);
	STDMETHODIMP GetSuperscript(long *pValue);
	STDMETHODIMP SetSuperscript(long Value);
	STDMETHODIMP GetUnderline(long *pValue);
	STDMETHODIMP SetUnderline(long Value);
	STDMETHODIMP GetWeight(long *pValue);
	STDMETHODIMP SetWeight(long Value);

//@access Private ITextFont helper methods
private:
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, DWORD dwMask, long Type, long Value);
	HRESULT	EffectGetter (long *ptomBool, DWORD dwMask);
	HRESULT	EffectSetter (long Value, DWORD dwMask, DWORD dwEffect);
	HRESULT	FormatSetter (DWORD dwMask);
	HRESULT	UpdateFormat ();
};


class CTxtPara : public ITextPara, CTxtFormat
{
	friend	CTxtRange;

	CParaFormat	_PF;
	DWORD		_dwMask;			// PARAFORMAT2 mask
	union
	{
	  DWORD _dwFlags;				// All together now
	  struct
	  {
		DWORD _fApplyLater : 1;		// Delay call to _prg->ParaFormatSetter()
		DWORD _fCacheParms : 1;		// Update _PF now but not on GetXs
	  };
	};
	LONG		_rgxTabs[MAX_TAB_STOPS];// Place to store tabs till committed

public:
	CTxtPara(CTxtRange *prg);
	~CTxtPara();

	// IUnknown methods
	STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDispatch methods
	STDMETHODIMP GetTypeInfoCount(UINT * pctinfo);
	STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** pptinfo);
	STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR ** rgszNames, UINT cNames,
							 LCID lcid, DISPID * rgdispid) ;
	STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
					  DISPPARAMS * pdispparams, VARIANT * pvarResult,
					  EXCEPINFO * pexcepinfo, UINT * puArgErr) ;

	// ITextPara methods
	STDMETHODIMP GetDuplicate(ITextPara **ppPara);
	STDMETHODIMP SetDuplicate(ITextPara *pPara);
	STDMETHODIMP CanChange(long *pB);
	STDMETHODIMP IsEqual(ITextPara *pPara, long *pB);
	STDMETHODIMP Reset(long Value);
	STDMETHODIMP GetStyle(long *pValue);
	STDMETHODIMP SetStyle(long Value);

	STDMETHODIMP GetAlignment(long *pValue);
	STDMETHODIMP SetAlignment(long Value);
	STDMETHODIMP GetHyphenation(long *pValue);
	STDMETHODIMP SetHyphenation(long Value);
	STDMETHODIMP GetFirstLineIndent(float *pValue);
	STDMETHODIMP GetKeepTogether(long *pValue);
	STDMETHODIMP SetKeepTogether(long Value);
	STDMETHODIMP GetKeepWithNext(long *pValue);
	STDMETHODIMP SetKeepWithNext(long Value);
	STDMETHODIMP GetLeftIndent(float *pValue);
	STDMETHODIMP GetLineSpacing(float *pValue);
	STDMETHODIMP GetLineSpacingRule(long *pValue);
    STDMETHODIMP GetListAlignment(long * pValue);
    STDMETHODIMP SetListAlignment(long Value);
    STDMETHODIMP GetListLevelIndex(long * pValue);
    STDMETHODIMP SetListLevelIndex(long Value);
    STDMETHODIMP GetListStart(long * pValue);
    STDMETHODIMP SetListStart(long Value);
    STDMETHODIMP GetListTab(float * pValue);
    STDMETHODIMP SetListTab(float Value);
	STDMETHODIMP GetListType(long *pValue);
	STDMETHODIMP SetListType(long Value);
	STDMETHODIMP GetNoLineNumber(long *pValue);
	STDMETHODIMP SetNoLineNumber(long Value);
	STDMETHODIMP GetPageBreakBefore(long *pValue);
	STDMETHODIMP SetPageBreakBefore(long Value);
	STDMETHODIMP GetRightIndent(float *pValue);
	STDMETHODIMP SetRightIndent(float Value);
	STDMETHODIMP SetIndents(float StartIndent, float LeftIndent, float RightIndent);
	STDMETHODIMP SetLineSpacing(long LineSpacingRule, float LineSpacing);
	STDMETHODIMP GetSpaceAfter(float *pValue);
	STDMETHODIMP SetSpaceAfter(float Value);
	STDMETHODIMP GetSpaceBefore(float *pValue);
	STDMETHODIMP SetSpaceBefore(float Value);
	STDMETHODIMP GetWidowControl(long *pValue);
	STDMETHODIMP SetWidowControl(long Value);

	STDMETHODIMP GetTabCount(long *pValue);
	STDMETHODIMP AddTab(float tpPos, long tbAlign, long tbLeader);
	STDMETHODIMP ClearAllTabs();
	STDMETHODIMP DeleteTab(float tbPos);
	STDMETHODIMP GetTab(long iTab, float *ptbPos, long *ptbAlign, long *ptbLeader);

	HRESULT	FormatSetter (DWORD dwMask);

//@access Private ITextPara helper methods
private:
	HRESULT	GetParameter (long *pParm, DWORD dwMask, long Type, long *pValue);
	HRESULT	SetParameter (long *pParm, DWORD dwMask, long Type, long Value);
	HRESULT	EffectGetter (long * ptomBool, DWORD dwMask);
	HRESULT	EffectSetter (long Value, DWORD dwMask);
	HRESULT	UpdateFormat ();
	void	CheckTabsAddRef();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_txtbrk.h ===
/*
 *		Text Breaker & Bit stream break array class definition
 *		
 *		File:    _txtbrk.h
 * 		Create:  Mar 29, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */


#ifndef _TXTBRK_H
#define _TXTBRK_H

// DEBUG definition
#ifdef BITVIEW
#define	BVDEBUG		_DEBUG
#define Assert		ASSERT
#else
#define BVDEBUG		DEBUG
#endif


// The number of buffer breaks before the sync point
#define	CWORD_TILLSYNC		3	// Thai wordbreak engine is expected to be in sync within 3 words
#define CCLUSTER_TILLSYNC	1	// Indic cluster is normally in sync in within 1

// Abstract Data type
#define ITEM				UINT

// CPU register size
//#define RSIZE				(sizeof(ITEM)*8)
#define RSIZE				32

// Mask most/least significant <n> bits
#define MASK_LOW(u, n)		( ((ITEM)(u)) & (1<<(n))-1 )
#define MASK_HIGH(u, n)		~MASK_LOW(u, RSIZE-n)

// BreakArray Exit convention
#ifdef BVDEBUG
#define PUSH_STATE(x,y,z)	PushState(x,y,z)
#define VALIDATE(x)			Validate(x)
#else
#define PUSH_STATE(x,y,z)
#define VALIDATE(x)			x
#endif

// Who put the state?
#define INSERTER			0
#define REMOVER				1
#define COLLAPSER			2
#define REPLACER			3


#ifdef BVDEBUG
typedef struct {
	LONG	who;
	LONG	ibGap;
	LONG	cbGap;
	LONG	cbBreak;
	LONG	cbSize;
	LONG	cp;
	LONG	cch;
} BVSTATE;
#endif

class CBreakArray : public CArray<ITEM>
{
public:
#ifdef BITVIEW
	friend class CBitView;
#endif

	CBreakArray();
	~CBreakArray() {}

	ITEM*		Elem(LONG iel) const;
	BOOL		IsValid() const { return Count() > 0; }
	void		CheckArray();

	LONG		InsertBreak (LONG cp, LONG cch);
	LONG		RemoveBreak (LONG cp, LONG cch);
	LONG 		ReplaceBreak (LONG cp, LONG cchOld, LONG cchNew);
	void		ClearBreak (LONG cp, LONG cch);
	void		SetBreak (LONG cp, BOOL fOn);
	BOOL		GetBreak (LONG cp);

	LONG		CollapseGap (void);
private:

	// n-Bits shifting methods
	void		ShUp (LONG iel, LONG cel, LONG n);
	void		ShDn (LONG iel, LONG cel, LONG n);

	// Size (in bits)
	LONG		_ibGap;			// offset from start of array to gap
	LONG		_cbGap;			// gap size
	LONG		_cbBreak;		// number of valid break
	LONG		_cbSize;		// bit array size (excluded the sentinel element)
#ifdef BITVIEW
	LONG		_cCollapse;		// how many time collapse?
#endif

public:
	LONG		GetCchBreak() { return _cbBreak; }
#ifdef BVDEBUG
	LONG		GetCbSize() { return _cbSize; }
	LONG		Validate(LONG cchRet);		
	void		PushState(LONG cp, LONG cch, LONG who);
#endif
#ifdef BITVIEW
	LONG		SetCollapseCount();
#endif

protected:
#ifdef BVDEBUG
	BVSTATE		_s;
#endif
	LONG		AddBreak(LONG cp, LONG cch);
};


#ifndef BITVIEW


///////	Complex script text breaker class
// 
//		The engine to handle cluster and (dictionary-based) word breaking method
//		used by most SouthEast Asian languages such as Thai, Lao, Burmese etc.
//
//		Create: Mar 12, 1998
//

enum BREAK_UNIT
{
	BRK_WORD		= 1,
	BRK_CLUSTER 	= 2,
	BRK_BOTH		= 3
};

class CTxtBreaker : public ITxNotify
{
public:
	CTxtBreaker(CTxtEdit *ped);
	~CTxtBreaker();

	// Breaker allocation
	BOOL				AddBreaker(UINT brkUnit);

	// Breaker refreshing
	void				Refresh();

	// Query methods
	BOOL				CanBreakCp (BREAK_UNIT brk, LONG cp);

	// ITxNotify methods

	virtual void    	OnPreReplaceRange (LONG cp, LONG cchDel, LONG cchNew,
										LONG cpFormatMin, LONG cpFormatMax);
	virtual void    	OnPostReplaceRange (LONG cp, LONG cchDel, LONG cchNew,
										LONG cpFormatMin, LONG cpFormatMax);
	virtual void		Zombie() {};

private:
	CTxtEdit*			_ped;
	CBreakArray*		_pbrkWord;		// word-break array (per codepoint property)
	CBreakArray*		_pbrkChar;		// cluster-break array (per codepoint property)
};

#endif	// !BITVIEW

#endif	// _TXTBRK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\afxres.h ===
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_urlsup.h ===
/*
 *	@doc INTERNAL
 *
 *	@module	_URLSUP.H	URL detection support |
 *
 *	Author:	alexgo (4/1/96)
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _URLSUP_H_
#define _URLSUP_H_

#include "_dfreeze.h"
#include "_notmgr.h"
#include "_range.h"

class CTxtEdit;
class IUndoBuilder;

// Maximum URL length. It's a good thing to have a protection like
// this to make sure we don't select the whole document; and we really
// need this for space-containing URLs
#define URL_MAX_SIZE			512
#define URL_MAX_SCOPE			512


// for MoveByDelimiter
#define	URL_EATWHITESPACE		32
#define URL_STOPATWHITESPACE	1
#define	URL_EATNONWHITESPACE	0
#define URL_STOPATNONWHITESPACE	2
#define	URL_EATPUNCT			0
#define URL_STOPATPUNCT			4
#define	URL_EATNONPUNCT			0
#define URL_STOPATNONPUNCT		8
#define URL_STOPATCHAR			16

// need this one to initialize a scan with something invalid
#define URL_INVALID_DELIMITER	TEXT(' ')

#define LEFTANGLEBRACKET	TEXT('<')
#define RIGHTANGLEBRACKET	TEXT('>')

/*
 *	CDetectURL
 *
 *	@class	This class will	watched edit changes and automatically
 *			change detected URL's into links (see CFE_LINK && EN_LINK)
 */
class CDetectURL : public ITxNotify
{
//@access	Public Methods
public:
	// constructor/destructor

	CDetectURL(CTxtEdit *ped);				//@cmember constructor
	~CDetectURL();							//@cmember destructor

	// ITxNotify methods
											//@cmember called before a change
	virtual void    OnPreReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                       LONG cpFormatMin, LONG cpFormatMax);
											//@cmember called after a change
	virtual void    OnPostReplaceRange( LONG cp, LONG cchDel, LONG cchNew,
                       LONG cpFormatMin, LONG cpFormatMax);
	virtual void	Zombie();				//@cmember turn into a zombie

	// useful methods

	void	ScanAndUpdate(IUndoBuilder *publdr);//@cmember scan the changed 
											// area and update the link status

//@access	Private Methods and Data
private:

	// worker routines for ScanAndUpdate
	BOOL GetScanRegion(LONG& rcpStart, LONG& rcpEnd);//@cmember get the region
											// to check and clear the accumltr

	void ExpandToURL(CTxtRange& rg, LONG &cchAdvance);		
											//@cmember expand the range to
											// the next URL candidate
	BOOL IsURL(CTxtRange& rg);				//@cmember returns TRUE if the text
											// is a URL.
	void SetURLEffects(CTxtRange& rg, IUndoBuilder *publdr);	//@cmember Set
											// the desired URL effects

											//@cmember removes URL effects if
											// appropriate
	void CheckAndCleanBogusURL(CTxtRange& rg, BOOL &fDidClean, IUndoBuilder *publdr);

											//@cmember scan along for white
											// space / not whitespace,
											// punctuation / non punctuation
											// and remember what stopped the scan
	LONG MoveByDelimiters(const CTxtPtr& tp, LONG iDir, DWORD grfDelimiters, 
							WCHAR *pchStopChar);

	LONG GetAngleBracket(CTxtPtr &tp, LONG cch = 0);
	WCHAR BraceMatch(WCHAR chEnclosing);
			
	CTxtEdit *				_ped;			//@cmember the edit context
	CAccumDisplayChanges 	_adc;			//@cmember change accumulator

	// FUTURE (alexgo): we may want to add more options to detection,
	// such as the charformat to use on detection, etc.
};

#endif // _URLSUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_util.h ===
/*
 *	_UTIL.H
 *
 *	Purpose:
 *		declarations for various useful utility functions
 *
 *	Author:
 *		alexgo (4/25/95)
 */

#ifndef __UTIL_H__
#define __UTIL_H__

HGLOBAL DuplicateHGlobal( HGLOBAL hglobal );
INT CountMatchingBits(const DWORD *a, const DWORD *b, INT total);
HRESULT ObjectReadSiteFlags(REOBJECT * preobj);


//Default values for drag scrolling
//(that aren't already defined by windows).
#define DEFSCROLLMAXVEL 100	//Cursor velocity above which we will not
							//drag scroll (units=.01 in/sec).
#define DEFSCROLLVAMOUNT 50	//Vert. scroll amount per interval (units=.01 in)
#define DEFSCROLLHAMOUNT 50 //Horz. scroll amount per interval (units=.01 in)

//Stuff from OLESTD samples

//Ole clipboard format defines.
#define CF_EMBEDSOURCE      "Embed Source"
#define CF_EMBEDDEDOBJECT   "Embedded Object"
#define CF_LINKSOURCE       "Link Source"
#define CF_OBJECTDESCRIPTOR "Object Descriptor"
#define CF_FILENAME         "FileName"
#define CF_OWNERLINK        "OwnerLink"

HRESULT OleStdSwitchDisplayAspect(
			LPOLEOBJECT			lpOleObj,
			LPDWORD				lpdwCurAspect,
			DWORD				dwNewAspect,
			HGLOBAL				hMetaPict,
			BOOL				fDeleteOldAspect,
			BOOL				fSetupViewAdvise,
			LPADVISESINK		lpAdviseSink,
			BOOL FAR *			lpfMustUpdate);
LPUNKNOWN OleStdQueryInterface(
			LPUNKNOWN			lpUnk,
			REFIID				riid);

void OleUIDrawShading(LPRECT lpRect, HDC hdc);

VOID OleSaveSiteFlags(LPSTORAGE pstg, DWORD dwFlags, DWORD dwUser, DWORD dvAspect);

INT	AppendString( BYTE **, BYTE *, int *, int * );

/****************************************************************************/
/*		     Stabilization classes				    						*/
/*        These are used to stabilize objects during re-entrant calls       */
/****************************************************************************/

//+-------------------------------------------------------------------------
//
//  Class: 	CSafeRefCount
//
//  Purpose: 	A concrete class for objects like the default handler to
//				inherit from.  CSafeRefCount will keep track of reference
//				counts, nesting counts, and zombie states, allowing objects
//				to easily manage the liveness of their memory images.
//
//  Interface:	
//
//  History:    dd-mmm-yy Author    Comment
//   			01-Aug-94 alexgo    author
//
//--------------------------------------------------------------------------

class CSafeRefCount
{
public:
	ULONG	SafeAddRef();
	ULONG	SafeRelease();
	ULONG	IncrementNestCount();
	ULONG	DecrementNestCount();
	BOOL	IsZombie();
   
			CSafeRefCount();
	virtual ~CSafeRefCount();

protected:
    VOID    Zombie();

private:

	ULONG	m_cRefs;
	ULONG	m_cNest;

	ULONG	m_fInDelete		:1;
	ULONG   m_fForceZombie	:1;
};

//+-------------------------------------------------------------------------
//
//  Class:	CStabilize
//
//  Purpose: 	An instance of this class should be allocated on the
//				stack of every object method that makes an outgoing call.
//				The contstructor takes a pointer to the object's base
//				CSafeRefCount class.
//
//  Interface:
//
//  History:    dd-mmm-yy Author    Comment
// 				01-Aug-94 alexgo    author
//
//  Notes:	The constructor will increment the nest count of the
//			object while the destructor will decrement it.
//
//--------------------------------------------------------------------------

class CStabilize
{
public:
	inline CStabilize( CSafeRefCount *pObjSafeRefCount );
	inline ~CStabilize();

private:
	CSafeRefCount *	m_pObjSafeRefCount;
};

inline CStabilize::CStabilize( CSafeRefCount *pObjSafeRefCount )
{
	pObjSafeRefCount->IncrementNestCount();
	m_pObjSafeRefCount = pObjSafeRefCount;
}

inline CStabilize::~CStabilize()
{
	m_pObjSafeRefCount->DecrementNestCount();
}

/*
 *	SafeReleaseAndNULL(IUnknown **ppUnk)
 *
 *	Purpose:
 *      Helper for getting stable pointers during destruction or other times
 *
 *	Notes: 
 *      Not thread safe, must provide higher level synchronization.
 */

inline void SafeReleaseAndNULL(IUnknown **ppUnk)
{
    if (*ppUnk != NULL)
    {
    IUnknown *pUnkSave = *ppUnk;
    *ppUnk = NULL;
    pUnkSave->Release();
    }
}

BOOL FIsIconMetafilePict(HGLOBAL hmfp);
HANDLE OleStdGetMetafilePictFromOleObject(
        LPOLEOBJECT         lpOleObj,
        DWORD               dwDrawAspect,
        LPSIZEL             lpSizelHim,
        DVTARGETDEVICE FAR* ptd);
HGLOBAL OleGetObjectDescriptorDataFromOleObject(
        LPOLEOBJECT pObj,
        DWORD       dwAspect,
        POINTL      ptl,
        LPSIZEL     pszl);

// Default size for stack buffer
#define MAX_STACK_BUF 256

/*
 *	CTempBuf
 *	
 * 	@class	A simple temporary buffer allocator class that will allocate
 *			buffers on the stack up to MAX_STACK_BUF and then use the 
 *			heap thereafter. 
 */
class CTempBuf
{
//@access Public Data
public:
							//@cmember Constructor
							CTempBuf();

							//@cmember Destructor
							~CTempBuf();

							//@cmember Get buffer of size cb
	void *					GetBuf(LONG cb);

//@access Private Data
private:

							//@cmember Sets up initial state of object
	void					Init();

							//@cmember Frees any buffers allocated from heap
	void					FreeBuf();

							//@cmember Buffer on stack to use
	char					_chBuf[MAX_STACK_BUF];

							//@cmember Pointer to buffer to use
	void *					_pv;

							//@cmember Size of currently allocated buffer
	LONG					_cb;
};

/*
 *	CTempBuf::CTempBuf
 *
 *	@mfunc	Initialize object
 *
 */
inline CTempBuf::CTempBuf()
{
	Init();
}

/*
 *	CTempBuf::~CTempBuf
 *
 *	@mfunc	Free any resources attached to this object
 *
 */
inline CTempBuf::~CTempBuf()
{
	FreeBuf();
}

/*
 *	CTempCharBuf
 *	
 * 	@class	A wrapper for the temporary buffer allocater that returns a buffer of
 *			char's.
 *
 *	@base	private | CTempBuf
 */
class CTempWcharBuf : private CTempBuf
{
//@access Public Data
public:

							//@cmember Get buffer of size cch wide characters
	WCHAR *					GetBuf(LONG cch);
};


/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer of the requested size
 *
 *	@rdesc	Pointer to buffer or NULL if one could not be allocated
 *
 */
inline WCHAR *CTempWcharBuf::GetBuf(
	LONG cch)				//@parm size of buffer needed in *characters*
{
	return (WCHAR *) CTempBuf::GetBuf(cch * sizeof(WCHAR));
}


/*
 *	CTempCharBuf
 *	
 * 	@class	A wrapper for the temporary buffer allocater that returns a buffer of
 *			char's.
 *
 *	@base	private | CTempBuf
 */
class CTempCharBuf : private CTempBuf
{
//@access Public Data
public:

							//@cmember Get buffer of size cch characters
	char *					GetBuf(LONG cch);
};


/*
 *	CTempBuf::GetBuf
 *
 *	@mfunc	Get a buffer of the requested size
 *
 *	@rdesc	Pointer to buffer or NULL if one could not be allocated
 *
 */
inline char *CTempCharBuf::GetBuf(LONG cch)
{
	return (char *) CTempBuf::GetBuf(cch * sizeof(TCHAR));
}


// Author revision color table
extern const COLORREF rgcrRevisions[]; 

// Only fixed number of revision color so don't let the table overflow.
#define REVMASK	7



#endif // !__UTIL_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_text.h ===
/*
 *	@doc 	INTERNAL
 *
 *	@module _TEXT.H	-- Declaration for a CTxtRun pointer |
 *	
 *	CTxtRun pointers point at the plain text runs (CTxtArray) of the
 *	backing store and derive from CRunPtrBase via the CRunPtr template.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _TEXT_H
#define _TEXT_H

#include "_runptr.h"
#include "_doc.h"
#include "textserv.h"
#include "_m_undo.h"

class CRchTxtPtr;
class CTxtEdit;
class CTxtIStream;

/*
 *	CTxtPtr
 *
 *	@class
 *		provides access to the array of characters in the backing store
 *		(i.e. <c CTxtArray>)
 *
 *	@base 	public | CRunPtr<lt>CTxtArray<gt>
 *
 *	@devnote
 *		The state transitions for this object are the same as those for
 *		<c CRunPtrBase>.  <md CTxtPtr::_cp> simply caches the current
 *		cp (even though it can be derived from _iRun and _ich).  _cp is
 *		used frequently enough (and computing may be expensive) that
 *		caching the value is worthwhile.
 *
 *		CTxtPtr's *may* be put on the stack, but do so with extreme
 *		caution.  These objects do *not* float; if a change is made to
 *		the backing store while a CTxtPtr is active, it will be out
 *		of sync and may lead to a crash.  If such a situation may
 *		exist, use a <c CTxtRange> instead (as these float and keep
 *		their internal text && format run pointers up-to-date).
 *
 *		Otherwise, a CTxtPtr is a useful, very lightweight plain
 *		text scanner.
 */

// FindEOP() result flags.  Low byte used for cchEOP
#define FEOP_CELL	256
#define FEOP_EOP	512

// FindWhiteSpace input flags
#define FWS_SKIP		1
#define FWS_BOUNDTOPARA	2
#define FWS_ADVANCECP	256

class CTxtPtr : public CRunPtr<CTxtBlk>
{
	// Only CRchTxtPtr is allowed to call private methods like replace range.
	friend class CRchTxtPtr;

//@access Public Methods
public:
#ifdef DEBUG
	BOOL Invariant( void ) const;		//@cmember	Invariant checking
	void MoveGapToEndOfBlock () const;
#endif	// DEBUG

	CTxtPtr(CTxtEdit *ped, LONG cp);	//@cmember	Constructor
	CTxtPtr(const CTxtPtr &tp);			//@cmember	Copy Constructor

	LONG	GetText(LONG cch, TCHAR *pch);	//@cmember 	Fetch <p cch> chars

									//@cmember Fetch <p cch> chars with usp xlat	
	LONG	GetTextForUsp(LONG cch, TCHAR *pch, BOOL fNeutralOverride);

									//@cmember Fetch <p cch> chars with xlat
	LONG	GetPlainText(LONG cch, TCHAR *pchBuff,
					LONG cpMost, BOOL fTextize, BOOL fAdjustCRLF = TRUE);
	TCHAR	NextCharCount(LONG& cch);	//@cmember Advance, GetChar, decrement
	TCHAR	NextChar();				//@cmember Advance to & return next char
	TCHAR	PrevChar();				//@cmember Backup to & return previous char
	TCHAR	GetChar();				//@cmember Fetch char at current cp
	TCHAR	GetPrevChar();			//@cmember Fetch char at previous cp
	LONG	GetTextLength() const;	//@cmember Get total cch for this document
	const TCHAR* GetPch(LONG& cchValid) const;//@cmember	Get ptr to block of chars

							//@cmember	Get ptr to a reverse block of chars
	const TCHAR* GetPchReverse(LONG& cchValidReverse, LONG* pcchValid = NULL);

	// The text array has its own versions of these methods (overuling
	// those in runptr base so that <md CTxtPtr::_cp> can be correctly
	// maintained.

	LONG	BindToCp(LONG cp);	//@cmember	Rebinds text pointer to cp
	LONG 	SetCp(LONG cp);		//@cmember	Sets the cp for the run ptr
	LONG	GetCp() const 		//@cmember	Gets the current cp
	{
		// NB! Don't do invariant checking here so floating
		// range mechanism can work OK
		return _cp;
	};
	void	Zombie();			//@cmember	Turn this tp into a zombie

	LONG	AdvanceCp(LONG cch);//@cmember	Advance cp by cch chars
	
	// Advance/backup/adjust safe over CRLF and UTF-16 word pairs
	LONG	AdjustCpCRLF();		//@cmember	Backup to start of multichar
	LONG	AdvanceCpCRLF(BOOL fMulticharAdvance = TRUE);	//@cmember	Advance over multichar
							 	//@cmember	Backup over multichar
	LONG	BackupCpCRLF(BOOL fMulticharBackup = TRUE);
	BOOL	IsAfterEOP();		//@cmember	Does current cp follow an EOP?
	BOOL	IsAtEOP();			//@cmember	Is current cp at an EOP marker?
	BOOL	IsAtBOSentence();	//@cmember	At beginning of a sentence?
	BOOL	IsAtBOWord();		//@cmember	At beginning of word?
	LONG	MoveWhile(LONG cchRun, WCHAR chFirst, WCHAR chLast, BOOL fInRange);
	
	// Search
								//@cmember	Find indicated text
	LONG	FindText(LONG cpMost, DWORD dwFlags, TCHAR const *pch, LONG cch);
								//@cmember 	Find next EOP
	LONG	FindEOP(LONG cchMax, LONG *pResults = NULL);
								//@cmember	Find next exact	match to <p pch>
	LONG	FindExact(LONG cchMax, TCHAR *pch);
	LONG	FindBOSentence(LONG cch);	//@cmember	Find beginning of sentence
	LONG	FindOrSkipWhiteSpaces(LONG cchMax, DWORD dwFlags = 0, DWORD* pdwResult = NULL);
	LONG	FindWhiteSpaceBound(LONG cchMin, LONG& cpStart, LONG& cpEnd, DWORD dwFlags = 0);

	// Word break support
	LONG	FindWordBreak(INT action, LONG cpMost = -1);//@cmember	Find next word break
	LONG	TranslateRange(LONG cch, UINT CodePage,
						   BOOL fSymbolCharSet, IUndoBuilder *publdr);

//@access	Private methods and data
private:
							//@cmember	Replace <p cchOld> characters with
							// <p cchNew> characters from <p pch>
	LONG	ReplaceRange(LONG cchOld, LONG cchNew, TCHAR const *pch,
									IUndoBuilder *publdr, IAntiEvent *paeCF,
									IAntiEvent *paePF);

							//@cmember	undo helper
	void 	HandleReplaceRangeUndo(LONG cchOld, LONG cchNew,
						IUndoBuilder *publdr, IAntiEvent *paeCF,
						IAntiEvent *paePF);

									//@cmember	Insert a range of text helper
									// for ReplaceRange					
	LONG 	InsertRange(LONG cch, TCHAR const *pch);
	void 	DeleteRange(LONG cch);	//@cmember  Delete range of text helper
									// for ReplaceRange
		// support class for FindText
	class CTxtFinder
	{
	public:
		BOOL FindText(const CTxtPtr &tp, LONG cpMost, DWORD dwFlags,
					  const TCHAR *pchToFind, LONG cchToFind,
					  LONG &cpFirst, LONG &cpLast);
		//@cmember Same functionality as CTxtPtr::FindText wrapper
		
	private:
		inline BOOL CharComp(TCHAR ch1, TCHAR ch2) const;
		inline BOOL CharCompIgnoreCase(TCHAR ch1, TCHAR ch2) const;
		LONG FindChar(TCHAR ch, CTxtIStream &tistr);	
		//@cmember Advances cp to char matching ch from CTxtIStream
		LONG MatchString(const TCHAR *pchToFind, LONG cchToFind, CTxtIStream &tistr);
		//@cmember Advances cp if chars in pchToFind match next chars from CTxtIStream
		LONG MatchStringBiDi(const TCHAR *pchToFind, LONG cchToFind, CTxtIStream &tistr);
		//@cmember Like MatchString, but with checks for special Arabic/Hebrew chars
		
		LONG _cchToSearch;		//@cmember # of chars to search for current FindText call
		BOOL _fSearchForward;
		BOOL _fIgnoreCase;
		BOOL _fMatchAlefhamza;	//@cmember Flags derived from dwFlags from FindText for
		BOOL _fMatchKashida;	//	Arabic/Hebrew searches
		BOOL _fMatchDiac;
		int _iDirection;		//@cmember +/-1 to step through pchToFind
	};

	LONG		_cp;		//@cmember	Character position in text stream
#ifdef DEBUG
	const WCHAR *_pchCp;	// Points to string at cp for ease in debugging
#endif

public:
	CTxtEdit *	_ped;		//@cmember	Ptr to text edit class needed for
							//  things like word break proc and used a lot
							//  by derived classes
};

/*
 *	CTxtIStream
 *
 *	@class
 *		Refinement of the CTxtPtr class which implements an istream-like interface.
 *		Given a CTxtPtr and a direction, a CTxtFinder object returns a char
 *		for every call to GetChar.  No putzing around with the buffer gap is
 *		necessary, and expensive calls to AdvanceCp and GetPch are kept to an
 *		absolute minimum.
 *		
 *	@base 	private | CTxtPtr
 *
 *	@devnote
 *		At present, this class is used in the implementation of the CTxtFinder
 *		class.  Finds require fast scanning of the sequence of characters leading
 *		in either direction from the cp.  Calls to AdvanceCp and GetPch slow down
 *		such scanning significantly, so this class implements a unidirectional
 *		istream-like scanner which avoids unnecessary calls to these expensive
 *		CTxtPtr methods.
 */
class CTxtIStream : private CTxtPtr
{
public:
	enum { DIR_FWD, DIR_REV };
	typedef TCHAR (CTxtIStream::*PFNGETCHAR)();

							//@cmember Creates istr to read in iDir
	CTxtIStream(const CTxtPtr &tp, int iDir);

	inline TCHAR GetChar() 	//@cmember Returns next char in stream dir
		{ return (this->*_pfnGetChar)(); }

private:
	TCHAR GetNextChar();	//@cmember Returns next char in fwd dir	
	TCHAR GetPrevChar();	//@cmember Returns next char in rev dir

 	void FillPchFwd();		//@cmember Refreshes _pch and _cch with chars in fwd dir
 	void FillPchRev();		//@cmember Refreshes _pch and _cch with chars in rev dir

	PFNGETCHAR _pfnGetChar;	//@cmember Func ptr to routine which get next char in iDir
	LONG _cch;				//@cmember Count of valid chars in _pch in iDir
	const TCHAR *_pch;		//@cmember Next _cch chars in iDir
};

// =======================   Misc. routines  ====================================================

void	TxCopyText(TCHAR const *pchSrc, TCHAR *pchDst, LONG cch);
//LONG	TxFindEOP(const TCHAR *pchBuff, LONG cch);
INT		CALLBACK TxWordBreakProc(TCHAR const *pch, INT ich, INT cb, INT action);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re32wrap\wrapper.h ===
#ifndef _WRAPPER_H_
#define _WRAPPER_H_
#include <windows.h>

#define RICHEDIT_CLASS10A   "RICHEDIT"          // Richedit 1.0

extern "C"
{
LRESULT CALLBACK RichEdit32WndProc(
    HWND hWnd, 
    UINT uMsg, 
    WPARAM wParam, 
    LPARAM lParam);
}


WNDPROC lpfnRichEditANSIWndProc;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_uspi.h ===
/*
 *		Uniscribe interface (& related classes) class definition
 *		
 *		File:    _uspi.h
 * 		Create:  Jan 10, 1998
 *		Author:  Worachai Chaoweeraprasit (wchao)
 *
 *		Copyright (c) 1998, Microsoft Corporation. All rights reserved.
 */

#ifndef _USPI_H
#define _USPI_H

#include "_ls.h"
#include "usp10.h"		// Uniscribe SDK protocol


// classes
//
class CFormatRunPtr;
class CMeasurer;
class CTxtEdit;
class CUniscribe;
class CBiDiFSM;
class CTxtBreaker;


#define ALIGN(x)            		(int)(((x)+3) & ~3)		// dword aligning
#define GLYPH_COUNT(c)          	((((c)*3)/2)+16)
#define MAX_CLIENT_BUF				512						// size (in byte) of internal buffer

// USP client parameters block
//
#define cli_string                  0x00000001
#define cli_psi                     0x00000002
#define cli_psla                    0x00000004
#define cli_pwgi					0x00000008
#define cli_psva					0x00000010
#define cli_pcluster				0x00000020
#define cli_pidx					0x00000040
#define cli_pgoffset				0x00000080

#define cli_Itemize                 (cli_string | cli_psi)
#define cli_Break                   (cli_psla)
#define cli_Shape					(cli_pwgi | cli_psva | cli_pcluster)
#define cli_Place					(cli_pidx | cli_pgoffset)
#define cli_ShapePlace				(cli_Shape | cli_Place)



#ifndef LOCALE_SNATIVEDIGITS
#define LOCALE_SNATIVEDIGITS		0x00000013
#endif



/////   LANG
//
//      The following defines are temporary - they will be removed once they
//      have been added to the standard NLS header files.


#ifndef LANG_BURMESE
#define LANG_BURMESE     			0x55       // Myanmar
#endif
#ifndef LANG_KHMER
#define LANG_KHMER       			0x53       // Cambodia
#endif
#ifndef LANG_LAO
#define LANG_LAO         			0x54       // Lao
#endif
#ifndef LANG_MONGOLIAN
#define LANG_MONGOLIAN   			0x50       // Mongolia
#endif
#ifndef LANG_TIBETAN
#define LANG_TIBETAN     			0x51       // Tibet
#endif
#ifndef LANG_URDU
#define LANG_URDU        			0x20       // India / Pakistan
#endif



//
// Memory block will contain USPCLIENT -the table of ptrs, as a memory block's header
// followed by subtables then requested data blocks. All things tie together as a
// contiguous data area so client can free the whole thing in one shot.
//


// SI subtable
//
typedef struct tagUSP_CLIENT_SI
{
	//
	// ScriptItemize's
	//
	WCHAR*          pwchString;
	int             cchString;
	SCRIPT_ITEM*    psi;
} USP_CLIENT_SI, *PUSP_CLIENT_SI;

// SB subtable
//
typedef struct tagUSP_CLIENT_SB
{
	//
	// ScriptBreak's
	//
	SCRIPT_LOGATTR* psla;
} USP_CLIENT_SB, *PUSP_CLIENT_SB;

// SS & SP subtable
typedef struct tagUSP_CLIENT_SSP
{
	//
	// ScriptShape's
	//
	WORD*			pwgi;
	WORD*			pcluster;
	SCRIPT_VISATTR*	psva;

	//
	// ScriptPlace's
	//
	int*			pidx;
	GOFFSET*		pgoffset;
} USP_CLIENT_SSP, *PUSP_CLIENT_SSP;


// header (root) table
//
typedef struct tagUSP_CLIENT
{
	PUSP_CLIENT_SI  si;
	PUSP_CLIENT_SB  sb;
	PUSP_CLIENT_SSP	ssp;
} USP_CLIENT, *PUSP_CLIENT;



// buffer request structure
//
typedef struct tagBUF_REQ
{
	int             size;	// size of requested element
	int             c;		// count of requested element
	PVOID*          ppv;	// ref to ptr of requested buffer
} BUF_REQ;


typedef enum
{
	DIGITS_NOTIMPL = 0,
	DIGITS_CTX,
	DIGITS_NONE,
	DIGITS_NATIONAL
} DIGITSHAPE;


#define		IsCS(x)				(BOOL)((x)==U_COMMA || (x)==U_PERIOD || (x)==U_COLON)


// CUniscribe's internal buffer request flag
//
#define 	igb_Glyph			1
#define 	igb_VisAttr			2
#define 	igb_Pidx			4



// LS Callback's static return buffer
#define 	celAdvance			32

class CBufferBase
{
public:
	CBufferBase(int cbElem) { _cbElem = cbElem; }
	void*	GetPtr(int cel);
	void	Release();
protected:
	void*	_p;
	int		_cElem;
	int		_cbElem;
};

template <class ELEM>
class CBuffer : public CBufferBase
{
public:
	CBuffer() : CBufferBase(sizeof(ELEM)) {}
	~CBuffer() { Release(); }
	ELEM*	Get(int cel) { return (ELEM*)GetPtr(cel); }
};


///////	Uniscribe interface object class
// 		
//

BOOL	IsSupportedOS();

class CUniscribe
{
public:
	CUniscribe();
	~CUniscribe();

	WORD	ApplyDigitSubstitution (BYTE bDigitSubstMode);

	// public helper functions
	//

	const   SCRIPT_PROPERTIES*  GeteProp (WORD eScript);
	const   CBiDiFSM*           GetFSM ();


	BOOL    CreateClientStruc (BYTE* pbBufIn, LONG cbBufIn, PUSP_CLIENT* ppc, LONG cchString, DWORD dwMask);
	void	SubstituteDigitShaper (PLSRUN plsrun, CMeasurer* pme);


	inline BOOL CacheAllocGlyphBuffers(int cch, int& cGlyphs, WORD*& pwgi, SCRIPT_VISATTR*& psva)
	{
		cGlyphs = GLYPH_COUNT(cch);
		return (pwgi = GetGlyphBuffer(cGlyphs)) && (psva = GetVABuffer(cGlyphs));
	}


	inline BOOL IsValid()
	{
		return TRUE;
	}


	BOOL	GetComplexCharSet(const SCRIPT_PROPERTIES* psp, BYTE bCharSetDefault, BYTE& bCharSetOut);
	BYTE	GetRtlCharSet(CTxtEdit* ped);


	// higher level services
	//
	int     ItemizeString (USP_CLIENT* pc, WORD uInitLevel, int* pcItems, WCHAR* pwchString, int cch,
						   BOOL fUnicodeBidi, WORD wLangId = LANG_NEUTRAL);
	int     ShapeString (PLSRUN plsrun, SCRIPT_ANALYSIS* psa, CMeasurer* pme, const WCHAR* pwch, int cch,
						 WORD*& pwgi, WORD* pwlc, SCRIPT_VISATTR*& psva);
	int     PlaceString (PLSRUN plsrun, SCRIPT_ANALYSIS* psa, CMeasurer* pme, const WORD* pcwgi, int cgi,
						 const SCRIPT_VISATTR* psva, int* pgdx, GOFFSET* pgduv, ABC* pABC);
	int		PlaceMetafileString (PLSRUN plsrun, CMeasurer* pme, const WCHAR* pwch, int cch, PINT* ppiDx);

private:


	// private helper functions
	//
	HDC     PrepareShapeDC (CMeasurer* pme, HRESULT hrReq, HFONT& hOrgFont);
	BYTE	GetCDMCharSet(BYTE bCharSetDefault);
	DWORD	GetNationalDigitLanguage(LCID lcid);

	// get callback static buffers
	//
	SCRIPT_VISATTR*	GetVABuffer(int cel) { return _rgva.Get(cel); }
	WORD*			GetGlyphBuffer(int cel) { return _rgglyph.Get(cel); }
	int*			GetWidthBuffer(int cel) { return _rgwidth.Get(cel); }



	// LS callback (static) buffers
	//
	CBuffer<WORD>						_rgglyph;
	CBuffer<int>						_rgwidth;
	CBuffer<SCRIPT_VISATTR>				_rgva;

	// pointer to BidiLevel Finite State Machine
	CBiDiFSM*                           _pFSM;

	// pointer to script properties resource table
	const SCRIPT_PROPERTIES**           _ppProp;

	WORD								_wesNationalDigit;	// National digit script ID
	BYTE								_bCharSetRtl;		// Right to left charset to use
	BYTE								_bCharSetCDM;		// CDM charset to use
};

extern CUniscribe*      g_pusp;
extern int				g_cMaxScript;		// Maximum number of script produced by Uniscribe

// Virtual script ID
#define	SCRIPT_MAX_COUNT	((WORD)g_cMaxScript)
#define	SCRIPT_WHITE		SCRIPT_MAX_COUNT + 1



///////	Bidi Finite State Machine class
// 		
//		(detail: bidifsm2.html)
//
//		Revise: 12-28-98 (wchao)
//

// inputs class:
#define 	NUM_FSM_INPUTS		5
typedef enum
{
	chLTR = 0,
	chRTL,
	digitLTR,
	digitRTL,
	chGround					// Neutralize current level down to initial level
} INPUT_CLASS;

// states:
#define		NUM_FSM_STATES		6
typedef enum
{
	S_A = 0,
	S_B,
	S_C,
	S_X,
	S_Y,
	S_Z
} STATES;


class CBiDiFSMCell
{
public:
	CBiDiLevel	_level;			// BiDi level
	USHORT  	_uNext;			// Offset to the next state relative to FSM start
};


class CBiDiFSM
{
public:
	CBiDiFSM (CUniscribe* pusp) { _pusp = pusp; }
	~CBiDiFSM ();

	BOOL                Init (void);
	INPUT_CLASS         InputClass (const CCharFormat* pcCF, CTxtPtr* ptp, LONG cchRun) const;
	HRESULT             RunFSM (CRchTxtPtr* prtp, LONG cRuns, LONG cRunsStart, BYTE bBaseLevel) const;

	inline void			SetFSMCell (CBiDiFSMCell* pCell, CBiDiLevel* pLevel, USHORT uNext)
	{
		pCell->_level	= *pLevel;
		pCell->_uNext	= uNext;
	}


private:
	short               _nState;		// number of state
	short               _nInput;		// number of input class
	CUniscribe*         _pusp;			// Uniscribe obj associated with
	CBiDiFSMCell*       _pStart;		// start FSM
};

#endif		// _USPI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re30\_w32sys.h ===
/*
 *	_w32sys.h
 *	
 *	Purpose:
 *		Isolate various Win 32 system dependencies.
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#ifndef _W32SYS_H

#define _W32SYS_H

#if defined(PEGASUS)

#if !defined(WINNT)
#include "memory.h"								// for memmove
#endif

struct IMESTYLE;
struct IMECOLORSTY;
struct CIMEShare;

#define NOACCESSIBILITY							// No Accessibility support on Win CE
#define NOMAGELLAN								// No Magellan on Win CE
#define NODROPFILES								// No drop files support on Win CE
#define NOMETAFILES								// No metafiles on Win CE
#define NOPEDDUMP								// No support for ped debug dump on CE
#define NOFONTSUBINFO							// Avoid reading fontsubinfo profile on CE
#define CONVERT2BPP
#define NODUMPFORMATRUNS
#define NOMLKEYBOARD

#define dxCaret		2							// caret width
#define FONTCACHESIZE 8
#define CCSHASHSEARCHSIZE	15
#define DEFAULT_UNDO_SIZE 20
#define NUMPASTECHARSWAITCURSOR 1024

#else //!PEGASUS

#define dxCaret		1							// caret width
#define FONTCACHESIZE 24
#define CCSHASHSEARCHSIZE	31
#define DEFAULT_UNDO_SIZE 100
#define NUMPASTECHARSWAITCURSOR (1024*32)

#define OBSOLETE	// need this to get old IMEShare defines
#include "imeshare.h"

#endif	// defined(PEGASUS)

#ifndef NOLINESERVICES
#define LINESERVICES
#endif

#define	RSHIFT	1
#define	LSHIFT	2
#define	RCTRL	0x10
#define	LCTRL	0x20
#define	RALT	0x40
#define	LALT	0x80

#define SHIFT	(RSHIFT + LSHIFT)
#define ALT		(RALT + LALT)
#define CTRL	(RCTRL + LCTRL)

#define	HOTEURO			0x1000
#define ALT0			0x2000
#define ALTNUMPAD		0x4000
#define LETAFTERSHIFT	0x8000

// special virtual keys copied from Japan MSVC ime.h
#define VK_KANA         0x15
#define VK_KANJI        0x19

// Initialization flags that can be used in system.ini for testing purposes
#define SYSINI_USELS		0x1
#define SYSINI_BIDI			0x2
#define SYSINI_USEAIMM		0x4
#define SYSINI_DEBUGFONT	0x8
#define SYSINI_DEBUGGCF125X	0x10

/*
 *	GetCaretDelta ()
 *	
 *	@func 	Get size of caret to add to current caret position to get the
 *	maximum extent needed to display caret.
 *
 *	@rdesc	Size of caret over 1 pixel
 *
 *	@devnote	This exists solely to abstract this calculation
 *	to handle a variable size caret.
 */
inline int GetCaretDelta()
{
	return dxCaret - 1;
}


// Used in rtfread.cpp to keep track of lossy rtf.
#ifdef PWORD_CONVERTER_V2
#define REPORT_LOSSAGE
#endif


// Defines for some Codepages
#define CP_JAPAN			932
#define CP_KOREAN			949
#define CP_CHINESE_TRAD		950
#define CP_CHINESE_SIM		936
#define CP_HEBREW			1255
#define CP_ARABIC			1256
#define CP_THAI				874
#define CP_VIETNAMESE		1258

// Indic codepages from NT50
#define CP_DEVANAGARI		57002
#define CP_BENGALI			57003
#define CP_TAMIL			57004
#define CP_TELUGU			57005
#define CP_ASSAMESE			57006
#define CP_ORIYA			57007
#define CP_KANNADA			57008
#define CP_MALAYALAM		57009
#define CP_GUJARATI			57010
#define CP_PUNJABI			57011

// Ad hoc codepages to keep rgCpgCharSet unique
#define CP_GEORGIAN			58000
#define CP_ARMENIAN			58001

// Newly introduced Indic language ID
#if(WINVER < 0x500)
#define	LANG_HINDI			0x39
#define	LANG_KONKANI		0x57
#define	LANG_NEPALI			0x61
#define	LANG_BENGALI		0x45
#define	LANG_PUNJABI		0x46
#define	LANG_GUJARATHI		0x47
#define	LANG_ORIYA			0x48
#define	LANG_TAMIL			0x49
#define	LANG_TELUGU			0x4a
#define	LANG_KANNADA		0x4b
#define	LANG_MALAYALAM		0x4c
#define	LANG_ASSAMESE		0x4d
#define	LANG_MARATHI		0x4e
#define	LANG_SANSKRIT		0x4f
#endif


// Index returned by CharSetIndexFromChar()
#define	FE_FLAG			0x10000
#define	MULTIPLE_FLAG	0x80000000			// Sign bit
#define FE_INDEX		FE_FLAG + MULTIPLE_FLAG

#define ANSI_INDEX		0
#define ARABIC_INDEX	7
#define GREEK_INDEX		14
#define HAN_INDEX		FE_INDEX + 1
#define HANGUL_INDEX	FE_FLAG + 11
#define HEBREW_INDEX	6
#define RUSSIAN_INDEX	9
#define SHIFTJIS_INDEX	FE_FLAG + 8
#define VIET_INDEX		17
#define THAI_INDEX		18

#define DEVANAGARI_INDEX	19
#define TAMIL_INDEX			20
#define GEORGIAN_INDEX		21
#define ARMENIAN_INDEX		22
#define INDIC_FIRSTINDEX	DEVANAGARI_INDEX
#define INDIC_LASTINDEX		ARMENIAN_INDEX

#define UNKNOWN_INDEX		MULTIPLE_FLAG + 1

#define	PC437_CHARSET		254
#define DEVANAGARI_CHARSET	127
#define TAMIL_CHARSET		126
#define GEORGIAN_CHARSET	125
#define ARMENIAN_CHARSET	124
#define ADHOC_CHARSET		120

// controls the size of two charset tables.
#define NCHARSETS		 24

#define IsSymbolOrOEM(x)	(x == SYMBOL_CHARSET || x == OEM_CHARSET)

enum CC
{
	CC_ARABIC,
	CC_HEBREW,
	CC_RTL,
	CC_LTR,
	CC_EOP,
	CC_ASCIIDIGIT,
	CC_NEUTRAL
};

#define IsRTL(cc)		(cc <= CC_RTL)

const SHORT sLanguageEnglishUS = 0x0409;
const SHORT sLanguageMask	 = 	0x03ff;
const SHORT sLanguageArabic	 = 	0x0401;
const SHORT sLanguageHebrew	 = 	0x040d;
// FUTURE: currently this const == sLanguageEnglishUS
//			for no reason except that it was this way
//			in RE1.0 BiDi. Consider changing, or sticking
//			the real language in, and changing the logic
//			of handling wLang a bit.
const SHORT sLanguageNonBiDi =	0x0409;


// Logical unit definition
const int LX_PER_INCH = 1440;
const int LY_PER_INCH = 1440;

// HIMETRIC units per inch (used for conversion)
const int HIMETRIC_PER_INCH = 2540;

#ifdef DEBUG

void* __cdecl operator new(size_t nSize, char *szFile, int nLine);
#define NEW_DEBUG new(__FILE__, __LINE__)
#define new NEW_DEBUG

void UpdateMst(void);

struct MST
{
	char *szFile;
	int  cbAlloc;
}; //Memory Statistics;

extern MST vrgmst[];

#endif //DEBUG

#ifdef CopyMemory
#undef CopyMemory
#endif
#ifdef MoveMemory
#undef MoveMemory
#endif
#ifdef FillMemory
#undef FillMemory
#endif
#ifdef ZeroMemory
#undef ZeroMemory
#endif
#ifdef CompareMemory
#undef CompareMemory
#endif

#ifndef	KF_ALTDOWN
#define KF_ALTDOWN    0x2000
#endif

// Use for our version of ExtTextOut
enum CONVERTMODE
{
	CVT_NONE,			// Use Unicode (W) CharWidth/TextOut APIs
	CVT_WCTMB,			// Convert to MBCS using WCTMB and _wCodePage
	CVT_LOWBYTE			// Use low byte of 16-bit chars (for SYMBOL_CHARSET
};						//  and when code page isn't installed)

// Opaque Type
class CTxtSelection;
class CTxtEdit;
class CCharFormat;
class CCcs;

enum UN_FLAGS
{
	UN_NOOBJECTS				= 1,
	UN_CONVERT_WCH_EMBEDDING	= 2
};

#undef GetStringTypeEx
#undef CharLower
#undef CharLowerBuff
#undef CharUpperBuff
#undef CreateIC
#undef CreateFile
#undef CreateFontIndirect
#undef CompareString
#undef DefWindowProc
#undef GetKeyboardLayout
#undef GetProfileSection
#undef GetTextMetrics
#undef GetTextExtentPoint32
#undef GetTextFace
#undef GetWindowLong
#undef GetWindowLongPtr
#undef GetClassLong
#undef LoadBitmap
#undef LoadCursor
#undef LoadLibrary
#undef SendMessage
#undef SetWindowLong
#undef SetWindowLongPtr
#undef PostMessage
#undef lstrcmp
#undef lstrcmpi
#undef PeekMessage
#undef GetModuleFileName
#undef GetLayout
#undef SetLayout

// Bits used in _fFEFontInfo:
#define JPN_FONT_AVAILABLE		0x0001		// True if Jpn font is available
#define KOR_FONT_AVAILABLE		0x0002		// True if Kor font is available
#define BIG5_FONT_AVAILABLE		0x0004		// True if Trad. Chinese font is available
#define GB_FONT_AVAILABLE		0x0008		// True if Simplified Chinese font is available	
#define FEUSER_LCID				0x0010		// True if User LCID is FE LCID
#define FEUSER_CODEPAGE			0x0060		//  indicate which User FE codepage its
#define FEUSER_CP_JPN			0x0000		//	 =00 for JPN
#define FEUSER_CP_KOR			0x0020		//	 =20 for KOR
#define FEUSER_CP_BIG5			0x0040		//	 =40 for BIG5
#define FEUSER_CP_GB			0x0060		//	 =60 for GB
#define FEDATA_NOT_INIT			0xFFFF		// No data yet

class CConvertStrW
{
public:
    operator WCHAR *();

protected:
    CConvertStrW();
    ~CConvertStrW();
    void Free();

    LPWSTR   _pwstr;
    WCHAR    _awch[MAX_PATH * 2];
};

inline CConvertStrW::CConvertStrW()
{
    _pwstr = NULL;
}

inline CConvertStrW::~CConvertStrW()
{
    Free();
}

inline CConvertStrW::operator WCHAR *()
{
    return _pwstr;
}

class CStrInW : public CConvertStrW
{
public:
    CStrInW(LPCSTR pstr);
    CStrInW(LPCSTR pstr, UINT uiCodePage);
    CStrInW(LPCSTR pstr, int cch, UINT uiCodePage);
    int strlen();

protected:
    CStrInW();
    void Init(LPCSTR pstr, int cch, UINT uiCodePage);

    int _cwchLen;
	UINT _uiCodePage;
};

inline CStrInW::CStrInW()
{
}

inline int CStrInW::strlen()
{
    return _cwchLen;
}


typedef DWORD (WINAPI* PFN_GETLAYOUT)(HDC);
typedef DWORD (WINAPI* PFN_SETLAYOUT)(HDC, DWORD);


class CW32System
{
private :
	static DWORD		_dwPlatformId;				// platform GetVersionEx();
	static LCID			_syslcid;

public :
	static BOOL			_fHaveIMMProcs;
	static CIMEShare	*_pIMEShare;
	static BOOL			_fHaveAIMM;
	static BOOL			_fHaveIMMEShare;
	static UINT			_fRegisteredXBox;			// flag indicating if listbox and combobox were registered
	static DWORD		_dwMajorVersion;			// major version from GetVersionEx()
	static DWORD		_dwMinorVersion;			// minor version from GetVersionEx()
	static INT			_icr3DDarkShadow;			// value to use for COLOR_3DDKSHADOW
	static UINT			_MSIMEMouseMsg;				// private msg for support mouse operation
	static UINT			_MSIMEReconvertMsg;			// private msg for reconversion
	static UINT			_MSIMEReconvertRequestMsg;	// private msg for reconversion request
	static UINT			_MSIMEDocFeedMsg;			// private msg for document feed
	static UINT			_MSIMEQueryPositionMsg;		// private msg for query position
	static UINT			_MSIMEServiceMsg;			// private msg for checking MSIME98 or later

	static UINT			_MSMouseRoller;				// private msg for mouse scrolling

	// Misc flags used for more precise character classification
	static	WORD		_fFEFontInfo;
	static 	BOOL		_fLRMorRLM;


	CW32System();

	~CW32System();

	static DWORD AddRef();
	static DWORD Release();

	// Platform testing
	static bool OnWinNTFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && IsFELCID(_syslcid );
	}
	static bool OnWinNTNonFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && !IsFELCID(_syslcid );
	}
	static bool OnWinNT5()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && 5 == _dwMajorVersion;
	}
	static bool OnWinNT4()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_NT && 4 == _dwMajorVersion;
	}
	static bool OnWin9xFE()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && IsFELCID(_syslcid );
	}
	static bool OnWin9x()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS;
	}
	static bool OnWin95()
	{
		return OnWin9x() && (4 == _dwMajorVersion) && (0 == _dwMinorVersion);
	}
	static bool OnWin95FE()
	{
		return OnWin95() && IsFELCID(_syslcid );
	}
	static bool OnWin9xThai()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && PRIMARYLANGID(_syslcid) == LANG_THAI;
	}
	static bool OnWin9xBiDi()
	{
		return _dwPlatformId == VER_PLATFORM_WIN32_WINDOWS && IsBiDiLcid(_syslcid);
	}
	static bool OnBiDiOS()
	{
		return IsBiDiLcid(_syslcid) != 0;
	}
	struct WM_CHAR_INFO
	{
		bool _fAccumulate;
		bool _fLeadByte;
		bool _fTrailByte;
		bool _fIMEChar;
	};
	static UINT GetACP() {return _ACP;}

	static LRESULT ANSIWndProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam, BOOL fIs10Mode );
	static void AnsiFilter( UINT &msg, WPARAM &wparam, LPARAM lparam, void *pvoid, BOOL fIs10Mode = FALSE );
	static HGLOBAL WINAPI GlobalAlloc( UINT uFlags, DWORD dwBytes );
	static HGLOBAL WINAPI GlobalFree( HGLOBAL hMem );
	static UINT WINAPI GlobalFlags( HGLOBAL hMem );
	static HGLOBAL WINAPI GlobalReAlloc( HGLOBAL hMem, DWORD dwBytes, UINT uFlags );
	static DWORD WINAPI GlobalSize( HGLOBAL hMem );
	static PVOID WINAPI GlobalLock( HGLOBAL hMem );
	static HGLOBAL WINAPI GlobalHandle( LPCVOID pMem );
	static BOOL WINAPI GlobalUnlock( HGLOBAL hMem );
	static void WINAPI REGetCharWidth(
		HDC		hdc,
		TCHAR	iChar,
		SHORT *	pWidth,
		UINT	uiCodePage,
		SHORT	xOverhang,		//@parm Equivalent to GetTextMetrics() tmOverhang.
		INT		iDefWidth);		//@parm Default width to use if font calc's zero
								//width. (Handles Win95 problem).
	static void WINAPI REExtTextOut(
		CONVERTMODE cm,
		UINT uiCodePage,
		HDC hdc,
		int x,
		int y,
		UINT fuOptions,
		CONST RECT *lprc,
		const WCHAR *lpString,
		UINT cch,
		CONST INT *lpDx,
		BOOL  FEFontOnNonFEWin95);
	static CONVERTMODE WINAPI DetermineConvertMode( HDC hdc, BYTE tmCharSet );
	static void WINAPI CalcUnderlineInfo(HDC hdc, CCcs *pccs, TEXTMETRIC *ptm );
	static BOOL WINAPI EnableScrollBar( HWND hWnd, UINT wSBflags, UINT wArrows );
	static BOOL WINAPI ShowScrollBar( HWND hWnd, int wBar, BOOL bShow, LONG nMax );
	static BOOL WINAPI IsEnhancedMetafileDC( HDC hdc );
	static HPALETTE WINAPI ManagePalette(
		HDC hdc,
		CONST LOGPALETTE *plogpal,
		HPALETTE &hpalOld,
		HPALETTE &hpalNew
	);

	static void GetFacePriCharSet(HDC hdc, LOGFONT* plf);

	static int WINAPI GetMapMode(HDC hdc);
	static BOOL WINAPI WinLPtoDP(HDC hdc, LPPOINT lppoints, int nCount);

	static long WINAPI WvsprintfA(LONG cb, LPSTR szBuf, LPCSTR szFmt, va_list arglist);

	static int WINAPI MulDiv(int nNumber, int nNumerator, int nDenominator);

	// Convert Himetric along the X axis to X pixels
	static inline LONG	HimetricXtoDX(LONG xHimetric, LONG xPerInch)
	{
		// This formula is rearranged to get rid of the need for floating point
		// arithmetic. The real way to understand the formula is to use
		// (xHimetric / HIMETRIC_PER_INCH) to get the inches and then multiply
		// the inches by the number of x pixels per inch to get the pixels.
		return (LONG) MulDiv(xHimetric, xPerInch, HIMETRIC_PER_INCH);
	}

	// Convert Himetric along the Y axis to Y pixels
	static inline LONG HimetricYtoDY(LONG yHimetric, LONG yPerInch)
	{
		// This formula is rearranged to get rid of the need for floating point
		// arithmetic. The real way to understand the formula is to use
		// (xHimetric / HIMETRIC_PER_INCH) to get the inches and then multiply
		// the inches by the number of y pixels per inch to get the pixels.
		return (LONG) MulDiv(yHimetric, yPerInch, HIMETRIC_PER_INCH);
	}

	// Convert Pixels on the X axis to Himetric
	static inline LONG DXtoHimetricX(LONG dx, LONG xPerInch)
	{
		// This formula is rearranged to get rid of the need for floating point
		// arithmetic. The real way to understand the formula is to use
		// (dx / x pixels per inch) to get the inches and then multiply
		// the inches by the number of himetric units per inch to get the
		// count of himetric units.
		return (LONG) MulDiv(dx, HIMETRIC_PER_INCH, xPerInch);
	}

	// Convert Pixels on the Y axis to Himetric
	static inline LONG DYtoHimetricY(LONG dy, LONG yPerInch)
	{
		// This formula is rearranged to get rid of the need for floating point
		// arithmetic. The real way to understand the formula is to use
		// (dy / y pixels per inch) to get the inches and then multiply
		// the inches by the number of himetric units per inch to get the
		// count of himetric units.
		return (LONG) MulDiv(dy, HIMETRIC_PER_INCH, yPerInch);
	}

	//
	// Case insensitive ASCII compare
	//
	static BOOL ASCIICompareI( const BYTE *pstr1, const BYTE *pstr2, int iCount )
	{
		int i;	
		for (i = 0; i < iCount && !((pstr1[i] ^ pstr2[i]) & ~0x20); i++)
			;
		return i == iCount;
	}

	//
	// Allocate and convert a MultiByte string to a wide character string
	// Allocated strings must be freed with delete
	//
	static WCHAR *ConvertToWideChar( const char *pstr )
	{
		int istrlen = 0;
		if(pstr)
			for (istrlen; pstr[istrlen]; istrlen++);
		WCHAR *pnew = new WCHAR[istrlen + 1];
		if(pnew && (!pstr || 0 != ::MultiByteToWideChar(
								CP_ACP, 0, pstr, -1, pnew, istrlen + 1)))
		{
			return pnew;
		}
		return NULL;
	}

	//
	// functions for memory and string management
	//
#ifdef DEBUG
	static void  PvSet(void *pv, char *szFile, int line);
	static PVOID PvAllocDebug(ULONG cbBuf, UINT uiMemFlags, char *szFile, int line);
	static PVOID PvReAllocDebug(PVOID pvBuf, DWORD cbBuf, char *szFile, int line);
	static void  FreePvDebug(PVOID pvBuf);
#endif
	static PVOID PvAlloc(ULONG cbBuf, UINT uiMemFlags);
	static PVOID PvReAlloc(PVOID pvBuf, DWORD cbBuf);
	static void	FreePv(PVOID pvBuf);

	static inline void *MoveMemory(void *dst, const void *src, size_t cb)
	{
		Assert(cb >= 0);
		return memmove(dst, src, cb);
	}

	static inline void *CopyMemory(void *dst, const void *src, size_t cb)
	{
		// Will work for overlapping regions
		Assert(cb >= 0);
		return MoveMemory(dst, src, cb);
	}

	static inline void *FillMemory(void *dst, int fill, size_t cb)
	{
		return memset(dst, fill, cb);
	}

	static inline void *ZeroMemory(void *dst, size_t cb)
	{
		Assert(cb >= 0);
		return memset(dst, 0, cb);
	}

	static inline int CompareMemory(const void *s1, const void *s2, size_t cb)
	{
		return memcmp(s1, s2, cb);
	}

	static size_t wcslen(const wchar_t *wcs);
	static wchar_t * wcscpy(wchar_t * dst, const wchar_t * src);
	static int wcscmp(const wchar_t * src, const wchar_t * dst);
	static int wcsicmp(const wchar_t * src, const wchar_t * dst);
	static wchar_t * wcsncpy (wchar_t * dest, const wchar_t * source, size_t count);
	static int wcsnicmp(const wchar_t *first, const wchar_t *last, size_t count);
	static unsigned long strtoul(const char *);


	// ----------------------------------
	// IME Support
	// ----------------------------------
	static BOOL ImmInitialize( void );
	static void ImmTerminate( void );
	static LONG ImmGetCompositionStringA ( HIMC, DWORD, PVOID, DWORD, BOOL );
	static LONG ImmGetCompositionStringW ( HIMC, DWORD, PVOID, DWORD, BOOL  );
	static HIMC ImmGetContext ( HWND );
	static BOOL ImmSetCompositionFontA ( HIMC, LPLOGFONTA, BOOL );
	static BOOL ImmSetCompositionWindow ( HIMC, LPCOMPOSITIONFORM, BOOL );
	static BOOL ImmReleaseContext ( HWND, HIMC );
	static DWORD ImmGetProperty ( HKL, DWORD, BOOL );
	static BOOL ImmGetCandidateWindow ( HIMC, DWORD, LPCANDIDATEFORM, BOOL );
	static BOOL ImmSetCandidateWindow ( HIMC, LPCANDIDATEFORM, BOOL );
	static BOOL ImmNotifyIME ( HIMC, DWORD, DWORD, DWORD, BOOL );
	static HIMC ImmAssociateContext ( HWND, HIMC, BOOL );
	static UINT ImmGetVirtualKey ( HWND, BOOL );
	static HIMC ImmEscape ( HKL, HIMC, UINT, PVOID, BOOL );
	static BOOL ImmGetOpenStatus ( HIMC, BOOL );
	static BOOL ImmSetOpenStatus ( HIMC, BOOL, BOOL );
	static BOOL ImmGetConversionStatus ( HIMC, LPDWORD, LPDWORD, BOOL );
	static BOOL ImmSetConversionStatus ( HIMC, DWORD, DWORD, BOOL );
	static HWND ImmGetDefaultIMEWnd ( HWND , BOOL);
	static BOOL ImmSetCompositionStringW (HIMC, DWORD, PVOID, DWORD, PVOID, DWORD);
	static BOOL FSupportSty ( UINT, UINT );
	static const IMESTYLE * PIMEStyleFromAttr ( const UINT );
	static const IMECOLORSTY * PColorStyleTextFromIMEStyle ( const IMESTYLE * );
	static const IMECOLORSTY * PColorStyleBackFromIMEStyle ( const IMESTYLE * );
	static BOOL FBoldIMEStyle ( const IMESTYLE * );
	static BOOL FItalicIMEStyle ( const IMESTYLE * );
	static BOOL FUlIMEStyle ( const IMESTYLE * );
	static UINT IdUlIMEStyle ( const IMESTYLE * );
	static COLORREF RGBFromIMEColorStyle ( const IMECOLORSTY * );

	// ----------------------------------
	// National Language Keyboard support
	// ----------------------------------
	static HKL	CheckChangeKeyboardLayout (BYTE bCharSet);
	static HKL	ActivateKeyboard (LONG index);
	static DWORD GetCharFlags125x(WCHAR ch);
	static BOOL GetKeyboardFlag (WORD dwKeyMask, WORD wKey);
	static WORD GetKeyboardFlags ()				{return _wKeyboardFlags;}
	static HKL  GetKeyboardLayout (DWORD dwThreadID);
	static WORD GetKeyPadNumber ()				{return _wNumKeyPad;}
	static WORD GetDeadKey ()					{return _wDeadKey;}
	static void InitKeyboardFlags ();
	static void RefreshKeyboardLayout ();
	static void ResetKeyboardFlag (WORD wFlag)	{_wKeyboardFlags &= ~wFlag;}
	static void SetDeadKey (WORD wDeadKey)		{_wDeadKey = wDeadKey;}
	static void SetKeyboardFlag (WORD wFlag)	{_wKeyboardFlags |= wFlag;}
	static void SetKeyPadNumber (WORD wNum)		{_wNumKeyPad = wNum;}
	static bool UsingHebrewKeyboard ()
					{return PRIMARYLANGID(_hklCurrent) == LANG_HEBREW;}
	static void InitPreferredFontInfo();
	static bool SetPreferredFontInfo(
		int cpg,
		bool fUIFont,
		SHORT iFont,
		BYTE yHeight,
		BYTE bPitchAndFamily
	);
	static bool GetPreferredFontInfo(
		int cpg,
		bool fUIFont,
		SHORT& iFont,
		BYTE& yHeight,
		BYTE& bPitchAndFamily
	);

	static SHORT GetPreferredFontHeight(	
		bool	fUIFont,
		BYTE	bOrgCharSet,
		BYTE	bNewCharSet,
		SHORT	yOrgHeight
	);

	static void CheckInstalledFEFonts();
	static void CheckInstalledKeyboards();
	static bool IsFontAvail( HDC hDC, int cpg, bool fUIFont = false, short *piFontIndex = NULL);
	static bool IsFEFontInSystem( int cpg );
	static UINT GetFEFontInfo( void );
	static int IsFESystem()
	{
		return IsFELCID( _syslcid );
	}

#ifndef NOACCESSIBILITY
	// ----------------------------------
	// Accessability Support
	// ----------------------------------
	static HRESULT VariantCopy(VARIANTARG FAR*  pvargDest, VARIANTARG FAR*  pvargSrc);
	static LRESULT LResultFromObject(REFIID riid, WPARAM wParam, LPUNKNOWN punk);
	static HRESULT AccessibleObjectFromWindow(HWND hWnd, DWORD dwID, REFIID riidInterface, void ** ppvObject);
	static BOOL BlockInput(BOOL fBlock);
	static UINT	SendInput(UINT nInputs, LPINPUT pInputs, int cbSize);
	static VOID	NotifyWinEvent(DWORD dwEvent, HWND hWnd, LONG lObjectType, LONG lObjectId);
#endif
	
	// ----------------------------------
	// OLE Support
	// ----------------------------------
	static HRESULT LoadRegTypeLib ( REFGUID, WORD, WORD, LCID, ITypeLib ** );
	static HRESULT LoadTypeLib ( const OLECHAR *, ITypeLib ** );
	static HRESULT LoadTypeLibEx( LPCOLESTR szFile, REGKIND regkind, ITypeLib ** pptlib );
	static BSTR SysAllocString ( const OLECHAR * );
	static BSTR SysAllocStringLen ( const OLECHAR *, UINT );
	static void SysFreeString ( BSTR );
	static UINT SysStringLen ( BSTR );
	static void VariantInit ( VARIANTARG * );
	static HRESULT OleCreateFromData ( LPDATAOBJECT, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** );
	static void CoTaskMemFree ( PVOID );
	static HRESULT CreateBindCtx ( DWORD, LPBC * );
	static HANDLE OleDuplicateData ( HANDLE, CLIPFORMAT, UINT );
	static HRESULT CoTreatAsClass ( REFCLSID, REFCLSID );
	static HRESULT ProgIDFromCLSID ( REFCLSID, LPOLESTR * );
	static HRESULT OleConvertIStorageToOLESTREAM ( LPSTORAGE, LPOLESTREAM );
	static HRESULT OleConvertIStorageToOLESTREAMEx ( LPSTORAGE, CLIPFORMAT, LONG, LONG, DWORD, LPSTGMEDIUM, LPOLESTREAM );
	static HRESULT OleSave ( LPPERSISTSTORAGE, LPSTORAGE, BOOL );
	static HRESULT StgCreateDocfileOnILockBytes ( ILockBytes *, DWORD, DWORD, IStorage ** );
	static HRESULT CreateILockBytesOnHGlobal ( HGLOBAL, BOOL, ILockBytes ** );
	static HRESULT OleCreateLinkToFile ( LPCOLESTR, REFIID, DWORD, LPFORMATETC, LPOLECLIENTSITE, LPSTORAGE, void ** );
	static PVOID CoTaskMemAlloc ( ULONG );
	static PVOID CoTaskMemRealloc ( PVOID, ULONG );
	static HRESULT OleInitialize ( PVOID );
	static void OleUninitialize ( );
	static HRESULT OleSetClipboard ( IDataObject * );
	static HRESULT OleFlushClipboard ( );
	static HRESULT OleIsCurrentClipboard ( IDataObject * );
	static HRESULT DoDragDrop ( IDataObject *, IDropSource *, DWORD, DWORD * );
	static HRESULT OleGetClipboard ( IDataObject ** );
	static HRESULT RegisterDragDrop ( HWND, IDropTarget * );
	static HRESULT OleCreateLinkFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** );
	static HRESULT OleCreateStaticFromData ( IDataObject *, REFIID, DWORD, LPFORMATETC, IOleClientSite *, IStorage *, void ** );
	static HRESULT OleDraw ( IUnknown *, DWORD, HDC, LPCRECT );
	static HRESULT OleSetContainedObject ( IUnknown *, BOOL );
	static HRESULT CoDisconnectObject ( IUnknown *, DWORD );
	static HRESULT WriteFmtUserTypeStg ( IStorage *, CLIPFORMAT, LPOLESTR );
	static HRESULT WriteClassStg ( IStorage *, REFCLSID );
	static HRESULT SetConvertStg ( IStorage *, BOOL );
	static HRESULT ReadFmtUserTypeStg ( IStorage *, CLIPFORMAT *, LPOLESTR * );
	static HRESULT ReadClassStg ( IStorage *pstg, CLSID * );
	static HRESULT OleRun ( IUnknown * );
	static HRESULT RevokeDragDrop ( HWND );
	static HRESULT CreateStreamOnHGlobal ( HGLOBAL, BOOL, IStream ** );
	static HRESULT GetHGlobalFromStream ( IStream *pstm, HGLOBAL * );
	static HRESULT OleCreateDefaultHandler ( REFCLSID, IUnknown *, REFIID, void ** );
	static HRESULT CLSIDFromProgID ( LPCOLESTR, LPCLSID );
	static HRESULT OleConvertOLESTREAMToIStorage ( LPOLESTREAM, IStorage *, const DVTARGETDEVICE * );
	static HRESULT OleLoad ( IStorage *, REFIID, IOleClientSite *, void ** );
	static HRESULT ReleaseStgMedium ( LPSTGMEDIUM );
	static HRESULT CoCreateInstance (REFCLSID rclsid, LPUNKNOWN pUnknown,
		DWORD dwClsContext, REFIID riid, PVOID *ppv);
	static void FreeOle();
	static void FreeIME();
	static BOOL HaveIMEShare();
	static BOOL getIMEShareObject(CIMEShare **ppIMEShare);	
	static BOOL IsAIMMLoaded() { return _fHaveAIMM; }
	static BOOL GetAimmObject(IUnknown **ppAimm);
	static BOOL LoadAIMM();
	static HRESULT AIMMDefWndProc(HWND hWnd, UINT msg, WPARAM wparam, LPARAM lparam, LRESULT *plres);
	static HRESULT AIMMGetCodePage (HKL hKL, UINT *uCodePage);
	static HRESULT AIMMActivate (BOOL fRestoreLayout);
	static HRESULT AIMMDeactivate (void);
	static HRESULT AIMMFilterClientWindows(ATOM *aaClassList, UINT uSize);
	
	int __cdecl sprintf(char * buff, char *fmt, ...);

	// ----------------------------------
	// Useful ANSI<-->Unicode conversion
	//          and language id routines
	// ----------------------------------
	static int	MbcsFromUnicode(LPSTR pstr, int cch, LPCWSTR pwstr,
					int cwch = -1, UINT codepage = CP_ACP,
					UN_FLAGS flags = UN_CONVERT_WCH_EMBEDDING);
	static int	UnicodeFromMbcs(LPWSTR pwstr, int cwch, LPCSTR pstr, int cch = -1,
					UINT uiCodePage = CP_ACP);
	static int	MBTWC(INT CodePage, DWORD dwFlags, LPCSTR pstrMB, int cchMB,
					LPWSTR pstrWC, int cchWC, LPBOOL pfNoCodePage);
	static int	WCTMB(INT CodePage, DWORD dwFlags, LPCWSTR pstrWC, int cchWC,
					LPSTR pstrMB, int cchMB, LPCSTR	pchDefault, LPBOOL pfUsedDef,
					LPBOOL pfNoCodePage, BOOL fTestCodePage = FALSE);
	static int	VerifyFEString(INT cpg, LPCWSTR pstrWC, int cchWC, BOOL	fTestInputCpg);
	static HGLOBAL TextHGlobalAtoW( HGLOBAL hglobal );
	static HGLOBAL TextHGlobalWtoA( HGLOBAL hglobal );
	static UINT ConvertLanguageIDtoCodePage(WORD lid);

	static HKL	FindDirectionalKeyboard(BOOL fRTL);
	static BYTE GetCharSet(INT cpg, int *pcharsetIndex = NULL);
	static BYTE MatchFECharSet(DWORD dwCharInfo, DWORD dwFontSig);	
	static INT  GetCodePage(BYTE bCharSet);
	static DWORD GetFontSig(WORD wCharSet);
	static DWORD GetFontSigFromScript(int iScript);
	static BYTE GetFirstAvailCharSet(DWORD dwFontSig);
	static UINT GetKeyboardCodePage(DWORD dwMakeAPICall = 0);
	static LCID GetKeyboardLCID(DWORD dwMakeAPICall = 0);
	static UINT GetLocaleCodePage();
	static LCID GetLocaleLCID();
	static HKL	GetPreferredKbd(LONG iScript) {return _hkl[iScript];}
	static void	SetPreferredKbd(LONG iScript, HKL hkl) {_hkl[iScript] = hkl;}
	static UINT GetSystemDefaultCodePage()
					{return ConvertLanguageIDtoCodePage(GetSystemDefaultLangID());}
	static int	GetTrailBytesCount(BYTE ach, UINT cpg);
	static BYTE	GetGdiCharSet(BYTE bCharSet);

	static INT  In125x(WCHAR ch, BYTE bCharSet);
	static BOOL Is8BitCodePage(unsigned CodePage);
	static BOOL IsAlef(TCHAR ch);
	static BOOL IsBiDiCharSet(unsigned CharSet)
					{return IN_RANGE(HEBREW_CHARSET, CharSet, ARABIC_CHARSET);}
	static bool IsBiDiCodePage(int cpg)
					{return	IN_RANGE(CP_HEBREW, cpg, CP_ARABIC);}
	static bool IsBiDiKbdInstalled()
					{return	_hkl[HEBREW_INDEX] || _hkl[ARABIC_INDEX];}
	static bool IsThaiKbdInstalled()
					{return	_hkl[THAI_INDEX] != 0;}
	static bool IsIndicKbdInstalled();
	static bool IsComplexKbdInstalled()
					{return	IsBiDiKbdInstalled() || IsThaiKbdInstalled() || IsIndicKbdInstalled();}
	static BOOL IsPrivateCharSet(unsigned CharSet)
					{return IN_RANGE(ADHOC_CHARSET, CharSet, DEVANAGARI_CHARSET);}
	static bool IsVietnameseCodePage(int cpg)
					{return	cpg == CP_VIETNAMESE;}
	static BOOL IsDiacritic(WCHAR ch);
	static BOOL IsBiDiDiacritic(TCHAR ch);
	static BOOL IsBiDiKashida(WCHAR ch)
					{return ch == 0x0640;}
	static BOOL IsBiDiLcid(LCID lcid);
	static BOOL IsIndicLcid(LCID lcid);
	static BOOL IsComplexScriptLcid(LCID lcid);
	static BOOL IsCharSetValid(BYTE bCharSet);
	static BOOL IsDiacriticOrKashida(WCHAR ch, WORD wC3Type);
	static bool IsFELCID(LCID lcid);
	static BOOL IsFECharSet (BYTE bCharSet);
	static bool IsFECodePage(int cpg)
					{return	IN_RANGE(CP_JAPAN, cpg, CP_CHINESE_TRAD);}
	static BOOL IsFECodePageFont (DWORD dwFontSig);
	static BOOL IsRTLCharSet(BYTE bCharSet);
		   BOOL IsStrongDirectional(CC cc)	{return cc <= CC_LTR;}
	static BOOL IsVietCdmSequenceValid(WCHAR ch1, WCHAR ch2);
	static BOOL	IsZWG(char ch, BYTE bCharSet);	//@cmember Is char a 0-width glyph?
	static BOOL IsUTF8BOM(BYTE *pstr);

	static LONG ScriptIndexFromCharSet(BYTE bCharSet);
	static LONG ScriptIndexFromChar	  (WCHAR ch);
	static LONG ScriptIndexFromFontSig(DWORD dwFontSig);

	static WPARAM ValidateStreamWparam(WPARAM wparam);

	static CC	MECharClass(TCHAR ch);

	static HDC GetScreenDC();


	// ----------------------------------
	// Unicode Wrapped Functions
	// ----------------------------------

	// We could use inline and a function pointer table to improve efficiency and code size.

	static ATOM WINAPI RegisterREClass(
		const WNDCLASSW *lpWndClass,
		const char *szAnsiClassName,
		WNDPROC AnsiWndProc
	);
	static BOOL GetVersion(
		DWORD *pdwPlatformId,
		DWORD *pdwMajorVersion,
		DWORD *pdwMinorVersion
	);
	static BOOL GetStringTypes(
		LCID	lcid,
		LPCTSTR lpSrcStr,
		int		cchSrc,
		LPWORD	lpCharType1,
		LPWORD	lpCharType3
	);
	static BOOL WINAPI GetStringTypeEx(
		LCID     Locale,
		DWORD    dwInfoType,
		LPCWSTR lpSrcStr,
		int      cchSrc,
		LPWORD   lpCharType
	);
	static LPWSTR WINAPI CharLower(LPWSTR pwstr);
	static DWORD WINAPI CharLowerBuff(LPWSTR pwstr, DWORD cchLength);
	static DWORD WINAPI CharUpperBuff(LPWSTR pwstr, DWORD cchLength);
	static HDC WINAPI CreateIC(
        LPCWSTR             lpszDriver,
        LPCWSTR             lpszDevice,
        LPCWSTR             lpszOutput,
        CONST DEVMODEW *    lpInitData
	);
	static HANDLE WINAPI CreateFile(
        LPCWSTR                 lpFileName,
        DWORD                   dwDesiredAccess,
        DWORD                   dwShareMode,
        LPSECURITY_ATTRIBUTES   lpSecurityAttributes,
        DWORD                   dwCreationDisposition,
        DWORD                   dwFlagsAndAttributes,
        HANDLE                  hTemplateFile
	);
	static HFONT WINAPI CreateFontIndirect(CONST LOGFONTW * plfw);
	static int WINAPI CompareString (
		LCID  Locale,			// locale identifier
		DWORD  dwCmpFlags,		// comparison-style options
		LPCWSTR  lpString1,		// pointer to first string
		int  cch1,			// size, in bytes or characters, of first string
		LPCWSTR  lpString2,		// pointer to second string
		int  cch2 			// size, in bytes or characters, of second string
	);
	static LRESULT WINAPI DefWindowProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam);
	static int WINAPI GetObject(HGDIOBJ hgdiObj, int cbBuffer, PVOID lpvObj);
	static DWORD APIENTRY GetProfileSection(
		LPCWSTR lpAppName,
		LPWSTR lpReturnedString,
		DWORD nSize
	);
	static BOOL APIENTRY GetTextExtentPoint32(
        HDC     hdc,
        LPCWSTR pwsz,
        int     cb,
        LPSIZE  pSize
	);
	static int WINAPI GetTextFace(
        HDC    hdc,
        int    cch,
        LPWSTR lpFaceName
	);
	static BOOL WINAPI GetTextMetrics(HDC hdc, LPTEXTMETRICW lptm);
	static BOOL WINAPI GetTextMetrics(HDC hdc, LOGFONTW &lf, TEXTMETRICW &tm);
	static LONG WINAPI GetWindowLong(HWND hWnd, int nIndex);
	static LONG_PTR WINAPI GetWindowLongPtr(HWND hWnd, int nIndex);
	static DWORD WINAPI GetClassLong(HWND hWnd, int nIndex);
	static HBITMAP WINAPI LoadBitmap(HINSTANCE hInstance, LPCWSTR lpBitmapName);
	static HCURSOR WINAPI LoadCursor(HINSTANCE hInstance, LPCWSTR lpCursorName);
	static HINSTANCE WINAPI LoadLibrary(LPCWSTR lpLibFileName);
	static LRESULT WINAPI SendMessage(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam
	);
	static LONG WINAPI SetWindowLong(HWND hWnd, int nIndex, LONG dwNewLong);
	static LONG WINAPI SetWindowLongPtr(HWND hWnd, int nIndex, LONG_PTR dwNew);
	static BOOL WINAPI PostMessage(
        HWND    hWnd,
        UINT    Msg,
        WPARAM  wParam,
        LPARAM  lParam
	);
	static BOOL WINAPI UnregisterClass(LPCWSTR lpClassName, HINSTANCE hInstance);
	static int WINAPI lstrcmp(LPCWSTR lpString1, LPCWSTR lpString2);
	static int WINAPI lstrcmpi(LPCWSTR lpString1, LPCWSTR lpString2);
	static BOOL WINAPI PeekMessage(
        LPMSG   lpMsg,
        HWND    hWnd,
        UINT    wMsgFilterMin,
        UINT    wMsgFilterMax,
        UINT    wRemoveMsg
	);
	static DWORD WINAPI GetModuleFileName(
		HMODULE hModule,
		LPWSTR lpFilename,
		DWORD nSize
    );
	static DWORD GetCurrentThreadId(void);

private:
	// System Parameters
	static BOOL		_fSysParamsOk;			// System Parameters have been Initialized
	static INT 		_xWidthSys;				// average char width of system font
	static INT 		_yHeightSys;			// height of system font
	static INT		_ySysFontLeading;		// System font internal leading
	static BOOL 	_fUsePalette;
	static LONG 	_xPerInchScreenDC;		// Pixels per inch used for conversions ...
	static LONG 	_yPerInchScreenDC;		// ... and determining whether screen or ...
	static INT		_cxBorder;				// GetSystemMetricx(SM_CXBORDER)...
	static INT		_cyBorder;				// GetSystemMetricx(SM_CYBORDER)...
	static INT		_cxVScroll;				// Width/height of scrlbar arw bitmap
	static INT		_cyHScroll;				// Width of scrlbar arw bitmap
	static LONG 	_dxSelBar;
	static INT		_sysiniflags;			// Start using line services from the start

	static UINT		_ACP;					// Current Ansi code page identifier

	static HDC		_hdcScreen;
	// Double click distances
	static INT		_cxDoubleClk;
	static INT		_cyDoubleClk;	

	// Double Click Time in milliseconds
	static INT		_DCT;

	//Width of hot zone (in pixels) for auto-scrolling
    static WORD	_nScrollInset;
    //Delay (in ms) before scrolling
    static WORD _nScrollDelay;
	//Interval (in ms) at which we scroll
    static WORD _nScrollInterval;
	//Amount of horizontal scroll at each interval (pixels)
	static WORD _nScrollHAmount;
	//Amount of vertical scroll at each interval (pixels)
	static WORD _nScrollVAmount;
	//Amount of time to wait for determining start of drag operation
	static WORD _nDragDelay;
	//Minimun distance that must be traversed within drag delay time interval
	static WORD _nDragMinDist;
	//Keyboard deadkey
	static WORD _wDeadKey;
	//Keyboard shift/ctrl/alt/lock status
	static WORD _wKeyboardFlags;
	//North/South sizing cursor (double arrow)
	static HCURSOR _hcurSizeNS;
	//West/East sizing cursor (double arrow)
	static HCURSOR _hcurSizeWE;
	//Northwest/Southeast sizing cursor (double arrow)
	static HCURSOR _hcurSizeNWSE;
	//Northeast/Southwest sizing cursor (double arrow)
	static HCURSOR _hcurSizeNESW;
	//Number of Lines to scroll with a mouse roller wheel, -1 for pages
	static LONG	_cLineScroll;
	//System Font Handle.  This one need only be done once.
	static HFONT _hSystemFont;
	//System Keyboard Layout
	static HKL _hklCurrent;
	static HKL _hkl[NCHARSETS];

	// Ref Count
	static DWORD _cRefs;

	//AltNumericKeyboard number
	static WORD _wNumKeyPad;

	//Digit substitution mode (context, none, national)
	static BYTE	_bDigitSubstMode;

	//SYSTEM_FONT charset
	static BYTE _bSysCharSet;

public:
	static INT	GetXWidthSys()		 {return _xWidthSys; }
	static INT	GetYHeightSys()		 {return _yHeightSys; }
	static INT	GetSysFontLeading()	 {return _ySysFontLeading; }
	static LONG GetXPerInchScreenDC(){return _xPerInchScreenDC; }
	static LONG GetYPerInchScreenDC(){return _yPerInchScreenDC; }
	static INT	GetCxBorder()		 {return _cxBorder; }
	static INT	GetCyBorder()		 {return _cyBorder; }
	static INT	GetCyHScroll()		 {return _cyHScroll; }
	static INT	GetCxVScroll()		 {return _cxVScroll; }
	static LONG GetDxSelBar()		 {return _dxSelBar; }
    static WORD GetScrollInset()	 {return _nScrollInset; }
    static WORD GetScrollDelay()	 {return _nScrollDelay; }
    static WORD GetScrollInterval()	 {return _nScrollInterval; }
	static WORD GetScrollHAmount()	 {return _nScrollHAmount; }
	static WORD GetScrollVAmount()	 {return _nScrollVAmount; }
	static INT	GetCxDoubleClk()	 {return _cxDoubleClk; }
	static INT	GetCyDoubleClk()	 {return _cyDoubleClk; }
	static INT	GetDCT()			 {return _DCT; }
	static WORD GetDragDelay()		 {return _nDragDelay; }
	static WORD GetDragMinDist()	 {return _nDragMinDist; }
	static LONG GetRollerLineScrollCount();
	static HCURSOR GetSizeCursor(LPTSTR idcur);
	static HFONT GetSystemFont()	 {return _hSystemFont; }
	static BYTE ReadRegDigitSubstitutionMode();
	static BYTE GetDigitSubstitutionMode() {return _bDigitSubstMode;}
	static bool fUseAimm()			 {return (_sysiniflags & SYSINI_USEAIMM) != 0;}
	static bool fUseBiDi()			 {return (_sysiniflags & SYSINI_BIDI) != 0;}
	static bool fUseLs()			 {return (_sysiniflags & SYSINI_USELS) != 0;}
	static bool fDebugFont()		 {return (_sysiniflags & SYSINI_DEBUGFONT) != 0;}
	static int  DebugDefaultCpg()    {return HIWORD(_sysiniflags);}
	static BOOL FUsePalette()		 {return _fUsePalette; }
	static void InitSysParams(BOOL fUpdate = FALSE);
	static DWORD GetRefs()			 {return _cRefs;}
	static BYTE	GetSysCharSet()		 {return _bSysCharSet;}

	// Should also be wrapped but aren't.  Used for debugging.
	// MessageBox
	// OutputDebugString

	// lstrcmpiA should also be wrapped for Win CE's sake but the code
	// that uses it is ifdeffed out for WINCE.


	// Mirroring API entry points
	static PFN_GETLAYOUT			_pfnGetLayout;
	static PFN_SETLAYOUT			_pfnSetLayout;
};

extern CW32System *W32;
HKL	   g_hkl[];

#if !defined(W32SYS_CPP)

#define OnWinNTFE					W32->OnWinNTFE
#define OnWin95FE					W32->OnWin95FE
#ifdef DEBUG
#define PvAlloc(cbBuf, uiMemFlags)	W32->PvAllocDebug(cbBuf, uiMemFlags, __FILE__, __LINE__)
#define PvReAlloc(pv, cbBuf)		W32->PvReAllocDebug(pv, cbBuf, __FILE__, __LINE__)
#define PvSet(pv)					W32->PvSet(pv, __FILE__, __LINE__)
#define FreePv						W32->FreePvDebug
#else
#define PvAlloc						W32->PvAlloc
#define PvReAlloc					W32->PvReAlloc
#define FreePv						W32->FreePv
#endif
#define CopyMemory					W32->CopyMemory
#define MoveMemory					W32->MoveMemory
#define FillMemory					W32->FillMemory
#define ZeroMemory					W32->ZeroMemory
#define CompareMemory				W32->CompareMemory
#define GlobalAlloc					W32->GlobalAlloc
#define GlobalFree					W32->GlobalFree
#define GlobalFlags					W32->GlobalFlags
#define	GlobalReAlloc				W32->GlobalReAlloc
#define	GlobalSize					W32->GlobalSize
#define	GlobalLock					W32->GlobalLock
#define	GlobalHandle				W32->GlobalHandle
#define	GlobalUnlock				W32->GlobalUnlock

#define ImmInitialize				W32->ImmInitialize
#define ImmTerminate				W32->ImmTerminate

#define ImmGetCompositionStringA	W32->ImmGetCompositionStringA
#define ImmGetCompositionStringW	W32->ImmGetCompositionStringW
#define ImmGetContext				W32->ImmGetContext
#define ImmSetCompositionFontA		W32->ImmSetCompositionFontA
#define ImmSetCompositionWindow		W32->ImmSetCompositionWindow
#define ImmReleaseContext			W32->ImmReleaseContext
#define ImmGetProperty				W32->ImmGetProperty
#define ImmGetCandidateWindow		W32->ImmGetCandidateWindow
#define ImmSetCandidateWindow		W32->ImmSetCandidateWindow
#define ImmNotifyIME				W32->ImmNotifyIME
#define ImmAssociateContext			W32->ImmAssociateContext
#define ImmGetVirtualKey			W32->ImmGetVirtualKey
#define ImmEscape					W32->ImmEscape
#define ImmGetOpenStatus			W32->ImmGetOpenStatus
#define ImmSetOpenStatus			W32->ImmSetOpenStatus
#define ImmGetConversionStatus		W32->ImmGetConversionStatus
#define ImmSetConversionStatus		W32->ImmSetConversionStatus
#define ImmGetDefaultIMEWnd			W32->ImmGetDefaultIMEWnd
#define ImmSetCompositionStringW	W32->ImmSetCompositionStringW
#define LoadRegTypeLib				W32->LoadRegTypeLib
#define LoadTypeLib					W32->LoadTypeLib
#define SysAllocString				W32->SysAllocString
#define SysAllocStringLen			W32->SysAllocStringLen
#define SysFreeString				W32->SysFreeString
#define SysStringLen				W32->SysStringLen
#define VariantInit					W32->VariantInit
#define OleCreateFromData			W32->OleCreateFromData
#define CoTaskMemFree				W32->CoTaskMemFree
#define CreateBindCtx				W32->CreateBindCtx
#define OleDuplicateData			W32->OleDuplicateData
#define CoTreatAsClass				W32->CoTreatAsClass
#define ProgIDFromCLSID				W32->ProgIDFromCLSID
#define OleConvertIStorageToOLESTREAM W32->OleConvertIStorageToOLESTREAM
#define OleConvertIStorageToOLESTREAMEx W32->OleConvertIStorageToOLESTREAMEx
#define OleSave						W32->OleSave
#define StgCreateDocfileOnILockBytes W32->StgCreateDocfileOnILockBytes
#define CreateILockBytesOnHGlobal	W32->CreateILockBytesOnHGlobal
#define OleCreateLinkToFile			W32->OleCreateLinkToFile
#define CoTaskMemAlloc				W32->CoTaskMemAlloc
#define CoTaskMemRealloc			W32->CoTaskMemRealloc
#define OleInitialize				W32->OleInitialize
#define OleUninitialize				W32->OleUninitialize
#define OleSetClipboard				W32->OleSetClipboard
#define OleFlushClipboard			W32->OleFlushClipboard
#define OleIsCurrentClipboard		W32->OleIsCurrentClipboard
#define DoDragDrop					W32->DoDragDrop
#define OleGetClipboard				W32->OleGetClipboard
#define RegisterDragDrop			W32->RegisterDragDrop
#define OleCreateLinkFromData		W32->OleCreateLinkFromData
#define OleCreateStaticFromData		W32->OleCreateStaticFromData
#define OleDraw						W32->OleDraw
#define OleSetContainedObject		W32->OleSetContainedObject
#define CoDisconnectObject			W32->CoDisconnectObject
#define WriteFmtUserTypeStg			W32->WriteFmtUserTypeStg
#define WriteClassStg				W32->WriteClassStg
#define SetConvertStg				W32->SetConvertStg
#define ReadFmtUserTypeStg			W32->ReadFmtUserTypeStg
#define ReadClassStg				W32->ReadClassStg
#define OleRun						W32->OleRun
#define RevokeDragDrop				W32->RevokeDragDrop
#define CreateStreamOnHGlobal		W32->CreateStreamOnHGlobal
#define GetHGlobalFromStream		W32->GetHGlobalFromStream
#define OleCreateDefaultHandler		W32->OleCreateDefaultHandler
#define CLSIDFromProgID				W32->CLSIDFromProgID
#define OleConvertOLESTREAMToIStorage W32->OleConvertOLESTREAMToIStorage
#define OleLoad						W32->OleLoad
#define ReleaseStgMedium			W32->ReleaseStgMedium
#define CoCreateInstance			W32->CoCreateInstance
#define FSupportSty					W32->FSupportSty
#define PIMEStyleFromAttr			W32->PIMEStyleFromAttr
#define PColorStyleTextFromIMEStyle W32->PColorStyleTextFromIMEStyle
#define PColorStyleBackFromIMEStyle W32->PColorStyleBackFromIMEStyle
#define FBoldIMEStyle				W32->FBoldIMEStyle
#define FItalicIMEStyle				W32->FItalicIMEStyle
#define FUlIMEStyle					W32->FUlIMEStyle
#define IdUlIMEStyle				W32->IdUlIMEStyle
#define RGBFromIMEColorStyle		W32->RGBFromIMEColorStyle

#define fHaveIMMProcs				W32->_fHaveIMMProcs
#define fHaveAIMM					W32->_fHaveAIMM
#define dwPlatformId				W32->_dwPlatformId
#define dwMajorVersion				W32->_dwMajorVersion
#define icr3DDarkShadow				W32->_icr3DDarkShadow
#define MSIMEMouseMsg				W32->_MSIMEMouseMsg				
#define MSIMEReconvertMsg			W32->_MSIMEReconvertMsg		
#define MSIMEReconvertRequestMsg	W32->_MSIMEReconvertRequestMsg
#define MSIMEDocFeedMsg				W32->_MSIMEDocFeedMsg
#define MSIMEQueryPositionMsg		W32->_MSIMEQueryPositionMsg
#define MSIMEServiceMsg				W32->_MSIMEServiceMsg

#define ScriptIndexFromChar			W32->ScriptIndexFromChar
#define ScriptIndexFromCharSet		W32->ScriptIndexFromCharSet	
#define MECharClass					W32->MECharClass
#define MbcsFromUnicode				W32->MbcsFromUnicode	
#define UnicodeFromMbcs				W32->UnicodeFromMbcs
#define TextHGlobalAtoW				W32->TextHGlobalAtoW
#define TextHGlobalWtoA				W32->TextHGlobalWtoA
#define ConvertLanguageIDtoCodePage	W32->ConvertLanguageIDtoCodePage	
#define In125x						W32->In125x	

#define Is8BitCodePage				W32->Is8BitCodePage
#define IsAlef						W32->IsAlef
#define IsAmbiguous					W32->IsAmbiguous
#define IsBiDiCharSet				W32->IsBiDiCharSet
#define IsBiDiDiacritic				W32->IsBiDiDiacritic
#define IsBiDiKashida				W32->IsBiDiKashida
#define IsBiDiKbdInstalled			W32->IsBiDiKbdInstalled
#define IsDiacritic					W32->IsDiacritic
#define	IsCharSetValid				W32->IsCharSetValid	
#define IsDiacriticOrKashida		W32->IsDiacriticOrKashida
#define IsFECharSet					W32->IsFECharSet	
#define IsFELCID					W32->IsFELCID	
#define IsPrivateCharSet			W32->IsPrivateCharSet
#define IsRTLCharSet				W32->IsRTLCharSet	
#define IsStrongDirectional			W32->IsStrongDirectional
#define IsThaiKbdInstalled			W32->IsThaiKbdInstalled
#define IsIndicKbdInstalled			W32->IsIndicKbdInstalled
#define IsComplexKbdInstalled		W32->IsComplexKbdInstalled
#define	IsTrailByte					W32->IsTrailByte
#define IsVietCdmSequenceValid		W32->IsVietCdmSequenceValid
	
#define	GetCharSet					W32->GetCharSet	
#define GetGdiCharSet				W32->GetGdiCharSet
#define	GetCodePage					W32->GetCodePage	
#define	GetFontSig					W32->GetFontSig
#define GetFirstAvailCharSet		W32->GetFirstAvailCharSet
#define MatchFECharSet				W32->MatchFECharSet
#define	GetKeyboardCodePage			W32->GetKeyboardCodePage	
#define	GetKeyboardLCID				W32->GetKeyboardLCID	
#define	GetLocaleCodePage			W32->GetLocaleCodePage	
#define	GetLocaleLCID				W32->GetLocaleLCID	
#define	GetSystemDefaultCodePage	W32->GetSystemDefaultCodePage
#define GetTrailBytesCount			W32->GetTrailBytesCount	
#define	MBTWC						W32->MBTWC	
#define	WCTMB						W32->WCTMB
#define VerifyFEString				W32->VerifyFEString		

#define CharLower					W32->CharLower
#define CharLowerBuff				W32->CharLowerBuff
#define CharUpperBuff				W32->CharUpperBuff
#define CreateIC					W32->CreateIC
#define CreateFile					W32->CreateFile
#define CreateFontIndirect			W32->CreateFontIndirect
#define CompareString				W32->CompareString
#define DefWindowProc				W32->DefWindowProc
#define GetDeadKey					W32->GetDeadKey
#define GetKeyboardFlag				W32->GetKeyboardFlag
#define GetKeyboardFlags			W32->GetKeyboardFlags
#define GetKeyboardLayout			W32->GetKeyboardLayout
#define GetKeyPadNumber				W32->GetKeyPadNumber
#define GetProfileSection			W32->GetProfileSection
#define GetTextExtentPoint32		W32->GetTextExtentPoint32
#define GetTextMetrics				W32->GetTextMetrics
#define GetTextFace					W32->GetTextFace
#define GetWindowLong				W32->GetWindowLong
#define GetWindowLongPtr			W32->GetWindowLongPtr
#define GetClassLong				W32->GetClassLong
#define InitKeyboardFlags			W32->InitKeyboardFlags
#define IsEnhancedMetafileDC		W32->IsEnhancedMetafileDC
#define LoadBitmap					W32->LoadBitmap
#define LoadCursor					W32->LoadCursor
#define LoadLibrary					W32->LoadLibrary
#define ResetKeyboardFlag			W32->ResetKeyboardFlag
#define SendMessage					W32->SendMessage
#define SetDeadKey					W32->SetDeadKey
#define SetKeyboardFlag				W32->SetKeyboardFlag
#define SetKeyPadNumber				W32->SetKeyPadNumber
#define SetWindowLong				W32->SetWindowLong
#define SetWindowLongPtr			W32->SetWindowLongPtr
#define PostMessage					W32->PostMessage
#define lstrcmp						W32->lstrcmp
#define lstrcmpi					W32->lstrcmpi
#define PeekMessage					W32->PeekMessage
#define GetMapMode					W32->GetMapMode
#define WinLPtoDP					W32->WinLPtoDP
#define MulDiv						W32->MulDiv

// AIMM wrapper
#define IsAIMMLoaded				W32->IsAIMMLoaded
#define LoadAIMM					W32->LoadAIMM
#define CallAIMMDefaultWndProc		W32->AIMMDefWndProc
#define GetAIMMKeyboardCP			W32->AIMMGetCodePage
#define ActivateAIMM				W32->AIMMActivate
#define DeactivateAIMM				W32->AIMMDeactivate
#define FilterClientWindowsAIMM		W32->AIMMFilterClientWindows
#define sprintf						W32->sprintf

#define wcslen						W32->wcslen
#define wcscpy						W32->wcscpy
#define wcscmp						W32->wcscmp
#define wcsicmp						W32->wcsicmp
#define wcsncpy						W32->wcsncpy

#define GetLayout					(*W32->_pfnGetLayout)
#define SetLayout					(*W32->_pfnSetLayout)

#define GetACP						W32->GetACP

#endif // !defined(W32SYS_CPP)

#define VER_PLATFORM_WIN32_MACINTOSH	0x8001

#if defined PEGASUS && !defined(WINNT)

// The follwing definitions do not exist in the Windows CE environment but we emulate them.
// The values have been copied from the appropriate win32 header files.

#pragma message(REVIEW "Using NT definitions not in Windows CE")

// Memory allocation flag.  Win CE uses Local mem instead of Global mem
#define GMEM_ZEROINIT       LMEM_ZEROINIT
#define GMEM_MOVEABLE		LMEM_MOVEABLE
#define GMEM_FIXED			LMEM_FIXED

// Scroll Bars
#define ESB_ENABLE_BOTH				0x0000
#define ESB_DISABLE_BOTH			0x0003

// Text alignment values
#define TA_TOP                      0
#define TA_BOTTOM                   8
#define TA_BASELINE                 24
#define TA_CENTER                   6
#define TA_LEFT                     0

// Device Technology.  This one is mostly used for exclusion
#define DT_METAFILE         5   // Metafile, VDM

// Resources for LoadCursor.
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)

// FInd/Replace options
#define FR_DOWN                         0x00000001
#define FR_WHOLEWORD                    0x00000002
#define FR_MATCHCASE                    0x00000004

// Window messages
#define WM_NCMOUSEMOVE                  0x00A0
#define WM_NCMBUTTONDBLCLK              0x00A9
#define WM_DROPFILES                    0x0233

// Code Pages
#define CP_UTF8              65001          /* UTF-8 translation */

// Clipboard formats
#define CF_METAFILEPICT     3

// Special cursor shapes
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)

/* Mapping Modes */
#define MM_TEXT             1
#define SetMapMode(hdc, mapmode)
#define SetWindowOrgEx(hdc, xOrg, yOrg, pt)
#define SetViewportExtEx(hdc, nX, nY, lpSize)
#define SetWindowExtEx(hdc, x, y, lpSize)

/* Pen Styles : Windows CE only supports PS_DASH */
#define PS_DOT PS_DASH
#define PS_DASHDOT PS_DASH
#define PS_DASHDOTDOT PS_DASH

/* Missing APIs */
#define GetMessageTime()	0
#define IsIconic(hwnd)		0

#pragma message (REVIEW "JMO. This is temporary to try to get the Pegasus Build untracked" )

#ifdef DEBUG
#define MoveToEx(a, b, c, d) 0
#else
#define MoveToEx(a, b, c, d)
#endif

#ifdef DEBUG
#define LineTo(a, b, c) 0
#else
#define LineTo(a, b, c)
#endif

#define GetProfileIntA(a, b, c) 0

class METARECORD
{
};

#define GetDesktopWindow() NULL

#define WS_EX_TRANSPARENT       0x00000020L
#define WM_MOUSEACTIVATE			0x0021

#define IsDBCSLeadByte(x) 0

#define WM_SYSCOLORCHANGE               0x0015
#define WM_STYLECHANGING                0x007C
#define WM_WINDOWPOSCHANGING            0x0046
#define WM_SETCURSOR                    0x0020
#define WM_NCPAINT                      0x0085

#define OEM_CHARSET             255
#define SHIFTJIS_CHARSET        128
#define THAI_CHARSET            222
#define WM_IME_CHAR                     0x0286
#define IME_CMODE_NATIVE                0x0001
#define IME_CMODE_HANGEUL               IME_CMODE_NATIVE
#define IME_ESC_HANJA_MODE              0x1008

#define SM_SWAPBUTTON           23

class CHARSETINFO
{
};

class HDROP
{
};

#define TCI_SRCCODEPAGE 2

#define TPM_RIGHTBUTTON 0x0002L

#define RegisterClipboardFormatA(s)  RegisterClipboardFormatW(TEXT(s))
#define GetThreadLocale() 0

#define EASTEUROPE_CHARSET      238
#define HEBREW_CHARSET          177
#define RUSSIAN_CHARSET         204
#define GB2312_CHARSET          134
#define HANGEUL_CHARSET         129
#define JOHAB_CHARSET           130
#define CHINESEBIG5_CHARSET     136
#define GREEK_CHARSET           161
#define TURKISH_CHARSET         162
#define BALTIC_CHARSET          186
#define ARABIC_CHARSET          178
#define MAC_CHARSET             77

#define ENUMLOGFONTA ENUMLOGFONT
#define ENUMLOGFONTW ENUMLOGFONT
#define FONTENUMPROCA FONTENUMPROC
typedef int *LPOPENFILENAMEA;
typedef int *LPOPENFILENAMEW;

#endif

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL			0x00400000L		// Right to left mirroring
#endif

#ifndef LAYOUT_RTL
#define LAYOUT_RTL				0x00000001
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\aimmex.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for aimmex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __aimmex_h__
#define __aimmex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IActiveIMMAppEx_FWD_DEFINED__
#define __IActiveIMMAppEx_FWD_DEFINED__
typedef interface IActiveIMMAppEx IActiveIMMAppEx;
#endif 	/* __IActiveIMMAppEx_FWD_DEFINED__ */


#ifndef __IAImmFnDocFeed_FWD_DEFINED__
#define __IAImmFnDocFeed_FWD_DEFINED__
typedef interface IAImmFnDocFeed IAImmFnDocFeed;
#endif 	/* __IAImmFnDocFeed_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "oaidl.h"
#include "msctf.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_aimmex_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// aimmex.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1999 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMMEx Interfaces.



extern RPC_IF_HANDLE __MIDL_itf_aimmex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimmex_0000_v0_0_s_ifspec;

#ifndef __IActiveIMMAppEx_INTERFACE_DEFINED__
#define __IActiveIMMAppEx_INTERFACE_DEFINED__

/* interface IActiveIMMAppEx */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IActiveIMMAppEx;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D7A6F58A-D478-44ab-86C9-591C23A26534")
    IActiveIMMAppEx : public IActiveIMMApp
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindowsEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ BOOL fGuidMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindowsGUIDMap( 
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize,
            /* [in] */ BOOL *aaGildMap) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuidAtom( 
            /* [in] */ HIMC hImc,
            /* [in] */ BYTE bAttr,
            /* [out] */ TfGuidAtom *pGuidAtom) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnfilterClientWindowsEx( 
            /* [in] */ HWND hWnd) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppExVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMAppEx * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMAppEx * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMAppEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMAppEx * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
            IActiveIMMAppEx * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEW )( 
            IActiveIMMAppEx * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *IsUIMessageW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE *NotifyIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE *ReleaseContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *SetCandidateWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionFontW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionStringW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE *SetCompositionWindow )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *SetConversionStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *SetOpenStatus )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE *SetStatusWindowPos )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *SimulateHotKey )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterWordW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE *Activate )( 
            IActiveIMMAppEx * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE *Deactivate )( 
            IActiveIMMAppEx * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnDefWindowProc )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindows )( 
            IActiveIMMAppEx * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE *GetCodePageA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE *GetLangId )( 
            IActiveIMMAppEx * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContextEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags);
        
        HRESULT ( STDMETHODCALLTYPE *DisableIME )( 
            IActiveIMMAppEx * This,
            /* [in] */ DWORD idThread);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsA )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetImeMenuItemsW )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *EnumInputContext )( 
            IActiveIMMAppEx * This,
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindowsEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd,
            /* [in] */ BOOL fGuidMap);
        
        HRESULT ( STDMETHODCALLTYPE *FilterClientWindowsGUIDMap )( 
            IActiveIMMAppEx * This,
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize,
            /* [in] */ BOOL *aaGildMap);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuidAtom )( 
            IActiveIMMAppEx * This,
            /* [in] */ HIMC hImc,
            /* [in] */ BYTE bAttr,
            /* [out] */ TfGuidAtom *pGuidAtom);
        
        HRESULT ( STDMETHODCALLTYPE *UnfilterClientWindowsEx )( 
            IActiveIMMAppEx * This,
            /* [in] */ HWND hWnd);
        
        END_INTERFACE
    } IActiveIMMAppExVtbl;

    interface IActiveIMMAppEx
    {
        CONST_VTBL struct IActiveIMMAppExVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMAppEx_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMAppEx_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMAppEx_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMAppEx_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMAppEx_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMAppEx_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMAppEx_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMAppEx_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMAppEx_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMAppEx_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMAppEx_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMAppEx_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMAppEx_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMAppEx_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMAppEx_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMAppEx_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMAppEx_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMAppEx_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMAppEx_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMAppEx_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMAppEx_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMAppEx_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMAppEx_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMAppEx_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMAppEx_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMAppEx_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMAppEx_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMAppEx_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMAppEx_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMAppEx_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMAppEx_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMAppEx_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMAppEx_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMAppEx_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMAppEx_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMAppEx_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMAppEx_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMAppEx_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMAppEx_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMAppEx_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMAppEx_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMAppEx_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMAppEx_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMAppEx_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMAppEx_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMAppEx_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMAppEx_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMAppEx_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMAppEx_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMAppEx_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMAppEx_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMAppEx_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMAppEx_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMAppEx_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMAppEx_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMAppEx_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMAppEx_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMAppEx_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMAppEx_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMAppEx_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMAppEx_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMAppEx_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMAppEx_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMAppEx_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMAppEx_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMAppEx_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMAppEx_AssociateContextEx(This,hWnd,hIMC,dwFlags)	\
    (This)->lpVtbl -> AssociateContextEx(This,hWnd,hIMC,dwFlags)

#define IActiveIMMAppEx_DisableIME(This,idThread)	\
    (This)->lpVtbl -> DisableIME(This,idThread)

#define IActiveIMMAppEx_GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsA(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMAppEx_GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)	\
    (This)->lpVtbl -> GetImeMenuItemsW(This,hIMC,dwFlags,dwType,pImeParentMenu,pImeMenu,dwSize,pdwResult)

#define IActiveIMMAppEx_EnumInputContext(This,idThread,ppEnum)	\
    (This)->lpVtbl -> EnumInputContext(This,idThread,ppEnum)


#define IActiveIMMAppEx_FilterClientWindowsEx(This,hWnd,fGuidMap)	\
    (This)->lpVtbl -> FilterClientWindowsEx(This,hWnd,fGuidMap)

#define IActiveIMMAppEx_FilterClientWindowsGUIDMap(This,aaClassList,uSize,aaGildMap)	\
    (This)->lpVtbl -> FilterClientWindowsGUIDMap(This,aaClassList,uSize,aaGildMap)

#define IActiveIMMAppEx_GetGuidAtom(This,hImc,bAttr,pGuidAtom)	\
    (This)->lpVtbl -> GetGuidAtom(This,hImc,bAttr,pGuidAtom)

#define IActiveIMMAppEx_UnfilterClientWindowsEx(This,hWnd)	\
    (This)->lpVtbl -> UnfilterClientWindowsEx(This,hWnd)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_FilterClientWindowsEx_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HWND hWnd,
    /* [in] */ BOOL fGuidMap);


void __RPC_STUB IActiveIMMAppEx_FilterClientWindowsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_FilterClientWindowsGUIDMap_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ ATOM *aaClassList,
    /* [in] */ UINT uSize,
    /* [in] */ BOOL *aaGildMap);


void __RPC_STUB IActiveIMMAppEx_FilterClientWindowsGUIDMap_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_GetGuidAtom_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HIMC hImc,
    /* [in] */ BYTE bAttr,
    /* [out] */ TfGuidAtom *pGuidAtom);


void __RPC_STUB IActiveIMMAppEx_GetGuidAtom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMAppEx_UnfilterClientWindowsEx_Proxy( 
    IActiveIMMAppEx * This,
    /* [in] */ HWND hWnd);


void __RPC_STUB IActiveIMMAppEx_UnfilterClientWindowsEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMAppEx_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_aimmex_0221 */
/* [local] */ 

EXTERN_C const CLSID CLSID_CAImmLayer;


extern RPC_IF_HANDLE __MIDL_itf_aimmex_0221_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimmex_0221_v0_0_s_ifspec;

#ifndef __IAImmFnDocFeed_INTERFACE_DEFINED__
#define __IAImmFnDocFeed_INTERFACE_DEFINED__

/* interface IAImmFnDocFeed */
/* [unique][uuid][object][local] */ 


EXTERN_C const IID IID_IAImmFnDocFeed;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6e098993-9577-499a-a830-52344f3e200d")
    IAImmFnDocFeed : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE DocFeed( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ClearDocFeedBuffer( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartReconvert( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE StartUndoCompositionString( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAImmFnDocFeedVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IAImmFnDocFeed * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IAImmFnDocFeed * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *DocFeed )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *ClearDocFeedBuffer )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartReconvert )( 
            IAImmFnDocFeed * This);
        
        HRESULT ( STDMETHODCALLTYPE *StartUndoCompositionString )( 
            IAImmFnDocFeed * This);
        
        END_INTERFACE
    } IAImmFnDocFeedVtbl;

    interface IAImmFnDocFeed
    {
        CONST_VTBL struct IAImmFnDocFeedVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAImmFnDocFeed_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAImmFnDocFeed_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAImmFnDocFeed_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAImmFnDocFeed_DocFeed(This)	\
    (This)->lpVtbl -> DocFeed(This)

#define IAImmFnDocFeed_ClearDocFeedBuffer(This)	\
    (This)->lpVtbl -> ClearDocFeedBuffer(This)

#define IAImmFnDocFeed_StartReconvert(This)	\
    (This)->lpVtbl -> StartReconvert(This)

#define IAImmFnDocFeed_StartUndoCompositionString(This)	\
    (This)->lpVtbl -> StartUndoCompositionString(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_DocFeed_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_DocFeed_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_ClearDocFeedBuffer_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_ClearDocFeedBuffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_StartReconvert_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_StartReconvert_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAImmFnDocFeed_StartUndoCompositionString_Proxy( 
    IAImmFnDocFeed * This);


void __RPC_STUB IAImmFnDocFeed_StartUndoCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAImmFnDocFeed_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\windows\richedit\re41\aimm.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for aimm.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __aimm_h__
#define __aimm_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IEnumInputContext_FWD_DEFINED__
#define __IEnumInputContext_FWD_DEFINED__
typedef interface IEnumInputContext IEnumInputContext;
#endif 	/* __IEnumInputContext_FWD_DEFINED__ */


#ifndef __IActiveIMMRegistrar_FWD_DEFINED__
#define __IActiveIMMRegistrar_FWD_DEFINED__
typedef interface IActiveIMMRegistrar IActiveIMMRegistrar;
#endif 	/* __IActiveIMMRegistrar_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


#ifndef __IActiveIMMIME_FWD_DEFINED__
#define __IActiveIMMIME_FWD_DEFINED__
typedef interface IActiveIMMIME IActiveIMMIME;
#endif 	/* __IActiveIMMIME_FWD_DEFINED__ */


#ifndef __IActiveIME_FWD_DEFINED__
#define __IActiveIME_FWD_DEFINED__
typedef interface IActiveIME IActiveIME;
#endif 	/* __IActiveIME_FWD_DEFINED__ */


#ifndef __IActiveIME2_FWD_DEFINED__
#define __IActiveIME2_FWD_DEFINED__
typedef interface IActiveIME2 IActiveIME2;
#endif 	/* __IActiveIME2_FWD_DEFINED__ */


#ifndef __CActiveIMM_FWD_DEFINED__
#define __CActiveIMM_FWD_DEFINED__

#ifdef __cplusplus
typedef class CActiveIMM CActiveIMM;
#else
typedef struct CActiveIMM CActiveIMM;
#endif /* __cplusplus */

#endif 	/* __CActiveIMM_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_aimm_0000 */
/* [local] */ 

//=--------------------------------------------------------------------------=
// aimm.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM Interfaces.




extern RPC_IF_HANDLE __MIDL_itf_aimm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimm_0000_v0_0_s_ifspec;


#ifndef __ActiveIMM_LIBRARY_DEFINED__
#define __ActiveIMM_LIBRARY_DEFINED__

/* library ActiveIMM */
/* [version][lcid][helpstring][uuid] */ 

#ifndef _IMM_
#error Must include imm.h!
#endif
#if 0
typedef WORD LANGID;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    } 	REGISTERWORDA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    } 	REGISTERWORDW;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    } 	LOGFONTA;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    } 	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	CANDIDATEFORM;

typedef /* [public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    } 	COMPOSITIONFORM;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    } 	CANDIDATELIST;

typedef /* [public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    } 	STYLEBUFA;

typedef /* [public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    } 	STYLEBUFW;

typedef WORD ATOM;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0010
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    CHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOA;

typedef /* [public][public][public][public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0011
    {
    UINT cbSize;
    UINT fType;
    UINT fState;
    UINT wID;
    HBITMAP hbmpChecked;
    HBITMAP hbmpUnchecked;
    DWORD dwItemData;
    WCHAR szString[ 80 ];
    HBITMAP hbmpItem;
    } 	IMEMENUITEMINFOW;

#endif
#ifndef _DDKIMM_H_
typedef /* [public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0012
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        } 	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    } 	INPUTCONTEXT;

typedef /* [public][public] */ struct __MIDL___MIDL_itf_aimm_0000_0014
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    } 	IMEINFO;

#endif

EXTERN_C const IID LIBID_ActiveIMM;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/* interface IEnumRegisterWordA */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordA **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordA * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordA * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordA * This,
            /* [out] */ IEnumRegisterWordA **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordA * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordA * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Clone_Proxy( 
    IEnumRegisterWordA * This,
    /* [out] */ IEnumRegisterWordA **ppEnum);


void __RPC_STUB IEnumRegisterWordA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Next_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDA *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordA_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Reset_Proxy( 
    IEnumRegisterWordA * This);


void __RPC_STUB IEnumRegisterWordA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Skip_Proxy( 
    IEnumRegisterWordA * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/* interface IEnumRegisterWordW */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordW **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumRegisterWordW * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumRegisterWordW * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumRegisterWordW * This,
            /* [out] */ IEnumRegisterWordW **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW *rgRegisterWord,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumRegisterWordW * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumRegisterWordW * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Clone_Proxy( 
    IEnumRegisterWordW * This,
    /* [out] */ IEnumRegisterWordW **ppEnum);


void __RPC_STUB IEnumRegisterWordW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Next_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDW *rgRegisterWord,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumRegisterWordW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Reset_Proxy( 
    IEnumRegisterWordW * This);


void __RPC_STUB IEnumRegisterWordW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Skip_Proxy( 
    IEnumRegisterWordW * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IEnumInputContext_INTERFACE_DEFINED__
#define __IEnumInputContext_INTERFACE_DEFINED__

/* interface IEnumInputContext */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IEnumInputContext;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("09b5eab0-f997-11d1-93d4-0060b067b86e")
    IEnumInputContext : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumInputContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IEnumInputContext * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IEnumInputContext * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IEnumInputContext * This,
            /* [out] */ IEnumInputContext **ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ HIMC *rgInputContext,
            /* [out] */ ULONG *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IEnumInputContext * This);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IEnumInputContext * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumInputContextVtbl;

    interface IEnumInputContext
    {
        CONST_VTBL struct IEnumInputContextVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumInputContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumInputContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumInputContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumInputContext_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumInputContext_Next(This,ulCount,rgInputContext,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgInputContext,pcFetched)

#define IEnumInputContext_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumInputContext_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumInputContext_Clone_Proxy( 
    IEnumInputContext * This,
    /* [out] */ IEnumInputContext **ppEnum);


void __RPC_STUB IEnumInputContext_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Next_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ HIMC *rgInputContext,
    /* [out] */ ULONG *pcFetched);


void __RPC_STUB IEnumInputContext_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Reset_Proxy( 
    IEnumInputContext * This);


void __RPC_STUB IEnumInputContext_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumInputContext_Skip_Proxy( 
    IEnumInputContext * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumInputContext_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumInputContext_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMRegistrar_INTERFACE_DEFINED__
#define __IActiveIMMRegistrar_INTERFACE_DEFINED__

/* interface IActiveIMMRegistrar */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b3458082-bd00-11d1-939b-0060b067b86e")
    IActiveIMMRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterIME( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ LPCWSTR pszIconFile,
            /* [in] */ LPCWSTR pszDesc) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterIME( 
            /* [in] */ REFCLSID rclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMRegistrar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMRegistrar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMRegistrar * This);
        
        HRESULT ( STDMETHODCALLTYPE *RegisterIME )( 
            IActiveIMMRegistrar * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ LANGID lgid,
            /* [in] */ LPCWSTR pszIconFile,
            /* [in] */ LPCWSTR pszDesc);
        
        HRESULT ( STDMETHODCALLTYPE *UnregisterIME )( 
            IActiveIMMRegistrar * This,
            /* [in] */ REFCLSID rclsid);
        
        END_INTERFACE
    } IActiveIMMRegistrarVtbl;

    interface IActiveIMMRegistrar
    {
        CONST_VTBL struct IActiveIMMRegistrarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMRegistrar_RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)	\
    (This)->lpVtbl -> RegisterIME(This,rclsid,lgid,pszIconFile,pszDesc)

#define IActiveIMMRegistrar_UnregisterIME(This,rclsid)	\
    (This)->lpVtbl -> UnregisterIME(This,rclsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMRegistrar_RegisterIME_Proxy( 
    IActiveIMMRegistrar * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ LANGID lgid,
    /* [in] */ LPCWSTR pszIconFile,
    /* [in] */ LPCWSTR pszDesc);


void __RPC_STUB IActiveIMMRegistrar_RegisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMRegistrar_UnregisterIME_Proxy( 
    IActiveIMMRegistrar * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IActiveIMMRegistrar_UnregisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMRegistrar_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/* interface IActiveIMMMessagePumpOwner */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ const MSG *pMsg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Pause( 
            /* [out] */ DWORD *pdwCookie) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resume( 
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMMessagePumpOwner * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *Start )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *End )( 
            IActiveIMMMessagePumpOwner * This);
        
        HRESULT ( STDMETHODCALLTYPE *OnTranslateMessage )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ const MSG *pMsg);
        
        HRESULT ( STDMETHODCALLTYPE *Pause )( 
            IActiveIMMMessagePumpOwner * This,
            /* [out] */ DWORD *pdwCookie);
        
        HRESULT ( STDMETHODCALLTYPE *Resume )( 
            IActiveIMMMessagePumpOwner * This,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMMessagePumpOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMMessagePumpOwner_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IActiveIMMMessagePumpOwner_End(This)	\
    (This)->lpVtbl -> End(This)

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    (This)->lpVtbl -> OnTranslateMessage(This,pMsg)

#define IActiveIMMMessagePumpOwner_Pause(This,pdwCookie)	\
    (This)->lpVtbl -> Pause(This,pdwCookie)

#define IActiveIMMMessagePumpOwner_Resume(This,dwCookie)	\
    (This)->lpVtbl -> Resume(This,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Start_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_End_Proxy( 
    IActiveIMMMessagePumpOwner * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_OnTranslateMessage_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ const MSG *pMsg);


void __RPC_STUB IActiveIMMMessagePumpOwner_OnTranslateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Pause_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [out] */ DWORD *pdwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Pause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Resume_Proxy( 
    IActiveIMMMessagePumpOwner * This,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IActiveIMMMessagePumpOwner_Resume_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/* interface IActiveIMMApp */
/* [unique][uuid][object] */ 


EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ ATOM *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE AssociateContextEx( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DisableIME( 
            /* [in] */ DWORD idThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOA *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOA *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetImeMenuItemsW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwType,
            /* [in] */ IMEMENUITEMINFOW *pImeParentMenu,
            /* [out] */ IMEMENUITEMINFOW *pImeMenu,
            /* [in] */ DWORD dwSize,
            /* [out] */ DWORD *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumInputContext( 
            /* [in] */ DWORD idThread,
            /* [out] */ IEnumInputContext **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IActiveIMMApp * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IActiveIMMApp * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IActiveIMMApp * This);
        
        HRESULT ( STDMETHODCALLTYPE *AssociateContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA *pData);
        
        HRESULT ( STDMETHODCALLTYPE *ConfigureIMEW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW *pData);
        
        HRESULT ( STDMETHODCALLTYPE *CreateContext )( 
            IActiveIMMApp * This,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *DestroyContext )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EnumRegisterWordW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW **pEnum);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *EscapeW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT *plResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST *pCandList,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateListCountW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pdwListSize,
            /* [out] */ DWORD *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE *GetCandidateWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionFontW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW *plf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionStringW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE *GetCompositionWindow )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE *GetContext )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionListW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST *pDst,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetConversionStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD *pfdwConversion,
            /* [out] */ DWORD *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE *GetDefaultIMEWnd )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetDescriptionW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineA )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetGuideLineW )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetIMEFileNameW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetOpenStatus )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE *GetProperty )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleA )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetRegisterWordStyleW )( 
            IActiveIMMApp * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW *pStyleBuf,
            /* [out] */ UINT *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE *GetStatusWindowPos )( 
            IActiveIMMApp * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE *GetVirtualKey )( 
            IActiveIMMApp * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE *InstallIMEA )( 
           