   // at top-level.
            if (fShell && GetUIVersion() < 5) {
                DeleteMenu(hmenuView, FCIDM_MENU_EXPLORE, MF_BYCOMMAND);
            }
        }

        // Folder Options requires integrated shell
        if (fShell && WhichPlatform() != PLATFORM_INTEGRATED)
        {
            if (hmenuView)
            {
                _EnableMenuItem(hmenuView, FCIDM_BROWSEROPTIONS, FALSE);
            }
            HMENU hmenuTools = SHGetMenuFromID(hmenu, FCIDM_MENU_TOOLS);
            if (hmenuTools)
            {
                _EnableMenuItem(hmenuTools, FCIDM_BROWSEROPTIONS, FALSE);
            }
        }
    }

    return hmenu;
}

// Determine if we need to add the Fortezza menu
// For perf reasons, do not call this function unless user is 
// browsing outside the local machine--- it will load WININET
bool NeedFortezzaMenu()
{
    static bool fChecked = false,
                fNeed = false;
    
    // Never show the Fortezza option when offline
    if (SHIsGlobalOffline())
        return false;
    else if (fChecked)
        return fNeed;
    else
    {
        fChecked = true;
        DWORD  fStatus  = 0;
        BOOL   fQuery   = InternetQueryFortezzaStatus(&fStatus, 0);
        return (fNeed = fQuery && (fStatus&FORTSTAT_INSTALLED));
    }
}

// Create and return the Fortezza menu
HMENU FortezzaMenu()
{
    HMENU hfm = NULL;

    static TCHAR  szLogInItem[32]   = TEXT(""), // Initialize to empty strings
                  szLogOutItem[32]  = TEXT(""), 
                  szChangeItem[32]  = TEXT("");
    static bool   fInit = false;

    if (!fInit)             // Load the strings only once
    {
        MLLoadString(IDS_FORTEZZA_LOGIN, szLogInItem, ARRAYSIZE(szLogInItem)-1);
        MLLoadString(IDS_FORTEZZA_LOGOUT, szLogOutItem, ARRAYSIZE(szLogOutItem)-1);
        MLLoadString(IDS_FORTEZZA_CHANGE, szChangeItem, ARRAYSIZE(szChangeItem)-1);
        fInit = true;
    }
    
    if (hfm = CreatePopupMenu())
    {
        AppendMenu(hfm, MF_STRING, FCIDM_FORTEZZA_LOGIN, szLogInItem);
        AppendMenu(hfm, MF_STRING, FCIDM_FORTEZZA_LOGOUT, szLogOutItem);
        AppendMenu(hfm, MF_STRING, FCIDM_FORTEZZA_CHANGE, szChangeItem);
    }
    return hfm;
}

// Configure the menu depending on card state
// This function is called only if Fortezza has been detected
void SetFortezzaMenu(HMENU hfm)
{
    if (hfm==NULL)
        return;

    DWORD fStatus = 0;
    if (InternetQueryFortezzaStatus(&fStatus, 0))
    {
        // If the query succeeds, the items are enabled depending
        // on whether the user is logged in to Fortezza.
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_CHANGE, (fStatus&FORTSTAT_LOGGEDON) ? TRUE  : FALSE);
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_LOGIN,  (fStatus&FORTSTAT_LOGGEDON) ? FALSE : TRUE);
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_LOGOUT, (fStatus&FORTSTAT_LOGGEDON) ? TRUE  : FALSE);
    }
    else
    {
        // If the query fails, all items are grayed out.
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_CHANGE, FALSE);
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_LOGIN, FALSE);
        _EnableMenuItem(hfm, FCIDM_FORTEZZA_LOGOUT, FALSE);
    }
    return;
}

DWORD DoNetConnect(HWND hwnd)
{
    return (DWORD)SHStartNetConnectionDialog(NULL, NULL, RESOURCETYPE_DISK);
}

DWORD DoNetDisconnect(HWND hwnd)
{
    DWORD ret = WNetDisconnectDialog(NULL, RESOURCETYPE_DISK);

    SHChangeNotifyHandleEvents();       // flush any drive notifications

    TraceMsg(DM_TRACE, "shell:CNet - TRACE: DisconnectDialog returned (%lx)", ret);
    if (ret == WN_EXTENDED_ERROR)
    {
        // FEATURE: is this still needed
        // There has been a bug with this returning this but then still
        // doing the disconnect.  For now lets bring up a message and then
        // still do the notify to have the shell attempt to cleanup.
        TCHAR szErrorMsg[MAX_PATH];  // should be big enough
        TCHAR szName[80];            // The name better not be any bigger.
        DWORD dwError;
        WNetGetLastError(&dwError, szErrorMsg, ARRAYSIZE(szErrorMsg),
                szName, ARRAYSIZE(szName));

        MLShellMessageBox(NULL,
               MAKEINTRESOURCE(IDS_NETERROR), MAKEINTRESOURCE(IDS_DISCONNECTERROR),
               MB_ICONHAND | MB_OK, dwError, szName, szErrorMsg);
    }

    // FEATURE: deal with error, perhaps open a window on this drive
    return ret;
}



CShellBrowser2::CShellBrowser2() :
#ifdef NO_MARSHALLING
        _fDelayedClose(FALSE),
        _fOnIEThread(TRUE),
#endif
        _fStatusBar(TRUE),
        _fShowMenu(TRUE),
        _fValidComCatCache(FALSE),
        _fShowSynchronize(TRUE),
        _iSynchronizePos(-1),
        CSBSUPERCLASS(NULL)
{
    // warning: can't call SUPERCLASS until _Initialize has been called
    // (since that's what does the aggregation)

    ASSERT(IsEqualCLSID(_clsidThis, CLSID_NULL));
    ASSERT(_hwndDummyTB == NULL);
}
#pragma warning(default:4355)  // using 'this' in constructor

HRESULT CShellBrowser2::_Initialize(HWND hwnd, IUnknown *pauto)
{
    HRESULT hr;
    SHELLSTATE ss = {0};

    hr = SUPERCLASS::_Initialize(hwnd, pauto);
    if (SUCCEEDED(hr)) {
        SetTopBrowser();
        int i = _AllocToolbarItem();
        ASSERT(i == ITB_ITBAR);
        _GetToolbarItem(ITB_ITBAR)->fShow = TRUE;
        _put_itbLastFocus(ITB_VIEW);
        InitializeDownloadManager();
        _nTBTextRows = -1;
        
        SHGetSetSettings(&ss, SSF_MAPNETDRVBUTTON, FALSE);
        _fShowNetworkButtons = ss.fMapNetDrvBtn;

        // Initialize the base class transition site pointer.
        InitializeTransitionSite();

        // Invalidate icon cache in case non-IE browser took over .htm icons.
        IEInvalidateImageList();
        _UpdateRegFlags();
        
        _nMBIgnoreNextDeselect = RegisterWindowMessage(TEXT("CMBIgnoreNextDeselect"));

        _fShowFortezza = FALSE;
        _hfm = NULL;
    }

    return hr;
}

HRESULT CShellBrowser2_CreateInstance(HWND hwnd, void **ppsb)
{
    CShellBrowser2 *psb = new CShellBrowser2();
    if (psb)
    {
        HRESULT hr = psb->_Initialize(hwnd, NULL);      // aggregation, etc.
        if (FAILED(hr)) {
            ASSERT(0);    // shouldn't happen
            ATOMICRELEASE(psb);
        }
        *ppsb = (void *)psb;
        return hr;
    }
    return E_OUTOFMEMORY;
}

CShellBrowser2::~CShellBrowser2()
{
    _TheaterMode(FALSE, FALSE);

    if (IsWindow(_hwndDummyTB))
        DestroyWindow(_hwndDummyTB);
    
    // If automation was enabled, kill it now
    ATOMICRELEASE(_pbsmInfo);
    ATOMICRELEASE(_poctNsc);
    ATOMICRELEASE(_pcmNsc);
    ATOMICRELEASE(_pism);
    ATOMICRELEASE(_pizm);
    ATOMICRELEASE(_pcmSearch);
    ASSERT(0 == _punkMsgLoop);
    
    ILFree(_pidlLastHist);

    if (_hmenuPreMerged)
        DestroyMenu(_hmenuPreMerged);

    if (_hmenuTemplate)
        DestroyMenu(_hmenuTemplate);

    if (_hmenuFull)
        DestroyMenu(_hmenuFull);

    if (_hfm)
        DestroyMenu(_hfm);

    if (_lpPendingButtons)
        LocalFree(_lpPendingButtons);

    if (_lpButtons)
        LocalFree(_lpButtons);

    if (_hZoneIcon)
        DestroyIcon(_hZoneIcon);

    Str_SetPtr(&_pszSynchronizeText, NULL);

    if (_hEventComCat)
        CloseHandle(_hEventComCat);

    TraceMsg(TF_SHDLIFE, "dtor CShellBrowser2 %x", this);
}

void CShellBrowser2::v_FillCabStateHeader(CABSH* pcabsh, FOLDERSETTINGS* pfs)
{
    WINDOWPLACEMENT wp;
    OLECMD rgCmds[3] = {0};

    LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
    if (ptbi)
    {
        rgCmds[0].cmdID = CITIDM_VIEWTOOLS;
        rgCmds[1].cmdID = CITIDM_VIEWADDRESS;
        rgCmds[2].cmdID = CITIDM_VIEWLINKS;

        IUnknown_QueryStatus(ptbi->ptbar, &CGID_PrivCITCommands, ARRAYSIZE(rgCmds), rgCmds, NULL);
    }

    pcabsh->wv.bStdButtons = BOOLIFY(rgCmds[0].cmdf);
    pcabsh->wv.bAddress = BOOLIFY(rgCmds[1].cmdf);
    pcabsh->wv.bLinks = BOOLIFY(rgCmds[2].cmdf);    
    pcabsh->wv.bStatusBar = _fStatusBar;

    wp.length = sizeof(WINDOWPLACEMENT);
    GetWindowPlacement(_pbbd->_hwnd, &wp);

    pcabsh->dwHotkey = (UINT)SendMessage(_pbbd->_hwnd, WM_GETHOTKEY, 0, 0);

    //
    // Now Lets convert all of this common stuff into a
    // non 16/32 bit dependant data structure, such that both
    // can us it.
    //
    pcabsh->dwSize = sizeof(*pcabsh);
    pcabsh->flags = wp.flags;

    // 99/05/26 #345915 vtan: Don't mess with this. It's BY DESIGN.
    // #169839 caused #345915. When a window is minimized and closed
    // it should NEVER be opened minimized. The code that was here
    // has now caused a one month period where persistence of window
    // placement can be with SW_SHOWMINIMIZED which will cause the
    // window to restore minimized. This will go away when the window
    // is next closed.

    if ((wp.showCmd == SW_SHOWMINIMIZED) || (wp.showCmd == SW_MINIMIZE))
        pcabsh->showCmd = SW_SHOWNORMAL;
    else
        pcabsh->showCmd = wp.showCmd;

    pcabsh->ptMinPosition.x = wp.ptMinPosition.x;
    pcabsh->ptMinPosition.y = wp.ptMinPosition.y;
    pcabsh->ptMaxPosition.x = wp.ptMaxPosition.x;
    pcabsh->ptMaxPosition.y = wp.ptMaxPosition.y;

    pcabsh->rcNormalPosition = *((RECTL*)&wp.rcNormalPosition);

    // Now the folder settings
    pcabsh->ViewMode = pfs->ViewMode;
    // NB Don't ever preserve the best-fit flag or the nosubfolders flag.
    pcabsh->fFlags = pfs->fFlags & ~FWF_NOSUBFOLDERS & ~FWF_BESTFITWINDOW;

    pcabsh->fMask = CABSHM_VERSION;
    pcabsh->dwVersionId = CABSH_VER;

}

BOOL CShellBrowser2::_GetVID(SHELLVIEWID *pvid)
{
    BOOL bGotVID = FALSE;

    if (_pbbd->_psv && pvid) 
    {
        IShellView2 *psv2;
        
        if (SUCCEEDED(_pbbd->_psv->QueryInterface(IID_PPV_ARG(IShellView2, &psv2))))
        {
            if (S_OK == psv2->GetView(pvid, SV2GV_CURRENTVIEW))
            {
                bGotVID = TRUE;
            }
        
           psv2->Release();
        }
    }
    return bGotVID;
}

HRESULT CShellBrowser2::SetAsDefFolderSettings()
{
    HRESULT hres;

    if (_pbbd->_psv) 
    {
        SHELLVIEWID  vid;
        BOOL bGotVID = _GetVID(&vid);
        FOLDERSETTINGS fs;

        _pbbd->_psv->GetCurrentInfo(&fs);

        CABINETSTATE cs;
        GetCabState(&cs);

        if (cs.fNewWindowMode)
            g_dfs.bDefToolBarMulti = FALSE;
        else
            g_dfs.bDefToolBarSingle = FALSE;
        
        g_dfs.fFlags = fs.fFlags & (FWF_AUTOARRANGE); // choose the ones we case about
        g_dfs.uDefViewMode = fs.ViewMode;
        g_dfs.bDefStatusBar = _fStatusBar;
        
        g_dfs.bUseVID = bGotVID;
        if (bGotVID)
        {
            g_dfs.vid = vid;
        }
        else
        {
            ViewIDFromViewMode(g_dfs.uDefViewMode, &g_dfs.vid);
        }
        g_dfs.dwViewPriority = VIEW_PRIORITY_USEASDEFAULT;

        SaveDefaultFolderSettings(GFSS_SETASDEFAULT);

//  99/02/10 #226140 vtan: Get DefView to set default view

        IUnknown_Exec(_pbbd->_psv, &CGID_DefView, DVID_SETASDEFAULT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);

        hres = S_OK;
    } else {
        hres = E_FAIL;
    }

    return hres;
}

//---------------------------------------------------------------------------
// Closing a cabinet window.
//
// save it's local view info in the directory it is looking at
//
// NOTE: this will fail on read only media like net or cdrom
//
// REVIEW: we may not want to save this info on removable media
// (but if we don't allow a switch to force this!)
//
void CShellBrowser2::_SaveState()
{
    CABINETSTATE cs;
    GetCabState(&cs);

    // Don't save any state info if restrictions are in place.

    // We are trying to give a way for automation scripts to run that do not
    // update the view state.  To handle this we say if the window is not visible
    // (the script can set or unset visibility) than do not save the state (unless
    // falways add...)
    // Notwithstanding the above comments, suppress updating view state if UI
    // was set by automation
    if (_fUISetByAutomation ||
        !cs.fSaveLocalView ||
        SHRestricted(REST_NOSAVESET) || !IsWindowVisible(_pbbd->_hwnd) || _ptheater)
        return;

    if (_pbbd->_psv)
    {
        // Only save state if we close the browser in the same mode (either IE or Explorer)
        // that we started in.
        if (BOOLIFY(_IsPageInternet(_GetPidl())) == BOOLIFY(_fInternetStart))
        {
            if (IsOS(OS_WHISTLERORGREATER))
            {
                _PropertyBagSaveState();
            }
            else
            {
                _OldSaveState();
            }
        }
    }
}

void CShellBrowser2::_PropertyBagSaveState()
{
    FOLDERSETTINGS fs;
    _pbbd->_psv->GetCurrentInfo(&fs);

    CABSH cabsh;
    v_FillCabStateHeader(&cabsh, &fs);

    IPropertyBag* ppb;
    if (SUCCEEDED(GetPropertyBag(SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
    {
        SHPropertyBag_WritePOINTLScreenRes(ppb, VS_PROPSTR_MINPOS, &cabsh.ptMinPosition);
        SHPropertyBag_WritePOINTLScreenRes(ppb, VS_PROPSTR_MAXPOS, &cabsh.ptMaxPosition);
        SHPropertyBag_WriteRECTLScreenRes(ppb, VS_PROPSTR_POS, &cabsh.rcNormalPosition);

        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_REV, _dwRevCount);
        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_WPFLAGS, cabsh.flags);
        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_SHOW, cabsh.showCmd);
        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_FFLAGS, cabsh.fFlags);
        SHPropertyBag_WriteDWORD(ppb, VS_PROPSTR_HOTKEY, cabsh.dwHotkey);
        SHPropertyBag_WriteBOOL(ppb, VS_PROPSTR_BUTTONS, cabsh.wv.bStdButtons);
        SHPropertyBag_WriteBOOL(ppb, VS_PROPSTR_STATUS, cabsh.wv.bStatusBar);
        SHPropertyBag_WriteBOOL(ppb, VS_PROPSTR_LINKS, cabsh.wv.bLinks);
        SHPropertyBag_WriteBOOL(ppb, VS_PROPSTR_ADDRESS, cabsh.wv.bAddress);

        SHELLVIEWID  vid;
        if (_GetVID(&vid))
        {
            SHPropertyBag_WriteGUID(ppb, VS_PROPSTR_VID, &vid);
        }
        else
        {
            SHPropertyBag_Delete(ppb, VS_PROPSTR_VID);
        }

        ppb->Release();
    }
}

void CShellBrowser2::_OldSaveState()
{
    WINDOWPLACEMENT     currentWindowPlacement;
    WINVIEW             winView;

    currentWindowPlacement.length = 0;

    // if these keys are down, save the current states
    if (IsCShellBrowser2()  &&
        GetAsyncKeyState(VK_CONTROL) < 0) 
    {
       SetAsDefFolderSettings();
    }

    // Now get the view information
    FOLDERSETTINGS fs;
    _pbbd->_psv->GetCurrentInfo(&fs);


    IStream* pstm = NULL;

    // 99/05/07 #291358 vtan: Temporary solution to a problem dating back to IE4 days.

    // Here's where the window frame state if saved. This also saves the FOLDERSETTINGS
    // view information. Ideally it's best to separate the two but it seems reasonable
    // to only save frame state if this is the initial navigation. Once navigated away
    // only save view information and preserve the current frame state by reading what's
    // there and copying it. If there's no frame state then use what the current frame
    // state is. It could be possible to write out an empty frame state but if this
    // state is roamed to a down-level platform it may cause unexpected results.

    if (_fSBWSaved)
    {
        IStream     *pIStream;
        CABSH       cabinetStateHeader;

        pIStream = v_GetViewStream(_pbbd->_pidlCur, STGM_READ, L"CabView");
        if (pIStream != NULL)
        {
            if (SUCCEEDED(_FillCabinetStateHeader(pIStream, &cabinetStateHeader)))
            {

                // If an old frame state exists then save it and mark it as valid.

                currentWindowPlacement.length = sizeof(currentWindowPlacement);
                currentWindowPlacement.flags = cabinetStateHeader.flags;
                currentWindowPlacement.showCmd = cabinetStateHeader.showCmd;
                currentWindowPlacement.ptMinPosition = *(reinterpret_cast<POINT*>(&cabinetStateHeader.ptMinPosition));
                currentWindowPlacement.ptMaxPosition = *(reinterpret_cast<POINT*>(&cabinetStateHeader.ptMaxPosition));
                currentWindowPlacement.rcNormalPosition = *(reinterpret_cast<RECT*>(&cabinetStateHeader.rcNormalPosition));
                winView = cabinetStateHeader.wv;
            }
            pIStream->Release();
        }
    }

    if (!(_fSBWSaved && _fWin95ViewState))
    {
        pstm = v_GetViewStream(_pbbd->_pidlCur, STGM_CREATE | STGM_WRITE, L"CabView");
        _fSBWSaved = TRUE;
    }
    if (pstm)
    {
        CABSH cabsh;
        SHELLVIEWID  vid;
        BOOL bGotVID = _GetVID(&vid);

        v_FillCabStateHeader(&cabsh, &fs);

        if (currentWindowPlacement.length == sizeof(currentWindowPlacement))
        {

            // If an old frame state exists then put it back over the current frame state.

            cabsh.flags = currentWindowPlacement.flags;
            cabsh.showCmd = currentWindowPlacement.showCmd;
            cabsh.ptMinPosition = *(reinterpret_cast<POINTL*>(&currentWindowPlacement.ptMinPosition));
            cabsh.ptMaxPosition = *(reinterpret_cast<POINTL*>(&currentWindowPlacement.ptMaxPosition));
            cabsh.rcNormalPosition = *(reinterpret_cast<RECTL*>(&currentWindowPlacement.rcNormalPosition));
            cabsh.wv = winView;
        }

        if (bGotVID)
        {
            cabsh.vid = vid;
            cabsh.fMask |= CABSHM_VIEWID;
        }

        cabsh.fMask |= CABSHM_REVCOUNT;
        cabsh.dwRevCount = _dwRevCount;     // save out the rev count of when we were opened
    
        //
        // First output the common non view specific information
        //
        pstm->Write(&cabsh, sizeof(cabsh), NULL);

        // And release it, which will commit it to disk..
        pstm->Release();

        // NOTE (toddb): The DefView view state is saved by the base class so we don't need
        // to explicitly save it here.  If you do it gets called twice which is wasted time.
        // Do not call _pbbd->_psv->SaveViewState(); from this function.
    }

#ifdef DEBUG
    if (g_dwPrototype & 0x00000010) {
        //
        // Save toolbars
        //
        pstm = v_GetViewStream(_pbbd->_pidlCur, STGM_CREATE | STGM_WRITE, L"Toolbars");
        if (pstm) {
            _SaveToolbars(pstm);
            pstm->Release();
        }
    }
#endif
}

STDAPI_(LPITEMIDLIST) IEGetInternetRootID(void);

IStream *CShellBrowser2::v_GetViewStream(LPCITEMIDLIST pidl, DWORD grfMode, LPCWSTR pwszName)
{
    IStream *pstm = NULL;
    LPITEMIDLIST pidlToFree = NULL;
    BOOL    bCabView = (0 == StrCmpIW(pwszName, L"CabView"));
    
    if (((NULL == pidl) && IsEqualCLSID(_clsidThis, CLSID_InternetExplorer)) ||
        IsBrowserFrameOptionsPidlSet(pidl, BFO_BROWSER_PERSIST_SETTINGS))
    {
        //  If this is a child of the URL or we're looking at an unititialized IE frame,
        //  then save all in the IE stream
        pidlToFree = IEGetInternetRootID();
        pidl = pidlToFree;
    }
    else if (bCabView && _fNilViewStream)
    {
        // if we loaded cabview settings from the 'unknown pidl' view stream,
        // we've got to stick with it, whether or not we now have a pidl.
        pidl = NULL; 
    }
   
    if (pidl)
    {
        pstm = SHGetViewStream(pidl, grfMode, pwszName, REGSTR_KEY_STREAMMRU, REGVALUE_STREAMS);
    }
    else if (bCabView)
    {
        //  So we don't have a pidl for which to grab a stream, so we'll just
        //  make up a stream to cover the situation.   A hack no doubt, but before we 
        //  were handling this case by always loading from the IE stream. (doh!)
        
        //  Actually, the whole thing is busted because we're
        //  creating the window (and trying to restore the windowpos) as part of
        //  CoCreateInstance(), before the client can navigate the browser.
        pstm = OpenRegStream(HKEY_CURRENT_USER, 
                              REGSTR_PATH_EXPLORER TEXT("\\Streams\\<nil>"), 
                              TEXT("CabView"), 
                              grfMode);
        _fNilViewStream = TRUE; // cabview settings initialized from the 'unknown pidl' view stream.
    }
    ILFree(pidlToFree);
    return pstm;
}
 
HRESULT CShellBrowser2::_FillCabinetStateHeader (IStream *pIStream, CABSH *cabsh)

{
    HRESULT hResult;

    // Now read in the state from the stream file.
    // read the old header first.

    hResult = IStream_Read(pIStream, cabsh, sizeof(CABSHOLD));

    // Sanity test to make the structure is sane

    if (FAILED(hResult) || (cabsh->dwSize < sizeof(CABSHOLD)))
        hResult = E_OUTOFMEMORY;        // bogus but good enough

    // Read the remainder of the structure if we can.  If not, then
    // set the mask equal to zero so we don't get confused later.

    if (cabsh->dwSize < sizeof(CABSH) ||
        FAILED(IStream_Read(pIStream, ((LPBYTE)cabsh) + sizeof(CABSHOLD), sizeof(CABSH) - sizeof(CABSHOLD))))
    {
        cabsh->fMask = 0;
    }
    return(hResult);
}

BOOL CShellBrowser2::_ReadSettingsFromPropertyBag(IPropertyBag* ppb, IETHREADPARAM *piei)
{
    BOOL fRet;

    CABSH cabsh = {0};
    cabsh.dwSize = sizeof(cabsh);
    cabsh.fMask = CABSHM_VERSION;
    cabsh.dwVersionId = CABSH_VER;

    if (SUCCEEDED(SHPropertyBag_ReadDWORD(ppb, VS_PROPSTR_WPFLAGS, &cabsh.flags)))
    {
        if (FAILED(SHPropertyBag_ReadPOINTLScreenRes(ppb, VS_PROPSTR_MINPOS, &cabsh.ptMinPosition)))
        {
            cabsh.ptMinPosition.x = cabsh.ptMinPosition.y = -1;
        }

        if (FAILED(SHPropertyBag_ReadPOINTLScreenRes(ppb, VS_PROPSTR_MAXPOS, &cabsh.ptMaxPosition)))
        {
            cabsh.ptMaxPosition.x = cabsh.ptMaxPosition.y = -1;
        }

        if (FAILED(SHPropertyBag_ReadRECTLScreenRes(ppb, VS_PROPSTR_POS, &cabsh.rcNormalPosition)))
        {
            cabsh.rcNormalPosition.left = cabsh.rcNormalPosition.top = cabsh.rcNormalPosition.right = cabsh.rcNormalPosition.bottom = CW_USEDEFAULT;
        }

        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_MODE, &cabsh.ViewMode, FVM_TILE);
        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_SHOW, &cabsh.showCmd, 0);
        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_FFLAGS, &cabsh.fFlags, FWF_BESTFITWINDOW | g_dfs.fFlags);
        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_HOTKEY, &cabsh.dwHotkey, 0);

        cabsh.wv.bStdButtons = SHPropertyBag_ReadBOOLDefRet(ppb, VS_PROPSTR_BUTTONS, TRUE);
        cabsh.wv.bStatusBar = SHPropertyBag_ReadBOOLDefRet(ppb, VS_PROPSTR_STATUS, TRUE);
        cabsh.wv.bLinks = SHPropertyBag_ReadBOOLDefRet(ppb, VS_PROPSTR_LINKS, TRUE);
        cabsh.wv.bAddress = SHPropertyBag_ReadBOOLDefRet(ppb, VS_PROPSTR_ADDRESS, TRUE);

        cabsh.fMask |= CABSHM_REVCOUNT;
        SHPropertyBag_ReadDWORDDef(ppb, VS_PROPSTR_REV, &cabsh.dwRevCount, g_dfs.dwDefRevCount);

        if (SUCCEEDED(SHPropertyBag_ReadGUID(ppb, VS_PROPSTR_VID, &cabsh.vid)))
        {
            cabsh.fMask |= CABSHM_VIEWID;
        }

        fRet = _FillIEThreadParamFromCabsh(&cabsh, piei);
    }
    else
    {
        fRet = FALSE;
    }

    return fRet;
}

BOOL CShellBrowser2::_FillIEThreadParamFromCabsh(CABSH* pcabsh, IETHREADPARAM *piei)
{
    BOOL fUpgradeToWebView = FALSE;
    bool bInvalidWindowPlacement;

    // Now extract the data and put it into appropriate structures

    // first the window placement info
    piei->wp.length = sizeof(piei->wp);
    piei->wp.flags = (UINT)pcabsh->flags;
    piei->wp.showCmd = (UINT)pcabsh->showCmd;
    
    ASSERT(sizeof(piei->wp.ptMinPosition) == sizeof(pcabsh->ptMinPosition));
    piei->wp.ptMinPosition = *((LPPOINT)&pcabsh->ptMinPosition);
    piei->wp.ptMaxPosition = *((LPPOINT)&pcabsh->ptMaxPosition);

    ASSERT(sizeof(piei->wp.rcNormalPosition) == sizeof(pcabsh->rcNormalPosition));
    piei->wp.rcNormalPosition = *((RECT*)&pcabsh->rcNormalPosition);

    // Do some simple sanity checks to make sure that the returned
    // information appears to be reasonable and not random garbage
    // We want the Show command to be normal or minimize or maximize.
    // Only need one test as they are consectutive and start at zero
    // DON'T try to validate too much of the WINDOWPLACEMENT--
    // SetWindowPlacement does a much better job, especially in
    // multiple-monitor scenarios...

    // 99/03/09 #303300 vtan: Sanity check for zero/negative width or
    // height. SetWindowPlacement doesn't sanity check for this -
    // only for whether the rectangle left and top are in the visible
    // screen area. If this condition is detected then reset to default
    // and force DefView to best fit the window.

    {
        LONG    lWidth, lHeight;

        lWidth = piei->wp.rcNormalPosition.right - piei->wp.rcNormalPosition.left;
        lHeight = piei->wp.rcNormalPosition.bottom - piei->wp.rcNormalPosition.top;
        bInvalidWindowPlacement = ((lWidth <= 0) || (lHeight <= 0));
        if (bInvalidWindowPlacement)
            piei->wp.length = 0;
    }

    if (piei->wp.showCmd > SW_MAX)
        return FALSE;

    piei->fs.ViewMode = (UINT)pcabsh->ViewMode;
    piei->fs.fFlags = (UINT)pcabsh->fFlags;
    if (pcabsh->fMask & CABSHM_VIEWID)
    {
        // There was code here to revert to large icon mode if fWin95Classic
        // mode was turned on. This is completely busted because fWin95Classic
        // just affects the DEFAULT view, not any PERSISTED view.
        piei->m_vidRestore = pcabsh->vid;
        piei->m_dwViewPriority = VIEW_PRIORITY_CACHEHIT; // we have a cache hit!
    }

    // If there was a revcount, check if we've been overridden by
    // a subsequent "use these settings as the default for all future
    // windows".
    if (pcabsh->fMask & CABSHM_REVCOUNT)
    {
        if (g_dfs.dwDefRevCount != pcabsh->dwRevCount)
        {
            if (g_dfs.bUseVID)
            {
                piei->m_vidRestore = g_dfs.vid;
            }
            else
            {
                ViewIDFromViewMode(g_dfs.uDefViewMode, &(piei->m_vidRestore));
            }
            
            piei->fs.ViewMode  = g_dfs.uDefViewMode;
            piei->fs.fFlags    = g_dfs.fFlags;
            piei->m_dwViewPriority = g_dfs.dwViewPriority;
        }
    }

    _dwRevCount = g_dfs.dwDefRevCount;      // save this with the browser so we can save it out later

    if (!(pcabsh->fMask & CABSHM_VERSION) || (pcabsh->dwVersionId < CABSH_VER))
    {
        SHELLSTATE ss = {0};

        // old version of stream....

        SHGetSetSettings(&ss, SSF_WIN95CLASSIC, FALSE);

        // we have either a cache miss (or an older dwVersionId), or we are restricting to win95 mode,
        // so set the priority accordingly.
        piei->m_dwViewPriority = ss.fWin95Classic ? VIEW_PRIORITY_RESTRICTED : VIEW_PRIORITY_CACHEMISS; 
        
        if (ss.fWin95Classic)
        {
            // Hey, it's a Win95 CABSH structure and we're in Win95 mode,
            // so don't change the defaults!
            ViewIDFromViewMode(pcabsh->ViewMode, &(piei->m_vidRestore));
        }
        else
        {
            // Upgrade scenario:
            //   My Computer in List should wind up in Web View/List
            //   C:\ in List should wind up in List
            // If this fails (C:\ winds up in Large Icon), we can try
            // to comment out this code altogether. Hopefully defview's
            // default view stuff will realize Web View should be
            // selected and My Computer will go to Web View instead
            // of staying in List.
            //
            piei->m_vidRestore = DFS_VID_Default;

            // Note: if we upgrade to web view, we better let the
            // view recalc window space or the window will be TOO SMALL
            fUpgradeToWebView = TRUE;
        }

        if (pcabsh->wv.bStdButtons) // win95 called this bToolbar
        {
            // Win95 called bStdButtons bToolbar. IE4 separates this
            // into bAddress and bStdButtons. Set bAddress for upgrade.
            pcabsh->wv.bAddress = TRUE;

#define RECT_YADJUST    18
            // bump up the rect slightly to account for new toolbar size....
            // 18 is an approximately random number which assumes that the default
            // configuration is a single height toolbar which is approx twice as high as the
            // old toobar....
            //
            // NOTE: old browser streams are always for the primary monitor, so we just
            //       check to see if we are going to fit on the screen. If not, then don't bother.
            //
            // NOTE: when we rev the version number, we'll want to do this
            //       rect adjustment for the CABSH_WIN95_VER version...
            //
            int iMaxYSize = GetSystemMetrics(SM_CYFULLSCREEN);
            if (piei->wp.rcNormalPosition.bottom + piei->wp.rcNormalPosition.top + RECT_YADJUST < iMaxYSize)
            {
                piei->wp.rcNormalPosition.bottom += RECT_YADJUST;
            }
#undef RECT_YADJUST
        }
    }

    // After all that upgrade work, check the classic shell restriction
    if (SHRestricted(REST_CLASSICSHELL))
    {
        // It doesn't matter what vid was specified, use the ViewMode
        ViewIDFromViewMode(pcabsh->ViewMode, &(piei->m_vidRestore));
        piei->m_dwViewPriority = VIEW_PRIORITY_RESTRICTED; // use highest priority because of the restriction.

        // Oops, we can't upgrade...
        fUpgradeToWebView = FALSE;
    }

    // And the Hotkey
    piei->wHotkey = (UINT)pcabsh->dwHotkey;

    piei->wv = pcabsh->wv;

    // if we upgraded to web view, then any persisted window sizes will
    // probably be too small -- let them get resized by the view...
    if (fUpgradeToWebView || bInvalidWindowPlacement)
        piei->fs.fFlags |= FWF_BESTFITWINDOW;
    else
        piei->fs.fFlags &= ~FWF_BESTFITWINDOW;

    return TRUE;
}

BOOL CShellBrowser2::_ReadSettingsFromStream(IStream *pstm, IETHREADPARAM *piei)
{
    BOOL fRet;

    CABSH cabsh;

    if (SUCCEEDED(_FillCabinetStateHeader(pstm, &cabsh)))
    {
        fRet = _FillIEThreadParamFromCabsh(&cabsh, piei);
    }
    else
    {
        fRet = FALSE;
    }
     
    return fRet;
}

void CShellBrowser2::_FillIEThreadParam(LPCITEMIDLIST pidl, IETHREADPARAM *piei)
{
    BOOL fSettingsLoaded = FALSE;

    if (0 == GetSystemMetrics(SM_CLEANBOOT))
    {
        if (IsOS(OS_WHISTLERORGREATER))
        {
            IPropertyBag* ppb;
            if (SUCCEEDED(_GetPropertyBag(pidl, SHGVSPB_FOLDER, IID_PPV_ARG(IPropertyBag, &ppb))))
            {
                fSettingsLoaded = _ReadSettingsFromPropertyBag(ppb, piei);
                ppb->Release();
            }
        }
        else
        {
            IStream* pstm = v_GetViewStream(pidl, STGM_READ, L"CabView");
            if (pstm)
            {
                fSettingsLoaded = _ReadSettingsFromStream(pstm, piei);
                pstm->Release();
            }
        }
    }

    if (!fSettingsLoaded)
        v_GetDefaultSettings(piei);
}

void CShellBrowser2::_UpdateFolderSettings(LPCITEMIDLIST pidl)
{
    if (!_fWin95ViewState)
    {
        IETHREADPARAM iei = { 0 };

        _FillIEThreadParam(pidl, &iei);
    
        _fsd._vidRestore = iei.m_vidRestore;
        _fsd._dwViewPriority = iei.m_dwViewPriority;
        _fsd._fs = iei.fs;
    }
    else if (_pbbd->_psv)
    {
        IShellView2     *pISV2;

        // 99/04/16 #323726 vtan: Make sure that both the FOLDERSETTINGS (in _fsd._fs)
        // and the VID (in _fsd.vidRestore) is set up properly for shdocvw to make a
        // decision. This fixes Win95 browse in single window mode inheriting the view
        // from the source of navigation.

        _pbbd->_psv->GetCurrentInfo(&_fsd._fs);
        if (SUCCEEDED(_pbbd->_psv->QueryInterface(IID_PPV_ARG(IShellView2, &pISV2))))
        {
            if (SUCCEEDED(pISV2->GetView(&_fsd._vidRestore, SV2GV_CURRENTVIEW)))
                _fsd._dwViewPriority = VIEW_PRIORITY_INHERIT;
            else
                _fsd._dwViewPriority = VIEW_PRIORITY_DESPERATE;
            pISV2->Release();
        }
    }
}

void CShellBrowser2::_LoadBrowserWindowSettings(IETHREADPARAM *piei, LPCITEMIDLIST pidl)
{
    _FillIEThreadParam(pidl, piei);

    //Copy the two restore settings from piei to ShellBrowser.
    _fsd._vidRestore = piei->m_vidRestore;
    _fsd._dwViewPriority = piei->m_dwViewPriority;
    _fsd._fs = piei->fs;

    // Now that the ITBar has the menu on it, it must always be shown. We turn
    // on/off bands individually now...
    LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
    ptbi->fShow = TRUE;
        
    _fStatusBar = piei->wv.bStatusBar;

    // never allow VK_MENU to be our hot key
    if (piei->wHotkey != VK_MENU)
        SendMessage(_pbbd->_hwnd, WM_SETHOTKEY, piei->wHotkey, 0);

#ifdef DEBUG
    if (g_dwPrototype & 0x00000010) {
        //
        // Load toolbars
        //
        IStream* pstm = v_GetViewStream(pidl, STGM_READ, L"Toolbars");
        if (pstm) {
            _LoadToolbars(pstm);
            pstm->Release();
        }
    }
#endif
}

void CShellBrowser2::_UpdateChildWindowSize(void)
{
    if (!_fKioskMode) {
        if (_hwndStatus && _fStatusBar) {
            SendMessage(_hwndStatus, WM_SIZE, 0, 0L);
        }
    }
}


/*----------------------------------------------------------
Purpose: Helper function to do ShowDW on the internet toolbar.

         We can show all the bands in the toolbar, but we must
         never accidentally hide the menuband.  CShellBrowser2
         should call this function rather than IDockingWindow::ShowDW 
         directly if there is any chance fShow would be FALSE.

*/
void ITBar_ShowDW(IDockingWindow * pdw, BOOL fTools, BOOL fAddress, BOOL fLinks)
{
    IUnknown_Exec(pdw, &CGID_PrivCITCommands, CITIDM_SHOWTOOLS, fTools, NULL, NULL);
    IUnknown_Exec(pdw, &CGID_PrivCITCommands, CITIDM_SHOWADDRESS, fAddress, NULL, NULL);
    IUnknown_Exec(pdw, &CGID_PrivCITCommands, CITIDM_SHOWLINKS, fLinks, NULL, NULL);
}   

void CShellBrowser2::_HideToolbar(LPUNKNOWN punk)
{
    for (UINT itb=0; itb < (UINT)_GetToolbarCount(); itb++) {
        LPTOOLBARITEM ptbi = _GetToolbarItem(itb);

        if (ptbi->ptbar && SHIsSameObject(ptbi->ptbar, punk)) 
        {
            if (ITB_ITBAR == itb)
                ITBar_ShowDW(ptbi->ptbar, FALSE, FALSE, FALSE);
            else
                ptbi->ptbar->ShowDW(FALSE);
        }
    }
}

HRESULT CShellBrowser2::v_ShowHideChildWindows(BOOL fChildOnly)
{
    // (scotth): _hwndStatus is bogus when closing a window
    if (_hwndStatus && IS_VALID_HANDLE(_hwndStatus, WND))
        ShowWindow(_hwndStatus, (!_fKioskMode && _fStatusBar) ? SW_SHOW : SW_HIDE);

    Exec(NULL, OLECMDID_UPDATECOMMANDS, 0, NULL, NULL);
    _UpdateChildWindowSize();

    SUPERCLASS::v_ShowHideChildWindows(fChildOnly);

    // We should call _UpdateBackForwardState after the parent show/hide
    // toolbars. 
    UpdateBackForwardState();

    return S_OK;
}

#define MAX_BROWSER_WINDOW_TEMPLATE  (MAX_BROWSER_WINDOW_TITLE - 20)

void CShellBrowser2::v_GetAppTitleTemplate(LPTSTR pszBuffer, size_t cchBuffer, LPTSTR pszTitle)
{
    if (_fAppendIEToCaptionBar) 
    {
        TCHAR szBuffer[MAX_BROWSER_WINDOW_TEMPLATE];
        _GetAppTitle(szBuffer, ARRAYSIZE(szBuffer));
        StringCchPrintf(pszBuffer, cchBuffer, TEXT("%%s - %s"), szBuffer);
    } 
    else 
    {
        // don't tack on "intenet explorer" if we didn't start there
        StringCchCopy(pszBuffer, cchBuffer, TEXT("%s"));
    }
}


/*----------------------------------------------------------
Purpose: Intercept messages for menuband.

         Menuband messages must be intercepted at two points:

         1) the main message pump (IsMenuMessage method)
         2) the wndproc of a window that has a menuband 
            (TranslateMenuMessage method)

         The reason is sometimes a message will be received
         by the wndproc which did not pass thru the apps main
         message pump, but must be dealt with.  There are other
         messages which must be handled in the main message 
         pump, before TranslateMessage or DispatchMessage.

Returns: TRUE if the message was handled

*/
HRESULT CShellBrowser2::v_MayTranslateAccelerator(MSG* pmsg)
{
    HRESULT hres = S_FALSE;
    
    // (scotth): for some unknown reason (aka ActiveX init), we are 
    // receiving a null hwnd with WM_DESTROY when the user scrolls a page
    // that causes the ticker control to appear.  Check the pmsg->hwnd here
    // so we don't mistake a rogue WM_DESTROY msg for the real thing.
    
    IMenuBand* pmb = _GetMenuBand(_pbbd->_hwnd == pmsg->hwnd && WM_DESTROY == pmsg->message);

    if (pmb && _fActivated)
    {
        hres = pmb->IsMenuMessage(pmsg);

        // don't need to release pmb
    }
    
    if (hres != S_OK)
    {
        // REARCHITECT cleanup -- move menuband stuff & this check to v_MayTranslateAccelerator's caller
        if (WM_KEYFIRST <= pmsg->message && pmsg->message <= WM_KEYLAST)
        {
            hres = SUPERCLASS::v_MayTranslateAccelerator(pmsg);

            if (hres != S_OK)
            {
                //
                // Our SUPERCLASS didn't handle it.
                //
                if (_ShouldTranslateAccelerator(pmsg))
                {
                    //
                    // Okay, it's one of ours.  Let the toolbars have a crack at
                    // translating it.
                    //
                    for (UINT itb=0; (itb < (UINT)_GetToolbarCount()) && (hres != S_OK); itb++)
                    {
                        LPTOOLBARITEM ptbi = _GetToolbarItem(itb);

                        if (ptbi->fShow && (NULL != ptbi->ptbar))
                        {
                            IUnknown *pUnk;
                            
                            if (SUCCEEDED(IUnknown_GetClientDB(ptbi->ptbar, &pUnk)))
                            {
                                ASSERT(NULL != pUnk);
                                
                                hres = IUnknown_TranslateAcceleratorIO(pUnk, pmsg);

                                pUnk->Release();
                            }
                        }
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Take a whack at translating any messages.

         CShellBrowser2 uses this to translate messages needed
         for menu bands.

Returns: TRUE if we handled it

*/
BOOL CShellBrowser2::_TranslateMenuMessage(HWND hwnd, UINT uMsg, 
    WPARAM * pwParam, LPARAM * plParam, LRESULT * plRet)
{
    BOOL bRet = FALSE;
    IMenuBand* pmb = _GetMenuBand(WM_DESTROY == uMsg);

    if (pmb)
    {
        MSG msg;

        msg.hwnd = hwnd;
        msg.message = uMsg;
        msg.wParam = *pwParam;
        msg.lParam = *plParam;
        
        bRet = (S_OK == pmb->TranslateMenuMessage(&msg, plRet));

        *pwParam = msg.wParam;
        *plParam = msg.lParam;

        // don't need to release pmb
    }

    return bRet;
}    

static TCHAR g_szWorkingOffline[MAX_BROWSER_WINDOW_TEMPLATE]=TEXT("");
static TCHAR g_szWorkingOfflineTip[MAX_BROWSER_WINDOW_TEMPLATE]=TEXT("");
static TCHAR g_szAppName[MAX_BROWSER_WINDOW_TEMPLATE]=TEXT("");

void InitTitleStrings()
{
    if (!g_szWorkingOffline[0])
    {
        DWORD dwAppNameSize = sizeof(g_szAppName);
        
        // Load this stuff only once per process for perf.
        if (SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, TEXT("Window Title"), NULL,
                            g_szAppName, &dwAppNameSize) != ERROR_SUCCESS)
            MLLoadString(IDS_TITLE, g_szAppName, ARRAYSIZE(g_szAppName));

        MLLoadString(IDS_WORKINGOFFLINETIP, g_szWorkingOfflineTip, ARRAYSIZE(g_szWorkingOfflineTip));
        MLLoadString(IDS_WORKINGOFFLINE, g_szWorkingOffline, ARRAYSIZE(g_szWorkingOffline));
        SHTruncateString(g_szWorkingOffline, ARRAYSIZE(g_szWorkingOffline) - (lstrlen(g_szAppName) + 4)); // give room for separator & EOL
    }
}

void CShellBrowser2::_ReloadTitle()
{
    g_szWorkingOffline[0] = 0;
    _fTitleSet = FALSE;
    _SetTitle(NULL);
}


HICON OfflineIcon()
{
    static HICON s_hiconOffline = NULL;
    if (!s_hiconOffline) 
    {
        s_hiconOffline = (HICON)LoadImage(HinstShdocvw(), MAKEINTRESOURCE(IDI_OFFLINE), IMAGE_ICON,
                             GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
        
    }
    return s_hiconOffline;
}


void CShellBrowser2::_ReloadStatusbarIcon()
{
    BOOL fIsOffline;
    VARIANTARG var = {0};
    var.vt = VT_I4;
    
    if (_pbbd && SUCCEEDED(IUnknown_Exec(_pbbd->_psv, &CGID_Explorer, SBCMDID_GETPANE, PANE_OFFLINE, NULL, &var)) &&
        (var.lVal != PANE_NONE))
    {    
        if (_pbbd->_pidlCur && IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_USE_IE_OFFLINE_SUPPORT))
            fIsOffline = SHIsGlobalOffline();
        else
            fIsOffline = FALSE;
    
        SendControlMsg(FCW_STATUS, SB_SETICON, var.lVal, fIsOffline ? (LPARAM) OfflineIcon() : NULL, NULL);
        if (fIsOffline) 
        {
            InitTitleStrings();
            SendControlMsg(FCW_STATUS, SB_SETTIPTEXT, var.lVal, (LPARAM)g_szWorkingOfflineTip, NULL);
        }
    }
}

void CShellBrowser2::_GetAppTitle(LPTSTR pszBuffer, DWORD cchSize)
{
    BOOL fOffline = SHIsGlobalOffline();
    
    pszBuffer[0] = 0;

    InitTitleStrings();

    if (fOffline)
    {
        StringCchPrintf(pszBuffer, cchSize, TEXT("%s - %s"), g_szAppName, g_szWorkingOffline);
    }
    else
    {
#ifdef DEBUG
#ifdef UNICODE
#define DLLNAME TEXT("(BrowseUI UNI)")
#else
#define DLLNAME TEXT("(BrowseUI)")
#endif
        StringCchPrintf(pszBuffer, cchSize, TEXT("%s - %s"), g_szAppName, DLLNAME); 
#else
        StringCchCopy(pszBuffer, cchSize, g_szAppName);
#endif
    }

}

HWND CShellBrowser2::_GetCaptionWindow()
{
    return _pbbd->_hwnd;
}


/*----------------------------------------------------------
Purpose: Gets the cached menu band.  If the menu band hasn't
         been acquired yet, attempt to get it.  If bDestroy
         is TRUE, the menu band will be released.

         This does not AddRef because an AddRef/Release for each
         message is not necessary -- as long as callers beware!
*/
IMenuBand* CShellBrowser2::_GetMenuBand(BOOL bDestroy)
{
    // Don't bother to create it if we're about to go away.
    if (_fReceivedDestroy)
    {
        ASSERT(NULL == _pmb);
    }
    else if (bDestroy)
    {
        ATOMICRELEASE(_pmb);

        // Make it so we don't re-create the _pmb after the WM_DESTROY
        _fReceivedDestroy = TRUE;
    }

    // The menuband is created sometime after WM_CREATE is sent.  Keep
    // trying to get the menuband interface until we get it.

    else if (!_pmb)
    {
        IBandSite *pbs;
        if (SUCCEEDED(IUnknown_QueryService(_GetITBar(), IID_IBandSite, IID_PPV_ARG(IBandSite, &pbs))))
        {
            IDeskBand *pdbMenu;

            pbs->QueryBand(CBIDX_MENU, &pdbMenu, NULL, NULL, 0);
            if (pdbMenu)
            {
                pdbMenu->QueryInterface(IID_PPV_ARG(IMenuBand, &_pmb));
                // Cache _pmb, so don't release it here

                pdbMenu->Release();
            }
            pbs->Release();
        }
    }

    return _pmb;
}    


void CShellBrowser2::_SetMenu(HMENU hmenu)
{
    // Create a top-level menuband given this hmenu.  Add it to 
    // the bandsite.

    if (!_pmb) 
    {
        _GetMenuBand(FALSE);      // this does not AddRef

        if (!_pmb)
            return;
    }

    IShellMenu* psm;

    if (SUCCEEDED(_pmb->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
    {
        HMENU hCurMenu = NULL;
        psm->GetMenu(&hCurMenu, NULL, NULL);

        // only call setmenu if we know it is not the menu we have currently or it is not one of our precached standards...
        if ((hmenu != hCurMenu) || 
            (hmenu != _hmenuFull && hmenu != _hmenuTemplate  && hmenu != _hmenuPreMerged))
        {
            psm->SetMenu(hmenu, NULL, SMSET_DONTOWN | SMSET_MERGE);
        }
        psm->Release();
    }
}

STDAPI SHFlushClipboard(void);

HRESULT CShellBrowser2::OnDestroy()
{
    SUPERCLASS::OnDestroy();
    
    SHFlushClipboard();

    if (_uFSNotify)
        SHChangeNotifyDeregister(_uFSNotify);

    if (_fAutomation)
        IECleanUpAutomationObject();

    _DecrNetSessionCount();

    return S_OK;
}

BOOL CShellBrowser2::_CreateToolbar()
{
    return TRUE;
}

void CShellBrowser2::v_InitMembers()
{
    _hmenuTemplate =  _MenuTemplate(MENU_TEMPLATE, TRUE);
    _hmenuFull =      _MenuTemplate(MENU_FULL, TRUE);
    _hmenuPreMerged = _MenuTemplate(MENU_PREMERGED, FALSE);

    if (_fRunningInIexploreExe)
        _hmenuCur = _hmenuPreMerged;
    else
        _hmenuCur = _hmenuTemplate;
}


// REVIEW UNDONE - Stuff in programs defaults to save positions ???
void CShellBrowser2::v_GetDefaultSettings(IETHREADPARAM *piei)
{
    // set the flags

    // Best fit window means get the window to size according to the
    // contents of the view so that windows without existing settings
    // come up looking OK.
    piei->fs.fFlags = FWF_BESTFITWINDOW | g_dfs.fFlags;
    if (!_fRunningInIexploreExe)
    {
        piei->wv.bStatusBar = g_dfs.bDefStatusBar;
    }
    else
    {
        piei->wv.bStatusBar = TRUE;  //status bar is on by default in IE.
    }

    CABINETSTATE cs;
    GetCabState(&cs);
    if (cs.fSimpleDefault && cs.fNewWindowMode)
    {
        piei->wv.bStdButtons = piei->wv.bAddress = g_dfs.bDefToolBarMulti;
    }
    else
    {
        piei->wv.bStdButtons = piei->wv.bAddress = g_dfs.bDefToolBarSingle;
    }

    // For Win95 classic view, ITBar should be hidden by default.
    SHELLSTATE ss = {0};
    SHGetSetSettings(&ss, SSF_WIN95CLASSIC, FALSE);

    //  SHGetSetSettings checks SHRestricted(REST_CLASSICSHELL) for us
    if (ss.fWin95Classic)
    {
        piei->fs.ViewMode = FVM_ICON;
        piei->m_vidRestore = VID_LargeIcons;
        piei->m_dwViewPriority = VIEW_PRIORITY_RESTRICTED; // use highest priority because of the restriction.
    }
    else
    {
        piei->fs.ViewMode = g_dfs.uDefViewMode;
        piei->m_vidRestore = g_dfs.vid;
        piei->m_dwViewPriority = g_dfs.dwViewPriority;
    }

    _dwRevCount = g_dfs.dwDefRevCount;      // save this with the browser so we can save it out later

    ASSERT(piei->wp.length == 0);
}

void CShellBrowser2::_DecrNetSessionCount()
{
    TraceMsg(DM_SESSIONCOUNT, "_DecrNetSessionCount");

    if (_fVisitedNet) {
        SetQueryNetSessionCount(SESSION_DECREMENT);
        _fVisitedNet = FALSE;
    }
}

void CShellBrowser2::_IncrNetSessionCount()
{
    TraceMsg(DM_SESSIONCOUNT, "_IncrNetSessionCount");

    if (!_fVisitedNet) {
        BOOL fDontDoDefaultCheck = (BOOLIFY(_fAutomation) || (!(BOOLIFY(_fAddDialUpRef))));
        if (!SetQueryNetSessionCount(fDontDoDefaultCheck ? SESSION_INCREMENT_NODEFAULTBROWSERCHECK : SESSION_INCREMENT)) {
            g_szWorkingOffline[0] = 0;
#ifdef NO_MARSHALLING
            if (!_fOnIEThread)
                SetQueryNetSessionCount(fDontDoDefaultCheck ? SESSION_INCREMENT_NODEFAULTBROWSERCHECK : SESSION_INCREMENT);
#endif
      }
        _fVisitedNet = TRUE;
    }
}


// Initialize the Internet Toolbar. Create a dummy class to trap all the Messages that
// are sent to the old toolbar
BOOL CShellBrowser2::_PrepareInternetToolbar(IETHREADPARAM* piei)
{
    HRESULT hr = S_OK;

    if (!_GetITBar())
    {
        DWORD dwServerType = CLSCTX_INPROC_SERVER;
#ifdef FULL_DEBUG
        if (!(g_dwPrototype & PF_NOBROWSEUI))
            /// this will cause us to use OLE's co-create intance and not short circuit it.
            dwServerType = CLSCTX_INPROC;
#endif
        hr = CoCreateInstance(CLSID_InternetToolbar, NULL,
                              dwServerType,
                              IID_PPV_ARG(IDockingWindow, &_GetToolbarItem(ITB_ITBAR)->ptbar));

        TraceMsg(DM_ITBAR|DM_STARTUP, "CSB::_PrepareInternetToolbar CoCreate(CLS_ITBAR) returned %x", hr);

        if (SUCCEEDED(hr))
        {
            IUnknown_SetSite(_GetITBar(), SAFECAST(this, IShellBrowser*));
            // Look at the type of folder using "pidlInitial" and 
            // see if we have a stream for this type.
            // If so, open it and call IPersistStreamInit::Load(pstm);
            // else, call IPersistStreamInit::InitNew(void);

            IPersistStreamInit  *pITbarPSI;

            //Get the pointer to 
            if (SUCCEEDED(_GetITBar()->QueryInterface(IID_PPV_ARG(IPersistStreamInit, &pITbarPSI))))
            {
                // The initial toolbar needs to be the Web toolbar
                IUnknown_Exec(pITbarPSI, &CGID_PrivCITCommands, CITIDM_ONINTERNET, (_fUseIEToolbar ? CITE_INTERNET : CITE_SHELL), NULL, NULL);

                IStream *pstm = _GetITBarStream(_fUseIEToolbar, STGM_READ);
                if (pstm)
                {
                    //Stream exists. Let's load it from there.
                    hr = pITbarPSI->Load(pstm);
                    pstm->Release();
                }
                else
                {
                    //No stream already exists. Initialize from the old location!
                    pITbarPSI->InitNew();
                }

                pITbarPSI->Release();
            }

            SUPERCLASS::v_ShowHideChildWindows(TRUE);
        
            if (!_hwndDummyTB)
            {
                _hwndDummyTB = SHCreateWorkerWindow(DummyTBWndProc, _pbbd->_hwnd, 0, WS_CHILD, (HMENU)9999, this);
            }
        }
    }

    if (SUCCEEDED(hr) && !_pxtb)
        hr = QueryService(SID_SExplorerToolbar, IID_PPV_ARG(IExplorerToolbar, &_pxtb));

    return SUCCEEDED(hr);
}

BOOL LoadWindowPlacement(WINDOWPLACEMENT * pwndpl)
{
    BOOL fRetVal = FALSE;

    if (pwndpl)
    {
        DWORD dwSize = sizeof(WINDOWPLACEMENT);
        if (SHGetValueGoodBoot(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("Window_Placement"), NULL, (PBYTE)pwndpl, &dwSize) == ERROR_SUCCESS)
        {
           fRetVal = TRUE;
            // Is the default value invalid?
            if ((pwndpl->rcNormalPosition.left >= pwndpl->rcNormalPosition.right) ||
                (pwndpl->rcNormalPosition.top >= pwndpl->rcNormalPosition.bottom))
            {
                // Yes, so fix it.  We worry about the normal size being zero or negative.
                // This fixes the munged case. 
                ASSERT(0); //  the stream is corrupted.
                fRetVal = FALSE;
            }
        }
    }
    return fRetVal;
}


BOOL StoreWindowPlacement(WINDOWPLACEMENT *pwndpl)
{
    if (pwndpl)
    {
        // Don't store us as minimized - that isn't what the user intended.
        // I.E. right click on minimized IE 3.0 in tray, pick close.  Since
        // we are minmized in that scenario we want to force normal
        // instead so we at least show up.
    
        if (pwndpl->showCmd == SW_SHOWMINIMIZED ||
            pwndpl->showCmd == SW_MINIMIZE)
            pwndpl->showCmd = SW_SHOWNORMAL;

        // Are about to save a corrupted window size?
        if ((pwndpl->rcNormalPosition.left >= pwndpl->rcNormalPosition.right) ||
            (pwndpl->rcNormalPosition.top >= pwndpl->rcNormalPosition.bottom))
        {
            // Yes, so fix it.
            ASSERT(0); // the size is invalid or corrupted.
        }
        else
        {
            return SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("Window_Placement"), REG_BINARY, (const BYTE *)pwndpl, sizeof(WINDOWPLACEMENT)) == ERROR_SUCCESS;
        }
    }
    return FALSE;
}



BOOL StorePlacementOfWindow(HWND hwnd)
{
    WINDOWPLACEMENT wndpl;
    wndpl.length = sizeof(WINDOWPLACEMENT);
    
    if (GetWindowPlacement(hwnd, &wndpl)) 
    {
        return StoreWindowPlacement(&wndpl);
    }
    return FALSE;
}



// forward declaration
void EnsureWindowIsCompletelyOnScreen (RECT *prc);



// The rect will be offset slightly below and to the right of its current position.
// If this would cause it to move partly off the nearest monitor, then it is 
// instead placed at the top left of the same monitor.

void CascadeWindowRect(RECT *pRect)
{
    int delta = GetSystemMetrics(SM_CYCAPTION) + GetSystemMetrics(SM_CYSIZEFRAME) - 1;

    OffsetRect(pRect, delta, delta);
    
    // test if the new rect will end up getting moved later on
    RECT rc = *pRect;
    EnsureWindowIsCompletelyOnScreen(&rc);

    if (!EqualRect(pRect, &rc))
    {
        // rc had to be moved, so we'll restart the cascade using the best monitor
        MONITORINFO minfo;
        minfo.cbSize = sizeof(minfo);
        if (GetMonitorInfo(MonitorFromRect(&rc, MONITOR_DEFAULTTONEAREST), &minfo))
        {
            // And we do mean rcMonitor, not rcWork.  For example, if the taskbar is
            // at the top, then using rcMonitor with top-left = (0,0) will place it on
            // the edge of the taskbar.  Using rcWork with top-left = (0,y) will put
            // it y pixels below the taskbar's bottom edge, which is wrong.

            if (rc.bottom < pRect->bottom && rc.left == pRect->left)
            {
                // Too tall to cascade further down, but we can keep the X and just
                // reset the Y.  This fixes the bug of having a tall windows piling up
                // on the top left corner -- instead they will be offset to the right
                OffsetRect(pRect, 0, minfo.rcMonitor.top - pRect->top);   
            }
            else
            {
                // we've really run out of room, so restart cascade at top left
                OffsetRect(pRect, 
                    minfo.rcMonitor.left - pRect->left,
                    minfo.rcMonitor.top - pRect->top);
            }
        }
    }
}




void CalcWindowPlacement(BOOL fInternetStart, HWND hwnd, IETHREADPARAM *piei, WINDOWPLACEMENT *pwndpl)
{
    static RECT s_rcExplorer = {-1, -1, -1, -1};

    // We don't load the window placement for shell windows

    if (!fInternetStart || LoadWindowPlacement(pwndpl)) 
    {
        // If the show command specifies a normal show or default (i.e., our initial
        // display setting is not being overridden by the command line or
        // CreateProcess setting) then use the saved window state show command.
        // Otherwise, use the show command passed in to us.
        if (fInternetStart && ((piei->nCmdShow == SW_SHOWNORMAL) || (piei->nCmdShow == SW_SHOWDEFAULT)))
            piei->nCmdShow = pwndpl->showCmd;
        
        // Cascade if there is window of the same kind directly under us.

        HWND hwndT = NULL;
        ATOM atomClass = (ATOM) GetClassWord(hwnd, GCW_ATOM);

        while (hwndT = FindWindowEx(NULL, hwndT, (LPCTSTR) atomClass, NULL))
        {
            // Don't use GetWindowRect here because we load window placements
            // from the registry and they use the workspace coordinate system

            WINDOWPLACEMENT wp;
            wp.length = sizeof(wp);
            GetWindowPlacement(hwndT, &wp);        

            if (wp.rcNormalPosition.left == pwndpl->rcNormalPosition.left &&
                wp.rcNormalPosition.top == pwndpl->rcNormalPosition.top)
            {
                if ((piei->uFlags & COF_EXPLORE) &&
                    (s_rcExplorer.left != -1) && (s_rcExplorer.top != -1))
                {
                    // An explorer window is trying to appear on top of
                    // another one.  We'll use our stored rect's top-left 
                    // to make it cascade like IE windows.

                    OffsetRect(&pwndpl->rcNormalPosition,
                       s_rcExplorer.left - pwndpl->rcNormalPosition.left,
                       s_rcExplorer.top - pwndpl->rcNormalPosition.top);                    
                }

                // do the cascade for all windows
                CascadeWindowRect(&pwndpl->rcNormalPosition);
            }
        }

        // for IE and explorer, save the current location
        if (piei->uFlags & COF_EXPLORE)
            s_rcExplorer = pwndpl->rcNormalPosition;
        else if (fInternetStart)
            StoreWindowPlacement(pwndpl);
    } 
    else 
    {
        pwndpl->length = 0;
    }
}

class   CRGN
{
    public:
                CRGN (void)                     {   mRgn = CreateRectRgn(0, 0, 0, 0);                               }
                CRGN (const RECT& rc)           {   mRgn = CreateRectRgnIndirect(&rc);                              }
                ~CRGN (void)                    {   if (mRgn) TBOOL(DeleteObject(mRgn));                                      }

                operator HRGN (void)    const   {   return(mRgn);                                                   }
        void    SetRegion (const RECT& rc)      {   TBOOL(SetRectRgn(mRgn, rc.left, rc.top, rc.right, rc.bottom));  }
    private:
        HRGN    mRgn;
};

BOOL    CALLBACK    GetDesktopRegionEnumProc (HMONITOR hMonitor, HDC hdcMonitor, RECT* prc, LPARAM lpUserData)

{
    MONITORINFO     monitorInfo;

    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfo(hMonitor, &monitorInfo) != 0)
    {
        HRGN    hRgnDesktop;
        CRGN    rgnMonitorWork(monitorInfo.rcWork);

        hRgnDesktop = *reinterpret_cast<CRGN*>(lpUserData);
        if ((HRGN)rgnMonitorWork)
            TINT(CombineRgn(hRgnDesktop, hRgnDesktop, rgnMonitorWork, RGN_OR));
    }
    return(TRUE);
}

void    EnsureWindowIsCompletelyOnScreen (RECT *prc)

//  99/04/13 #321962 vtan: This function exists because user32 only determines
//  whether ANY part of the window is visible on the screen. It's possible to
//  place a window without an accessible title. Pretty useless when using the
//  mouse and forces the user to use the VERY un-intuitive alt-space.

{
    HMONITOR        hMonitor;
    MONITORINFO     monitorInfo;

    // First find the monitor that the window resides on using GDI.

    hMonitor = MonitorFromRect(prc, MONITOR_DEFAULTTONEAREST);
    ASSERT(hMonitor);           // get vtan - GDI should always return a result
    monitorInfo.cbSize = sizeof(monitorInfo);
    if (GetMonitorInfo(hMonitor, &monitorInfo) != 0)
    {
        LONG    lOffsetX, lOffsetY;
        RECT    *prcWorkArea, rcIntersect;
        CRGN    rgnDesktop, rgnIntersect, rgnWindow;

        // Because the WINDOWPLACEMENT rcNormalPosition field is in WORKAREA
        // co-ordinates this causes a displacement problem. If the taskbar is
        // at the left or top of the primary monitor the RECT passed even though
        // at (0, 0) may be at (100, 0) on the primary monitor in GDI co-ordinates
        // and GetMonitorInfo() will return a MONITORINFO in GDI co-ordinates.
        // The safest generic algorithm is to offset the WORKAREA RECT into GDI
        // co-ordinates and apply the algorithm in that system. Then offset the
        // WORKAREA RECT back into WORKAREA co-ordinates.

        prcWorkArea = &monitorInfo.rcWork;
        if (EqualRect(&monitorInfo.rcMonitor, &monitorInfo.rcWork) == 0)
        {

            // Taskbar is on this monitor - offset required.

            lOffsetX = prcWorkArea->left - monitorInfo.rcMonitor.left;
            lOffsetY = prcWorkArea->top - monitorInfo.rcMonitor.top;
        }
        else
        {

            // Taskbar is NOT on this monitor - no offset required.

            lOffsetX = lOffsetY = 0;
        }
        TBOOL(OffsetRect(prc, lOffsetX, lOffsetY));

        // WORKAREA RECT is in GDI co-ordinates. Apply the algorithm.

        // Check to see if this window already fits the current visible screen
        // area. This is a direct region comparison.

        // This enumeration may cause a performance problem. In the event that
        // a cheap and simple solution is required it would be best to do a
        // RECT intersection with the monitor and the window before resorting
        // to the more expensive region comparison. Get vtan if necessary.

        TBOOL(EnumDisplayMonitors(NULL, NULL, GetDesktopRegionEnumProc, reinterpret_cast<LPARAM>(&rgnDesktop)));
        rgnWindow.SetRegion(*prc);
        TINT(CombineRgn(rgnIntersect, rgnDesktop, rgnWindow, RGN_AND));
        if (EqualRgn(rgnIntersect, rgnWindow) == 0)
        {
            LONG    lDeltaX, lDeltaY;

            // Some part of the window is not within the visible desktop region
            // Move it until it all fits. Size it if it's too big.

            lDeltaX = lDeltaY = 0;
            if (prc->left < prcWorkArea->left)
                lDeltaX = prcWorkArea->left - prc->left;
            if (prc->top < prcWorkArea->top)
                lDeltaY = prcWorkArea->top - prc->top;
            if (prc->right > prcWorkArea->right)
                lDeltaX = prcWorkArea->right - prc->right;
            if (prc->bottom > prcWorkArea->bottom)
                lDeltaY = prcWorkArea->bottom - prc->bottom;
            TBOOL(OffsetRect(prc, lDeltaX, lDeltaY));
            TBOOL(IntersectRect(&rcIntersect, prc, prcWorkArea));
            TBOOL(CopyRect(prc, &rcIntersect));
        }

        // Put WORKAREA RECT back into WORKAREA co-ordinates.

        TBOOL(OffsetRect(prc, -lOffsetX, -lOffsetY));
    }
}

LPITEMIDLIST MyDocsIDList(void);

#define FRAME_OPTIONS_TO_TEST      (BFO_ADD_IE_TOCAPTIONBAR | BFO_USE_DIALUP_REF | BFO_USE_IE_TOOLBAR | \
                                    BFO_BROWSER_PERSIST_SETTINGS | BFO_USE_IE_OFFLINE_SUPPORT)
HRESULT CShellBrowser2::_SetBrowserFrameOptions(LPCITEMIDLIST pidl)
{
    BROWSERFRAMEOPTIONS dwOptions = FRAME_OPTIONS_TO_TEST;
    if (FAILED(GetBrowserFrameOptionsPidl(pidl, dwOptions, &dwOptions)))
    {
        // GetBrowserFrameOptionsPidl() will fail if pidl is NULL.
        // in that case we want to use _fInternetStart to determine
        // if we want these bits set or not.
        if (_fInternetStart)
            dwOptions = FRAME_OPTIONS_TO_TEST;   // Assume None.
        else
            dwOptions = BFO_NONE;   // Assume None.
    }
        
    _fAppendIEToCaptionBar = BOOLIFY(dwOptions & BFO_ADD_IE_TOCAPTIONBAR);
    _fAddDialUpRef = BOOLIFY(dwOptions & BFO_USE_DIALUP_REF);
    _fUseIEToolbar = BOOLIFY(dwOptions & BFO_USE_IE_TOOLBAR);
    _fEnableOfflineFeature = BOOLIFY(dwOptions & BFO_USE_IE_OFFLINE_SUPPORT);
    _fUseIEPersistence = BOOLIFY(dwOptions & BFO_BROWSER_PERSIST_SETTINGS);


    return S_OK;
}


HRESULT CShellBrowser2::_ReplaceCmdLine(LPTSTR pszCmdLine, DWORD cchCmdLine)
{
    TCHAR szVeryFirstPage[MAX_URL_STRING];

    HRESULT hr = _GetStdLocation(szVeryFirstPage, ARRAYSIZE(szVeryFirstPage), DVIDM_GOFIRSTHOME);
    TraceMsg(DM_NAV, "CSB::_ReplaceCmdLine _GetStdLocation(DVIDM_GOFIRSTHOME) returned %x", hr);

    if (SUCCEEDED(hr)) 
    {
        hr = StringCchCopy(pszCmdLine, cchCmdLine, szVeryFirstPage);
        TraceMsg(DM_NAV, "CSB::_ReplaceCmdLine _GetStdLocation(DVIDM_GOFIRSTHOME) returned %s", pszCmdLine);
    }

    return hr;
}
   

HRESULT CShellBrowser2::OnCreate(LPCREATESTRUCT pcs)
{
    HRESULT hres = S_OK;
    IETHREADPARAM* piei = (IETHREADPARAM*)pcs->lpCreateParams;
    BOOL    fUseHomePage = (piei->piehs ? FALSE : TRUE); // intentionally reversered
    DWORD dwExStyle = IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd : 0L;

    _clsidThis = (piei->uFlags & COF_IEXPLORE) ? 
                 CLSID_InternetExplorer : CLSID_ShellBrowserWindow;

#ifdef NO_MARSHALLING
    if (!piei->fOnIEThread) 
        _fOnIEThread = FALSE;
#endif
    //
    //  Make this thread foreground here so that any UI from
    // USERCLASS::OnCreate will be on the top of other windows.
    // We used to call this in _AfterWindowCreate, but it is
    // too late for dialog boxes we popup while processing WM_CREATE
    // message.
    //
    // Note that we do call SetForegroundWindow even if this window
    // is not created as a result of CoCreateInstance. The automation
    // client is supposed to make it visible and bring it to the
    // foreground if it needs to. 
    //
    if (!piei->piehs) 
    {
        SetForegroundWindow(_pbbd->_hwnd);  
    }

    SUPERCLASS::OnCreate(pcs);
    
    EnsureWebViewRegSettings();

    ASSERT(piei);
    _fRunningInIexploreExe = BOOLIFY(piei->uFlags & COF_IEXPLORE);
    v_InitMembers();

    CString             strCmdLine;

    if (piei->pszCmdLine)
    {
        strCmdLine = piei->pszCmdLine;
    }
    else
    {
        strCmdLine.Empty();
    }
    
    if (piei->fCheckFirstOpen) 
    {
        ASSERT(!ILIsRooted(piei->pidl));
        //
        // We don't want to go to the very first page, if this window
        // is created as the result of CoCreateInstnace.
        //
        if (!piei->piehs && (piei->uFlags & COF_IEXPLORE))
        {
            LPTSTR      pstrCmdLine = strCmdLine.GetBuffer( MAX_URL_STRING );

            if ( strCmdLine.GetAllocLength() < MAX_URL_STRING )
            {
                TraceMsg( TF_WARNING, "CShellBrowser2::OnCreate() - strCmdLine Allocation Failed!" );
                hres = E_OUTOFMEMORY;
            }
            else
            {
                if (SUCCEEDED(_ReplaceCmdLine( pstrCmdLine, MAX_URL_STRING ))) 
                {
                    _fInternetStart = TRUE;
                }

                // Let CString class own the buffer again.
                strCmdLine.ReleaseBuffer();
            }
        }

        piei->fCheckFirstOpen = FALSE;
    }

    // NOTE: These flags and corresponding ones in IETHREADPARAM are set to FALSE at creation, 
    // ParseCommandLine() is the only place where they are set.  -- dli
    _fNoLocalFileWarning = piei->fNoLocalFileWarning;
    _fKioskMode = piei->fFullScreen;
    if (piei->fNoDragDrop)
        SetFlags(0, BSF_REGISTERASDROPTARGET);
    _fAutomation = piei->fAutomation;
    
    // If someone deliberately tell us not to use home page. 
    if (piei->fDontUseHomePage) 
    {
        fUseHomePage = 0;
        
        // only the IE path sets this flag.
        // this is used by iexplorer.exe -nohome
        // and by ie dde to start out blank then navigate next
        _fInternetStart = TRUE;
    }

    if (piei->ptl)
        InitializeTravelLog(piei->ptl, piei->dwBrowserIndex);

    LPITEMIDLIST pidl = NULL;
    BOOL fCloning = FALSE;

    if ((( ! strCmdLine.IsEmpty() ) || piei->pidl)  && !_fAutomation)
    {
        if (piei->pidl) 
        {
            pidl = ILClone(piei->pidl);
        } 
        else 
        {
            int             cchCmdLine = strCmdLine.GetLength();
            LPTSTR          pstrCmdLine = strCmdLine.GetBuffer( MAX_URL_STRING );
            HRESULT         hresWrap;
            if ( strCmdLine.GetAllocLength() < MAX_URL_STRING )
            {
                TraceMsg( TF_WARNING, "CShellBrowser2::OnCreate() - strCmdLine Allocation Failed!" );
                hresWrap = E_OUTOFMEMORY;
            }
            else
            {
                hresWrap = WrapSpecialUrlFlat( pstrCmdLine, cchCmdLine + 1 );

                // Let CString class own the buffer again.
                strCmdLine.ReleaseBuffer();
            }

            if ( SUCCEEDED( hresWrap ) )
            {
                HRESULT hresT = _ConvertPathToPidl(this, _pbbd->_hwnd, strCmdLine, &pidl);

                TraceMsg(DM_STARTUP, "CSB::OnCreate ConvertPathToPidl(strCmdLine) returns %x", hresT);
            }
        }
    }
    

    if (pidl) 
    {
         fUseHomePage = FALSE;
    } 
    else if (_pbbd->_ptl && SUCCEEDED(_pbbd->_ptl->GetTravelEntry((IShellBrowser *)this, 0, NULL))) 
    {
        pidl = ILClone(&s_idlNULL);
        fCloning = TRUE;
        fUseHomePage = FALSE;
        // NOTE: if we ever hit this code when opening a window at non-web address
        // we'll need to be more selective about setting this flag
        _fInternetStart = TRUE;
    } 
    else if (fUseHomePage) 
    {
        // if we're not top level, assume we're going to be told
        // where to browse
        CString     strPath;

        LPTSTR      pstrPath = strPath.GetBuffer( MAX_URL_STRING );

        if ( strPath.GetAllocLength() < MAX_URL_STRING )
        {
            TraceMsg( TF_WARNING, "CShellBrowser2::OnCreate() - strPath Allocation Failed!" );
            hres = E_OUTOFMEMORY;
        }
        else
        {
            if (piei->uFlags & COF_IEXPLORE)
            {
                hres = _GetStdLocation( pstrPath, MAX_URL_STRING, DVIDM_GOHOME );
            }
            else
            {
                //  we need to get the default location for an explorer window
                //  which classically has been the root drive of the windows install
                GetModuleFileName( GetModuleHandle(NULL), pstrPath, MAX_URL_STRING );

                PathStripToRoot(pstrPath);
            }

            // Let CString class own the buffer again.
            strPath.ReleaseBuffer();
        }

        if (SUCCEEDED(hres)) 
        {
            IECreateFromPath( strPath, &pidl );
        }
    }

    // do this here after we've found what pidl we're looking at
    // but do it before the CalcWindowPlacement because
    // it might need to override
    _LoadBrowserWindowSettings(piei, pidl);

    // call this before PrepareInternetToolbar because it needs to know
    // _fInternetStart to know which toolbar config to use
    if (!_fInternetStart) 
    {
        if (pidl) 
        {
            if (fUseHomePage || IsURLChild(pidl, TRUE)) 
            {
                _fInternetStart = TRUE;
            } 
            else 
            {
                DWORD dwAttrib = SFGAO_FOLDER | SFGAO_BROWSABLE;

                // if it's on the file system, we'll still consider it to be an
                // internet folder if it's a docobj (including .htm file)
                IEGetAttributesOf(pidl, &dwAttrib);

                if ((dwAttrib & (SFGAO_FOLDER | SFGAO_BROWSABLE)) == SFGAO_BROWSABLE)
                    _fInternetStart = TRUE;
            }
        } 
        else if (!(piei->uFlags & COF_SHELLFOLDERWINDOW))
        {
            _fInternetStart = TRUE;
        }
    }

    _SetBrowserFrameOptions(pidl);
    CalcWindowPlacement(_fUseIEPersistence, _pbbd->_hwnd, piei, &piei->wp);
    
    if (!_PrepareInternetToolbar(piei))
        return E_FAIL;

    _CreateToolbar();

    // We must create _hwndStatus before navigating, because the
    // first navigate will go synchronous and the shell sends
    // status messages during that time. If the status window hasn't
    // been created, they drop on the floor.
    //
    _hwndStatus = CreateWindowEx(dwExStyle, STATUSCLASSNAME, NULL,
                                 WS_CHILD | SBARS_SIZEGRIP | WS_CLIPSIBLINGS | WS_VISIBLE | SBT_TOOLTIPS
                                 & ~(WS_BORDER | CCS_NODIVIDER),
                                -100, -100, 10, 10, _pbbd->_hwnd, (HMENU)FCIDM_STATUS, HINST_THISDLL, NULL);
#ifdef DEBUG
    if (g_dwPrototype & 0x00000004) 
    {
        HRESULT hres = E_FAIL;
        if (_SaveToolbars(NULL) == S_OK) 
        {
            // _LoadBrowserWindowSettings did a v_GetViewStream/ _LoadToolbars
            // if it succeeded (i.e. if we have > 0 toolbars), we're done
            // actually, even 0 toolbars could mean success, oh well...
            hres = S_OK;
        }
        ASSERT(SUCCEEDED(hres));
    }
#endif
    
    // REARCHITECT: do this early to let these objects see the first
    // navigate. but this causes a deadlock if the objects require
    // marshalling back to the main thread.
    _LoadBrowserHelperObjects();

    BOOL fDontIncrementSessionCounter = FALSE;
    if (pidl)    // paranoia
    {
        if (fCloning)
        {
            ASSERT(_pbbd->_ptl);
            hres = _pbbd->_ptl->Travel((IShellBrowser*)this, 0);
        } 
        else
        {
            if (!_fAddDialUpRef)
                fDontIncrementSessionCounter = TRUE;
                
            hres = _NavigateToPidl(pidl, 0, 0);
            if (FAILED(hres)) 
            {
                fDontIncrementSessionCounter = TRUE; // We're going to windows\blank.htm or fail ...
                if (_fAddDialUpRef)
                {
                    // if we failed, but this was a URL child, 
                    // we should still activate and go to blank.htm
                    hres = S_FALSE;
                }
                else if (piei->uFlags & COF_EXPLORE)
                {
                    // If an explorer browser, fall back to the desktop.
                    //
                    // The reason is that we want Start->Windows Explorer to
                    // bring up a browser even if MyDocs is inaccessible;
                    // however we don't want Start->Run "<path>" to bring up
                    // a browser if <path> is inaccessible.
                    //
                    
                    BOOL fNavDesktop = (hres != HRESULT_FROM_WIN32(ERROR_CANCELLED));

                    if (!fNavDesktop)
                    {
                        LPITEMIDLIST pidlDocs = MyDocsIDList();
                        if (pidlDocs)
                        {
                            fNavDesktop = ILIsEqual(pidl, pidlDocs);
                            ILFree(pidlDocs);
                        }
                    }
                    if (fNavDesktop)
                        hres = _NavigateToPidl(&s_idlNULL, 0, 0);
                }
            }
        }

        ILFree(pidl);
    }

    if (_fAddDialUpRef && !fDontIncrementSessionCounter)
        _IncrNetSessionCount();

    if (IsOS(OS_WHISTLERORGREATER))
    {
        if (piei->wp.length == 0)
        {
            HMONITOR hmon = (piei->uFlags & COF_HASHMONITOR) ? reinterpret_cast<HMONITOR>(piei->pidlRoot) : NULL;
            _GetDefaultWindowPlacement(_pbbd->_hwnd, hmon, &piei->wp);
        }
    }
    else
    {

        // 99/04/07 #141049 vtan: If hMonitor was given then use this as the basis
        // for placement of a new window. Move the window position from the primary
        // monitor (where user32 placed it) to the specified HMONITOR. If this
        // results in a placement off screen then SetWindowPlacement() will fix
        // this up for us.

        if ((piei->wp.length == 0) && ((piei->uFlags & COF_HASHMONITOR) != 0) && (piei->pidlRoot != NULL))
        {
            MONITORINFO     monitorInfo;

            piei->wp.length = sizeof(piei->wp);
            TBOOL(GetWindowPlacement(_pbbd->_hwnd, &piei->wp));
            monitorInfo.cbSize = sizeof(monitorInfo);
            TBOOL(GetMonitorInfo(reinterpret_cast<HMONITOR>(piei->pidlRoot), &monitorInfo));
            TBOOL(OffsetRect(&piei->wp.rcNormalPosition, monitorInfo.rcMonitor.left, monitorInfo.rcMonitor.top));
        }
    }

    if (piei->wp.length == sizeof(piei->wp)) 
    {
        BOOL fSetWindowPosition = TRUE;

        // we do a SetWindowPlacement first with SW_HIDE
        // to get the size right firsth
        // then we really show it.
        if ((piei->nCmdShow == SW_SHOWNORMAL) || 
            (piei->nCmdShow == SW_SHOWDEFAULT)) 
            piei->nCmdShow = piei->wp.showCmd;
        piei->wp.showCmd = SW_HIDE;

        HWND hwndTray = GetTrayWindow();
        if (hwndTray)
        {
            RECT rc;
            if (GetWindowRect(hwndTray, &rc) && ISRECT_EQUAL(rc, piei->wp.rcNormalPosition))
            {
                // In this case, we want to ignore the position because
                // it's equal to the tray. (Came from Win95/OSR2 days)
                fSetWindowPosition = FALSE;
            }
        }

        if (fSetWindowPosition)
        {
            EnsureWindowIsCompletelyOnScreen(&piei->wp.rcNormalPosition);
            SetWindowPlacement(_pbbd->_hwnd, &piei->wp);
        }
    }

    v_ShowHideChildWindows(TRUE);

    if (piei->piehs)
    {
        // this thread was created to be the browser automation object

        // turn this on to prove CoCreateInstance does not cause a dead lock.
#ifdef MAX_DEBUG
        SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0, 0);
        Sleep(5);
        SendMessage(HWND_BROADCAST, WM_WININICHANGE, 0, 0);
#endif
        //
        // WARNING: Note that we must SetEvent even though we can't return
        //  the marshalled automation object for some reason. Not signaling
        //  the event will block the caller thread for a long time.
        //
        if (SUCCEEDED(hres)) 
        {
            hres = CoMarshalInterface(piei->piehs->GetStream(), IID_IUnknown, _pbbd->_pautoWB2,
                                                 MSHCTX_INPROC, 0, MSHLFLAGS_NORMAL);
        }
        piei->piehs->PutHresult(hres);
        SetEvent(piei->piehs->GetHevent());
    }

    if (g_tidParking == GetCurrentThreadId()) 
    {
        IEOnFirstBrowserCreation(_fAutomation ? _pbbd->_pautoWB2 : NULL);
    }

    SHGetThreadRef(&_punkMsgLoop);  // pick up the ref to this thread

    TraceMsg(DM_STARTUP, "CSB::OnCreate returning hres=%x", hres);
    if (FAILED(hres))
    {
        _SetMenu(NULL);
        return E_FAIL;
    }
    return S_OK;
}

void CShellBrowser2::_GetDefaultWindowPlacement(HWND hwnd, HMONITOR hmon, WINDOWPLACEMENT* pwp)
{
    ASSERT(IsOS(OS_WHISTLERORGREATER));  // don't use on legacy systems.

    // We tailor our Web View content for 800x600
    int cxView = 800;
    int cyView = 600;

    int x;
    int y;

    // Make sure we fit on the monitor...
    //
    if (NULL == hmon)
        hmon = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);

    if (hmon)
    {
        MONITORINFO monInfo = {sizeof(monInfo), 0};
        if (GetMonitorInfo(hmon, &monInfo))
        {
            pwp->length = sizeof(WINDOWPLACEMENT);
            if (GetWindowPlacement(hwnd, pwp))
            {
                // Move the window to the specified monitor.
                OffsetRect(&pwp->rcNormalPosition, monInfo.rcMonitor.left, monInfo.rcMonitor.top);

                // Reposition this window to fit on this monitor
                x = pwp->rcNormalPosition.left;
                y = pwp->rcNormalPosition.top;
                if (monInfo.rcWork.left <= pwp->rcNormalPosition.left &&
                    pwp->rcNormalPosition.left <= monInfo.rcWork.right &&
                    pwp->rcNormalPosition.left + cxView > monInfo.rcWork.right)
                {
                    x = max(monInfo.rcWork.left, monInfo.rcWork.right - cxView);
                }
                if (monInfo.rcWork.top <= pwp->rcNormalPosition.top &&
                    pwp->rcNormalPosition.top <= monInfo.rcWork.bottom &&
                    pwp->rcNormalPosition.top + cyView > monInfo.rcWork.bottom)
                {
                    y = max(monInfo.rcWork.top, monInfo.rcWork.bottom - cyView);
                }

                // Even with the above positioning, we don't want to be bigger than the monitor
                cxView = min(cxView, RECTWIDTH(monInfo.rcWork));
                cyView = min(cyView, RECTHEIGHT(monInfo.rcWork));

                // We're not using the whole screen so use the calculated position, else maximize.
                if (cxView != RECTWIDTH(monInfo.rcWork) || cyView != RECTHEIGHT(monInfo.rcWork))
                {
                    pwp->rcNormalPosition.left   = x;
                    pwp->rcNormalPosition.top    = y;
                    pwp->rcNormalPosition.right  = x + cxView;
                    pwp->rcNormalPosition.bottom = y + cyView;
                }
                else
                {
                    pwp->showCmd = SW_MAXIMIZE;
                }

            }
            else
            {
                pwp->length = 0;
            }
        }
    }
}



//***    InfoIdmToTBIdm -- convert btwn browserbar IDM and TBIDM
//
int InfoIdmToTBIdm(int val, BOOL fToTB)
{
    static const int menutab[] = {
        FCIDM_VBBSEARCHBAND, 
        FCIDM_VBBFAVORITESBAND, 
        FCIDM_VBBHISTORYBAND, 
        FCIDM_VBBEXPLORERBAND,
    };

    static const int tbtab[] = {
        TBIDM_SEARCH, 
        TBIDM_FAVORITES,
        TBIDM_HISTORY,
        TBIDM_ALLFOLDERS,
    };

    return SHSearchMapInt(fToTB ? menutab : tbtab, fToTB ? tbtab : menutab,
        ARRAYSIZE(menutab), val);
}

void _CheckSearch(UINT idmInfo, BOOL fCheck, IExplorerToolbar* _pxtb)
{
    idmInfo = InfoIdmToTBIdm(idmInfo, TRUE);
    if (idmInfo == -1)
        return;

    if (_pxtb)
    {
        UINT uiState;
        if (SUCCEEDED(_pxtb->GetState(&CLSID_CommonButtons, idmInfo, &uiState)))
        {
            if (fCheck)
                uiState |= TBSTATE_CHECKED;
            else
                uiState &= ~TBSTATE_CHECKED;
            _pxtb->SetState(&CLSID_CommonButtons, idmInfo, uiState);
        }
    }
}


//
// Implementation of CShellBrowser2::ShowToolbar
//
// Make toolbar visible or not and update our conception of whether it
// should be shown.  The toolbar by definition is strictly the toolbar.
// The caller has no idea that part of our internet toolbar also has
// the menu.  We must make sure we don't hide the menuband -- only the
// other bands on the internet toolbar.
//
// Returns: S_OK, if successfully done.
//          E_INVALIDARG, duh.
//
HRESULT CShellBrowser2::ShowToolbar(IUnknown* punkSrc, BOOL fShow)
{
    HRESULT hres;
    UINT itb = _FindTBar(punkSrc);

    if (ITB_ITBAR == itb)
    {
        LPTOOLBARITEM ptbi = _GetToolbarItem(itb);

        ITBar_ShowDW(ptbi->ptbar, fShow, fShow, fShow); 
        ptbi->fShow = fShow;

        hres = S_OK;
    }
    else
        hres = SUPERCLASS::ShowToolbar(punkSrc, fShow);

    return S_OK;
}


extern IDeskBand * _GetInfoBandBS(IBandSite *pbs, REFCLSID clsid);

#ifdef DEBUG // {
//***
// NOTES
//  WARNING: dtor frees up CBandSiteMenu on exit!
//  should we make sure some minimum set is created?
HRESULT CShellBrowser2::_AddInfoBands(IBandSite *pbs)
{
    if (!_pbsmInfo)
        return E_FAIL;

    BANDCLASSINFO *pbci;
    for (int i = 0; (pbci = _pbsmInfo->GetBandClassDataStruct(i)) != NULL; i++) 
    {
        IDeskBand *pband = _GetInfoBandBS(pbs, pbci->clsid);
        if (pband != NULL)
            pband->Release();
    }

    {
        // Exec -> Select or SetBandState ??? What do this mean ???
        // REARCHITECT chrisfra 5/23/97 - ever heard of variants?  this should set
        // vt = VT_I4 and lVal = 1.  this is horrible, I assume this is being ripped
        // out when Select funcs added, if not, it should be recoded.
        VARIANTARG vaIn = { 0 };
        //VariantInit();
        vaIn.vt = VT_UNKNOWN;
        vaIn.punkVal = (IUnknown *)1;   // show all
        IUnknown_Exec(pbs, &CGID_DeskBand, DBID_SHOWONLY, OLECMDEXECOPT_PROMPTUSER, &vaIn, NULL);
        //VariantClear();
    }

    return S_OK;
}
#endif // }

// REARCHITECT: [justmann 2000-01-27 this seems so ancient that it can be ignored]
// this is for ie4 shell compat - the ie4 shell menus have a Explorer bar popup
// need to make a pass through & fix all _GetBrowserBarMenu ref's,
// since we're back to having view->explorer bars-> on all platforms
HMENU CShellBrowser2::_GetBrowserBarMenu()
{
    HMENU hmenu = _GetMenuFromID(FCIDM_VIEWBROWSERBARS);

    if (hmenu == NULL)
    {
        hmenu = _GetMenuFromID(FCIDM_MENU_VIEW);
        if (hmenu == NULL)
        {
            //if we're here, someone has taken our view menu (docobj)
            hmenu = SHGetMenuFromID(_hmenuPreMerged, FCIDM_VIEWBROWSERBARS);
            ASSERT(hmenu);
        }
    }
    ASSERT(IsMenu(hmenu));
    return hmenu;
}


void CShellBrowser2::_AddBrowserBarMenuItems(HMENU hmenu)
{
    // Find the placeholder item, so we can add items before it
    int iPos = SHMenuIndexFromID(hmenu, FCIDM_VBBPLACEHOLDER);
    if (iPos < 0)
    {
        // we've already had our way with this menu
        ASSERT(_pbsmInfo);
        return;
    }

    //_pbsmInfo is shared across all views in the view menu
    BOOL fCreatedNewBSMenu = FALSE;

    if (!_pbsmInfo) 
    {
        IUnknown *punk;
        if (SUCCEEDED(CBandSiteMenu_CreateInstance(NULL, &punk, NULL))) 
        {
            punk->QueryInterface(CLSID_BandSiteMenu, (void **)&_pbsmInfo);
            punk->Release();
            fCreatedNewBSMenu = TRUE;
        }
    }

    if (!_pbsmInfo)
        return;

    int idCmdNext;
    UINT cBands = 0;

    if (fCreatedNewBSMenu) 
    {
        //  Load up infobands
        cBands = _pbsmInfo->LoadFromComCat(&CATID_InfoBand);

        // nuke any infoband entries that are already in the fixed list
        for (int i = FCIDM_VBBFIXFIRST; i < FCIDM_VBBFIXLAST; i++) 
        {
            const CLSID *pclsid = _InfoIdmToCLSID(i);
            if (pclsid)
            {
                if (_pbsmInfo->DeleteBandClass(*pclsid))
                    cBands--;
            }
        }

        // merge the additional infobands contiguously
        idCmdNext = _pbsmInfo->CreateMergeMenu(hmenu, VBBDYN_MAXBAND, iPos - 1, FCIDM_VBBDYNFIRST,0);

        //  Load up commbands
        _iCommOffset = cBands;
        cBands = _pbsmInfo->LoadFromComCat(&CATID_CommBand);
    }
    else
    {
        // Add the additional infobands contiguously
        int cMergedInfoBands = _pbsmInfo->GetBandClassCount(&CATID_InfoBand, TRUE /*merged*/); 
        idCmdNext = _pbsmInfo->CreateMergeMenu(hmenu, cMergedInfoBands, iPos - 1, FCIDM_VBBDYNFIRST,0);
        cBands = _pbsmInfo->LoadFromComCat(NULL);
    }

    // placeholder position may have changed at this point
    iPos = SHMenuIndexFromID(hmenu, FCIDM_VBBPLACEHOLDER);

    // Add comm bands.
    if (_iCommOffset != cBands)
    {
        //  Insert a separator if there are comm bands
        InsertMenu(hmenu, iPos + _iCommOffset + 1, MF_BYPOSITION | MF_SEPARATOR, -1, NULL);

        // Now merge the comm bands
        _pbsmInfo->CreateMergeMenu(hmenu, VBBDYN_MAXBAND, iPos + _iCommOffset + 2, idCmdNext, _iCommOffset);
    }
    DeleteMenu(hmenu, FCIDM_VBBPLACEHOLDER, MF_BYCOMMAND);

    if (!CMediaBarUtil::IsWMP7OrGreaterCapable())
    {
        DeleteMenu(hmenu, FCIDM_VBBMEDIABAND, MF_BYCOMMAND);
    }
}

int CShellBrowser2::_IdBarFromCmdID(UINT idCmd)
{
    const CATID* pcatid = _InfoIdmToCATID(idCmd);

    if (pcatid)
    {
        if (IsEqualCATID(*pcatid, CATID_InfoBand))
        {
            // It's a vertical bar
            return IDBAR_VERTICAL;
        }
        else
        {
            // It's a horizontal bar
            ASSERT(IsEqualCATID(*pcatid, CATID_CommBand));
            return IDBAR_HORIZONTAL;
        }
    }

    // Command doesn't correspond to any bar
    return IDBAR_INVALID;
}

int CShellBrowser2::_eOnOffNotMunge(int eOnOffNot, UINT idCmd, UINT idBar)
{
    // FEATURE: todo -- drive an ashen stake through the foul heart of this function

    if (eOnOffNot == -1) 
    {
        // toggle
        // 'special' guys are set; 'real' guys are toggled
        ASSERT(idCmd != FCIDM_VBBNOVERTICALBAR && idCmd != FCIDM_VBBNOHORIZONTALBAR);

        if (idCmd == FCIDM_VBBNOVERTICALBAR || idCmd == FCIDM_VBBNOHORIZONTALBAR)
            eOnOffNot = 0;
        else if ((idCmd >= FCIDM_VBBDYNFIRST) && (idCmd <= FCIDM_VBBDYNLAST))
            eOnOffNot = (idBar == IDBAR_VERTICAL) ? (idCmd != _idmInfo) : (idCmd != _idmComm);
        else
            eOnOffNot = (idCmd != _idmInfo);
    }

    return eOnOffNot;
}

#define MIIM_FTYPE       0x00000100

//***   csb::_SetBrowserBarState -- handle menu/toolbar/exec command, *and* update UI
// ENTRY/EXIT
//  idCmd           FCIDM_VBB* or -1 (if want to use pclsid instead)
//  pclsid          clsid or NULL (if want to use idCmd instead)
//  eOnOffToggle    1=on, 0=off, -1=not (off/not only for fixed bands for now)
// NOTES
//  menu code calls w/ idCmd, Exec code calls w/ pclsid
//
void CShellBrowser2::_SetBrowserBarState(UINT idCmd, const CLSID *pclsid, int eOnOffNot, LPCITEMIDLIST pidl)
{
    if (idCmd == -1)
        idCmd = _InfoCLSIDToIdm(pclsid);

    if (pclsid == NULL)
        pclsid = _InfoIdmToCLSID(idCmd);

    ASSERT(_InfoCLSIDToIdm(pclsid) == idCmd);

    int idBar = _IdBarFromCmdID(idCmd);
    if (idBar == IDBAR_INVALID)
    {
        // We don't recognize this bubby, bail
        return;
    }
    ASSERT(IDBAR_VERTICAL == idBar || IDBAR_HORIZONTAL == idBar);

    // Munge the unholy eOnOffNot
    eOnOffNot = _eOnOffNotMunge(eOnOffNot, idCmd, idBar);
    if (eOnOffNot == 0 && (idCmd != _idmInfo) && (idCmd != _idmComm)) 
    {
        // already off
        return;
    }

    // _ShowHideBrowserBar can affect the size of the view window, but the on/off state of
    // the bar isn't actually updated until we update _idmInfo below.  But we want the
    // view to be able to query the accurate on/off state of the bar during the resize.
    // So postpone resize of the actual hwnd until after the on/off state is set correctly.
    //
    _fHaveDelayedSize = FALSE;
    _hwndDelayedSize = _pbbd->_hwndView;

    // Reduce flicker: turn off window painting while we resize several windows
    BOOL fLock = LockWindowUpdate(_pbbd->_hwnd);

    ASSERT(0 == eOnOffNot || 1 == eOnOffNot);
    pclsid = _ShowHideBrowserBar(idBar, pclsid, eOnOffNot, pidl);

    if (IDBAR_VERTICAL == idBar)
        v_SetIcon();

    if (IDBAR_VERTICAL == idBar)
    {
        // Vertical bar

        // since we support multiple searches in the same band
        // it is possible to have search band open when we clicked on
        // a different search so to avoid flicker we don't "unpress" the button
        if (_idmInfo != idCmd)
            _CheckSearch(_idmInfo, FALSE, _pxtb);

        _idmInfo = eOnOffNot ? idCmd : FCIDM_VBBNOVERTICALBAR;
        _CheckSearch(_idmInfo, TRUE, _pxtb);
    }
    else 
    {
        // Horizontal bar
        _idmComm = eOnOffNot ? idCmd : FCIDM_VBBNOHORIZONTALBAR;
    }

    // Make sure that the toolbar is updated
    Exec(NULL, OLECMDID_UPDATECOMMANDS, 0, NULL, NULL);

    //set the dirty bit on itbar and save
    Exec(&CGID_PrivCITCommands, CITIDM_SET_DIRTYBIT, TRUE, NULL, NULL);
    Exec(&CGID_ShellBrowser, FCIDM_PERSISTTOOLBAR, 0, NULL, NULL);

    // If we delayed a resize of the view window, update it now
    if (_fHaveDelayedSize)
    {
        HWND hwnd = _hwndDelayedSize;
        _hwndDelayedSize = NULL;
        _PositionViewWindow(hwnd, &_rcDelayedSize);
    }
    else
    {
        _hwndDelayedSize = NULL;
    }

    if (fLock)
        LockWindowUpdate(NULL);
}

//***   do the op, but do *not* update the UI
// ENTRY/EXIT
//  return      guy who's now visible (pclsid, 0 [VBBNONE], or 1 [VBBALL])
// NOTES
//  don't call this directly, it's just a helper.
//  don't reference UI stuff (_idmInfo etc.) (except for ASSERTs).
const CLSID * CShellBrowser2::_ShowHideBrowserBar(int idBar, const CLSID *pclsid, int eOnOff, LPCITEMIDLIST pidl /*= NULL*/)
{
    ASSERT(IDBAR_VERTICAL == idBar || IDBAR_HORIZONTAL == idBar);

    IBandSite* pbsSite = NULL;
    HRESULT    hr = E_FAIL;

    if (_fUISetByAutomation)
    {
        if (0 == eOnOff || NULL == pclsid)
        {
            // if pclsid -- hide that bar, else -- hide everyone
            ASSERT(NULL == pclsid || _InfoCLSIDToIdm(pclsid) == ((IDBAR_VERTICAL == idBar) ? _idmInfo : _idmComm));

            _GetBrowserBar(idBar, FALSE, NULL, NULL);
            return NULL;
        }
    }

    if (0 == eOnOff || NULL == pclsid)
    {
        // if pclsid -- hide that bar, else -- hide everyone
        ASSERT(NULL == pclsid || _InfoCLSIDToIdm(pclsid) == ((IDBAR_VERTICAL == idBar) ? _idmInfo : _idmComm));

        _GetBrowserBar(idBar, FALSE, NULL, NULL);
        return NULL;
    }

    hr = _GetBandSite(idBar, &pbsSite, pclsid, eOnOff);
    if (SUCCEEDED(hr))
    {
        hr = _EnsureAndNavigateBand(pbsSite, pclsid, pidl);
        ASSERT(pbsSite);  // _GetBandSite() or _GetBrowserBand() flunked with its return code ?
        pbsSite->Release();
    }

    return SUCCEEDED(hr) ? pclsid : NULL;
}

HRESULT CShellBrowser2::_GetBandSite(int idBar, IBandSite** ppbsSite, const CLSID *pclsid, int eOnOff)
{
    *ppbsSite = NULL;

    LPCWSTR pwszItem = (IDBAR_VERTICAL == idBar) ? INFOBAR_TBNAME : COMMBAR_TBNAME;

    //----- Persist current DeskBar (if it exists) -----
    IDeskBar* pdbBar;
    HRESULT hr = FindToolbar(pwszItem, IID_PPV_ARG(IDeskBar, &pdbBar));
    if (S_OK == hr) 
    {
        VARIANT varClsid;

        // if a bar is being shown, tell CBrowserBar which clsid it is
        SA_BSTRGUID strClsid;
        InitFakeBSTR(&strClsid, *pclsid);

        varClsid.vt      = VT_BSTR;
        varClsid.bstrVal = strClsid.wsz;

        IUnknown_Exec(pdbBar, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, eOnOff, &varClsid, NULL);
    }
    ATOMICRELEASE(pdbBar);

    // get bar (create/cache or retrieve from cache)
    return _GetBrowserBar(idBar, TRUE, ppbsSite, pclsid);
}

HRESULT CShellBrowser2::_EnsureAndNavigateBand(IBandSite* pbsSite, const CLSID* pclsid, LPCITEMIDLIST pidl /*= NULL*/)
{
    ASSERT(NULL != pbsSite);
    ASSERT(NULL != pclsid);

    IDeskBand* pdbBand = NULL;
    HRESULT    hr = E_FAIL;

    if (NULL != _pbbd->_pautoWB2)
    {
        // check if this band can be found through automation
        SA_BSTRGUID strClsid;
        InitFakeBSTR(&strClsid, *pclsid);

        VARIANT varProp;
        hr = _pbbd->_pautoWB2->GetProperty(strClsid.wsz, &varProp);
        if (SUCCEEDED(hr))
        {
            if (VT_UNKNOWN == varProp.vt && NULL != varProp.punkVal)
            {
                hr = varProp.punkVal->QueryInterface(IID_PPV_ARG(IDeskBand, &pdbBand));
            }
            else
            {
                hr = E_FAIL;
            }

            VariantClear(&varProp);
        }

        // this property doesn't exist yet, so create a new band
        if (FAILED(hr))
        {                
            pdbBand = _GetInfoBandBS(pbsSite, *pclsid);
            if (pdbBand)
            {
                // add to the property so that it can be found later
                VARIANT var;
                var.vt      = VT_UNKNOWN;
                var.punkVal = pdbBand;

                _pbbd->_pautoWB2->PutProperty(strClsid.wsz, var);
            }
        }
    }

    // automation object is not there, try to succeed anyway
    if (NULL == pdbBand)
    {
        ASSERTMSG(FALSE, "IWebBrowser2 is not available");
        pdbBand = _GetInfoBandBS(pbsSite, *pclsid);
    }

    if (pdbBand)
    {
        IBandNavigate* pbn;

        if (pidl && SUCCEEDED(pdbBand->QueryInterface(IID_PPV_ARG(IBandNavigate, &pbn))))
        {
            pbn->Select(pidl);
            pbn->Release();
        }

        // show me, hide everyone else
        VARIANT var;
        var.vt      = VT_UNKNOWN;
        var.punkVal = pdbBand;

        // Exec -> Select or SetBandState
        IUnknown_Exec(pbsSite, &CGID_DeskBand, DBID_SHOWONLY, OLECMDEXECOPT_PROMPTUSER, &var, NULL);

        pdbBand->Release();
        hr = S_OK;
    }

    return hr;
}

BANDCLASSINFO* CShellBrowser2::_BandClassInfoFromCmdID(UINT idCmd)
{
    if (IsInRange(idCmd, FCIDM_VBBDYNFIRST, FCIDM_VBBDYNLAST))
    {
        if (_pbsmInfo)
        {
            int i, cnt = _pbsmInfo->GetBandClassCount(NULL, FALSE);
            for (i = 0; i < cnt; i++)
            {
                BANDCLASSINFO *pbci = _pbsmInfo->GetBandClassDataStruct(i);
                if (pbci && idCmd == pbci->idCmd)
                    return pbci;
            }
        }
    }

    return NULL;
}

// map menu ID valued (FCIDM_VBB*'s) to corresponding CLSID
// handles both 'fixed' and dynamic guys

const CLSID *CShellBrowser2::_InfoIdmToCLSID(UINT idCmd)
{
    const CLSID *pclsid = NULL;

    if (IsInRange(idCmd, FCIDM_VBBFIXFIRST, FCIDM_VBBFIXLAST))
    {
        switch (idCmd) {
        case FCIDM_VBBSEARCHBAND:       pclsid = &CLSID_SearchBand; break;
        case FCIDM_VBBFAVORITESBAND:    pclsid = &CLSID_FavBand; break;
        case FCIDM_VBBHISTORYBAND:      pclsid = &CLSID_HistBand; break;
        case FCIDM_VBBEXPLORERBAND:     pclsid = &CLSID_ExplorerBand; break;
        case FCIDM_VBBMEDIABAND:        pclsid = &CLSID_MediaBand; break;
        }
    }
    else
    {
        BANDCLASSINFO* pbci = _BandClassInfoFromCmdID(idCmd);
        if (pbci)
            pclsid = &pbci->clsid;
    }

    return pclsid;
}

const CATID *CShellBrowser2::_InfoIdmToCATID(UINT idCmd)
{
    const CATID* pcatid = NULL;

    if (IsInRange(idCmd, FCIDM_VBBFIXFIRST, FCIDM_VBBFIXLAST))
    {
        // The fixed bars are all in the vertical comcat
        pcatid = &CATID_InfoBand;
    }
    else
    {
        // Dynamic bar, have to look up the catid
        BANDCLASSINFO* pbci = _BandClassInfoFromCmdID(idCmd);
        if (pbci)
            pcatid = &pbci->catid;
    }

    return pcatid;
}

UINT CShellBrowser2::_InfoCLSIDToIdm(const CLSID *pguid)
{
    if (pguid == NULL)
        return 0;
    else if (IsEqualIID(*pguid, CLSID_ExplorerBand))
        return FCIDM_VBBEXPLORERBAND;
    else if (IsEqualIID(*pguid, CLSID_SearchBand))
        return FCIDM_VBBSEARCHBAND;
    else if (IsEqualIID(*pguid, CLSID_FileSearchBand))
        return FCIDM_VBBSEARCHBAND;
    else if (IsEqualIID(*pguid, CLSID_FavBand))
        return FCIDM_VBBFAVORITESBAND;
    else if (IsEqualIID(*pguid, CLSID_HistBand)) 
        return FCIDM_VBBHISTORYBAND;
    else if (IsEqualIID(*pguid, CLSID_MediaBand)) 
        return FCIDM_VBBMEDIABAND;
    else 
    {
        if (!_pbsmInfo)
        {
            // Load the Browser Bar Menu to load the class ids of all Component Categories dynamic Browser bars
            _AddBrowserBarMenuItems(_GetBrowserBarMenu());

            // Unable to load the clsids from dynamic bars.
            if (!_pbsmInfo)
                return -1;
        }

        BANDCLASSINFO *pbci;
        for (int i = 0; NULL != (pbci = _pbsmInfo->GetBandClassDataStruct(i)); i++)
            if (IsEqualIID(*pguid, pbci->clsid))
                return (pbci->idCmd);

        // FEATURE: look up in _pbsmInfo->LoadFromComCat's HDPA
        // ASSERT(0);
    }
    return -1;
}

HBITMAP CreateColorBitmap(int cx, int cy)
{
    HBITMAP hbm = NULL;

    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        hbm = CreateCompatibleBitmap(hdc, cx, cy);
        ReleaseDC(NULL, hdc);
    }

    return hbm;
}

HRESULT CShellBrowser2::_GetBSForBar(LPCWSTR pwszItem, IBandSite **ppbs)
{
    *ppbs = NULL;
    IDeskBar *pdbBar;
    HRESULT hr = FindToolbar(pwszItem, IID_PPV_ARG(IDeskBar, &pdbBar));
    if (hr == S_OK) 
    {
        IUnknown *punkBS;
        hr = pdbBar->GetClient(&punkBS);
        if (SUCCEEDED(hr)) 
        {
            hr = punkBS->QueryInterface(IID_PPV_ARG(IBandSite, ppbs));
            ASSERT(SUCCEEDED(hr));
            punkBS->Release();
        }
        pdbBar->Release();
    }
    return hr;
}

void CShellBrowser2::_ExecAllBands(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, 
                            VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    IBandSite *pbsBS;

    HRESULT hres = _GetBSForBar(INFOBAR_TBNAME, &pbsBS);
    if (hres == S_OK) 
    {
        DWORD dwBandID;
        for (int i = 0; SUCCEEDED(pbsBS->EnumBands(i, &dwBandID)); i++) 
        {
            IDeskBand *pstb;
            hres = pbsBS->QueryBand(dwBandID, &pstb, NULL, NULL, 0);
            if (SUCCEEDED(hres)) 
            {
                IUnknown_Exec(pstb, pguidCmdGroup, nCmdID, nCmdexecopt, 
                                pvarargIn, pvarargOut);
                pstb->Release();
            }
        }
        pbsBS->Release();
    }
 }

HRESULT CShellBrowser2::_GetBrowserBar(int idBar, BOOL fShow, IBandSite** ppbs, const CLSID* pclsid)
{
    HRESULT hres;
    IUnknown *punkBar;
    IDeskBar *pdbBar = NULL;
    IUnknown *punkBS = NULL;

    if (ppbs) 
        *ppbs = NULL;
    
    if (IDBAR_VERTICAL == idBar)
    {
        hres = FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdbBar));
    }
    else
    {
        ASSERT(IDBAR_HORIZONTAL == idBar);  // No other bars right now.
        hres = FindToolbar(COMMBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdbBar));
    }

    TraceMsg(DM_MISC, "CSB::_GetBrowserBar FindToolbar returned %x", hres);

    BOOL fTurnOffAutoHide = FALSE;
    if (hres == S_OK)
    {
        // already have one
        hres = pdbBar->GetClient((IUnknown**) &punkBS);
        ASSERT(SUCCEEDED(hres));
        punkBar = pdbBar;
        // punkBar->Release() down below        
    }
    else 
    {
        //if there's not a bar, don't bother creating one so it can be hidden
        if (!fShow)
            return S_OK;

        // 1st time, create a new one
        CBrowserBar* pdb = new CBrowserBar();
        if (NULL == pdb)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            // add it
            pdb->QueryInterface(IID_PPV_ARG(IUnknown, &punkBar));

            //if a bar is being shown, tell CBrowserBar which clsid it is
            SA_BSTRGUID strClsid;
            InitFakeBSTR(&strClsid, *pclsid);

            VARIANT varClsid;
            varClsid.vt = VT_BSTR;
            varClsid.bstrVal = strClsid.wsz;
        
            IUnknown_Exec(punkBar, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, fShow, &varClsid, NULL);

            UINT uiWidthOrHeight = pdb->_PersistState(NULL, FALSE);

            //don't let anyone be 0 width
            if (uiWidthOrHeight == 0)
                uiWidthOrHeight = (IDBAR_VERTICAL == idBar) ? INFOBAR_WIDTH : COMMBAR_HEIGHT;

            fTurnOffAutoHide = !(GetSystemMetrics(SM_CXSCREEN) <= 800);

            CBrowserBarPropertyBag* ppb;

            //  FEATURE - this needs to be persisted and restored
            //  when % widths are implemented, should use that
            ppb = new CBrowserBarPropertyBag();
            if (ppb)
            {
                if (IDBAR_VERTICAL == idBar)
                {
                    ppb->SetDataDWORD(PROPDATA_SIDE, ABE_LEFT);     // LEFT
                    ppb->SetDataDWORD(PROPDATA_LEFT, uiWidthOrHeight);
                    ppb->SetDataDWORD(PROPDATA_RIGHT, uiWidthOrHeight);
                }
                else
                {
                    ppb->SetDataDWORD(PROPDATA_SIDE, ABE_BOTTOM);     // BOTTOM
                    ppb->SetDataDWORD(PROPDATA_TOP, uiWidthOrHeight);
                    ppb->SetDataDWORD(PROPDATA_BOTTOM, uiWidthOrHeight);
                }

                ppb->SetDataDWORD(PROPDATA_MODE, WBM_BBOTTOMMOST);

                SHLoadFromPropertyBag(punkBar, ppb);
                ppb->Release();
            }

            hres = AddToolbar(punkBar, (IDBAR_VERTICAL == idBar) ? INFOBAR_TBNAME : COMMBAR_TBNAME, DWFAF_HIDDEN);

            if (SUCCEEDED(hres))
            {
                hres = BrowserBar_Init(pdb, &punkBS, idBar);
            }

            pdb->Release();
        }
    }
    // need to set band info here each time since deskbar/bandsite get reused
    if (fShow && punkBS)
    {
        BANDSITEINFO bsinfo;
        bsinfo.dwMask = BSIM_STYLE;
        bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_LEFTALIGN;
        
        IBandSite* pSite;
        HRESULT hr = punkBS->QueryInterface(IID_PPV_ARG(IBandSite, &pSite));
        if (SUCCEEDED(hr)) 
        {
            pSite->SetBandSiteInfo(&bsinfo);
            pSite->Release();
        }
    }

    // note: must call _SetTheaterBrowserBar BEFORE ShowToolbar when showing bar
    if (IDBAR_VERTICAL == idBar && fShow)
        _SetTheaterBrowserBar();    
    ShowToolbar(punkBar, fShow);      
    // note: must call _SetTheaterBrowserBar AFTER ShowToolbar when hiding bar
    if (IDBAR_VERTICAL == idBar && !fShow)
        _SetTheaterBrowserBar();

    //tell CBrowserBar about the new bar, must be AFTER it is shown (to get the size right)
    if (SUCCEEDED(hres) && fShow)
    {
        //if a bar is being shown, tell CBrowserBar which clsid it is
        SA_BSTRGUID strClsid;
        InitFakeBSTR(&strClsid, *pclsid);

        VARIANT varClsid;
        varClsid.vt = VT_BSTR;
        varClsid.bstrVal = strClsid.wsz;
    
        IUnknown_Exec(punkBar, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, fShow, &varClsid, NULL);
    }
    else
    {
        IUnknown_Exec(punkBar, &CGID_DeskBarClient, DBCID_CLSIDOFBAR, 0, NULL, NULL);
    }

    // note: must have called ShowToolbar BEFORE setting pin button state
    if (fTurnOffAutoHide)
    {
        VARIANT v = { VT_I4 };
        v.lVal = FALSE;
        IUnknown_Exec(punkBar, &CGID_Theater, THID_SETBROWSERBARAUTOHIDE, 0, &v, &v);
    }

    punkBar->Release();

    //FEATURE: What should we do for CommBar in Theatre Mode?

    if (punkBS)
    {
        HRESULT hr = S_OK;
        if (ppbs)
        {
            hr = punkBS->QueryInterface(IID_PPV_ARG(IBandSite, ppbs));
        }
        punkBS->Release();
        
        return hr;  // there are callers to _GetBrowserBar which need to know if QI for IBandSite succeeded
    }
    
    return E_FAIL;
}


#ifdef DEBUG
//***   DBCheckCLSID -- make sure class tells truth about its CLSID
//
BOOL DBCheckCLSID(IUnknown *punk, const CLSID *pclsid)
{
    CLSID clsid;

    HRESULT hr = IUnknown_GetClassID(punk, &clsid);
    if (SUCCEEDED(hr) && IsEqualGUID(*pclsid, clsid))
        return TRUE;

    TraceMsg(DM_ERROR, "dbcc: CLSID mismatch! &exp=%x &act=%x", pclsid, clsid);
    return FALSE;
}
#endif

IDeskBand * _GetInfoBandBS(IBandSite *pbs, REFCLSID clsid)
{
    IDeskBand *pstb = FindBandByClsidBS(pbs, clsid);
    if (pstb == NULL) 
    {
        TraceMsg(DM_MISC, "_gib: create band");

        if (SUCCEEDED(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IDeskBand, &pstb))))
        {
            // hide all bands before adding new band
            VARIANTARG vaIn = { 0 };
            vaIn.vt = VT_UNKNOWN;
            vaIn.punkVal = 0;
            IUnknown_Exec(pbs, &CGID_DeskBand, DBID_SHOWONLY, OLECMDEXECOPT_PROMPTUSER, &vaIn, NULL);

            pbs->AddBand(pstb);
        }
    }

    return pstb;
}

void CShellBrowser2::_OrganizeFavorites()
{
    TCHAR szPath[MAX_PATH];

    if (SHGetSpecialFolderPath(NULL, szPath, CSIDL_FAVORITES, TRUE))
    {
        if (GetKeyState(VK_SHIFT) < 0)
        {
            OpenFolderPath(szPath);
        }
        else
            DoOrganizeFavDlgW(_pbbd->_hwnd, NULL);
    }
}

/*----------------------------------------------------------
Purpose: Handle WM_COMMAND for favorites menu

*/
void CShellBrowser2::_FavoriteOnCommand(HMENU hmenu, UINT idCmd)
{
    switch (idCmd) 
    {
    case FCIDM_ORGANIZEFAVORITES:
        _OrganizeFavorites();
        break;

    case FCIDM_ADDTOFAVORITES:
        Exec(&CGID_Explorer, SBCMDID_ADDTOFAVORITES, OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
        // Instrument add to favorites from menu
        UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_ADDTOFAV, UIBL_MENU);        
        break;

    case FCIDM_UPDATESUBSCRIPTIONS:
        UpdateSubscriptions();
        break;
    }
}

HRESULT CShellBrowser2::CreateBrowserPropSheetExt(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;

    IUnknown *punk;
    HRESULT hr = CoCreateInstance(CLSID_ShellFldSetExt, NULL, CLSCTX_INPROC_SERVER, riid, (void **)&punk);
    if (SUCCEEDED(hr)) 
    {
        IShellExtInit *psxi;
        hr = punk->QueryInterface(IID_PPV_ARG(IShellExtInit, &psxi));
        if (SUCCEEDED(hr)) 
        {
            hr = psxi->Initialize(NULL, NULL, 0);
            if (SUCCEEDED(hr)) 
            {
                IUnknown_SetSite(punk, SAFECAST(this, IShellBrowser*));
                IUnknown_Set((IUnknown **)ppvObj, punk);
                hr = S_OK;            // All happy
            }
            psxi->Release();
        }
        punk->Release();
    }
    return hr;
}

LPITEMIDLIST CShellBrowser2::_GetSubscriptionPidl()
{
    LPITEMIDLIST        pidlSubscribe = NULL;
    IDispatch *         pDispatch = NULL;
    IHTMLDocument2 *    pHTMLDocument = NULL;

    // Search HTML for <LINK REL="Subscription" HREF="{URL}">
    if  (
        SUCCEEDED(_pbbd->_pautoWB2->get_Document(&pDispatch))
        &&
        SUCCEEDED(pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pHTMLDocument)))
       )
    {
        IHTMLElementCollection * pLinksCollection;

        if (SUCCEEDED(GetDocumentTags(pHTMLDocument, OLESTR("LINK"), &pLinksCollection)))
        {
            long lItemCnt;

            // Step through each of the LINKs in the
            // collection looking for REL="Subscription".
            EVAL(SUCCEEDED(pLinksCollection->get_length(&lItemCnt)));
            for (long lItem = 0; lItem < lItemCnt; lItem++)
            {
                IDispatch *         pDispItem = NULL;
                IHTMLLinkElement *  pLinkElement = NULL;

                VARIANT vEmpty = { 0 };
                VARIANT vIndex; V_VT(&vIndex) = VT_I4; V_I4(&vIndex) = lItem;

                if  (
                    SUCCEEDED(pLinksCollection->item(vIndex, vEmpty, &pDispItem))
                    &&
                    SUCCEEDED(pDispItem->QueryInterface(IID_IHTMLLinkElement,
                                                        (void **)&pLinkElement))
                   )
                {
                    BSTR bstrREL = NULL;
                    BSTR bstrHREF = NULL;

                    // Finally! We have a LINK element, check its REL type.
                    if  (
                        SUCCEEDED(pLinkElement->get_rel(&bstrREL))
                        &&
                        (bstrREL != NULL)
                        &&
                        SUCCEEDED(pLinkElement->get_href(&bstrHREF))
                        &&
                        (bstrHREF != NULL)
                       )
                    {
                        // Check for REL="Subscription"
                        if (StrCmpIW(bstrREL, OLESTR("Subscription")) == 0)
                        {
                            TCHAR szName[MAX_URL_STRING];

                            SHUnicodeToTChar(bstrHREF, szName, ARRAYSIZE(szName));
                            EVAL(SUCCEEDED(IECreateFromPath(szName, &pidlSubscribe)));
                        }
                    }

                    if (bstrHREF != NULL)
                        SysFreeString(bstrHREF);

                    if (bstrREL != NULL)
                        SysFreeString(bstrREL);
                }

                VariantClear(&vIndex);
                VariantClear(&vEmpty);

                SAFERELEASE(pLinkElement);
                SAFERELEASE(pDispItem);

                // If we found a correctl REL type, quit searching.
                if (pidlSubscribe != NULL)
                    break;
            }

            pLinksCollection->Release();
        }
    }

    SAFERELEASE(pHTMLDocument);
    SAFERELEASE(pDispatch);

    return pidlSubscribe;
}

LPITEMIDLIST CShellBrowser2::_TranslateRoot(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlChild = ILFindChild(ILRootedFindIDList(_pbbd->_pidlCur), pidl);

    ASSERT(pidlChild);

    LPITEMIDLIST pidlRoot = ILCloneFirst(_pbbd->_pidlCur);

    if (pidlRoot)
    {
        LPITEMIDLIST pidlRet = ILCombine(pidlRoot, pidlChild);
        ILFree(pidlRoot);
        return pidlRet;
    }

    return NULL;
}

BOOL CShellBrowser2::_ValidTargetPidl(LPCITEMIDLIST pidl, BOOL *pfTranslateRoot)
{
    // validate that this is an allowable target to browse to.
    // check that it is a child of our root.
    if (pfTranslateRoot)
        *pfTranslateRoot = FALSE;
        
    if (ILIsRooted(_pbbd->_pidlCur)) 
    {
        BOOL fRet = ILIsEqualRoot(_pbbd->_pidlCur, pidl);

        if (!fRet && pfTranslateRoot 
        && ILIsParent(ILRootedFindIDList(_pbbd->_pidlCur), pidl, FALSE))
        {
            fRet = TRUE;
            *pfTranslateRoot = TRUE;
        }
                
        return fRet;
    }
    
    return TRUE;
}

IStream* CShellBrowser2::_GetITBarStream(BOOL fWebBrowser, DWORD grfMode)
{
    return GetITBarStream(fWebBrowser ? ITBS_WEB : ITBS_SHELL, grfMode);
}

HRESULT CShellBrowser2::_SaveITbarLayout(void)
{
    HRESULT hres = E_FAIL;

#ifdef NO_MARSHALLING
    if (!_fOnIEThread)
      return S_OK;
#endif

    if (_fUISetByAutomation || _ptheater)
    {
        return S_OK;
    }
    if (_GetITBar())
    {
        IPersistStreamInit  *pITbarPSI;

        //Yes! It's a different type. We may need to save the stream
        if (SUCCEEDED(_GetITBar()->QueryInterface(IID_PPV_ARG(IPersistStreamInit, &pITbarPSI))))
        {
            //Do we need to save the stream?
            if (pITbarPSI->IsDirty() == S_OK)
            {
                BOOL fInternet = (CITE_INTERNET == 
                    GetScode(IUnknown_Exec(pITbarPSI, &CGID_PrivCITCommands, CITIDM_ONINTERNET, CITE_QUERY, NULL, NULL)));
                IStream *pstm = _GetITBarStream(fInternet, STGM_WRITE);
                if (pstm)
                {
                    //Stream exists. Save it there!.
                    hres = pITbarPSI->Save(pstm, TRUE);
                    pstm->Release();
                }
                else
                {
                    //Stream creation failed! Why?
                    TraceMsg(DM_ITBAR, "CSB::_SaveITbarLayout ITBar Stream creation failed");
                    ASSERT(0);
                }
            }
            else
                hres = S_OK; // No need to save. Return success!

            pITbarPSI->Release();
        }
        else
        {
            //ITBar doesn't support IPersistStreamInit?
            AssertMsg(0, TEXT("CSB::_NavigateToPidl ITBar doesn't support IPersistStreamInit"));
        }
    }

    return hres;
}

// Returns TRUE if we are supposed to fail the navigate, FALSE otherwise
BOOL MaybeRunICW(LPCITEMIDLIST pidl, IShellBrowser *psb, HWND hwndUI)
{
    TCHAR szURL[MAX_URL_STRING];

    EVAL(SUCCEEDED(IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szURL, SIZECHARS(szURL), NULL)));
    if (UrlHitsNetW(szURL) && !UrlIsInstalledEntry(szURL)) 
    {
        if ((CheckRunICW(szURL)) || CheckSoftwareUpdateUI(hwndUI, psb)) // see if ICW needs to run
            return TRUE;
    }

    return FALSE;
}

HRESULT CShellBrowser2::_NavigateToPidl(LPCITEMIDLIST pidl, DWORD grfHLNF, DWORD dwFlags)
{
    if (pidl) 
    {
        ASSERT(_ValidTargetPidl(pidl, NULL)); 

        if (!g_fICWCheckComplete && IsBrowserFrameOptionsPidlSet(pidl, BFO_USE_DIALUP_REF))
        {
            if (MaybeRunICW(pidl, SAFECAST(this, IShellBrowser *), _pbbd->_hwnd))
            {
                // ICW ran and this was first navigate, shut down now.
                // Or the user wants a software update, so we're launching a new browser
                // to the update page
                _pbbd->_pautoWB2->put_Visible(FALSE);
                _pbbd->_pautoWB2->Quit();
                return E_FAIL;
            }                 
        }

        if (!_fVisitedNet && IsBrowserFrameOptionsPidlSet(pidl, BFO_USE_DIALUP_REF))
            _IncrNetSessionCount();
    }

    // See if we are about to navigate to a pidl of a different type. If so, 
    // open the stream and call the ITBar's IPersistStreamInit::save to save.
    // If we don't have a _pidlCur, then we're opening for the first time, so don't need to save
    if (_pbbd->_pidlCur && _GetITBar())
    {
        //Check if we are about to navigate to a different "type" of folder
        if (((INT_PTR)_pbbd->_pidlCur && !IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_BROWSER_PERSIST_SETTINGS)) != 
           ((INT_PTR)pidl && !IsBrowserFrameOptionsPidlSet(pidl, BFO_BROWSER_PERSIST_SETTINGS)))
        {
            _SaveITbarLayout();
        }
    }
    
    return SUPERCLASS::_NavigateToPidl(pidl, grfHLNF, dwFlags);
}

HRESULT CShellBrowser2::BrowseObject(LPCITEMIDLIST pidl, UINT wFlags)
{
    HRESULT hr;
    LPITEMIDLIST pidlFree = NULL;

    // if we're about to go to a new browser, save the layout so that they'll pick it up
    if (wFlags & SBSP_NEWBROWSER) 
        _SaveITbarLayout();

    // 99/03/30 vtan: part of #254171 addition
    // explore with explorer band     visible = same window
    // explore with explorer band NOT visible =  new window
    if (wFlags & SBSP_EXPLOREMODE)
    {
        BOOL fExplorerBandVisible;
        if (SUCCEEDED(IsControlWindowShown(FCW_TREE, &fExplorerBandVisible)) && fExplorerBandVisible)
        {
            wFlags &= ~SBSP_NEWBROWSER;
            wFlags |= SBSP_SAMEBROWSER;
        }
        else
        {
            wFlags &= ~SBSP_SAMEBROWSER;
            wFlags |= SBSP_NEWBROWSER;
        }
    }
    
    // if the caller did not specify explictly "new window" or "same window"
    // we compute that here for them. note, CBaseBrowser assumes SBSP_SAMEBROWSER
    // if SBSP_NEWBROWSER is not specified

    if ((wFlags & (SBSP_NEWBROWSER | SBSP_SAMEBROWSER)) == 0)
    {
        CABINETSTATE cs;
        GetCabState(&cs);
        if (GetAsyncKeyState(VK_CONTROL) < 0)
            cs.fNewWindowMode = !cs.fNewWindowMode;
        if (cs.fNewWindowMode)
            wFlags |= SBSP_NEWBROWSER | SBSP_NOTRANSFERHIST;
    }

    BOOL fTranslate = FALSE;

    // REVIEW: do this only if NEWBROWSER is not set?
    if (pidl && pidl != (LPCITEMIDLIST)-1 && !_ValidTargetPidl(pidl, &fTranslate))
    {
        OpenFolderPidl(pidl);   // we can't navigate to it...  create a new top level dude
        return E_FAIL;
    }

    if (fTranslate)
    {
        pidl = pidlFree = _TranslateRoot(pidl);
    }

    if ((wFlags & SBSP_PARENT) && !_ShouldAllowNavigateParent())
    {
        hr =  E_FAIL;
        goto exit;
    }

#ifdef BROWSENEWPROCESS_STRICT // "Nav in new process" has become "Launch in new process", so this is no longer needed
    // If we want to be strict about BrowseNewProcess (apparently not,
    // given recent email discussions), we'd have to try this one in
    // a new process.  However, don't do that if the window would wind up
    // completely blank.
    //
    if ((_pbbd->_pidlCur || _pbbd->_pidlPending) && TryNewProcessIfNeeded(pidl))
    {
        hr = S_OK;
        goto exit;
    }
#endif

    hr = SUPERCLASS::BrowseObject(pidl, wFlags);

exit:
    ILFree(pidlFree);
    return hr;
}


void CShellBrowser2::_ToolTipFromCmd(LPTOOLTIPTEXT pnm)
{
    UINT idCommand = (UINT)pnm->hdr.idFrom;
    LPTSTR pszText = pnm->szText;
    int cchText = ARRAYSIZE(pnm->szText);
    DWORD dwStyle;

    ITravelLog *ptl;

    if (pnm->hdr.hwndFrom)
        dwStyle = GetWindowLong(pnm->hdr.hwndFrom, GWL_STYLE);

    switch (idCommand) {
    case FCIDM_NAVIGATEBACK:
    case FCIDM_NAVIGATEFORWARD:
        if (SUCCEEDED(GetTravelLog(&ptl)))
        {
            WCHAR wzText[MAX_PATH];

            ASSERT(ptl);
            if (S_OK == ptl->GetToolTipText(SAFECAST(this, IShellBrowser *), idCommand == FCIDM_NAVIGATEBACK ? TLOG_BACK : TLOG_FORE, 0, wzText, ARRAYSIZE(wzText)))
            {
                SHUnicodeToTChar(wzText, pszText, cchText);
                if (pnm->hdr.hwndFrom)
                    SetWindowLong(pnm->hdr.hwndFrom, GWL_STYLE, dwStyle | TTS_NOPREFIX);
            }
            ptl->Release();
            return;
        }
        break;
    }

    if (pnm->hdr.hwndFrom)
        SetWindowLong(pnm->hdr.hwndFrom, GWL_STYLE, dwStyle & ~(TTS_NOPREFIX));
    if (!MLLoadString(idCommand + MH_TTBASE, pszText, cchText))
        *pszText = 0;
}

void CShellBrowser2::v_ParentFolder()
{
    if (_ShouldAllowNavigateParent()) 
    {
        IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, 0, NULL, NULL);
        if (piei) 
        {
            piei->hwndCaller = _pbbd->_hwnd;
            piei->pidl = ILClone(_pbbd->_pidlCur);
            if (!ILRemoveHiddenID(piei->pidl, IDLHID_NAVIGATEMARKER))
            {
                ILRemoveLastID(piei->pidl);
            }
            piei->uFlags = COF_NORMAL;
            piei->nCmdShow = SW_SHOW;
            piei->psbCaller = this;
            AddRef();
            SHOpenFolderWindow(piei);
        }
    }
}

LRESULT CShellBrowser2::v_ForwardMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return ForwardViewMsg(uMsg, wParam, lParam);
}

HRESULT CShellBrowser2::_GetCodePage(UINT *puiCodePage, DWORD dwCharSet)
{
    HRESULT hres = E_FAIL;
    VARIANT varIn = { 0 };
    VARIANT varResult = { 0 };
    VARIANT *pvarIn;
    
    if (_pbbd->_pctView)
    {
        if (dwCharSet == SHDVID_DOCFAMILYCHARSET)
        {
            // need varIn
            varIn.vt = VT_I4;
            // varIn.lVal is already inited to zero which is what we want
            pvarIn = &varIn;
        }
        else
        {
            pvarIn = NULL;
        }

        _pbbd->_pctView->Exec(&CGID_ShellDocView, dwCharSet, 0, pvarIn, &varResult);
        *puiCodePage = (UINT)varResult.lVal;
    }
    
    return hres;
}


void CShellBrowser2::_SendCurrentPage(DWORD dwSendAs)
{
    if (_pbbd->_pidlCur && !ILIsEmpty(_pbbd->_pidlCur))
    {
        UINT uiCodePage;
        _GetCodePage(&uiCodePage, SHDVID_DOCCHARSET);

       IOleCommandTarget *pcmdt = NULL;
       if (_pbbd->_pautoWB2)
       {
           (_pbbd->_pautoWB2)->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
           ASSERT(pcmdt);
       }
       SendDocToMailRecipient(_pbbd->_pidlCur, uiCodePage, dwSendAs, pcmdt);
       if (pcmdt)
           pcmdt->Release();
    }
}


typedef void (* PFNSHOWJAVACONSOLE)(void);

// We need a LoadLibrary/GetProcAddress stub here since msjava.lib improperly
// exports ShowJavaConsole as undecorated (ShowJavaConsole vs. _ShowJavaConsole@0).
STDAPI_(void) DL_ShowJavaConsole()
{
    static PFNSHOWJAVACONSOLE s_pfn = (PFNSHOWJAVACONSOLE)-1;

    if (s_pfn == (PFNSHOWJAVACONSOLE)-1)
    {
        HMODULE hmodMSJAVA = LoadLibraryA("MSJAVA.DLL");
        if (hmodMSJAVA)
        {
            s_pfn = (PFNSHOWJAVACONSOLE)GetProcAddress(hmodMSJAVA, "ShowJavaConsole");
        }
        else
        {
            s_pfn = NULL;
        }
    }

    if (s_pfn)
    {
        s_pfn();
    }
}


LRESULT CShellBrowser2::OnCommand(WPARAM wParam, LPARAM lParam)
{
    int id;
    DWORD dwError;

    if (_ShouldForwardMenu(WM_COMMAND, wParam, lParam)) {
        ForwardViewMsg(WM_COMMAND, wParam, lParam);
        return S_OK;
    }
    
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    
    switch(idCmd)
    {
    case FCIDM_MOVE:
    case FCIDM_COPY:
    case FCIDM_PASTE:
    case FCIDM_SELECTALL:
        {
            IOleCommandTarget* pcmdt;
            HRESULT hres = _FindActiveTarget(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
            if (SUCCEEDED(hres)) {
                const static UINT c_mapEdit[] = {
                    OLECMDID_CUT, OLECMDID_COPY, OLECMDID_PASTE, OLECMDID_SELECTALL };
    
                pcmdt->Exec(NULL, c_mapEdit[idCmd-FCIDM_MOVE], OLECMDEXECOPT_PROMPTUSER, NULL, NULL);
                pcmdt->Release();
            }
        }
        return S_OK;

    case FCIDM_DELETE:
    case FCIDM_PROPERTIES:
    case FCIDM_RENAME:
        if (_HasToolbarFocus())
        {
            static const int tbtab[] = {
                FCIDM_DELETE,       FCIDM_PROPERTIES,       FCIDM_RENAME    };
            static const int cttab[] = {
                SBCMDID_FILEDELETE, SBCMDID_FILEPROPERTIES, SBCMDID_FILERENAME };

            DWORD nCmdID = SHSearchMapInt(tbtab, cttab, ARRAYSIZE(tbtab), idCmd);

            IDockingWindow* ptbar = _GetToolbarItem(_itbLastFocus)->ptbar;
            if (SUCCEEDED(IUnknown_Exec(ptbar, &CGID_Explorer, nCmdID, 0, NULL, NULL)))
                return S_OK;
        }

        SUPERCLASS::OnCommand(wParam, lParam);
        break;

    case FCIDM_VIEWAUTOHIDE:
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_VIEWAUTOHIDE, 0, NULL, NULL);
        break;

    case FCIDM_VIEWTOOLBARCUSTOMIZE:
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_VIEWTOOLBARCUSTOMIZE, 0, NULL, NULL);
        break;
        
    case FCIDM_VIEWLOCKTOOLBAR:
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_VIEWLOCKTOOLBAR, 0, NULL, NULL);
        break;

    case FCIDM_VIEWTEXTLABELS:
        if (!SHIsRestricted2W(_pbbd->_hwnd, REST_NoToolbarOptions, NULL, 0))
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_TEXTLABELS, 0, NULL, NULL);
        break;
        
    case FCIDM_EDITPAGE:
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_EDITPAGE, 0, NULL, NULL);
        break;

    case FCIDM_FINDFILES:
        // Call Exec on ourselfes -- it's handled there
        if (!SHIsRestricted2W(_pbbd->_hwnd, REST_NoFindFiles, NULL, 0))
        {
            IDockingWindow* ptbar = _GetToolbarItem(ITB_ITBAR)->ptbar;
            VARIANT  var = {0};
            VARIANT *pvar = NULL;

            if (ptbar)
            {
                pvar = &var;
                var.vt = VT_UNKNOWN;
                var.punkVal = ptbar;
                ptbar->AddRef();
            }
            Exec(NULL, OLECMDID_FIND, OLECMDEXECOPT_PROMPTUSER, pvar, NULL);
            if (ptbar)
                ptbar->Release();
        }
        break;

    case FCIDM_CONNECT:
        DoNetConnect(_pbbd->_hwnd);
        break;

    case FCIDM_DISCONNECT:
        DoNetDisconnect(_pbbd->_hwnd);
        break;

    case FCIDM_FORTEZZA_LOGIN:
        dwError = InternetFortezzaCommand(FORTCMD_LOGON, _pbbd->_hwnd, 0);
        break;

    case FCIDM_FORTEZZA_LOGOUT:
        dwError = InternetFortezzaCommand(FORTCMD_LOGOFF, _pbbd->_hwnd, 0);
        break;

    case FCIDM_FORTEZZA_CHANGE:
        dwError = InternetFortezzaCommand(FORTCMD_CHG_PERSONALITY, _pbbd->_hwnd, 0);
        break;

    case FCIDM_BACKSPACE:
        // NT #216896: We want to use FCIDM_PREVIOUSFOLDER even for URL PIDLs if they
        //             have the folder attribute set because they could be using delegate
        //             pidls thru DefView. (FTP & Web Folders) -BryanSt
        if (_pbbd->_pidlCur && IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_NO_PARENT_FOLDER_SUPPORT))
        {
            ITravelLog *ptl;
            if (SUCCEEDED(GetTravelLog(&ptl)))
            {
                ASSERT(ptl);
                if (S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_FORE, NULL))
                {
                    OnCommand(GET_WM_COMMAND_MPS(FCIDM_NAVIGATEBACK,
                                                  GET_WM_COMMAND_HWND(wParam, lParam),
                                                  GET_WM_COMMAND_CMD(wParam, lParam)));
                }
                ptl->Release();
            }
        } else {
            OnCommand(GET_WM_COMMAND_MPS(FCIDM_PREVIOUSFOLDER,
                                          GET_WM_COMMAND_HWND(wParam, lParam),
                                          GET_WM_COMMAND_CMD(wParam, lParam)));
        }
        break;
        
    case FCIDM_PREVIOUSFOLDER:
        // missnamed...  is really parent folder
        v_ParentFolder();
        break;

    case FCIDM_FILECLOSE:
        PostMessage(_pbbd->_hwnd, WM_CLOSE, 0, 0);
        break;

    case FCIDM_FTPOPTIONS:
        {
            VARIANT varArgs = {0};

            varArgs.vt = VT_I4;
            varArgs.lVal = SBO_NOBROWSERPAGES;
            Exec(&CGID_Explorer, SBCMDID_OPTIONS, 0, &varArgs, NULL);
        }
        break;

    case FCIDM_BROWSEROPTIONS:
        if (!IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_RENAME_FOLDER_OPTIONS_TOINTERNET) ||
            !SHIsRestricted2W(_pbbd->_hwnd, REST_NoBrowserOptions, NULL, 0))
            Exec(&CGID_Explorer, SBCMDID_OPTIONS, 0, NULL, NULL);
        break;

    case FCIDM_RESETWEBSETTINGS:
        ResetWebSettings(_pbbd->_hwnd, NULL);
        break;

    case FCIDM_MAIL:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, MAIL_DEF_KEY);
        break;

    case FCIDM_MYCOMPUTER:
        {
            LPITEMIDLIST pidlMyComputer;

            SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer);
            if (pidlMyComputer)
            {
                BrowseObject(pidlMyComputer, SBSP_SAMEBROWSER);
                ILFree(pidlMyComputer);
            }
        }
        break;

    case FCIDM_CONTACTS:    
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, CONTACTS_DEF_KEY);
        break;

    case FCIDM_NEWS:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, NEWS_DEF_KEY);
        break;

    case FCIDM_CALENDAR:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, CALENDAR_DEF_KEY);
        break;
    
    case FCIDM_TASKS:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, TASKS_DEF_KEY);
        break;
    
    case FCIDM_JOURNAL:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, JOURNAL_DEF_KEY);
        break;
    
    case FCIDM_NOTES:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, NOTES_DEF_KEY);
        break;
    
    case FCIDM_CALL:
        SHRunIndirectRegClientCommand(_pbbd->_hwnd, CALL_DEF_KEY);
        break;

    case FCIDM_NEWMESSAGE:
        DropOnMailRecipient(NULL, 0);
        break;

    case FCIDM_SENDLINK:
    case FCIDM_SENDDOCUMENT:
        _SendCurrentPage(idCmd == FCIDM_SENDDOCUMENT ? FORCE_COPY : FORCE_LINK);
        break;

    case FCIDM_STARTPAGE:
    case FCIDM_UPDATEPAGE:
    case FCIDM_CHANNELGUIDE:
        {
            LPITEMIDLIST pidl = NULL;

            ASSERT(IDP_START == 0);
            ASSERT(FCIDM_STARTPAGE+IDP_START == FCIDM_STARTPAGE);
            ASSERT(FCIDM_STARTPAGE+IDP_UPDATE == FCIDM_UPDATEPAGE);
            ASSERT(FCIDM_STARTPAGE+IDP_CHANNELGUIDE == FCIDM_CHANNELGUIDE);

            HRESULT hres = SHDGetPageLocation(_pbbd->_hwnd, idCmd-FCIDM_STARTPAGE, NULL, 0, &pidl);
            if (SUCCEEDED(hres)) {
                hres = BrowseObject(pidl, SBSP_SAMEBROWSER);
                ILFree(pidl);
            }
        }
        break;

    case FCIDM_SEARCHPAGE:
        {
            // This command from the Windows Explorer's Go menu used to be handled by navigating to 
            // a search page on MSN.  We now maintain consistency with the shell's handling of
            // Start->Find->On the Internet, by invoking the extension directly.

            ASSERT(FCIDM_STARTPAGE+IDP_SEARCH == FCIDM_SEARCHPAGE);

            IContextMenu *pcm; 

            HRESULT hres = CoCreateInstance(CLSID_WebSearchExt, NULL,
                CLSCTX_INPROC_SERVER, IID_IContextMenu, (void **) &pcm);
            if (SUCCEEDED(hres))
            {
                CMINVOKECOMMANDINFO ici = {0};            
                ici.cbSize = sizeof(ici);
                ici.nShow  = SW_NORMAL;
                pcm->InvokeCommand(&ici);
                pcm->Release();
            }
        }
        break;


    case FCIDM_HELPABOUT:
    {
        TCHAR szWindows[64];
        MLLoadString(IDS_WINDOWSNT, szWindows, ARRAYSIZE(szWindows));
        ShellAbout(_pbbd->_hwnd, szWindows, NULL, NULL);
        break;
    }

    case FCIDM_HELPTIPOFTHEDAY:
        _SetBrowserBarState(-1, &CLSID_TipOfTheDay, -1);
        break;

    case FCIDM_HELPISLEGAL:
    {
        TCHAR szFWLinkPathTemplate[MAX_PATH];
        TCHAR szFWLinkPath[MAX_PATH];
        LPITEMIDLIST pidl;

        LoadString(HINST_THISDLL, IDS_FWLINK_HELPISLEGAL, szFWLinkPathTemplate, ARRAYSIZE(szFWLinkPathTemplate));

        if (SUCCEEDED(URLSubstitution(szFWLinkPathTemplate, szFWLinkPath, ARRAYSIZE(szFWLinkPath), URLSUB_CLCID)))
        {
            if (SUCCEEDED(IEParseDisplayName(CP_ACP, szFWLinkPath, &pidl)))
            {
                BrowseObject(pidl, SBSP_SAMEBROWSER);
                ILFree(pidl);
            }
        }
        break;
    }


    case FCIDM_NAVIGATEBACK:
        if (_pbbd->_psvPending)
        {
            _CancelPendingView();
        }
        else 
        {
            if (g_dwStopWatchMode & (SPMODE_BROWSER | SPMODE_JAVA))
            {
                DWORD dwTime = GetPerfTime();

                if (g_dwStopWatchMode & SPMODE_BROWSER)  // Used to get browser total download time
                    StopWatch_StartTimed(SWID_BROWSER_FRAME, TEXT("Browser Frame Back"), SPMODE_BROWSER | SPMODE_DEBUGOUT, dwTime);
                if (g_dwStopWatchMode & SPMODE_JAVA)  // Used to get java applet load time
                    StopWatch_StartTimed(SWID_JAVA_APP, TEXT("Java Applet Back"), SPMODE_JAVA | SPMODE_DEBUGOUT, dwTime);
            }
            NavigateToPidl(NULL, HLNF_NAVIGATINGBACK);
        }
        break;

    case FCIDM_NAVIGATEFORWARD:
        NavigateToPidl(NULL, HLNF_NAVIGATINGFORWARD);
        break;

    case FCIDM_ADDTOFAVNOUI:
        Exec(&CGID_Explorer, SBCMDID_ADDTOFAVORITES, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        // Instrument this, add to favorites called by keyboard 
        UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_ADDTOFAV, UIBL_KEYBOARD);
        break;

    // Some tools relied on the old Command ID...
    case FCIDM_W95REFRESH:
        idCmd = FCIDM_REFRESH;
        // Fall through...
    case FCIDM_REFRESH:
        if (TRUE == _fInRefresh)
        {
            // We are already doing a refresh.  If we keep doing refreshes,
            // then we can enter into infinite recursion.  If the refresh
            // cause a dialog to be displayed and refresh messages keep coming
            // in, then the messagebox call will be called over and over.
            // Besides multiple dialog boxes, this grows the stack until
            // we run out of space and crash.
            break;
        }

        _fInRefresh = TRUE;

    // fall thru...
    case FCIDM_STOP:
    {
        SHELLSTATE ss = {0};
        SHGetSetSettings(&ss, SSF_MAPNETDRVBUTTON, FALSE);
        if ((!_fShowNetworkButtons && ss.fMapNetDrvBtn) ||
            (_fShowNetworkButtons && !ss.fMapNetDrvBtn))
        {
            UINT uiBtnState = 0;
            _fShowNetworkButtons = ss.fMapNetDrvBtn;
            _pxtb->GetState(&CLSID_CommonButtons, TBIDM_CONNECT, &uiBtnState);
            if (ss.fMapNetDrvBtn)
                uiBtnState &= ~TBSTATE_HIDDEN;
            else    
                uiBtnState |= TBSTATE_HIDDEN;
            _pxtb->SetState(&CLSID_CommonButtons, TBIDM_CONNECT, uiBtnState);
            _pxtb->SetState(&CLSID_CommonButtons, TBIDM_DISCONNECT, uiBtnState);
        }

        if (idCmd == FCIDM_REFRESH)
        {
            VARIANT v = {0};
            v.vt = VT_I4;
            v.lVal = OLECMDIDF_REFRESH_NO_CACHE|OLECMDIDF_REFRESH_PROMPTIFOFFLINE;
            Exec(NULL, OLECMDID_REFRESH, OLECMDEXECOPT_DONTPROMPTUSER, &v, NULL);

            // Refresh the toolbar
            if (_pxtb)
            {
                IServiceProvider* psp;
                if (SUCCEEDED(_pxtb->QueryInterface(IID_PPV_ARG(IServiceProvider, &psp))))
                {
                    IAddressBand *pab = NULL;
                    if (SUCCEEDED(psp->QueryService(IID_IAddressBand, IID_IAddressBand, (void**)&pab)))
                    {
                        VARIANTARG varType = {0};
                        varType.vt = VT_I4;
                        varType.lVal = OLECMD_REFRESH_TOPMOST;
                        pab->Refresh(&varType);
                        pab->Release();
                    }
                    psp->Release();
                }
            }
        }
        else
        {
            if (g_dwStopWatchMode & SPMODE_BROWSER)
                StopWatch_Lap(SWID_BROWSER_FRAME | SWID_MASK_BROWSER_STOPBTN, TEXT("Browser Frame Esc"), SPMODE_BROWSER | SPMODE_DEBUGOUT);

            Exec(NULL, OLECMDID_STOP, OLECMDEXECOPT_DONTPROMPTUSER, NULL, NULL);
        }

        if (FCIDM_REFRESH == idCmd)
        {
            _fInRefresh = FALSE;
        }
        break;
    }
    

#ifndef DISABLE_FULLSCREEN

    case FCIDM_THEATER:
        if (!SHRestricted2(REST_NoTheaterMode, NULL, 0))
        {
            // Toggle theater mode.  Don't allow theater mode if we're in kiosk mode.
            if (_ptheater || _fKioskMode) {
                _TheaterMode(FALSE, TRUE);
            } else {
                _TheaterMode(TRUE, FALSE);
            }
        }
        break;

#endif

    case FCIDM_NEXTCTL:
        _CycleFocus(NULL);
        break;

    case FCIDM_VIEWOFFLINE:
        if ((!SHIsGlobalOffline()) && (IsCriticalOperationPending()))
        {
            if (MLShellMessageBox(_pbbd->_hwnd,
                    MAKEINTRESOURCE(IDS_CANCELFILEDOWNLOAD),
                    MAKEINTRESOURCE(IDS_FILEDOWNLOADCAPTION),
                    MB_YESNO | MB_ICONSTOP) == IDNO)
                break;
        }
    
        Offline(SBSC_TOGGLE);
        if (_pbbd->_pszTitleCur)
            _SetTitle(_pbbd->_pszTitleCur);
            
        break;


#ifdef TEST_AMBIENTS
    case FCIDM_VIEWLOCALOFFLINE:
        _LocalOffline(SBSC_TOGGLE);
        break;

    case FCIDM_VIEWLOCALSILENT:
        _LocalSilent(SBSC_TOGGLE);
        break;
#endif // TEST_AMBIENTS


    case FCIDM_VIEWTOOLBAR:
        v_ShowControl(FCW_INTERNETBAR, SBSC_TOGGLE);
        break;

    case FCIDM_VIEWMENU:
        id = CITIDM_VIEWMENU;
        goto ITBarShowBand;

    case FCIDM_VIEWTOOLS:
        id = CITIDM_VIEWTOOLS;
        goto ITBarShowBand;
        
    case FCIDM_VIEWADDRESS:
        id = CITIDM_VIEWADDRESS;
        goto ITBarShowBand;
        
    case FCIDM_VIEWLINKS:
        id = CITIDM_VIEWLINKS;
        goto ITBarShowBand;
            
ITBarShowBand:
        if (!SHIsRestricted2W(_pbbd->_hwnd, REST_NoToolbarOptions, NULL, 0))
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, id, 0, NULL, NULL);
        break;
                
    case FCIDM_VIEWSTATUSBAR:    
        v_ShowControl(FCW_STATUS, SBSC_TOGGLE);                    
        break;
        
    case FCIDM_VBBSEARCHBAND:
        {
            IDockingWindow* ptbar = _GetToolbarItem(ITB_ITBAR)->ptbar;
            VARIANT  var = {0};

            var.vt = VT_I4;
            var.lVal = -1;
            IUnknown_Exec(ptbar, &CLSID_CommonButtons, TBIDM_SEARCH, 0, NULL, &var);
        }
        break;

    case FCIDM_VIEW_PRIVACY_POLICIES:
        {
            if ( _pbbd != NULL && _pbbd->_pctView != NULL)
            {
                HRESULT hr = _pbbd->_pctView->Exec(&CGID_ShellDocView, 
                    SHDVID_PRIVACYSTATUS, TRUE, NULL, NULL);
            }
        }
        break;
    
    case FCIDM_VBBEXPLORERBAND:
    case FCIDM_VBBFAVORITESBAND:
    case FCIDM_VBBHISTORYBAND:
    case FCIDM_VBBMEDIABAND:
        if (g_dwStopWatchMode)
        {
            StopWatch_Start(SWID_EXPLBAR, TEXT("Shell bar Start"), SPMODE_SHELL | SPMODE_DEBUGOUT);
        }

        switch (idCmd)
        {
        case FCIDM_VBBFAVORITESBAND:
            if (SHIsRestricted2W(_pbbd->_hwnd, REST_NoFavorites, NULL, 0))
                break;

        default:
            _SetBrowserBarState(idCmd, NULL, -1);
            break;
        }
        
        if (g_dwStopWatchMode)
        {
            TCHAR szText[100];
            TCHAR szMenu[32];
            DWORD dwTime = GetPerfTime();
            GetMenuString(_GetMenuFromID(FCIDM_MENU_VIEW), idCmd, szMenu, ARRAYSIZE(szMenu) - 1, MF_BYCOMMAND);
            StringCchPrintf(szText, ARRAYSIZE(szText), TEXT("Shell %s bar Stop"), szMenu); // truncation ok since this is for display only
            StopWatch_StopTimed(SWID_EXPLBAR, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT, dwTime);
        }
        break;

    case FCIDM_JAVACONSOLE:
        DL_ShowJavaConsole();
        break;

    case FCIDM_SHOWSCRIPTERRDLG:
        {
            HRESULT hr;

            hr = Exec(&CGID_ShellDocView,
                      SHDVID_DISPLAYSCRIPTERRORS,
                      0,
                      NULL,
                      NULL);

            return hr;
        }
        break;

    default:
        if (IsInRange(idCmd, FCIDM_FAVORITECMDFIRST, FCIDM_FAVORITECMDLAST) 
            && !SHIsRestricted2W(_pbbd->_hwnd, REST_NoFavorites, NULL, 0)) {
            _FavoriteOnCommand(NULL, idCmd);
        } else if (IsInRange(idCmd, FCIDM_RECENTFIRST, FCIDM_RECENTLAST)) {
            ITravelLog *ptl;
            GetTravelLog(&ptl);
            if (ptl)
            {
                ptl->Travel(SAFECAST(this, IShellBrowser *), idCmd - (FCIDM_RECENTFIRST + GOMENU_RECENT_ITEMS) + GOMENU_RECENT_ITEMS / 2);
                ptl->Release();
                UpdateBackForwardState();
            }
        } else if (IsInRange(idCmd, FCIDM_SEARCHFIRST, FCIDM_SEARCHLAST)) {
            if (_pcmSearch)
            {
                CMINVOKECOMMANDINFO ici = {0};
            
                ici.cbSize = sizeof(ici);
                //ici.hwnd = NULL; // no need for hwnd for search cm InvokeCommand
                ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - FCIDM_SEARCHFIRST);
                ici.nShow  = SW_NORMAL;
                _pcmSearch->InvokeCommand(&ici);
            }
            else
            {
                TraceMsg(DM_TRACE, "CSB::OnCommand() - find cmd with NULL pcmFind");
            }
        } else if (IsInRange(idCmd, FCIDM_MENU_TOOLS_FINDFIRST, FCIDM_MENU_TOOLS_FINDLAST)) {
            if (GetUIVersion() < 5 && _pcmFind)
            {
                LPITEMIDLIST pidl = (_pbbd->_pidlPending) ? _pbbd->_pidlPending : _pbbd->_pidlCur;
                TCHAR szPath[MAX_PATH];

                SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, SIZECHARS(szPath), NULL);

                // Handle cases like "desktop" (make it default to My Computer)
                if (!PathIsDirectory(szPath))
                {
                    szPath[0] = TEXT('\0');
                }

                CMINVOKECOMMANDINFO ici = {0};
            
                ici.cbSize = sizeof(ici);
                //ici.hwnd = NULL; // no need for hwnd for search cm InvokeCommand
                ici.lpVerb = (LPSTR)MAKEINTRESOURCE(idCmd - FCIDM_MENU_TOOLS_FINDFIRST);
                ici.nShow  = SW_NORMAL;

                // Set the root of the search
                char szAnsiPath[MAX_PATH];
                szAnsiPath[0] = '\0';
                SHTCharToAnsi(szPath, szAnsiPath, ARRAYSIZE(szAnsiPath));                
                ici.lpDirectory = szAnsiPath;

                _pcmFind->InvokeCommand(&ici);
            }
        } else if (IsInRange(idCmd, FCIDM_VBBDYNFIRST, FCIDM_VBBDYNLAST)) {
            _SetBrowserBarState(idCmd, NULL, -1);
        } else if (IsInRange(idCmd, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST)) {
            _ExecFileContext(idCmd);
        } else if (IsInRange(idCmd, FCIDM_EXTERNALBANDS_FIRST, FCIDM_EXTERNALBANDS_LAST)) {
            id = idCmd - FCIDM_EXTERNALBANDS_FIRST + CITIDM_VIEWEXTERNALBAND_FIRST;
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, id, 0, NULL, NULL);
        } else {
            SUPERCLASS::OnCommand(wParam, lParam);
        }
        break;
    }
    return S_OK;
}

HMENU CShellBrowser2::_GetMenuFromID(UINT uID)
{
    return SHGetMenuFromID(_hmenuCur, uID);
}


void CShellBrowser2::_PruneMailNewsItems(HMENU hmenu)
{
    //
    // REARCHITECT: this logic is duplicated in _OnFileMenuPopup,
    // _OnMailMenuPopup, CDocObjectHost::_OnInitMenuPopup
    //

    // Iterate through the mail, news, contacts, etc. menu items,
    // and for each item, remove the item if either
    //
    // (a) REST_GoMenu is set, or
    // (b) the item has no registered client
    //
    // If all items are removed, remember to remove the separator too.
    // 

    static const struct
    {
        DWORD dwCmd;
        LPCTSTR pszClient;
    }
    c_mailnewsitems[] =
    {
        { FCIDM_MAIL,       MAIL_DEF_KEY },
        { FCIDM_NEWS,       NEWS_DEF_KEY },
        { FCIDM_CONTACTS,   CONTACTS_DEF_KEY },
        { FCIDM_CALENDAR,   CALENDAR_DEF_KEY },
        { FCIDM_TASKS,      TASKS_DEF_KEY },
        { FCIDM_JOURNAL,    JOURNAL_DEF_KEY },
        { FCIDM_NOTES,      NOTES_DEF_KEY },
        { FCIDM_CALL,       CALL_DEF_KEY },
    };

    BOOL fGoRestricted = SHRestricted2(REST_GoMenu, NULL, 0);

    for (int i = 0; i < ARRAYSIZE(c_mailnewsitems); i++)
    {
        if (fGoRestricted || !SHIsRegisteredClient(c_mailnewsitems[i].pszClient))
        {
            DeleteMenu(hmenu, c_mailnewsitems[i].dwCmd, MF_BYCOMMAND);
        }
    }

    _SHPrettyMenu(hmenu);   // to ensure separator is removed if necessary
}

void CShellBrowser2::_ExecFileContext(UINT idCmd)
{
    if (_pcmNsc)
    {
        CMINVOKECOMMANDINFO ici = {
            sizeof(CMINVOKECOMMANDINFO),
                0L,
                _pbbd->_hwnd,
                MAKEINTRESOURCEA(idCmd-FCIDM_FILECTX_FIRST),
                NULL, 
                NULL,
                SW_NORMAL,
        };
        _pcmNsc->InvokeCommand(&ici);

        // It's no good after an invoke...
        IUnknown_SetSite(_pcmNsc, NULL);
        ATOMICRELEASE(_pcmNsc);
   }
}

void CShellBrowser2::_EnableFileContext(HMENU hmenuPopup)
{
    IContextMenu2 *pcm = NULL;
    OLECMDTEXTV<MAX_FILECONTEXT_STRING> cmdtv;
    OLECMDTEXT *pcmdText = &cmdtv;

    // First clean up any previous merge we may have done
    DeleteMenu(hmenuPopup, FCIDM_FILENSCBANDSEP, MF_BYCOMMAND);
    DeleteMenu(hmenuPopup, FCIDM_FILENSCBANDPOPUP, MF_BYCOMMAND);
    IUnknown_SetSite(_pcmNsc, NULL);
    ATOMICRELEASE(_pcmNsc);

    // Second, get the name and pcm for the NSC selection, if available
    if (_poctNsc)
    {
        OLECMD rgcmd = { SBCMDID_INITFILECTXMENU, 0 };
        
        pcmdText->cwBuf = MAX_FILECONTEXT_STRING;
        pcmdText->cmdtextf = OLECMDTEXTF_NAME;
        pcmdText->rgwz[0] = 0;
        _poctNsc->QueryStatus(&CGID_Explorer, 1, &rgcmd, pcmdText);
        if (rgcmd.cmdf & OLECMDF_ENABLED)
        {
            VARIANT var = {0};

            HRESULT hr = _poctNsc->Exec(&CGID_Explorer, SBCMDID_INITFILECTXMENU, OLECMDEXECOPT_PROMPTUSER, NULL, &var);
            if (SUCCEEDED(hr) && VT_UNKNOWN == var.vt && NULL != var.punkVal)
            {
                var.punkVal->QueryInterface(IID_PPV_ARG(IContextMenu2, &pcm));
            }
            VariantClearLazy(&var);
        }
    }

    // Third, merge the menu in if we got it
    if (pcm)
    {
        HMENU hmenu = CreatePopupMenu();
        if (hmenu)
        {
            IUnknown_SetSite(pcm, _poctNsc);
            HRESULT hr = pcm->QueryContextMenu(hmenu, 0, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST, CMF_EXPLORE);
            if (SUCCEEDED(hr))
            {
                UINT nInsert = SHMenuIndexFromID(hmenuPopup, FCIDM_VIEWOFFLINE);
                if (-1 == nInsert)
                    nInsert = SHMenuIndexFromID(hmenuPopup, FCIDM_FILECLOSE);
                if (-1 == nInsert)
                    nInsert = GetMenuItemCount(hmenuPopup);

                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(mii);

                mii.fMask = MIIM_ID | MIIM_TYPE;
                mii.fType = MFT_SEPARATOR;
                mii.wID = FCIDM_FILENSCBANDSEP;
                InsertMenuItem(hmenuPopup, nInsert, MF_BYPOSITION, &mii);

                // BUGBUG: "&" is a legal UI name, we need to map this to "&&" or whatever the menu escape sequence is...
                mii.fMask = MIIM_ID | MIIM_TYPE | MIIM_SUBMENU;
                mii.fType = MFT_STRING;
                mii.hSubMenu = hmenu;
                mii.dwTypeData = pcmdText->rgwz;
                mii.wID = FCIDM_FILENSCBANDPOPUP;
                InsertMenuItem(hmenuPopup, nInsert, MF_BYPOSITION, &mii);
 
                _pcmNsc = pcm;
                _pcmNsc->AddRef();
            }
            else
            {
                IUnknown_SetSite(pcm, NULL);
            }

            if (FAILED(hr))
                DestroyMenu(hmenu);
        }

        pcm->Release();
    }
}

void CShellBrowser2::_MungeGoMyComputer(HMENU hmenuPopup)
{
    //need to have a menu item My Computer but a user might have changed
    //it to something else so go get the new name
    LPITEMIDLIST pidlMyComputer;
    TCHAR szBuffer[MAX_PATH]; //buffer to hold menu item string
    TCHAR szMenuText[MAX_PATH+1+6];

    SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer);
    if (pidlMyComputer)
    {
        if (SUCCEEDED(SHGetNameAndFlags(pidlMyComputer, SHGDN_NORMAL, szMenuText, SIZECHARS(szMenuText), NULL)))
        {   
            MENUITEMINFO mii;

            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_TYPE;
            mii.fType = MFT_STRING;
            mii.dwTypeData = szBuffer;
            mii.cch = ARRAYSIZE(szBuffer);
            if (GetMenuItemInfoWrap(hmenuPopup, FCIDM_MYCOMPUTER, FALSE, &mii)) 
            {
                LPTSTR  pszHot;
                LPTSTR pszMenuItem = (LPTSTR) mii.dwTypeData;
                
                //before we get rid of the old name, need to get 
                //the hot key for it
                //check if the old name had a hot key
                //StrChr is defined in shlwapi (strings.c) and accepts word even in ascii version
                if (NULL != (pszHot = StrChr(pszMenuItem, (WORD)TEXT('&'))))
                {   //yes
                    LPTSTR   psz;

                    pszHot++; //make it point to the hot key, not &
                    //try to find the key in the new string
                    if (NULL == (psz = StrChr(szMenuText, (WORD)*pszHot)))
                    {   //not found, then we'll insert & at the beginning of the new string
                        psz = szMenuText;
                    }

                    // can't put hotkey to full width characters
                    // and some of japanese specific half width chars.
                    // the comparison 
                    BOOL fFEmnemonic = FALSE;
                    if (g_fRunOnFE)
                    {
                        WORD wCharType[2];
                        // if built Ansi it takes max. 2 bytes to determine if 
                        // the given character is full width.
                        // DEFAULT_SYSTEM_LOCALE has to change when we have a way
                        // to get current UI locale.
                        //
                        GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE3, psz, 
                                        sizeof(WCHAR)/sizeof(TCHAR), wCharType);

                        if ((wCharType[0] & C3_FULLWIDTH)
                           ||(wCharType[0] & C3_KATAKANA) 
                           ||(wCharType[0] & C3_IDEOGRAPH)
                           ||((wCharType[0] & C3_ALPHA) && !(wCharType[0] & C3_HALFWIDTH)))
                        {
                            fFEmnemonic = TRUE;
                        }
                    }

                    if (fFEmnemonic)
                    {
                        size_t lenMenuText = lstrlen(szMenuText);
                        if (lenMenuText + 4 < ARRAYSIZE(szMenuText))
                        {
                            szMenuText[lenMenuText + 0] = TEXT('(');
                            szMenuText[lenMenuText + 1] = TEXT('&');
                            szMenuText[lenMenuText + 2] = *pszHot;
                            szMenuText[lenMenuText + 3] = TEXT(')');
                            szMenuText[lenMenuText + 4] = NULL;
                        }
                    }
                    else
                    {
                        //make space for & to be inserted
                        if (lstrlen(szMenuText) + 1 < ARRAYSIZE(szMenuText))
                        {
                            memmove(psz+1, psz, (lstrlen(psz)+1) * sizeof(TCHAR)); 
                            psz[0] = TEXT('&');
                        }
                    }
                }

                mii.dwTypeData = szMenuText;
                SetMenuItemInfo(hmenuPopup, FCIDM_MYCOMPUTER, FALSE, &mii);
            }
        }
        ILFree(pidlMyComputer);
    }
}

inline BOOL IsWebPidl(LPCITEMIDLIST pidl)
{
    return (!pidl || ILIsWeb(pidl));
}

void CShellBrowser2::_InsertTravelLogItems(HMENU hmenu, int nPos)
{
    ITravelLog *ptl;
            
    GetTravelLog(&ptl);
    if (!ptl)
        return;

    //add the back items to the menu
    MENUITEMINFO mii = {0};
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_ID | MIIM_TYPE;

    //delete all back menu items after the separator

    for (int i=GetMenuItemCount(hmenu); i >=0; i--)
    {
        mii.cch = 0;
        if (GetMenuItemInfoWrap(hmenu, i, TRUE, &mii) &&
            IsInRange(mii.wID, FCIDM_RECENTMENU, FCIDM_RECENTLAST))
        {
            DeleteMenu(hmenu, i, MF_BYPOSITION);
            if (i < nPos)
                nPos--;
        }
    }       

    //add the items
    if (S_OK == ptl->InsertMenuEntries(SAFECAST(this, IShellBrowser*), hmenu, nPos, FCIDM_RECENTFIRST, 
                           FCIDM_RECENTFIRST + GOMENU_RECENT_ITEMS, TLMENUF_CHECKCURRENT | TLMENUF_BACKANDFORTH))
    {
        //if something was added, insert a separator
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask  = MIIM_ID | MIIM_TYPE;
        mii.fType  = MFT_SEPARATOR;
        mii.wID    = FCIDM_RECENTMENU;
        
        InsertMenuItem(hmenu, nPos, TRUE, &mii);
    }
    
    ptl->Release();
}

void CShellBrowser2::_OnGoMenuPopup(HMENU hmenuPopup)
{
    ITravelLog *ptl;

    GetTravelLog(&ptl);
    // if we've got a site or if we're trying to get to a site,
    // enable the back button
    BOOL fBackward = (ptl ? S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_BACK, NULL) : FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_NAVIGATEBACK, fBackward);

    BOOL fForeward = (ptl ? S_OK == ptl->GetTravelEntry(SAFECAST(this, IShellBrowser *), TLOG_FORE, NULL) : FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_NAVIGATEFORWARD, fForeward);

    if (IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_NO_PARENT_FOLDER_SUPPORT) ||
        SHRestricted2W(REST_GoMenu, NULL, 0)) 
    {
        DeleteMenu(hmenuPopup, FCIDM_PREVIOUSFOLDER, MF_BYCOMMAND);
    }
    else
        _EnableMenuItem(hmenuPopup, FCIDM_PREVIOUSFOLDER, _ShouldAllowNavigateParent());

    ATOMICRELEASE(ptl);

    if (SHRestricted2(REST_NoChannelUI, NULL, 0))
        DeleteMenu(hmenuPopup, FCIDM_CHANNELGUIDE, MF_BYCOMMAND);

    _MungeGoMyComputer(hmenuPopup);

    _PruneMailNewsItems(hmenuPopup);
    
    // if in ie4 shell browser we leave travel log in the file menu
    if ((GetUIVersion() >= 5 || !_pbbd->_psf || IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_GO_HOME_PAGE)))
    {
        // The travel log goes after "Home Page".
        int nPos = GetMenuPosFromID(hmenuPopup, FCIDM_STARTPAGE) + 1;

        // If "Home Page" isn't there, then just append to the end.
        if (nPos <= 0)
        {
            nPos = GetMenuItemCount(hmenuPopup);
        }

        _InsertTravelLogItems(hmenuPopup, nPos);
    }
}


HRESULT AssureFtpOptionsMenuItem(HMENU hmenuPopup)
{
    HRESULT hr = S_OK;

    // Append the item if it is missing.  It can be missing because
    // sometimes the menu will be displayed before the shell merges it's
    // menus, so we are modifying the template that will be used for other
    // pages.
    if (GetMenuPosFromID(hmenuPopup, FCIDM_FTPOPTIONS) == 0xFFFFFFFF)
    {
        // Yes, it's missing so we need to add it.
        int nToInsert = GetMenuPosFromID(hmenuPopup, FCIDM_BROWSEROPTIONS);

        if (EVAL(0xFFFFFFFF != nToInsert))
        {
            TCHAR szInternetOptions[64];
            MLLoadString(IDS_INTERNETOPTIONS, szInternetOptions, ARRAYSIZE(szInternetOptions));

            MENUITEMINFO mii = {0};
            mii.cbSize = sizeof(mii);
            mii.fMask = (MIIM_TYPE | MIIM_STATE | MIIM_ID);
            mii.fType = MFT_STRING;
            mii.fState = MFS_ENABLED | MFS_UNCHECKED;
            mii.wID = FCIDM_FTPOPTIONS;
            mii.dwTypeData = szInternetOptions;
            mii.cch   = lstrlen(szInternetOptions);

            // We want to go right after "Folder Options" so we found
            // the spot.
            TBOOL(InsertMenuItem(hmenuPopup, (nToInsert + 1), TRUE, &mii));

            // REARCHITECT: The PMs finally decided that
            //         it would be good to always have "Inet Options" & "Folder Options"
            //         in all views. (FTP, Shell, & Web)  However doing it now
            //         is too late so we want to do this later.  When that is done
            //         we can get ride of all this stuff.

            // Now we just want to make sure FCIDM_BROWSEROPTIONS is "Folder Options"
            // because some users over load it to say "Internet Options" which
            // just added above.  So we want to force it back to "Folder Options".
            if (GetMenuItemInfo(hmenuPopup, FCIDM_BROWSEROPTIONS, FALSE, &mii))
            {
                TCHAR szFolderOptions[MAX_PATH];

                MLLoadString(IDS_FOLDEROPTIONS, szFolderOptions, ARRAYSIZE(szFolderOptions));
                mii.dwTypeData = szFolderOptions;
                mii.cch   = lstrlen(szFolderOptions);
                SetMenuItemInfo(hmenuPopup, FCIDM_BROWSEROPTIONS, FALSE, &mii);
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


HRESULT UpdateOptionsMenuItem(IShellFolder * psf, HMENU hmenuPopup, BOOL fForNT5)
{
    BOOL fCorrectVersion;

    if (fForNT5)
        fCorrectVersion = (GetUIVersion() >= 5);
    else
        fCorrectVersion = (GetUIVersion() < 5);

    // We want "Internet Options" in addition to "Folder Options" on
    // NT5's Tools menu for FTP Folders.  Is this the case?
    if (fCorrectVersion &&
        IsBrowserFrameOptionsSet(psf, BFO_BOTH_OPTIONS))
    {
        EVAL(SUCCEEDED(AssureFtpOptionsMenuItem(hmenuPopup)));
    }
    else
    {
        // No, so delete the item.
        DeleteMenu(hmenuPopup, FCIDM_FTPOPTIONS, MF_BYCOMMAND);
    }

    return S_OK;
}

void CShellBrowser2::_OnViewMenuPopup(HMENU hmenuPopup)
{
    OLECMD rgcmd[] = {
        { CITIDM_VIEWTOOLS, 0 },
        { CITIDM_VIEWADDRESS, 0 },
        { CITIDM_VIEWLINKS, 0 },
        { CITIDM_VIEWTOOLBARCUSTOMIZE, 0 },
        { CITIDM_VIEWMENU, 0 },
        { CITIDM_VIEWAUTOHIDE, 0 },
        { CITIDM_TEXTLABELS, 0 },
        { CITIDM_VIEWLOCKTOOLBAR, 0 },
    };
    
    UpdateOptionsMenuItem(_pbbd->_psf, hmenuPopup, FALSE);

    //  See _MenuTemplate for the kooky enable/disable scenarios.
    //  Today's kookiness:  The ever-changing "Options" menuitem.
    //  According to the table, we want Options under View on
    //  Non-NT5, in the shell or FTP scenarios.  Therefore, we want
    //  options deleted in the opposite scenario.  And for good measure,
    //  we also delete it if we don't know who we are yet, or if we
    //  are restricted.
    if (SHRestricted(REST_NOFOLDEROPTIONS) ||
        (GetUIVersion() >= 5) || !_pbbd->_pidlCur || 
        IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_RENAME_FOLDER_OPTIONS_TOINTERNET))
    {
        DeleteMenu(hmenuPopup, FCIDM_BROWSEROPTIONS, MF_BYCOMMAND);
    }

    if (SHRestricted2(REST_NoViewSource, NULL, 0))
        _EnableMenuItem(hmenuPopup, DVIDM_MSHTML_FIRST+IDM_VIEWSOURCE, FALSE);

    if (_GetToolbarItem(ITB_ITBAR)->fShow) {
        IUnknown_QueryStatus(_GetITBar(), &CGID_PrivCITCommands, ARRAYSIZE(rgcmd), rgcmd, NULL);
    }

    HMENU hmenuToolbar = LoadMenuPopup(MENU_ITOOLBAR);

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    mii.hSubMenu = hmenuToolbar;
    // why _hmenuCur?  why not hmenuPopup?
    SetMenuItemInfo(_hmenuCur, FCIDM_VIEWTOOLBAR, FALSE, &mii); 

    _CheckMenuItem(hmenuToolbar, FCIDM_VIEWADDRESS, rgcmd[1].cmdf & OLECMDF_ENABLED);
    _CheckMenuItem(hmenuToolbar, FCIDM_VIEWLINKS, rgcmd[2].cmdf & OLECMDF_ENABLED);

    int cItemsBelowSep = 3;
    BOOL fCustomizeAvailable = TRUE;
    if (!(rgcmd[3].cmdf & OLECMDF_ENABLED)) {
        DeleteMenu(hmenuToolbar, FCIDM_VIEWTOOLBARCUSTOMIZE, MF_BYCOMMAND);
        fCustomizeAvailable = FALSE;
        cItemsBelowSep--;
    }

    DeleteMenu(hmenuToolbar, FCIDM_VIEWGOBUTTON, MF_BYCOMMAND);

    if (fCustomizeAvailable || _ptheater || 
        SHRestricted2(REST_LOCKICONSIZE, NULL, 0)) {
        DeleteMenu(hmenuToolbar, FCIDM_VIEWTEXTLABELS, MF_BYCOMMAND);
        cItemsBelowSep--;
    } else {
        _CheckMenuItem (hmenuToolbar, FCIDM_VIEWTEXTLABELS, rgcmd[6].cmdf);
    }
    
    if (_ptheater) {
        _CheckMenuItem (hmenuToolbar, FCIDM_VIEWMENU, rgcmd[4].cmdf);
        _CheckMenuItem (hmenuToolbar, FCIDM_VIEWAUTOHIDE, rgcmd[5].cmdf);
        DeleteMenu(hmenuToolbar, FCIDM_VIEWTOOLS, MF_BYCOMMAND);
    } else {
        _CheckMenuItem(hmenuToolbar, FCIDM_VIEWTOOLS, rgcmd[0].cmdf & OLECMDF_ENABLED);
        DeleteMenu(hmenuToolbar, FCIDM_VIEWMENU, MF_BYCOMMAND);
        DeleteMenu(hmenuToolbar, FCIDM_VIEWAUTOHIDE, MF_BYCOMMAND);
        cItemsBelowSep--;
    }
    
    if (_ptheater || SHRestricted2(REST_NOBANDCUSTOMIZE, NULL, 0))
    {
        // No lock in theater mode or Windows Explorer
        DeleteMenu(hmenuToolbar, FCIDM_VIEWLOCKTOOLBAR, MF_BYCOMMAND);
    }
    else
    {
        _CheckMenuItem(hmenuToolbar, FCIDM_VIEWLOCKTOOLBAR, rgcmd[7].cmdf & OLECMDF_ENABLED);
    }

    _CheckMenuItem(hmenuPopup, FCIDM_VIEWSTATUSBAR,
                  v_ShowControl(FCW_STATUS, SBSC_QUERY) == SBSC_SHOW);

#ifndef DISABLE_FULLSCREEN
    if (SHRestricted2(REST_NoTheaterMode, NULL, 0))
        _EnableMenuItem(hmenuPopup, FCIDM_THEATER, FALSE);
    else
        _CheckMenuItem(hmenuPopup, FCIDM_THEATER, (_ptheater ? TRUE : FALSE));
#endif

    // if we're on nt5 OR we're not integrated and we're not in explorer
    // add browser bars to the view menu
    if (_GetBrowserBarMenu() == hmenuPopup)
    {
        _AddBrowserBarMenuItems(hmenuPopup);
    }
    // else it gets added only on view/explorer bars

    RestrictItbarViewMenu(hmenuPopup, _GetITBar());
    if (!cItemsBelowSep) 
        DeleteMenu(hmenuToolbar, FCIDM_VIEWCONTEXTMENUSEP, MF_BYCOMMAND);

    DWORD dwValue;
    DWORD dwSize = sizeof(dwValue);
    BOOL  fDefault = FALSE;

    // Check the registry to see if we need to show the "Java Console" menu item.
    //
    SHRegGetUSValue(TEXT("Software\\Microsoft\\Java VM"),
        TEXT("EnableJavaConsole"), NULL, (LPBYTE)&dwValue, &dwSize, FALSE, 
        (void *) &fDefault, sizeof(fDefault));

    // If the value is false or absent, remove the menu item.
    //
    if (!dwValue)
    {
        RemoveMenu(hmenuPopup, FCIDM_JAVACONSOLE, MF_BYCOMMAND);
    }

    //  Component categories cache can be passively (and efficiently) kept consistent through
    //  a registry change notification in integrated platforms on NT and Win=>98.
    //  both of these do an async update as necessary.
    if (g_fRunningOnNT && GetUIVersion() >= 5)
    {
        _QueryHKCRChanged();
    }
    else if (!_fValidComCatCache)
    {
        //  With browser-only, we'll refresh only if we haven't done so already.
        _fValidComCatCache = 
            S_OK == _FreshenComponentCategoriesCache(TRUE /* unconditional update */) ;
    }

    IDispatch *         pDispatch = NULL;
    IHTMLDocument2*     pHTMLDocument = NULL;
    BSTR                bstrUrl = NULL;
    if( SUCCEEDED(_pbbd->_pautoWB2->get_Document(&pDispatch))
        && SUCCEEDED(pDispatch->QueryInterface(IID_PPV_ARG(IHTMLDocument2, &pHTMLDocument)))
        && pHTMLDocument != NULL
        && SUCCEEDED(pHTMLDocument->get_URL( &bstrUrl)))
    {
        bool fEnableViewPrivacyPolicies = (0 == StrNCmpI( bstrUrl, L"http", ARRAYSIZE(L"http")-1));
        _EnableMenuItem( hmenuPopup, FCIDM_VIEW_PRIVACY_POLICIES, fEnableViewPrivacyPolicies);
//        if( !fEnableViewPrivacyPolicies)
//            DeleteMenu( hmenuPopup, FCIDM_VIEW_PRIVACY_POLICIES, MF_BYCOMMAND);
    }
    SAFERELEASE( pDispatch);
    SAFERELEASE( pHTMLDocument);
    SysFreeString( bstrUrl);
    bstrUrl = NULL;

    // prettify the menu (make sure first and last items aren't
    // separators and that there are no runs of >1 separator)
    _SHPrettyMenu(hmenuPopup);
}


void CShellBrowser2::_OnToolsMenuPopup(HMENU hmenuPopup)
{
    // Party on tools->options
    //
    //  Again _MenuTemplate has the gory details.  We want to lose
    //  "Options" in the non-NT5, shell or FTP scenarios, so we want
    //  to keep it in the opposite case.  (FTP is a freebie since FTP
    //  doesn't have a Tools menu to begin with.)
    //
    //  And don't forget restrictions.
    //  And as a bonus, we have to change the name of the menuitem
    //  in the web scenario to "Internet &Options".
    BOOL fWeb = IsWebPidl(_pbbd->_pidlCur);

    UpdateOptionsMenuItem(_pbbd->_psf, hmenuPopup, TRUE);

    //
    // Figure out whether or not "reset web settings" is needed
    //
    if (!fWeb ||                            // only visible in web mode
        !IsResetWebSettingsEnabled() ||     // only if not disabled by the ieak
        !IsResetWebSettingsRequired())      // and only needed if someone clobbered our reg keys
    {
        DeleteMenu(hmenuPopup, FCIDM_RESETWEBSETTINGS, MF_BYCOMMAND);
    }


    DWORD dwOptions;
    GetBrowserFrameOptions(_pbbd->_psf, (BFO_RENAME_FOLDER_OPTIONS_TOINTERNET | BFO_BOTH_OPTIONS), &dwOptions);   

    DWORD rgfAttrib = SFGAO_FOLDER;
    if (SHRestricted(REST_NOFOLDEROPTIONS) && 
        SUCCEEDED(IEGetAttributesOf(_pbbd->_pidlCur, &rgfAttrib)) && (rgfAttrib & SFGAO_FOLDER))
    {
        DeleteMenu(hmenuPopup, FCIDM_BROWSEROPTIONS, MF_BYCOMMAND);
    }
    else
    {
        // Only do this if the NSE wants it named "Internet Options" but doesn't want "Folder Options"
        // also.
        if (IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_RENAME_FOLDER_OPTIONS_TOINTERNET))
        {
            TCHAR szInternetOptions[64];

            MLLoadString(IDS_INTERNETOPTIONS, szInternetOptions, ARRAYSIZE(szInternetOptions));

            MENUITEMINFO mii;
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE | MIIM_STATE | MIIM_ID;
            mii.fType = MFT_STRING;
            mii.fState = MFS_ENABLED | MFS_UNCHECKED;
            mii.dwTypeData = szInternetOptions;
            mii.cch   = lstrlen(szInternetOptions);
            mii.wID   = FCIDM_BROWSEROPTIONS;

            // Append the item if it is missing, else just set it
            if (GetMenuState(hmenuPopup, FCIDM_BROWSEROPTIONS, MF_BYCOMMAND) == 0xFFFFFFFF)
            {
                AppendMenu(hmenuPopup, MF_SEPARATOR, -1, NULL);
                InsertMenuItem(hmenuPopup, 0xFFFFFFFF, TRUE, &mii);
            }
            else
            {
                SetMenuItemInfo(hmenuPopup, FCIDM_BROWSEROPTIONS, FALSE, &mii);
            }
        }
    }

    // Nuke tools->connect through tools->disconnect if restricted or if no net
    if ((!(GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS)) ||
         SHRestricted(REST_NONETCONNECTDISCONNECT))
    {
        for (int i = FCIDM_CONNECT; i <= FCIDM_CONNECT_SEP; i++)
            DeleteMenu(hmenuPopup, i, MF_BYCOMMAND);
    }

    // Nuke tools->find + sep if restricted or if UI version >= 5
    // or if running rooted explorer (since the Find extensions assume
    // unrooted)
    if (SHRestricted(REST_NOFIND) || (GetUIVersion() >= 5)) {
        DeleteMenu(hmenuPopup, FCIDM_TOOLSSEPARATOR, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_MENU_FIND, MF_BYCOMMAND);
    }

    BOOL fAvailable;
    uCLSSPEC ucs;
    QUERYCONTEXT qc = { 0 };
    MENUITEMINFO mii;

    ucs.tyspec = TYSPEC_CLSID;
    ucs.tagged_union.clsid = CLSID_SubscriptionMgr;

    // see if this option is available
    fAvailable = (SUCCEEDED(FaultInIEFeature(NULL, &ucs, &qc, FIEF_FLAG_PEEK)));

    if (fAvailable && !_fShowSynchronize)
    {
        //  Turn it back on
        
        if (NULL != _pszSynchronizeText)
        {
            _fShowSynchronize = TRUE;


            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE | MIIM_ID;
            mii.fType = MFT_STRING;
            mii.wID = FCIDM_UPDATESUBSCRIPTIONS;
            mii.dwTypeData = _pszSynchronizeText;

            InsertMenuItem(hmenuPopup, _iSynchronizePos, MF_BYPOSITION, &mii);
        }
    }
    else if (!fAvailable && _fShowSynchronize)
    {
        //  Turn it off
        int iSyncPos = GetMenuPosFromID(hmenuPopup, FCIDM_UPDATESUBSCRIPTIONS);

        if (NULL == _pszSynchronizeText)
        {
            _iSynchronizePos = iSyncPos;

            MENUITEMINFO mii;
            TCHAR szBuf[MAX_PATH];
            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_TYPE | MIIM_ID;
            mii.dwTypeData = szBuf;
            mii.cch = ARRAYSIZE(szBuf);

            if (GetMenuItemInfo(hmenuPopup, FCIDM_UPDATESUBSCRIPTIONS, MF_BYCOMMAND, &mii))
            {
                Str_SetPtr(&_pszSynchronizeText, (LPTSTR)mii.dwTypeData);
            }
        }

        DeleteMenu(hmenuPopup, FCIDM_UPDATESUBSCRIPTIONS, MF_BYCOMMAND);
        
        _fShowSynchronize = FALSE;
    }

    ASSERT((fAvailable && _fShowSynchronize) || (!fAvailable && !_fShowSynchronize));

    if (SHRestricted2(REST_NoWindowsUpdate, NULL, 0))
    {
        DeleteMenu(hmenuPopup, (DVIDM_HELPMSWEB+2), MF_BYCOMMAND);
    }
    else
    {
        DWORD   dwRet;
        DWORD   dwType;
        DWORD   dwSize;
        TCHAR   szNewUpdateName[MAX_PATH];

        // check to see if "Windows Update" should be called
        // something different in the menu

        dwSize = sizeof(szNewUpdateName);

        dwRet = SHRegGetUSValue(c_szMenuItemCust,
                                c_szWindowUpdateName,
                                &dwType,
                                (LPVOID)szNewUpdateName,
                                &dwSize,
                                FALSE,
                                NULL,
                                0);

        if (dwRet == ERROR_SUCCESS)
        {
            ASSERT(dwSize <= sizeof(szNewUpdateName));
            ASSERT(szNewUpdateName[(dwSize/sizeof(TCHAR))-1] == TEXT('\0'));

            // if we got anything, replace the menu item's text, or delete
            // the item if the text was NULL. we can tell if the text was
            // an empty string by seeing whether we got back more
            // bytes than just a null terminator

            if (dwSize > sizeof(TCHAR))
            {
                MENUITEMINFO mii;

                mii.cbSize = sizeof(mii);
                mii.fMask = MIIM_TYPE;
                mii.fType = MFT_STRING;
                mii.dwTypeData = szNewUpdateName;

                SetMenuItemInfo(hmenuPopup, FCIDM_PRODUCTUPDATES, FALSE, &mii);
            }
            else
            {
                ASSERT(dwSize == 0);

                DeleteMenu(hmenuPopup, FCIDM_PRODUCTUPDATES, MF_BYCOMMAND);
            }
        }
    }

    // Disable Mail and News submenu if we don't support it
    OLECMD rgcmd[] = {
       { SBCMDID_DOMAILMENU, 0 },
    };

    HRESULT hr = QueryStatus(&CGID_Explorer, ARRAYSIZE(rgcmd), rgcmd, NULL);  
    _EnableMenuItem(hmenuPopup, FCIDM_MAILANDNEWS, SUCCEEDED(hr) && (rgcmd[0].cmdf & OLECMDF_ENABLED));

    // prettify the menu (make sure first and last items aren't
    // separators and that there are no runs of >1 separator)
    _SHPrettyMenu(hmenuPopup);
}

void CShellBrowser2::_OnFileMenuPopup(HMENU hmenuPopup)
{
    // disable create shortcut, rename, delete, and properties
    // we'll enable them bellow if they are available
    _EnableMenuItem(hmenuPopup, FCIDM_DELETE, FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_PROPERTIES, FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_RENAME, FALSE);
    _EnableMenuItem(hmenuPopup, FCIDM_LINK, FALSE);
    
    if (SHRestricted2(REST_NoExpandedNewMenu, NULL, 0)
        && (GetMenuState(hmenuPopup, DVIDM_NEW, MF_BYCOMMAND) != 0xFFFFFFFF))
    {
        TCHAR szNewWindow[64];

        MLLoadString(IDS_NEW_WINDOW, szNewWindow, ARRAYSIZE(szNewWindow));

        MENUITEMINFO mii;
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_TYPE;
        mii.fType = MFT_STRING;
        mii.fState = MFS_ENABLED;
        mii.wID = DVIDM_NEWWINDOW;
        mii.dwTypeData = szNewWindow;
        mii.cch = lstrlen(szNewWindow);
        InsertMenuItem(hmenuPopup, DVIDM_NEW, FALSE, &mii);
        DeleteMenu(hmenuPopup, DVIDM_NEW, MF_BYCOMMAND);
    }

    if (_HasToolbarFocus())
    {
        OLECMD rgcmd[] = {
            { SBCMDID_FILEDELETE, 0 },
            { SBCMDID_FILEPROPERTIES, 0 },
            { SBCMDID_FILERENAME, 0},
            { SBCMDID_CREATESHORTCUT, 0},
        };
        IDockingWindow* ptbar = _GetToolbarItem(_itbLastFocus)->ptbar;
        if (SUCCEEDED(IUnknown_QueryStatus(ptbar, &CGID_Explorer, ARRAYSIZE(rgcmd), rgcmd, NULL)))
        {
            _EnableMenuItem(hmenuPopup, FCIDM_DELETE, rgcmd[0].cmdf & OLECMDF_ENABLED);
            _EnableMenuItem(hmenuPopup, FCIDM_PROPERTIES, rgcmd[1].cmdf & OLECMDF_ENABLED);
            _EnableMenuItem(hmenuPopup, FCIDM_RENAME, rgcmd[2].cmdf & OLECMDF_ENABLED);
            _EnableMenuItem(hmenuPopup, FCIDM_LINK, rgcmd[3].cmdf & OLECMDF_ENABLED);
        }
    }
    _EnableMenuItem(hmenuPopup, FCIDM_FILECLOSE, S_FALSE == _DisableModeless());

    _EnableFileContext(hmenuPopup);

    if (_fEnableOfflineFeature || (GetUIVersion() < 5))
    {
        _CheckMenuItem(hmenuPopup, FCIDM_VIEWOFFLINE, (Offline(SBSC_QUERY) == S_OK));
    }
    else
        RemoveMenu(hmenuPopup, FCIDM_VIEWOFFLINE, MF_BYCOMMAND);


    if (_fVisitedNet && NeedFortezzaMenu()) // Do not load WININET.DLL in explorer mode
    {
        // The logic here ensures that the menu is created once per instance
        // and only if there is a need to display a Fortezza menu.
        if (!_fShowFortezza)
        {
            static TCHAR szItemText[16] = TEXT("");
            if (!szItemText[0]) // The string will be loaded only once
                MLLoadString(IDS_FORTEZZA_MENU, szItemText, ARRAYSIZE(szItemText));
            if (_hfm==NULL)
                _hfm = FortezzaMenu();
            InsertMenu(hmenuPopup, FCIDM_FILECLOSE, MF_POPUP, (UINT_PTR) _hfm, szItemText);
            _fShowFortezza = TRUE;
        }
        SetFortezzaMenu(hmenuPopup);
    }
    else if (_fShowFortezza)    // Don't need the menu but already displayed?
    {                           // Remove without destroying the handle
        int cbItems = GetMenuItemCount(hmenuPopup);
        RemoveMenu(hmenuPopup, cbItems-2, MF_BYPOSITION);
        _fShowFortezza = FALSE;
    }


    // See if we can edit the page
    OLECMD rgcmd[] = {
        { CITIDM_EDITPAGE, 0 },
    };
    struct {
        OLECMDTEXT ct;
        wchar_t rgwz[128];
    } cmdText = {0};

    cmdText.ct.cwBuf = ARRAYSIZE(cmdText.rgwz) + ARRAYSIZE(cmdText.ct.rgwz);
    cmdText.ct.cmdtextf = OLECMDTEXTF_NAME;

    IDockingWindow* ptbar = _GetITBar();
    IUnknown_QueryStatus(ptbar, &CGID_PrivCITCommands, ARRAYSIZE(rgcmd), rgcmd, &cmdText.ct);

    _EnableMenuItem(hmenuPopup, FCIDM_EDITPAGE, rgcmd[0].cmdf & OLECMDF_ENABLED);

    // Update the name of the edit menu item
    TCHAR szText[80];
    MENUITEMINFO mii = {0};
    mii.cbSize = sizeof(MENUITEMINFO);
    mii.fMask = MIIM_TYPE;
    mii.dwTypeData = szText;
    if (cmdText.ct.cwActual > 1)
    {
        SHUnicodeToTChar(cmdText.ct.rgwz, szText, ARRAYSIZE(szText));
    }
    else
    {
        // Use default edit text
        MLLoadString(IDS_EDITPAGE, szText, ARRAYSIZE(szText));
    }
    SetMenuItemInfo(hmenuPopup, FCIDM_EDITPAGE, FALSE, &mii);



#ifdef TEST_AMBIENTS
   _CheckMenuItem(hmenuPopup, FCIDM_VIEWLOCALOFFLINE,
                  _LocalOffline(SBSC_QUERY) == TRUE);      
   _CheckMenuItem(hmenuPopup, FCIDM_VIEWLOCALSILENT,
                  _LocalSilent(SBSC_QUERY) == TRUE);    
#endif // TEST_AMBIENTS

    // must not change ie4 shell experience
    // so travel log still goes to the file menu   
    if ((GetUIVersion() < 5) && !IsWebPidl(_pbbd->_pidlCur))
    {
        int nPos = GetMenuItemCount(hmenuPopup) - 1; // Start with the last item
        MENUITEMINFO mii = {0};
        BOOL fFound = FALSE;

        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_TYPE;

        // Find the last separator separator
        while (!fFound && nPos > 0)
        {
            mii.cch = 0;
            GetMenuItemInfo(hmenuPopup, nPos, TRUE, &mii);
            if (mii.fType & MFT_SEPARATOR)
                fFound = TRUE;
            else
                nPos --;
        }

        if (fFound)
        {
            _InsertTravelLogItems(hmenuPopup, nPos);
        }
    }

    HMENU hmFileNew = SHGetMenuFromID(hmenuPopup, DVIDM_NEW);

    if (hmFileNew)
    {
        // remove menu items for unregistered components
        // this code is duplicated in shdocvw\dochost.cpp and is necessary here 
        // so that unwanted items are not present before dochost has fully loaded

        const static struct {
            LPCTSTR pszClient;
            UINT idCmd;
        } s_Clients[] = {
            { NEW_MAIL_DEF_KEY, DVIDM_NEWMESSAGE },
            { NEW_CONTACTS_DEF_KEY, DVIDM_NEWCONTACT },
            { NEW_NEWS_DEF_KEY, DVIDM_NEWPOST },
            { NEW_APPOINTMENT_DEF_KEY, DVIDM_NEWAPPOINTMENT },
            { NEW_MEETING_DEF_KEY, DVIDM_NEWMEETING },
            { NEW_TASK_DEF_KEY, DVIDM_NEWTASK },
            { NEW_TASKREQUEST_DEF_KEY, DVIDM_NEWTASKREQUEST },
            { NEW_JOURNAL_DEF_KEY, DVIDM_NEWJOURNAL },
            { NEW_NOTE_DEF_KEY, DVIDM_NEWNOTE },
            { NEW_CALL_DEF_KEY, DVIDM_CALL }
        };

        BOOL bItemRemoved = FALSE;  

        for (int i = 0; i < ARRAYSIZE(s_Clients); i++) 
        {
            if (!SHIsRegisteredClient(s_Clients[i].pszClient)) 
            {
                if (RemoveMenu(hmFileNew, s_Clients[i].idCmd, MF_BYCOMMAND))
                  bItemRemoved = TRUE;
            }
        }

        if (bItemRemoved) // ensure the last item is not a separator
            _SHPrettyMenu(hmFileNew);
    }

    if (!SHIsRegisteredClient(MAIL_DEF_KEY))
    {
        // disable Send Page by Email, Send Link by Email
        HMENU hmFileSend = SHGetMenuFromID(hmenuPopup, DVIDM_SEND);

        if (hmFileSend)
        {
            EnableMenuItem(hmFileSend, DVIDM_SENDPAGE, MF_BYCOMMAND | MF_GRAYED);
            EnableMenuItem(hmFileSend, DVIDM_SENDSHORTCUT, MF_BYCOMMAND | MF_GRAYED);
        }
    }

    if (!IEHardened() && -1 != GetMenuState(hmenuPopup, DVIDM_ADDSITE, MF_BYCOMMAND))
    {
        DeleteMenu(hmenuPopup, DVIDM_ADDSITE, MF_BYCOMMAND);
    }
}

void CShellBrowser2::_OnSearchMenuPopup(HMENU hmenuPopup)
{
    if (!_pcmSearch)
        _pxtb->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcmSearch));

    if (_pcmSearch)
        _pcmSearch->QueryContextMenu(hmenuPopup, 0, FCIDM_SEARCHFIRST, FCIDM_SEARCHLAST, 0);
}

void CShellBrowser2::_OnHelpMenuPopup(HMENU hmenuPopup)
{
    RIP(IS_VALID_HANDLE(hmenuPopup, MENU));

    // Do nothing if this is the DocHost version of the Help menu,
    // which always says "About Internet Explorer", and bring up
    // IE about dlg.

    // If we're running in native browser mode,
    // it says "About Windows" and bring up shell about dlg.
    // Change the "About Windows" to "About Windows NT" if running on NT.
    // Not sure what to do for Memphis yet.

    //
    // remove menu items which have been marked for removal
    // via the IEAK restrictions
    //

    if (SHRestricted2(REST_NoHelpItem_TipOfTheDay, NULL, 0))
    {
        DeleteMenu(hmenuPopup, FCIDM_HELPTIPOFTHEDAY, MF_BYCOMMAND);
    }

    if (SHRestricted2(REST_NoHelpItem_NetscapeHelp, NULL, 0))
    {
        DeleteMenu(hmenuPopup, FCIDM_HELPNETSCAPEUSERS, MF_BYCOMMAND);
    }

    if (SHRestricted2(REST_NoHelpItem_Tutorial, NULL, 0))
    {
        DeleteMenu(hmenuPopup, DVIDM_HELPTUTORIAL, MF_BYCOMMAND);
    }

    if (SHRestricted2(REST_NoHelpItem_SendFeedback, NULL, 0))
    {
        DeleteMenu(hmenuPopup, FCIDM_HELPSENDFEEDBACK, MF_BYCOMMAND);
    }

    if (!IEHardened())
    {
        DeleteMenu(hmenuPopup, DVIDM_HELPIESEC, MF_BYCOMMAND);
    }

    // "Is this copy of Windows legal?" only supported on Whistler and greater.
    if (!IsOS(OS_WHISTLERORGREATER))
    {
        DeleteMenu(hmenuPopup, FCIDM_HELPISLEGAL, MF_BYCOMMAND);
    }

    UINT ids = IDS_ABOUTWINDOWS;
    if (IsOS(OS_NT4ORGREATER) && !IsOS(OS_WIN2000ORGREATER))
    {
        ids = IDS_ABOUTWINDOWSNT;
    }
    else if (IsOS(OS_WIN98ORGREATER))
    {
        ids = IDS_ABOUTWINDOWS9X;
    }

    if (ids)
    {
        MENUITEMINFO mii = { 0 };
        TCHAR szName[80];            // The name better not be any bigger.

        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_TYPE;

        // We only try to get FCIDM_HELPABOUT, which will fail if this
        // is the DocHost version of help menu (who has DVIDM_HELPABOUT.)

        if (GetMenuItemInfoWrap(hmenuPopup, FCIDM_HELPABOUT, FALSE, &mii) &&
            MLLoadString(ids, szName, ARRAYSIZE(szName)))
        {
            mii.dwTypeData = szName;
            SetMenuItemInfo(hmenuPopup, FCIDM_HELPABOUT, FALSE, &mii);
        }
    }

    SHCheckMenuItem(hmenuPopup, FCIDM_HELPTIPOFTHEDAY, (_idmComm == _InfoCLSIDToIdm(&CLSID_TipOfTheDay)));
}

void CShellBrowser2::_OnMailMenuPopup(HMENU hmenuPopup)
{
    if (!SHIsRegisteredClient(MAIL_DEF_KEY))
    {
        DeleteMenu(hmenuPopup, FCIDM_MAIL, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_NEWMESSAGE, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_SENDLINK, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_SENDDOCUMENT, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_MAILNEWSSEPARATOR, MF_BYCOMMAND);
    }

    if (!SHIsRegisteredClient(NEWS_DEF_KEY))
    {
        DeleteMenu(hmenuPopup, FCIDM_MAILNEWSSEPARATOR, MF_BYCOMMAND);
        DeleteMenu(hmenuPopup, FCIDM_NEWS, MF_BYCOMMAND);
    }
}

void CShellBrowser2::_OnEditMenuPopup(HMENU hmenuPopup)
{
    OLECMD rgcmdEdit[] = {{CITIDM_EDITPAGE, 0 }};

    OLECMD rgcmd[] = {
        { OLECMDID_CUT, 0 },
        { OLECMDID_COPY, 0 },
        { OLECMDID_PASTE, 0 },
        { OLECMDID_SELECTALL, 0 }
    };
    ASSERT(FCIDM_COPY==FCIDM_MOVE+1);
    ASSERT(FCIDM_PASTE==FCIDM_MOVE+2);
    ASSERT(FCIDM_SELECTALL==FCIDM_MOVE+3);

    TraceMsg(DM_PREMERGEDMENU, "CSB::_OnEditMenuPopup got FCIDM_MENU_EDIT");
    IOleCommandTarget* pcmdt;
    HRESULT hres = _FindActiveTarget(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
    if (SUCCEEDED(hres)) {
        pcmdt->QueryStatus(NULL, ARRAYSIZE(rgcmd), rgcmd, NULL);
        pcmdt->Release();
    }

    for (int i=0; i<ARRAYSIZE(rgcmd); i++) {
        _EnableMenuItem(hmenuPopup, FCIDM_MOVE+i, rgcmd[i].cmdf & OLECMDF_ENABLED);
    }

    if (SUCCEEDED(_GetITBar()->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt))))
    {
        pcmdt->QueryStatus(&CGID_PrivCITCommands, ARRAYSIZE(rgcmdEdit), rgcmdEdit, NULL);
        pcmdt->Release();
    }    
    _EnableMenuItem(hmenuPopup, FCIDM_EDITPAGE, rgcmdEdit[0].cmdf & OLECMDF_ENABLED);

    // prettify the menu (make sure first and last items aren't
    // separators and that there are no runs of >1 separator)
    _SHPrettyMenu(hmenuPopup);
}

void CShellBrowser2::_OnFindMenuPopup(HMENU hmenuPopup)
{
    TraceMsg(DM_TRACE, "CSB::_OnFindMenuPopup cabinet InitMenuPopup of Find commands");

    ASSERT(GetUIVersion() < 5); // otherwise the menu is deleted when we load it from resources
    ASSERT(!SHRestricted(REST_NOFIND)); // otherwise the menu is deleted when we load it from resources

    ATOMICRELEASE(_pcmFind);
    _pcmFind = SHFind_InitMenuPopup(hmenuPopup, _pbbd->_hwnd, FCIDM_MENU_TOOLS_FINDFIRST, FCIDM_MENU_TOOLS_FINDLAST);
}

void CShellBrowser2::_OnExplorerBarMenuPopup(HMENU hmenuPopup)
{
    if (_hEventComCat)
    {
        // Wait a bit for the comcat cache enumeration to finish
        WaitForSingleObject(_hEventComCat, 1500);
        CloseHandle(_hEventComCat);
        _hEventComCat = NULL;
    }

    _AddBrowserBarMenuItems(hmenuPopup);

    if (SHRestricted2(REST_NoFavorites, NULL, 0))
        _EnableMenuItem(hmenuPopup, FCIDM_VBBFAVORITESBAND, FALSE);

    if (SHRestricted2(REST_No_LaunchMediaBar, NULL, 0))
        _EnableMenuItem(hmenuPopup, FCIDM_VBBMEDIABAND, FALSE);

    for (int idCmd = FCIDM_VBBFIXFIRST; idCmd <= FCIDM_VBBDYNLAST; idCmd++)
        SHCheckMenuItem(hmenuPopup, idCmd, FALSE);

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fState = MFS_CHECKED;
    mii.fMask = MIIM_STATE;
    SetMenuItemInfo(hmenuPopup, _idmInfo, FALSE, &mii);
    SetMenuItemInfo(hmenuPopup, _idmComm, FALSE, &mii);

    // if we have pre-ie4 shell32, remove the folders bar option
    if (GetUIVersion() < 4)
        DeleteMenu(hmenuPopup, FCIDM_VBBEXPLORERBAND, MF_BYCOMMAND);
}

LRESULT CShellBrowser2::v_OnInitMenuPopup(HMENU hmenuPopup, int nIndex, BOOL fSystemMenu)
{
    if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_EXPLORE)) {
        _OnGoMenuPopup(hmenuPopup);
    } 
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_VIEW)) {
        _OnViewMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_TOOLS)) {
        _OnToolsMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_FILE)) {
        _OnFileMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_SEARCHMENU)) {
        _OnSearchMenuPopup(hmenuPopup);
    }
    else if ((hmenuPopup == _GetMenuFromID(FCIDM_MENU_HELP)) ||
             (hmenuPopup == SHGetMenuFromID(_hmenuFull, FCIDM_MENU_HELP))) {
        // For the help menu we try both the current menu and by chance the FullSB menu
        // as if we get here before the menu merge we will not have set the current menu
        // and that would leave Help about windows95 for all platforms.
        _OnHelpMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_EDIT)) {
        _OnEditMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_MENU_FIND)) {
        _OnFindMenuPopup(hmenuPopup);
    }
    else if (hmenuPopup == _GetMenuFromID(FCIDM_VIEWBROWSERBARS)) {
        _OnExplorerBarMenuPopup(hmenuPopup);
    }
    else {
        UINT wID = GetMenuItemID(hmenuPopup, 0); // assume the first item on the popup identifies the menu
        
        if (wID == FCIDM_MAIL) {
            _OnMailMenuPopup(hmenuPopup);
        }
        else if (_pcmNsc && IsInRange(wID, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST)) {
            _pcmNsc->HandleMenuMsg(WM_INITMENUPOPUP, (WPARAM)hmenuPopup, (LPARAM)MAKELONG(nIndex, fSystemMenu));
        }
        else if (_pcm) {
            _pcm->HandleMenuMsg(WM_INITMENUPOPUP, (WPARAM)hmenuPopup, (LPARAM)MAKELONG(nIndex, fSystemMenu));
        }
    }
    
    return S_OK;
}

#pragma warning (disable:4200)
typedef struct {
    int nItemOffset;
    int nPopupOffset;
    struct {
        UINT uID;
        HMENU hPopup;
    } sPopupIDs[];
} MENUHELPIDS;
#pragma warning (default:4200)


void CShellBrowser2::_SetMenuHelp(HMENU hmenu, UINT wID, LPCTSTR pszHelp)
{
    if (pszHelp && pszHelp[0])
    {
        UINT flags = SBT_NOBORDERS | 255;

        // If the menu text is RTL, then so too will the status text be
        MENUITEMINFO mii = { sizeof(mii) };
        mii.fMask = MIIM_TYPE;
        if (GetMenuItemInfo(hmenu, wID, FALSE, &mii) &&
            (mii.fType & MFT_RIGHTORDER))
            flags |= SBT_RTLREADING;

        SendMessage(_hwndStatus, SB_SETTEXT, flags, (LPARAM)pszHelp);
        SendMessage(_hwndStatus, SB_SIMPLE, 1, 0);
    }
}

void CShellBrowser2::_SetExternalBandMenuHelp(HMENU hmenu, UINT wID)
{
    OLECMD cmd = { CITIDM_VIEWEXTERNALBAND_FIRST + (wID - FCIDM_EXTERNALBANDS_FIRST), 0 };
    OLECMDTEXTV<MAX_PATH> cmdtv;
    cmdtv.cwBuf = MAX_PATH;
    cmdtv.cmdtextf = OLECMDTEXTF_STATUS;
    cmdtv.rgwz[0] = 0;

    IUnknown_QueryStatus(_GetITBar(), &CGID_PrivCITCommands, 1, &cmd, &cmdtv);

    _SetMenuHelp(hmenu, wID, cmdtv.rgwz);
}

void CShellBrowser2::_SetBrowserBarMenuHelp(HMENU hmenu, UINT wID)
{
    if (_pbsmInfo)
    {
        BANDCLASSINFO *pbci = _BandClassInfoFromCmdID(wID);
        if (pbci)
        {
            LPCTSTR pszHelp = pbci->pszHelpPUI ? pbci->pszHelpPUI : pbci->pszHelp;
            _SetMenuHelp(hmenu, wID, pszHelp);
        }
    }
}

// Handles WM_MENUSELECT.  Returns FALSE if this menu item isn't handled by
// the frame.
LRESULT CShellBrowser2::_OnMenuSelect(WPARAM wParam, LPARAM lParam, UINT uHelpFlags)
{
    MENUHELPIDS sMenuHelpIDs = {
        MH_ITEMS, MH_POPUPS,
        0, NULL,        // Placeholder for specific menu 
        0, NULL         // This list must be NULL terminated 
    };
    TCHAR szHint[MAX_PATH];     // OK with MAX_PATH
    UINT uMenuFlags = GET_WM_MENUSELECT_FLAGS(wParam, lParam);
    WORD wID = GET_WM_MENUSELECT_CMD(wParam, lParam);
    HMENU hMenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);

    /* 
       HACKHACK
       USER32 TrackPopup menus send a menu deselect message which clears our
       status text at inopportune times.  We work around this with a private
       MBIgnoreNextDeselect message.
    */

    // Did someone ask us to clear the status text?
    if (!hMenu && LOWORD(uMenuFlags)==0xffff)
    {
        // Yes

        // Should we honour that request?
        if (!_fIgnoreNextMenuDeselect)
            // Yes
            SendMessage(_hwndStatus, SB_SIMPLE, 0, 0L);
        else
            // No
            _fIgnoreNextMenuDeselect = FALSE;

        return 1L;
    }
    
    // Clear this out just in case, but don't update yet
    SendMessage(_hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM)(LPTSTR)c_szNULL);
    SendMessage(_hwndStatus, SB_SIMPLE, 1, 0L);

    if (uMenuFlags & MF_SYSMENU)
    {
        // We don't put special items on the system menu any more, so go
        // straight to the MenuHelp
        goto DoMenuHelp;
    }

    if (uMenuFlags & MH_POPUP)
    {
        MENUITEMINFO miiSubMenu;

        if (!_hmenuCur)
        {
            return(0L);
        }

        miiSubMenu.cbSize = sizeof(MENUITEMINFO);
        miiSubMenu.fMask = MIIM_SUBMENU|MIIM_ID;
        if (!GetMenuItemInfoWrap(GET_WM_MENUSELECT_HMENU(wParam, lParam), wID, TRUE, &miiSubMenu))
        {
            // Check if this was a top level menu
            return(0L);
        }

        // Change the parameters to simulate a "normal" menu item
        wParam = miiSubMenu.wID;
        wID = (WORD)miiSubMenu.wID;
//
// NOTES: We are eliminating this range check so that we can display
//  help-text on sub-menus. I'm not sure why explorer.exe has this check.
//
#if 0
        if (!IsInRange(wID, FCIDM_GLOBALFIRST, FCIDM_GLOBALLAST))
            return 0L;
#endif
        uMenuFlags = 0;
    }

    // FEATURE: chrisfra 9/2/97
    //  No menu help for context menu stuck in File Menu or menus that aren't ours
    //  in IE 5.0, might want to write code to use context
    //  menu to get help to work

    if (IsInRange(wID, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST) ||
        !IsInRange(wID, FCIDM_FIRST, FCIDM_LAST))
        return 0L;

    if (_pcmSearch && IsInRange(wID, FCIDM_SEARCHFIRST, FCIDM_SEARCHLAST))
    {
        _pcmSearch->HandleMenuMsg(WM_MENUSELECT, wParam, lParam);
       return 0L;
    }

#if 0
    if (IsInRange(wID, FCIDM_RECENTFIRST, FCIDM_RECENTLAST)) {
        wID = FCIDM_RECENTFIRST;
    }
#endif

    // Menu help for plug-in explorer bars.
    if (IsInRange(wID, FCIDM_VBBDYNFIRST, FCIDM_VBBDYNLAST))
    {
        _SetBrowserBarMenuHelp(hMenu, wID);
        return 0L;
    }

    // Menu help for plug-in itbar bands
    if (IsInRange(wID, FCIDM_EXTERNALBANDS_FIRST, FCIDM_EXTERNALBANDS_LAST))
    {
        _SetExternalBandMenuHelp(hMenu, wID);
        return 0L;
    }

    szHint[0] = 0;

    sMenuHelpIDs.sPopupIDs[0].uID = 0;
    sMenuHelpIDs.sPopupIDs[0].hPopup = NULL;

DoMenuHelp:
    MenuHelp(WM_MENUSELECT, wParam, lParam, _hmenuCur, MLGetHinst(),
             _hwndStatus, (UINT *)&sMenuHelpIDs);

    return 1L;
}

void CShellBrowser2::_DisplayFavoriteStatus(LPCITEMIDLIST pidl)
{
    LPTSTR pszURL = NULL;

    IUniformResourceLocator * pURL;
    if (SUCCEEDED(CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
        IID_IUniformResourceLocator, (void **)&pURL)))
    {
        IPersistFile *ppf;
        if (SUCCEEDED(pURL->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
        {
            WCHAR wszPath[MAX_PATH];

            // Get the full path to the .lnk
            if (SHGetPathFromIDListW(pidl, wszPath))
            {
                // Attempt to connect the storage of the IURL to the pidl
                if (SUCCEEDED(ppf->Load(wszPath, STGM_READ)))
                {
                    pURL->GetURL(&pszURL);
                }
            }

            ppf->Release();
        }

        pURL->Release();
    }

    SendMessage(_hwndStatus, SB_SIMPLE, 1, 0L);
    SendMessage(_hwndStatus, SB_SETTEXT, SBT_NOBORDERS|255, (LPARAM)pszURL);

    if (pszURL)
        SHFree(pszURL);
}

LRESULT CShellBrowser2::_ThunkTTNotify(LPTOOLTIPTEXTA pnmTTTA)
{
    TOOLTIPTEXTW tttw = {0};

    tttw.hdr = pnmTTTA->hdr;
    tttw.hdr.code = TTN_NEEDTEXTW;

    tttw.lpszText = tttw.szText;
    tttw.hinst    = pnmTTTA->hinst;
    tttw.uFlags   = pnmTTTA->uFlags;
    tttw.lParam   = pnmTTTA->lParam;

    LRESULT lRes = SUPERCLASS::OnNotify(&tttw.hdr);

    pnmTTTA->hdr = tttw.hdr;
    pnmTTTA->hdr.code = TTN_NEEDTEXTA;

    pnmTTTA->hinst = tttw.hinst;
    pnmTTTA->uFlags = tttw.uFlags;
    pnmTTTA->lParam = tttw.lParam;

    if (tttw.lpszText == LPSTR_TEXTCALLBACKW)
        pnmTTTA->lpszText = LPSTR_TEXTCALLBACKA;
    else if (!tttw.lpszText)
        pnmTTTA->lpszText = NULL;
    else if (!HIWORD(tttw.lpszText))
        pnmTTTA->lpszText = (LPSTR)tttw.lpszText;
    else {
        WideCharToMultiByte(CP_ACP, 0, tttw.lpszText, -1,
                            pnmTTTA->szText, ARRAYSIZE(pnmTTTA->szText), NULL, NULL);
    }

    return lRes;
}

UINT GetDDEExecMsg()
{
    static UINT uDDEExec = 0;

    if (!uDDEExec)
        uDDEExec = RegisterWindowMessage(TEXT("DDEEXECUTESHORTCIRCUIT"));

    return uDDEExec;
}

LRESULT CShellBrowser2::OnNotify(LPNMHDR pnm)
{
    switch (pnm->code)
    {
        case NM_DBLCLK:
        {
            int idCmd = -1;
            LPNMCLICK pnmc = (LPNMCLICK)pnm;
            switch(pnmc->dwItemSpec)
            {
                case STATUS_PANE_NAVIGATION:
                    idCmd = SHDVID_NAVIGATIONSTATUS;
                    break;
                        
                case STATUS_PANE_PROGRESS:
                    idCmd = SHDVID_PROGRESSSTATUS;
                    break;
                    
                case STATUS_PANE_OFFLINE:
                    idCmd = SHDVID_ONLINESTATUS;
                    break;

                case STATUS_PANE_PRIVACY:
                    idCmd = SHDVID_PRIVACYSTATUS;
                    break;
                
                //case STATUS_PANE_PRINTER:
                //    idCmd = SHDVID_PRINTSTATUS;
                //    break;
                
                case STATUS_PANE_ZONE:
                    idCmd = SHDVID_ZONESTATUS;
                    break;
                    
                case STATUS_PANE_SSL:
                    idCmd = SHDVID_SSLSTATUS;
                    break;
                    
                default:
                    break;
            }
            if (_pbbd->_pctView && (idCmd != -1))
            {
                HRESULT hr = _pbbd->_pctView->Exec(&CGID_ShellDocView, idCmd, NULL, NULL, NULL);

                // If the parent couldn't handle it, maybe we can.
                if (FAILED(hr)) {
                    if (pnmc->dwItemSpec == _uiZonePane &&
                        _pbbd->_pidlCur)
                    {
                        WCHAR wszUrl[MAX_URL_STRING];
                        if (SUCCEEDED(::IEGetDisplayName(_pbbd->_pidlCur, wszUrl, SHGDN_FORPARSING)))
                        {
                            ULONG_PTR uCookie = 0;
                            SHActivateContext(&uCookie);
                            ZoneConfigureW(_pbbd->_hwnd, wszUrl);
                            if (uCookie)
                            {
                                SHDeactivateContext(uCookie);
                            }
                        }
                    }
                }
            }
            
            break;
        }
        
        case TTN_NEEDTEXTA:
        case TTN_NEEDTEXTW:
            if (IsInRange(pnm->idFrom, FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST)) {
                if (pnm->code == TTN_NEEDTEXTA && _fUnicode) 
                    return _ThunkTTNotify((LPTOOLTIPTEXTA)pnm);
                else
                    return SUPERCLASS::OnNotify(pnm);
            }         
            return 0;

        case SEN_DDEEXECUTE:
            //  381213 - webfolders needs dde shortcircuit in IE to work - ZekeL - 30-APR-2001
            //  on NT4SUR (non-integrated) we have to make sure that webfolders
            //  continues to be able to get folder window reuse for navigation.
            //
            //  this was:
            //      if (pnm->idFrom == 0 && GetUIVersion() >= 4) 
            //  and i am pretty sure some thing will break, since we once again 
            //  allow the shortcircuit code to run on pre-shell integrated.
            //  but maybe not since we no longer use the bogus folder navigation
            //  in order to implement OpenNew window for HTMLFile
           
            if (pnm->idFrom == 0) 
            {
                LPNMVIEWFOLDER pnmPost = DDECreatePostNotify((LPNMVIEWFOLDER)pnm) ;

                if (pnmPost)
                {
                    PostMessage(_pbbd->_hwnd, GetDDEExecMsg(), 0, (LPARAM)pnmPost);
                    return TRUE;
                }

            }
            break;
            
        case SBN_SIMPLEMODECHANGE:
            if ((pnm->idFrom == FCIDM_STATUS) && _hwndProgress) 
                _ShowHideProgress();
            break;
            
        default:
            break;
    }        
    return 0;
}

DWORD CShellBrowser2::_GetTempZone()
{
    LPCITEMIDLIST pidlChild;
    IShellFolder* psfParent;
    WCHAR szURL[MAX_URL_STRING];
    
    szURL[0] = 0;   // parse name for zone goes here
    
    if (SUCCEEDED(IEBindToParentFolder(_pbbd->_pidlCur, &psfParent, &pidlChild)))
    {
        // see if this is a folder shortcut, if so we use it's path for the zone
        IShellLink *psl;
        if (SUCCEEDED(psfParent->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidlChild, IID_IShellLink, NULL, (void **)&psl)))
        {
            LPITEMIDLIST pidlTarget;
            if (S_OK == psl->GetIDList(&pidlTarget))
            {
                ::IEGetDisplayName(pidlTarget, szURL, SHGDN_FORPARSING);
                ILFree(pidlTarget);
            }
            psl->Release();
        }
        psfParent->Release();
    }
    
    if (NULL == _pism)
    {
        // Don't need to QueryService for this since CShellBrowser is the top of the chain.
        CoCreateInstance(CLSID_InternetSecurityManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IInternetSecurityManager, &_pism));
    }

    DWORD nZone = ZONE_UNKNOWN;
    if (_pism && (szURL[0] || SUCCEEDED(::IEGetDisplayName(_pbbd->_pidlCur, szURL, SHGDN_FORPARSING))))
    {
        _pism->MapUrlToZone(szURL, &nZone, 0);
    }
    return nZone;
}

void Exec_GetZone(IUnknown * punk, VARIANTARG *pvar)
{
    IUnknown_Exec(punk, &CGID_Explorer, SBCMDID_MIXEDZONE, 0, NULL, pvar);

    if (pvar->vt == VT_UI4) // MSHTML was able to figure out what zone we are in
        pvar->ulVal = MAKELONG(STATUS_PANE_ZONE, pvar->ulVal);    
    else if (pvar->vt == VT_NULL)  // MSHTML has figured us to be in a mixed zone
        pvar->ulVal = MAKELONG(STATUS_PANE_ZONE, ZONE_MIXED);    
    else // We don't have zone info
        pvar->ulVal = MAKELONG(STATUS_PANE_ZONE, ZONE_UNKNOWN);    

    pvar->vt = VT_UI4;
}

//
//  in:
//          pvar    if NULL, we query the view for the zone
//                  non NULL, contains a VT_UI4 that encodes the zone pane and the zone value

void CShellBrowser2::_UpdateZonesPane(VARIANT *pvar)
{
    LONG lZone = ZONE_UNKNOWN;
    BOOL fMixed = FALSE;
    TCHAR szDisplayName[MAX_ZONE_DISPLAYNAME];
    VARIANTARG var = {0};

    if (NULL == pvar)
    {
        pvar = &var;
        Exec_GetZone(_pbbd->_pctView, &var);
    }

    // Do we already have the zone and fMixed info?
    if (pvar->vt == VT_UI4)
    {
        lZone = (signed short)HIWORD(pvar->lVal);
        _uiZonePane = (int)(signed short)LOWORD(pvar->lVal);
        if (lZone == ZONE_MIXED)
        {
            lZone = ZONE_UNKNOWN;
            fMixed = TRUE;
        }

        if (lZone < 0 && !IS_SPECIAL_ZONE(lZone))
        {
            // sometimes we're getting back an invalid zone index from urlmon,
            // and if we don't bound the index, we'll crash later
            lZone = ZONE_UNKNOWN;
        }
    }

    var.vt = VT_EMPTY;
    if (_pbbd->_pctView && SUCCEEDED(_pbbd->_pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_ZONE, NULL, &var)))
        _uiZonePane = var.ulVal;
    else
        _uiZonePane = STATUS_PANE_ZONE;

    // Sanity Check the zone
    if (_pbbd->_pidlCur)
    {
        DWORD nTempZone = _GetTempZone();
        if (nTempZone != ZONE_UNKNOWN)
            if (nTempZone > (DWORD)lZone)
                lZone = nTempZone;
    }

    szDisplayName[0] = 0;

    if (ZONE_UNKNOWN == lZone)
        MLLoadStringW(IDS_UNKNOWNZONE, szDisplayName, ARRAYSIZE(szDisplayName));
    else
    {
        if (_hZoneIcon)
        {
            // Before we can delete it, make comctl32's statusbar code stop using it.
            // Or else we rip.
            SendControlMsg(FCW_STATUS, SB_SETICON, _uiZonePane, (LPARAM)NULL, NULL);
            DestroyIcon(_hZoneIcon);
        }

        // This will zero the icon & name on failure
        _GetCachedZoneIconAndName(lZone, &_hZoneIcon, szDisplayName, ARRAYSIZE(szDisplayName));
    }
    
    if (fMixed)
    {
        TCHAR szMixed[32];
        MLLoadString(IDS_MIXEDZONE, szMixed, ARRAYSIZE(szMixed));
        StringCchCat(szDisplayName, ARRAYSIZE(szDisplayName), szMixed); // truncation ok
    }

    SendControlMsg(FCW_STATUS, SB_SETTEXTW, _uiZonePane, (LPARAM)szDisplayName, NULL);
    SendControlMsg(FCW_STATUS, SB_SETICON, _uiZonePane, (LPARAM)_hZoneIcon, NULL);
}

HRESULT CShellBrowser2::ReleaseShellView()
{
    // Give the current view a chance to save before we navigate away
    if (!_fClosingWindow)
    {
        // only try to save if we actually have a current view (this gets
        // called multiple times in a row on destruction, and it gets called
        // before the first view is created)
        //
        if (_pbbd->_psv)
            _SaveState();
    }

    return SUPERCLASS::ReleaseShellView();
}

bool IsWin95ClassicViewState (void)
{
    DWORD dwValue;
    DWORD cbSize = sizeof(dwValue);
    return ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
            TEXT("ClassicViewState"), NULL, &dwValue, &cbSize) && dwValue;
}

BOOL _PersistOpenBrowsers()
{
    return SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"),
                                TEXT("PersistBrowsers"), FALSE, FALSE);
}

// For Folder Advanced Options flags that we check often, it's better
// to cache the values as flags in CBaseBrowser2. Update them here.
void CShellBrowser2::_UpdateRegFlags()
{
    _fWin95ViewState = IsWin95ClassicViewState();
}


HRESULT CShellBrowser2::CreateViewWindow(IShellView* psvNew, IShellView* psvOld, LPRECT prcView, HWND* phwnd)
{
    if (_pbbd->_psv)
    {
        // snag the current view's setting so we can pass it along
        _UpdateFolderSettings(_pbbd->_pidlPending);
        
        // this is not a valid flag to pass along after the first one
        _fsd._fs.fFlags &= ~FWF_BESTFITWINDOW;
    }

    return SUPERCLASS::CreateViewWindow(psvNew, psvOld, prcView, phwnd);
}

HRESULT CShellBrowser2::ActivatePendingView(void)
{
    _fTitleSet = FALSE;
 
    // NOTES: (SatoNa)
    //
    //  Notice that we no longer call SetRect(&_rcBorderDoc, 0, 0, 0, 0)
    // here. We call it in CShellBrowser2::ReleaseShellView instead.
    // See my comment over there for detail.
    //
    HRESULT hres = SUPERCLASS::ActivatePendingView();
    if (FAILED(hres))
        return hres;

    _ReloadStatusbarIcon();   
       
    _SetTitle(NULL);
    v_SetIcon();
    VALIDATEPENDINGSTATE();

    if (_pxtb)
        _pxtb->SendToolbarMsg(&CLSID_CommonButtons, TB_ENABLEBUTTON, TBIDM_PREVIOUSFOLDER, _ShouldAllowNavigateParent(), NULL);

    UpdateWindowList();
    
    if (!_HasToolbarFocus()) 
    {
        HWND hwndFocus = GetFocus();
        //
        // Trident may take the input focus when they are being UIActivated.
        // In that case, don't mess with the focus.
        //
        if (_pbbd->_hwndView && (hwndFocus==NULL || !IsChild(_pbbd->_hwndView, hwndFocus))) 
            SetFocus(_pbbd->_hwndView);
    }

    // Let's profile opening time
    if (g_dwProfileCAP & 0x00010000)
        StopCAP();

    // Let's profile opening time
    if (g_dwProfileCAP & 0x00000020)
        StartCAP();

    return S_OK;
}

void CShellBrowser2::_UpdateBackForwardStateNow()
{
    _fUpdateBackForwardPosted = FALSE;
    SUPERCLASS::UpdateBackForwardState();
}

HRESULT CShellBrowser2::UpdateBackForwardState()
{
    if (!_fUpdateBackForwardPosted) 
    {
        PostMessage(_pbbd->_hwnd, CWM_UPDATEBACKFORWARDSTATE, 0, 0);
        _fUpdateBackForwardPosted = TRUE;
    }
    return S_OK;
}

HRESULT CShellBrowser2::_TryShell2Rename(IShellView* psv, LPCITEMIDLIST pidlNew)
{
    HRESULT hres = SUPERCLASS::_TryShell2Rename(psv, pidlNew); 
    if (SUCCEEDED(hres)) 
    {
        _SetTitle(NULL);
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Determines if this message should be forwarded onto
         the dochost frame.

Returns: TRUE if the message needs to be forwarded
*/
BOOL CShellBrowser2::_ShouldForwardMenu(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (!_fDispatchMenuMsgs)
        return FALSE;
    
    switch (uMsg) 
    {
    case WM_MENUSELECT:
    {
        // See CDocObjectHost::_ShouldForwardMenu for more details
        // about how this works.
        HMENU hmenu = GET_WM_MENUSELECT_HMENU(wParam, lParam);
        if (hmenu && (MF_POPUP & GET_WM_MENUSELECT_FLAGS(wParam, lParam)))
        {
            HMENU hmenuSub = GetSubMenu(hmenu, GET_WM_MENUSELECT_CMD(wParam, lParam));
            
            if (hmenu == _hmenuCur)
            {
                // Normal case, where we just look at the topmost popdown menus
                _fForwardMenu = _menulist.IsObjectMenu(hmenuSub);
            }
            else if (_menulist.IsObjectMenu(hmenuSub))
            {
                // This happens if the cascading submenu (micro-merged help menu for
                // example) should be forwarded on, but the parent menu should
                // not.
                _fForwardMenu = TRUE;
            }
        }
        break;
    }

    case WM_COMMAND:
        if (_fForwardMenu) 
        {
            // Stop forwarding menu messages after WM_COMMAND
            _fForwardMenu = FALSE;

            // If it wasn't from an accelerator, forward it
            if (0 == GET_WM_COMMAND_CMD(wParam, lParam))
                return TRUE;
        }
        break;
    }
    return _fForwardMenu;
}


DWORD CShellBrowser2::v_RestartFlags()
{
    return COF_CREATENEWWINDOW;
}

void CShellBrowser2::_CloseAllParents()
{
    LPITEMIDLIST pidl = ILClone(_pbbd->_pidlCur);
    if (pidl) 
    {
        for (ILRemoveLastID(pidl); !ILIsEmpty(pidl); ILRemoveLastID(pidl)) 
        {
            HWND hwnd;
            if (WinList_FindFolderWindow(pidl, NULL, &hwnd, NULL) == S_OK) 
            {
                TraceMsg(DM_SHUTDOWN, "csb.cap: post WM_CLOSE hwnd=%x", hwnd);
                PostMessage(hwnd, WM_CLOSE, 0, 0);
            }
        }
        ILFree(pidl);
    }
}


BOOL CShellBrowser2::_ShouldSaveWindowPlacement()
{
    // If this is done by automation, maybe we should not update the defaults, so
    // to detect this we say if the window is not visible, don't save away the defaults
    
    // For the internet, save one setting for all, otherwise use the win95
    // view stream mru
    
    return (IsWindowVisible(_pbbd->_hwnd) && _fUseIEPersistence && !_fUISetByAutomation &&
            _pbbd->_pidlCur && IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_BROWSER_PERSIST_SETTINGS));
}


void CShellBrowser2::_OnConfirmedClose()
{
    if (_pbbd->_pidlCur && IsCShellBrowser2() && (GetKeyState(VK_SHIFT) < 0)) {
        _CloseAllParents();
    }
    
    if (_fUseIEPersistence && IsCShellBrowser2())
    {
        // save off whether we should launch in fullscreen or not
        SHRegSetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                        TEXT("FullScreen"), REG_SZ, 
                        _ptheater ? TEXT("yes") : TEXT("no"), 
                        _ptheater ? sizeof(TEXT("yes")) : sizeof(TEXT("no")), 
                        SHREGSET_DEFAULT);
    }

    if (_ptheater)
    {
        ShowWindow(_pbbd->_hwnd, SW_HIDE);
        _TheaterMode(FALSE, FALSE);
        _fDontSaveViewOptions = TRUE;
    } 
    else 
    {
        if (_ShouldSaveWindowPlacement())
        {
            StorePlacementOfWindow(_pbbd->_hwnd);
        }
        else
            _fDontSaveViewOptions = TRUE;
    }

    // for now we use the same 12-hour (SessionTime) rule
    // possibly we should just do it always?
    UEMFireEvent(&UEMIID_BROWSER, UEME_CTLSESSION, UEMF_XEVENT, FALSE, -1);
    if (!g_bRunOnNT5) {
        // for down-level guys (old explorer), fake a shell end session too
        UEMFireEvent(&UEMIID_SHELL, UEME_CTLSESSION, UEMF_XEVENT, FALSE, -1);
    }

    // Save view states before closing all toolbars
    // Remember that we saved so we don't do it again
    // during _ReleaseShellView
    _SaveState();
    _fClosingWindow = TRUE;

    // To prevent flashing, we move the window off the screen, unfortunately
    // we can't hide it as shockwave briefly puts up dialog which causes
    // an ugly blank taskbar icon to appear.
    // do this after _SaveState() because that saves window pos info

    // NTRAID 455003: this won't look too good with multi monitors...
    SetWindowPos(_pbbd->_hwnd, NULL, 10000, 10000, 0, 0, SWP_NOSIZE|SWP_NOZORDER);
    
    // Save the Internet toolbar before we close it!
    if (!_fDontSaveViewOptions)
        _SaveITbarLayout();

    _CloseAndReleaseToolbars(TRUE);
    ATOMICRELEASE(_pxtb);
    
    // If you wait until WM_DESTROY (DestroyWindow below) to do this, under some
    // circumstances (eg an html page with an iframe whose src is an UNC based directory)
    // Ole will not Release the CShellBrowser2 that it addref'ed on RegisterDragDrop
    // (chrisfra 7/22/97)
    SetFlags(0, BSF_REGISTERASDROPTARGET);

    // If you wait until WM_DESTROY to do this, some OCs (like shockwave)
    // will hang (probably posting themselves a message)
    _CancelPendingView();
    ReleaseShellView();

    ATOMICRELEASE(_pmb);
    
    // Destroy the icons we created while we still can
    _SetWindowIcon(_pbbd->_hwnd, NULL, ICON_SMALL);
    _SetWindowIcon(_pbbd->_hwnd, NULL, ICON_BIG);

    // getting a random fault on rooted explorer on shutdown on this Destroy, maybe
    // somehow getting reentered.  So atomic destroy it...
    // NOTE: chrisg removed this at one point - is it dead?
    HWND hwndT = _pbbd->_hwnd;
    PutBaseBrowserData()->_hwnd = NULL;
    DestroyWindow(hwndT);

}


// these three functions, CommonHandleFielSysChange,
// v_HandleFileSysChange and this one
// may seem strange, but the idea is that the notify may come in from
// different sources (OneTree vs, win95 style fsnotify vs nt style)
// _OnFSNotify cracks the input, unifies it and calls CommonHnaldeFileSysChange
//  that calls to v_HandleFIleSysChange.  The Common...() is for stuff both needs
// the v_Handle...() is for overridden ones
void CShellBrowser2::_OnFSNotify(WPARAM wParam, LPARAM lParam)
{
    LPSHChangeNotificationLock  pshcnl = NULL;
    LONG lEvent;
    LPITEMIDLIST *ppidl = NULL; // on error, SHChangeNotification_Lock doesn't zero this out!
    IShellChangeNotify * pIFSN;
    
    if (g_fNewNotify && (wParam || lParam))
    {
        // New style of notifications need to lock and unlock in order to free the memory...
        pshcnl = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);
    } else {
        lEvent = (LONG)lParam;
        ppidl = (LPITEMIDLIST*)wParam;
    }

    if (ppidl)
    {
        //
        //  If we haven't initialized "this" yet, we should ignore all the
        // notification.
        //
        if (_pbbd->_pidlCur)
        {
            _CommonHandleFileSysChange(lEvent, ppidl[0], ppidl[1]);

            //
            //  Forward to ITBar too...
            //
            if (_GetITBar() && SUCCEEDED(_GetITBar()->QueryInterface(IID_PPV_ARG(IShellChangeNotify, &pIFSN))))
            {
                pIFSN->OnChange(lEvent, ppidl[0], ppidl[1]);
                pIFSN->Release();
            }
        }
    }

    if (pshcnl)
    {
        SHChangeNotification_Unlock(pshcnl);
    }
}

LPITEMIDLIST BurnDrivePidl()
{
    LPITEMIDLIST pidl = NULL;

    ICDBurn *pcdb;
    if (SUCCEEDED(CoCreateInstance(CLSID_CDBurn, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(ICDBurn, &pcdb))))
    {
        WCHAR szDrive[4];
        if (SUCCEEDED(pcdb->GetRecorderDriveLetter(szDrive, ARRAYSIZE(szDrive))))
        {
            pidl = ILCreateFromPath(szDrive);
        }
        pcdb->Release();
    }
    return pidl;
}

BOOL IsCurrentBurnDrive(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;

    LPITEMIDLIST pidlBurn = BurnDrivePidl();
    if (pidlBurn)
    {
        fRet = ILIsEqual(pidlBurn, pidl) || ILIsParent(pidlBurn, pidl, FALSE);
        ILFree(pidlBurn);
    }
    return fRet;
}

// fDisconnectAlways means we shouldn't try to re-open the folder (like when
// someone logs off of a share, reconnecting would ask them for
// a password again when they just specified that they want to log off)
void CShellBrowser2::_FSChangeCheckClose(LPCITEMIDLIST pidl, BOOL fDisconnect)
{
    if (ILIsParent(pidl, _pbbd->_pidlCur, FALSE) ||
        (ILIsRooted(_pbbd->_pidlCur) && (ILIsParent(pidl, ILRootedFindIDList(_pbbd->_pidlCur), FALSE))))
    {
        if (!fDisconnect)
        {
            //  APPCOMPAT: FileNet IDMDS (Panagon)'s shell folder extension
            //  incorrectly reports itself as a file system folder, so sniff the
            //  pidl to see if we should ignore the bit.  (B#359464: tracysh)

            // (tybeam) argh put the burndrive check back in again.
            // this app compat hack brings me no joy, its false positive city and basically all it is is the
            // PathFileExistsAndAttributes check.  if you ever have an issue where you have a namespace
            // extension that reports that it's on the filesystem and could possibly fail a PathFileExists
            // on a parsing name (which happens in the burning folder if theres no cd in the drive and it
            // checks the parsing name of the root) and it closes the window randomly, this is the problem
            // right here.
            TCHAR szPath[MAX_PATH];
            DWORD dwAttrib = SFGAO_FILESYSTEM | SFGAO_BROWSABLE;
            if (SUCCEEDED(SHGetNameAndFlags(_pbbd->_pidlCur, SHGDN_FORPARSING, szPath, SIZECHARS(szPath), &dwAttrib))
            && (dwAttrib & SFGAO_FILESYSTEM)
            && !(dwAttrib & SFGAO_BROWSABLE)
            && IsFlagClear(SHGetObjectCompatFlagsFromIDList(_pbbd->_pidlCur), OBJCOMPATF_NOTAFILESYSTEM)
            && !PathFileExistsAndAttributes(szPath, NULL)
            && !IsCurrentBurnDrive(_pbbd->_pidlCur))
            {
                fDisconnect = TRUE;
            }
        }
        
        if (fDisconnect)
            _pbbd->_pautoWB2->Quit();
    }
}

void CShellBrowser2::v_HandleFileSysChange(LONG lEvent, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2)
{
    BOOL fDisconnectAlways = FALSE;

    //
    //  If we are in the middle of changing folders,
    // ignore this event.
    //
    if (_pbbd->_psvPending) {
        return;
    }

    // README:
    // If you need to add events here, then you must change SHELLBROWSER_FSNOTIFY_FLAGS in
    // order to get the notifications
    switch(lEvent)
    {
    case SHCNE_DRIVEADDGUI:
        if (ILIsParent(pidl1, _pbbd->_pidlCur, FALSE)) {
            PostMessage(_pbbd->_hwnd, WM_COMMAND, FCIDM_REFRESH, 0L);
        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_SERVERDISCONNECT:
    case SHCNE_DRIVEREMOVED:
        if (g_fRunningOnNT || (lEvent == SHCNE_MEDIAREMOVED) || (lEvent == SHCNE_SERVERDISCONNECT))
            fDisconnectAlways = TRUE;

        // the cd burning case can get a removal event when we lock the
        // drive to commence burning or when the user ejects.
        // since we have an open browser on the drive we could get closed and thats bad,
        // so we prevent that here.
        if ((lEvent == SHCNE_MEDIAREMOVED) && IsCurrentBurnDrive(_pbbd->_pidlCur))
        {
            // jump out, we don't want to close.
            break;
        }
        // fall through

    case SHCNE_UPDATEDIR:
    case SHCNE_NETUNSHARE:
        // preserve old behavior of when the explorer (all folders) bar is up,
        // go to nearest parent folder
        if (_idmInfo == FCIDM_VBBEXPLORERBAND)
            break;
        _FSChangeCheckClose(pidl1, fDisconnectAlways);
        break;
    }

}

// converts a simple pidl to a full pidl

LPITEMIDLIST _SimpleToReal(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlReturn = NULL;
    IShellFolder *psf;
    LPCITEMIDLIST pidlChild;
    if (SUCCEEDED(IEBindToParentFolder(pidl, &psf, &pidlChild)))
    {
        LPITEMIDLIST pidlRealChild;
        if (SUCCEEDED(SHGetRealIDL(psf, pidlChild, &pidlRealChild)))
        {
            LPITEMIDLIST pidlParent = ILCloneParent(pidl);
            if (pidlParent)
            {
                pidlReturn = ILCombine(pidlParent, pidlRealChild);
                
                ILFree(pidlParent);
            }
            
            ILFree(pidlRealChild);
        }
        
        psf->Release();
    }

    return pidlReturn;
}



void CShellBrowser2::_CommonHandleFileSysChange(LONG lEvent, LPITEMIDLIST pidl1, LPITEMIDLIST pidl2)
{
    v_HandleFileSysChange(lEvent, pidl1, pidl2);

    // WARNING: In all cases _pbbd will have NULL contents before first navigate.

    if (_pbbd->_psvPending) {
        return;
    }

    // stuff that needs to be done tree or no tree
    switch (lEvent) {

    // README:
    // If you need to add events here, then you must change SHELLBROWSER_FSNOTIFY_FLAGS in
    // order to get the notifications
        
    case SHCNE_RENAMEFOLDER:
    {
        // the rename might be ourselfs or our parent... if it's
        // our parent, we want to tack on the child idl's from the renamed
        // parent to us onto the new pidl (pidlExtra).
        // then show that result.
        LPCITEMIDLIST pidlChild = ILFindChild(pidl1, _pbbd->_pidlCur);
        if (pidlChild) 
        {
            LPITEMIDLIST pidlTarget = ILCombine(pidl2, pidlChild);
            if (pidlTarget)
            {
                LPITEMIDLIST pidlReal = _SimpleToReal(pidlTarget);
                if (pidlReal) 
                {
                    if (!ILIsEqual(pidlReal, _pbbd->_pidlCur))
                    {
                        BrowseObject(pidlReal, SBSP_REDIRECT | SBSP_SAMEBROWSER);
                    }
                    ILFree(pidlReal);
                }
                ILFree(pidlTarget);
            }
        }
    }
    // fall through
    case SHCNE_UPDATEITEM:
        // the name could have changed
        if (ILIsEqual(_pbbd->_pidlCur, pidl1))
            _SetTitle(NULL);
        break;

    case SHCNE_UPDATEIMAGE:
        IUnknown_CPContainerInvokeParam(_pbbd->_pautoEDS,
                DIID_DWebBrowserEvents2, DISPID_TITLEICONCHANGE, NULL, 0);
#ifdef DEBUG
        if (_pbbd->_pautoEDS)
        {
            // Verify that every IExpDispSupport also supports IConnectionPointContainer
            IConnectionPointContainer *pcpc;
            IExpDispSupport* peds;

            if (SUCCEEDED(_pbbd->_pautoEDS->QueryInterface(IID_IConnectionPointContainer, (void **)&pcpc)))
            {
                pcpc->Release();
            }
            else if (SUCCEEDED(_pbbd->_pautoEDS->QueryInterface(IID_IExpDispSupport, (void **)&peds)))
            {
                peds->Release();
                AssertMsg(0, TEXT("IExpDispSupport without IConnectionPointContainer for %08x"), _pbbd->_pautoEDS);
            }
        }
#endif
        v_SetIcon();
        break;
    }
}

//---------------------------------------------------------------------------
// Helper Function to see if a pidl is on a network drive which is not
// persistent.  This is useful if we are shuting down and saving a list
// of the open windows to restore as we won't be able to restore these.

BOOL FPidlOnNonPersistentDrive(LPCITEMIDLIST pidl)
{
    TCHAR szPath[MAX_PATH];
    HANDLE hEnum;
    BOOL fRet = TRUE;

    TraceMsg(DM_SHUTDOWN, "csb.wp: FPidlOnNonPersistentDrive(pidl=%x)", pidl);
    if (!SHGetPathFromIDList(pidl, szPath) || (szPath[0] == TEXT('\0')))
        return(FALSE);  // not file system pidl assume ok.

    TraceMsg(DM_SHUTDOWN, "csb.wp: FPidlOnNonPersistentDrive - After GetPath=%s)", szPath);
    if (PathIsUNC(szPath) || !IsNetDrive(DRIVEID(szPath)))
    {
        fRet = FALSE;
        goto End;
    }

    // Ok we got here so now we have a network drive ...
    // we will have to enumerate over
    //
    if (WNetOpenEnum(RESOURCE_REMEMBERED, RESOURCETYPE_DISK,
            RESOURCEUSAGE_CONTAINER | RESOURCEUSAGE_ATTACHED,
            NULL, &hEnum) == WN_SUCCESS)
    {
        DWORD dwCount=1;
        union
        {
            NETRESOURCE nr;         // Large stack usage but I
            TCHAR    buf[1024];      // Dont think it is thunk to 16 bits...
        }nrb;

        DWORD   dwBufSize = sizeof(nrb);

        while (WNetEnumResource(hEnum, &dwCount, &nrb.buf,
                &dwBufSize) == WN_SUCCESS)
        {
            // We only want to add items if they do not have a local
            // name.  If they had a local name we would have already
            // added them!
            if ((nrb.nr.lpLocalName != NULL) &&
                    (CharUpperChar(*(nrb.nr.lpLocalName)) == CharUpperChar(szPath[0])))
            {
                fRet = FALSE;
                break;
            }
        }
        WNetCloseEnum(hEnum);
    }

End:
    TraceMsg(DM_TRACE, "c.c_arl: %s, is Persistent? %d", szPath, fRet);
    return(fRet);


}

void HackToPrepareForEndSession(LPCITEMIDLIST pidl)
{
    TCHAR szPath[MAX_PATH];

    TraceMsg(DM_SHUTDOWN, "csb.wp: HackToPrepareForEndSession(pidl=%x)", pidl);
    SHGetPathFromIDList(pidl, szPath);
}

//---------------------------------------------------------------------------
// returns:
//      TRUE if the user wants to abort the startup sequence
//      FALSE keep going
//
// note: this is a switch, once on it will return TRUE to all
// calls so these keys don't need to be pressed the whole time
BOOL AbortStartup()
{
    static BOOL bAborted = FALSE;       // static so it sticks!

    // TraceMsg(DM_TRACE, "Abort Startup?");

    if (bAborted)
        return TRUE;    // don't do funky startup stuff
    else {
        bAborted = (GetSystemMetrics(SM_CLEANBOOT) || ((GetAsyncKeyState(VK_CONTROL) < 0) || (GetAsyncKeyState(VK_SHIFT) < 0)));
        return bAborted;
    }
}

//---------------------------------------------------------------------------
// Restore all of the window that asked to save a command line to be
// restarted when windows was exited.
//
BOOL AddToRestartList(DWORD dwFlags, LPCITEMIDLIST pidl)
{
    int cItems = 0;
    DWORD cbData = sizeof(cItems);
    TCHAR szSubKey[80];
    BOOL fRet = FALSE;
    IStream *pstm;

    // cases that we don't want to save window state for...

    if (SHRestricted(REST_NOSAVESET) || FPidlOnNonPersistentDrive(pidl) || !_PersistOpenBrowsers())
        return FALSE;

    HKEY hkRestart = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("RestartCommands"), TRUE);
    if (hkRestart)
    {
        if (ERROR_SUCCESS != (SHGetValueGoodBoot(hkRestart, NULL, TEXT("Count"), NULL, (BYTE *)&cItems, &cbData)))
            cItems = 0;

        // Now Lets Create a registry Stream for this guy...
        if (SUCCEEDED(StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), TEXT("%d"), cItems)))
        {
            pstm = OpenRegStream(hkRestart, NULL, szSubKey, STGM_WRITE);
            TraceMsg(DM_SHUTDOWN, "csb.wp: AddToRestartList(pstm=%x)", pstm);
            if (pstm)
            {
                WORD wType = (WORD)-1;    // sizeof of cmd line == -1 implies pidl...

                // Now Write a preamble to the start of the line that
                // tells wType that this is an explorer
                pstm->Write(&wType, sizeof(wType), NULL);

                // Now Write out the version number of this stream
                // Make sure to inc the version number if the structure changes
                pstm->Write(&c_wVersion, sizeof(c_wVersion), NULL);

                // Now Write out the dwFlags
                pstm->Write(&dwFlags, sizeof(dwFlags), NULL);
            
                // And the pidl;
                ILSaveToStream(pstm, pidl);

                // And Release the stream;
                pstm->Release();

                cItems++;   // Say that there are twice as many items...

                fRet = (ERROR_SUCCESS == SHSetValue(hkRestart, NULL, TEXT("Count"), REG_BINARY, &cItems, sizeof(cItems)));
            }
        }
        RegCloseKey(hkRestart);
    }

    return fRet;
}

//---------------------------------------------------------------------------
void SHCreateSavedWindows(void)
{
    HKEY hkRestart = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, TEXT("RestartCommands"), FALSE);
    if (_PersistOpenBrowsers() && hkRestart)
    {
        int cItems = 0;
        DWORD cbData = sizeof(cItems);


        SHGetValueGoodBoot(hkRestart, NULL, TEXT("Count"), NULL, (PBYTE)&cItems, &cbData);

        // walk in the reverse order that they were added.
        for (cItems--; cItems >= 0; cItems--)
        {
            if (AbortStartup())
                break;

            TCHAR szName[80];
            if (SUCCEEDED(StringCchPrintf(szName, ARRAYSIZE(szName), TEXT("%d"), cItems)))
            {
                IStream *pstm = OpenRegStream(hkRestart, NULL, szName, STGM_READ);
                if (pstm)
                {
                    WORD wType;
                    if (SUCCEEDED(pstm->Read(&wType, sizeof(wType), NULL)))
                    {
                        if (wType == (WORD)-1)
                        {
                            WORD wVersion;
                            DWORD dwFlags;
                            LPITEMIDLIST pidl = NULL;       // need to be inited for ILLoadFromStream()

                            // We have a folder serialized so get:
                            //     WORD:wVersion, DWORD:dwFlags, PIDL:pidlRoot, PIDL:pidl

                            if (SUCCEEDED(pstm->Read(&wVersion, sizeof(wVersion), NULL)) &&
                                (wVersion == c_wVersion) &&
                                SUCCEEDED(pstm->Read(&dwFlags, sizeof(dwFlags), NULL)) && 
                                SUCCEEDED(ILLoadFromStream(pstm, &pidl)) && pidl)
                            {
                                // this call does window instance management 
                                IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, 0, NULL, NULL);
                                if (piei) 
                                {
                                    piei->pidl = pidl;
                                    pidl = NULL;     // so this is not freed below
                                    piei->uFlags = dwFlags;
                                    piei->nCmdShow = SW_SHOWDEFAULT;
                                    SHOpenFolderWindow(piei);
                                }
                                ILFree(pidl);
                            }
                        }
                    }
                    pstm->Release();
                }
            }
        }
    }

    if (hkRestart)
    {
        SHDeleteKeyA(hkRestart, NULL);
        RegCloseKey(hkRestart);
    }
}


//
//  This code intercept the WM_CONTEXTMENU message from USER and popups
// up the context menu of the folder itself when the user clicks the icon
// at the left-top corner of the frame (only when it is in the folder mode).
//
BOOL CShellBrowser2::v_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    BOOL fProcessed = FALSE;

    TraceMsg(DM_TRACE, "csb.ocm Got WM_CONTEXTMENU");
    
    if (_pbbd->_pidlCur && 
        !ILIsEmpty(_pbbd->_pidlCur) && 
        (SendMessage(_pbbd->_hwnd, WM_NCHITTEST, 0, lParam) == HTSYSMENU) && 
        !SHRestricted(REST_NOVIEWCONTEXTMENU))
    {
        IShellFolder *psfParent;
        LPCITEMIDLIST pidlChild;

        if (SUCCEEDED(IEBindToParentFolder(_pbbd->_pidlCur, &psfParent, &pidlChild))) 
        {
            IContextMenu * pcm;
            HRESULT hres = psfParent->GetUIObjectOf(_pbbd->_hwnd, 1, (LPCITEMIDLIST*)&pidlChild, IID_IContextMenu, NULL, (void **)&pcm);
            if (SUCCEEDED(hres))
            {
                HMENU hpopup = LoadMenuPopup(MENU_SYSPOPUP);
                if (hpopup)
                {
                    pcm->QueryContextMenu(hpopup, GetMenuItemCount(hpopup), IDSYSPOPUP_FIRST, IDSYSPOPUP_LAST, 0);

                    // Open doesn't make sense, since you're already looking at the folder
                    ContextMenu_DeleteCommandByName(pcm, hpopup, IDSYSPOPUP_FIRST, L"open");

                    // These are just confusing
                    ContextMenu_DeleteCommandByName(pcm, hpopup, IDSYSPOPUP_FIRST, L"delete");
                    ContextMenu_DeleteCommandByName(pcm, hpopup, IDSYSPOPUP_FIRST, L"link");

                    // The above may have allowed two separators to now be adjascent
                    _SHPrettyMenu(hpopup);

                    // For sendto menu, we go on even if this fails
                    pcm->QueryInterface(IID_PPV_ARG(IContextMenu3, &_pcm));
                    
                    if (GetMenuItemCount(hpopup) > 1) 
                    {
                        // only do this if the context menu added something...
                        // otherwise we end up with nothing but a "close" menu
                        
                        fProcessed=TRUE;
                        UINT idCmd = TrackPopupMenu(hpopup,
                                               TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                                               GET_X_LPARAM(lParam),
                                               GET_Y_LPARAM(lParam),
                                               0, _pbbd->_hwnd, NULL);

                        switch(idCmd)
                        {
                        case 0:
                            break;  // canceled

                        case IDSYSPOPUP_CLOSE:
                            _pbbd->_pautoWB2->Quit();
                            break;

                        default:
                        {
                            TCHAR szPath[MAX_PATH];
                            // unless we KNOW that our target can handle CommandInfoEx, we cannot send it to them
                            CMINVOKECOMMANDINFO ici = {
                                sizeof(ici),
                                0L,
                                _pbbd->_hwnd,
                                (LPSTR)MAKEINTRESOURCE(idCmd - IDSYSPOPUP_FIRST),
                                NULL, NULL,
                                SW_NORMAL
                            };
#ifdef UNICODE
                            CHAR szPathAnsi[MAX_PATH];
                            SHGetPathFromIDListA(_pbbd->_pidlCur, szPathAnsi);
                            SHGetPathFromIDList(_pbbd->_pidlCur, szPath);
                            ici.lpDirectory = szPathAnsi;
//                            ici.lpDirectoryW = szPath;
                            ici.fMask |= CMIC_MASK_UNICODE;
#else
                            SHGetPathFromIDList(_pbbd->_pidlCur, szPath);
                            ici.lpDirectory = szPath;
#endif
                            pcm->InvokeCommand(&ici);
                            break;
                        }
                        }
                    }

                    ATOMICRELEASE(_pcm);
                    DestroyMenu(hpopup);
                }
                pcm->Release();
            }
            psfParent->Release();

        }
    }
    return fProcessed;
}

void CShellBrowser2::_OnClose(BOOL fPushed)
{
    // We can't close if it's nested.
    if (fPushed) 
    {
#ifdef NO_MARSHALLING
        // IEUNIX : Mark this window  for delayed deletion from the main message
        // pump. The problem is , if scripting closes a window and immediately 
        // opens a modal dialog. The WM_CLOSE message  for the browser window is
        // dispatched from the modal loop and we end up being called from the 
        // window proc. This  happens a lot on UNIX because we have multiple 
        // browser windows on the same thread.
        if (!_fDelayedClose)
            _fDelayedClose = TRUE;
        else
#endif
        MessageBeep(0);
        return;
    }

    if (SHIsRestricted2W(_pbbd->_hwnd, REST_NoBrowserClose, NULL, 0))
        return;

    // We are not supposed to process WM_CLOSE if modeless operation is
    // disabled.
    if (S_OK == _DisableModeless()) 
    {
        TraceMsg(DM_ERROR, "CShellBrowser2::_OnClose called when _DisableModeless() is TRUE. Ignored.");
        MessageBeep(0);
        UINT id = MLShellMessageBox(_pbbd->_hwnd,
               MAKEINTRESOURCE(IDS_CLOSEANYWAY),
               MAKEINTRESOURCE(IDS_TITLE),
               MB_OKCANCEL | MB_SETFOREGROUND | MB_ICONSTOP);
        if (id == IDCANCEL) 
        {
#ifdef NO_MARSHALLING
            _fReallyClosed = FALSE;
#endif
            return;
        }
    }

#ifdef NO_MARSHALLING
    _fReallyClosed = TRUE;
#endif

    // we cannot close in the middle of creating view window.  
    // someone dispatched messages and it wasn't us...
    // we WILL fault.
    // FEATURE:  after ie3, we can flag this and close when we're done tryingto create the
    // viewwindow
    if (_pbbd->_fCreatingViewWindow)
        return;

    // The dochost needs to know that we are shutting
    // down so that it do such things send an Exec to 
    // Trident to tell it we are unloading. 
    //
    Exec(&CGID_Explorer, SBCMDID_ONCLOSE, 0, NULL, NULL);

    if (_MaySaveChanges() != S_FALSE) 
    {
        // Close the browse context and release it.
        IHlinkBrowseContext * phlbc = NULL;
        
        if (_pbbd->_phlf)
            _pbbd->_phlf->GetBrowseContext(&phlbc);
        
        if (phlbc) 
        {
            _pbbd->_phlf->SetBrowseContext(NULL);
            phlbc->Close(0);
            phlbc->Release();
        }

        FireEvent_Quit(_pbbd->_pautoEDS);
        
        // this is once we KNOW that we're going to close down
        // give subclasses a chance to clean up
#ifdef NO_MARSHALLING
        RemoveBrowserFromList(this);
#endif
        _OnConfirmedClose();
    }


    //
    // NOTES: Originally, this call was made only for RISC platform.
    //  We, however, got a request from ISVs that their OCs should be
    //  unloaded when the user closes the window.
    //
    //  On risc NT we need to call CoFreeUnusedLibraries in case any x86 dlls
    //  were loaded by Ole32. We call this after calling _OnClose so that
    //  we can even unload the OC on the current page. (SatoNa)
    //
    CoFreeUnusedLibraries();
}

//
// stolen from comctl32
//
// in:
//      hwnd    to do check on
//      x, y    in client coordinates
//
// returns:
//      TRUE    the user began to drag (moved mouse outside double click rect)
//      FALSE   mouse came up inside click rect
//
// FEATURE, should support VK_ESCAPE to cancel

BOOL CheckForDragBegin(HWND hwnd, int x, int y)
{
    RECT rcDragRadius;
    int  cxDrag = GetSystemMetrics(SM_CXDRAG);
    int  cyDrag = GetSystemMetrics(SM_CYDRAG);

    ASSERT((cxDrag > 1) && (cyDrag > 1));

    // See if the user moves a certain number of pixels in any direction
    SetRect(&rcDragRadius,
            x - cxDrag,
            y - cyDrag,
            x + cxDrag,
            y + cyDrag);

    MapWindowRect(hwnd, NULL, &rcDragRadius);

    SetCapture(hwnd);

    do 
    {
        MSG msg;

        // NTRAID 610356: Sleep the thread waiting for mouse input. Prevents pegging the CPU in a
        // PeekMessage loop.
        switch (MsgWaitForMultipleObjectsEx(0, NULL, INFINITE, QS_MOUSE, MWMO_INPUTAVAILABLE))
        {
            case WAIT_OBJECT_0:
            {
                if (PeekMessage(&msg, NULL, WM_MOUSEFIRST, WM_MOUSELAST, PM_REMOVE))
                {
                    // See if the application wants to process the message...
                    if (CallMsgFilter(&msg, MSGF_COMMCTRL_BEGINDRAG) == 0)
                    {
                        switch (msg.message)
                        {
                            case WM_LBUTTONUP:
                            case WM_RBUTTONUP:
                            case WM_LBUTTONDOWN:
                            case WM_RBUTTONDOWN:
                            {
                                // Released the mouse without moving outside the
                                // drag radius, not beginning a drag.
                                ReleaseCapture();
                                return FALSE;
                            }
                            case WM_MOUSEMOVE:
                            {
                                if (!PtInRect(&rcDragRadius, msg.pt)) 
                                {
                                    // Moved outside the drag radius, beginning a drag.
                                    ReleaseCapture();
                                    return TRUE;
                                }

                                break;
                            }
                            default:
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);

                                break;
                            }
                        }
                    }
                }
                break;
            }
            default:
                break;
        }

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
    } while (GetCapture() == hwnd);

    return FALSE;
}

void CShellBrowser2::_SetTheaterBrowserBar()
{
#ifndef DISABLE_FULLSCREEN
    if (_ptheater) {
        IDeskBar *pdbBar = NULL;
        
        FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdbBar));
        
        _ptheater->SetBrowserBar(pdbBar, 120, 200);
        
        if (pdbBar)
            pdbBar->Release();
    }
#endif
}

void CShellBrowser2::_TheaterMode(BOOL fShow, BOOL fRestorePrevious)
{
#ifndef DISABLE_FULLSCREEN
    if (BOOLIFY(fShow) == BOOLIFY(_ptheater))
        return;
    
    WINDOWPLACEMENT wp;
    RECT rc;
    if (fRestorePrevious && !fShow) {
        _ptheater->GetPreviousWindowPlacement(&wp, &rc);
    } else 
        fRestorePrevious = FALSE;
        
    HRESULT hresResize = _pbsInner->AllowViewResize(FALSE);
    
    if (!fShow) 
    {    
        if (_ptheater) {            
            if (fRestorePrevious) {
                PutBaseBrowserData()->_hwnd = _ptheater->GetMasterWindow();
                SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_DLGFRAME | WS_THICKFRAME | WS_BORDER, WS_DLGFRAME | WS_THICKFRAME | WS_BORDER);
                SetWindowPos(_pbbd->_hwnd, NULL, 0, 0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_FRAMECHANGED);
            }
            delete _ptheater;
            _ptheater = NULL;
        }
    } 
    else 
    {
        _SaveITbarLayout();
        _SaveState();
        SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_DLGFRAME | WS_THICKFRAME, 0);
        // if we're going to theater mode, don't allow best fit stuff
        _fsd._fs.fFlags &= ~FWF_BESTFITWINDOW;
        
        HWND hwndToolbar = NULL;
        
        if (_GetITBar())
            _GetITBar()->GetWindow(&hwndToolbar);

        _ptheater = new CTheater(_pbbd->_hwnd, hwndToolbar, (IOleCommandTarget*)this);
        if (_ptheater) 
        {
            _SetTheaterBrowserBar();

            // the progress control is a bit special in this mode.  we pull this out and make it topmost.
            _ShowHideProgress();
        }
    }
    
    // the itbar is special in that it stays with the auto-hide window.
    // it needs to know about theater mode specially
    // Also, set _ptheater->_fAutoHideToolbar to _pitbar->_fAutoHide
    VARIANT vOut = { VT_I4 };
    vOut.lVal = FALSE;  // default: no auto hide explorer toolbar
    IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_THEATER, fShow ? THF_ON : THF_OFF, &vOut, &vOut);

    if (_ptheater)
    {
        _ptheater->SetAutoHideToolbar(vOut.lVal);
    }

    _pbsInner->AllowViewResize(hresResize == S_OK);
    SUPERCLASS::OnSize(SIZE_RESTORED);

    if (_ptheater)
        _ptheater->Begin();     // kick start!

    // notify trident that it's ambients are invalid to force
    // it to re-query us for the flat property
    if (_pbbd->_pctView) 
    {
        VARIANTARG vaIn;
        vaIn.vt = VT_I4;
        vaIn.lVal = DISPID_UNKNOWN;

        _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_AMBIENTPROPCHANGE, NULL, &vaIn, NULL);
    }

    if (_pxtb) 
    {
        UINT uiState;
        if (SUCCEEDED(_pxtb->GetState(&CLSID_CommonButtons, TBIDM_THEATER, &uiState))) 
        {
            if (_ptheater)
                uiState |= TBSTATE_CHECKED;
            else
                uiState &= ~TBSTATE_CHECKED;
            
            _pxtb->SetState(&CLSID_CommonButtons, TBIDM_THEATER, uiState);
        }
    }

    if (!_ptheater && !_fShowMenu)
        IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_SHOWMENU, FALSE, NULL, NULL);

    if (fRestorePrevious) 
    {
        SetWindowPos(_pbbd->_hwnd, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), 0);
        if (IsWindowVisible(_pbbd->_hwnd)) 
        {
            ShowWindow(_pbbd->_hwnd, wp.showCmd);
            SetWindowPlacement(_pbbd->_hwnd, &wp);
        }
    }
#endif /* !DISABLE_FULLSCREEN */
}

BOOL CShellBrowser2::_OnSysMenuClick(BOOL bLeftClick, WPARAM wParam, LPARAM lParam)
{
    POINT pt = {GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};
    DWORD dwStart = GetTickCount();

    MapWindowPoints(NULL, _pbbd->_hwnd, &pt, 1);

    if (!CheckForDragBegin(_pbbd->_hwnd, pt.x, pt.y))
    {
        if (bLeftClick)
        {
            DWORD dwDelta = (GetTickCount() - dwStart);
            DWORD dwDblClick = GetDoubleClickTime();

            if (dwDelta < dwDblClick)
            {
                // HACK: use the lParam (coords) as the timer ID to communicate
                // that to the WM_TIMER handler
                //
                // HACK: store the timer id in a global. Since there's only one
                // double-click on a sysmenu at a time, this should be fine.
                if (g_sysmenuTimer)
                    KillTimer(_GetCaptionWindow(), g_sysmenuTimer);

                // We are special casing 0 as meaning there is no timer, so if the coords come in at
                // 0 then cheat them to 1.
                if (lParam == 0)
                    lParam++;

                g_sysmenuTimer = SetTimer(_GetCaptionWindow(), lParam, dwDblClick - dwDelta, NULL);
            }
            else
                DefWindowProcWrap(_pbbd->_hwnd, WM_CONTEXTMENU, (WPARAM)_pbbd->_hwnd, lParam);
        }
        else
            SendMessage(_pbbd->_hwnd, WM_CONTEXTMENU, (WPARAM)_pbbd->_hwnd, lParam);
        return FALSE;
    }
    IOleCommandTarget *pcmdt = NULL;
    if (_pbbd->_pautoWB2)
    {
        (_pbbd->_pautoWB2)->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &pcmdt));
        ASSERT(pcmdt);
    }
    
    BOOL fRet = DoDragDropWithInternetShortcut(pcmdt, _pbbd->_pidlCur, _pbbd->_hwnd);
    
    if (pcmdt)
        pcmdt->Release();

    return fRet;
}

void _SetWindowsListMarshalled(IWebBrowser2 *pautoWB2)
{
    IEFrameAuto* pief;
    if (SUCCEEDED(pautoWB2->QueryInterface(IID_IEFrameAuto, (void **)&pief))) 
    {
        pief->OnWindowsListMarshalled();
        pief->Release();
    }
}

BOOL CShellBrowser2::_OnTimer(UINT_PTR idTimer)
{
    BOOL fResult = FALSE;

    // HACK: _OnSysMenuClick uses the cursor coords as the timer ID.
    // So first check if g_sysmenuTimer is set before checking for
    // standard timer IDs.
    
    if (g_sysmenuTimer == idTimer)
    {
        KillTimer(_GetCaptionWindow(), g_sysmenuTimer);
        g_sysmenuTimer = 0;

        // the timer ID is the lParam from the left click!
        SendMessage(_GetCaptionWindow(), WM_SYSMENU, 0, idTimer);
        fResult = TRUE;
    }
    else
    {
        switch (idTimer)
        {
        case SHBTIMER_MENUSELECT:
            KillTimer(_pbbd->_hwnd, SHBTIMER_MENUSELECT);
            fResult = TRUE;

            if (_pidlMenuSelect)
            {
                _DisplayFavoriteStatus(_pidlMenuSelect);
                Pidl_Set(&_pidlMenuSelect, NULL);
            }
            break;
        }
    }
    return fResult;
}


void CShellBrowser2::_OnActivate(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (LOWORD(wParam) == WA_INACTIVE)
        _fActivated = FALSE;
    else
        _fActivated = TRUE;

    if (_pbbd->_hwndView)
        SendMessage(_pbbd->_hwndView, uMsg, wParam, lParam);

    if (LOWORD(wParam) != WA_INACTIVE)
    {
        // remember who had focus last, since trident will
        // grab focus on an OnFrameWindowActivate(TRUE)
        int itbLast = _pbsOuter->_get_itbLastFocus();

        _pbsOuter->OnFrameWindowActivateBS(TRUE);

        if (itbLast != ITB_VIEW)
        {
            // restore focus to its rightful owner
            LPTOOLBARITEM ptbi = _GetToolbarItem(itbLast);
            if (ptbi)
                IUnknown_UIActivateIO(ptbi->ptbar, TRUE, NULL);
        }
    }
    else
    {
#ifdef KEYBOARDCUES
        if (_pbbd->_hwnd)
        {
            SendMessage(_pbbd->_hwnd, WM_CHANGEUISTATE,
                MAKEWPARAM(UIS_SET, UISF_HIDEFOCUS | UISF_HIDEACCEL), 0);
        }
#endif
        _pbsOuter->OnFrameWindowActivateBS(FALSE);
    }
}


// Main window proc for CShellBrowser2

LRESULT CShellBrowser2::WndProcBS(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;

    if (_TranslateMenuMessage(hwnd, uMsg, &wParam, &lParam, &lRet))
        return lRet;

    switch(uMsg)
    {
    case WMC_DISPATCH:
        BSTR Url;
        {

            HRESULT hres;
            switch(wParam) {
            case DSID_NOACTION:
                return S_OK;
           
            case DSID_NAVIGATEIEBROWSER:
//
//  APPCOMPAT: To be fully compatible with IE 2.0, we don't want to use
// the window that has a navigation in progress. Enabling this code,
// however, causes some problem with the very first DDE. I need to
// investigate more, IF we need that level of compatibility. (SatoNa)
//
                
                // this is only used for IE Browser.
                // if this is not in iemode, then fail.
                // this prevents us from reusing C:\ to navigate to www
                if  (!v_IsIEModeBrowser())
                    return E_FAIL;

                ASSERT(lParam);
                if (!lParam)
                    break;
                Url = ((DDENAVIGATESTRUCT*)lParam)->wszUrl;
                hres = _pbbd->_pautoWB2->Navigate(Url, NULL, NULL, NULL, NULL);
                return hres;
                break;

            case DSID_GETLOCATIONURL:
                return _pbbd->_pautoWB2->get_LocationURL((BSTR*)lParam);

            case DSID_GETLOCATIONTITLE:
                return _pbbd->_pautoWB2->get_LocationName((BSTR*)lParam);
            
            case DSID_GETHWND:
                *(HWND*)lParam = hwnd;
                return S_OK;
#if 0
            case DSID_CANCEL:
                return _pbbd->_pautoWB2->Stop();
#endif
            case DSID_EXIT:
                return _pbbd->_pautoWB2->Quit();
            }
        }
        return (LRESULT)HRESULT_FROM_WIN32(ERROR_BUSY);
        
    case CWM_CLONEPIDL:
        if (_pbbd->_pidlCur)
        {
            return (LRESULT)SHAllocShared(_pbbd->_pidlCur, ILGetSize(_pbbd->_pidlCur), (DWORD)wParam);
        }
        break;
        
    case CWM_SELECTITEM:
    {
        LPITEMIDLIST pidl = (LPITEMIDLIST)SHLockShared((HANDLE)lParam, GetCurrentProcessId());
        if (pidl)
        {
            if (_pbbd->_psv) 
                _pbbd->_psv->SelectItem(pidl, (UINT)wParam);
            SHUnlockShared(pidl);
        }
        SHFreeShared((HANDLE)lParam, GetCurrentProcessId());   // Receiver responsible for freeing
        break;
    }
    
    case CWM_THEATERMODE:
        _TheaterMode(BOOLFROMPTR(wParam), !wParam);
        break;
        
    case CWM_GLOBALSTATECHANGE:
        // need to update the title
        if (wParam == CWMF_GLOBALSTATE)
            _SetTitle(NULL);
        else if (wParam == CWMF_SECURITY)
        {
            _UpdateZonesPane(NULL);
        }
        break;

        
    case CWM_FSNOTIFY:
        _OnFSNotify(wParam, lParam);
        break;
        
    case CWM_UPDATEBACKFORWARDSTATE:
        _UpdateBackForwardStateNow();
        break;

    case CWM_SHOWDRAGIMAGE:
        return DAD_ShowDragImage((BOOL)lParam);

    case WM_ENDSESSION:
        TraceMsg(DM_SHUTDOWN, "csb.wp: WM_ENDSESSION wP=%d lP=%d", wParam, lParam);
        if (wParam && IsWindowVisible(_pbbd->_hwnd) && _pbbd->_pidlCur && !_fUISetByAutomation) 
        {
            TraceMsg(DM_SHUTDOWN, "csb.wp: call AddToRestartList");
            if (!IsBrowserFrameOptionsSet(_pbbd->_psf, BFO_NO_REOPEN_NEXT_RESTART))
                AddToRestartList(v_RestartFlags(), _pbbd->_pidlCur);

            // for now we use the same 12-hour (SessionTime) rule
            // possibly we should just do it always?
            UEMFireEvent(&UEMIID_BROWSER, UEME_CTLSESSION, UEMF_XEVENT, FALSE, -1);
            if (!g_bRunOnNT5) {
                // for down-level guys (old explorer), fake a shell end session too
                UEMFireEvent(&UEMIID_SHELL, UEME_CTLSESSION, UEMF_XEVENT, FALSE, -1);
            }
            // And make sure we have saved it's state out
            TraceMsg(DM_SHUTDOWN, "csb.wp: call _SaveState");
            _SaveState();
        }
        TraceMsg(DM_SHUTDOWN, "csb.wp: WM_ENDSESSION return 0");
        break;

    case WM_TIMER:
        if (!_OnTimer(wParam))
            goto DoDefault;
        break;

    case WM_NCLBUTTONDOWN:
    case WM_NCRBUTTONDOWN:
        if (wParam != HTSYSMENU)
            goto DoDefault;

        _OnSysMenuClick(uMsg == WM_NCLBUTTONDOWN, wParam, lParam);
        break;

    case WM_NCLBUTTONDBLCLK:
        // We fault while shutting down the window if the timing is bad.
        // We're not sure why, but USER get's mightily confused. The only
        // difference between this scheme and a normal double-click-on-sysmenu
        // is the timer we have hanging around. Kill the timer before
        // processing this message. Hopefully that will work [mikesh/cheechew]
        //
        // HACK: remember this timer id is stored in a global variable
        //
        if (g_sysmenuTimer)
        {
            KillTimer(_GetCaptionWindow(), g_sysmenuTimer);
            g_sysmenuTimer = 0;
        }

        // We still want to process this DBLCLK
        goto DoDefault;
        
    case WM_CONTEXTMENU:
        if (!v_OnContextMenu(wParam, lParam))
            goto DoDefault;
        break;

    case WM_WININICHANGE:
        {
            DWORD dwSection = SHIsExplorerIniChange(wParam, lParam);

            // Hack for NT4 and Win95, where there is no SPI_GETMENUSHOWDELAY
            // Don't need to check wParam == SPI_SETMENUSHOWDELAY since we
            // always query afresh on NT5/Win98.
            if (dwSection & EICH_SWINDOWS)
                g_lMenuPopupTimeout = -1; /* in case MenuShowDelay changed */

            // Transitioning to/from "Working Offline" just broadcasts (0,0)
            // so that's all we listen for
            if (dwSection == EICH_UNKNOWN)
            {
                _ReloadTitle();
                _ReloadStatusbarIcon();
            }
        }
        goto DoDefault;

    case WM_INITMENUPOPUP:
        v_OnInitMenuPopup((HMENU)wParam, LOWORD(lParam), HIWORD(lParam));
        v_ForwardMenuMsg(uMsg, wParam, lParam);
        break;

    case WM_MENUSELECT:
        if (_ShouldForwardMenu(uMsg, wParam, lParam)) 
        {
            ForwardViewMsg(uMsg, wParam, lParam);
        } 
        else
        {
            BOOL fIsPopup = GET_WM_MENUSELECT_FLAGS(wParam, lParam) & MF_POPUP;

            if ((!_OnMenuSelect(wParam, lParam, 0) &&
                 (fIsPopup || IsInRange(LOWORD(wParam), FCIDM_SHVIEWFIRST, FCIDM_SHVIEWLAST)))

                || (_fDispatchMenuMsgs && fIsPopup))
            {
                ForwardViewMsg(uMsg, wParam, lParam);
            }

        }
        
        break;
        
    case WM_EXITSIZEMOVE:
        _fDisallowSizing = FALSE;
        break;

    case WM_WINDOWPOSCHANGING:
        if (_fDisallowSizing) 
        {
            LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;
            pwp->flags |= SWP_NOMOVE | SWP_NOSIZE;
        }
        break;
        
    case WM_ENTERSIZEMOVE:
        if (_ptheater)
            _fDisallowSizing = TRUE;
        break;

    case WM_EXITMENULOOP:
    case WM_ENTERMENULOOP:
        ForwardViewMsg(uMsg, wParam, lParam);
        break;

    case WM_DRAWITEM:
    case WM_MEASUREITEM:
        if (_ShouldForwardMenu(uMsg, wParam, lParam))
            ForwardViewMsg(uMsg, wParam, lParam);
        else
        {
            UINT  idCmd;
        
            switch (uMsg)
            {
                case WM_MEASUREITEM:
                    idCmd = GET_WM_COMMAND_ID(((MEASUREITEMSTRUCT *)lParam)->itemID, 0);
                    break;
                case WM_DRAWITEM:
                    idCmd = GET_WM_COMMAND_ID(((LPDRAWITEMSTRUCT)lParam)->itemID, 0);
                    break;
            }
        
            if (InRange(idCmd, FCIDM_SEARCHFIRST, FCIDM_SEARCHLAST) && _pcmSearch)
                _pcmSearch->HandleMenuMsg(uMsg, wParam, lParam);
            else if (_pcmNsc && IsInRange(idCmd, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST))
                _pcmNsc->HandleMenuMsg(uMsg, wParam, lParam);
            else if (_pcm && (_pcm->HandleMenuMsg(uMsg, wParam, lParam) == S_OK))
            {
                // the context menu ate it
            }
            else
            {                
                v_ForwardMenuMsg(uMsg, wParam, lParam);
            }
        }            
        break;

    case WM_QUERYENDSESSION:
        TraceMsg(DM_SHUTDOWN, "csb.wp: WM_QUERYENDSESSION");
#ifdef DEBUG
        if (S_OK == _DisableModeless())
        {
            TraceMsg(DM_WARNING, "CSB::WndProc got WM_QUERYENDSESSION when disabled");
            MessageBeep(0);
            UINT id = MLShellMessageBox(_pbbd->_hwnd,
                   MAKEINTRESOURCE(IDS_CLOSEANYWAY),
                   MAKEINTRESOURCE(IDS_TITLE),
                   MB_OKCANCEL | MB_SETFOREGROUND | MB_ICONSTOP);
            if (id==IDCANCEL) {
                return FALSE;
            }
        }
#endif
        // Try calling something that will call SHGetPathFromIDList to make sure we won't
        // call GetProcAddress while processing the WM_ENDSESSION...
        if (_pbbd->_pidlCur)
            HackToPrepareForEndSession(_pbbd->_pidlCur);

        return TRUE;    // OK to close

    case WM_CLOSE:
#ifdef NO_MARSHALLING
        _OnClose(_fOnIEThread);
#else
        _OnClose(TRUE);
#endif
        break;      

    case PUI_OFFICE_COMMAND:
    {
        switch (wParam)
        {
        case PLUGUI_CMD_SHUTDOWN:
        {
            HRESULT hr;
            VARIANT v;

            // first, kill the internet options modal
            // property sheet if it exists
            // it might be open because that's one of
            // out UI lang change scenarios

            V_VT(&v) = VT_BYREF;
            v.byref = NULL;

            if (_pbbd != NULL && _pbbd->_pctView != NULL)
            {
                hr = _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_GETOPTIONSHWND, 0, NULL, &v);
                if (SUCCEEDED(hr))
                {
                    ASSERT(V_VT(&v) == VT_BYREF);

                    if (v.byref != NULL)
                    {
                        // close the lang change modal property sheet
                        SendMessage((HWND)v.byref, WM_CLOSE, NULL, NULL);
                    }
                }
            }

            // now try to close the browser in general
            if (_pbbd != NULL && _pbbd->_pautoWB2 != NULL)
                _pbbd->_pautoWB2->Quit();

            break;
        }

        case PLUGUI_CMD_QUERY:
        {
            HMODULE hMod;

            // answer if we're an iexplore.exe process because
            // that means we're not sharing any dlls with the shell

            hMod = GetModuleHandle(TEXT("IEXPLORE.EXE"));

            if (hMod != NULL && !g_bRunOnNT5)
            {
                PLUGUI_QUERY    puiQuery;

                ASSERT(!g_bRunOnNT5);

                // we indicate that we participate in plugUI shutdown by
                // returning the version number for Office 9

                puiQuery.uQueryVal = 0;
                puiQuery.PlugUIInfo.uMajorVersion = OFFICE_VERSION_9;
                puiQuery.PlugUIInfo.uOleServer = FALSE;
                return puiQuery.uQueryVal;
            }
            break;
        }
        } // switch (wParam)

        break; // PUI_OFFICE_COMMAND
    }

    case WM_SYSCOMMAND:
        //
        // WARNING: User uses low four bits for some undocumented feature
        //  (only for SC_*). We need to mask those bits to make this case
        //  statement work.
        //
        switch (wParam & 0xfff0) {
        case SC_MAXIMIZE:                        
            if (GetKeyState(VK_CONTROL) < 0)
            {
                LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
                if (ptbi->fShow)    
                    PostMessage(_pbbd->_hwnd, CWM_THEATERMODE, TRUE, 0);
                else
                    goto DoDefault;
            }
            else
                goto DoDefault;
            break;
            
        case SC_CLOSE:
            // Make it posted so that we can detect if it's nested.
            PostMessage(_pbbd->_hwnd, WM_CLOSE, 0, 0);
            break;
            
        case SC_MINIMIZE:
            goto DoDefault;

        case SC_RESTORE:
            if (_ptheater && !_fMinimized)
            {
                PostMessage(_pbbd->_hwnd, CWM_THEATERMODE, FALSE, 0);
                return 0;
            }                         
            goto DoDefault;        

        default:
            goto DoDefault;
        }
        break;

    case WM_SIZE:
        // WARNING: Remember that we won't get WM_SIZE if we directly process
        // WM_WINDOWPOSCHANGED.
        {
            BOOL fMinimized = (wParam == SIZE_MINIMIZED);

            if (BOOLIFY(_fMinimized) != fMinimized)
            {
                TraceMsg(DM_ONSIZE, "SB::_WndProc WM_SIZE _fMinimized %d -> %d",
                         _fMinimized, fMinimized);
    
                _fMinimized = fMinimized;

                // Pause/Resume toolbars (intentionally ignores _pbbd->_psvPending). 
                VARIANT var = { 0 };
                var.vt = VT_I4;
                var.lVal = !_fMinimized;
                _ExecChildren(NULL, TRUE, NULL, OLECMDID_ENABLE_INTERACTION, OLECMDEXECOPT_DONTPROMPTUSER, &var, NULL);

                // Pause/Resule the view (refrelcts _pbbd->_psvPending too). 
                _PauseOrResumeView(_fMinimized);
            }
        }
#ifndef DISABLE_FULLSCREEN
        if (_ptheater && !_fMinimized)
            _ptheater->RecalcSizing();
#endif
        goto DoDefault;

    case WM_ACTIVATE:
        _OnActivate(uMsg, wParam, lParam);
        break;

    case WM_SETFOCUS:
        goto DoDefault;

    case WM_MENUCHAR:
        {
            LRESULT lres = 0;

            // Forwarding for IContextMenu3. 
            UINT idCmd = GetMenuItemID((HMENU)lParam, 0); // approximately correct: assume the first item on the menu identifies the range

            if (_pcm && _pcm->HandleMenuMsg2(uMsg, wParam, lParam, &lres) == S_OK)
                ; // do nothing
            else if (_pcmSearch && _pcmSearch->HandleMenuMsg2(uMsg, wParam, lParam, &lres) == S_OK)
                ; // do nothing
            else if (_pcmNsc && InRange(idCmd, FCIDM_FILECTX_FIRST, FCIDM_FILECTX_LAST))
                SHForwardContextMenuMsg(_pcmNsc, uMsg, wParam, lParam, &lres, FALSE);
            else
                lres = v_ForwardMenuMsg(uMsg, wParam, lParam);
            return lres;
        }
        break;

    case WM_CREATE:
#ifdef KEYBOARDCUES
        SendMessage(hwnd, WM_CHANGEUISTATE, MAKEWPARAM(UIS_INITIALIZE, 0), 0);
#endif
        lRet = SUPERCLASS::WndProcBS(hwnd, uMsg, wParam, lParam);
        if (lRet)
        {
            _OnClose(FALSE);
            _GetMenuBand(TRUE);
        }
        return lRet;

    case WMC_MARSHALIDISPATCHSLOW:
        {
#ifndef NO_MARSHALLING
            IStream *pIStream;
            HRESULT hres = CreateStreamOnHGlobal(NULL, TRUE, &pIStream);
            if (SUCCEEDED(hres)) 
            {
                HANDLE hShared = NULL;
                _fMarshalledDispatch = TRUE;
                hres = CoMarshalInterface(pIStream, IID_IDispatch,
                    _pbbd->_pautoWB2, MSHCTX_NOSHAREDMEM, NULL, MSHLFLAGS_NORMAL);
                if (SUCCEEDED(hres))
                {
                    _SetWindowsListMarshalled(_pbbd->_pautoWB2);

                    ULARGE_INTEGER uliPos;
                    const LARGE_INTEGER li = {0,0};
                    pIStream->Seek(li, STREAM_SEEK_CUR, &uliPos);

                    // And point back to the beginning...
                    pIStream->Seek(li, STREAM_SEEK_SET, NULL);
    
                    hShared = SHAllocShared(NULL, uliPos.LowPart + sizeof(DWORD), (DWORD)lParam);
                    if (hShared)
                    {
                        LPBYTE pv = (LPBYTE)SHLockShared(hShared, (DWORD)lParam);
                        if (pv)
                        {
                            *((DWORD*)pv) = uliPos.LowPart;
                            pIStream->Read(pv + sizeof(DWORD), uliPos.LowPart, NULL);
                            SHUnlockShared(pv);
                        }
                        else
                        {
                            SHFreeShared(hShared, (DWORD)lParam);
                            hShared = NULL;
                        }
                    }
                }
                pIStream->Release();
                return (LRESULT)hShared;
            }
#else
            IDispatch **idispTemp = (IDispatch**)lParam;
            *idispTemp = _pbbd->_pautoWB2;
            return S_OK;
#endif
        }

    case WM_GETOBJECT:
        if (OBJID_MENU == (DWORD)lParam)
        {
            IAccessible* pacc;
            IMenuBand* pmb = _GetMenuBand(FALSE);

            if (pmb && SUCCEEDED(IUnknown_QueryService(pmb, SID_SMenuBandChild, 
                IID_PPV_ARG(IAccessible, &pacc))))
            {
                lRet = LresultFromObject(IID_IAccessible, wParam, pacc);
                pacc->Release();

                return lRet;
            }
        }
        break;

    default:
        lRet = _WndProcBSNT5(hwnd, uMsg, wParam, lParam);
        if (lRet)
            return lRet;

        if (_nMBIgnoreNextDeselect == uMsg)
        {
            _fIgnoreNextMenuDeselect = TRUE;
            TraceMsg(TF_MENUBAND, "MenuBand: Shbrowse.cpp received our private MBIgnoreNextDeselect");
            break;
        }
        else if (GetDDEExecMsg() == uMsg)
        {
            ASSERT(lParam && 0 == ((LPNMHDR)lParam)->idFrom);
            DDEHandleViewFolderNotify(this, _pbbd->_hwnd, (LPNMVIEWFOLDER)lParam);
            LocalFree((LPNMVIEWFOLDER)lParam);
            return TRUE;
        }
        else if (g_msgMSWheel == uMsg)
        {
            // Frame doesn't have scrollbar, let the view have a crack at it (309709)
            return SendMessage(_pbbd->_hwndView, uMsg, wParam, lParam);
        }

DoDefault:
        lRet = SUPERCLASS::WndProcBS(hwnd, uMsg, wParam, lParam);
        if (WM_COMMAND == uMsg)
        {
            IUnknown_SetSite(_pcmNsc, NULL);
            ATOMICRELEASE(_pcmNsc);
        }

        return lRet;
    }

    return 0;
}

HRESULT CShellBrowser2::OnSetFocus()
{
    TraceMsg(DM_FOCUS, "csb.osf: hf()=%d itbLast=%d", _HasToolbarFocus(), _get_itbLastFocus());
    // forward to whoever had focus last (view or toolbar).  i think this
    // was added for ie4:55511 to fix pblm w/ tabbing away from IE and
    // then back.  note the check of _get_itbLastFocus w/o the usual
    // _HasToolbarFocus/_FixToolbarFocus magic...
    //
    // this used to be in CCB::OSF but that's bogus since in the desktop
    // case, this means once a deskbar (e.g. address) has focus, we can
    // never get focus back on the desktop (nt5:167864).
    if (_get_itbLastFocus() == ITB_VIEW) {
        // forward it on to view (in basesb)
        _pbsInner->OnSetFocus();
    } else {
        LPTOOLBARITEM ptbi = _GetToolbarItem(_get_itbLastFocus());
        if (ptbi)
            IUnknown_UIActivateIO(ptbi->ptbar, TRUE, NULL);
    }
    return 0;
}


LRESULT CALLBACK IEFrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lResult = 0;
    CShellBrowser2* psb = (CShellBrowser2*)GetWindowPtr0(hwnd);

    switch(uMsg)
    {
    case WM_NCCREATE:
    {
        IETHREADPARAM* piei = (IETHREADPARAM*)((LPCREATESTRUCT)lParam)->lpCreateParams;

        ASSERT(psb == NULL);

        if (piei->uFlags & COF_EXPLORE) 
        {
            CExplorerBrowser_CreateInstance(hwnd, (void **)&psb);
        } 
        else
        {
            CShellBrowser2_CreateInstance(hwnd, (void **)&psb);
        }

        if (psb)
        {
            SetWindowLongPtr(hwnd, 0, (LONG_PTR)psb);

            _InitAppGlobals();
            // Hack: Let's try only registering dde on iexplorer windows for
            // shell speed.  (ie ignore shell folders)
            DWORD dwAttr = SFGAO_FOLDER;

            if ((!(piei->pidl &&
                   SUCCEEDED(IEGetAttributesOf(piei->pidl, &dwAttr)) &&
                   (dwAttr & SFGAO_FOLDER))) ||
                (piei->uFlags & COF_FIREEVENTONDDEREG))
            {
                //
                // Tell IEDDE that a new browser window is available.
                //
                IEDDE_NewWindow(hwnd);

                //
                // Fire the DdeRegistered event if necessary.
                //
                if (piei->uFlags & COF_FIREEVENTONDDEREG)
                {
                    ASSERT(piei->szDdeRegEvent[0]);
                    FireEventSzW(piei->szDdeRegEvent);
                }
            }
            return psb->WndProcBS(hwnd, uMsg, wParam, lParam);
        }
        else
        {
            return 0;
        }
    }

    case WM_CREATE:
    {
        lResult = psb ? psb->WndProcBS(hwnd, uMsg, wParam, lParam) : DefWindowProc(hwnd, uMsg, wParam, lParam);
 
        // if we have a psb and WndProc() failed (!lResult), then fall through
        // and process the WM_NCDESTROY.
        if (!psb || !lResult)
            break;

        if (psb)
            psb->_OnClose(FALSE);
        // Fall Thru because we need to clean up since the create failed.
        // fall through
    }

    case WM_NCDESTROY:

        //
        // Tell IEDDE that a browser window is no longer available.
        //
        IEDDE_WindowDestroyed(hwnd);

        // WM_NCDESTROY is supposed to be the last message we ever
        // receive, but let's be paranoid just in case...
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)0);
        
        // psb may be NULL if we failed to create the window.  An
        // Example includes using Start->Run to open a window to
        // a UNC share that the user doesn't have permissions to see.
        if (psb) 
        {
            psb->PutBaseBrowserData()->_hwnd = NULL;
            if (psb->_dwRegisterWinList)
            {
                if (psb->_fMarshalledDispatch)
                {
                    IShellWindows* psw = WinList_GetShellWindows(TRUE);
                    if (psw)
                    {
                        psw->Revoke(psb->_dwRegisterWinList);
                        psw->Release();
                    }
                }
                else
                {
                    if (psb->_psw)
                        psb->_psw->Revoke(psb->_dwRegisterWinList);
                } 
            }
            ATOMICRELEASE(psb->_psw);
            psb->_fMarshalledDispatch = 0;
            psb->_dwRegisterWinList = 0;
            ATOMICRELEASE(psb->_punkMsgLoop); // Release the message loop if the browser is going away
            psb->Release();
        }
        
        break;

    default:
        return psb ? psb->WndProcBS(hwnd, uMsg, wParam, lParam) : DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lResult;
}


// *** IShellBrowser methods *** (same as IOleInPlaceFrame)

/*----------------------------------------------------------
Purpose: IShellBrowser::InsertMenusSB method

*/
HRESULT CShellBrowser2::InsertMenusSB(HMENU hmenu, LPOLEMENUGROUPWIDTHS lpMenuWidths)
{
    RIP(IS_VALID_HANDLE(hmenu, MENU));

    if (_hmenuTemplate) 
    {
        HMENU hmenuSrc;
        if (_get_itbLastFocus() == ITB_VIEW && 
            _pbbd->_uActivateState == SVUIA_ACTIVATE_FOCUS) 
        {
            hmenuSrc = _hmenuTemplate;
        }
        else
        {
            hmenuSrc = _hmenuFull;
        }

        Shell_MergeMenus(hmenu, hmenuSrc, 0, 0, FCIDM_BROWSERLAST, MM_SUBMENUSHAVEIDS);
        lpMenuWidths->width[0] = 1;     // File
        lpMenuWidths->width[2] = 2;     // Edit, View
        lpMenuWidths->width[4] = 1;     // Help
    }

    // Save this away so we can correctly build the menu list object
    _hmenuBrowser = hmenu;

    DEBUG_CODE(_DumpMenus(TEXT("InsertMenusSB"), TRUE);)

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IShellBrowser::SetMenuSB method

*/
HRESULT CShellBrowser2::SetMenuSB(HMENU hmenu, HOLEMENU hmenuRes, HWND hwnd)
{
    RIP(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    // A NULL hmenu means to reinstate the container's original menu
    if (hmenu) {
        _hmenuCur = hmenu;
    } else {
        if (_fRunningInIexploreExe)
            _hmenuCur = _hmenuPreMerged;
        else
            _hmenuCur = _hmenuTemplate;
    }

    _fDispatchMenuMsgs = FALSE;
    _fForwardMenu = FALSE;

    // Normally _hmenuBrowser is set by the caller of InsertMenusSB.
    // However, with the actual web browser, InsertMenusSB is never called.
    // That means _hmenuBrowse is either NULL or non-NULL but invalid.
    // So in that case assume hmenu is equivalent.  This essentially makes
    // all messages get sent to the frame, which is what we want.

    HMENU hmenuBrowser;

    if (!IsMenu(_hmenuBrowser)) // We're calling IsMenu on purpose
        _hmenuBrowser = NULL;

    if (NULL != _hmenuBrowser)
        hmenuBrowser = _hmenuBrowser;
    else
        hmenuBrowser = hmenu;

    _menulist.Set(hmenu, hmenuBrowser);

    // Was the help menu merged?
    HMENU hmenuHelp = NULL;
    
    if (_pbbd->_pctView)
    {
        VARIANTARG vaOut = {0};

        if (S_OK == _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_QUERYMERGEDHELPMENU, 0, NULL, &vaOut))
        {
            // Yes; remove it from the list so it isn't accidentally
            // forwarded on.

            if (VT_INT_PTR == vaOut.vt)
            {
                hmenuHelp = (HMENU)vaOut.byref;

                ASSERT(IS_VALID_HANDLE(hmenuHelp, MENU));
                _menulist.RemoveMenu(hmenuHelp);
            }
            VariantClearLazy(&vaOut);
            
            vaOut.vt = VT_EMPTY;
            vaOut.byref = NULL;
            
            if (S_OK == _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_QUERYOBJECTSHELPMENU, 0, NULL, &vaOut))
            {
                if (VT_INT_PTR == vaOut.vt)
                {
                    // Add the object's help submenu to the list so it gets forwarded
                    HMENU hmenuObjHelp = (HMENU)vaOut.byref;

                    ASSERT(IS_VALID_HANDLE(hmenuObjHelp, MENU));
                    _menulist.AddMenu(hmenuObjHelp);
                }
                VariantClearLazy(&vaOut);
            }
            
        }
    }
    
    // 80734: Was the Go To menu taken from the View menu and grafted onto the
    // main menu by DocHost?  The menulist won't detect this graft, so we have
    // to check ourselves and make sure it's not marked as belonging to the 
    // docobject.
    //
    // This test is duplicated in CDocObjectHost::_SetMenu

    MENUITEMINFO mii;
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;

    if (hmenu && _hmenuBrowser && 
        GetMenuItemInfo(hmenu, FCIDM_MENU_EXPLORE, FALSE, &mii))
    {
        HMENU hmenuGo = mii.hSubMenu;

        if (GetMenuItemInfo(_hmenuBrowser, FCIDM_MENU_EXPLORE, FALSE, &mii) &&
            mii.hSubMenu == hmenuGo && _menulist.IsObjectMenu(hmenuGo))
        {
            _menulist.RemoveMenu(hmenuGo);
        }
    }

    DEBUG_CODE(_hmenuHelp = hmenuHelp;)

    if (!_fKioskMode)
    {
        if (_fShowMenu)
            _SetMenu(_hmenuCur);
        else
            _SetMenu(NULL);
    }

    DEBUG_CODE(_DumpMenus(TEXT("SetMenuSB"), TRUE););

    return S_OK;
}


/*----------------------------------------------------------
Purpose: Remove menus that are shared with other menus from 
         the given browser menu.

*/
HRESULT CShellBrowser2::RemoveMenusSB(HMENU hmenuShared)
{
    // Generally, there is no need to remove most of the menus because 
    // they were cloned and inserted into this menu.  However, the 
    // Favorites menu is an exception because it is shared with
    // _hmenuFav.

    return S_OK;
}

void CShellBrowser2::_ShowHideProgress()
{
    if (_hwndProgress) {
        
        UINT uShow = SW_SHOW;
        if (SendMessage(_hwndProgress, PBM_GETPOS, 0, 0) == 0)
            uShow = SW_HIDE;
        
        ShowWindow(_hwndProgress, uShow);
        
        TraceMsg(TF_SHDPROGRESS, "CShellBrowser2::_ShowHideProgress() uShow = %X", uShow);
    }
}

HRESULT CShellBrowser2::SendControlMsg(UINT id, UINT uMsg, WPARAM wParam,
            LPARAM lParam, LRESULT *pret)
{
    HRESULT hres = SUPERCLASS::SendControlMsg(id, uMsg, wParam, lParam, pret);
    
    if (id == FCW_PROGRESS) {
        if (uMsg == PBM_SETRANGE32 || uMsg == PBM_SETPOS)
            _ShowHideProgress();
        
        if (_ptheater && _ptheater->_hwndProgress)
            SendMessage(_ptheater->_hwndProgress, uMsg, wParam, lParam);
    }
    return hres;
}

HRESULT CShellBrowser2::_QIExplorerBand(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;
    HRESULT hr = E_FAIL;
    IDeskBar* pdbBar;
    if (SUCCEEDED(FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdbBar))) && pdbBar)
    {
        IUnknown* punkBS;
        if (SUCCEEDED(pdbBar->GetClient(&punkBS)))
        {
            IBandSite* pbs;
            if (SUCCEEDED(punkBS->QueryInterface(IID_PPV_ARG(IBandSite, &pbs))))
            {
                IDeskBand* pdbBand = FindBandByClsidBS(pbs, CLSID_ExplorerBand);
                if (pdbBand)
                {
                    hr = pdbBand->QueryInterface(riid, ppvObj);
                    pdbBand->Release();
                }
                pbs->Release();
            }
            punkBS->Release();
        }
        pdbBar->Release();
    }
    return hr;
}

HRESULT CShellBrowser2::GetControlWindow(UINT id, HWND * lphwnd)
{
    // the defaults
    HRESULT hres = E_FAIL;
    *lphwnd = NULL;

    switch (id)
    {
    case FCW_INTERNETBAR:
        if (_GetITBar() && _GetToolbarItem(ITB_ITBAR)->fShow)
            hres = _GetITBar()->GetWindow(lphwnd);
        break;
        
    case FCW_TOOLBAR:
        *lphwnd = _hwndDummyTB;
        break;

    case FCW_STATUS:
        *lphwnd = _hwndStatus;
        break;
        
    case FCW_PROGRESS:
        if (!_hwndProgress && _hwndStatus) {
            _hwndProgress = CreateWindowEx(0, PROGRESS_CLASS, NULL,
                                           WS_CHILD | WS_CLIPSIBLINGS | PBS_SMOOTH,
                                           0, 0, 1, 1,
                                           _hwndStatus, (HMENU)1,
                                           HINST_THISDLL, NULL);

            // we yank off this bit because we REALLY don't want it because
            // the status bar already draws this for us when we specify rects
            //
            // but the progress bar forces this bit on during creation
            if (_hwndProgress)
                SHSetWindowBits(_hwndProgress, GWL_EXSTYLE, WS_EX_STATICEDGE, 0);
        }
        *lphwnd = _hwndProgress;
        break;

    case FCW_TREE:
        {
            BOOL fExplorerBandVisible;
            if (SUCCEEDED(IsControlWindowShown(FCW_TREE, &fExplorerBandVisible)) && fExplorerBandVisible)
            {
                IOleWindow* pow;
                if (SUCCEEDED(_QIExplorerBand(IID_IOleWindow, (void**)&pow)))
                {
                    pow->GetWindow(lphwnd);
                    pow->Release();
                }
            }
        }
        break;
    }

    if (*lphwnd) {
        hres = S_OK;
    }
    return hres;
}


//==========================================================================
//
//==========================================================================
HRESULT CShellBrowser2::SetToolbarItems(LPTBBUTTON pViewButtons, UINT nButtons,
            UINT uFlags)
{
    LPTBBUTTON pStart= NULL, pbtn= NULL;
    int nFirstDiff = 0, nTotalButtons = 0;
    BOOL bVisible = FALSE;

    if (uFlags & FCT_CONFIGABLE)
    {
        return S_OK;
    }

    // Allocate buffer for the default buttons plus the ones passed in
    //
    pStart = (LPTBBUTTON)LocalAlloc(LPTR, nButtons * sizeof(TBBUTTON));
    if (!pStart)
        return S_OK;

    pbtn = pStart;
    nTotalButtons = 0;

    if (pViewButtons)
    {
        int i;
        for (i = nButtons - 1; i >= 0; --i)
        {
            // copy in the callers buttons
            //
            pbtn[i] = pViewButtons[i];
            // make sure this is properly set to -1.
            // in win95, we had no strings so extensions couldn't set it, but some didn't initialize to -1
            if ((!pbtn[i].iString || (pbtn[i].iString <= (MAX_TB_BUTTONS + NUMBER_SHELLGLYPHS - 1))))
            {
                // We should not set our own shell iString to -1
                ASSERT(pbtn[i].iString != pbtn[i].iBitmap);
                // comment about Hummingbird passing 0xc always
                COMPILETIME_ASSERT(MAX_TB_BUTTONS + NUMBER_SHELLGLYPHS >= 0xc);
                pbtn[i].iString = -1;
            }
        }

        pbtn += nButtons;
        nTotalButtons += nButtons;
    }

    
    if (_pxtb)
    {
        // for right now, disable customize for all old style views
        DWORD dwFlags = VBF_NOCUSTOMIZE; 
        TCHAR szScratch[32];
    
        if (_nTBTextRows  == -1) {
            if (MLLoadString(IDS_SHELL_TB_TEXTROWS, szScratch, ARRAYSIZE(szScratch)))
                _nTBTextRows   = (UINT)StrToInt(szScratch);
            else    
                _nTBTextRows   = 0;
        }

        if (_nTBTextRows   == 1)
            dwFlags |= VBF_ONELINETEXT;
        else if (_nTBTextRows   == 2)
            dwFlags |= VBF_TWOLINESTEXT;
            
        
        _pxtb->SetCommandTarget((IUnknown *)SAFECAST(this, IOleCommandTarget *), &CGID_ShellBrowser, dwFlags);
        if (_lpPendingButtons)
            LocalFree(_lpPendingButtons);
        _lpPendingButtons = (TBBUTTON*)pStart;
        _nButtonsPending =  nTotalButtons;
    }
    else
    {
        LocalFree(pStart);
    }
    
    return S_OK;
}


#ifdef DEBUG
//---------------------------------------------------------------------------
// Copy the exception info so we can get debug info for Raised exceptions
// which don't go through the debugger.
void _CopyExceptionInfo(LPEXCEPTION_POINTERS pep)
{
    PEXCEPTION_RECORD per;

    per = pep->ExceptionRecord;
    TraceMsg(DM_ERROR, "Exception %x at %#08x.", per->ExceptionCode, per->ExceptionAddress);

    if (per->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
    {
        // If the first param is 1 then this was a write.
        // If the first param is 0 then this was a read.
        if (per->ExceptionInformation[0])
        {
            TraceMsg(DM_ERROR, "Invalid write to %#08x.", per->ExceptionInformation[1]);
        }
        else
        {
            TraceMsg(DM_ERROR, "Invalid read of %#08x.", per->ExceptionInformation[1]);
        }
    }
}
#else
#define _CopyExceptionInfo(x) TRUE
#endif

#define SVSI_SELFLAGS (SVSI_SELECT|SVSI_FOCUSED|SVSI_DESELECTOTHERS|SVSI_ENSUREVISIBLE)

void CShellBrowser2::_AfterWindowCreated(IETHREADPARAM *piei)
{
    //
    // Let interested people know we are alive
    //
    if (piei->uFlags & COF_SELECT)
    {
        IShellView* psv = _pbbd->_psv ? _pbbd->_psv : _pbbd->_psvPending;
        if (psv)
            psv->SelectItem(piei->pidlSelect, SVSI_SELFLAGS);
    }

    //
    //  Keep it hidden if this is the first instance which is started
    // with "/automation" flag or this object is being created as the
    // result of our CreateInstance.
    //
    if (!_fAutomation && !piei->piehs)
    {
        if (_fKioskMode)
        {
            // Turn off flag as we need to let the next function set it...
            _fKioskMode = FALSE;

            // Hack -1 implies
            ShowControlWindow((UINT)-1, TRUE);
        }
        
        UINT nCmdShow = piei->nCmdShow;
        BOOL fSetForeground = FALSE;
        BOOL fStartTheater = FALSE;

        // we need to do this setforegroundwindow 
        // because of a bug in user.  if the previous thread didn't have
        // activation, ShowWindow will NOT give us activation even though
        // it's supposed to
        switch (nCmdShow) {
        case SW_SHOWNORMAL:
        case SW_SHOWMAXIMIZED:
        case SW_SHOW:
            fSetForeground = TRUE;
            break;
        }
        
        if (_fUseIEPersistence) 
        {
            fStartTheater = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                TEXT("FullScreen"), FALSE, FALSE);
        }
        
        if (fStartTheater) 
        {
            _TheaterMode(TRUE, FALSE);
            if (fSetForeground)
                nCmdShow = SW_SHOW;
        }

        MSG msg;
        if (!PeekMessage(&msg, _pbbd->_hwnd, WM_CLOSE, WM_CLOSE, PM_NOREMOVE)) 
        {
            ShowWindow(_pbbd->_hwnd, nCmdShow);
            //
            // AT THIS POINT ALL DDE TRANSACTIONS SHOULD SUCCEED. THE BROWSER
            // WINDOW WAS ADDED TO THE DDE WINITEM LIST ON WM_NCCREATE,
            // AUTOMATION WAS REGISTERED AS STARTED ON THE OnCreate,
            // AND THE WINDOW IS NOW VISIBLE AS A PART OF THE SHOWWINDOW.
            // 99% OF ALL DDE STARTUP BUGS ARE CAUSED BY SOMEBODY CHECKING FOR
            // MESSAGES (PEEKMESSAGE, GETMESSAGE, INTERPROC SENDMESSAGE, ETC.)
            // BEFORE THIS POINT.
            //
            if (fSetForeground)
                SetForegroundWindow(_pbbd->_hwnd);
        } 
        else 
        {
            ASSERT(msg.hwnd == _pbbd->_hwnd);
        }            
    }

    _SetTitle(NULL);

    //
    // Delay register our window now.
    //  Note that we need to do it after SetEvent(piei->piehs->GetHevent()) to
    //  avoid soft dead-lock in OLE, and we need to do it after the
    //  ShowWindow above because this will allow DDE messages to get
    //  sent to us.
    //
    //  RegisterWindow() shouldnt have been called yet, but if it has, we dont want
    //  to change its registration class from here.  zekel 9-SEP-97
    //
    ASSERT(!_fDidRegisterWindow);

    RegisterWindow(FALSE, (piei->uFlags & COF_EXPLORE) ? SWC_EXPLORER : SWC_BROWSER);


    // Delay loading accelerators from v_initmembers
    ASSERT(MLGetHinst());
    HACCEL hacc = LoadAccelerators(MLGetHinst(), MAKEINTRESOURCE(ACCEL_MERGE));
    ASSERT(hacc);
    SetAcceleratorMenu(hacc);

    // Send size so status bar shows
    SendMessage(_pbbd->_hwnd, WM_SIZE, 0, 0);

    // delay doing a bunch of registrations
    // things we don't want our subclass to inherit
    if (v_InitMembers == CShellBrowser2::v_InitMembers) 
    {
        // register to get filesys notifications
        _uFSNotify = RegisterNotify(_pbbd->_hwnd, CWM_FSNOTIFY, NULL, SHELLBROWSER_FSNOTIFY_FLAGS,
                                    SHCNRF_ShellLevel | SHCNRF_InterruptLevel, TRUE);
    }
    
    SignalFileOpen(piei->pidl);
}

//
//  RegisterWindow() should only be called with Unregister if the caller
//  wants to insure that the new ShellWindowClass is used.  this is used
//  by CIEFrameAuto to force the browser window in the 3rdParty winlist.
//
HRESULT CShellBrowser2::RegisterWindow(BOOL fForceReregister, int swc)
{
    if (!_psw) 
        _psw = WinList_GetShellWindows(FALSE);
    
    if (_psw)
    {
        if (fForceReregister && _fDidRegisterWindow)
        {
            _psw->Revoke(_dwRegisterWinList);
            _fDidRegisterWindow = FALSE;
        }

        if (!_fDidRegisterWindow)
        {
            // raymondc- HandleToLong should really be HANDLE_PTR or something - Browser folks need to fix the IDL
            _psw->Register(NULL, HandleToLong(_pbbd->_hwnd), swc, &_dwRegisterWinList);
            _fDidRegisterWindow = TRUE;
            _swcRegistered = swc;

            UpdateWindowList();
        }
        return S_OK;
    }
    return E_FAIL;
}

LRESULT CALLBACK IEFrameWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

void InitializeExplorerClass()
{
    static BOOL fInited = FALSE;

    if (!fInited) 
    {
        ENTERCRITICAL;
        if (!fInited) {

            WNDCLASS  wc = { 0 };

            wc.style            = CS_BYTEALIGNWINDOW;
            wc.lpfnWndProc      = IEFrameWndProc;
            wc.cbWndExtra       = sizeof(void *);
            wc.hInstance        = HINST_THISDLL;
            wc.hIcon            = LoadIcon(HinstShdocvw(), MAKEINTRESOURCE(ICO_TREEUP));
            wc.hCursor          = LoadCursor(NULL, IDC_SIZEWE);
            wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1);
            wc.lpszClassName    = c_szExploreClass;

            RegisterClass(&wc);

            wc.hIcon            = LoadIcon(HinstShdocvw(), MAKEINTRESOURCE(IDI_STATE_NORMAL));
            wc.hCursor          = LoadCursor(NULL, IDC_ARROW);

            wc.lpszClassName    = c_szIExploreClass;
            RegisterClass(&wc);
            
            // shell32 is stuck with this id forever since it came out on win95
#define IDI_FOLDEROPEN          5      // open folder
            wc.hIcon            = LoadIcon(HinstShell32(), MAKEINTRESOURCE(IDI_FOLDEROPEN));
            wc.lpszClassName    = c_szCabinetClass;
            RegisterClass(&wc);

            // this needs to be set at the END..
            // because otherwise a race condition occurs and some guys run throught the
            // outter most check and try to create before we're registered.
            fInited = TRUE;
        }
        LEAVECRITICAL;
    }
}

// compatability: we need to have the right class name so people can find our window
//
LPCTSTR _GetExplorerClassName(UINT uFlags)
{
    if (uFlags & COF_EXPLORE)
        return c_szExploreClass;
    else if (uFlags & COF_IEXPLORE || WhichPlatform() == PLATFORM_BROWSERONLY)
        return c_szIExploreClass;
    else
        return c_szCabinetClass;
}

void TimedDispatchMessage(MSG *pmsg)
{
    DWORD dwTime;
    if (g_dwStopWatchMode & SPMODE_MSGTRACE)
        dwTime = StopWatch_DispatchTime(TRUE, *pmsg, 0);
        
    DispatchMessage(pmsg);
    
    if (g_dwStopWatchMode)
    {
        if (g_dwStopWatchMode & SPMODE_MSGTRACE)
            StopWatch_DispatchTime(FALSE, *pmsg, dwTime);

        if ((g_dwStopWatchMode & SPMODE_SHELL) && (pmsg->message == WM_PAINT))
            StopWatch_TimerHandler(pmsg->hwnd, 1, SWMSG_PAINT, pmsg); // Save tick count for paint msg
    }
}


void DesktopChannel();

void BrowserThreadProc(IETHREADPARAM* piei)
{
    HMENU hmenu;
    HWND hwnd;
    DWORD dwExStyle = WS_EX_WINDOWEDGE;
    LONG cRefMsgLoop;           // the ref count for this thread
    IUnknown *punkMsgLoop;      // the ref object (wraps cRefMsgLoop) for this thread
    IUnknown *punkRefProcess;   // the process ref this thread holds (may be none)
    
#ifdef NO_MARSHALLING
    THREADWINDOWINFO *lpThreadWindowInfo = InitializeThreadInfoStructs();
    if (!lpThreadWindowInfo)
       goto Done;
#endif

    UINT tidCur = GetCurrentThreadId();
    UINT uFlags = piei->uFlags;

    // Set our priority higher for startup so that we are not starved by background tasks and
    // other pesky system activity
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

#ifndef NO_ETW_TRACING
    // Event trace for windows enable by shlwapi.
    if (g_dwStopWatchMode & SPMODE_EVENTTRACE)
        EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_STARTFRAME, NULL);
#endif
    if (g_dwStopWatchMode & (SPMODE_SHELL | SPMODE_BROWSER | SPMODE_JAVA | SPMODE_MSGTRACE))
        StopWatch_MarkFrameStart(piei->uFlags & COF_EXPLORE ? " (explore)" : "");

    punkRefProcess = piei->punkRefProcess;
    piei->punkRefProcess = NULL;        // we took ownership
   
    LPWSTR pszCloseEvent = (piei->uFlags & COF_FIREEVENTONCLOSE) ? StrDupW(piei->szCloseEvent) : NULL;

    // if we're going to do desktop channel stuff, do it and return
#ifdef ENABLE_CHANNELS
    if (piei->fDesktopChannel) 
    {
        if (piei->pSplash)
        {
            piei->pSplash->Dismiss();
            ATOMICRELEASE(piei->pSplash);
        }

        if (piei->uFlags & COF_FIREEVENTONDDEREG) 
        {
            ASSERT(piei->szDdeRegEvent[0]);
            FireEventSzW(piei->szDdeRegEvent);
        }

        DesktopChannel();
        goto Done;
    }
#endif  / ENABLE_CHANNELS
    TraceMsg(TF_SHDTHREAD, "BrowserThreadProc() - IE_ThreadProc(%x) just started.", tidCur);

    InitializeExplorerClass();

    if (SUCCEEDED(SHCreateThreadRef(&cRefMsgLoop, &punkMsgLoop)))
    {
        if (tidCur == g_tidParking)
        {
            SHSetInstanceExplorer(punkMsgLoop);   // we are process reference
        }
        SHSetThreadRef(punkMsgLoop);
    }

    // Set our title temporarily (for people who grab our title, like the SHEnumErrorMessage guy
    TCHAR szTempTitle[MAX_PATH];
    if (piei->uFlags & COF_IEXPLORE)
        MLLoadString(IDS_TITLE, szTempTitle, ARRAYSIZE(szTempTitle));
    else
        MLLoadString(IDS_CABINET, szTempTitle, ARRAYSIZE(szTempTitle));

    //
    // APPCOMPAT - apps like WebCD require a non-null menu on the
    // browser.  Thankfully USER won't draw a menuband on an empty hmenu.
    //
    hmenu = CreateMenu();
    dwExStyle |= IS_BIDI_LOCALIZED_SYSTEM() ? dwExStyleRTLMirrorWnd | dwExStyleNoInheritLayout: 0L;

    hwnd = SHNoFusionCreateWindowEx(dwExStyle, _GetExplorerClassName(piei->uFlags), szTempTitle,
        WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN, 
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, 
        hmenu, HINST_THISDLL, piei);

    if (punkMsgLoop)
        punkMsgLoop->Release();     // browser (in open state) holds the ref

    if (piei->pSplash)
    {
        piei->pSplash->Dismiss();
        ATOMICRELEASE(piei->pSplash);
    }
    
    if (hwnd)
    {
        if (g_dwStopWatchMode & SPMODE_SHELL)   // Create the timer to start watching for paint messages
            StopWatch_TimerHandler(hwnd, 0, SWMSG_CREATE, NULL);

        CShellBrowser2* psb = (CShellBrowser2*)GetWindowPtr0(hwnd);
        if (psb)
        {
#ifdef NO_MARSHALLING
            AddFirstBrowserToList(psb);
#endif
            psb->AddRef();
            psb->_AfterWindowCreated(piei);

            SHDestroyIETHREADPARAM(piei);
            piei = NULL;

            TraceMsg(TF_SHDTHREAD, "BrowserThreadProc() - IE_ThreadProc(%x) about to start the message loop", tidCur);

            BOOL fThreadPriorityHasBeenReset = FALSE;

            while (1)
            {
                MSG  msg;
                BOOL fPeek;

                fPeek = PeekMessage(&msg, NULL, 0, 0, PM_REMOVE);

                if (fPeek)
                {

#ifndef NO_ETW_TRACING
                    if (g_dwStopWatchMode & SPMODE_EVENTTRACE) {
                        if (msg.message == WM_KEYDOWN) {
                            if (msg.wParam == VK_RETURN) {
                                EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTRET, NULL);
                            }
                            else if (msg.wParam == VK_BACK) {
                                EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTBACK, NULL);
                            }
                            else if (msg.wParam == VK_NEXT) {
                                EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTNEXT, NULL);
                            }
                            else if (msg.wParam == VK_PRIOR) {
                                EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTPRIOR, NULL);
                            }
                        }
                        else if (msg.message == WM_LBUTTONUP) {
                            EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_USERINPUTLBUT, NULL);
                        }
                    }
#endif

                    if (g_dwStopWatchMode)
                        StopWatch_CheckMsg(hwnd, msg, uFlags == COF_EXPLORE ? " (explore) " : "");  // Key off of WM_KEYDOWN to start timing
#ifdef NO_MARSHALLING
                    CShellBrowser2 *psbOld = psb;
                    CShellBrowser2 *psb = CheckAndForwardMessage(lpThreadWindowInfo, psbOld, msg);
                    if (!psb) 
                        psb = psbOld;
#endif
                    if (psb->_pbbd->_hwnd && IsWindow(psb->_pbbd->_hwnd))
                    {
                        //
                        // Directly dispatch WM_CLOSE message to distinguish nested
                        // message loop case.
                        //
                        if ((msg.message == WM_CLOSE) && (msg.hwnd == psb->_pbbd->_hwnd)) 
                        {
                            psb->_OnClose(FALSE);
                            continue;
                        }
#ifdef NO_MARSHALLING
                        HWND hwnd = GetActiveWindow();
                        if (!IsNamedWindow(hwnd, TEXT("Internet Explorer_TridentDlgFrame")))
                        {
                            if (S_OK == psb->v_MayTranslateAccelerator(&msg))
                                continue;
                        }
                        else
                        {
                            DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);
                            if (dwExStyle & WS_EX_MWMODAL_POPUP)
                            {
                                if (S_OK == psb->v_MayTranslateAccelerator(&msg))
                                    continue;
                            }
                            else
                            {
                                if (msg.message >= WM_KEYFIRST && msg.message <= WM_KEYLAST && 
                                    (TranslateModelessAccelerator(&msg, hwnd) == S_OK))
                                    continue;
                            }
                        }
#else
                        if (S_OK == psb->v_MayTranslateAccelerator(&msg))
                            continue;
#endif
                    }

                    TranslateMessage(&msg);
                    TimedDispatchMessage(&msg);
                }
#ifdef NO_MARSHALLING
                else if ((cRefMsgLoop == 0) && (lpThreadWindowInfo->cWindowCount == 0))
#else
                else if (cRefMsgLoop == 0)
#endif
                {
                    TraceMsg(TF_SHDTHREAD, "BrowserThreadProc() - cRefMsgLoop == 0, done");
                    break;  // exit while (1), no more refs on this thread
                } 
                else 
                {
                    if (!fThreadPriorityHasBeenReset)
                    {
                        fThreadPriorityHasBeenReset = TRUE;
                        // Reset our priority to normal now that we have finished the startup
                        SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);
#ifdef PERF_LOGGING
                        HANDLE hEvent = OpenEvent(EVENT_MODIFY_STATE, FALSE, TEXT("ExplorerWindowIdle"));
                        if (hEvent)
                        {
                            SetEvent(hEvent);
                            CloseHandle(hEvent);
                        }
#endif
                    }

                    WaitMessage();

                    if (g_dwStopWatchMode & SPMODE_MSGTRACE)
                        StopWatch_SetMsgLastLocation(2);
                }
            }

            TraceMsg(TF_SHDTHREAD, "BrowserThreadProc() - IE_ThreadProc(%x) end of message loop", tidCur);
            psb->Release();
        }
    } 
    else 
    {
        // Unregister any pending that may be there
        WinList_Revoke(piei->dwRegister);
        TraceMsg(TF_WARNING, "BrowserThreadProc() - IE_ThreadProc CreateWindow failed");
    }
#if defined(ENABLE_CHANNELS) || defined(NO_MARSHALLING)
Done:
#endif
    // Make sure we return the thread priority to normal in case this thread is re-used.
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_NORMAL);

    if (pszCloseEvent) 
    {
        FireEventSzW(pszCloseEvent);
        LocalFree(pszCloseEvent);
    }

    SHDestroyIETHREADPARAM(piei);

    if (punkRefProcess)
        punkRefProcess->Release();

#ifdef NO_MARSHALLING
    FreeThreadInfoStructs();
#endif
}

DWORD CALLBACK BrowserProtectedThreadProc(void *pv)
{
    if (g_dwProfileCAP & 0x00000004)
        StartCAP();

    HRESULT hrInit = OleInitialize(NULL);

    PostMessage(GetShellWindow(), DTM_SETAPPSTARTCUR, 0, 0);

#ifdef DEBUG
    if (hrInit != S_OK)
    {
        TraceMsg(TF_WARNING, "BrowserProtectedThreadProc: OleInitialize returned %x ?!?", hrInit);
    }
#endif

    ULONG_PTR dwCookie = 0;
    NT5_ActivateActCtx(NULL, &dwCookie);        // Set to inherit the process context

#if !defined(FULL_DEBUG) && (!defined(UNIX) || (defined(UNIX) && defined(GOLDEN)))

    EXCEPTION_RECORD exr;
    
    _try
    {
        BrowserThreadProc((IETHREADPARAM*)pv);
    }
    _except((exr = *((GetExceptionInformation())->ExceptionRecord),
            _CopyExceptionInfo(GetExceptionInformation()),
            UnhandledExceptionFilter(GetExceptionInformation())))
    {
        LPCTSTR pszMsg = NULL;
        //  we will try to display a message box to tell the user
        // that a thread has died...
        //
        if (GetExceptionCode() == STATUS_NO_MEMORY)
            pszMsg = MAKEINTRESOURCE(IDS_EXCEPTIONNOMEMORY);
        else if (WhichPlatform() == PLATFORM_BROWSERONLY)
        {
            pszMsg =  MAKEINTRESOURCE(IDS_EXCEPTIONMSG);
        }
        // don't show the message box on non-nt systems
        //  older than millennium (with an older shell)
        //  see IE5.5 bug#93165
        else if (g_fRunningOnNT || (GetUIVersion() < 5))
        {
            pszMsg = MAKEINTRESOURCE(IDS_EXCEPTIONMSGSH);
        }

        if (pszMsg)
        {
            MLShellMessageBox(NULL, pszMsg,
                              MAKEINTRESOURCE(IDS_TITLE), MB_ICONEXCLAMATION|MB_SETFOREGROUND);
        }

        if (GetExceptionCode() != STATUS_NO_MEMORY)
            IEWriteErrorLog(&exr);
    }
    __endexcept
#else
    // IEUNIX : This exception handler should only be used in Release 
    // version of the product. We are disabling it for debugging purposes.

    BrowserThreadProc((IETHREADPARAM*)pv);
#endif

    NT5_DeactivateActCtx(dwCookie);
    
    if (SUCCEEDED(hrInit))
    {
        OleUninitialize();
    }

    return 0;
}


// Check if this IETHREADPARAM/LPITEMIDLIST requires launch in a new process
// and if so launch it and return TRUE.
//
BOOL TryNewProcessIfNeeded(LPCITEMIDLIST pidl)
{
    if (pidl && IsBrowseNewProcessAndExplorer() 
    && IsBrowserFrameOptionsPidlSet(pidl, BFO_PREFER_IEPROCESS))
    {
        TCHAR szURL[MAX_URL_STRING];

        HRESULT hres = ::IEGetDisplayName(pidl, szURL, SHGDN_FORPARSING);
        if (SUCCEEDED(hres))
        {
            hres = IENavigateIEProcess(szURL, FALSE);
            if (SUCCEEDED(hres))
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL TryNewProcessIfNeeded(IETHREADPARAM * piei)
{
    BOOL bRet = TryNewProcessIfNeeded(piei->pidl);
    if (bRet)
    {
        SHDestroyIETHREADPARAM(piei);
    }
    return bRet;
}


// NOTE: this is a ThreadProc (shdocvw creates this as a thread)
//
// this takes ownership of piei and will free it
//
BOOL SHOpenFolderWindow(IETHREADPARAM* piei)
{
    BOOL fSuccess = FALSE;

    _InitAppGlobals();

    CABINETSTATE cs;
    GetCabState(&cs);

    //
    // If "/select" switch is specified, but we haven't splitted
    // the pidl yet (because the path is passed rather than pidl),
    // split it here.
    //
    if ((piei->uFlags & COF_SELECT) && piei->pidlSelect == NULL) 
    {
        LPITEMIDLIST pidlLast = ILFindLastID(piei->pidl);
        // Warning: pidlLast can be NULL if the command line is
        // sufficiently wacky.  E.g.,
        //
        // explorer /select
        //
        if (pidlLast)
        {
            piei->pidlSelect = ILClone(pidlLast);
            pidlLast->mkid.cb = 0;
        }
    }

    if (GetAsyncKeyState(VK_CONTROL) < 0)
        cs.fNewWindowMode = !cs.fNewWindowMode;

    //
    // Check to see if we can reuse the existing window first
    //

    OLECMD  rgCmds[1] = {0};
    rgCmds[0].cmdID = SBCMDID_EXPLORERBAR;
    BOOL bForceSameWindow = (piei->uFlags & COF_EXPLORE) &&
        SUCCEEDED(IUnknown_QueryStatus(piei->psbCaller, &CGID_Explorer, ARRAYSIZE(rgCmds), rgCmds, NULL)) && 
        (rgCmds[0].cmdf & OLECMDF_LATCHED);
    if (bForceSameWindow ||
        piei->psbCaller &&
        !(piei->uFlags & COF_CREATENEWWINDOW) &&
        !cs.fNewWindowMode)
    {
        if (piei->pidl)
        {
            UINT uFlags = SBSP_SAMEBROWSER;
            
            if (piei->uFlags & COF_EXPLORE)
                uFlags |= SBSP_EXPLOREMODE;
            else 
                uFlags |= SBSP_OPENMODE;

            if (SUCCEEDED(piei->psbCaller->BrowseObject(piei->pidl, uFlags)))
                goto ReusedWindow;
        }
    }

    //
    // Don't look for an existing window if we are opening an explorer.
    //
    if (!((piei->uFlags & COF_EXPLORE) || (piei->uFlags & COF_NOFINDWINDOW))) 
    {
        HWND hwnd;
        IWebBrowserApp* pwba;
        HRESULT hres = WinList_FindFolderWindow(piei->pidl, NULL, &hwnd, &pwba);
        if (hres == S_OK)
        {
            ASSERT(pwba); // WinList_FindFolerWindow should not return S_OK if this fails
            SetForegroundWindow(hwnd);

            //  IE30COMPAT - we need to refresh when we hunt and pick up these windows - zekel 31-JUL-97
            //  this will happen if we just do a navigate to ourself.  this is the
            //  same kind of behavior we see when we do a shellexec of an URL.
            //  
            //  we dont use the pwb from FindFolderWindow because it turns out that RPC will
            //  fail the QI for it when we are being called from another process.  this
            //  occurs when IExplore.exe Sends the WM_COPYDATA to the desktop to navigate
            //  a window to an URL that is already there.  so instead of using the pwb
            //  we do a CDDEAuto_Navigate().  which actually goes and uses pwb itself.
            //
            TCHAR szUrl[MAX_URL_STRING];
            if (SUCCEEDED(IEGetNameAndFlags(piei->pidl, SHGDN_FORPARSING, szUrl, SIZECHARS(szUrl), NULL)))
            {
                BSTR bstrUrl = SysAllocString(szUrl);
                if (bstrUrl)
                {
                    pwba->Navigate(bstrUrl, NULL, NULL, NULL, NULL);
                    SysFreeString(bstrUrl);
                }   
            }
            pwba->Release();

            if (IsIconic(hwnd))
                ShowWindow(hwnd, SW_RESTORE);
            if (piei->nCmdShow)
                ShowWindow(hwnd, piei->nCmdShow);
            goto ReusedWindow;
        }
        else if (hres == E_PENDING)
            goto ReusedWindow;        // Assume it will come up sooner or later
    }

    // Okay, we're opening up a new window, let's honor
    // the BrowseNewProcess flag, even though we lose
    // other info (COF_EXPLORE, etc).
    //
    if (TryNewProcessIfNeeded(piei))
        return TRUE;

    if (((piei->uFlags & (COF_INPROC | COF_IEXPLORE)) == (COF_INPROC | COF_IEXPLORE)) &&
        g_tidParking == 0) 
    {
        // we're starting from iexplore.exe 
        g_tidParking = GetCurrentThreadId();
    }
    
    if (piei->pidl && IsURLChild(piei->pidl, TRUE))
        piei->uFlags |= COF_IEXPLORE;

    ASSERT(piei->punkRefProcess == NULL);
    SHGetInstanceExplorer(&piei->punkRefProcess);     // pick up the process ref (if any)

    if (piei->uFlags & COF_INPROC)
    {
        BrowserProtectedThreadProc(piei);
        fSuccess = TRUE;
    } 
    else 
    {
#ifndef NO_MARSHALLING

        DWORD idThread;
        HANDLE hThread = CreateThread(NULL,
#ifdef DEBUG
                                      0, // on debug builds we inherit the default process stack size (so we can identify excessive stack usage)
#else
                                      (1024 * 56), // we pre-allocate a 56k stack for browser windows
#endif
                                      BrowserProtectedThreadProc,
                                      piei,
                                      CREATE_SUSPENDED,
                                      &idThread);
        if (hThread) 
        {
            WinList_RegisterPending(idThread, piei->pidl, NULL, &piei->dwRegister);

            ResumeThread(hThread);
            CloseHandle(hThread);
            fSuccess = TRUE;
        } 
        else 
        {
            SHDestroyIETHREADPARAM(piei);
        }
#else
        IEFrameNewWindowSameThread(piei);
#endif
    }
    return fSuccess;
    
ReusedWindow:
    SHDestroyIETHREADPARAM(piei);
    return TRUE;
}


//
// Notes: pidlNew will be freed
//
STDAPI SHOpenNewFrame(LPITEMIDLIST pidlNew, ITravelLog *ptl, DWORD dwBrowserIndex, UINT uFlags)
{
    HRESULT hres;

    IETHREADPARAM* piei = SHCreateIETHREADPARAM(NULL, SW_SHOWNORMAL, ptl, NULL);
    if (piei) 
    {
        hres = S_OK;

        if (ptl)
            piei->dwBrowserIndex = dwBrowserIndex;

        if (pidlNew)
        {
            piei->pidl = pidlNew;
            pidlNew = NULL;
        }

        piei->uFlags = uFlags;

        if (!TryNewProcessIfNeeded(piei))
        {
#ifndef NO_MARSHALLING
            ASSERT(piei->punkRefProcess == NULL);
            SHGetInstanceExplorer(&piei->punkRefProcess);     // pick up the process ref (if any)

            DWORD idThread;
            HANDLE hThread = CreateThread(NULL,
#ifdef DEBUG
                                          0, // on debug builds we inherit the default process stack size (so we can identify excessive stack usage)
#else
                                          (1024 * 56), // we pre-allocate a 56k stack for browser windows
#endif
                                          BrowserProtectedThreadProc,
                                          piei,
                                          0,
                                          &idThread);
            if (hThread)
            {
                //  this handles removing this from the debug memory list of
                //  the opening thread.
                CloseHandle(hThread);
            } 
            else 
            {
                SHDestroyIETHREADPARAM(piei);
                hres = E_FAIL;
            }
#else
            IEFrameNewWindowSameThread(piei);
#endif
        }
    } 
    else 
        hres = E_OUTOFMEMORY;

    ILFree(pidlNew);

    return hres;
}


HRESULT CShellBrowser2::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, 
                                   OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hres = SUPERCLASS::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext);
    
    if (pguidCmdGroup == NULL) 
    {
        //
        //  If the curretly focused toolbar suppors the IOleCommandTarget
        // ask it the status of clipboard commands.
        // actually we should ask *both* ourselves (the active target)
        // and then the view (the same way our IOCT::Exec does...)
        //
        if (_HasToolbarFocus())
        {
            LPTOOLBARITEM ptbi;
            ptbi = _GetToolbarItem(_get_itbLastFocus());
            if (ptbi && ptbi->ptbar)
            {
                IOleCommandTarget* pcmd;
                HRESULT hresT = ptbi->ptbar->QueryInterface(
                                    IID_IOleCommandTarget, (void**)&pcmd);
                if (SUCCEEDED(hresT)) 
                {
                    for (ULONG i = 0; i < cCmds; i++) 
                    {
                        switch (rgCmds[i].cmdID)
                        {
                        case OLECMDID_CUT:
                        case OLECMDID_COPY:
                        case OLECMDID_PASTE:
                            pcmd->QueryStatus(pguidCmdGroup, 1, &rgCmds[i], pcmdtext);
                            break;
                        }
                    }
                    pcmd->Release();
                }
            }
        }
    }
    else if (IsEqualGUID(CGID_ShellBrowser, *pguidCmdGroup)) 
    {
        if (pcmdtext) {
            ASSERT(cCmds == 1);
            switch (pcmdtext->cmdtextf)
            {
            case OLECMDTEXTF_NAME:
            {
                TOOLTIPTEXTA ttt = { NULL };
                CHAR *pszBuffer = ttt.szText;
                CHAR szTemp[MAX_TOOLTIP_STRING];

                ttt.hdr.code = TTN_NEEDTEXTA;
                ttt.hdr.idFrom = rgCmds[0].cmdID;
                ttt.lpszText = ttt.szText;
                OnNotify((LPNMHDR)&ttt);

                if (ttt.hinst)
                {
                    LoadStringA(ttt.hinst, (UINT) PtrToUlong(ttt.lpszText), szTemp, ARRAYSIZE(szTemp));
                    pszBuffer = szTemp;
                }
                else if (ttt.lpszText)
                    pszBuffer = ttt.lpszText;

                pcmdtext->cwActual = SHAnsiToUnicode(pszBuffer, pcmdtext->rgwz, pcmdtext->cwBuf);
                pcmdtext->cwActual -= 1;
                hres = S_OK;
                break;
            }

            default:    
                hres = E_FAIL;
                break;
            }        
        } else {
            for (ULONG i = 0 ; i < cCmds ; i++) {

                switch(rgCmds[i].cmdID) {
                case FCIDM_PREVIOUSFOLDER:
                    if (_ShouldAllowNavigateParent())
                        rgCmds[i].cmdf |= OLECMDF_ENABLED;
                    else
                        rgCmds[i].cmdf &= OLECMDF_ENABLED;

                    hres = S_OK;
                    break;
                }
            }
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        // should fill pcmdtext as well

        for (ULONG i = 0 ; i < cCmds ; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case SBCMDID_SHOWCONTROL:
            case SBCMDID_DOFAVORITESMENU:
            case SBCMDID_ACTIVEOBJECTMENUS:            
            case SBCMDID_SETMERGEDWEBMENU:
                rgCmds[i].cmdf = OLECMDF_ENABLED;   // support these unconditionally
                break;

            case SBCMDID_DOMAILMENU:
                rgCmds[i].cmdf = SHIsRegisteredClient(NEWS_DEF_KEY) || SHIsRegisteredClient(MAIL_DEF_KEY) ? OLECMDF_ENABLED : 0;
                //If go menu is restricted, disable mail menu on toolbar also
                if (SHRestricted2(REST_GoMenu, NULL, 0))
                    rgCmds[i].cmdf = 0;
                break;

            case SBCMDID_SEARCHBAR:
            case SBCMDID_FAVORITESBAR:
            case SBCMDID_HISTORYBAR:
            case SBCMDID_EXPLORERBAR:
            case SBCMDID_DISCUSSIONBAND:
            case SBCMDID_MEDIABAR:
                {
                UINT idm;

                rgCmds[i].cmdf |= OLECMDF_SUPPORTED|OLECMDF_ENABLED;
                
                switch (rgCmds[i].cmdID) {
                case SBCMDID_DISCUSSIONBAND: 
                    {
                        // Perf: Avoid calling _InfoCLSIDToIdm unless we have loaded
                        // the band info already because it is very expensive!
                        if (_pbsmInfo && FCIDM_VBBNOHORIZONTALBAR != _idmComm)
                        {
                            idm = _InfoCLSIDToIdm(&CLSID_DiscussionBand);
                            if (idm == -1)
                            {
                                // The discussion band is not registered
                                ClearFlag(rgCmds[i].cmdf, OLECMDF_SUPPORTED|OLECMDF_ENABLED);
                            }
                            else if (idm == _idmComm)
                            {
                                rgCmds[i].cmdf |= OLECMDF_LATCHED;
                            }
                        }
                        else
                        {
                            //
                            // Since the band info has not been loaded or idmComm is FCIDM_VBBNONE,
                            // we know that the discussion band is not up and is not latched.  So
                            // we can check the registry instead and avoid defer the cost of
                            // initializing _pbsmInfo
                            //
                            // See if the discussions band is registered for the CATID_CommBand
                            idm = -1;
                            HKEY hkey = NULL;
                            static BOOL fDiscussionBand = -1;

                            // We get called a lot, so only read the registry once.
                            if (-1 == fDiscussionBand)
                            {
                                if (RegOpenKeyEx(HKEY_CLASSES_ROOT, c_szDiscussionBandReg, NULL, KEY_READ, &hkey) == ERROR_SUCCESS)
                                {
                                    // We found the discussions band
                                    fDiscussionBand = 1;
                                    RegCloseKey(hkey);
                                }
                                else
                                {
                                    fDiscussionBand = 0;
                                }
                            }

                            if (!fDiscussionBand)
                            {
                                // The discussions band is not registered
                                ClearFlag(rgCmds[i].cmdf, OLECMDF_SUPPORTED|OLECMDF_ENABLED);
                            }
                        }
                        break;
                    }
                case SBCMDID_SEARCHBAR:      idm=FCIDM_VBBSEARCHBAND     ; break;
                case SBCMDID_FAVORITESBAR:  
                    idm=FCIDM_VBBFAVORITESBAND;
                    if (SHRestricted2(REST_NoFavorites, NULL, 0))
                        ClearFlag(rgCmds[i].cmdf, OLECMDF_ENABLED);
                    break;
                case SBCMDID_HISTORYBAR:     idm=FCIDM_VBBHISTORYBAND    ; break;
                case SBCMDID_EXPLORERBAR:    idm=FCIDM_VBBEXPLORERBAND   ; break;
                case SBCMDID_MEDIABAR:       idm=FCIDM_VBBMEDIABAND      ; break;

                default:
                    ASSERT(FALSE);
                    return E_FAIL;
                }

                if (idm == _idmInfo)
                    rgCmds[i].cmdf |= OLECMDF_LATCHED;

                break;
                }
            }
        }
        hres = S_OK;
    }
        
    return hres;
}

// REARCHITECT (980710 adp) should clean up to do consistent routing.  this
// ad-hoc per-nCmdID stuff is too error-prone.
HRESULT CShellBrowser2::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, 
                             VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        switch (nCmdID) 
        {
        case OLECMDID_SETTITLE:
            // NT #282632: This bug is caused when the current IShellView is a web page and
            //    the pending view is a shell folder w/Web View that has certain timing charataristics.
            //    MSHTML from the Web View will fire OLECMDID_SETTITLE with the URL of the
            //    web view template.  The problem is that there is a bug in IE4 SI's shell32
            //    that let that message go to the browser (here), even though the view wasn't
            //    active.  Since we don't know who it came from, we forward it down to the current
            //    view who squirls away the title.  This title is then given in the Back toolbar
            //    button drop down history.  This is hack around the IE4 SI shell32 bug is to kill
            //    that message. -BryanSt
            TraceMsg(DM_TRACE, "csb.e: SetTitle is called");
            break;  // continue.

        // Clipboard commands and common operations will be dispatched 
        // to the currently focused toolbar.
        case OLECMDID_CUT:
        case OLECMDID_COPY:
        case OLECMDID_PASTE:
        case OLECMDID_DELETE:
        case OLECMDID_PROPERTIES:
            if (_HasToolbarFocus()) {
                LPTOOLBARITEM ptbi;
                if (ptbi = _GetToolbarItem(_get_itbLastFocus()))
                {
                    HRESULT hres = IUnknown_Exec(ptbi->ptbar, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                    if (SUCCEEDED(hres))
                        return hres;
                }
            }
            break;  // give the view a chance
        }
    }
    else if (IsEqualGUID(CGID_DefView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
            case DVID_RESETDEFAULT:

//  99/02/09 #226140 vtan: Exec command issued from
//  CFolderOptionsPsx::ResetDefFolderSettings()
//  when user clicks "Reset All Folders" in folder
//  options "View" tab. Pass this thru to DefView.

                ASSERTMSG(nCmdexecopt == OLECMDEXECOPT_DODEFAULT, "nCmdexecopt must be OLECMDEXECOPT_DODEFAULT");
                ASSERTMSG(pvarargIn == NULL, "pvarargIn must be NULL");
                ASSERTMSG(pvarargOut == NULL, "pvarargOut must be NULL");
                IUnknown_Exec(_pbbd->_psv, &CGID_DefView, DVID_RESETDEFAULT, OLECMDEXECOPT_DODEFAULT, NULL, NULL);
                return(S_OK);
                break;
            default:
                break;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case SBCMDID_MAYSAVEVIEWSTATE:
            return _fDontSaveViewOptions ? S_FALSE : S_OK;  // May need to save out earlier...
            
        case SBCMDID_CANCELANDCLOSE:
            _CancelPendingNavigationAsync();
            PostMessage(_pbbd->_hwnd, WM_CLOSE, 0, 0);

            return S_OK;

        case SBCMDID_CANCELNAVIGATION:
            //
            // Special code to close the window if the very first navigation caused
            // an asynchronous download (e.g. from athena).
            //
            if (!_pbbd->_pidlCur && pvarargIn && pvarargIn->vt == VT_I4 && pvarargIn->lVal == FALSE) 
            {
                _CancelPendingNavigationAsync();
                PostMessage(_pbbd->_hwnd, WM_CLOSE, 0, 0);

                return S_OK;
            }

            break; // fall through

        case SBCMDID_MIXEDZONE:
            _UpdateZonesPane(pvarargIn);
            break;

        case SBCMDID_ISIEMODEBROWSER:
            return v_IsIEModeBrowser() ? S_OK : S_FALSE;

        case SBCMDID_STARTEDFORINTERNET:
            return _fInternetStart ? S_OK : S_FALSE;

        case SBCMDID_ISBROWSERACTIVE:
            return _fActivated ? S_OK : S_FALSE;

        case SBCMDID_SUGGESTSAVEWINPOS:
            if (_ShouldSaveWindowPlacement())
            {
                StorePlacementOfWindow(_pbbd->_hwnd);
                return S_OK;
            }
            return S_FALSE;

        case SBCMDID_ONVIEWMOVETOTOP:
            if (_ptheater)
            {
                return _ptheater->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
            }
            return S_FALSE;
        }    
    } 
    else if (IsEqualGUID(CGID_MenuBandHandler, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBHANDCID_PIDLSELECT:
            {
                LPITEMIDLIST pidl = VariantToIDList(pvarargIn);
                if (pidl)
                {
                    if (!ILIsEmpty(pidl))
                    {
                        if (_pidlMenuSelect)
                            KillTimer(_pbbd->_hwnd, SHBTIMER_MENUSELECT);
                    
                        // Opening the favorites' shortcuts can be slow.  So set a
                        // timer so we don't open needlessly as the mouse runs over
                        // the menu quickly.
                        if (Pidl_Set(&_pidlMenuSelect, pidl))
                        {
                            if (!SetTimer(_pbbd->_hwnd, SHBTIMER_MENUSELECT, MENUSELECT_TIME, NULL))
                                Pidl_Set(&_pidlMenuSelect, NULL);
                        }
                    }
                    ILFree(pidl);
                }
            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_MenuBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBANDCID_EXITMENU:
            // we're done with the menu band (favorites)
            // kill the timer
            // this is to fix bug #61917 where the status bar would get stack
            // in the simple mode (actually the timer would go off after we 
            // navigated to the page with the proper status bar mode, but then
            // we would call _DisplayFavoriteStatus that would put it back in
            // the simple mode)
            if (_pidlMenuSelect)
                KillTimer(_pbbd->_hwnd, SHBTIMER_MENUSELECT);
            
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_FilterObject, *pguidCmdGroup))
    {
        HRESULT hres = E_INVALIDARG;

        switch (nCmdID)
        {
        case PHID_FilterOutPidl:
            {
                LPITEMIDLIST pidl = VariantToIDList(pvarargIn);
                if (pidl)
                {
                    // We are filtering out everything except folders, shortcuts, and 
                    // internet shortcuts
                    DWORD dwAttribs = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_LINK;

                    // include everthing by default
                    VariantClearLazy(pvarargOut); 
                    pvarargOut->vt = VT_BOOL;
                    pvarargOut->boolVal = VARIANT_FALSE;    

                    IEGetAttributesOf(pidl, &dwAttribs);

                    // include all non file system objects, folders and links
                    // (non file system things like the Channel folders contents)
                    if (!(dwAttribs & (SFGAO_FOLDER | SFGAO_LINK)) &&
                         (dwAttribs & SFGAO_FILESYSTEM))
                        pvarargOut->boolVal = VARIANT_TRUE; // don't include

                    hres = S_OK;
                    ILFree(pidl);
                }
            }
            break;

        default:
            TraceMsg(TF_WARNING, "csb.e: Received unknown CGID_FilterObject cmdid (%d)", nCmdID);
            break;
        }

        return hres;
    } 
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        // we reflect AMBIENTPROPCHANGE down because this is how iedisp notifies dochost
        // that an ambient property has changed. we don't need to reflect this down in
        // cwebbrowsersb because only the top-level iwebbrowser2 is allowed to change props
        case SHDVID_AMBIENTPROPCHANGE:
        case SHDVID_PRINTFRAME:
        case SHDVID_MIMECSETMENUOPEN:
        case SHDVID_FONTMENUOPEN:
            if (pvarargIn)
            {
                if ((VT_I4 == pvarargIn->vt) && (DISPID_AMBIENT_OFFLINEIFNOTCONNECTED == pvarargIn->lVal))
                {
                    VARIANT_BOOL fIsOffline;
                    if (_pbbd->_pautoWB2)
                    {
                        _pbbd->_pautoWB2->get_Offline(&fIsOffline);
                        if (fIsOffline)
                        {
                            // this top level frame just went Offline 
                            //  - so decr net session count
                            _DecrNetSessionCount();
                        }
                        else
                        {
                            // this top level frame went online. 
                            _IncrNetSessionCount();
                        }     
                    }
                }
            }
            break;
        }
    }

    HRESULT hres = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    if (pguidCmdGroup == NULL)
    {
DefaultCommandGroup:

        switch (nCmdID) 
        {
        case OLECMDID_REFRESH:
            // FolderOptions.Advanced refreshes all browser windows
            _UpdateRegFlags();
            _SetTitle(NULL); // maybe "full path in title bar" changed

            v_ShowHideChildWindows(FALSE);
            
            // pass this to the browserbar
            IDeskBar* pdb;
            FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pdb));
            if (pdb) 
            {
                IUnknown_Exec(pdb, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                pdb->Release();
            }            
            hres = S_OK;
            break;
        }
    }
    else if (IsEqualGUID(CGID_ShellBrowser, *pguidCmdGroup))
    {
        // toolbar buttons we put there ourselves

        hres = S_OK;    // assume accepted

        switch (nCmdID)
        {
        case FCIDM_PREVIOUSFOLDER:
            v_ParentFolder();
            break;

        case FCIDM_CONNECT:
            DoNetConnect(_pbbd->_hwnd);
            break;
    
        case FCIDM_DISCONNECT:
            DoNetDisconnect(_pbbd->_hwnd);
            break;

        case FCIDM_GETSTATUSBAR:
            if (pvarargOut->vt == VT_I4)
                pvarargOut->lVal = _fStatusBar;
            break;

        case FCIDM_SETSTATUSBAR:
            if (pvarargIn->vt == VT_I4) 
            {
                _fStatusBar = pvarargIn->lVal;
                v_ShowHideChildWindows(FALSE);
            }
            break;

        case FCIDM_PERSISTTOOLBAR:
            _SaveITbarLayout();
            break;

        default:
            // pass off the nCmdID to the view for processing / translation.
            DFVCMDDATA cd;

            cd.pva = pvarargIn;
            cd.hwnd = _pbbd->_hwnd;
            cd.nCmdIDTranslated = 0;
            SendMessage(_pbbd->_hwndView, WM_COMMAND, nCmdID, (LONG_PTR)&cd);

            if (cd.nCmdIDTranslated)
            {
                // We sent the private nCmdID to the view.  The view did not
                // process it (probably because it didn't have the focus),
                // but instead translated it into a standard OLECMDID for
                // further processing by the toolbar with the focus.

                pguidCmdGroup = NULL;
                nCmdID = cd.nCmdIDTranslated;
                hres = OLECMDERR_E_NOTSUPPORTED;
                goto DefaultCommandGroup;
            }
            break;
        }
    }
    else if (IsEqualGUID(IID_IExplorerToolbar, *pguidCmdGroup))
    {
        // these are commands to intercept
        if (_HasToolbarFocus() && _get_itbLastFocus() != ITB_ITBAR)
        {
            int idCmd = -1;

            // certain shell commands we should pick off
            switch (nCmdID)
            {
            case OLECMDID_DELETE:
            case SFVIDM_FILE_DELETE:
                idCmd = FCIDM_DELETE;
                break;

            case OLECMDID_PROPERTIES:
            case SFVIDM_FILE_PROPERTIES:
                idCmd = FCIDM_PROPERTIES;
                break;

            case OLECMDID_CUT:
            case SFVIDM_EDIT_CUT:
                idCmd = FCIDM_MOVE;
                break;

            case OLECMDID_COPY:
            case SFVIDM_EDIT_COPY:
                idCmd = FCIDM_COPY;
                break;

            case OLECMDID_PASTE:
            case SFVIDM_EDIT_PASTE:
                idCmd = FCIDM_PASTE;
                break;
            }

            if (idCmd != -1)
            {
                OnCommand(GET_WM_COMMAND_MPS(idCmd, 0, NULL));
                return S_OK;
            }
        }
    } 
    else if (IsEqualGUID(CGID_PrivCITCommands, *pguidCmdGroup)) 
    {
        return IUnknown_Exec(_GetITBar(), pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        hres = S_OK;        // assume we will get it

        switch(nCmdID) 
        {
        case SBCMDID_SETMERGEDWEBMENU:
            if (!_hmenuPreMerged)
                _hmenuPreMerged = _MenuTemplate(MENU_PREMERGED, FALSE);

            if (SHRestricted2W(REST_NoHelpMenu, NULL, 0))
            {
                DeleteMenu(_hmenuPreMerged, FCIDM_MENU_HELP, MF_BYCOMMAND);
            }

            SetMenuSB(_hmenuPreMerged, NULL, NULL);
            if (pvarargOut) {
                pvarargOut->vt = VT_INT_PTR;
                pvarargOut->byref = _hmenuPreMerged;
            }
            break;

        case SBCMDID_ACTIVEOBJECTMENUS:
            _fDispatchMenuMsgs = TRUE;
            break;

        case SBCMDID_SENDPAGE:
        case SBCMDID_SENDSHORTCUT:
            _SendCurrentPage(nCmdID == SBCMDID_SENDPAGE ? FORCE_COPY : FORCE_LINK);
            break;

        case SBCMDID_SEARCHBAR:
        case SBCMDID_FAVORITESBAR:
        case SBCMDID_HISTORYBAR:
        case SBCMDID_EXPLORERBAR:
        case SBCMDID_DISCUSSIONBAND:
        case SBCMDID_MEDIABAR:
            {
            UINT idm;

            switch (nCmdID) 
            {
            case SBCMDID_SEARCHBAR:      idm = FCIDM_VBBSEARCHBAND      ; break;
            case SBCMDID_FAVORITESBAR:   idm = FCIDM_VBBFAVORITESBAND   ; break;
            case SBCMDID_HISTORYBAR:     idm = FCIDM_VBBHISTORYBAND     ; break;
            case SBCMDID_EXPLORERBAR:    idm = FCIDM_VBBEXPLORERBAND    ; break;
            case SBCMDID_MEDIABAR:       idm = FCIDM_VBBMEDIABAND       ; break;

            // The discussion band maps to one of the dynamic bands
            case SBCMDID_DISCUSSIONBAND: idm = _InfoCLSIDToIdm(&CLSID_DiscussionBand)  ; break;
            default:                     idm = -1; break;
            }

            if (idm != -1)
            {
                // default is toggle (-1)
                int i = (pvarargIn && EVAL(pvarargIn->vt == VT_I4)) ? pvarargIn->lVal : -1;
                LPITEMIDLIST pidl = VariantToIDList(pvarargOut);    // accepts null variant input
                _SetBrowserBarState(idm, NULL, i, pidl);
                ILFree(pidl);   // accepts NULL
            }

            hres = S_OK;

            break;
            }

        case SBCMDID_SHOWCONTROL:
        {
            DWORD dwRet;
            int iControl, iCmd;
            
            if (nCmdexecopt == OLECMDEXECOPT_DODEFAULT &&
                pvarargIn &&
                pvarargIn->vt == VT_I4) 
            {
                iControl = (int)(short)LOWORD(pvarargIn->lVal);
                iCmd = (int)(short)HIWORD(pvarargIn->lVal);
            } 
            else 
            {
                iControl = (int)(short)LOWORD(nCmdexecopt);
                iCmd = (HIWORD(nCmdexecopt) ? SBSC_SHOW : SBSC_HIDE);
            }                

            dwRet = v_ShowControl(iControl, iCmd);
            if (dwRet == (DWORD)-1)
                break;

            if (pvarargOut) 
            {
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = dwRet;
            }
            break;
        }

        case SBCMDID_DOFAVORITESMENU:
        case SBCMDID_DOMAILMENU:
            {
                HMENU hmenu = NULL;

                if (nCmdID == SBCMDID_DOFAVORITESMENU)
                {
                    HMENU hmenuWnd = NULL;
                   
                    IShellMenu* psm;
                    if (SUCCEEDED(_pmb->QueryInterface(IID_PPV_ARG(IShellMenu, &psm))))
                    {
                        psm->GetMenu(&hmenuWnd, NULL, NULL);
                        psm->Release();
                    }
                    
                    if (hmenuWnd)
                    {
                        hmenu = SHGetMenuFromID(hmenuWnd, FCIDM_MENU_FAVORITES);
                    }
                }
                else
                    hmenu = LoadMenuPopup(MENU_MAILNEWS);

                if (hmenu)
                {
                    if (pvarargIn && pvarargIn->vt == VT_I4) 
                    {
                        TrackPopupMenu(hmenu, 0, 
                            GET_X_LPARAM(pvarargIn->lVal), GET_Y_LPARAM(pvarargIn->lVal), 
                            0, _GetCaptionWindow(), NULL);
                    }
                    if (nCmdID == SBCMDID_DOMAILMENU)
                        DestroyMenu(hmenu);
                }
            }
            break;

        case SBCMDID_SELECTHISTPIDL:
            {
                //  remember most recent hist pidl.  if we have history band visible, tell it
                //  the hist pidl.  if the band is not visible, it is it's responsibility to
                //  query the most recent hist pidl via SBCMDID_GETHISTPIDL
                //  the semantics of the call from UrlStorage is that if we respond S_OK to
                //  to this command, we take ownership of pidl and must ILFree it.
                //  when we call the band, on the other hand, they must ILClone it if they want
                //  to use it outside of the Exec call.
                if (_pidlLastHist) 
                {
                    ILFree(_pidlLastHist);
                    _pidlLastHist = NULL;
                }
                _pidlLastHist = VariantToIDList(pvarargIn); // take ownership

                if (_poctNsc)
                {
                    _poctNsc->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                }
            }
            break;

        case SBCMDID_GETHISTPIDL:
            if (pvarargOut) {
                VariantClearLazy(pvarargOut);
                if (_pidlLastHist)
                {
                    InitVariantFromIDList(pvarargOut, _pidlLastHist);
                }
            }
            break;

        case SBCMDID_UNREGISTERNSCBAND:
            if (pvarargIn && pvarargIn->vt == VT_UNKNOWN && pvarargIn->punkVal)
            {
                if (_poctNsc && SHIsSameObject(_poctNsc, pvarargIn->punkVal))
                {
                    ATOMICRELEASE(_poctNsc);
                    IUnknown_SetSite(_pcmNsc, NULL);
                    ATOMICRELEASE(_pcmNsc);
                }
            }
            break;

        case SBCMDID_REGISTERNSCBAND:
            ATOMICRELEASE(_poctNsc);
            IUnknown_SetSite(_pcmNsc, NULL);
            ATOMICRELEASE(_pcmNsc);
            if (pvarargIn && pvarargIn->vt == VT_UNKNOWN && pvarargIn->punkVal)
            {
                pvarargIn->punkVal->QueryInterface(IID_PPV_ARG(IOleCommandTarget, &_poctNsc));
            }
            break;
                    
        case SBCMDID_TOOLBAREMPTY:
            if (pvarargIn && VT_UNKNOWN == pvarargIn->vt && pvarargIn->punkVal) 
            {
                if (_IsSameToolbar(INFOBAR_TBNAME, pvarargIn->punkVal))
                    _SetBrowserBarState(_idmInfo, NULL, 0);
                else if (_IsSameToolbar(COMMBAR_TBNAME, pvarargIn->punkVal))
                    _SetBrowserBarState(_idmComm, NULL, 0);
                else
                    _HideToolbar(pvarargIn->punkVal);
            }
            break;

        case SBCMDID_GETTEMPLATEMENU:
            if (pvarargOut) 
            {
                pvarargOut->vt = VT_INT_PTR;
                pvarargOut->byref = (LPVOID)_hmenuTemplate;
            }
            break;

        case SBCMDID_GETCURRENTMENU:
            if (pvarargOut) 
            {
                pvarargOut->vt = VT_INT_PTR;
                pvarargOut->byref = (LPVOID)_hmenuCur;
            }
            break;

        default:
            //
            // Note that we should return hres from the super class as-is.
            //
            // hres = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    } 
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        case SHDVID_GETSYSIMAGEINDEX:
            pvarargOut->vt = VT_I4;
            pvarargOut->lVal = _GetIconIndex();
            hres = (pvarargOut->lVal==-1) ? E_FAIL : S_OK;
            break;
            
        case SHDVID_HELP:
            if(!SHIsRestricted2W(_pbbd->_hwnd, REST_NoHelpMenu, NULL, 0))
            {
                SHHtmlHelpOnDemandWrap(_pbbd->_hwnd, TEXT("iexplore.chm > iedefault"), HH_DISPLAY_TOPIC, 0, ML_CROSSCODEPAGE);
                hres = S_OK;
            }
            break;
            
        case SHDVID_GETBROWSERBAR:
        {
            const CLSID *pclsid = _InfoIdmToCLSID(_idmInfo);
            // kinda strange to (ab-)use checked menu items as
            // state marker to persist the CLSID between Exec calls (applies also to SHDVID_NAVIGATEBBTOURL below)!!
            // but that's how both SHDVID_GETBROWSERBAR and SHDVID_NAVIGATEBBTOURL are called
            //
            // assume that the currently checked menu points to the explorer bar
            // this navigate to URL is aimed to.
            // Currently Trident's NavigateInBand is the only caller
            // using this command; it calls SHDVID_GETBROWSERBAR first and thus set the _idmInfo

            IBandSite *pbs;
            hres = E_FAIL;

            VariantInit(pvarargOut);

            _GetBrowserBar(IDBAR_VERTICAL, TRUE, &pbs, pclsid);
            if (pbs) 
            {
                IDeskBand *pband = _GetInfoBandBS(pbs, *pclsid);
                if (pband) 
                {
                    pvarargOut->vt = VT_UNKNOWN;
                    pvarargOut->punkVal = pband;
                    hres = S_OK;
                }
                pbs->Release();
            }
            break;
        }
        
        case SHDVID_SHOWBROWSERBAR:
            {
                CLSID *pclsid;
                CLSID guid;
                if (pvarargIn->vt == VT_BSTR) 
                {
                    if (SUCCEEDED(IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_VIEWEXTERNALBAND_BYCLASSID, nCmdexecopt, pvarargIn, NULL))) 
                    {
                        hres = S_OK;
                        break;
                    }

                    // external (can marshal)
                    if (!GUIDFromString(pvarargIn->bstrVal, &guid))
                        return S_OK; // Invalid CLSID; IE5 returned S_OK so I guess it's ok

                    pclsid = &guid;
                }
                else if (pvarargIn->vt == VT_INT_PTR) 
                {
                    // internal (can't marshal)
                    ASSERT(0);  // dead code?  let's make sure...
                    TraceMsg(TF_WARNING, "csb.e: SHDVID_SHOWBROWSERBAR clsid !marshall (!)");
                    pclsid = (CLSID *) (pvarargIn->byref);
                }
                else 
                {
                    ASSERT(0);
                    pclsid = NULL;
                    break;
                }

                // enforce mediabar restriction: even though menu and toolbar have MediaBar disabled, resp. removed
                // user can still launch thru targeting _media or when mediabar was last open explorer bar before restriction is set
                if (    IsEqualIID(*pclsid, CLSID_MediaBand)
                    && SHRestricted2(REST_No_LaunchMediaBar, NULL, 0) )
                {
                    hres = E_ACCESSDENIED;
                    pclsid = NULL;
                    break;
                }
                _SetBrowserBarState(-1, pclsid, nCmdexecopt ? 1 : 0);
                hres = S_OK;
                break;
            }

        case SHDVID_ISBROWSERBARVISIBLE:
            // Quickly return false if both bars are hidden
            hres = S_FALSE;
            if (_idmComm != FCIDM_VBBNOHORIZONTALBAR || _idmInfo != FCIDM_VBBNOVERTICALBAR)
            {
                if (pvarargIn->vt == VT_BSTR)
                {
                    // Get the associated id
                    CLSID clsid;
                    if (GUIDFromString(pvarargIn->bstrVal, &clsid))
                    {
                        UINT idm = _InfoCLSIDToIdm(&clsid);
                        if (_idmComm == idm || _idmInfo == idm)
                        {
                            // It's visible!
                            hres = S_OK; 
                        }
                    }
                }
            }
            return hres;

        case SHDVID_ISEXPLORERBARVISIBLE:
            hres = (_idmInfo != FCIDM_VBBNOVERTICALBAR) ? S_OK : S_FALSE;
            return hres;

        case SHDVID_NAVIGATEBB:
        {
            LPITEMIDLIST pidl = VariantToIDList(pvarargIn);
            if (pidl)
            {
                if (!ILIsEmpty(pidl))
                {
                    IBandSite   * pbs;
                    const CLSID * pclsid = _InfoIdmToCLSID(_idmInfo);

                    _GetBrowserBar(IDBAR_VERTICAL, TRUE, &pbs, pclsid);
                    if (pbs) 
                    {
                        IDeskBand *pband = _GetInfoBandBS(pbs, *pclsid);
                        if (pband) 
                        {
                            IBandNavigate *pbn;
                            pband->QueryInterface(IID_PPV_ARG(IBandNavigate, &pbn));
                            if (pbn) 
                            {
                                pbn->Select(pidl);
                                pbn->Release();
                            }
                            pband->Release();
                        }
                        pbs->Release();
                    }
                    hres = S_OK;
                }
                ILFree(pidl);
            }
            break;
        }

        case SHDVID_NAVIGATEBBTOURL:
        {
            const CLSID *pclsid = _InfoIdmToCLSID(_idmInfo);
            if (    IsEqualIID(*pclsid, CLSID_MediaBand)
                &&  SHRegGetBoolUSValue(REG_MEDIA_STR, TEXT("SuppressOnlineContent"), FALSE, FALSE))
            {
                hres = E_FAIL;
                break;
            }
            LPITEMIDLIST pidl;
            hres = IEParseDisplayNameWithBCW(CP_ACP, V_BSTR(pvarargIn), NULL, &pidl);
            
            if (!hres && pidl && !ILIsEmpty(pidl))
            {
                // see comments in SHDVID_GETBROWSERBAR above!
                //
                // assume that the currently checked menu points to the explorer bar
                // this navigate to URL is aimed to.
                // Currently Trident's NavigateInBand is the only caller
                // using this command; it calls SHDVID_GETBROWSERBAR first and thus set the _idmInfo

                IBandSite *pbs;
                _GetBrowserBar(IDBAR_VERTICAL, TRUE, &pbs, pclsid);
            
                if (pbs) 
                {
                    IDeskBand *pband = _GetInfoBandBS(pbs, *pclsid);
                    if (pband) 
                    {
                        // 
                        // See if we can use ISearchBandTBHelper which has a "truer" navigate
                        // method.
                        //
                        ISearchBandTBHelper * pSearchBandTBHelper = NULL;

                        pband->QueryInterface(IID_ISearchBandTBHelper, (void**)&pSearchBandTBHelper);
                        if (pSearchBandTBHelper)
                        {
                            pSearchBandTBHelper->NavigateToPidl(pidl);
                            pSearchBandTBHelper->Release();
                        }
                        else
                        {
                            //
                            // Probably a different band.  See if it implements 
                            // IBandNavigate
                            //
                            IBandNavigate * pbn = NULL;
                    
                            pband->QueryInterface(IID_PPV_ARG(IBandNavigate, &pbn));
                            if (pbn) 
                            {
                                pbn->Select(pidl);
                                pbn->Release();
                            }
                            pband->Release();
                        }
                    }
                    pbs->Release();
                }
                
                ILFree(pidl);
            }
            break;
        }

        case SHDVID_CLSIDTOIDM:
            ASSERT(pvarargIn && pvarargIn->vt == VT_BSTR && pvarargOut);
            CLSID clsid;

            GUIDFromString(pvarargIn->bstrVal, &clsid);

            pvarargOut->vt = VT_I4;
            pvarargOut->lVal = _InfoCLSIDToIdm(&clsid);
            
            hres = S_OK;
            break;
        }
    } 
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup)) 
    {
        if (_ptheater)
            hres = _ptheater->Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_ExplorerBarDoc, *pguidCmdGroup)) 
    {
        //  These are commands that should be applied to all the explorer bar bands.  for example
        //  to reflect font size changes to the search band. they should be applied to the
        //  contained doc object, changing guid to CGID_MSTHML
        _ExecAllBands(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }
    else if (IsEqualGUID(CGID_DocHostCmdPriv, *pguidCmdGroup))
    {
        switch(nCmdID) 
        {
        // This command is sent by Trident when 
        // navigating in a shell view.
        //
        case DOCHOST_DOCHYPERLINK:  // Sent by Trident when in a shell view.
            hres = E_FAIL;
            
            if (VT_BSTR == V_VT(pvarargIn))
            {
                LPITEMIDLIST pidl = NULL;
            
                hres = IEParseDisplayNameWithBCW(CP_ACP, V_BSTR(pvarargIn), NULL, &pidl);

                if (pidl)
                {
                    hres = BrowseObject(pidl, SBSP_SAMEBROWSER);
                    ILFree(pidl);
                }
            }

            break;

       
        default:
            break;
        }
    }

    return hres;
}


//***   _IsSameToolbar -- does punkBar have specified name?
// ENTRY/EXIT
//  fRet    TRUE if matches, o.w. FALSE
//
BOOL CShellBrowser2::_IsSameToolbar(LPWSTR wszBarName, IUnknown *punkBar)
{
    BOOL fRet = FALSE;
    IUnknown *punk;
    HRESULT hres = FindToolbar(wszBarName, IID_PPV_ARG(IUnknown, &punk));
    ASSERT((hres == S_OK) == (punk != NULL));
    if (punk) 
    {
        if (SHIsSameObject(punkBar, punk)) 
        {
            fRet = TRUE;
        }
        punk->Release();
    }
    return fRet;
}

STDAPI SHGetWindowTitle(LPCITEMIDLIST pidl, LPTSTR pszFullName, DWORD cchSize)
{
    CABINETSTATE cs;
    GetCabState(&cs);

    return SHTitleFromPidl(pidl, pszFullName, cchSize, cs.fFullPathTitle);
}

// pwszName - The Name of the URL, not
//            limited in size, but the result will
//            be truncated if the imput is too long.
//
// The title will be generated by taking the
// title of the HTML page (pszName) and appending
// the name of the browser to the end in the
// following format:
//    "HTML_TITLE - BROWSER_NAME", like:
//    "My Web Page - Microsoft Internet Explorer"

void CShellBrowser2::_SetTitle(LPCWSTR pwszName)
{
    TCHAR szTitle[MAX_BROWSER_WINDOW_TITLE];
    TCHAR szFullName[MAX_PATH];
    BOOL fNotDisplayable = FALSE;

    if (!pwszName && _fTitleSet) 
    {
        // if the content has once set our title,
        // don't revert to our own mocked up name
        return;
    }
    else if (pwszName)
    {
        _fTitleSet = TRUE;
    }

    BOOL fDisplayable = SHIsDisplayable(pwszName, g_fRunOnFE, g_bRunOnNT5);

    if (pwszName && fDisplayable) 
    {
        StringCchCopy(szFullName, ARRAYSIZE(szFullName), pwszName); // truncation ok
        SHCleanupUrlForDisplay(szFullName);
    }
    else if (_pbbd->_pidlCur)
    {
        SHGetWindowTitle(_pbbd->_pidlCur, szFullName, ARRAYSIZE(szFullName));
    }
    else if (_pbbd->_pidlPending)
    {
        SHGetWindowTitle(_pbbd->_pidlPending, szFullName, ARRAYSIZE(szFullName));
    }
    else
        szFullName[0] = 0;

    // Before adding on the app title truncate the szFullName so that if it is 
    // really long then when the app title " - Microsoft Internet Explorer" is
    // appended it fits.
    //
    // Used to be 100, but that wasn't quite enough to display default title.
    //
    ASSERT(96 <= ARRAYSIZE(szFullName));
    SHTruncateString(szFullName, 96); // any more than 60 is useless anyways

    if (szFullName[0]) 
    {
        TCHAR szBuf[MAX_URL_STRING];

        v_GetAppTitleTemplate(szBuf, ARRAYSIZE(szBuf), szFullName);

        // truncation ok since this is for display only
        StringCchPrintf(szTitle, ARRAYSIZE(szTitle), szBuf, szFullName); 
    }
    else if (_fInternetStart)
    {
        _GetAppTitle(szTitle, ARRAYSIZE(szTitle));
    } 
    else
        szTitle[0] = 0;

    SendMessage(_pbbd->_hwnd, WM_SETTEXT, 0, (LPARAM)szTitle);
}

void _SetWindowIcon (HWND hwnd, HICON hIcon, BOOL bLarge)

{
    HICON   hOldIcon;
    //
    // If the shell window is RTL mirrored, then flip the icon now,
    // before inserting them into the system cache, so that they end up
    // normal (not mirrrored) on the shell. This is mainly a concern for
    // 3rd party components. [samera]
    //
    if (IS_PROCESS_RTL_MIRRORED())
    {        
        SHMirrorIcon(&hIcon, NULL);
    }

    hOldIcon = (HICON)SendMessage(hwnd, WM_SETICON, bLarge, (LPARAM)hIcon);
    if (hOldIcon &&
        (hOldIcon != hIcon))
    {
        DestroyIcon(hOldIcon);
    }
}

void _WindowIconFromImagelist(HWND hwndMain, int nIndex, BOOL bLarge)
{
    HIMAGELIST himlSysLarge = NULL;
    HIMAGELIST himlSysSmall = NULL;

    Shell_GetImageLists(&himlSysLarge, &himlSysSmall);

    // if we're using the def open icon or if extracting fails,
    // use the icon we've already created.
    HICON hIcon = ImageList_ExtractIcon(g_hinst, bLarge ? himlSysLarge : himlSysSmall, nIndex);
    if (hIcon)
        _SetWindowIcon(hwndMain, hIcon, bLarge);
}

int CShellBrowser2::_GetIconIndex(void)
{

    int iSelectedImage = -1;
    if (_pbbd->_pidlCur) 
    {
        if (_pbbd->_pctView) // we must check!
        {
            VARIANT var = {0};
            HRESULT hresT = _pbbd->_pctView->Exec(&CGID_ShellDocView, SHDVID_GETSYSIMAGEINDEX, 0, NULL, &var);
            if (SUCCEEDED(hresT)) {
                if (var.vt==VT_I4) {
                    iSelectedImage= var.lVal;
                } else {
                    ASSERT(0);
                    VariantClearLazy(&var);
                }
            }
        }

        if (iSelectedImage==-1)
        {
            //
            // Put Optimization here. 
            //
            IShellFolder *psfParent;
            LPCITEMIDLIST pidlChild;

            if (SUCCEEDED(IEBindToParentFolder(_pbbd->_pidlCur, &psfParent, &pidlChild))) 
            {
                // set the small one first to prevent user stretch blt on the large one
                SHMapPIDLToSystemImageListIndex(psfParent, pidlChild, &iSelectedImage);
                psfParent->Release();
            }
        }
    }
    return iSelectedImage;
}

bool    CShellBrowser2::_IsExplorerBandVisible (void)

//  99/02/10 #254171 vtan: This function determines whether
//  the explorer band is visible. This class should not really
//  care but it needs to know to change the window's icon.
//  This is a hack and should be moved or re-architected.

//  99/02/12 #292249 vtan: Re-worked algorithm to use
//  IBandSite::QueryBand and IPersistStream::GetClassID to
//  recognize the explorer band. Note that the old routine
//  used IDeskBand's inclusion of IOleWindow to get the HWND
//  and use the Win32 API IsWindowVisible().

//  99/06/25 #359477 vtan: Put this code back.
//  IsControlWindowShown uses QueryStatus for the explorer
//  band which doesn't work when v_SetIcon is called. The
//  band is NOT considered latched and therefore not visible.

{
    IDeskBar    *pIDeskBar;
    bool bVisible = false;
    HRESULT hResult = FindToolbar(INFOBAR_TBNAME, IID_PPV_ARG(IDeskBar, &pIDeskBar));
    if (SUCCEEDED(hResult) && (pIDeskBar != NULL))
    {
        UINT    uiToolBar;

        uiToolBar = _FindTBar(pIDeskBar);
        if (uiToolBar != static_cast<UINT>(-1))
        {
            LPTOOLBARITEM   pToolBarItem;

            pToolBarItem = _GetToolbarItem(uiToolBar);
            if ((pToolBarItem != NULL) && pToolBarItem->fShow)  // check this state
            {
                IUnknown    *pIUnknown;

                hResult = pIDeskBar->GetClient(reinterpret_cast<IUnknown**>(&pIUnknown));
                if (SUCCEEDED(hResult) && (pIUnknown != NULL))
                {
                    IBandSite   *pIBandSite;

                    hResult = pIUnknown->QueryInterface(IID_IBandSite, reinterpret_cast<void**>(&pIBandSite));
                    if (SUCCEEDED(hResult) && (pIBandSite != NULL))
                    {
                        UINT    uiBandIndex;
                        DWORD   dwBandID;

                        uiBandIndex = 0;
                        hResult = pIBandSite->EnumBands(uiBandIndex, &dwBandID);
                        while (SUCCEEDED(hResult))
                        {
                            DWORD       dwState;
                            IDeskBand   *pIDeskBand;

                            dwState = 0;
                            hResult = pIBandSite->QueryBand(dwBandID, &pIDeskBand, &dwState, NULL, 0);
                            if (SUCCEEDED(hResult))
                            {
                                CLSID   clsid;

                                hResult = IUnknown_GetClassID(pIDeskBand, &clsid);
                                if (SUCCEEDED(hResult) && IsEqualGUID(clsid, CLSID_ExplorerBand))
                                    bVisible = ((dwState & BSSF_VISIBLE) != 0);     // and this state
                                pIDeskBand->Release();
                                hResult = pIBandSite->EnumBands(++uiBandIndex, &dwBandID);
                            }
                        }
                        pIBandSite->Release();
                    }
                    pIUnknown->Release();
                }
            }
        }
        pIDeskBar->Release();
    }
    return(bVisible);
}

void CShellBrowser2::v_SetIcon()
{
    if (_IsExplorerBandVisible())
    {
        #define IDI_STFLDRPROP          46
        //  Explorer tree view pane is visible - use the magnifying glass icon
        HICON hIcon = reinterpret_cast<HICON>(LoadImage(HinstShell32(), MAKEINTRESOURCE(IDI_STFLDRPROP), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0));
        _SetWindowIcon(_pbbd->_hwnd, hIcon, ICON_SMALL);
        hIcon = reinterpret_cast<HICON>(LoadImage(HinstShell32(), MAKEINTRESOURCE(IDI_STFLDRPROP), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CXICON), 0));
        _SetWindowIcon(_pbbd->_hwnd, hIcon, ICON_BIG);
    }
    else
    {
        //  Otherwise use whatever icon it really should be
        int iSelectedImage = _GetIconIndex();
        if (iSelectedImage != -1) 
        {
            _WindowIconFromImagelist(_pbbd->_hwnd, iSelectedImage, ICON_SMALL);
            _WindowIconFromImagelist(_pbbd->_hwnd, iSelectedImage, ICON_BIG);
        }
    }
}

HRESULT CShellBrowser2::SetTitle(IShellView * psv, LPCWSTR lpszName)
{
    // If the pending view had it's title set immediately and waits
    // in pending state for a while. And if the current view has script updating
    // the title. Then the current title will be displayed after the navigate
    // is complete. I added psv to fix this problem to CBaseBrowser2, but I
    // didn't fix it here. [mikesh]
    //
    //  Don't set title if view is still pending (or you'll show unrated titles)
        // Figure out which object is changing.

    if (SHIsSameObject(_pbbd->_psv, psv))
    {
        _SetTitle(lpszName);
    }

    SUPERCLASS::SetTitle(psv, lpszName);
    return S_OK;
}

HRESULT CShellBrowser2::UpdateWindowList(void)
{
    if (_psw) {
        WinList_NotifyNewLocation(_psw, _dwRegisterWinList, _pbbd->_pidlCur);
    }
    return S_OK;
}

HRESULT CShellBrowser2::SetFlags(DWORD dwFlags, DWORD dwFlagMask)
{
    if (dwFlagMask & BSF_THEATERMODE)
        _TheaterMode(dwFlags & BSF_THEATERMODE, TRUE);

    if (dwFlagMask & BSF_RESIZABLE)
        SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_SIZEBOX, (dwFlags & BSF_RESIZABLE) ? WS_SIZEBOX : 0);

     if (dwFlagMask & BSF_CANMAXIMIZE)
        SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_MAXIMIZEBOX, (dwFlags & BSF_CANMAXIMIZE) ? WS_MAXIMIZEBOX : 0);

    if ((dwFlagMask & BSF_UISETBYAUTOMATION) && (dwFlags & BSF_UISETBYAUTOMATION))
    {
        _fDontSaveViewOptions = TRUE;
        _fUISetByAutomation = TRUE;
        // to hide any visible browser bar
        //REARCHITECT this will be removed when explorer bars become 1st class toolbars
        _SetBrowserBarState(_idmInfo, NULL, 0);
        _SetBrowserBarState(_idmComm, NULL, 0);
    }

    return SUPERCLASS::SetFlags(dwFlags, dwFlagMask);
}

HRESULT CShellBrowser2::GetFlags(DWORD *pdwFlags)
{
    DWORD dwFlags;
    
    SUPERCLASS::GetFlags(&dwFlags);

    if (_fUISetByAutomation)
        dwFlags |= BSF_UISETBYAUTOMATION;
    if (_fNoLocalFileWarning)
        dwFlags |= BSF_NOLOCALFILEWARNING;
    if (_ptheater)
        dwFlags |= BSF_THEATERMODE;
    *pdwFlags = dwFlags;

    return S_OK;
}

DWORD CShellBrowser2::v_ShowControl(UINT iControl, int iCmd)
{
    int iShowing = -1;
    int nWhichBand;

    switch (iControl) 
    {
    case FCW_STATUS:
        iShowing = (_fStatusBar ? SBSC_SHOW : SBSC_HIDE);
        if (iCmd != SBSC_QUERY && (iShowing != iCmd)) 
        {
            _fStatusBar = !_fStatusBar;
            // let itbar know that a change has occurred
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_STATUSCHANGED, 0, NULL, NULL);
            v_ShowHideChildWindows(FALSE);
        }
        break;

    case FCW_INTERNETBAR:
        {
            LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
            iShowing = (ptbi->fShow ? SBSC_SHOW : SBSC_HIDE);
            if (iCmd != SBSC_QUERY &&
                (iShowing != iCmd)) 
            {
                ptbi->fShow = !ptbi->fShow;
                v_ShowHideChildWindows(FALSE);
            }
        }
        break;

    case FCW_ADDRESSBAR:
    case FCW_TOOLBAND:
    case FCW_LINKSBAR:
    case FCW_MENUBAR:
        switch(iControl)
        {
            case FCW_ADDRESSBAR:
                nWhichBand = CITIDM_SHOWADDRESS;
                break;

            case FCW_TOOLBAND:
                nWhichBand = CITIDM_SHOWTOOLS;
                break;

            case FCW_LINKSBAR:
                nWhichBand = CITIDM_SHOWLINKS;
                break;

            case FCW_MENUBAR:
                nWhichBand = CITIDM_SHOWMENU;
                break;
        }
        if (iCmd != SBSC_QUERY)
        {
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, 
                nWhichBand, (iCmd == SBSC_SHOW), NULL, NULL);
        }
        break;

    default:
        break;
    }

    return iShowing;
}

HRESULT CShellBrowser2::ShowControlWindow(UINT id, BOOL fShow)
{
    switch (id)
    {
    case (UINT)-1:  // Set into Kiosk mode...
        if (BOOLIFY(_fKioskMode) != fShow)
        {
            _fKioskMode = fShow;
            if (_fKioskMode)
            {
                _wndpl.length = sizeof(WINDOWPLACEMENT);
                GetWindowPlacement(_pbbd->_hwnd, &_wndpl);
                SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX, 0);
                SHSetWindowBits(_pbbd->_hwnd, GWL_EXSTYLE, WS_EX_WINDOWEDGE, 0);
                _SetMenu(NULL);

                LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
                if (ptbi)
                {
                    ptbi->fShow = FALSE;
                }

                HMONITOR hmon = MonitorFromRect(&_wndpl.rcNormalPosition, MONITOR_DEFAULTTONEAREST);
                RECT rcMonitor;
                GetMonitorRect(hmon, &rcMonitor);
                
                SetWindowPos(_pbbd->_hwnd, NULL, rcMonitor.top, rcMonitor.left, RECTWIDTH(rcMonitor),
                        RECTHEIGHT(rcMonitor), SWP_NOZORDER);
            }
            else
            {
                if (_fShowMenu)
                    _SetMenu(_hmenuCur);
                else
                    _SetMenu(NULL);

                SHSetWindowBits(_pbbd->_hwnd, GWL_STYLE, WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX, WS_CAPTION|WS_SYSMENU|WS_THICKFRAME|WS_MINIMIZEBOX|WS_MAXIMIZEBOX);
                SHSetWindowBits(_pbbd->_hwnd, GWL_EXSTYLE, WS_EX_WINDOWEDGE, WS_EX_WINDOWEDGE);
                SetWindowPlacement(_pbbd->_hwnd, &_wndpl);
            }

            // Let window manager know to recalculate things...
            v_ShowHideChildWindows(FALSE);

            SetWindowPos(_pbbd->_hwnd, NULL, 0, 0, 0, 0,
                    SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_FRAMECHANGED);
        }
        break;

    case FCW_INTERNETBAR:
    case FCW_STATUS:
    case FCW_ADDRESSBAR:
        v_ShowControl(id, fShow ? SBSC_SHOW : SBSC_HIDE);
        break;
        
    case FCW_MENUBAR:
        if (BOOLIFY(_fShowMenu) != BOOLIFY(fShow))
        {
            _fShowMenu = BOOLIFY(fShow);
            if (_fShowMenu)
            {
                _SetMenu(_hmenuCur);
            }
            else
            {
                _SetMenu(NULL);
            }

            // Let window manager know to recalculate things...
            v_ShowControl(id, fShow ? SBSC_SHOW : SBSC_HIDE);
            // Let ITBar know whether to allow selection of menu bar or no
            IUnknown_Exec(_GetITBar(), &CGID_PrivCITCommands, CITIDM_DISABLESHOWMENU, !_fShowMenu, NULL, NULL);

            SetWindowPos(_pbbd->_hwnd, NULL, 0, 0, 0, 0,
                    SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE|SWP_FRAMECHANGED);
        }
        break;

    default:
        return E_INVALIDARG;   // Not one of the ones we support...
    }
    return S_OK;
}

BOOL CShellBrowser2::_ShouldAllowNavigateParent()
{
    LPCITEMIDLIST pidl = ILIsRooted(_pbbd->_pidlCur) ? ILGetNext(_pbbd->_pidlCur) : _pbbd->_pidlCur;
    return !ILIsEmpty(pidl);
}

HRESULT CShellBrowser2::IsControlWindowShown(UINT id, BOOL *pfShown)
{
    switch (id)
    {
    case (UINT)-1:  // Set into Kiosk mode...
        *pfShown = _fKioskMode;
        break;

    case FCW_INTERNETBAR:
        *pfShown = _GetToolbarItem(ITB_ITBAR)->fShow;
        break;

    case FCW_STATUS:
        *pfShown = _fStatusBar;
        break;

    case FCW_MENUBAR:
        *pfShown = _fShowMenu;
        break;
        
    case FCW_TREE:
    {
        BOOL    fShown;

        OLECMD rgCmds[1] = {0};
        rgCmds[0].cmdID = SBCMDID_EXPLORERBAR;
        QueryStatus(&CGID_Explorer, ARRAYSIZE(rgCmds), rgCmds, NULL);
        fShown = (rgCmds[0].cmdf & OLECMDF_LATCHED);
        if (pfShown != NULL)
            *pfShown = fShown;
        break;
    }

    case FCW_ADDRESSBAR:
    {
        OLECMD rgcmd[] = {
            { CITIDM_VIEWTOOLS, 0 },
            { CITIDM_VIEWADDRESS, 0 }
        };
        if (_GetToolbarItem(ITB_ITBAR)->fShow)
            IUnknown_QueryStatus(_GetITBar(), &CGID_PrivCITCommands, ARRAYSIZE(rgcmd), rgcmd, NULL);
        *pfShown = rgcmd[1].cmdf & OLECMDF_ENABLED ? TRUE : FALSE;
        break;
    }

    default:
        return E_INVALIDARG;   // Not one of the ones we support...
    }

    return S_OK;
}

HRESULT CShellBrowser2::SetReferrer(LPITEMIDLIST pidl)
{
    //
    //  this is only used when we create a new window, and
    //  we need some sort of ZoneCrossing context.
    //
    Pidl_Set(&_pidlReferrer, pidl);

    return (_pidlReferrer || !pidl) ? S_OK :E_FAIL;
}

HRESULT CShellBrowser2::_CheckZoneCrossing(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    //
    //  NOTE - right now we only handle having one or the other - zekel 8-AUG-97
    //  we should only have pidlReferrer if we have been freshly 
    //  created.  if we decide to use it on frames that already exist,
    //  then we need to decide whether we should show pidlCur or pidlReferrer.
    //  by default we give Referrer preference.
    //
    AssertMsg((!_pidlReferrer && !_pbbd->_pidlCur) || 
        (_pidlReferrer && !_pbbd->_pidlCur) || 
        (!_pidlReferrer && _pbbd->_pidlCur), 
        TEXT("REVIEW: should this be allowed?? -zekel"));

    LPITEMIDLIST pidlRef = _pidlReferrer ? _pidlReferrer : _pbbd->_pidlCur;

    //
    //  Call InternetConfirmZoneCrossingA API only if this is the top-level
    // browser (not a browser control) AND there is a current page.
    //
    if (pidlRef) {
        
        HRESULT hresT = S_OK;
        // Get the URL of the current page.
        WCHAR szURLPrev[MAX_URL_STRING];

        const WCHAR c_szURLFile[] = L"file:///c:\\";  // dummy one
        LPCWSTR pszURLPrev = c_szURLFile;    // assume file:

        //         We should get the display name first and then only use
        //         the default value if the szURLPrev doesn't have a scheme.
        //         Also do this for szURLNew below.  This will fix Folder Shortcuts
        //         especially to Web Folders.  We also need to use the pidlTarget
        //         Folder Shortcut pidl.
        if (IsURLChild(pidlRef, FALSE))
        {
            hresT = ::IEGetDisplayName(pidlRef, szURLPrev, SHGDN_FORPARSING);
            pszURLPrev = szURLPrev;
        }

        if (SUCCEEDED(hresT))
        {
            // Get the URL of the new page.
            WCHAR szURLNew[MAX_URL_STRING];
            LPCWSTR pszURLNew = c_szURLFile;
            if (IsURLChild(pidl, FALSE)) {
                hresT = ::IEGetDisplayName(pidl, szURLNew, SHGDN_FORPARSING);
                pszURLNew = szURLNew;
            }

            if (pszURLPrev != pszURLNew && SUCCEEDED(hresT))
            {
                // HACK: This API takes LPTSTR instead of LPCTSTR. 
                DWORD err = InternetConfirmZoneCrossing(_pbbd->_hwnd, (LPWSTR)pszURLPrev, (LPWSTR) pszURLNew, FALSE);

                hr = HRESULT_FROM_WIN32(err);
                TraceMsg(DM_ZONE, "CSB::_CheckZoneCrossing InetConfirmZoneXing %hs %hs returned %d", pszURLPrev, pszURLNew, err);
                if (FAILED(hr) &&
                    (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr) &&
                    (E_OUTOFMEMORY != hr))
                {
                    // We only need to investigate an error if it is unexpected.  Out of memory and
                    // a user cancelling the dialog are valid.
                    TraceMsg(DM_ERROR, "CSB::_CheckZoneCrossing ICZC returned error (%d)", err);
                }
            }
            else
            {
                TraceMsg(DM_ZONE, "CSB::_CheckZoneCrossing IEGetDisplayName(pidl) failed %x", hresT);
            }
        }
        else
        {
            TraceMsg(DM_ZONE, "CSB::_CheckZoneCrossing IEGetDisplayName(pidlRef) failed %x", hresT);
        }
    }

    SetReferrer(NULL);

    return hr;
}

BOOL CShellBrowser2::v_IsIEModeBrowser()
{
    //
    // if we didnt register the window or if it is not registered as 3rdparty,
    //  then it is allowed to be an IEModeBrowser.
    //
    return (!_fDidRegisterWindow || (_swcRegistered != SWC_3RDPARTY)) && 
        (_fInternetStart || (_pbbd->_pidlCur && IsURLChild(_pbbd->_pidlCur, TRUE)));
}


// IServiceProvider::QueryService

STDMETHODIMP CShellBrowser2::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SExplorerToolbar)) 
    {
        LPTOOLBARITEM ptbi = _GetToolbarItem(ITB_ITBAR);
        if (ptbi->ptbar) 
        {
            return ptbi->ptbar->QueryInterface(riid, ppvObj);
        }
    } 
    else if (IsEqualGUID(guidService, SID_SMenuBandHandler) || 
             IsEqualGUID(guidService, SID_SHostProxyFilter))
    {
        return QueryInterface(riid, ppvObj);
    }
    
    return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

HRESULT CShellBrowser2::EnableModelessSB(BOOL fEnable)
{
    HRESULT hres = SUPERCLASS::EnableModelessSB(fEnable);
//
//  We don't want to leave the frame window disabled if a control left
// us disabled because of its bug. Instead, we'll put a warning dialog
// box -- IDS_CLOSEANYWAY. (SatoNa)
//
#if 0
    EnableMenuItem(GetSystemMenu(_pbbd->_hwnd, FALSE), SC_CLOSE, (S_OK == _DisableModeless()) ?
                         (MF_BYCOMMAND | MF_GRAYED) : (MF_BYCOMMAND| MF_ENABLED));
#endif
    return hres;
}

LPCITEMIDLIST CShellBrowser2::_GetPidl()
{
    LPCITEMIDLIST pidl = _pbbd->_pidlNewShellView;

    if (pidl == NULL)
        pidl = _pbbd->_pidlPending;

    if (pidl == NULL)
        pidl = _pbbd->_pidlCur;

    return pidl;
}

BOOL CShellBrowser2::_DoesPidlRoam(LPCITEMIDLIST pidl)
{
    WCHAR szPath[MAX_PATH];
    BOOL fRet = SHGetPathFromIDList(pidl, szPath);
    if (fRet)
    {
        fRet = PathIsUNC(szPath);
    }
    return fRet;
}

HRESULT CShellBrowser2::_CreateFakeNilPidl(LPITEMIDLIST *ppidl)
{
    IShellFolder *psfDesktop;
    HRESULT hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        IBindCtx *pbc;
        hr = BindCtx_CreateWithMode(STGM_CREATE, &pbc);
        if (SUCCEEDED(hr))
        {
            // the new "nil" clsid
            hr = psfDesktop->ParseDisplayName(NULL, pbc, L"::{cce6191f-13b2-44fa-8d14-324728beef2c}", NULL, ppidl, NULL);
            pbc->Release();
        }
        psfDesktop->Release();
    }
    return hr;
}

BOOL CShellBrowser2::_IsPageInternet(LPCITEMIDLIST pidl)
{
    BOOL fInternet = FALSE;
    if (((NULL == pidl) && IsEqualCLSID(_clsidThis, CLSID_InternetExplorer)) ||
        IsBrowserFrameOptionsPidlSet(pidl, BFO_BROWSER_PERSIST_SETTINGS))
    {
        fInternet = TRUE;
    }

    return fInternet;
}

HRESULT CShellBrowser2::_GetPropertyBag(LPCITEMIDLIST pidl, DWORD dwFlags, REFIID riid, void** ppv)
{
    HRESULT hr;

    if (_IsPageInternet(pidl))
    {
        LPITEMIDLIST pidlIE = IEGetInternetRootID();

        if (pidlIE)
        {
            hr = SHGetViewStatePropertyBag(pidlIE, VS_BAGSTR_EXPLORER, dwFlags, riid, ppv);
            ILFree(pidlIE);
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

    }
    else if (!pidl || _fNilViewStream)
    {
        // the old-style save-to-stream code faked up a "nil" location in the case of NULL.
        // additionally if we loaded from this fake stream we had to save to it later.
        // the search window actually relies on this behavior since it doesnt get its
        // pidl for navigation until the window is already up.
        // it's too late to change the way search initializes its view window and the
        // solution is nontrivial anyway, so mimic the old behavior here.
        LPITEMIDLIST pidlNil;
        hr = _CreateFakeNilPidl(&pidlNil);
        if (SUCCEEDED(hr))
        {
            hr = SHGetViewStatePropertyBag(pidlNil, VS_BAGSTR_EXPLORER, dwFlags, riid, ppv);
            ILFree(pidlNil);
        }
        _fNilViewStream = TRUE;
    }
    else
    {
        if (_DoesPidlRoam(pidl))
        {
            dwFlags |= SHGVSPB_ROAM;
        }

        hr = SHGetViewStatePropertyBag(pidl, VS_BAGSTR_EXPLORER, dwFlags, riid, ppv);
    }

    return hr;
}

HRESULT CShellBrowser2::GetPropertyBag(DWORD dwFlags, REFIID riid, void** ppv)
{
    LPCITEMIDLIST pidl = _GetPidl();

    return _GetPropertyBag(pidl, dwFlags, riid, ppv);
}

HRESULT CShellBrowser2::GetViewStateStream(DWORD grfMode, IStream **ppstm)

//  99/02/05 #226140 vtan: DefView doesn't perist the dwDefRevCount
//  like ShellBrowser does. When DefView asks ShellBrowser for the
//  view state stream ShellBrowser would blindly return the stream
//  (implemented in the super class CCommonBrowser). In order to
//  ensure the stream's validity the method is now replaced with
//  this code which verifies the dwDefRevCount matches. If there
//  is a mismatch the function bails with an error otherwise it
//  calls the regularly scheduled program (super CCommonBrowser).

//  This will have to be revisited when separating frame
//  state from view state.

{
    HRESULT         hResult;
    IStream*        pIStream;
    LPCITEMIDLIST   pIDL;

    pIDL = _GetPidl();
    pIStream = v_GetViewStream(pIDL, STGM_READ, L"CabView");
    if (pIStream != NULL)
    {
        CABSH   cabinetStateHeader;

        hResult = _FillCabinetStateHeader(pIStream, &cabinetStateHeader);
        pIStream->Release();
        if (SUCCEEDED(hResult) &&
            ((cabinetStateHeader.fMask & CABSHM_REVCOUNT) != 0) &&
            (g_dfs.dwDefRevCount != cabinetStateHeader.dwRevCount))
        {
            *ppstm = NULL;
            return(E_FAIL);
        }
    }
    return(SUPERCLASS::GetViewStateStream(grfMode, ppstm));
}

LRESULT CALLBACK CShellBrowser2::DummyTBWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CShellBrowser2* pSB = (CShellBrowser2*)GetWindowPtr0(hwnd);    // GetWindowLong(hwnd, 0)
    LRESULT lRes = 0L;
    
    if (uMsg < WM_USER)
        return(::DefWindowProcWrap(hwnd, uMsg, wParam, lParam));
    else    
    {
        switch (uMsg) {
            
        case TB_ADDBITMAP:
            pSB->_pxtb->AddBitmap(&CGID_ShellBrowser, BITMAP_NORMAL, (UINT)wParam, (TBADDBITMAP*)lParam, &lRes, RGB(192,192,192));
            pSB->_pxtb->AddBitmap(&CGID_ShellBrowser, BITMAP_HOT, (UINT)wParam, (TBADDBITMAP*)lParam, &lRes, RGB(192,192,192));
            break;
            
        default:
            if (pSB->_pxtb)
                pSB->_pxtb->SendToolbarMsg(&CGID_ShellBrowser, uMsg, wParam, lParam, &lRes);
            return lRes;
        }
    }
    return lRes;
}    

// When a view adds buttons with no text, the CInternet toolbar may call back and ask
// for the tooltip strings. Unfortunately, at that time _pbbd->_hwndView is not yet set and therefore
// the tooltip texts will not be set. 
//
// So, to get around that, we do not add the buttons if there is no _pbbd->_hwndView (see ::SetToolbarItem)
// The CBaseBrowser2's ::_SwitchActivationNow() is the one that sets the _pbbd->_hwndView. So when this hwnd is
// set then we add the buttons
// 
// We send the WM_NOTIFYFORMAT because when CInternetToolbar::AddButtons calls back with the WM_NOTIFYs 
// for the tooltips, we need to know whether or not the view is UNICODE or not.
HRESULT CShellBrowser2::_SwitchActivationNow()
{
    ASSERT(_pbbd->_psvPending);

#if 0
    // if we have a progress control, make sure it's off before we switch activation
    if (_hwndProgress)
        SendControlMsg(FCW_PROGRESS, PBM_SETRANGE32, 0, 0, NULL);
#endif

    SUPERCLASS::_SwitchActivationNow();

    // need to do this as close to the assign of _pbbd->_hwndView as possible
    _fUnicode = (SendMessage (_pbbd->_hwndView, WM_NOTIFYFORMAT,
                                 (WPARAM)_pbbd->_hwnd, NF_QUERY) == NFR_UNICODE);
    
    if (_lpButtons) {
        LocalFree(_lpButtons);
        _lpButtons = NULL;
        _nButtons = 0;
    }
    
    if (_lpPendingButtons)
    {
        
        _lpButtons = _lpPendingButtons;
        _nButtons = _nButtonsPending;
        _lpPendingButtons = NULL;
        _nButtonsPending = 0;
        
        if ((_pxtb) && (_pbbd->_hwndView))
            _pxtb->AddButtons(&CGID_ShellBrowser, _nButtons, _lpButtons);
        
    }    
    return S_OK;
}


#ifdef DEBUG
/*----------------------------------------------------------
Purpose: Dump the menu handles for this browser.  Optionally
         breaks after dumping handles.

*/
void
CShellBrowser2::_DumpMenus(
    IN LPCTSTR pszMsg,
    IN BOOL    bBreak)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        ASSERT(pszMsg);

        TraceMsg(TF_ALWAYS, "CShellBrowser2: Dumping menus for %#08x %s", (void *)this, pszMsg);
        TraceMsg(TF_ALWAYS, "   _hmenuTemplate = %x, _hmenuFull = %x, _hmenuBrowser = %x",
                 _hmenuTemplate, _hmenuFull, _hmenuBrowser);
        TraceMsg(TF_ALWAYS, "   _hmenuCur = %x, _hmenuPreMerged = %x, _hmenuHelp = %x",
                 _hmenuCur, _hmenuPreMerged, _hmenuHelp);

        _menulist.Dump(pszMsg);
        
        if (bBreak && IsFlagSet(g_dwBreakFlags, BF_ONDUMPMENU))
            DebugBreak();
    }
}
#endif

HRESULT CShellBrowser2::SetBorderSpaceDW(IUnknown* punkSrc, LPCBORDERWIDTHS pborderwidths)
{
    return SUPERCLASS::SetBorderSpaceDW(punkSrc, pborderwidths);
}

//
//  This is a helper member of CBaseBroaser class (non-virtual), which
// returns the effective client area. We get this rectangle by subtracting
// the status bar area from the real client area.
//
HRESULT CShellBrowser2::_GetEffectiveClientArea(LPRECT lprectBorder, HMONITOR hmon)
{
    static const int s_rgnViews[] =  {1, 0, 1, FCIDM_STATUS, 0, 0};

    // n.b. do *not* call SUPER/_psbInner

    ASSERT(hmon == NULL);
    GetEffectiveClientRect(_pbbd->_hwnd, lprectBorder, (LPINT)s_rgnViews);
    return S_OK;
}

// Should we return more informative return values?
// "Browser Helper Objects"

BOOL CShellBrowser2::_LoadBrowserHelperObjects(void)
{
    BOOL bRet = FALSE;
    BOOL bNoExplorer = FALSE;
    HKEY hkey;

    // We shouldn't load browser extensions if we're in fail-safe mode, or if the user asked us to disable these extensions/
    // In the future, we should allow disabling on a per-extension basis (when not in safe mode)
    if ((!SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\Main"), TEXT("Enable Browser Extensions"), FALSE, TRUE))
        || (GetSystemMetrics(SM_CLEANBOOT)!=0))
    {
        return TRUE;
    }

    if (_pbbd->_pautoWB2 &&
        RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_EXPLORER TEXT("\\Browser Helper Objects"), 0, KEY_ENUMERATE_SUB_KEYS, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szGUID[64];
        DWORD cb = ARRAYSIZE(szGUID);
        for (int i = 0;
             RegEnumKeyEx(hkey, i, szGUID, &cb, NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
             i++)
        {
            // If we're not in IEXPLORE's process
            //
            if (!_fRunningInIexploreExe)
            {
                // Check to see if there's a "NoExplorer" value
                //
                bNoExplorer = (ERROR_SUCCESS == SHGetValue(hkey, szGUID, TEXT("NoExplorer"), NULL, NULL, NULL));
            }

            // If we're in IEXPLORE.EXE or we're in EXPLORER.EXE but there's no "NoExplorer" value, then
            // go ahead and load the BHO
            if (_fRunningInIexploreExe || !bNoExplorer)
            {
                CLSID clsid;
                IObjectWithSite *pows;
                if (GUIDFromString(szGUID, &clsid) &&
                    !(SHGetObjectCompatFlags(NULL, &clsid) & OBJCOMPATF_UNBINDABLE) &&
                    SUCCEEDED(CoCreateInstance(clsid, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IObjectWithSite, &pows))))
                {
                    pows->SetSite(_pbbd->_pautoWB2);    // give the poinetr to IWebBrowser2

                    SA_BSTRGUID strClsid;
                    // now register this object so that it can be found through automation.
                    SHTCharToUnicode(szGUID, strClsid.wsz, ARRAYSIZE(strClsid.wsz));
                    strClsid.cb = lstrlenW(strClsid.wsz) * sizeof(WCHAR);

                    VARIANT varUnknown = {0};
                    varUnknown.vt = VT_UNKNOWN;
                    varUnknown.punkVal = pows;
                    _pbbd->_pautoWB2->PutProperty(strClsid.wsz, varUnknown);

                    pows->Release(); // Instead of calling variantClear() 

                    bRet = TRUE;
                }
            }
            cb = ARRAYSIZE(szGUID);
        }
        RegCloseKey(hkey);
    }
    return bRet;
}

HRESULT CShellBrowser2::OnViewWindowActive(IShellView * psv)
{
    _pbsInner->SetActivateState(SVUIA_ACTIVATE_FOCUS);
    return SUPERCLASS::OnViewWindowActive(psv);
}

HRESULT CShellBrowser2::_PositionViewWindow(HWND hwnd, LPRECT prc)
{
    if (hwnd == _hwndDelayedSize)
    {
        _fHaveDelayedSize = TRUE;
        _rcDelayedSize = *prc;
    }
    else
    {
        RECT rc = *prc;

        if (_ptheater) {
            InflateRect(&rc, GetSystemMetrics(SM_CXEDGE), GetSystemMetrics(SM_CYEDGE));
        }
        
        SetWindowPos(hwnd, NULL,
                     rc.left, rc.top, 
                     rc.right - rc.left, 
                     rc.bottom - rc.top,
                     SWP_NOZORDER | SWP_NOACTIVATE);
    }

    return S_OK;
}

HRESULT CShellBrowser2::OnFocusChangeIS(IUnknown* punkSrc, BOOL fSetFocus)
{
    if (fSetFocus && _ptheater && SHIsSameObject(punkSrc, _GetITBar())) {
        _ptheater->Exec(&CGID_Theater, THID_TOOLBARACTIVATED, 0, NULL, NULL);
    }
    return SUPERCLASS::OnFocusChangeIS(punkSrc, fSetFocus);
}


HRESULT CShellBrowser2::Offline(int iCmd)
{
    HRESULT hresIsOffline = SUPERCLASS::Offline(iCmd);
        
    if (iCmd == SBSC_TOGGLE)
    {        
        VARIANTARG var = {0};
        if (_pbbd->_pctView && SUCCEEDED(_pbbd->_pctView->Exec(&CGID_Explorer, SBCMDID_GETPANE, PANE_OFFLINE, NULL, &var))
            && V_UI4(&var) != PANE_NONE)
        {
            SendControlMsg(FCW_STATUS, SB_SETICON, V_UI4(&var), 
                (hresIsOffline == S_OK) ? (LPARAM) OfflineIcon() : NULL, NULL);
            if (hresIsOffline == S_OK) {
                InitTitleStrings();
                SendControlMsg(FCW_STATUS, SB_SETTIPTEXT, V_UI4(&var), 
                               (LPARAM) g_szWorkingOfflineTip, NULL);
            }
        } 
    }
        
    return hresIsOffline;
}

HRESULT CShellBrowser2::_FreshenComponentCategoriesCache(BOOL bForceUpdate)
{
    CATID catids[2] ;
    ULONG cCatids = 0 ;
    catids[0] = CATID_InfoBand ;
    catids[1] = CATID_CommBand ;

    //  Check if our CATIDs are cached...
    if (!bForceUpdate)
    {
        for(ULONG i=0; i< ARRAYSIZE(catids); i++)
        {
            if (S_OK != SHDoesComCatCacheExist(catids[i], TRUE))
            {
                bForceUpdate = TRUE ;
                break ;
            }
        }
    }

    if (bForceUpdate)
    {
        // Create an event for the comcat task to signal when it's
        // done.  We need to do this because sometimes the task hasn't
        // finished by the time the user opens the "Explorer Bars"
        // submenu, and so they won't see the Bloomberg bar (for
        // example) that they just installed unless we wait for the task
        // to complete.

        if (_hEventComCat == NULL)
            _hEventComCat = CreateEvent(NULL, FALSE, FALSE, NULL);

        return SHWriteClassesOfCategories(ARRAYSIZE(catids), catids, 0, NULL, 
                                   TRUE, FALSE /*no wait*/, _hEventComCat) ;
    }

    return S_FALSE ;
}

void CShellBrowser2::_QueryHKCRChanged()
{
    ASSERT(g_fRunningOnNT && GetUIVersion() >= 5);

    //  In an integrated installation >= v5 on NT, we have the benefit
    //  of an HKCR change notification.  Posting this message will cause
    //  the desktop to check to see if HKCR was modified recently; if so, 
    //  the _SetupAppRan handler will execute in the desktop process.   
    //  This causes, among other evil, freshening of our component categories cache.
    //  it is ok that this is isnt synchronous because the update
    //  is async regardless.

    PostMessage(GetShellWindow(), DTM_QUERYHKCRCHANGED, 
                 QHKCRID_VIEWMENUPOPUP, (LPARAM)NULL) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_)
#define AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif


#define _ATL_APARTMENT_THREADED

#define _ATL_NO_DEBUG_CRT           // use the shell debug facilities

#ifdef ATL_ENABLED
#define _ATL_NO_UUIDOF

extern "C"
inline HRESULT __stdcall OleCreatePropertyFrame(
  HWND hwndOwner,    //Parent window of property sheet dialog box
  UINT x,            //Horizontal position for dialog box
  UINT y,            //Vertical position for dialog box
  LPCOLESTR lpszCaption,
                     //Pointer to the dialog box caption
  ULONG cObjects,    //Number of object pointers in lplpUnk
  LPUNKNOWN FAR* lplpUnk,
                     //Pointer to the objects for property sheet
  ULONG cPages,      //Number of property pages in lpPageClsID
  LPCLSID lpPageClsID,
                     //Array of CLSIDs for each property page
  LCID lcid,         //Locale identifier for property sheet locale
  DWORD dwReserved,  //Reserved
  LPVOID lpvReserved //Reserved
)
{
    return S_OK;
}
#endif

#include <debug.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__3964D994_AC96_11D1_9851_00C04FD91972__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\theater.h ===
#ifndef _THEATER_H
#define _THEATER_H

// Metrics for this view mode
#define THEATER_CYTOOLBAR       26
#define CLOSEMIN_HEIGHT         16
#define CLOSEMIN_YOFFSET        1
#define CLOSEMIN_XOFFSET        1
#define CLOSEMIN_WIDTH          54
#define PROGRESS_WIDTH          (CLOSEMIN_WIDTH + 2)
#define PROGRESS_HEIGHT         6
#define PROGRESS_YPOS           (CLOSEMIN_HEIGHT + (2 * CLOSEMIN_YOFFSET) + 1)
#define BRAND_YOFFSET           0
#define BRAND_WIDTH             34
#define BRAND_HEIGHT            26
#define CX_HIT                  (GetSystemMetrics(SM_CXEDGE) * 3)
#define CX_BROWOVERLAP          (GetSystemMetrics(SM_CXEDGE) / 2)
#define CX_FLOATERSHOWN         (BRAND_WIDTH + CLOSEMIN_WIDTH + (2 * CLOSEMIN_XOFFSET))

#define SHORT_DELAY             90
#define LONG_DELAY              (4 * SHORT_DELAY)

// Theatre mode controls
#define TMC_PROGRESSBAR     1
#define TMC_BRANDBAND       2
#define TMC_STATUSBAR       3

#define TM_STATUS_PANES                2
#define TM_STATUS_PANE_NAVIGATION      0
#define TM_STATUS_PANE_SSL             1

class CShellBrowser2;

class CTheater:
   public IOleWindow, 
   public IOleCommandTarget, 
   public IServiceProvider
{
    
public:
    HWND GetMasterWindow() {return _hwndBrowser;};
    void Begin();
    CTheater(HWND hwnd, HWND hwndToolbar, IUnknown *punkOwner);
    ~CTheater();
    
    
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }
    
    // IOleCommandTarget
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);

    HRESULT SetBrowserBar(IUnknown* punk, int cxHidden, int cxExpanded);
    void GetPreviousWindowPlacement(WINDOWPLACEMENT* pwp, LPRECT prc)  { *pwp = _wp; *prc = _rcOld;};
    void SetAutoHideToolbar(long val) { _fAutoHideToolbar = val; };            
    void RecalcSizing();

protected:
    friend class CShellBrowser2;
    // save data
    // we put the save state data in here so that the browser doesn't have to waste memory with this data when not in theater mode
    // also, because it's transient, don't use bitfields.  save code instead of memory for transient stuff
    
private:
    int _cyLast;
    HWND _hwndToolbar; // this is the toolbar window that we want to make sure the hidden window encompasses
    HWND _hwndBrowser; // this is the hwnd that we slide down
    HWND _hwndTaskbar;
    BOOL _fShown;
    BOOL _fTaskbarShown;
    BOOL _fDelay;
    BOOL _fAutoHideToolbar;
    BOOL _fInitialBrowserBar;
    BOOL _fAutoHideBrowserBar;    

    HHOOK   _hhook;
    IUnknown *_punkOwner;
    IUnknown *_punkBrowBar;
    HWND _hwndBrowBar;
    WINDOWPLACEMENT _wp;
    RECT _rcOld;
    
    UINT _cRef;
    
    IDeskBand* _pdbBrand;
    HWND _hwndClose;
    HWND _hwndFloater;      // the Floating pallete window
    HWND _hwndProgress;     // used in CShellBrowser(2) - maybe move to interface
    int _cActiveRef;        // the ref count for activating the Floatering palette

    static CAssociationList _al; // associate threadid with CTheater objects
    
    void _SwapParents(HWND hwndOld, HWND hwndNew);
    void _Initialize();
    void _SizeBrowser();
    void _SizeFloater();
    void _CreateCloseMinimize();
    void _PositionCloseRestore();
    void _DelayHideFloater();

    void _DelayHideToolbar();
    void _HideToolbar();
    void _ShowToolbar();
    void _ContinueHideToolbar();
    LRESULT _OnMsgHook(int nCode, WPARAM wParam, MOUSEHOOKSTRUCT *pmhs, BOOL fFake);

    BOOL _IsBrowserActive();
    
    void _ShowTaskbar();
    void _HideTaskbar();

    void _Unhide(int iWhich, UINT uDelay);
    int _iUnhidee;

    BOOL _PtNearWindow(POINT pt, HWND hwnd);
    BOOL _PtOnEdge(POINT pt, int iEdge);
    BOOL _GetWindowRectRel(HWND hWnd, LPRECT lpRect);

    BOOL_PTR _HasBegun() { return (BOOL_PTR)_hhook; }
    
    BOOL _fBrowBarShown;
    int _cxBrowBarShown;
    int _cxBrowBarHidden;
    void _ContinueHideBrowBar();
    void _HideBrowBar();
    void _ShowBrowBar();

    BOOL _CanHideWindow(HWND hwnd);

    BOOL _fFloaterShown;
    COLORREF _clrBrandBk;
    void _ContinueHideFloater();
    void _HideFloater();
    void _ShowFloater();

    void _SanityCheckZorder();
    void _OnCommand(UINT idCmd);

    static LRESULT _MsgHook(int nCode, WPARAM wParam, LPARAM lParam);
    static LRESULT _FloaterWndProc(HWND  hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

#define THID_ACTIVATE               1
#define THID_DEACTIVATE             2
#define THID_SETBROWSERBARWIDTH     3  // tells the browser bar what it's fixed width should be
#define THID_SETTOOLBARAUTOHIDE     4
#define THID_SETBROWSERBARAUTOHIDE  5
#define THID_TOOLBARACTIVATED       6
#define THID_ONINTERNET             7
#define THID_RECALCSIZING           8

// Explorer bar registry save structure
typedef struct _BROWBARSAVE {
    UINT uiWidthOrHeight;
    BOOL fAutoHide : 1;
} BROWBARSAVE;

#define SZ_REGVALUE_EXPLORERBARA  "ExplorerBar"
#define SZ_REGVALUE_EXPLORERBAR   TEXT(SZ_REGVALUE_EXPLORERBARA)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\xbarglyph.cpp ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      XBarGlyph.h
//
//  Contents:  image of an xBar pane
//
//  Classes:   CXBarGlyph
//
//------------------------------------------------------------------------

#include "priv.h"
#include "XBarGlyph.h"
#include "resource.h"
#include "tb_ids.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

#define CX_SMALL_ICON   16
#define CX_LARGE_ICON   20

// These defines are zero-index offsets into the existing toolbar buttons
#define IBAR_ICON_FAVORITES 6
#define IBAR_ICON_SEARCH    5
#define IBAR_ICON_HISTORY   12
#define IBAR_ICON_EXPLORER  43
#define IBAR_ICON_DEFAULT   10


//------------------------------------------------------------------------
CXBarGlyph::CXBarGlyph()
  : _hbmpColor(NULL),
    _hbmpMask(NULL),
    _fAlpha(FALSE),
    _lWidth(0),
    _lHeight(0)
{

}

//------------------------------------------------------------------------
CXBarGlyph::~CXBarGlyph()
{
    DESTROY_OBJ_WITH_HANDLE(_hbmpColor, DeleteObject);
    DESTROY_OBJ_WITH_HANDLE(_hbmpMask, DeleteObject);
}

//------------------------------------------------------------------------
HRESULT
    CXBarGlyph::SetIcon(HICON hIcon, BOOL fAlpha)
{
    DESTROY_OBJ_WITH_HANDLE(_hbmpColor, DeleteObject);
    DESTROY_OBJ_WITH_HANDLE(_hbmpMask, DeleteObject);

    if (hIcon == NULL) {
        return E_INVALIDARG;
    }
    ICONINFO    ii = {0};
    if (GetIconInfo(hIcon, &ii))
    {
        _hbmpColor = ii.hbmColor;
        _hbmpMask = ii.hbmMask;
        _fAlpha = fAlpha;
        _EnsureDimensions();
    }
    else {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}

//------------------------------------------------------------------------
HICON
    CXBarGlyph::GetIcon(void)
{
    ICONINFO ii = {0};
    ii.fIcon = TRUE;
    ii.hbmColor = _hbmpColor;
    ii.hbmMask = _hbmpMask;
    return CreateIconIndirect(&ii);
}

//------------------------------------------------------------------------
BOOL
    CXBarGlyph::HaveGlyph(void)
{
    return (_hbmpColor != NULL);
}

//------------------------------------------------------------------------
LONG
    CXBarGlyph::GetWidth(void)
{
    _EnsureDimensions();
    return _lWidth;
}

//------------------------------------------------------------------------
LONG
    CXBarGlyph::GetHeight(void)
{
    _EnsureDimensions();
    return _lHeight;
}

//------------------------------------------------------------------------
HRESULT
    CXBarGlyph::LoadGlyphFile(LPCTSTR pszPath, BOOL fSmall)
{
    // ISSUE/010304/davidjen  could be smarter and make educated guess of file format by analyzing file name
    // now we assume it's always an icon format
    USES_CONVERSION;
    HRESULT hr = E_FAIL;
    if (pszPath && *pszPath)
    {
        CString strPath = pszPath;
        HICON   hIcon = NULL;
        int nBmpIndex = PathParseIconLocation((LPWSTR)T2CW(strPath));
        strPath.ReleaseBuffer();

        CString strExpPath;
        SHExpandEnvironmentStrings(strPath, strExpPath.GetBuffer(MAX_PATH), MAX_PATH);
        strExpPath.ReleaseBuffer();

        // If no resource id, assume it's an ico file
        UINT cx = fSmall ? CX_SMALL_ICON : CX_LARGE_ICON;
        if (nBmpIndex == 0)
        {
            hIcon = (HICON)LoadImage(0, strExpPath, IMAGE_ICON, cx, cx, LR_LOADFROMFILE);
        }

        if (hIcon == NULL)
        {
            // try loading as a embedded icon file
            HINSTANCE hInst = LoadLibraryEx(strExpPath, NULL, LOAD_LIBRARY_AS_DATAFILE);
            if (hInst)
            {
                hIcon = (HICON)LoadImage(hInst, MAKEINTRESOURCE(nBmpIndex), IMAGE_ICON, cx, cx, LR_DEFAULTCOLOR);
                FreeLibrary(hInst);
            }
        }
        if (hIcon != NULL)
        {
            // ISSUE/010304/davidjen
            //  assume that we only have non-alpha icons, could be smarter and look at bitmap
            hr = SetIcon(hIcon, false);
        }
    }
    else {
        hr = E_INVALIDARG;
    }
    return hr;
}

//------------------------------------------------------------------------
HRESULT
    CXBarGlyph::LoadDefaultGlyph(BOOL fSmall, BOOL fHot)
{
    HRESULT hr = E_FAIL;
    UINT id = ((SHGetCurColorRes() <= 8) ? IDB_IETOOLBAR: IDB_IETOOLBARHICOLOR);
    id += (fSmall ? 2 : 0) + (fHot ? 1 : 0);
    UINT cx = fSmall ? CX_SMALL_ICON : CX_LARGE_ICON;

    // We should use a cached default icon, rather than repeatedly crafting the default icon ourselves
    HICON hIcon = NULL;
    HIMAGELIST himl = ImageList_LoadImage(HINST_THISDLL,
                                          MAKEINTRESOURCE(id), cx, 0, 
                                          RGB(255, 0, 255),
                                          IMAGE_BITMAP, LR_CREATEDIBSECTION);
    if (himl)
    {
        hIcon = ImageList_GetIcon(himl, IBAR_ICON_DEFAULT, ILD_NORMAL);
        hr = SetIcon(hIcon, false);  // know that this is always non-alpha channel bitmap
        ImageList_Destroy(himl);
    }
    return hr;
}


//------------------------------------------------------------------------
HRESULT
    CXBarGlyph::Draw(HDC hdc, int x, int y)
{
    if (_hbmpColor)
    {
        BITMAP bm;
        GetObject(_hbmpColor, sizeof(bm), &bm);
        if (_fAlpha && (bm.bmBitsPixel >= 32) && IsOS(OS_WHISTLERORGREATER))
        {
            DrawAlphaBitmap(hdc, x, y, GetWidth(), GetHeight(), _hbmpColor);
        }
        else
        {
            DrawTransparentBitmap(hdc, x, y, _hbmpColor, _hbmpMask);
        }
    }
    else
    {
        return S_FALSE; // no glyph
    }
    return S_OK;
}

//------------------------------------------------------------------------
void
    CXBarGlyph::_EnsureDimensions(void)
{
    if (_hbmpColor == NULL)
    {
        _lWidth = _lHeight = 0;
        return;
    }

    // update dimensions of glyph
    if ((_lWidth <= 0) || (_lHeight <= 0))
    {
        BITMAP bm;
        GetObject(_hbmpColor, sizeof(bm), &bm);
        _lWidth = bm.bmWidth;
        _lHeight = bm.bmHeight;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\theater.cpp ===
#include "priv.h"
#include "theater.h"
#include "itbar.h"
#include "sccls.h"
#include "resource.h"
#include "brand.h"
#include "legacy.h"

#include "mluisupp.h"

#if defined(MAINWIN)
#include <mainwin.h>
#endif

#ifndef DISABLE_FULLSCREEN

#define IDT_INITIAL             1
#define IDT_UNHIDE              2
#define IDT_TOOLBAR             3
#define IDT_BROWBAR             4
#define IDT_TASKBAR             5
#define IDT_DELAY               6
#define IDT_HIDETOOLBAR         7
#define IDT_HIDEBROWBAR         8
#define IDT_HIDEFLOATER         9
#define IDT_HIDEFLOATER1SEC     10
#define IDT_INITIALBROWSERBAR   11

#define TF_THEATER              0

#define E_TOP       0
#define E_LEFT      1
#define E_RIGHT     2
#define E_BOTTOM    3

// association list.  sort of like dpa, but by association key rather than by index
// we need this because windows hooks are global and have no data associated with them.
// on the callback, we use our thread id as the key
CAssociationList CTheater::_al; // associate threadid with CTheater objects


// _GetWindowRectRel: gets window's coordinates relative to _hwndBrowser
BOOL CTheater::_GetWindowRectRel(HWND hWnd, LPRECT lpRect)
{
    BOOL bResult = GetWindowRect(hWnd, lpRect);
    if (bResult)
        MapWindowPoints(HWND_DESKTOP, _hwndBrowser, (LPPOINT)lpRect, 2);
    return bResult;
}

CTheater::CTheater(HWND hwnd, HWND hwndToolbar, IUnknown* punkOwner) :
   _hwndBrowser(hwnd), _hwndToolbar(hwndToolbar), _cRef(1)
{
    ASSERT(punkOwner);
    _punkOwner = punkOwner;
    _punkOwner->AddRef();

    _al.Add(GetCurrentThreadId(), this);

    _wp.length = SIZEOF(_wp);
    GetWindowPlacement(_hwndBrowser, &_wp);
    GetWindowRect(_hwndBrowser, &_rcOld);
#ifndef FULL_DEBUG
    SetWindowZorder(_hwndBrowser, HWND_TOPMOST);
#endif
    ShowWindow(_hwndBrowser, SW_MAXIMIZE);
    _Initialize();

    
    _fAutoHideBrowserBar = TRUE;
}

CTheater::~CTheater()
{
    SetWindowZorder(_hwndBrowser, HWND_NOTOPMOST);
    SetBrowserBar(NULL, 0, 0);
    if (_hhook)
    {
        UnhookWindowsHookEx(_hhook);
        _hhook = NULL;
    }
    _al.Delete(GetCurrentThreadId());
    
    KillTimer(_hwndFloater, IDT_UNHIDE);
    KillTimer(_hwndFloater, IDT_DELAY);
    KillTimer(_hwndFloater, IDT_HIDETOOLBAR);
    KillTimer(_hwndFloater, IDT_HIDEBROWBAR);

    if (_pdbBrand) {
        IUnknown_SetSite(_pdbBrand, NULL);
        _pdbBrand->CloseDW(0);
        _pdbBrand->Release();
    }
    
    if (_hwndClose) {
        HIMAGELIST himl = (HIMAGELIST)SendMessage(_hwndClose, TB_SETIMAGELIST, 0, 0);
        ImageList_Destroy(himl);
    }
    
    if (_hwndFloater) {
        DestroyWindow(_hwndFloater);

    }

    _punkOwner->Release();
}

BOOL CTheater::_IsBrowserActive()
{
    HRESULT hr = IUnknown_Exec(_punkOwner, &CGID_Explorer, SBCMDID_ISBROWSERACTIVE, 0, NULL, NULL);
    return (hr == S_OK);
}

void CTheater::_ShowTaskbar()
{    
    if (SHForceWindowZorder(_hwndTaskbar, HWND_TOPMOST))
        _fTaskbarShown = TRUE;
}

void CTheater::_HideTaskbar()
{
    if (_IsBrowserActive())
    {
        HWND hwnd = GetForegroundWindow();
        if (!GetCapture() && (SHIsChildOrSelf(_hwndTaskbar, hwnd) != S_OK))
        {
            if (SetWindowZorder(_hwndTaskbar, _hwndBrowser))
                _fTaskbarShown = FALSE;
        } 
    }
}

void CTheater::_ShowToolbar()
{
    if (!_fShown)
    {
        KillTimer(_hwndFloater, IDT_HIDETOOLBAR);                

        if (_hwndToolbar)
        {
            RECT rcParent;
            RECT rc;

            GetWindowRect(_hwndToolbar, &rc);
            GetClientRect(_hwndBrowser, &rcParent);
        
            IUnknown_Exec(_punkOwner, &CGID_PrivCITCommands, CITIDM_THEATER, THF_UNHIDE, NULL, NULL);
            
            SetWindowPos(_hwndToolbar, _hwndFloater, 0, 0, RECTWIDTH(rcParent), RECTHEIGHT(rc), SWP_NOACTIVATE | SWP_SHOWWINDOW);
            _ShowFloater();
        }        
        _fShown = TRUE;
    }
}

void CTheater::_HideToolbar()
{
    // don't start hiding if floater is still active
    if (!_cActiveRef) 
    {
        if (_fAutoHideToolbar && (GetCapture() == NULL) && !IsChild(_hwndToolbar, GetFocus()))
        {        
            _HideFloater();

            SetTimer(_hwndFloater, IDT_HIDETOOLBAR, 50, NULL);
            _cyLast = -1;
            _fShown = FALSE;       
        }
    }
}

void CTheater::_ContinueHideToolbar()
{
    while (1) {
        RECT rc;
        int cy;

        _GetWindowRectRel(_hwndToolbar, &rc);

#ifdef MAINWIN
    if (MwIsMwwmAllwm(_hwndBrowser))
    {
        // Simulating
        rc.right = rc.right - rc.left;
        rc.bottom = rc.bottom - rc.top;
        rc.top = 0;
        rc.bottom = 0;
    }
#endif

        cy = rc.bottom;
        OffsetRect(&rc, 0, -4);
        
        if (cy > 0 && cy != _cyLast) {
            RECT rcT;
            _GetWindowRectRel(_hwndToolbar, &rcT);
            
            SetWindowPos(_hwndToolbar, NULL, rcT.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
            UpdateWindow(_hwndToolbar);
            Sleep(10);
            _cyLast = cy;
        } else {
            IUnknown_Exec(_punkOwner, &CGID_PrivCITCommands, CITIDM_THEATER, THF_HIDE, NULL, NULL);
            ShowWindow(_hwndToolbar, SW_HIDE);

            // Hide floater and restore parenthood so msgs are picked up again
            ShowWindow(_hwndFloater, SW_HIDE);            
            SetParent(_hwndFloater, _hwndBrowser);            
            
            break;
        }
    }
}

void CTheater::_ShowBrowBar()
{
    if (!_fBrowBarShown)
    {
        RECT rc;        

        KillTimer(_hwndFloater, IDT_HIDEBROWBAR);
        _GetWindowRectRel(_hwndBrowBar, &rc);        

        rc.left = 0;
        rc.right = _cxBrowBarShown;
        SetWindowPos(_hwndBrowBar, _hwndToolbar, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOACTIVATE);

        _SanityCheckZorder();
        
        _fBrowBarShown = TRUE;
    }
}

void CTheater::_HideBrowBar()
{
    // don't start hiding if something has capture
    if (_fBrowBarShown && _CanHideWindow(_hwndBrowBar))
    {
        SetTimer(_hwndFloater, IDT_HIDEBROWBAR, 50, NULL);        
        _fBrowBarShown = FALSE;
        if (_fInitialBrowserBar)
            KillTimer(_hwndFloater, IDT_INITIALBROWSERBAR);                        
    }
}

// REARCHITECT: We should signal browser bar to suppress resizing during autohide.  Current scheme 
// works only because browser bar doesn't resize itself upon SetWindowPos to zero width.
void CTheater::_ContinueHideBrowBar()
{
    RECT rc;
    POINT pt;
    INT cxOffset, cxEdge;
    
    if (!_GetWindowRectRel(_hwndBrowBar, &rc))
        return;             // bail
    cxEdge = rc.left;
    
    if (_fInitialBrowserBar)
        cxOffset = -2;      // slow hide
    else
        cxOffset = -6;      // fast hide
    _fInitialBrowserBar = FALSE;
    
    while (rc.right > cxEdge)
    {
        // If mouse has moved over the bar, kill the hide
        GetCursorPos(&pt);
        MapWindowPoints(HWND_DESKTOP, _hwndBrowser, &pt, 1);
        if (PtInRect(&rc, pt))
        {
            _ShowBrowBar();
            return;
        }
        OffsetRect(&rc, cxOffset, 0);                
        SetWindowPos(_hwndBrowBar, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_NOACTIVATE);
        RedrawWindow(_hwndBrowBar, NULL, NULL, RDW_UPDATENOW | RDW_ALLCHILDREN);
        Sleep(5);
    }
}

BOOL CTheater::_CanHideWindow(HWND hwnd)
{
    return (!GetCapture() && !IsChild(hwnd, GetFocus()));
}

void CTheater::_ShowFloater()
{    
    if (!_fFloaterShown) 
    {
        _fFloaterShown = TRUE;
        SetParent(_hwndFloater, _hwndBrowser);

        KillTimer(_hwndFloater, IDT_HIDEFLOATER);
        
        _SizeFloater();
        SetWindowPos(_hwndFloater, HWND_TOP, 0, 0, 0, 0, SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);
        InvalidateRect(_hwndFloater, NULL, TRUE);
        UpdateWindow(_hwndFloater);
        
        ShowWindow(_hwndFloater, SW_SHOW);
        if (!_fShown && _fAutoHideToolbar)
            _DelayHideFloater();
    }    
}

void CTheater::_DelayHideFloater()
{
    if (!_cActiveRef)
    {
        SetTimer(_hwndFloater, IDT_HIDEFLOATER1SEC, 1000, NULL);
    }
}

void CTheater::_HideFloater()
{
    if (_fAutoHideToolbar && _fFloaterShown)
    {
        if (!_fShown)
        {
            // don't start hiding if something has capture
            if (_CanHideWindow(_hwndFloater))
            {
                SetTimer(_hwndFloater, IDT_HIDEFLOATER, 50, NULL);        
                _fFloaterShown = FALSE;
                ASSERT(!_cActiveRef);
                _cActiveRef++;
                return;
            }
            else
            {
                _DelayHideFloater();
            }
        }
        else
        {
            SetParent(_hwndFloater, _hwndToolbar);
            _fFloaterShown = FALSE;
        }
    }
}

void CTheater::_ContinueHideFloater()
{
    while (1) 
    {
        RECT rc;        
        _GetWindowRectRel(_hwndFloater, &rc);        

        rc.left += 6;
        
        if (rc.left < rc.right) 
        {            
            SetWindowPos(_hwndFloater, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), SWP_NOZORDER | SWP_NOACTIVATE);
            UpdateWindow(_hwndFloater);
            Sleep(5);            
        } 
        else 
        {                        
            ShowWindow(_hwndFloater, SW_HIDE);
            _cActiveRef--;            
            break;
        }
    }
}

void CTheater::_Unhide(int iWhich, UINT uDelay)
{
    _iUnhidee = iWhich;
    SetTimer(_hwndFloater, IDT_UNHIDE, uDelay, NULL);    
}

BOOL CTheater::_PtNearWindow(POINT pt, HWND hwnd)
{
    RECT rc;

    _GetWindowRectRel(hwnd, &rc);
    InflateRect(&rc, 60, 60);
    return (PtInRect(&rc, pt));
}

int GetWindowHeight(HWND hwnd)
{
    ASSERT(hwnd);

    RECT rc;
    GetWindowRect(hwnd, &rc);
    return RECTHEIGHT(rc);
}

BOOL CTheater::_PtOnEdge(POINT pt, int iEdge)
{
    RECT rc;
    _GetWindowRectRel(_hwndBrowser, &rc);    

    switch (iEdge)
    {
        case E_LEFT:
            rc.right = rc.left + CX_HIT;
            goto leftright;

        case E_RIGHT:
            rc.left = rc.right - CX_HIT;
leftright:
            rc.top += GetWindowHeight(_hwndToolbar);
            rc.bottom -= GetSystemMetrics(SM_CXVSCROLL);
            break;

        case E_TOP:
            rc.bottom = rc.top + CX_HIT;
            goto topbottom;

        case E_BOTTOM:
            rc.top = rc.bottom - CX_HIT;
topbottom:
            InflateRect(&rc, - GetSystemMetrics(SM_CXVSCROLL), 0);
            break;
    }
    return (PtInRect(&rc, pt));
}

LRESULT CTheater::_OnMsgHook(int nCode, WPARAM wParam, MOUSEHOOKSTRUCT *pmhs, BOOL fFake)
{    
    if (nCode >= 0) 
    {
        POINT pt;
        GetCursorPos(&pt);
        MapWindowPoints(HWND_DESKTOP, _hwndBrowser, &pt, 1);

        BOOL bTryUnhideTaskbar = !_fTaskbarShown;

        // The timer business is so that we don't unhide 
        // on a user trying to get to the scrollbar
        if (_iUnhidee) 
        {
            KillTimer(_hwndFloater, IDT_UNHIDE);
            _iUnhidee = 0;
        }
        
        if (_PtOnEdge(pt, E_LEFT))
        {
            if (!_fBrowBarShown && _hwndBrowBar)
                _Unhide(IDT_BROWBAR, SHORT_DELAY);
        }
        else if (_PtOnEdge(pt, E_TOP))
        {
            if (!_fShown)
                _Unhide(IDT_TOOLBAR, SHORT_DELAY);
        }
        else if (!_PtOnEdge(pt, E_RIGHT) && !_PtOnEdge(pt, E_BOTTOM))
        {
            bTryUnhideTaskbar = FALSE;
        }
        
#ifndef UNIX
        if (bTryUnhideTaskbar && !_fDelay && !_iUnhidee)
        {
            RECT rc;
            _GetWindowRectRel(_hwndTaskbar, &rc);
            if (PtInRect(&rc, pt))
                _Unhide(IDT_TASKBAR, GetCapture() ? LONG_DELAY : SHORT_DELAY);
        }
#endif

        if (_fAutoHideBrowserBar && _fBrowBarShown && !_PtNearWindow(pt, _hwndBrowBar))
            _HideBrowBar();
        
        if (_fAutoHideToolbar && _fShown && !_PtNearWindow(pt, _hwndToolbar))
            _HideToolbar();        
        
#ifndef UNIX
        if (_fTaskbarShown && !_PtNearWindow(pt, _hwndTaskbar))
           _HideTaskbar();
#endif
    }

    if (fFake)
        return 0;
    else
        return CallNextHookEx(_hhook, nCode, wParam, (LPARAM)pmhs);
}

LRESULT CTheater::_MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    CTheater* pTheater;
    if (SUCCEEDED(_al.Find(GetCurrentThreadId(), (LPVOID*)&pTheater)))
    {
        return pTheater->_OnMsgHook(nCode, wParam, (MOUSEHOOKSTRUCT*)lParam, FALSE);
    }
    return 0;
}

void CTheater::Begin()
{
    _ShowToolbar();    
    SetTimer(_hwndFloater, IDT_INITIAL, 1500, NULL);
}

void CTheater::_SizeBrowser()
{
    // position & size the browser window
    RECT rc;
    HMONITOR hMon = MonitorFromWindow(_hwndBrowser, MONITOR_DEFAULTTONEAREST);
    GetMonitorRect(hMon, &rc);
    InflateRect(&rc, CX_BROWOVERLAP, CX_BROWOVERLAP);
    SetWindowPos(_hwndBrowser, HWND_TOP, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc), 0);
}

void CTheater::_SizeFloater()
{
    // position & size the floater
    RECT rc;
    GetWindowRect(_hwndBrowser, &rc);
    int x = RECTWIDTH(rc) - (CX_FLOATERSHOWN + CX_BROWOVERLAP);
    int y = 0;

    int cy = GetWindowHeight(_hwndToolbar);

    SetWindowPos(_hwndFloater, HWND_TOP, x, y, CX_FLOATERSHOWN, cy, SWP_NOACTIVATE);
}

void CTheater::_CreateCloseMinimize()
{
    _hwndClose = CreateWindowEx( WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                WS_VISIBLE | WS_CHILD | 
                                TBSTYLE_TOOLTIPS | TBSTYLE_FLAT | TBSTYLE_TRANSPARENT |
                                WS_CLIPCHILDREN | WS_CLIPSIBLINGS | 
                                CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 0,
                                CLOSEMIN_WIDTH, CLOSEMIN_HEIGHT,
                                _hwndFloater, 0, HINST_THISDLL, NULL);

    if (_hwndClose) {
        static const TBBUTTON tb[] =
        {
            { 0, SC_MINIMIZE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 },
            { 1, SC_RESTORE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 },
            { 2, SC_CLOSE, TBSTATE_ENABLED, TBSTYLE_BUTTON, {0,0}, 0, 0 }
        };

        HIMAGELIST himl = ImageList_LoadImage(HINST_THISDLL,
                                              MAKEINTRESOURCE(IDB_THEATERCLOSE),
                                              10, 0, RGB(255,0,255),
                                              IMAGE_BITMAP, LR_CREATEDIBSECTION);
        ImageList_SetBkColor(himl, RGB(0,0,0));

        SendMessage(_hwndClose, TB_SETIMAGELIST, 0, (LPARAM)himl);
        SendMessage(_hwndClose, TB_BUTTONSTRUCTSIZE,    SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndClose, TB_ADDBUTTONS, ARRAYSIZE(tb), (LPARAM)tb);
        SendMessage(_hwndClose, TB_SETMAXTEXTROWS,      0, 0L);
        TBBUTTONINFO tbbi;
        TCHAR szBuf[256];
        tbbi.cbSize = SIZEOF(TBBUTTONINFO);
        tbbi.dwMask = TBIF_TEXT;
        tbbi.pszText = szBuf;
        MLLoadString(IDS_CLOSE, szBuf, ARRAYSIZE(szBuf));
        SendMessage(_hwndClose, TB_SETBUTTONINFO, SC_CLOSE, (LPARAM)&tbbi);
        MLLoadString(IDS_RESTORE, szBuf, ARRAYSIZE(szBuf));
        SendMessage(_hwndClose, TB_SETBUTTONINFO, SC_RESTORE, (LPARAM)&tbbi);
        MLLoadString(IDS_MINIMIZE, szBuf, ARRAYSIZE(szBuf));
        SendMessage(_hwndClose, TB_SETBUTTONINFO, SC_MINIMIZE, (LPARAM)&tbbi);
    }    
}

void CTheater::_Initialize()
{
    _SizeBrowser();
    
#ifndef UNIX
    _hwndTaskbar = FindWindow(TEXT("Shell_TrayWnd"), NULL);

#ifdef DEBUG
    if (!_hwndTaskbar)
    {
        TraceMsg(TF_WARNING, "CTheater::_Initialize -- couldn't find taskbar window");
    }
#endif // DEBUG

#else
    _hwndTaskbar   = NULL;
#endif
    _fTaskbarShown = FALSE;

    _hwndFloater = SHCreateWorkerWindow(_FloaterWndProc, _hwndBrowser,  
#if defined(MAINWIN)
                                      // Removing window manager decors
                                      WS_EX_MW_UNMANAGED_WINDOW |
#endif
                                      WS_EX_TOOLWINDOW, 
                                      WS_CHILD | WS_CLIPCHILDREN | WS_CLIPSIBLINGS, NULL, this);
    if (_hwndFloater) {

        int cx = 0;        
        
        // create animating E logo
        IUnknown* punk;
        CBrandBand_CreateInstance(NULL, (IUnknown **)&punk, NULL);
        if (punk) {
            punk->QueryInterface(IID_IDeskBand, (LPVOID*)&_pdbBrand);
            if (_pdbBrand) {
                HWND hwndBrand;
                
                IUnknown_SetSite(_pdbBrand, SAFECAST(this, IOleWindow*));                                
                IUnknown_GetWindow(_pdbBrand, &hwndBrand);
                                
                ASSERT(hwndBrand);
#ifdef DEBUG
                // Make sure brand isn't too tall
                DESKBANDINFO dbi = {0};
                _pdbBrand->GetBandInfo(0, 0, &dbi);
                ASSERT(!(dbi.ptMinSize.y > BRAND_HEIGHT));
#endif
                if (hwndBrand) 
                {
                    SetWindowPos(hwndBrand, NULL, 
                        cx, BRAND_YOFFSET, BRAND_WIDTH, BRAND_HEIGHT,
                        SWP_NOZORDER | SWP_SHOWWINDOW);
                    cx += BRAND_WIDTH + CLOSEMIN_XOFFSET;                    
                }
                // get floater background color
                VARIANTARG var = {VT_I4};
                IUnknown_Exec(_pdbBrand, &CGID_PrivCITCommands, CITIDM_GETDEFAULTBRANDCOLOR, 0, NULL, &var);
                _clrBrandBk = (COLORREF) var.lVal;
            }
            punk->Release();
        }
        
        // now create the progress bar        
        _hwndProgress = CreateWindowEx(0, PROGRESS_CLASS, NULL,
                                       WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS | PBS_SMOOTH,
                                       cx - 1, PROGRESS_YPOS, 
                                       PROGRESS_WIDTH, PROGRESS_HEIGHT,
                                       _hwndFloater, (HMENU)TMC_PROGRESSBAR,
                                       HINST_THISDLL, NULL);
        if (_hwndProgress)
        {
            SendMessage(_hwndProgress, PBM_SETBKCOLOR, 0, _clrBrandBk);
            SendMessage(_hwndProgress, PBM_SETBARCOLOR, 0, GetSysColor(COLOR_BTNSHADOW));

            // hack of the 3d client edge that WM_BORDER implies in dialogs
            // add the 1 pixel static edge that we really want
            SHSetWindowBits(_hwndProgress, GWL_EXSTYLE, WS_EX_STATICEDGE, 0);
            SetWindowPos(_hwndProgress, NULL, 0,0,0,0, 
                SWP_NOSIZE | SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
        }
        
        // make the close/minimize buttons & position them
        _CreateCloseMinimize();
        if (_hwndClose)
        {
            SetWindowPos(_hwndClose, HWND_TOP, cx, CLOSEMIN_YOFFSET, 0, 0, 
                SWP_NOSIZE | SWP_NOACTIVATE);
        }

        _SizeFloater();
    }
}

void CTheater::_SwapParents(HWND hwndOldParent, HWND hwndNewParent)
{
    HWND hwnd = ::GetWindow(hwndOldParent, GW_CHILD);

    while (hwnd) {
        //
        //  Note that we must get the next sibling BEFORE we set the new
        // parent.
        //
        HWND hwndNext = ::GetWindow(hwnd, GW_HWNDNEXT);
        if (hwnd != _hwndToolbar) {
            ::SetParent(hwnd, hwndNewParent);
        }
        hwnd = hwndNext;
    }
}

//////  begin floating palette (floater) window implementation
///  
/// floater keeps a ref count of activation (via command target)
/// when the last activity goes away, it sets a timer and hides after a second.
/// this is a regional window that will host the animation icon, progress bar, and 
/// close / minimize buttons

ULONG CTheater::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTheater::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTheater::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTheater, IOleWindow),
        QITABENT(CTheater, IOleCommandTarget),
        QITABENT(CTheater, IServiceProvider),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CTheater::GetWindow(HWND * lphwnd) 
{
    *lphwnd = _hwndFloater; 
    if (_hwndFloater)
        return S_OK; 
    return E_FAIL;
}

void CTheater::_SanityCheckZorder()
{
    //
    // The view may have jumped to HWND_TOP, so we need to
    // fix up the floater, toolbar, and browbar positions
    // within the z-order.
    //
    SetWindowZorder(_hwndFloater, HWND_TOP);
    SetWindowZorder(_hwndToolbar, _hwndFloater);
    SetWindowZorder(_hwndBrowBar, _hwndToolbar);
}

HRESULT CTheater::QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds, 
                                  OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    return OLECMDERR_E_UNKNOWNGROUP;
}

HRESULT CTheater::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, 
                           VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = OLECMDERR_E_NOTSUPPORTED;
    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_Theater, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case THID_ACTIVATE:
            _cActiveRef++;
            if (_cActiveRef == 1)
                _ShowFloater();            
            break;
            
        case THID_DEACTIVATE:
            // we can get a deactivate before the first activate if 
            // we come up during a navigate
            if (_cActiveRef > 0)
            {
                _cActiveRef--;               
                _DelayHideFloater();
            }
            break;
            
        case THID_SETBROWSERBARAUTOHIDE:
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                _fAutoHideBrowserBar = pvarargIn->lVal;
                if (!_fAutoHideBrowserBar)
                {
                    // clear initial hide anymore.  they are well aware of it if
                    // they hit this switch
                    _fInitialBrowserBar = FALSE;
                    _ShowBrowBar();
                }
            }            
            break;
            
        case THID_SETBROWSERBARWIDTH:
            if (pvarargIn && pvarargIn->vt == VT_I4)
                _cxBrowBarShown = pvarargIn->lVal;
            break;
            
        case THID_SETTOOLBARAUTOHIDE:
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                _fAutoHideToolbar = pvarargIn->lVal;
                if (pvarargIn->lVal)
                    _HideToolbar();
                else                             
                    _ShowToolbar();                                    
            }
            break;         

        case THID_ONINTERNET:
            IUnknown_Exec(_pdbBrand, &CGID_PrivCITCommands, CITIDM_ONINTERNET, nCmdexecopt, pvarargIn, pvarargOut);
            break;

        case THID_RECALCSIZING:
            RecalcSizing();
            break;
        }
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SBCMDID_ONVIEWMOVETOTOP:
            _SanityCheckZorder();
            hres = S_OK;
            break;
        }
    }
    
    return hres;
}

void CTheater::_OnCommand(UINT idCmd)
{
    PostMessage(_hwndBrowser, WM_SYSCOMMAND, idCmd, 0);
}

LRESULT CTheater::_FloaterWndProc(HWND  hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CTheater *t = (CTheater*)GetWindowPtr0(hwnd);
    if (!t)
        return 0;

    switch (uMsg)
    {
    case WM_COMMAND:
        t->_OnCommand(GET_WM_COMMAND_ID(wParam, lParam));
        break;

    case WM_CLOSE:
    case WM_NOTIFY:
        return SendMessage(t->_hwndBrowser, uMsg, wParam, lParam);

    case WM_TIMER:
    {           
        switch (wParam) {

        case IDT_HIDEFLOATER1SEC:
            t->_HideFloater();
            break;                       

        case IDT_INITIALBROWSERBAR:
            // _fAutoHideBrowserBar may have changed after the timer was set
            if (t->_fAutoHideBrowserBar)
                t->_HideBrowBar();
            return 1;
            
        case IDT_INITIAL:
            {
                t->_HideToolbar();
                t->_hhook = SetWindowsHookEx(WH_MOUSE, _MsgHook, MLGetHinst(), GetCurrentThreadId());

                HWND hwndInsertAfter;
                if (t->_IsBrowserActive())
                {
                    // We're active, just move to non-topmost
                    hwndInsertAfter = HWND_NOTOPMOST;
                }
                else
                {
                    // Another window became active while we were
                    // moving to fullscreen mode; move ourselves below
                    // that window.  We need to walk up the parent chain
                    // so that if the window has a modal dialog open we
                    // won't insert ourselves between the dialog and the
                    // app.
                    hwndInsertAfter = GetForegroundWindow();
                    HWND hwnd;
                    while (hwnd = GetParent(hwndInsertAfter))
                    {
                        hwndInsertAfter = hwnd;
                    }
                }

                SetWindowZorder(t->_hwndBrowser, hwndInsertAfter);

                // Call the hook handler manually to insure that even if there's no mouse
                // movement the handler will get called once.  That way, bar unhiding will
                // still work if the user has already given up and stopped moving the mouse.

                t->_OnMsgHook(0, 0, NULL, TRUE);
            }

            break;
            
        case IDT_UNHIDE:
            switch (t->_iUnhidee)
            {
                case IDT_TOOLBAR:
                    t->_ShowToolbar();
                    break;
                
                case IDT_BROWBAR:
                    t->_ShowBrowBar();
                    break;
                
                case IDT_TASKBAR:
                    t->_ShowTaskbar();
                    break;

            }
            SetTimer(t->_hwndFloater, IDT_DELAY, LONG_DELAY, NULL);
            t->_fDelay = TRUE;            
            t->_iUnhidee = 0;
            break;

        case IDT_DELAY:
            t->_fDelay = FALSE;
            break;        
            
        case IDT_HIDETOOLBAR:
            t->_ContinueHideToolbar();
            break;
            
        case IDT_HIDEBROWBAR:
            t->_ContinueHideBrowBar();
            break;

        case IDT_HIDEFLOATER:
            t->_ContinueHideFloater();
            break;
        }
        KillTimer(hwnd, wParam);
        break;
    }

    case WM_SETTINGCHANGE:
        if (wParam == SPI_SETNONCLIENTMETRICS)
        {
            t->RecalcSizing();
        }
        break;

    case WM_ERASEBKGND:
    {
        HDC hdc = (HDC)wParam;
        RECT rc;
        GetClientRect(hwnd, &rc);
        SHFillRectClr(hdc, &rc, t->_clrBrandBk);        
        return 1;
    }        

    default:
        return ::DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
    }        

    return 0;
}

void CTheater::RecalcSizing()
{
    _SizeBrowser();
    _SizeFloater();
}

HRESULT CTheater::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_punkOwner, guidService, riid, ppvObj);
}

HRESULT CTheater::SetBrowserBar(IUnknown* punk, int cxHidden, int cxExpanded)
{
    if (punk != _punkBrowBar) {
        IUnknown_Exec(_punkBrowBar, &CGID_Theater, THID_DEACTIVATE, 0, NULL, NULL);
        ATOMICRELEASE(_punkBrowBar);

        IUnknown_GetWindow(punk, &_hwndBrowBar);
        _punkBrowBar = punk;
        if (punk)
            punk->AddRef();
    
        if (_hwndBrowBar) 
        {
            _cxBrowBarShown = cxExpanded;
            
            // tell the browser bar to only ever request the hidden window size
            VARIANT var = { VT_I4 };
            var.lVal = _fAutoHideBrowserBar;
            IUnknown_Exec(_punkBrowBar, &CGID_Theater, THID_ACTIVATE, 0, &var, &var);
            _fAutoHideBrowserBar = var.lVal;            
        }
    } 

    if (punk) {
        if (_hwndBrowBar)
            _ShowBrowBar();                
   
        // if we're in autohide mode, the first hide should be slow
        if (_fAutoHideBrowserBar) {
            _fInitialBrowserBar = TRUE;        
            SetTimer(_hwndFloater, IDT_INITIALBROWSERBAR, 1000, NULL);
        }
    }
    return S_OK;
}

#endif /* !DISABLE_FULLSCREEN */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\util.cpp ===
#include "priv.h"
#include "sccls.h"
#include "mlang.h"  // fo char conversion
#include "bandprxy.h"
#include "resource.h"
#include <shdocvw.h>
#include <icwcfg.h>
#include <advpub.h> // for IE activesetup GUID
#include <shellapi.h>
#include "apithk.h" //for WM_KEYBOARDCUES msg
#include <platform.h>
#include <mobsync.h>
#include <mobsyncp.h>

#include "..\shell32\shitemid.h"    // for SHID_XX

#ifdef UNIX
#include "unixstuff.h"
#endif /* UNIX */

#define MLUI_INIT
#include "mluisupp.h"

//small (previously duplicated) functions shared between shdcovw and browseui
#include "..\inc\brutil.cpp"

// #define MLUI_SUPPORT   1

LCID g_lcidLocale = MAKELCID(LANG_USER_DEFAULT, SORT_DEFAULT);

#define DM_NAV              TF_SHDNAVIGATE
#define DM_ZONE             TF_SHDNAVIGATE
#define DM_IEDDE            DM_TRACE
#define DM_CANCELMODE       0
#define DM_UIWINDOW         0
#define DM_ENABLEMODELESS   0
#define DM_EXPLORERMENU     0
#define DM_BACKFORWARD      0
#define DM_PROTOCOL         0
#define DM_ITBAR            0
#define DM_STARTUP          0
#define DM_AUTOLIFE         0
#define DM_PALETTE          0

const VARIANT c_vaEmpty = {0};
const LARGE_INTEGER c_li0 = { 0, 0 };


#undef VariantCopy

WINOLEAUTAPI VariantCopyLazy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc)
{
    VariantClearLazy(pvargDest);

    switch(pvargSrc->vt)
    {
    case VT_I4:
    case VT_UI4:
    case VT_BOOL:
        // we can add more
        *pvargDest = *pvargSrc;
        return S_OK;

    case VT_UNKNOWN:
        if (pvargDest)
        {
            *pvargDest = *pvargSrc;
            pvargDest->punkVal->AddRef();
            return S_OK;
        }
        ASSERT(0);
        return E_INVALIDARG;
    }

    return VariantCopy(pvargDest, pvargSrc);
}

//
// WARNING: This function must be placed at the end because we #undef
// VariantClear
//
#undef VariantClear

HRESULT VariantClearLazy(VARIANTARG *pvarg)
{
    switch(pvarg->vt)
    {
    case VT_I4:
    case VT_UI4:
    case VT_EMPTY:
    case VT_BOOL:
        // No operation
        break;

    default:
        return VariantClear(pvarg);
    }
    return S_OK;
}


HRESULT QueryService_SID_IBandProxy(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj)
{
    HRESULT hr = E_FAIL;

    if (ppbp)
    {
        if (NULL == (*ppbp))
            hr = IUnknown_QueryService(punkParent, SID_IBandProxy, IID_PPV_ARG(IBandProxy, ppbp));

        if (*ppbp && ppvObj)
            hr = (*ppbp)->QueryInterface(riid, ppvObj);        // They already have the object.
    }


    return hr;
}

HRESULT CreateIBandProxyAndSetSite(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj)
{
    ASSERT(ppbp);

    HRESULT hr = CoCreateInstance(CLSID_BandProxy, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandProxy, ppbp));
    if (SUCCEEDED(hr))
    {
        // Set the site
        ASSERT(*ppbp);
        (*ppbp)->SetSite(punkParent);

        if (ppvObj)
            hr = (*ppbp)->QueryInterface(riid, ppvObj);
    }
    else
    {
        if (ppvObj)
            *ppvObj = NULL;
    }
    return hr;
}

HRESULT IUnknown_FileSysChange(IUnknown* punk, DWORD dwEvent, LPCITEMIDLIST* ppidl)
{
    HRESULT hres = E_FAIL;
    if (punk)
    {
        IAddressBand * pab;
        hres = punk->QueryInterface(IID_PPV_ARG(IAddressBand, &pab));
        if (SUCCEEDED(hres))
        {
            hres = pab->FileSysChange(dwEvent, ppidl);
            pab->Release();
        }
    }
    return hres;
}


UINT    g_cfURL = 0;
UINT    g_cfHIDA = 0;
UINT    g_cfFileDescA = 0;
UINT    g_cfFileDescW = 0;
UINT    g_cfFileContents = 0;
UINT    g_cfPreferedEffect = 0;

void InitClipboardFormats()
{
    if (g_cfURL == 0)
    {
        g_cfURL = RegisterClipboardFormat(CFSTR_SHELLURL);
        g_cfHIDA = RegisterClipboardFormat(CFSTR_SHELLIDLIST);
        g_cfFileDescA = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORA);
        g_cfFileDescW = RegisterClipboardFormat(CFSTR_FILEDESCRIPTORW);
        g_cfFileContents = RegisterClipboardFormat(CFSTR_FILECONTENTS);
        g_cfPreferedEffect = RegisterClipboardFormat(CFSTR_PREFERREDDROPEFFECT);
    }
}

DEFFOLDERSETTINGS g_dfs = INIT_DEFFOLDERSETTINGS;

void _InitDefaultFolderSettings()
{
    if (GetSystemMetrics(SM_CLEANBOOT))
        return;

    g_dfs.vid = g_bRunOnNT5 ? VID_LargeIcons : DFS_VID_Default;

    DEFFOLDERSETTINGS dfs = g_dfs;
    DWORD dwType, cbData = sizeof(dfs);

    if (SUCCEEDED(SKGetValue(SHELLKEY_HKCU_EXPLORER, REGVALUE_STREAMS, TEXT("Settings"), &dwType, &dfs, &cbData)) 
    && dwType == REG_BINARY)
    {
        if (cbData < sizeof(DEFFOLDERSETTINGS_W2K) || dfs.dwStructVersion < DFS_NASH_VER)
        {
            dfs.vid = g_bRunOnNT5 ? VID_LargeIcons : DFS_VID_Default;
            dfs.dwStructVersion = DFS_NASH_VER;
            dfs.bUseVID = TRUE;
        }

        if (cbData < sizeof(DEFFOLDERSETTINGS) || dfs.dwStructVersion < DFS_WHISTLER_VER)
        {
            dfs.dwViewPriority = VIEW_PRIORITY_CACHEMISS;
            dfs.dwStructVersion = DFS_WHISTLER_VER;
        }

        g_dfs = dfs;
    }
}

CABINETSTATE g_CabState = { 0 };
extern HANDLE g_hCabStateChange;
LONG g_lCabStateCount = -1;     // never a valid count

void GetCabState(CABINETSTATE *pcs)
{
    if (g_hCabStateChange == NULL)
        g_hCabStateChange = SHGlobalCounterCreate(GUID_FolderSettingsChange);

    LONG lCabStateCur = SHGlobalCounterGetValue(g_hCabStateChange);
    if (g_lCabStateCount != lCabStateCur)
    {
        g_lCabStateCount = lCabStateCur;
        if (!ReadCabinetState(&g_CabState, sizeof(g_CabState)))
        {
            WriteCabinetState(&g_CabState);
        }
    }
    *pcs = g_CabState;
}

typedef struct tagINIPAIR
{
    DWORD dwFlags;
    LPCTSTR pszSection;
}
INIPAIR, *PINIPAIR;

const INIPAIR c_aIniPairs[] =
{
    EICH_KINET,          TEXT("Software\\Microsoft\\Internet Explorer"),
    EICH_KINETMAIN,      TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
    EICH_KWIN,           TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
    EICH_KWINEXPLORER,   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer"),
    EICH_KWINEXPLSMICO,  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SmallIcons"),
    EICH_KWINPOLICY,     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies"),
    EICH_SSAVETASKBAR,   TEXT("SaveTaskbar"),
    EICH_SWINDOWMETRICS, TEXT("WindowMetrics"),
    EICH_SSHELLMENU,     TEXT("ShellMenu"),
    EICH_SPOLICY,        TEXT("Policy"),
    EICH_SWINDOWS,       TEXT("Windows"),
};

DWORD SHIsExplorerIniChange(WPARAM wParam, LPARAM lParam)
{
    DWORD dwFlags = 0;

    if (lParam == 0)
    {
        if (wParam == 0)
        {
            dwFlags = EICH_UNKNOWN;
        }
    }
    else
    {
        //
        // In the wacky world of browseui, UNICODE-ANSI doesn't vary from
        // window to window.  Instead, on NT browseui registers all windows
        // UNICODE, while on 9x user browseui registers all windows ANSI.
        //
        LPCTSTR pszSection;
        TCHAR szTemp[MAX_PATH];     // not a filename, but a section/registry key name

        if (g_fRunningOnNT)
        {
#ifdef UNICODE
            pszSection = (LPCTSTR)lParam;
#else
            UINT cch = WideCharToMultiByte(CP_ACP, 0, (LPCWSTR)lParam, -1, szTemp, ARRAYSIZE(szTemp), NULL, NULL);
            if (cch == 0)
            {
                szTemp[0] = TEXT('\0'); // it won't compare
            }
#endif
        }
        else
        {
#ifdef UNICODE
            UINT cch = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lParam, -1, szTemp, ARRAYSIZE(szTemp));
            if (cch == 0)
            {
                szTemp[0] = TEXT('\0'); // it won't compare
            }
#else
            pszSection = (LPCTSTR)lParam;
#endif
        }

        for (int i = 0; !dwFlags && i < ARRAYSIZE(c_aIniPairs); i++)
        {
            if (StrCmpI(pszSection, c_aIniPairs[i].pszSection) == 0)
            {
                dwFlags = c_aIniPairs[i].dwFlags;
            }
        }
    }

    return dwFlags;
}

void _InitAppGlobals()
{
    static BOOL fInitialized = FALSE;
    if (!fInitialized)
    {
        _InitComCtl32();
        _InitDefaultFolderSettings();

        // dont put anything else here. instead init on demand

        fInitialized = TRUE;        // allow a race on the above calls
    }
}

BOOL _InitComCtl32()
{
    static BOOL fInitialized = FALSE;
    if (!fInitialized)
    {
        INITCOMMONCONTROLSEX icc;

        icc.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icc.dwICC = ICC_USEREX_CLASSES | ICC_COOL_CLASSES | ICC_INTERNET_CLASSES | ICC_PAGESCROLLER_CLASS
            | ICC_NATIVEFNTCTL_CLASS;
        fInitialized = InitCommonControlsEx(&icc);
    }
    return fInitialized;
}


DWORD GetPreferedDropEffect(IDataObject *pdtobj)
{
    InitClipboardFormats();

    DWORD dwEffect = 0;
    STGMEDIUM medium;
    DWORD *pdw = (DWORD *)DataObj_GetDataOfType(pdtobj, g_cfPreferedEffect, &medium);
    if (pdw)
    {
        dwEffect = *pdw;
        ReleaseStgMediumHGLOBAL(pdw,&medium);
    }
    return dwEffect;
}

HRESULT _SetPreferedDropEffect(IDataObject *pdtobj, DWORD dwEffect)
{
    InitClipboardFormats();

    HRESULT hres = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(*pdw));
    if (pdw)
    {
        STGMEDIUM medium;
        FORMATETC fmte = {g_cfPreferedEffect, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        *pdw = dwEffect;

        medium.tymed = TYMED_HGLOBAL;
        medium.hGlobal = pdw;
        medium.pUnkForRelease = NULL;

        hres = pdtobj->SetData(&fmte, &medium, TRUE);

        if (FAILED(hres))
            GlobalFree((HGLOBAL)pdw);
    }
    return hres;
}

//***   Reg_GetStrs -- get values from registry, assign to struct
void Reg_GetStrs(HKEY hkey, const struct regstrs *tab, LPTSTR szBuf, int cchBuf, void *pv)
{
    for (; tab->name != NULL; tab++)
    {
        ULONG cbTmp = cchBuf;

        // NOTE: IE4 did *NOT* support SHLoadRegUIString, so don't call Reg_GetStrs
        // on roamable data.  (Or at least don't register plugui strings there.)
        if (ERROR_SUCCESS == SHLoadRegUIString(hkey, tab->name, szBuf, cbTmp))
        {
            // pv->field = StrDup(szBuf)
            *(LPTSTR *)((char *)pv + tab->off) = StrDup(szBuf);
        }
    }
    return;
}

BOOL g_fNewNotify = FALSE;   // Are we using classic mode (W95 or new mode?
PFNSHCHANGENOTIFYREGISTER    g_pfnSHChangeNotifyRegister = NULL;
PFNSHCHANGENOTIFYDEREGISTER  g_pfnSHChangeNotifyDeregister = NULL;

#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, _ord)

BOOL _DelayLoadRegisterNotify(void)
{
    // See if we need to still figure out which version of SHChange Notify to call?
    if  (g_pfnSHChangeNotifyDeregister == NULL)
    {
        // This should never fail, since we are load-time-linked to SHELL32
        HMODULE hmodShell32 = GetModuleHandleA("SHELL32.DLL");
        if (hmodShell32)
        {
            g_pfnSHChangeNotifyRegister = (PFNSHCHANGENOTIFYREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32, "NTSHChangeNotifyRegister",MAKEINTRESOURCEA(640));
            if (g_pfnSHChangeNotifyRegister && (WhichPlatform() == PLATFORM_INTEGRATED))
            {
                g_pfnSHChangeNotifyDeregister = (PFNSHCHANGENOTIFYDEREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32,"NTSHChangeNotifyDeregister", MAKEINTRESOURCEA(641));
                g_fNewNotify = TRUE;
            }
            else
            {
                g_pfnSHChangeNotifyRegister = (PFNSHCHANGENOTIFYREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32, "SHChangeNotifyRegister", MAKEINTRESOURCEA(2));
                g_pfnSHChangeNotifyDeregister = (PFNSHCHANGENOTIFYDEREGISTER)GET_PRIVATE_PROC_ADDRESS(hmodShell32, "SHChangeNotifyDeregister",MAKEINTRESOURCEA(4));
            }
        }
    }
    return (NULL == g_pfnSHChangeNotifyDeregister) ? FALSE : TRUE;
}

ULONG RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive)
{
    if (_DelayLoadRegisterNotify())
    {
        SHChangeNotifyEntry fsne;

        if (g_fNewNotify)
            uFlags |= SHCNRF_NewDelivery;

        fsne.fRecursive = fRecursive;
        fsne.pidl = pidl;
        return g_pfnSHChangeNotifyRegister(hwnd, uFlags, dwEvents, nMsg, 1, &fsne);
    }
    return 0;
}

int PropBag_ReadInt4(IPropertyBag* pPropBag, LPWSTR pszKey, int iDefault)
{
    SHPropertyBag_ReadInt(pPropBag, pszKey, &iDefault);
    return iDefault;
}


STDAPI_(BOOL) _EnsureLoaded(HINSTANCE *phinst, LPCSTR pszDLL)
{
    if (*phinst == NULL)
    {
#ifdef DEBUG
        if (g_dwDumpFlags & DF_DELAYLOADDLL)
        {
            TraceMsg(TF_ALWAYS, "DLLLOAD: Loading %s for the first time", pszDLL);
        }

        if (g_dwBreakFlags & 0x00000080)
        {
            DebugBreak();
        }
#endif
        *phinst = LoadLibraryA(pszDLL);
        if (*phinst == NULL)
        {
            return FALSE;
        }
    }
    return TRUE;
}


// global g_hinst values 
HINSTANCE g_hinstSHDOCVW = NULL;
HINSTANCE g_hinstShell32 = NULL;

HINSTANCE HinstShdocvw()
{
    _EnsureLoaded(&g_hinstSHDOCVW, "shdocvw.dll");
    return g_hinstSHDOCVW;
}

HINSTANCE HinstShell32()
{
    _EnsureLoaded(&g_hinstShell32, "shell32.dll");
    return g_hinstShell32;
}

STDAPI_(BOOL) CallCoInternetQueryInfo(LPCTSTR pszURL, QUERYOPTION QueryOption)
{
    DWORD fRetVal;
    DWORD dwSize;
    WCHAR wszURL[MAX_URL_STRING];

    SHTCharToUnicode(pszURL, wszURL, ARRAYSIZE(wszURL));
    return SUCCEEDED(CoInternetQueryInfo(
                        wszURL, QueryOption,
                        0, &fRetVal, sizeof(fRetVal), &dwSize, 0)) && fRetVal;
}


HRESULT IURLQualifyW(IN LPCWSTR pcwzURL, DWORD dwFlags, OUT LPWSTR pwzTranslatedURL, LPBOOL pbWasSearchURL, LPBOOL pbWasCorrected)
{
    return IURLQualify(pcwzURL, dwFlags, pwzTranslatedURL, pbWasSearchURL, pbWasCorrected);
}

BSTR LoadBSTR(HINSTANCE hinst, UINT uID)
{
    WCHAR wszBuf[128];
    if (LoadStringW(hinst, uID, wszBuf, ARRAYSIZE(wszBuf)))
    {
        return SysAllocString(wszBuf);
    }
    return NULL;
}

HRESULT _SetStdLocation(LPTSTR szPath, UINT id)
{
    HRESULT hres = E_FAIL;
    WCHAR szDefaultPath[MAX_URL_STRING];

    ASSERT(id == DVIDM_GOHOME);
    if (SUCCEEDED(URLSubLoadString(MLGetHinst(), IDS_DEF_HOME, szDefaultPath, SIZECHARS(szDefaultPath), URLSUB_ALL)))
    {
        if (!StrCmp(szDefaultPath, szPath))
            return S_OK;  // We don't need to write out the name string.
    }

    DWORD cbSize = (lstrlen(szPath) + 1) * sizeof(TCHAR);
    if (ERROR_SUCCESS == SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Main"), (id==DVIDM_GOHOME) ? TEXT("Start Page") : TEXT("Search Page"),
                REG_SZ, (LPBYTE)szPath, cbSize))
    {
        hres = S_OK;
    }

    return hres;
}

//***   IsVK_TABCycler -- is key a TAB-equivalent
// ENTRY/EXIT
//  dir     0 if not a TAB, non-0 if a TAB
// NOTES
//  NYI: -1 for shift+tab, 1 for tab
//
int IsVK_TABCycler(MSG *pMsg)
{
    int nDir = 0;

    if (!pMsg)
        return nDir;

    if (pMsg->message != WM_KEYDOWN)
        return nDir;
    if (! (pMsg->wParam == VK_TAB || pMsg->wParam == VK_F6))
        return nDir;

    nDir = (GetKeyState(VK_SHIFT) < 0) ? -1 : 1;

#ifdef KEYBOARDCUES
    HWND hwndParent = GetParent(pMsg->hwnd);

    if (hwndParent)
        SendMessage(hwndParent, WM_CHANGEUISTATE, MAKEWPARAM(UIS_CLEAR, UISF_HIDEFOCUS), 0);
#endif
    return nDir ;
}

BOOL IsVK_CtlTABCycler(MSG *pMsg)
{
    if (IsVK_TABCycler(pMsg))
    {
        if (GetKeyState(VK_CONTROL) < 0 || (pMsg->wParam == VK_F6))
            return TRUE;
    }

    return FALSE;
}

const ITEMIDLIST s_idlNULL = { 0 } ;

// Copied from shell32 (was _ILCreate), which does not export this.
// The fsmenu code needs this function.
STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST)SHAlloc(cbSize);
    if (pidl)
        memset(pidl, 0, cbSize);      // needed for external task allicator

    return pidl;
}

void SaveDefaultFolderSettings(UINT flags)
{
    ASSERT(!(flags & ~GFSS_VALID));

    if (flags & GFSS_SETASDEFAULT)
        g_dfs.dwDefRevCount++;

    SKSetValue(SHELLKEY_HKCU_EXPLORER, REGVALUE_STREAMS, TEXT("Settings"), REG_BINARY, &g_dfs, sizeof(g_dfs));
}

BOOL ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid)
{
    switch (uViewMode)
    {
    case FVM_ICON:
        *pvid = VID_LargeIcons;
        break;

    case FVM_SMALLICON:
        *pvid = VID_SmallIcons;
        break;

    case FVM_LIST:
        *pvid = VID_List;
        break;

    case FVM_DETAILS:
        *pvid = VID_Details;
        break;

    case FVM_THUMBNAIL:
        *pvid = VID_Thumbnails;
        break;

    case FVM_TILE:
        *pvid = VID_Tile;
        break;

    default:
        *pvid = VID_LargeIcons;
        return(FALSE);
    }

    return(TRUE);
}

// This is a hack for IE6 23652 Beta 2. Remove in Whistler RC 1.
BOOL CheckForOutlookExpress()
{
    HKEY hKeyMail   = NULL;
    HKEY hKeyOE     = NULL;
    DWORD dwErr     = 0;
    TCHAR szBuf[MAX_PATH];
    BOOL bRet = FALSE;

    // Open the key for default internet mail client
    // HKLM\Software\Clients\Mail

    dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Clients\\Mail"), 0, KEY_QUERY_VALUE, &hKeyMail);
    if(dwErr != ERROR_SUCCESS)
    {
        // DebugTrace( TEXT("RegopenKey %s Failed -> %u\n"), szDefMailKey, dwErr);
        goto out;
    }

    dwErr = SHRegGetString(hKeyMail, NULL, NULL, szBuf, ARRAYSIZE(szBuf));
    if(dwErr != ERROR_SUCCESS)
    {
        goto out;
    }

    if(!lstrcmpi(szBuf, TEXT("Outlook Express")))
    {
        // Yes its outlook express ..
        bRet = TRUE;
    }

out:
    if(hKeyOE)
        RegCloseKey(hKeyOE);
    if(hKeyMail)
        RegCloseKey(hKeyMail);
    return bRet;
}


HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState)
{
    IDropTarget *pdrop;
    HRESULT hres = CoCreateInstance(CLSID_MailRecipient,
        NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
        IID_PPV_ARG(IDropTarget, &pdrop));

    ULONG_PTR uCookie = 0;
    if (CheckForOutlookExpress())
    {
        SHActivateContext(&uCookie);
    }
    if (SUCCEEDED(hres))
    {
        hres = SHSimulateDrop(pdrop, pdtobj, grfKeyState, NULL, NULL);
        pdrop->Release();
    }
    if (uCookie)
    {
        SHDeactivateContext(uCookie);
    }

    return hres;
}



//
// This function cannot return Non -NULL pointers if
// it returns a FAILED(hr)
//

HRESULT CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(
    LPCITEMIDLIST pidl,
    IUnknown *pUnkSite,
    IUniformResourceLocator **ppUrlOut,
    IDataObject **ppdtobj
)
{
    HRESULT hr;
    TCHAR szUrl[MAX_URL_STRING];


    ASSERT(ppUrlOut);
    ASSERT(ppdtobj);
    *ppUrlOut = NULL;
    *ppdtobj = NULL;
    szUrl[0] = TEXT('\0');

    hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szUrl, SIZECHARS(szUrl), NULL);

    if ((S_OK == hr) && (*szUrl))
    {

       BOOL fIsHTML = FALSE;
       BOOL fHitsNet = UrlHitsNetW(szUrl);

       if (!fHitsNet)
       {
            if (URL_SCHEME_FILE == GetUrlScheme(szUrl))
            {
                TCHAR *szExt = PathFindExtension(szUrl);
                if (szExt)
                {
                    fIsHTML = ((0 == StrCmpNI(szExt, TEXT(".htm"),4)) ||
                              (0 == StrCmpNI(szExt, TEXT(".html"),5)));
                }
            }
       }

       if (fHitsNet || fIsHTML)
       {
            // Create a shortcut object and
            HRESULT hr = CoCreateInstance(CLSID_InternetShortcut, NULL, CLSCTX_INPROC_SERVER,
                            IID_PPV_ARG(IUniformResourceLocator, ppUrlOut));
            if (SUCCEEDED(hr))
            {

                hr = (*ppUrlOut)->SetURL(szUrl, 0);
                if (S_OK == hr)
                {

                    // Get the IDataObject and send that back for the Drag Drop
                    hr = (*ppUrlOut)->QueryInterface(IID_PPV_ARG(IDataObject, ppdtobj));
                    if (SUCCEEDED(hr))
                    {
                        IUnknown_SetSite(*ppUrlOut, pUnkSite); // Only set the site if we're sure of
                                                          // returning SUCCESS
                    }
                }
           }
       }
       else
       {
            hr = E_FAIL;
       }
    }

    if (FAILED(hr))
    {
        SAFERELEASE(*ppUrlOut);
        SAFERELEASE(*ppdtobj);
    }
    return hr;
}

HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite)
{
    IDataObject *pdtobj = NULL;
    IUniformResourceLocator *purl = NULL;
    HRESULT hr = CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(pidl, pUnkSite, &purl, &pdtobj);
    if (FAILED(hr))
    {
        ASSERT(NULL == pdtobj);
        ASSERT(NULL == purl);
        hr = GetDataObjectForPidl(pidl, &pdtobj);
    }

    if (SUCCEEDED(hr))
    {
        IQueryCodePage * pQcp;
        if (SUCCEEDED(pdtobj->QueryInterface(IID_PPV_ARG(IQueryCodePage, &pQcp))))
        {
            pQcp->SetCodePage(uiCodePage);
            pQcp->Release();
        }
        hr = DropOnMailRecipient(pdtobj, grfKeyState);
        pdtobj->Release();
    }

    if (purl)
    {
        IUnknown_SetSite(purl, NULL);
        purl->Release();
    }
    return hr;
}

#ifdef DEBUG
/****************************************************\
    FUNCTION: Dbg_PidlStr

    DESCRIPTION:
        Create a display name for the pidl passed in
    and store the display name in pszBuffer.
\****************************************************/
LPTSTR Dbg_PidlStr(LPCITEMIDLIST pidl, LPTSTR pszBuffer, DWORD cchBufferSize)
{
    if (pidl)
    {
        if (ILIsRooted(pidl))
        {
            StringCchCopy(pszBuffer, cchBufferSize, TEXT("<ROOTED>"));  // ok to truncate for debug display only
        }
        else
        {
            IEGetNameAndFlags(pidl, SHGDN_FORPARSING, pszBuffer, cchBufferSize, NULL);
        }
    }
    else
    {
        StringCchCopy(pszBuffer, cchBufferSize, TEXT("<NULL>"));    // ok to truncate for debug display only
    }

    return pszBuffer;
}
#endif // DEBUG


#ifdef DEBUG
#define MAX_DEPTH 8

void Dbg_RecursiveDumpMenu(HMENU hmenu, int iDepth)
{
    if (!hmenu || iDepth > MAX_DEPTH)
        return;

    TCHAR szTabs[MAX_DEPTH + 1];
    for (int i = 0; i < iDepth; i++)
    {
        szTabs[i] = '\t';
    }
    szTabs[iDepth] = '\0';

    int cItems = GetMenuItemCount(hmenu);
    for (i = 0; i < cItems; i++)
    {
        MENUITEMINFO mii;
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE;

        TCHAR szTmp[64];
        mii.dwTypeData = szTmp;
        mii.cch = ARRAYSIZE(szTmp);

        if (GetMenuItemInfoWrap(hmenu, i, TRUE, &mii))
        {
            LPTSTR pszType;
            if (mii.fType == MFT_STRING && mii.dwTypeData)
                pszType = mii.dwTypeData;
            else
                pszType = TEXT("");

            TraceMsg(TF_ALWAYS, "%swID %x\tfType %x\t%s", szTabs, mii.wID, mii.fType, pszType);

            if (mii.hSubMenu)
            {
                Dbg_RecursiveDumpMenu(mii.hSubMenu, iDepth + 1);
            }
        }
    }
}

// FUNCTION: Dbg_DumpMenu
//
// walk hmenu & dump every item
void Dbg_DumpMenu(LPCTSTR psz, HMENU hmenu)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        TraceMsg(TF_ALWAYS, "Dumping hmenu %x (%s)", hmenu, psz);
        Dbg_RecursiveDumpMenu(hmenu, 0);
        TraceMsg(TF_ALWAYS, "End hmenu dump");
    }
}
#endif


// evil evil evil. for browse only mode support. not the right way to do things
STDAPI LookForDesktopIniText(IShellFolder *psf, LPCITEMIDLIST pidl, LPCTSTR pszKey, LPTSTR pszBuffer, DWORD cbSize);

#define CLSID_SIZE 40

HRESULT LoadHandler(const CLSID * pCLSID, LPCWSTR pszBuffer, REFIID riid, void **ppvObj)
{
    ASSERT(pszBuffer);
    CLSID clsid;

    if (!pCLSID)
    {
        // find the extension first ....
        // REARCHITECT - Shouldn't this be PathFindExtension?
        // Otherwise we will get confused by "foo.bar\baz"
        LPCWSTR pszDot = StrRChrW(pszBuffer, NULL, WCHAR('.'));
        if (!pszDot)
        {
            return E_NOINTERFACE;
        }

        HKEY hKey;
        LONG lRes = RegOpenKeyEx(HKEY_CLASSES_ROOT, pszDot, 0, KEY_QUERY_VALUE, &hKey);
        if (lRes != ERROR_SUCCESS)
        {
            return E_NOINTERFACE;
        }

        TCHAR szSubKey[CLSID_SIZE + 10];
        TCHAR szCLSID[CLSID_SIZE];
        DWORD dwType = REG_SZ;
        lRes = ERROR_FILE_NOT_FOUND;

        HRESULT hr = StringCchCopy(szSubKey, ARRAYSIZE(szSubKey), TEXT("shellex\\"));
        if (SUCCEEDED(hr))
        {
            int cch = SHStringFromGUID(riid, szSubKey + 8, ARRAYSIZE(szSubKey) - 8);
            if (cch != 0)
            {

                DWORD cbSize = sizeof(szCLSID);

                // should we test for a value as well as a key ?
                lRes = SHGetValue(hKey, szSubKey, TEXT(""), &dwType, szCLSID, &cbSize);
            }
        }
        RegCloseKey(hKey);

        if (lRes != ERROR_SUCCESS || dwType != REG_SZ)
        {
            return E_NOINTERFACE;
        }

        if (!GUIDFromString(szCLSID, &clsid))
        {
            return E_NOINTERFACE;
        }
        pCLSID = &clsid;
    }

    ASSERT(pCLSID);

    IPersistFile *pFile;
    HRESULT hr = CoCreateInstance(*pCLSID, NULL, CLSCTX_INPROC_SERVER,
                                   IID_PPV_ARG(IPersistFile, &pFile));
    if (FAILED(hr))
    {
        return E_NOINTERFACE;
    }

    *ppvObj = NULL;

    hr = pFile->Load(pszBuffer, TRUE);
    if (SUCCEEDED(hr))
    {
        hr = pFile->QueryInterface(riid, ppvObj);
    }

    ATOMICRELEASE(pFile);

    return hr;
}

// routine used to make us think it really came from the right place....
HRESULT FakeGetUIObjectOf(IShellFolder *psf, LPCITEMIDLIST pidl, UINT * prgfFlags, REFIID riid, void **ppvObj)
{
    HRESULT hr = E_NOINTERFACE;

    if (WhichPlatform() == PLATFORM_INTEGRATED)
    {
        // we are on Nashville try the new mechanism first...
        hr = psf->GetUIObjectOf(NULL, 1, & pidl, riid, NULL, ppvObj);
        if (SUCCEEDED(hr))
        {
            return hr;
        }
    }

    // failure cases...
    if (riid == IID_IExtractImage || riid == IID_IExtractLogo || riid == IID_IQueryInfo)
    {
        // make sure this hacked up code is only executed for browser only release....
        // otherwise people will not register their stuff right and what a mess that will be.....
        if (WhichPlatform() == PLATFORM_INTEGRATED)
        {
            return hr;
        }

        // try the IconExtractor first ....
        IExtractIconA *pIcon;
        hr = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IExtractIconA, NULL, &pIcon));
        if (SUCCEEDED(hr))
        {
            if (riid != IID_IQueryInfo)
            {
                hr = pIcon->QueryInterface(IID_IExtractLogo, ppvObj);
                ATOMICRELEASE(pIcon);

                if (SUCCEEDED(hr))
                    return NOERROR;
            }
            else
            {
                hr = pIcon->QueryInterface(IID_IQueryInfo, ppvObj);
                ATOMICRELEASE(pIcon);

                //if someone is asking for an IQueryInfo, don't try giving them an IExtractImage
                return hr;
            }
        }

        // browser mode only hack so we can detect if we are asking for the normal logo or the wide one...
        LPCTSTR pszTag = TEXT("Logo");
        if (prgfFlags != NULL && *prgfFlags)
        {
            pszTag = TEXT("WideLogo");
        }

        TCHAR szBuffer[MAX_PATH];
        hr = LookForDesktopIniText(psf, pidl, pszTag, szBuffer, ARRAYSIZE(szBuffer));
        if (SUCCEEDED(hr))
        {
            // use IID_IExtractImage, this is the same interface as IExtractLogo, just IExtractLogo
            // allows us to restrict the things that show up in Logo View...

            hr = LoadHandler(NULL, szBuffer, IID_IExtractImage, ppvObj);
        }
    }

    return hr;
}

BOOL GetInfoTipEx(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    BOOL fRet = FALSE;

    *pszText = 0;   // empty for failure

    if (pidl)
    {
        IQueryInfo *pqi;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IQueryInfo, NULL, &pqi))))
        {
            WCHAR *pwszTip;
            pqi->GetInfoTip(dwFlags, &pwszTip);
            if (pwszTip)
            {
                fRet = TRUE;
                SHUnicodeToTChar(pwszTip, pszText, cchTextMax);
                SHFree(pwszTip);
            }
            pqi->Release();
        }
        else if (SUCCEEDED(FakeGetUIObjectOf(psf, pidl, 0, IID_PPV_ARG(IQueryInfo, &pqi))))
        {
            WCHAR *pwszTip;
            pqi->GetInfoTip(0, &pwszTip);
            if (pwszTip)
            {
                fRet = TRUE;
                SHUnicodeToTChar(pwszTip, pszText, cchTextMax);
                SHFree(pwszTip);
            }
            pqi->Release();
        }
    }
    return fRet;
}

BOOL GetInfoTip(IShellFolder* psf, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax)
{
    return GetInfoTipEx(psf, 0, pidl, pszText, cchTextMax);
}


#define MAX_CLASS   80  // From ..\shell32\fstreex.c
BOOL IsBrowsableShellExt(LPCITEMIDLIST pidl)
{
    DWORD    cb;
    LPCTSTR pszExt;
    TCHAR   szFile[MAX_PATH];
    TCHAR   szProgID[MAX_CLASS];
    TCHAR   szCLSID[GUIDSTR_MAX], szCATID[GUIDSTR_MAX];
    TCHAR   szKey[GUIDSTR_MAX * 4];
    HKEY    hkeyProgID = NULL;
    BOOL    fRet = FALSE;

    for (;;)
    {
        // Make sure we have a file extension
        if  (
            !SHGetPathFromIDList(pidl, szFile)
            ||
            ((pszExt = PathFindExtension(szFile)) == NULL)
            ||
            (pszExt[0] != TEXT('.'))
           )
        {
            break;
        }

        // Get the ProgID.
        cb = sizeof(szProgID);
        if  (
            (SHGetValue(HKEY_CLASSES_ROOT, pszExt, NULL, NULL, szProgID, &cb) != ERROR_SUCCESS)
            ||
            (RegOpenKeyEx(HKEY_CLASSES_ROOT, szProgID, 0, KEY_QUERY_VALUE, &hkeyProgID) != ERROR_SUCCESS)
           )
        {
            break;
        }

        // From the ProgID, get the CLSID.
        cb = sizeof(szCLSID);
        if (SHGetValue(hkeyProgID, TEXT("CLSID"), NULL, NULL, szCLSID, &cb) != ERROR_SUCCESS)
            break;

        // Construct the registry key that detects if
        // a CLSID is a member of a CATID.
        SHStringFromGUID(CATID_BrowsableShellExt, szCATID, ARRAYSIZE(szCATID));

        HRESULT hr = StringCchPrintf(szKey, ARRAYSIZE(szKey),
                       TEXT("CLSID\\%s\\Implemented Categories\\%s"),
                             szCLSID, szCATID);
        if (FAILED(hr))
            break;

        // See if it's there.
        cb = 0;
        if (SHGetValue(HKEY_CLASSES_ROOT, szKey, NULL, NULL, NULL, &cb) != ERROR_SUCCESS)
            break;

        fRet = TRUE;
        break;
    }

    if (hkeyProgID != NULL)
        RegCloseKey(hkeyProgID);

    return fRet;
}


void OpenFolderPidl(LPCITEMIDLIST pidl)
{
    SHELLEXECUTEINFO shei = { 0 };

    shei.cbSize     = sizeof(shei);
    shei.fMask      = SEE_MASK_INVOKEIDLIST;
    shei.nShow      = SW_SHOWNORMAL;
    shei.lpIDList   = (LPITEMIDLIST)pidl;
    ShellExecuteEx(&shei);
}

void OpenFolderPath(LPCTSTR pszPath)
{
    LPITEMIDLIST pidl = ILCreateFromPath(pszPath);
    if (pidl)
    {
        OpenFolderPidl(pidl);
        ILFree(pidl);
    }
}

// NOTE: this is only called from browseui, why is it in the lib directory?
STDAPI UpdateSubscriptions()
{
#ifndef DISABLE_SUBSCRIPTIONS

    HRESULT hr;

    if (!SHRestricted2W(REST_NoManualUpdates, NULL, 0))
    {
        ISyncMgrSynchronizeInvoke *pSyncMgrInvoke;
        hr = CoCreateInstance(CLSID_SyncMgr, NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
                              IID_PPV_ARG(ISyncMgrSynchronizeInvoke, &pSyncMgrInvoke));

        if (SUCCEEDED(hr))
        {
            hr = pSyncMgrInvoke->UpdateAll();
            pSyncMgrInvoke->Release();
        }
    }
    else
    {
        SHRestrictedMessageBox(NULL);
        hr = S_FALSE;
    }
    
    return hr;

#else  /* !DISABLE_SUBSCRIPTIONS */

    return E_FAIL;

#endif /* !DISABLE_SUBSCRIPTIONS */
}


STDAPI_(int) _SHHandleUpdateImage(LPCITEMIDLIST pidlExtra)
{
    SHChangeUpdateImageIDList * pUs = (SHChangeUpdateImageIDList*) pidlExtra;

    if (!pUs)
    {
        return -1;
    }

    // if in the same process, or an old style notification
    if (pUs->dwProcessID == GetCurrentProcessId())
    {
        return (int) pUs->iCurIndex;
    }
    else
    {
        WCHAR szBuffer[MAX_PATH];
        int iIconIndex = pUs->iIconIndex;
        UINT uFlags = pUs->uFlags;

        HRESULT hr = StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), pUs->szName);
        if (SUCCEEDED(hr))
        {
            // we are in a different process, look up the hash in our index to get the right one...
            return Shell_GetCachedImageIndex(szBuffer, iIconIndex, uFlags);
        }
        else
        {
            return -1;
        }
    }
}

// As perf, share IShellLink implementations between bands and ask
// the bandsite for an implementation. Don't rely on the bandsite
// because you never know who will host us in the future. (And bandsite
// can change to not have us hosted at save/load time. Ex: it doesn't
// set our site before loading us from the stream, which sounds buggy.)
//
HRESULT SavePidlAsLink(IUnknown* punkSite, IStream *pstm, LPCITEMIDLIST pidl)
{
    HRESULT hr = E_FAIL;
    IShellLinkA* psl;

    if (punkSite)
        hr = IUnknown_QueryService(punkSite, IID_IBandSite, IID_PPV_ARG(IShellLinkA, &psl));
    if (FAILED(hr))
        hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &psl));
    if (SUCCEEDED(hr))
    {
        IPersistStream *pps;
        hr = psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
        if (EVAL(SUCCEEDED(hr)))
        {
            ASSERT(pidl);
            psl->SetIDList(pidl);

            hr = pps->Save(pstm, FALSE);

            // Win95 and NT4 shell32 have a bug in the CShellLink implementation
            // THEY DON'T NULL TERMINATE THEIR "EXTRA DATA SECTION". This causes
            // the object to trash the rest of the stream when it reads back in.
            // Fix this by writing the NULL out in the Browser Only case.
            if (SUCCEEDED(hr) && (PLATFORM_BROWSERONLY == WhichPlatform()))
            {
                DWORD dw = 0;
                pstm->Write(&dw, sizeof(dw), NULL);
            }

            pps->Release();
        }
        psl->Release();
    }
    return hr;
}

HRESULT LoadPidlAsLink(IUnknown* punkSite, IStream *pstm, LPITEMIDLIST *ppidl)
{
    IShellLinkA* psl;
    HRESULT hr = IUnknown_QueryService(punkSite, IID_IBandSite, IID_PPV_ARG(IShellLinkA, &psl));
    if (FAILED(hr))
        hr = CoCreateInstance(CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellLinkA, &psl));
    if (SUCCEEDED(hr))
    {
        IPersistStream *pps;
        hr = psl->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
        if (EVAL(SUCCEEDED(hr)))
        {
            hr = pps->Load(pstm);
            if (EVAL(SUCCEEDED(hr)))
            {
                hr = psl->GetIDList(ppidl);

                // Don't make me resolve the link because it's soo slow because
                // it often loads 80k of networking dlls.
                if (!EVAL(SUCCEEDED(hr)))
                {
                    hr = psl->Resolve(NULL, SLR_NOUPDATE | SLR_NO_UI);
                    if (EVAL(SUCCEEDED(hr)))
                        hr = psl->GetIDList(ppidl);
                }

                hr = *ppidl ? S_OK : E_FAIL;
            }
            pps->Release();
        }
        psl->Release();
    }
    return hr;
}



// AdjustECPosition
//
// purpose: because FE NT always uses WCHAR position for ComboBoxEx32
//          even though we're ANSI module for EM_GETSEL/EM_SETSEL,
//          we need to adjust between WCHAR and TCHAR position.
// iType:   ADJUST_TO_WCHAR_POS or ADJUST_TO_TCHAR_POS
//
int AdjustECPosition(char *psz, int iPos, int iType)
{
    char *pstr = psz;
    int iNewPos = iPos;

    if (psz && g_fRunOnFE && g_fRunningOnNT)
    {
        if (ADJUST_TO_WCHAR_POS == iType)
        {
            iNewPos = 0;
            while (*pstr && (pstr - psz != iPos))
            {
                pstr = CharNextA(pstr);
                iNewPos++;
            }
        }
        else if (ADJUST_TO_TCHAR_POS == iType)
        {
            while (*pstr && iPos--)
                pstr = CharNextA(pstr);
            iNewPos = (int)(pstr - psz);
        }
    }
    return iNewPos;
}

int CALLBACK _CompareIDs(LPARAM p1, LPARAM p2, LPARAM psf)
{
    HRESULT hr = ((IShellFolder*)psf)->CompareIDs(0, (LPITEMIDLIST)p1, (LPITEMIDLIST)p2);

    //ASSERT(SUCCEEDED(hr))
    return (short)HRESULT_CODE(hr);
}
HDPA GetSortedIDList(LPITEMIDLIST pidl)
{
    HDPA hdpa = DPA_Create(4);
    if (hdpa)
    {
        IShellFolder* psf;
        if (SUCCEEDED(IEBindToObject(pidl, &psf)))
        {
            LPENUMIDLIST penum;
            SHELLSTATE ss = {0};

            SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS, FALSE);

            if (S_OK == IShellFolder_EnumObjects(psf, NULL,
                ss.fShowAllObjects ? SHCONTF_FOLDERS | SHCONTF_INCLUDEHIDDEN : SHCONTF_FOLDERS,
                &penum))
            {
                LPITEMIDLIST pidl;
                ULONG celt;
                while (penum->Next(1, &pidl, &celt) == S_OK && celt == 1)
                {
                    if (DPA_AppendPtr(hdpa, pidl) == -1)
                    {
                        SHFree(pidl);
                    }
                }
                penum->Release();
            }
            DPA_Sort(hdpa, (PFNDPACOMPARE)_CompareIDs, (LPARAM)psf);
            psf->Release();
        }
    }

    return hdpa;
}

int DPA_SHFreeCallback(void * p, void * d)
{
    SHFree((LPITEMIDLIST)p);
    return 1;
}

void FreeSortedIDList(HDPA hdpa)
{
    DPA_DestroyCallback(hdpa, (PFNDPAENUMCALLBACK)DPA_SHFreeCallback, 0);
    hdpa = NULL;
}

/****************************************************\
    FUNCTION: StrCmpIWithRoot

    PARAMETERS:
        szDispNameIn - Str to see if it is the same as the
                Display Name of the Root ISF.
        fTotalStrCmp - If TRUE, pszDispNameIn has to completely equal the
                Root's Display Name to succeed.  If FALSE, only the first part
                of pszDispNameIn needs to compare to the Root's Display Name
                for this function to return successful.
        ppszCachedRoot (In/Out Optional) - If this function will be called more than
                once, this function will cache the string and make it run
                quicker. The first time this function is called, (*ppszCachedRoot)
                needs to be NULL.  This function will allocate and the caller
                needs to call LocalFree() when it's no longer needed.

    DESCRIPTION:
        This function will get the Display Name of the Root ISF (Desktop) and
    see if the first cchDispNameComp chars of szDispNameIn
    match that display name.  S_OK will be returned if TRUE, and
    S_FALSE if not.
\****************************************************/
HRESULT StrCmpIWithRoot(LPCTSTR pszDispNameIn, BOOL fTotalStrCmp, LPTSTR * ppszCachedRoot)
{
    HRESULT hr;
    TCHAR szDispNameTemp[MAX_PATH];
    LPTSTR pszDispName = szDispNameTemp;

    ASSERT(IS_VALID_STRING_PTR(pszDispNameIn, -1));
    ASSERT(NULL == ppszCachedRoot || IS_VALID_WRITE_PTR(ppszCachedRoot, LPTSTR));

    // Did the caller supply the display name of the namespace root?
    if ((!ppszCachedRoot) ||
        (ppszCachedRoot && !*ppszCachedRoot))
    {
        MLLoadString(IDS_DESKTOP, szDispNameTemp, SIZECHARS(szDispNameTemp));

        // Cache this guy?
        if (ppszCachedRoot)
        {
            // Yes
            *ppszCachedRoot = StrDup(szDispNameTemp);
            if (!*ppszCachedRoot)
                return E_OUTOFMEMORY;
        }
    }

    if (ppszCachedRoot && *ppszCachedRoot)
        pszDispName = *ppszCachedRoot;

    // Do we want to compare the entire string or just the first part of it?
    if (fTotalStrCmp)
        hr = (0 == lstrcmpi(pszDispName, pszDispNameIn)) ? S_OK : S_FALSE;   // Entire String
    else if (ppszCachedRoot)
    {
        // Compare the first part of the string
        DWORD cchDispNameComp = lstrlen(*ppszCachedRoot);
        hr = (0 == StrCmpNI(pszDispName, pszDispNameIn, cchDispNameComp)) ? S_OK : S_FALSE;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

/****************************************************\
    FUNCTION: GetMRUEntry

    PARAMETERS:
        hKey - Pointer to Registry Key to retrieve MRU entries from.
        dwMRUIndex - 0 based MRU Index to retrieve.
        pszMRUEntry - Location to store MRU Entry string.
        cchMRUEntry - Size of Buffer in characters.

    DESCRIPTION:
        This function will retrieve the MRU Entry specified
    by dwMRUIndex.
\****************************************************/
HRESULT GetMRUEntry(HKEY hKey, DWORD dwMRUIndex, LPTSTR pszMRUEntry, DWORD cchMRUEntry, LPITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;
    TCHAR szValueName[15];   // big enough for "url99999"

    ASSERT(hKey);
    ASSERT(pszMRUEntry);
    ASSERT(cchMRUEntry);

    // make a value name a la "url1" (1-based for historical reasons)
    hr = StringCchPrintf(szValueName, ARRAYSIZE(szValueName), SZ_REGVAL_MRUENTRY, dwMRUIndex+1);
    if (SUCCEEDED(hr))
    {
        cchMRUEntry *= sizeof(TCHAR);

        if (ERROR_SUCCESS != SHQueryValueEx(hKey, szValueName, NULL, NULL, (LPBYTE) pszMRUEntry, &cchMRUEntry))
        {
            pszMRUEntry[0] = TEXT('\0');
            hr = E_FAIL;
        }
    }
    return hr;
}

/*----------------------------------------------------------
Purpose: Gets a registry value that is User Specifc.
         This will open HKEY_CURRENT_USER if it exists,
         otherwise it will open HKEY_LOCAL_MACHINE.

Returns: DWORD containing success or error code.
Cond:    --
*/
LONG OpenRegUSKey(LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
{
    DWORD dwRet = RegOpenKeyEx(HKEY_CURRENT_USER, lpSubKey, ulOptions, samDesired, phkResult);

    if (ERROR_SUCCESS != dwRet)
        dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, lpSubKey, ulOptions, samDesired, phkResult);

    return dwRet;
}



typedef struct tagSTREAMHEADER
{
    DWORD dwHeaderSize;
    DWORD dwDataSize;
    DWORD dwSignature;
    DWORD dwVersion;
} STREAMHEADER;


/****************************************************\
    FUNCTION: LoadStreamHeader

    PARAMETERS:
        dwSignature - The signature that the caller supports
        dwStartVersion - The lowest version the caller chooses to support.
        dwEndVersion - The highest version the caller chooses to support.
        pdwSize (OUT) - The size that the caller should read.
        pdwVersionOut (OUT) - The version found.
        return - if S_OK, then the caller needs to read pdwSize bytes
                               of data.
                 if S_FALSE, then the caller should use default settings
                                  and return S_OK.

    DESCRIPTION:
        This function see if the caller owns this
    data in the stream.  If the caller does own the
    stream segment, the size and version will be returned.
    If the caller doesn't own the stream segment then S_FALSE is
    returned to indicate that the caller should use default
    data.  If the caller doesn't claim to support the version
    found (because of the dwStartVersion-dwEndVersion range),
    then S_FALSE is returned to indicate to use default values
    and this function skips over that segment in the stream
    so the next segment can be parsed.
\****************************************************/
HRESULT LoadStreamHeader(IStream *pstm,
                                    DWORD dwSignature,      // What version?
                                    DWORD dwStartVersion,   // What is the earlies version supported?
                                    DWORD dwEndVersion,     // What is the oldest version supported?
                                    DWORD * pdwSize,        // What is the size to read?
                                    DWORD * pdwVersionOut)  // What version was found in the stream?
{
    HRESULT hr;
    STREAMHEADER shHeader;
    BOOL fNotOurs = FALSE;
    BOOL fSkipData = FALSE;

    hr = pstm->Read(&shHeader, sizeof(shHeader), NULL);

    ASSERT(pdwSize && pdwVersionOut);
    *pdwSize = 0;
    *pdwVersionOut = 0;

    if (SUCCEEDED(hr))
    {
        if (shHeader.dwHeaderSize != sizeof(shHeader))
            fNotOurs = TRUE;
        else if (shHeader.dwSignature != dwSignature)
            fNotOurs = TRUE;
        else if (shHeader.dwVersion < dwStartVersion)
            fSkipData = TRUE;
        else if (shHeader.dwVersion > dwEndVersion)
            fSkipData = TRUE;

        if (fNotOurs)
        {
            // It's not, so reset it so the next guy will be able to read correctly.
            LARGE_INTEGER li;

            li.LowPart = (DWORD)-(LONG)sizeof(shHeader);
            li.HighPart = 0;

            hr = pstm->Seek(li, STREAM_SEEK_CUR, NULL);
            hr = S_FALSE; // Means caller should use default data.
        }

        // Do we want to skip the Data for this part of the stream?
        if (fSkipData)
        {
            ASSERT(STREAMSIZE_UNKNOWN != shHeader.dwDataSize);  // SERIOUS, we cannot skip over data because we don't know size.

            if (STREAMSIZE_UNKNOWN != shHeader.dwDataSize)
            {
                // Yes.  The caller cannot read in this data because the caller doesn't support
                // this version of the data.  Therefore, we skip past the data and return S_FALSE
                // to indicate to the caller that default settings should be used.
                LARGE_INTEGER li;

                li.LowPart = shHeader.dwDataSize;
                li.HighPart = 0;

                hr = pstm->Seek(li, STREAM_SEEK_CUR, NULL);
                hr = S_FALSE; // Means caller should use default data.
            }
        }

        if (!fNotOurs && !fSkipData)
        {
            *pdwSize = shHeader.dwDataSize;
            *pdwVersionOut = shHeader.dwVersion;
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: SaveStreamHeader

    DESCRIPTION:
        This function will save a StreamHeader to
    the stream that will allow the caller to verify
    if he/she owns the data the next time it's read in.
    It will also support the ability to ignore old
    or future versions of data.
\****************************************************/
HRESULT SaveStreamHeader(IStream *pstm, DWORD dwSignature, DWORD dwVersion, DWORD dwSize)
{
    HRESULT hr;
    STREAMHEADER shHeader;

    shHeader.dwHeaderSize = sizeof(STREAMHEADER);
    shHeader.dwDataSize = dwSize;
    shHeader.dwSignature = dwSignature;
    shHeader.dwVersion = dwVersion;

    hr = pstm->Write(&shHeader, sizeof(shHeader), NULL);
    return hr;
}


//----------------------------------------------------------------------
//
// CMenuList
//
//----------------------------------------------------------------------


typedef struct
{
    HMENU   hmenu;
    BITBOOL bObject:1;              // TRUE: menu belongs to object
} MLITEM;       // CMenuList item


CMenuList::CMenuList(void)
{
    ASSERT(NULL == _hdsa);
}


CMenuList::~CMenuList(void)
{
    if (_hdsa)
    {
        DSA_Destroy(_hdsa);
        _hdsa = NULL;
    }
}


/*----------------------------------------------------------
Purpose: Set the menu list (comparable to HOLEMENU) so we can
         dispatch commands to the frame or the object correctly.
         We do this since menu bands bypass OLE's FrameFilterWndProc.

         We build the menu list by comparing the given hmenuShared
         with hmenuFrame.  Anything in hmenuShared that is not
         in hmenuFrame belongs to the object.

*/
void CMenuList::Set(HMENU hmenuShared, HMENU hmenuFrame)
{
    ASSERT(NULL == hmenuShared || IS_VALID_HANDLE(hmenuShared, MENU));
    ASSERT(NULL == hmenuFrame || IS_VALID_HANDLE(hmenuFrame, MENU));

    if (_hdsa)
    {
        ASSERT(IS_VALID_HANDLE(_hdsa, DSA));

        DSA_DeleteAllItems(_hdsa);
    }
    else
        _hdsa = DSA_Create(sizeof(MLITEM), 10);

    if (_hdsa && hmenuShared && hmenuFrame)
    {
        int i;
        int iFrame = 0;
        int cmenu = GetMenuItemCount(hmenuShared);
        int cmenuFrame = GetMenuItemCount(hmenuFrame);
        BOOL bMatched;
        int iSaveFrame;
        int iHaveFrame = -1;

        TCHAR sz[64];
        TCHAR szFrame[64];
        MENUITEMINFO miiFrame;
        MENUITEMINFO mii;
        MLITEM mlitem;

        miiFrame.cbSize = sizeof(miiFrame);
        miiFrame.hSubMenu = NULL;
        mii.cbSize = sizeof(mii);

        for (i = 0; i < cmenu; i++)
        {

            mii.cch = SIZECHARS(sz);
            mii.fMask  = MIIM_SUBMENU | MIIM_TYPE;
            mii.dwTypeData = sz;
            EVAL(GetMenuItemInfoWrap(hmenuShared, i, TRUE, &mii));

            ASSERT(IS_VALID_HANDLE(mii.hSubMenu, MENU));

            mlitem.hmenu = mii.hSubMenu;

            iSaveFrame = iFrame;
            bMatched = FALSE;

            //  DocObject might have dropped some of our menus, like edit and view
            //  Need to be able to skip over dropped frame menus
            while (1)
            {
                if (iHaveFrame != iFrame)
                {
                    iHaveFrame = iFrame;
                    if (iFrame < cmenuFrame)
                    {
                        miiFrame.cch = SIZECHARS(szFrame);
                        miiFrame.fMask  = MIIM_SUBMENU | MIIM_TYPE;
                        miiFrame.dwTypeData = szFrame;
                        EVAL(GetMenuItemInfoWrap(hmenuFrame, iFrame, TRUE, &miiFrame));
                    }
                    else
                    {
                        // Make it so it won't compare
                        miiFrame.hSubMenu = NULL;
                        *szFrame = 0;
                    }

                }
                ASSERT(iFrame >= cmenuFrame || IS_VALID_HANDLE(miiFrame.hSubMenu, MENU));

                // The browser may have a menu that was not merged into
                // the shared menu because the object put one in with
                // the same name.  Have we hit this case? Check by comparing
                // sz and szFrame

                if (mii.hSubMenu == miiFrame.hSubMenu || 0 == StrCmp(sz, szFrame))
                {
                    bMatched = TRUE;
                    break;
                }
                else
                {
                    if (iFrame >= cmenuFrame)
                    {
                        break;
                    }
                    iFrame++;
                }
            }

            // Is this one of our menus?
            mlitem.bObject = (mii.hSubMenu == miiFrame.hSubMenu) ? FALSE:TRUE;
            if (bMatched)
            {
                iFrame++;
            }
            else
            {
                iFrame = iSaveFrame;
            }
            DSA_SetItem(_hdsa, i, &mlitem);
        }
    }
}


/*----------------------------------------------------------
Purpose: Adds the given hmenu to the list.

*/
void CMenuList::AddMenu(HMENU hmenu)
{
    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        MLITEM mlitem;

        mlitem.hmenu = hmenu;
        mlitem.bObject = TRUE;

        DSA_AppendItem(_hdsa, &mlitem);
    }
}


/*----------------------------------------------------------
Purpose: Removes the given hmenu from the list.

*/
void CMenuList::RemoveMenu(HMENU hmenu)
{
    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        int i = DSA_GetItemCount(_hdsa) - 1;

        for (; i >= 0; i--)
        {
            MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
            ASSERT(pmlitem);

            if (hmenu == pmlitem->hmenu)
            {
                DSA_DeleteItem(_hdsa, i);
                break;
            }
        }
    }
}


/*----------------------------------------------------------
Purpose: Returns TRUE if the given hmenu belongs to the object.

*/
BOOL CMenuList::IsObjectMenu(HMENU hmenu)
{
    BOOL bRet = FALSE;

    ASSERT(NULL == hmenu || IS_VALID_HANDLE(hmenu, MENU));

    if (_hdsa && hmenu)
    {
        int i;

        for (i = 0; i < DSA_GetItemCount(_hdsa); i++)
        {
            MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
            ASSERT(pmlitem);

            if (hmenu == pmlitem->hmenu)
            {
                bRet = pmlitem->bObject;
                break;
            }
        }
    }
    return bRet;
}


#ifdef DEBUG

void CMenuList::Dump(LPCTSTR pszMsg)
{
    if (IsFlagSet(g_dwDumpFlags, DF_DEBUGMENU))
    {
        TraceMsg(TF_ALWAYS, "CMenuList: Dumping menus for %#08x %s", this, pszMsg);

        if (_hdsa)
        {
            int i;

            for (i = 0; i < DSA_GetItemCount(_hdsa); i++)
            {
                MLITEM * pmlitem = (MLITEM *)DSA_GetItemPtr(_hdsa, i);
                ASSERT(pmlitem);

                TraceMsg(TF_ALWAYS, "   [%d] = %x", i, pmlitem->hmenu);
            }
        }
    }
}

#endif

#define REGVAL_FIRST_HOME_PAGE          TEXT("First Home Page")
#define REGVAL_UPDATE_CHECK_PAGE        TEXT("Update_Check_Page")
#define REGVAL_UPDATE_CHECK_INTERVAL    TEXT("Update_Check_Interval")
#define REGVAL_LASTCHECKEDHI            TEXT("LastCheckedHi")
#define REGSTR_PATH_INFODEL_REST        TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Infodelivery\\Restrictions")
#define REGVAL_IEUPDATECHECK_REST       TEXT("NoUpdateCheck")
#define DEFAULT_IEUPDATECHECK_PAGE      TEXT("http://www.microsoft.com/isapi/redir.dll?Prd=ie&Pver=5.0&Ar=ie5update&O1=b1")

BOOL
IsUpdateCheckRestricted()
{

    HKEY hkeyRest = 0;
    BOOL bUpdateCheckRest = FALSE;
    DWORD dwValue = 0;
    DWORD dwLen = sizeof(DWORD);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_INFODEL_REST, 0, KEY_QUERY_VALUE, &hkeyRest) == ERROR_SUCCESS)
    {
        if (ERROR_SUCCESS == SHRegGetDWORD(hkeyRest, NULL, REGVAL_IEUPDATECHECK_REST, &dwValue)
            && dwValue)
        {
            bUpdateCheckRest = TRUE;
        }

        RegCloseKey(hkeyRest);
    }

    if (!bUpdateCheckRest)
    {
        // Check to see if the user has turned it off under advanced options
        dwValue = 0;
        dwLen = sizeof(DWORD);
        if (SHRegGetUSValue(REGSTR_PATH_MAIN, REGVAL_IEUPDATECHECK_REST, NULL, (LPBYTE)&dwValue, &dwLen, 0,NULL,0) == ERROR_SUCCESS && dwValue)
                bUpdateCheckRest = TRUE;
    }

    return bUpdateCheckRest;
}


HRESULT
CheckIEMinimalUpdate()
{
    HRESULT hr = S_OK;
    HKEY hkeyIE = 0;
    TCHAR szUpdateUrl[MAX_URL_STRING];
    DWORD dwSize;
    DWORD dwType;
    FILETIME ftlast, ftnow;
    DWORD dwMagicDays = 0;
    DWORD dwMagicPerDay = 201;

    if (IsUpdateCheckRestricted())
    {
        hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
        goto Exit;
    }

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MAIN, 0, KEY_QUERY_VALUE, &hkeyIE))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (ERROR_SUCCESS != SHRegGetDWORD(hkeyIE, NULL, REGVAL_UPDATE_CHECK_INTERVAL, &dwMagicDays)
        || dwMagicDays == 0)
    {
        dwMagicDays = 30;   // hardcode default to check every 30 days.
    }

    if (ERROR_SUCCESS != SHRegGetString(hkeyIE, NULL, REGVAL_UPDATE_CHECK_PAGE, szUpdateUrl, ARRAYSIZE(szUpdateUrl)))
    {
        hr = StringCchCopy(szUpdateUrl, ARRAYSIZE(szUpdateUrl), DEFAULT_IEUPDATECHECK_PAGE);
        if (FAILED(hr))
        {
            szUpdateUrl[0] = TEXT('\0');
        }
    }

    RegCloseKey(hkeyIE);

    if (RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_MAIN, 0, KEY_QUERY_VALUE | KEY_SET_VALUE, &hkeyIE) == ERROR_SUCCESS)
    {
        dwType = REG_SZ;
        dwSize = MAX_URL_STRING;
        if (RegQueryValueEx(hkeyIE, REGVAL_FIRST_HOME_PAGE, NULL, &dwType,
            NULL, &dwSize) == ERROR_SUCCESS)
        {
            // if already exists then skip this write
            hr = S_FALSE;
            goto Exit;
        }

        GetSystemTimeAsFileTime(&ftnow);
        ftnow.dwLowDateTime = 0;

        ZeroMemory(&ftlast, sizeof(ftlast));

        if (ERROR_SUCCESS == SHRegGetDWORD(hkeyIE, NULL, REGVAL_LASTCHECKEDHI, &ftlast.dwHighDateTime))
        {
            ftlast.dwHighDateTime += (dwMagicPerDay * dwMagicDays);
        }

        if (CompareFileTime(&ftlast, &ftnow) > 0)
        {
            hr = S_FALSE;
        }
        else if (szUpdateUrl[0] == TEXT('\0'))
        {
            hr = E_FAIL;
        }
        else
        {
            RegSetValueEx(hkeyIE,REGVAL_FIRST_HOME_PAGE, NULL,
                REG_SZ,(LPBYTE)szUpdateUrl, (lstrlen(szUpdateUrl)+1)*sizeof(TCHAR));

            RegSetValueEx(hkeyIE, REGVAL_LASTCHECKEDHI, NULL, REG_DWORD,
               (unsigned char *)&ftnow.dwHighDateTime, sizeof(DWORD));
        }

        RegCloseKey(hkeyIE);
    }

Exit:

    return hr;
}


static BOOL s_fSUCheckComplete = FALSE;
// returns:
//      TRUE    The user clicked Update Now and we ShellExe'ed
//              the update URL.
//      FALSE   We did not launch a browser to the update page.
// NOTE: the "run-once-ness" of this is controlled by the ICW check
//       variable g_fICWCheckComplete.

BOOL CheckSoftwareUpdateUI(HWND hwndOwner, IShellBrowser *pisb)
{
    BOOL fLaunchUpdate = FALSE;

#ifndef UNIX
    HRESULT hr = S_OK;
    int nRes;
    SOFTDISTINFO sdi = { 0 };
    sdi.cbSize = sizeof(SOFTDISTINFO);

    if (s_fSUCheckComplete)
        return FALSE;
    else
        s_fSUCheckComplete = TRUE;

    // We're putting up a message box, so make the msg pump modal
    pisb->EnableModelessSB(FALSE);

    nRes = SoftwareUpdateMessageBox(hwndOwner, awchMSIE4GUID, 0, &sdi);

    pisb->EnableModelessSB(TRUE);

    if (nRes != IDABORT)
    {
        if (nRes == IDYES)
        {
            // Okay, we tried to do this a couple of different ways.
            // Originally, this was done with ShellExecEx. This failed
            // because the http hook wasn't 100% reliable on Win95.
            // The next stab was to:
            //LPITEMIDLIST pidl;
            // The user wants to navigate to the install page.
            //hr = pibs->IEParseDisplayName(CP_ACP, sdi.szHREF, &pidl);
            //if (SUCCEEDED(hr))
            //{
            //    OpenFolderPidl(pidl);
            //    ILFree(pidl);
            //}
            hr = NavToUrlUsingIEW(sdi.szHREF, TRUE);

        } // if user wants update

        if (sdi.szTitle != NULL)
            CoTaskMemFree(sdi.szTitle);
        if (sdi.szAbstract != NULL)
            CoTaskMemFree(sdi.szAbstract);
        if (sdi.szHREF != NULL)
            CoTaskMemFree(sdi.szHREF);

        fLaunchUpdate = nRes == IDYES && SUCCEEDED(hr);

    }

    if (!fLaunchUpdate)
    {
        // for minimal install of IE every N days or so we want to
        // hijack the home page to check if an update is available
        // for us.

        CheckIEMinimalUpdate();
    }
#endif

    return fLaunchUpdate;
}



BOOL g_fICWCheckComplete = FALSE;

// returns:
//      TRUE    Internet Connection Wizard (ICW) was run, and we should exit
//              the browser since we likely need to restart the system
//      FALSE   did not run the ICW, continue on as normal

BOOL CheckRunICW(LPCTSTR pszURL)
{
    if (g_fICWCheckComplete)
        return FALSE;

    DWORD dwICWCompleted = 0;
    BOOL fRet = FALSE;

    // Check if ICW has already been run

    DWORD dwSize = sizeof(dwICWCompleted);
    SHGetValue(HKEY_CURRENT_USER, TEXT(ICW_REGPATHSETTINGS), TEXT(ICW_REGKEYCOMPLETED), NULL, &dwICWCompleted, &dwSize);

    if (!dwICWCompleted)
    {
        HINSTANCE hInetCfgDll = LoadLibrary(TEXT("inetcfg.dll"));
        // set this to TRUE here so that if there's an error in loading the dll, or getting the proc address,
        // we don't keep trying to do that.
        g_fICWCheckComplete = TRUE;
        if (hInetCfgDll)
        {
            PFNCHECKCONNECTIONWIZARD fp = (PFNCHECKCONNECTIONWIZARD)GetProcAddress(hInetCfgDll, "CheckConnectionWizard");
            if (fp)
            {
                DWORD dwRet;
                DWORD dwFlags = ICW_LAUNCHFULL | ICW_LAUNCHMANUAL | ICW_FULL_SMARTSTART;

                if (pszURL)
                {
                    PFNSETSHELLNEXT fpSetShellNext = (PFNSETSHELLNEXT)GetProcAddress(hInetCfgDll, "SetShellNext");
                    if (fpSetShellNext)
                    {
                        CHAR szAnsiUrl[MAX_URL_STRING];

                        SHTCharToAnsi(pszURL, szAnsiUrl, ARRAYSIZE(szAnsiUrl));
                        dwFlags |= ICW_USE_SHELLNEXT;
                        fpSetShellNext(szAnsiUrl);
                    }
                }

                // if we get this far, set the fICWCheckComplete back to FALSE (had to be false since we didn't early out)
                // and let the ICW set the reg key.  this is so that if the user decides to cancel and come back later,
                // we respect that.
                g_fICWCheckComplete = FALSE;

                // Launch ICW full or manual path, whichever is available
                // NOTE: the ICW code makes sure only a single instance is up
                fp(dwFlags, &dwRet);

                // If it was launched successfully, we need to exit
                // since ICW may restart the machine if it needs to
                // install system files.
                if (dwRet & (ICW_LAUNCHEDFULL | ICW_LAUNCHEDMANUAL))
                {
                    fRet = TRUE;
                }
            }
            FreeLibrary(hInetCfgDll);
        }
    }
    else
    {
        g_fICWCheckComplete = TRUE;
    }

    return fRet;
}


int GetColorComponent(LPSTR *ppsz)
{
    int iColor = 0;
    if (*ppsz)
    {
        LPSTR pBuf = *ppsz;
        iColor = StrToIntA(pBuf);

        // find the next comma
        while(pBuf && *pBuf && *pBuf!=L',')
            pBuf++;

        // if valid and not NULL...
        if (pBuf && *pBuf)
            pBuf++;         // increment

        *ppsz = pBuf;
    }
    return iColor;
}

// Read the registry for a string (REG_SZ) of comma separated RGB values
COLORREF RegGetColorRefString(HKEY hkey, LPTSTR RegValue, COLORREF Value)
{
    CHAR SmallBuf[80];
    CHAR szRegKey[MAXIMUM_SUB_KEY_LENGTH];
    LPSTR pszBuf;
    DWORD cb;
    int iRed, iGreen, iBlue;

    SHTCharToAnsi(RegValue, szRegKey, ARRAYSIZE(szRegKey));
    cb = sizeof(SmallBuf);
    if (SHQueryValueExA(hkey, szRegKey, NULL, NULL, (LPBYTE)&SmallBuf, &cb)
        == ERROR_SUCCESS)
    {
        pszBuf = SmallBuf;

        iRed = GetColorComponent(&pszBuf);
        iGreen = GetColorComponent(&pszBuf);
        iBlue = GetColorComponent(&pszBuf);

        // make sure all values are valid
        iRed    %= 256;
        iGreen  %= 256;
        iBlue   %= 256;

        Value = RGB(iRed, iGreen, iBlue);
    }

    return Value;
}

LRESULT SetHyperlinkCursor(IShellFolder* pShellFolder, LPCITEMIDLIST pidl)
{
    HCURSOR hCursor;
    BOOL fCursorSet = FALSE;

    if (!pidl)
        return 0;

    if (SHIsGlobalOffline())
    {
        IQueryInfo *pqi;
        if (SUCCEEDED(pShellFolder->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IQueryInfo, NULL, &pqi))))
        {
            DWORD dwFlags = 0;
            if (SUCCEEDED(pqi->GetInfoFlags(&dwFlags)))
            {
                if (0 == (dwFlags & QIF_CACHED))
                {
                    // Load Offline cursor since not cached
                    hCursor = (HCURSOR)LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_OFFLINE_HAND));
                    if (hCursor)
                    {
                        SetCursor(hCursor);
                        fCursorSet = TRUE;
                    }
                }
            }
            pqi->Release();
        }
    }

    if (!fCursorSet)
    {
        // For whatever reason, offline cursor was not set
        hCursor = LoadHandCursor(0);
        if (hCursor)
            SetCursor(hCursor);
    }

    return 1;
}

BOOL IsSubscribableA(LPCSTR pszUrl)
{
    //  REARCHITECT: this should be method on the subscription mgr interface - zekel
    DWORD dwScheme = GetUrlSchemeA(pszUrl);
    return (dwScheme == URL_SCHEME_HTTP) || (dwScheme == URL_SCHEME_HTTPS);
}

BOOL IsSubscribableW(LPCWSTR pwzUrl)
{
    //  REARCHITECT: this should be method on the subscription mgr interface - zekel
    DWORD dwScheme = GetUrlSchemeW(pwzUrl);
    return (dwScheme == URL_SCHEME_HTTP) || (dwScheme == URL_SCHEME_HTTPS);
}

HWND GetTrayWindow()
{
#ifndef UNIX
    static HWND s_hwndTray = NULL;

    if (!IsWindow(s_hwndTray))
    {
        s_hwndTray = FindWindow(TEXT(WNDCLASS_TRAYNOTIFY), NULL);
    }
    return s_hwndTray;
#else
    return NULL;
#endif
}

void FireEventSzA(LPCSTR szEvent)
{
    HANDLE hEvent = OpenEventA(EVENT_MODIFY_STATE, FALSE, szEvent);
    if (hEvent)
    {
        SetEvent(hEvent);
        CloseHandle(hEvent);
    }
}

void FireEventSzW(LPCWSTR pszEvent)
{
    USES_CONVERSION;
    FireEventSzA(W2A(pszEvent));
}

BOOL IsNamedWindow(HWND hwnd, LPCTSTR pszClass)
{
#ifndef UNIX
    TCHAR szClass[32];
#else // UNIX use this function for trident dialog window
    TCHAR szClass[64];
#endif

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return lstrcmp(szClass, pszClass) == 0;
}

BOOL IsExplorerWindow(HWND hwnd)
{
    return IsNamedWindow(hwnd, c_szExploreClass);
}

BOOL IsFolderWindow(HWND hwnd)
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return (lstrcmp(szClass, c_szCabinetClass) == 0) || (lstrcmp(szClass, c_szIExploreClass) == 0);
}


// returns TRUE if the unknown is on a window that was opened as IE
// returns FALSE if the window was opened on the shell namespace, even if it's now showing a web page
// returns FALSE in other cases e.g. on the taskbar

STDAPI_(BOOL) WasOpenedAsBrowser(IUnknown *punkSite) 
{
    // this is a more reliable way of distinguishing windows opened for a URL.  Checking
    // the hwnd's classname does not work -- clicking on a hyperlink from Outlook 98 opens
    // a browser window with a shell window's classname.

    return (S_OK == IUnknown_QueryServiceExec(punkSite, SID_STopLevelBrowser, &CGID_Explorer, SBCMDID_STARTEDFORINTERNET, 0, NULL, NULL));
}


#define DXTRACK 1
void FrameTrack(HDC hdc, LPRECT prc, UINT uFlags)
{
    COLORREF clrSave, clr;
    RECT    rc;

    // upperleft
    switch (uFlags)
    {
    case TRACKHOT:
        clr = GetSysColor(COLOR_BTNHILIGHT);
        break;
    case TRACKNOCHILD:
    case TRACKEXPAND:
        clr = GetSysColor(COLOR_BTNSHADOW);
        break;
    default:
        ASSERT(FALSE);
        break;
    }
    clrSave = SetBkColor(hdc, clr);
    rc = *prc;
    rc.bottom = rc.top + DXTRACK;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    rc.bottom = prc->bottom;
    rc.right = rc.left + DXTRACK;
    rc.top = prc->top + DXTRACK;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    // lowerright
    switch (uFlags)
    {
    case TRACKHOT:
        clr = GetSysColor(COLOR_BTNSHADOW);
        break;
    case TRACKNOCHILD:
    case TRACKEXPAND:
        clr = GetSysColor(COLOR_BTNHILIGHT);
        break;
    default:
        ASSERT(FALSE);
        break;
    }
    SetBkColor(hdc, clr);
    if (uFlags & (TRACKHOT | TRACKNOCHILD))
    {
        rc.right = prc->right;
        rc.top = rc.bottom - DXTRACK;
        rc.left = prc->left;
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    }
    rc.right = prc->right;
    rc.left = prc->right - DXTRACK;
    rc.top = prc->top;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    SetBkColor(hdc, clrSave);
    return;
}

#ifdef DEBUG // {
//***   SearchDW -- scan for DWORD in buffer
// ENTRY/EXIT
//  pdwBuf  buffer
//  cbBuf   size of buffer in *bytes* (*not* DWORDs)
//  dwVal   DWORD we're looking for
//  dOff    (return) byte offset in buffer; o.w. -1 if not found
//
int SearchDWP(DWORD_PTR *pdwBuf, int cbBuf, DWORD_PTR dwVal)
{
    int dOff;

    for (dOff = 0; dOff < cbBuf; dOff += sizeof(DWORD_PTR), pdwBuf++)
    {
        if (*pdwBuf == dwVal)
            return dOff;
    }

    return -1;
}
#endif // }


int CAssociationList::FindEntry(DWORD dwKey)
{
    if (_hdsa)
    {
        for (int i = 0; i < DSA_GetItemCount(_hdsa); i++)
        {
            ASSOCDATA* pad;
            pad = (ASSOCDATA*)DSA_GetItemPtr(_hdsa, i);
            if (pad->dwKey == dwKey)
                return i;
        }
    }
    return -1;
}

HRESULT CAssociationList::Find(DWORD dwKey, void ** ppData)
{
    HRESULT hr = E_FAIL;

    ENTERCRITICAL;
    int i = FindEntry(dwKey);
    if (i != -1)
    {
        ASSOCDATA* pad = (ASSOCDATA*)DSA_GetItemPtr(_hdsa, i);
        ASSERT(dwKey == pad->dwKey);
        *ppData = pad->lpData;
        hr = S_OK;
    }
    LEAVECRITICAL;

    return hr;
}

void CAssociationList::Delete(DWORD dwKey)
{
    ENTERCRITICAL;
    int i = FindEntry(dwKey);
    if (i != -1)
    {
        DSA_DeleteItem(_hdsa, i);
    }
    LEAVECRITICAL;
}


BOOL CAssociationList::Add(DWORD dwKey, void *lpData)
{
    ENTERCRITICAL;
    if (!_hdsa)
    {
        _hdsa = DSA_Create(sizeof(ASSOCDATA), 4);
    }
    LEAVECRITICAL;

    BOOL fRet = FALSE;
    if (_hdsa)
    {
        ASSOCDATA ad;
        ad.dwKey = dwKey;
        ad.lpData = lpData;

        ENTERCRITICAL;
        fRet = DSA_AppendItem(_hdsa, &ad) != -1;
        LEAVECRITICAL;
    }
    return fRet;
}

int g_cxSmIcon = 0;
int g_cySmIcon = 0;
HIMAGELIST g_himlSysSmall = NULL;

void _InitSmallImageList()
{
    if (!g_himlSysSmall)
    {
        Shell_GetImageLists(NULL, &g_himlSysSmall);
        ImageList_GetIconSize(g_himlSysSmall, &g_cxSmIcon, &g_cySmIcon);
    }
}


#define CXIMAGEGAP      6

STDAPI_(void) DrawMenuItem(DRAWITEMSTRUCT* lpdi, LPCTSTR lpszMenuText, UINT iIcon)
{
    _InitSmallImageList();

    if ((lpdi->itemAction & ODA_SELECT) || (lpdi->itemAction & ODA_DRAWENTIRE))
    {
        int x, y;
        SIZE sz;
        RECT rc;

        // Draw the image (if there is one).
        GetTextExtentPoint32(lpdi->hDC, lpszMenuText, lstrlen(lpszMenuText), &sz);

        if (lpdi->itemState & ODS_SELECTED)
        {
            SetBkColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
            FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_HIGHLIGHT));
        }
        else
        {
            SetTextColor(lpdi->hDC, GetSysColor(COLOR_MENUTEXT));
            FillRect(lpdi->hDC,&lpdi->rcItem,GetSysColorBrush(COLOR_MENU));
        }

        rc = lpdi->rcItem;
        rc.left += +2 * CXIMAGEGAP + g_cxSmIcon;

        DrawText(lpdi->hDC, lpszMenuText, lstrlen(lpszMenuText), &rc, DT_SINGLELINE | DT_VCENTER | DT_EXPANDTABS);
        if (iIcon != -1)
        {
            x = lpdi->rcItem.left + CXIMAGEGAP;
            y = (lpdi->rcItem.bottom + lpdi->rcItem.top - g_cySmIcon) / 2;
            ImageList_Draw(g_himlSysSmall, iIcon, lpdi->hDC, x, y, ILD_TRANSPARENT);
        }
        else
        {
            x = lpdi->rcItem.left + CXIMAGEGAP;
            y = (lpdi->rcItem.bottom + lpdi->rcItem.top - g_cySmIcon) / 2;
        }
    }
}

STDAPI_(LRESULT) MeasureMenuItem(MEASUREITEMSTRUCT *lpmi, LPCTSTR lpszMenuText)
{
    LRESULT lres = FALSE;

    if (0 == g_cxSmIcon)
    {
        _InitSmallImageList();
    }

    // Get the rough height of an item so we can work out when to break the
    // menu. User should really do this for us but that would be useful.
    HDC hdc = GetDC(NULL);
    if (hdc)
    {
        // REVIEW cache out the menu font?
        NONCLIENTMETRICSA ncm;
        ncm.cbSize = sizeof(ncm);
        if (SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, FALSE))
        {
            HFONT hfont = CreateFontIndirectA(&ncm.lfMenuFont);
            if (hfont)
            {
                SIZE sz;
                HFONT hfontOld = (HFONT)SelectObject(hdc, hfont);
                GetTextExtentPoint32(hdc, lpszMenuText, lstrlen(lpszMenuText), &sz);
                lpmi->itemHeight = max (g_cySmIcon+CXIMAGEGAP/2, ncm.iMenuHeight);
                lpmi->itemWidth = g_cxSmIcon + 2*CXIMAGEGAP + sz.cx;
                SelectObject(hdc, hfontOld);
                DeleteObject(hfont);
                lres = TRUE;
            }
        }
        ReleaseDC(NULL, hdc);
    }
    return lres;
}

//+-------------------------------------------------------------------------
// This function scans the document for the given HTML tag and returns the
// result in a collection.
//--------------------------------------------------------------------------
HRESULT GetDocumentTags
(
    IHTMLDocument2 *          pHTMLDocument,    // doc to search
    LPOLESTR                  pszTagName,       // tag name to search for
    IHTMLElementCollection ** ppTagsCollection  // returned collection
)
{
    HRESULT hr;

    *ppTagsCollection = NULL;

    //
    // First get all document elements
    //
    IHTMLElementCollection * pAllCollection;
    if (SUCCEEDED(hr = pHTMLDocument->get_all(&pAllCollection)))
    {
        //
        // Now get all the elements with tags == pszTagName
        //
        VARIANT v;
        v.vt = VT_BSTR;
        v.bstrVal = ::SysAllocString(pszTagName);
        if (v.bstrVal)
        {
            IDispatch * pDispTagsCollection;
            if (SUCCEEDED(hr = pAllCollection->tags(v, &pDispTagsCollection)))
            {
                hr = pDispTagsCollection->QueryInterface(IID_PPV_ARG(IHTMLElementCollection, ppTagsCollection));
                pDispTagsCollection->Release();
            }

            pAllCollection->Release();
            VariantClear(&v);
        }
    }

    return hr;
}

// This function uses the memory allocator from comctrl (which differs between NT and W95)
BOOL WINAPI Str_SetPtrPrivateW(WCHAR FAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew)
{
    LPWSTR pwzNewCopy = NULL;

    if (pwzNew)
    {
        pwzNewCopy = StrDup(pwzNew);
        if (!pwzNewCopy)
            return FALSE;
    }

    LPWSTR pwzOld = (LPWSTR)InterlockedExchangePointer((void * *)ppwzCurrent, (void *)pwzNewCopy);
    if (pwzOld)
        LocalFree(pwzOld);

    return TRUE;
}

// This function is compatible with API's that use LocalAlloc for string memory
BOOL WINAPI SetStr(WCHAR FAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew)
{
    int cchLength;
    LPWSTR pwzOld;
    LPWSTR pwzNewCopy = NULL;

    if (pwzNew)
    {
        cchLength = lstrlenW(pwzNew);

        // alloc a new buffer w/ room for the null terminator
        pwzNewCopy = (LPWSTR)LocalAlloc(LPTR, (cchLength + 1) * sizeof(WCHAR));

        if (!pwzNewCopy)
            return FALSE;

        HRESULT hr = StringCchCopy(pwzNewCopy, cchLength + 1, pwzNew);
        if (FAILED(hr))
        {
            LocalFree(pwzNewCopy);
            return FALSE;
        }
    }

    pwzOld = (LPWSTR)InterlockedExchangePointer((void * *)ppwzCurrent, (void *)pwzNewCopy);

    if (pwzOld)
        LocalFree(pwzOld);

    return TRUE;
}

//---------------------------------------------------------------------------
// If the string contains &ch or begins with ch then return TRUE.
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand)
{
    LPTSTR pchAS = StrChr(lpsz, TEXT('&')); // Find the first ampersand.
    if (pchAS && !fIgnoreAmpersand)
    {
        // Yep, is the next char the one we want.
        if (CharUpperChar(*CharNext(pchAS)) == CharUpperChar(ch))
        {
            // Yep.
            return TRUE;
        }
    }
    else if (CharUpperChar(*lpsz) == CharUpperChar(ch))
    {
        return TRUE;
    }

    return FALSE;
}

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
void _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject)
{
    RECT    rc;
    POINT   pt;

    GetWindowRect(hwndTarget, &rc);

    //
    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    DAD_DragEnterEx2(hwndTarget, pt, pdtObject);
    return;
}

void _DragMove(HWND hwndTarget, const POINTL ptStart)
{
    RECT rc;
    POINT pt;

    GetWindowRect(hwndTarget, &rc);

    //
    // If hwndTarget is RTL mirrored, then measure the
    // the client point from the visual right edge
    // (near edge in RTL mirrored windows). [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwndTarget))
        pt.x = rc.right - ptStart.x;
    else
        pt.x = ptStart.x - rc.left;

    pt.y = ptStart.y - rc.top;
    DAD_DragMove(pt);
    return;
}



HRESULT CheckDesktopIni(LPCTSTR pszPath, LPCTSTR pszKey, LPTSTR pszBuffer, DWORD cchSize)
{
    // NOTE:
    // NOTE: DO NOT COPY THIS CODE. We only do this here for channels because we expect
    // NOTE: the 99% case to be that it succeeds. If you need to find out if it is a
    // NOTE: system folder, then you need to hack the pidl to get the system bit
    // NOTE:
    DWORD dwAttrs = GetFileAttributes(pszPath);
    if (dwAttrs == (DWORD) -1 || !(dwAttrs & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY)))
        return E_NOINTERFACE;

    TCHAR szDIPath[MAX_PATH];

    if (!PathCombine(szDIPath, pszPath, TEXT("desktop.ini")))
    {
        return E_FAIL;
    }

    if (pszKey == NULL)
    {
        if (GetFileAttributes(szDIPath) == (DWORD) -1)
        {
            return E_FAIL;
        }
    }
    else
    {
        GetPrivateProfileString(TEXT(".ShellClassInfo"), pszKey, TEXT(""), pszBuffer, cchSize, szDIPath);
        if (*pszBuffer == 0)
            return E_NOINTERFACE;

        // if its not a URL, then
        if (!PathIsURL(pszBuffer))
        {
            if (!PathCombine(pszBuffer, pszPath, pszBuffer))
            {
                return E_FAIL;
            }
        }
    }
    return NOERROR;
}

STDAPI LookForDesktopIniText(IShellFolder *psf, LPCITEMIDLIST pidl, LPCTSTR pszKey, LPTSTR pszBuffer, DWORD cchSize)
{
    TCHAR szPath[MAX_PATH];
    DWORD ulFlags = SFGAO_FOLDER | SFGAO_FILESYSTEM;
    HRESULT hr = GetPathForItem(psf, pidl, szPath, &ulFlags);
    if (SUCCEEDED(hr) && (ulFlags & SFGAO_FOLDER))
    {
        hr = CheckDesktopIni(szPath, pszKey, pszBuffer, cchSize);
    }
    return hr;
}

// this is for channel category folders

HRESULT FakeGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl)
{
    HRESULT hres = E_FAIL;

    WIN32_FIND_DATAA wfd;

    // before looking for a desktop.ini (which hits the disk), cheaply
    // see if it's a system folder.
    //
    // SHGetDataFromIDListA returns E_INVALIDARG on IE4.0 shell32 and
    // IE4.01 shell32.  It is fixed in IE4.01qfe shell32 and IE4.01sp1
    // shell32.  It also appears to work on NT4 and W95 shell32.  If
    // SHGetDataFromIDListA returns E_INVALIDARG we drop through and
    // do the slow LookForDesktopIniText call.
    //

    HRESULT hresTemp = SHGetDataFromIDListA(psf, pidl, SHGDFIL_FINDDATA, &wfd, sizeof(wfd));

    // on win95 non integrated, only the A version is implemented
    if ((E_INVALIDARG == hresTemp) ||
        (SUCCEEDED(hresTemp) &&
        (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
        (wfd.dwFileAttributes & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))))
    {
        // final failure case, check to see if it is a system folder with a desktop.ini file. This is gross and slow,
        // but this is only called when the user has navigated so we can be a little slower. Please do NOT COPY this
        // code or DavidDS will get really really upset and perf will be bad.
        TCHAR szBuffer[MAX_URL_STRING];

        // this will check for SFGAO_FOLDER & SFGAO_FILESYSTEM first...
        hres = LookForDesktopIniText(psf, pidl, TEXT("URL"), szBuffer, ARRAYSIZE(szBuffer));
        if (SUCCEEDED(hres))
        {
            DWORD dwChar = ARRAYSIZE(szBuffer);
            // this call uses a temp, so we can reuse the buffer...
            hres = UrlCreateFromPath(szBuffer, szBuffer, &dwChar, 0);
            if (SUCCEEDED(hres))
                hres = IECreateFromPath(szBuffer, ppidl);
        }
    }
    else
    {
        hres = E_FAIL;
    }
    return hres;
}

// Can we browse or navigate to this pidl?  If not, need
BOOL ILIsBrowsable(LPCITEMIDLIST pidl, BOOL *pfIsFolder)
{
    if (!pidl)
        return FALSE;
    DWORD dwAttributes = SFGAO_FOLDER | SFGAO_BROWSABLE;
    HRESULT hr = IEGetAttributesOf(pidl, &dwAttributes);

    if (pfIsFolder && SUCCEEDED(hr))
        *pfIsFolder = dwAttributes & SFGAO_FOLDER;

    return SUCCEEDED(hr) && (dwAttributes & (SFGAO_FOLDER | SFGAO_BROWSABLE));
}



// gets a target pidl given a name space item. typically this is a .lnk or .url file
//
//  in:
//        psf         shell folder for item
//        pidl        item relative to psf, single level
//
//  in/out
//        pdwAttribs  [optional] attributes mask to filter on (returned).
//        must be initalized
//
//
//  returns
//        *ppidl      the target pidl
//        *pdwAttribs [optional] attributes of the source object

STDAPI SHGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl,
                         LPITEMIDLIST *ppidl, DWORD *pdwAttribs)
{
    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(NULL == pdwAttribs || IS_VALID_WRITE_PTR(pdwAttribs, DWORD));
    ASSERT(ILFindLastID(pidl) == pidl);   // must be single level PIDL

    *ppidl = NULL;      // assume failure

    DWORD dwAttribs = SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_LINK | SFGAO_BROWSABLE;

    if (pdwAttribs)
        dwAttribs |= *pdwAttribs;

    HRESULT hres = psf->GetAttributesOf(1, &pidl, &dwAttribs);
    if (SUCCEEDED(hres))
    {
        // first try the most efficient way
        IShellLinkA *psl;       // "A" so this works on Win95
        hres = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IShellLinkA, NULL, &psl));
        if (SUCCEEDED(hres))
        {
            hres = psl->GetIDList(ppidl);
            psl->Release();
        }

        // this is for .lnk and .url files that don't register properly
        if (FAILED(hres) && (dwAttribs & (SFGAO_FILESYSTEM | SFGAO_LINK)) == (SFGAO_FILESYSTEM | SFGAO_LINK))
        {
            TCHAR szPath[MAX_PATH];

            hres = GetPathForItem(psf, pidl, szPath, NULL);
            if (SUCCEEDED(hres))
                hres = GetLinkTargetIDList(szPath, NULL, 0, ppidl);
        }

        // .doc or .html. return the pidl for this.
        // (fully qualify against the folder pidl)
        if (FAILED(hres) && (dwAttribs & SFGAO_BROWSABLE))
        {
            LPITEMIDLIST pidlFolder;
            hres = SHGetIDListFromUnk(psf, &pidlFolder);
            if (SUCCEEDED(hres))
            {
                *ppidl = ILCombine(pidlFolder, pidl); // navigate to this thing...
                hres = *ppidl ? S_OK : E_OUTOFMEMORY;
                ILFree(pidlFolder);
            }
        }

        // channel name space items on non integrated
        if (FAILED(hres) && WhichPlatform() != PLATFORM_INTEGRATED)
        {
            IExtractIconA *pxicon;   // Use IID_IExtractIconA so we work on W95.
            hres = psf->GetUIObjectOf(NULL, 1, &pidl, IID_X_PPV_ARG(IExtractIconA, NULL, &pxicon));
            if (SUCCEEDED(hres))
            {
                hres = pxicon->QueryInterface(IID_PPV_ARG(IShellLinkA, &psl));
                if (SUCCEEDED(hres))
                {
                    hres = psl->GetIDList(ppidl);
                    psl->Release();
                }
                pxicon->Release();
            }
        }

        // Callers of SHGetNavigateTarget assume that the returned pidl
        // is navigatable (SFGAO_FOLDER or SFGAO_BROWSER), which isn't
        // the case for a link (it could be a link to an exe).
        //
        if (SUCCEEDED(hres) && !ILIsBrowsable(*ppidl, NULL))
        {
            ILFree(*ppidl);
            *ppidl = NULL;
            hres = E_FAIL;
        }

        if (SUCCEEDED(hres) && pdwAttribs)
            *pdwAttribs = dwAttribs;
    }
    return hres;
}

BOOL CreateShortcutAndDoDragDropIfPIDLIsNetUrl(IOleCommandTarget *pcmdt, LPITEMIDLIST pidl, HWND hwnd)
{
    IUniformResourceLocator *purl;
    IDataObject *pdtobj;

    HRESULT hr = CreateShortcutSetSiteAndGetDataObjectIfPIDLIsNetUrl(pidl, pcmdt, &purl, &pdtobj);

    if (SUCCEEDED(hr))
    {
        ASSERT(pdtobj);
        ASSERT(purl);

        // REARCHITECT: we should be binding to the parent and getting the attributes
        // to determine the allowed effects - like we do in DragDrop()
        DWORD dwEffect = (DROPEFFECT_COPY | DROPEFFECT_LINK);

        ::_SetPreferedDropEffect(pdtobj, DROPEFFECT_LINK);
        // Win95 Browser Only - the shell32 in this process doesn't know
        // ole is loaded, even though it is.
        SHLoadOLE(SHELLNOTIFY_OLELOADED);

        hr = SHDoDragDrop(hwnd, pdtobj, NULL, dwEffect, &dwEffect);
        // the returned value is not S_OK even tho' the drag drop succeeded
        // however it is a success return
        if (SUCCEEDED(hr))
        {
            // Since drag drop succeeded
            // Bring down the icon for this shortcut
            IUnknown_Exec(purl, &CGID_ShortCut, ISHCUTCMDID_DOWNLOADICON, 0, NULL, NULL);
        }
        pdtobj->Release();
        IUnknown_SetSite(purl, NULL);
        purl->Release();
    }

    return SUCCEEDED(hr);
}

BOOL DoDragDropWithInternetShortcut(IOleCommandTarget *pcmdt, LPITEMIDLIST pidl, HWND hwnd)
{
    BOOL fDragDropDone = CreateShortcutAndDoDragDropIfPIDLIsNetUrl(pcmdt, pidl, hwnd);
    if (FALSE == fDragDropDone)
    {
        // simply use PIDL and get none of the persistence effect
        fDragDropDone = SUCCEEDED(DragDrop(hwnd, NULL, pidl, DROPEFFECT_LINK, NULL));
    }
    return fDragDropDone;
}

STDAPI_(HWND) GetTopLevelAncestor(HWND hWnd)
{
    HWND hwndTemp;

    while ((hwndTemp=GetParent(hWnd)) != NULL)
    {
        hWnd = hwndTemp;
    }

    return(hWnd);
}

#if 0
BOOL IsIERepairOn()
{
    static DWORD     dwChecked = -1;

    if (dwChecked == -1)
    {
        DWORD   dwSize, dwType;

        // First check the OS setting. On NT5 and Win98-OSR, Repair is Off.
        // OS turned Off Repair ==> "DisableRepair" RegValue is set to 1.
        dwChecked = 1;       // The default Repair is ON
        dwSize = sizeof(dwChecked);
        if (SHRegGetUSValue(SZ_REGKEY_ACTIVE_SETUP, SZ_REGVALUE_DISABLE_REPAIR, &dwType, (void *) &dwChecked, &dwSize, TRUE, (void *)NULL, 0) == ERROR_SUCCESS)
        {
            // OS Reg setting of 0 ==> Repair is ON
            // OS Reg setting of 1 ==> Repair is OFF
            dwChecked = (dwChecked == 0) ? 1 : 0;
        }
        else
        {
            dwChecked = 1;   // if we fail to read Reg, go back to default.
        }

        // Check for Admin policy only if OS setting leaves Repair On.
        if (dwChecked == 1)
        {
            dwSize = sizeof(dwChecked);
            if (SHRegGetUSValue(SZ_REGKEY_IE_POLICIES, SZ_REGVALUE_IEREPAIR, &dwType, (void *) &dwChecked, &dwSize, TRUE, (void *)NULL, 0) != ERROR_SUCCESS)
            {
                dwChecked = 1;   // if we fail to read Reg, go back to default.
            }
        }
    }
    return (dwChecked == 1);
}

#endif

BOOL IsResetWebSettingsEnabled(void)
{
    static BOOL fUseCache = FALSE;  // have we already looked up the answer in the registry?
    static BOOL fEnabled;           // is the feature enabled or disabled?

    if (!fUseCache)
    {

        DWORD dwData;
        DWORD dwSize = sizeof(dwData);
        DWORD dwType;

        //
        // Next time, we'll use the cached value instead of
        // looking in the registry
        //
        fUseCache = TRUE;

        //
        // Look up the appropriate ieak value in the registry
        //
        if (ERROR_SUCCESS == SHRegGetUSValue(
                                SZ_REGKEY_INETCPL_POLICIES,
                                SZ_REGVALUE_RESETWEBSETTINGS,
                                &dwType,
                                (void *)&dwData,
                                &dwSize,
                                FALSE,
                                NULL,
                                0))
        {
            //
            // If the value was found in the registry, then
            // set fEnabled accordingly
            //
            fEnabled = !dwData;

        }
        else
        {
            //
            // If the value is missing from the registry, then
            // assume the feature is enabled
            //
            fEnabled = TRUE;

        }

    }

    return fEnabled;

}

STDAPI_(BOOL) InitOCHostClass(const SHDRC * pshdrc)
{
    // It would be nice to remove this, but since it was exported, we keep it here for compat
    RIPMSG(FALSE, "This export is dead, caller needs to call SHDOCVW!DllRegisterWindowClasses directly");
    return DllRegisterWindowClasses(pshdrc);
}

STDAPI SHNavigateToFavorite(IShellFolder* psf, LPCITEMIDLIST pidl, IUnknown* punkSite, DWORD dwFlags)
{
    HRESULT hres = S_FALSE;

    TCHAR szPath[MAX_PATH];

    // Can we navigate to this favorite?
    BOOL fNavigateDone = SUCCEEDED(GetPathForItem(psf, pidl, szPath, NULL)) &&
                         SUCCEEDED(NavFrameWithFile(szPath, punkSite));
    if (fNavigateDone)
        return S_OK;

    LPITEMIDLIST pidlGoto;

    ASSERT(!(dwFlags & (SBSP_NEWBROWSER | SBSP_SAMEBROWSER)));
    
    if (SUCCEEDED(SHGetNavigateTarget(psf, pidl, &pidlGoto, NULL)))
    {
        IShellBrowser* psb;
        if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_STopLevelBrowser,
            IID_PPV_ARG(IShellBrowser, &psb))))
        {
            hres = psb->BrowseObject(pidlGoto, dwFlags | SBSP_SAMEBROWSER);
            psb->Release();
        }
        ILFree(pidlGoto);
    }
    return hres;
}
STDAPI SHGetTopBrowserWindow(IUnknown* punk, HWND* phwnd)
{
    IOleWindow* pOleWindow;
    HRESULT hr = IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_PPV_ARG(IOleWindow, &pOleWindow));
    if (SUCCEEDED(hr))
    {
        hr = pOleWindow->GetWindow(phwnd);
        pOleWindow->Release();
    }
    return hr;
}


BOOL ILIsFolder(LPCITEMIDLIST pidl)
{
    BOOL fIsFolder = FALSE;
    DWORD dwAttributes = SFGAO_FOLDER;
    HRESULT hr = IEGetAttributesOf(pidl, &dwAttributes);

    if (SFGAO_FOLDER == dwAttributes)
        fIsFolder = TRUE;

    return fIsFolder;
}


STDAPI_(LPITEMIDLIST) IEGetInternetRootID(void)
{
    LPITEMIDLIST pidl;

    //
    //  HACKHACK - we want the pidl to the Internet SF
    //  so we make a dummy URL and parse it.  then
    //  we know its parent will be the Internet SF.
    //
    if (SUCCEEDED(IECreateFromPath(TEXT("dummy://url"), &pidl)))
    {
        ASSERT(!ILIsEmpty(_ILNext(pidl)));
        ASSERT(IsURLChild(pidl, FALSE));

        //  we only want the parent Internt SF
        _ILNext(pidl)->mkid.cb = 0;
        return pidl;
    }
    return NULL;
}

STDAPI_(void) UpdateButtonArray(TBBUTTON *ptbDst, const TBBUTTON *ptbSrc, int ctb, LONG_PTR lStrOffset)
{
    memcpy(ptbDst, ptbSrc, ctb*sizeof(TBBUTTON));
    if (lStrOffset == -1)
    {
        // handle failure case
        for (int i = 0; i < ctb; i++)
            ptbDst[i].iString = 0;
    }
    else
    {
        for (int i = 0; i < ctb; i++)
            ptbDst[i].iString += lStrOffset;
    }
}

//----------------------------------------------------------------------------
//  <Swipped from the NT5 version of Shell32>
//
STDAPI PathToAppPathKey(LPCTSTR pszPath, LPTSTR pszKey, int cchKey)
{
    HRESULT hr;
    // Use the szTemp variable of pseem to build key to the programs specific
    // key in the registry as well as other things...
    hr = StringCchCopy(pszKey, cchKey, REGSTR_PATH_APPPATHS);
    if (SUCCEEDED(hr))
    {
        hr = StringCchCat(pszKey, cchKey, TEXT("\\"));
        if (SUCCEEDED(hr))
        {
            hr = StringCchCat(pszKey, cchKey, PathFindFileName(pszPath));
            if (SUCCEEDED(hr))
            {
                // Currently we will only look up .EXE if an extension is not
                // specified
                if (*PathFindExtension(pszKey) == 0)
                {
                    hr = StringCchCat(pszKey, cchKey, TEXT(".exe"));
                }
            }
        }
    }
    return hr;
}

//----------------------------------------------------------------------------
//  <Swipped from the NT5 version of Shell32>
//
// this function checks for the existance of a value called "useURL" under the
// App Paths key in the registry associated with the app that is passed in.

STDAPI_(BOOL) DoesAppWantUrl(LPCTSTR pszCmdLine)
{
    TCHAR szRegKeyName[MAX_PATH];
    HKEY hKeyAppPaths;
    BOOL bRet = FALSE;

// bug 61538 - The edit button never passes in args or quotes and the 
// code below was screwing up if there were spaces in the path.
//
    // need to copy the string since PathRemoveArgs whacks in a \0
//    TCHAR szTemp[MAX_PATH];
//    lstrcpyn(szTemp, pszCmdLine, ARRAYSIZE(szTemp));
//    PathRemoveArgs(szTemp);
//    PathUnquoteSpaces(szTemp);

    HRESULT hr;
    hr = PathToAppPathKey(pszCmdLine, szRegKeyName, ARRAYSIZE(szRegKeyName));
    if (SUCCEEDED(hr))
    {
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegKeyName, 0L, KEY_QUERY_VALUE, &hKeyAppPaths) == ERROR_SUCCESS)
        {
            bRet = RegQueryValueEx(hKeyAppPaths, TEXT("UseURL"), NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
            RegCloseKey(hKeyAppPaths);
        }
    }

    return bRet;
}


// thread reference count object, this uses SHSetThreadRef()to let other code
// in this process hold a reference to this main thread, and thus the main thread in this process

class CRefThread : public IUnknown
{
public:
    // IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    CRefThread(LONG *pcRef);

private:
    ~CRefThread();

    LONG *_pcRef;
    UINT _idThread;
};


CRefThread::CRefThread(LONG *pcRef) 
{
    _idThread = GetCurrentThreadId();
    _pcRef = pcRef;
    *_pcRef = 1;

}

//
//  Note that this code tightens but does not close a race window.
//  Although we nuke the process reference, the class factory for
//  the web browser has yet to be deregistered, so if somebody decides
//  to create one, our class factory will wake up and create a
//  shell folder, which will flake out because it can't get a
//  process reference.
//
CRefThread::~CRefThread() 
{
    // Avoid re-entrancy during destruction
    *_pcRef = 1000;

    // If we are the process reference, then revoke the process reference
    // since we're going away.

    IUnknown *punk;
    SHGetInstanceExplorer(&punk);
    if (punk == this)
        SHSetInstanceExplorer(NULL);
    ATOMICRELEASE(punk);

    // Nobody should've rescued our reference
    ASSERT(*_pcRef == 1000);
    *_pcRef = 0;

    // get the other thread out of WaitMessage() or GetMessage()
    PostThreadMessage(_idThread, WM_NULL, 0, 0);
}


HRESULT CRefThread::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { { 0 }, };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CRefThread::AddRef()
{
    return InterlockedIncrement(_pcRef);
}

ULONG CRefThread::Release()
{
    ASSERT( 0 != *_pcRef );
    ULONG cRef = InterlockedDecrement(_pcRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDAPI SHCreateThreadRef(LONG *pcRef, IUnknown **ppunk)
{
    *ppunk = new CRefThread(pcRef);
    if (*ppunk)
        return S_OK;

    *pcRef = 0;
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

//
// Returns the cache file associated with a URL.  For file: urls, the associated
// disk file is returned.  Not that we don't use URLDownloadToCacheFile because 
// it causes another I-M-S GET to to be sent to the server
//
HRESULT URLToCacheFile
(
    LPCWSTR pszUrl,
    LPWSTR pszFile,
    int    cchFile
)
{
    HRESULT hr;
    DWORD dwScheme = GetUrlScheme(pszUrl);

    if (URL_SCHEME_FILE == dwScheme)
    {
        ULONG cch = cchFile;
        hr = PathCreateFromUrl(pszUrl, pszFile, &cch, 0);
    }
    else
    {
        // bug 73386 - GetUrlCacheEntryInfoExW fails to find entries if there is an anchor
        // so we have to whack it off.
        //
        // We should really fix GetUrlCacheEntryInfoExW instead, but apparently 
        // this is risky for 5.x
        //
        hr = S_OK;
        WCHAR szUrlBuf[MAX_URL_STRING];
        if (URL_SCHEME_HTTP == dwScheme || URL_SCHEME_HTTPS == dwScheme)
        {
            LPWSTR pszAnchor = StrChr(pszUrl, L'#');
            if (pszAnchor)
            {
                hr = StringCchCopyN(szUrlBuf, ARRAYSIZE(szUrlBuf), pszUrl, pszAnchor - pszUrl);

                pszUrl = szUrlBuf;
            }
        }

        if (SUCCEEDED(hr))
        {
            char szBuf[1024];
            LPINTERNET_CACHE_ENTRY_INFOW pCE = (LPINTERNET_CACHE_ENTRY_INFOW)szBuf;
            DWORD dwEntrySize = sizeof(szBuf);

            BOOL fGotCacheInfo = GetUrlCacheEntryInfoExW(pszUrl, pCE, &dwEntrySize, NULL, NULL, NULL, 0);
            if (!fGotCacheInfo)
            {
                if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                {
                    // We guessed too small for the buffer so allocate the correct size & retry
                    pCE = (LPINTERNET_CACHE_ENTRY_INFOW)LocalAlloc(LPTR, dwEntrySize);
                    if (pCE)
                    {
                        fGotCacheInfo = GetUrlCacheEntryInfoEx(pszUrl, pCE, &dwEntrySize, NULL, NULL, NULL, 0);
                    }
                }
                else
                {
                    // Retry using UTF8 encoding
                    //
                    // This fix belongs in GetUrlCacheEntryInfoEx (StevePro 01/19/99)
                    //
                    char szUrl[MAX_URL_STRING];
                    if (SHUnicodeToAnsiCP(CP_UTF8, pszUrl, szUrl, ARRAYSIZE(szUrl)))
                    {
                        szUrl[ARRAYSIZE(szUrl)-1] = '\0';   // paranoia

                        // UrlEscapeA Internally converts to unicode which messes up utf8.  So we
                        // copy the string to a WCHAR buffer without coverting and call the unicode version.
                        // Yuk!
                        WCHAR wzUrl[ARRAYSIZE(szUrl)];
                        char* psz = szUrl;
                        WCHAR* pwz = wzUrl;

                        while (*psz!= NULL)
                        {
                            *pwz++ = ((WCHAR)*psz++) & 0xff;
                        }
                        *pwz = L'\0';

                        ULONG cch = ARRAYSIZE(wzUrl);
                        UrlEscapeW(wzUrl, wzUrl, &cch, /*URL_ESCAPE_PERCENT*/0);

                        psz = szUrl;
                        pwz = wzUrl;
                        while (*pwz!= NULL)
                        {
                            *psz++ = (char)LOWORD(*pwz++);
                        }
                        *psz = '\0';

                        LPINTERNET_CACHE_ENTRY_INFOA pCEA = (LPINTERNET_CACHE_ENTRY_INFOA)szBuf;
                        dwEntrySize = sizeof(szBuf);

                        BOOL fUtf8Worked = GetUrlCacheEntryInfoExA(szUrl, pCEA, &dwEntrySize, NULL, NULL, NULL, 0);
                        if (!fUtf8Worked)
                        {
                            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                            {
                                // We guessed too small for the buffer so allocate the correct size & retry
                                pCEA = (LPINTERNET_CACHE_ENTRY_INFOA)LocalAlloc(LPTR, dwEntrySize);
                                if (pCEA)
                                {
                                    fUtf8Worked = GetUrlCacheEntryInfoExA(szUrl, pCEA, &dwEntrySize, NULL, NULL, NULL, 0);
                                }
                            }
                        }

                        if (fUtf8Worked)
                        {
                            if (SHAnsiToUnicode(pCEA->lpszLocalFileName, pszFile, cchFile) >= cchFile)
                            {
                                hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                            }
                            else
                            {
                                hr = S_OK;
                            }
                        }

                        if ((char *)pCEA != szBuf)
                        {
                            LocalFree((HLOCAL)pCEA);
                        }
                    }
                }
            }

            if (fGotCacheInfo)
            {
                hr = StringCchCopy(pszFile, cchFile, pCE->lpszLocalFileName);
            }

            // Free our GetUrlCacheEntryInfo buffer if we allocated one
            if ((char *)pCE != szBuf)
            {
                LocalFree((HLOCAL)pCE);
            }
        }
    }
    return hr;
}

#ifdef DEBUG
void DebugDumpPidl(DWORD dwDumpFlag, LPTSTR pszOutputString, LPCITEMIDLIST pidl)
{
    if (g_dwDumpFlags & dwDumpFlag)
    {
        TCHAR szPath[MAX_PATH];
        LPTSTR lpsz;
        if (pidl)  
        {
            lpsz = szPath;
            SHGetPathFromIDList(pidl, szPath);
        } 
        else 
        {
            lpsz = TEXT("(NULL)");
        }
        TraceMsg(TF_ALWAYS, "%s: \"%s\"", pszOutputString, lpsz);
    }
}
#endif

// Variable argument version that ultimately call FormatMessageLiteW
BOOL __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...)
{
    BOOL fRet;
    va_list ArgList;
    va_start(ArgList, cchBuf);

    fRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szTemplate, 0, 0, szBuf, cchBuf, &ArgList);

    va_end(ArgList);
    return fRet;
}


// [msadek], On win9x we get the message thru a chain from explorer /iexplore (ANSI app.).
// and pass it to comctl32 (Unicode) so it will fail to match the hot key.
// the system sends the message with ANSI char and we treated it as Unicode.
// It looks like noone is affected with this bug (US, FE) since they have hot keys always in Latin.
// Bidi platforms are affected since they do have hot keys in native language.

WPARAM AnsiWparamToUnicode(WPARAM wParam)
{
    char szCh[2];
    WCHAR wszCh[2];
    szCh[0] = (BYTE)wParam;
    szCh[1] = '\0';

    if (MultiByteToWideChar(CP_ACP, 0, (LPCSTR)szCh, ARRAYSIZE(szCh),
                                   wszCh, ARRAYSIZE(wszCh)))
    {
        memcpy(&wParam, wszCh, sizeof(WCHAR));
    }

    return wParam;
}

void SHOutlineRect(HDC hdc, const RECT* prc, COLORREF cr)
{
    RECT rc;
    COLORREF clrSave = SetBkColor(hdc, cr);
    
    //top
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->top + 1;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //left
    rc.left = prc->left;
    rc.top = prc->top;
    rc.right = prc->left + 1;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    //right
    rc.left = prc->right - 1;
    rc.top = prc->top;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    // bottom
    rc.left = prc->left;
    rc.top = prc->bottom - 1;
    rc.right = prc->right;
    rc.bottom = prc->bottom;
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);

    SetBkColor(hdc, clrSave);
}

HMONITOR GetPrimaryMonitor()
{
    POINT pt = {0,0};
    return MonitorFromPoint(pt, MONITOR_DEFAULTTOPRIMARY); 
}

// Gets the Monitor's bounding or work rectangle, if the hMon is bad, return
// the primary monitor's bounding rectangle. 
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork)
{
    MONITORINFO mi; 
    mi.cbSize = sizeof(mi);
    if (hMon && GetMonitorInfo(hMon, &mi))
    {
        if (!prc)
            return TRUE;
        
        else if (bWork)
            CopyRect(prc, &mi.rcWork);
        else 
            CopyRect(prc, &mi.rcMonitor);
        
        return TRUE;
    }
    
    if (prc)
        SetRect(prc, 0, 0, GetSystemMetrics(SM_CXSCREEN), GetSystemMetrics(SM_CYSCREEN));
    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
//  Utils to load background bitmap for toolbars etc.
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////



//------------------------------------------------------------------------
// determine source name for bitmap, sift thru IE history....
HRESULT _GetBackBitmapLocation(LPTSTR psz, BOOL fInternet)
{
    HRESULT hres = E_FAIL;
    DWORD dwType;
    DWORD dwcbData;
    static const TCHAR c_szRegKeyCoolbar[] = TSZIEPATH TEXT("\\Toolbar");

    // IE4 shipped back bitmap customization affecting both browser and shell.
    // IE5 wants these to be separate customizations.  But in the roaming
    // case a customized IE4 customer shouldn't lose customization when going
    // to the IE5 machine.  So we might need to check twice:
    //
    if (fInternet)
    {
        // Try the IE5 internet location.
        dwcbData = MAX_PATH * sizeof(TCHAR);
        hres = SHGetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("BackBitmapIE5"), &dwType, psz, &dwcbData);
    }
    else
    {
        // Try the NT5 shell location.
        dwcbData = MAX_PATH * sizeof(TCHAR);
        hres = SHGetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("BackBitmapShell"), &dwType, psz, &dwcbData);
    }
    if (ERROR_SUCCESS != hres)
    {
        // Try the old combined internet/shell location
        dwcbData = MAX_PATH * sizeof(TCHAR);
        hres = SHGetValue(HKEY_CURRENT_USER, c_szRegKeyCoolbar, TEXT("BackBitmap"), &dwType, psz, &dwcbData);
    }

    return hres;
}


//------------------------------------------------------------------------
//  determine background settings and source for toolbar,
//  load bitmap (file/resource) and update cache
HBITMAP LoadToolbarBackBmp(LPTSTR * ppszBitmap, BMPCACHE * pbmpCache, BOOL fInternet)
{
    HIGHCONTRAST    hc;
    HBITMAP     hbmp = pbmpCache->hbmp;
    COLORREF    cr3D = GetSysColor(COLOR_3DFACE);
    TCHAR       szScratch[MAX_PATH];
    LPTSTR      pszBitmap = NULL;
    BOOL        fBitmapInvalid = FALSE;


    ENTERCRITICAL;

    // If the stashed hbmp's cr3D color changed, we need to mark invalid
    if (pbmpCache->hbmp && pbmpCache->cr3D != cr3D)
        fBitmapInvalid = TRUE;

    // get the location spec for the bitmap
    hc.cbSize = sizeof(HIGHCONTRAST);
    if ((SystemParametersInfoA(SPI_GETHIGHCONTRAST, hc.cbSize, (LPVOID) &hc, FALSE)) &&
        (hc.dwFlags & HCF_HIGHCONTRASTON))
    {
        // we have no bitmap in high contrast
    }
    else if (SUCCEEDED(_GetBackBitmapLocation(szScratch, fInternet)))
    {
        pszBitmap = szScratch;
    }

    // if they are removing the bitmap, we need to mark invalid
    if (!pszBitmap && *ppszBitmap)
        fBitmapInvalid = TRUE;

    // or it's location has been changed, we need to mark invalid
    if (pszBitmap && (!*ppszBitmap || lstrcmpi(pszBitmap, *ppszBitmap)))
        fBitmapInvalid = TRUE;

    if (fBitmapInvalid)
    {
        TraceMsg(DM_ITBAR, "LoadToolbarBackBmp: Loading Background Bitmap");

        Str_SetPtr(ppszBitmap, pszBitmap);

        hbmp=NULL;
        if (*ppszBitmap)
        {
            if ((*ppszBitmap)[0])
            {
                hbmp = (HBITMAP) LoadImage(NULL, szScratch, IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADFROMFILE | LR_LOADMAP3DCOLORS );
            }

            if (!hbmp)
            {
#ifdef OLD_SWIRLY_BACKDROP
                if (SHGetCurColorRes() <= 8)
                    hbmp = (HBITMAP) LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_BACK), IMAGE_BITMAP, 0, 0, LR_DEFAULTSIZE | LR_CREATEDIBSECTION | LR_LOADMAP3DCOLORS );
#endif
            }
        }

#ifdef OLD_LEGACY_BAD_COLOUR_CODE
        if (hbmp)
        {
            // mapping needed ?
            // DONTWORRYABOUTTHIS: this will be removed as soon as I get the new backdrop....
            if ( /* cr3D != RGB(192,192,192) */ FALSE)
            {
                RGBQUAD     rgbTable[256];
                RGBQUAD     rgbFace;
                HDC         dc;
                HBITMAP     hbmSave;
                UINT        i;
                UINT        n;

                dc = CreateCompatibleDC(NULL);
                hbmSave = (HBITMAP)SelectObject(dc, hbmp);
                n = GetDIBColorTable(dc, 0, 256, rgbTable);

                rgbFace.rgbRed   = GetRValue(cr3D);
                rgbFace.rgbGreen = GetGValue(cr3D);
                rgbFace.rgbBlue  = GetBValue(cr3D);

                for (i = 0; i < n; i++)
                {
                    if ( rgbTable[i].rgbRed == 192 && rgbTable[i].rgbGreen == 192 && rgbTable[i].rgbBlue == 192 )
                    {
                        rgbTable[i] = rgbFace;
                    }
                    else
                    {
                        rgbTable[i].rgbRed   = (rgbTable[i].rgbRed   * rgbFace.rgbRed  ) / 192;
                        rgbTable[i].rgbGreen = (rgbTable[i].rgbGreen * rgbFace.rgbGreen) / 192;
                        rgbTable[i].rgbBlue  = (rgbTable[i].rgbBlue  * rgbFace.rgbBlue ) / 192;
                    }
                }

                SetDIBColorTable(dc, 0, n, rgbTable);
                SelectObject(dc, hbmSave);
                DeleteDC(dc);
            }
        }
#endif

        if (pbmpCache->hbmp)
            DeleteObject(pbmpCache->hbmp);
        pbmpCache->hbmp = hbmp;
        pbmpCache->cr3D = cr3D;
    }

    LEAVECRITICAL;

    return hbmp;
}


VOID StripDecorations(PTSTR pszTitle, BOOL fStripAmp)
{
    LPTSTR  pszCleaned = pszTitle;    // work in-place
    LPCTSTR psz = pszTitle;
    while (*psz && (*psz != TEXT('\t')))
    {
        if (*psz != TEXT('&') || !fStripAmp)
        {
            *pszCleaned = *psz;
            pszCleaned++;
        }
        psz++;
    }
    *pszCleaned = TEXT('\0');
}

//------------------------------------------------------------------------
LPCTSTR UnescapeDoubleAmpersand(LPTSTR pszTitle)
{
    LPTSTR  pszCleaned = pszTitle;    // work in-place
    LPCTSTR psz = pszTitle;
    bool fEscapedAmp = false;
    while (*psz)
    {
        if (*psz != TEXT('&') || fEscapedAmp)
        {
            // copy character
            *pszCleaned = *psz;
            pszCleaned++;
            fEscapedAmp = false;
        }
        else
        {
            LPCTSTR pszNext = psz + 1;
            if (pszNext && (*pszNext == TEXT('&'))) {
                fEscapedAmp = true; // keep next ampersand
            }
        }
        psz++;
    }
    *pszCleaned = TEXT('\0');
    return pszTitle;
}

UINT MapClsidToID(REFCLSID rclsid)
{
    UINT nCmdID;

    nCmdID = 0;

    if (IsEqualCLSID(CLSID_SearchBand, rclsid))
        nCmdID = FCIDM_VBBSEARCHBAND;
    else if (IsEqualCLSID(CLSID_FavBand, rclsid))
        nCmdID = FCIDM_VBBFAVORITESBAND;
    else if (IsEqualCLSID(CLSID_HistBand, rclsid))
        nCmdID = FCIDM_VBBHISTORYBAND;
    else if (IsEqualCLSID(CLSID_ExplorerBand, rclsid))
        nCmdID = FCIDM_VBBEXPLORERBAND;
    else if (IsEqualCLSID(CLSID_FileSearchBand, rclsid))
        nCmdID = FCIDM_VBBSEARCHBAND;

    return nCmdID;        
}


// Create mask from given bitmap, use color at pixel (x/y) as transparent color
HBITMAP CreateMaskBitmap(HDC hdc, int x, int y, HBITMAP hbmpImage)
{
    ASSERT(hbmpImage);
    BITMAP bm;
    if (::GetObject(hbmpImage, sizeof(BITMAP), &bm) != sizeof(BITMAP)) {
        return FALSE;
    }

    HDC hdcImg = NULL;
    HDC hdcMask = NULL;
    HBITMAP hbmpMask = NULL;
    HBITMAP hbmpOldImg = NULL;
    HBITMAP hbmpOldMsk = NULL;
    COLORREF clrTransparent = 0;

    hdcImg = ::CreateCompatibleDC(hdc);
    if (hdcImg == NULL)     goto _CMBcleanup;
    hdcMask = ::CreateCompatibleDC(hdc);
    if (hdcMask == NULL)    goto _CMBcleanup;

    hbmpMask = ::CreateBitmap(bm.bmWidth, bm.bmHeight, 1, 1, NULL);
    if (hbmpMask == NULL)   goto _CMBcleanup;
    hbmpOldImg = (HBITMAP) ::SelectObject(hdcImg, hbmpImage);
    hbmpOldMsk = (HBITMAP) ::SelectObject(hdcMask, hbmpMask);

    clrTransparent = ::GetPixel(hdcImg, 0, 0);
    ::SetBkColor(hdcImg, clrTransparent);
    ::BitBlt(hdcMask, 0, 0, bm.bmWidth, bm.bmHeight, hdcImg, 0, 0, SRCCOPY);

_CMBcleanup:
    if (hbmpOldImg && hdcImg)
        SelectObject(hdcImg, hbmpOldImg);
    if (hdcImg)
        DeleteDC(hdcImg);
    if (hbmpOldMsk && hdcMask)
        SelectObject(hdcMask, hbmpOldMsk);
    if (hdcMask)
        DeleteDC(hdcMask);

    return hbmpMask;
}

// draw bitmap transparently; on Win2K and up, one could use MaskBlt()
BOOL DrawTransparentBitmapPart(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbmpImage, HBITMAP hbmpMask)
{
    ASSERT(hbmpImage);
    BITMAP bm;
    if (::GetObject(hbmpImage, sizeof(BITMAP), &bm) != sizeof(BITMAP)) {
        return FALSE;
    }

    HBITMAP hbmpTmpMask = NULL;
    // create temporary mask bitmap if none supplied
    if (hbmpMask == NULL) {
        hbmpMask = hbmpTmpMask = CreateMaskBitmap(hdc, 0, 0, hbmpImage);
    }
    if (hbmpMask == NULL) {
        return FALSE;
    }

    HDC hdcOffScr = NULL;
    HBITMAP hbmOffScr = NULL;
    HBITMAP hbmOldOffScr = NULL;
    HDC hdcImage = NULL;
    HBITMAP hbmOldImage = NULL;
    HDC hdcMask = NULL;
    HBITMAP hbmOldMask = NULL;

    // draw.to offscreen bitmap
    hdcOffScr = ::CreateCompatibleDC(hdc);
    if (hdcOffScr == NULL)      goto _DTBcleanup;
    hbmOffScr = ::CreateBitmap(dx, dy,GetDeviceCaps(hdc, PLANES),
                               (BYTE)GetDeviceCaps(hdc, BITSPIXEL), NULL);
    if (hbmOffScr == NULL)      goto _DTBcleanup;
    hbmOldOffScr = (HBITMAP)::SelectObject(hdcOffScr, hbmOffScr);

    // Copy the image of the destination rectangle to the
    // off-screen buffer DC, so we can play with it.
    ::BitBlt(hdcOffScr, 0, 0, dx, dy, hdc, x, y, SRCCOPY);

    // prepare DCs for both image and mask
    hdcImage = ::CreateCompatibleDC(hdc); 
    if (hdcImage == NULL)       goto _DTBcleanup;
    hbmOldImage = (HBITMAP)::SelectObject(hdcImage, hbmpImage);
    hdcMask = ::CreateCompatibleDC(hdc);
    if (hdcMask == NULL)        goto _DTBcleanup;
    hbmOldMask = (HBITMAP)::SelectObject(hdcMask, hbmpMask);

    ::SetBkColor(hdcOffScr, RGB(255,255,255));
    ::BitBlt(hdcOffScr, 0, 0, dx, dy, hdcImage, 0, 0, SRCINVERT);
    ::BitBlt(hdcOffScr, 0, 0, dx, dy, hdcMask,  0, 0, SRCAND);
    ::BitBlt(hdcOffScr, 0, 0, dx, dy, hdcImage, 0, 0, SRCINVERT);

    // Copy the resultant image back to the screen DC.
    ::BitBlt(hdc,       x, y, dx, dy, hdcOffScr, 0, 0, SRCCOPY);

_DTBcleanup:
    if (hdcOffScr && hbmOldOffScr)
        ::SelectObject(hdcOffScr, hbmOldOffScr);
    if (hdcOffScr)
        ::DeleteDC(hdcOffScr);
    if (hbmOffScr)
        ::DeleteObject(hbmOffScr);

    if (hdcImage && hbmOldImage)
        ::SelectObject(hdcImage, hbmOldImage);
    if (hdcImage)
        ::DeleteDC(hdcImage);

    if (hdcMask && hbmOldMask)
        ::SelectObject(hdcMask, hbmOldMask);
    if (hdcMask)
        ::DeleteDC(hdcMask);
    if (hbmpTmpMask)
        ::DeleteObject(hbmpTmpMask);

    return TRUE;
}

// draw bitmap transparently; on Win2K and up, one could use MaskBlt()
BOOL DrawTransparentBitmap(HDC hdc, int x, int y, HBITMAP hbmpImage, HBITMAP hbmpMask)
{
    ASSERT(hbmpImage);
    BITMAP bm;
    if (::GetObject(hbmpImage, sizeof(BITMAP), &bm) != sizeof(BITMAP)) {
        return FALSE;
    }

    return DrawTransparentBitmapPart(hdc, x, y, bm.bmWidth, bm.bmHeight, hbmpImage, hbmpMask);
}

//------------------------------------------------------------------------
BOOL
    DrawAlphaBitmap(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbmpImage)
{
    BLENDFUNCTION bf = {0};
    HDC hdcImage = ::CreateCompatibleDC(hdc);
    if (hdcImage == NULL) {
        return false;
    }
    HBITMAP hbmOldImage = (HBITMAP)::SelectObject(hdcImage, hbmpImage);

    bf.BlendOp = AC_SRC_OVER;
    bf.SourceConstantAlpha = 255;
    bf.AlphaFormat = AC_SRC_ALPHA;
    AlphaBlend(hdc, x, y, dx, dy, hdcImage, 0, 0, dx, dy, bf);
    
    if (hbmOldImage) {
        SelectObject(hdcImage, hbmOldImage);
    }
    DESTROY_OBJ_WITH_HANDLE(hdcImage, DeleteObject);

    return true;
}


STDAPI_(IDeskBand *) FindBandByClsidBS(IBandSite *pbs, REFCLSID clsidToFind)
{
    DWORD dwBandID;
    for (int i = 0; SUCCEEDED(pbs->EnumBands(i, &dwBandID)); i++) 
    {
        IDeskBand *pstb;
        HRESULT hr = pbs->QueryBand(dwBandID, &pstb, NULL, NULL, 0);
        if (SUCCEEDED(hr)) 
        {
            CLSID clsid;

            hr = IUnknown_GetClassID(pstb, &clsid);
            if (SUCCEEDED(hr) && IsEqualGUID(clsidToFind, clsid)) 
            {
                return pstb;
            }
            pstb->Release();
        }
    }

    return NULL;
}

HIMAGELIST CreateImageList(HINSTANCE hi, LPCTSTR lpbmp, int cx, int cGrow, COLORREF crMask,
                           UINT uType, UINT uFlags, BOOL bUseNewMirroringSupport)
{
    HBITMAP hbmImage;
    HIMAGELIST piml = NULL;
    BITMAP bm;
    int cy, cInitial;
    UINT flags;

    hbmImage = (HBITMAP)LoadImage(hi, lpbmp, uType, 0, 0, uFlags);
    if (hbmImage && (sizeof(bm) == GetObject(hbmImage, sizeof(bm), &bm)))
    {
        // If cx is not stated assume it is the same as cy.
        // ASSERT(cx);
        cy = bm.bmHeight;

        if (cx == 0)
            cx = cy;

        cInitial = bm.bmWidth / cx;

        ENTERCRITICAL;

        if (bUseNewMirroringSupport)
        {
            flags = ILC_MIRROR | PrivateILC_PERITEMMIRROR;
        }
        else
        {
            flags = 0;
        }

        if (crMask != CLR_NONE)
            flags |= ILC_MASK;
        if (bm.bmBits)
            flags |= (bm.bmBitsPixel & ILC_COLORMASK);

        piml = ImageList_Create(cx, cy, flags, cInitial, cGrow);
        if (piml)
        {
            int added;

            if (crMask == CLR_NONE)
                added = ImageList_Add(piml, hbmImage, NULL);
            else
                added = ImageList_AddMasked(piml, hbmImage, crMask);

            if (added < 0)
            {
                ImageList_Destroy(piml);
                piml = NULL;
            }
        }
        LEAVECRITICAL;
    }

    if (hbmImage)
        DeleteObject(hbmImage);

    return piml;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\xbarglyph.h ===
//------------------------------------------------------------------------
//
//  Microsoft Windows 
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:      XBarGlyph.h
//
//  Contents:  image of an xBar pane
//
//  Classes:   CXBarGlyph
//
//------------------------------------------------------------------------

#ifndef _XBAR_GLYPH_H_
#define _XBAR_GLYPH_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


//------------------------------------------------------------------------
// encapsule the image used by xBar panes,
// can potentially be any format, for now we only support icon format
class CXBarGlyph  :
        public     CRefCount
{
public:
	                    CXBarGlyph();
protected:
	virtual            ~CXBarGlyph();

// operations
public:
    HRESULT             SetIcon(HICON hIcon, BOOL fAlpha);
    HICON               GetIcon(void);
    BOOL                IsAlpha(void)   { return _fAlpha; }
    BOOL                HaveGlyph(void);
    LONG                GetWidth(void);
    LONG                GetHeight(void);
    HRESULT             LoadGlyphFile(LPCTSTR pszPath, BOOL fSmall);
    HRESULT             LoadDefaultGlyph(BOOL fSmall, BOOL fHot);
    HRESULT             Draw(HDC hdc, int x, int y);

private:
    void                _EnsureDimensions(void);

// attributes
protected:
    HBITMAP             _hbmpColor;
    HBITMAP             _hbmpMask;
    BOOL                _fAlpha;
    LONG                _lWidth;
    LONG                _lHeight;

private:
};

#endif // !defined(_XBAR_GLYPH_H_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\dll\makefile.inc ===
..\browseui.rc : $(CCSHELL_DIR)\lib\$O\brdispp.tlb $(SELFREGNAME) $(BROWSELCR_DEP)

!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\util.h ===
#ifndef _UTIL_H_
#define _UTIL_H_

int IsVK_TABCycler(MSG *pMsg);
BOOL IsVK_CtlTABCycler(MSG *pMsg);

#ifdef __cplusplus
extern "C" {
#endif

BOOL __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...);

HRESULT IUnknown_FileSysChange(IUnknown* punk, DWORD dwEvent, LPCITEMIDLIST* ppidl);
HRESULT QueryService_SID_IBandProxy(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj);
HRESULT CreateIBandProxyAndSetSite(IUnknown * punkParent, REFIID riid, IBandProxy ** ppbp, void **ppvObj);
DWORD GetPreferedDropEffect(IDataObject *pdtobj);
HRESULT _SetPreferedDropEffect(IDataObject *pdtobj, DWORD dwEffect);
#ifdef DEBUG
int SearchDWP(DWORD_PTR *pdwBuf, int cbBuf, DWORD_PTR dwVal);
#endif


#define REGVALUE_STREAMSA           "Streams"
#define REGVALUE_STREAMS            TEXT(REGVALUE_STREAMSA)

#define SZ_REGKEY_TYPEDCMDMRU       TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU")
#define SZ_REGKEY_TYPEDURLMRU       TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs")
#define SZ_REGVAL_MRUENTRY          TEXT("url%lu")

#define SZ_REGKEY_INETCPL_POLICIES   TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define SZ_REGVALUE_RESETWEBSETTINGS TEXT("ResetWebSettings")

#define SZ_REGKEY_IE_POLICIES       TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Main")
#define SZ_REGVALUE_IEREPAIR        TEXT("Repair IE Option")
#define SZ_REGKEY_ACTIVE_SETUP      TEXT("Software\\Microsoft\\Active Setup")
#define SZ_REGVALUE_DISABLE_REPAIR  TEXT("DisableRepair")

#if 0
BOOL    IsIERepairOn();
#endif

BOOL IsResetWebSettingsEnabled(void);

HRESULT GetMRUEntry(HKEY hKey, DWORD dwMRUIndex, LPTSTR pszMRUEntry, DWORD cchMRUEntry, LPITEMIDLIST * ppidl);

extern UINT g_cfURL;
extern UINT g_cfHIDA;
extern UINT g_cfFileDescA;
extern UINT g_cfFileDescW;
extern UINT g_cfFileContents;

extern const CLSID g_clsidNull; // for those that want a NULL clsid.

void InitClipboardFormats();

// raymondc's futile attempt to reduce confusion
//
// EICH_KBLAH = a registry key named blah
// EICH_SBLAH = a win.ini section named blah

#define EICH_UNKNOWN        0xFFFFFFFF
#define EICH_KINET          0x00000002
#define EICH_KINETMAIN      0x00000004
#define EICH_KWIN           0x00000008
#define EICH_KWINPOLICY     0x00000010
#define EICH_KWINEXPLORER   0x00000020
#define EICH_SSAVETASKBAR   0x00000040
#define EICH_SWINDOWMETRICS 0x00000080
#define EICH_SPOLICY        0x00000100
#define EICH_SSHELLMENU     0x00000200
#define EICH_KWINEXPLSMICO  0x00000400
#define EICH_SWINDOWS       0x00000800

DWORD SHIsExplorerIniChange(WPARAM wParam, LPARAM lParam);


#define GEN_DEBUGSTRW(str)  ((str) ? (str) : L"<Null Str>")
#define GEN_DEBUGSTRA(str)  ((str) ? (str) : "<Null Str>")

#ifdef UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRW
#else // UNICODE
#define GEN_DEBUGSTR  GEN_DEBUGSTRA
#endif // UNICODE


void _InitAppGlobals();
BOOL _InitComCtl32();


void* DataObj_GetDataOfType(IDataObject* pdtobj, UINT cfType, STGMEDIUM *pstg);
HRESULT RootCreateFromPath(LPCTSTR pszPath, LPITEMIDLIST * ppidl);

extern DEFFOLDERSETTINGS g_dfs;

STDAPI_(void) SaveDefaultFolderSettings(UINT flags);
STDAPI_(void) GetCabState(CABINETSTATE *pcs);

//-------------------------------------------------------------------------

//***   Reg_GetStrs -- read registry strings into struct fields
struct regstrs
{
    LPTSTR  name;   // registry name
    int     off;    // struct offset
};

BOOL    ViewIDFromViewMode(UINT uViewMode, SHELLVIEWID *pvid);
void Reg_GetStrs(HKEY hkey, const struct regstrs *tab, TCHAR *szBuf, int cchBuf, void *pv);

HRESULT DropOnMailRecipient(IDataObject *pdtobj, DWORD grfKeyState);
HRESULT SendDocToMailRecipient(LPCITEMIDLIST pidl, UINT uiCodePage, DWORD grfKeyState, IUnknown *pUnkSite);

#ifdef DEBUG
void    Dbg_DumpMenu(LPCTSTR psz, HMENU hmenu);
#else
#define Dbg_DumpMenu(psz, hmenu)
#endif

extern const LARGE_INTEGER c_li0;
extern BOOL g_fNewNotify;
// FEATURE: Need to handle two different implementations of SHChangeRegister...
typedef ULONG (* PFNSHCHANGENOTIFYREGISTER)(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, int cEntries, SHChangeNotifyEntry *pshcne);
typedef BOOL  (* PFNSHCHANGENOTIFYDEREGISTER)(unsigned long ulID);

ULONG RegisterNotify(HWND hwnd, UINT nMsg, LPCITEMIDLIST pidl, DWORD dwEvents, UINT uFlags, BOOL fRecursive);

int PropBag_ReadInt4(IPropertyBag* pPropBag, LPWSTR pszKey, int iDefault);
HINSTANCE HinstShdocvw();
HINSTANCE HinstShell32();

extern const VARIANT c_vaEmpty;
#define PVAREMPTY ((VARIANT*)&c_vaEmpty)

BOOL ILIsBrowsable(LPCITEMIDLIST pidl, BOOL *pfISFolder);

STDAPI_(LPITEMIDLIST) IEILCreate(UINT cbSize);

BOOL GetInfoTipEx(IShellFolder* psf, DWORD dwFlags, LPCITEMIDLIST pidl, LPTSTR pszText, int cchTextMax);
BOOL IsBrowsableShellExt(LPCITEMIDLIST pidl);
void OpenFolderPidl(LPCITEMIDLIST pidl);
void OpenFolderPath(LPCTSTR pszPath);
int WINAPI _SHHandleUpdateImage( LPCITEMIDLIST pidlExtra );

extern BOOL g_fICWCheckComplete;
BOOL    CheckSoftwareUpdateUI( HWND hwndOwner, IShellBrowser *pisb );
BOOL    CheckRunICW(LPCTSTR);

#ifdef DEBUG
LPTSTR Dbg_PidlStr(LPCITEMIDLIST pidl, LPTSTR pszBuffer, DWORD cchBufferSize);
#else // DEBUG
#define Dbg_PidlStr(pidl, pszBuffer, cchBufferSize)   ((LPTSTR)NULL)
#endif // DEBUG

HRESULT SavePidlAsLink(IUnknown* punkSite, IStream *pstm, LPCITEMIDLIST pidl);
HRESULT LoadPidlAsLink(IUnknown* punkSite, IStream *pstm, LPITEMIDLIST *ppidl);

#define ADJUST_TO_WCHAR_POS     0
#define ADJUST_TO_TCHAR_POS     1
int AdjustECPosition(char *psz, int iPos, int iType);
BOOL ExecItemFromFolder(HWND hwnd, LPCSTR pszVerb, IShellFolder* psf, LPCITEMIDLIST pidlItem);

// See if a give URL is actually present as an installed entry
STDAPI_(BOOL) CallCoInternetQueryInfo(LPCTSTR pszURL, QUERYOPTION QueryOption);
#define UrlIsInstalledEntry(pszURL) CallCoInternetQueryInfo(pszURL, QUERY_IS_INSTALLEDENTRY)

BOOL IsSubscribableA(LPCSTR pszUrl);
BOOL IsSubscribableW(LPCWSTR pwzUrl);

HRESULT IURLQualifyW(IN LPCWSTR pcwzURL, DWORD dwFlags, OUT LPWSTR pwzTranslatedURL, LPBOOL pbWasSearchURL, LPBOOL pbWasCorrected);

#ifdef UNICODE
#define IsSubscribable IsSubscribableW
#define IURLQualifyT   IURLQualifyW
#else // UNICODE
#define IsSubscribable IsSubscribableA
#define IURLQualifyT   IURLQualifyA
#endif // UNICODE

#define IURLQualifyA   IURLQualify


HDPA    GetSortedIDList(LPITEMIDLIST pidl);
void    FreeSortedIDList(HDPA hdpa);

//#define StopWatch       StopWatchT

int GetColorComponent(LPSTR *ppsz);
COLORREF RegGetColorRefString( HKEY hkey, LPTSTR RegValue, COLORREF Value);
LRESULT SetHyperlinkCursor(IShellFolder* pShellFolder, LPCITEMIDLIST pidl);

HRESULT StrCmpIWithRoot(LPCTSTR szDispNameIn, BOOL fTotalStrCmp, LPTSTR * ppszCachedRoot);
STDAPI UpdateSubscriptions();

enum TRI_STATE
{
    TRI_UNKNOWN = 2,
    TRI_TRUE = TRUE,
    TRI_FALSE = FALSE
};
LONG OpenRegUSKey(LPCTSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);
HWND GetTrayWindow();

#define STREAMSIZE_UNKNOWN  0xFFFFFFFF
HRESULT SaveStreamHeader(IStream *pstm, DWORD dwSignature, DWORD dwVersion, DWORD dwSize);
HRESULT LoadStreamHeader(IStream *pstm, DWORD dwSignature, DWORD dwStartVersion, DWORD dwEndVersion, DWORD * pdwSize, DWORD * pdwVersionOut);

// _FrameTrack flags
#define TRACKHOT        0x0001
#define TRACKEXPAND     0x0002
#define TRACKNOCHILD    0x0004
void FrameTrack(HDC hdc, LPRECT prc, UINT uFlags);

#ifdef __cplusplus
//+-------------------------------------------------------------------------
// This function scans the document for the given HTML tag and returns the
// result in a collection.
//--------------------------------------------------------------------------
interface IHTMLDocument2;
interface IHTMLElementCollection;
HRESULT GetDocumentTags(IHTMLDocument2* pHTMLDocument, LPOLESTR pszTagName, IHTMLElementCollection** ppTagsCollection);


// CMenuList:  a small class that tracks whether a given hmenu belongs
//             to the frame or the object, so the messages can be
//             dispatched correctly.
class CMenuList
{
public:
    CMenuList(void);
    ~CMenuList(void);

    void Set(HMENU hmenuShared, HMENU hmenuFrame);
    void AddMenu(HMENU hmenu);
    void RemoveMenu(HMENU hmenu);
    BOOL IsObjectMenu(HMENU hmenu);

#ifdef DEBUG
    void Dump(LPCTSTR pszMsg);
#endif

private:
    HDSA    _hdsa;
};


};
#endif


#ifdef __cplusplus
class CAssociationList
{
public:
    //
    // WARNING: We don't want a destructor on this because then it can't
    // be a global object without bringing in the CRT main.  So
    // we can't free the DSA in a destructor.  The DSA memory will be
    // freed by the OS when the process detaches.  If this
    // class is ever dynamically allocated (ie not a static) then
    // we will need to free the DSA.
    //
//    ~CAssociationList();
    BOOL    Add(DWORD dwKey, LPVOID lpData);
    void    Delete(DWORD dwKey);
    HRESULT Find(DWORD dwKey, LPVOID* ppData);

protected:
    int     FindEntry(DWORD dwKey);

    struct ASSOCDATA
    {
            DWORD dwKey;
            LPVOID lpData;
    };

    HDSA    _hdsa;
};

#endif

STDAPI_(void) DrawMenuItem(DRAWITEMSTRUCT* pdi, LPCTSTR lpszMenuText, UINT iIcon);
STDAPI_(LRESULT) MeasureMenuItem(MEASUREITEMSTRUCT *lpmi, LPCTSTR lpszMenuText);

void FireEventSz(LPCTSTR szEvent);
#ifndef UNICODE
void FireEventSzW(LPCWSTR szEvent);
#else
#define FireEventSzW FireEventSz
#endif

// comctl32.dll doesn't really implement Str_SetPtrW.
STDAPI_(BOOL) Str_SetPtrPrivateW(WCHAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew);

// This function is similar to Str_SetPtrPrivateW but it is compatible with API's
// that use LocalAlloc for string memory
STDAPI_(BOOL) SetStr(WCHAR * UNALIGNED * ppwzCurrent, LPCWSTR pwzNew);

// Review chrisny:  this can be moved into an object easily to handle generic droptarget, dropcursor
// , autoscrool, etc. . .
STDAPI_(void) _DragEnter(HWND hwndTarget, const POINTL ptStart, IDataObject *pdtObject);
STDAPI_(void) _DragMove(HWND hwndTarget, const POINTL ptStart);

#define Str_SetPtrW         Str_SetPtrPrivateW

STDAPI_(BOOL) _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand);

STDAPI GetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl, DWORD *pdwAttribs);

STDAPI_(BOOL) DoDragDropWithInternetShortcut(IOleCommandTarget *pcmdt, LPITEMIDLIST pidl, HWND hwnd);

STDAPI_(BSTR) SysAllocStringA(LPCSTR);

#ifdef UNICODE
#define SysAllocStringT(psz)    SysAllocString(psz)
#else
#define SysAllocStringT(psz)    SysAllocStringA(psz)
#endif

void EnableOKButton(HWND hDlg, int id, LPTSTR pszText);
BOOL IsExplorerWindow(HWND hwnd);
BOOL IsFolderWindow(HWND hwnd);

STDAPI_(BOOL) WasOpenedAsBrowser(IUnknown *punkSite);

STDAPI_(HWND) GetTopLevelAncestor(HWND hWnd);

STDAPI SHNavigateToFavorite(IShellFolder* psf, LPCITEMIDLIST pidl, IUnknown* punkSite, DWORD dwFlags);
STDAPI SHGetTopBrowserWindow(IUnknown* punk, HWND* phwnd);
STDAPI_(void) UpdateButtonArray(TBBUTTON *ptbDst, const TBBUTTON *ptbSrc, int ctb, LONG_PTR lStrOffset);
STDAPI_(BOOL) DoesAppWantUrl(LPCTSTR pszCmdLine);

STDAPI SHCreateThreadRef(LONG *pcRef, IUnknown **ppunk);
BOOL ILIsFolder(LPCITEMIDLIST pidl);
HRESULT URLToCacheFile(LPCWSTR pszUrl, LPWSTR pszFile, int cchFile);

#ifdef DEBUG
void DebugDumpPidl(DWORD dwDumpFlag, LPTSTR pszOutputString, LPCITEMIDLIST pidl);
#else
#define DebugDumpPidl(p, q, w)
#endif

STDAPI_(LPITEMIDLIST) SafeILClone(LPCITEMIDLIST pidl);
#define ILClone         SafeILClone   

WPARAM AnsiWparamToUnicode(WPARAM wParam);
HMONITOR GetPrimaryMonitor();
BOOL GetMonitorRects(HMONITOR hMon, LPRECT prc, BOOL bWork);
#define GetMonitorRect(hMon, prc) \
        GetMonitorRects((hMon), (prc), FALSE)
#define GetMonitorWorkArea(hMon, prc) \
        GetMonitorRects((hMon), (prc), TRUE)
#define IsMonitorValid(hMon) \
        GetMonitorRects((hMon), NULL, TRUE)
#define GetNumberOfMonitors() \
        GetSystemMetrics(SM_CMONITORS)

void SHOutlineRect(HDC hdc, const RECT* prc, COLORREF cr);



//------------------------------------------------------------------------
typedef struct tagBMPCACHE
{
    HBITMAP hbmp;
    COLORREF cr3D;
} BMPCACHE;


//------------------------------------------------------------------------
//  determine background settings and source for toolbar,
//  load bitmap (file/resource) and update cache
HBITMAP LoadToolbarBackBmp(LPTSTR * ppszBitmap, BMPCACHE * pbmpCache, BOOL fInternet);

UINT MapClsidToID(REFCLSID rclsid);

VOID StripDecorations(PTSTR psz, BOOL fStripAmp);
LPCTSTR UnescapeDoubleAmpersand(LPTSTR pszTitle);

// Create mask from given bitmap, use color at pixel (x/y) as transparent color
HBITMAP CreateMaskBitmap(HDC hdc, int x, int y, HBITMAP hbmpImage);

// draw bitmap transparently; on Win2K and up, one could use MaskBlt()
BOOL DrawTransparentBitmap(HDC hdc, int x, int y, HBITMAP hbmpImage, HBITMAP hbmpMask);
BOOL DrawTransparentBitmapPart(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbmpImage, HBITMAP hbmpMask);
BOOL DrawAlphaBitmap(HDC hdc, int x, int y, int dx, int dy, HBITMAP hbmpImage);


STDAPI_(IDeskBand *) FindBandByClsidBS(IBandSite *pbs, REFCLSID clsid);
HIMAGELIST CreateImageList(HINSTANCE hi, LPCTSTR lpbmp, int cx, int cGrow, COLORREF crMask,
                           UINT uType, UINT uFlags, BOOL bUseNewMirroringSupport);


#ifdef __cplusplus
//------------------------------------------------------------------------
// ref count base class for non-COM classes
class CRefCount
{
public:
                    CRefCount() : _cRef(0) {};
    ULONG           AddRef(void)
                    {
                        return InterlockedIncrement(&_cRef);
                    }

    ULONG           Release(void)
                    {
                        ASSERT( 0 != _cRef );
                        ULONG cRef = InterlockedDecrement(&_cRef);
                        if ( 0 == cRef )
                        {
                            delete this;
                        }
                        return cRef;
                    }

protected:
    virtual        ~CRefCount() {};

    long            _cRef;
};


//------------------------------------------------------------------------
// smart pointer for non-COM classes
template <class T>
    class _NoAddRefReleaseOnCRefPtr : public T
{
    private:
        STDMETHOD_(ULONG, AddRef)()=0;
        STDMETHOD_(ULONG, Release)()=0;
};

//------------------------------------------------------------------------
template<class T>
    class CRefPtr
{
public:
    CRefPtr()
    {
        _p = NULL;
    }
    CRefPtr(T* p)
    {
        _p = p;
        if (_p != NULL)
            _p->AddRef();
    }
    CRefPtr(const CRefPtr<T>& p)
    {
        _p = p;
        if (_p != NULL)
            _p->AddRef();
    }
    ~CRefPtr()
    {
        if (_p)
            _p->Release();
    }
    void Release()
    {
        T* pTemp = _p;
        if (pTemp)
        {
            _p = NULL;
            pTemp->Release();
        }
    }
    operator T*() const
    {
        return (T*)_p;
    }
    T& operator*() const
    {
        ASSERT(_p != NULL);
        return *_p;
    }
    //The assert on operator& usually indicates a bug.  If this is really
    //what is needed, however, take the address of the p member explicitly.
    T** operator&()
    {
        ASSERT(_p == NULL);
        return &_p;
    }
    _NoAddRefReleaseOnCRefPtr<T>* operator->() const
    {
        ASSERT(_p != NULL);
        return (_NoAddRefReleaseOnCRefPtr<T>*)_p;
    }
    T* operator=(T* p)
    {
        if (p != NULL)
            p->AddRef();
        if (_p)
            (_p)->Release();
        _p = p;
        return p;
    }
    T* operator=(const CRefPtr<T>& p)
    {
        if (p != NULL)
            p->AddRef();
        if (_p)
            (_p)->Release();
        _p = p;
        return p;
    }
    bool operator!() const
    {
        return (_p == NULL);
    }
    bool operator<(T* pT) const
    {
        return _p < pT;
    }
    bool operator==(T* pT) const
    {
        return _p == pT;
    }
    T* Detach()
    {
        T* pt = _p;
        _p = NULL;  // no release here, hand out live ptr!
        return pt;
    }
private:
    T   *_p;
};

#endif // __cplusplus

#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\emclient\regdb.cpp ===
#include "priv.h"
#include <runtask.h>
#include "uacount.h"
#include "regdb.h"
#include "uemapp.h"
#include "uareg.h"

#define DM_UEMTRACE     TF_UEM
#define DM_PERF         0           // perf tune

#define DB_NOLOG        FALSE

#define SZ_CTLSESSION       TEXT("UEME_CTLSESSION")
#define SZ_CUACount_ctor    TEXT("UEME_CTLCUACount:ctor")

#define SZ_DEL_PREFIX       TEXT("del.")
#define SZ_RUN_PREFIX       TEXT("UEME_RUN")


//***
// DESCRIPTION
//  inc this any time you change the format of *anything* below {guid}
//  doing so will cause us to nuke the {guid} subtree and start fresh
#define UA_VERSION      3

#if 0
char c_szDotDot[] = TEXT("..");     // RegStrFS does *not* support
#endif


// kind of hoaky to do INITGUID, but we want the GUID private to this file
#define INITGUID
#include <initguid.h>
// {C28EB156-523C-11d2-A561-00A0C92DBFE8}
DEFINE_GUID(CLSID_GCTaskTOID,
    0xc28eb156, 0x523c, 0x11d2, 0xa5, 0x61, 0x0, 0xa0, 0xc9, 0x2d, 0xbf, 0xe8);
#undef  INITGUID


class CGCTask : public CRunnableTask
{
public:
    //*** IUnknown
    // (... from CRunnableTask)

    //*** THISCLASS
    HRESULT Initialize(CEMDBLog *that);
    virtual STDMETHODIMP RunInitRT();

protected:
    CGCTask();
    virtual ~CGCTask();

    friend CGCTask *CGCTask_Create(CEMDBLog *that);

    CEMDBLog    *_that;
};


// {
//***   CEMDBLog --

//CRITICAL_SECTION g_csDbSvr /*=0*/ ;

CEMDBLog *g_uempDbSvr[UEMIND_NSTANDARD + UEMIND_NINSTR];    // 0=shell 1=browser

//***   g_fDidUAGC -- breadcrumbs in case we die (even non-DEBUG)
// keep minimal state in case we deadlock or die or whatever
// 0:not 1:pre-task 2:pre-GC 3:post-GC
int g_fDidUAGC;


FNNRW3 CEMDBLog::s_Nrw3Info = {
    CEMDBLog::s_Read,
    CEMDBLog::s_Write,
    CEMDBLog::s_Delete,
};

//*** helpers {

#define E_NUKE      (E_FAIL + 1)

//***   RegGetVersion -- check registry tree 'Version'
// ENTRY/EXIT
//  (see RegChkVersion)
//  hr          (ret) S_OK:ok  S_FALSE:no tree  E_NUKE:old  E_FAIL:new
HRESULT RegGetVersion(HKEY hk, LPTSTR pszSubkey, LPTSTR pszValue, DWORD dwVers)
{
    HRESULT hr;
    HKEY hk2;

    if (RegOpenKeyEx(hk, pszSubkey, 0, KEY_QUERY_VALUE, &hk2) == ERROR_SUCCESS)
    {
        if (!pszValue)
            pszValue = TEXT("Version");

        hr = E_NUKE;                    // assume version mismatch
        DWORD dwData;
        if (SHRegGetDWORD(hk2, NULL, pszValue, &dwData) == ERROR_SUCCESS)
        {
            if (dwData == dwVers)
                hr = S_OK;              // great!
            else if (dwData > dwVers)
                hr = E_FAIL;            // we're an old client, fail
            else
                ASSERT(hr == E_NUKE);   // we're a new client, nuke it
        }
        RegCloseKey(hk2);
    }
    else
    {
        hr = S_FALSE;                   // assume nothing there at all
    }

    return hr;
}

//***   RegChkVersion -- check registry tree 'version', nuke if outdated 
// ENTRY/EXIT
//  hk          e.g. hkey for "HKCU/.../Uassist"
//  pszSubkey   e.g. "{clsid}"
//  pszValue    e.g. "Version"
//  dwVers      e.g. 3
//  hr          (ret) S_OK:matched, S_FAIL:mismatched and del'ed, E_FAIL:o.w.
//  (other)     (SE) pszSubkey deleted if not matched
HRESULT RegChkVersion(HKEY hk, LPTSTR pszSubkey, LPTSTR pszValue, DWORD dwVers)
{
    HRESULT hr;
    DWORD i;

    // RegGetVersion()  S_OK:ok  S_FALSE:new  E_NUKE:old  E_FAIL:fail
    hr = RegGetVersion(hk, pszSubkey, pszValue, dwVers);

    // at this point, we have:
    //  S_OK: ok
    //  S_FALSE: entire tree missing
    //  E_NUKE: no "Version" or old version (nuke it)
    //  E_FAIL: new version (we can't handle it)
    if (hr == E_FAIL) {
        TraceMsg(DM_UEMTRACE, "bui.rcv: incompat (uplevel)");
    }

    if (hr == E_NUKE) {
        TraceMsg(DM_UEMTRACE, "bui.rcv: bad tree, try delete");
        hr = S_FALSE;       // assume nuked
        i = SHDeleteKey(hk, pszSubkey);
        if (i != ERROR_SUCCESS) {
            TraceMsg(DM_UEMTRACE, "bui.rcv: delete failed!");
            hr = E_FAIL;    // bogus tree left laying around
        }
    }

    TraceMsg(DM_UEMTRACE, "bui.rcv: hr=0x%x", hr);

    return hr;
}

//***   GetUEMLogger -- get the (shared) instance of our logger object
// NOTES
//  BY DESIGN: we leak g_uempDbSvr.
//  race condition on g_uempDbSvr.  our caller guards against this.
//  the 5 billion ASSERTs below were for diagnosing nt5:145449 (fixed).
HRESULT GetUEMLogger(int iSvr, CEMDBLog **p)
{
    HRESULT hr, hrVers;
    CEMDBLog *pDbSvr;
    DWORD dwData, cbSize;

    ASSERT(iSvr < ARRAYSIZE(g_uempDbSvr));
    pDbSvr = g_uempDbSvr[iSvr];

    if (pDbSvr) {
        pDbSvr->AddRef();
        *p = pDbSvr;
        return S_OK;
    }

    pDbSvr = CEMDBLog_Create();

    if (EVAL(pDbSvr)) {
        TCHAR szClass[GUIDSTR_MAX];     // "{clsid}"

        SHStringFromGUID(IND_NONINSTR(iSvr) ? UEMIID_BROWSER : UEMIID_SHELL, szClass, GUIDSTR_MAX);
        TraceMsg(DM_UEMTRACE, "bui.gul: UEMIID_%s=%s", IND_NONINSTR(iSvr) ? TEXT("BROWSER") : TEXT("SHELL"), szClass);

        hr = pDbSvr->ChDir(!IND_ISINSTR(iSvr) ? SZ_UASSIST : SZ_UASSIST2);
        if (SUCCEEDED(hr)) {
            hrVers = RegChkVersion(pDbSvr->GetHkey(), szClass, SZ_UAVERSION, UA_VERSION);
            if (FAILED(hrVers)) {
                TraceMsg(DM_UEMTRACE, "bui.gul: rcv()=0x%x (!)", hrVers);
                hr = hrVers;
            }
        }
        if (SUCCEEDED(hr)) {
            hr = pDbSvr->ChDir(szClass);
            ASSERT(hrVers == S_OK || hrVers == S_FALSE);
            if (SUCCEEDED(hr) && hrVers == S_FALSE) {
                dwData = UA_VERSION;
                cbSize = SIZEOF(dwData);
                hr = pDbSvr->SetValue(SZ_UAVERSION, REG_DWORD, (BYTE*)&dwData, cbSize);
            }
        }
        if (SUCCEEDED(hr))
            hr = pDbSvr->ChDir(SZ_COUNT);

        // n.b. we can't call pDbSvr->GarbageCollect here since flags
        // (e.g. _fNoDecay) not set yet
        // pDbSvr->GarbageCollect(FALSE);

        if (FAILED(hr)) 
        {
            // this fails during RunOnce
            pDbSvr->Release();
            pDbSvr = NULL;
        }
    }

    if (pDbSvr) {
        ENTERCRITICAL;
        if (g_uempDbSvr[iSvr] == 0) {
            g_uempDbSvr[iSvr] = pDbSvr;     // xfer refcnt
            pDbSvr = NULL;
        }
        LEAVECRITICAL;
        if (pDbSvr)
            pDbSvr->Release();
    }

    *p = g_uempDbSvr[iSvr];

    return *p ? S_OK : E_FAIL;
}

CEMDBLog::CEMDBLog() : _cRef(1)
{
    ASSERT(_fBackup == FALSE);
    ASSERT(_fNoEncrypt == FALSE);
    return;
}

CEMDBLog::~CEMDBLog()
{
#if XXX_CACHE
    int i;

    for (i = 0; i < ARRAYSIZE(_rgCache); i++) 
    {
        if (_rgCache[i].pv) 
        {
            LocalFree(_rgCache[i].pv);
            _rgCache[i].pv = NULL;
            _rgCache[i].cbSize = 0;

        }
    }
#endif

    SetRoot(0, STGM_READ);         // close
    ASSERT(!_hkey);

    return;
}

void CEMDBLog_CleanUp()
{
    int i;
    CEMDBLog *pDbSvr;

    TraceMsg(DM_UEMTRACE, "bui.uadb_cu: cleaning up");
    for (i = 0; i < UEMIND_NSTANDARD + UEMIND_NINSTR; i++) {
        if ((pDbSvr = (CEMDBLog *)InterlockedExchangePointer((void**) &g_uempDbSvr[i], (LPVOID) -1)))
            delete pDbSvr;
    }
    return;
}


HRESULT CEMDBLog::Initialize(HKEY hkey, DWORD grfMode)
{
    HRESULT hr;

    hr = SetRoot(hkey, grfMode);
    return hr;
}

//***
//  hkey        e.g. HKLM
//  pszSubKey   e.g. "...\\Explorer\\Instance\\{...}"
//  grfMode     subset of STGM_* values
HRESULT CEMDBLog::SetRoot(HKEY hkeyNew, DWORD grfMode)
{
    ASSERT(grfMode == STGM_READ || grfMode == STGM_WRITE);
    if (_hkey) {
        RegCloseKey(_hkey);
        _grfMode = 0;
        _hkey = 0;
    }

    if (hkeyNew) {
        _grfMode = grfMode;
        _hkey = SHRegDuplicateHKey(hkeyNew);    // xfer ownership (and up khey refcnt)
        if (_hkey == NULL)
            return E_FAIL;
    }

    return S_OK;
}

HRESULT CEMDBLog::ChDir(LPCTSTR pszSubKey)
{
    RIPMSG(!!pszSubKey, "ChDir: caller passed invalid pszSubKey!");

    HRESULT hr;

    if (pszSubKey)
    {
        if (_hkey && (_grfMode == STGM_READ || _grfMode == STGM_WRITE))
        {
            LONG lr;
            HKEY hkeyNew;
            
            if (_grfMode == STGM_READ)
            {
                lr = RegOpenKeyEx(_hkey, pszSubKey, 0, KEY_QUERY_VALUE, &hkeyNew);
            }
            else
            {
                lr = RegCreateKeyEx(_hkey, pszSubKey, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_QUERY_VALUE | KEY_SET_VALUE | DELETE, NULL, &hkeyNew, NULL);
            }

            if (lr == ERROR_SUCCESS)
            {
                RegCloseKey(_hkey);
                _hkey = hkeyNew;
            }

            hr = HRESULT_FROM_WIN32(lr);
        }
        else
        {
            ASSERT(_hkey);
            ASSERT(_grfMode == STGM_READ || _grfMode == STGM_WRITE);
            hr = E_UNEXPECTED;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

//***   CEMDBLog -- file-system-like view of registry
// DESCRIPTION
//  basically keeps track of where we are and does 'relative' opens from
// there.  NYI: intent is to eventually support 'chdir' ops.
// NOTES
//

CEMDBLog *CEMDBLog_Create()
{
    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, TRUE);
    if (hk)
    {
        CEMDBLog *prsfs = new CEMDBLog;
        if (prsfs && FAILED(prsfs->Initialize(hk, STGM_WRITE))) {
            prsfs->Release();
            prsfs = NULL;
        }
        RegCloseKey(hk);
        return prsfs;
    }
    return NULL;

}

//***   IsREG_XX_SZ -- see if ansi/unicode is an issue
//
#define IsREG_XX_SZ(dwTyp) \
    ((dwTyp) == REG_SZ || (dwTyp) == REG_MULTI_SZ || (dwTyp) == REG_EXPAND_SZ)

HRESULT CEMDBLog::QueryValue(LPCTSTR pszName, BYTE *pbData, LPDWORD pcbData)
{
    long i;
    DWORD dwType;

    i = SHQueryValueEx(_hkey, pszName, NULL, &dwType, pbData, pcbData);
    ASSERT(i != ERROR_SUCCESS || !IsREG_XX_SZ(dwType));
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CEMDBLog::SetValue(LPCTSTR pszName, DWORD dwType, const BYTE *pbData, DWORD cbData)
{
    long i;

    ASSERT(_grfMode == STGM_WRITE);

    ASSERT(!IsREG_XX_SZ(dwType));
    i = RegSetValueEx(_hkey, pszName, NULL, dwType, pbData, cbData);
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CEMDBLog::DeleteValue(LPCTSTR pszName)
{
    long i;

    ASSERT(_grfMode == STGM_WRITE);
    i = SHDeleteValue(_hkey, NULL, pszName);
    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}

HRESULT CEMDBLog::RmDir(LPCTSTR pszName, BOOL fRecurse)
{
    HRESULT hr = E_FAIL;
    DWORD i;

    ASSERT(fRecurse);   // others NYI

    ASSERT(_grfMode == STGM_WRITE);

    if (fRecurse) {
        i = SHDeleteKey(_hkey, pszName);
    }
    else {
        // not sure what to do, since we want a non-recursive delete
        // but we do want to handle presence of values (which shlwapi
        // doesn't support)
        //i = DeleteEmptyKey(_hkey, pszName);
        i = -1;
    }

    return (i == ERROR_SUCCESS) ? S_OK : E_FAIL;
}


//***   THIS::Count -- increment profile count for command
// ENTRY/EXIT
//  fUpdate     FALSE for the GC case (since can't update reg during RegEnum)
// NOTES
HRESULT CEMDBLog::GetCount(LPCTSTR pszCmd)
{
    return _GetCountRW(pszCmd, TRUE);
}

// Returns the Filetime that is encoded in the Count Object. 
// note: we do a delayed upgrade of the binary stream in the registry. We will
// use the old uem count info, but tack on the new filetime information when we increment the useage.
FILETIME CEMDBLog::GetFileTime(LPCTSTR pszCmd)
{
    NRWINFO rwi;
    HRESULT hres;
    CUACount aCnt;
    rwi.self = this;
    rwi.pszName = pszCmd;
    // This is a bizzar way of reading a string from the registry....
    hres = aCnt.LoadFrom(&s_Nrw3Info, &rwi);
    return aCnt.GetFileTime();
}


HRESULT CEMDBLog::_GetCountRW(LPCTSTR pszCmd, BOOL fUpdate)
{
    HRESULT hr;
    CUACount aCnt;
    NRWINFO rwi;
    int i;

    hr = _GetCountWithDefault(pszCmd, TRUE, &aCnt);

    i = aCnt.GetCount();

    if (fUpdate) {
        rwi.self = this;
        rwi.pszName = pszCmd;
        hr = aCnt.SaveTo(FALSE, &s_Nrw3Info, &rwi);
    }

    return i;
}

//***
// ENTRY/EXIT
//  hr  (ret) S_OK if dead, o.w. != S_OK
HRESULT CEMDBLog::IsDead(LPCTSTR pszCmd)
{
    HRESULT hr;

    hr = _GetCountRW(pszCmd, FALSE);
    return hr;
}

extern DWORD g_dCleanSess;

//***
// NOTES
//  we need to be careful not to party on guys that either aren't counts
// (e.g. UEME_CTLSESSION), or are 'special' (e.g. UEME_CTLCUACOUNT), or
// shouldn't be deleted (e.g. "del.xxx").  for now we take a conservative
// approach and just nuke things w/ UEME_RUN* as a prefix.  better might
// be to use a dope vector and delete anything that's marked as 'cleanup'.
HRESULT CEMDBLog::GarbageCollect(BOOL fForce)
{
    int i;

    if (!fForce) {
        if (g_dCleanSess != 0) {
            i = GetSessionId();
            if ((i % g_dCleanSess) != 0) {
                TraceMsg(DM_UEMTRACE, "uadb.gc: skip");
                return S_FALSE;
            }
        }
    }

    g_fDidUAGC = 1;     // breadcrumbs in case we die (even non-DEBUG)

    // do _GarbageCollectSlow(), in the background
    HRESULT hr = E_FAIL;
    CGCTask *pTask = CGCTask_Create(this);
    if (pTask) {
        IShellTaskScheduler *pSched;
        hr = CoCreateInstance(CLSID_SharedTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_IShellTaskScheduler, (void**)&pSched);

        if (SUCCEEDED(hr)) {
            hr = pSched->AddTask(pTask, CLSID_GCTaskTOID, 0L, ITSAT_DEFAULT_PRIORITY);
            pSched->Release();  // (o.k. even if task hasn't completed)
        }
        pTask->Release();
    }

    return hr;
}

HRESULT CEMDBLog::_GarbageCollectSlow()
{
    HKEY hk;
    int i;
    DWORD dwI, dwCch, dwType;
    HDSA hdsa;
    TCHAR *p;
    TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];

    TraceMsg(DM_UEMTRACE, "uadb.gc: hit");

    hdsa = DSA_Create(SIZEOF(szKey), 4);    // max size, oh well...
    if (hdsa) {
        TCHAR  szRun[SIZEOF(SZ_RUN_PREFIX)];
        TCHAR  szTemp[SIZEOF(SZ_RUN_PREFIX)];
        TCHAR *pszTemp;
 
        pszTemp = _MayEncrypt(SZ_RUN_PREFIX, szTemp, ARRAYSIZE(szTemp));
        StringCchCopy(szRun, ARRAYSIZE(szRun), pszTemp);
        ASSERT(lstrlen(szRun) == lstrlen(SZ_RUN_PREFIX));
        hk = GetHkey();
        for (dwI = 0; ; dwI++) {
            dwCch = ARRAYSIZE(szKey);
            if (SHEnumValue(hk, dwI, szKey, &dwCch, &dwType, NULL, NULL) != NOERROR)
                break;
            if (StrCmpN(szKey, szRun, ARRAYSIZE(szRun) - 1) == 0) {
                if (IsDead(szKey) == S_OK)
                    DSA_AppendItem(hdsa, szKey);
            }
        }

        for (i = DSA_GetItemCount(hdsa) - 1; i > 0; i--) {
            p = (TCHAR *)DSA_GetItemPtr(hdsa, i);
            TraceMsg(DM_UEMTRACE, "uadb.gc: nuke %s", p);
            GetCount(p);    // decay to 0 will delete
        }

        DSA_Destroy(hdsa);
        hdsa = NULL;
    }

    return S_OK;
}

HRESULT CEMDBLog::IncCount(LPCTSTR pszCmd)
{
    HRESULT hr;
    NRWINFO rwi;

    TraceMsg(DM_UEMTRACE, "uemt: ic <%s>", pszCmd);

    if (DB_NOLOG)
        return E_FAIL;

#if 0 // ChDir is currently done at create time 
    hr = ChDir(SZ_COUNT);
#endif

    CUACount aCnt;

    hr = _GetCountWithDefault(pszCmd, TRUE, &aCnt);

    aCnt.IncCount();

    // Since we are incrementing the count,
    // We should update the last execute time
    aCnt.UpdateFileTime();

    rwi.self = this;
    rwi.pszName = pszCmd;
    hr = aCnt.SaveTo(TRUE, &s_Nrw3Info, &rwi);

    return hr;
}

HRESULT CEMDBLog::SetCount(LPCTSTR pszCmd, int cCnt)
{
    HRESULT hr;
    NRWINFO rwi;

    TraceMsg(DM_UEMTRACE, "uemt: ic <%s>", pszCmd);

    if (DB_NOLOG)
        return E_FAIL;

    CUACount aCnt;

    // fDef=FALSE so don't create if doesn't exist
    hr = _GetCountWithDefault(pszCmd, /*fDef=*/FALSE, &aCnt);

    if (SUCCEEDED(hr)) {       // don't want default...
        aCnt.SetCount(cCnt);

        rwi.self = this;
        rwi.pszName = pszCmd;
        hr = aCnt.SaveTo(TRUE, &s_Nrw3Info, &rwi);
    }

    return hr;
}

//***
// ENTRY/EXIT
//  fDefault    provide default if entry not found
//  ret         S_OK: found w/o default; S_FALSE: needed default; E_xxx: error
// NOTES
//  calling w/ fDefault=FALSE can still return S_FALSE
HRESULT CEMDBLog::_GetCountWithDefault(LPCTSTR pszCmd, BOOL fDefault, CUACount *pCnt)
{
    HRESULT hr, hrDef;
    NRWINFO rwi;

    rwi.self = this;
    rwi.pszName = pszCmd;
    hr = pCnt->LoadFrom(&s_Nrw3Info, &rwi);

    hrDef = S_OK;
    if (FAILED(hr)) {
        hrDef = S_FALSE;
        if (fDefault) {
            rwi.pszName = SZ_CUACount_ctor;
            hr = pCnt->LoadFrom(&s_Nrw3Info, &rwi);

            // pCnt->Initialize happens below (possibly 2x)
            if (FAILED(hr)) {
                TraceMsg(DM_UEMTRACE, "uadb._gcwd: create ctor %s", SZ_CUACount_ctor);
                hr = pCnt->Initialize(SAFECAST(this, IUASession *));

                ASSERT(pCnt->_GetCount() == 0);
                pCnt->_SetMru(SID_SNOWINIT);    // start clock ticking...

                // cnt=UAC_NEWCOUNT, age=Now
                int i = _fNoDecay ? 1 : UAC_NEWCOUNT;
                pCnt->SetCount(i);      // force age
                ASSERT(pCnt->_GetCount() == i);

                hr = pCnt->SaveTo(/*fForce*/TRUE, &s_Nrw3Info, &rwi);
            }

#if XXX_DELETE
            pCnt->_SetFlags(UACF_INHERITED, UACF_INHERITED);
#endif
        }
    }

    hr = pCnt->Initialize(SAFECAST(this, IUASession *));
    if (SUCCEEDED(hr))
        pCnt->_SetFlags(UAXF_XMASK, _SetFlags(0, 0) & UAXF_XMASK);

    return SUCCEEDED(hr) ? hrDef : hr;
}

HRESULT CEMDBLog::SetFileTime(LPCTSTR pszCmd, const FILETIME *pft)
{
    HRESULT hr;
    NRWINFO rwi;

    TraceMsg(DM_UEMTRACE, "uemt: sft <%s>", pszCmd);

    if (DB_NOLOG)
        return E_FAIL;

    CUACount aCnt;

    // fDef=FALSE so don't create if doesn't exist
    hr = _GetCountWithDefault(pszCmd, /*fDef=*/FALSE, &aCnt);

    if (SUCCEEDED(hr)) {       // don't want default...
        aCnt.SetFileTime(pft);

        rwi.self = this;
        rwi.pszName = pszCmd;
        hr = aCnt.SaveTo(TRUE, &s_Nrw3Info, &rwi);
    }

    return hr;
}


#if XXX_DELETE
#define BTOM(b, m)  ((b) ? (m) : 0)

DWORD CEMDBLog::_SetFlags(DWORD dwMask, DWORD dwFlags)
{
    // standard guys
    if (dwMask & UAXF_NOPURGE)
        _fNoPurge = BOOLIFY(dwFlags & UAXF_NOPURGE);
    if (dwMask & UAXF_BACKUP)
        _fBackup = BOOLIFY(dwFlags & UAXF_BACKUP);
    if (dwMask & UAXF_NOENCRYPT)
        _fNoEncrypt = BOOLIFY(dwFlags & UAXF_NOENCRYPT);
    if (dwMask & UAXF_NODECAY)
        _fNoDecay = BOOLIFY(dwFlags & UAXF_NODECAY);

    // my guys
    // (none)

    return 0    // n.b. see continuation line(s)!!!
        | BTOM(_fNoPurge  , UAXF_NOPURGE)
        | BTOM(_fBackup   , UAXF_BACKUP)
        | BTOM(_fNoEncrypt, UAXF_NOENCRYPT)
        | BTOM(_fNoDecay  , UAXF_NODECAY)
        ;
}
#endif

#define ROT13(i)    (((i) + 13) % 26)

#define XXX_HASH    0       // proto code for way-shorter regnames
#if !defined(DEBUG) && XXX_HASH
#pragma message("warning: XXX_HASH defined non-DEBUG")
#endif

//***   _MayEncrypt -- encrypt registry key/value name
// NOTES
TCHAR *CEMDBLog::_MayEncrypt(LPCTSTR pszSrcPlain, LPTSTR pszDstEnc, int cchDst)
{
    TCHAR *pszName;

    if (!_fNoEncrypt) {
#if XXX_HASH
        DWORD dwHash;

        HashData((BYTE*)pszSrcPlain, lstrlen(pszSrcPlain), (BYTE*)&dwHash, SIZEOF(dwHash));
        if (EVAL(cchDst >= (8 + 1)))
        {
            StringCchPrintf(pszDstEnc, cchDst, TEXT("%x"), dwHash);
            pszName = pszDstEnc;
        }
        else
            pszName = (TCHAR *)pszSrcPlain;
#else
        TCHAR ch;

        // uh-oh, gotta figure out an intl-aware encryption scheme...
        pszName = pszDstEnc;
        pszDstEnc[--cchDst] = 0;      // pre-terminate for overflow case
        ch = -1;
        while (cchDst-- > 0 && ch != 0) {
            ch = *pszSrcPlain++;

            if (TEXT('a') <= ch && ch <= TEXT('z'))
                ch = TEXT('a') + ROT13(ch - TEXT('a'));
            else if (TEXT('A') <= ch && ch <= TEXT('Z'))
                ch = TEXT('A') + ROT13(ch - TEXT('A'));
            else
                ;

            *pszDstEnc++ = ch;
        }
#endif
        TraceMsg(DM_UEMTRACE, "uadb._me: plain=%s(enc=%s)", pszSrcPlain - (pszDstEnc - pszName), pszName);
    }
    else {
        pszName = (TCHAR *)pszSrcPlain;
    }

    return pszName;
}

#if XXX_CACHE // {
//***
// ENTRY/EXIT
//  op      0:read, 1:write, 2:delete
//
HRESULT CEMDBLog::CacheOp(CACHEOP op, void *pvBuf, DWORD cbBuf, PNRWINFO prwi)
{
    static TCHAR * const pszNameTab[] = { SZ_CTLSESSION, SZ_CUACount_ctor, };
    int i;

    ASSERT(ARRAYSIZE(pszNameTab) == ARRAYSIZE(_rgCache));

    for (i = 0; i < ARRAYSIZE(pszNameTab); i++) 
    {
        if (lstrcmp(prwi->pszName, pszNameTab[i]) == 0) 
        {
            TraceMsg(DM_PERF, "cedl.s_%c: this'=%x n=%s", TEXT("rwd")[op], prwi->self, prwi->pszName);

            switch (op) 
            {
                // Read from the cache
            case CO_READ:
                // Do we have a cached item?
                if (_rgCache[i].pv) 
                {
                    // The cached buffer should be smaller than or equal to the 
                    // passed buffer size, or we get a buffer overflow
                    if (_rgCache[i].cbSize <= cbBuf)
                    {
                        // Load the cache into the buffer. Note that the
                        // size requested may be larger than the size cached. This
                        // is due to upgrade senarios
                        memcpy(pvBuf, _rgCache[i].pv, _rgCache[i].cbSize);
                        return S_OK;
                    }
                    else
                    {
                        ASSERT(FALSE);
                    }
                }
                break;

                // Write to the Cache
            case CO_WRITE:

                // Is the size different or not initialized?
                // When we first allocate this spot, it's size is zero. The
                // incomming buffer should be greater.
                if (_rgCache[i].cbSize != cbBuf)
                {
                    // The size is different or uninialized.
                    if (_rgCache[i].pv)                         // Free whatever we've got 
                    {                                           // because we're getting a new one.
                        _rgCache[i].cbSize = 0;                 // Set the size to zero.
                        LocalFree(_rgCache[i].pv);
                    }

                    // Allocate a new buffer of the current size.
                    _rgCache[i].pv = LocalAlloc(LPTR, cbBuf);
                }


                // Were we successful in allocating a cache buffer?
                if (_rgCache[i].pv) 
                {
                    // Yes, make the buffer size the same... Do this here incase the
                    // allocate fails.
                    _rgCache[i].cbSize = cbBuf;
                    memcpy(_rgCache[i].pv, pvBuf, _rgCache[i].cbSize);
                    return S_OK;
                }
                break;

            case CO_DELETE:     // delete
                if (_rgCache[i].pv) 
                {
                    LocalFree(_rgCache[i].pv);
                    _rgCache[i].pv = NULL;
                    _rgCache[i].cbSize = 0;
                }
                return S_OK;

            default:
                ASSERT(0);  // 'impossible'
                break;
            }

            TraceMsg(DM_PERF, "cedl.s_%c: this'=%x n=%s cache miss", TEXT("rwd")[op], prwi->self, prwi->pszName);
            break;
        }
    }
    return S_FALSE;
}
#endif // }

HRESULT CEMDBLog::s_Read(void *pvBuf, DWORD cbBuf, PNRWINFO prwi)
{
    HRESULT hr;
    CEMDBLog *pdb = (CEMDBLog *)prwi->self;
    TCHAR *pszName;
    TCHAR szNameEnc[MAX_URL_STRING];

#if XXX_CACHE
    if (pdb->CacheOp(CO_READ, pvBuf, cbBuf, prwi) == S_OK)
        return S_OK;
#endif
    pszName = pdb->_MayEncrypt(prwi->pszName, szNameEnc, ARRAYSIZE(szNameEnc));
    hr = pdb->QueryValue(pszName, (BYTE *)pvBuf, &cbBuf);
#if XXX_CACHE
    pdb->CacheOp(CO_WRITE, pvBuf, cbBuf, prwi);
#endif
    return hr;
}

HRESULT CEMDBLog::s_Write(void *pvBuf, DWORD cbBuf, PNRWINFO prwi)
{
    HRESULT hr;
    CEMDBLog *pdb = (CEMDBLog *)prwi->self;
    TCHAR *pszName;
    TCHAR szNameEnc[MAX_URL_STRING];

#if XXX_CACHE
    // CO_DELETE not CO_WRITE (easier/safer) (perf fine since rarely write)
    pdb->CacheOp(CO_DELETE, pvBuf, cbBuf, prwi);
#endif
    pszName = pdb->_MayEncrypt(prwi->pszName, szNameEnc, ARRAYSIZE(szNameEnc));
    hr = pdb->SetValue(pszName, REG_BINARY, (BYTE *)pvBuf, cbBuf);
    return hr;
}

HRESULT CEMDBLog::s_Delete(void *pvBuf, DWORD cbBuf, PNRWINFO prwi)
{
    HRESULT hr;
    CEMDBLog *pdb = (CEMDBLog *)prwi->self;
    TCHAR *pszName;
    TCHAR szNameEnc[MAX_URL_STRING];

#if XXX_CACHE
    pdb->CacheOp(CO_DELETE, pvBuf, cbBuf, prwi);
#endif
    pszName = pdb->_MayEncrypt(prwi->pszName, szNameEnc, ARRAYSIZE(szNameEnc));
    if (pdb->_fBackup)
    {
        if (pvBuf == NULL)
        {
            // happily we already have the data
            // o.w. we'd need to QueryValue into a mega-buffer
            TraceMsg(TF_WARNING, "uadb.s_d: _fBackup && !pvBuf (!)");
            ASSERT(0);
        }
        else
        {
            TCHAR szDel[MAX_URL_STRING];
            hr = StringCchPrintf(szDel, ARRAYSIZE(szDel), SZ_DEL_PREFIX TEXT("%s"), pszName);
            if (SUCCEEDED(hr))
            {
                hr = pdb->SetValue(szDel, REG_BINARY, (BYTE *)pvBuf, cbBuf);
            }

            if (FAILED(hr))
                TraceMsg(TF_WARNING, "uadb.s_d: _fBackup hr=%x (!)", hr);
        }
        // (we'll do delete whether or not the _fBackup works)
    }

    hr = pdb->DeleteValue(pszName);
    TraceMsg(DM_UEMTRACE, "uadb.s_d: delete s=%s(%s) (_fBackup=%d) pRaw=0x%x hr=%x", pszName, prwi->pszName, pdb->_fBackup, pvBuf, hr);
#if 1 // unneeded?
    if (FAILED(hr))
        hr = s_Write(pvBuf, cbBuf, prwi);
#endif
    return hr;
}

// }

//***   THIS::IUASession::* {

int CEMDBLog::GetSessionId()
{
    HRESULT hr;
    NRWINFO rwi;
    CUASession aSess;
    int i;

    rwi.self = this;
    rwi.pszName = SZ_CTLSESSION;
    hr = aSess.LoadFrom(&s_Nrw3Info, &rwi);
    aSess.Initialize();

    i = aSess.GetSessionId();

    hr = aSess.SaveTo(FALSE, &s_Nrw3Info, &rwi);

    return i;
}

void CEMDBLog::SetSession(UAQUANTUM uaq, BOOL fForce)
{
    HRESULT hr;
    NRWINFO rwi;
    CUASession aSess;

    rwi.self = this;
    rwi.pszName = SZ_CTLSESSION;
    hr = aSess.LoadFrom(&s_Nrw3Info, &rwi);
    aSess.Initialize();

    aSess.SetSession(uaq, fForce);

    hr = aSess.SaveTo(TRUE, &s_Nrw3Info, &rwi);

    return;
}

// }

//***   THIS::CUASession::* {

extern DWORD g_dSessTime;

CUASession::CUASession()
{
    _fInited = FALSE;
    _fDirty = FALSE;
    return;
}

HRESULT CUASession::Initialize()
{
    if (!_fInited) {
        _fInited = TRUE;

        _cCnt = 0;
        _qtMru = 0;
        _fDirty = TRUE;
    }

    return S_OK;
}

//***   THIS::GetSessionId -- increment profile count for command
//
int CUASession::GetSessionId()
{
    return _cCnt;
}

//***
// ENTRY/EXIT
//  fForce  ignore threshhold rules (e.g. for DEBUG)
void CUASession::SetSession(UAQUANTUM uaq, BOOL fForce)
{
    UATIME qtNow;

    qtNow = GetUaTime(NULL);
    if (qtNow - _qtMru >= g_dSessTime || fForce) {
        TraceMsg(DM_UEMTRACE, "uadb.ss: sid=%d++", _cCnt);
        _cCnt++;
        // nt5:173090
        // if we wrap, there's nothing we can do.  it would be pretty
        // bad, since everything would get promoted (since 'now' will
        // be *older* than 'mru' so there will be no decay).  worse still
        // they'd stay promoted for a v. long time.  we could detect that
        // in the decay code and (lazily) reset the count to 'now,1' or
        // somesuch, but it should never happen so we simply ASSERT.
        ASSERT(_cCnt != 0);     // 'impossible'
        _qtMru = qtNow;

        _fDirty = TRUE;
    }

    return;
}

HRESULT CUASession::LoadFrom(PFNNRW3 pfnIO, PNRWINFO pRwi)
{
    HRESULT hr;

    hr = (*pfnIO->_pfnRead)(_GetRawData(), _GetRawCount(), pRwi);
    if (SUCCEEDED(hr))
        _fInited = TRUE;
    return hr;
}

HRESULT CUASession::SaveTo(BOOL fForce, PFNNRW3 pfnIO, PNRWINFO pRwi)
{
    HRESULT hr;

    hr = S_FALSE;
    if (fForce || _fDirty) {
        hr = (*pfnIO->_pfnWrite)(_GetRawData(), _GetRawCount(), pRwi);
        _fDirty = FALSE;
    }
    return hr;
}

// }

//*** CGCTask::* {
CGCTask *CGCTask_Create(CEMDBLog *that)
{
    CGCTask *pthis = new CGCTask;
    if (pthis) {
        if (FAILED(pthis->Initialize(that))) {
            delete pthis;
            pthis = NULL;
        }
    }
    return pthis;
}

HRESULT CGCTask::Initialize(CEMDBLog *that)
{
    ASSERT(!_that);
    ASSERT(that);
    that->AddRef();
    _that = that;
    return S_OK;
}

CGCTask::CGCTask() : CRunnableTask(RTF_DEFAULT)
{
}

CGCTask::~CGCTask()
{
    if (_that)
        _that->Release();
}

//***   CGCTask::CRunnableTaskRT::* {

HRESULT CGCTask::RunInitRT()
{
    HRESULT hr;

    ASSERT(_that);
    g_fDidUAGC = 2;     // breadcrumbs in case we die (even non-DEBUG)
    hr = _that->_GarbageCollectSlow();
    g_fDidUAGC = 3;     // breadcrumbs in case we die (even non-DEBUG)
    return hr;
}

// }

// }

#if 0
#ifdef DEBUG
void emdbtst()
{
    HRESULT hr;
    CEMDBLog *pdb = new CEMDBLog;

    if (pdb)
    {
        hr = pdb->Initialize(HKEY_CURRENT_USER, TEXT("UIProf"));
        ASSERT(SUCCEEDED(hr));

        pdb->CountIncr("foo");
        pdb->CountIncr("bar");
        pdb->CountIncr("foo");

        delete pdb;
    }

    return;
}
#endif
#endif

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\emclient\regdb.h ===
//***   CEMDBLog --
//
#define XXX_CACHE   1       // caching on

class CEMDBLog : public IUASession
{
public:
    ULONG AddRef(void)
        {
            return InterlockedIncrement(&_cRef);
        }

    ULONG Release(void)
        {
            ASSERT( 0 != _cRef );
            ULONG cRef = InterlockedDecrement(&_cRef);
            if ( 0 == cRef )
            {
                delete this;
            }
            return cRef;
        }

    //*** THISCLASS
    virtual HRESULT Initialize(HKEY hkey, DWORD grfMode);
    HRESULT SetRoot(HKEY hkey, DWORD grfMode);
    HRESULT ChDir(LPCTSTR pszSubKey);

    /*virtual HRESULT Initialize(HKEY hk, DWORD grfMode);*/
    HRESULT QueryValue(LPCTSTR pszName, BYTE *pbData, LPDWORD pcbData);
    HRESULT SetValue(LPCTSTR pszName, DWORD dwType, const BYTE *pbData, DWORD cbData);
    HRESULT DeleteValue(LPCTSTR pszName);
    HRESULT RmDir(LPCTSTR pszName, BOOL fRecurse);

    HKEY GetHkey()  { return _hkey; }

    // IUASession
    virtual void SetSession(UAQUANTUM uaq, BOOL fForce);
    virtual int GetSessionId();

    // THISCLASS
    HRESULT GetCount(LPCTSTR pszCmd);
    HRESULT IncCount(LPCTSTR pszCmd);
    FILETIME GetFileTime(LPCTSTR pszCmd);
    HRESULT SetCount(LPCTSTR pszCmd, int cCnt);
    HRESULT SetFileTime(LPCTSTR pszCmd, const FILETIME *pft);
    DWORD _SetFlags(DWORD dwMask, DWORD dwFlags);
    HRESULT GarbageCollect(BOOL fForce);


protected:
    CEMDBLog();
    friend CEMDBLog *CEMDBLog_Create();
    friend void CEMDBLog_CleanUp();
    friend class CGCTask;

    // THISCLASS helpers
    HRESULT _GetCountWithDefault(LPCTSTR pszCmd, BOOL fDefault, CUACount *pCnt);
    HRESULT _GetCountRW(LPCTSTR pszCmd, BOOL fUpdate);
    static HRESULT s_Read(void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
    static HRESULT s_Write(void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
    static HRESULT s_Delete(void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
#if XXX_CACHE
    typedef enum e_cacheop { CO_READ=0, CO_WRITE=1, CO_DELETE=2, } CACHEOP;
    HRESULT CacheOp(CACHEOP op, void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
#endif
    TCHAR *_MayEncrypt(LPCTSTR pszSrcPlain, LPTSTR pszDstEnc, int cchDst);
    HRESULT IsDead(LPCTSTR pszCmd);
    HRESULT _GarbageCollectSlow();

    static FNNRW3 s_Nrw3Info;
#if XXX_CACHE
    struct
    {
        UINT  cbSize;
        void* pv;
    } _rgCache[2];
#endif
protected:
    virtual ~CEMDBLog();

    long _cRef;
    HKEY    _hkey;
    int     _grfMode;   // read/write (subset of STGM_* values)


    BITBOOL     _fNoPurge : 1;      // 1:...
    BITBOOL     _fBackup : 1;       // 1:simulate delete (debug)
    BITBOOL     _fNoEncrypt : 1;    // 1:...
    BITBOOL     _fNoDecay : 1;      // 1:...

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\emclient\uacount.h ===
//***   CUACount -- user-assistance counter w/ decay
//
#define XXX_DELETE      1
#define XXX_VERSIONED   0

//***   NRW -- named i/o
// DESCRIPTION
//  i/o to a 'named' location (e.g. registry)
typedef struct {
    void *self;
    LPCTSTR pszName;
} NRWINFO, *PNRWINFO;

typedef HRESULT (*PFNNRW)(void *pvBuf, DWORD cbBuf, PNRWINFO prwi);
typedef struct {
    PFNNRW _pfnRead;
    PFNNRW _pfnWrite;
    PFNNRW _pfnDelete;
} FNNRW3, *PFNNRW3;

//***   UAQ_* -- quantum
// NOTES
//  todo: for now everything is flat
typedef enum {
    UAQ_TASK=0,
    UAQ_DOC=0,
    UAQ_APP=0,
    UAQ_SESSION=0
} UAQUANTUM;
#define UAQ_DEFAULT UAQ_SESSION         // currently implemented quanta
#define UAQ_COUNT   (UAQ_SESSION + 1)

typedef DWORD   UATIME;                 // 1 minute (approx)

#define UAT_MINUTE1 ((UATIME)1)         // 1  minute
#define UAT_HOUR12  ((UATIME)(12 * 60)) // 12 hours (see FTToUATime)

extern UATIME GetUaTime(LPSYSTEMTIME pst);

//***   UATTOMSEC -- convert UATIME to mSec's
// NOTES
//  ISSUE: we should be more accurate.  currently we just assume a UATIME
// is exactly 1 minute, which it's not...  easy enough to do, but we'll
// wait until i have time to do the math.
#define UATTOMSEC(uat)      ((uat) * 60 * 1000)

class IUASession
{
public:
    virtual void SetSession(UAQUANTUM uaq, BOOL fForce) PURE;
    virtual int GetSessionId() PURE;
};

class CUASession : public IUASession
{
    struct SUASession {
#if XXX_VERSIONED
        UINT    _cbSize;
#endif
        UATIME  _qtMru;
        int     _cCnt;
    };

public:
    void SetSession(UAQUANTUM uaq, BOOL fForce);
    int GetSessionId();

    CUASession();           // n.b. public so can stack-alloc
    HRESULT Initialize();
    HRESULT LoadFrom(PFNNRW3 pfnIO, PNRWINFO pRwi);
    HRESULT SaveTo(BOOL fForce, PFNNRW3 pfnIO, PNRWINFO pRwi);

protected:
    // for xfers directly into me w/o an extra copy-ctor
    // e.g. p->QueryValue(pszName, aUac.GetRawData(), &cb);
    // e.g. p->SetValue  (pszName, aUac.GetRawData(), aUac.GetRawCount());
    _inline BYTE *  _GetRawData() { return (BYTE *)&_qtMru; };
    _inline DWORD   _GetRawCount() { return SIZEOF(SUASession); };

    //struct SUASession {
#if XXX_VERSIONED
        UINT    _cbSize;
#endif
        UATIME  _qtMru;
        int     _cCnt;
    //};

    BITBOOL         _fInited : 1;   // 1:we've been initialized
    BITBOOL         _fDirty : 1;    // 1:save me (e.g. _sidMru was xformed)
};

// all special values are < 0 for easy check
#define SID_SNOWREAD    (-1)    // like SID_SNOWINIT, but no auto-save
#define SID_SNOWINIT    (-2)    // convert to 'now' on 1st read
#define SID_SNOWALWAYS  (-3)    // always 'now'

#define ISSID_SSPECIAL(s) ((int)(s) < 0)

// tunable values for IncCount (talk to your neighborhood PM)
#define UAC_NEWCOUNT    2      // brand-new count starts from here
#define UAC_MINCOUNT    6      // incr to a minimum of this

class CUACount
{
    // must match CUACount semi-embedded struct
    struct SUACount 
    {
#define UAC_d0  _sidMruDisk
#if XXX_VERSIONED
#undef  UAC_d0
#define UAC_d0  _cbSize
        UINT    _cbSize;
#endif
        UINT    _sidMruDisk;    // MRU for this entry
        // todo: eventually we'll want task,doc,app,session
        // so this will be _cCnt[UAQ_COUNT], and we'll index by _cCnt[quanta]
        int     _cCnt;      // use count (lazily decayed)
        FILETIME _ftExecuteTime;
    };

public:
    CUACount();         // n.b. public so can stack-alloc
    HRESULT Initialize(IUASession *puas);
    HRESULT LoadFrom(PFNNRW3 pfnIO, PNRWINFO pRwi);
    HRESULT SaveTo(BOOL fForce, PFNNRW3 pfnIO, PNRWINFO pRwi);

#ifdef DEBUG
    BOOL    DBIsInit();
#endif
    int     GetCount();
    void    IncCount();
    void    AddCount(int i);
    void    SetCount(int cCnt);
    void    UpdateFileTime();
    FILETIME GetFileTime();
    void SetFileTime(const FILETIME *pft);

    // most people should *not* call these
    void    _SetMru(UINT sidMru) { _sidMruDisk = sidMru; Initialize(_puas); };
    int     _GetCount() { return _cCnt; };
#if XXX_DELETE
    DWORD   _SetFlags(DWORD dwMask, DWORD dwValue);
        #define UACF_INHERITED  0x01
        #define UACF_NODECAY    0x02
#endif

protected:
    int     _DecayCount(BOOL fWrite);
    UINT    _ExpandSpecial(UINT sidMru);

    // for xfers directly into me w/o an extra copy-ctor
    // e.g. p->QueryValue(pszName, aUac.GetRawData(), &cb);
    // e.g. p->SetValue  (pszName, aUac.GetRawData(), aUac.GetRawCount());
    _inline BYTE *  _GetRawData() { return (BYTE *)&UAC_d0; };
    _inline DWORD   _GetRawCount() { return SIZEOF(SUACount); };

    // struct SUACount {
#if XXX_VERSIONED
    UINT    _cbSize;        // SIZEOF
#endif
    UINT    _sidMruDisk;    // MRU for this entry
    // todo: eventually we'll want task,doc,app,session
    // so this will be cCnt[UAQ_COUNT], and we'll index by cCnt[quanta]
    int     _cCnt;      // use count (lazily decayed)
    FILETIME _ftExecuteTime;
    // }
    UINT    _sidMru;    // MRU for this entry

    IUASession *    _puas;          // session callback
    BITBOOL         _fInited : 1;   // 1:we've been initialized
    BITBOOL         _fDirty : 1;    // 1:save me (e.g. _sidMru was xformed)
#if XXX_DELETE
    BITBOOL         _fInherited : 1;    // 1:we didn't exist
#else
    BITBOOL         _fUnused : 1;
#endif
    BITBOOL         _fNoDecay : 1;      // 1:don't decay me
    BITBOOL         _fNoPurge : 1;      // 1:don't auto-delete me (debug)

private:
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\emclient\uacount.cpp ===
//***   CUACount -- user-assistance counter w/ decay
// NOTES
//  todo: scavenging to clean out registry.  but see caveats in UAC_CDEF.

#include "priv.h"
#include "uacount.h"
#include "uareg.h"

#define DM_UEMTRACE     TF_UEM

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

//***   UAC_CDEFAULT -- initial _cCnt for entry (we *always* show items)
// NOTES
//  eventually we might want to scavenge all entries, decaying them down
// and deleting any that decay to 0.  note however that this will cause
// them to look like they have a default count of 1 (see CUAC::Init), so
// they'll suddenly appear on the menus again.
#define UAC_CDEFAULT    0       // initial _cCnt for entry

#define SID_SDEFAULT    SID_SNOWREAD    // initial _sidMru for new entry


//***
// NOTES
//  it's getting to the point that we should disallow stack-alloc'ed
// guys and instead count on new() to 0-init us.
CUACount::CUACount()
{
    // Since this is created on the stack, we don't get the benefits of the 
    // Heap allocator's zero initialization...
    ZeroMemory(_GetRawData(), _GetRawCount());

    _fInited = FALSE;   // need to call Initialize
#if XXX_VERSIONED
    _cbSize = -1;
#endif
#if XXX_DELETE
    _fInherited = FALSE;
#endif
    _fDirty = FALSE;
    _fNoDecay = _fNoPurge = FALSE;

    return;
}

#ifdef DEBUG
BOOL CUACount::DBIsInit()
{
#if XXX_VERSIONED
    ASSERT((_cbSize == SIZEOF(SUACount)) == BOOLIFY(_fInited));
#endif
    return _fInited;
}
#endif

HRESULT CUACount::Initialize(IUASession *puas)
{
    _puas = puas;
    if (!_fInited) {
        _fInited = TRUE;
#if XXX_VERSIONED
        // todo: _cbSize -1 means no entry, < SIZEOF means version upgrade
        _cbSize = SIZEOF(SUACount);
#endif
        // hardcode the SZ_CUACount_ctor values here
        _cCnt = UAC_CDEFAULT;       // all items start out visible
        _sidMruDisk = SID_SNOWREAD; // ... and non-aged
    }

    _sidMru = _sidMruDisk;
    if (ISSID_SSPECIAL(_sidMruDisk)) {
        _sidMru = _ExpandSpecial(_sidMruDisk);
        if (_sidMruDisk == SID_SNOWINIT) {
            _sidMruDisk = _sidMru;
            _fDirty = TRUE;
        }
        else if (_sidMruDisk == SID_SNOWREAD) {
            _sidMruDisk = _sidMru;
            ASSERT(!_fDirty);
        }
    }

    return S_OK;
}

HRESULT CUACount::LoadFrom(PFNNRW3 pfnIO, PNRWINFO pRwi)
{
    HRESULT hr;

    hr = (*pfnIO->_pfnRead)(_GetRawData(), _GetRawCount(), pRwi);
    if (SUCCEEDED(hr))
        _fInited = TRUE;
    return hr;
}

HRESULT CUACount::SaveTo(BOOL fForce, PFNNRW3 pfnIO, PNRWINFO pRwi)
{
    HRESULT hr;

    hr = S_FALSE;
    if (fForce || _fDirty) {
        if (!ISSID_SSPECIAL(_sidMruDisk)) 
            _sidMruDisk = _sidMru;
#if XXX_DELETE
        if (_cCnt == 0 && !_fNoPurge && pfnIO->_pfnDelete)
            hr = (*pfnIO->_pfnDelete)(_GetRawData(), _GetRawCount(), pRwi);
        else
#endif
        hr = (*pfnIO->_pfnWrite)(_GetRawData(), _GetRawCount(), pRwi);
        // ASSERT(SUCCEEDED(hr)); // this legitimately happens (low memory, access denied)
        _fDirty = FALSE;
    }
    return hr;
}

//***   GetCount -- get count info (w/ lazy decay)
//
int CUACount::GetCount()
{
    ASSERT(DBIsInit());

    int cCnt = _DecayCount(FALSE);

    return cCnt;
}

void CUACount::IncCount()
{
    AddCount(1);
    return;
}

void CUACount::AddCount(int i)
{
    ASSERT(DBIsInit());

    _DecayCount(TRUE);
    _cCnt += i;

    if (_cCnt == 0 && i > 0) {
        // nt5:173048
        // handle wrap
        // should never happen, but what the heck
        // do *not* remove this assert, if we ever let people do DecCount
        // we'll need to rethink it...
        ASSERT(0);  // 'impossible'
        _cCnt++;
    }

    // 981029 new incr algorithm per ie5 PM
    // UAC_MINCOUNT: initial inc starts at 6
    // _fNoDecay: but, UAssist2 doesn't do this
    if (_cCnt < UAC_MINCOUNT && !_fNoDecay)
        _cCnt = UAC_MINCOUNT;

    return;
}

//***
// NOTES
//  should we update the timestamp?  maybe add a fMru param?
void CUACount::SetCount(int cCnt)
{
    ASSERT(DBIsInit());

    _cCnt = cCnt;

    return;
}

void CUACount::SetFileTime(const FILETIME *pft)
{
    ASSERT(DBIsInit());

    _ftExecuteTime = *pft;

    return;
}



#if XXX_DELETE
#define BTOM(b, m)  ((b) ? (m) : 0)

DWORD CUACount::_SetFlags(DWORD dwMask, DWORD dwFlags)
{
    // standard guys
    if (dwMask & UAXF_NOPURGE)
        _fNoPurge = BOOLIFY(dwFlags & UAXF_NOPURGE);
#if 0
    if (dwMask & UAXF_BACKUP)
        _fBackup = BOOLIFY(dwFlags & UAXF_BACKUP);
#endif
    if (dwMask & UAXF_NODECAY)
        _fNoDecay = BOOLIFY(dwFlags & UAXF_NODECAY);

    // my guys
    if (dwMask & UACF_INHERITED)
        _fInherited = BOOLIFY(dwFlags & UACF_INHERITED);

    return 0    // n.b. see continuation line(s)!!!
#if XXX_DELETE
        | BTOM(_fInherited, UACF_INHERITED)
#endif
        | BTOM(_fNoPurge, UAXF_NOPURGE)
        | BTOM(_fNoDecay, UAXF_NODECAY)
        ;
}
#endif

//***   PCTOF -- p% of n (w/o floating point!)
//
#define PCTOF(n, p)   (((n) * (p)) / 100)

//***   _DecayCount -- decay (and propagate) count
// ENTRY/EXIT
//  fWrite  TRUE if want to update object and timestamp, o.w. FALSE
//  cNew    (return) new count
// DESCRIPTION
//  on a read, we do the decay but don't update the object.  on the write
// we decay and update.
// NOTES
//  todo: if/when we make cCnt a vector, we can propagate stuff here.
// this would allow us to usually inc a single small-granularity elt,
// and propagate to the large-gran elts only when we really need them.
//  perf: we could make the table 'cumulative', then we wouldn't have
// to do as much computation.  not worth the trouble...
int CUACount::_DecayCount(BOOL fWrite)
{
    int cCnt;

    cCnt = _cCnt;
    if (cCnt > 0 || fWrite) {
        UINT sidNow;

        sidNow = _puas->GetSessionId();

        if (!_fNoDecay) {
            // from mso-9 spec
            // last used 'timTab' sessions ago => dec by >-of abs, pct
            // n.b. this table is non-cumulative
            static const int timTab[] = { 3, 6, 9, 12, 17, 23, 29,  31,  -1, };
            static const int absTab[] = { 1, 1, 1,  2,  3,  4,  5,   0,   0, };
            static const int pctTab[] = { 0, 0, 0, 25, 25, 50, 75, 100, 100, };

            UINT sidMru;
            int dt;
            int i;

            sidMru = _sidMru;
            ASSERT(!ISSID_SSPECIAL(_sidMru));

            ASSERT(sidMru != SID_SDEFAULT);
            if (sidMru != SID_SDEFAULT) {
                dt = sidNow - sidMru;
                // iterate fwd not bkwd so bail early in common case
                for (i = 0; i < ARRAYSIZE(timTab); i++) {
                    if ((UINT)dt < (UINT)timTab[i])
                        break;

                    cCnt -= MAX(absTab[i], PCTOF(cCnt, pctTab[i]));
                    // don't go negative!
                    // gotta check *each* time thru loop (o.w. PCT is bogus)
                    cCnt = MAX(0, cCnt);
                }
            }
        }

        if (cCnt != _cCnt)
            TraceMsg(DM_UEMTRACE, "uac.dc: decay %d->%d", _cCnt, cCnt);

        if (fWrite) {
            _sidMru = sidNow;
            _cCnt = cCnt;
        }

#if XXX_DELETE
        if (cCnt == 0 && !_fInherited) {
            // if we decay down to 0, mark so it will be deleted
            TraceMsg(DM_UEMTRACE, "uac.dc: decay %d->%d => mark dirty pRaw=0x%x", _cCnt, cCnt, _GetRawData());
            _cCnt = 0;
            _fDirty = TRUE;
        }
#endif
    }

    return cCnt;
}

//***
// NOTES
//   perf: currently all special guys return sidNow so no 'switch' necessary
UINT CUACount::_ExpandSpecial(UINT sidMru)
{
    UINT sidNow;

    if (EVAL(ISSID_SSPECIAL(sidMru))) {
        ASSERT(_puas);
        sidNow = _puas->GetSessionId();     // perf: multiple calls
        switch (sidMru) {
        case SID_SNOWALWAYS:
            return sidNow;
            //break;

        case SID_SNOWREAD:
        case SID_SNOWINIT:
            return sidNow;
            //break;

#ifdef DEBUG
        default:
            ASSERT(0);
            break;
#endif
        }
    }

    return sidMru;
}


// Return the encoded filetime. This is read from the registry or
// generated from UpdateFileTime.
FILETIME CUACount::GetFileTime()
{
    return _ftExecuteTime;
}

// Updates the internal filetime information. This info
// will be later persisted to the registry.
void CUACount::UpdateFileTime()
{
    SYSTEMTIME st;
    // Get the current system time.
    GetSystemTime(&st);

    // This is done for ARP. They use filetimes, not the system time 
    // for the calculation of the last execute time.
    SystemTimeToFileTime(&st, &_ftExecuteTime);
}


// {
//***   UATIME --

//***   FTToUATime -- convert FILETIME to UATIME
// DESCRIPTION
//  UATIME granularity is (approximately) 1 minute.  the math works out
// roughly as follows:
//      filetime granularity is 100 nanosec
//      1 ft = 10^-7 sec
//      highword is 2^32 ft = 2^32 * 10^-7 sec
//      1 sec = hiw / (2^32 * 10^-7)
//      1 min = hiw * 60 / (2^32 * 10^-7)
//          = hiw * 60 / (1G * 10^-7)
//          ~= hiw * 60 / ~429
//          = hiw / 7.15
//          ~= hiw / 8 approx
//  the exact granularity is:
//      ...
#define FTToUATime(pft)  ((DWORD)(*(_int64 *)(pft) >> 29))  // 1 minute (approx)

//***   GetUaTime -- convert systemtime (or 'now') to UATIME
//
UATIME GetUaTime(LPSYSTEMTIME pst)
{
    FILETIME ft;
    UATIME uat;

    if (pst == NULL)
    {
        GetSystemTimeAsFileTime(&ft);
    }
    else
    {
        SystemTimeToFileTime(pst, &ft);
    }

    uat = FTToUATime(&ft);    // minutes

    return uat;
}

// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\emclient\uareg.h ===
//***   uareg.h -- UAssist registry settings and flags
//

//***   SZ_* -- registry locations
//
#define SZ_UASSIST          TEXT("UserAssist")
#define SZ_UASSIST2         TEXT("UserAssist2")
  #define SZ_SETTINGS         TEXT("Settings")
    #define SZ_SESSTIME         TEXT("SessionTime")
    #define SZ_IDLETIME         TEXT("IdleTime")
    #define SZ_CLEANTIME        TEXT("CleanupTime")
    #define SZ_NOPURGE          TEXT("NoPurge")     // (debug) don't nuke 0s
    #define SZ_BACKUP           TEXT("Backup")      // (debug) simulate deletes
    #define SZ_NOLOG            TEXT("NoLog")
    #define SZ_INSTRUMENT       TEXT("Instrument")
    #define SZ_NOENCRYPT        TEXT("NoEncrypt")   // (debug) don't encrypt
//{guid}
    #define SZ_UAVERSION      TEXT("Version")
    #define SZ_COUNT          TEXT("Count")
//    #define SZ_CTLSESSION     TEXT("UEME_CTLSESSION")
//    #define SZ_CUACount_ctor  TEXT("UEME_CTLCUACount:ctor")

//***   UA*F_* -- flags
// standard, shared by some of {CUserAssist,CUADbase,CUACount}
#define UAXF_NOPURGE    0x01000000
#define UAXF_BACKUP     0x02000000
#define UAXF_NOENCRYPT  0x04000000
#define UAXF_NODECAY    0x08000000
#define UAXF_RESERVED2  0x10000000
#define UAXF_RESERVED3  0x20000000
#define UAXF_RESERVED4  0x40000000
#define UAXF_RESERVED5  0x80000000

#define UAXF_XMASK      0xff000000

// for CUserAssist API
#define UAAF_NOLOG      0x01
#define UAAF_INSTR      0x02

// for CUADbase
#define UADF_UNUSED     0x01

// for CUACount
#define UACF_UNUSED     0x01


//***
//
#define UEMIND_NINSTR   0
#ifdef UAAF_INSTR
#undef  UEMIND_NINSTR
#define UEMIND_NINSTR   2

#define UEMIND_SHELL2   (UEMIND_SHELL + UEMIND_NINSTR)
#define UEMIND_BROWSER2 (UEMIND_BROWSER + UEMIND_NINSTR)
#endif

#define IND_NONINSTR(iGrp) \
    (!IND_ISINSTR(iGrp) ? (iGrp) : ((iGrp) - UEMIND_NINSTR))
#define IND_ISINSTR(iGrp)   (UEMIND_NINSTR && iSvr >= UEMIND_NINSTR)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\augisf.h ===
#ifndef _AUGISF_H
#define _AUGISF_H


// Augmented IShellFolder Object.  This takes two IShellFolder interfaces
// and wraps them so an object can enumerate as if they were in a single
// IShellFolder implementation.


class CAugmentedISF : public IAugmentedShellFolder2,
                      public IShellService,
                      public ITranslateShellChangeNotify
{
    
public:
    // *** IUnknown methods ***
    virtual STDMETHODIMP QueryInterface(REFIID,void **);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    
    // *** IShellFolder methods ***
    virtual STDMETHODIMP ParseDisplayName(HWND hwndOwner,
                                LPBC pbcReserved, LPOLESTR lpszDisplayName,
                                ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);

    virtual STDMETHODIMP EnumObjects( THIS_ HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList);

    virtual STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
    virtual STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                ULONG * rgfInOut);
    virtual STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
    virtual STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    virtual STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                                LPCOLESTR lpszName, DWORD uFlags,
                                LPITEMIDLIST * ppidlOut);

    // *** IAugmentedShellFolder methods ***
    virtual STDMETHODIMP AddNameSpace(const GUID * pguidObject, IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags);
    virtual STDMETHODIMP GetNameSpaceID(LPCITEMIDLIST pidl, GUID * pguidOut);
    virtual STDMETHODIMP QueryNameSpace(DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf);
    virtual STDMETHODIMP EnumNameSpace(DWORD uNameSpace, DWORD * pdwID);

    // *** IAugmentedShellFolder2 methods ***
    //not used
    //virtual STDMETHODIMP GetNameSpaceCount( OUT LONG* pcNamespaces ) ;
    //virtual STDMETHODIMP GetIDListWrapCount( LPCITEMIDLIST pidlWrap, OUT LONG * pcPidls) ;
    virtual STDMETHODIMP UnWrapIDList( LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder** apsf, LPITEMIDLIST * apidlFolder, LPITEMIDLIST * apidlItems, LONG * pcFetched ) ;

    // *** IShellService methods ***
    virtual STDMETHODIMP SetOwner(IUnknown * punkOwner);

    // *** ITranslateShellChangeNotify methods ***
    virtual STDMETHODIMP TranslateIDs(LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                      LONG *plEvent2, LPITEMIDLIST * ppidlOut1Event2, LPITEMIDLIST * ppidlOut2Event2);
    virtual STDMETHODIMP IsChildID(LPCITEMIDLIST pidlKid, BOOL fImmediate);
    virtual STDMETHODIMP IsEqualID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual STDMETHODIMP Register(HWND hwnd, UINT uMsg, long lEvents);
    virtual STDMETHODIMP Unregister();

protected:
    CAugmentedISF();
    ~CAugmentedISF();

    friend HRESULT  CAugmentedISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    
    IShellFolder *  _GetObjectPSF(int nID);
    BOOL            _IsCommonPidl(LPCITEMIDLIST pidl);

    STDMETHOD_( LPITEMIDLIST, TranslatePidl )( LPCITEMIDLIST pidlNS, LPCITEMIDLIST pidl, LPARAM lParam /*int nID*/) ;
    STDMETHOD_( LPITEMIDLIST, GetNativePidl )( LPCITEMIDLIST pidl, LPARAM lParam /*int nID*/) ;



    int     _cRef;
    HDPA    _hdpa;

    IUnknown * _punkOwner;
};


#endif  // _AUGISF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\augmisf.h ===
//-------------------------------------------------------------------------//
//  
//  AugMisf.h  - Augmented Merge IShellFolder class declaration.
//
//-------------------------------------------------------------------------//

#ifndef __AUGMISF_H__
#define __AUGMISF_H__

class CAugISFEnumItem
{
public:
    CAugISFEnumItem()   {};
    BOOL Init(IShellFolder* psf, int iShellFolder, LPCITEMIDLIST pidl);
    BOOL InitWithWrappedToOwn(IShellFolder* psf, int iShellFolder, LPITEMIDLIST pidl);

    ~CAugISFEnumItem()
    {
        Str_SetPtr(&_pszDisplayName, NULL);
        ILFree(_pidlWrap);
    }
    void SetDisplayName(LPTSTR pszDispName)
    {
        Str_SetPtr(&_pszDisplayName, pszDispName);
    }
    ULONG          _rgfAttrib;
    LPTSTR         _pszDisplayName;
    LPITEMIDLIST   _pidlWrap;
};


//  Forwards:
//-------------//
class CNamespace ;
STDAPI CAugmentedISF2_CreateInstance( IUnknown*, IUnknown**, LPCOBJECTINFO );  

class IAugmentedMergedShellFolderInternal : public IUnknown
{
public:
    STDMETHOD(GetPidl)(THIS_ int* /*in|out*/ piPos, DWORD grfEnumFlags, LPITEMIDLIST* ppidl) PURE;
};

//-------------------------------------------------------------------------//
//  Supports hierarchically merged shell namespaces
class CAugmentedMergeISF : public IAugmentedShellFolder2,
                           public IShellFolder2,
                           public IShellService,
                           public ITranslateShellChangeNotify,
                           public IDropTarget,
                           public IAugmentedMergedShellFolderInternal
//-------------------------------------------------------------------------//
{
public:
    // *** IUnknown methods ***
    STDMETHOD ( QueryInterface )    ( REFIID, void ** ) ;
    STDMETHOD_( ULONG, AddRef )     ( ) ;
    STDMETHOD_( ULONG, Release )    ( ) ;
    
    // *** IShellFolder methods ***
    STDMETHOD( BindToObject )       ( LPCITEMIDLIST, LPBC, REFIID, LPVOID * ) ;
    STDMETHOD( BindToStorage )      ( LPCITEMIDLIST, LPBC, REFIID, LPVOID * ) ;
    STDMETHOD( CompareIDs )         ( LPARAM, LPCITEMIDLIST, LPCITEMIDLIST) ;
    STDMETHOD( CreateViewObject )   ( HWND, REFIID, LPVOID * ) ;
    STDMETHOD( EnumObjects )        ( HWND, DWORD, LPENUMIDLIST * ) ;
    STDMETHOD( GetAttributesOf )    ( UINT, LPCITEMIDLIST * , ULONG * ) ;
    STDMETHOD( GetDisplayNameOf )   ( LPCITEMIDLIST , DWORD , LPSTRRET ) ;
    STDMETHOD( GetUIObjectOf )      ( HWND, UINT, LPCITEMIDLIST *, REFIID, UINT *, LPVOID * ) ;
    STDMETHOD( ParseDisplayName )   ( HWND, LPBC, LPOLESTR, ULONG *, LPITEMIDLIST *, ULONG * ) ;
    STDMETHOD( SetNameOf )          ( HWND, LPCITEMIDLIST, LPCOLESTR, DWORD, LPITEMIDLIST *) ;

    // *** IShellFolder2 methods ***
    // stub implementation to indicate we support CompareIDs() for identity
    STDMETHOD( GetDefaultSearchGUID)( LPGUID ) { return E_NOTIMPL; }
    STDMETHOD( EnumSearches )       ( LPENUMEXTRASEARCH *pe) { *pe = NULL; return E_NOTIMPL; }
    STDMETHOD(GetDefaultColumn)(DWORD dwRes, ULONG *pSort, ULONG *pDisplay) { return E_NOTIMPL; };
    STDMETHOD(GetDefaultColumnState)(UINT iColumn, DWORD *pbState) { return E_NOTIMPL; };
    STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv) { return E_NOTIMPL; };
    STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails){ return E_NOTIMPL; };
    STDMETHOD(MapColumnToSCID)(UINT iCol, SHCOLUMNID *pscid) { return E_NOTIMPL; };

    // *** IAugmentedShellFolder methods ***
    STDMETHOD( AddNameSpace )       ( const GUID * pguidObject, IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags ) ;
    STDMETHOD( GetNameSpaceID )     ( LPCITEMIDLIST pidl, GUID * pguidOut ) ;
    STDMETHOD( QueryNameSpace )     ( DWORD dwID, GUID * pguidOut, IShellFolder ** ppsf ) ;
    STDMETHOD( EnumNameSpace )      ( DWORD cNameSpaces, DWORD * pdwID ) ;

    // *** IAugmentedShellFolder2 methods ***
    // not used anywhere
    //STDMETHOD( GetNameSpaceCount )  ( OUT LONG* pcNamespaces ) ;
    //STDMETHOD( GetIDListWrapCount)  ( LPCITEMIDLIST pidlWrap, OUT LONG * pcPidls) ;
    STDMETHOD( UnWrapIDList)        ( LPCITEMIDLIST pidlWrap, LONG cPidls, IShellFolder** apsf, LPITEMIDLIST* apidlFolder, LPITEMIDLIST* apidlItems, LONG* pcFetched ) ;

    // *** IShellService methods ***
    STDMETHOD( SetOwner )           ( IUnknown * punkOwner ) ;

    // *** ITranslateShellChangeNotify methods ***
    STDMETHOD( TranslateIDs )       ( LONG *plEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                      LONG *plEvent2, LPITEMIDLIST * ppidlOut1Event2, LPITEMIDLIST * ppidlOut2Event2);
    STDMETHOD( IsChildID )          ( LPCITEMIDLIST pidlKid, BOOL fImmediate );
    STDMETHOD( IsEqualID )          ( LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2 );
    STDMETHOD( Register )           ( HWND hwnd, UINT uMsg, long lEvents );
    STDMETHOD( Unregister )         ( void );

    // *** IDropTarget methods ***
    STDMETHOD(DragEnter)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragOver)(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHOD(DragLeave)(void);
    STDMETHOD(Drop)(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IAugmentedMergedShellFolderInternal ***
    STDMETHODIMP GetPidl(int* piPos, DWORD grfEnumFlags, LPITEMIDLIST* ppidl);

//  Construction, Destruction
protected:
    CAugmentedMergeISF() ;
    virtual ~CAugmentedMergeISF() ;

//  Miscellaneous helpers
protected:
    STDMETHOD( QueryNameSpace )     ( DWORD dwID, OUT PVOID* ppvNameSpace ) ;
    
    //  pidl crackers
    STDMETHOD_( LPITEMIDLIST, GetNativePidl )( LPCITEMIDLIST pidl, LPARAM lParam /*int nID*/) ;

    BOOL     _IsCommonPidl(LPCITEMIDLIST pidlItem);

    HRESULT _SearchForPidl(IShellFolder* psf, LPCITEMIDLIST pidl, BOOL fFolder, int* piIndex, CAugISFEnumItem** ppEnumItem);
    HRESULT  _GetNamespaces(LPCITEMIDLIST pidlWrap, CNamespace** ppnsCommon, UINT* pnCommonID,
                                                    CNamespace** ppnsUser, UINT* pnUserID,
                                                    LPITEMIDLIST* ppidl, BOOL *pbIsFolder);
    HRESULT  _GetContextMenu(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, 
                                        UINT * prgfInOut, LPVOID* ppvOut);
    BOOL     _AffectAllUsers();
    //  namespace utility methods
    STDMETHOD( GetDefNamespace )    ( LPCITEMIDLIST pidl, ULONG, OUT IShellFolder** ppsf, OUT LPITEMIDLIST* ppv) ;
    STDMETHOD( GetDefNamespace )    ( ULONG dwAttrib, OUT PVOID* ppv, OUT UINT *pnID, OUT PVOID* ppv0) ;
    CNamespace* Namespace( int iNamespace ) ;
    int         NamespaceCount() const ;
    void        FreeNamespaces() ;

    int                 AcquireObjects() ;
    void                FreeObjects() ;
    static int CALLBACK DestroyObjectsProc( LPVOID pv, LPVOID pvData ) ;
    friend int CALLBACK AugMISFSearchForWrappedPidl(LPVOID p1, LPVOID p2, LPARAM lParam);
    BOOL IsChildIDInternal(LPCITEMIDLIST pidl, BOOL fImmediate, int* iShellFolder);

#ifdef DEBUG
    void DumpObjects();
#endif
    
//  Callback routines
private:
    static      int SetOwnerProc( LPVOID, LPVOID ) ;
    static      int DestroyNamespacesProc(LPVOID pv, LPVOID pvData) ;

//  Data
protected:
    HDPA          _hdpaNamespaces ;     // source namespace collection
    LPUNKNOWN     _punkOwner ;          // owner object
    LONG          _cRef;                // reference count.
    IDropTarget*  _pdt;
    HWND          _hwnd;
    BITBOOL       _fCommon : 1;         // is _pdt a common programs folder (or its child)
#ifdef DEBUG
    BITBOOL       _fInternalGDNO:1 ;
#endif
    HDPA          _hdpaObjects;
    int           _count;
    DWORD         _grfDragEnterKeyState;
    DWORD         _dwDragEnterEffect;

    friend HRESULT CAugmentedISF2_CreateInstance( IUnknown*, IUnknown**, LPCOBJECTINFO );  
} ;

//-------------------------------------------------------------------------//
//  inline implementation 
inline int CAugmentedMergeISF::NamespaceCount() const {
    return _hdpaNamespaces ? DPA_GetPtrCount( _hdpaNamespaces ) : 0 ;
}
inline CNamespace* CAugmentedMergeISF::Namespace( int iNamespace )  {
    return _hdpaNamespaces ? 
        (CNamespace*)DPA_GetPtr( _hdpaNamespaces, iNamespace ) : NULL ;
}

//-------------------------------------------------------------------------//
//  CAugmentedMergeISF enumerator object.
class CEnum : public IEnumIDList
//-------------------------------------------------------------------------//
{
//  Public interface methods
public:
    // *** IUnknown methods ***
    STDMETHOD ( QueryInterface ) (REFIID, void ** ) ;
    STDMETHOD_( ULONG,AddRef )  () ;
    STDMETHOD_( ULONG,Release ) () ;

    // *** IEnumIDList methods ***
    STDMETHOD( Next )  (ULONG, LPITEMIDLIST*, ULONG* ) ;
    STDMETHOD( Skip )  (ULONG) ;
    STDMETHOD( Reset ) ();
    STDMETHOD( Clone ) (IEnumIDList** ) ;

// Construction, destruction, assignment:
public:
    CEnum(IAugmentedMergedShellFolderInternal* psmsfi, DWORD grfEnumFlags, int iPos = 0);
    ~CEnum() ;

    //  Miscellaneous methods, data
protected:
    IAugmentedMergedShellFolderInternal* _psmsfi;

    DWORD _grfEnumFlags;
    LONG  _cRef;
    int _iPos;
} ;



#endif __AUGMISF_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\augm.cpp ===
//-------------------------------------------------------------------------//
//  
//  AugMisf.cpp  - Augmented Merge IShellFolder class implementation.
//
//-------------------------------------------------------------------------//
#include "priv.h"
#include "augmisf.h"
#include "resource.h"

#include "mluisupp.h"

#define TF_AUGM 0x10000000
//-------------------------------------------------------------------------//
//  BUGBUG: Shell allocator bullchit, inserted here because SHRealloc 
//  isn't imported into browseui, this module's hosting executable.
//  If we get SHRealloc, the following block can be removed:
#define _EXPL_SHELL_ALLOCATOR_

#ifdef  _EXPL_SHELL_ALLOCATOR_

#define SHRealloc( pv, cb )     shrealloc( pv, cb )

void* shrealloc( void* pv,  size_t cb )
{
    IMalloc* pMalloc ;
    void*    pvRet = NULL ;
    if( SUCCEEDED( SHGetMalloc( &pMalloc ) ) )  {
        pvRet = pMalloc->Realloc( pv, cb ) ;
        ATOMICRELEASE( pMalloc ) ;
    }
    return pvRet ;
}

#endif _EXPL_SHELL_ALLOCATOR_

BOOL     AffectAllUsers(HWND hwnd);

// id - verb mappings for IContextMenu impl
const struct
{
    UINT     id;
    LPCSTR   pszVerb;
} c_sIDVerbMap[] = 
{
    {SMIDM_DELETE,     "delete"},
    {SMIDM_RENAME,     "rename"},
    {SMIDM_PROPERTIES, "properties"},
    //{SMIDM_OPEN,       "open"},
    //{SMIDM_EXPLORE,    "explore"},
};

// augmisf context menu

class CAugMergeISFContextMenu : public IContextMenu2
{
public:
    // *** IUnknown methods ***
    STDMETHOD (QueryInterface)(REFIID, void**);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // *** IContextMenu methods ***
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax);

    // *** IContextMenu2 methods ***    
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:
    CAugMergeISFContextMenu(IShellFolder *psfCommon, LPCITEMIDLIST pidlCommon, 
                            IShellFolder *psfUser,   LPCITEMIDLIST pidlUser, LPITEMIDLIST pidl,
                            HWND hwnd, UINT * prgfInOut);
    ~CAugMergeISFContextMenu();

    friend class CAugmentedMergeISF;
    friend CAugMergeISFContextMenu* CreateMergeISFContextMenu(
                            IShellFolder *psfCommon, LPCITEMIDLIST pidlCommon, 
                            IShellFolder *psfUser,   LPCITEMIDLIST pidlUser, LPITEMIDLIST pidl,
                            HWND hwnd, UINT * prgfInOut);
protected:
    LPITEMIDLIST    _pidlItem;
    IShellFolder *  _psfCommon;
    IShellFolder *  _psfUser;
    IContextMenu *  _pcmCommon;
    IContextMenu *  _pcmUser;
    LPITEMIDLIST    _pidlCommon;
    LPITEMIDLIST    _pidlUser;
    UINT            _idFirst;
    LONG            _cRef;
    HWND            _hwnd;
};

CAugMergeISFContextMenu* CreateMergeISFContextMenu(
                            IShellFolder *psfCommon, LPCITEMIDLIST pidlCommon, 
                            IShellFolder *psfUser,   LPCITEMIDLIST pidlUser, LPITEMIDLIST pidl,
                            HWND hwnd, UINT * prgfInOut)
{
    CAugMergeISFContextMenu* pcm = new CAugMergeISFContextMenu(psfCommon, pidlCommon,
                                                               psfUser, pidlUser,
                                                               pidl, hwnd, prgfInOut);
    if (pcm)
    {
        if (!pcm->_pidlItem)
        {
            delete pcm;
            pcm = NULL;
        }
    }
    return pcm;
}


CAugMergeISFContextMenu::CAugMergeISFContextMenu(IShellFolder *psfCommon, LPCITEMIDLIST pidlCommon,
                                                 IShellFolder *psfUser, LPCITEMIDLIST pidlUser,
                                                 LPITEMIDLIST pidl, HWND hwnd, UINT * prgfInOut)
{
    _cRef = 1;
    HRESULT hres;

    _hwnd = hwnd;
    _psfCommon = psfCommon;
    if (_psfCommon)
    {
        _psfCommon->AddRef();
        hres = _psfCommon->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pidl, IID_IContextMenu, prgfInOut, (void **)&_pcmCommon);

        ASSERT(SUCCEEDED(hres) || !_pcmCommon);
        _pidlCommon = ILClone(pidlCommon);
    }
    _psfUser = psfUser;
    if (_psfUser)
    {
        _psfUser->AddRef();
        hres = _psfUser->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pidl, IID_IContextMenu, prgfInOut, (void **)&_pcmUser);

        ASSERT(SUCCEEDED(hres) || !_pcmUser);
        _pidlUser = ILClone(pidlUser);
    }
    _pidlItem = ILClone(pidl);
    ASSERT(_psfCommon || _psfUser);
}

CAugMergeISFContextMenu::~CAugMergeISFContextMenu()
{
    ATOMICRELEASE(_psfCommon);
    ATOMICRELEASE(_pcmCommon);
    ATOMICRELEASE(_psfUser);
    ATOMICRELEASE(_pcmUser);
    ILFree(_pidlCommon);
    ILFree(_pidlUser);
    ILFree(_pidlItem);
}

STDMETHODIMP CAugMergeISFContextMenu::QueryInterface(REFIID riid, LPVOID *ppvOut)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CAugMergeISFContextMenu, IContextMenu, IContextMenu2),
        QITABENT(CAugMergeISFContextMenu, IContextMenu2),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvOut);
}

STDMETHODIMP_(ULONG) CAugMergeISFContextMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CAugMergeISFContextMenu::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef ) 
    {
        delete this;
    }
    return cRef;
}

HRESULT CAugMergeISFContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hres = E_INVALIDARG;
    
    if (hmenu)
    {
        HMENU hmContext = LoadMenuPopup(MENU_SM_CONTEXTMENU);
        if (hmContext)
        {
            if (!_psfCommon || !_psfUser)
            {
                DeleteMenu(hmContext, SMIDM_OPENCOMMON, MF_BYCOMMAND);
                DeleteMenu(hmContext, SMIDM_EXPLORECOMMON, MF_BYCOMMAND);
            }

            _idFirst = idCmdFirst;
            Shell_MergeMenus(hmenu, hmContext, -1, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
            DestroyMenu(hmContext);

            // Make it look "Shell Like"
            SetMenuDefaultItem(hmenu, 0, MF_BYPOSITION);

            hres = S_OK;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    
    return hres;
}

HRESULT CAugMergeISFContextMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    UINT    id = -1;
    HRESULT hres = E_FAIL;
    CMINVOKECOMMANDINFO ici = *pici;

    if (pici->cbSize < SIZEOF(CMINVOKECOMMANDINFO))
        return E_INVALIDARG;

    if (HIWORD(pici->lpVerb))
    {
        for (int i=0; i < ARRAYSIZE(c_sIDVerbMap); i++)
        {
            if (lstrcmpiA(pici->lpVerb, c_sIDVerbMap[i].pszVerb) == 0)
            {
                id = c_sIDVerbMap[i].id;
                break;
            }
        }
    }
    else
        id = (UINT) PtrToUlong( pici->lpVerb ); // Win64: should be ok since MAKEINTRESOURCE assumed

    switch (id)
    {
        case -1:
            hres = E_INVALIDARG;
            break;

        case SMIDM_OPEN:
        case SMIDM_EXPLORE:
        case SMIDM_OPENCOMMON:
        case SMIDM_EXPLORECOMMON:
            {
                IShellFolder * psf;
                LPITEMIDLIST   pidl;

                if (id == SMIDM_OPEN || id == SMIDM_EXPLORE)
                {
                    if (_psfUser)
                    {
                        psf  = _psfUser;
                        pidl = _pidlUser;
                    }
                    else
                    {
                        psf  = _psfCommon;
                        pidl = _pidlCommon;
                    }
                }
                else
                {
                    psf  = _psfCommon;
                    pidl = _pidlCommon;
                }
                    
                if (psf && pidl)
                {
                    SHELLEXECUTEINFO shei = {0};

                    shei.lpIDList = ILCombine(pidl, _pidlItem);
                    if (shei.lpIDList)
                    {
                        shei.cbSize     = sizeof(shei);
                        shei.fMask      = SEE_MASK_IDLIST;
                        shei.nShow      = SW_SHOWNORMAL;
                        if (id == SMIDM_EXPLORE || id == SMIDM_EXPLORECOMMON)
                            shei.lpVerb = TEXT("explore");
                        else
                            shei.lpVerb = TEXT("open");
                        hres = ShellExecuteEx(&shei) ? S_OK : E_FAIL;
                        ILFree((LPITEMIDLIST)shei.lpIDList);
                    }
                }
            }
            break;

        case SMIDM_PROPERTIES:
            {
                IContextMenu * pcm = _pcmUser ? _pcmUser : _pcmCommon;

                if (pcm)
                {
                    ici.lpVerb = "properties";
                    hres = pcm->InvokeCommand(&ici);
                }
            }
            break;
        case SMIDM_DELETE:
            ici.lpVerb = "delete";
            hres = S_OK;
            
            if (_pcmUser)
            {
                hres = _pcmUser->InvokeCommand(&ici);
            }
            else if (_pcmCommon)
            {
                ici.fMask |= CMIC_MASK_FLAG_NO_UI;
                if (AffectAllUsers(_hwnd))
                    hres = _pcmCommon->InvokeCommand(&ici);   
                else
                    hres = E_FAIL;
            }   
                
            break;
            
        case SMIDM_RENAME:
            ASSERT(0);
            hres = E_NOTIMPL; // sftbar picks this off
            break;
      }
    
    return hres;
}

HRESULT CAugMergeISFContextMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT* pwReserved, LPSTR pszName, UINT cchMax)
{
    HRESULT hres = E_NOTIMPL;

    // if hiword in not null then a string is passed to us. we don't handle that case (yet?)
    if (!HIWORD(idCmd) && (uType == GCS_VERBA || uType == GCS_VERBW))
    {
        hres = E_INVALIDARG;

        for (int i = 0; hres != S_OK && i < ARRAYSIZE(c_sIDVerbMap); i++)
        {
            if (c_sIDVerbMap[i].id == idCmd)
            {
                if (uType == GCS_VERBA)
                {
                    hres = StringCchCopyA(pszName, cchMax, c_sIDVerbMap[i].pszVerb);
                }
                else
                {
                    SHAnsiToUnicode(c_sIDVerbMap[i].pszVerb, (LPWSTR)pszName, cchMax);
                    hres = S_OK;
                }
            }
        }
    }
    return hres;
}

// we need IContextMenu2 although HandleMenuMsg is not impl because of the way sftbar
// works -- it caches only IContextMenu2 so if we don't have ICM2 sftbar will think
// that it does not have context menu so it will eat the messages intended for the hmenu
// that way, with context menu up, if user presses esc it will kill start menu sub menu
// not the context menu.
HRESULT CAugMergeISFContextMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return E_NOTIMPL;
}
//-------------------------------------------------------------------------//
//  Augmented Merge Shell Folder's pidl wrapper package consists of a versioned 
//  header followed by n 'source namespace' pidl wrappers.
//  Each individual pidl wrapper consists of a header containing a
//  collection lookup index followed by the source pidl itself.  The 
//  source pidl's mkid.cb member is used to seek the next pidl wrap in
//  the package.
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//--- Augmented Merge Shell Folder's pidl wrapper header
typedef struct tagAUGM_IDWRAP {
    USHORT      cb ;         // pidl wrap length 
    USHORT      Reserved ;   // reserved.
    ULONG       tag ;        // AugMergeISF pidl signature
    ULONG       version ;    // AugMergeISF pidl version
    ULONG       cSrcs ;      // Number of source namespace objects backing this composite pidl
} AUGM_IDWRAP;

typedef UNALIGNED AUGM_IDWRAP *PAUGM_IDWRAP;

//--- Source pidl header.  One or more of these records will be concatenated 
//    within the wrap following the wrap header.
typedef struct tagAUGM_IDSRC   {
    UINT        nID     ;     // source namespace index
    BYTE        pidl[0] ;     // source pidl
} AUGM_IDSRC;

typedef UNALIGNED AUGM_IDSRC *PAUGM_IDSRC;

//-------------------------------------------------------------------------//
//  Constants
//-------------------------------------------------------------------------//
#define AUGM_WRAPTAG            MAKELONG( MAKEWORD('A','u'), MAKEWORD('g','M') )
#define AUGM_WRAPVERSION_1_0    MAKELONG( 1, 0 )
#define AUGM_WRAPCURRENTVERSION AUGM_WRAPVERSION_1_0
#define INVALID_NAMESPACE_INDEX ((UINT)-1)
#define CB_IDLIST_TERMINATOR    sizeof(USHORT)


//-------------------------------------------------------------------------//
//  Augmented Merge shell folder pidl wrap utilities
//-------------------------------------------------------------------------//


//-------------------------------------------------------------------------//
//  Resolves the wrap header from the indicated pidl.  
#define AugMergeISF_GetWrap( p ) ((PAUGM_IDWRAP)(p))

//-------------------------------------------------------------------------//
//  Determines whether the indicated pidl is an Augmented Merge 
//  shell folder pidl wrapper.
HRESULT AugMergeISF_IsWrap(
    IN LPCITEMIDLIST pidlTest, 
    IN ULONG nVersion = AUGM_WRAPCURRENTVERSION )
{
    ASSERT(IS_VALID_PIDL( pidlTest ));

    if (pidlTest)
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlTest ) ;

        return  (pWrap->cb >= sizeof(AUGM_IDWRAP) && 
                pWrap->tag == AUGM_WRAPTAG && 
                pWrap->version == nVersion) ?  
                    S_OK : E_UNEXPECTED ;         //BUGBUG: better error code for version mismatch?
    }
    else
    {
        return E_INVALIDARG;
    }
}


//-------------------------------------------------------------------------//
//  Retrieves the number of source namespace pidls in the wrap.
//  If the pidl was not wrapped, the return value is -1.
ULONG AugMergeISF_GetSourceCount( IN LPCITEMIDLIST pidl )  
{
    ASSERT(SUCCEEDED(AugMergeISF_IsWrap(pidl)));
    return AugMergeISF_GetWrap(pidl)->cSrcs;
}


//-------------------------------------------------------------------------//
//  Creates an IDLIST wrapper object based on the indicated source pidl.
HRESULT AugMergeISF_CreateWrap( 
    IN LPCITEMIDLIST pidlSrc, 
    IN UINT nSrcID, 
    OUT LPITEMIDLIST* ppidlWrap )
{
    ASSERT( ppidlWrap ) ;
    ASSERT( IS_VALID_PIDL( pidlSrc ) && INVALID_NAMESPACE_INDEX != nSrcID  ) ;

    *ppidlWrap = NULL ;

    //  Allocate a header and terminator
    LPBYTE pBuf = NULL ;
    WORD   cbAlloc = sizeof(AUGM_IDWRAP) + 
                     sizeof(AUGM_IDSRC) + pidlSrc->mkid.cb + 
                     // we need two terminators, one for pidlSrc and one for the wrap
                     // the one for pidlSrc is necessary for the ILClone to work
                     // because it gets confused with the nSrcID that follows the pidl
                     CB_IDLIST_TERMINATOR + 
                     CB_IDLIST_TERMINATOR ;

    if( NULL == (pBuf = (LPBYTE)IEILCreate( cbAlloc )) )
        return E_OUTOFMEMORY ;

    //  Initialize wrap header members
    PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pBuf ) ;
    pWrap->cb       = cbAlloc - CB_IDLIST_TERMINATOR ;
    pWrap->tag      = AUGM_WRAPTAG ;
    pWrap->version  = AUGM_WRAPCURRENTVERSION ;

    if( pidlSrc )
    {
        PAUGM_IDSRC pSrc = (PAUGM_IDSRC)(pBuf + sizeof(AUGM_IDWRAP)) ;
        pSrc->nID = nSrcID ;
        memcpy( pSrc->pidl, pidlSrc, pidlSrc->mkid.cb ) ;
        pWrap->cSrcs = 1 ;
    }

    *ppidlWrap = (LPITEMIDLIST)pWrap ;
    return S_OK ;
}

BOOL WrappedPidlContainsSrcID(LPCITEMIDLIST pidlWrap, UINT uSrcID)
{
    ASSERT(SUCCEEDED(AugMergeISF_IsWrap(pidlWrap)));
    PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlWrap ) ;

    if( pWrap->cSrcs > 0 )
    {
        LPBYTE       p     = ((LPBYTE)pWrap) + sizeof(AUGM_IDWRAP) ; // position of first pidl header.
        PAUGM_IDSRC  pSrc  = (PAUGM_IDSRC)p ;                       
        // offset to next pidl header, needs terminator so that ILClone below can work
        UINT         cbPidl= ((LPITEMIDLIST)pSrc->pidl)->mkid.cb + CB_IDLIST_TERMINATOR;

        if (pSrc->nID != uSrcID && pWrap->cSrcs > 1)
        {
            pSrc = (PAUGM_IDSRC)(p + sizeof(AUGM_IDSRC) + cbPidl) ;
        }

        if (pSrc->nID == uSrcID)
            return TRUE;
    }

    return FALSE;
}

HRESULT AugMergeISF_WrapRemovePidl(
    IN LPITEMIDLIST pidlWrap, 
    IN UINT nSrcID, 
    OUT LPITEMIDLIST* ppidlRet )
{
    ASSERT( IS_VALID_WRITE_PTR( ppidlRet, LPITEMIDLIST )) ;
    
    *ppidlRet = NULL ;

    HRESULT hr = AugMergeISF_IsWrap(pidlWrap);
    if (SUCCEEDED(hr))
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlWrap ) ;

        ASSERT(pWrap->cSrcs > 1);

        LPBYTE       p     = ((LPBYTE)pWrap) + sizeof(AUGM_IDWRAP) ; // position of first pidl header.
        PAUGM_IDSRC  pSrc  = (PAUGM_IDSRC)p ;                       
        // offset to next pidl header, needs terminator so that ILClone below can work
        UINT         cbPidl= ((LPITEMIDLIST)pSrc->pidl)->mkid.cb + CB_IDLIST_TERMINATOR;

        // We want to look for the Other SrcID. So we loop while the source id we're removing is
        // equal. When it's not equal, we've got the ID.
        if (pSrc->nID == nSrcID)
        {
            pSrc = (PAUGM_IDSRC)(p + sizeof(AUGM_IDSRC) + cbPidl) ;
        }

        if (pSrc->nID != nSrcID)
        {
            hr = AugMergeISF_CreateWrap((LPITEMIDLIST)pSrc->pidl, pSrc->nID, ppidlRet);
            ILFree(pidlWrap);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    return hr;
}

//-------------------------------------------------------------------------//
//  Adds a source pidl to the indicated pidl wrap.
HRESULT AugMergeISF_WrapAddPidl( 
    IN LPCITEMIDLIST pidlSrc, 
    IN UINT nSrcID, 
    IN OUT LPITEMIDLIST* ppidlWrap )
{
    ASSERT (ppidlWrap && IS_VALID_PIDL( *ppidlWrap ));
    ASSERT (IS_VALID_PIDL( pidlSrc ));
    ASSERT (INVALID_NAMESPACE_INDEX != nSrcID );

    HRESULT hr ;
    if (FAILED((hr = AugMergeISF_IsWrap(*ppidlWrap))))
        return hr ;

    // AHHHHHHHHHHH Rewrite this.
    if (WrappedPidlContainsSrcID(*ppidlWrap, nSrcID))
    {
        if (AugMergeISF_GetSourceCount(*ppidlWrap) > 1)
        {
            hr = AugMergeISF_WrapRemovePidl((LPITEMIDLIST)*ppidlWrap, nSrcID, ppidlWrap);
        }
        else
        {
            ILFree(*ppidlWrap);
            return AugMergeISF_CreateWrap(pidlSrc, nSrcID, ppidlWrap);
        }

        if (FAILED(hr))
        {
            return hr;
        }
    }

    //  Retrieve wrap header
    PAUGM_IDWRAP pWrap = (PAUGM_IDWRAP)*ppidlWrap ;
    
    //  Reallocate a block large enough to contain our new record.
    WORD offTerm0 = pWrap->cb,      // offset to end of existing wrap
         offTerm1 = offTerm0 + sizeof(AUGM_IDSRC) + pidlSrc->mkid.cb,  // offset to end of next record
         cbRealloc= offTerm1 + 2*CB_IDLIST_TERMINATOR ;   // total bytes to reallocate

    LPBYTE pRealloc ;
    if( NULL == (pRealloc = (LPBYTE)SHRealloc( pWrap, cbRealloc )) )
        return E_OUTOFMEMORY ;

    //  Adjust our pointers if memory moved
    pWrap = (PAUGM_IDWRAP)pRealloc ;

    //  Initialize new record in the wrap
    UNALIGNED AUGM_IDSRC* pSrc = (PAUGM_IDSRC)(pRealloc + offTerm0 ) ;
    pSrc->nID = nSrcID ;
    memcpy( pSrc->pidl, pidlSrc, pidlSrc->mkid.cb ) ;

    //  Terminate new record 
    ZeroMemory( pRealloc + offTerm1, 2*CB_IDLIST_TERMINATOR ) ;

    //  Update our header
    pWrap->cb = cbRealloc - CB_IDLIST_TERMINATOR ;
    pWrap->cSrcs++ ;

    *ppidlWrap = (LPITEMIDLIST)pWrap ;
    return S_OK ;
}

//-------------------------------------------------------------------------//
//  Private pidl enumeration block (GetFirst/GetNext)
typedef struct tagAUGM_IDWRAP_ENUM
{
    ULONG           cbStruct ;    // structure size
    PAUGM_IDWRAP    pWrap ;       // wrap header.
    PAUGM_IDSRC     pSrcNext ;    // pointer to next src header
} AUGM_IDWRAP_ENUM, *PAUGM_IDWRAP_ENUM ;

//-------------------------------------------------------------------------//
//  Begins enumeration of source pidls in the indicated pidl wrap.
HANDLE AugMergeISF_EnumFirstSrcPidl( 
    IN LPCITEMIDLIST pidlWrap, 
    OUT UINT* pnSrcID, 
    OUT LPITEMIDLIST* ppidlRet )
{
    ASSERT( IS_VALID_WRITE_PTR( ppidlRet, LPITEMIDLIST ) && IS_VALID_WRITE_PTR( pnSrcID, UINT ) ) ;
    
    PAUGM_IDWRAP_ENUM pEnum = NULL ;
    *ppidlRet = NULL ;
    *pnSrcID  = (UINT)-1 ;

    HRESULT hr = AugMergeISF_IsWrap(pidlWrap);
    if(SUCCEEDED(hr))
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlWrap ) ;

        if( pWrap->cSrcs > 0 )
        {
            LPBYTE       p     = ((LPBYTE)pWrap) + sizeof(AUGM_IDWRAP) ; // position of first pidl header.
            PAUGM_IDSRC  pSrc  = (PAUGM_IDSRC)p ;                       
            // offset to next pidl header, needs terminator so that ILClone below can work
            UINT         cbPidl= ((LPITEMIDLIST)pSrc->pidl)->mkid.cb + CB_IDLIST_TERMINATOR;
            
            if( NULL != (pEnum = new AUGM_IDWRAP_ENUM) )
            {
                pEnum->cbStruct = sizeof(*pEnum) ;
                pEnum->pWrap    = pWrap ;
                pEnum->pSrcNext = (PAUGM_IDSRC)(p + sizeof(AUGM_IDSRC) + cbPidl) ;
                *pnSrcID = pSrc->nID ;
                *ppidlRet = ILClone( (LPITEMIDLIST)pSrc->pidl ) ;
                if ( NULL == *ppidlRet )
                {
                    delete pEnum;
                    pEnum = NULL;
                }
            }
        }
    }
    return pEnum ;
}

//-------------------------------------------------------------------------//
//  Continues source pidl enumeration
BOOL AugMergeISF_EnumNextSrcPidl( 
    IN HANDLE hEnum, 
    OUT UINT* pnSrcID, 
    OUT LPITEMIDLIST* ppidlRet )
{
    PAUGM_IDWRAP_ENUM pEnum = (PAUGM_IDWRAP_ENUM)hEnum ;
    HRESULT           hr = E_UNEXPECTED ;

    ASSERT( IS_VALID_WRITE_PTR( pEnum, AUGM_IDWRAP_ENUM ) ) ;
    ASSERT( sizeof(*pEnum) == pEnum->cbStruct ) ;
    ASSERT( sizeof(*pEnum) == pEnum->cbStruct );

    *ppidlRet = NULL ;
    *pnSrcID  = (UINT)-1 ;

    if (SUCCEEDED((hr = AugMergeISF_IsWrap((LPCITEMIDLIST)pEnum->pWrap)))) 
    {
        if ((LPBYTE)(pEnum->pWrap) + pEnum->pWrap->cb <= (LPBYTE)pEnum->pSrcNext)
            hr = S_FALSE ;
        else
        {
            UNALIGNED AUGM_IDSRC* pualSrcNext = pEnum->pSrcNext;

            *pnSrcID = pualSrcNext->nID;
            *ppidlRet = ILClone((LPITEMIDLIST)pualSrcNext->pidl);
            
            pEnum->pSrcNext = (PAUGM_IDSRC)(
                                    ((LPBYTE)pualSrcNext) + 
                                    sizeof(AUGM_IDSRC) +
                                    ((LPITEMIDLIST)pualSrcNext->pidl)->mkid.cb + 
                                    CB_IDLIST_TERMINATOR);

            hr = S_OK ;
            return TRUE ;
        }
    }
    return FALSE ;
}

//-------------------------------------------------------------------------//
//  Terminates source pidl enumeration
void AugMergeISF_EndEnumSrcPidls( 
    IN OUT HANDLE& hEnum )
{
    PAUGM_IDWRAP_ENUM pEnum = (PAUGM_IDWRAP_ENUM)hEnum ;

    ASSERT( IS_VALID_WRITE_PTR( pEnum, AUGM_IDWRAP_ENUM ) && 
        sizeof(*pEnum) == pEnum->cbStruct  );
    delete pEnum ;
    hEnum = NULL ;
}

//-------------------------------------------------------------------------//
//  Allocates and returns a copy of the specified source pidl 
//  from the wrapped pidl.
HRESULT AugMergeISF_GetSrcPidl( 
    IN LPCITEMIDLIST pidlWrap, 
    IN UINT nSrcID, 
    OUT LPITEMIDLIST* ppidlRet )
{
    ASSERT( ppidlRet ) ;
    *ppidlRet = NULL ;

    HANDLE       hEnum ;
    BOOL         bEnum ;
    UINT         nSrcIDEnum ;
    LPITEMIDLIST pidlEnum ;

    for( hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nSrcIDEnum, &pidlEnum ), bEnum = TRUE ;
         hEnum && bEnum ;
         bEnum = AugMergeISF_EnumNextSrcPidl( hEnum, &nSrcIDEnum, &pidlEnum ) )
    {
        if( nSrcIDEnum == nSrcID )
        {
            *ppidlRet = pidlEnum ;
            AugMergeISF_EndEnumSrcPidls(hEnum);
            return S_OK ;
        }

        ILFree( pidlEnum ) ;
    }
    AugMergeISF_EndEnumSrcPidls( hEnum ) ;

    return E_FAIL ;
}

#ifdef DEBUG
BOOL  IsValidWrappedPidl(LPCITEMIDLIST pidlWrap)
{
    BOOL fValid = FALSE;

    if (pidlWrap == NULL)
        return FALSE;

    if (FAILED(AugMergeISF_IsWrap(pidlWrap)))
        return FALSE;


    HANDLE       hEnum ;
    UINT         nSrcIDEnum ;
    LPITEMIDLIST pidlEnum ;

    hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nSrcIDEnum, &pidlEnum );
    do 
    {
        fValid = IS_VALID_PIDL(pidlEnum);
        ILFree(pidlEnum);
    }
    while( fValid && AugMergeISF_EnumNextSrcPidl( hEnum, &nSrcIDEnum, &pidlEnum ));
    AugMergeISF_EndEnumSrcPidls( hEnum ) ;

    return fValid;
}
#endif

//-------------------------------------------------------------------------//

int AugmEnumCompare(void *pv1, void *pv2, LPARAM lParam)
{
    CAugISFEnumItem* paugmEnum1 = (CAugISFEnumItem*)pv1;
    CAugISFEnumItem* paugmEnum2 = (CAugISFEnumItem*)pv2;
    int iRet = -1;

    if (paugmEnum1 && paugmEnum2)
    {
        // Are these two items of different types?
        if (BOOLIFY(paugmEnum1->_rgfAttrib & SFGAO_FOLDER) ^ BOOLIFY(paugmEnum2->_rgfAttrib & SFGAO_FOLDER))
        {
            // Yes. Then Folders sort before items.
            iRet = BOOLIFY(paugmEnum1->_rgfAttrib & SFGAO_FOLDER) ? 1 : -1;
        }
        else    // They are of the same type. Then compare by name
        {
            iRet = lstrcmpi(paugmEnum1->_pszDisplayName, paugmEnum2->_pszDisplayName);
        }
    }
        

    return iRet;
}

LPVOID AugmEnumMerge(UINT uMsg, void * pv1, void * pv2, LPARAM lParam)
{    
    void * pvRet = pv1;
    
    switch (uMsg)
    {
        case DPAMM_MERGE:
            {
                HANDLE hEnum;
                UINT   nSrcID;
                LPITEMIDLIST pidl;
                CAugISFEnumItem* paugmeDest = (CAugISFEnumItem*)pv1;
                CAugISFEnumItem* paugmeSrc  = (CAugISFEnumItem*)pv2;

                ASSERT(paugmeDest && paugmeSrc);

                hEnum = AugMergeISF_EnumFirstSrcPidl(paugmeSrc->_pidlWrap, &nSrcID, &pidl);
                if (hEnum)
                {
                    // add pidl from src to dest
                    AugMergeISF_WrapAddPidl(pidl, nSrcID, &paugmeDest->_pidlWrap); 
                    // no longer need hEnum
                    AugMergeISF_EndEnumSrcPidls(hEnum);
                    // this was copied to paugmeDest->_pidlWrap
                    ILFree(pidl);
                }
            }
            break;
        case DPAMM_INSERT:
            {
                CAugISFEnumItem* paugmNew = new CAugISFEnumItem;
                CAugISFEnumItem* paugmSrc = (CAugISFEnumItem*)pv1;

                if (paugmNew)
                {
                    paugmNew->_pidlWrap = ILClone(paugmSrc->_pidlWrap);
                    if (paugmNew->_pidlWrap)
                    {
                        paugmNew->SetDisplayName(paugmSrc->_pszDisplayName);
                        paugmNew->_rgfAttrib = paugmSrc->_rgfAttrib;
                    }
                    else
                    {
                        delete paugmNew;
                        paugmNew = NULL;
                    }
                }
                pvRet = paugmNew;
            }
            break;
        default:
            ASSERT(0);
    }
    return pvRet;
}

typedef struct
{
    LPTSTR pszDisplayName;
    BOOL   fFolder;
} AUGMISFSEARCHFORPIDL;

int CALLBACK AugMISFSearchForOnePidlByDisplayName(LPVOID p1, LPVOID p2, LPARAM lParam)
{
    AUGMISFSEARCHFORPIDL* pSearchFor = (AUGMISFSEARCHFORPIDL*)p1;
    CAugISFEnumItem* paugmEnum  = (CAugISFEnumItem*)p2;

    // Are they of different types?
    if (BOOLIFY(paugmEnum->_rgfAttrib & SFGAO_FOLDER) ^ pSearchFor->fFolder)
    {
        // Yes. 
        return pSearchFor->fFolder ? 1 : -1;
    }
    else    // They are of the same type. Then compare by name
    {
        return StrCmpI(pSearchFor->pszDisplayName, paugmEnum->_pszDisplayName);
    }
}

//-------------------------------------------------------------------------------------------------//
//  DPA utilities
#define DPA_GETPTRCOUNT( hdpa )         ((NULL != (hdpa)) ? DPA_GetPtrCount((hdpa)) : 0)
#define DPA_GETPTR( hdpa, i, type )     ((NULL != (hdpa)) ? (type*)DPA_GetPtr((hdpa), i) : (type*)NULL)
#define DPA_DESTROY( hdpa, pfn )        { if( NULL != hdpa ) \
                                            { DPA_DestroyCallback( hdpa, pfn, NULL ) ; \
                                              hdpa = NULL ; }}

//-------------------------------------------------------------------------------------------------//
//  Forwards...
class CEnum ;
class CChildObject ;


//-------------------------------------------------------------------------------------------------//
//  Augmented Merge Shell Folder source namespace descriptor.
//
//  Objects of class CNamespace are created by CAugmentedMergeISF in 
//  the AddNameSpace() method impl, and are maintained in the collection
//  CAugmentedMergeISF::_hdpaNamespaces.
//
class CNamespace
//-------------------------------------------------------------------------------------------------//
{
public:
    CNamespace( const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib ) ; 
    ~CNamespace() ;

    IShellFolder*   ShellFolder()   { return _psf ; }
    REFGUID         Guid()          { return _guid ; }
    ULONG           Attrib() const  { return _dwAttrib ; }
    LPITEMIDLIST    GetPidl() const { return _pidl; }

    void            Assign( const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib ) ;
    void            Unassign() ;

    HRESULT         RegisterNotify( HWND, UINT, ULONG ) ;
    HRESULT         UnregisterNotify() ;

    BOOL            SetOwner( IUnknown *punk ) ;
    
protected:
    IShellFolder*   _psf ;      // IShellFolder interface pointer
    GUID            _guid ;     // optional GUID for specialized UI handling
    LPITEMIDLIST    _pidl ;     // optional pidl
    ULONG           _dwAttrib ;  // optional flags
    UINT            _uChangeReg ; // Shell change notify registration ID.
} ;

//-------------------------------------------------------------------------------------------------//
inline CNamespace::CNamespace( const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib ) 
    :  _psf(NULL), 
       _pidl(NULL), 
       _guid(GUID_NULL), 
       _dwAttrib(0), 
       _uChangeReg(0)
{
    Assign( pguidUIObject, psf, pidl, dwAttrib ) ;
}

//-------------------------------------------------------------------------------------------------//
inline CNamespace::~CNamespace()  { 
    UnregisterNotify() ;
    Unassign() ;
}

//-------------------------------------------------------------------------------------------------//
//  Assigns data members.
void CNamespace::Assign( const GUID * pguidUIObject, IShellFolder* psf, LPCITEMIDLIST pidl, ULONG dwAttrib )
{
    Unassign() ;
    if( NULL != (_psf = psf) )
        _psf->AddRef() ;

    _pidl       = ILClone( pidl ) ;
    _guid       = pguidUIObject ? *pguidUIObject : GUID_NULL ;
    _dwAttrib   = dwAttrib ;

}

//-------------------------------------------------------------------------------------------------//
//  Unassigns data members.
void CNamespace::Unassign()
{
    ATOMICRELEASE( _psf ) ; 
    ILFree( _pidl ) ;
    _pidl = NULL ;
    _guid = GUID_NULL ;
    _dwAttrib = 0L ;
}

//-------------------------------------------------------------------------------------------------//
//  Register change notification for the namespace
HRESULT CNamespace::RegisterNotify( HWND hwnd, UINT uMsg, ULONG lEvents )
{
    if( 0 == _uChangeReg )
        _uChangeReg = ::RegisterNotify(hwnd,
                                       uMsg,
                                       _pidl,
                                       lEvents,
                                       SHCNRF_ShellLevel | SHCNRF_InterruptLevel | SHCNRF_RecursiveInterrupt,
                                       TRUE);

    return 0 != _uChangeReg ? S_OK : E_FAIL ;
}

//-------------------------------------------------------------------------------------------------//
//  Unregister change notification for the namespace
HRESULT CNamespace::UnregisterNotify()
{
    if( 0 != _uChangeReg )
    {
        UINT uID = _uChangeReg;

        _uChangeReg = 0;
        ::SHChangeNotifyDeregister(uID);
    }
    return S_OK;
}

//-------------------------------------------------------------------------------------------------//
inline BOOL CNamespace::SetOwner(IUnknown *punkOwner)
{
    if (_psf)
    {
        IUnknown_SetOwner(_psf, punkOwner);
        return TRUE ;
    }
    
    return FALSE ;
}

//-------------------------------------------------------------------------//
CAugmentedMergeISF::CAugmentedMergeISF() : _cRef(1)
{
    ASSERT(_hdpaNamespaces == NULL);
    ASSERT(_punkOwner == NULL);
    ASSERT(_pdt == NULL);
    DllAddRef() ;
}

//-------------------------------------------------------------------------//
CAugmentedMergeISF::~CAugmentedMergeISF()
{
    SetOwner(NULL);
    FreeNamespaces();
    DllRelease();
}

//-------------------------------------------------------------------------//
//  CAugmentedMergeISF global CreateInstance method for da class factory
//-------------------------------------------------------------------------//
STDAPI CAugmentedISF2_CreateInstance( IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi )
{
    // aggregation checking is handled in class factory
    CAugmentedMergeISF* pObj;

    if( NULL == (pObj = new CAugmentedMergeISF) )
        return E_OUTOFMEMORY ;

    *ppunk = SAFECAST( pObj, IAugmentedShellFolder2 * ) ;
    return S_OK;
}

//-------------------------------------------------------------------------//
//   CAugmentedMergeISF - IUnknown methods
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI( CAugmentedMergeISF, IShellFolder, IAugmentedShellFolder ),
        QITABENT( CAugmentedMergeISF, IAugmentedShellFolder ),
        QITABENT( CAugmentedMergeISF, IAugmentedShellFolder2 ),
        QITABENT( CAugmentedMergeISF, IShellFolder2 ),
        QITABENT( CAugmentedMergeISF, IShellService ),
        QITABENT( CAugmentedMergeISF, ITranslateShellChangeNotify ),
        QITABENT( CAugmentedMergeISF, IDropTarget ),
        { 0 },
    };
    return QISearch( this, qit, riid, ppvObj ) ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP_(ULONG) CAugmentedMergeISF::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

//-------------------------------------------------------------------------//
STDMETHODIMP_(ULONG) CAugmentedMergeISF::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef ) 
    {
        delete this;
    }
    return cRef;
}

//-------------------------------------------------------------------------//
//   CAugmentedMergeISF - IShellFolder methods
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList)
{
    HRESULT hr = E_FAIL;

    if (_hdpaNamespaces)
    {
        // BUGBUG (lamadio): This does not work if you have 2 enumerators. But,
        // when asking for a new enumerator, we should flush the cache.
        FreeObjects();

        *ppenumIDList = new CEnum(this, grfFlags);

        if (NULL == *ppenumIDList)
            return E_OUTOFMEMORY ;
        hr = S_OK ;
    }
    
    return hr;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::BindToObject( LPCITEMIDLIST pidlWrap, LPBC pbc, REFIID riid, LPVOID *ppvOut )
{
    ASSERT(IS_VALID_PIDL( pidlWrap ) && NULL != ppvOut);

    *ppvOut = NULL ;
        
    if (SUCCEEDED(AugMergeISF_IsWrap(pidlWrap)))
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap( pidlWrap ) ;
        ASSERT(IsValidWrappedPidl(pidlWrap));
        ASSERT( pWrap ) ;
        ASSERT( pWrap->cSrcs > 0 ) ;    // should never, never happen

        HANDLE           hEnum ;
        BOOL             bEnum ;
        UINT             nIDSrc = -1 ;
        DEBUG_CODE(int   iNumBound = 0);
        LPITEMIDLIST     pidlSrc ;
        HRESULT          hr = E_UNEXPECTED ;
        CNamespace* pSrc = NULL ;
        
        CAugmentedMergeISF* pISF ;
        if (NULL == (pISF = new CAugmentedMergeISF))
            return E_OUTOFMEMORY ;
    
        for (hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nIDSrc, &pidlSrc ), bEnum = TRUE ;
             hEnum && bEnum ;
             bEnum = AugMergeISF_EnumNextSrcPidl( hEnum, &nIDSrc, &pidlSrc))
        {
            if (SUCCEEDED((hr = QueryNameSpace(nIDSrc, (PVOID*)&pSrc))) && pSrc)
            {
                IShellFolder *psf;

                hr = S_FALSE;
                if (SUCCEEDED(pSrc->ShellFolder()->BindToObject(pidlSrc, NULL, IID_IShellFolder, (void **)&psf)))
                {
                    LPCITEMIDLIST pidlParent = pSrc->GetPidl();
                    LPITEMIDLIST  pidlFull   = ILCombine(pidlParent, pidlSrc);
                                 
                    hr = pISF->AddNameSpace(NULL, psf, pidlFull, pSrc->Attrib());
#ifdef DEBUG
                    if (SUCCEEDED(hr))
                        iNumBound++;
#endif
                    ILFree(pidlFull);
                    psf->Release();
                }
                ASSERT(SUCCEEDED(hr));
            }
            ILFree(pidlSrc);
        }

             // If this hits, then something is terribly wrong. Either we were unable to bind to the
             // ShellFolders, or the add failed. This could be caused by a bad wrapped pidl.
        ASSERT(iNumBound > 0);

        AugMergeISF_EndEnumSrcPidls( hEnum ) ;
        hr = pISF->QueryInterface(riid, ppvOut);
        pISF->Release();
        return hr ;
    }
    return E_UNEXPECTED ;    
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::BindToStorage( LPCITEMIDLIST, LPBC, REFIID, void ** )
{
    return E_NOTIMPL ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::CompareIDs( 
    LPARAM lParam, 
    LPCITEMIDLIST pidl1, 
    LPCITEMIDLIST pidl2)
{
    IShellFolder    *psf1 = NULL, *psf2 = NULL;
    LPITEMIDLIST    pidlItem1 = NULL, pidlItem2 = NULL;
    int             iRet = 0 ;
    HRESULT         hr1, hr2, hr ;

    hr1 = GetDefNamespace( pidl1, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf1, &pidlItem1 ) ;
    hr2 = GetDefNamespace( pidl2, ASFF_DEFNAMESPACE_DISPLAYNAME, &psf2, &pidlItem2 ) ;

    if( SUCCEEDED( hr1 ) && SUCCEEDED( hr2 ) )
    {
        ULONG dwAttrib1 = SFGAO_FOLDER, dwAttrib2 = SFGAO_FOLDER;
        //  Same namespace? Just forward the request.
        if( psf1 == psf2 )
        {
            hr = psf1->CompareIDs( lParam, pidlItem1, pidlItem2 ) ;
            ILFree( pidlItem1 ) ;
            ILFree( pidlItem2 ) ;
            return hr ;
        }

        hr1 = psf1->GetAttributesOf( 1, (LPCITEMIDLIST*)&pidlItem1, &dwAttrib1 ) ;
        hr2 = psf2->GetAttributesOf( 1, (LPCITEMIDLIST*)&pidlItem2, &dwAttrib2 ) ;

        if( SUCCEEDED( hr1 ) && SUCCEEDED( hr2 ) )
        {
            //  Comparison heuristics:
            //  (1) folders take precedence over nonfolders, (2) alphanum comparison
            if( 0 != (dwAttrib1 & SFGAO_FOLDER) && 
                0 == (dwAttrib2 & SFGAO_FOLDER) )
                iRet = -1 ;
            else if( 0 == (dwAttrib1 & SFGAO_FOLDER) && 
                     0 != (dwAttrib2 & SFGAO_FOLDER) )
                iRet = 1 ;
            else
            {
                STRRET  strName1, strName2;
                HRESULT hres1 = E_FAIL;
                HRESULT hres2 = E_FAIL;
                TCHAR   szName1[MAX_PATH],  szName2[MAX_PATH];
                hr1 = psf1->GetDisplayNameOf(pidlItem1, SHGDN_FORPARSING | SHGDN_INFOLDER, &strName1); 
                hr2 = psf2->GetDisplayNameOf(pidlItem2, SHGDN_FORPARSING | SHGDN_INFOLDER, &strName2);

                if (SUCCEEDED(hr1) && SUCCEEDED(hr2))
                {
                    // must call StrRetToBuf because it frees StrRet strings if allocated
                    hres1 = StrRetToBuf(&strName1, pidlItem1, szName1, ARRAYSIZE(szName1));
                    hres2 = StrRetToBuf(&strName2, pidlItem2, szName2, ARRAYSIZE(szName2));
                }
                // if the names match we return -1 because they are different pidls with
                // the same name

                if (SUCCEEDED(hr1) && SUCCEEDED(hr2) && SUCCEEDED(hres1) && SUCCEEDED(hres2))
                {
                    iRet = lstrcmp(szName1, szName2); // Comparisons are by name with items of the same type.
                }
            }
        }
    }

    hr = FAILED( hr1 ) ? hr1 : 
         FAILED( hr2 ) ? hr2 : 
         S_OK ;
   
    if( pidlItem1 )
        ILFree( pidlItem1 ) ;
    if( pidlItem2 )
        ILFree( pidlItem2 ) ;

    return MAKE_HRESULT( HRESULT_SEVERITY( hr ), HRESULT_FACILITY( hr ), iRet ) ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::CreateViewObject( 
    HWND hwndOwner, 
    REFIID riid, 
    LPVOID * ppvOut )
{
    HRESULT          hr ;
    CNamespace  *pSrc, *pSrc0 ;
    
    pSrc = pSrc0 = NULL ;

    // TODO: Handle IDropTarget here, delegate for all others.
    if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = QueryInterface(riid, ppvOut);
        if (SUCCEEDED(hr))
            _hwnd = hwndOwner;
        return hr;
    }

    //  Search for default namespace for CreateViewObj()
    if( FAILED( (hr = GetDefNamespace( ASFF_DEFNAMESPACE_VIEWOBJ, (PVOID*)&pSrc, NULL, (PVOID*)&pSrc0 )) ) )
        return hr ;

    if( NULL == pSrc ) 
        pSrc = pSrc0 ;

    if( NULL != pSrc )
    {
        ASSERT( pSrc->ShellFolder() ) ;
        hr = pSrc->ShellFolder()->CreateViewObject( hwndOwner, riid, ppvOut ) ;
    }

    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetAttributesOf( 
    UINT cidl, 
    LPCITEMIDLIST * apidl, 
    ULONG * rgfInOut )
{
    IShellFolder* pISF ;
    LPITEMIDLIST  pidlItem ;
    HRESULT       hr ;

    if( cidl > 1 )  // support 1 only.
        return E_NOTIMPL ;
        
    if( !apidl )
        return E_INVALIDARG ;
    
    //  Forward to default namespace for item attributes
    if( FAILED( (hr = GetDefNamespace(  
        apidl[0], ASFF_DEFNAMESPACE_ATTRIB, &pISF, &pidlItem )) ) )
        return hr ;

    hr = pISF->GetAttributesOf( 1, (LPCITEMIDLIST*)&pidlItem, rgfInOut ) ;
    
    ILFree( pidlItem ) ;
    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetUIObjectOf(
    HWND hwndOwner, 
    UINT cidl, 
    LPCITEMIDLIST * apidl, 
    REFIID riid, 
    UINT * prgfInOut, 
    LPVOID * ppvOut )
{
    IShellFolder* pISF ;
    LPITEMIDLIST  pidlItem ;
    HRESULT       hr ;

    if (cidl > 1)  // support 1 only.
        return E_NOTIMPL ;
        
    if (!apidl)
        return E_INVALIDARG ;

    if (IsEqualGUID(riid, IID_IContextMenu))
    {
        hr = _GetContextMenu(hwndOwner, cidl, apidl, prgfInOut, ppvOut);
    }
    else
    {
        //  Forward to default namespace for UI object
        if (FAILED((hr = GetDefNamespace(apidl[0], ASFF_DEFNAMESPACE_UIOBJ, &pISF, &pidlItem))))
            return hr ;

        hr = pISF->GetUIObjectOf(hwndOwner, 1, (LPCITEMIDLIST*)&pidlItem, riid, prgfInOut, ppvOut);
        ILFree(pidlItem);
    }
    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetDisplayNameOf( 
    LPCITEMIDLIST pidl, 
    DWORD grfFlags, 
    LPSTRRET pstrName )
{
    IShellFolder* pISF ;
    LPITEMIDLIST  pidlItem ;
    HRESULT       hr ;

    //  Forward to default namespace for display name
    if (FAILED((hr = GetDefNamespace( 
        pidl, ASFF_DEFNAMESPACE_DISPLAYNAME, &pISF, &pidlItem))))
        return hr ;

    if (SUCCEEDED((hr = pISF->GetDisplayNameOf(pidlItem, grfFlags, pstrName))))
    {
        //  STRRET_OFFSET has no meaning in context of the pidl wrapper.
        //  We can either calculate the offset into the wrapper, or allocate
        //  a wide char for the name.  For expedience, we'll allocate the name.
        
        if (pstrName->uType == STRRET_OFFSET)
        {
            UINT cch = lstrlenA( STRRET_OFFPTR( pidlItem, pstrName ) ) ;
            LPWSTR pwszName = (LPWSTR)SHAlloc( (cch + 1) * sizeof(WCHAR));

            if (NULL !=  pwszName)
            {
                SHAnsiToUnicode( STRRET_OFFPTR( pidlItem, pstrName ), pwszName, cch+1 );
                pwszName[cch] = (WCHAR)0 ;
            }
            pstrName->pOleStr = pwszName ;
            pstrName->uType   = STRRET_WSTR ;
        }

#ifdef DEBUG
        // If the trace flags are set, and this is not comming from an internal query,
        // Then append the location where this name came from
        if (g_qwTraceFlags & TF_AUGM && _fInternalGDNO == FALSE)
        {
            if (pstrName->uType == STRRET_WSTR)
            {
                LPWSTR wszOldName = pstrName->pOleStr;
                UINT cch = lstrlenW(wszOldName);
                UINT cchWithExtra = cch + 50;

                pstrName->pOleStr = (LPWSTR)SHAlloc( cchWithExtra * sizeof(WCHAR));

                if (pstrName->pOleStr)
                {
                    StringCchCopyW(pstrName->pOleStr, cchWithExtra, wszOldName);

                    if (AugMergeISF_GetSourceCount(pidl) > 1)
                        StringCchCatW(pstrName->pOleStr, cchWithExtra, L" (Merged)");
                    else if (WrappedPidlContainsSrcID(pidl, 0))
                        StringCchCatW(pstrName->pOleStr, cchWithExtra, L" (1)");
                    else
                        StringCchCatW(pstrName->pOleStr, cchWithExtra, L" (2)");

                    SHFree(wszOldName);
                }
                else
                {
                    pstrName->pOleStr = wszOldName;
                }
            }
            else if (pstrName->uType == STRRET_CSTR)
            {
                if (AugMergeISF_GetSourceCount(pidl) > 1)
                    StringCchCatA(pstrName->cStr, ARRAYSIZE(pstrName->cStr), " (Merged)");
                else if (WrappedPidlContainsSrcID(pidl, 0))
                    StringCchCatA(pstrName->cStr, ARRAYSIZE(pstrName->cStr), " (1)");
                else
                    StringCchCatA(pstrName->cStr, ARRAYSIZE(pstrName->cStr), " (2)");
            }
        }

#endif
    }

    ILFree( pidlItem ) ;
    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::ParseDisplayName( 
    HWND hwndOwner, 
    LPBC pbcReserved, 
    LPOLESTR pwszName, 
    ULONG * pchEaten, 
    LPITEMIDLIST * ppidl, 
    ULONG * pdwAttrib )
{
    int iIndex;
    LPITEMIDLIST pidl;

    *ppidl = NULL;
    // This ParseDisplayName should iterate through all our delegates until one works.
    for (iIndex = NamespaceCount() - 1; iIndex >=0 ; iIndex--)
    {
        CNamespace* pSrc = Namespace(iIndex) ;
        if (pSrc)
        {
            if (SUCCEEDED(pSrc->ShellFolder()->ParseDisplayName(hwndOwner, pbcReserved, pwszName, pchEaten,
                                                  &pidl, pdwAttrib)))
            {
                ASSERT(pidl);   // Make sure a valid pidl comes out.
                if (*ppidl == NULL)
                    AugMergeISF_CreateWrap(pidl, iIndex, ppidl);
                else
                    AugMergeISF_WrapAddPidl(pidl, iIndex, ppidl);

                ILFree(pidl);
            }
        }
    }

    return *ppidl? S_OK : E_FAIL;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::SetNameOf( 
    HWND hwndOwner, 
    LPCITEMIDLIST pidl, 
    LPCOLESTR pwszName, 
    DWORD uFlags, 
    LPITEMIDLIST *ppidlOut )
{
    CNamespace*   pnsCommon;
    CNamespace*   pnsUser;
    LPITEMIDLIST  pidlItem;
    HRESULT       hres;
    UINT          uiUser;
    UINT          uiCommon;

    hres = _GetNamespaces(pidl, &pnsCommon, &uiCommon, &pnsUser, &uiUser, &pidlItem, NULL);
    if (SUCCEEDED(hres))
    {
        LPITEMIDLIST pidlNew = NULL;
        UINT         uiNamespace = INVALID_NAMESPACE_INDEX;

        if (pnsUser)
        {
            hres = pnsUser->ShellFolder()->SetNameOf(hwndOwner, pidlItem, pwszName, uFlags, &pidlNew);
            uiNamespace = uiUser;
        }
        else if (pnsCommon)
        {
            hres = E_FAIL;

            if (AffectAllUsers(hwndOwner))
            {
                hres = pnsCommon->ShellFolder()->SetNameOf(hwndOwner, pidlItem, pwszName, uFlags, &pidlNew);
                uiNamespace = uiCommon;
            }
        }

        if (ppidlOut)
        {
            *ppidlOut = NULL;
            // wrap the pidl
            if (SUCCEEDED(hres) && pidlNew)
                AugMergeISF_CreateWrap(pidlNew, uiNamespace, ppidlOut);
        }
        
        ILFree(pidlNew);
        ILFree(pidlItem);
    }
    return hres;
}

//-------------------------------------------------------------------------//
//  IAugmentedShellFolder methods
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
//  Adds a source namespace to the Augmented Merge shell folder object.
STDMETHODIMP CAugmentedMergeISF::AddNameSpace( 
    const GUID * pguidObject, 
    IShellFolder * psf, 
    LPCITEMIDLIST pidl, 
    DWORD dwFlags )
{
    ASSERT (IS_VALID_CODE_PTR(psf, IShellFolder*));
    ASSERT (IS_VALID_PIDL(pidl));

    //  Check for duplicate via full display name
    
    for( int i=0, max = NamespaceCount() ; i < max; i++ )
    {
        CNamespace* pSrc = Namespace( i ) ;
        if (pSrc)
        {
            if (ILIsEqual(pSrc->GetPidl(), pidl))
            {
                //  Found!  Reassign attributes
                pSrc->Assign( pguidObject, psf, pidl, dwFlags ) ;
                return S_OK ;
            }
        }
    }

    //  No match; safe to append it to collection, creating DPA if necessary.
    if( NULL == _hdpaNamespaces && 
        NULL == (_hdpaNamespaces= DPA_Create( 2 )) )
        return E_OUTOFMEMORY ;

    CNamespace *pSrc = new CNamespace( pguidObject, psf, pidl, dwFlags );
    if( NULL == pSrc )
        return E_OUTOFMEMORY ;
    
    return DPA_AppendPtr( _hdpaNamespaces, pSrc ) >= 0 ?  S_OK : E_FAIL;
}

//-------------------------------------------------------------------------//
//  Retrieves the primary namespace iid for the wrapped pidl.
STDMETHODIMP CAugmentedMergeISF::GetNameSpaceID( 
    LPCITEMIDLIST pidl, 
    GUID * pguidOut )
{
    HRESULT hr ;
    if (FAILED((hr = AugMergeISF_IsWrap( pidl ))))
        return hr ;

    //  BUGBUG: need to enumerate wrapped source pidls
    return E_NOTIMPL ;
}

//-------------------------------------------------------------------------//
//  Retrieves a pointer to a source namespace descriptor associated with 
//  the specified lookup index.
STDMETHODIMP CAugmentedMergeISF::QueryNameSpace( ULONG nID, PVOID* ppSrc )
{
    if (!ppSrc)
        return E_INVALIDARG;
    *ppSrc = NULL;

    LONG cSrcs;

    if ((cSrcs = NamespaceCount()) <=0)
        return E_FAIL;

    if(nID >= (ULONG)cSrcs) 
        return E_INVALIDARG;

    if (NULL == (*ppSrc = Namespace(nID)))
        return E_UNEXPECTED;

    return S_OK;
}

//-------------------------------------------------------------------------//
//  Retrieves data for the namespace identified by dwID.
STDMETHODIMP CAugmentedMergeISF::QueryNameSpace( 
    ULONG nID, 
    GUID * pguidOut, 
    IShellFolder ** ppsf )
{
    CNamespace* pSrc = NULL ;
    HRESULT          hr = QueryNameSpace( nID, (PVOID*)&pSrc ) ;

    if( pguidOut )  
        *pguidOut = NULL != pSrc ? pSrc->Guid() : GUID_NULL ;

    if( ppsf )
    {      
        if( (*ppsf = (NULL != pSrc) ? pSrc->ShellFolder() : NULL) != NULL )
            (*ppsf)->AddRef() ;
    }

    return hr ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::EnumNameSpace( 
    DWORD uNameSpace, 
    DWORD * pdwID )
{
    return E_NOTIMPL ;
}

//-------------------------------------------------------------------------//
//  IAugmentedShellFolder2 methods
//-------------------------------------------------------------------------//

//GetNameSpaceCount and GetIDListWrapCount are not used anywhere
#if 0
//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetNameSpaceCount( OUT LONG* pcNamespaces )
{
    if( !pcNamespaces )
        return E_INVALIDARG ;

    *pcNamespaces = (LONG)NamespaceCount() ;
    return S_OK ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetIDListWrapCount(
    LPCITEMIDLIST pidlWrap, 
    OUT LONG * pcPidls)
{
    if( NULL == pidlWrap || NULL == pcPidls )
        return E_INVALIDARG ;

    *pcPidls = 0 ;

    HRESULT hr ;
    if (SUCCEEDED((hr = AugMergeISF_IsWrap(pidlWrap))))
    {
        PAUGM_IDWRAP pWrap = AugMergeISF_GetWrap(pidlWrap);
        *pcPidls = pWrap->cSrcs;
        hr = S_OK;
    }
    return hr;
}
#endif // #if 0
//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::UnWrapIDList(
    LPCITEMIDLIST pidlWrap, 
    LONG cPidls, 
    IShellFolder** apsf, 
    LPITEMIDLIST* apidlFolder, 
    LPITEMIDLIST* apidlItems, 
    LONG* pcFetched )
{
    HRESULT         hr ;
    HANDLE          hEnum ;
    BOOL            bEnum = TRUE ;
    UINT            nSrcID ;
    LPITEMIDLIST    pidlItem ;
    LONG            cFetched = 0;

    if (NULL == pidlWrap || cPidls <= 0)
        return E_INVALIDARG ;

    if (FAILED((hr = AugMergeISF_IsWrap(pidlWrap))))
        return hr ;

    //  Enumerate pidls in wrap
    for (hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nSrcID, &pidlItem);
         cFetched < cPidls && hEnum && bEnum ;
         bEnum = AugMergeISF_EnumNextSrcPidl( hEnum, &nSrcID, &pidlItem))
    {
        //  Retrieve namespace data
        CNamespace* pSrc ;
        if (SUCCEEDED((hr = QueryNameSpace(nSrcID, (PVOID*)&pSrc))))
        {
            if (apsf)
            {
                apsf[cFetched] = pSrc->ShellFolder() ;
                if (apsf[cFetched])
                    apsf[cFetched]->AddRef();
            }
            if (apidlFolder)
                apidlFolder[cFetched] = ILClone(pSrc->GetPidl());
            if (apidlItems)
            {
                apidlItems[cFetched] = pidlItem;
                pidlItem = NULL; // paranoia -- just making sure we, somehow, don't free this guy at the end of the for loop
            }
            cFetched++ ;
        }
        else
        {
            ILFree( pidlItem ) ;
        }
    }
    ILFree(pidlItem); // AugMergeISF_EnumNextSrcPidl is called (if there are 2 wrapped pidls and we ask for only one)
                      // right before we exit the for loop so we have to free pidl if allocated.
    if (hEnum)
        AugMergeISF_EndEnumSrcPidls( hEnum );

    if( pcFetched )
        *pcFetched = cFetched ;
    
    return cFetched == cPidls ? S_OK : S_FALSE ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::SetOwner( IUnknown* punkOwner )
{
    HRESULT hr = S_OK ;
    
    int cSrcs = NamespaceCount() ;

    if( cSrcs > 0 )
        DPA_EnumCallback( _hdpaNamespaces, SetOwnerProc, NULL ) ;

    ATOMICRELEASE( _punkOwner ) ;

    if( punkOwner )
    {
        hr = punkOwner->QueryInterface(IID_IUnknown, (LPVOID *)&_punkOwner ) ;
        
        if( cSrcs )
            DPA_EnumCallback( _hdpaNamespaces, SetOwnerProc, (void *)_punkOwner);
    }

    return hr ;
}

//-------------------------------------------------------------------------//
int CAugmentedMergeISF::SetOwnerProc( LPVOID pv, LPVOID pvParam )
{
    CNamespace* pSrc = (CNamespace*) pv ;
    ASSERT( pSrc ) ;

    return pSrc->SetOwner( (IUnknown*)pvParam ) ;
}

//-------------------------------------------------------------------------//
//  ITranslateShellChangeNotify methods
//-------------------------------------------------------------------------//

LPITEMIDLIST ILCombineBase(LPCITEMIDLIST pidlContainingBase, LPCITEMIDLIST pidlRel)
{
    // This routine differs from ILCombine in that it takes the First pidl's base, and
    // cats on the last id of the second pidl. We need this so Wrapped pidls
    // end up with the same base, and we get a valid full pidl.
    LPITEMIDLIST pidlRet = NULL;
    LPITEMIDLIST pidlBase = ILClone(pidlContainingBase);
    if (pidlBase)
    {
        ILRemoveLastID(pidlBase);

        pidlRet = ILCombine(pidlBase, pidlRel);

        ILFree(pidlBase);
    }

    return pidlRet;
}

BOOL IsFolderEvent(LONG lEvent)
{
    return lEvent == SHCNE_MKDIR || lEvent == SHCNE_RMDIR || lEvent == SHCNE_RENAMEFOLDER;
}

#ifdef DEBUG
void CAugmentedMergeISF::DumpObjects()
{
    if (g_dwDumpFlags & TF_AUGM)
    {
        ASSERT(_hdpaObjects);
        int iObjectCount = DPA_GetPtrCount(_hdpaObjects);
        TraceMsg(TF_AUGM, "CAugMISF::DumpObjects: Number of items: %d", iObjectCount);

        CNamespace* pns = (CNamespace *)DPA_FastGetPtr(_hdpaNamespaces, 0);
        if (pns)
            DebugDumpPidl(TF_AUGM, TEXT("CAugMISF::DumpObjects Namespace 1"), pns->GetPidl());

        pns = (CNamespace *)DPA_FastGetPtr(_hdpaNamespaces, 1);
        if (pns)
            DebugDumpPidl(TF_AUGM, TEXT("CAugMISF::DumpObjects Namespace 2"), pns->GetPidl());

        for (int i = 0; i < iObjectCount; i++)
        {
            CAugISFEnumItem* pEnumItem = (CAugISFEnumItem*)DPA_FastGetPtr(_hdpaObjects, i);
            TraceMsg(TF_ALWAYS, "CAugMISF::DumpObjects: %s, Folder: %s Merged: %s",
                pEnumItem->_pszDisplayName, 
                BOOLIFY(pEnumItem->_rgfAttrib & SFGAO_FOLDER) ? TEXT("Yes") : TEXT("No"),
                (AugMergeISF_GetSourceCount(pEnumItem->_pidlWrap) > 1)? TEXT("Yes") : TEXT("No")); 
        }
    }
}
#endif

BOOL GetRealPidlFromSimple(LPCITEMIDLIST pidlSimple, LPITEMIDLIST* ppidlReal)
{
    // Similar to SHGetRealIDL in Function, but SHGetRealIDL does SHGDN_FORPARSING | INFOLDER.
    // I need the parsing name. I can't rev SHGetRealIDL very easily, so here's this one!
    TCHAR szFullName[MAX_PATH];
    if (SUCCEEDED(SHGetNameAndFlags(pidlSimple, SHGDN_FORPARSING, szFullName, SIZECHARS(szFullName), NULL)))
    {
        *ppidlReal = ILCreateFromPath(szFullName);
    }

    if (*ppidlReal == NULL) // Unable to create? Then use the simple pidl. This is because it does not exist any more
    {                       // For say, a Delete Notify
        *ppidlReal = ILClone(pidlSimple);
    }

    return *ppidlReal != NULL;
}



//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::TranslateIDs( 
    LONG *plEvent, 
    LPCITEMIDLIST pidl1, 
    LPCITEMIDLIST pidl2, 
    LPITEMIDLIST * ppidlOut1, 
    LPITEMIDLIST * ppidlOut2,
    LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
    LPITEMIDLIST *ppidlOut2Event2)
{
    HRESULT hres = E_FAIL;

    switch (*plEvent)
    {
    case SHCNE_EXTENDED_EVENT:
    case SHCNE_ASSOCCHANGED:
    case SHCNE_UPDATEIMAGE:
        return S_OK;

    case SHCNE_UPDATEDIR:
        FreeObjects();
        return S_OK;
    }

    ASSERT(ppidlOut1);
    ASSERT(ppidlOut2);
    LONG lEvent = *plEvent;

    *plEvent2 = (LONG)-1;
    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;

    
    *ppidlOut1 = (LPITEMIDLIST)pidl1;
    *ppidlOut2 = (LPITEMIDLIST)pidl2;

    if (!plEvent)
        return E_FAIL;

    // If they are already wrapped, don't wrap twice.
    if ((pidl1 && SUCCEEDED(AugMergeISF_IsWrap(ILFindLastID(pidl1)))) ||
        (pidl2 && SUCCEEDED(AugMergeISF_IsWrap(ILFindLastID(pidl2)))))
    {
        // We don't want to wrap twice.
        return E_FAIL;
    }

    if (!_hdpaNamespaces)
        return E_FAIL;

    if (!_hdpaObjects)
        return E_FAIL;

    CAugISFEnumItem* pEnumItem;

    int iIndex;
    int iShellFolder1 = -1;
    int iShellFolder2 = -1;
    IShellFolder* psf1 = NULL;
    IShellFolder* psf2 = NULL;
    LPITEMIDLIST pidlReal1 = NULL;
    LPITEMIDLIST pidlReal2 = NULL;
    LPITEMIDLIST pidlRealRel1 = NULL;
    LPITEMIDLIST pidlRealRel2 = NULL;
    BOOL fFolder = IsFolderEvent(*plEvent);

    // Get the information about these Simple pidls: Are they our Children? If so, what namespace?
    BOOL fChild1 = IsChildIDInternal(pidl1, TRUE, &iShellFolder1);
    BOOL fChild2 = IsChildIDInternal(pidl2, TRUE, &iShellFolder2);

    // Is either a child?
    if (!(fChild1 || fChild2))
        return hres;

    // Ok, pidl1 is a child, can we get the Real pidl from the simple one?
    if (pidl1 && !GetRealPidlFromSimple(pidl1, &pidlReal1))
        goto Cleanup;

    // Ok, pidl2 is a child, can we get the Real pidl from the simple one?
    if (pidl2 && !GetRealPidlFromSimple(pidl2, &pidlReal2))
        goto Cleanup;

    // These are for code clarity later on. We deal with Relative pidls from here until the very end,
    // when we combine the base of the in pidls with the outgoing wrapped pidls.
    if (pidlReal1)
        pidlRealRel1 = ILFindLastID(pidlReal1);

    if (pidlReal2)
        pidlRealRel2 = ILFindLastID(pidlReal2);

    // Is Pidl1 in our namespaces?
    if (iShellFolder1 != -1)
    {
        // Yes, lets get the non-refcounted shell folder that know's about this pidl.
        CNamespace * pns = (CNamespace *)DPA_GetPtr(_hdpaNamespaces, iShellFolder1);
        psf1 = pns->ShellFolder();  // Non ref counted.
    }

    // Is Pidl2 in our namespaces?
    if (iShellFolder2 != -1)
    {
        // Yes, lets get the non-refcounted shell folder that know's about this pidl.
        CNamespace * pns = (CNamespace *)DPA_GetPtr(_hdpaNamespaces, iShellFolder2);
        psf2 = pns->ShellFolder();  // Non ref counted.
    }

    hres = S_OK;

    DEBUG_CODE(_fInternalGDNO = TRUE);

    switch(*plEvent)
    {
    case 0: // Just look up the pidls and return.
        {
            DWORD rgfAttrib = SFGAO_FOLDER;
            if (iShellFolder1 != -1)
            {
                psf1->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlRealRel1, &rgfAttrib);
                if (S_OK == _SearchForPidl(psf1, pidlRealRel1, BOOLIFY(rgfAttrib & SFGAO_FOLDER), &iIndex, &pEnumItem))
                {
                    *ppidlOut1 = ILCombineBase(pidlReal1, pEnumItem->_pidlWrap);
                    if (!*ppidlOut1)
                        hres = E_OUTOFMEMORY;
                }
            }

            rgfAttrib = SFGAO_FOLDER;
            if (iShellFolder2 != -1 && SUCCEEDED(hres))
            {
                psf2->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlRealRel2, &rgfAttrib);
                if (S_OK == _SearchForPidl(psf2, pidlRealRel2, BOOLIFY(rgfAttrib & SFGAO_FOLDER), &iIndex, &pEnumItem))
                {
                    *ppidlOut2 = ILCombineBase(pidlReal2, pEnumItem->_pidlWrap);
                    if (!*ppidlOut2)
                        hres = E_OUTOFMEMORY;
                }
            }
        }

        break;

    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        {
            TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_MKDIR") : TEXT("SHCNE_CREATE")); 
            // Is there a thing of this name already?
            if (S_OK == _SearchForPidl(psf1, pidlRealRel1, fFolder, &iIndex, &pEnumItem))
            {
                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s needs to be merged. Converting to Rename", pEnumItem->_pszDisplayName);
                // Yes; Then we need to merge this new pidl into the wrapped pidl, and change this
                // to a rename, passing the Old wrapped pidl as the first arg, and the new wrapped pidl
                // as the second arg. I have to be careful about the freeing:
                // Free *ppidlOut1
                // Clone pEnumItem->_pidlWrap -> *ppidlOut1.
                // Add pidl1 to pEnumItem->_pidlWrap.
                // Clone new pEnumItem->_pidlWrap -> *ppidlOut2.  ASSERT(*ppidlOut2 == NULL)

                *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                if (*ppidlOut1)
                {
                    AugMergeISF_WrapAddPidl(pidlRealRel1, iShellFolder1, &pEnumItem->_pidlWrap); 
                    *ppidlOut2 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);

                    if (!*ppidlOut2)
                        TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl2");

                    *plEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                }
                else
                {
                    TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl1");
                }

            }
            else
            {
                LPITEMIDLIST pidlWrap;
                CAugISFEnumItem* paugmEnum = new CAugISFEnumItem;
                if (paugmEnum)
                {
                    if (SUCCEEDED(AugMergeISF_CreateWrap(pidlRealRel1, (UINT)iShellFolder1, &pidlWrap)) &&
                        paugmEnum->InitWithWrappedToOwn(SAFECAST(this, IAugmentedShellFolder2*), 
                                                        iShellFolder1, pidlWrap))
                    {
                        AUGMISFSEARCHFORPIDL AugMSearch;
                        AugMSearch.pszDisplayName = paugmEnum->_pszDisplayName;
                        AugMSearch.fFolder = fFolder;

                        int iInsertIndex = DPA_Search(_hdpaObjects, (LPVOID)&AugMSearch, 0,
                                AugMISFSearchForOnePidlByDisplayName, NULL, DPAS_SORTED | DPAS_INSERTAFTER);

                        TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Creating new unmerged %s at %d", 
                            paugmEnum->_pszDisplayName, iInsertIndex);

                        if (iInsertIndex < 0)
                            iInsertIndex = DA_LAST;

                        if (DPA_InsertPtr(_hdpaObjects, iInsertIndex, paugmEnum) == -1)
                        {
                            TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Was unable to add %s for some reason. Bailing", 
                                paugmEnum->_pszDisplayName);
                            DestroyObjectsProc(paugmEnum, NULL);
                        }
                        else
                        {
                            *ppidlOut1 = ILCombineBase(pidl1, paugmEnum->_pidlWrap);
                        }
                    }
                    else
                        DestroyObjectsProc(paugmEnum, NULL);
                }
            }

        }
        break;

    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        {
            TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_RMDIR") : TEXT("SHCNE_DELETE")); 
            int iDeleteIndex;
            // Is there a folder of this name already?
            if (S_OK == _SearchForPidl(psf1, pidlRealRel1, 
                fFolder, &iDeleteIndex, &pEnumItem))
            {
                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Found %s checking merge state.", pEnumItem->_pszDisplayName); 
                // Yes; Then we need to unmerge this pidl from the wrapped pidl, and change this
                // to a rename, passing the Old wrapped pidl as the first arg, and the new wrapped pidl
                // as the second arg. I have to be careful about the freeing:
                // Free *ppidlOut1
                // Clone pEnumItem->_pidlWrap -> *ppidlOut1.
                // Remove pidl1 from pEnumItem->_pidlWrap
                // Convert to rename, pass new wrapped as second arg. 

                if (AugMergeISF_GetSourceCount( pEnumItem->_pidlWrap )  > 1 )
                {
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is Merged. Removing pidl, convert to rename", pEnumItem->_pszDisplayName); 
                    *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                    if (*ppidlOut1)
                    {
                        EVAL(SUCCEEDED(AugMergeISF_WrapRemovePidl(pEnumItem->_pidlWrap, 
                            iShellFolder1, &pEnumItem->_pidlWrap)));

                        *ppidlOut2 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);

                        if (!*ppidlOut2)
                            TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl2");

                        *plEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                    }
                    else
                    {
                        TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl1");
                    }
                }
                else
                {
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is not Merged. deleteing", pEnumItem->_pszDisplayName); 
                    pEnumItem = (CAugISFEnumItem*)DPA_DeletePtr(_hdpaObjects, iDeleteIndex);

                    if (EVAL(pEnumItem))
                    {
                        *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                        DestroyObjectsProc(pEnumItem, NULL);
                    }
                    else
                    {
                        TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to get %d from DPA", iDeleteIndex);
                    }
                }

            }

        }
        break;

    case SHCNE_RENAMEITEM:
    case SHCNE_RENAMEFOLDER:
        {
            // BUGBUG (lamadio): When renaming an item in the menu, this code will split it into
            // a Delete and a Create. We need to detect this situation and convert it to 1 rename. This
            // will solve the problem of the lost order during a rename....
            BOOL fEvent1Set = FALSE;
            BOOL fFirstPidlInNamespace = FALSE;
            TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s", fFolder? 
                TEXT("SHCNE_RENAMEFOLDER") : TEXT("SHCNE_RENAMEITEM")); 

            // Is this item being renamed FROM the Folder?
            if (iShellFolder1 != -1 &&          // Is this pidl a child of the Folder?
                S_OK == _SearchForPidl(psf1, pidlRealRel1, 
                fFolder, &iIndex, &pEnumItem))  // Is it found?
            {
                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Old pidl %s is in the Folder", pEnumItem->_pszDisplayName); 
                // Yes.
                // Then we need to see if the item that it's being renamed from was Merged

                // Need this for reentrancy
                if (WrappedPidlContainsSrcID(pEnumItem->_pidlWrap, iShellFolder1))
                {
                    // Was it merged?
                    if (AugMergeISF_GetSourceCount(pEnumItem->_pidlWrap) > 1)    // Case 3)
                    {
                        TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is Merged. Removing pidl. Convert to rename for event 1", 
                            pEnumItem->_pszDisplayName); 
                        // Yes;
                        // Then we need to unmerge that item.
                        *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                        if (*ppidlOut1)
                        {
                            // UnWrap
                            AugMergeISF_WrapRemovePidl(pEnumItem->_pidlWrap, iShellFolder1, &pEnumItem->_pidlWrap); 

                            *ppidlOut2 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);

                            if (!*ppidlOut2)
                                TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl2");

                            // This We need to "Rename" the old wrapped pidl, to this new one
                            // that does not contain the old item.
                            fEvent1Set = TRUE;
                        }
                        else
                        {
                            TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to create new pidl1");
                        }
                    }
                    else
                    {
                        TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is not merged. Nuking item Convert to Delete for event 1.", 
                            pEnumItem->_pszDisplayName); 
                        // No, This was not a wrapped pidl. Then, convert to a delete:
                        pEnumItem = (CAugISFEnumItem*)DPA_DeletePtr(_hdpaObjects, iIndex);

                        if (EVAL(pEnumItem))
                        {
                            // If we're renaming from this folder, into this folder, Then the first event stays a rename.
                            if (iShellFolder2 == -1)
                            {
                                fEvent1Set = TRUE;
                                *plEvent = fFolder? SHCNE_RMDIR : SHCNE_DELETE;
                            }
                            else
                            {
                                fFirstPidlInNamespace = TRUE;
                            }
                            *ppidlOut1 = ILCombineBase(pidl1, pEnumItem->_pidlWrap);
                            DestroyObjectsProc(pEnumItem, NULL);
                        }
                        else
                        {
                            TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Failure. Was unable to find Item at %d", iIndex);
                        }

                    }
                }
                else
                {
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Skipping this because we already processed it."
                        "Dragging To Desktop?");
                    hres = E_FAIL;
                }

            }

            // Is this item is being rename INTO the Start Menu?
            if (iShellFolder2 != -1)
            {
                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: New pidl is in the Folder"); 
                LPITEMIDLIST* ppidlNewWrapped1 = ppidlOut1;
                LPITEMIDLIST* ppidlNewWrapped2 = ppidlOut2;
                LONG* plNewEvent = plEvent;

                if (fEvent1Set)
                {
                    plNewEvent = plEvent2;
                    ppidlNewWrapped1 = ppidlOut1Event2;
                    ppidlNewWrapped2 = ppidlOut2Event2;
                }

                if (S_OK == _SearchForPidl(psf2, pidlRealRel2, 
                    fFolder, &iIndex, &pEnumItem))
                {

                    // If we're renaming from this folder, into this folder, Check to see if the destination has a
                    // conflict. If there is a confict (This case), then convert first event to a remove, 
                    // and the second event to the rename.
                    if (fFirstPidlInNamespace)
                    {
                        fEvent1Set = TRUE;
                        *plEvent = fFolder? SHCNE_RMDIR : SHCNE_DELETE;
                        plNewEvent = plEvent2;
                        ppidlNewWrapped1 = ppidlOut1Event2;
                        ppidlNewWrapped2 = ppidlOut2Event2;
                    }
                    
                    
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is in Folder", pEnumItem->_pszDisplayName);
                    TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Adding pidl to %s. Convert to Rename for event %s", 
                        pEnumItem->_pszDisplayName, fEvent1Set? TEXT("2") : TEXT("1"));

                    // Then the destination needs to be merged.
                    *ppidlNewWrapped1 = ILCombineBase(pidl2, pEnumItem->_pidlWrap);
                    if (*ppidlNewWrapped1)
                    {
                        TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Successfully created out pidl1");
                        AugMergeISF_WrapAddPidl(pidlRealRel2, iShellFolder2, &pEnumItem->_pidlWrap); 

                        *ppidlNewWrapped2 = ILCombineBase(pidl2, pEnumItem->_pidlWrap);

                        *plNewEvent = fFolder? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM;
                    }
                }
                else
                {
                    LPITEMIDLIST pidlWrap;
                    CAugISFEnumItem* paugmEnum = new CAugISFEnumItem;

                    if (paugmEnum)
                    {
                        if (SUCCEEDED(AugMergeISF_CreateWrap(pidlRealRel2, (UINT)iShellFolder2, &pidlWrap)) &&
                            paugmEnum->InitWithWrappedToOwn(SAFECAST(this, IAugmentedShellFolder2*), 
                                                            iShellFolder2, pidlWrap))
                        {
                            AUGMISFSEARCHFORPIDL AugMSearch;
                            AugMSearch.pszDisplayName = paugmEnum->_pszDisplayName;
                            AugMSearch.fFolder = BOOLIFY(paugmEnum->_rgfAttrib & SFGAO_FOLDER);

                            int iInsertIndex = DPA_Search(_hdpaObjects, &AugMSearch, 0,
                                    AugMISFSearchForOnePidlByDisplayName, NULL, DPAS_SORTED | DPAS_INSERTAFTER);

                            TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: %s is a new item. Converting to Create", 
                                paugmEnum->_pszDisplayName);

                            if (iInsertIndex < 0)
                                iInsertIndex = DA_LAST;

                            if (DPA_InsertPtr(_hdpaObjects, iInsertIndex, paugmEnum) == -1)
                            {
                                TraceMsg(TF_ERROR, "CAugMISF::TranslateIDs: Was unable to add %s for some reason. Bailing", 
                                    paugmEnum->_pszDisplayName);
                                DestroyObjectsProc(paugmEnum, NULL);
                            }
                            else
                            {
                                TraceMsg(TF_AUGM, "CAugMISF::TranslateIDs: Creating new item %s at %d for event %s", 
                                    paugmEnum->_pszDisplayName, iInsertIndex,  fEvent1Set? TEXT("2") : TEXT("1"));

                                // If we're renaming from this folder, into this folder, Then the first event stays
                                // a rename.
                                if (!fFirstPidlInNamespace)
                                {
                                    *plNewEvent = fFolder ? SHCNE_MKDIR : SHCNE_CREATE;
                                    *ppidlNewWrapped1 = ILCombineBase(pidl2, pidlWrap);
                                    *ppidlNewWrapped2 = NULL;
                                }
                                else
                                    *ppidlOut2 = ILCombineBase(pidl2, pidlWrap);

                            }
                        }
                        else
                            DestroyObjectsProc(paugmEnum, NULL);

                    }
                }
            }
        }
        break;

    default:
        break;
    }

Cleanup:
    ILFree(pidlReal1);
    ILFree(pidlReal2);

#ifdef DEBUG
    DumpObjects();
    _fInternalGDNO = FALSE;
#endif


    return hres;
}

BOOL CAugmentedMergeISF::IsChildIDInternal(LPCITEMIDLIST pidlKid, BOOL fImmediate, int* piShellFolder)
{
    // This is basically the same Method as the interface method, but returns the shell folder
    // that it came from.
    BOOL fChild = FALSE;

    //At this point we should have a translated pidl
    if (pidlKid)
    {
        if (SUCCEEDED(AugMergeISF_IsWrap(pidlKid)))
        {
            LPCITEMIDLIST pidlRelKid = ILFindLastID(pidlKid);
            if (pidlRelKid)
            {
                UINT   uiId;
                LPITEMIDLIST pidl;
                HANDLE hEnum = AugMergeISF_EnumFirstSrcPidl(pidlRelKid, &uiId, &pidl);

                if (hEnum)
                {
                    do
                    {
                        ILFree(pidl);

                        for (int i = 0; fChild == FALSE && i < DPA_GetPtrCount(_hdpaNamespaces); i++)
                        {
                            CNamespace * pns = (CNamespace *)DPA_GetPtr(_hdpaNamespaces, i);
                            // reuse pidl
                            if (pns && (pidl = pns->GetPidl()) != NULL)
                            {
                                if (ILIsParent(pidl, pidlKid, fImmediate) &&
                                    !ILIsEqual(pidl, pidlKid))
                                {
                                    fChild = TRUE;
                                    if (piShellFolder)
                                        *piShellFolder = i;
                                }
                            }
                        }
                    }
                    while (fChild == FALSE && AugMergeISF_EnumNextSrcPidl(hEnum, &uiId, &pidl));

                    AugMergeISF_EndEnumSrcPidls(hEnum);
                }
            }
        }
        else
        {
            int cSrcs = NamespaceCount();

            for(int i = 0; fChild == FALSE && i < cSrcs ; i++)
            {
                CNamespace* pSrc = Namespace(i);
                if (pSrc && ILIsParent(pSrc->GetPidl(), pidlKid, fImmediate) && 
                    !ILIsEqual(pSrc->GetPidl(), pidlKid))
                {
                    fChild = TRUE;
                    if (piShellFolder)
                        *piShellFolder = i;
                }
            }
        }
    }

    return fChild;
}

//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::IsChildID( LPCITEMIDLIST pidlKid, BOOL fImmediate)
{
    return IsChildIDInternal(pidlKid, fImmediate, NULL) ? S_OK : S_FALSE;
}

//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::IsEqualID( LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2 )
{
    // This used to return E_NOTIMPL. I'm kinda overloading the interface to mean:
    // is this equal tp any of your namespaces.
    HRESULT hres = S_FALSE;
    int cSrcs = NamespaceCount();

    for(int i = 0; hres == S_FALSE && i < cSrcs ; i++)
    {
        CNamespace* pSrc = Namespace(i);
        if (pidl1)
        {
            if (pSrc && ILIsEqual(pSrc->GetPidl(), pidl1))
                hres = S_OK;
        }
        else if (pidl2) // If you pass a pidl2 it means: Is pidl2 a parent of one of my namespaces?
        {
            if (pSrc && ILIsParent(pidl2, pSrc->GetPidl(), FALSE))
                hres = S_OK;
        }

    }
    return hres;
}

//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::Register( 
    HWND hwnd, 
    UINT uMsg, 
    long lEvents )
{
    int i, cSrcs ;

    if( 0 >= (cSrcs = NamespaceCount()) )
        return E_FAIL ;
    
    for( i = 0; i < cSrcs ; i++ )
    {
        CNamespace* pSrc ;
        if( NULL != (pSrc = Namespace( i )) )
            pSrc->RegisterNotify( hwnd, uMsg, lEvents ) ;
    }
    return S_OK ;
}

//-------------------------------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::Unregister ()
{
    int i, cSrcs = NamespaceCount() ;
    
    if( cSrcs <= 0 )
        return E_FAIL ;
    
    for( i = 0; i < cSrcs ; i++ )
    {
        CNamespace* pSrc ;
        if( NULL != (pSrc = Namespace( i )) )
            pSrc->UnregisterNotify() ;
    }
    return S_OK ;
}

// *** IDropTarget methods ***
#define HIDA_GetPIDLFolder(pida)        (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[0])
#define HIDA_GetPIDLItem(pida, i)       (LPCITEMIDLIST)(((LPBYTE)pida)+(pida)->aoffset[i+1])

HRESULT CAugmentedMergeISF::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    ASSERT(!_fCommon);
    ASSERT(_pdt == NULL);
    if (pDataObj)
    {        
        InitClipboardFormats();
        
        FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium;

        medium.pUnkForRelease = NULL;
        medium.hGlobal = NULL;

        if (SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
        {
            LPIDA pida = (LPIDA)GlobalLock(medium.hGlobal);
            
            if (pida)
            {
                LPCITEMIDLIST pidlItem = HIDA_GetPIDLFolder(pida);

                _fCommon = BOOLIFY(_IsCommonPidl(pidlItem));
                GlobalUnlock(medium.hGlobal);
            }
            ReleaseStgMedium(&medium);
        }

        CNamespace *pSrc = NULL;
        ULONG gdnsAttribs = 0;
        
        if (!_fCommon)
            gdnsAttribs = ASFF_DEFNAMESPACE_ALL;
            
        if (SUCCEEDED(GetDefNamespace(gdnsAttribs, (PVOID*)&pSrc, NULL, NULL)))
        {
            if (SUCCEEDED(pSrc->ShellFolder()->CreateViewObject(_hwnd, IID_IDropTarget, (void **)&_pdt)))
            {
                _pdt->DragEnter(pDataObj, grfKeyState, pt, pdwEffect);
            }
        }        
    }

    _grfDragEnterKeyState = grfKeyState;
    _dwDragEnterEffect = *pdwEffect;

    return S_OK;
}

HRESULT CAugmentedMergeISF::DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres = S_OK;

    if (_pdt)
        hres = _pdt->DragOver(grfKeyState, pt, pdwEffect);
        
    return hres;
}

HRESULT CAugmentedMergeISF::DragLeave(void)
{
    HRESULT hres = S_OK;

    _fCommon = 0;
    if (_pdt)
    {
        hres = _pdt->DragLeave();
        ATOMICRELEASE(_pdt);
    }
    
    return hres;
}

HRESULT CAugmentedMergeISF::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres = S_OK;
    BOOL    bNoUI = !_fCommon;
    BOOL    bConfirmed = !_fCommon;

    if (!_pdt && pDataObj)
    {
        LPITEMIDLIST pidlParent = NULL,
                     pidlOther  = NULL;
        
        int csidl = _fCommon ? CSIDL_COMMON_STARTMENU : CSIDL_STARTMENU,
            csidlOther = _fCommon ? CSIDL_STARTMENU : CSIDL_COMMON_STARTMENU;

        if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl, &pidlParent)) &&
            SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidlOther, &pidlOther)))
        {
            FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            STGMEDIUM medium;
            
            medium.pUnkForRelease = NULL;
            medium.hGlobal = NULL;

            if (SUCCEEDED(pDataObj->GetData(&fmte, &medium)))
            {
                LPIDA pida = (LPIDA)GlobalLock(medium.hGlobal);
                
                if (pida)
                {
                    IShellFolder *psfParent = NULL,
                                 *psfOther  = NULL;

                    if (SUCCEEDED(IEBindToObject(pidlParent, &psfParent)) &&
                        SUCCEEDED(IEBindToObject(pidlOther,  &psfOther)))
                    {
                        LPCITEMIDLIST pidlItem, pidl;
                        LPITEMIDLIST  pidlRel;
                                      
                        pidlItem   = HIDA_GetPIDLItem(pida, 0);

                        // we came here because we don't have pdt which means that
                        // there is only one folder in our namespace and that's not
                        // the one we have to drop IDataObj on.

                        CNamespace* pCNamespace = Namespace(0);

                        if (pCNamespace)
                        {
                            pidl = pCNamespace->GetPidl();  // don't need to free pidl.

                            if (pidl)
                            {
                                pidlRel = ILClone(ILFindChild(pidlOther, pidl));
                        
                                if (pidlRel)
                                {
                                    STRRET strret;
                                    TCHAR  szDir[MAX_PATH];

                                    strret.uType = STRRET_CSTR;
                                    if (SUCCEEDED(psfParent->GetDisplayNameOf(pidlRel, SHGDN_FORPARSING, &strret)) &&
                                        SUCCEEDED(StrRetToBuf(&strret, pidlRel, szDir, ARRAYSIZE(szDir))))
                                    {
                                        if (_fCommon)
                                        {
                                            bConfirmed = AffectAllUsers(_hwnd);
                                            bNoUI = TRUE;
                                        }

                                        if (bConfirmed)
                                        {
                                            BOOL bCreated = FALSE;

                                            switch (SHCreateDirectory(_hwnd, szDir))
                                            {
                                            case ERROR_FILENAME_EXCED_RANGE:
                                            case ERROR_FILE_EXISTS:
                                            case ERROR_ALREADY_EXISTS:
                                            case 0: // It was created successfully.
                                                bCreated = TRUE;
                                            }

                                            if (bCreated)
                                            {
                                                IShellFolder *psf;
                                    
                                                if (SUCCEEDED(psfParent->BindToObject(pidlRel, NULL, IID_IShellFolder, (void **)&psf)))
                                                {
                                                    psf->CreateViewObject(_hwnd, IID_IDropTarget, (void **)&_pdt);
                                                    // we're going to call drop on it, call dragenter first
                                                    if (_pdt)
                                                        _pdt->DragEnter(pDataObj, _grfDragEnterKeyState, pt, &_dwDragEnterEffect);
                                                    psf->Release();
                                                }
                                            }
                                        }
                                    }
                          
                                    ILFree(pidlRel);
                                }
                            }
                        }
                    }
                    if (psfParent)
                        psfParent->Release();
                    if (psfOther)
                        psfOther->Release();

                    GlobalUnlock(medium.hGlobal);
                }
                ReleaseStgMedium(&medium);
            }
        }
        ILFree(pidlParent);
        ILFree(pidlOther);
    }

    if (_pdt)
    {
        hres = E_FAIL;
        
        if ((bNoUI || (bConfirmed = AffectAllUsers(_hwnd))) && bConfirmed)
            hres = _pdt->Drop(pDataObj, grfKeyState, pt, pdwEffect);
        else
            hres = _pdt->DragLeave();

        ATOMICRELEASE(_pdt);
    }
    _fCommon = 0;

    return hres;
}

//-------------------------------------------------------------------------------------------------//
LPITEMIDLIST CAugmentedMergeISF::GetNativePidl(LPCITEMIDLIST pidlWrap, LPARAM nSrcID /*int nID*/)
{
    LPITEMIDLIST pidlRet = NULL;

    if (SUCCEEDED(AugMergeISF_GetSrcPidl(pidlWrap, (UINT)nSrcID, &pidlRet)))
        return pidlRet ;

    // not wrapped by me.
    return NULL;
}

BOOL AffectAllUsers(HWND hwnd)
{
    TCHAR szMessage[255];
    TCHAR szTitle[20];
    BOOL  bRet = FALSE;

    if (MLLoadShellLangString(IDS_ALLUSER_WARNING, szMessage, ARRAYSIZE(szMessage)) > 0 &&
        MLLoadShellLangString(IDS_ALLUSER_WARNING_TITLE, szTitle, ARRAYSIZE(szTitle)) > 0)
    {
        bRet = IDYES == MessageBox(hwnd, szMessage, szTitle, MB_YESNO | MB_ICONINFORMATION);
    }
    return bRet;
}

BOOL CAugmentedMergeISF::_IsCommonPidl(LPCITEMIDLIST pidlItem)
{
    BOOL bRet = FALSE;
    LPITEMIDLIST pidlCommon;
    
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_STARTMENU, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }
    if (!bRet &&
        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_PROGRAMS, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }
    if (!bRet &&
        SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_COMMON_DESKTOPDIRECTORY, &pidlCommon)))
    {
        bRet = ILIsParent(pidlCommon, pidlItem, FALSE);
        ILFree(pidlCommon);
    }

    return bRet;
}

HRESULT CAugmentedMergeISF::_SearchForPidl(IShellFolder* psf, LPCITEMIDLIST pidl, BOOL fFolder, int* piIndex, CAugISFEnumItem** ppEnumItem)
{
    STRRET str;
    TCHAR szDisplayName[MAX_PATH];
    int iIndex = -1;

    *ppEnumItem = NULL;

    if (SUCCEEDED(psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, &str)) &&
        SUCCEEDED(StrRetToBuf(&str, pidl, szDisplayName, ARRAYSIZE(szDisplayName))))
    {
        AUGMISFSEARCHFORPIDL SearchFor;
        SearchFor.pszDisplayName = szDisplayName;
        SearchFor.fFolder = fFolder;

        iIndex = DPA_Search(_hdpaObjects, (LPVOID)&SearchFor, 0,
                AugMISFSearchForOnePidlByDisplayName, NULL, DPAS_SORTED);

        if (iIndex >= 0)
        {
            *ppEnumItem = DPA_GETPTR( _hdpaObjects, iIndex, CAugISFEnumItem);
        }
    }

    if (piIndex)
        *piIndex = iIndex;

    if (*ppEnumItem)
        return S_OK;

    return S_FALSE;
}


// given a wrapped pidl
// f-n returns common and user namespaces (if they are in wrapped pidl) -- note that they are not addrefed
// unwrapped pidl, and if the unwrapped pidl is folder or not
HRESULT CAugmentedMergeISF::_GetNamespaces(LPCITEMIDLIST pidlWrap, 
                                           CNamespace** ppnsCommon, 
                                           UINT* pnCommonID,
                                           CNamespace** ppnsUser, 
                                           UINT* pnUserID,
                                           LPITEMIDLIST* ppidl, 
                                           BOOL *pbIsFolder)
{    
    HRESULT      hres;
    UINT         nSrcID;
    CNamespace * pns;
    int          cWrapped;
    HANDLE       hEnum;
    
    ASSERT(ppnsCommon && ppnsUser && ppidl);

    *ppnsCommon = NULL;
    *ppnsUser   = NULL;
    *ppidl      = NULL;

    ASSERT(SUCCEEDED(AugMergeISF_IsWrap(pidlWrap)));
        
    cWrapped = AugMergeISF_GetSourceCount(pidlWrap);

    if (NULL == _hdpaNamespaces || 0 >= cWrapped || 
        NULL == (hEnum = AugMergeISF_EnumFirstSrcPidl(pidlWrap, &nSrcID, ppidl)))
        return E_FAIL;
        
    hres = QueryNameSpace(nSrcID, (void **)&pns);
    if (EVAL(SUCCEEDED(hres)))
    {
        IShellFolder * psf;
        ULONG rgf = SFGAO_FOLDER;

        psf = pns->ShellFolder(); // no addref
        ASSERT(psf);
        if (SUCCEEDED(psf->GetAttributesOf(1, (LPCITEMIDLIST*)ppidl, &rgf)))
        {
            if (pbIsFolder)
                *pbIsFolder = rgf & SFGAO_FOLDER;
                
            LPITEMIDLIST   pidlItem;
            UINT           nCommonID;
            CNamespace*    pnsCommonTemp;

            // get common namespace (attribs = 0)
            hres = GetDefNamespace(0, (void **)&pnsCommonTemp, &nCommonID, NULL);
            ASSERT(NamespaceCount() == 2 && SUCCEEDED(hres) || NamespaceCount() == 1);
            if (FAILED(hres))
                nCommonID = 1;

            if (nCommonID == nSrcID)
            {
                *ppnsCommon = pns;
                if (pnCommonID)
                    *pnCommonID = nCommonID;
            }
            else
            {
                *ppnsUser = pns;
                if (pnUserID)
                    *pnUserID = nSrcID;
            }
            
            if (AugMergeISF_EnumNextSrcPidl(hEnum, &nSrcID, &pidlItem))
            {
                ASSERT(ILIsEqual(*ppidl, pidlItem));
                ILFree(pidlItem);
                if (SUCCEEDED(QueryNameSpace(nSrcID, (void **)&pns)))
                {
                    ASSERT(pns);
                    if (nCommonID == nSrcID)
                    {
                        *ppnsCommon = pns;
                        if (pnCommonID)
                            *pnCommonID = nCommonID;
                    }
                    else
                    {
                        *ppnsUser = pns;
                        if (pnUserID)
                            *pnUserID = nSrcID;
                    }
                }
            }

            hres = S_OK;
        }
    }
    AugMergeISF_EndEnumSrcPidls(hEnum);

    return hres;
}

HRESULT CAugmentedMergeISF::_GetContextMenu(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, 
                                            UINT * prgfInOut, void ** ppvOut)
{
    HRESULT      hres;
    LPITEMIDLIST pidl;
    BOOL         bIsFolder;
    CNamespace * pnsCommon;
    CNamespace * pnsUser;

    ASSERT(cidl == 1);

    // psfCommon and psfUser are not addrefed
    hres = _GetNamespaces(apidl[0], &pnsCommon, NULL, &pnsUser, NULL, &pidl, &bIsFolder);
    if (SUCCEEDED(hres))
    {
        ASSERT(pnsCommon || pnsUser);
        if (bIsFolder)
        {
            // folder? need our context menu
            IShellFolder * psfCommon = NULL;
            IShellFolder * psfUser = NULL;
            LPCITEMIDLIST  pidlCommon = NULL;
            LPCITEMIDLIST  pidlUser = NULL;

            if (pnsCommon)
            {
                psfCommon  = pnsCommon->ShellFolder();
                pidlCommon = pnsCommon->GetPidl();
            }
            if (pnsUser)
            {
                psfUser    = pnsUser->ShellFolder();
                pidlUser   = pnsUser->GetPidl();
            }
            CAugMergeISFContextMenu * pcm = CreateMergeISFContextMenu(psfCommon, pidlCommon, 
                                                                      psfUser, pidlUser,
                                                                      pidl, hwnd, prgfInOut);

            if (pcm)
            {
                hres = pcm->QueryInterface(IID_IContextMenu, ppvOut);
                pcm->Release();
            }
            else
                hres = E_OUTOFMEMORY;
        }
        else
        {   // it's not a folder
            // delegate to the isf
            IShellFolder * psf = pnsUser ? pnsUser->ShellFolder() : pnsCommon->ShellFolder();

            hres = psf->GetUIObjectOf(hwnd, 1, (LPCITEMIDLIST*)&pidl, IID_IContextMenu, prgfInOut, ppvOut);
        }
        ILFree(pidl);
    }

    return hres;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CAugmentedMergeISF::GetDefNamespace( 
    LPCITEMIDLIST pidlWrap, 
    ULONG dwAttrib, 
    OUT IShellFolder** ppsf,
    OUT LPITEMIDLIST* ppidlItem )
{
    HRESULT          hr ;
    LPITEMIDLIST     pidl ;
    CNamespace* pSrc ;
    ULONG            dwDefAttrib = dwAttrib & ASFF_DEFNAMESPACE_ALL ;
    int              cWrapped ;
    UINT             nSrcID ;
    HANDLE           hEnum ;

    ASSERT( ppsf ) ;
    
    *ppsf = NULL ;
    if (ppidlItem) 
        *ppidlItem = NULL ;

    if (FAILED((hr = AugMergeISF_IsWrap( pidlWrap ))))
        return hr ;
    cWrapped = AugMergeISF_GetSourceCount( pidlWrap ) ;

    //  No namespaces?
    if (NULL == _hdpaNamespaces || 0 >= cWrapped || 
        NULL == (hEnum = AugMergeISF_EnumFirstSrcPidl( pidlWrap, &nSrcID, &pidl)))
        return E_FAIL ;

    //  Only one namespace in wrap? Give up the shell folder and item ID.
    if (1 == cWrapped || 0==dwDefAttrib)
    {
        AugMergeISF_EndEnumSrcPidls( hEnum ) ; // no need to go further

        //  Retrieve the namespace object identified by nSrcID.
        if( SUCCEEDED( (hr = QueryNameSpace( nSrcID, (PVOID*)&pSrc )) ) ) 
        {
            *ppsf = pSrc->ShellFolder() ;
            if( ppidlItem )
                *ppidlItem = pidl ;
            return S_OK ;
        }

        ILFree( pidl ) ;
        return hr ;
    }

    //  More than one namespace in wrap?
    if( cWrapped > 1 )
    {
        LPITEMIDLIST   pidl0   = NULL ;
        CNamespace*    pSrc0   = NULL ;  // get this below.

        for (BOOL bEnum = TRUE ; bEnum ; 
             bEnum = AugMergeISF_EnumNextSrcPidl(hEnum, &nSrcID,  &pidl))
        {
            if (SUCCEEDED((hr = QueryNameSpace(nSrcID, (PVOID*)&pSrc)))) 
            {
                if (dwDefAttrib & pSrc->Attrib())
                {
                    //  Matched attributes; we're done.
                    AugMergeISF_EndEnumSrcPidls(hEnum);
                    *ppsf = pSrc->ShellFolder() ;
                    if (ppidlItem)
                        *ppidlItem = pidl;
                    if(pidl0) 
                        ILFree(pidl0);
                    return S_OK ;
                }

                //  Stash first namespace object and item pidl.  
                //  We'll default to these if                
                if( NULL == pSrc0 )
                {
                    pSrc0 = pSrc ;
                    pidl0 = ILClone( pidl ) ;
                }
            }
            ILFree( pidl ) ;
        }
        AugMergeISF_EndEnumSrcPidls( hEnum ) ;
        
        //  Default to first namespace
        if( pSrc0 && pidl0 )
        {
            *ppsf       = pSrc0->ShellFolder() ;
            if( ppidlItem )
                *ppidlItem  = pidl0 ;
            return S_OK ;
        }
    }
    
    return E_UNEXPECTED ;
}

//-------------------------------------------------------------------------//
//  Retrieves the default namespaces for the indicated attibutes.
//  The dwAttrib arg must be initialized prior to function entry,
STDMETHODIMP CAugmentedMergeISF::GetDefNamespace( 
    ULONG dwAttrib,
    OUT   PVOID* ppSrc, UINT *pnSrcID, PVOID* ppSrc0 )
{
    CNamespace* pSrc ;
    ULONG       dwDefAttrib = dwAttrib & ASFF_DEFNAMESPACE_ALL ;

    // this is an internal helper so we better make sure we pass the correct params!
    //if (NULL == ppSrc)
    //    return E_INVALIDARG ;
    *ppSrc = NULL ;
    if( ppSrc0 ) 
        *ppSrc0 = NULL ;

    for( int i = 0, cSrcs = NamespaceCount(); i < cSrcs ; i++ )
    {
        if( NULL != (pSrc = Namespace( i )) )
        {
            if( 0 == i && ppSrc0 )
                *ppSrc0 = pSrc ;

            if( dwDefAttrib & pSrc->Attrib() || 
                dwDefAttrib == 0 && !(pSrc->Attrib() & ASFF_DEFNAMESPACE_ALL))
            {
                *ppSrc = pSrc;
                if (NULL != pnSrcID)
                    *pnSrcID = i;
                return S_OK ;
            }
        }
    }

    return E_FAIL ;
}

// BUGBUG(lamadio): Move this to a better location, This is a nice generic function
#ifdef DEBUG
BOOL DPA_VerifySorted(HDPA hdpa, PFNDPACOMPARE pfn, LPARAM lParam)
{
    if (!EVAL(hdpa))
        return FALSE;

    for (int i = 0; i < DPA_GetPtrCount(hdpa) - 1; i++)
    {
        if (pfn(DPA_FastGetPtr(hdpa, i), DPA_FastGetPtr(hdpa, i + 1), lParam) > 0)
            return FALSE;
    }

    return TRUE;
}
#else
#define DPA_VerifySorted(hdpa, pfn, lParam)
#endif

int CAugmentedMergeISF::AcquireObjects()
{
    HDPA hdpa2 = NULL;

    DEBUG_CODE(_fInternalGDNO = TRUE);
    
    for (int i = 0; i < DPA_GETPTRCOUNT(_hdpaNamespaces); i++)
    {
        CNamespace * pns = DPA_GETPTR(_hdpaNamespaces, i, CNamespace);
        IShellFolder * psf;
        IEnumIDList  * peid;
        HDPA         * phdpa;

        ASSERT(pns);
        psf = pns->ShellFolder(); // no addref here!

        if (i == 0)
        {
            phdpa = &_hdpaObjects;
            _hdpaObjects = DPA_Create(4);   // We should always create the DPA
        }
        else
        {
            ASSERT(i == 1); // no support for more than 2 isf's
            phdpa = &hdpa2;
        }
        
        HRESULT hres = psf->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS | SHCONTF_INCLUDEHIDDEN, &peid);
        if (SUCCEEDED(hres))
        {
            if (!*phdpa)
                *phdpa = DPA_Create(4);

            if (*phdpa)
            {
                LPITEMIDLIST pidl;
                ULONG        cEnum;
                
                while (SUCCEEDED(peid->Next(1, &pidl, &cEnum)) && 1 == cEnum)
                {
                    CAugISFEnumItem* paugmEnum = new CAugISFEnumItem;

                    if (paugmEnum)
                    {
                        
                        if (paugmEnum->Init(SAFECAST(this, IAugmentedShellFolder2*), i, pidl))
                        {
                            if (DPA_AppendPtr(*phdpa, paugmEnum) == -1)
                                DestroyObjectsProc(paugmEnum, NULL);
                        }
                        else
                            delete paugmEnum;
                    }
                    ILFree(pidl);
                }
            }
            peid->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "CAugMISF::AcquireObjects: Failed to get enumerator 0x%x", hres);

        }
    }

    // now that we have both hdpa's (or one) let's merge them.
    if (DPA_GETPTRCOUNT(_hdpaNamespaces) == 2 && hdpa2)
    {
        DPA_Merge(_hdpaObjects, hdpa2, DPAM_UNION, AugmEnumCompare, AugmEnumMerge, (LPARAM)0);
        DPA_DESTROY(hdpa2, DestroyObjectsProc);
    }
    else
    {
        DPA_Sort(_hdpaObjects, AugmEnumCompare, 0);
    }

    ASSERT(DPA_VerifySorted(_hdpaObjects, AugmEnumCompare, 0));

    DEBUG_CODE(_fInternalGDNO = FALSE);


#ifdef DEBUG
    TraceMsg(TF_AUGM, "CAugMISF::AcquireObjects");
    DumpObjects();
#endif

    _count = DPA_GETPTRCOUNT(_hdpaObjects);
    
    return _count;
}

//-------------------------------------------------------------------------//
void CAugmentedMergeISF::FreeObjects()
{
    DPA_DESTROY( _hdpaObjects, DestroyObjectsProc ) ;
    _hdpaObjects = NULL;
    _count = 0 ;
}

//-------------------------------------------------------------------------//
int CAugmentedMergeISF::DestroyObjectsProc( LPVOID pv, LPVOID pvData )
{
    CAugISFEnumItem* paugmEnum = (CAugISFEnumItem*)pv;

    if (EVAL(NULL != paugmEnum))
    {
        delete paugmEnum;
    }
    return TRUE ;
}

//-------------------------------------------------------------------------//
void CAugmentedMergeISF::FreeNamespaces()
{
    DPA_DESTROY( _hdpaNamespaces, DestroyNamespacesProc ) ;
}

//-------------------------------------------------------------------------//
int CAugmentedMergeISF::DestroyNamespacesProc( LPVOID pv, LPVOID pvData )
{
    CNamespace* p ;
    if( NULL != (p = (CNamespace*)pv) )
        delete p ;
    return TRUE ;
}


STDMETHODIMP CAugmentedMergeISF::GetPidl(int* piPos, DWORD grfEnumFlags, LPITEMIDLIST* ppidl)
{
    *ppidl = NULL;

    if (_hdpaObjects == NULL)
        AcquireObjects();

    if (_hdpaObjects == NULL)
        return E_OUTOFMEMORY;

    BOOL   fWantFolders    = 0 != (grfEnumFlags & SHCONTF_FOLDERS),
           fWantNonFolders = 0 != (grfEnumFlags & SHCONTF_NONFOLDERS),
           fWantHidden     = 0 != (grfEnumFlags & SHCONTF_INCLUDEHIDDEN) ;

    while (*piPos < _count)
    {
        CAugISFEnumItem* paugmEnum = DPA_GETPTR( _hdpaObjects, *piPos, CAugISFEnumItem);
        if ( NULL != paugmEnum )
        {
            BOOL fFolder         = 0 != (paugmEnum->_rgfAttrib & SFGAO_FOLDER),
                 fHidden         = 0 != (paugmEnum->_rgfAttrib & SFGAO_HIDDEN);
             
            if ((!fHidden || fWantHidden) && 
                ((fFolder && fWantFolders) || (!fFolder && fWantNonFolders)))
            {
                //  Copy out the pidl ;
                *ppidl = ILClone(paugmEnum->_pidlWrap);
                break;
            }
            else
            {
                (*piPos)++;
            }
        }
    }

    if (*ppidl)
        return S_OK;

    return S_FALSE;
}


//-------------------------------------------------------------------------//
CEnum::CEnum(IAugmentedMergedShellFolderInternal* psmsfi, DWORD grfEnumFlags, int iPos) : 
        _cRef(1), 
        _iPos(iPos),
        _psmsfi(psmsfi),
        _grfEnumFlags(grfEnumFlags)

{ 
    _psmsfi->AddRef();
}

CEnum::~CEnum()
{
    ATOMICRELEASE(_psmsfi);
}

//-------------------------------------------------------------------------//
//  class CEnum - IUnknown methods 
//-------------------------------------------------------------------------//

//-------------------------------------------------------------------------//
STDMETHODIMP CEnum::QueryInterface( REFIID riid, LPVOID * ppvObj )
{
    static const QITAB qit[] = { 
        QITABENT(CEnum, IEnumIDList), 
        { 0 } 
    };
    return QISearch(this, qit, riid, ppvObj);
}
//-------------------------------------------------------------------------//
STDMETHODIMP_(ULONG) CEnum::AddRef ()
{
    return InterlockedIncrement(&_cRef);
}
//-------------------------------------------------------------------------//
STDMETHODIMP_(ULONG) CEnum::Release ()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef ) 
    {
        delete this;
    }
    return cRef;
}

//-------------------------------------------------------------------------//
//  class CEnum - IEnumIDList methods 
//-------------------------------------------------------------------------//
STDMETHODIMP CEnum::Next( 
    ULONG celt,
    LPITEMIDLIST *rgelt,
    ULONG *pceltFetched )
{
    int iStart = _iPos;
    int cFetched = 0;
    HRESULT hres = S_OK;

    if( !(celt > 0 && rgelt) || (NULL == pceltFetched && celt > 1 ) )
        return E_INVALIDARG ;
    
    *rgelt = 0;

    while(hres == S_OK && (_iPos - iStart) < (int)celt)
    {
        LPITEMIDLIST pidl;
        hres = _psmsfi->GetPidl(&_iPos, _grfEnumFlags, &pidl);
        if (hres == S_OK)
        {
            rgelt[cFetched] = pidl;
            cFetched++ ;
        }
        _iPos++;
    }
    
    if( pceltFetched )
        *pceltFetched = cFetched ;
    
    return celt == (ULONG)cFetched ? S_OK : S_FALSE ;
}

//-------------------------------------------------------------------------//
STDMETHODIMP CEnum::Skip(ULONG celt)
{
    _iPos += celt;
    return S_OK ;
}
//-------------------------------------------------------------------------//
STDMETHODIMP CEnum::Reset()
{
    _iPos = 0;
    return S_OK ;
}
//-------------------------------------------------------------------------//
// REVIEW: Can probably be E_NOTIMPL
STDMETHODIMP CEnum::Clone( IEnumIDList **ppenum )
{
    if( NULL == (*ppenum = new CEnum( _psmsfi, _grfEnumFlags, _iPos )) )
        return E_OUTOFMEMORY;

    return S_OK;
}



BOOL CAugISFEnumItem::Init(IShellFolder* psf, int iShellFolder, LPCITEMIDLIST pidl)
{
    // This is ok, the memory just gets written to twice. 
    if (SUCCEEDED(AugMergeISF_CreateWrap(pidl, iShellFolder, &_pidlWrap)))
    {
        // Takes ownership of passed in pidl.
        return InitWithWrappedToOwn(psf, iShellFolder, _pidlWrap);
    }

    return FALSE;
}

BOOL CAugISFEnumItem::InitWithWrappedToOwn(IShellFolder* psf, int iShellFolder, LPITEMIDLIST pidl)
{
    BOOL fRet = FALSE;
    STRRET str;
    TCHAR  szDisplayName[MAX_PATH];

    _pidlWrap = pidl;
    
    _rgfAttrib = SFGAO_FOLDER | SFGAO_HIDDEN;

    psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidl, &_rgfAttrib);

    if (SUCCEEDED(psf->GetDisplayNameOf(pidl, SHGDN_FORPARSING | SHGDN_INFOLDER, &str)) &&
        SUCCEEDED(StrRetToBuf(&str, pidl, szDisplayName, ARRAYSIZE(szDisplayName))))
    {
        SetDisplayName(szDisplayName);
        fRet = TRUE;
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\augisf.cpp ===
#include "priv.h"
#include "sccls.h"
#include "iface.h"
#include "augisf.h"
#include "menuisf.h"

//=================================================================
// Implementation of an IShellFolder that wraps a collection of
// other IShellFolders.  We call this an augmented IShellFolder
// object.
//
//=================================================================

// The CAugmentedISF wraps all the pidls so it can identify which pidl
// belongs to which IShellFolder object.

typedef struct tagIDWRAP
{
    // Real pidl goes on the end
    
    UINT   nID;         // Refers to a specific IShellFolder object
    UINT   cbOriginal;  // the original size of the pidl.  we need this because we dword align the pidl before wrapping it
} IDWRAP, * PIDWRAP;

#define IDWrap_GetWrap(pidl)            ((PIDWRAP)(((LPBYTE)pidl) + (pidl)->mkid.cb - SIZEOF(IDWRAP)))
#define IDWrap_GetID(pidl)              (IDWrap_GetWrap(pidl)->nID)
#define IDWrap_GetOriginalSize(pidl)    (IDWrap_GetWrap(pidl)->cbOriginal)

/*----------------------------------------------------------
    The CAugmentedISF object holds an array of CISFElems, each of which
    refers to an IShellFolder which will be enumerated.
*/
class CISFElem
{
public:
    CISFElem *      Clone(void);
    HRESULT         AcquireEnumerator(DWORD dwFlags);
    IShellFolder *  GetPSF()                { return _psf; };
    IEnumIDList *   GetEnumerator()         { return _pei; };
    void            GetNameSpaceID(GUID * rguid);
    HRESULT         SetPidl(LPCITEMIDLIST pidl);
    LPCITEMIDLIST   GetPidl()               { return _pidl; };
    DWORD           GetFlags()              { return _dwFlags; };
    void            SetRegister(UINT uReg)  { _uRegister = uReg; };
    UINT            GetRegister()           { return _uRegister; };

    CISFElem(const GUID * pguid, IShellFolder * psf, DWORD dwFlags);
    ~CISFElem();

protected:

    GUID           _guid;       // Unique ID
    IShellFolder * _psf;
    IEnumIDList *  _pei;        // Used by CAugSIFEnum only
    LPITEMIDLIST   _pidl;
    DWORD          _dwFlags;
    UINT           _uRegister;

    friend BOOL IsValidPCISFElem(CISFElem * pel);
};

//
// CAugmentedISF enumerator
//
class CAugISFEnum : public IEnumIDList
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef) () ;
    STDMETHOD_(ULONG,Release) ();

    // *** IEnumIDList methods ***
    STDMETHOD(Next)  (ULONG celt,
                      LPITEMIDLIST *rgelt,
                      ULONG *pceltFetched);
    STDMETHOD(Skip)  (ULONG celt);
    STDMETHOD(Reset) ();
    STDMETHOD(Clone) (IEnumIDList **ppenum);

    // Other methods
    HRESULT     Init(HDPA hdpaISF, DWORD dwEnumFlags);
        
    CAugISFEnum();
    ~CAugISFEnum();

protected:
    IEnumIDList *   _GetObjectEnumerator(int nID);

    UINT    _cRef;
    int     _iCurISF;       // current item in _hdpaISF
    HDPA    _hdpaISF;
};

/*----------------------------------------------------------
    Pidl wrapping routine
*/
LPITEMIDLIST AugISF_WrapPidl( LPCITEMIDLIST pidl, int nID )
{
    LPITEMIDLIST pidlRet = NULL;

    // get the size of the pidl
    // round up to dword align.  
    UINT cbPidlSize = (pidl->mkid.cb + 3) & ~3; 
    
    ASSERT(cbPidlSize >= pidl->mkid.cb);
    UINT cbSize = SIZEOF(IDWRAP) + cbPidlSize + SIZEOF(DWORD); // pidl plus terminator
    LPBYTE p = (LPBYTE)SHAlloc(cbSize);
    if (p)
    {
        ZeroMemory(p, cbSize); 
        memcpy(p, pidl, pidl->mkid.cb);

        IDWRAP* pidw = (IDWRAP*) (p + cbPidlSize);
        pidw->nID = nID;
        pidw->cbOriginal = pidl->mkid.cb;
                           
        // now make the cb be the whole pidl (not including the final null)
        pidlRet = (LPITEMIDLIST)p;
        pidlRet->mkid.cb = (USHORT) (cbPidlSize + SIZEOF(IDWRAP));
    }
    return pidlRet;
}    

// GetIDListWrapCount and GetNameSpaceCount are not used anywhere
#if 0
/*----------------------------------------------------------
Purpose: IAugmentedShellFolder2::GetIDListWrapCount
*/
STDMETHODIMP CAugmentedISF::GetNameSpaceCount( OUT LONG* pcNamespaces )
{
    if( NULL == pcNamespaces )
        return E_INVALIDARG ;

    *pcNamespaces = (NULL != _hdpa) ? DPA_GetPtrCount( _hdpa ) : 0 ;
    return S_OK ;
}

/*----------------------------------------------------------
Purpose: IAugmentedShellFolder2::GetIDListWrapCount
*/
STDMETHODIMP CAugmentedISF::GetIDListWrapCount( 
    LPCITEMIDLIST pidlWrap, 
    OUT LONG * pcPidls )
{
    if( NULL == pidlWrap || NULL == pcPidls )   
        return E_INVALIDARG ;

    PIDWRAP pWrap = IDWrap_GetWrap(pidlWrap) ;
    *pcPidls = 0 ;

    if( NULL != _hdpa && 
        DPA_GetPtrCount( _hdpa ) > (int)pWrap->nID && 
        pWrap->cbOriginal < pidlWrap->mkid.cb + sizeof(IDWRAP) )
        *pcPidls = 1 ;

    return S_OK ;
}
#endif
/*----------------------------------------------------------
Purpose: IAugmentedShellFolder2::UnWrapIDList
*/
STDMETHODIMP CAugmentedISF::UnWrapIDList( 
    LPCITEMIDLIST pidl, 
    LONG cPidls, 
    IShellFolder ** ppsf, 
    LPITEMIDLIST * ppidlFolder, 
    LPITEMIDLIST * ppidl, 
    LONG * pcFetched )
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(IS_VALID_PIDL(pidl));

    if( pcFetched )
        *pcFetched = 0 ;
    
    if (pidl)
    {
        UINT nId = IDWrap_GetID(pidl);
        CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, nId);

        if (pel)
        {
            LPITEMIDLIST pidlNew = ILClone(GetNativePidl(pidl, nId));
            LPITEMIDLIST pidlFolderNew = ILClone(pel->GetPidl());

            if (pidlNew && pidlFolderNew)
            {
                if ( ppsf )
                {
                    *ppsf = pel->GetPSF();
                    (*ppsf)->AddRef();
                }

                *ppidl = pidlNew;
                *ppidlFolder = pidlFolderNew;
                
                if( pcFetched ) 
                    *pcFetched = 1 ;
                
                hres = (cPidls == 1) ? S_OK : S_FALSE ;
            }
            else
            {
                ILFree(pidlNew);
                ILFree(pidlFolderNew);
                hres = E_OUTOFMEMORY;
            }
        }
        else
            hres = E_FAIL;
    }

    return hres;
}

/*----------------------------------------------------------
    Purpose: CAugmentedISF::TranslatePidl
*/
LPITEMIDLIST CAugmentedISF::TranslatePidl( LPCITEMIDLIST pidlNS, LPCITEMIDLIST pidl, LPARAM nID )
{
    LPITEMIDLIST pidlRet = NULL;

    // Is this not empty and an immediate child?
    if (ILIsParent(pidlNS, pidl, TRUE))
    {
        LPCITEMIDLIST pidlChild;
        LPITEMIDLIST pidlNew;
        TCHAR szFullName[MAX_PATH];
        LPITEMIDLIST pidlFull = NULL;

        // HACKHACK (lamadio): You cannot use SHGetRealIDL for augisf encapsulated
        // IShellFolders. This routine QIs for INeedRealShellFolder, which IAugISF 
        // doesnot forward. The fstree code does not handle aggregation, so this 
        // cannot be forwarded anyway. This code can be cleaned up when we rewrite 
        // the fstree stuff... Sep.4.1997

        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szFullName, SIZECHARS(szFullName), NULL))
        && (pidlFull = ILCreateFromPath(szFullName)) != NULL)
        {
            pidlChild = ILFindLastID(pidlFull);
            pidlNew = ILClone(pidlFull);
        }
        else
        {
            pidlChild = ILFindLastID(pidl);
            pidlNew = ILClone(pidl);
        }

        // Yes; create a new full pidl where the last element is wrapped

        if (pidlNew)
        {
            ILRemoveLastID(pidlNew);

            LPITEMIDLIST pidlWrap = AugISF_WrapPidl( pidlChild, (int)nID );
            if (pidlWrap)
            {
                pidlRet = ILCombine(pidlNew, pidlWrap);
                ILFree(pidlWrap);
            }
            ILFree(pidlNew);
        }

        ILFree(pidlFull);   //Checks for a NULL pidl
    }
    else
        pidlRet = (LPITEMIDLIST)pidl;

    return pidlRet;
}    

/*----------------------------------------------------------
    Purpose: CAugmentedISF::GetNativePidl
    Clones and returns a copy of the native ('source') pidl 
    contained in the specified wrap.
*/
LPITEMIDLIST CAugmentedISF::GetNativePidl(LPCITEMIDLIST pidl, LPARAM lParam /*int nID*/ )
{
    ASSERT(IS_VALID_PIDL(pidl));
    UNREFERENCED_PARAMETER( lParam ) ; // only one source ID in the wrap!

    LPITEMIDLIST pidlNew = ILClone(pidl);

    if (pidlNew)
    {
        // Take off our trailing wrap signature
        pidlNew->mkid.cb = IDWrap_GetOriginalSize(pidl);

        ASSERT(sizeof(IDWRAP) >= sizeof(USHORT));

        USHORT * pu = (USHORT *)_ILNext(pidlNew);
        *pu = 0;
    }
    return pidlNew;
}    




CISFElem::CISFElem(const GUID * pguid, IShellFolder * psf, DWORD dwFlags) : _dwFlags(dwFlags)
{
    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(NULL == pguid || IS_VALID_READ_PTR(pguid, GUID));

    if (pguid)
        CopyMemory(&_guid, pguid, sizeof(_guid));

    _psf = psf;
    _psf->AddRef();
}    

CISFElem::~CISFElem()
{
    ASSERT(IS_VALID_CODE_PTR(_psf, IShellFolder));
    
    _psf->Release();

    if (_pei)
        _pei->Release();

    Pidl_Set(&_pidl, NULL);
}   

CISFElem * CISFElem::Clone(void)
{
    CISFElem * pelem = new CISFElem(&_guid, _psf, _dwFlags);

    if (pelem)
    {
        // If this fails, we're punting and going ahead anyway
        pelem->SetPidl(_pidl);      
    }

    return pelem;
}     


void CISFElem::GetNameSpaceID(GUID * pguid)
{
    ASSERT(IS_VALID_WRITE_PTR(pguid, GUID));
    CopyMemory(pguid, &_guid, sizeof(_guid));
}    


HRESULT CISFElem::SetPidl(LPCITEMIDLIST pidl)
{
    HRESULT hres = S_OK;

    Pidl_Set(&_pidl, pidl);

    if (pidl && NULL == _pidl)
        hres = E_OUTOFMEMORY;

    return hres;
}

/*----------------------------------------------------------
Purpose: Gets an enumerator for the IShellFolder and caches it.

*/
HRESULT CISFElem::AcquireEnumerator(DWORD dwFlags)
{
    return IShellFolder_EnumObjects(_psf, NULL, dwFlags, &_pei);
}    


//
// CAugmentedISF object
//


#undef SUPERCLASS


#ifdef DEBUG

BOOL IsValidPCISFElem(CISFElem * pel)
{
    return (IS_VALID_WRITE_PTR(pel, CISFElem) &&
            IS_VALID_CODE_PTR(pel->_psf, IShellFolder) &&
            (NULL == pel->_pidl || IS_VALID_PIDL(pel->_pidl)));
}   
 
#endif

// Constructor
CAugmentedISF::CAugmentedISF() : 
    _cRef(1)
{
    DllAddRef();
}


/*----------------------------------------------------------
Purpose: Callback to destroy each element

*/
int CISFElem_DestroyCB(LPVOID pv, LPVOID pvData)
{
    CISFElem * pel = (CISFElem *)pv;

    ASSERT(NULL == pel || IS_VALID_STRUCT_PTR(pel, CISFElem));

    if (pel)
        delete pel;

    return TRUE;
}   


/*----------------------------------------------------------
Purpose: Callback to set the owner of each element

*/
int CISFElem_SetOwnerCB(LPVOID pv, LPVOID pvData)
{
    CISFElem * pel = (CISFElem *)pv;

    ASSERT(IS_VALID_STRUCT_PTR(pel, CISFElem));

    IShellFolder * psf = pel->GetPSF();
    if (psf)
    {
        IUnknown_SetOwner(psf, (IUnknown *)pvData);
        // don't need to release psf
    }

    return TRUE;
}   


typedef struct {
    HRESULT hres;
    HWND hwnd;
    const IID * piid;
    void ** ppvObj;
} CVODATA;

    
/*----------------------------------------------------------
Purpose: Callback to call CreateViewObject

*/
int CISFElem_CreateViewObjectCB(LPVOID pv, LPVOID pvData)
{
    CISFElem * pel = (CISFElem *)pv;
    CVODATA * pdata = (CVODATA *)pvData;

    ASSERT(IS_VALID_STRUCT_PTR(pel, CISFElem));
    ASSERT(IS_VALID_WRITE_PTR(pdata, CVODATA));

    IShellFolder * psf = pel->GetPSF();
    if (psf)
    {
        pdata->hres = psf->CreateViewObject(pdata->hwnd, *(pdata->piid), pdata->ppvObj);
        if (SUCCEEDED(pdata->hres))
            return FALSE;       // stop on first success
            
        // don't need to release psf
    }

    return TRUE;
}   



// Destructor
CAugmentedISF::~CAugmentedISF()
{
    SetOwner(NULL);

    DPA_DestroyCallback(_hdpa, CISFElem_DestroyCB, NULL);
    _hdpa = NULL;

    DllRelease();
}


STDMETHODIMP_(ULONG) CAugmentedISF::AddRef()
{
    _cRef++;
    return _cRef;
}


STDMETHODIMP_(ULONG) CAugmentedISF::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0) 
        return _cRef;

    delete this;
    return 0;
}


STDMETHODIMP CAugmentedISF::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAugmentedISF, IShellFolder),
        QITABENT(CAugmentedISF, IAugmentedShellFolder),
        QITABENT(CAugmentedISF, IAugmentedShellFolder2),
        QITABENT(CAugmentedISF, IShellService),
        QITABENT(CAugmentedISF, ITranslateShellChangeNotify),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}


/*----------------------------------------------------------
Purpose: IShellService::SetOwner method

*/
STDMETHODIMP CAugmentedISF::SetOwner(IUnknown* punk)
{
    HRESULT hres = S_OK;

    ASSERT(NULL == punk || IS_VALID_CODE_PTR(punk, IUnknown));

    if (_hdpa && _punkOwner)
        DPA_EnumCallback(_hdpa, CISFElem_SetOwnerCB, NULL);
        
    ATOMICRELEASE(_punkOwner);
    
    if (punk) 
    {
        hres = punk->QueryInterface(IID_IUnknown, (LPVOID *)&_punkOwner);
        
        if (_hdpa)
            DPA_EnumCallback(_hdpa, CISFElem_SetOwnerCB, (void *)_punkOwner);
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::EnumObjects method

*/
STDMETHODIMP CAugmentedISF::EnumObjects(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppenumIDList)
{
    HRESULT hres = E_FAIL;

    if (_hdpa)
    {
        *ppenumIDList = new CAugISFEnum();

        if (*ppenumIDList)
        {
            hres = ((CAugISFEnum *)(*ppenumIDList))->Init(_hdpa, grfFlags);

            if (FAILED(hres))
            {
                delete *ppenumIDList;
                *ppenumIDList = NULL;
            }
        }
        else
            hres = E_OUTOFMEMORY;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::BindToObject method

*/
STDMETHODIMP CAugmentedISF::BindToObject(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                REFIID riid, LPVOID * ppvOut)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_WRITE_PTR(ppvOut, LPVOID));

    *ppvOut = NULL;

    UINT id = IDWrap_GetID(pidl);
    IShellFolder * psf = _GetObjectPSF(id);

    if (psf)
    {
        LPITEMIDLIST pidlReal = GetNativePidl(pidl, id);

        if (pidlReal)
        {
            hres = psf->BindToObject(pidlReal, pbcReserved, riid, ppvOut);
            ILFree(pidlReal);
        }
        else
            hres = E_OUTOFMEMORY;

        psf->Release();
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::BindToStorage method

*/
STDMETHODIMP CAugmentedISF::BindToStorage(LPCITEMIDLIST pidl, LPBC pbcReserved,
                                 REFIID riid, LPVOID * ppvObj)
{
    TraceMsg(TF_WARNING, "Called unimplemented CAugmentedISF::BindToStorage");
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IShellFolder::CompareIDs method

*/
STDMETHODIMP CAugmentedISF::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = 0;
    int nID1 = IDWrap_GetID(pidl1);
    int nID2 = IDWrap_GetID(pidl2);

    if (nID1 == nID2)
    {
        IShellFolder * psf = _GetObjectPSF(nID1);
        if (psf)
        {
            LPITEMIDLIST pidlReal1 = GetNativePidl(pidl1, nID1);

            if (pidlReal1)
            {
                LPITEMIDLIST pidlReal2 = GetNativePidl(pidl2, nID2);
                if (pidlReal2)
                {
                    hres = psf->CompareIDs(lParam, pidlReal1, pidlReal2);
                    ILFree(pidlReal2);
                }
                ILFree(pidlReal1);
            }
            psf->Release();
        }
    }
    else
    {
        //In this situation, we want to see if one of these items wants to be sorted
        // below the other. 
        CISFElem * pel1 = (CISFElem *)DPA_GetPtr(_hdpa, nID1);
        CISFElem * pel2 = (CISFElem *)DPA_GetPtr(_hdpa, nID2);
        DWORD dwel1 = 0;
        DWORD dwel2 = 0;

        if (pel1)
            dwel1 = pel1->GetFlags();

        if (pel2)
            dwel2 = pel2->GetFlags();

        // if both want their items sorted below the other, punt and do neither.
        if ((dwel1 & ASFF_SORTDOWN) ^ (dwel2 & ASFF_SORTDOWN))
            hres = ResultFromShort((dwel1 & ASFF_SORTDOWN)? 1 : -1);
        else
            hres = (nID1 - nID2);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::CreateViewObject method

*/
STDMETHODIMP CAugmentedISF::CreateViewObject (HWND hwndOwner, REFIID riid, LPVOID * ppvOut)
{
    HRESULT hres = E_FAIL;

    if (_hdpa)
    {
        CVODATA cvodata;

        cvodata.hres = E_FAIL;
        cvodata.hwnd = hwndOwner;
        cvodata.piid = &riid;
        cvodata.ppvObj = ppvOut;
        
        // Whoever responds first wins
        DPA_EnumCallback(_hdpa, CISFElem_CreateViewObjectCB, (void *)&cvodata);

        hres = cvodata.hres;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::GetAttributesOf method

*/
STDMETHODIMP CAugmentedISF::GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl,
                                   ULONG * pfInOut)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_READ_PTR(apidl, LPCITEMIDLIST));
    ASSERT(IS_VALID_WRITE_PTR(pfInOut, ULONG));

    ULONG fInOut = *pfInOut;
    *pfInOut &= 0;

    // We only handle one pidl
    if (1 == cidl && apidl)
    {
        UINT id = IDWrap_GetID(*apidl);
        IShellFolder * psf = _GetObjectPSF(id);

        if (psf)
        {
            LPITEMIDLIST pidlReal = GetNativePidl(*apidl, id);

            if (pidlReal)
            {
                hres = psf->GetAttributesOf(1, (LPCITEMIDLIST *)&pidlReal, &fInOut);
                *pfInOut = fInOut;
                ILFree(pidlReal);
            }
            else
                hres = E_OUTOFMEMORY;

            psf->Release();
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::GetUIObjectOf method

*/
STDMETHODIMP CAugmentedISF::GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                                 REFIID riid, UINT * prgfInOut, LPVOID * ppvOut)
{
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_READ_PTR(apidl, LPCITEMIDLIST));

    *ppvOut = NULL;

    // We only handle one pidl
    if (1 == cidl && apidl)
    {
        UINT id = IDWrap_GetID(*apidl);
        IShellFolder * psf = _GetObjectPSF(id);

        if (psf)
        {
            LPITEMIDLIST pidlReal = GetNativePidl(*apidl, id);

            if (pidlReal)
            {
                hres = psf->GetUIObjectOf(hwndOwner, 1, (LPCITEMIDLIST *)&pidlReal, riid, prgfInOut, ppvOut);
                ILFree(pidlReal);
            }
            else
                hres = E_OUTOFMEMORY;

            psf->Release();
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::GetDisplayNameOf method

*/
STDMETHODIMP CAugmentedISF::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, 
                                             LPSTRRET pstrret)
{
    HRESULT hres = E_FAIL;

    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_WRITE_PTR(pstrret, STRRET));

    if (pidl) 
    {
        UINT id = IDWrap_GetID(pidl);
        IShellFolder * psf = _GetObjectPSF(id);

        if (psf)
        {
            LPITEMIDLIST pidlReal = GetNativePidl(pidl, id);

            if (pidlReal)
            {
                hres = psf->GetDisplayNameOf(pidlReal, uFlags, pstrret);
                ILFree(pidlReal);
            }
            else
                hres = E_OUTOFMEMORY;

            psf->Release();
        }
        else
            hres = E_FAIL;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::SetNameOf method

*/
STDMETHODIMP CAugmentedISF::SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl,
                             LPCOLESTR lpszName, DWORD uFlags,
                             LPITEMIDLIST * ppidlOut)
{
    HRESULT hres = E_FAIL;

    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));
    if (pidl) 
    {
        UINT id = IDWrap_GetID(pidl);
        IShellFolder * psf = _GetObjectPSF(id);

        if (psf)
        {
            LPITEMIDLIST pidlReal = GetNativePidl(pidl, id);

            if (pidlReal)
            {
                LPITEMIDLIST pidlOut = NULL;
                hres = psf->SetNameOf(hwndOwner, pidlReal,
                             lpszName, uFlags,
                             &pidlOut);

                // Do they want a pidl back?
                if (SUCCEEDED(hres) && ppidlOut)
                {
                    *ppidlOut = AugISF_WrapPidl( pidlOut, id );

                    if (!*ppidlOut)
                        hres = E_OUTOFMEMORY;
                }

                ILFree(pidlOut);
                ILFree(pidlReal);
            }
            else
                hres = E_OUTOFMEMORY;

            psf->Release();
        }
        else
            hres = E_FAIL;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolder::ParseDisplayName method

*/
STDMETHODIMP CAugmentedISF::ParseDisplayName(HWND hwndOwner,
        LPBC pbcReserved, LPOLESTR lpszDisplayName,
        ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes)
{
    TraceMsg(TF_WARNING, "Called unimplemented CAugmentedISF::ParseDisplayNameOf");
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IAugmentedShellFolder::AddNameSpace 

*/
STDMETHODIMP CAugmentedISF::AddNameSpace(const GUID * pguid, 
                                         IShellFolder * psf, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(NULL == pguid || IS_VALID_READ_PTR(pguid, GUID));
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (NULL == _hdpa)
    {
        _hdpa = DPA_Create(4);
    }

    if (psf && _hdpa)
    {
        hres = S_OK;        // Assume success

        CISFElem * pel = new CISFElem(pguid, psf, dwFlags);
        if (pel)
        {
            hres = pel->SetPidl(pidl);
            if (SUCCEEDED(hres))
            {
                if (DPA_ERR == DPA_AppendPtr(_hdpa, pel))
                    hres = E_OUTOFMEMORY;
            }

            if (FAILED(hres))
                delete pel;
        }
        else
            hres = E_OUTOFMEMORY;
    }
    return hres;
}    


/*----------------------------------------------------------
Purpose: IAugmentedShellFolder::GetNameSpaceID 

*/
STDMETHODIMP CAugmentedISF::GetNameSpaceID(LPCITEMIDLIST pidl, GUID * pguidOut)
{
    HRESULT hres = E_INVALIDARG;

    ASSERT(IS_VALID_PIDL(pidl));
    ASSERT(IS_VALID_WRITE_PTR(pguidOut, GUID));

    if (pidl && pguidOut)
    {
        UINT id = IDWrap_GetID(pidl);

        hres = E_FAIL;

        if (_hdpa)
        {
            CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, id);
            if (pel)
            {
                pel->GetNameSpaceID(pguidOut);
                hres = S_OK;
            }
        }
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: IAugmentedShellFolder::QueryNameSpace

*/
STDMETHODIMP CAugmentedISF::QueryNameSpace(DWORD dwID, GUID * pguidOut, 
                                           IShellFolder ** ppsf)
{
    HRESULT hres = E_FAIL;

    ASSERT(NULL == pguidOut || IS_VALID_WRITE_PTR(pguidOut, GUID));
    ASSERT(NULL == ppsf || IS_VALID_WRITE_PTR(ppsf, IShellFolder));

    if (_hdpa)
    {
        CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, dwID);
        if (pel)
        {
            if (ppsf)
            {
                IShellFolder * psf = pel->GetPSF();
                psf->AddRef();
                *ppsf = psf;
            }

            if (pguidOut)
                pel->GetNameSpaceID(pguidOut);

            hres = S_OK;
        }
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: IAugmentedShellFolder::EnumNameSpace 

*/
STDMETHODIMP CAugmentedISF::EnumNameSpace(DWORD uNameSpace, DWORD * pdwID)
{
    HRESULT hres = E_FAIL;

    if (_hdpa)
    {
        DWORD celem = DPA_GetPtrCount(_hdpa);

        if (-1 == uNameSpace)
            hres = celem;
        else
        {
            if (uNameSpace >= celem)
                hres = E_FAIL;
            else
            {
                // For now, simply use the index given
                *pdwID = uNameSpace;
                hres = S_OK;
            }
        }
    }

    return hres;
}    



/*----------------------------------------------------------
    Purpose: ITranslateShellChangeNotify::TranslateIDs 
*/
STDMETHODIMP CAugmentedISF::TranslateIDs(LONG *plEvent, 
                                LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, 
                                LPITEMIDLIST * ppidlOut1, LPITEMIDLIST * ppidlOut2,
                                LONG *plEvent2, LPITEMIDLIST *ppidlOut1Event2, 
                                LPITEMIDLIST *ppidlOut2Event2)
{
    HRESULT hres = S_OK;

    *plEvent2 = (LONG)-1;

    *ppidlOut1Event2 = NULL;
    *ppidlOut2Event2 = NULL;


    *ppidlOut1 = (LPITEMIDLIST)pidl1;
    *ppidlOut2 = (LPITEMIDLIST)pidl2;

    if (_hdpa)
    {
        int cElem = DPA_GetPtrCount(_hdpa);
        int i;

        // Go thru all the namespaces and find which one should 
        // translate this notification
        for (i = 0; i < cElem; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpa, i);
            if (pel)
            {
                LPCITEMIDLIST pidlNS = pel->GetPidl();

                if (pidlNS)
                {
                    if (pidl1)
                    {
                        *ppidlOut1 = TranslatePidl(pidlNS, pidl1, i);
                        if (NULL == *ppidlOut1)
                            hres = E_OUTOFMEMORY;
                    }

                    if (SUCCEEDED(hres) && pidl2)
                    {
                        *ppidlOut2 = TranslatePidl(pidlNS, pidl2, i);
                        if (NULL == *ppidlOut2)
                            hres = E_OUTOFMEMORY;
                    }

                    if (FAILED(hres))
                    {
                        if (*ppidlOut1 != pidl1)
                            Pidl_Set(ppidlOut1, NULL);

                        if (*ppidlOut2 != pidl2)
                            Pidl_Set(ppidlOut2, NULL);
                        break;
                    }
                    else
                    {
                        if (*ppidlOut1 != pidl1 || *ppidlOut2 != pidl2)
                            break;
                    }
                }
            }
        }
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: ITranslateShellChangeNotify::IsChildID
*/
STDMETHODIMP CAugmentedISF::IsChildID(LPCITEMIDLIST pidlKid, BOOL fImmediate)
{
    HRESULT hres = S_FALSE;
    //At this point we should have a translated pidl
    if (pidlKid)
    {
        // Weirdness: If fImmediate is TRUE, then this is a Wrapped pidl. If it's
        // false, then it's not, and we need to check to see if it's a Real FS Child.
        if (fImmediate)
        {
            LPCITEMIDLIST pidlRelKid = ILFindLastID(pidlKid);
            if (pidlRelKid)
            {
                int nID = IDWrap_GetID(pidlRelKid);
                CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, nID);
                if (pel && pel->GetPidl())
                {
                
                    if (ILIsParent(pel->GetPidl(), pidlKid, TRUE))
                        hres = S_OK;
                }
            }
        }
        else
        {
            int cElem = DPA_GetPtrCount(_hdpa);
            int i;

            for (i = 0; i < cElem; i++)
            {
                CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, i);
                if (pel && pel->GetPidl())
                {
                    if (ILIsParent(pel->GetPidl(), pidlKid, FALSE))
                    {
                        hres = S_OK;
                        break;
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: ITranslateShellChangeNotify::IsEqualID

*/
STDMETHODIMP CAugmentedISF::IsEqualID(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int cElem = DPA_GetPtrCount(_hdpa);
    int i;

    for (i = 0; i < cElem; i++)
    {
        CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpa, i);

        if (pel)
        {
            if (pidl1)
            {
                if (ILIsEqual(pel->GetPidl(),pidl1))
                    return S_OK;
            }
            else if (pidl2)
            {
                if (ILIsParent(pidl2, pel->GetPidl(), FALSE))
                    return S_OK;
            }
        }
    }

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: ITranslateShellChangeNotify::Register
    Registers all pidls contained to the passed in window

*/
STDMETHODIMP CAugmentedISF::Register(HWND hwnd, UINT uMsg, long lEvents)
{
    HRESULT hres = NOERROR;
    if (_hdpa)
    {
        int cElem = DPA_GetPtrCount(_hdpa);
        int i;

        for (i = 0; i < cElem; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpa, i);

            // Has this namespace been registered yet?
            if (pel && 0 == pel->GetRegister())
            {
                // No; register it
                LPCITEMIDLIST pidlNS = pel->GetPidl();

                if (pidlNS)
                {
                    pel->SetRegister(RegisterNotify(hwnd, uMsg, pidlNS, lEvents,
                                                    SHCNRF_ShellLevel | SHCNRF_InterruptLevel, TRUE));
                }
            }
        }
    }
    else
        hres = E_FAIL;

    return hres;

}

/*----------------------------------------------------------
Purpose: ITranslateShellChangeNotify::Unregister

*/
STDMETHODIMP CAugmentedISF::Unregister()
{
    HRESULT hres = NOERROR;
    if (_hdpa)
    {
        int cElem = DPA_GetPtrCount(_hdpa);
        int i;

        for (i = 0; i < cElem; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpa, i);
            UINT uReg;
            if (pel && (uReg = pel->GetRegister()) != 0)
            {
                // SHChangeNotifyDeregister will flush messages
                // which will send a notify which will come back here...
                pel->SetRegister(0);
                SHChangeNotifyDeregister(uReg);
            }
        }
    }
    else
        hres = E_FAIL;

    return hres;

}

/*----------------------------------------------------------
Purpose: Returns the psf associated with the ID.

*/
IShellFolder * CAugmentedISF::_GetObjectPSF(int nID)
{
    IShellFolder * psf = NULL;

    if (_hdpa)
    {
        CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpa, nID);
        if (pel)
        {
            psf = pel->GetPSF();
            ASSERT(IS_VALID_CODE_PTR(psf, IShellFolder));

            psf->AddRef();
        }
    }
    return psf;
}    



//
//  CAugISF Enumerator object
//

#undef SUPERCLASS


// Constructor
CAugISFEnum::CAugISFEnum() :
   _cRef(1)
{
}


// Destructor
CAugISFEnum::~CAugISFEnum()
{
    if (_hdpaISF)
    {
        DPA_DestroyCallback(_hdpaISF, CISFElem_DestroyCB, NULL);
        _hdpaISF = NULL;
    }
}


HRESULT CAugISFEnum::Init(HDPA hdpaISF, DWORD dwEnumFlags)
{
    HRESULT hres = S_OK;

    ASSERT(IS_VALID_HANDLE(hdpaISF, DPA));

    // Clone the DPA
    _hdpaISF = DPA_Clone(hdpaISF, NULL);
    if (_hdpaISF)
    {
        // Clone the elements too
        int cElem = DPA_GetPtrCount(_hdpaISF);
        int i;

        // If something fails in the loop, at least try to enumerate 
        // other namespaces.
        for (i = 0; i < cElem; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpaISF, i);
            if (pel)
            {
                CISFElem * pelNew = pel->Clone();
                if (pelNew)
                {
                    // Get the enumerator
                    if (SUCCEEDED(pelNew->AcquireEnumerator(dwEnumFlags)))
                        DPA_SetPtr(_hdpaISF, i, pelNew);
                    else
                    {
                        TraceMsg(TF_WARNING, "CAugISFEnum::Init.  Namespace %d has no enumerator.", i);

                        // Remove it from the list to enumerate, and continue
                        DPA_DeletePtr(_hdpaISF, i);
                        cElem--;
                        i--;
                        delete pelNew;
                    }
                }
            }
        }
    }
    else
        hres = E_OUTOFMEMORY;

    return hres;
}    


STDMETHODIMP CAugISFEnum::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CAugISFEnum, IEnumIDList),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}


STDMETHODIMP_(ULONG) CAugISFEnum::AddRef()
{
    return ++_cRef;
}


STDMETHODIMP_(ULONG) CAugISFEnum::Release()
{
    if (--_cRef > 0) {
        return _cRef;
    }

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IEnumIDList::Next method

         This will call the current enumerator for the next
         object.  The object's pidl is wrapped in an IDWRAP
         (which is stamped with the identifier of the specific
         IShellFolder the object belongs to) and handed back.
         
         If the current enumerator has no more items to return,
         this function will call the next enumerator for its
         first item, and returns that.  The subsequent call 
         will pick up from there.

*/
STDMETHODIMP CAugISFEnum::Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched)
{
    ULONG celtFetched = 0;
    HRESULT hres = S_FALSE;

    if (celt > 0)
    {
        IEnumIDList * pei = _GetObjectEnumerator(_iCurISF);
        if (pei)
        {
            LPITEMIDLIST pidl;

            hres = pei->Next(1, &pidl, &celtFetched);

            if (SUCCEEDED(hres))
            {
                // End of enumeration for this object?
                if (S_FALSE == hres)
                {
                    // Yes; go to next ISF object
                    _iCurISF++;
                    hres = Next(celt, rgelt, &celtFetched);
                }
                else
                {
                    // No; now wrap the pidl.  
                    rgelt[0] = AugISF_WrapPidl( pidl, _iCurISF );
                    if (rgelt[0]) 
                    {
                        celtFetched = 1;
                        hres = S_OK;
                    } 
                    else 
                        hres = E_OUTOFMEMORY;

                    ILFree(pidl);
                }
            }

            pei->Release();
        }
    }
    
    if (pceltFetched) 
        *pceltFetched = celtFetched;

    return hres;
}


STDMETHODIMP CAugISFEnum::Skip(ULONG celt)
{
    return E_NOTIMPL;
}


STDMETHODIMP CAugISFEnum::Reset()
{
    if (_hdpaISF)
    {
        // Reset all the enumerators
        int cel = DPA_GetPtrCount(_hdpaISF);
        int i;

        for (i = 0; i < cel; i++)
        {
            CISFElem * pel = (CISFElem *)DPA_FastGetPtr(_hdpaISF, i);
            if (pel)
            {
                IEnumIDList * pei = pel->GetEnumerator();
                if (pei)
                {
                    pei->Reset();
                    // Don't Release b/c GetEnumerator doesn't AddRef
                }
            }
        }
    }

    _iCurISF = 0;

    return S_OK;
}


STDMETHODIMP CAugISFEnum::Clone(IEnumIDList **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: Returns the enumerator associated with the ID.

*/
IEnumIDList * CAugISFEnum::_GetObjectEnumerator(int nID)
{
    IEnumIDList * pei = NULL;

    if (_hdpaISF)
    {
        CISFElem * pel = (CISFElem *)DPA_GetPtr(_hdpaISF, nID);
        if (pel)
        {
            pei = pel->GetEnumerator();
            ASSERT(IS_VALID_CODE_PTR(pei, IEnumIDList));

            pei->AddRef();
        }
    }
    return pei;
}    


/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
STDAPI CAugmentedISF_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres;
    CAugmentedISF* pObj;

    hres = E_OUTOFMEMORY;

    pObj = new CAugmentedISF();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IShellFolder *);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\emclient\uemapp.cpp ===
//***   uemapp.cpp -- application side of event monitor
// DESCRIPTION
//  event generators, actions, helpers, etc.

#include "priv.h"
#include <trayp.h>
#include "sccls.h"
#include "uemapp.h"
#include "uacount.h"
#include "regdb.h"
#include "uareg.h"
#include "resource.h"

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define BIT_ASSIGN(dwBits, dwMasks, dwVals) \
    (((dwBits) & ~(dwMasks)) | (dwVals))

#define DM_UEMTRACE     0
#define DM_UEMTRACE2    0           // verbose
#define DM_IDLEDETECT   0           // TF_CUSTOM2
#define DM_EVTMON       TF_UEM

int SHSearchInt(int *psrc, int cnt, int val);
int UEMIIDToInd(const GUID *pguidGrp);

void UEMEnableTimer(UINT uTimeout);

//***   event firers {

//CASSERT(UEMIND_SHELL == 0 && UEMIND_BROWSER == 1);
HRESULT GetUEMLogger(int iCmd, CEMDBLog **p);

CEMDBLog *g_uempDbLog[UEMIND_NSTANDARD + UEMIND_NINSTR];

DWORD g_uemdwFlags /*=0*/;      // UAF_* and UAAF_*

// Turning this so that it's a Flat 12hours. You have to explicitly set the SessionTime=0 
// in the registry to debug.
#ifdef DEBUG_UEM_TIMEOUTS
#define UAS_SESSTIME    UAT_MINUTE1
#else
#define UAS_SESSTIME    UAT_HOUR12
#endif

#define UAS_SESSMIN     0
#define UAS_SESSMAX     ... none for now ...

DWORD g_dSessTime = UAS_SESSTIME;           // session time threshhold

#define UAS_IDLETIME    UAT_HOUR12
#define UAS_IDLEMIN     0
#define UAS_IDLEMAX     ... none for now ...

DWORD g_dIdleTime = UAS_IDLETIME;           // idle time threshhold

#define UAS_CLEANSESS   16
DWORD g_dCleanSess = UAS_CLEANSESS;         // cleanup session count threshhold

void UEMSpecial(int iTab, int iGrp, int eCmd, WPARAM wParam, LPARAM lParam)
{
    CEMDBLog *pDbLog = NULL;

    if (iGrp < ARRAYSIZE(g_uempDbLog))
        pDbLog = g_uempDbLog[iGrp];

    if (!pDbLog) 
    {
        ASSERT(0);
        TraceMsg(TF_ERROR, "uemt: pDbLog not initialized iTab=%d iGrp=%d eCmd=%d wParam=0x%x lParam=0x%x", iTab, iGrp, eCmd, wParam, lParam);
        return;
    }

    switch (eCmd) {
    case UEME_DBTRACEA:
        TraceMsg(DM_UEMTRACE, "uemt: e=runtrace s=%hs(0x%x)", (int)lParam, (int)lParam);
        break;
    case UEME_DBTRACEW:
        TraceMsg(DM_UEMTRACE, "uemt: e=runtrace s=%ls(0x%x)", (int)lParam, (int)lParam);
        break;
#ifdef DEBUG
    case UEME_DBSLEEP:
        Sleep((DWORD)lParam);
        break;
#endif

    // UEME_DONE*
    case UEME_DONECANCEL:
        TraceMsg(DM_UEMTRACE, "uemt: e=donecancel lP=%x", (int)lParam);
        break;

    // UEME_ERROR*
    case UEME_ERRORA:
        TraceMsg(DM_UEMTRACE, "uemt: e=errora id=%hs(0x%x)", (LPSTR)lParam, (int)lParam);
        break;
    case UEME_ERRORW:
        TraceMsg(DM_UEMTRACE, "uemt: e=errorw id=%ls(0x%x)", (LPWSTR)lParam, (int)lParam);
        break;

    case UEME_CTLSESSION:
        ASSERT(lParam == -1);   // eventually, UAQ_*
        pDbLog->SetSession(UAQ_SESSION, (BOOL)wParam);
#ifdef UAAF_INSTR
        // might be safer to copy UA.sess rather than inc UA2.sess in parallel?
        if (g_uemdwFlags & UAAF_INSTR) 
        {
            if (EVAL(g_uempDbLog[iGrp + UEMIND_NINSTR]))
                g_uempDbLog[iGrp + UEMIND_NINSTR]->SetSession(UAQ_SESSION, (BOOL)wParam);
        }
#endif
        break;

    default:
        TraceMsg(DM_UEMTRACE, "uemt: e=0x%x(%d) lP=0x%x(%d)", eCmd, eCmd, (int)lParam, (int)lParam);
        break;
    }
    return;
}

#ifdef DEBUG // {
int DBShellMenuValTab[] = 
{
    0x8,    // UEMC_FILERUN
    401,    // IDM_FILERUN
};

TCHAR * DBShellMenuStrTab[] = 
{
    TEXT("run"),
    TEXT("run"),
};

int DBBrowserMenuValTab[] = {
    0x106,
};
TCHAR * DBBrowserMenuStrTab[] = {
    TEXT("properties"),
};

int DBBrowserTbarValTab[] = {
    0x124, 0x122,
};
TCHAR * DBBrowserTbarStrTab[] = {
    TEXT("stop"),
    TEXT("home"),
};

// Function used only in this file, and only in debug,
// so no point in adding to shlwapi
LPTSTR SHSearchMapIntStr(const int *src, const LPTSTR *dst, int cnt, int val)
{
    for (; cnt > 0; cnt--, src++, dst++) {
        if (*src == val)
            return *dst;
    }
    return (LPTSTR)-1;
}
#endif // }


#define TABDAT(ueme, dope, u1, u2, u3, u4)  ueme,
int UemeValTab[] = {
    #include "uemedat.h"
};
#undef  TABDAT

#define TABDAT(ueme, dope, u1, u2, u3, u4)  TEXT(# ueme),
TCHAR *UemeStrTab[] = {
    #include "uemedat.h"
};
#undef  TABDAT

#define TABDAT(ueme, dope, u1, u2, u3, u4)  dope,
char *UemeDopeTab[] = {
    #include "uemedat.h"
};
#undef  TABDAT

BOOL UEMEncodePidl(IShellFolder *psf, LPITEMIDLIST pidlItem,
    LPTSTR pszBuf, DWORD cchBuf, int* piIndexStart, int* pcsidl);

#define MAX_EVENT_NAME      32

//***
// NOTES
//  todo: could put more encoding instrs in dope vector (e.g. %pidl, %tstr)
//  for now there are only a couple so we hard-code them
void UEMEncode(int iTab, WCHAR *pwszEvent, size_t cchEvent, WCHAR *pwszEncoded, size_t cchEncoded, int iGrp, int eCmd, WPARAM wParam, LPARAM lParam)
{
#ifdef DEBUG
    TCHAR *pdb2;
#endif
    int i, csIdl;
    TCHAR szBufTmp[MAX_URL_STRING];
    TCHAR wszEvent[MAX_PATH];


    ASSERT(pwszEvent[0] == 0);
    ASSERT(pwszEncoded == 0 || pwszEncoded[0] == 0);

    if (iTab == -1 || iTab >= ARRAYSIZE(UemeStrTab))
    {
        StringCchCopy(pwszEvent, cchEvent, TEXT("UEM?_?"));
    }
    else
    {
        StringCchCopy(pwszEvent, cchEvent, UemeStrTab[iTab]);
        ASSERT(lstrlen(pwszEvent) < MAX_EVENT_NAME);

        if (pwszEncoded) {
            switch (eCmd) {
            case UEME_RUNPIDL:
                if (UEMEncodePidl((IShellFolder *)wParam, (LPITEMIDLIST)lParam, szBufTmp, SIZECHARS(szBufTmp), &i, &csIdl)) {
                    StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:%%csidl%d%%%s"), pwszEvent, csIdl, szBufTmp + i);
                }
                else {
                    StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:%s"), pwszEvent, szBufTmp);
                }
                break;

            case UEME_RUNPATHA:
                ASSERT(lstrcmp(pwszEvent, TEXT("UEME_RUNPATHA")) == 0);
                ASSERT(pwszEvent[12] == TEXT('A'));
                pwszEvent[12] = 0;    // nuke the 'A'/'W'

                SHAnsiToTChar((PSTR)lParam, wszEvent, ARRAYSIZE(wszEvent));

                if (wParam != -1) {
                    StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:%%csidl%d%%%s"), pwszEvent, wParam, wszEvent);
                }
                else {
                    StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:%s"), pwszEvent, wszEvent);
                }
                break;

            case UEME_RUNPATHW:
                ASSERT(lstrcmp(pwszEvent, TEXT("UEME_RUNPATHW")) == 0);
                ASSERT(pwszEvent[12] == TEXT('W'));
                pwszEvent[12] = 0;    // nuke the 'A'/'W'

                if (wParam != -1) {
                    StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:%%csidl%d%%%ls"), pwszEvent, wParam, (WCHAR *)lParam);
                }
                else {
                    StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:%ls"), pwszEvent, (WCHAR *)lParam);
                }
                break;

            case UEME_RUNCPLA:
                ASSERT(lstrcmp(pwszEvent, TEXT("UEME_RUNCPLA")) == 0);
                ASSERT(pwszEvent[11] == TEXT('A'));
                pwszEvent[11] = 0;    // nuke the 'A'/'W'

                SHAnsiToTChar((PSTR)lParam, wszEvent, ARRAYSIZE(wszEvent));

                StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:%s"), pwszEvent, wszEvent);
                break;

            case UEME_RUNCPLW:
                ASSERT(lstrcmp(pwszEvent, TEXT("UEME_RUNCPLW")) == 0);
                ASSERT(pwszEvent[11] == TEXT('W'));
                pwszEvent[11] = 0;    // nuke the 'A'/'W'

                StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:%ls"), pwszEvent, (WCHAR *)lParam);
                break;

            default:
                StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:0x%x,%x"), pwszEvent, (DWORD)wParam, (DWORD)lParam);
                break;
            }
        }
    }

#ifdef DEBUG
    pdb2 = (TCHAR *)-1;

    switch (eCmd) {
    case UEME_UIMENU:
        switch (iGrp) {
        case UEMIND_SHELL:
            pdb2 = SHSearchMapIntStr(DBShellMenuValTab, DBShellMenuStrTab, ARRAYSIZE(DBShellMenuValTab), (int)lParam);
            break;
        case UEMIND_BROWSER:
            pdb2 = SHSearchMapIntStr(DBBrowserMenuValTab, DBBrowserMenuStrTab, ARRAYSIZE(DBBrowserMenuValTab), (int)lParam);
            break;
        default:
            break;
        }
        break;

    case UEME_UITOOLBAR:
        ASSERT(iGrp == UEMIND_BROWSER);
        pdb2 = SHSearchMapIntStr(DBBrowserTbarValTab, DBBrowserTbarStrTab, ARRAYSIZE(DBBrowserTbarValTab), (int)lParam);
        break;

    default:
        break;
    }

    if (pdb2 != (TCHAR *)-1) {
        if (pwszEncoded)
            StringCchPrintf(pwszEncoded, cchEncoded, TEXT("%s:%s"), pwszEvent, pdb2);
    }
#endif
}

STDAPI _UEMGetDisplayName(IShellFolder *psf, LPCITEMIDLIST pidl, UINT shgdnf, LPTSTR pszOut, DWORD cchOut)
{
    HRESULT hr;
    
    if (psf)
    {
        ASSERT(pidl == ILFindLastID(pidl));
        STRRET str;
        
        hr = psf->GetDisplayNameOf(pidl, shgdnf, &str);
        if (SUCCEEDED(hr))
            hr = StrRetToBuf(&str, pidl, pszOut, cchOut);
    }
    else
        hr = SHGetNameAndFlags(pidl, shgdnf, pszOut, cchOut, NULL);

    return hr;
}

//***   FoldCSIDL -- folder special CSIDLs to keep start menu happy
//
#define FoldCSIDL(csidl) \
    ((csidl) == CSIDL_COMMON_PROGRAMS ? CSIDL_PROGRAMS : (csidl))

//***   UemEncodePidl -- encode pidl into csidl and relative path
//
BOOL UEMEncodePidl(IShellFolder *psf, LPITEMIDLIST pidlItem,
    LPTSTR pszBuf, DWORD cchBuf, int* piIndexStart, int* pcsidl)
{
    static UINT csidlTab[] = { CSIDL_PROGRAMS, CSIDL_COMMON_PROGRAMS, CSIDL_FAVORITES, -1 };
    UINT *pcsidlCur;
    int i;
    TCHAR szFolderPath[MAX_PATH];

    _UEMGetDisplayName(psf, pidlItem, SHGDN_FORPARSING, pszBuf, cchBuf);

    for (pcsidlCur = csidlTab; *pcsidlCur != (UINT)-1; pcsidlCur++) 
    {
        // perf: assume shell32 caches this (it does)
        if (SHGetSpecialFolderPath(NULL, szFolderPath, *pcsidlCur, FALSE))
        {
            i = PathCommonPrefix(szFolderPath, pszBuf, NULL);

            if (i != 0 && i == lstrlen(szFolderPath))  
            {
                *pcsidl = FoldCSIDL(*pcsidlCur);
                *piIndexStart = i;
                return TRUE;
            }
        }
    }

    return FALSE;
}

//***   UEMEvalMsg -- fire event
// ENTRY/EXIT
//  pguidGrp    'owner' of event.  e.g. shell, browser, joe-app, etc.
//  eCmd        command.  one of UEME_* (standard) or UEME_USER+xxx (custom).
//  wP, lP      args.
// NOTES
//  - pri=1 gotta filter events for privacy issues (esp. Ger).  not sure if
//  we should add a param saying 'usage' of event or just infer it from the
//  event.
//  - pri=? gotta encrypt the data we log
//  - pri=? change to UemEvalMsg(eCmd, wParam, lParam)
//
void UEMEvalMsg(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr;

    hr = UEMFireEvent(pguidGrp, eCmd, UEMF_XEVENT, wParam, lParam);
    return;
}

STDAPI_(BOOL) UEMGetInfo(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    HRESULT hr;

    hr = UEMQueryEvent(pguidGrp, eCmd, wParam, lParam, pui);
    return SUCCEEDED(hr);
}

class CUserAssist : public IUserAssist
{
public:
    //*** IUnknown
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppv);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    //*** IUserAssist
    virtual STDMETHODIMP FireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam);
    virtual STDMETHODIMP QueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);
    virtual STDMETHODIMP SetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui);

protected:
    CUserAssist();
    HRESULT Initialize();
    virtual ~CUserAssist();
    friend HRESULT CUserAssist_CI2(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
    friend void CUserAssist_CleanUp(DWORD dwReason, void *lpvReserved);

    friend HRESULT UEMRegisterNotify(UEMCallback pfnUEMCB, void *param);

    HRESULT _InitLock();
    HRESULT _Lock();
    HRESULT _Unlock();

    void FireNotify(const GUID *pguidGrp, int eCmd)
    {
        // Assume that we have the lock
        if (_pfnNotifyCB)
            _pfnNotifyCB(_param, pguidGrp, eCmd);
    }

    HRESULT RegisterNotify(UEMCallback pfnUEMCB, void *param)
    {
        HRESULT hr;
        int cTries = 0;
        do
        {
            cTries++;
            hr = _Lock();
            if (SUCCEEDED(hr))
            {
                _pfnNotifyCB = pfnUEMCB;
                _param = param;
                _Unlock();
            }
            else
            {
                ::Sleep(100); // wait some for the lock to get freed up
            }
        }
        while (FAILED(hr) && cTries < 20);
        return hr;
    }

private:
    LONG    _cRef;

    HANDLE  _hLock;

    UEMCallback _pfnNotifyCB;
    void        *_param;

};

#define SZ_UALOCK   TEXT("_SHuassist.mtx")


void DoLog(CEMDBLog *pDbLog, TCHAR *pszBuf1, TCHAR *pszBuf2)
{
    if (pDbLog && *pszBuf1) {
        pDbLog->IncCount(pszBuf1);
        if (*pszBuf2) {
            //ASSERT(iGrp == UEMIND_BROWSER);   // not req'd but currently true
            pDbLog->IncCount(pszBuf2);
        }
    }

    return;
}

HRESULT CUserAssist::FireEvent(const GUID *pguidGrp, int eCmd, DWORD dwFlags, WPARAM wParam, LPARAM lParam)
{
    TCHAR szBuf1[32];               // "UEME_xxx"
    TCHAR szBuf2[MAX_URL_STRING];   // "UEME_xxx:0x%x,%x"
    int iGrp;
    CEMDBLog *pDbLog;
    int i, iTab;
    char ch;
    char *pszDope;

    ASSERT(this != 0);

    // If called for instrumentation (NOT event monitor) and instrumentation not enabled
    // we should exit!
    if ((UEMF_INSTRUMENT == (dwFlags & UEMF_MASK)) && (!(g_uemdwFlags & UAAF_INSTR)))
        return E_FAIL;
    
    if (g_uemdwFlags & UAAF_NOLOG)
        return E_FAIL;

    if (eCmd & UEME_FBROWSER) {
        ASSERT(0);
        ASSERT(IsEqualIID(*pguidGrp, UEMIID_NIL));
        pguidGrp = &UEMIID_BROWSER;
        eCmd &= ~UEME_FBROWSER;
    }

    iGrp = UEMIIDToInd(pguidGrp);

    pDbLog = g_uempDbLog[iGrp];

    TraceMsg(DM_UEMTRACE2, "uemt: eCmd=0x%x wP=0x%x lP=0x%x(%d)", eCmd, wParam, (int)lParam, (int)lParam);

    szBuf1[0] = szBuf2[0] = 0;

    iTab = SHSearchInt(UemeValTab, ARRAYSIZE(UemeValTab), eCmd);
    if (iTab == -1) {
        ASSERT(0);
        return E_FAIL;
    }

    pszDope = UemeDopeTab[iTab];

    while (ch = *pszDope++) {
        switch (ch) {
        case 'e':
            i = *pszDope++ - '0';
            if (i >= 2)
            {
                UEMEncode(iTab, szBuf1, ARRAYSIZE(szBuf1), szBuf2, ARRAYSIZE(szBuf2), iGrp, eCmd, wParam, lParam);
            }
            else
            {
                UEMEncode(iTab, szBuf1, ARRAYSIZE(szBuf1), NULL, 0, iGrp, eCmd, wParam, lParam);
            }
            TraceMsg(DM_UEMTRACE, "uemt: %s %s (0x%x %x %x)", szBuf1, szBuf2, eCmd, wParam, lParam);
            break;

        case 'f':
            // make sure we don't cause ourselves trouble in future
            // EM only gives us a couple of DWORDs, so we need s.t. like:
            //  bits(UEMIND_*)+bits(wParam)+bits(lParam) <= bits(DWORD)
            // for now we allow 0/-1 in hiword, if/when we use EM we'll
            // need to clean that up.
            break;

        case 'l':
            if (SUCCEEDED(_Lock())) {
                if (dwFlags & UEMF_EVENTMON)
                    DoLog(pDbLog, szBuf1, szBuf2);
#ifdef UAAF_INSTR
                if ((g_uemdwFlags & UAAF_INSTR) && (dwFlags & UEMF_INSTRUMENT))
                    DoLog(g_uempDbLog[iGrp + UEMIND_NINSTR], szBuf1, szBuf2);
#endif
                FireNotify(pguidGrp, eCmd);
                _Unlock();
            }
            break;

        case 'x':
            TraceMsg(DM_UEMTRACE, "uemt: NYI");
            goto Lnodope;

#ifdef DEBUG
        case '!':
            ASSERT(0);
            break;
#endif

        case '@':
            if (SUCCEEDED(_Lock())) {
                UEMSpecial(iTab, iGrp, eCmd, wParam, lParam);
                FireNotify(pguidGrp, eCmd);
                _Unlock();
            }
            break;
        }
    }
Lnodope:

    return S_OK;
}

HRESULT CUserAssist::QueryEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    int iGrp;
    CEMDBLog *pDbLog;
    TCHAR szBuf1[32];               // "UEME_xxx"
    TCHAR szBuf2[MAX_URL_STRING];   // "UEME_xxx:0x%x,%x"

    ASSERT(this != 0);

    if (g_uemdwFlags & UAAF_NOLOG)
        return E_FAIL;

    ASSERT(eCmd == UEME_RUNPIDL
        || eCmd == UEME_RUNPATH || eCmd == UEME_RUNWMCMD);  // others NYI

    ASSERT(pui->cbSize == SIZEOF(*pui));
    // pui->dwVersion?

    iGrp = UEMIIDToInd(pguidGrp);

    pDbLog = g_uempDbLog[iGrp];

    TraceMsg(DM_UEMTRACE2, "uemgi: eCmd=0x%x wP=0x%x lP=0x%x(%d)", eCmd, wParam, (int)lParam, (int)lParam);

    szBuf1[0] = szBuf2[0] = 0;

    int iTab = SHSearchInt(UemeValTab, ARRAYSIZE(UemeValTab), eCmd);
    UEMEncode(iTab, szBuf1, ARRAYSIZE(szBuf1), szBuf2, ARRAYSIZE(szBuf2), iGrp, eCmd, wParam, lParam);

    int cHit;
    //if (SUCCEEDED(_Lock()))
    cHit = pDbLog->GetCount(szBuf2);
    //_Unlock();

    TraceMsg(DM_UEMTRACE, "uemgi: cHit=%d psz=%s", cHit, szBuf2);

    if (pui->dwMask & UEIM_HIT) 
    {
        pui->cHit = cHit;
    }

    if (pui->dwMask & UEIM_FILETIME) 
    {
        pui->ftExecute = pDbLog->GetFileTime(szBuf2);
    }

    return S_OK;
}

HRESULT CUserAssist::SetEvent(const GUID *pguidGrp, int eCmd, WPARAM wParam, LPARAM lParam, LPUEMINFO pui)
{
    int iGrp;
    CEMDBLog *pDbLog;
    TCHAR szBuf1[32];               // "UEME_xxx"
    TCHAR szBuf2[MAX_URL_STRING];   // "UEME_xxx:0x%x,%x"

    ASSERT(this != 0);

    if (g_uemdwFlags & UAAF_NOLOG)
        return E_FAIL;

    ASSERT(pui->cbSize == SIZEOF(*pui));
    // pui->dwVersion?

    iGrp = UEMIIDToInd(pguidGrp);

    pDbLog = g_uempDbLog[iGrp];

    TraceMsg(DM_UEMTRACE2, "uemgi: eCmd=0x%x wP=0x%x lP=0x%x(%d)", eCmd, wParam, (int)lParam, (int)lParam);

    szBuf1[0] = szBuf2[0] = 0;

    int iTab = SHSearchInt(UemeValTab, ARRAYSIZE(UemeValTab), eCmd);
    UEMEncode(iTab, szBuf1, ARRAYSIZE(szBuf1), szBuf2, ARRAYSIZE(szBuf2), iGrp, eCmd, wParam, lParam);

    pui->dwMask &= UEIM_HIT | UEIM_FILETIME;    // what we support

    if (pui->dwMask && SUCCEEDED(_Lock())) {
        if (pui->dwMask & UEIM_HIT) {
            pDbLog->SetCount(szBuf2, pui->cHit);
        }
        if (pui->dwMask & UEIM_FILETIME) {
            pDbLog->SetFileTime(szBuf2, &pui->ftExecute);
        }
        _Unlock();
    }

    return S_OK;
}

//***   CUserAssist::CCI,ctor/dtor/init {

IUnknown *g_uempUaSingleton;

//***   CUserAssist_CreateInstance -- manage *singleton* instance
//
HRESULT CUserAssist_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hr = E_FAIL;

    if (g_uempUaSingleton == 0) {
        IUnknown *pua;

        hr = CUserAssist_CI2(pUnkOuter, &pua, poi);
        if (pua)
        {
            ENTERCRITICAL;
            if (g_uempUaSingleton == 0)
            {
                // Now the global owns the ref.
                g_uempUaSingleton = pua;    // xfer refcnt
                pua = NULL;
            }
            LEAVECRITICAL;
            if (pua)
            {
                // somebody beat us.
                // free up the 2nd one we just created, and use new one
                TraceMsg(DM_UEMTRACE, "sl.cua_ci: undo race");
                pua->Release();
            }

            // Now, the caller gets it's own ref.
            g_uempUaSingleton->AddRef();
            TraceMsg(DM_UEMTRACE, "sl.cua_ci: create pua=0x%x g_uempUaSingleton=%x", pua, g_uempUaSingleton);
        }
    }
    else {
        g_uempUaSingleton->AddRef();
    }

    TraceMsg(DM_UEMTRACE, "sl.cua_ci: ret g_uempUaSingleton=0x%x", g_uempUaSingleton);
    *ppunk = g_uempUaSingleton;
    return *ppunk ? S_OK : hr;
}

//***   CUserAssist_CI2 -- *always* create instance
//
HRESULT CUserAssist_CI2(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CUserAssist * p = new CUserAssist();

    if (p && FAILED(p->Initialize())) {
        delete p;
        p = NULL;
    }

    if (p) {
        *ppunk = SAFECAST(p, IUserAssist*);
        return S_OK;
    }

    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

extern "C"
HRESULT UEMRegisterNotify(UEMCallback pfnUEMCB, void *param)
{
    HRESULT hr = E_UNEXPECTED;
    if (g_uempUaSingleton)
    {
        CUserAssist *pua = reinterpret_cast<CUserAssist *>(g_uempUaSingleton);
        hr = pua->RegisterNotify(pfnUEMCB, param);
    }
    return hr;
}

extern void GetUEMSettings();
DWORD g_dwSessionStart; // When did this session start?

#if defined(_M_IX86) && (_MSC_VER < 1200)
#pragma optimize("", off)
#define BUG_OPTIMIZE        // restore, see below
#endif

//***
HRESULT CUserAssist::Initialize()
{
    HRESULT hr = S_OK;

    ASSERT(UEMIND_SHELL == 0 && UEMIND_BROWSER == 1);

    hr = _InitLock();

    // get standard loggers
    if (SUCCEEDED(hr))
        hr = GetUEMLogger(UEMIND_SHELL, &g_uempDbLog[UEMIND_SHELL]);
    if (SUCCEEDED(hr))
        hr = GetUEMLogger(UEMIND_BROWSER, &g_uempDbLog[UEMIND_BROWSER]);

    GetUEMSettings();

#define UAXF_XSETTINGS  (UAXF_NOPURGE|UAXF_BACKUP|UAXF_NOENCRYPT)
    if (g_uempDbLog[UEMIND_SHELL]) 
    {
        g_uempDbLog[UEMIND_SHELL]->_SetFlags(UAXF_XSETTINGS, g_uemdwFlags & UAXF_XSETTINGS);
        // n.b. just for shell (browser no need, instr no decay)
        g_uempDbLog[UEMIND_SHELL]->GarbageCollect(FALSE);
    }

    if (g_uempDbLog[UEMIND_BROWSER])
    {
        g_uempDbLog[UEMIND_BROWSER]->_SetFlags(UAXF_XSETTINGS, g_uemdwFlags & UAXF_XSETTINGS);
        g_uempDbLog[UEMIND_BROWSER]->GarbageCollect(FALSE);
    }
    
#ifdef UAAF_INSTR
    if (g_uemdwFlags & UAAF_INSTR) {
        if (SUCCEEDED(hr))
            hr = GetUEMLogger(UEMIND_SHELL2, &g_uempDbLog[UEMIND_SHELL2]);
        if (SUCCEEDED(hr))
            hr = GetUEMLogger(UEMIND_BROWSER2, &g_uempDbLog[UEMIND_BROWSER2]);
        if (g_uempDbLog[UEMIND_SHELL2]) {
            g_uempDbLog[UEMIND_SHELL2]->_SetFlags(UAXF_XSETTINGS, g_uemdwFlags & UAXF_XSETTINGS);
            g_uempDbLog[UEMIND_SHELL2]->_SetFlags(UAXF_NODECAY, UAXF_NODECAY);
        }
        if (g_uempDbLog[UEMIND_BROWSER2]) {
            g_uempDbLog[UEMIND_BROWSER2]->_SetFlags(UAXF_XSETTINGS, g_uemdwFlags & UAXF_XSETTINGS);
            g_uempDbLog[UEMIND_BROWSER2]->_SetFlags(UAXF_NODECAY, UAXF_NODECAY);
        }
    }
#endif

    g_dwSessionStart = GetTickCount();
    UEMEnableTimer(UATTOMSEC(g_dIdleTime));

    return hr;
}

#ifdef BUG_OPTIMIZE
#pragma optimize("", on)
#undef BUG_OPTIMIZE
#endif

void CEMDBLog_CleanUp();

//***   CUserAssist_CleanUp -- free up the world (on DLL_PROCESS_DETACH)
// NOTES
//  a bit hoaky right now since our UEMLog object isn't really refcnt'ed
void CUserAssist_CleanUp(DWORD dwReason, void *lpvReserved)
{
    int i;
    IUnknown *pUa;

    ASSERT(dwReason == DLL_PROCESS_DETACH);
    if (lpvReserved != 0) {
        // on process termination, *don't* nuke us since:
        //  - safety: other DLLs in our process may still be using us, and
        // they'll blow up when they reference us if we're freed
        //  - leaks: process termination will free us up when all is done,
        // so there's no worry about a leak
        TraceMsg(DM_UEMTRACE, "bui.cua_cu: skip cleanup (end process/non-FreeLibrary)");
        return;
    }
    // otherwise, on FreeLibrary, *do* nuke us since:
    //  - safety: our refcnt is 0, so nobody is using us any more
    //  - leaks: multiple Load/FreeLibrary calls will cause a leak if we
    // don't free ourselves here

    //ENTERCRITICAL;

    TraceMsg(DM_UEMTRACE, "bui.cua_cu: cleaning up");

    UEMEnableTimer(0);

    // free cache (and make sure we'll GPF if we party on it further)
    for (i = 0; i < UEMIND_NSTANDARD + UEMIND_NINSTR; i++) {
        // UEMIND_SHELL, UEMIND_BROWSER, UEMIND_SHELL2, UEMIND_BROWSER2
        InterlockedExchangePointer((void**) &g_uempDbLog[i], (LPVOID) -1);
    }

    // free 'real' guy
    CEMDBLog_CleanUp();

    // free THIS
    if (pUa = (IUnknown *)InterlockedExchangePointer((void**) &g_uempUaSingleton, (LPVOID) -1)) {
        delete SAFECAST(pUa, CUserAssist *);
    }

    //LEAVECRITICAL;
}

DWORD Reg_GetFlags(DWORD dwInit, HKEY hk, LPCTSTR pszSubkey, LPCTSTR const pszNameTab[], DWORD *dwMaskTab, int cTab)
{
    int i;
    DWORD dwMasks, dwVals;

    dwMasks = dwVals = 0;
    for (i = 0; i < cTab; i++) {
        DWORD dwData, cbSize = SIZEOF(dwData);
        if (SHGetValue(hk, pszSubkey, pszNameTab[i], NULL, &dwData, &cbSize) == ERROR_SUCCESS) {
            TraceMsg(DM_UEMTRACE, "ua: regkey %s\\%s=0x%x", pszSubkey, pszNameTab[i], dwData);
            dwMasks |= dwMaskTab[i];
            if (dwData)
                dwVals |= dwMaskTab[i];
        }
    }
    dwInit = BIT_ASSIGN(dwInit, dwMasks, dwVals);
    TraceMsg(DM_UEMTRACE, "ua.grs: ret 0x%x", dwInit);
    return dwInit;
}

void Reg_GetVals(HKEY hk, LPCTSTR pszSubkey, LPCTSTR const pszNameTab[], DWORD **dwValTab, int cTab)
{
    for (int i = 0; i < cTab; i++) {
        DWORD dwData, cbSize = SIZEOF(dwData);
        if (SHGetValue(hk, pszSubkey, pszNameTab[i], NULL, &dwData, &cbSize) == ERROR_SUCCESS) {
            TraceMsg(DM_UEMTRACE, "ua: regkey %s/%s=0x%x", pszSubkey, pszNameTab[i], dwData);
            *dwValTab[i] = dwData;
        }
    }
}

void GetUEMSettings()
{
    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, FALSE);
    if (hk)
    {
        static const LPCTSTR pszName1Tab[] = {
            SZ_NOPURGE  , SZ_BACKUP  , SZ_NOLOG  , SZ_INSTRUMENT, SZ_NOENCRYPT,
        };
        static DWORD dwMask1Tab[] = {
            UAXF_NOPURGE, UAXF_BACKUP, UAAF_NOLOG, UAAF_INSTR   , UAXF_NOENCRYPT,
        };
        static const LPCTSTR pszName2Tab[] = { SZ_SESSTIME,  SZ_IDLETIME , SZ_CLEANTIME, };
        static DWORD *dwVal2Tab[]   = { &g_dSessTime, &g_dIdleTime, &g_dCleanSess,};

        g_uemdwFlags = Reg_GetFlags(g_uemdwFlags, hk, SZ_UASSIST TEXT("\\") SZ_SETTINGS, pszName1Tab, dwMask1Tab, ARRAYSIZE(pszName1Tab));

        TraceMsg(DM_UEMTRACE, "ua: g_uemdwFlags=0x%x", g_uemdwFlags);

        Reg_GetVals(hk, SZ_UASSIST TEXT("\\") SZ_SETTINGS, pszName2Tab, dwVal2Tab, ARRAYSIZE(pszName2Tab));
        if (!((int)UAS_SESSMIN <= (int)g_dSessTime /*&& g_dSessTime<=UAS_SESSMAX*/))
            g_dSessTime = UAS_SESSTIME;
        if (!((int)UAS_IDLEMIN <= (int)g_dIdleTime /*&& g_dIdleTime<=UAS_IDLEMAX*/))
            g_dIdleTime = UAS_IDLETIME;

        RegCloseKey(hk);
    }

    if (SHRestricted2(REST_NoUserAssist, NULL, 0)) {
        TraceMsg(DM_WARNING, "ua: restrict off!");
        g_uemdwFlags |= UAAF_NOLOG;
        g_uemdwFlags &= ~UAAF_INSTR;    // paranoia (UAAF_NOLOG should be enuf)
    }

#ifdef DEBUG
    if (g_uemdwFlags & UAAF_NOLOG)
        TraceMsg(DM_WARNING, "ua: logging off!");
#endif

    return;
}

CUserAssist::CUserAssist() : _cRef(1)
{
    return;
}

//***
// NOTES
//  n.b. we're only called on DLL_PROCESS_DETACH (refcnt never really
// goes to 0).
CUserAssist::~CUserAssist()
{
    if (_hLock)
        CloseHandle(_hLock);
#if 1 // 981022 breadcrumbs for stress failure (see if we're double freed)
    //memcpy((BYTE *)_hLock, "CUAd", 4);
    _hLock = (void *)0x77777777;
#endif

    return;
}

// }

//***   CUserAssist::IUnknown::* {

ULONG CUserAssist::AddRef()
{
    ULONG cRef = InterlockedIncrement(&_cRef);
    TraceMsg(DM_UEMTRACE2, "cua.ar: _cRef=%d", cRef);
    return cRef;
}

ULONG CUserAssist::Release()
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    TraceMsg(DM_UEMTRACE2, "cua.r: cRef=%d", cRef);
    return cRef;
}

HRESULT CUserAssist::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CUserAssist, IUserAssist),         // IID_IUserAssist
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

// }

//***   locking stuff {

HRESULT CUserAssist::_InitLock()
{
    HRESULT hr = S_OK;

    if ((_hLock = CreateMutex(NULL, FALSE, SZ_UALOCK)) == NULL) {
        TraceMsg(TF_ERROR, "cua.i: no mutex");
        hr = E_FAIL;
    }

    return hr;
}

#define LOCK_TIMEOUT    0   // immediate timeout, should be rare

HRESULT CUserAssist::_Lock()
{
    DWORD dwRes;

    dwRes = WaitForSingleObject(_hLock, LOCK_TIMEOUT);
    switch (dwRes) {
    case WAIT_ABANDONED:
        return S_FALSE;

    case WAIT_OBJECT_0:
        return S_OK;

    case WAIT_TIMEOUT:
        TraceMsg(DM_UEMTRACE, "cua.l: locked (timeout)");
        return E_FAIL;
    }
    /*NOTREACHED*/
    return E_FAIL;
}

HRESULT CUserAssist::_Unlock()
{
    ReleaseMutex(_hLock);
    return S_OK;
}


// }

//***   timer stuff {

DWORD_PTR g_idTimer;
BOOL g_fIdle /*=FALSE*/;

#if !(_WIN32_WINNT >= 0x0500) // {

#define GetLastInputInfo    UEMGetLastInputInfo

typedef struct {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO;

DWORD g_dwTime;         // prev GetTickCount
int g_csKeys;           // prev GetKeyboardState
int g_csCursor;         // prev GetCursorPos

BOOL (*g_pfnGLII)(LASTINPUTINFO *plii);     // 'real' version

//***   memsum -- checksum bytes
//
int memsum(void *pv, int n)
{
    unsigned char *pb = (unsigned char *)pv;
    int sum = 0;

    while (n-- > 0)
        sum += *pb++;

    return sum;
}

//***   UEMGetLastInputInfo -- simulate (sort of...) GetLastInputInfo
// DESCRIPTION
//  we fake it big time.  our detection of 'currently non-idle' is pretty
// good, but the the actual *time* we were idle is pretty iffy.  each time
// we're called defines a checkpoint.  any time the new checkpoint differs
// from the old one, we update our (approx) idle start point.
BOOL UEMGetLastInputInfo(LASTINPUTINFO *plii)
{
    int csCursor, csKeys;
    POINT ptCursor;
    BYTE ksKeys[256];       // per GetKeyboardState spec

    if (g_dwTime == 0) {
        // 1st time here...
        g_dwTime = GetTickCount();
        g_csCursor = g_csKeys = -1;
        // GetProcAddress only accepts ANSI.
        *(FARPROC *)&g_pfnGLII = GetProcAddress(GetModuleHandle(TEXT("user32.dll")),
            "GetLastInputInfo");
        TraceMsg(DM_UEMTRACE, "bui.glii: init g_dwTime=%d pfn=0x%x", g_dwTime, g_pfnGLII);
    }

#if 1 // 980313 adp: off until we can test it!
    // 1st try the easy (and exact) way...
    if (g_pfnGLII)
        return (*g_pfnGLII)(plii);
#endif

    // now the hard (and approximate) way...
    csCursor = csKeys = -1;
    if (GetCursorPos(&ptCursor))
        csCursor = memsum(&ptCursor, SIZEOF(ptCursor));
    if (GetKeyboardState(ksKeys))
        csKeys = memsum(ksKeys, SIZEOF(ksKeys));
    
    if (csCursor != g_csCursor || csKeys != g_csKeys
      || (csCursor == -1 && csKeys == -1)) {
        TraceMsg(DM_UEMTRACE, "bui.glli: !idle cur=0x%x cur'=%x keys=%x keys'=%x gtc(old)=%x",
            g_csCursor, csCursor, g_csKeys, csKeys, g_dwTime);
        g_dwTime = GetTickCount();
        g_csCursor = csCursor;
        g_csKeys = csKeys;
    }

    plii->dwTime = g_dwTime;

    TraceMsg(DM_UEMTRACE, "bui.uastp: !nt5, simulate GLII()=%d", plii->dwTime);

    return TRUE;
}

#endif // }

LRESULT UEMSendTrayMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    //
    //  We may be sending a function pointer, so make sure the target window
    //  is in our address space.
    //
    //  We need to revalidate that g_hwndTray really is the
    //  tray window, because Explorer may have crashed, and then the
    //  window handle got recycled into our process, and so we send
    //  a random message to a window that isn't what we think it is.
    // (raymondc)
    //
    HWND hwndTray;
    DWORD dwPid;
    LRESULT lres;

    hwndTray = GetTrayWindow();
    if (IsWindow(hwndTray) &&
        GetWindowThreadProcessId(hwndTray, &dwPid) &&
        dwPid == GetCurrentProcessId()) {
        lres = SendMessage(hwndTray, uMsg, wParam, lParam);
    } else {
        lres = 0;
    }
    return lres;
}

//***
//
//  UEMTimerProc
//
//  Periodically checks if the user has gone idle.
//
//  Rules for session increment:
//
//  No session lasts longer than g_dIdleTime units.
//
//  If the user remains idle for a long time, keep bumping the
//  "start of session" timer so time spent idle does not count towards
//  the new session.
//
void CALLBACK UEMTimerProc(HWND hwnd, UINT uMsg, UINT idEvt, DWORD dwNow)
{
#ifdef DEBUG
    static long iDepth;     // make sure we don't get 2 ticks
#endif
    UINT dwIdleTime;        // mSec
    LASTINPUTINFO lii;

    ASSERT(iDepth == 0);
    ASSERT(InterlockedIncrement(&iDepth) > 0);

    UEMEnableTimer(0);

    dwIdleTime = UATTOMSEC(g_dIdleTime);    // convert to mSec's (again...)

    lii.cbSize = SIZEOF(lii);
    if (GetLastInputInfo(&lii)) {
        DWORD dwNow = GetTickCount();

        TraceMsg(DM_IDLEDETECT, "UEM.tp: now-start=%d, now-last=%d",
                 dwNow - g_dwSessionStart, dwNow - lii.dwTime);

        if (!g_fIdle && dwNow - g_dwSessionStart >= dwIdleTime)
        {
            g_fIdle = TRUE;
            g_dwSessionStart = dwNow;
            TraceMsg(DM_IDLEDETECT, "UEM.tp: IncrementSession");
            UEMFireEvent(&UEMIID_SHELL, UEME_CTLSESSION, UEMF_XEVENT, TRUE, -1);
            UEMFireEvent(&UEMIID_BROWSER, UEME_CTLSESSION, UEMF_XEVENT, TRUE, -1);
            UEMSendTrayMessage(TM_REFRESH, 0, 0); // RefreshStartMenu
        }

        //
        //  Get out of idle mode if the user has done anything since
        //  the session started.  And mark the session as having started
        //  at the point the user did something.
        //
        if (dwNow - lii.dwTime < dwNow - g_dwSessionStart) {
            TraceMsg(DM_IDLEDETECT, "UEM.tp: not idle; starting new session");
            g_dwSessionStart = lii.dwTime;
            g_fIdle = FALSE;
        }

        //
        //  Now decide how much longer before the next interesting event.
        //
        DWORD dwWait = g_fIdle ? dwIdleTime : dwIdleTime - (dwNow - g_dwSessionStart);

        TraceMsg(DM_UEMTRACE, "UEM.tp: sleep=%d", dwWait);
        UEMEnableTimer(dwWait);
    }
    //else timer left disabled

    ASSERT(InterlockedDecrement(&iDepth) == 0);
    return;
}

//***   UEMEnableTimer -- turn timer on/off
// ENTRY
//  uTimeout    delay in mSec; 0 means disable
void UEMEnableTimer(UINT uTimeout)
{
#if !(_WIN32_WINNT >= 0x0500)
    static BOOL fVirg = TRUE;   // 1st time thru?

    if (fVirg) {
        LASTINPUTINFO lii;

        fVirg = FALSE;

        lii.cbSize = SIZEOF(lii);
        GetLastInputInfo(&lii);     // prime it in case it's simulated
    }
#endif

    if (uTimeout) {
        // ASSERT(!g_idTimer); // race window can hit this assert spuriously
        g_idTimer = UEMSendTrayMessage(TM_SETTIMER, uTimeout, (LPARAM)UEMTimerProc);
    }
    else if (g_idTimer) {
        UEMSendTrayMessage(TM_KILLTIMER, 0, g_idTimer);
        g_idTimer = 0;
    }

    return;
}

// }

// }

//***   utils {

//***   FAST_IsEqualIID -- fast compare
// (cast to 'int' so don't get overloaded ==)
#define FAST_IsEqualIID(piid1, piid2)   ((int) (piid1) == (int) (piid2))

//***
// ENTRY/EXIT
//  iGuid   (return) index of GUID in table, o.w. -1 if not found
// NOTES
//  move to shlwapi if this is needed some place other than here.
int SHSearchIID(IID **pguidTab, int cnt, IID *pguidVal)
{
    IID **pguid;
    BOOL fInt;

    pguid = pguidTab;
    fInt = (pguidVal == 0 || pguidVal == (IID *)-1);
    for (; cnt > 0; cnt--, pguid++) {
        if (fInt) {
            if (*pguid == pguidVal)
                goto Lfound;
        }
        else if (IsEqualIID(**pguid, *pguidVal)) {
Lfound:
            return (int)(pguid - pguidTab);
        }
    }
    return -1;
}

int SHSearchInt(int *psrc, int cnt, int val)
{
    int *pcur;

    pcur = psrc;
    for (; cnt > 0; cnt--, pcur++) {
        if (*pcur == val)
            return (int)(pcur - psrc);
    }
    return -1;
}

int UEMIIDToInd(const GUID *pguidGrp)
{
    int iGrp;

    if (IsEqualIID(*pguidGrp, UEMIID_BROWSER))
        iGrp = UEMIND_BROWSER;
    else if (IsEqualIID(*pguidGrp, UEMIID_SHELL))
        iGrp = UEMIND_SHELL;
    else 
    {
        ASSERT(IsEqualIID(*pguidGrp, UEMIID_NIL));
        iGrp = UEMIND_SHELL;
    }

    return iGrp;
}
// }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\channel.h ===
#ifndef _CHANNEL_H
#define _CHANNEL_H


void Channel_UpdateQlinks();

HRESULT Channel_GetFolder(LPTSTR pszPath, int cchPath);
LPITEMIDLIST Channel_GetFolderPidl();
HRESULT ChannelBand_CreateInstance(IUnknown** ppunk);
HRESULT Channels_OpenBrowser(IWebBrowser2 **ppwb, BOOL fInPlace);


#endif

BOOL GetFirstUrl(TCHAR szURL[], DWORD cb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\channel.cpp ===
#include "priv.h"
#include <varutil.h>

#ifdef ENABLE_CHANNELS
#include "channel.h"
#include "bands.h"
#include "isfband.h"
#include "itbar.h"
#include "qlink.h"
#define WANT_CBANDSITE_CLASS
#include "bandsite.h"
#include "resource.h"
#include "deskbar.h"
#include "dpastuff.h"

#include "dbapp.h"
#include "chanbar.h"

#include "subsmgr.h"
#include "chanmgr.h"
#include "chanmgrp.h"

#include "mluisupp.h"

void FrameTrack(HDC hdc, LPRECT prc, UINT uFlags);

HRESULT Channel_GetFolder(LPTSTR pszPath, int cchPath)
{
    TCHAR szChannel[MAX_PATH];
    TCHAR szFav[MAX_PATH];
    ULONG cbChannel = sizeof(szChannel);
    HRESULT hr = E_FAIL;

    if (SHGetSpecialFolderPath(NULL, szFav, CSIDL_FAVORITES, TRUE))
    {
        //
        // Get the potentially localized name of the Channel folder from the
        // registry if it is there.  Otherwise just read it from the resource.
        // Then tack this on the favorites path.
        //

        if (ERROR_SUCCESS != SHRegGetUSValue(L"Software\\Microsoft\\Windows\\CurrentVersion",
                                             L"ChannelFolderName", NULL, (void*)szChannel,
                                             &cbChannel, TRUE, NULL, 0))
        {
            MLLoadString(IDS_CHANNEL, szChannel, ARRAYSIZE(szChannel));
        }

        if (PathCombine(pszPath, szFav, szChannel) && PathFileExists(pszPath))
        {
            // Use the channel folder name we just verified
            hr = S_OK;
        }
        else
        {
            //
            // For IE5+ use the channels dir if it exists - else use favorites
            //
            hr = StringCchCopy(pszPath, cchPath, szFav);
        }
    }    
    
    return hr;
}

LPITEMIDLIST Channel_GetFolderPidl()
{
    LPITEMIDLIST pidl = NULL;
    TCHAR szPath[MAX_PATH];
    if (SUCCEEDED(Channel_GetFolder(szPath, ARRAYSIZE(szPath))))
    {
        pidl = ILCreateFromPath(szPath);
        if (!pidl && CreateDirectory(szPath, NULL)) {
            pidl = ILCreateFromPath(szPath);
        }
    }
    return pidl;
}



HRESULT ChannelBand_CreateInstance(IUnknown** ppunk)
{
    *ppunk = NULL;
    
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidl = Channel_GetFolderPidl();
    if (pidl)
    {
        IFolderBandPriv *pfbp;
        hr = CISFBand_CreateEx(NULL, pidl, IID_PPV_ARG(IFolderBandPriv, &pfbp));
        if (SUCCEEDED(hr))
        {
            hr = pfbp->SetCascade(TRUE);
            if (SUCCEEDED(hr))
            {
                hr = pfbp->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
            }
            pfbp->Release();
        }
        ILFree(pidl);
    }

    return hr;
}

//
// Navigates the left browser pane to the channels directory.
//
void NavigateBrowserBarToChannels(IWebBrowser2* pwb)
{
    ASSERT(pwb);

    IChannelMgrPriv* pIChannelMgrPriv;

    if (SUCCEEDED(CoCreateInstance(CLSID_ChannelMgr, NULL, CLSCTX_INPROC_SERVER,
                                    IID_IChannelMgrPriv, (void**)&pIChannelMgrPriv)))
    {
        ASSERT(pIChannelMgrPriv);

        LPITEMIDLIST pidl;

        if (SUCCEEDED(pIChannelMgrPriv->GetChannelFolder(&pidl, IChannelMgrPriv::CF_CHANNEL)))
        {
            ASSERT(pidl);

            VARIANT varPath;

            if (SUCCEEDED(InitVariantFromIDList(&varPath, pidl)))
            {
                VARIANT varFlags;

                varFlags.vt   = VT_I4;
                varFlags.lVal = navBrowserBar;

                pwb->Navigate2(&varPath, &varFlags, PVAREMPTY, PVAREMPTY, PVAREMPTY);

                VariantClear(&varPath);
            }

            ILFree(pidl);
        }

        pIChannelMgrPriv->Release();
    }

    return;
}


STDAPI NavigateToPIDL(IWebBrowser2* pwb, LPCITEMIDLIST pidl)
{
    ASSERT(pwb);
    ASSERT(pidl);

    VARIANT varThePidl;
    HRESULT hr = InitVariantFromIDList(&varThePidl, pidl);
    if (SUCCEEDED(hr))
    {
        hr = pwb->Navigate2(&varThePidl, PVAREMPTY, PVAREMPTY, PVAREMPTY, PVAREMPTY);
        VariantClear(&varThePidl);       // Needed to free the copy of the PIDL in varThePidl.
    }
    return hr;
}

//
// Implements the IE4 channel quick launch shell control file functionality.
// This gets called from shdoc401 on pre-NT5 platforms and from shell32 on
// Nt5 or greater.
//
HRESULT Channel_QuickLaunch(void)
{
    IWebBrowser2* pIWebBrowser2;

    HRESULT hr = Channels_OpenBrowser(&pIWebBrowser2, FALSE);
    if (SUCCEEDED(hr))
    {
        ASSERT(pIWebBrowser2);

        NavigateBrowserBarToChannels(pIWebBrowser2);

        LPITEMIDLIST pidl;
        TCHAR szURL[MAX_URL_STRING] = TEXT("");

        GetFirstUrl(szURL, SIZEOF(szURL));

        if (szURL[0])
        {
            hr = IECreateFromPath(szURL, &pidl);

            if (SUCCEEDED(hr))
            {
                ASSERT(pidl);

                hr = NavigateToPIDL(pIWebBrowser2, pidl);

                ILFree(pidl);
            }
        }
        else
        {
            hr = E_FAIL;
        }

        pIWebBrowser2->Release();
    }

    return hr;
}



/////////////////////////////////////
////// Browser only channel band support


// the CProxyWin95Desktop class implements an OleWindow 
// to represent the win95 desktop
// the browseronly channel band will use this as its host


class CProxyWin95Desktop : 
   public IOleWindow
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return E_NOTIMPL; }

    CProxyWin95Desktop(HWND hwnd);
    
protected:
    
    UINT _cRef;
    HWND _hwnd;
};

CProxyWin95Desktop::CProxyWin95Desktop(HWND hwnd) : _cRef(1), _hwnd(hwnd)
{
}

ULONG CProxyWin95Desktop::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CProxyWin95Desktop::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CProxyWin95Desktop::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IOleWindow) ||
        IsEqualIID(riid, SID_SShellDesktop)  // private hack for deskbar.cpp
       ) {
        *ppvObj = SAFECAST(this, IOleWindow*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    
    AddRef();
    return S_OK;
}

HRESULT CProxyWin95Desktop::GetWindow(HWND * lphwnd) 
{
    *lphwnd = _hwnd; 
    if (_hwnd)
        return S_OK; 
    return E_FAIL;
}

void Channels_InitState(IUnknown* punkBar)
{
    // initialize properties
    CDeskBarPropertyBag* ppb = new CDeskBarPropertyBag();
    if (ppb) {
        // Get the default rc
        CISSTRUCT cis;
        DWORD     cbSize = sizeof(CISSTRUCT);
        RECT     *prc = &cis.rc;

        cis.iVer = 1;  // set version number to 1
        SystemParametersInfoA(SPI_GETWORKAREA, 0, prc, 0);
        prc->bottom = min(prc->bottom - 20, prc->top + 12*38 + 28); // 12 icons + caption

        if(IS_BIDI_LOCALIZED_SYSTEM())
        {
            prc->right = prc->left + 90;
            OffsetRect(prc, 20, 10);
        }
        else
        {
            prc->left = prc->right - 90;
            OffsetRect(prc, -20, 10);
        }

        // query registry for persisted state
        SHRegGetUSValue(SZ_REGKEY_CHANBAR, SZ_REGVALUE_CHANBAR, NULL, 
                        (LPVOID)&cis, &cbSize, FALSE, (LPVOID)&cis, cbSize);

        // set ppb by prc
        ppb->SetDataDWORD(PROPDATA_MODE, WBM_FLOATING | WBMF_BROWSER);
        ppb->SetDataDWORD(PROPDATA_X, prc->left);
        ppb->SetDataDWORD(PROPDATA_Y, prc->top);
        ppb->SetDataDWORD(PROPDATA_CX, RECTWIDTH(*prc));
        ppb->SetDataDWORD(PROPDATA_CY, RECTHEIGHT(*prc));
        SHLoadFromPropertyBag(punkBar, ppb);
        ppb->Release();
    }
}

void Channels_MainLoop(IDockingWindow *pdw)
{
    MSG msg;
    HWND hwnd;
    // loop while the window exists
    do {
        GetMessage(&msg, NULL, 0, 0);
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        pdw->GetWindow(&hwnd);
    } while (hwnd);
}

void Channels_SetBandInfoSFB(IUnknown* punkBand)
{
    BANDINFOSFB bi;

    // Set band startup conditions
    bi.dwMask = ISFB_MASK_STATE | ISFB_MASK_VIEWMODE;
    bi.dwStateMask = ISFB_STATE_CHANNELBAR | ISFB_STATE_NOSHOWTEXT;
    bi.dwState = ISFB_STATE_CHANNELBAR | ISFB_STATE_NOSHOWTEXT;
    bi.wViewMode = ISFBVIEWMODE_LOGOS;

    IUnknown_SetBandInfoSFB(punkBand, &bi);
}

// from isfband.cpp
extern IDeskBand * ChannelBand_Create( LPCITEMIDLIST pidl );

// this does the desktop channel in browser only mode
void DesktopChannel()
{
    _InitComCtl32();

    // Don't show channel bar:
    //      *. in integrated mode with active desktop turned on, or
    //      *. NoChannelUI restriction is set, or
    //      *. there is already one on desktop
    
    if (SHRestricted2(REST_NoChannelUI, NULL, 0))
        return;
        
    if (WhichPlatform() == PLATFORM_INTEGRATED) {
        SHELLSTATE  ss = { 0 };

        SHGetSetSettings(&ss, SSF_DESKTOPHTML, FALSE); // Get the setting
        if (ss.fDesktopHTML) {
            return;
        }
    }
        
    if (FindWindowEx(GetShellWindow(), NULL, TEXT("BaseBar"), TEXT("ChanApp")) ||
        FindWindowEx(NULL, NULL, TEXT("BaseBar"), TEXT("ChanApp"))) // can be a toplevel window
        return;

    LPITEMIDLIST pidl = Channel_GetFolderPidl();
    if (pidl) {
        IUnknown* punk = (IUnknown *) ChannelBand_Create( pidl );
        if (punk) {

            Channels_SetBandInfoSFB(punk);

            IUnknown* punkBar;
            IUnknown* punkBandSite;

            HRESULT hres = ChannelDeskBarApp_Create(&punkBar, &punkBandSite);
            if (SUCCEEDED(hres)) {
                CProxyWin95Desktop* pow = new CProxyWin95Desktop(GetShellWindow());
                if (pow) {
                    IBandSite* pbs;
                    IDockingWindow* pdw;

                    Channels_InitState(punkBar);

                    // these are always our own guys, so these QI's MUST succeed if the creation succeeded
                    punkBandSite->QueryInterface(IID_IBandSite, (LPVOID*)&pbs);
                    punkBar->QueryInterface(IID_IDockingWindow, (LPVOID*)&pdw);
                    ASSERT(pbs && pdw);

                    hres = pbs->AddBand(punk);
                    IUnknown_SetSite(pdw, (IOleWindow*)pow);

                    pbs->SetBandState((DWORD)-1, BSSF_NOTITLE, BSSF_NOTITLE);

                    pdw->ShowDW(TRUE);

                    Channels_MainLoop(pdw);

                    pdw->Release();
                    pbs->Release();
                    pow->Release();
                }
                punkBar->Release();
                punkBandSite->Release();
            }

            punk->Release();
        }
        ILFree(pidl);
    }
}

HRESULT Channels_OpenBrowser(IWebBrowser2 **ppwb, BOOL fInPlace)
{
    HRESULT hres;
    IWebBrowser2* pwb;

    if (fInPlace) {
        ASSERT(ppwb && *ppwb != NULL);
        pwb = *ppwb;
        hres = S_OK;
    }
    else {
        hres = CoCreateInstance(CLSID_InternetExplorer, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(IWebBrowser2, &pwb));
    }
    
    if (SUCCEEDED(hres))
    {
        SA_BSTRGUID  strGuid;
        VARIANT      vaGuid;

        // Don't special case full-screen mode for channels post IE4.  Use the
        // browser's full screen setting.
        // 
        //BOOL fTheater = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Channels"),
        BOOL fTheater = SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                                            TEXT("FullScreen"), FALSE, FALSE);
        pwb->put_TheaterMode( fTheater ? VARIANT_TRUE : VARIANT_FALSE);
        pwb->put_Visible(VARIANT_TRUE);


        if (!SHRestricted2(REST_NoChannelUI, NULL, 0))
        {
#ifdef ENABLE_CHANNELPANE
            StringFromGUID2(CLSID_ChannelBand, strGuid.wsz, ARRAYSIZE(strGuid.wsz));
#else
            StringFromGUID2(CLSID_FavBand, strGuid.wsz, ARRAYSIZE(strGuid.wsz));
#endif

            strGuid.cb = lstrlenW(strGuid.wsz) * SIZEOF(WCHAR);

            vaGuid.vt = VT_BSTR;
            vaGuid.bstrVal = strGuid.wsz;

            pwb->ShowBrowserBar(&vaGuid, PVAREMPTY, PVAREMPTY);
        }
        
        // don't release, we're going to return pwb.
    }
    
    if (ppwb)
        *ppwb = pwb;
    else if (pwb)
        pwb->Release();
    
    return hres;
}

BOOL GetFirstUrl(TCHAR szURL[], DWORD cb)
{
    //BOOL fFirst = FALSE;
    DWORD dwType;

    // Don't special case first channel click post IE4.
    /*if (SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("ChannelsFirstURL"), 
            &dwType, szURL, &cb, FALSE, NULL, 0) == ERROR_SUCCESS) 
    {        
        HUSKEY hUSKey;
                
        if (SHRegOpenUSKey(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), KEY_WRITE, NULL, 
                &hUSKey, FALSE) == ERROR_SUCCESS)
        {
            SHRegDeleteUSValue(hUSKey, TEXT("ChannelsFirstURL"), SHREGDEL_HKCU);
            SHRegCloseUSKey(hUSKey);
        }
        fFirst = TRUE;
    } 
    else if (SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"), TEXT("ChannelsURL"), 
        &dwType, szURL, &cb, FALSE, NULL, 0) == ERROR_SUCCESS)
    {
        // nothing
    }
    else
    {
        // BUGBUG if code is ever revived, this res:// needs to be
        // accessed through MLBuildResURLWrap because of pluggable UI
        szURL = lstrcpy(szURL, TEXT("res://ie4tour.dll/channels.htm"));
    }*/

    SHRegGetUSValue(TEXT("Software\\Microsoft\\Internet Explorer\\Main"),
                    TEXT("ChannelsURL"), &dwType, szURL, &cb, FALSE, NULL, 0);
    return FALSE; 
}


//////////////////////////////////////////////////
//
// ChannelBand
//
// This is a special band that only looks at the channels folder.
// It overrides several functions from CISFBand.
//

#undef  SUPERCLASS
#define SUPERCLASS CISFBand

class ChannelBand : public SUPERCLASS
{
public:
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

protected:
    ChannelBand();
    friend IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidl);

    virtual HRESULT _LoadOrderStream();

    virtual HWND _CreatePager(HWND hwndParent);

    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW* pnmcd);

    virtual void _Dropped(int nIndex, BOOL fDroppedOnSource);
    virtual HRESULT _AfterLoad();
    virtual void _OnDragBegin(int iItem, DWORD dwPreferedEffect);
} ;


#define COLORBK     RGB(0,0,0)
ChannelBand::ChannelBand() :
    SUPERCLASS()
{
    _lEvents |= SHCNE_EXTENDED_EVENT;
    _dwStyle |= TBSTYLE_CUSTOMERASE;

    _crBkgnd = COLORBK;     // i see a channelband and i want to paint it black
    _fHaveBkColor = TRUE;
}

HWND ChannelBand::_CreatePager(HWND hwndParent)
{
    // we do want a pager for this band, so
    // override isfband's implementation w/ grandpa's
    return CSFToolbar::_CreatePager(hwndParent);
}

HRESULT ChannelBand::QueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IContextMenu))
        return E_NOINTERFACE;
    
    
    return SUPERCLASS::QueryInterface(riid, ppvObj);
}


IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidlDefault)
{
    ChannelBand * pBand = NULL;
    LPITEMIDLIST pidl = NULL;

    if (!pidlDefault)
    {
        pidl = Channel_GetFolderPidl();
        pidlDefault = pidl;
    }
    if (EVAL(pidlDefault))
    {
        pBand = new ChannelBand;

        if (pBand)
        {
            if (FAILED(pBand->InitializeSFB(NULL, pidlDefault)))
            {
                ATOMICRELEASE(pBand);
            }
        }

        ILFree(pidl);
    }

    return pBand;
}

HRESULT ChannelBand::_AfterLoad()
{
    HRESULT hres = SUPERCLASS::_AfterLoad();

    _LoadOrderStream();

    return hres;
}

HRESULT ChannelBand::_LoadOrderStream()
{
    OrderList_Destroy(&_hdpaOrder);

    COrderList_GetOrderList(&_hdpaOrder, _pidl, _psf);
    return S_OK;
}


HRESULT ChannelBand::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = E_FAIL;

    switch (lEvent)
    {
    case SHCNE_EXTENDED_EVENT:
    {
        SHChangeMenuAsIDList UNALIGNED * pdwidl = (SHChangeMenuAsIDList UNALIGNED *)pidl1;
        if ( pdwidl->dwItem1 == SHCNEE_ORDERCHANGED )
        {
            if (SHChangeMenuWasSentByMe(this, pidl1))
            {
                // We sent this order change, ignore it
                TraceMsg(TF_BAND, "ChannelBand::OnChange SHCNEE_ORDERCHANGED skipped (we're source)");
                hres = S_OK;
            }
            else if (EVAL(pidl2) && _pidl)
            {
                if (ILIsEqual(_pidl, pidl2))
                {
                    TraceMsg(TF_BAND, "ChannelBand::OnChange SHCNEE_ORDERCHANGED accepted");

                    _LoadOrderStream();

                    if (_fShow)
                        _FillToolbar();

                    hres = S_OK;
                }
            }
            break;
        }
        // if it wasn't SHCNEE_ORDERCHANGED, then drop through to pass to the base class..
    }

    default:
        hres = SUPERCLASS::OnChange(lEvent, pidl1, pidl2);
        break;
    }

    return hres;
}

HRESULT ChannelBand::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    if (_iDragSource >= 0)
    {
        return SUPERCLASS::OnDropDDT(pdt, pdtobj, pgrfKeyState, pt, pdwEffect);
    }
    else
    {
        // we don't call superclass in this case 'cuz we want to undo
        // it's "always use shortcut" override.
        //
        _fDropping = TRUE;
        return S_OK;
    }
}

LRESULT ChannelBand::_OnCustomDraw(NMCUSTOMDRAW* pnmcd)
{
    NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
    LRESULT lres;

    lres = SUPERCLASS::_OnCustomDraw(pnmcd);
        
    switch (pnmcd->dwDrawStage)
    {
    case CDDS_PREPAINT:
        lres |= CDRF_NOTIFYITEMDRAW;
        break;

    case CDDS_PREERASE:
        // Channel band has a darker background color
        {
            RECT rc;
            GetClientRect(_hwndTB, &rc);
            // BUGBUG perf: use SHFillRectClr not SetBk/ExtText/SetBk
            COLORREF old = SetBkColor(pnmcd->hdc, _crBkgnd);
            ExtTextOut(pnmcd->hdc,0,0,ETO_OPAQUE,&rc,NULL,0,NULL);
            SetBkColor(pnmcd->hdc, old);
            lres = CDRF_SKIPDEFAULT;                
        }
        break;

    case CDDS_ITEMPREPAINT:
        // Channel band doesn't draw as buttons
        lres |= TBCDRF_NOEDGES | TBCDRF_NOOFFSET | TBCDRF_NOMARK |
                CDRF_NOTIFYPOSTPAINT;
        break;

    case CDDS_ITEMPOSTPAINT:
        // Channel band draws the hot item (CDIS_HOT)
        //
        
        pnmcd->rc.top++;
        pnmcd->rc.left++;
        if (pnmcd->uItemState & CDIS_SELECTED)
            // Mark the selected item 
            FrameTrack(pnmcd->hdc,  &(pnmcd->rc), TRACKNOCHILD);                           
        else if (pnmcd->uItemState & CDIS_HOT)
            // Mark the hot item 
            FrameTrack(pnmcd->hdc,  &(pnmcd->rc), TRACKHOT);                           
        break;

    }
    
    return lres;
}

void ChannelBand::_Dropped(int nIndex, BOOL fDroppedOnSource)
{
    ASSERT(_fDropping);

    // I'm not changing this to match the other derivatives (ISFBand, mnfolder, quick links),
    // because this structure is slightly different
    _fDropped = TRUE;

    // Persist the new order out to the registry
    if (SUCCEEDED(COrderList_SetOrderList(_hdpa, _pidl, _psf)))
    {
        // Notify everyone that the order changed
        SHSendChangeMenuNotify(this, SHCNEE_ORDERCHANGED, 0, _pidl);
    }
}

void ChannelBand::_OnDragBegin(int iItem, DWORD dwPreferedEffect)
{
    //
    // Don't allow drag if REST_NoRemovingChannels is enabled.
    //

    if (!SHRestricted2(REST_NoRemovingChannels, NULL, 0))
        SUPERCLASS::_OnDragBegin(iItem, dwPreferedEffect);

    return;
}




#endif // ENABLE_CHANNELS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\dpastuff.cpp ===
#include "priv.h"

#include "..\inc\dpastuff.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\iaccess.h ===
#ifndef _IAccessible_h
#define _IAccessible_h

#include "oleacc.h"
#include "mnbase.h"
#include "menuband.h"

#define CHILDID_SELF 0

#define MB_STATE_TRACK 1
#define MB_STATE_MENU  2
#define MB_STATE_ITEM  4

#define TOOLBAR_MASK 0x80000000

// BUGBUG (lamadio): The designers of the Accessibility interface did not know
// the rule about COM identity. They allow a QI for the external object IEnumVariant

class CAccessible : public IAccessible, public IEnumVARIANT, public IOleWindow
{
    int             _cRef;
    // IDispatch Support
    ITypeInfo*      _pTypeInfo;
    BOOL            _LoadTypeLib();


    // Track menu popup Support
    IAccessible*    _pInnerAcc;
    HWND            _hwndMenuWindow;
    HMENU           _hMenu;
    WORD            _wID;

    // Menuband Support
    CMenuToolbarBase* _pmtbBottom;
    CMenuToolbarBase* _pmtbTop;
    IShellMenuAcc*    _psma;
    IMenuBand*        _pmb;

    // Menuband Item Support
    CMenuToolbarBase*  _pmtbItem;

    int               _iAccIndex;
    int               _iIndex;  
    int               _iEnumIndex;
    int               _idCmd;


    // Object info
    BITBOOL         _fInitialized: 1;
    BITBOOL         _fState: 3;

    HRESULT _GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild);
    HRESULT _GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* iIndex);
    HRESULT _GetAccessibleItem(int iIndex, IDispatch** ppdisp);
    HRESULT _GetAccName(BSTR* pbstr);
    HRESULT _Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);


public:
    CAccessible(HMENU, WORD);
    CAccessible(IMenuBand*);
    CAccessible(IMenuBand*, int iIndex);
    virtual ~CAccessible();
    HRESULT InitAcc();

    // *** IUnknown methods ***
    virtual STDMETHODIMP_(ULONG) AddRef();
    virtual STDMETHODIMP_(ULONG) Release();
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID FAR* ppvObj);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT FAR* pctinfo);
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo);
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid);
    virtual STDMETHODIMP Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
        UINT FAR* puArgErr);


    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);


    // *** IAccessible methods ***
    virtual STDMETHODIMP get_accParent(IDispatch * FAR* ppdispParent);
    virtual STDMETHODIMP get_accChildCount(long FAR* pChildCount);
    virtual STDMETHODIMP get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild);

    virtual STDMETHODIMP get_accName(VARIANT varChild, BSTR* pszName);
    virtual STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pszValue);
    virtual STDMETHODIMP get_accDescription(VARIANT varChild, BSTR FAR* pszDescription);
    virtual STDMETHODIMP get_accRole(VARIANT varChild, VARIANT *pvarRole);
    virtual STDMETHODIMP get_accState(VARIANT varChild, VARIANT *pvarState);

    
    virtual STDMETHODIMP get_accHelp(VARIANT varChild, BSTR* pszHelp);
    virtual STDMETHODIMP get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
    virtual STDMETHODIMP get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);

    virtual STDMETHODIMP get_accFocus(VARIANT FAR * pvarFocusChild);

    virtual STDMETHODIMP get_accSelection(VARIANT FAR * pvarSelectedChildren);
    
    virtual STDMETHODIMP get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

    virtual STDMETHODIMP accSelect(long flagsSelect, VARIANT varChild);

    virtual STDMETHODIMP accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);

    virtual STDMETHODIMP accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
    virtual STDMETHODIMP accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);

    virtual STDMETHODIMP accDoDefaultAction(VARIANT varChild);

    virtual STDMETHODIMP put_accName(VARIANT varChild, BSTR szName);
    virtual STDMETHODIMP put_accValue(VARIANT varChild, BSTR pszValue);


    // *** IEnumVARIANT methods ***
    virtual STDMETHODIMP Next(unsigned long celt, 
                            VARIANT FAR* rgvar, 
                            unsigned long FAR* pceltFetched); 
    virtual STDMETHODIMP Skip(unsigned long celt); 
    virtual STDMETHODIMP Reset(); 
    virtual STDMETHODIMP Clone(IEnumVARIANT FAR* FAR* ppenum); 
};

extern "C"
{
    LRESULT LresultFromObject(REFIID riid, WPARAM wParam, IUnknown*);
    void WINAPI NotifyWinEvent(DWORD event, HWND hwnd,
        LONG idObject, LONG idChild);
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\fadetsk.h ===
#ifndef _FADETSK_H
#define _FADETSK_H

#include <runtask.h>
extern const GUID TASKID_Fader;

#define FADE_BEGIN          0x00000001
#define FADE_END            0x00000002

typedef void (*PFNFADESCREENRECT)(DWORD dwFadeState, LPVOID pvParam); // Called after the Fade has begun

class CFadeTask : public CRunnableTask
{
public:
    // IRunnableTask methods (override)
    virtual STDMETHODIMP RunInitRT(void);

    CFadeTask();
    void _StopFade();
    BOOL FadeRect(PRECT prc, PFNFADESCREENRECT pfn, LPVOID pvParam);

private:
    virtual ~CFadeTask();

    HWND        _hwndFader;
    RECT        _rect;
    PFNFADESCREENRECT _pfn;
    LPVOID      _pvParam;
    HDC         _hdcFade;
    HBITMAP     _hbm;
    HBITMAP     _hbmOld;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\htmlbm.cpp ===
#include "priv.h"
#include "sccls.h"
#include "runtask.h"
#include "legacy.h"

#include <ntquery.h>    // defines some values used for fmtid and pid

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }
DEFINE_SCID(SCID_WRITETIME,     PSGUID_STORAGE, PID_STG_WRITETIME);


class CThumbnail : public IThumbnail2, public CLogoBase
{
public:
    CThumbnail(void);

    // IUnknown
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);

    // IThumbnail
    STDMETHODIMP Init(HWND hwnd, UINT uMsg);
    STDMETHODIMP GetBitmap(LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight);

    // IThumbnail2
    STDMETHODIMP GetBitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight);

private:
    ~CThumbnail(void);

    LONG _cRef;
    HWND _hwnd;
    UINT _uMsg;
    IShellImageStore *_pImageStore;

    virtual IShellFolder * GetSF() {ASSERT(0);return NULL;};
    virtual HWND GetHWND() {ASSERT(0); return _hwnd;};

    HRESULT UpdateLogoCallback(DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache);
    REFTASKOWNERID GetTOID();

    BOOL _InCache(LPCWSTR pszItemPath, LPCWSTR pszGLocation, const FILETIME * pftDateStamp);
    HRESULT _BitmapFromIDList(LPCITEMIDLIST pidl, LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight);
    HRESULT _InitTaskCancelItems();
};


static const GUID TOID_Thumbnail = { 0xadec3450, 0xe907, 0x11d0, {0xa5, 0x7b, 0x00, 0xc0, 0x4f, 0xc2, 0xf7, 0x6a} };

HRESULT CDiskCacheTask_Create(CLogoBase * pView,
                               IShellImageStore *pImageStore,
                               LPCWSTR pszItem,
                               LPCWSTR pszGLocation,
                               DWORD dwItem,
                               IRunnableTask ** ppTask);
                               
class CDiskCacheTask : public CRunnableTask
{
public:
    CDiskCacheTask();

    STDMETHODIMP RunInitRT(void);

    friend HRESULT CDiskCacheTask_Create(CLogoBase * pView,
                           IShellImageStore *pImageStore,
                           LPCWSTR pszItem,
                           LPCWSTR pszGLocation,
                           DWORD dwItem,
                           const SIZE * prgSize,
                           IRunnableTask ** ppTask);

private:
    ~CDiskCacheTask();
    HRESULT PrepImage(HBITMAP * phBmp);
    
    IShellImageStore *_pImageStore;
    WCHAR _szItem[MAX_PATH];
    WCHAR _szGLocation[MAX_PATH];
    CLogoBase * _pView;
    DWORD _dwItem;
    SIZE m_rgSize;
};

// CreateInstance
HRESULT CThumbnail_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CThumbnail *pthumbnail = new CThumbnail();
    if (pthumbnail)
    {
        *ppunk = SAFECAST(pthumbnail, IThumbnail*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

// Constructor / Destructor
CThumbnail::CThumbnail(void) : _cRef(1)
{
    DllAddRef();
}

CThumbnail::~CThumbnail(void)
{
    if (_pTaskScheduler)
    {
        _pTaskScheduler->RemoveTasks(TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, FALSE);
        _pTaskScheduler->Release();
        _pTaskScheduler = NULL;
    }

    DllRelease();
}

HRESULT CThumbnail::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CThumbnail, IThumbnail2), 
        QITABENTMULTI(CThumbnail, IThumbnail, IThumbnail2), 
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CThumbnail::AddRef(void)
{
    return InterlockedIncrement(&_cRef);
}

ULONG CThumbnail::Release(void)
{
    ASSERT( 0 != _cRef );
    ULONG cRef = InterlockedDecrement(&_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

// IThumbnail
HRESULT CThumbnail::Init(HWND hwnd, UINT uMsg)
{
    _hwnd = hwnd;
    _uMsg = uMsg;
    ASSERT(NULL == _pTaskScheduler);

    return S_OK;
}

HRESULT CThumbnail::_InitTaskCancelItems()
{
    if (!_pTaskScheduler)
    {
        if (SUCCEEDED(CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTaskScheduler, &_pTaskScheduler))))
        {
            // make sure RemoveTasks() actually kills old tasks even if they're not done yet
            _pTaskScheduler->Status(ITSSFLAG_KILL_ON_DESTROY, ITSS_THREAD_TIMEOUT_NO_CHANGE);
        }
    }

    if (_pTaskScheduler)
    {
        // Kill any old tasks in the scheduler.
        _pTaskScheduler->RemoveTasks(TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, FALSE);
    }
    return _pTaskScheduler ? S_OK : E_FAIL;
}

HRESULT CThumbnail::_BitmapFromIDList(LPCITEMIDLIST pidl, LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    LPCITEMIDLIST pidlLast;
    IShellFolder *psf;
    HRESULT hr = SHBindToIDListParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        IExtractImage *pei;
        hr = psf->GetUIObjectOf(NULL, 1, &pidlLast, IID_PPV_ARG_NULL(IExtractImage, &pei));
        if (SUCCEEDED(hr))
        {
            DWORD dwPriority;
            DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_SCREEN | IEIFLAG_OFFLINE;
            SIZEL rgSize = {lWidth, lHeight};

            WCHAR szBufferW[MAX_PATH];
            hr = pei->GetLocation(szBufferW, ARRAYSIZE(szBufferW), &dwPriority, &rgSize, SHGetCurColorRes(), &dwFlags);
            if (SUCCEEDED(hr))
            {
                if (S_OK == hr)
                {
                    HBITMAP hBitmap;
                    hr = pei->Extract(&hBitmap);
                    if (SUCCEEDED(hr))
                    {
                        hr = UpdateLogoCallback(dwItem, 0, hBitmap, NULL, TRUE);
                    }
                }
                else
                    hr = E_FAIL;
            }
            else if (E_PENDING == hr)
            {
                WCHAR szPath[MAX_PATH];

                if (NULL == pszFile)
                {
                    DisplayNameOf(psf, pidlLast, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath));
                    pszFile = szPath;
                }

                // now get the date stamp and check the disk cache....
                FILETIME ftImageTimeStamp;
                BOOL fNoDateStamp = TRUE;
                // try it in the background...

                // od they support date stamps....
                IExtractImage2 *pei2;
                if (SUCCEEDED(pei->QueryInterface(IID_PPV_ARG(IExtractImage2, &pei2))))
                {
                    if (SUCCEEDED(pei2->GetDateStamp(&ftImageTimeStamp)))
                    {
                        fNoDateStamp = FALSE;   // we have a date stamp..
                    }
                    pei2->Release();
                }
                else
                {
                    IShellFolder2 *psf2;
                    if (SUCCEEDED(psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2))))
                    {
                        if (SUCCEEDED(GetDateProperty(psf2, pidlLast, &SCID_WRITETIME, &ftImageTimeStamp)))
                        {
                            fNoDateStamp = FALSE;   // we have a date stamp..
                        }
                        psf2->Release();
                    }
                }

                // if it is in the cache, and it is an uptodate image, then fetch from disk....
                // if the timestamps are wrong, then the extract code further down will then try

                // we only test the cache on NT5 because the templates are old on other platforms and 
                // thus the image will be the wrong size...
                IRunnableTask *prt;
                if (IsOS(OS_WIN2000ORGREATER) && _InCache(pszFile, szBufferW, (fNoDateStamp ? NULL : &ftImageTimeStamp)))
                {
                    hr = CDiskCacheTask_Create(this, _pImageStore, pszFile, szBufferW, dwItem, &rgSize, &prt);
                    if (SUCCEEDED(hr))
                    {
                        // let go of the image store, so the task has the only ref and the lock..
                        ATOMICRELEASE(_pImageStore);
                    }
                }
                else
                {
                    // Cannot hold the prt which is returned in a member variable since that
                    // would be a circular reference
                    hr = CExtractImageTask_Create(this, pei, L"", dwItem, -1, EITF_SAVEBITMAP | EITF_ALWAYSCALL, &prt);
                }
            
                if (SUCCEEDED(hr))
                {
                    // Add the task to the scheduler.
                    hr = _pTaskScheduler->AddTask(prt, TOID_Thumbnail, ITSAT_DEFAULT_LPARAM, dwPriority);
                    prt->Release();
                }
            }
            
            pei->Release();
        }
        psf->Release();
    }
    
    ATOMICRELEASE(_pImageStore);
    return hr;
}

STDMETHODIMP CThumbnail::GetBitmap(LPCWSTR pszFile, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    HRESULT hr = _InitTaskCancelItems();

    if (pszFile)
    {
        LPITEMIDLIST pidl = ILCreateFromPathW(pszFile);
        if (pidl)
        {
            hr = _BitmapFromIDList(pidl, pszFile, dwItem, lWidth, lHeight);
            ILFree(pidl);
        }
        else
            hr = E_FAIL;
    }
    return hr;
}

// IThumbnail2

STDMETHODIMP CThumbnail::GetBitmapFromIDList(LPCITEMIDLIST pidl, DWORD dwItem, LONG lWidth, LONG lHeight)
{
    HRESULT hr = _InitTaskCancelItems();
    if (pidl)
    {
        hr = _BitmapFromIDList(pidl, NULL, dwItem, lWidth, lHeight);
    }
    return hr;
}


// private stuff
HRESULT CThumbnail::UpdateLogoCallback(DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache)
{
    if (!PostMessage(_hwnd, _uMsg, dwItem, (LPARAM)hImage))
    {
        DeleteObject(hImage);
    }

    return S_OK;
}

REFTASKOWNERID CThumbnail::GetTOID()    
{ 
    return TOID_Thumbnail;
}

BOOL CThumbnail::_InCache(LPCWSTR pszItemPath, LPCWSTR pszGLocation, const FILETIME * pftDateStamp)
{
    BOOL fRes = FALSE;

    HRESULT hr;
    if (_pImageStore)
        hr = S_OK;
    else
    {
        // init the cache only once, assume all items from same folder!
        WCHAR szName[MAX_PATH];
        StrCpyNW(szName, pszItemPath, ARRAYSIZE(szName));
        PathRemoveFileSpecW(szName);
        hr = LoadFromFile(CLSID_ShellThumbnailDiskCache, szName, IID_PPV_ARG(IShellImageStore, &_pImageStore));
    }

    if (SUCCEEDED(hr))
    {
        DWORD dwStoreLock;
        hr = _pImageStore->Open(STGM_READ, &dwStoreLock);
        if (SUCCEEDED(hr))
        {
            FILETIME ftCacheDateStamp;
            hr = _pImageStore->IsEntryInStore(pszGLocation, &ftCacheDateStamp);
            if ((hr == S_OK) && (!pftDateStamp || 
                (pftDateStamp->dwLowDateTime == ftCacheDateStamp.dwLowDateTime && 
                 pftDateStamp->dwHighDateTime == ftCacheDateStamp.dwHighDateTime)))
            {
                fRes = TRUE;
            }
            _pImageStore->Close(&dwStoreLock);
        }
    }
    return fRes;
}

HRESULT CDiskCacheTask_Create(CLogoBase * pView,
                               IShellImageStore *pImageStore,
                               LPCWSTR pszItem,
                               LPCWSTR pszGLocation,
                               DWORD dwItem,
                               const SIZE * prgSize,
                               IRunnableTask ** ppTask)
{
    HRESULT hr = E_OUTOFMEMORY;
    
    CDiskCacheTask *pTask = new CDiskCacheTask;    
    if (pTask)
    {
        hr = StringCchCopyW(pTask->_szItem, ARRAYSIZE(pTask->_szItem), pszItem);
        if (SUCCEEDED(hr))
        {
            hr = StringCchCopyW(pTask->_szGLocation, ARRAYSIZE(pTask->_szGLocation), pszGLocation);
            if (SUCCEEDED(hr))
            {
                pTask->_pView = pView;
                pTask->_pImageStore = pImageStore;
                pImageStore->AddRef();
                pTask->_dwItem = dwItem;

                pTask->m_rgSize = * prgSize;
                
                *ppTask = SAFECAST(pTask, IRunnableTask *);
            }
        }
    }

    return hr;
}

STDMETHODIMP CDiskCacheTask::RunInitRT()
{
    // otherwise, run the task ....
    HBITMAP hBmp = NULL;
    DWORD dwLock;

    HRESULT hr = _pImageStore->Open(STGM_READ, &dwLock);
    if (SUCCEEDED(hr))
    {
        // at this point, we assume that it IS in the cache, and we already have a read lock on the cache...
        hr = _pImageStore->GetEntry(_szGLocation, STGM_READ, &hBmp);
    
        // release the lock, we don't need it...
        _pImageStore->Close(&dwLock);
    }
    ATOMICRELEASE(_pImageStore);

    if (hBmp)
    {
        PrepImage(&hBmp);
    
        _pView->UpdateLogoCallback(_dwItem, 0, hBmp, _szItem, TRUE);
    }

    // ensure we don't return the  "we've suspended" value...
    if (hr == E_PENDING)
        hr = E_FAIL;
        
    return hr;
}

CDiskCacheTask::CDiskCacheTask() : CRunnableTask(RTF_DEFAULT)
{
}

CDiskCacheTask::~CDiskCacheTask()
{
    ATOMICRELEASE(_pImageStore);
}

HRESULT CDiskCacheTask::PrepImage(HBITMAP * phBmp)
{
    ASSERT(phBmp && *phBmp);

    DIBSECTION rgDIB;

    if (!GetObject(*phBmp, sizeof(rgDIB), &rgDIB))
    {
        return E_FAIL;
    }

    // the disk cache only supports 32 Bpp DIBS now, so we can ignore the palette issue...
    ASSERT(rgDIB.dsBm.bmBitsPixel == 32);
    
    HBITMAP hBmpNew = NULL;
    HPALETTE hPal = NULL;
    if (SHGetCurColorRes() == 8)
    {
        hPal = SHCreateShellPalette(NULL);
    }
    
    IScaleAndSharpenImage2 * pScale;
    HRESULT hr = CoCreateInstance(CLSID_ThumbnailScaler, NULL,
                           CLSCTX_INPROC_SERVER, IID_PPV_ARG(IScaleAndSharpenImage2, &pScale));
    if (SUCCEEDED(hr))
    {
        hr = pScale->ScaleSharpen2((BITMAPINFO *) &rgDIB.dsBmih,
                                    rgDIB.dsBm.bmBits, &hBmpNew, &m_rgSize, SHGetCurColorRes(),
                                    hPal, 0, FALSE);
        pScale->Release();
    }

    if (hPal)
        DeletePalette(hPal);
    
    if (SUCCEEDED(hr) && hBmpNew)
    {
        DeleteObject(*phBmp);
        *phBmp = hBmpNew;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\icotask.h ===
#ifndef CIconTask_h
#define CIconTask_h

#include <runtask.h>

typedef void (*PFNICONTASKBALLBACK)(LPVOID pvData, UINT uId, UINT iIconIndex);

class CIconTask : public CRunnableTask
{
public:
#if 0   // Needed if we implement multiple interfaces
    // IUnknown methods
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CRunnableTask::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) 
        { return CRunnableTask::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
        { return CRunnableTask::QueryInterface(riid, ppvObj); };
#endif

    // IRunnableTask methods (override)
    virtual STDMETHODIMP RunInitRT(void);

    CIconTask(LPITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId);
private:
    virtual ~CIconTask();


    LPITEMIDLIST        _pidl;
    PFNICONTASKBALLBACK _pfn;
    LPVOID              _pvData;
    UINT                _uId;
};

// NOTE: If you pass NULL for psf and pidlFolder, you must pass a full pidl which
// the API takes ownership of. (This is an optimization) lamadio - 7.28.98
HRESULT AddIconTask(IShellTaskScheduler* pts, IShellFolder* psf, LPCITEMIDLIST pidlFolder,
                    LPCITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId, 
                    int* piTempIcon);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\fadetsk.cpp ===
#include "priv.h"
#include "fadetsk.h"
#include "apithk.h"

/// Fade Rect Support
// {2DECD184-21B0-11d2-8385-00C04FD918D0}
const GUID TASKID_Fader = 
{ 0x2decd184, 0x21b0, 0x11d2, { 0x83, 0x85, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

CFadeTask::CFadeTask() : CRunnableTask(RTF_DEFAULT)
{
    ASSERT(g_bRunOnNT5);    // This should only get created on NT5
    WNDCLASSEX wc = {0};

    if (!GetClassInfoEx(g_hinst, TEXT("SysFader"), &wc)) 
    {
        wc.cbSize          = sizeof(wc);
        wc.lpfnWndProc     = DefWindowProc;
        wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
        wc.hInstance       = g_hinst;
        wc.lpszClassName   = TEXT("SysFader");
        wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;

        if (!RegisterClassEx(&wc))
           return;
    }

    _hwndFader = CreateWindowEx(WS_EX_LAYERED | WS_EX_TRANSPARENT | 
                            WS_EX_TOPMOST | WS_EX_TOOLWINDOW, 
                            TEXT("SysFader"), TEXT("SysFader"),
                            WS_POPUP,
                            0, 0, 0, 0, NULL, (HMENU) 0, 
                            g_hinst, NULL);
}

CFadeTask::~CFadeTask()
{
    if (_hwndFader)
        DestroyWindow(_hwndFader);
}

#define ALPHASTART (200)

BOOL CFadeTask::FadeRect(PRECT prc, PFNFADESCREENRECT pfn, LPVOID pvParam)
{
    if (IsRunning() == IRTIR_TASK_RUNNING)
        return FALSE;

    InterlockedExchange(&_lState, IRTIR_TASK_NOT_RUNNING);

    _rect = *prc;
    _pfn = pfn;
    _pvParam = pvParam;

    POINT   pt;
    POINT   ptSrc = {0, 0};
    SIZE    size;

    // prc and pt are in screen coordinates.
    pt.x = _rect.left;
    pt.y = _rect.top;

    // Get the size of the rectangle for the blits.
    size.cx = RECTWIDTH(_rect);
    size.cy = RECTHEIGHT(_rect);

    // Get the DC for the screen and window.
    HDC hdcScreen = GetDC(NULL);
    if (hdcScreen)
    {
        HDC hdcWin = GetDC(_hwndFader);
        if (hdcWin)
        {
            // If we don't have a HDC for the fade, then create one.
            if (!_hdcFade)
            {
                _hdcFade = CreateCompatibleDC(hdcScreen);
                if (!_hdcFade)
                    goto Stop;

                // Create a bitmap that covers the fade region, instead of the whole screen.
                _hbm = CreateCompatibleBitmap(hdcScreen, size.cx, size.cy);
                if (!_hbm)
                    goto Stop;

                // select it in, saving the old bitmap's handle
                _hbmOld = (HBITMAP)SelectBitmap(_hdcFade, _hbm);
            }

            // Get the stuff from the screen and squirt it into the fade dc.
            BitBlt(_hdcFade, 0, 0, size.cx, size.cy, hdcScreen, pt.x, pt.y, SRCCOPY);

            // Now let user do it's magic. We're going to mimic user and start with a slightly
            // faded, instead of opaque, rendering (Looks smoother and cleaner.
            BlendLayeredWindow(_hwndFader, hdcWin, &pt, &size, _hdcFade, &ptSrc, ALPHASTART);

            // Now that we have it all build up, display it on screen.
            SetWindowPos(_hwndFader, HWND_TOPMOST, 0, 0, 0, 0,
                SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
    Stop:
            ReleaseDC(_hwndFader, hdcWin);
        }

        ReleaseDC(NULL, hdcScreen);
    }

    if (_pfn)
        _pfn(FADE_BEGIN, _pvParam);

    return TRUE;
}



#define FADE_TIMER_ID 10
#define FADE_TIMER_TIMEOUT 10 // milliseconds
#define FADE_TIMEOUT 350 // milliseconds
#define FADE_ITERATIONS 35
#define QUAD_PART(a) ((a)##.QuadPart)

void CFadeTask::_StopFade()
{
    if (_hwndFader)
    {
        SetWindowPos(_hwndFader, HWND_BOTTOM, 0, 0, 0, 0,
            SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_HIDEWINDOW);
    }

    if (_pfn)
        _pfn(FADE_END, _pvParam);

    if (_hdcFade)
    {
        if (_hbmOld)
        {
            SelectBitmap(_hdcFade, _hbmOld);
        }
        DeleteDC(_hdcFade);
        _hdcFade = NULL;
    }
    
    if (_hbm)
    {
        DeleteObject(_hbm);
        _hbm = NULL;
    }
}
 
STDMETHODIMP CFadeTask::RunInitRT(void)
{
    BOOL    fRet = FALSE;
    LARGE_INTEGER liDiff;
    LARGE_INTEGER liFreq;
    LARGE_INTEGER liStart;
    DWORD dwElapsed;
    BYTE bBlendConst;

    // Start the fade timer and the count-down for the fade.
    QueryPerformanceFrequency(&liFreq);
    QueryPerformanceCounter(&liStart);

    // Do this until the conditions specified in the loop.
    while ( TRUE )
    {
        // Calculate the elapsed time in milliseconds.
        QueryPerformanceCounter(&liDiff);
        QUAD_PART(liDiff) -= QUAD_PART(liStart);
        dwElapsed = (DWORD)((QUAD_PART(liDiff) * 1000) / QUAD_PART(liFreq));

        if (dwElapsed >= FADE_TIMEOUT) 
        {
            goto Stop;
        }

        bBlendConst = (BYTE)(ALPHASTART * (FADE_TIMEOUT - 
                dwElapsed) / FADE_TIMEOUT);

        if (bBlendConst <= 1) 
        {
            goto Stop;
        }

        // Since only the alpha is updated, there is no need to pass
        // anything but the new alpha function. This saves a source copy.
        BlendLayeredWindow(_hwndFader, NULL, NULL, NULL, NULL, NULL, bBlendConst);
        Sleep(FADE_TIMER_TIMEOUT);
    }

Stop:
    _StopFade();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\icotask.cpp ===
#include "priv.h"
#include "icotask.h"

// {EB30900C-1AC4-11d2-8383-00C04FD918D0}
static const GUID TASKID_IconExtraction = 
{ 0xeb30900c, 0x1ac4, 0x11d2, { 0x83, 0x83, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0 } };

CIconTask::CIconTask(LPITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, UINT uId):
    _pidl(pidl), _pfn(pfn), _pvData(pvData), _uId(uId), CRunnableTask(RTF_DEFAULT)
   
{ 
    
}

CIconTask::~CIconTask()
{
    if (_pidl)
        ILFree(_pidl);
}

// IRunnableTask methods (override)
STDMETHODIMP CIconTask::RunInitRT(void)
{
    int iIndex = -1;
    IShellFolder* psf;
    LPCITEMIDLIST pidlItem;

    // We need to rebind because shell folders may not be thread safe.
    HRESULT hres = IEBindToParentFolder(_pidl, &psf, &pidlItem);

    if (SUCCEEDED(hres))
    {
        iIndex = SHMapPIDLToSystemImageListIndex(psf, pidlItem, NULL);
        psf->Release();
    }

    _pfn(_pvData, _uId, iIndex);
    return S_OK;        // return S_OK even if we don't get an icon.
}


// NOTE: If you pass NULL for psf and pidlFolder, you must pass a full pidl which
// the API takes ownership of. (This is an optimization) lamadio - 7.28.98

HRESULT AddIconTask(IShellTaskScheduler* pts, IShellFolder* psf, LPCITEMIDLIST pidlFolder, 
                    LPCITEMIDLIST pidl, PFNICONTASKBALLBACK pfn, LPVOID pvData, 
                    UINT uId, int* piTempIcon)
{
    if (!pts)
        return E_INVALIDARG;


    HRESULT hres = E_PENDING;
    TCHAR szIconFile[MAX_PATH];


    // The shell has a concept of GIL_ASYNC which means that an extension called with this flag
    // should not really load the target file, it should "Fake" it, returning an icon for the type.
    // Later, on a background thread, we're going to call it again without the GIL_ASYNC, and at
    // that time, it should really extract the icon.

    // This is an optimiation for slow icon extraction, such as network shares

    // NOTE: There is significant overhead to actually loading the shell extension. If you know the
    // type of the item, pass NULL to piTempIcopn


    if (piTempIcon)
    {
        *piTempIcon = -1;

        UINT uFlags;
        IExtractIconA* pixa;
        IExtractIconW* pix;
        if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST*)&pidl, IID_IExtractIconW, NULL, (LPVOID*)&pix)))
        {
            hres = pix->GetIconLocation(GIL_FORSHELL | GIL_ASYNC,
                        szIconFile, ARRAYSIZE(szIconFile), piTempIcon, &uFlags);
            pix->Release();
        }
        else if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1,(LPCITEMIDLIST*)&pidl, IID_IExtractIconA, NULL, (LPVOID*)&pixa)))
        {
            char szIconFileA[MAX_PATH];
            hres = pixa->GetIconLocation(GIL_FORSHELL | GIL_ASYNC,
                        szIconFileA, ARRAYSIZE(szIconFileA), piTempIcon, &uFlags);
            SHAnsiToUnicode(szIconFileA, szIconFile, ARRAYSIZE(szIconFile));
            pixa->Release();
        }
    }

    if (hres == E_PENDING)
    {
        if (piTempIcon)
            *piTempIcon = Shell_GetCachedImageIndex(szIconFile, *piTempIcon, 0);

        LPITEMIDLIST pidlFull;
        if (psf)
            pidlFull = ILCombine(pidlFolder, pidl);
        else
            pidlFull = (LPITEMIDLIST)pidl;

        hres = E_OUTOFMEMORY;
        CIconTask* pit = new CIconTask(pidlFull, pfn, pvData, uId);
        // Don't ILFree(pidlFull) because CIconTask takes ownership.
        // BUGBUG (lamadio) Remove this from the memory list. Ask Saml how to do this
        // for the IMallocSpy stuff.

        if (pit)
        {
            hres = pts->AddTask(SAFECAST(pit, IRunnableTask*), TASKID_IconExtraction, 
                ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY);

            pit->Release();
        }
    }
    else
    {
        *piTempIcon = SHMapPIDLToSystemImageListIndex(psf, pidl, NULL);
        hres = S_OK;
    }

    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\iaccess.cpp ===
#include "priv.h"
// BUGBUG (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "apithk.h"
#include "resource.h"
#include "initguid.h"
#include "iaccess.h"

#include "mluisupp.h"

CAccessible::CAccessible(HMENU hmenu, WORD wID):
    _hMenu(hmenu), _wID(wID), _cRef(1)
{
    _fState = MB_STATE_TRACK;
}

CAccessible::CAccessible(IMenuBand* pmb): _cRef(1)
{
    _fState = MB_STATE_MENU;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::CAccessible(IMenuBand* pmb, int iIndex): _cRef(1)
{
    _fState = MB_STATE_ITEM;
    _iAccIndex = iIndex;
    _pmb = pmb;
    if (_pmb)
    {
        _pmb->AddRef();
    }
}

CAccessible::~CAccessible()
{
    ATOMICRELEASE(_pTypeInfo);
    ATOMICRELEASE(_pInnerAcc);
    switch (_fState)
    {
    case MB_STATE_TRACK:
        ASSERT(!_hwndMenuWindow || IsWindow(_hwndMenuWindow));
        if (_hwndMenuWindow)
        {
            // Don't Destroy hmenu. It's part of a larger one...
            SetMenu(_hwndMenuWindow, NULL);
            DestroyWindow(_hwndMenuWindow);
            _hwndMenuWindow = NULL;
        }
        break;

    case MB_STATE_ITEM:
        ATOMICRELEASE(_pmtbItem);
        // Fall Through

    case MB_STATE_MENU:
        ATOMICRELEASE(_pmtbTop);
        ATOMICRELEASE(_pmtbBottom);
        ATOMICRELEASE(_psma);
        ATOMICRELEASE(_pmb);
        break;
    }
}

HRESULT CAccessible::InitAcc()
{
    HRESULT hres = E_FAIL;
    if (_fInitialized)
        return NOERROR;

    _fInitialized = TRUE;   // We're initialized if we fail or not...

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (EVAL(_hMenu))
        {
            _hwndMenuWindow = CreateWindow(TEXT("static"),
                TEXT("MenuWindow"), WS_POPUP, 0, 0, 0, 0, NULL,
                _hMenu, g_hinst, NULL);
            if (EVAL(_hwndMenuWindow))
            {
                IAccessible* paccChild1;
                hres = CreateStdAccessibleObject(_hwndMenuWindow, OBJID_MENU, IID_IAccessible, (void**)&paccChild1);
                if(SUCCEEDED(hres))
                {
                    VARIANT varChild;
                    varChild.vt = VT_I4;
                    varChild.lVal = _wID + 1;        //Accesibility is 1 based

                    // In order to get "On par" with the OleAcc's implementation of the HMENU wrapper,
                    // we need to do this twice. Once gets us the IAccessible for the "MenuItem" on the 
                    // "Menubar". The second gets us the "Menuitem's" child. This is what we need to emulate
                    // their heirarchy.
                    IDispatch* pdispChild1;
                    hres = paccChild1->get_accChild(varChild, &pdispChild1);

                    // OLEAcc returns a Success code (S_FALSE) while initializing the out param to zero.
                    // Explicitly test this situation.

                    // Does this have a Child?
                    if (hres == S_OK)
                    {
                        // Yes. Look for that child
                        IAccessible* paccChild2;
                        hres = pdispChild1->QueryInterface(IID_IAccessible, (void**)&paccChild2);

                        // Does this have a child?
                        if (hres == S_OK)
                        {
                            // Yep, then we store this guy's child...
                            IDispatch* pdispChild2;
                            varChild.lVal = 1;        //Get the first child
                            hres = paccChild2->get_accChild(varChild, &pdispChild2);
                            if (hres == S_OK)
                            {
                                hres = pdispChild2->QueryInterface(IID_IAccessible, (void**)&_pInnerAcc);
                                pdispChild2->Release();
                            }
                            paccChild2->Release();
                        }
                        pdispChild1->Release();
                    }
                    paccChild1->Release();
                }
            }
        }
        break;


    case MB_STATE_ITEM:
    case MB_STATE_MENU:
        hres = _pmb->QueryInterface(IID_IShellMenuAcc, (void**)&_psma);
        if (SUCCEEDED(hres))
        {
            _psma->GetTop(&_pmtbTop);
            _psma->GetBottom(&_pmtbBottom);
        }

        if (_fState == MB_STATE_ITEM)
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            if (SUCCEEDED(_GetChildFromVariant(&varChild, &_pmtbItem, &_iIndex)))
                _idCmd = GetButtonCmd(_pmtbItem->_hwndMB, _iIndex);
        }

        break;
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CAccessible::AddRef()
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CAccessible::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CAccessible::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = 
    {
        QITABENT(CAccessible, IDispatch),
        QITABENT(CAccessible, IAccessible),
        QITABENT(CAccessible, IEnumVARIANT),
        QITABENT(CAccessible, IOleWindow),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);

    return hres;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetTypeInfoCount method

*/
STDMETHODIMP CAccessible::GetTypeInfoCount(UINT FAR* pctinfo)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfoCount(pctinfo);
    *pctinfo = 1;
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetTypeInfo method

*/
STDMETHODIMP CAccessible::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo FAR* FAR* pptinfo)
{
    *pptinfo = NULL;
    if (_pInnerAcc)
        return _pInnerAcc->GetTypeInfo(itinfo, lcid, pptinfo);

    if (itinfo != 0)
        return DISP_E_BADINDEX;

    if (EVAL(_LoadTypeLib()))
    {
        *pptinfo = _pTypeInfo;
        _pTypeInfo->AddRef();
        return NOERROR;
    }
    else
        return E_FAIL;
}

/*----------------------------------------------------------
Purpose: IDispatch::GetIDsOfNames method

*/
STDMETHODIMP CAccessible::GetIDsOfNames(REFIID riid, OLECHAR FAR* FAR* rgszNames, UINT cNames,
        LCID lcid, DISPID FAR* rgdispid)
{
    if (_pInnerAcc)
        return _pInnerAcc->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);

    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->GetIDsOfNames(rgszNames, cNames, rgdispid);
    }
    else
        return E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDispatch::Invoke method

*/
STDMETHODIMP CAccessible::Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
    DISPPARAMS FAR* pdispparams, VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,
    UINT FAR* puArgErr)

{
    if (_pInnerAcc)
        return _pInnerAcc->Invoke(dispidMember, riid, lcid, wFlags, pdispparams, pvarResult, 
            pexcepinfo, puArgErr);
    
    if (IID_NULL != riid)
        return DISP_E_UNKNOWNINTERFACE;

    if (EVAL(_LoadTypeLib()))
    {
        return _pTypeInfo->Invoke(static_cast<IDispatch*>(this),
            dispidMember, wFlags, pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    else
        return E_FAIL;
}

BOOL CAccessible::_LoadTypeLib()
{
    ITypeLib* pTypeLib;
    if (_pTypeInfo)
        return TRUE;

    if (SUCCEEDED(LoadTypeLib(L"oleacc.dll", &pTypeLib)))
    {
        pTypeLib->GetTypeInfoOfGuid(IID_IAccessible, &_pTypeInfo);
        ATOMICRELEASE(pTypeLib);
        return TRUE;
    }
    return FALSE;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accParent method

*/
STDMETHODIMP CAccessible::get_accParent(IDispatch * FAR* ppdispParent)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accParent(ppdispParent);
        break;

    case MB_STATE_MENU:
        {
            IUnknown* punk;
            if (SUCCEEDED(_psma->GetParentSite(IID_IUnknown, (void**)&punk)))
            {
                IAccessible* pacc;
                if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                    IID_IAccessible, (void**)&pacc)))
                {
                    VARIANT varChild = {VT_I4, CHILDID_SELF};     // Init
                    hres = pacc->get_accFocus(&varChild);
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->get_accChild(varChild, ppdispParent);
                    }
                    VariantClearLazy(&varChild);
                    pacc->Release();
                }
                else
                {
                    // Another implementation headache: Accessibility requires
                    // us to return S_FALSE when there is no parent.

                    *ppdispParent = NULL;
                    hres = S_FALSE;
                }

                punk->Release();
            }

            return hres;
        }
    case MB_STATE_ITEM:
        // The parent of an item is the menuband itself
        return IUnknown_QueryService(_psma, SID_SMenuPopup, IID_IDispatch, (void**)ppdispParent);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChildCount method

*/
STDMETHODIMP CAccessible::get_accChildCount(long FAR* pChildCount)
{   
    *pChildCount = 0;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChildCount(pChildCount);
        break;

    case MB_STATE_MENU:
        {
            int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
            int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
            *pChildCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;
        }
        break;
    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
            *pChildCount = 1;
        break;

    }
    
    return NOERROR;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accChild method

*/
STDMETHODIMP CAccessible::get_accChild(VARIANT varChildIndex, IDispatch * FAR* ppdispChild)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accChild(varChildIndex, ppdispChild);
        break;

    case MB_STATE_MENU:
        {
            if (varChildIndex.vt == VT_I4 && varChildIndex.lVal == CHILDID_SELF)
            {
                // So this is the ONLY menthod that is allowed to fail when something is
                // unavailable.
                *ppdispChild = NULL;
                hres = E_INVALIDARG;
            }
            else
            {
                int iIndex;
                // Since it's returing an index, we don't need to test the success case
                _GetChildFromVariant(&varChildIndex, NULL, &iIndex);
                hres = _GetAccessibleItem(iIndex, ppdispChild);
            }
        }
        break;

    case MB_STATE_ITEM:
        if (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)
        {
            VARIANT varChild;
            hres = _GetVariantFromChildIndex(_pmtbItem->_hwndMB, _iIndex, &varChild);
            if (SUCCEEDED(hres))
            {
                hres = _psma->GetSubMenu(&varChild, IID_IDispatch, (void**)ppdispChild);
            }
        }
        else
            hres = E_NOINTERFACE;
        break;
    }
    
    return hres;   
}

HRESULT CAccessible::_GetAccName(BSTR* pbstr)
{
    IDispatch* pdisp;
    HRESULT hres = get_accParent(&pdisp);
    // Get parent can return a success code, but still fail to return a parent.
    // This interface sucks.
    if (hres == S_OK)
    {
        IAccessible* pacc;
        hres = pdisp->QueryInterface(IID_IAccessible, (void**)&pacc);
        if (SUCCEEDED(hres))
        {
            VARIANT varChild;
            hres = pacc->get_accFocus(&varChild);
            if (SUCCEEDED(hres))
                hres = pacc->get_accName(varChild, pbstr);
        }
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accName method

*/
STDMETHODIMP CAccessible::get_accName(VARIANT varChild, BSTR* pszName)
{   
    CMenuToolbarBase* pmtb = _pmtbItem;
    int idCmd = _idCmd;

    *pszName = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accName(varChild, pszName);
        break;

    case MB_STATE_MENU:
        if (varChild.lVal == CHILDID_SELF)
        {
            if (_GetAccName(pszName) == S_FALSE)
            {
                TCHAR sz[100];
                MLLoadString(IDS_ACC_APP, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
                if (!*pszName)
                    return E_OUTOFMEMORY;
            }
            return NOERROR;
        }
        else
        {
            int iIndex;
            if (FAILED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                return DISP_E_MEMBERNOTFOUND;

            idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
        }

        // Fall Through

    case MB_STATE_ITEM:
        {
            TCHAR sz[MAX_PATH];
            int idString = 0;
            TBBUTTON tbb;
            if (ToolBar_GetButton(pmtb->_hwndMB, _iIndex, &tbb) && 
                tbb.fsStyle & BTNS_SEP)
            {
                idString = IDS_ACC_SEP;
            }
            else if (pmtb->GetChevronID() == _idCmd)
            {
                idString = IDS_ACC_CHEVRON;
            }

            if (idString != 0)
            {
                MLLoadString(idString, sz, ARRAYSIZE(sz));
                *pszName = SysAllocStringT(sz);
            }
            else
            {
                UINT cch = (UINT)SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, NULL);

                if (cch != 0 && cch < ARRAYSIZE(sz))
                {
                    if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                    {
                        SHStripMneumonic(sz);
                        *pszName = SysAllocString(sz);
                    }
                }
            }

            if (_fState == MB_STATE_MENU)
                pmtb->Release();

            if (!*pszName)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accValue method

*/
STDMETHODIMP CAccessible::get_accValue(VARIANT varChild, BSTR* pszValue)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accValue(varChild, pszValue);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // This does not make sense for these.
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDescription method

*/
STDMETHODIMP CAccessible::get_accDescription(VARIANT varChild, BSTR FAR* pszDescription)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDescription(varChild, pszDescription);
        break;

    case MB_STATE_MENU:
        if (FAILED(_GetAccName(pszDescription)))
        {
            TCHAR sz[100];
            MLLoadString(IDS_ACC_APPMB, sz, ARRAYSIZE(sz));
            *pszDescription = SysAllocStringT(sz);
            if (!*pszDescription)
                return E_OUTOFMEMORY;
        }
        break;
    case MB_STATE_ITEM:
        return get_accName(varChild, pszDescription);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accRole method

*/
STDMETHODIMP CAccessible::get_accRole(VARIANT varChild, VARIANT *pvarRole)
{   
    pvarRole->vt = VT_I4;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accRole(varChild, pvarRole);
        break;

    case MB_STATE_MENU:
        {
            BOOL fVertical;
            BOOL fOpen;
            _psma->GetState(&fVertical, &fOpen);
            pvarRole->lVal = ( fVertical )? ROLE_SYSTEM_MENUPOPUP : ROLE_SYSTEM_MENUBAR;
            return NOERROR;
        }

    case MB_STATE_ITEM:
        pvarRole->lVal = ROLE_SYSTEM_MENUITEM;
        return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accState method

*/
STDMETHODIMP CAccessible::get_accState(VARIANT varChild, VARIANT *pvarState)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accState(varChild, pvarState);
        break;

    case MB_STATE_MENU:
        {
            // All menus can be selected, and given focus. Most will be visible.
            DWORD dwState = STATE_SYSTEM_FOCUSABLE;

            BOOL fOpen;
            BOOL fVertical;
            _psma->GetState(&fVertical, &fOpen);

            // Do we have a menu popped up?
            if (fOpen)
            {
                // Yes, then we have focus
                dwState |= STATE_SYSTEM_FOCUSED;
            }
            else if (fVertical)
            {
                // If we're a vertical menu without being popped up, then we're invisible.
                dwState |= STATE_SYSTEM_INVISIBLE;
            }


            pvarState->vt = VT_I4;
            pvarState->lVal = dwState;
        }
        return NOERROR;

    case MB_STATE_ITEM:
        {
            DWORD dwAccState = STATE_SYSTEM_FOCUSABLE;

            int idHotTracked = ToolBar_GetHotItem(_pmtbItem->_hwndMB);
            DWORD dwState = ToolBar_GetState(_pmtbItem->_hwndMB, _iIndex);

            if (dwState & TBSTATE_PRESSED)
                dwAccState |= STATE_SYSTEM_SELECTABLE | STATE_SYSTEM_FOCUSED;

            if (idHotTracked == _iIndex)
                dwAccState |= STATE_SYSTEM_HOTTRACKED;

            pvarState->vt = VT_I4;
            pvarState->lVal = dwAccState;

            return NOERROR;
        }
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelp method

*/
STDMETHODIMP CAccessible::get_accHelp(VARIANT varChild, BSTR* pszHelp)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelp(varChild, pszHelp);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accHelpTopic method

*/
STDMETHODIMP CAccessible::get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        // Not implemented
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

#define CH_PREFIX TEXT('&')

TCHAR GetAccelerator(LPCTSTR psz, BOOL bUseDefault)
{
    TCHAR ch = (TCHAR)-1;
    LPCTSTR pszAccel = psz;
    // then prefixes are allowed.... see if it has one
    do 
    {
        pszAccel = StrChr(pszAccel, CH_PREFIX);
        if (pszAccel) 
        {
            pszAccel = CharNext(pszAccel);

            // handle having &&
            if (*pszAccel != CH_PREFIX)
                ch = *pszAccel;
            else
                pszAccel = CharNext(pszAccel);
        }
    } while (pszAccel && (ch == (TCHAR)-1));

    if ((ch == (TCHAR)-1) && bUseDefault)
    {
        // Since we're unicocde, we don't need to mess with MBCS
        ch = *psz;
    }

    return ch;
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accKeyboardShortcut method

*/
STDMETHODIMP CAccessible::get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        goto labelGetaccel;

    case MB_STATE_MENU:
        {

            if (varChild.lVal != CHILDID_SELF)
            {
                if (SUCCEEDED(_GetChildFromVariant(&varChild, &pmtb, &iIndex)))
                {
labelGetaccel:
                    TCHAR sz[MAX_PATH];
                    TCHAR szAccel[100] = TEXT("");
                    int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                    if (S_FALSE == _psma->IsEmpty())
                    {
                        UINT cch = (UINT)SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, NULL);

                        if (cch != 0 && cch < ARRAYSIZE(sz))
                        {
                            if (SendMessage(pmtb->_hwndMB, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                            {
                                BOOL fVertical, fOpen;
                                _psma->GetState(&fVertical, &fOpen);
                                if (!fVertical)
                                {
                                    MLLoadString(IDS_ACC_ALT, szAccel, ARRAYSIZE(szAccel));
                                }
                                szAccel[lstrlen(szAccel)] = GetAccelerator(sz, TRUE);
                                szAccel[lstrlen(szAccel)] = TEXT('\0');
                                hres = S_OK;
                            }
                        }
                    }

                    *pszKeyboardShortcut = SysAllocStringT(szAccel);
                    if (!*pszKeyboardShortcut)
                        hres = E_OUTOFMEMORY;
                    pmtb->Release();
                }
            }

        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accFocus method

*/
STDMETHODIMP CAccessible::get_accFocus(VARIANT FAR * pvarFocusChild)
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accFocus(pvarFocusChild);
        break;

    case MB_STATE_MENU:
        {
            pvarFocusChild->vt = VT_I4;
            pvarFocusChild->lVal = CHILDID_SELF;

            CMenuToolbarBase* pmtbTracked;
            _psma->GetTracked(&pmtbTracked);
            if (pmtbTracked)
            {
                int iIndex = ToolBar_GetHotItem(pmtbTracked->_hwndMB);
                hres = _GetVariantFromChildIndex(pmtbTracked->_hwndMB, 
                    iIndex, pvarFocusChild);
                pmtbTracked->Release();
            }
        }
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accSelection method

*/
STDMETHODIMP CAccessible::get_accSelection(VARIANT FAR * pvarSelectedChildren)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accSelection(pvarSelectedChildren);
        break;

    case MB_STATE_MENU:
        return get_accFocus(pvarSelectedChildren);
        break;

    case MB_STATE_ITEM:
        // Not implemented;
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::get_accDefaultAction method

*/
STDMETHODIMP CAccessible::get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction)
{   
    TCHAR sz[MAX_PATH];

    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->get_accDefaultAction(varChild, pszDefaultAction);
        break;

    case MB_STATE_MENU:
        {
            MLLoadString(IDS_ACC_CLOSE, sz, ARRAYSIZE(sz));
            *pszDefaultAction = SysAllocStringT(sz);

            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }

    case MB_STATE_ITEM:
        {
            if (S_OK == _psma->IsEmpty())
            {
                sz[0] = TEXT('\0');
            }
            else
            {
                int iId = (_pmtbItem->v_GetFlags(_idCmd) & SMIF_SUBMENU)? IDS_ACC_OPEN: IDS_ACC_EXEC;
                MLLoadString(iId, sz, ARRAYSIZE(sz));
            }

            *pszDefaultAction = SysAllocStringT(sz);
            if (!*pszDefaultAction)
                return E_OUTOFMEMORY;

            return NOERROR;
        }
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accSelect method

*/
STDMETHODIMP CAccessible::accSelect(long flagsSelect, VARIANT varChild)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accSelect(flagsSelect, varChild);
        break;

    case MB_STATE_MENU:
    case MB_STATE_ITEM:
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accLocation method

*/
STDMETHODIMP CAccessible::accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild)
{   
    CMenuToolbarBase* pmtb;
    int iIndex;
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
        break;

    case MB_STATE_ITEM:
        pmtb = _pmtbItem;
        pmtb->AddRef();
        iIndex = _iIndex;
        hres = NOERROR;
        goto labelGetRect;

    case MB_STATE_MENU:
        {
            RECT rc;
            if (varChild.vt == VT_I4)
            {
                if (varChild.lVal == CHILDID_SELF)
                {
                    IUnknown* punk;
                    hres = _psma->GetParentSite(IID_IUnknown, (void**)&punk);
                    if (SUCCEEDED(hres))
                    {
                        IOleWindow* poct;
                        hres = IUnknown_QueryService(punk, SID_SMenuPopup, 
                            IID_IOleWindow, (void**)&poct);
                        if (SUCCEEDED(hres))
                        {
                            HWND hwnd;
                            hres = poct->GetWindow(&hwnd);
                            if (SUCCEEDED(hres))
                            {
                                // Return the window rect of the menubar.
                                GetWindowRect(hwnd, &rc);
                            }

                            poct->Release();
                        }

                        punk->Release();
                    }
                }
                else
                {
                    hres = _GetChildFromVariant(&varChild, &pmtb, &iIndex);
                    if (SUCCEEDED(hres))
                    {

labelGetRect:           int idCmd = GetButtonCmd(pmtb->_hwndMB, iIndex);
                        if (!ToolBar_GetRect(pmtb->_hwndMB, idCmd, &rc))  //1 based index
                            hres = E_INVALIDARG;
                        MapWindowPoints(pmtb->_hwndMB, NULL, (LPPOINT)&rc, 2);
                        pmtb->Release();
                    }
                }

                if (SUCCEEDED(hres))
                {
                    *pxLeft = rc.left;
                    *pyTop = rc.top;
                    *pcxWidth = rc.right - rc.left;
                    *pcyHeight = rc.bottom - rc.top;
                }
            }
        }
        break;
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accNavigate method

*/
STDMETHODIMP CAccessible::accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)     
{   
    HRESULT hres = DISP_E_MEMBERNOTFOUND;
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accNavigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_MENU:
        return _Navigate(navDir, varStart, pvarEndUpAt);
        break;

    case MB_STATE_ITEM:
        {
            VARIANT varChild;
            _GetVariantFromChildIndex(NULL, _iAccIndex, &varChild);
            return _Navigate(navDir, varChild, pvarEndUpAt);
        }
    }
    
    return hres;   
}

/*----------------------------------------------------------
Purpose: IAccessible::accHitTest method

*/
STDMETHODIMP CAccessible::accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint)
{   
    POINT pt = {xLeft, yTop};
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accHitTest(xLeft, yTop, pvarChildAtPoint);
        break;

    case MB_STATE_MENU:
        {
            if (_psma)
            {
                int iIndex;
                HWND hwnd = WindowFromPoint(pt);

                if (hwnd == _pmtbTop->_hwndMB || hwnd == _pmtbBottom->_hwndMB)
                {
                    ScreenToClient(hwnd, &pt);
                    iIndex = ToolBar_HitTest(hwnd, &pt);
                    if (iIndex >= 0)
                    {
                        pvarChildAtPoint->vt = VT_DISPATCH;
                        // This call expects the index to be an "Accessible" index which is one based
                        VARIANT varChild;
                        _GetVariantFromChildIndex(hwnd, iIndex, &varChild);

                        //Since this is just returining an index, we don't need to test success
                        _GetChildFromVariant(&varChild, NULL, &iIndex);
                        return _GetAccessibleItem(iIndex, &pvarChildAtPoint->pdispVal);
                    }
                }

                // Hmm, must be self
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;

                return S_OK;
            }
        }
        break;

    case MB_STATE_ITEM:
        {
            RECT rc;
            MapWindowPoints(NULL, _pmtbItem->_hwndMB, &pt, 1);

            if (ToolBar_GetRect(_pmtbItem->_hwndMB, _idCmd, &rc) &&
                PtInRect(&rc, pt))
            {
                pvarChildAtPoint->vt = VT_I4;
                pvarChildAtPoint->lVal = CHILDID_SELF;
            }
            else
            {
                pvarChildAtPoint->vt = VT_EMPTY;
                pvarChildAtPoint->lVal = (DWORD)(-1);
            }
            return NOERROR;
        }
        break;

    }
    
    return DISP_E_MEMBERNOTFOUND;
}

/*----------------------------------------------------------
Purpose: IAccessible::accDoDefaultAction method

*/
STDMETHODIMP CAccessible::accDoDefaultAction(VARIANT varChild)
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->accDoDefaultAction(varChild);
        break;

    case MB_STATE_MENU:
        if (_psma)
            return _psma->DoDefaultAction(&varChild);
        break;

    case MB_STATE_ITEM:
        if (SendMessage(_pmtbItem->_hwndMB, TB_SETHOTITEM2, _iIndex, 
            HICF_OTHER | HICF_RESELECT | HICF_TOGGLEDROPDOWN))
            return NOERROR;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accName method

*/
STDMETHODIMP CAccessible::put_accName(VARIANT varChild, BSTR szName)     
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
        if (_pInnerAcc)
            return _pInnerAcc->put_accName(varChild, szName);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}

/*----------------------------------------------------------
Purpose: IAccessible::put_accValue method

*/
STDMETHODIMP CAccessible::put_accValue(VARIANT varChild, BSTR pszValue)  
{   
    switch (_fState)
    {
    case MB_STATE_TRACK:
       if (_pInnerAcc)
            return _pInnerAcc->put_accValue(varChild, pszValue);
        break;
    }
    
    return DISP_E_MEMBERNOTFOUND;   
}


HRESULT CAccessible::_Navigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt)
{
    ASSERT(pvarEndUpAt);
    int iIndex = 0;         // 1 based index
    int iTBIndex;
    HRESULT hres = S_FALSE;
    TBBUTTONINFO tbInfo;
    int idCmd;
    VARIANT varTemp;
    CMenuToolbarBase* pmtb;
    BOOL fVertical;
    BOOL fOpen;


    tbInfo.cbSize = sizeof(TBBUTTONINFO);

    pvarEndUpAt->vt = VT_DISPATCH;
    pvarEndUpAt->pdispVal = NULL;

    _GetChildFromVariant(&varStart, NULL, &iIndex);

    _psma->GetState(&fVertical, &fOpen);
    if (!fVertical)
    {
        static const long navMap[] = 
        {
            NAVDIR_LEFT,    // Map to Up
            NAVDIR_RIGHT,   // Map to Down
            NAVDIR_UP,      // Map to Left
            NAVDIR_DOWN,    // Map to Right
        };
        if (IsInRange(navDir, NAVDIR_UP, NAVDIR_RIGHT))
            navDir = navMap[navDir - NAVDIR_UP];
    }

    switch (navDir)
    {
    case NAVDIR_NEXT:
        {
            VARIANT varVert;
            varVert.vt = VT_BOOL;
            // For the Vertical case, Next should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through
    case NAVDIR_DOWN:

        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex++;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    case NAVDIR_FIRSTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }

        iIndex = 0;
        hres = NOERROR;
        break;

    case NAVDIR_LASTCHILD:
        if (_fState == MB_STATE_ITEM)
        {
            pvarEndUpAt->vt = VT_EMPTY;
            pvarEndUpAt->pdispVal = NULL;
            hres = S_FALSE;
            break;
        }
        iIndex = -1;
        hres = NOERROR;
        break;

    case NAVDIR_LEFT:
        pvarEndUpAt->vt = VT_DISPATCH;
        return get_accParent(&pvarEndUpAt->pdispVal);
        break;

    case NAVDIR_RIGHT:
        {
            CMenuToolbarBase* pmtb = (varStart.lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
            int idCmd = GetButtonCmd(pmtb->_hwndMB, (varStart.lVal & ~TOOLBAR_MASK) - 1);
            if (pmtb->v_GetFlags(idCmd) & SMIF_SUBMENU)
            {
                IMenuPopup* pmp;
                hres = _psma->GetSubMenu(&varStart, IID_IMenuPopup, (void**)&pmp);
                if (SUCCEEDED(hres))
                {
                    IAccessible* pacc;
                    hres = IUnknown_QueryService(pmp, SID_SMenuBandChild, IID_IAccessible, (void**)&pacc);
                    if (SUCCEEDED(hres))
                    {
                        hres = pacc->accNavigate(NAVDIR_FIRSTCHILD, varStart, pvarEndUpAt);
                        pacc->Release();
                    }
                    pmp->Release();
                }
            }

                return hres;
        }
        break;

    case NAVDIR_PREVIOUS:
        {
            VARIANT varVert;
            varVert.vt = VT_BOOL;
            // For the Vertical case, Pervious should return an error. 

            // Is this band vertical?
            // Don't do this for anything but the menu case.
            if (_fState == MB_STATE_MENU &&
                SUCCEEDED(IUnknown_QueryServiceExec(_psma, SID_SMenuBandParent, &CGID_MenuBand, 
                          MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                varVert.boolVal == VARIANT_TRUE)
            {
                // Yes. Then punt
                hres = S_FALSE;
                break;
            }
            // Fall Through
        }
        //Fall through

    case NAVDIR_UP:
        hres = NOERROR;
        while (SUCCEEDED(hres))
        {
            iIndex--;
            hres = _GetVariantFromChildIndex(NULL, iIndex, &varTemp);
            if (SUCCEEDED(hres))
            {
                hres = _GetChildFromVariant(&varTemp, &pmtb, &iTBIndex);
                if (SUCCEEDED(hres))
                {
                    if (iTBIndex == 0)    
                    {   
                        hres = S_FALSE;
                        //Don't navigate to self, allow the top bar to get a whack.
                        IUnknown* punk;
                        if (SUCCEEDED(_psma->GetParentSite(IID_IOleCommandTarget, (void**)&punk)))
                        {
                            IOleCommandTarget* poct;
                            if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                IID_IOleCommandTarget, (void**)&poct)))
                            {
                                VARIANT varVert;
                                varVert.vt = VT_BOOL;

                                if (SUCCEEDED(poct->Exec(&CGID_MenuBand, MBANDCID_ISVERTICAL, 0, NULL, &varVert)) &&
                                    varVert.boolVal == VARIANT_FALSE)
                                {
                                    IAccessible* pacc;
                                    if (SUCCEEDED(IUnknown_QueryService(punk, SID_SMenuBandParent, 
                                        IID_IAccessible, (void**)&pacc)))
                                    {
                                        VARIANT varChild = {VT_I4, CHILDID_SELF};
                                        hres = pacc->get_accFocus(&varChild);
                                        if (SUCCEEDED(hres))
                                        {
                                            hres = pacc->get_accChild(varChild, &pvarEndUpAt->pdispVal);
                                        }

                                        VariantClearLazy(&varChild);
                                        pacc->Release();
                                    }
                                }
                                poct->Release();
                            }
                            punk->Release();
                        }
                    }   // iTBIndex == 0

                    tbInfo.dwMask = TBIF_STATE | TBIF_STYLE;
                    idCmd = GetButtonCmd(pmtb->_hwndMB, iTBIndex);
                    ToolBar_GetButtonInfo(pmtb->_hwndMB, idCmd, &tbInfo);
                    pmtb->Release();

                    if (!(tbInfo.fsState & TBSTATE_HIDDEN) &&
                        !(tbInfo.fsStyle & TBSTYLE_SEP))
                    {
                        break;
                    }
                }
            }
        }
        break;

    default:
        hres = E_INVALIDARG;
    }

    if (SUCCEEDED(hres) && S_FALSE != hres)
        hres = _GetAccessibleItem(iIndex, &pvarEndUpAt->pdispVal);

    return hres;
}

HRESULT CAccessible::_GetVariantFromChildIndex(HWND hwnd, int iIndex, VARIANT* pvarChild)
{
    // First bit: Top 1, bottom 0
    // Rest is index into that toolbar.
    pvarChild->vt = VT_I4;
    pvarChild->lVal = iIndex + 1;

    if (hwnd)
    {
        if (hwnd == _pmtbTop->_hwndMB)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
    }
    else
    {
        // Caller wants us to figure out based on index from top.
        int iTopCount = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        int iBottomCount = ToolBar_ButtonCount(_pmtbBottom->_hwndMB);
        int iTotalCount = (_pmtbTop != _pmtbBottom)? iTopCount + iBottomCount : iTopCount;

        if (iIndex < iTopCount)
        {
            pvarChild->lVal |= TOOLBAR_MASK;
        }
        else
        {
            pvarChild->lVal -= iTopCount;
        }

        // This works because:
        // If there are 2 toolbars, the bottom one is represented by top bit clear.
        // If there is only one, then it doesn't matter if it's top or bottom.

        // lVal is not zero based....
        if (iIndex == -1)
            pvarChild->lVal = iTotalCount;

        if (iIndex >= iTotalCount)
            return E_FAIL;
    }

    return NOERROR;
}

HRESULT CAccessible::_GetChildFromVariant(VARIANT* pvarChild, CMenuToolbarBase** ppmtb, int* piIndex)
{
    ASSERT(_pmtbTop && _pmtbBottom);
    ASSERT(piIndex);

    if (ppmtb)
        *ppmtb = NULL;

    *piIndex = -1;

    // Passing a NULL for an HWND returns the index from the beginning of the set.
    int iAdd = 0;
    if (pvarChild->vt != VT_I4)
        return E_FAIL;

    if (pvarChild->lVal & TOOLBAR_MASK)
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbTop;
        }
    }
    else
    {
        if (ppmtb)
        {
            *ppmtb = _pmtbBottom;
        }
        else
        {
            iAdd = ToolBar_ButtonCount(_pmtbTop->_hwndMB);
        }
    }

    if (ppmtb && *ppmtb)
        (*ppmtb)->AddRef();

    *piIndex = (pvarChild->lVal & ~TOOLBAR_MASK) + iAdd - 1;

    return (ppmtb && !*ppmtb) ? E_FAIL : S_OK;
}


HRESULT CAccessible::_GetAccessibleItem(int iIndex, IDispatch** ppdisp)
{
    HRESULT hres = E_OUTOFMEMORY;
    CAccessible* pacc = new CAccessible(_pmb, iIndex);

    if (pacc)
    {
        hres = pacc->InitAcc();
        if (SUCCEEDED(hres))
        {
            hres = pacc->QueryInterface(IID_IDispatch, (void**) ppdisp);
        }
        pacc->Release();
    }
    return hres;
}

// *** IEnumVARIANT methods ***
STDMETHODIMP CAccessible::Next(unsigned long celt, 
                        VARIANT FAR* rgvar, 
                        unsigned long FAR* pceltFetched)
{

    // Picky customer complaint. Check for NULL...
    if (pceltFetched)
        *pceltFetched = 1;
    return _GetVariantFromChildIndex(NULL, _iEnumIndex++, rgvar);
}

STDMETHODIMP CAccessible::Skip(unsigned long celt)
{
    return E_NOTIMPL;
}

STDMETHODIMP CAccessible::Reset()
{
    _iEnumIndex = 0;
    return NOERROR;
}

STDMETHODIMP CAccessible::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    return E_NOTIMPL;
}

// *** IOleWindow methods ***
STDMETHODIMP CAccessible::GetWindow(HWND * lphwnd)
{
    *lphwnd = NULL;

    switch (_fState)
    {
    case MB_STATE_TRACK:
        *lphwnd = _hwndMenuWindow;
        break;

    case MB_STATE_ITEM:
        *lphwnd = _pmtbItem->_hwndMB;
        break;

    case MB_STATE_MENU:
        *lphwnd = _pmtbTop->_hwndMB;
        break;
    }

    if (*lphwnd)
        return NOERROR;

    return E_FAIL;
}

STDMETHODIMP CAccessible::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\isfband.h ===
#ifndef BANDISF
#define BANDISF

//#include "iface.h"
#include "bands.h"
//#include "cwndproc.h"
//#include "droptgt.h"
#include "logo.h"
#include "sftbar.h"
#include "legacy.h"

class CISFBand : public CToolbarBand,
                 public CSFToolbar,
                 public CLogoBase,
                 public IFolderBandPriv

{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IPersistStream methods (CToolBand PURE) ***
    virtual STDMETHODIMP GetClassID(LPCLSID lpClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);

    // *** IContextMenu methods (override) ***
    virtual STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    
    // *** IOleCommandTarget ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);
    
    // *** IShellFolderBand methods ***
    virtual STDMETHODIMP InitializeSFB(LPSHELLFOLDER psf, LPCITEMIDLIST pidl);
    virtual STDMETHODIMP SetBandInfoSFB(BANDINFOSFB * pbi);
    virtual STDMETHODIMP GetBandInfoSFB(BANDINFOSFB * pbi);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IFolderBandPriv
    // for internal guys so that we don't have to use a prop page
    virtual STDMETHODIMP SetCascade(BOOL f) { _fCascadeFolder = BOOLIFY(f); return S_OK; };
    virtual STDMETHODIMP SetAccelerators(BOOL f) { _fAccelerators = BOOLIFY(f); return S_OK; }; 
    virtual STDMETHODIMP SetNoIcons(BOOL f)   { _fNoIcons = BOOLIFY(f); return S_OK; };
    virtual STDMETHODIMP SetNoText(BOOL f)  { _fNoShowText = BOOLIFY(f); return S_OK; };

protected:

    friend HRESULT    CISFBand_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
    friend CISFBand * CISFBand_CreateEx(IShellFolder * psf, LPCITEMIDLIST pidl);

    CISFBand();
    virtual ~CISFBand();

    void    _ReleaseMenu();
    void    _SetDirty(BOOL fDirty);
    virtual HRESULT _SetSubMenuPopup(IMenuPopup* pmp, UINT uiCmd, LPCITEMIDLIST pidl, DWORD dwFlagsMDBPU);
    virtual IMenuPopup * _CreateMenuPopup(IShellFolder * psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi);
    virtual void _SendInitMenuPopup(IMenuPopup * pmp, LPCITEMIDLIST pidl);
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon);

    void    _ReleaseMenuPopup(IMenuPopup** ppmp);
    void    _SetCacheMenuPopup(IMenuPopup* pmp);
    HRESULT _DropdownItem(LPCITEMIDLIST pidl, UINT idCmd);

    LRESULT _TryChannelSurfing(LPCITEMIDLIST pidl);
    HRESULT _GetChannelBrowser(IWebBrowser2 **ppwb);
    HRESULT _IStreamFromOrderList(VARIANT* pvarargOut);
    HRESULT _OrderListFromIStream(VARIANT* pvarargIn);

    IMenuPopup *_pmpCache;
    IMenuPopup *    _pmp;               // Submenu popup

    const GUID*     _pguidUEMGroup;


    BITBOOL         _fCascadeFolder :1;
    BITBOOL         _fNoRecalcDefaults :1;// Don't recalc defaults during GetBandInfo
    BITBOOL         _fInitialized :1;   // have we initialized the toolbar
    BITBOOL         _fDebossed :1;      // TRUE to enable debossed rebar style
    BITBOOL         _fLinksMode :1;     // TRUE: do not allow drag & drop onto content items.
    BITBOOL         _fHaveBkColor :1;    // TRUE if _crBkgnd is valid
    BITBOOL         _fHaveColors :1;    // TRUE if _crBtnXX are valid
    BITBOOL         _fFullOpen :1;      // TRUE if band should maximize when opened
    BITBOOL         _fClosing : 1;      // TRUE if we are shutting down....
    BITBOOL         _fDesktop :1;       // 1:desktop 0:browser(or non-ActDesk)
    BITBOOL         _fBtnMinSize :1;    // TRUE if band should report min thickness of button
    BITBOOL         _fDelayPainting :1;
    BITBOOL         _fChannels :1;      // TRUE if we want "Navigate Target" sup
    BITBOOL         _fCreatedBandProxy :1; // TRUE if we created a BandProxy ourself and hence need to call SetOwner on it
    BITBOOL         _fAllowDropdown: 1;
    BITBOOL         _fDelayInit :1;
    
    int             _eUemLog :2;        // UEMIND_* (NIL:off, o.w.:group)
    int             _iIdealLength;      // our ideal height/width last time bandsite asked
    
    COLORREF        _crBkgnd;           // Background color (must set _fHaveBkColor)
    COLORREF        _crBtnLt;           // Button hilite color (must set _fHaveColors)
    COLORREF        _crBtnDk;           // Button lolite color (must set _fHaveColors)

    DWORD _dwPriv; // private for bsmenu
    IBandProxy      * _pbp;

    HPALETTE _hpalOld;          // the old palette saved while we do a draw.....

    int _GetIdealSize(PSIZE psize);

    HRESULT _IsPidlVisible(LPITEMIDLIST pidl);

    virtual LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW* pnmcd);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferedEffect);
    
    virtual void _CreateToolbar(HWND hwndParent);
    virtual HWND _CreatePager(HWND hwndParent);

    virtual int _GetBitmap(int iCommandID, PIBDATA pibData, BOOL fUseCache);
    virtual void _ToolbarChanged() { _BandInfoChanged(); };

    BOOL _IsChildID(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlChild);

    BOOL _UpdateIconSize(UINT fIconSize, BOOL fUpdateButtons);
    void _UpdateVerticalMode(BOOL fVertical);

    LRESULT _TryCascadingItem(LPCITEMIDLIST pidl, UINT uiCmd);
    LRESULT _TrySimpleInvoke(LPCITEMIDLIST pidl);

    HRESULT _SiteOnSelect(DWORD dwType);
    
    virtual HRESULT _GetTitleW(LPWSTR pwzTitle, DWORD cchSize);

    virtual void _Initialize();

    friend class CExtractImageTask;
    friend HRESULT CALLBACK UpdateBandLogo( LPVOID pData, DWORD dwItem, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );

    friend HRESULT FindBandInBandSite(IMenuPopup* pmpParent, IBandSite** ppbs, LPCITEMIDLIST pidl, REFIID riid, void** ppvOut);


    // stuff for CLogoBase
    virtual IShellFolder * GetSF();
    virtual HWND GetHWND();
    virtual REFTASKOWNERID GetTOID();
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HRESULT UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache );
    
    void _StopDelayPainting();
    void _FixupAppDataDirectory();
};

IMenuPopup* ISFBandCreateMenuPopup(IUnknown *punk, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
IMenuPopup* ISFBandCreateMenuPopup2(IUnknown *punk, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);

#define CGID_ISFBand CLSID_ISFBand

HRESULT CExtractImageTask_Create( CLogoBase* plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask );

#define EITF_SAVEBITMAP     0x00000001  // do not delete bitmap on destructor
#define EITF_ALWAYSCALL     0x00000002  // always call the update whether extract succeded or not

HRESULT IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\isfband.cpp ===
#include "priv.h"
#include <varutil.h>
#include "sccls.h"

#include "iface.h"
#include "itbar.h"
#include "itbdrop.h"
#include "bands.h"
#include "isfband.h"
#include "menubar.h"
#include "resource.h"
#include "menuisf.h"
#include "dpastuff.h"
#include "shlwapi.h"
#include "cobjsafe.h"
#include <iimgctx.h>
#include "uemapp.h"
#include "mnfolder.h"
#include "channel.h"
#include "browmenu.h"


#define DM_VERBOSE      0       // misc verbose traces
#define DM_PERSIST      0
#define TF_BANDDD   TF_BAND
#define DM_RENAME       0
#define DM_MISC         0       // miscellany

#define SZ_PROPERTIESA     "properties"
#define SZ_PROPERTIES      TEXT(SZ_PROPERTIESA)
#define SZ_REGKEY_ADVFOLDER        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced")

// {F47162A0-C18F-11d0-A3A5-00C04FD706EC}
static const GUID TOID_ExtractImage = { 0xf47162a0, 0xc18f, 0x11d0, { 0xa3, 0xa5, 0x0, 0xc0, 0x4f, 0xd7, 0x6, 0xec } };


#define SUPERCLASS CToolBand

HRESULT FakeGetUIObjectOf( IShellFolder *psf, LPCITEMIDLIST pidl, UINT * prgfFlags, REFIID riid, void **ppvObj );

extern UINT g_idFSNotify;

HRESULT CExtractImageTask_Create( CLogoBase *plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask );

class CExtractImageTask : public IRunnableTask
{
    public:
        STDMETHOD ( QueryInterface ) ( REFIID riid, void **ppvObj );
        STDMETHOD_( ULONG, AddRef ) ();
        STDMETHOD_( ULONG, Release ) ();

        STDMETHOD (Run)( void );
        STDMETHOD (Kill)( BOOL fWait );
        STDMETHOD (Suspend)( );
        STDMETHOD (Resume)( );
        STDMETHOD_( ULONG, IsRunning )( void );

    protected:

        CExtractImageTask( HRESULT * pHr,
                           CLogoBase *plb,
                           IExtractImage * pImage,
                           LPCWSTR pszCache,
                           DWORD dwItem,
                           int iIcon,
                           DWORD dwFlags );
        ~CExtractImageTask();
        HRESULT InternalResume();

    friend HRESULT CExtractImageTask_Create( CLogoBase* plb,
                                                 LPEXTRACTIMAGE pExtract,
                                                 LPCWSTR pszCache,
                                                 DWORD dwItem,
                                                 int iIcon,
                                                 DWORD dwFlags,
                                                 LPRUNNABLETASK * ppTask );

        LONG            m_cRef;
        LONG            m_lState;
        LPEXTRACTIMAGE  m_pExtract;
        LPRUNNABLETASK  m_pTask;
        WCHAR           m_szPath[MAX_PATH];
        DWORD           m_dwFlags;
        DWORD           m_dwItem;
        CLogoBase*      m_plb;
        HBITMAP         m_hBmp;
        int             m_iIcon;
};
//=================================================================
// Implementation of CISFBand
//=================================================================


CISFBand::CISFBand() : CToolbarBand()
{
    _fCanFocus = TRUE;
    _eUemLog = UEMIND_NIL;
    _dwPriv = -1;

    _fHasOrder = TRUE;  // ISFBand always has an order...
    _fAllowDropdown = BOOLIFY(SHRegGetBoolUSValue(SZ_REGKEY_ADVFOLDER, TEXT("CascadeFolderBands"),
                    FALSE,
                    FALSE)); 

    // Should we enable logging of arbirary events?
//    _pguidUEMGroup = &UEMIID_SHELL;
    ASSERT(_pguidUEMGroup == NULL);


    // Assert that this class is ZERO INITed.
    ASSERT(!_pbp);
    ASSERT(FALSE == _fCreatedBandProxy);
}


CISFBand::~CISFBand()
{
    if(_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);

    ATOMICRELEASE(_pbp);
}

HRESULT CISFBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres;
    CISFBand* pObj;

    hres = E_OUTOFMEMORY;

    pObj = new CISFBand();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IShellFolderBand*);
        hres = S_OK;
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: See CISFBand::Init for an explanation on the parameters.

*/
CISFBand* CISFBand_CreateEx(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    CISFBand * p = NULL;

    if (psf || pidl)
    {
        p = new CISFBand();
        if (p)
        {
            IShellFolderBand * psfband = SAFECAST(p, IShellFolderBand *);
            if (psfband && FAILED(psfband->InitializeSFB(psf, pidl)))
            {
                delete p;
                p = NULL;
            }
        }
    }
    return p;
}

#ifdef DEBUG
#define _AddRef(psz) { ++_cRef; TraceMsg(TF_SHDREF, "CDocObjectView(%x)::QI(%s) is AddRefing _cRef=%d", this, psz, _cRef); }
#else
#define _AddRef(psz)    ++_cRef
#endif

HRESULT CISFBand::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CISFBand, IShellFolderBand),
        QITABENT(CISFBand, IFolderBandPriv),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = CToolBand::QueryInterface(riid, ppvObj);

    if (FAILED(hres))
        hres = CSFToolbar::QueryInterface(riid, ppvObj);


    if (S_OK != hres)
    {
        // HACKHACK: this is yucko!
        if (IsEqualIID(riid, CLSID_ISFBand))
        {
            *ppvObj = (void*)this;
            _AddRef(TEXT("CLSID_ISFBand"));
            return S_OK;
        }
    }

    return hres;
}


#if 0
LPITEMIDLIST PidlFromFolderAndSubPath(int iFolder, TCHAR *pszSubPath)
{
    LPITEMIDLIST pidl = NULL;
    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, iFolder, &pidl))) {
        if (pszSubPath) {
            TCHAR szPath[MAX_PATH];
            SHGetPathFromIDList(pidl, szPath);
            PathCombine(szPath, szPath, pszSubPath);
            ILFree(pidl);
            pidl = ILCreateFromPath(szPath);
        }
    }
    return pidl;
}
#endif

//***   ILIsParentCSIDL -- like ILIsParent, but accepts a CSIDL_* for pidl1
// NOTES
//  TODO move to shlwapi (if/when idlist.c moves there)?
//
STDAPI_(BOOL) ILIsParentCSIDL(int csidl1, LPCITEMIDLIST pidl2, BOOL fImmediate)
{
    LPITEMIDLIST pidlSpec;
    BOOL fRet = FALSE;

    if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, csidl1, &pidlSpec))) {
        fRet = ILIsParent(pidlSpec, pidl2, fImmediate);
        ILFree(pidlSpec);
    }

    return fRet;
}

/*----------------------------------------------------------
Purpose: IShellFolderBand::InitializeSFB

         - supply IShellFolder with no PIDL if you want to view some
           ISF (either already instantiated from the filesystem or
           some non-filesystem ISF) that you do NOT want to receive
           notifies from (either from SHChangeNotify nor from
           IShellChangeNotify)

         - supply a PIDL with no IShellFolder for a full-blown band
           looking at a shell namespace (rooted on desktop) item.

*/
HRESULT CISFBand::InitializeSFB(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hres = S_OK;

    // Did they try to add the Recycle Bin? If so we need to reject it
    // for consistance reasons.  We also reject the Temp. Internet Files
    // for security reasons.
    if (pidl && (ILIsParentCSIDL(CSIDL_BITBUCKET, pidl, FALSE) ||
                ILIsParentCSIDL(CSIDL_INTERNET_CACHE, pidl, FALSE)))
    {
        // this will eventually show up as IDS_CANTISFBAND
        TraceMsg(DM_TRACE, "cib.isfb: recycle => E_INVALIDARG");
        hres = E_INVALIDARG;
    }

    if (SUCCEEDED(hres))
        hres = CSFToolbar::SetShellFolder(psf, pidl);
    if (SUCCEEDED(hres))
        _AfterLoad();

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellFolderBand::SetBandInfoSFB

*/
HRESULT CISFBand::SetBandInfoSFB(BANDINFOSFB * pbi)
{
    ASSERT(pbi);
    if (!pbi)
        return E_POINTER;

    if ((pbi->dwMask & ISFB_MASK_INVALID) ||
        (pbi->dwMask & ISFB_MASK_VIEWMODE) && (pbi->wViewMode & ~3))
        return E_INVALIDARG;

    // We don't handle ISFB_MASK_SHELLFOLDER and ISFB_MASK_IDLIST
    // in Set because there's a lot of work to resync pidl, psf, and
    // notifcations in the toolbar.  If somebody wants to do it,
    // more power to ya.  :)
    if (pbi->dwMask & (ISFB_MASK_SHELLFOLDER | ISFB_MASK_IDLIST))
        return E_INVALIDARG;

    if (pbi->dwMask & ISFB_MASK_STATE)
    {
        if (pbi->dwStateMask & ISFB_STATE_DEBOSSED)
            _fDebossed = BOOLIFY(pbi->dwState & ISFB_STATE_DEBOSSED);
        if (pbi->dwStateMask & ISFB_STATE_ALLOWRENAME)
            _fAllowRename = BOOLIFY(pbi->dwState & ISFB_STATE_ALLOWRENAME);
        if (pbi->dwStateMask & ISFB_STATE_NOSHOWTEXT)
            _fNoShowText = BOOLIFY(pbi->dwState & ISFB_STATE_NOSHOWTEXT);
        if (pbi->dwStateMask & ISFB_STATE_CHANNELBAR)
            _fChannels = BOOLIFY(pbi->dwState & ISFB_STATE_CHANNELBAR);
        /* ISFB_STATE_NOTITLE: removed 970619, use cbs::SetBandState */
        if (pbi->dwStateMask & ISFB_STATE_QLINKSMODE)
            _fLinksMode = BOOLIFY(pbi->dwState & ISFB_STATE_QLINKSMODE);
        if (pbi->dwStateMask & ISFB_STATE_FULLOPEN)
            _fFullOpen = BOOLIFY(pbi->dwState & ISFB_STATE_FULLOPEN);
        if (pbi->dwStateMask & ISFB_STATE_NONAMESORT)
            _fNoNameSort = BOOLIFY(pbi->dwState & ISFB_STATE_NONAMESORT);
        if (pbi->dwStateMask & ISFB_STATE_BTNMINSIZE)
            _fBtnMinSize = BOOLIFY(pbi->dwState & ISFB_STATE_BTNMINSIZE);
    }

    if (pbi->dwMask & ISFB_MASK_BKCOLOR)
    {
        _crBkgnd = pbi->crBkgnd;
        _fHaveBkColor = TRUE;
        if (EVAL(_hwndTB))
            SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_CUSTOMERASE, TBSTYLE_CUSTOMERASE);

        ASSERT(_hwnd);

        if (_hwndPager)
        {
            TraceMsg(TF_BAND, "cib.sbisfb: Pager_SetBkColor(_hwnd=%x crBkgnd=%x)", _hwnd, _crBkgnd);
            Pager_SetBkColor(_hwnd, _crBkgnd);
        }
    }

    // BUGBUG (kkahl): We don't support changing these once TB is created
    if (pbi->dwMask & ISFB_MASK_COLORS)
    {
        _crBtnLt = pbi->crBtnLt;
        _crBtnDk = pbi->crBtnDk;
        _fHaveColors = TRUE;
    }

    if (pbi->dwMask & ISFB_MASK_VIEWMODE)
    {
        _uIconSize = (pbi->wViewMode & 3); // stored in a 2-bit field currently...

        // only force no recalc if one of the recalcable fields was set
        _fNoRecalcDefaults = TRUE;
    }


    // If the bandsite queried us before, let it know the info may have changed
    if (_fInitialized)
        _BandInfoChanged();

    return S_OK;
}


/*----------------------------------------------------------
Purpose: IShellFolderBand::GetBandInfoSFB

*/
HRESULT CISFBand::GetBandInfoSFB(BANDINFOSFB * pbi)
{
    ASSERT(pbi);
    if (!pbi)
        return E_POINTER;

    if (pbi->dwMask & ISFB_MASK_STATE)
    {
        pbi->dwState = 0;
        pbi->dwStateMask = ISFB_STATE_ALL;

        if (_fDebossed)
            pbi->dwState |= ISFB_STATE_DEBOSSED;
        if (_fAllowRename)
            pbi->dwState |= ISFB_STATE_ALLOWRENAME;
        if (_fNoShowText)
            pbi->dwState |= ISFB_STATE_NOSHOWTEXT;
        if (_fLinksMode)
            pbi->dwState |= ISFB_STATE_QLINKSMODE;
        if (_fFullOpen)
            pbi->dwState |= ISFB_STATE_FULLOPEN;
        if (_fNoNameSort)
            pbi->dwState |= ISFB_STATE_NONAMESORT;
        if (_fBtnMinSize)
            pbi->dwState |= ISFB_STATE_BTNMINSIZE;
    }

    if (pbi->dwMask & ISFB_MASK_BKCOLOR)
    {
        pbi->crBkgnd = (_fHaveBkColor) ? _crBkgnd : CLR_DEFAULT;
    }

    if (pbi->dwMask & ISFB_MASK_COLORS)
    {
        if (_fHaveColors)
        {
            pbi->crBtnLt = _crBtnLt;
            pbi->crBtnDk = _crBtnDk;
        }
        else
        {
            pbi->crBtnLt = CLR_DEFAULT;
            pbi->crBtnDk = CLR_DEFAULT;
        }
    }

    if (pbi->dwMask & ISFB_MASK_VIEWMODE)
    {
        pbi->wViewMode = _uIconSize;
    }

    if (pbi->dwMask & ISFB_MASK_SHELLFOLDER)
    {
        pbi->psf = _psf;
        if (pbi->psf)
            pbi->psf->AddRef();
    }

    if (pbi->dwMask & ISFB_MASK_IDLIST)
    {
        if (_pidl)
            pbi->pidl = ILClone(_pidl);
        else
            pbi->pidl = NULL;
    }
    return S_OK;
}

// *** IInputObject methods ***
HRESULT CISFBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    if (SendMessage(_hwnd, TB_TRANSLATEACCELERATOR, 0, (LPARAM)lpMsg))
        return S_OK;

    return SUPERCLASS::TranslateAcceleratorIO(lpMsg);
}

void CISFBand::_SetCacheMenuPopup(IMenuPopup* pmp)
{
    if (!SHIsSameObject(pmp, _pmpCache)) {
        _ReleaseMenuPopup(&_pmpCache);
        _pmpCache = pmp;
        if (_pmpCache)
            _pmpCache->AddRef();
    }
}


void CISFBand::_ReleaseMenuPopup(IMenuPopup** ppmp)
{
    IUnknown_SetSite(*ppmp, NULL);
    ATOMICRELEASE(*ppmp);
}

/*----------------------------------------------------------
Purpose: Releases the held menu popup.

*/
void CISFBand::_ReleaseMenu()
{
    if (!SHIsSameObject(_pmp, _pmpCache)) {
        TraceMsg(TF_MENUBAND, "Releasing pmp %#lx", _pmp);
        _ReleaseMenuPopup(&_pmp);
    } else
        ATOMICRELEASE(_pmp);
}

//***
// ENTRY/EXIT
//  S_OK        desktop browser
//  S_FALSE     other browser (explorer, OC, etc.)
//  E_xxx       not a browser at all (e.g. band asking tray)
HRESULT IsDesktopBrowser(IUnknown *punkSite)
{
    HRESULT hr;
    IServiceProvider *psp;
    IUnknown *punk;

    hr = E_FAIL;
    if (SUCCEEDED(IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_IServiceProvider, (void**)&psp))) {
        hr = S_FALSE;
        if (SUCCEEDED(psp->QueryInterface(SID_SShellDesktop, (void**)&punk))) {
            hr = S_OK;
            punk->Release();
        }
        psp->Release();
    }

    TraceMsg(DM_VERBOSE, "idb: ret hrDesk=%x (0=dt 1=sh e=!brow)", hr);
    return hr;
}


/*----------------------------------------------------------
Purpose: IDockingWindow::SetSite method.

*/
HRESULT CISFBand::SetSite(IUnknown* punkSite)
{
    _ReleaseMenu();

    SUPERCLASS::SetSite(punkSite);

    if (_punkSite)
    {
        if (!_hwndTB)
            _CreateToolbar(_hwndParent);

        IUnknown_SetOwner(_psf, SAFECAST(this, IDeskBand*));

        _Initialize();  // BUGBUG always or just on 1st SetSite?
    }
    else
        IUnknown_SetOwner(_psf, NULL);


    // BUGBUG: the below is bogus - no need to throw away and recreate.

    // First destroy the band proxy

    // Call SetSite(NULL) only if you own
    // if not, it's the parent from whom you got it via QS who will call SetSite(NULL)

    if(_pbp && _fCreatedBandProxy)
        _pbp->SetSite(NULL);

    ATOMICRELEASE(_pbp);
    _fCreatedBandProxy = FALSE;
    // Need a bandproxy
    QueryService_SID_IBandProxy(punkSite, IID_IBandProxy, &_pbp, NULL);
    if(!_pbp)
    {
        // We need to create it ourselves since our parent couldn't help
        ASSERT(FALSE == _fCreatedBandProxy);
        HRESULT hres;
        hres = CreateIBandProxyAndSetSite(punkSite, IID_IBandProxy, &_pbp, NULL);
        if(_pbp)
        {
            ASSERT(S_OK == hres);
            _fCreatedBandProxy = TRUE;
        }
    }

    ASSERT(_pbp);
    return S_OK;
}

void CISFBand::_Initialize()
{
    _fDesktop = (IsDesktopBrowser(_punkSite) == S_OK);

    return;
}


/*----------------------------------------------------------
Purpose: IDockingWindow::CloseDW method.

*/
HRESULT CISFBand::CloseDW(DWORD dw)
{
    _fClosing = TRUE;

    // close down the task scheduler ...
    if ( _pTaskScheduler )
        ATOMICRELEASE( _pTaskScheduler );

    _UnregisterToolbar();
    EmptyToolbar();

    IUnknown_SetOwner(_psf, NULL);
    _SetCacheMenuPopup(NULL);

    // should get freed in EmptyToolbar();
    ASSERT(!_hdpa);

    return SUPERCLASS::CloseDW(dw);
}


/*----------------------------------------------------------
Purpose: IDockingWindow::ShowDW method

*/
HRESULT CISFBand::ShowDW(BOOL fShow)
{
    HRESULT hres = S_OK;

    SUPERCLASS::ShowDW(fShow);

    if (fShow)
    {
        _fShow = TRUE;

        if (_fDirty)
        {
            _FillToolbar();
        }

        if (!_fDelayInit)
        {
            _RegisterToolbar();
        }
    }
    else
    {
        _fShow = FALSE;
    }

    return hres;
}

void CISFBand::_StopDelayPainting()
{
    if (_fDelayPainting) {
        _fDelayPainting = FALSE;
        // May be called by background thread
        // Use PostMessage instead of SendMessage to avoid deadlock
        PostMessage(_hwndTB, WM_SETREDRAW, TRUE, 0);
        if (_hwndPager)
            PostMessage(_hwnd, PGM_RECALCSIZE, 0L, 0L);
    }
}

HWND CISFBand::_CreatePager(HWND hwndParent)
{
    // don't create a pager for isfbands
    return hwndParent;
}

void CISFBand::_CreateToolbar(HWND hwndParent)
{
    if (_fHaveBkColor)
        _dwStyle |= TBSTYLE_CUSTOMERASE;
    CSFToolbar::_CreateToolbar(hwndParent);
    if ( _fHaveBkColor )
        ToolBar_SetInsertMarkColor(_hwndTB, GetSysColor( COLOR_BTNFACE ));

    ASSERT(_hwndTB);

    SendMessage(_hwndTB, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);

    if(_fChannels)
    {
        SHSetWindowBits(_hwndTB, GWL_EXSTYLE, dwExStyleRTLMirrorWnd, 0);        
    }    

    _hwnd = _hwndPager ? _hwndPager : _hwndTB;

    if (_fHaveColors)
    {
        COLORSCHEME cs;

        cs.dwSize = SIZEOF(cs);
        cs.clrBtnHighlight  = _crBtnLt;
        cs.clrBtnShadow     = _crBtnDk;
        SendMessage(_hwndTB, TB_SETCOLORSCHEME, 0, (LPARAM) &cs);
    }
}

int CISFBand::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iBitmap;
    if ( _uIconSize == ISFBVIEWMODE_LOGOS )
    {
        LPRUNNABLETASK pTask = NULL;
        DWORD dwPriority = 0;
        // fetch the logo instead...
        ASSERT(!_fDelayPainting);
       // Warning - cannot hold ptask in a member variable - it will be a circular reference
        iBitmap = GetLogoIndex( iCommandID, pibdata->GetPidl(), &pTask, &dwPriority, NULL );
        if (pTask)
        {
            AddTaskToQueue(pTask, dwPriority, (DWORD)iCommandID);
            ATOMICRELEASE(pTask);
        }
    }
    else
        iBitmap = CSFToolbar::_GetBitmap(iCommandID, pibdata, fUseCache);

    return iBitmap;
}

void CISFBand::_SetDirty(BOOL fDirty)
{
    CSFToolbar::_SetDirty(fDirty);

    if (fDirty)
        IUnknown_Exec(_punkSite, &CGID_PrivCITCommands, CITIDM_SET_DIRTYBIT, TRUE, NULL, NULL);
}

BOOL CISFBand::_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    BOOL fChanged = (_uIconSize != uIconSize);

    _uIconSize = uIconSize;
    HIMAGELIST himl = NULL;

    if ( uIconSize == ISFBVIEWMODE_LOGOS )
    {
        if ( SUCCEEDED( InitLogoView()))
        {
            himl = GetLogoHIML();
        }
        if ( himl )
        {
            SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);

            _UpdateButtons();
        }
    }

    if ( !himl )
        fChanged |= CSFToolbar::_UpdateIconSize(uIconSize,fUpdateButtons);
    return fChanged;
}

void CISFBand::_UpdateVerticalMode(BOOL fVertical)
{
    _fVertical = (fVertical != 0);

    TraceMsg(TF_BAND, "ISFBand::_UpdateVerticalMode going %hs", _fVertical ? "VERTICAL" : "HORIZONTAL");

    ASSERT(_hwnd);

    if (_hwndPager) {
        SHSetWindowBits(_hwnd, GWL_STYLE, PGS_HORZ|PGS_VERT,
            _fVertical ? PGS_VERT : PGS_HORZ);
    }

    if (_hwndTB)
    {
        SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_WRAPABLE | CCS_VERT,
            TBSTYLE_WRAPABLE | (_fVertical ? CCS_VERT : 0));
    }
}

HRESULT IUnknown_QueryBand(IUnknown *punk, DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    HRESULT hr;
    IBandSite *pbs;

    hr = punk->QueryInterface(IID_IBandSite, (void**)&pbs);
    if (SUCCEEDED(hr)) {
        hr = pbs->QueryBand(dwBandID, ppstb, pdwState, pszName, cchName);
        pbs->Release();
    }
    return hr;
}

#define CISFBAND_GETBUTTONSIZE()  (_hwndTB ?  (LONG)SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0L) : MAKELONG(16, 16))

//
// _GetIdealSize
//
// calculates ideal height and width for band and passes back in
// psize, if psize isn't NULL; return value is band's 'ideal length'
// (ideal height if vertical, else ideal width)
//
int CISFBand::_GetIdealSize(PSIZE psize)
{
    SIZE size;
    LONG lButtonSize = CISFBAND_GETBUTTONSIZE();
    RECT rc = {0};
    if (_hwndTB)
        GetClientRect(_hwndTB, &rc);

    if (_fVertical)
    {
        // set width to be max of toolbar width and toolbar button width
        size.cx = max(RECTWIDTH(rc), LOWORD(lButtonSize));
        // have toolbar calculate height given that width
        SendMessage(_hwndTB, TB_GETIDEALSIZE, TRUE, (LPARAM)&size);
    }
    else
    {
        // set height to be max of toolbar width and toolbar button width
        size.cy = max(RECTHEIGHT(rc), HIWORD(lButtonSize));
        // have toolbar calculate width given that height
        SendMessage(_hwndTB, TB_GETIDEALSIZE, FALSE, (LPARAM)&size);
    }

    // BUGBUG: I'm ripping out this check as it causes nt5 bug #225449 (disappearing chevron).
    // _fDirty == TRUE doesn't mean "we're still waiting to call _FillToolbar", it just means
    // "we need to persist out this order stream".  The bit gets set after a drag-and-drop
    // reordering, but we don't call a matching _FillToolbar in that case.
#if 0
    if (_fDirty)
    {
        // until the TB is populated, we get back bogus data from the
        // above.  so use -1 until we actually have a correct answer.
        size.cx = size.cy = -1;
    }
#endif

    if (psize)
        *psize = size;
    return _fVertical ? size.cy : size.cx;
}

/*----------------------------------------------------------
Purpose: IDeskBand::GetBandInfo method

*/

HRESULT CISFBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode,
                              DESKBANDINFO* pdbi)
{
    HRESULT hr = S_OK;

    _dwBandID = dwBandID;
    // We don't know the default icon size until GetBandInfo is called.
    // After we set the default, we pay attention to the context menu.
    //
    if (!_fNoRecalcDefaults)
    {
        _uIconSize = (fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL)) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
        _fNoRecalcDefaults = TRUE;
    }

    if (!_fInitialized) {
        _fInitialized = TRUE;
        _UpdateIconSize(_uIconSize, FALSE);
        _UpdateShowText(_fNoShowText);
    }

    // we treat floating the same as vertical
    _UpdateVerticalMode(fViewMode & (DBIF_VIEWMODE_FLOATING |DBIF_VIEWMODE_VERTICAL));

    LONG lButtonSize = CISFBAND_GETBUTTONSIZE();

    pdbi->dwModeFlags = DBIMF_VARIABLEHEIGHT | DBIMF_USECHEVRON;
    if (_fDebossed)
        pdbi->dwModeFlags |= DBIMF_DEBOSSED;

    pdbi->ptMinSize.x = 0;
    pdbi->ptMaxSize.y = 32000; // random
    pdbi->ptIntegral.y = 1;
    pdbi->ptIntegral.x = 1;

    if (!_fFullOpen)
        _iIdealLength = _GetIdealSize((PSIZE)&pdbi->ptActual);

    // CalcMinWidthHeight {
    // BUGBUG need pager msg for cx/cy scroll
    #define g_cxScrollbar   (GetSystemMetrics(SM_CXVSCROLL) * 3 / 4)
    #define g_cyScrollbar   (GetSystemMetrics(SM_CYVSCROLL) * 3 / 4)
    #define CX_TBBUTTON_MAX (16 + CX_FILENAME_AVG)  // button + name
    #define CY_TBBUTTON_MAX (16)                    // button

    int csBut, csButMin, clBut, clButMin, clScroll;

    // set up short/long aliases
    if (_fVertical) {
        csBut = LOWORD(lButtonSize);
        if (_fBtnMinSize)
            csButMin = min(csBut, CX_TBBUTTON_MAX);
        else
            csButMin = 0;   // people like to shrink things way down, so let 'em

        clBut = HIWORD(lButtonSize);
        clButMin = clBut;
        //ASSERT(min(clBut, CY_TBBUTTON_MAX) == clButMin);  // fails!

        clScroll = g_cyScrollbar;
    }
    else {
        csBut = HIWORD(lButtonSize);
        csButMin = csBut;
        //ASSERT(min(csBut, CY_TBBUTTON_MAX) == csButMin);  // fails!

        clBut = LOWORD(lButtonSize);
        clButMin = min(clBut, CX_TBBUTTON_MAX);

        clScroll = g_cxScrollbar;

        // nt5:176448: integral for horz
        //pdbi->ptIntegral.y = csBut;   this is the cause for 287082 and 341592
    }

    // n.b. virt pdbi->pt.x,y is really phys y,x (i.e. phys long,short)
    pdbi->ptMinSize.x = 0;
    pdbi->ptMinSize.y = csButMin;

    DWORD dwState = BSSF_NOTITLE;
    IUnknown_QueryBand(_punkSite, dwBandID, NULL, &dwState, NULL, 0);
    if (dwState & BSSF_NOTITLE) {   // _fNoTitle
        int i, cBut, clTmp;

        // cbut=    text    notext
        // horz     1       4
        // vert     1       1
        cBut = 1;
        if (!_fVertical && _fNoShowText) {
            // special-case for QLaunch so see several buttons
            cBut = 4;   // for both QLaunch and arbitrary ISF band
        }

        pdbi->ptMinSize.x = cBut * clButMin;

        if (_hwndPager) {
            // tack on extra space for pager arrows
            pdbi->ptMinSize.x += 2 * clScroll;
        }

        i = (int)SendMessage(_hwndTB, TB_BUTTONCOUNT, 0, 0);
        if (i <= cBut) {
            clTmp = i * clBut;
            if (clTmp < pdbi->ptMinSize.x) {
                // scrollbars take as much space as button would
                // so just do the button
                pdbi->ptMinSize.x = clTmp;
            }
        }
    }
    // }

#if 0 // BUGBUG don't we need this?
    if (_fHaveBkColor) {
        pdbi->crBkgnd = _crBkgnd;
        pdbi->dwModeFlags |= DBIMF_BKCOLOR;
    }
#endif

    hr = _GetTitleW(pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    if (FAILED(hr))
    {
        // we don't support title
#ifdef DEBUG
        if (pdbi->dwMask & DBIM_TITLE)
            TraceMsg(DM_VERBOSE, "cisfb.gbi: patch ~DBIM_TITLE");
#endif
        pdbi->dwMask &= ~DBIM_TITLE;
    }

    return hr;
}

LRESULT CISFBand::_OnCustomDraw(NMCUSTOMDRAW* pnmcd)
{
    NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
    LRESULT lres = CDRF_DODEFAULT;

    switch (pnmcd->dwDrawStage)
    {
    case CDDS_PREPAINT:
        // if there is a palette, then quietly select it into the DC ...
        if ( _hpalHalftone && _uIconSize == ISFBVIEWMODE_LOGOS )
        {
            ASSERT( pnmcd->hdc );
            _hpalOld = SelectPalette( pnmcd->hdc, _hpalHalftone, TRUE );
            // LINTASSERT(_hpalOld || !_hpalOld);   // 0 semi-ok for SelectPalette
            RealizePalette( pnmcd->hdc );
        }

        // make sure we get the postpaint as well so we can de-select the palette...
        lres = CDRF_NOTIFYPOSTPAINT;
        break;

    case CDDS_POSTPAINT:
        // if there is a palette, then quietly select it into the DC ...
        if ( _hpalHalftone && _uIconSize == ISFBVIEWMODE_LOGOS )
        {
            ASSERT( pnmcd->hdc );
            (void) SelectPalette( pnmcd->hdc, _hpalOld, TRUE );
            // we don't need a realize here, we can keep the other palette realzied, we
            // re select the old palette above, otherwise we bleed the resource....
            // RealizePalette( pnmcd->hdc );
        }
        break;

    case CDDS_PREERASE:
        if (_fHaveBkColor)
        {
            RECT rcClient;
            GetClientRect(_hwndTB, &rcClient);
            SHFillRectClr(pnmcd->hdc, &rcClient, _crBkgnd);
            lres = CDRF_SKIPDEFAULT;
        }
        break;
    }

    return lres;
}

void CISFBand::_OnDragBegin(int iItem, DWORD dwPreferedEffect)
{
    LPCITEMIDLIST pidl = _IDToPidl(iItem, &_iDragSource);
    ToolBar_MarkButton(_hwndTB, iItem, TRUE);

    DragDrop(_hwnd, _psf, pidl, dwPreferedEffect, NULL);

    ToolBar_MarkButton(_hwndTB, iItem, FALSE);
    _iDragSource = -1;
}

LRESULT CISFBand::_OnHotItemChange(NMTBHOTITEM * pnm)
{
    LPNMTBHOTITEM  lpnmhi = (LPNMTBHOTITEM)pnm;
    LRESULT lres = 0;

    if (_hwndPager && (lpnmhi->dwFlags & HICF_ARROWKEYS))
    {
        int iOldPos, iNewPos;
        RECT rc, rcPager;
        int heightPager;

        int iSelected = lpnmhi->idNew;
        iOldPos = (int)SendMessage(_hwnd, PGM_GETPOS, (WPARAM)0, (LPARAM)0);
        iNewPos = iOldPos;
        SendMessage(_hwndTB, TB_GETITEMRECT, (WPARAM)iSelected, (LPARAM)&rc);

        if (rc.top < iOldPos)
        {
             iNewPos =rc.top;
        }

        GetClientRect(_hwnd, &rcPager);
        heightPager = RECTHEIGHT(rcPager);

        if (rc.top >= iOldPos + heightPager)
        {
             iNewPos += (rc.bottom - (iOldPos + heightPager)) ;
        }

        if (iNewPos != iOldPos)
            SendMessage(_hwnd, PGM_SETPOS, (WPARAM)0, (LPARAM)iNewPos);
    }
    else
    {
        lres = CToolbarBand::_OnHotItemChange(pnm);
    }

    return lres;
}

LRESULT CISFBand::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;
    switch (pnm->code)
    {
    case TBN_DROPDOWN:
        {
            LPNMTOOLBAR pnmtb = (LPNMTOOLBAR)pnm;
            lres = TBDDRET_DEFAULT;
            _DropdownItem(_IDToPidl(pnmtb->iItem), pnmtb->iItem);
        }
        break;

    default:
        lres = CSFToolbar::_OnNotify(pnm);
    }

    return lres;
}


HRESULT CISFBand::_TBStyleForPidl(LPCITEMIDLIST pidl, 
                               DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon)
{
    HRESULT hres = CSFToolbar::_TBStyleForPidl(pidl, pdwTBStyle, pdwTBState, pdwMIFFlags, piIcon);

    if (_fAllowDropdown &&
        !_fCascadeFolder && 
        ((_GetAttributesOfPidl(pidl, SFGAO_FOLDER) & SFGAO_FOLDER) ||
         IsBrowsableShellExt(pidl)))
    {
        *pdwTBStyle &= ~BTNS_BUTTON;
        *pdwTBStyle |= BTNS_DROPDOWN;
    }
    return hres;
}

LRESULT CISFBand::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    lres = CSFToolbar::_OnContextMenu(wParam, lParam);

    // todo: csidl?
    TraceMsg(DM_MISC, "cib._ocm: _dwPriv=%d", _dwPriv);
    UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UICONTEXT, (_dwPriv == CSIDL_APPDATA || _dwPriv == CSIDL_FAVORITES) ? UIBL_CTXTQCUTITEM : UIBL_CTXTISFITEM);

    return lres;
}

LRESULT CISFBand::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
    case WM_SIZE:
        // forward to toolbar
        SendMessage(_hwndTB, TB_AUTOSIZE, wParam, lParam);

        if (_GetIdealSize(NULL) != _iIdealLength) {
            // our ideal size has changed since the last time bandsite
            // asked; so tell bandsite ask us for our bandinfo again
            _BandInfoChanged();
        }
        return 0;
    }
    return CSFToolbar::_DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/*----------------------------------------------------------
Purpose: Set the given IMenuPopup as the submenu to expand.  Returns
         S_FALSE if the menu was modal, S_OK if it was modeless, or
         failure.

*/
HRESULT CISFBand::_SetSubMenuPopup(IMenuPopup* pmp, UINT uiCmd, LPCITEMIDLIST pidl, DWORD dwFlagsMPPF)
{
    HRESULT hres = E_FAIL;

    _ReleaseMenu();

    _pmp = pmp;

    if (pmp) {

        pmp->AddRef();

        RECT rc;
        POINT pt;

        SendMessage(_hwndTB, TB_GETRECT, uiCmd, (LPARAM)&rc);
        MapWindowPoints(_hwndTB, HWND_DESKTOP, (POINT*)&rc, 2);

        // Align the sub menu appropriately
        if (_fVertical) {
            pt.x = rc.right;
            pt.y = rc.top;
        } else {
            pt.x = rc.left;
            pt.y = rc.bottom;
        }

        //
        // Use a reflect point for the sub-menu to start
        // if the window is RTL mirrored. [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(_hwndTB)) {
            pt.x = (_fVertical) ? rc.left : rc.right;
        }

        // Tell the sub menu deskbar who we are, so it can
        // inform us later when the user navigates out of
        // its scope.
        IUnknown_SetSite(_pmp, SAFECAST(this, IDeskBand*));

        // This must be called after SetSite is done above
        _SendInitMenuPopup(pmp, pidl);

        // Show the menubar
        hres = _pmp->Popup((POINTL*)&pt, (RECTL*)&rc, dwFlagsMPPF);
    }
    return hres;
}

void CISFBand::_SendInitMenuPopup(IMenuPopup * pmp, LPCITEMIDLIST pidl)
{
}

IMenuPopup* ISFBandCreateMenuPopup(IUnknown *punk, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand)
{
    return ISFBandCreateMenuPopup2(punk, NULL, psf, pidl, pbi, bMenuBand);
}


IMenuPopup* ISFBandCreateMenuPopup2(IUnknown *punk, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand)
{
    IMenuPopup* pmpParent = NULL;
    VARIANTARG v = {0};
    BOOL fUseCache = FALSE;

    if (punk && pidl) {
        fUseCache = TRUE;
        IUnknown_Exec(punk, &CGID_ISFBand, ISFBID_CACHEPOPUP, 0, NULL, &v);
        if (v.vt == VT_UNKNOWN && v.punkVal)
            v.punkVal->QueryInterface(IID_IMenuPopup, (void **)&pmpParent);
    }

    IMenuPopup * pmp = CreateMenuPopup2(pmpParent, pmb, psf, pidl, pbi, bMenuBand);

    if (fUseCache) {
        // cache it now

        // clear from the variant above to release v.punkVal of pmpParent
        VariantClear(&v);

        if (pmp) {
            VariantInit(&v);
            v.vt = VT_UNKNOWN;
            v.punkVal = pmp;
            pmp->AddRef();
            IUnknown_Exec(punk, &CGID_ISFBand, ISFBID_CACHEPOPUP, 0, &v, NULL);
            VariantClear(&v);
        }
    }

    ATOMICRELEASE(pmpParent);
    return pmp;
}


IMenuPopup * CISFBand::_CreateMenuPopup(
    IShellFolder * psfChild,
    LPCITEMIDLIST  pidlFull,
    BANDINFOSFB *  pbi)
{
    return ISFBandCreateMenuPopup(SAFECAST(this, IOleCommandTarget*), psfChild, pidlFull, pbi, FALSE);
}

HRESULT CISFBand::_DropdownItem(LPCITEMIDLIST pidl, UINT idCmd)
{
    HRESULT hres = E_FAIL;
    if (_pidl && _psf)
    {
        LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);

        if (pidlFull)
        {
            IShellFolder* psf;

            if (SUCCEEDED(_psf->BindToObject(pidl, NULL, IID_IShellFolder, (void **)&psf)))
            {
                RECT rc;
                SendMessage(_hwndTB, TB_GETRECT, idCmd, (LPARAM)&rc);
                MapWindowPoints(_hwndTB, HWND_DESKTOP, (POINT*)&rc, 2);

                ITrackShellMenu* ptsm;
                if (SUCCEEDED(CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER,
                    IID_ITrackShellMenu, (void**)&ptsm)))
                {
                    CFavoritesCallback *pfcb = new CFavoritesCallback();
                    if(pfcb) {
                        ptsm->Initialize(pfcb, 0, 0, SMINIT_TOPLEVEL | SMINIT_VERTICAL|SMINIT_NOSETSITE);
                        pfcb->SetSite(_punkSite);
                    }
                    else 
                        ptsm->Initialize(NULL, 0, 0, SMINIT_TOPLEVEL | SMINIT_VERTICAL);


                    if (SUCCEEDED(ptsm->SetShellFolder(psf, pidlFull, NULL, SMSET_TOP | SMSET_USEBKICONEXTRACTION)))
                    {
                        POINTL pt = {rc.left, rc.right};
                        hres = ptsm->Popup(_hwndTB, &pt, (RECTL*)&rc, MPPF_BOTTOM);
                    }
                    if(pfcb)
                        pfcb->Release();

                    ptsm->Release();
                }
                psf->Release();
            }

            ILFree(pidlFull);
        }
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: Try treating the pidl as a cascading menu item.

Returns: non-zero if succeeded
*/
LRESULT CISFBand::_TryCascadingItem(LPCITEMIDLIST pidl, UINT uiCmd)
{
    LRESULT lRet = 0;

    // Do we cascade to another submenu?
    if ((GetKeyState(VK_CONTROL) < 0) || _fCascadeFolder)
    {
        // Is the item a browsable folder?
        if ((_GetAttributesOfPidl(pidl, SFGAO_FOLDER) & SFGAO_FOLDER) ||
            IsBrowsableShellExt(pidl))
        {
            // Yes; cascade the browsable folder as a submenu
            lRet = (S_OK == _DropdownItem(pidl, uiCmd));
        }
    }

    return lRet;
}

/*----------------------------------------------------------
Purpose: Try just invoking the pidl

Returns: non-zero if succeeded
*/
LRESULT CISFBand::_TrySimpleInvoke(LPCITEMIDLIST pidl)
{
    LRESULT lRet = 0;

    if (S_OK == _pbp->IsConnected())    // Force IE
    {
        LPITEMIDLIST pidlDest;

        if (SUCCEEDED(SHGetNavigateTarget(_psf, pidl, &pidlDest, NULL)) && pidlDest &&
            ILIsWeb(pidlDest))
        {

            TCHAR szPath[MAX_PATH];

            // We want to ensure that we first give NavFrameWithFile a chance
            // since this will do the right thing if the PIDL points to a
            // shortcut.
            // If the PIDL is a shortcut, NavFrameWithFile will restore any
            // persistence information stored in the shortcut
            // if that fails - we take the default code path that simply
            // uses the PIDL
            lRet = SUCCEEDED(GetPathForItem(_psf, pidl, szPath, NULL)) &&
                   SUCCEEDED(NavFrameWithFile(szPath, (IServiceProvider *)this));

            if (!lRet)
            {
                if (EVAL(_pbp) && (SUCCEEDED(_pbp->NavigateToPIDL(pidlDest))))
                    lRet = 1;
            }
            ILFree(pidlDest);
        }
    }

    if (!lRet)
    {
        IContextMenu *pcm = (LPCONTEXTMENU)_GetUIObjectOfPidl(pidl, IID_IContextMenu);
        if (pcm)
        {
            LPCSTR pVerb = NULL;
            UINT fFlags = 0;

            // If ALT double click, accelerator for "Properties..."
            if (GetKeyState(VK_MENU) < 0)
            {
                pVerb = SZ_PROPERTIESA;
            }

            //
            //  SHIFT+dblclick does a Explore by default
            //
            if (GetKeyState(VK_SHIFT) < 0)
            {
                fFlags |= CMF_EXPLORE;
            }

            IContextMenu_Invoke(pcm, _hwndTB, pVerb, fFlags);

            pcm->Release();
        }
    }

    return lRet;
}


/*----------------------------------------------------------
Purpose: Helper function to call the menubar site's IMenuPopup::OnSelect
         method.

*/
HRESULT CISFBand::_SiteOnSelect(DWORD dwType)
{
    IMenuPopup * pmp;
    HRESULT hres = IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_IMenuPopup, (void **)&pmp);
    if (SUCCEEDED(hres))
    {
        pmp->OnSelect(dwType);
        pmp->Release();
    }
    return hres;
}

LRESULT CISFBand::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uiCmd = GET_WM_COMMAND_ID(wParam, lParam);
    LRESULT lres = 0;

    TraceMsg(TF_BAND, "_OnCommand 0x%x", uiCmd);

    LPCITEMIDLIST pidl = _IDToPidl(uiCmd);

    if (pidl)
    {
        if (_eUemLog != UEMIND_NIL) 
        {
            // FEATURE_UASSIST should be grp,uiCmd
            UEMFireEvent(&UEMIID_SHELL, UEME_UIQCUT, UEMF_XEVENT, -1, (LPARAM)-1);
        }

        // Only do this if we are the quick links in the browser. The derived class will set this
        if (_pguidUEMGroup)
        {
            LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);
            if (pidlFull)
            {
                UEMFireEvent(_pguidUEMGroup, UEME_RUNPIDL, UEMF_XEVENT, (WPARAM)_psf, (LPARAM)pidl);
                SHSendChangeMenuNotify(NULL, SHCNEE_PROMOTEDITEM, 0, pidlFull);
                ILFree(pidlFull);
            }
        }

        lres = _TryCascadingItem(pidl, uiCmd);

        if (!lres && _fChannels)
            lres = _TryChannelSurfing(pidl);

        if (!lres)
            lres = _TrySimpleInvoke(pidl);
    }
    else
    {
        MessageBeep(MB_OK);
    }

    return(lres);
}

// *** IPersistStream
//

HRESULT CISFBand::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_ISFBand;
    return S_OK;
}

//
//  This might be a directory inside CSIDL_APPDATA that was created on
//  a Win9x machine.  Win9x doesn't do the special folder signature info,
//  so when it shows up on NT, it's just a boring directory that now points
//  to the wrong place.
//
//  So if we get a bad directory, see if it's one of these corrupted
//  Win9x pidls and if so, try to reconstitute the original CSIDL_APPDATA
//  by searching for "Application Data".
//

void CISFBand::_FixupAppDataDirectory()
{
    TCHAR szDirPath[MAX_PATH];

    //  We use PathFileExists to check for existence because it turns off
    //  hard error boxes if the target is not available (e.g., floppy not
    //  in drive)

    if (SHGetPathFromIDList(_pidl, szDirPath) &&
        !PathFileExists(szDirPath))
    {
        static TCHAR szBSAppData[] = TEXT("\\Application Data");
        LPTSTR pszAppData;

        // For every instance of "Application Data", try to graft it
        // into the real CSIDL_APPDATA. If it works, run with it.

        for (pszAppData = szDirPath;
             pszAppData = StrStrI(pszAppData, szBSAppData);
             pszAppData++)
        {
            // Found a candidate.  The thing after "\\Application Data"
            // had better be another backslash (in which case we step
            // over it) or the end of the string (in which case we don't).

            TCHAR szPathBuffer[MAX_PATH];
            LPTSTR pszTail = pszAppData + ARRAYSIZE(szBSAppData) - 1;

            // If we did our math right, we should be right after the
            // "a" at the end of "Application Data".
            ASSERT(pszTail[-1] == TEXT('a'));

            if (pszTail[0] == TEXT('\\'))
                pszTail++;              // Step over separator
            else if (pszTail[0] == TEXT('\0'))
                { }                     // at end of string; stay there
            else
                continue;               // we were faked out; keep looking

            if (SHGetSpecialFolderPath(NULL, szPathBuffer, CSIDL_APPDATA, FALSE))
            {
                PathCombine(szPathBuffer, szPathBuffer, pszTail);
                if (PathFileExists(szPathBuffer))
                {
                    LPITEMIDLIST    pidlReal;
                    pidlReal = ILCreateFromPath(szPathBuffer);
                    if (pidlReal)
                    {
                        ILFree(_pidl);
                        _pidl = pidlReal;
                    }
                    ASSERT(_pidl);
                    break;              // found it; stop looking
                }
            }
        }
    }
}

typedef struct tagBANDISFSTREAM {
    WORD        wVersion;   // version of this structure
    WORD        cbSize;     // size of this structure
    DWORD       dwFlags;    // BANDISF_ flags
    DWORD       dwPriv;     // special folder identifier
    WORD        wViewMode;  // small/large/logo
    WORD        wUnused;    // For DWORD alignment
    COLORREF    crBkgnd;    // band background color
    COLORREF    crBtnLt;    // band button hilite color
    COLORREF    crBtnDk;    // band button lolite color
} BANDISFSTREAM, * PBANDISFSTREAM;

#define BANDISF_VERSION 0x22

#define BANDISF_MASK_PSF         0x00000001 // TRUE if _psf is saved
#define BANDISF_BOOL_NOSHOWTEXT  0x00000002 // TRUE if _fNoShowText
#define BANDISF_BOOL_LARGEICON   0x00000004 // last used in version 0x20
#define BANDISF_MASK_PIDLASLINK  0x00000008 // TRUE if _pidl is saved as a link
#define BANDISF_UNUSED10         0x00000010 // (obsolete) was BOOL_NOTITLE
#define BANDISF_BOOL_CHANNELS    0x00000020 // TRUE if in channel mode
#define BANDISF_BOOL_ALLOWRENAME 0x00000040 // TRUE if _psf context menu should be enabled
#define BANDISF_BOOL_DEBOSSED    0x00000080 // TRUE if band should have embossed background
#define BANDISF_MASK_ORDERLIST   0x00000100 // TRUE if an order list is saved
#define BANDISF_BOOL_BKCOLOR     0x00000200 // TRUE if bk color is persisted
#define BANDISF_BOOL_FULLOPEN    0x00000400 // TRUE if band should maximize when opened
#define BANDISF_BOOL_NONAMESORT  0x00000800 // TRUE if band should _not_ sort icons by name
#define BANDISF_BOOL_BTNMINSIZE  0x00001000 // TRUE if band should report min thickness of button
#define BANDISF_BOOL_COLORS      0x00002000 // TRUE if colors are persisted
#define BANDISF_VALIDBITS        0x00003FFF

HRESULT CISFBand::Load(IStream *pstm)
{
    HRESULT hres;
    DWORD cbRead;
    BANDISFSTREAM bisfs = {0};

    // figure out what we need to load
    //
    // read first DWORD only (old stream format started with ONE dword)
    hres = pstm->Read(&bisfs, SIZEOF(DWORD), &cbRead);

    if (SUCCEEDED(hres))
    {
        if (bisfs.cbSize == 0)
        {
            // upgrade case, IE4 beta1 shipped this way
            //
            bisfs.dwFlags = *((LPDWORD)&bisfs);
            bisfs.cbSize = SIZEOF(bisfs);
            bisfs.wVersion = BANDISF_VERSION;
            bisfs.dwPriv = -1;
            bisfs.wViewMode = (bisfs.dwFlags & BANDISF_BOOL_LARGEICON) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
        }
        else
        {
            // read rest of stream
            //
            DWORD dw = (DWORD)bisfs.cbSize;
            if (dw > SIZEOF(bisfs))
                dw = SIZEOF(bisfs);
            dw -= SIZEOF(DWORD);
            hres = pstm->Read(&(bisfs.dwFlags), dw, &cbRead);
            if (FAILED(hres))
                return(hres);
        }

        // HEY, DON'T BE LAME ANY MORE.  When you next touch this code,
        // I suggest you figure out what sizes of this structure have
        // been actually shipped and only upgrade those.  Also use
        // the offsetof macro so you don't have to keep calculating these
        // things...

        // old upgrade, I don't know what state is persisted at setup time!
        //
        if (bisfs.cbSize == SIZEOF(bisfs) - 3*SIZEOF(COLORREF) - SIZEOF(DWORD) - SIZEOF(DWORD))
        {
            bisfs.dwPriv = -1;
            bisfs.cbSize += SIZEOF(DWORD);
        }
        // most recent upgrade, this is NOT persisted in registry at setup time!!!
        //
        if (bisfs.cbSize == SIZEOF(bisfs) - 3*SIZEOF(COLORREF) - SIZEOF(DWORD))
        {
            bisfs.wViewMode = (bisfs.dwFlags & BANDISF_BOOL_LARGEICON) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS;
            bisfs.cbSize = SIZEOF(bisfs);
        }
        // upgrade from version 0x21 + crBkgnd only to 0x22
        //
        if (bisfs.cbSize == SIZEOF(bisfs) - 2*SIZEOF(COLORREF))
        {
            bisfs.cbSize = SIZEOF(bisfs);
        }
        // upgrade from version 0x21 to 0x22
        //
        if (bisfs.cbSize == SIZEOF(bisfs) - 3*SIZEOF(COLORREF))
        {
            bisfs.cbSize = SIZEOF(bisfs);
        }

        if (!EVAL(bisfs.cbSize >= SIZEOF(bisfs)))
        {
            return(E_FAIL);
        }
        ASSERT(!(bisfs.dwFlags & ~BANDISF_VALIDBITS));

        if (bisfs.dwFlags & BANDISF_BOOL_NOSHOWTEXT)
            _fNoShowText = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_ALLOWRENAME)
            _fAllowRename = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_DEBOSSED)
            _fDebossed = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_FULLOPEN)
            _fFullOpen = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_NONAMESORT)
            _fNoNameSort = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_BTNMINSIZE)
            _fBtnMinSize = TRUE;
        if (bisfs.dwFlags & BANDISF_BOOL_BKCOLOR)
        {
            _crBkgnd = bisfs.crBkgnd;
            _fHaveBkColor = TRUE;
        }
        if (bisfs.dwFlags & BANDISF_BOOL_COLORS)
        {
            _crBtnLt = bisfs.crBtnLt;
            _crBtnDk = bisfs.crBtnDk;
            _fHaveColors = TRUE;
        }

        _dwPriv = bisfs.dwPriv;
#if 1 // BUGBUG FEATURE_UASSIST hack this should be persisted not recalc'ed
#define UEMIsLogCsidl(dwPrivID)    ((dwPrivID) == CSIDL_APPDATA)
        if (UEMIsLogCsidl(_dwPriv)) {
            _eUemLog = UEMIND_SHELL;
        }
#endif

        _uIconSize = bisfs.wViewMode;
        _fNoRecalcDefaults = TRUE;

        if (bisfs.dwFlags & BANDISF_MASK_PIDLASLINK)
        {
            ASSERT(NULL==_pidl);
            hres = LoadPidlAsLink(_punkSite, pstm, &_pidl);
            // If we hit hits, LoadPidlAsLink() read a chuck of our data. - BryanSt
            ASSERT(SUCCEEDED(hres));

//            DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
//            TraceMsg(TF_BAND|TF_GENERAL, "CISFBand::Load() _pidl=>%s<", Dbg_PidlStr(_pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

            _FixupAppDataDirectory();

        }
                
        if (SUCCEEDED(hres) && (bisfs.dwFlags & BANDISF_MASK_PSF))
        {
            ASSERT(NULL == _psf);
            hres = OleLoadFromStream(pstm, IID_IShellFolder, (void **)&_psf);
        }

        // map this to working info
        //
        if (SUCCEEDED(hres))
            _AfterLoad();

        // we need _psf before we can read the order list.
        if (SUCCEEDED(hres) && (bisfs.dwFlags & BANDISF_MASK_ORDERLIST))
        {
            hres = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);

            if (SUCCEEDED(hres))
            {
                // _fDropped "persists" along with the orderlist - if this flag
                // is set, we assume we have a non-default ordering
                _fDropped = TRUE;
            }
        }
    }

    return hres;
}

HRESULT SaveIsfToStream(IShellFolder *psf, IStream *pstm)
{
    IPersistStream* pps;
    HRESULT hres = psf->QueryInterface(IID_PPV_ARG(IPersistStream, &pps));
    if (SUCCEEDED(hres))
    {
        hres = OleSaveToStream(pps, pstm);

        pps->Release();
    }
    return hres;
}

HRESULT CISFBand::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hres;
    BANDISFSTREAM bisfs = {0};

    // figure out what we will save
    //
    if (_pidl)
        bisfs.dwFlags |= BANDISF_MASK_PIDLASLINK;

    // BUGBUG(lamadio): This case is busted. None of the IShellFolders implement IPersistStream (at least as far as
    // TJ and I can see). Qhen quick links initializes, it will set the pidlQuickLinks as the _pidl. So, in the 
    // After load, _fPSFBandDesktop gets set to TRUE. Why? I don't know. Well, then we never attempt to persist the 
    // IShellFolder and we will never fail the save. We should remove this case so we don't run into this again.
    if (_psf && !_fPSFBandDesktop)
        bisfs.dwFlags |= BANDISF_MASK_PSF;
    if (_fDropped && (_hdpa || _hdpaOrder)) // only if a drop occurred do we have non-default ordering
        bisfs.dwFlags |= BANDISF_MASK_ORDERLIST;

    if (_fNoShowText)
        bisfs.dwFlags |= BANDISF_BOOL_NOSHOWTEXT;
    if (_fAllowRename)
        bisfs.dwFlags |= BANDISF_BOOL_ALLOWRENAME;
    if (_fDebossed)
        bisfs.dwFlags |= BANDISF_BOOL_DEBOSSED;
    if (_fFullOpen)
        bisfs.dwFlags |= BANDISF_BOOL_FULLOPEN;
    if (_fNoNameSort)
        bisfs.dwFlags |= BANDISF_BOOL_NONAMESORT;
    if (_fBtnMinSize)
        bisfs.dwFlags |= BANDISF_BOOL_BTNMINSIZE;
    if (_fHaveBkColor)
    {
        bisfs.dwFlags |= BANDISF_BOOL_BKCOLOR;
        bisfs.crBkgnd = _crBkgnd;
    }
    if (_fHaveColors)
    {
        bisfs.dwFlags |= BANDISF_BOOL_COLORS;
        bisfs.crBtnLt = _crBtnLt;
        bisfs.crBtnDk = _crBtnDk;
    }

    bisfs.cbSize = SIZEOF(bisfs);
    bisfs.wVersion = BANDISF_VERSION;
    bisfs.dwPriv = _dwPriv;
    bisfs.wViewMode = _uIconSize;

    // now save it
    //
    hres = pstm->Write(&bisfs, SIZEOF(bisfs), NULL);

    if (SUCCEEDED(hres) && bisfs.dwFlags & BANDISF_MASK_PIDLASLINK)
    {
        hres = SavePidlAsLink(_punkSite, pstm, _pidl);
        // BUGBUG: We need to save a terminator.
    }

    if (SUCCEEDED(hres) && bisfs.dwFlags & BANDISF_MASK_PSF)
    {
        hres = SaveIsfToStream(_psf, pstm);
    }

    if (SUCCEEDED(hres) && (bisfs.dwFlags & BANDISF_MASK_ORDERLIST))
    {
        hres = OrderList_SaveToStream(pstm, (_hdpa ? _hdpa : _hdpaOrder), _psf);
    }


    return(hres);
}

#if 0
// IPersistPropertyBag implementation
//
HRESULT CISFBand::Load(IPropertyBag *pPropBag, IErrorLog *pErrorLog)
{
    ASSERT(0);  // obsolete!
    _fCascadeFolder = PropBag_ReadInt4(pPropBag, L"Cascade", FALSE);
    // n.b. old "Title" property nuked
    _uIconSize = (PropBag_ReadInt4(pPropBag, L"Large", TRUE) ? ISFBVIEWMODE_LARGEICONS : ISFBVIEWMODE_SMALLICONS);
    _fNoShowText = PropBag_ReadInt4(pPropBag, L"Text", TRUE);

    return(S_OK);
}
HRESULT CISFBand::Save(IPropertyBag *pPropBag, BOOL fClearDirty, BOOL fSaveAllProperties)
{
    return(E_NOTIMPL);
}
HRESULT CISFBand::InitNew()
{
    ASSERT(0);  // obsolete!
    return(E_NOTIMPL);
}
#endif

// IContextMenu implementation
//
HRESULT CISFBand::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    BOOL fChanged = FALSE;
    int idCmd = -1;

    UINT uNewMode = 0;
    if (!HIWORD(lpici->lpVerb))
        idCmd = LOWORD(lpici->lpVerb);
    switch (idCmd)
    {
    case ISFBIDM_LARGE:
        uNewMode = ISFBVIEWMODE_LARGEICONS;
        goto newViewMode;

    case ISFBIDM_SMALL:
        uNewMode = ISFBVIEWMODE_SMALLICONS;
newViewMode:
        if (uNewMode != _uIconSize)
        {
            BOOL fRefresh = FALSE;

            if (uNewMode == ISFBVIEWMODE_LOGOS || _uIconSize == ISFBVIEWMODE_LOGOS)
            {
                // invalidate all before switching the imagelist...
                _RememberOrder();

                EmptyToolbar();
                fRefresh = TRUE;
            }

            // we Logo view has now left the building...
            if ( uNewMode != ISFBVIEWMODE_LOGOS && _uIconSize == ISFBVIEWMODE_LOGOS )
            {
                ExitLogoView();
            }

            fChanged = _UpdateIconSize(uNewMode, TRUE);

            if ( fRefresh )
            {
                _FillToolbar();
            }
            if (fChanged)
                _BandInfoChanged();
        }
        // fall thru
    default:
        return CSFToolbar::InvokeCommand(lpici);
    }

    return(S_OK);
}

// *** IOleCommandTarget methods ***

STDMETHODIMP CISFBand::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_ISFBand, *pguidCmdGroup))
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case ISFBID_CACHEPOPUP:
            case ISFBID_ISITEMVISIBLE:
            case ISFBID_PRIVATEID:
                rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                break;
            }
        }
        hr = S_OK;
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            switch (rgCmds[i].cmdID)
            {
            case SHDVID_UEMLOG:
                rgCmds[i].cmdf |= OLECMDF_SUPPORTED;
                break;
            }
        }
        hr = S_OK;
    }

    return hr;
}

HRESULT CISFBand::_IsPidlVisible(LPITEMIDLIST pidl)
{
    int i;

    if (_GetButtonFromPidl(pidl, NULL, &i)) {
        RECT rc;
        GetClientRect(_hwndTB, &rc);

        if (SHIsButtonObscured(_hwndTB, &rc, i))
            return S_FALSE;
        else
            return S_OK;
    }

    return E_FAIL;
}

HRESULT CISFBand::_OrderListFromIStream(VARIANT* pvarargIn)
{
    HRESULT hres = E_FAIL;
    if (pvarargIn->vt == VT_UNKNOWN)
    {
        IStream* pstm;
        if (SUCCEEDED(pvarargIn->punkVal->QueryInterface(IID_IStream, (void**)&pstm)))
        {
            OrderList_Destroy(&_hdpaOrder);
            hres = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);
            if (SUCCEEDED(hres))
            {
                _SetDirty(TRUE);
                if (_fShow)
                {
                    _FillToolbar();
                }
            }
            pstm->Release();
        }
    }

    return hres;
}

HRESULT CISFBand::_IStreamFromOrderList(VARIANT* pvarargOut)
{
    HRESULT hres = E_OUTOFMEMORY;
    ASSERT(pvarargOut != NULL);

    IStream* pstm = SHCreateMemStream(NULL, 0);
    if (pstm)
    {
        hres = OrderList_SaveToStream(pstm, _hdpa, _psf);
        if (SUCCEEDED(hres))
        {
            pvarargOut->vt = VT_UNKNOWN;
            pvarargOut->punkVal = pstm;
            pvarargOut->punkVal->AddRef();
        }
        pstm->Release();
    }

    return hres;
}

STDMETHODIMP CISFBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_ISFBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case ISFBID_CACHEPOPUP:
            if (pvarargIn && pvarargIn->vt == VT_UNKNOWN)
            {
                IMenuPopup* pmp = NULL;
                if (pvarargIn->punkVal)
                    pvarargIn->punkVal->QueryInterface(IID_IMenuPopup, (void **)&pmp);

                _SetCacheMenuPopup(pmp);

                ATOMICRELEASE(pmp);
            }

            if (pvarargOut)
            {
                pvarargOut->vt = VT_UNKNOWN;
                pvarargOut->punkVal = _pmpCache;
                if (_pmpCache)
                    _pmpCache->AddRef();
            }
            return S_OK;

        case ISFBID_ISITEMVISIBLE:
            {
                HRESULT hr = E_INVALIDARG;

                if (pvarargIn && pvarargIn->vt == VT_INT_PTR)
                    hr = _IsPidlVisible((LPITEMIDLIST)pvarargIn->byref);

                return hr;
            }

        case ISFBID_PRIVATEID:
            // hack hack for BSMenu to differentiate between specially created
            // isfbands. see bsmenu's _FindBand
            // if pvarargOut is set, we give back the id we have stored.
            if (pvarargOut)
            {
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _dwPriv;
            }
            // if pvarargIn is set, then we take and keep this id.
            if (pvarargIn && pvarargIn->vt == VT_I4)
                _dwPriv = pvarargIn->lVal;

            return S_OK;

        case ISFBID_GETORDERSTREAM:
            return _IStreamFromOrderList(pvarargOut);

        case ISFBID_SETORDERSTREAM:
            return _OrderListFromIStream(pvarargIn);
        }
    }
    else if (IsEqualGUID(CGID_ShellDocView, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case SHDVID_UEMLOG:
            ASSERT(pvarargOut == NULL);
            // if pvarargIn is set, then we take and keep this id.
            if (pvarargIn && pvarargIn->vt == VT_I4)
            {
                _eUemLog = pvarargIn->lVal;
                ASSERT(_eUemLog == UEMIND_SHELL || _eUemLog == UEMIND_BROWSER);
            }

            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_DeskBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBID_DELAYINIT:
            _fDelayInit = TRUE;
            break;

        case DBID_FINISHINIT:
            _fDelayInit = FALSE;
            _RegisterToolbar();
            break;
        }
        return S_OK;
    }
    
    return OLECMDERR_E_NOTSUPPORTED;
}

IShellFolder * CISFBand::GetSF()
{
    ASSERT( _psf );
    return _psf;
}

HWND CISFBand::GetHWND()
{
    return _hwndTB;
}

REFTASKOWNERID CISFBand::GetTOID()
{
    return TOID_ExtractImage;
}

HRESULT CISFBand::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (lEvent == SHCNE_RMDIR && _IsEqualID(pidl1))
    {
        HRESULT hres = E_FAIL;
        IBandSite *pbandSite;
        if (_punkSite)
        {
            hres = _punkSite->QueryInterface(IID_IBandSite, (void **)&pbandSite);
            if (EVAL(SUCCEEDED(hres))) 
            {
                pbandSite->RemoveBand(_dwBandID);
                pbandSite->Release();
            }
        }
        return hres;
    }
    else
    {
        return CSFToolbar::OnTranslatedChange(lEvent, pidl1, pidl2);
    }
}

HRESULT CISFBand::UpdateLogoCallback( DWORD dwItem, int iIcon, HBITMAP hImage, LPCWSTR pszCache, BOOL fCache )
{
    int iItem = (int)dwItem;
    HRESULT hr;
    UINT uImage;

    // catch if we are closing...
    if ( _fClosing )
        return NOERROR;

    IMAGECACHEINFO rgInfo;
    rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_LARGE | ICIFLAG_BITMAP | ICIFLAG_NOUSAGE;
    rgInfo.cbSize = sizeof( rgInfo );
    rgInfo.pszName = pszCache;

    rgInfo.hBitmapLarge = hImage;

    ASSERT(_pLogoCache);
    if (_pLogoCache)
        hr = _pLogoCache->AddImage( &rgInfo, &uImage );
    else
        hr = E_FAIL;

    // catch if we are closing...
    if ( _fClosing )
        return NOERROR;

    if ( SUCCEEDED( hr ))
    {
        // remember the icon to logo mapping....
        AddIndicesToLogoList( iIcon, uImage );

        // catch we are closing before we try and doa bloc
        PostMessage( _hwndTB, TB_CHANGEBITMAP, iItem, uImage );
    }

    // stop delay painting when the last extract image task calls back
    if (_fDelayPainting) {
        if (_pTaskScheduler && _pTaskScheduler->CountTasks(TOID_NULL) == 1) {
            _StopDelayPainting();
        }
    }

    return hr;
}

// }


HRESULT CISFBand::_GetTitleW(LPWSTR pwszTitle, DWORD cchSize)
{
    HRESULT hr = E_FAIL;
    TraceMsg(TF_BAND, "Calling baseclass CISFBand::_GetTitleW");

    if (!EVAL(pwszTitle))
        return E_INVALIDARG;

    *pwszTitle = 0;
    if (_pidl)
    {
        hr = SHGetNameAndFlagsW(_pidl, SHGDN_NORMAL, pwszTitle, cchSize, NULL);
    }
    else if (_psf && !_fPSFBandDesktop)
    {
#ifdef BUSTED
        // BUGBUG (scotth):  We cannot call GetDisplayNameOf with NULL pidl.
        //                   We must change this code so _pidl is always
        //                   valid, and key off a flag to determine whether
        //                   to receive notifies.  Remove this code once
        //                   that is done.

        STRRET strret;

        if (SUCCEEDED(_psf->GetDisplayNameOf(NULL, SHGDN_NORMAL, &strret)))
            StrRetToBufW(&strret, NULL, pwszTitle, cchSize);
#endif

    }

    return hr;
}

STDAPI NavigateToPIDL(IWebBrowser2* pwb, LPCITEMIDLIST pidl);

HRESULT FakeGetNavigateTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidl);


LRESULT CISFBand::_TryChannelSurfing(LPCITEMIDLIST pidl)
{
    LRESULT lRet = 0;

    ASSERT(_fChannels);

    LPITEMIDLIST pidlTarget;

    HRESULT hr = SHGetNavigateTarget(_psf, pidl, &pidlTarget, NULL);

    // channel category folders hack.
    if (FAILED(hr))
        hr = FakeGetNavigateTarget(_psf, pidl, &pidlTarget);

    if (SUCCEEDED(hr))
    {
        IWebBrowser2* pwb;

        // n.b. careful! only one of GCB and C_OB up the refcnt
        _GetChannelBrowser(&pwb);
        if (SUCCEEDED(Channels_OpenBrowser(&pwb, pwb != NULL)))
        {
            lRet = 1;   // success at this point

            if (SUCCEEDED(NavigateToPIDL(pwb, pidlTarget)))
            {
                LPITEMIDLIST pidlFull = ILCombine(_pidl, pidl);
                if (pidlFull)
                {
                    VARIANT varURLpidl, flags;
                    flags.vt = VT_I4;
                    flags.lVal = navBrowserBar;
                    if (SUCCEEDED(InitVariantFromIDList(&varURLpidl, pidlFull)))
                    {
                        pwb->Navigate2(&varURLpidl, &flags, PVAREMPTY, PVAREMPTY, PVAREMPTY);
                        VariantClear(&varURLpidl);
                    }
                    ILFree(pidlFull);
                }
            }
        }
        if (pwb)
            pwb->Release();

        ILFree(pidlTarget);
    }

    return lRet;
}

//***   _GetChannelBrowser -- find appropriate browser for surfing
// DESCRIPTION
//  for the DTBrowser case, we fail (pwb=NULL, hr=S_FALSE) so that our
// caller will create a new SHBrowser (which can be put into theater mode).
// for the SHBrowser case, we find the top-level browser (so we'll navigate
// in-place).
HRESULT CISFBand::_GetChannelBrowser(IWebBrowser2 **ppwb)
{
    HRESULT hr;
    IServiceProvider *psp;

    *ppwb = NULL;   // assume failure
    if (_fDesktop) {
        ASSERT(*ppwb == NULL);
        hr = S_FALSE;
    }
    else {
        hr = IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_IServiceProvider, (void**)&psp);
        ASSERT(SUCCEEDED(hr));
        if (SUCCEEDED(hr)) {
            hr = psp->QueryService(SID_SWebBrowserApp, IID_IWebBrowser2, (void **)ppwb);
            ASSERT(SUCCEEDED(hr));
            psp->Release();
        }
    }

    return hr;
}

HRESULT IUnknown_SetBandInfoSFB(IUnknown *punkBand, BANDINFOSFB *pbi)
{
    HRESULT hr = E_FAIL;
    IShellFolderBand *pisfBand;

    if (punkBand) {
        hr = punkBand->QueryInterface(IID_IShellFolderBand, (void **)&pisfBand);
        if (EVAL(SUCCEEDED(hr))) {
            hr = pisfBand->SetBandInfoSFB(pbi);
            pisfBand->Release();
        }
    }
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////CExtractImageTask///////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////
// Warning
//
// The CLogoBase class cannot have a ref on the returned task
// since that would be a circular reference
//
// Warning

HRESULT CExtractImageTask_Create( CLogoBase *plb,
                                  LPEXTRACTIMAGE pExtract,
                                  LPCWSTR pszCache,
                                  DWORD dwItem,
                                  int iIcon,
                                  DWORD dwFlags,
                                  LPRUNNABLETASK * ppTask )
{
    if ( !ppTask || !plb || !pExtract )
    {
        return E_INVALIDARG;
    }

    HRESULT hr = NOERROR;
    CExtractImageTask * pNewTask = new CExtractImageTask( &hr,
                                                          plb,
                                                          pExtract,
                                                          pszCache,
                                                          dwItem,
                                                          iIcon,
                                                          dwFlags );
    if ( !pNewTask )
    {
        return E_OUTOFMEMORY;
    }
    if ( FAILED( hr ))
    {
        pNewTask->Release();
        return hr;
    }

    *ppTask = SAFECAST( pNewTask, IRunnableTask *);
    return NOERROR;
}
/////////////////////////////////////////////////////////////////////////////////////////////////////


CExtractImageTask::CExtractImageTask( HRESULT * pHr, CLogoBase *plb, IExtractImage * pImage,
    LPCWSTR pszCache, DWORD dwItem, int iIcon, DWORD dwFlags )
{
    m_lState = IRTIR_TASK_NOT_RUNNING;

    m_plb = plb;
    m_plb->AddRef();

    // cannot assume the band will kill us before it dies....
    // hence we hold a reference

    StrCpyNW(m_szPath, pszCache, ARRAYSIZE(m_szPath));

    m_pExtract = pImage;
    pImage->AddRef();

    m_cRef = 1;

    // use the upper bit of the flags to determine if we should always call....
    m_dwFlags = dwFlags;
    m_dwItem = dwItem;
    m_iIcon = iIcon;

    // Since the task moves from thread to thread,
    // don't charge this thread for the objects we're using
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
CExtractImageTask::~CExtractImageTask()
{
    ATOMICRELEASE( m_pExtract );
    ATOMICRELEASE( m_pTask );

    if ( m_hBmp && !( m_dwFlags & EITF_SAVEBITMAP ))
    {
        DeleteObject( m_hBmp );
    }

    if(m_plb)
        m_plb->Release();
}

//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::QueryInterface( REFIID riid, void **ppvObj )
{
    if ( !ppvObj )
    {
        return E_INVALIDARG;
    }
    if ( IsEqualIID( riid, IID_IUnknown ))
    {
        *ppvObj = SAFECAST( this, IUnknown *);
    }
    else if ( IsEqualIID( riid, IID_IRunnableTask ))
    {
        *ppvObj = SAFECAST( this, IRunnableTask *);
    }
    else
    {
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_ (ULONG)  CExtractImageTask::AddRef()
{
    return InterlockedIncrement( &m_cRef );
}

//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_ (ULONG) CExtractImageTask::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement( &m_cRef );
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

//////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::Run ( void )
{
    HRESULT hr = E_FAIL;
    if ( m_lState == IRTIR_TASK_RUNNING )
    {
        hr = S_FALSE;
    }
    else if ( m_lState == IRTIR_TASK_PENDING )
    {
        hr = E_FAIL;
    }
    else if ( m_lState == IRTIR_TASK_NOT_RUNNING )
    {
        LONG lRes = InterlockedExchange( & m_lState, IRTIR_TASK_RUNNING);
        if ( lRes == IRTIR_TASK_PENDING )
        {
            m_lState = IRTIR_TASK_FINISHED;
            return NOERROR;
        }

        // see if it supports IRunnableTask
        m_pExtract->QueryInterface( IID_IRunnableTask, (void **) & m_pTask );

#ifdef UNIX
        //Hey Guys : IE4.01 has an error - it returns the wrong VTABLE
        //when this QI is done. We know how our VTABLEs are laid out

#else
        // IE4.01 has an error - it returns the wrong VTABLE
        // when this QI is done.

        if((LPVOID)m_pTask == (LPVOID)m_pExtract)
        {
            m_pTask = m_pTask + 2; // This vtable is two ptrs away and is in fstree.cpp in shell32 in IE4.01
        }
#endif

        if ( m_lState == IRTIR_TASK_RUNNING )
        {
            // start the extractor....
            hr = m_pExtract->Extract( &m_hBmp );
        }

        if (( SUCCEEDED( hr ) || ( hr != E_PENDING && (m_dwFlags & EITF_ALWAYSCALL))) && m_lState == IRTIR_TASK_RUNNING )
        {
            hr = InternalResume();
        }

        if ( m_lState != IRTIR_TASK_SUSPENDED || hr != E_PENDING )
        {
            m_lState = IRTIR_TASK_FINISHED;
        }
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::Kill ( BOOL fWait )
{
    if ( m_lState != IRTIR_TASK_RUNNING )
    {
        return S_FALSE;
    }

    LONG lRes = InterlockedExchange( &m_lState, IRTIR_TASK_PENDING );
    if ( lRes == IRTIR_TASK_FINISHED )
    {
        m_lState = lRes;
        return NOERROR;
    }

    // does it support IRunnableTask ? Can we kill it ?
    HRESULT hr = E_NOTIMPL;
    if ( m_pTask != NULL )
    {
        hr = m_pTask->Kill( FALSE );
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::Suspend( void )
{
    if ( !m_pTask )
    {
        return E_NOTIMPL;
    }

    if ( m_lState != IRTIR_TASK_RUNNING )
    {
        return E_FAIL;
    }


    LONG lRes = InterlockedExchange( &m_lState, IRTIR_TASK_SUSPENDED );
    HRESULT hr = m_pTask->Suspend();
    if ( SUCCEEDED( hr ))
    {
        lRes = (LONG) m_pTask->IsRunning();
        if ( lRes == IRTIR_TASK_SUSPENDED )
        {
            m_lState = lRes;
        }
    }
    else
    {
        m_lState = lRes;
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CExtractImageTask::Resume( void )
{
    if ( !m_pTask )
    {
        return E_NOTIMPL;
    }

    if ( m_lState != IRTIR_TASK_SUSPENDED )
    {
        return E_FAIL;
    }

    m_lState = IRTIR_TASK_RUNNING;

    HRESULT hr = m_pTask->Resume();
    if ( SUCCEEDED( hr ) || ( hr != E_PENDING && ( m_dwFlags & EITF_ALWAYSCALL )))
    {
        hr = InternalResume();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
HRESULT CExtractImageTask::InternalResume()
{
    HRESULT hr = NOERROR;
    if ( m_dwFlags & EITF_ALWAYSCALL || m_hBmp )
    {
        // call the update function
        hr = m_plb->UpdateLogoCallback( m_dwItem, m_iIcon, m_hBmp, m_szPath, TRUE );
    }

    m_lState = IRTIR_TASK_FINISHED;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_( ULONG ) CExtractImageTask:: IsRunning ( void )
{
    return m_lState;
}



////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////CLogoBase/////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
// static data...
IImageCache * CLogoBase::s_pSharedWideLogoCache = NULL;
long CLogoBase::s_lSharedWideLogosRef = 0;
HDSA CLogoBase::s_hdsaWideLogoIndices = NULL;
CRITICAL_SECTION CLogoBase::s_csSharedLogos = {0};

extern "C" void CLogoBase_Initialize( void )
{
    CLogoBase::_Initialize();
}

extern "C" void CLogoBase_Cleanup( void )
{
    CLogoBase::_Cleanup( );
}

void CLogoBase::_Initialize( void )
{
    InitializeCriticalSection( &s_csSharedLogos );
}

void CLogoBase::_Cleanup( void )
{
    DeleteCriticalSection( & s_csSharedLogos );
}


CLogoBase::CLogoBase( BOOL fWide )
{
    // are we paletized, then use the global halftone palette ....
    HDC hdcTmp = GetDC( NULL );
    if (hdcTmp)
    {
        if (GetDeviceCaps( hdcTmp, RASTERCAPS) & RC_PALETTE)
        {
            ASSERT( g_hpalHalftone );
            _hpalHalftone = g_hpalHalftone;
        }
        ReleaseDC( NULL, hdcTmp );
    }

    _fWide = fWide;
}

CLogoBase::~CLogoBase()
{
    if (_pLogoCache || _pTaskScheduler)
    {
        ExitLogoView();
    }

    // NOTE: no palette release because we are using the global Halftone palette......
}

HRESULT CLogoBase::AddRefLogoCache( void )
{
    if ( _fWide )
    {
        EnterCriticalSection( &s_csSharedLogos );

        if ( !s_lSharedWideLogosRef )
        {
            if ( !s_hdsaWideLogoIndices )
            {
                s_hdsaWideLogoIndices = DSA_Create( sizeof( LogoIndex ), 5 );
                if ( !s_hdsaWideLogoIndices )
                {
                    LeaveCriticalSection( &s_csSharedLogos );
                    return E_OUTOFMEMORY;
                }
            }

            ASSERT( s_hdsaWideLogoIndices );
            ASSERT( !s_pSharedWideLogoCache );

            // BUGBUG for now CoCreate one per view
            HRESULT hr = CoCreateInstance( CLSID_ImageListCache,
                                           NULL,
                                           CLSCTX_INPROC_SERVER,
                                           IID_IImageCache,
                                           (void **) & s_pSharedWideLogoCache );
            if ( FAILED( hr ))
            {
                LeaveCriticalSection( &s_csSharedLogos );
                return hr;
            }
        }

        ASSERT( s_pSharedWideLogoCache );

        // bump up the ref and get a pointer to it...
        s_lSharedWideLogosRef ++;
        _pLogoCache = s_pSharedWideLogoCache;
        _pLogoCache->AddRef();
        _hdsaLogoIndices = s_hdsaWideLogoIndices;
        LeaveCriticalSection( &s_csSharedLogos );

        return NOERROR;
    }
    else
    {
        // non wide logo version we don't share because w eonly expect there ever to be one...
        _hdsaLogoIndices = DSA_Create( sizeof( LogoIndex ), 5 );
        if ( !_hdsaLogoIndices )
        {
            return E_OUTOFMEMORY;
        }

        // BUGBUG for now CoCreate one per view
        return CoCreateInstance( CLSID_ImageListCache,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_IImageCache,
                                 (void **) & _pLogoCache );
    }
}

HRESULT CLogoBase::ReleaseLogoCache( void )
{
    if ( !_pLogoCache )
    {
        return S_FALSE;
    }

    ATOMICRELEASE(_pLogoCache);

    if ( _fWide )
    {
        EnterCriticalSection( &s_csSharedLogos );

        ASSERT( s_lSharedWideLogosRef > 0 );

        s_lSharedWideLogosRef --;
        if ( ! s_lSharedWideLogosRef )
        {
            // let go of the final ref.....
            ATOMICRELEASE(s_pSharedWideLogoCache);

            ASSERT( s_hdsaWideLogoIndices );
            DSA_Destroy( s_hdsaWideLogoIndices );
            s_hdsaWideLogoIndices = NULL;
        }

        LeaveCriticalSection( &s_csSharedLogos );
    }
    else
    {
        // free the HDSA
        DSA_Destroy( _hdsaLogoIndices );
        _hdsaLogoIndices = NULL;
    }

    return NOERROR;
}

HRESULT CLogoBase::InitLogoView( void )
{
    HRESULT hr = AddRefLogoCache();
    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_ShellTaskScheduler,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IShellTaskScheduler,
                              (void **) &_pTaskScheduler);
        if (FAILED(hr))
        {
            ATOMICRELEASE(_pLogoCache);
        }
        else
        {
            _rgLogoSize.cx = ( _fWide ) ? LOGO_WIDE_WIDTH : LOGO_WIDTH ;
            _rgLogoSize.cy = LOGO_HEIGHT;

            IMAGECACHEINITINFO rgInfo;
            rgInfo.cbSize = sizeof( rgInfo );
            rgInfo.dwMask = ICIIFLAG_LARGE;
            rgInfo.iStart = 0;
            rgInfo.iGrow = 5;

            // the color depth is currently the screen resolution...
            int iColorRes = SHGetCurColorRes();

            _dwClrDepth = (DWORD) iColorRes;
            switch (iColorRes)
            {
                case 16 :   rgInfo.dwFlags = ILC_COLOR16;
                            break;
                case 24 :
                case 32 :   rgInfo.dwFlags = ILC_COLOR24;
                            break;
                default :   rgInfo.dwFlags = ILC_COLOR8;
            }

            rgInfo.rgSizeLarge = _rgLogoSize;
            if (_pLogoCache)
                hr = _pLogoCache->GetImageList(&rgInfo);
            else
                hr = E_UNEXPECTED;

            if (FAILED(hr))
            {
                ATOMICRELEASE(_pLogoCache);
                ATOMICRELEASE(_pTaskScheduler);
            }
            else
            {
                _himlLogos = rgInfo.himlLarge;

                // GetImageList() will return S_FALSE if it was already created...
                if ((hr == S_OK) && (iColorRes <= 8))
                {
                    // init the color table so that it matches The "special halftone palette"
                    HPALETTE hpal = SHCreateShellPalette(NULL);
                    PALETTEENTRY rgColours[256];
                    RGBQUAD rgDIBColours[256];

                    ASSERT( hpal );
                    int nColours = GetPaletteEntries(hpal, 0, ARRAYSIZE(rgColours), rgColours);

                    // SHGetShellPalette should always return a 256 colour palette
                    ASSERT(nColours == ARRAYSIZE(rgColours));

                    // translate from the LOGPALETTE structure to the RGBQUAD structure ...
                    for (int iColour = 0; iColour < nColours; iColour ++)
                    {
                        rgDIBColours[iColour].rgbRed = rgColours[iColour].peRed;
                        rgDIBColours[iColour].rgbBlue = rgColours[iColour].peBlue;
                        rgDIBColours[iColour].rgbGreen = rgColours[iColour].peGreen;
                        rgDIBColours[iColour].rgbReserved = 0;
                    }

                    DeletePalette(hpal);

                    ImageList_SetColorTable(_himlLogos, 0, 256, rgDIBColours);
                }
            }
        }
    }

    return hr;
}

HRESULT CLogoBase::ExitLogoView( void )
{
    ATOMICRELEASE( _pTaskScheduler );

    // the task scheduler callbacks can reference
    // the logocache, so make sure you free the
    // logo cache AFTER the task scheduler!
    ReleaseLogoCache();

    return NOERROR;
}

int CLogoBase::GetCachedLogoIndex( DWORD dwItem, LPCITEMIDLIST pidl, LPRUNNABLETASK *ppTask, DWORD * pdwPriority, DWORD *pdwFlags )
{
    DWORD dwPassedFlags = 0;

    if ( pdwFlags )
    {
        dwPassedFlags = *pdwFlags;
        *pdwFlags = 0;
    }

    // No logo cache?
    if (!_pLogoCache)
        return 0;

    ASSERT( pidl );
    // HACK: this is used on browser only mode to tell what sort of logos we need...
    UINT rgfFlags = _fWide;
    LPEXTRACTIMAGE pImage = NULL;
    int iImage = -1;
    HRESULT hr = E_FAIL;

    // IID_IEXtractLogo and IID_IExtractImage are the same interface, by using a new guid
    // it means we can selectively decided what can logo in logo view...
    hr = FakeGetUIObjectOf( GetSF(), pidl, &rgfFlags, IID_IExtractLogo, (void **) &pImage );
    if ( SUCCEEDED( hr ))
    {
        // extract ....
        HBITMAP hImage;
        WCHAR szPath[MAX_PATH];
        DWORD dwFlags = IEIFLAG_ASYNC | IEIFLAG_ASPECT | dwPassedFlags;
        IMAGECACHEINFO rgInfo;
        UINT uIndex;
        BOOL fAsync;
        DWORD dwPriority;

        rgInfo.cbSize = sizeof( rgInfo );

        hr = pImage->GetLocation( szPath, MAX_PATH, &dwPriority, &_rgLogoSize, _dwClrDepth, &dwFlags );
        fAsync = ( hr == E_PENDING );
        if ( SUCCEEDED( hr ) || fAsync )
        {
            // mask off the flags passed to use by the flags returned from the extractor...
            if ( pdwFlags )
                *pdwFlags = dwPassedFlags & dwFlags;

            rgInfo.dwMask = ICIFLAG_NAME;
            rgInfo.pszName = szPath;

            hr = _pLogoCache->FindImage( &rgInfo, &uIndex );
            if ( hr == S_OK )
            {
                ATOMICRELEASE( pImage );
                return (int) uIndex;
            }

            if ( fAsync )
            {
                LPRUNNABLETASK pTaskTmp = NULL;

                ASSERT( _pTaskScheduler );

                // pass the icon index so we can find the right logo later...
                int iIcon = SHMapPIDLToSystemImageListIndex(GetSF(), pidl, NULL);
                hr = CExtractImageTask_Create( this,
                                               pImage,
                                               szPath,
                                               dwItem,
                                               iIcon,
                                               0,
                                               &pTaskTmp );
                if ( SUCCEEDED( hr ))
                {
                    if ( !ppTask )
                    {
                        hr = AddTaskToQueue( pTaskTmp, dwPriority, dwItem );
                        pTaskTmp->Release();
                    }
                    else
                    {
                        * ppTask = pTaskTmp;

                        ASSERT( pdwPriority );
                        *pdwPriority = dwPriority;
                    }
                }
                else if ( ppTask )
                {
                    *ppTask = NULL;
                }

                // if all this failed, then we will just end up with a default
                // logo. This is only likely to fail in low memory conditions,
                // so that will be fine.

                // if this SUCCEEDED we will drop through to pick up a defualt piccy for now.
            }
            else
            {
                // otherwise extract synchronously.......
                hr = pImage->Extract( &hImage );
                if ( SUCCEEDED( hr ))
                {
                    rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_LARGE | ICIFLAG_BITMAP | ICIFLAG_NOUSAGE;
                    rgInfo.hBitmapLarge = hImage;

                    hr = _pLogoCache->AddImage( &rgInfo, &uIndex );
                    DeleteObject( hImage );
                }
                if ( SUCCEEDED( hr ))
                {
                    iImage = (int ) uIndex;
                }
            }
        }
    }

    ATOMICRELEASE( pImage );

    return iImage;
}

int CLogoBase::GetLogoIndex( DWORD dwItem, LPCITEMIDLIST pidl, LPRUNNABLETASK *ppTask, DWORD * pdwPriority, DWORD *pdwFlags )
{
    int iImage = GetCachedLogoIndex(dwItem, pidl, ppTask, pdwPriority, pdwFlags );

    if ( iImage == -1 )
    {
        // always pass FALSE, we want the proper ICON, cdfview no longer hits the
        // wire for the icon so we can safely ask for the correct icon.
        iImage = GetDefaultLogo( pidl, FALSE);

    }
    return iImage;
}

HRESULT CLogoBase::AddTaskToQueue( LPRUNNABLETASK pTask, DWORD dwPriority, DWORD dwItem )
{
    ASSERT( _pTaskScheduler );
    return _pTaskScheduler->AddTask( pTask, GetTOID(), dwItem, dwPriority );
}

int CLogoBase::GetDefaultLogo( LPCITEMIDLIST pidl, BOOL fQuick )
{
    // Get icon to draw from
    int iIndex = -1;
    if ( !fQuick )
    {
        iIndex = SHMapPIDLToSystemImageListIndex(GetSF(), pidl, NULL);
    }
    if (iIndex < 0)
    {
        iIndex = II_DOCNOASSOC;
    }

    WCHAR wszText[MAX_PATH];

    wszText[0] = 0;

    STRRET strret;
    HRESULT hr = GetSF()->GetDisplayNameOf( pidl, SHGDN_NORMAL, &strret );
    if ( SUCCEEDED( hr ))
    {
        StrRetToBufW(&strret, pidl, wszText, ARRAYSIZE(wszText));
    }

    UINT uCacheIndex = (UINT) -1;

    if (_pLogoCache)    // We didn't have one in stress.
    {
        IMAGECACHEINFO rgInfo;
        rgInfo.cbSize = sizeof( rgInfo );
        rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_INDEX;
        rgInfo.pszName = wszText;
        rgInfo.iIndex = iIndex;

        hr = _pLogoCache->FindImage( &rgInfo, &uCacheIndex );
        if ( hr == S_OK )
        {
            return uCacheIndex;
        }

        HBITMAP hDef;
        hr = CreateDefaultLogo( iIndex, _rgLogoSize.cx, _rgLogoSize.cy, wszText, &hDef );
        if ( SUCCEEDED( hr ))
        {
            rgInfo.hBitmapLarge = hDef;
            rgInfo.hMaskLarge = NULL;
            rgInfo.dwMask = ICIFLAG_NAME | ICIFLAG_INDEX | ICIFLAG_BITMAP | ICIFLAG_LARGE;

            hr = _pLogoCache->AddImage( &rgInfo, &uCacheIndex );
            if ( FAILED(hr ))
            {
                uCacheIndex = (UINT) -1;
            }
            else
            {
                // remember the index of the logo
                AddIndicesToLogoList( iIndex, uCacheIndex );
            }
            DeleteObject( hDef );
        }
    }

    return (int) uCacheIndex;
}

#define DXFUDGE     4
#define COLORTEXT   RGB(255,255,255)
#define COLORBK     RGB(0,0,0)
HRESULT CLogoBase::CreateDefaultLogo(int iIcon, int cxLogo, int cyLogo, LPCTSTR pszText, HBITMAP * phBmpLogo)
{
    HRESULT hr = E_OUTOFMEMORY;
    HBITMAP hbmp = NULL;

    HIMAGELIST himl;
    int cxIcon, cyIcon;
   int x, y, dx, dy;

    // get the small icons....
    Shell_GetImageLists(NULL, &himl);
    ImageList_GetIconSize(himl, &cxIcon, &cyIcon);

    // Calculate position info. We assume logos are wider than they are tall.
    //
    ASSERT(cxLogo >= cyLogo);

    // Put the icon on the left
    x = 2;

    // Center the icon vertically
    if (cyIcon <= cyLogo)
    {
        y = (cyLogo - cyIcon) / 2;
        dy = cyIcon;
        dx = cxIcon;
    }
    else
    {
        y = 0;
        dy = cyLogo;

        // keep shrinkage proportional
        dx = MulDiv(cxIcon, cyIcon, cyLogo);
    }

    // get ready to draw
    HDC hTBDC = GetDC( GetHWND());
    if ( !hTBDC )
    {
        return E_FAIL;
    }
    HDC hdc = CreateCompatibleDC( hTBDC );
    if (hdc)
    {
        RECT    rc;
        int     dx, dy, x, y;
        SIZE    size;
        hbmp = CreateCompatibleBitmap(hTBDC, cxLogo, cyLogo);
        if (hbmp)
        {
            HGDIOBJ hTmp = SelectObject(hdc, hbmp);
            HPALETTE hpalOld;
            HFONT hfont, hfontOld;

            if ( _hpalHalftone )
            {
                hpalOld = SelectPalette( hdc, _hpalHalftone, TRUE );
                // LINTASSERT(hpalOld || !hpalOld);     // 0 semi-ok for SelectPalette
                RealizePalette( hdc );
            }

            SetMapMode( hdc, MM_TEXT );
            rc.left = rc.top = 0;
            rc.bottom = cyLogo;
            rc.right = cxLogo;
            SHFillRectClr(hdc, &rc, COLORBK);
            // draw the icon into the memory DC.
            ImageList_GetIconSize(himl, &dx, &dy);
            x = DXFUDGE;
            y = ((cyLogo- dy) >> 1);
            ImageList_Draw( himl, iIcon, hdc, x, y, ILD_TRANSPARENT );
            hfont = (HFONT)GetStockObject(DEFAULT_GUI_FONT);
            hfontOld = hfont ? (HFONT)SelectObject(hdc, hfont) : NULL;
            GetTextExtentPoint32(hdc, pszText, lstrlen(pszText), &size);
            x += (dx + DXFUDGE);
            y = ((cyLogo- size.cy) >> 1);
            rc.left = x;
            UINT eto = ETO_CLIPPED;
            SetTextColor(hdc, COLORTEXT);
            SetBkMode(hdc, TRANSPARENT);
            ExtTextOut(hdc, x, y, eto, &rc
                                        , pszText, lstrlen(pszText), NULL);
            if (hfontOld)
                SelectObject(hdc, hfontOld);

            if (hfont)
                DeleteObject(hfont);

            if ( _hpalHalftone )
            {
                (void) SelectPalette( hdc, hpalOld, TRUE );
                RealizePalette( hdc );
            }

            // remove the final bitmap
            SelectObject( hdc, hTmp );
            hr = S_OK;

            if (FAILED(hr))
            {
                DeleteObject(hbmp);
                hbmp = NULL;
            }
        }

        DeleteDC(hdc);
    }
    ReleaseDC( GetHWND(), hTBDC );

    *phBmpLogo = hbmp;

    return hr;
}

HRESULT CLogoBase::FlushLogoCache( )
{
    HRESULT hr = E_UNEXPECTED;

    if (_pLogoCache)
    {
        // forcibly clear out the logo cache so the items get refetched ...
        _pLogoCache->Flush(TRUE);
        hr = S_OK;
    }

    return hr;
}


HRESULT CLogoBase::DitherBitmap( HBITMAP hBmp, HBITMAP * phBmpNew )
{
//     if ( !phBmpNew )
//     {
//         return E_INVALIDARG;
//     }
//
//     if ( _dwClrDepth > 8)
//     {
//         *phBmpNew = hBmp;
//         return S_FALSE;
//     }
//
//     IIntDitherer * pDither;
//     HRESULT hr = CoCreateInstance( CLSID_IntDitherer,
//                                    NULL,
//                                    CLSCTX_INPROC_SERVER,
//                                    IID_IIntDitherer,
//                                    (void **) & pDither );
//     if ( FAILED( hr ))
//     {
//         return hr;
//     }
//
//     static BYTE rgb[32768];
//     static BOOL fInit = FALSE;
//
//     if ( !fInit )
//     {
//         // init the inverse color map table
//         SHGetInverseCMAP( rgb, sizeof( rgb ));
//         fInit = TRUE;
//     }
//
//     HDC hMemDc = CreateCompatibleDC( NULL );
//     if ( !hMemDc )
//     {
//         pDither->Release();
//         return E_FAIL;
//     }
//
//     HBITMAP hOld = SelectObject( hdc, hBmp );
//
//     BITMAPINFO bi;
//
//     ZeroMemory( &bi, sizeof( bi ));
//     bi.bmiHeader.biSize = sizeof( BITMAPINFOHEADER );
//     bi.bmiHeader.biBitCount = 0;
//     bi.bmiHeader.biCompression = 0;
//
//     // get the header information....
//     iRet = GetDIBits( hMemDc, hBmp, 0, 0, NULL, &bi, DIB_RGB_COLORS );
//     if ( iRet != 0 )
//     {
//         LPVOID  pBuffer, pBits;
//         int iOffset = 0;
//
//         if ( bi.bmiHeader.biCompression == BI_BITFIELDS )
//         {
//             iOffset = sizeof( DWORD ) * 3;
//         }
//         else if ( bi.bmiHeader.biBitCount <= 8 )
//         {
//             if ( bi.bmiHeader.biClrUsed )
//             {
//                 iOffset = sizeof( RGBQUAD ) * bi.bmiHeader.biClrUsed;
//             }
//             else
//             {
//                 iOffset = (1 << bi.bmiHeader.biBitCount) * sizeof( RGBQUAD );
//             }
//         }
//
//         bi.bmiHeader.biHeight = iHeight;
//
//         // calc
//         pBuffer = LocalAlloc( LPTR, sizeof( BITMAPINFOHEADER ) +
//             bi.bmiHeader.biSizeImage +
//             iOffset );
//
//         // calc the size of the colour table so we put the data afterwards...
//         pBits = (( LPBYTE )pBuffer ) + sizeof( BITMAPINFOHEADER ) + iOffset;
//
//         CopyMemory( pBuffer, &bi, sizeof( BITMAPINFOHEADER ) );
//         iRet = GetDIBits( hMemDc, hBmp, 0, iHeight, pBits,
//                           ( LPBITMAPINFO )pBuffer, DIB_RGB_COLORS );
//
//
//         // we know we are going to 256 colour bitmap, so create a DIBSECTION as the destination ...
//         pDither->DitherTo8bpp(  BYTE * pDestBits, LONG nDestPitch,
//                         BYTE * pSrcBits, LONG nSrcPitch, REFGUID bfidSrc,
//                         RGBQUAD * prgbDestColors, RGBQUAD * prgbSrcColors,
//                         rgb,
//                         LONG x, LONG y, LONG cx, LONG cy,
//                         -1, -1);
//     }
//     pDither->Release();

    ASSERT( FALSE );
    return E_NOTIMPL;
}

int CLogoBase::AddIndicesToLogoList( int iIcon, UINT uIndex )
{
    int iRet = -1;

    LogoIndex * pIndex;
    LogoIndex rgNew;

    rgNew.iIcon = iIcon;
    rgNew.iLogo = (int) uIndex;

    if ( _fWide )
    {
        EnterCriticalSection( &s_csSharedLogos );
    }

    // scan to see if we have an extact match already in there...
    for ( int n = 0; n < DSA_GetItemCount( _hdsaLogoIndices ); n ++ )
    {
        pIndex = (LogoIndex *) DSA_GetItemPtr( _hdsaLogoIndices, n );
        ASSERT( pIndex );
        if ( pIndex->iLogo == (int) uIndex )
        {
            // set the icon just incase it changed...
            pIndex->iIcon = iIcon;
            iRet = n;
            break;
        }
    }

    if ( iRet == -1 )
    {
        iRet = DSA_AppendItem( _hdsaLogoIndices, &rgNew );
    }

    if ( _fWide )
    {
        LeaveCriticalSection( &s_csSharedLogos );
    }

    return iRet;
}

int CLogoBase::FindLogoFromIcon( int iIcon, int * piLastLogo )
{
    int iRet = -1;

    if ( !piLastLogo )
    {
        return -1;
    }

    LogoIndex * pIndex;

    if ( _fWide )
    {
        EnterCriticalSection( &s_csSharedLogos );
    }

    for ( int n = *piLastLogo + 1; n < DSA_GetItemCount( _hdsaLogoIndices ); n ++ )
    {
        pIndex = (LogoIndex *) DSA_GetItemPtr( _hdsaLogoIndices, n );
        ASSERT( pIndex );

        if ( pIndex->iIcon == iIcon )
        {
            *piLastLogo = n;
            iRet = pIndex->iLogo;
            break;
        }
    }

    if ( _fWide )
    {
        LeaveCriticalSection( &s_csSharedLogos );
    }

    return iRet;
}

HRESULT CISFBand_CreateEx(IShellFolder* psf, LPCITEMIDLIST pidl, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = E_FAIL;

    if (psf || pidl)
    {
        IShellFolderBand *psfb;
        hr = CoCreateInstance(CLSID_ISFBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellFolderBand, &psfb));
        if (SUCCEEDED(hr))
        {
            hr = psfb->InitializeSFB(psf, pidl);
            if (SUCCEEDED(hr))
            {
                hr = psfb->QueryInterface(riid, ppv);
            }
            psfb->Release();
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\isfmenu.cpp ===
//
// isfmenu.cpp
//
// callback for chevron drop-down menu for isfbands
//

#include "priv.h"
#include "sccls.h"
#include "isfmenu.h"
#include "legacy.h"
#include "util.h"

// *** IUnknown methods ***
STDMETHODIMP CISFMenuCallback::QueryInterface (REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CISFMenuCallback, IShellMenuCallback),
        QITABENT(CISFMenuCallback, IObjectWithSite),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

STDMETHODIMP_(ULONG) CISFMenuCallback::AddRef ()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CISFMenuCallback::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if( _cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

BOOL CISFMenuCallback::_IsVisible(LPITEMIDLIST pidl)
{
    if (_poct) {
        VARIANTARG v;

        v.vt = VT_INT_PTR;
        v.byref = pidl;

        HRESULT hr = _poct->Exec(&CGID_ISFBand, ISFBID_ISITEMVISIBLE, 0, &v, NULL);
        return (hr == S_OK);
    }

    return FALSE;
}


HRESULT IUnknown_SeekToZero(IUnknown* punk)
{
    HRESULT hres = E_FAIL;
    IStream* pstm;
    if (punk && SUCCEEDED(punk->QueryInterface(IID_IStream, (void**)&pstm)))
    {
        // We need to seek to the beginning of the stream here. We don't do this in
        // the menubands because it's rude: They should not seek to the beginning
        // because there may be information that needs to be saved after them.
        //Set the seek pointer at the beginning.
        const LARGE_INTEGER li0 = {0};
        hres = pstm->Seek(li0, STREAM_SEEK_SET, NULL);
        pstm->Release();
    }

    return hres;
}

HRESULT CISFMenuCallback::_GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = S_FALSE;
    *ppvObj = NULL;
    if (IsEqualIID(riid, IID_IStream))
    {
        if (_pidl && psmd->pidlFolder && psmd->pidlItem)
        {
            // Verify that the Cascading menuband is ONLY asking for this folder.
            // because if there is a sub menu, It's going to ask again with the
            // pidl of that folder, which we don't have the Stream for, and we
            // can hose things pretty good if we indescriminatly hand out order streams

            LPITEMIDLIST pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlFull)
            {
                if (_poct && ILIsEqual(pidlFull, _pidl)) 
                {
                    VARIANTARG v = {0};

                    v.vt = VT_UNKNOWN;
                    hres = _poct->Exec(&CGID_ISFBand, ISFBID_GETORDERSTREAM, 0, NULL, &v);

                    if (SUCCEEDED(hres))
                    {
                        IUnknown_SeekToZero(v.punkVal);

                        hres = v.punkVal->QueryInterface(riid, ppvObj);
                        v.punkVal->Release();
                    }
                }
                ILFree(pidlFull);
            }
        }
    }
    return hres;
}

HRESULT CISFMenuCallback::_SetObject(LPSMDATA psmd, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;

    if (IsEqualIID(riid, IID_IStream))
    {
        if (_pidl && psmd->pidlFolder && psmd->pidlItem)
        {
            // Verify that the Cascading menuband is ONLY asking for this folder.
            // because if there is a sub menu, It's going to ask again with the
            // pidl of that folder, which we don't have the Stream for, and we
            // can hose things pretty good if we indescriminatly hand out order streams

            LPITEMIDLIST pidlFull = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlFull)
            {
                if (_poct && ILIsEqual(pidlFull, _pidl)) 
                {
                    ASSERT(ppvObj);

                    VARIANTARG v;

                    v.vt = VT_UNKNOWN;
                    v.punkVal = *(IUnknown**)ppvObj;

                    IUnknown_SeekToZero(*(IUnknown**)ppvObj);

                    hres = _poct->Exec(&CGID_ISFBand, ISFBID_SETORDERSTREAM, 0, &v, NULL);
                }
                ILFree(pidlFull);
            }
        }
    }

    return hres;
}


HRESULT CISFMenuCallback::_GetSFInfo(LPSMDATA psmd, PSMINFO psminfo)
{
    // We only want to filter pidls if:
    //  1) It's at the root of the links chevron menu
    //  2) It's _IS_ visible in the links bar. We don't want to show links
    //     in this menu that are visible.
    if (psmd->uIdAncestor == ANCESTORDEFAULT &&
        (psminfo->dwMask & SMIM_FLAGS)       && 
        _IsVisible(psmd->pidlItem))
    {
        // not obscured on the subject isfband; exclude from menu
        psminfo->dwFlags |= SMIF_HIDDEN;
    }

    return S_OK;
}

// *** IShellMenuCallback methods ***
STDMETHODIMP CISFMenuCallback::CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_FALSE;

    switch (uMsg) 
    {
    case SMC_SFEXEC:
        hr = SHNavigateToFavorite(psmd->psf, psmd->pidlItem, _punkSite, SBSP_DEFBROWSER | SBSP_DEFMODE);
        break;

    case SMC_GETSFINFO:
        hr = _GetSFInfo(psmd, (PSMINFO)lParam);
        break;

    case SMC_GETSFOBJECT:
        hr = _GetObject(psmd, *((GUID*)wParam), (void**)lParam);
        break;

    case SMC_SETSFOBJECT:
        hr = _SetObject(psmd, *((GUID*)wParam), (void**)lParam);
        break;

    }

    return hr;
}

// *** IObjectWithSite methods ***
STDMETHODIMP CISFMenuCallback::SetSite(IUnknown* punkSite)
{
    if (punkSite != _punkSite)
        IUnknown_Set(&_punkSite, punkSite);

    return S_OK;
}


HRESULT CISFMenuCallback::Initialize(IUnknown* punk)
{
    HRESULT hr = E_FAIL;

    if (punk)
        hr = punk->QueryInterface(IID_IOleCommandTarget, (PVOID*)&_poct);

    IShellFolderBand* psfb;
    hr = punk->QueryInterface(IID_IShellFolderBand, (PVOID*)&psfb);

    if (SUCCEEDED(hr)) 
    {
        BANDINFOSFB bi;
        bi.dwMask = ISFB_MASK_IDLIST | ISFB_MASK_SHELLFOLDER;

        hr = psfb->GetBandInfoSFB(&bi);
        _pidl = bi.pidl;
        if (bi.psf)
            bi.psf->Release();
        psfb->Release();
    }

    return hr;
}

CISFMenuCallback::CISFMenuCallback() : _cRef(1)
{
}

CISFMenuCallback::~CISFMenuCallback()
{
    ASSERT(_cRef == 0);

    ILFree(_pidl);

    ATOMICRELEASE(_poct);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\isfmenu.h ===
// CISFMenuCallback implementation

#ifndef _ISFMENU_H
#define _ISFMENU_H

#include "cowsite.h"

class CISFMenuCallback : public IShellMenuCallback,
                           public CObjectWithSite
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG)  Release();

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA smd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown* punkSite);

    CISFMenuCallback();
    HRESULT Initialize(IUnknown* punk);

private:
    virtual ~CISFMenuCallback();

    HRESULT _GetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    HRESULT _SetObject(LPSMDATA psmd, REFIID riid, void** ppvObj);
    BOOL _IsVisible(LPITEMIDLIST pidl);
    HRESULT _GetSFInfo(LPSMDATA psmd, PSMINFO psminfo);

    int _cRef;
    IOleCommandTarget* _poct;    // our isfband subject
    IUnknown* _punkSite;
    LPITEMIDLIST _pidl;
};

#endif // _ISFMENU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\menuband.h ===
#ifndef _MENUBAND_H_
#define _MENUBAND_H_

#include "bands.h"
#include "mnbase.h"
#include "fadetsk.h"
#include "legacy.h"

#define CGID_MenuBand CLSID_MenuBand

// Flags for MBANDCID_POPUPITEM

#define MBPUI_SETITEM           0x00001
#define MBPUI_INITIALSELECT     0x00002
#define MBPUI_ITEMBYPOS      0x00004

#ifdef STARTMENUSPLIT
// Flags for constructor
#define MENUBAND_HORIZ      0x00000001
#define MENUBAND_TOPLEVEL   0x00000002
#endif

// Special indices for MBANDCID_SELECTITEM
#define MBSI_FIRSTITEM       0
#define MBSI_NONE           -1
#define MBSI_LASTITEM       -2

// This arrow is used when we are in Right-To-Left Mirror mode
#define CH_MENUARROWRTLA '3'

// Forward declare
struct CMBMsgFilter;

// Define this to get Shell Expando menu style
// Undefine to get "Office IntelliMenu" style
//#define DRAWEDGE

// The CMenuBand class handles all menu behavior for bands.  

class CMenuBandMetrics : public IUnknown
{
public:
    // *** IUnknown methods ***
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    HFONT   _CalcFont(HWND hwnd, LPCTSTR pszFont, DWORD dwCharSet, TCHAR ch, int* pcx, 
        int* pcy, int* pcxMargin, int iOrientation, int iWeight);
    void    _SetMenuFont();         // (Called for TopLevMBand only) Sets: _hFontMenu
    void    _SetArrowFont(HWND hwnd);        // (Called for TopLevMBand only) Sets: _hFontArrow, _cyArrow
    void    _SetChevronFont(HWND hwnd);
    void    _SetTextBrush(HWND hwnd);

#ifndef DRAWEDGE
    void    _SetPaintMetrics(HWND hwnd);
#endif
    void    _SetColors();
    int     _cyArrow;               // Height of cascade arrow
    int     _cxArrow;               // Width of cascade arrow
    int     _cxMargin;              // Margin b/t text and arrow
    int     _cyChevron;
    int     _cxChevron;
    int     _cxChevronMargin;
    HCURSOR _hCursorOld;            // Cursor that was in use prior to entering menu mode
    HFONT   _hFontMenu;             // Font for menu text
    HFONT   _hFontArrow;            // Correct sized Marlett font for cascade arrow
    HFONT   _hFontChevron;
    HBRUSH  _hbrText;
#ifndef DRAWEDGE
    HPEN    _hPenHighlight;            // Pen for BTNHIGHLIGHT
    HPEN    _hPenShadow;               // Pen for BTNSHADOW
#endif

    COLORREF _clrBackground;
    COLORREF _clrDemoted;
    COLORREF _clrMenuText;

    BITBOOL  _fHighContrastMode;        // Accessibility

    CMenuBandMetrics(HWND hwnd);

private:
    ~CMenuBandMetrics();

    ULONG _cRef;
};


class CMenuBandState
{

    // Global State Variables
    BYTE    _fsUEMState;
    BOOL    _fKeyboardCue;
    CFadeTask* _ptFader;
    IShellTaskScheduler* _pScheduler;
    HWND    _hwndSubclassed;
    HWND    _hwndToolTip;
    HWND    _hwndWorker;
    void*   _pvContext;

    // Bits
    BITBOOL _fExpand: 1;
    BITBOOL _fContainsDrag: 1;
    BITBOOL _fTipShown: 1;
    BITBOOL _fBalloonStyle: 1;

    int     _cChangeNotify;

    // This will, in the future, contain the menuband stack
public:
    CMenuBandState();
    virtual ~CMenuBandState();

    // Set/Get the expand state for new popups.
    BOOL GetExpand()                { return (BOOL)_fExpand;      };
    void SetExpand(BOOL fExpand)    { _fExpand = BOOLIFY(fExpand);};
    BYTE GetUEMState()              { return _fsUEMState;         };
    void SetUEMState(BYTE bState)   { _fsUEMState = bState;       };
    BOOL GetKeyboardCue();
    void SetKeyboardCue(int iKC);
    BOOL HasDrag()                  { return _fContainsDrag;      };
    void HasDrag(BOOL fHasDrag)     { _fContainsDrag = BOOLIFY(fHasDrag); };
    void SetSubclassedHWND(HWND hwndSubclassed)   
                                    { _hwndSubclassed = hwndSubclassed; };
    HWND GetSubclassedHWND()        { return _hwndSubclassed; };
    HWND GetWorkerWindow(HWND hwndParent);
    void PushChangeNotify()         { ++_cChangeNotify; };
    void PopChangeNotify()          { --_cChangeNotify; };
    BOOL IsProcessingChangeNotify() { return _cChangeNotify != 0;   };

    // Context Stuff
    // a menuband context is used for the global message filter. Since we may have
    // more than one menu present in the system, there is a race condition that can occur
    // where the menu in one thread tries to pop off it's menus, when a menuband in another thread
    // tries to push them on. Through the use of a context, we can know when this is happening and
    // make sure that we pop all of the menus of one context before pushing from another.
    // - lamadio 9.15.98
    void SetContext(void* pvContext)    {_pvContext = pvContext;};
    void* GetContext()                  { return _pvContext;};

    // Fade Stuff
    BOOL FadeRect(PRECT prc, PFNFADESCREENRECT pfn, LPVOID pvParam);
    void CreateFader(HWND hwnd);
    IShellTaskScheduler* GetScheduler();

    // Chevron Tip Stuff
    void CenterOnButton(HWND hwndTB, BOOL fBalloon, int idCmd, LPTSTR pszTitle, LPTSTR szTip);
    void HideTooltip(BOOL fAllowBalloonCollapse);
    void PutTipOnTop();
};



interface IShellMenuAcc: public IUnknown
{
    // *** IShellMenuAcc methods ***
    STDMETHOD(GetTop)(THIS_ CMenuToolbarBase** ppmtbTop) PURE;
    STDMETHOD(GetBottom)(THIS_ CMenuToolbarBase** ppmtbBottom) PURE;
    STDMETHOD(GetTracked)(THIS_ CMenuToolbarBase** ppmtbTracked) PURE;
    STDMETHOD(GetParentSite)(THIS_ REFIID riid, void** ppvObj) PURE;
    STDMETHOD(GetState)(THIS_ BOOL* pfVertical, BOOL* pfOpen) PURE;
    STDMETHOD(DoDefaultAction)(THIS_ VARIANT* pvarChild) PURE;
    STDMETHOD(GetSubMenu)(THIS_ VARIANT* pvarChild, REFIID riid, void** ppvObj) PURE;
    STDMETHOD(IsEmpty)() PURE;
};

// {FAF6FE96-CE5E-11d1-8371-00C04FD918D0}
DEFINE_GUID(IID_IShellMenuAcc,              0xfaf6fe96, 0xce5e, 0x11d1, 0x83, 0x71, 0x0, 0xc0, 0x4f, 0xd9, 0x18, 0xd0);



class CMenuBand : public CToolBand,
                  public IMenuPopup,
                  public IMenuBand,
                  public IShellMenu2,
                  public IWinEventHandler,
                  public IShellMenuAcc
{
    // REVIEW (lamadio): I don't like this. Should I make these nested classes?
    friend class CMenuToolbarBase;
    friend class CMenuSFToolbar;
    friend class CMenuStaticToolbar;
    friend struct CMBMsgFilter;

public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) 
        { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void)
        { return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);
    
    // *** IInputObject methods (override) ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IDeskBar methods ***
    virtual STDMETHODIMP SetClient(IUnknown* punk) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetClient(IUnknown** ppunkClient) { return E_NOTIMPL; };
    virtual STDMETHODIMP OnPosRectChangeDB (LPRECT prc);

    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags) { return E_NOTIMPL; };

    // *** IMenuBand methods ***
    virtual STDMETHODIMP IsMenuMessage(MSG * pmsg);
    virtual STDMETHODIMP TranslateMenuMessage(MSG * pmsg, LRESULT * plRet);

    // *** IShellMenu methods ***
    virtual STDMETHODIMP Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags);
    virtual STDMETHODIMP GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags);
    virtual STDMETHODIMP SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags);
    virtual STDMETHODIMP GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual STDMETHODIMP InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual STDMETHODIMP GetState(LPSMDATA psmd);
    virtual STDMETHODIMP SetMenuToolbar(IUnknown* punk, DWORD dwFlags);

    // *** IShellMenu2 methods ***
    virtual STDMETHODIMP GetSubMenu(UINT idCmd, REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP SetToolbar(HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP SetMinWidth(int cxMenu);
    virtual STDMETHODIMP SetNoBorder(BOOL fNoBorder);
    virtual STDMETHODIMP SetTheme(LPCWSTR pszTheme);

    // ** IPersist ***
    virtual STDMETHODIMP GetClassID(CLSID*) { return E_NOTIMPL; };
    virtual STDMETHODIMP Load(IStream*) { return E_NOTIMPL; };
    virtual STDMETHODIMP Save(IStream*, BOOL) { return E_NOTIMPL; };

    // ** IWinEventHandler ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);


    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);

    // *** IShellMenuAcc ***
    virtual STDMETHODIMP GetTop(CMenuToolbarBase** ppmtbTop);
    virtual STDMETHODIMP GetBottom(CMenuToolbarBase** ppmtbBottom);
    virtual STDMETHODIMP GetTracked(CMenuToolbarBase** ppmtbTracked);
    virtual STDMETHODIMP GetParentSite(REFIID riid, void** ppvObj);
    virtual STDMETHODIMP GetState(BOOL* pfVertical, BOOL* pfOpen);
    virtual STDMETHODIMP DoDefaultAction(VARIANT* pvarChild);
    virtual STDMETHODIMP GetSubMenu(VARIANT* pvarChild, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP IsEmpty();
    
    // Other methods
    LRESULT GetMsgFilterCB(MSG * pmsg, BOOL bRemove);
    inline BOOL IsInSubMenu(void)       { return _fInSubMenu; };
    inline DWORD GetFlags()   {return _dwFlags; };
    
    // Other public methods
    void    ResizeMenuBar();        // Make our parent menubar resize
    void    SetTrackMenuPopup(IUnknown* punk);
    HRESULT ForwardChangeNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);   // Change notify Forwarder.

    CMenuBand();


    BOOL    SetTracked(CMenuToolbarBase* pmtb);

#ifdef UNIX
    BOOL RemoveTopLevelFocus();
#endif

private:

    friend HRESULT     CMenuBand_CreateInstance(IUnknown * punkOuter, IUnknown ** ppunk, LPCOBJECTINFO poi);
    friend CMenuBand * CMenuBand_Create(IShellFolder * psf, LPCITEMIDLIST pidl, BOOL bTopLevel);
    friend VOID CALLBACK CMenuBand_TimerProc( HWND hwnd, UINT uMsg, UINT idEvent, DWORD dwTime );

    virtual ~CMenuBand();

    void    _Initialize(DWORD dwFlags);// Flags are MENUBAND_*

    HRESULT _EnterMenuMode(void);
    void    _ExitMenuMode(void);
    void    _GetFontMetrics();      // (Called for non-TopLevelMBands) Uses IUnk_QS to set
                                    //  _hFontMenu, _hFontArrow, _cyArrow based on TopLevel's values
    void    _CancelMode(DWORD dwType);
    void    _AddToolbar(CMenuToolbarBase* pmtb, DWORD dwFlags);
    HRESULT _SiteOnSelect(DWORD dwType);
    HRESULT _SubMenuOnSelect(DWORD dwType);

    HRESULT _OnSysChar(MSG * pmsg, BOOL bFirstDibs);
    HRESULT _HandleAccelerators(MSG * pmsg);

    HRESULT _SiteSetSubMenu(IMenuPopup * pmp, BOOL bSet);

    void    _OnSelectArrow(int iDir);
    void    _UpdateButtons();

    HRESULT _CallCB(DWORD dwMsg, WPARAM wParam = 0, LPARAM lParam = 0);
    HRESULT _ProcessMenuPaneMessages(MSG* pmsg);

    
    // Member variables
    int     _nItemCur;              // Current item selected
    int     _nItemNew;              // New item to be selected/expanded
    int     _nItemTimer;            // the timer id for popping up cascading menus
    int     _nItemMove;             // Current item being moved
    int     _nItemSubMenu;          // item that's cascaded
    HWND    _hwndFocusPrev;
    HWND    _hwndParent;

    CMenuToolbarBase*   _pmtbMenu;          // The static menu toolbar 
                                            //  (may be pmtbTop or pmtbBottom)
    CMenuToolbarBase*   _pmtbShellFolder;   // Non-menu toolbar (shellfolder or other)
                                            //  (may be pmtbTop or pmtbBottom)
    
    CMenuToolbarBase*   _pmtbTop;           // The top toolbar
    CMenuToolbarBase*   _pmtbBottom;        // The bottom toolbar (may be == pmtbTop)
    CMenuToolbarBase*   _pmtbTracked;       // This is transient, may be pmtbTop or pmtbBottom

    IAugmentedShellFolder2* _pasf2;

    UINT    _uId;       // Id of this band (Derived from the item that poped it up)
    UINT    _uIdAncestor;   // Id of the top most menu item.
    HMENU   _hmenu;
    HWND    _hwndMenuOwner;
    DWORD   _dwMenuFlags;


    CMenuBandState*     _pmbState;              // Menu Band global state
    CMenuBandMetrics*   _pmbm;
    IShellMenuCallback* _psmcb;             // Callback Mechanism
    HCURSOR             _hCursorOld;
    DWORD               _dwFlags;
    UINT                _uIconSize;

    IMenuPopup*         _pmpSubMenu;        // Cached submenu
    IMenuPopup*         _pmpTrackPopup;     // BUGBUG: Find a way to use only menubands.

    void*               _pvUserData;        // User associated data.


    BITBOOL _fTopLevel: 1;          // TRUE: this is the toplevel parent menu
                                    //       (may be vertical for context menus)
    BITBOOL _fMenuMode: 1;          // TRUE: we are in menu mode
    BITBOOL _fPopupNewMenu: 1;      // TRUE: popup a new menu (_nItemNew) 
                                    //    once done with current menu
    BITBOOL _fInitialSelect: 1;     // TRUE: select first item when popping up submenu
    BITBOOL _fInSubMenu: 1;         // TRUE: currently in a submenu
    BITBOOL _fAltSpace: 1;          // TRUE: Alt-space was hit
    BITBOOL _fMenuFontCreated: 1;   // TRUE: This instance created the font and should delete it
    BITBOOL _fArrowFontCreated: 1;  // TRUE: This instance created the font and should delete it
    BITBOOL _fEmpty: 1;             // TRUE: Menu is empty
    BITBOOL _fParentIsNotASite: 1;  
    BITBOOL _fKeyboardSelected: 1;  
    BITBOOL _fInvokedByDrag: 1;     // TRUE: the menu cascaded open b/c of drag/drop
    BITBOOL _fDragEntered : 1;
    BITBOOL _fSysCharHandled: 1;    // TRUE: WM_SYSCHAR was already handled
    BITBOOL _fHasSubMenu:1;
    BITBOOL _fAppActive:1;       // TRUE: The Menus should be drawn using Memphis' grey menu.
    BITBOOL _fVertical: 1;
    BITBOOL _fShow : 1;
    BITBOOL _fClosing: 1;           // TRUE: When CloseDW is called.
    BITBOOL _fForceButtonUpdate: 1; // TRUE: Force a v_UpdateButtons.
    BITBOOL _fProcessingDup: 1;     // TRUE: when the contained classes are processing Dup chars.
    BITBOOL _fExpanded: 1;          // TRUE: This band is expanded
    BITBOOL _fCascadeAnimate: 1;
    BITBOOL _fPopupNewItemOnShow: 1;    // Causes _nItemNew to be displayed at ShowDW time.
    BITBOOL _fParentIsHorizontal: 1;

#ifdef DEBUG
    BITBOOL _fInitialized: 1;
#endif
    

    DEBUG_CODE( int _nMenuLevel; )
};

CMenuBand * CMenuBand_Create(IShellFolder * psf, LPCITEMIDLIST pidl, BOOL bHorizontal);
int MsgFilter_GetCount();
HRESULT IUnknown_BandChildSetKey(IUnknown* punk, HKEY hKey);

// The message filter redirects messages to the menuband
// that is at the top of the stack.  Each additional cascade
// pushes the new menuband onto the stack, and a cancel-level
// pops one off.
typedef struct tagMBELEM
{
    CMenuBand * pmb;
    HWND        hwndTB;
    HWND        hwndBar;
    RECT        rc;             // rect of hwndBar
    BITBOOL     bInitRect: 1;   // TRUE: rc is initialized
} MBELEM;

#define CMBELEM_INIT    10
#define CMBELEM_GROW    10

struct CMBMsgFilter
{
public:
    HHOOK       _hhookMsg;
    HWND        _hwndCapture;
    FDSA        _fdsa;              // Stack
    MBELEM      _rgmbelem[CMBELEM_INIT];
    BITBOOL     _fPreventCapture : 1;
    BITBOOL     _fInitialized: 1;
    BITBOOL     _fSetAtPush: 1;
    BITBOOL     _fDontIgnoreSysChar: 1;
    BITBOOL     _fEngaged: 1;
    BITBOOL     _fModal: 1;
    BITBOOL     _fAllocated: 1;
    POINT       _ptLastMove;
    CMenuBand*  _pmb;
    int         _iSysCharStack;
    void*       _pvContext;
    HCURSOR     _hcurArrow;
    int         _cRef;
    
    DEBUG_CODE( int _nMenuLevel; )
    void    AddRef();
    void    Release();


    void    ForceModalCollapse();
    void    SetModal(BOOL fModal);      // This is so that
                                        // a modal message band (Links)
                                        // sets activation correctly.
    void*   GetContext()    {   return _pvContext;  };
    void    SetContext(void* pvContext, BOOL fSet);
    void    Push(void* pvContext, CMenuBand * pmb, IUnknown * punkSite);
    int     Pop(void* pvContext);
    void    RetakeCapture(void);
    void    AcquireMouseLocation()   { GetCursorPos(&_ptLastMove); };


    void    ReEngage(void* pvContext);
    void    DisEngage(void* pvContext);
    BOOL    IsEngaged()  { return _fEngaged;};

    CMenuBand * _GetBottomMostSelected(void);
    CMenuBand * _GetTopPtr(void);
    CMenuBand * _GetWindowOwnerPtr(HWND hwnd);
    CMenuBand * _HitTest(POINT pt, HWND * phwnd = NULL);
    LRESULT     _HandleMouseMsgs(MSG * pmsg, BOOL bRemove);
    int         GetCount();
    void        PreventCapture(BOOL bSet) { _fPreventCapture = BOOLIFY(bSet); }
    CMenuBand * GetTopMostPtr(void)         { return _pmb; };
    void        SetTopMost(CMenuBand* pmb)  {_pmb = pmb; };
    void        SetHook(BOOL fSet, BOOL fIgnoreSysChar); 

    static LRESULT CALLBACK GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam);

//private:
};

CMBMsgFilter* GetMessageFilter();

extern CMBMsgFilter g_msgfilter;
extern UINT    g_nMBPopupOpen;
extern UINT    g_nMBFullCancel;
extern UINT    g_nMBDragCancel;
extern UINT    g_nMBAutomation;
extern UINT    g_nMBExecute;
extern UINT    g_nMBOpenChevronMenu;
extern long g_lMenuPopupTimeout;


#define MBTIMER_POPOUT      0x00008001         // event ID for popout menu timer
#define MBTIMER_DRAGOVER    0x00008002         // event ID for popout menu timer
#define MBTIMER_EXPAND      0x00008003
#define MBTIMER_TIMEOUT     (GetDoubleClickTime() * 4 / 5) // same formula that USER uses

#define MBTIMER_ENDEDIT     0x00008004
#define MBTIMER_ENDEDITTIME 1000

#define MBTIMER_CLOSE       0x00008005
#define MBTIMER_CLOSETIME   2000

#define MBTIMER_CLICKUNHANDLE 0x00008006

// Flashing Support
#define MBTIMER_FLASH       0x00008007
#define MBTIMER_FLASHTIME   100
#define COUNT_ENDFLASH      8

// UEM Profiling.
#define MBTIMER_UEMTIMEOUT  0x00008008

#define MBTIMER_DRAGPOPDOWN 0x00008009
#define MBTIMER_DRAGPOPDOWNTIMEOUT     (2 * GetDoubleClickTime()) //ASSERT(MBTIMER_DRAGPOPDOWNTIMEOUT > 
                                                        // MBTIMER_TIMEOUR)

#define MBTIMER_CHEVRONTIP  0x0000800A

#define MBTIMER_INFOTIP     0x0000800B
#define CH_RETURN       0xd

#define szfnMarlett     TEXT("MARLETT")

#endif  // _MENUBAND_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\menuband.cpp ===
#include "priv.h"
#include "sccls.h"
#include "menuband.h"
#include "itbar.h"
#include "bands.h"
#include "isfband.h"
#include "menubar.h"
#include "dpastuff.h"       // COrderList_*
#include "theater.h"
#include "resource.h"
#include "oleacc.h"
#include "apithk.h"
#include "uemapp.h"
#include "mnbase.h"
#include "mnfolder.h"
#include "mnstatic.h"
#include "iaccess.h"
#include "tbmenu.h"

#include "mluisupp.h"

// BUGBUG (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"

#define DM_MISC     0               // miscellany

#define PF_USINGNTSD    0x00000400      // set this if you're debugging on ntsd

// This must be reset to -1 on any WM_WININICHANGE.  We do it in
// shbrows2.cpp, but if there are no browser windows open when the
// metric changes, we end up running around with a stale value.  Oh well.
long g_lMenuPopupTimeout = -1;
static DWORD g_tlsMessageFilter = -1;


// {AD35F50A-0CC0-11d3-AE2D-00C04F8EEA99}
static const CLSID CLSID_MenuBandMetrics =
{ 0xad35f50a, 0xcc0, 0x11d3, { 0xae, 0x2d, 0x0, 0xc0, 0x4f, 0x8e, 0xea, 0x99
} };

// Registered window messages for the menuband
UINT    g_nMBPopupOpen = 0;
UINT    g_nMBFullCancel = 0;
UINT    g_nMBDragCancel = 0;
UINT    g_nMBAutomation = 0;
UINT    g_nMBExecute = 0;
UINT    g_nMBOpenChevronMenu = 0;
HCURSOR g_hCursorArrow = NULL;
//UINT    g_nMBIgnoreNextDeselect = 0;  // Dealt with in menuisf.cpp

BOOL IsAncestor(HWND hwndChild, HWND hwndAncestor)
{
    HWND hwnd = hwndChild;
    while (hwnd != hwndAncestor && hwnd != NULL)
    {
        hwnd = GetParent(hwnd);
    } 

    return hwndAncestor == hwnd;
}

//=================================================================
// Implementation of menuband message filter
//=================================================================

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg);


// Just one of these, b/c we only need one message filter
CMBMsgFilter g_msgfilter = { 0 };     

void FreeMessageFilter(CMBMsgFilter* that)
{
    if (g_tlsMessageFilter != -1)
    {
        CMBMsgFilter* pmf = (CMBMsgFilter*)TlsGetValue(g_tlsMessageFilter);

        if (pmf == that)
        {
            TlsSetValue(g_tlsMessageFilter, NULL);
        }
    }
}

void CMBMsgFilter::AddRef()
{
    _cRef++;

}

void CMBMsgFilter::Release()
{
    _cRef--;
    if (_cRef <= 0 && _fAllocated)
    {
        FreeMessageFilter(this);
        delete this;
    }
}

void CMBMsgFilter::SetModal(BOOL fModal)
{
    // There was an interesting problem:
    //   Click on the Chevron menu. Right click Delete. 
    //   The menus were hosed
    // Why?
    //   Well, I'll tell you:
    //   We got a deactivate on the subclassed window. We have
    //   2 menus subclassing it: The Main menu, and the modal
    //   chevron menu. Problem is, the main menu snagged the WM_ACTIVATE
    //   and does a set context. This causes a Pop and releases the Message hook.
    //   Since I still had a menu up, this caused havoc.
    //   So I introduced a concept of a "Modal" menuband. 
    //   This says: "Ignore any request to change contexts until I'm done". When
    //   that modal band is done, it sets the old context back in.
    //   Seems like a hack, but we need a better underlying archtecture for
    //   the message passing.
    _fModal = fModal;
}

void CMBMsgFilter::ReEngage(void* pvContext)      
{ 
    // We need to make sure that we don't dis/reengage when 
    // switching contexts
    if (pvContext == _pvContext)
        _fEngaged = TRUE; 
}

void CMBMsgFilter::DisEngage(void* pvContext)     
{ 
    if (pvContext == _pvContext)
        _fEngaged = FALSE;
}

int CMBMsgFilter::GetCount()
{
    return FDSA_GetItemCount(&_fdsa);
}

int MsgFilter_GetCount()
{
    return GetMessageFilter()->GetCount();
}

CMenuBand * CMBMsgFilter::_GetTopPtr(void)   
{ 
    CMenuBand * pmb = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, cItems-1, MBELEM); 
        pmb = pmbelem->pmb;
    }
    return pmb;
}

CMenuBand * CMBMsgFilter::_GetBottomMostSelected(void)
{
    // Ick, I can't believe I just did this. Mix COM and C++ identities... Yuck.
    CMenuBand* pmb = NULL;
    if (_pmb)
    {
        IUnknown_QueryService(SAFECAST(_pmb, IMenuBand*), SID_SMenuBandBottomSelected, CLSID_MenuBand, (void**)&pmb);

        // Since we have the C++ identity, release the COM identity.
        if (pmb)
            pmb->Release();
    }

    return pmb;
}


CMenuBand * CMBMsgFilter::_GetWindowOwnerPtr(HWND hwnd)   
{ 
    CMenuBand * pmb = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        // Go thru the list of bands on the stack and return the
        // one who owns the given window.
        int i;

        for (i = 0; i < cItems; i++)
        {
            MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, i, MBELEM); 
            if (pmbelem->pmb && S_OK == pmbelem->pmb->IsWindowOwner(hwnd))
            {
                pmb = pmbelem->pmb;
                break;
            }
        }
    }
    return pmb;
}


/*----------------------------------------------------------
Purpose: Return menuband or NULL based upon hittest.  pt must be 
         in screen coords
*/
CMenuBand * CMBMsgFilter::_HitTest(POINT pt, HWND * phwnd)
{ 
    CMenuBand * pmb = NULL;
    HWND hwnd = NULL;
    int cItems = FDSA_GetItemCount(&_fdsa);

    if (0 < cItems)
    {
        // Go thru the list of bands on the stack and return the
        // one who owns the given window.  Work backwards since the
        // later bands are on top (z-order), if the menus ever overlap.
        int i = cItems - 1;

        while (0 <= i)
        {
            MBELEM * pmbelem = FDSA_GetItemPtr(&_fdsa, i, MBELEM); 

            RECT rc;

            // Do this dynamically because the hwndBar hasn't been positioned
            // until after this mbelem has been pushed onto the msg filter stack.
            GetWindowRect(pmbelem->hwndBar, &rc);
            
            if (PtInRect(&rc, pt))
            {
                pmb = pmbelem->pmb;
                hwnd = pmbelem->hwndTB;
                break;
            }
            i--;
        }
    }

    if (phwnd)
        *phwnd = hwnd;

    return pmb;
}


void CMBMsgFilter::RetakeCapture(void)
{
    // The TrackPopupMenu submenus can steal the capture.  Take
    // it back.  Don't take it back if the we're in edit mode,
    // because the modal drag/drop loop has the capture at that
    // point.
    // We do not want to take capture unless we are engaged. 
    // We need to do this because we are not handling mouse messages lower down
    // in the code. When we set the capture, the messages that we do not handle
    // trickle up to the top level menu, and can cause weird problems (Such
    // as signaling a "click out of bounds" or a context menu of the ITBar)
    if (_hwndCapture && !_fPreventCapture && _fEngaged)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Setting capture to %#lx", _hwndCapture);
        SetCapture(_hwndCapture);
    }
}    

void CMBMsgFilter::SetHook(BOOL fSet, BOOL fDontIgnoreSysChar)
{
    if (fDontIgnoreSysChar)
        _iSysCharStack += fSet? 1: -1;

    if (NULL == _hhookMsg && fSet)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Initialize");
        _hhookMsg = SetWindowsHookEx(WH_GETMESSAGE, GetMsgHook, HINST_THISDLL, GetCurrentThreadId());
        _fDontIgnoreSysChar = fDontIgnoreSysChar;
    }
    else if (!fSet && _iSysCharStack == 0)
    {
        TraceMsg(TF_MENUBAND, "CMBMsgFilter: Hook removed");
        if (_hhookMsg)
        {
            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
        }
    }
}

// 1) Set Deskbars on Both Monitors and set to chevron
// 2) On Monitor #2 open a chevron
// 3) On Monitor #1 open a chevron then open the Start Menu
// Result: Start Menu does not work.

// The reason is, we set the _fModal of the global message filter. This prevents context switches. Why? 
// The modal flag was invented to solve context switching problems with the browser frame. So what causes this?
// Well, when switching from #2 to #3, we have not switched contexts. But since we got a click out of bounds, we collapse
// the previous menu. When switching from #3 to #4, neither have the context, so things get messy.

void CMBMsgFilter::ForceModalCollapse()
{
    if (_fModal)
    {
        _fModal = FALSE;
        SetContext(NULL, TRUE);
    }
}

void CMBMsgFilter::SetContext(void* pvContext, BOOL fSet)
{
    TraceMsg(TF_MENUBAND, "CMBMsgFilter::SetContext from 0x%x to 0x%x", _pvContext, pvContext);
    // When changing a menuband context, we need to pop all of the items
    // in the stack. This is to prevent a race condition that can occur.

    // We do not want to pop all of the items off the stack if we're setting the same context.
    // We do a set context on Activation, Both when we switch from one Browser frame to another
    // but also when right clicking or causing the Rename dialog to be displayed.

    BOOL fPop = FALSE;

    if (_fModal)
        return;

    // Are we setting a new context?
    if (fSet)
    {
        // Is this different than the one we've got?
        if (pvContext != _pvContext)
        {
            // Yes, then we need to pop off all of the old items.
            fPop = TRUE;
        }

        _pvContext = pvContext;
    }
    else
    {
        // Then we are trying to unset the message hook. Make sure it still belongs to
        // this context
        if (pvContext == _pvContext)
        {
            // This context is trying to unset itself, and no other context owns it.
            // remove all the old items.
            fPop = TRUE;
        }
    }

    if (fPop)
    {
        CMenuBand* pcmb = _GetTopPtr();
        if (pcmb)
        {
            PostMessage(pcmb->_pmbState->GetSubclassedHWND(), g_nMBFullCancel, 0, 0);
            // No release.

            if (FDSA_GetItemCount(&_fdsa) != 0)
            {
                CMBMsgFilter* pmf = GetMessageFilter();
                while (pmf->Pop(pvContext))
                    ;
            }
        }
    }
}




/*----------------------------------------------------------
Purpose: Push another menuband onto the message filter's stack

*/
void CMBMsgFilter::Push(void* pvContext, CMenuBand * pmb, IUnknown * punkSite)
{
    ASSERT(IS_VALID_CODE_PTR(pmb, CMenuBand));
    TraceMsg(TF_MENUBAND, "CMBMsgFilter::Push called from context 0x%x", pvContext);

    if (pmb && pvContext == _pvContext)
    {
        BOOL bRet = TRUE;
        HWND hwndBand;

        pmb->GetWindow(&hwndBand);

        // If the bar isn't available use the band window
        HWND hwndBar = hwndBand;
        IOleWindow * pow;

        IUnknown_QueryService(punkSite, SID_SMenuPopup, IID_IOleWindow, 
                              (LPVOID *)&pow);
        if (pow)
        {
            pow->GetWindow(&hwndBar);
            pow->Release();
        }

        if (NULL == _hhookMsg)
        {
            // We want to ignore the WM_SYSCHAR message in the message filter because
            // we are using the IsMenuMessage call instead of the global message hook.
            SetHook(TRUE, FALSE);
            TraceMsg(TF_MENUBAND, "CMBMsgFilter::push Setting hook from context 0x%x", pvContext);
            _fSetAtPush = TRUE;
        }

        if (!_fInitialized)
        {
            ASSERT(NULL == _hwndCapture);
            _hwndCapture = hwndBar;

            _fInitialized = TRUE;

            bRet = FDSA_Initialize(sizeof(MBELEM), CMBELEM_GROW, &_fdsa, _rgmbelem, CMBELEM_INIT);

            // We need to initialize this for the top level guy so that we have the correct positioning
            // from the start of this new set of bands. This is used to eliminate spurious WM_MOUSEMOVE
            // messages which cause problems. See _HandleMouseMessages for more information
            AcquireMouseLocation();
        }

        if (EVAL(bRet))
        {
            MBELEM mbelem = {0};
            
            TraceMsg(TF_MENUBAND, "CMBMsgFilter: Push (pmp:%#08lx) onto stack", SAFECAST(pmb, IMenuPopup *));
            pmb->AddRef();

            mbelem.pmb = pmb;
            mbelem.hwndTB = hwndBand;
            mbelem.hwndBar = hwndBar;

            FDSA_AppendItem(&_fdsa, &mbelem);

            CMenuBand* pmbTop = _GetTopPtr();

            if ((pmbTop && (pmbTop->GetFlags() & SMINIT_LEGACYMENU)) || NULL == GetCapture())
                RetakeCapture();
        }
        else
        {
            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;
            _hwndCapture = NULL;
        }
    }
}    


/*----------------------------------------------------------
Purpose: Pop a menuband off the message filter stack

         Returns the number of bands left on the stack
*/
int CMBMsgFilter::Pop(void* pvContext)
{
    int nRet = 0;

    TraceMsg(TF_MENUBAND, "CMBMsgFilter::pop called from context 0x%x", pvContext);

    // This can be called from a context switch or when we're exiting menu mode,
    // so we'll switch off the fact that we clear _hhookMsg when we pop the top twice.
    if (pvContext == _pvContext && _hhookMsg)
    {
        int iItem = FDSA_GetItemCount(&_fdsa) - 1;
        MBELEM * pmbelem;

        ASSERT(0 <= iItem);

        pmbelem = FDSA_GetItemPtr(&_fdsa, iItem, MBELEM);
        if (EVAL(pmbelem->pmb))
        {
            TraceMsg(TF_MENUBAND, "CMBMsgFilter: Pop (pmb=%#08lx) off stack", SAFECAST(pmbelem->pmb, IMenuPopup *));
            pmbelem->pmb->Release();
            pmbelem->pmb = NULL;
        }
        FDSA_DeleteItem(&_fdsa, iItem);

        if (0 == iItem)
        {

            TraceMsg(TF_MENUBAND, "CMBMsgFilter::pop removing hook from context 0x%x", pvContext);
            if (_fSetAtPush)
                SetHook(FALSE, FALSE);

            PreventCapture(FALSE);
            _fInitialized = FALSE;

            if (_hwndCapture && GetCapture() == _hwndCapture)
            {
                TraceMsg(TF_MENUBAND, "CMBMsgFilter: Releasing capture");
                ReleaseCapture();
            }
            _hwndCapture = NULL;
        }
#ifdef UNIX
        else if (1 == iItem)
        {
            CMenuBand * pmb = _GetTopPtr();
            if( pmb )
            {
                // Change item count only if we delete successfully.
                if( pmb->RemoveTopLevelFocus() )
                    iItem = FDSA_GetItemCount(&_fdsa);
            }
        }
#endif
        nRet = iItem;
  
        
    }
    return nRet;
}    


LRESULT CMBMsgFilter::_HandleMouseMsgs(MSG * pmsg, BOOL bRemove)
{
    LRESULT lRet = 0;
    CMenuBand * pmb;
    HWND hwnd = GetCapture();

    // Do we still have the capture?
    if (hwnd != _hwndCapture)
    {
        // No; is it b/c a CTrackPopupBar has it?

#if 0 // Nuke this trace because I was getting annoyed.
        //def DEBUG
        pmb = _GetTopPtr();
        if (!EVAL(pmb) || !pmb->IsInSubMenu())
        {
            // No
            TraceMsg(TF_WARNING, "CMBMsgFilter: someone else has the capture (%#lx)", hwnd);
        }
#endif
        if (NULL == hwnd)
        {
            // There are times that we must retake the capture because
            // TrackPopupMenuEx has taken it, or some context menu
            // might have taken it, so take it back.
            RetakeCapture();
            TraceMsg(TF_WARNING, "CMBMsgFilter: taking the capture back");
        }
    }
    else
    {
        // Yes; decide what to do with it
        POINT pt;
        HWND hwndPt;
        MSG msgT;

        pt.x = GET_X_LPARAM(pmsg->lParam);
        pt.y = GET_Y_LPARAM(pmsg->lParam);
        ClientToScreen(pmsg->hwnd, &pt);

        if (WM_MOUSEMOVE == pmsg->message)
        {
            // The mouse cursor can send repeated WM_MOUSEMOVE messages
            // with the same coordinates.  When the user tries to navigate
            // thru the menus with the keyboard, and the mouse cursor
            // happens to be over a menu item, these spurious mouse 
            // messages cause us to think the menu has been invoked under
            // the mouse cursor.  
            //
            // To avoid this unpleasant rudeness, we eat any gratuitous
            // WM_MOUSEMOVE messages.
            if (_ptLastMove.x == pt.x && _ptLastMove.y == pt.y)
            {
                pmsg->message = WM_NULL;
                goto Bail;
            }

            // Since this is not a duplicate point, we need to keep it around. 
            // We will use this stored point for the above comparison

            // msadek; W2k bug# 426005
            // On a mirrored system, we got a system bug as mouse coordinates has an off-by-one
            // This makes comparing the value with what we got from GetCursorPos() always fail.
            // Do not use AcquireMouseLocation().

            if(!IS_WINDOW_RTL_MIRRORED(pmsg->hwnd))
            {
                AcquireMouseLocation();
            }
            else
            {
                _ptLastMove.x = pt.x;
                _ptLastMove.y = pt.y;                
            }
            

            if (_hcurArrow == NULL)
                _hcurArrow = LoadCursor(NULL, IDC_ARROW);

            if (GetCursor() != _hcurArrow)
                SetCursor(_hcurArrow);

        }

        pmb = _HitTest(pt, &hwndPt);

        if (pmb)
        {
            // Forward mouse message onto appropriate menuband.  Note
            // the appropriate menuband's GetMsgFilterCB (below) will call
            // ScreenToClient to convert the coords correctly.

            // Use a stack variable b/c we don't want to confuse USER32
            // by changing the coords of the real message.
            msgT = *pmsg;
            msgT.lParam = MAKELPARAM(pt.x, pt.y);
            lRet = pmb->GetMsgFilterCB(&msgT, bRemove);

            // Remember the changed message (if there was one)
            pmsg->message = msgT.message;   
        }
        // Debug note: to debug menubands on ntsd, set the prototype
        // flag accordingly.  This will keep menubands from going
        // away the moment the focus changes to the NTSD window.

        else if ((WM_LBUTTONDOWN == pmsg->message || WM_RBUTTONDOWN == pmsg->message) &&
            !(g_dwPrototype & PF_USINGNTSD))
        {
            // Mouse down happened outside the menu.  Bail.
            pmb = _GetTopPtr();
            if (EVAL(pmb))
            {
                msgT.hwnd = pmsg->hwnd;
                msgT.message = g_nMBFullCancel;
                msgT.wParam = 0;
                msgT.lParam = 0;

                TraceMsg(TF_MENUBAND, "CMBMsgFilter (pmb=%#08lx): hittest outside, bailing", SAFECAST(pmb, IMenuPopup *));
                pmb->GetMsgFilterCB(&msgT, bRemove);
            }
#if 0
            // Now send the message to the originally intended window
            SendMessage(pmsg->hwnd, pmsg->message, pmsg->wParam, pmsg->lParam);
#endif
        }
        else
        {
            pmb = _GetTopPtr();
            if (pmb)
            {
                IUnknown_QueryServiceExec(SAFECAST(pmb, IOleCommandTarget*), SID_SMenuBandBottom, 
                    &CGID_MenuBand, MBANDCID_SELECTITEM, MBSI_NONE, NULL, NULL);
            }
        }
    }

Bail:
    return lRet;    
}    


/*----------------------------------------------------------
Purpose: Message hook used to track keyboard and mouse messages
         while the menuband is "active".  
         
         The menuband can't steal the focus away -- we use this
         hook to catch messages.

*/
LRESULT CMBMsgFilter::GetMsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;
    BOOL bRemove = (PM_REMOVE == wParam);
    CMBMsgFilter* pmf = GetMessageFilter();


    // The global message filter may be in a state when we are not processing messages,
    // but the menubands are still displayed. A situation where this will occur is when
    // a dialog box is displayed because of an interaction with the menus.

    // Are we engaged? (Are we allowed to process messages?)
    if (pmf->_fEngaged)
    {
        if (WM_SYSCHAR == pmsg->message)
        {
            // _fDontIgnoreSysChar is set when the Menubands ONLY want to know about
            // WM_SYSCHAR and nothing else.
            if (pmf->_fDontIgnoreSysChar)
            {
                CMenuBand * pmb = pmf->GetTopMostPtr();
                if (pmb)
                    lRet =  pmb->GetMsgFilterCB(pmsg, bRemove);
            }
        }
        else if (pmf->_fInitialized) // Only filter if we are initalized (have items on the stack)
        {
            switch (nCode)
            {
            case HC_ACTION:
        #ifdef DEBUG
                if (g_dwDumpFlags & DF_GETMSGHOOK)
                    DumpMsg(TEXT("GetMsg"), pmsg);
        #endif

                // A lesson about GetMsgHook: it gets the same message
                // multiple times for as long as someone calls PeekMessage
                // with the PM_NOREMOVE flag.  So we want to take action 
                // only when PM_REMOVE is set (so we don't handle more than
                // once).  If we modify any messages to redirect them (on a
                // regular basis), we must modify all the time so we don't 
                // confuse the app.

                // Messages get redirected to different bands in the stack
                // in this way:
                //
                //  1) Keyboard messages go to the currently open submenu 
                //     (topmost on the stack).  
                //
                //  2) The PopupOpen message goes to the hwnd that belongs 
                //     to the menu band (via IsWindowOwner).
                //

                switch (pmsg->message)
                {
                case WM_SYSKEYDOWN:
                case WM_KEYDOWN:
                case WM_CHAR:
                case WM_KEYUP:
                case WM_CLOSE:          // only this message filter gets WM_CLOSE
                    {
                        // There is a situation that can occur when the last selected
                        // menu pane is NOT the bottom most pane.
                        // We need to see if that last selected guy is tracking a context
                        // menu so that we forward the messages correctly.
                        CMenuBand * pmb = pmf->_GetBottomMostSelected();
                        if (pmb)
                        {
                            // Is it tracking a context menu?
                            if (S_OK == IUnknown_Exec(SAFECAST(pmb, IMenuBand*), &CGID_MenuBand, 
                                MBANDCID_ISTRACKING, 0, NULL, NULL))
                            {
                                // Yes, forward for proper handling.
                                lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                            }
                            else
                            {
                                // No; Then do the default processing. This can happen if there is no
                                // context menu, but there is a selected parent and not a selected child.
                                goto TopHandler;
                            }
                        }
                        else
                        {
                    TopHandler:
                            pmb = pmf->_GetTopPtr();
                            if (pmb)
                                lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                        }
                    }
                    break;

                case WM_NULL:
                    // Handle this here (we do nothing) to avoid mistaking this for
                    // g_nMBPopupOpen below, in case g_nMBPopupOpen is 0 if
                    // RegisterWindowMessage fails.
                    break;

                default:
                    if (bRemove && IsInRange(pmsg->message, WM_MOUSEFIRST, WM_MOUSELAST))
                    {
                        lRet = pmf->_HandleMouseMsgs(pmsg, bRemove);
                    }
                    else if (pmsg->message == g_nMBPopupOpen)
                    {
                        CMenuBand * pmb = pmf->_GetWindowOwnerPtr(pmsg->hwnd);
                        if (pmb)
                            lRet = pmb->GetMsgFilterCB(pmsg, bRemove);
                    }
                    else if (pmsg->message == g_nMBExecute)
                    {
                        CMenuBand * pmb = pmf->_GetWindowOwnerPtr(pmsg->hwnd);
                        if (pmb)
                        {
                            VARIANT var;
                            var.vt = VT_UINT_PTR;
                            var.ullVal = (UINT_PTR)pmsg->hwnd;
                            pmb->Exec(&CGID_MenuBand, MBANDCID_EXECUTE, (DWORD)pmsg->wParam, &var, NULL);
                        }
                    }

                    break;
                }
                break;

            default:
                if (0 > nCode)
                    return CallNextHookEx(pmf->_hhookMsg, nCode, wParam, lParam);
                break;
            }
        }
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        return CallNextHookEx(pmf->_hhookMsg, nCode, wParam, lParam);

    return 0;       // Always return 0
}    

CMBMsgFilter* GetMessageFilter()
{
    CMBMsgFilter* pmf = NULL;

    if (g_tlsMessageFilter == -1)
    {
        DWORD tls = TlsAlloc();
        if (tls != -1)
        {
            InterlockedExchange((LONG*)&g_tlsMessageFilter, tls);
            if (tls != g_tlsMessageFilter)
            {
                TlsFree(tls);
            }
        }
    }

    if (g_tlsMessageFilter != -1)
    {
        pmf = (CMBMsgFilter*)TlsGetValue(g_tlsMessageFilter);

        if (pmf == NULL)
        {
            pmf = new CMBMsgFilter;
            if (pmf)
            {
                pmf->_fAllocated = TRUE;
                TlsSetValue(g_tlsMessageFilter, pmf);
            }
        }
    }

    if (pmf == NULL)
        pmf = &g_msgfilter;

    return pmf;
}



//=================================================================
// Implementation of CMenuBand
//=================================================================

// Struct used by EXEC with a MBANDCID_GETFONTS to return fonts
typedef struct tagMBANDFONTS
{
    HFONT hFontMenu;    // [out]    TopLevelMenuBand's menu font
    HFONT hFontArrow;   // [out]    TopLevelMenuBand's font for drawing the cascade arrow
    int   cyArrow;      // [out]    Height of TopLevelMenuBand's cascade arrow
    int   cxArrow;      // [out]    Width of TopLevelMenuBand's cascade arrow
    int   cxMargin;     // [out]    Margin b/t text and arrow
} MBANDFONTS;

#define THISCLASS CMenuBand
#define SUPERCLASS CToolBand

#ifdef DEBUG
int g_nMenuLevel = 0;

#define DBG_THIS    _nMenuLevel, SAFECAST(this, IMenuPopup *)
#else
#define DBG_THIS    0, 0
#endif


CMenuBand::CMenuBand() :
    SUPERCLASS()
{
    GetMessageFilter()->AddRef();
    _fCanFocus = TRUE;

    _fAppActive = TRUE;

    _nItemNew = -1;
    _nItemCur = -1;
    _nItemTimer = -1;
    _uIconSize = ISFBVIEWMODE_SMALLICONS;
    _uIdAncestor = ANCESTORDEFAULT;
    _nItemSubMenu = -1;
}


// The purpose of this method is to finish initializing Menubands, 
// since it can be initialized in many ways. 

void CMenuBand::_Initialize(DWORD dwFlags)
{
    _fVertical = !BOOLIFY(dwFlags & SMINIT_HORIZONTAL);
    _fTopLevel = BOOLIFY(dwFlags & SMINIT_TOPLEVEL);

    _dwFlags = dwFlags;

    // We cannot have a horizontal menu if it is not the toplevel menu
    ASSERT(!_fVertical && _fTopLevel || _fVertical);

    if (_fTopLevel)
    {
        if (!g_nMBPopupOpen) 
        {
            g_nMBPopupOpen  = RegisterWindowMessage(TEXT("CMBPopupOpen"));
            g_nMBFullCancel = RegisterWindowMessage(TEXT("CMBFullCancel"));
            g_nMBDragCancel = RegisterWindowMessage(TEXT("CMBDragCancel"));
            g_nMBAutomation = RegisterWindowMessage(TEXT("CMBAutomation"));
            g_nMBExecute    = RegisterWindowMessage(TEXT("CMBExecute"));
            g_nMBOpenChevronMenu = RegisterWindowMessage(TEXT("CMBOpenChevronMenu"));

            g_hCursorArrow = LoadCursor(NULL, IDC_ARROW);
            TraceMsg(TF_MENUBAND, "CMBPopupOpen message = %#lx", g_nMBPopupOpen);
            TraceMsg(TF_MENUBAND, "CMBFullCancel message = %#lx", g_nMBFullCancel);
        }

        if (!_pmbState)
            _pmbState = new CMenuBandState;
    }

    DEBUG_CODE( _nMenuLevel = -1; )
}


CMenuBand::~CMenuBand()
{
    CMBMsgFilter* pmf = GetMessageFilter();
    // the message filter does not have a ref'd pointer to us!!!
    if (pmf->GetTopMostPtr() == this)
        pmf->SetTopMost(NULL);

    _CallCB(SMC_DESTROY);
    ATOMICRELEASE(_psmcb);

    // Cleanup
    CloseDW(0);

    if (_pmtbMenu)
        delete _pmtbMenu;

    if (_pmtbShellFolder)
        delete _pmtbShellFolder;

    
    ASSERT(_punkSite == NULL);
    ATOMICRELEASE(_pmpTrackPopup);

    ATOMICRELEASE(_pmbm);

    if (_fTopLevel)
    {
        if (_pmbState)
            delete _pmbState;
    }

    GetMessageFilter()->Release();
}


/*----------------------------------------------------------
Purpose: Create-instance function for class factory

*/
HRESULT CMenuBand_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    HRESULT hres = E_OUTOFMEMORY;
    CMenuBand* pObj = new CMenuBand();
    if (pObj)
    {
        *ppunk = SAFECAST(pObj, IShellMenu*);
        hres = S_OK;
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: Internal create-instance function

*/
CMenuBand * CMenuBand_Create(IShellFolder* psf, LPCITEMIDLIST pidl,
                             BOOL bHorizontal)
{
    CMenuBand * pmb = NULL;

    if (psf || pidl)
    {
        DWORD dwFlags = bHorizontal ? (SMINIT_HORIZONTAL | SMINIT_TOPLEVEL) : 0;

        pmb = new CMenuBand();
        if (pmb)
        {
            pmb->_Initialize(dwFlags);
            pmb->SetShellFolder(psf, pidl, NULL, 0);
        }
    }
    return pmb;
}
#ifdef UNIX

BOOL CMenuBand::RemoveTopLevelFocus()
{
    if( _fTopLevel )
    {
        _CancelMode( MPOS_CANCELLEVEL );
        return TRUE;
    }

    return FALSE;
}

#endif
void CMenuBand::_UpdateButtons()
{
    if (_pmtbMenu) 
        _pmtbMenu->v_UpdateButtons(FALSE);
    if (_pmtbShellFolder)
        _pmtbShellFolder->v_UpdateButtons(FALSE);

    _fForceButtonUpdate = FALSE;
}

HRESULT CMenuBand::ForwardChangeNotify(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    // Given a change notify from the ShellFolder child, we will forward that notify to each of our
    // sub menus, but only if they have a shell folder child.

    HRESULT hres = E_FAIL;
    BOOL fDone = FALSE;
    CMenuToolbarBase* pmtb = _pmtbBottom;   // Start With the bottom toolbar. This is
                                            // is an optimization because typically
                                            // menus that have both a Shell Folder portion
                                            // and a static portion have the majority
                                            // of the change activity in the bottom portion.

    // This can be NULL on a shutdown, when we're deregistering change notifies
    if (pmtb)
    {
        HWND hwnd = pmtb->_hwndMB;


        for (int iButton = 0; !fDone; iButton++)
        {
            IShellChangeNotify* ptscn;

            int idCmd = GetButtonCmd(hwnd, iButton);

#ifdef DEBUG
                TCHAR szSubmenuName[MAX_PATH];
                UINT cch = (UINT)SendMessage(hwnd, TB_GETBUTTONTEXT, idCmd, NULL);
                if (cch != 0 && cch < ARRAYSIZE(szSubmenuName))
                {
                    SendMessage(hwnd, TB_GETBUTTONTEXT, idCmd, (LPARAM)szSubmenuName);
                    TraceMsg(TF_MENUBAND, "CMenuBand: Forwarding Change notify to %s", szSubmenuName);
                }
#endif

            // If it's not a seperator, see if there is a sub menu with a shell folder child.
            if (idCmd != -1 &&
                SUCCEEDED(pmtb->v_GetSubMenu(idCmd, &SID_MenuShellFolder, IID_IShellChangeNotify, (void**)&ptscn)))
            {
                IShellMenu* psm;
                // Don't forward this notify if the sub menu has specifically registered for change notify (By not passing
                // DontRegisterChangeNotify.
                if (SUCCEEDED(ptscn->QueryInterface(IID_IShellMenu, (void**)&psm)))
                {
                    UINT uIdParent = 0;
                    DWORD dwFlags = 0;
                    // Get the flags
                    psm->GetShellFolder(&dwFlags, NULL, IID_NULL, NULL);
                    psm->GetMenuInfo(NULL, &uIdParent, NULL, NULL);

                    // If this menupane is an "Optimized" pane, (meaning that we don't register for change notify
                    // and forward from a top level menu down) then we want to forward. We also
                    // forward if this is a child of Menu Folder. If it is a child,
                    // then it also does not register for change notify, but does not explicitly set it in it's flags
                    // (review: Should we set it in it's flags?)
                    // If it is not an optimized pane, then don't forward.
                    if ((dwFlags & SMSET_DONTREGISTERCHANGENOTIFY) ||
                        uIdParent == MNFOLDER_IS_PARENT)
                    {
                        // There is!, then pass to the child the change.
                        hres = ptscn->OnChange(lEvent, pidl1, pidl2);

                        // Update Dir on a Recursive change notify forces us to update everyone... Good thing
                        // this does not happen alot and is caused by user interaction most of the time.
                    }
                    psm->Release();
                }

                ptscn->Release();
            }

            // Did we go through all of the buttons on this toolbar?
            if (iButton >= ToolBar_ButtonCount(hwnd) - 1)
            {
                // Yes, then we need to switch to the next toolbar.
                if (_pmtbTop != _pmtbBottom && pmtb != _pmtbTop)
                {
                    pmtb = _pmtbTop;
                    hwnd = pmtb->_hwndMB;
                    iButton = -1;       // -1 because at the end of the loop the for loop will increment.
                }
                else
                {
                    // No; Then we must be done.
                    fDone = TRUE;
                }
            }
        }
    }
    else
        hres = S_OK;        // Return success because we're shutting down.

    return hres;
}

// Resize the parent menubar
VOID CMenuBand::ResizeMenuBar()
{
    // If we're not shown, then we do not need to do any kind of resize.
    // NOTE: Horizontal menubands are always shown. Don't do any of the 
    // vertical stuff if we're horizontal.
    if (!_fShow)
        return;

    // If we're horizontal, don't do any Vertical sizing stuff.
    if (!_fVertical)
    {
        // BandInfoChanged is only for Horizontal Menubands.
        _BandInfoChanged();
        return;
    }

    // We need to update the buttons before a resize so that the band is the right size.
    _UpdateButtons();

    // Have the menubar think about changing its height
    IUnknown_QueryServiceExec(_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
        MBCID_RESIZE, 0, NULL, NULL);
}


STDMETHODIMP CMenuBand::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(CMenuBand, IMenuPopup),
        QITABENT(CMenuBand, IMenuBand),
        QITABENT(CMenuBand, IShellMenu),
        QITABENT(CMenuBand, IShellMenu2),
        QITABENT(CMenuBand, IWinEventHandler),
        QITABENT(CMenuBand, IShellMenuAcc),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);


    // BUGBUG (lamadio) 8.5.98: Nuke this. We should not expose the this pointer,
    // this is a bastardization of COM.
    if (FAILED(hres) && IsEqualGUID(riid, CLSID_MenuBand)) 
    {
        AddRef();
        *ppvObj = (LPVOID)this;
        hres = S_OK;
    }
    
    return hres;
}


/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuBand::QueryService(REFGUID guidService,
                                     REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL; // assume error

    if (IsEqualIID(guidService, SID_SMenuPopup) || 
        IsEqualIID(guidService, SID_SMenuBandChild) || 
        IsEqualIID(guidService, SID_SMenuBandParent) || 
        (_fTopLevel && IsEqualIID(guidService, SID_SMenuBandTop)))
    {
        if (IsEqualIID(riid, IID_IAccessible) || IsEqualIID(riid, IID_IDispatch))
        {
            hres = E_OUTOFMEMORY;
            CAccessible* pacc = new CAccessible(SAFECAST(this, IMenuBand*));

            if (pacc)
            {
                hres = pacc->InitAcc();
                if (SUCCEEDED(hres))
                {
                    hres = pacc->QueryInterface(riid, ppvObj);
                }
                pacc->Release();
            }
        }
        else
            hres = QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
             IsEqualIID(guidService, SID_SMenuBandBottomSelected))
    {
        // SID_SMenuBandBottom queries down
        BOOL fLookingForSelected = IsEqualIID(SID_SMenuBandBottomSelected, guidService);

        // Are we the leaf node?
        if (!_fInSubMenu)
        {
            if ( fLookingForSelected && 
                (_pmtbTracked == NULL ||
                 ToolBar_GetHotItem(_pmtbTracked->_hwndMB) == -1))
            {
                hres = E_FAIL;
            }
            else
            {
                hres = QueryInterface(riid, ppvObj);    // Yes; QI ourselves
            }
        }
        else 
        {
            // No; QS down...

            IMenuPopup* pmp = _pmpSubMenu;
            if (_pmpTrackPopup)
                pmp = _pmpTrackPopup;
            
            ASSERT(pmp);
            hres = IUnknown_QueryService(pmp, guidService, riid, ppvObj);
            if (FAILED(hres) && fLookingForSelected && _pmtbTracked != NULL)
            {
                hres = QueryInterface(riid, ppvObj);    // Yes; QI ourselves
            }
        }
    }
    else if (IsEqualIID(guidService, SID_MenuShellFolder))
    {
        // This is a method of some other menu in the scheme to get to specifically the MenuShellfolder,
        // This is for the COM Identity property.
        if (_pmtbShellFolder)
            hres = _pmtbShellFolder->QueryInterface(riid, ppvObj);
    }
    else
        hres = SUPERCLASS::QueryService(guidService, riid, ppvObj);

    return hres;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner method

*/
STDMETHODIMP CMenuBand::IsWindowOwner(HWND hwnd)
{
    if (( _pmtbShellFolder && (_pmtbShellFolder->IsWindowOwner(hwnd) == S_OK) ) ||
        (_pmtbMenu && (_pmtbMenu->IsWindowOwner(hwnd) == S_OK)))
        return S_OK;
    return S_FALSE;
}

#define MB_EICH_FLAGS (EICH_SSAVETASKBAR | EICH_SWINDOWMETRICS | EICH_SPOLICY | EICH_SSHELLMENU | EICH_KWINPOLICY)

/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the bandsite.
*/
STDMETHODIMP  CMenuBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    HRESULT hres = NOERROR;

    EnterModeless();

    // Could our metrics be changing?  (We keep track of this only for the 
    // toplevel menu)
    BOOL fProcessSettingChange = FALSE;

    switch (uMsg)
    {
    case WM_SETTINGCHANGE:
        fProcessSettingChange = !lParam || (SHIsExplorerIniChange(wParam, lParam) & MB_EICH_FLAGS);
        break;

    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        fProcessSettingChange = TRUE;
        break;
    }

    if (_fTopLevel && 
        fProcessSettingChange && 
        _pmbState && !_pmbState->IsProcessingChangeNotify())
    {

        // There is a race condition that can occur during a refresh 
        // that's really nasty. It causes another one to get pumped in the
        // middle of processing this one, Yuck!
        _pmbState->PushChangeNotify();
        // There is a race condiction that can occur when the menuband is created,
        // but not yet initialized. This has been hit by the IEAK group....
        if (_pmtbTop)
        {
            // Yes; create a new metrics object and tell the submenus
            // about it.

            CMenuBandMetrics* pmbm = new CMenuBandMetrics(_pmtbTop->_hwndMB);

            if (pmbm)
            {
                ATOMICRELEASE(_pmbm);
                _pmbm = pmbm;

                if (_pmtbMenu)
                    _pmtbMenu->SetMenuBandMetrics(_pmbm);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->SetMenuBandMetrics(_pmbm);

                _CallCB(SMC_REFRESH, wParam, lParam);

                // We need to force a button update at some point so that the new sizes are calculated
                // Setting this flag will cause the buttons to be updatted before the next time it 
                // is shown. If, however, the menu is currently displayed, then the ResizeMenuBar will
                // recalculate immediatly.
                
                _fForceButtonUpdate = TRUE;
                RECT rcOld;
                RECT rcNew;

                // Resize the MenuBar
                GetClientRect(_hwndParent, &rcOld);
                ResizeMenuBar();
                GetClientRect(_hwndParent, &rcNew);

                // If the rect sizes haven't changed, then we need to re-layout the
                // band because the button widths may have changed.
                if (EqualRect(&rcOld, &rcNew) && _fVertical)
                    _pmtbTop->NegotiateSize();
            }
        }

        if (_pmtbMenu)
            hres = _pmtbMenu->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        if (_pmtbShellFolder)
            hres = _pmtbShellFolder->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        _pmbState->PopChangeNotify();
    }
    else
    {
        if (_pmtbMenu && (_pmtbMenu->IsWindowOwner(hwnd) == S_OK) )
            hres = _pmtbMenu->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

        if (_pmtbShellFolder && (_pmtbShellFolder->IsWindowOwner(hwnd) == S_OK) )
            hres = _pmtbShellFolder->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    }

    ExitModeless();

    return hres;
}


/*----------------------------------------------------------
Purpose: IOleWindow::GetWindow method

*/
STDMETHODIMP CMenuBand::GetWindow(HWND * phwnd)
{
    // We assert that only a real menu can be hosted in a standard
    // bandsite (we're talking about the horizontal menubar).
    // So we only return the window associated with the static
    // menu.
    if (_pmtbMenu)
    {
        *phwnd = _pmtbMenu->_hwndMB;
        return NOERROR;
    }
    else
    {
        *phwnd = NULL;
        return E_FAIL;
    }
}    


/*----------------------------------------------------------
Purpose: IOleWindow::ContextSensitiveHelp method

*/
STDMETHODIMP CMenuBand::ContextSensitiveHelp(BOOL bEnterMode)
{
    return SUPERCLASS::ContextSensitiveHelp(bEnterMode);
}    


/*----------------------------------------------------------
Purpose: Handle WM_CHAR for accelerators

         This is handled for any vertical menu.  Since we have
         two toolbars (potentially), this function determines
         which toolbar gets the message depending on the 
         accelerator.

*/
HRESULT CMenuBand::_HandleAccelerators(MSG * pmsg)
{
    TCHAR ch = (TCHAR)pmsg->wParam;
    HWND hwndTop = _pmtbTop->_hwndMB;
    HWND hwndBottom = _pmtbBottom->_hwndMB;

    // Here's how this works: the menu can have one or two toolbars.
    // 
    // One toolbar: we simply forward the message onto the toolbar 
    // and let it handle any potential accelerators.
    //
    // Two toolbars: get the count of accelerators that match the
    // given char for each toolbar.  If only one toolbar has at
    // least one match, forward the message onto that toolbar.
    // Otherwise, forward the message onto the currently tracked
    // toolbar and let it negotiate which accelerator button to
    // choose (we might get a TBN_WRAPHOTITEM).
    //
    // If no match occurs, we beep.  Beep beep.
    //

    if (!_pmtbTracked)
        SetTracked(_pmtbTop);

    ASSERT(_pmtbTracked);

    if (_pmtbTop != _pmtbBottom)
    {
        int iNumBottomAccel;
        int iNumTopAccel;

        // Tell the dup handler not to handle this one....
        _fProcessingDup = TRUE;

        ToolBar_HasAccelerator(hwndTop, ch, &iNumTopAccel);
        ToolBar_HasAccelerator(hwndBottom, ch, &iNumBottomAccel);

        BOOL bBottom = (0 < iNumBottomAccel);
        BOOL bTop = (0 < iNumTopAccel);

        // Does one or the other (but not both) have an accelerator?
        if (bBottom ^ bTop)
        {
            // Yes; do the work here for that specific toolbar
            HWND hwnd = bBottom ? hwndBottom : hwndTop;
            int cAccel = bBottom ? iNumBottomAccel : iNumTopAccel;
            int idCmd;

            pmsg->message = WM_NULL;    // no need to forward the message

            // This should never really fail since we just checked
            EVAL( ToolBar_MapAccelerator(hwnd, ch, &idCmd) );

            DWORD dwFlags = HICF_ACCELERATOR | HICF_RESELECT;

            if (cAccel == 1)
                dwFlags |= HICF_TOGGLEDROPDOWN;

            int iPos = ToolBar_CommandToIndex(hwnd, idCmd);
            ToolBar_SetHotItem2(hwnd, iPos, dwFlags);
        }
        // No; were there no accelerators?
        else if ( !bTop )
        {
            // Yes
            if (_fVertical)
            {
                MessageBeep(MB_OK);
            }
            else
            {
                _CancelMode(MPOS_FULLCANCEL);
            }
        }
        // Else allow the message to go to the top toolbar

        _fProcessingDup = FALSE;
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: Callback for the get message filter.  We handle the
         keyboard messages here (rather than IInputObject::
         TranslateAcceleratorIO) so that we can redirect the
         message *and* have the message pump still call
         TranslateMessage to generate WM_CHAR and WM_SYSCHAR
         messages.

*/
LRESULT CMenuBand::GetMsgFilterCB(MSG * pmsg, BOOL bRemove)
{
    // (See the note in CMBMsgFilter::GetMsgHook about bRemove.)

    if (bRemove && !_fVertical && (pmsg->message == g_nMBPopupOpen) && _pmtbTracked)
    {
        // Menu is being popped open, send a WM_MENUSELECT equivalent.
        _pmtbTracked->v_SendMenuNotification((UINT)pmsg->wParam, FALSE);
    }

    if (_fTopLevel &&                           // Only do this for the top level
        _dwFlags & SMINIT_USEMESSAGEFILTER &&   // They want to use the message filter 
                                                // instead of IsMenuMessage
        bRemove &&                              // Only do this if we're removing it.
        WM_SYSCHAR == pmsg->message)            // We only care about WM_SYSCHAR
    {
        // We intercept Alt-key combos (when pressed together) here,
        // to prevent USER from going into a false menu loop check.  
        // There are compatibility problems if we let that happen.
        //
        // Sent by USER32 when the user hits an Alt-char combination.
        // We need to translate this into popping down the correct
        // menu.  Normally we intercept this in the message pump
        //
        if (_OnSysChar(pmsg, TRUE) == S_OK)
        {
            pmsg->message = WM_NULL;
        }
    }

    // If a user menu is up, then we do not want to intercept those messages. Intercepting
    // messages intended for the poped up user menu causes havoc with keyboard accessibility.
    // We also don't want to process messages if we're displaying a sub menu (It should be
    // handling them).

    BOOL fTracking = FALSE;
    if (_pmtbMenu)
        fTracking = _pmtbMenu->v_TrackingSubContextMenu();

    if (_pmtbShellFolder && !fTracking)
        fTracking = _pmtbShellFolder->v_TrackingSubContextMenu();


    if (!_fInSubMenu && !fTracking)    
    {
        // We don't process these messages when we're in a (modal) submenu

        switch (pmsg->message)
        {
        case WM_SYSKEYDOWN:
        case WM_KEYDOWN:
            // Don't process IME message. Restore original VK value.
            if (g_fRunOnFE && VK_PROCESSKEY == pmsg->wParam)
                pmsg->wParam = ImmGetVirtualKey(pmsg->hwnd);

            if (bRemove && 
                (VK_ESCAPE == pmsg->wParam || VK_MENU == pmsg->wParam))
            {
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received Esc in msg filter", DBG_THIS);

                DWORD dwSelect = (VK_ESCAPE == pmsg->wParam) ? MPOS_CANCELLEVEL : MPOS_FULLCANCEL;

                _CancelMode(dwSelect);

                pmsg->message = WM_NULL;
                return 1;
            }
            // Fall thru

        case WM_CHAR:
            // Hitting the spacebar should invoke the system menu
            if (!_fVertical && 
                WM_CHAR == pmsg->message && TEXT(' ') == (TCHAR)pmsg->wParam)
            {
                // We need to leave this modal loop before bringing
                // up the system menu (otherwise the user would need to 
                // hit Alt twice to get out.)  Post the message.
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Leaving menu mode for system menu", DBG_THIS);

                UIActivateIO(FALSE, NULL);

                // Say the Alt-key is down to catch DefWindowProc's attention
                pmsg->lParam |= 0x20000000;   
                pmsg->message = WM_SYSCHAR;

                // Use the parent of the toolbar, because toolbar does not
                // forward WM_SYSCHAR onto DefWindowProc.
                pmsg->hwnd = GetParent(_pmtbTop->_hwndMB);
                return 1;
            }
            else if (_fVertical && WM_CHAR == pmsg->message &&
                pmsg->wParam != VK_RETURN)
            {
#ifdef UNICODE
                // Need to do this before we ask the toolbars..
                // [msadek], On win9x we get the message thru a chain from explorer /iexplore (ANSI app.).
                // and pass it to comctl32 (Unicode) so it will fail to match the hot key.
                // the system sends the message with ANSI char and we treated it as Unicode.
                // It looks like noone is affected with this bug (US, FE) since they have hot keys always in Latin.
                // Bidi platforms are affected since they do have hot keys in native language.
                if(!g_fRunningOnNT)
                {
                    pmsg->wParam = AnsiWparamToUnicode(pmsg->wParam);
                }
#endif // UNICODE        


                // We do not want to pass VK_RETURN to _HandleAccelerators
                // because it will try to do a character match. When it fails
                // it will beep. Then we pass the VK_RETURN to the tracked toolbar
                // and it executes the command.

                // Handle accelerators here
                _HandleAccelerators(pmsg);
            }
            // Fall thru

        case WM_KEYUP:
            // Collection point for most key messages...

            if (NULL == _pmtbTracked)
            {
                // Normally we default to the top toolbar, unless that toolbar
                // cannot receive the selection (As is the case on the top level
                // start menu where the fast items are (Empty).                

                // Can the top toolbar be cycled into?
                if (!_pmtbTop->DontShowEmpty())
                {
                    // Yes;
                    SetTracked(_pmtbTop);      // default to the top toolbar
                }
                else
                {
                    // No; Set the tracked to the bottom, and hope that he can....
                    SetTracked(_pmtbBottom);
                }
            }

            // F10 has special meaning for menus. 
            //  - F10 alone, should toggle the selection of the first item 
            //      in a horizontal menu
            //  - Shift-F10 should display a context menu.

            if (VK_F10 == pmsg->wParam)
            {
                // Is this the Shift-F10 Case?
                if (GetKeyState(VK_SHIFT) < 0)
                {
                    // Yes. We need to force this message into a context menu
                    // message.
                    pmsg->message = WM_CONTEXTMENU;
                    pmsg->lParam = -1;
                    pmsg->wParam = (WPARAM)_pmtbTracked->_hwndMB;
                    return 0;
                }
                else if (!_fVertical)   //No; Then we need to toggle in the horizontal case
                {
                    if (_pmtbMenu)
                    {
                        // Set the hot item to the first one.
                        int iHot = 0;
                        if (ToolBar_GetHotItem(_pmtbMenu->_hwndMB) != -1)
                            iHot = -1;  // We're toggling the selection off.
                        ToolBar_SetHotItem(_pmtbMenu->_hwndMB, iHot);
                    }
                    return 0;
                }
            }
                
            // Redirect to the toolbar
            if (_pmtbTracked)
                pmsg->hwnd = _pmtbTracked->_hwndMB;
            return 0;

        case WM_NULL:
            // Handle this here (we do nothing) to avoid mistaking this for
            // g_nMBPopupOpen below, in case g_nMBPopupOpen is 0 if
            // RegisterWindowMessage fails.
            return 0;

        default:
            // We used to handle g_nMBPopupOpen here.  But we can't because calling TrackPopupMenu
            // (via CTrackPopupBar::Popup) w/in a GetMessageFilter is very bad.
            break;
        }
    }

    if (bRemove)
    {
        // These messages must be processed even when no submenu is open
        switch (pmsg->message)
        {
        case WM_CLOSE:
            // Being deactivated.  Bail out of menus.
            TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): sending MPOS_FULLCANCEL", DBG_THIS);

            _CancelMode(MPOS_FULLCANCEL);
            break;

        default:
            if (IsInRange(pmsg->message, WM_MOUSEFIRST, WM_MOUSELAST))
            {
                // If we move the mouse, collapse the tip. Careful not to blow away a balloon tip...
                if (_pmbState)
                    _pmbState->HideTooltip(FALSE);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->v_ForwardMouseMessage(pmsg->message, pmsg->wParam, pmsg->lParam);

                if (_pmtbMenu)
                    _pmtbMenu->v_ForwardMouseMessage(pmsg->message, pmsg->wParam, pmsg->lParam);

                // Don't let the message be dispatched now that we've
                // forwarded it.
                pmsg->message = WM_NULL;
            }
            else if (pmsg->message == g_nMBFullCancel)
            {
                // Popup 
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received private full cancel message", DBG_THIS);

                _SubMenuOnSelect(MPOS_CANCELLEVEL);
                _CancelMode(MPOS_FULLCANCEL);
                return 1;
            }
            break;
        }
    }
    
    return 0;    
}    


/*----------------------------------------------------------
Purpose: Handle WM_SYSCHAR

         This is handled for the toplevel menu only.

*/
HRESULT CMenuBand::_OnSysChar(MSG * pmsg, BOOL bFirstDibs)
{
    TCHAR ch = (TCHAR)pmsg->wParam;

    // HACKHACK (scotth): I'm only doing all this checking because I don't
    // understand why the doc-obj case sometimes (and sometimes doesn't) 
    // intercept this in its message filter.
    
    if (!bFirstDibs && _fSysCharHandled)
    {
        _fSysCharHandled = FALSE;
        return S_FALSE;
    }
    
    if (TEXT(' ') == (TCHAR)pmsg->wParam)
    {
        _fAltSpace = TRUE;  // In the words of Spock..."Remember"
        // start menu alt+space
        TraceMsg(DM_MISC, "cmb._osc: alt+space _fTopLevel(1)");
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, UIBL_INPMENU);
    }
    else if (!_fInSubMenu)
    {
        int idBtn;

        ASSERT(_fTopLevel);

        // There is a brief instant when we're merging a menu and pumping messages
        // This results in a null _pmtbMenu.
        if (_pmtbMenu)
        {
            // Only a toplevel menubar follows this codepath.  This means only
            // the static menu toolbar will exist (and not the shellfolder toolbar).
            _pmtbTracked = _pmtbMenu;

            HWND hwnd = _pmtbTracked->_hwndMB;
#ifdef UNICODE            
            // [msadek], On win9x we get the message thru a chain from explorer /iexplore (ANSI app.).
            // and pass it to comctl32 (Unicode) so it will fail to match the hot key.
            // the system sends the message with ANSI char and we treated it as Unicode.
            // It looks like noone is affected with this bug (US, FE) since they have hot keys always in Latin.
            // Bidi platforms are affected since they do have hot keys in native language.
            if(!g_fRunningOnNT)
            {
                ch = (TCHAR) AnsiWparamToUnicode(pmsg->wParam);
            }
#endif // UNICODE        
            if (ToolBar_MapAccelerator(hwnd, ch, &idBtn))
            {
                // Post a message since we're already in a menu loop
                TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): WM_SYSCHAR: Posting CMBPopup message", DBG_THIS);
                UIActivateIO(TRUE, NULL);
                _pmtbTracked->PostPopup(idBtn, TRUE, TRUE);
                // browser menu alt+key, start menu alt+key
                TraceMsg(DM_MISC, "cmb._osc: alt+key _fTopLevel(1)");
                UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, UIBL_INPMENU);
                return S_OK;
            }
        }
    }

    // Set or reset
    _fSysCharHandled = bFirstDibs ? TRUE : FALSE;
    
    return S_FALSE;
}

HRESULT CMenuBand::_ProcessMenuPaneMessages(MSG* pmsg)
{
    if (pmsg->message == g_nMBPopupOpen)
    {
        // Popup the submenu.  Since the top-level menuband receives this first, the
        // command must be piped down the chain to the bottom-most menuband.
        IOleCommandTarget * poct;
    
        QueryService(SID_SMenuBandBottom, IID_IOleCommandTarget, (LPVOID *)&poct);

        if (poct)
        {
            BOOL bSetItem = LOWORD(pmsg->lParam);
            BOOL bInitialSelect = HIWORD(pmsg->lParam);
            VARIANTARG vargIn;

            TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Received private popup menu message", DBG_THIS);

            DWORD dwOpt = 0;

            vargIn.vt = VT_I4;
            vargIn.lVal = (LONG)pmsg->wParam;
        
            if (bSetItem)
                dwOpt |= MBPUI_SETITEM;

            if (bInitialSelect)
                dwOpt |= MBPUI_INITIALSELECT;
            
            poct->Exec(&CGID_MenuBand, MBANDCID_POPUPITEM, dwOpt, &vargIn, NULL);
            poct->Release();
            return S_OK;
        }
    }
    else if (pmsg->message == g_nMBDragCancel)
    {
        // If we got a drag cancel, make sure that the bottom most
        // menu does not have the drag enter.
        IUnknown_QueryServiceExec(SAFECAST(this, IOleCommandTarget*), 
            SID_SMenuBandBottom, &CGID_MenuBand, MBANDCID_DRAGCANCEL, 0, NULL, NULL);
        return S_OK;
    }
    else if (pmsg->message == g_nMBOpenChevronMenu)
    {

        VARIANTARG v;
        v.vt = VT_I4;
        v.lVal = (LONG)pmsg->wParam;

        IUnknown_Exec(_punkSite, &CGID_DeskBand, DBID_PUSHCHEVRON, _dwBandID, &v, NULL);
    }
    else if (pmsg->message == g_nMBFullCancel)
    {
        _SubMenuOnSelect(MPOS_CANCELLEVEL);
        _CancelMode(MPOS_FULLCANCEL);
        return S_OK;
    }

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuBand::IsMenuMessage method

         The thread's message pump calls this function to see if any
         messages need to be redirected to the menu band.

         This returns S_OK if the message is handled.  The
         message pump should not pass it onto TranslateMessage
         or DispatchMessage if it does.

*/
STDMETHODIMP CMenuBand::IsMenuMessage(MSG * pmsg)
{
    HRESULT hres = S_FALSE;

    ASSERT(IS_VALID_WRITE_PTR(pmsg, MSG));

#ifdef DEBUG
    if (g_dwDumpFlags & DF_TRANSACCELIO)
        DumpMsg(TEXT("CMB::IsMM"), pmsg);
#endif
    if (!_fShow)
        goto Return;

    switch (pmsg->message)
    {
    case WM_SYSKEYDOWN:
        // blow this off if it's a repeated keystroke
        if (!(pmsg->lParam & 0x40000000))
        {
            SendMessage(_hwndParent, WM_CHANGEUISTATE ,MAKEWPARAM(UIS_CLEAR, UISF_HIDEACCEL), 0);

            // Are we pressing the Alt key to activate the menu?
            if (!_fMenuMode && pmsg->wParam == VK_MENU && _pmbState)
            {
                // Yes; The the menu was activated because of a keyboard,
                // Set the global state to show the keyboard cues.
                _pmbState->SetKeyboardCue(TRUE);

                // Since this only happens on the top level menu,
                // We only have to tell the "Top" menu to update it's state.
                _pmtbTop->SetKeyboardCue();
            }
        }
        break;

    case WM_SYSKEYUP:
        // If we're in menu mode, ignore this message. 
        // 
        if (_fMenuMode)
            hres = S_OK;
        break;

    case WM_SYSCHAR:
        // We intercept Alt-key combos (when pressed together) here,
        // to prevent USER from going into a false menu loop check.  
        // There are compatibility problems if we let that happen.
        //
        // Sent by USER32 when the user hits an Alt-char combination.
        // We need to translate this into popping down the correct
        // menu.  Normally we intercept this in the message pump
        //

        // Outlook Express needs a message hook in order to filter this 
        // message for perf we do not use that method.

        // Athena fix 222185 (lamadio) We also don't want to do this if we are not active! 
        // otherwise when WAB is on top of OE, we'll steal it's messages

        // BUGBUG: i'm removing GetTopMostPtr check below ... breaks menu accelerators for IE5 (224040)

        // (lamadio): If the Message filter is "engaged", then we can process accelerators.
        // Engaged does not mean that the filter is running.
        if (GetMessageFilter()->IsEngaged())
        {
            hres = (_OnSysChar(pmsg, TRUE) == S_OK) ? S_OK : S_FALSE;
        }
        break;

    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_KEYUP:
        if (_fMenuMode)
        {
            // All keystrokes should be handled or eaten by menubands
            // if we're engaged.  We must do this, otherwise hosted 
            // components like mshtml or word will try to handle the 
            // keystroke in CBaseBrowser.

            // Also, don't bother forwarding tabs
            if (VK_TAB != pmsg->wParam)
            {
                // Since we're answer S_OK, dispatch it ourselves.
                TranslateMessage(pmsg);
                DispatchMessage(pmsg);
            }

            hres = S_OK;
        }
        break;

    case WM_CONTEXTMENU:
        // HACKHACK (lamadio): Since the start button has the keyboard focus,
        // the start button will handle this. We need to forward this off to the 
        // currently tracked item at the bottom of the chain
        LRESULT lres;
        IWinEventHandler* pweh;

        if (_fMenuMode &&
            SUCCEEDED(QueryService(SID_SMenuBandBottomSelected, IID_IWinEventHandler, (LPVOID *)&pweh)))
        {
            // BUGBUG (lamadio): This will only work because only one of the two possible toolbars
            // handles this
            pweh->OnWinEvent(HWND_BROADCAST, pmsg->message, 
                pmsg->wParam, pmsg->lParam, &lres);
            pweh->Release();
            hres = S_OK;
        }
        break;

    default:

        // We only want to process the pane messages in IsMenuMessage when there is no
        // top level HWND. This is for the Deskbar menus. Outlook Express needs the 
        // TranslateMenuMessage entry point

        if (_pmbState->GetSubclassedHWND() == NULL)
            hres = _ProcessMenuPaneMessages(pmsg);
        break;
    }

Return:
    if (!_fMenuMode && hres != S_OK)
        hres = E_FAIL;


    return hres;
}

BOOL HasWindowTopmostOwner(HWND hwnd)
{
    HWND hwndOwner = hwnd;
    while (hwndOwner = GetWindowOwner(hwndOwner))
    {
        if (GetWindowLong(hwndOwner, GWL_EXSTYLE) & WS_EX_TOPMOST)
            return TRUE;
    }

    return FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuBand::TranslateMenuMessage method

         The main app's window proc calls this so the menuband
         catches messages that are dispatched from a different
         message pump (than the thread's main pump).
         
         Translates messages specially for menubands.  Some messages
         are processed while the menuband is active.  Others are only
         processed when it is not.  Messages that are not b/t
         WM_KEYFIRST and WM_KEYLAST are handled here (the browser
         does not send these messages to IInputObject::
         TranslateAcceleratorIO).


Returns: S_OK if message is processed

*/
STDMETHODIMP CMenuBand::TranslateMenuMessage(MSG * pmsg, LRESULT * plRet)
{
    ASSERT(IS_VALID_WRITE_PTR(pmsg, MSG));

#ifdef DEBUG
    if (g_dwDumpFlags & DF_TRANSACCELIO)
        DumpMsg(TEXT("CMB::TMM"), pmsg);
#endif

    switch (pmsg->message)
    {
    case WM_SYSCHAR:
        // In certain doc-obj situations, the OLE message filter (??)
        // grabs this before the main thread's message pump gets a 
        // whack at it.  So we handle it here too, in case we're in
        // this scenario.
        //
        // See the comments in IsMenuMessage regarding this message.
        return _OnSysChar(pmsg, FALSE);

    case WM_INITMENUPOPUP:
        // Normally the LOWORD(lParam) is the index of the menu that 
        // is being popped up.  TrackPopupMenu (which CMenuISF uses) 
        // always sends this message with an index of 0.  This breaks 
        // clients (like DefView) who check this value.  We need to
        // massage this value if we find we're the source of the 
        // WM_INITMENUPOPUP.
        //
        // (This is not in TranslateAcceleratorIO b/c TrackPopupMenu's
        // message pump does not call it.  The wndproc must forward
        // the message to this function for us to get it.)

        if (_fInSubMenu && _pmtbTracked)
        {
            // Massage lParam to use the right index
            int iPos = ToolBar_CommandToIndex(_pmtbTracked->_hwndMB, _nItemCur);
            pmsg->lParam = MAKELPARAM(iPos, HIWORD(pmsg->lParam));

            // Return S_FALSE so this message will still be handled
        }
        break;

    case WM_UPDATEUISTATE:
        if (_pmbState)
        {
            // we don't care about UISF_HIDEFOCUS
            if (UISF_HIDEACCEL == HIWORD(pmsg->wParam))
                _pmbState->SetKeyboardCue(UIS_CLEAR == LOWORD(pmsg->wParam) ? TRUE : FALSE);
        }
        break;


    case WM_ACTIVATE:
        {
            CMBMsgFilter* pmf = GetMessageFilter();
            // Debug note: to debug menubands on ntsd, set the prototype
            // flag accordingly.  This will keep menubands from going
            // away the moment the focus changes.

            // Becomming inactive?
            if (WA_INACTIVE == LOWORD(pmsg->wParam))
            {
                // Yes; Free up the global object
                // Athena fix (lamadio) 08.02.1998: Athena uses menubands. Since they
                // have a band per window in one thread, we needed a mechanism to switch
                // between them. So we used the Msgfilter to forward messages. Since there 
                // are multiple windows, we need to set correct one.
                // But, On a deactivate, we need to NULL it out incase a window,
                // running in the same thread, has normal USER menu. We don't want to steal
                // their messages.
                if (pmf->GetTopMostPtr() == this)
                    pmf->SetTopMost(NULL);

                pmf->DisEngage(_pmbState->GetContext());

                HWND hwndLostTo = (HWND)(pmsg->lParam);

                // We won't bail on the menus if we're loosing activation to a child.
                if (!IsAncestor(hwndLostTo, _pmbState->GetWorkerWindow(NULL)))
                {
                    if (_fMenuMode &&
                        !(g_dwPrototype & PF_USINGNTSD) && 
                        !_fDragEntered)
                    {
                        // Being deactivated.  Bail out of menus.  
                        // (Only the toplevel band gets this message.)
                        if (_fInSubMenu)
                        {
                            IMenuPopup* pmp = _pmpSubMenu;
                            if (_pmpTrackPopup)
                                pmp = _pmpTrackPopup;
                            ASSERT(pmp);    // This should be valid. If not, someone screwed up.
                            pmp->OnSelect(MPOS_FULLCANCEL);
                        }

                        _CancelMode(MPOS_FULLCANCEL);
                    }
                }
            }
            else if (WA_ACTIVE == LOWORD(pmsg->wParam) || 
                     WA_CLICKACTIVE == LOWORD(pmsg->wParam))
            {
                // If I have activation, the Worker Window needs to be bottom...
                //
                // NOTE: Don't do this if the worker window has a topmost owner
                // (such as the tray).  Setting a window to HWND_NOTOPMOST moves
                // its owner windows to HWND_NOTOPMOST as well, which in this case
                // was breaking the tray's "always on top" feature.
                //
                HWND hwndWorker = _pmbState->GetWorkerWindow(NULL);
                if (hwndWorker && !HasWindowTopmostOwner(hwndWorker) && !_fDragEntered)
                    SetWindowPos(hwndWorker, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);

                // Set the context because when a menu heirarchy becomes active because the
                // subclassed HWND becomes active, we need to reenable the message hook.
                pmf->SetContext(this, TRUE);

                // When we get reactivated, we need to position ourself above the start bar.
                Exec(&CGID_MenuBand, MBANDCID_REPOSITION, TRUE, NULL, NULL);
            
                // Becomming activated. We need to reengage the message hook so that
                // we get the correct messages.
                pmf->ReEngage(_pmbState->GetContext());

                // Are we in menu mode?
                if (_fMenuMode)
                {
                    // Need to reengage some things.
                    // Take the capture back because we have lost it to context menus or dialogs.
                    pmf->RetakeCapture();

                }
                pmf->SetTopMost(this);
            }

            //
            // Memphis and NT5 grey their horizontal menus when the windows is inactive.
            //
            if (!_fVertical && (g_bRunOnMemphis || g_bRunOnNT5) && _pmtbMenu)
            {
                // This needs to stay here because of the above check...
                if (WA_INACTIVE == LOWORD(pmsg->wParam))
                {
                    _fAppActive = FALSE;
                }
                else
                {
                    _fAppActive = TRUE;
                }
                // Reduces flicker by using this instead of an InvalidateWindow/UpdateWindow Pair
                RedrawWindow(_pmtbMenu->_hwndMB, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }
        break;

    case WM_SYSCOMMAND:
        if ( !_fMenuMode )
        {
            switch (pmsg->wParam & 0xFFF0)
            {
            case SC_KEYMENU:
                // The user either hit the Alt key by itself or Alt-space.
                // If it was Alt-space, let DefWindowProc handle it so the
                // system menu comes up.  Otherwise, we'll handle it to
                // toggle the menuband.

                // Was it Alt-space?
                if (_fAltSpace)
                {
                    // Yes; let it go
                    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Caught the Alt-space", DBG_THIS);
                    _fAltSpace = FALSE;
                }
                else if (_fShow)
                {
                    // No; activate the menu
                    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Caught the WM_SYSCOMMAND, SC_KEYMENU", DBG_THIS);

                    UIActivateIO(TRUE, NULL);

                    // We sit in a modal loop here because typically
                    // WM_SYSCOMMAND doesn't return until the menu is finished.
                    //
                    while (_fMenuMode) 
                    {
                        MSG msg;
                        if (GetMessage(&msg, NULL, 0, 0)) 
                        {
                            if ( S_OK != IsMenuMessage(&msg) )
                            {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                            }
                        }
                    }

                    *plRet = 0;
                    return S_OK;        // Caller shouldn't handle this
                }
                break;
            }
        }
        break;

    default:
        // We only want to process the pane messages in IsMenuMessage when there is no
        // top level HWND. This is for the Deskbar menus. Outlook Express needs the 
        // TranslateMenuMessage entry point
        if (_pmbState->GetSubclassedHWND() != NULL)
            return _ProcessMenuPaneMessages(pmsg);
        break;


    }
    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

         Called by the menusite to host this band.  Since the
         menuband contains two toolbars, we set their parent
         window to be the site's hwnd.

*/
STDMETHODIMP CMenuBand::SetSite(IUnknown* punkSite)
{
    // Do this first because SetParent needs to query to the top level browser for
    // sftbar who queries to the top level browser to get the drag and drop window.
    HRESULT hres = SUPERCLASS::SetSite(punkSite);

    if (_psmcb && _fTopLevel && !(_dwFlags & SMINIT_NOSETSITE))
        IUnknown_SetSite(_psmcb, punkSite);

    IUnknown_GetWindow(punkSite, &_hwndParent);

    // Need this for Closing an expanded vertical menu. Start Menu knows to do this when it's top level,
    // but the Favorites needs to know when it's parent is the horizontal menu.
    VARIANT var;
    if (SUCCEEDED(IUnknown_QueryServiceExec(punkSite, SID_SMenuBandParent, &CGID_MenuBand,
                                       MBANDCID_ISVERTICAL, 0, NULL, &var)) && 
        var.boolVal == VARIANT_FALSE)
    {
        _fParentIsHorizontal = TRUE;
    }


    // Tell the toolbars who their new parent is
    if (_pmtbMenu)
        _pmtbMenu->SetParent(_hwndParent);
    if (_pmtbShellFolder)
        _pmtbShellFolder->SetParent(_hwndParent);

    return hres;
}

/*----------------------------------------------------------
Purpose: IShellMenu::Initialize method

*/
STDMETHODIMP CMenuBand::Initialize(IShellMenuCallback* psmcb, UINT uId, UINT uIdAncestor, DWORD dwFlags)
{
    DEBUG_CODE( _fInitialized = TRUE; );

    // Initalized can be called with NULL values to only set some of them.

    // Default to Vertical
    if (!(dwFlags & SMINIT_HORIZONTAL) && !(dwFlags & SMINIT_VERTICAL))
        dwFlags |= SMINIT_VERTICAL;

    _Initialize(dwFlags);

    if (uIdAncestor != ANCESTORDEFAULT)
        _uIdAncestor = uIdAncestor;

    if (_uId != -1)
        _uId = uId;

    if (psmcb)
    {
        if (!SHIsSameObject(psmcb, _psmcb))
        {
            if (_punkSite && _fTopLevel && !(dwFlags & SMINIT_NOSETSITE))
                IUnknown_SetSite(_psmcb, NULL);

            ATOMICRELEASE(_psmcb);
            _psmcb = psmcb;
            _psmcb->AddRef();

            // We do not set the site in case this callback is shared between 2 bands (Menubar/Chevron menu)
            if (_punkSite && _fTopLevel && !(dwFlags & SMINIT_NOSETSITE))
                IUnknown_SetSite(_psmcb, _punkSite);

            // Only call this if we're setting a new one. Pass the address of the user associated
            // data section. This is so that the callback can associate data with this pane only
            _CallCB(SMC_CREATE, 0, (LPARAM)&_pvUserData);
        }
    }

    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IShellMenu::GetMenuInfo method

*/
STDMETHODIMP CMenuBand::GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags)
{
    if (ppsmc)
    {
        *ppsmc = _psmcb;
        if (_psmcb)
            ((IShellMenuCallback*)*ppsmc)->AddRef();
    }

    if (puId)
        *puId = _uId;

    if (puIdAncestor)
        *puIdAncestor = _uIdAncestor;

    if (pdwFlags)
        *pdwFlags = _dwFlags;

    return NOERROR;
}


void CMenuBand::_AddToolbar(CMenuToolbarBase* pmtb, DWORD dwFlags)
{
    pmtb->SetSite(SAFECAST(this, IMenuBand*));
    if (_hwndParent)
        pmtb->CreateToolbar(_hwndParent);
    
    // Treat this like a two-element stack, where this function
    // behaves like a "push".  The one additional trick is we 
    // could be pushing onto the top or the bottom of the "stack".

    if (dwFlags & SMSET_BOTTOM)
    {
        if (_pmtbBottom)
        {
            // I don't need to release, because _pmtbTop and _pmtbBottom are aliases for
            // _pmtbShellFolder and _pmtbMenu
            _pmtbTop = _pmtbBottom;
            _pmtbTop->SetToTop(TRUE);
        }

        _pmtbBottom = pmtb;
        _pmtbBottom->SetToTop(FALSE);
    }
    else    // Default to Top...
    {
        if (_pmtbTop)
        {
            _pmtbBottom = _pmtbTop;
            _pmtbBottom->SetToTop(FALSE);
        }

        _pmtbTop = pmtb;
        _pmtbTop->SetToTop(TRUE);
    }

    // _pmtbBottom should never be the only toolbar that exists in the menuband.
    if (!_pmtbTop)
        _pmtbTop = _pmtbBottom;

    // The menuband determines there is a single toolbar by comparing
    // the bottom with the top.  So make the bottom the same if necessary.
    if (!_pmtbBottom)
        _pmtbBottom = _pmtbTop;
}


/*----------------------------------------------------------
Purpose: IShellMenu::GetShellFolder method

*/
STDMETHODIMP CMenuBand::GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl,
                                       REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    if (_pmtbShellFolder)
    {
        *pdwFlags = _pmtbShellFolder->GetFlags();

        hres = S_OK;

        if (ppvObj)
        {
            // HACK HACK.  this should QI for a mnfolder specific interface to do this.
            hres = _pmtbShellFolder->GetShellFolder(ppidl, riid, ppvObj);
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::SetShellFolder method

*/
STDMETHODIMP CMenuBand::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hKey, DWORD dwFlags)
{
    ASSERT(_fInitialized);
    HRESULT hres = E_OUTOFMEMORY;

    // If we're processing a change notify, we cannot do anything that will modify state.
    // NOTE: if we don't have a state, we can't possibly processing a change notify
    if (_pmbState && _pmbState->IsProcessingChangeNotify())
        return E_PENDING;

    // Only one shellfolder menu can exist per menuband.  Additionally,
    // a shellfolder menu can exist either at the top of the menu, or
    // at the bottom (when it coexists with a static menu).

    // Is there already a shellfolder menu?
    if (_pmtbShellFolder)
    {
        IShellFolderBand* psfb;
        EVAL(SUCCEEDED(_pmtbShellFolder->QueryInterface(IID_IShellFolderBand, (void**)&psfb)));
        hres = psfb->InitializeSFB(psf, pidlFolder);
        psfb->Release();
        
    }
    else
    {
        _pmtbShellFolder = new CMenuSFToolbar(this, psf, pidlFolder, hKey, dwFlags);
        if (_pmtbShellFolder)
        {
            _AddToolbar(_pmtbShellFolder, dwFlags);
            hres = NOERROR;
        }
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuBand::GetMenu method

*/
STDMETHODIMP CMenuBand::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{
    HRESULT hres = E_FAIL;

    // HACK HACK.  this should QI for a menustatic specific interface to do this.
    if (_pmtbMenu)
        hres = _pmtbMenu->GetMenu(phmenu, phwnd, pdwFlags);

    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuBand::SetMenu method

*/
STDMETHODIMP CMenuBand::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{
    // Passing a NULL hmenu is valid. It means destroy our menu object.
    ASSERT(_fInitialized);
    HRESULT hres = E_FAIL;

    // Only one static menu can exist per menuband.  Additionally,
    // a static menu can exist either at the top of the menu, or
    // at the bottom (when it coexists with a shellfolder menu).

    // Is there already a static menu?
    if (_pmtbMenu)
    {
        // Since we're merging in a new menu, make sure to update the cache...
        _hmenu = hmenu;
        // Yes
        // HACK HACK.  this should QI for a menustatic specific interface to do this.
        return _pmtbMenu->SetMenu(hmenu, hwnd, dwFlags);
    }
    else
    {
        // BUGBUG (lamadio): This is to work around a problem in the interface definintion: We have
        // no method of setting the Subclassed HWND outside of a SetMenu. So I'm just piggybacking
        // off of this. A better fix would be to introduce IMenuBand2::SetSubclass(HWND). IMenuBand
        // actually implements the "Subclassing", so extending this interface would be worthwhile.
        _hwndMenuOwner = hwnd;

        if (_fTopLevel)
        {
            _pmbState->SetSubclassedHWND(hwnd);
        }

        if (hmenu)
        {
            _hmenu = hmenu;
            _pmtbMenu = new CMenuStaticToolbar(this, hmenu, hwnd, _uId, dwFlags);
            if (_pmtbMenu)
            {
                _AddToolbar(_pmtbMenu, dwFlags);
                hres = S_OK;
            }
            else
                hres = E_OUTOFMEMORY;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::SetMenuToolbar method

*/
STDMETHODIMP CMenuBand::SetMenuToolbar(IUnknown* punk, DWORD dwFlags)
{
    CMenuToolbarBase* pmtb;
    if (punk && SUCCEEDED(punk->QueryInterface(CLSID_MenuToolbarBase, (void**)&pmtb)))
    {
        ASSERT(_pmtbShellFolder == NULL);
        _pmtbShellFolder = pmtb;
        _AddToolbar(pmtb, dwFlags);
        return S_OK;
    }
    else
    {
        return E_INVALIDARG;
    }
}


/*----------------------------------------------------------
Purpose: IShellMenu::InvalidateItem method

*/
STDMETHODIMP CMenuBand::InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    HRESULT hres = S_FALSE;

    // If psmd is NULL, we need to just dump the toolbars and do a full reset.
    if (psmd == NULL)
    {
        // If we're processing a change notify, we cannot do anything that will modify state.
        if (_pmbState && _pmbState->IsProcessingChangeNotify())
            return E_PENDING;

        if (_pmbState)
            _pmbState->PushChangeNotify();

        // Tell the callback we're refreshing so that it can
        // reset any cached state
        _CallCB(SMC_REFRESH);
        _fExpanded = FALSE;

        // We don't need to refill if the caller only wanted to 
        // refresh the sub menus.

        // Refresh the Shell Folder first because
        // It may have no items after it's done, and the
        // menuband may rely on this to add a seperator
        if (_pmtbShellFolder)
            _pmtbShellFolder->v_Refresh();

        // Refresh the Static menu
        if (_pmtbMenu)
            _pmtbMenu->v_Refresh();

        if (_pmpSubMenu)
        {
            _fInSubMenu = FALSE;
            IUnknown_SetSite(_pmpSubMenu, NULL);
            ATOMICRELEASE(_pmpSubMenu);
        }

        if (_pmbState)
            _pmbState->PopChangeNotify();

    }
    else
    {
        if (_pmtbTop)
            hres = _pmtbTop->v_InvalidateItem(psmd, dwFlags);

        // We refresh everything at this level if the psmd is null
        if (_pmtbBottom && hres != S_OK)
            hres = _pmtbBottom->v_InvalidateItem(psmd, dwFlags);
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellMenu::GetState method

*/
STDMETHODIMP CMenuBand::GetState(LPSMDATA psmd)
{
    if (_pmtbTracked)
        return _pmtbTracked->v_GetState(-1, psmd);
    // todo: might want to put stuff from _CallCB (below) in here
    return E_FAIL;
}


HRESULT CMenuBand::_CallCB(DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    if (!_psmcb)
        return S_FALSE;

    // We don't need to check callback mask here because these are not maskable events.

    SMDATA smd = {0};
    smd.punk = SAFECAST(this, IShellMenu*);
    smd.uIdParent = _uId;
    smd.uIdAncestor = _uIdAncestor;
    smd.hwnd = _hwnd;
    smd.hmenu = _hmenu;
    smd.pvUserData = _pvUserData;
    if (_pmtbShellFolder)
        _pmtbShellFolder->GetShellFolder(&smd.pidlFolder, IID_IShellFolder, (void**)&smd.psf);
    HRESULT hres = _psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    ILFree(smd.pidlFolder);
    if (smd.psf)
        smd.psf->Release();

    return hres;
}


/*----------------------------------------------------------
Purpose: IInputObject::TranslateAcceleratorIO

         This is called by the base browser only when the menuband
         "has the focus", and only for messages b/t WM_KEYFIRST
         and WM_KEYLAST.  This isn't very useful for menubands.
         See the explanations in GetMsgFilterCB, IsMenuMessage
         and TranslateMenuMessage.

         In addition, menubands cannot ever have the activation,
         so this method should never be called.

         Returns S_OK if handled.
*/
STDMETHODIMP CMenuBand::TranslateAcceleratorIO(LPMSG pmsg)
{
    AssertMsg(0, TEXT("Menuband has the activation but it shouldn't!"));

    return S_FALSE;
}

/*----------------------------------------------------------
Purpose: IInputObject::HasFocusIO

*/
STDMETHODIMP CMenuBand::HasFocusIO()
{
    // We consider a menuband has the focus even if it has submenus
    // that are currently cascaded out.  All menubands in the chain
    // have the focus.
    return _fMenuMode ? S_OK : S_FALSE;
}

/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

         The child menubar calls us with its IMenuPopup pointer.
*/
STDMETHODIMP CMenuBand::SetSubMenu(IMenuPopup * pmp, BOOL fSet)
{
    ASSERT(IS_VALID_CODE_PTR(pmp, IMenuPopup));

    if (fSet)
    {
        _fInSubMenu = TRUE;
    }
    else 
    {
        if (_pmtbTracked)
        {
            _pmtbTracked->PopupClose();
        }

        _fInSubMenu = FALSE;
        _nItemSubMenu = -1;
    }

    return S_OK;
}    

HRESULT CMenuBand::_SiteSetSubMenu(IMenuPopup * pmp, BOOL bSet)
{
    HRESULT hres;
    IMenuPopup * pmpSite;

    hres = IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_IMenuPopup, 
                                 (LPVOID *)&pmpSite);
    if (SUCCEEDED(hres))
    {
        hres = pmpSite->SetSubMenu(pmp, bSet);
        pmpSite->Release();
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: Tell the GetMsg filter that this menuband is ready to
         listen to messages.

*/
HRESULT CMenuBand::_EnterMenuMode(void)
{
    ASSERT(!_fMenuMode);        // Must not push onto stack more than once

    if (g_dwProfileCAP & 0x00002000) 
        StartCAP();

    DEBUG_CODE( _nMenuLevel = g_nMenuLevel++; )

    _fMenuMode = TRUE;
    _fInSubMenu = FALSE;
    _nItemMove = -1;
    _fCascadeAnimate = TRUE;

    _hwndFocusPrev = NULL;

    if (_fTopLevel)
    {
        // BUGBUG (lamadio): this piece should be moved to the shbrowse callback

        // REVIEW (scotth): some embedded controls (like the surround
        // video ctl on the carpoint website) have another thread that
        // eats all the messages when the control has the focus.
        // This prevents us from getting any messages once we're in
        // menu mode.  I don't understand why USER menus work yet.
        // One way to work around this bug is to detect this case and
        // set the focus to our main window for the duration.
        
        if (GetWindowThreadProcessId(GetFocus(), NULL) != GetCurrentThreadId())
        {
            IShellBrowser* psb;
            
            if (SUCCEEDED(QueryService(SID_STopLevelBrowser, IID_IShellBrowser, (void**)&psb)))
            {
                HWND hwndT;
                
                psb->GetWindow(&hwndT);
                _hwndFocusPrev = SetFocus(hwndT);
                psb->Release();
            }
        }
    
        _hCursorOld = GetCursor();
        SetCursor(g_hCursorArrow);
        HideCaret(NULL);
    }

    _SiteSetSubMenu(this, TRUE);

    if (_pmtbTop)
    {
        HWND hwnd = _pmtbTop->_hwndMB;
        if (!_fVertical && -1 == _nItemNew)
        {
            // The Alt key always highlights the first menu item initially
            SetTracked(_pmtbTop);
            ToolBar_SetHotItem(hwnd, 0);
            NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTop->_hwndMB, OBJID_CLIENT, 
                GetIndexFromChild(TRUE, 0));
        }

        _pmtbTop->Activate(TRUE);

        // The toolbar usually tracks mouse events.  However, as the mouse
        // moves over submenus, we still want the parent menubar to
        // behave as if it has retained the focus (that is, keep the
        // last selected item highlighted). This also prevents the toolbar
        // from handling WM_MOUSELEAVE messages unnecessarily.
        ToolBar_SetAnchorHighlight(hwnd, TRUE);

        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Entering menu mode", DBG_THIS);
        NotifyWinEvent(_fVertical? EVENT_SYSTEM_MENUPOPUPSTART: EVENT_SYSTEM_MENUSTART, 
            hwnd, OBJID_CLIENT, CHILDID_SELF);
    }

    if (_pmtbBottom)
    {
        _pmtbBottom->Activate(TRUE);
        ToolBar_SetAnchorHighlight(_pmtbBottom->_hwndMB, TRUE); // Turn off anchoring
    }

    GetMessageFilter()->Push(_pmbState->GetContext(), this, _punkSite);

    return S_OK;
}    


void CMenuBand::_ExitMenuMode(void)
{
    _fMenuMode = FALSE;
    _nItemCur = -1;
    _fPopupNewMenu = FALSE;
    _fInitialSelect = FALSE;
    CMBMsgFilter* pmf = GetMessageFilter();

    if (_pmtbTop)
    {
        HWND hwnd = _pmtbTop->_hwndMB;
        ToolBar_SetAnchorHighlight(hwnd, FALSE); // Turn off anchoring
        if (!_fVertical)
        {
            // Use the first item, since we're assuming every menu must have
            // at least one item
            _pmtbTop->v_SendMenuNotification(0, TRUE);
        
            // The user may have clicked outside the menu, which would have
            // cancelled it.  But since we set the ANCHORHIGHLIGHT attribute,
            // the toolbar won't receive a message to cause it to
            // remove the highlight.  So do it explicitly now.
            SetTracked(NULL);
            UpdateWindow(hwnd);
        }

        _pmtbTop->Activate(FALSE);

        NotifyWinEvent(_fVertical? EVENT_SYSTEM_MENUPOPUPEND: EVENT_SYSTEM_MENUEND, 
            hwnd, OBJID_CLIENT, CHILDID_SELF);
    }

    if (_pmtbBottom)
    {
        _pmtbBottom->Activate(FALSE);
        ToolBar_SetAnchorHighlight(_pmtbBottom->_hwndMB, FALSE); // Turn off anchoring
    }

    pmf->Pop(_pmbState->GetContext());

    _SiteSetSubMenu(this, FALSE);

    if (_fTopLevel)
    {
        SetCursor(_hCursorOld);
        ShowCaret(NULL);
        
        pmf->SetContext(this, FALSE);

        // We do this here, because ShowDW(FALSE) does not get called on the
        // top level menu band. This resets the state, so that the accelerators 
        // are not shown.
        if (_pmbState)
            _pmbState->SetKeyboardCue(FALSE);

        // Tell the menus to update their state to the current global cue state.
        if (_pmtbTop)
            _pmtbTop->SetKeyboardCue();

        if (_pmtbTop != _pmtbBottom && _pmtbBottom)
            _pmtbBottom->SetKeyboardCue();

    }

    if (_hwndFocusPrev)
        SetFocus(_hwndFocusPrev);

    if (_fTopLevel)
    {
        //
        // The top-level menu has gone away.  Win32 focus and ui-activation don't
        // actually change when this happens, so the browser and focused dude have
        // no idea that something happened and won't generate any AA event.  So, we
        // do it here for them.  Note that if there was a selection inside the focused
        // dude, we'll lose it.  This is the best we can do for now, as we don't
        // currently have a way to tell the focused/ui-active guy (who knows about the
        // current selection) to reannounce focus.
        //
        HWND hwndFocus = GetFocus();
        NotifyWinEvent(EVENT_OBJECT_FOCUS, hwndFocus, OBJID_CLIENT, CHILDID_SELF);
    }
        
    TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): Exited menu mode", DBG_THIS);
    DEBUG_CODE( g_nMenuLevel--; )
    DEBUG_CODE( _nMenuLevel = -1; )
    if (g_dwProfileCAP & 0x00002000) 
        StopCAP();
}    


/*----------------------------------------------------------
Purpose: IInputObject::UIActivateIO

         Menubands CANNOT take the activation.  Normally
         a band would return S_OK and call the site's 
         OnFocusChangeIS method, so that its TranslateAcceleratorIO
         method would receive keyboard messages.

         However, menus are different.  The window/toolbar that
         currently has the activation must retain that activation
         when the menu pops down.  Because of this, menubands use 
         a GetMessage filter to intercept messages.

*/
STDMETHODIMP CMenuBand::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    HRESULT hres;
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    if (lpMsg != NULL) {
        // don't allow TAB to band (or any other 'non-explicit' activation).
        // (if we just cared about TAB we'd check IsVK_TABCycler).
        // all kinds of badness would result if we did.
        // the band can't take focus (see above), so it can't obey the
        // UIAct/OnFocChg rules (e.g. can't call OnFocusChangeIS), so
        // our basic activation-tracking assumptions would be broken.
        return S_FALSE;
    }

    if (fActivate)
    {
        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): UIActivateIO(%d)", DBG_THIS, fActivate);
        
        if (!_fMenuMode)
        {
            _EnterMenuMode();

            // BUGBUG (lamadio) : Should go in the Favorites callback.
            // The toplevel menuband does not set the real activation.  
            // But the children do, so activation can be communicated
            // with the parent menuband.
            if (_fVertical)
            {
                IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), TRUE);
            }
            else
            {
                IUnknown_Exec(_punkSite, &CGID_Theater, THID_TOOLBARACTIVATED, 0, NULL, NULL);
            }
        }

        if (_fPopupNewMenu)
        {
            _nItemCur = _nItemNew;
            ASSERT(-1 != _nItemCur);
            ASSERT(_pmtbTracked);

            _fPopupNewMenu = FALSE;
            _nItemNew = -1;

            // Popup a menu
            hres = _pmtbTracked->PopupOpen(_nItemCur);
            if (FAILED(hres))
            {
                // Don't fail the activation
            }
            else if (S_FALSE == hres)
            {
                // The submenu was modal and is finished now
                _ExitMenuMode();
            }
        }
    }
    else if (_fMenuMode)
    {
        TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): UIActivateIO(%d)", DBG_THIS, fActivate);

        ASSERT( !_fInSubMenu );

        if (!_fTopLevel)
            IUnknown_OnFocusChangeIS(_punkSite, SAFECAST(this, IInputObject*), FALSE);

        _ExitMenuMode();
    }

    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IDeskBand::GetBandInfo method

*/
HRESULT CMenuBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) 
{
    HRESULT hres = NOERROR;

    _dwBandID = dwBandID;           // critical for perf! (BandInfoChanged)

    pdbi->dwMask &= ~DBIM_TITLE;    // no title (ever, for now)

    // We expect that _pmtbBottom should never be the only toolbar
    // that exists in the menuband.
    ASSERT(NULL == _pmtbBottom || _pmtbTop);

    pdbi->dwModeFlags = DBIMF_USECHEVRON;

    if (_pmtbTop)
    {
        // If the buttons need to be updated in the toolbars, the we should 
        // do this before we start asking them about their sizes....
        if (_fForceButtonUpdate)
        {
            _UpdateButtons();
        }

        if (_fVertical) 
        {
            pdbi->ptMaxSize.y = 0;
            pdbi->ptMaxSize.x = 0;

            SIZE size = {0};
        
            if (_pmtbMenu)
            {
                // size param zero here => it's just an out param
                _pmtbMenu->GetSize(&size);

                // HACKHACK (lamadio): On downlevel, LARGE metrics mode causes 
                // Start menu to push the programs menu item off screen.
                if (size.cy > (3 * GetSystemMetrics(SM_CYSCREEN) / 4))
                {
                    Exec(&CGID_MenuBand, MBANDCID_SETICONSIZE, ISFBVIEWMODE_SMALLICONS, NULL, NULL);
                    size.cx = 0;
                    size.cy = 0;
                    _pmtbMenu->GetSize(&size);
                }

                pdbi->ptMaxSize.y = size.cy;
                pdbi->ptMaxSize.x = size.cx;
            }
            if (_pmtbShellFolder)
            {
                // size param should be non-zero here => it's an in/out param
                _pmtbShellFolder->GetSize(&size);
                pdbi->ptMaxSize.y += size.cy + ((_pmtbMenu && !_fExpanded)? 1 : 0);   // Minor sizing problem
                pdbi->ptMaxSize.x = max(size.cx, pdbi->ptMaxSize.x);
            }

            pdbi->ptMinSize = pdbi->ptMaxSize;

        }
        else
        {
            HWND hwnd = _pmtbTop->_hwndMB;
            ShowDW(TRUE);

            SIZE rgSize;
            if ( SendMessage( hwnd, TB_GETMAXSIZE, 0, (LPARAM) &rgSize ))
            {
                pdbi->ptActual.y = rgSize.cy;
                SendMessage(hwnd, TB_GETIDEALSIZE, FALSE, (LPARAM)&pdbi->ptActual);
            }

            // make our min size identical to the size of the first button
            // (we're assuming that the toolbar has at least one button)
            RECT rc;
            SendMessage(hwnd, TB_GETITEMRECT, 0, (WPARAM)&rc);
            pdbi->ptMinSize.x = RECTWIDTH(rc);
            pdbi->ptMinSize.y = RECTHEIGHT(rc);
        }
    }
    return hres;
}

/*----------------------------------------------------------
Purpose: IOleService::Exec method

*/
STDMETHODIMP CMenuBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdExecOpt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{

    // Don't do anything if we're closing.
    if (_fClosing)
        return E_FAIL;

    if (pguidCmdGroup == NULL) 
    {
        /*NOTHING*/
    }
    else if (IsEqualGUID(CGID_MENUDESKBAR, *pguidCmdGroup)) 
    {
        switch (nCmdID) 
        {
        case MBCID_GETSIDE:
            if (pvarargOut) 
            {
                BOOL fOurChoice = FALSE;
                pvarargOut->vt = VT_I4;
                
                if (!_fTopLevel) 
                {
                    // if we are not the top level menu, we 
                    // must continue with the direction our parent was in
                    IMenuPopup* pmpParent;
                    IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_IMenuPopup, (LPVOID*)&pmpParent);
                    if (pmpParent) 
                    {
                        if (FAILED(IUnknown_Exec(pmpParent, pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut)))
                            fOurChoice = TRUE;
                        pmpParent->Release();
                    }
                } else 
                    fOurChoice = TRUE;

                if (!fOurChoice) {
                    // only use the parent's side hint if it is in the same orientation (ie, horizontal menubar to vertical popup 
                    // means we need to make a new choice)
                    BOOL fParentVertical = (pvarargOut->lVal == MENUBAR_RIGHT || pvarargOut->lVal == MENUBAR_LEFT);
                    if (BOOLIFY(_fVertical) != BOOLIFY(fParentVertical))
                        fOurChoice = TRUE;
                }

                if (fOurChoice) 
                {
                    if (_fVertical)
                    {
                        HWND hWndMenuBand;

                        //
                        // The MenuBand is Mirrored , then start the first Menu Window
                        // as Mirrored. [samera]
                        //
                        if ((SUCCEEDED(GetWindow(&hWndMenuBand))) &&
                            (IS_WINDOW_RTL_MIRRORED(hWndMenuBand)) ) 
                            pvarargOut->lVal = MENUBAR_LEFT;
                        else
                            pvarargOut->lVal = MENUBAR_RIGHT;
                    }
                    else
                        pvarargOut->lVal = MENUBAR_BOTTOM;
                }

            }
            return S_OK;
        }
    }
    else if (IsEqualGUID(CGID_MenuBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case MBANDCID_GETFONTS:
            // BUGBUG (lamadio): can I remove this?
            if (pvarargOut)
            {
                if (EVAL(_pmbm))
                {
                    // BUGBUG (lamadio): this is not marshal-safe.
                    pvarargOut->vt = VT_UNKNOWN;
                    _pmbm->QueryInterface(IID_IUnknown, (void**)&pvarargOut->punkVal);
                    return S_OK;
                }
                else
                    return E_FAIL;
            }
            else
                return E_INVALIDARG;
            break;

        case MBANDCID_SETFONTS:
            if (pvarargIn && VT_UNKNOWN == pvarargIn->vt && pvarargIn->punkVal)
            {
                // BUGBUG (lamadio): this is not marshal-safe.
                ATOMICRELEASE(_pmbm);
                pvarargIn->punkVal->QueryInterface(CLSID_MenuBandMetrics, (void**)&_pmbm);

                _fForceButtonUpdate = TRUE;
                // Force Update of Toolbars:
                if (_pmtbMenu)
                    _pmtbMenu->SetMenuBandMetrics(_pmbm);

                if (_pmtbShellFolder)
                    _pmtbShellFolder->SetMenuBandMetrics(_pmbm);
            }
            else
                return E_INVALIDARG;
            break;


        case MBANDCID_RECAPTURE:
            GetMessageFilter()->RetakeCapture();
            break;

        case MBANDCID_NOTAREALSITE:
            _fParentIsNotASite = BOOLIFY(nCmdExecOpt);
            break;

        case MBANDCID_ITEMDROPPED:
            {
                _fDragEntered = FALSE;
                HWND hwndWorker = _pmbState->GetWorkerWindow(NULL);
                if (hwndWorker && !HasWindowTopmostOwner(hwndWorker))
                    SetWindowPos(hwndWorker, HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOMOVE);
            }
            break;

        case MBANDCID_DRAGENTER:
            _fDragEntered = TRUE;
            break;

        case MBANDCID_DRAGLEAVE:
            _fDragEntered = FALSE;
            break;

            
        case MBANDCID_SELECTITEM:
            {
                int iPos = nCmdExecOpt;

                // If they are passing vararg in, then this is an ID, not a position
                if (pvarargIn && pvarargIn->vt == VT_I4)
                {
                    _nItemNew = pvarargIn->lVal;
                    _fPopupNewItemOnShow = TRUE;
                }

                // This can be called outside of a created band.
                if (_pmtbTop)
                {
                    if (iPos == MBSI_NONE)
                    {
                        SetTracked(NULL);
                    }
                    else
                    {
                        CMenuToolbarBase* pmtb = (iPos == MBSI_LASTITEM) ? _pmtbBottom : _pmtbTop;
                        ASSERT(pmtb);

                        SetTracked(pmtb);
                        _pmtbTracked->SetHotItem(1, iPos, -1, HICF_OTHER);

                        // If the new hot item is in the obscured part of the menu, then the
                        // above call will have reentered & nulled out _pmtbTracked (since we
                        // drop down the chevron menu if the new hot item is obscured).  So we
                        // need to revalidate _pmtbTracked.
                        if (!_pmtbTracked)
                            break;

                        NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
                            GetIndexFromChild(TRUE, iPos));
                    }
                }
            }
            break;

        case MBANDCID_KEYBOARD:
            // If we've been executed because of a keyboard, then set the global
            // state to reflect that. This is sent by MenuBar when it's ::Popup
            // member is called with the flag MPPF_KEYBOARD. This is for start menu.
            if (_pmbState)
                _pmbState->SetKeyboardCue(TRUE);
            break;

        case MBANDCID_POPUPITEM:
            if (pvarargIn && VT_I4 == pvarargIn->vt)
            {
                // we don't want to popup a sub menu if we're tracking a context menu...
                if ( !((_pmtbBottom && _pmtbBottom->v_TrackingSubContextMenu()) || 
                       (_pmtbTop && _pmtbTop->v_TrackingSubContextMenu())))
                {
                    // No tracked item? Well default to the top (For the chevron menu)
                    if (!_pmtbTracked)
                    {
                        SetTracked(_pmtbTop);
                    }

                    // We don't want to display the sub menu if we're not shown.
                    // We do this because we could have been dismissed before the message
                    // was routed.
                    if (_fShow && _pmtbTracked)
                    {
                        int iItem;
                        int iPos;

                        if (nCmdExecOpt & MBPUI_ITEMBYPOS)
                        {
                            iPos = pvarargIn->lVal;
                            iItem = GetButtonCmd(_pmtbTracked->_hwndMB, pvarargIn->lVal);
                        }
                        else
                        {
                            iPos = ToolBar_CommandToIndex(_pmtbTracked->_hwndMB, pvarargIn->lVal);
                            iItem = pvarargIn->lVal;
                        }


                        if (nCmdExecOpt & MBPUI_SETITEM)
                        {
                            // Set the hot item explicitly since this can be
                            // invoked by the keyboard and the mouse could be 
                            // anywhere.
                            _pmtbTracked->SetHotItem(1, iPos, -1, HICF_OTHER);

                            // If the new hot item is in the obscured part of the menu, then the
                            // above call will have reentered & nulled out _pmtbTracked (since we
                            // drop down the chevron menu if the new hot item is obscured).  So we
                            // need to revalidate _pmtbTracked.
                            if (!_pmtbTracked)
                                break;

                            NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
                                GetIndexFromChild(TRUE, iPos) );
                        }

                        _pmtbTracked->PopupHelper(iItem, nCmdExecOpt & MBPUI_INITIALSELECT);
                    }
                }
            }
            break;

        case MBANDCID_ISVERTICAL:
            if (pvarargOut)
            {
                pvarargOut->vt = VT_BOOL;
                pvarargOut->boolVal = (_fVertical)? VARIANT_TRUE: VARIANT_FALSE;
            }
            break;
            
        case MBANDCID_SETICONSIZE:
            ASSERT(nCmdExecOpt == ISFBVIEWMODE_SMALLICONS || 
                nCmdExecOpt == ISFBVIEWMODE_LARGEICONS);

            _uIconSize = nCmdExecOpt;

            if (_pmtbTop)
                _pmtbTop->v_UpdateIconSize(nCmdExecOpt, TRUE);

            if (_pmtbBottom)
                _pmtbBottom->v_UpdateIconSize(nCmdExecOpt, TRUE);
            break;

        case MBANDCID_SETSTATEOBJECT:
            if (pvarargIn && VT_INT_PTR == pvarargIn->vt)
            {
                _pmbState = (CMenuBandState*)pvarargIn->byref;
            }
            break;

        case MBANDCID_ISINSUBMENU:
            if (_fInSubMenu || (_pmtbTracked && _pmtbTracked->v_TrackingSubContextMenu()))
                return S_OK;
            else
                return S_FALSE;
            break;

        case MBANDCID_ISTRACKING:
            if (_pmtbTracked && _pmtbTracked->v_TrackingSubContextMenu())
                return S_OK;
            else
                return S_FALSE;
            break;

        case MBANDCID_REPOSITION:

            // Don't reposition unless we're shown (Avoids artifacts onscreen of a bad positioning)
            if (_fShow)
            {
                // Don't forget to reposition US!!!
                IMenuPopup* pmdb;
                DWORD dwFlags = MPPF_REPOSITION | MPPF_NOANIMATE;

                // If we should force a reposition. This is so that we get
                // the trickle down reposition so things overlap correctly
                if (nCmdExecOpt)
                    dwFlags |= MPPF_FORCEZORDER;

                if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_IMenuPopup, (void**)&pmdb)))
                {
                    pmdb->Popup(NULL, NULL, dwFlags);
                    pmdb->Release();
                }

                // Reposition the Tracked sub menu based on the current popped up item 
                // since this pane has now moved
                // If they have a sub menu, tell them to reposition as well.
                if (_fInSubMenu && _pmtbTracked)
                {
                    IUnknown_QueryServiceExec(_pmpSubMenu, SID_SMenuBandChild,
                    &CGID_MenuBand, MBANDCID_REPOSITION, nCmdExecOpt, NULL, NULL);
                }
                _pmbState->PutTipOnTop();
            }
            break;

        case MBANDCID_REFRESH:
            InvalidateItem(NULL, SMINV_REFRESH);
            break;
            
        case MBANDCID_EXPAND:
            if (_pmtbShellFolder)
                _pmtbShellFolder->Expand(TRUE);

            if (_pmtbMenu)
                _pmtbMenu->Expand(TRUE);
            break;

        case MBANDCID_DRAGCANCEL:
            // If one of the Sub bands in the menu heirarchy has the drag 
            // (Either because of Drag enter or because of the drop) then 
            // we do not want to cancel. 
            if (!_pmbState->HasDrag())
                _CancelMode(MPOS_FULLCANCEL);
            break;

        case MBANDCID_EXECUTE:
            ASSERT(pvarargIn != NULL);
            if (_pmtbTop && _pmtbTop->IsWindowOwner((HWND)pvarargIn->ullVal) == S_OK)
                _pmtbTop->v_ExecItem((int)nCmdExecOpt);
            else if (_pmtbBottom && _pmtbBottom->IsWindowOwner((HWND)pvarargIn->ullVal) == S_OK)
                _pmtbBottom->v_ExecItem((int)nCmdExecOpt);
            _SiteOnSelect(MPOS_EXECUTE);
            break;
        }

        // Don't bother passing CGID_MenuBand commands to CToolBand
        return S_OK;
    }     
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdExecOpt, pvarargIn, pvarargOut);    
}


/*----------------------------------------------------------
Purpose: IDockingWindow::CloseDW method.

*/
STDMETHODIMP CMenuBand::CloseDW(DWORD dw)
{
    // We don't want to destroy the band if it's cached. 
    // That means it's the caller's respocibility to Unset this bit and call CloseDW explicitly
    if (_dwFlags & SMINIT_CACHED)
        return S_OK;

    // Since we're blowing away all of the menus,
    // Top and bottom are invalid
    _pmtbTracked = _pmtbTop = _pmtbBottom = NULL;

    if (_pmtbMenu)
    {
        _pmtbMenu->v_Close();
    }

    if (_pmtbShellFolder)
    {
        _pmtbShellFolder->v_Close();
    }

    if (_pmpSubMenu)
    {
        _fInSubMenu = FALSE;
        IUnknown_SetSite(_pmpSubMenu, NULL);
        ATOMICRELEASE(_pmpSubMenu);
    }

    // We don't want our base class to blow this window away. It belongs to someone else.
    _hwnd = NULL;
    _fClosing = TRUE;
    
    return SUPERCLASS::CloseDW(dw);
}


/*----------------------------------------------------------
Purpose: IDockingWindow::ShowDW method

Notes:
    for the start menu (non-browser) case, we bracket* the top-level popup
    operation w/ a LockSetForegroundWindow so that another app can't steal
    the foreground and collapse our menu.  (nt5:172813: don't do it for
    the browser case since a) we don't want to and b) ShowDW(FALSE) isn't
    called until exit the browser so we'd be permanently locked!)
*/
STDMETHODIMP CMenuBand::ShowDW(BOOL fShow)
{   
    CMBMsgFilter* pmf = GetMessageFilter();
    // Prevent rentrancy when we're already shown.
    ASSERT((int)_fShow == BOOLIFY(_fShow));
    if ((int)_fShow == BOOLIFY(fShow))
        return NOERROR;

    HRESULT hres = SUPERCLASS::ShowDW(fShow);

    if (!fShow)
    {
        _fShow = FALSE;
        if (_fTopLevel)
        {
            if (_fVertical) 
            {
                // (_fTopLevel && _fVertical) => start menu
                MyLockSetForegroundWindow(FALSE);
            }
            else if (_dwFlags & SMINIT_USEMESSAGEFILTER)
            {
                pmf->SetHook(FALSE, TRUE);
                pmf->SetTopMost(this);
            }

        }

        if ((_fTopLevel || _fParentIsHorizontal) && _pmbState)
        {
            // Reset to not have the drag when we collapse.
            _pmbState->HasDrag(FALSE);
            _pmbState->SetExpand(FALSE);
            _pmbState->SetUEMState(0);
        }

        _CallCB(SMC_EXITMENU);
    }
    else
    {
        _CallCB(SMC_INITMENU);

        _fClosing = FALSE;
        _fShow = TRUE;
        _GetFontMetrics();

        if (_fTopLevel)
        {
            // We set the context here so that the ReEngage causes the message filter
            // to start taking messages on a TopLevel::Show. This prevents a problem
            // where tracking doesn't work when switching between Favorites and Start Menu
            _pmbState->SetContext(this);
            pmf->SetContext(this, TRUE);

            pmf->ReEngage(_pmbState->GetContext());
            if (_hwndMenuOwner && _fVertical)
                SetForegroundWindow(_hwndMenuOwner);

            if (_fVertical) 
            {
                // (_fTopLevel && _fVertical) => start menu
                MyLockSetForegroundWindow(TRUE);
            }
            else if (_dwFlags & SMINIT_USEMESSAGEFILTER)
            {
                pmf->SetHook(TRUE, TRUE);
                pmf->SetTopMost(this);
            }

            _pmbState->CreateFader(_hwndParent);
        }
    }

    if (_pmtbShellFolder)
        _pmtbShellFolder->v_Show(_fShow, _fForceButtonUpdate);

    // Menu needs to be last so that it can update the seperator.
    if (_pmtbMenu)
        _pmtbMenu->v_Show(_fShow, _fForceButtonUpdate);

    if (_fPopupNewItemOnShow)
    {
        HWND hwnd = _pmbState ? _pmbState->GetSubclassedHWND() : NULL;

        if (hwnd || _pmtbMenu)
        {
            PostMessage(hwnd ? hwnd : _pmtbMenu->_hwndMB, g_nMBPopupOpen, 
                _nItemNew, MAKELPARAM(TRUE, TRUE));
        }
        _fPopupNewItemOnShow = FALSE;
    }

    _fForceButtonUpdate = FALSE;
    return hres;
}

void CMenuBand::_GetFontMetrics()
{
    if (_pmbm)
        return;

    if (_fTopLevel)
    {
        ASSERT(_pmtbTop);
        // We need only 1 HWND
        _pmbm = new CMenuBandMetrics(_pmtbTop->_hwndMB);
    }
    else
    {
        AssertMsg(0, TEXT("When this menuband was created, someone forgot to set the metrics"));
        IOleCommandTarget *poct;
    
        HRESULT hres = IUnknown_QueryService(_punkSite, SID_SMenuBandTop, IID_IOleCommandTarget, (LPVOID *)&poct);
        if (SUCCEEDED(hres))
        {
            VARIANTARG vargOut;

            // Ask the toplevel menuband for their font info
            if (SUCCEEDED(poct->Exec(&CGID_MenuBand, MBANDCID_GETFONTS, 0, NULL, &vargOut)))
            {
                if (vargOut.vt == VT_UNKNOWN && vargOut.punkVal)
                {
                    vargOut.punkVal->QueryInterface(CLSID_MenuBandMetrics, (void**)&_pmbm);
                    vargOut.punkVal->Release();
                }
            }
            poct->Release();
        }
    }
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

         This allows the child menubar to tell us when and how
         to bail out of the menu.
*/
STDMETHODIMP CMenuBand::OnSelect(DWORD dwType)
{
    int iIndex;

    switch (dwType)
    {
    case MPOS_CHILDTRACKING:
        // this means that our child did get tracked over it, so we should abort any timeout to destroy it

        if (_pmtbTracked)
        {
            HWND hwnd = _pmtbTracked->_hwndMB;
            if (_nItemTimer) 
            {
                _pmtbTracked->KillPopupTimer();
        
                // Use the command id of the SubMenu that we actually have cascaded out.
                iIndex = ToolBar_CommandToIndex(hwnd, _nItemSubMenu);
                ToolBar_SetHotItem(hwnd, iIndex);
            }
            KillTimer(hwnd, MBTIMER_DRAGOVER);
            _SiteOnSelect(dwType);
        }
        break;
        
    case MPOS_SELECTLEFT:
        if (!_fVertical)
            _OnSelectArrow(-1);
        else
        {
            // Cancel the child submenu.  Hitting left arrow is like
            // hitting escape.
            _SubMenuOnSelect(MPOS_CANCELLEVEL);
        }
        break;

    case MPOS_SELECTRIGHT:
        if (!_fVertical)
            _OnSelectArrow(1);
        else
        {
            // The right arrow gets propagated up to the top, so
            // a fully cascaded menu will be cancelled and the
            // top level menuband will move to the next menu to the
            // right.
            _SiteOnSelect(dwType);
        }
        break;
        
    case MPOS_CANCELLEVEL:
        // Forward onto submenu
        _SubMenuOnSelect(dwType);
        break;

    case MPOS_FULLCANCEL:
    case MPOS_EXECUTE:
        DEBUG_CODE( TraceMsg(TF_MENUBAND, "%d (pmb=%#08lx): CMenuToolbarBase received %s", 
                    DBG_THIS, MPOS_FULLCANCEL == dwType ? TEXT("MPOS_FULLCANCEL") : TEXT("MPOS_EXECUTE")); )

        _CancelMode(dwType);
        break;
    }
    return S_OK;    
}    

void CMenuBand::SetTrackMenuPopup(IUnknown* punk)
{ 
    ATOMICRELEASE(_pmpTrackPopup);
    if (punk)
    {
        punk->QueryInterface(IID_IMenuPopup, (void**)&_pmpTrackPopup);
    }
}


/*----------------------------------------------------------
Purpose: Set the currently tracked toolbar.  Only one
         of the toolbars can have the "activation" at one time.
*/
BOOL CMenuBand::SetTracked(CMenuToolbarBase* pmtb)
{
    if (pmtb == _pmtbTracked)
        return FALSE;

    if (_pmtbTracked)
    {
        // Tell the existing toolbar we're leaving him
        SendMessage(_pmtbTracked->_hwndMB, TB_SETHOTITEM2, -1, HICF_LEAVING);
    }

    _pmtbTracked = pmtb;

    if (_pmtbTracked)
    {
        // This is for accessibility.
        HWND hwnd = _pmtbTracked->_hwndMB;
        int iHotItem = ToolBar_GetHotItem(hwnd);

        if (iHotItem >= 0)
        {
            // Toolbar Items are 0 based, Accessibility apps require 1 based
            NotifyWinEvent(EVENT_OBJECT_FOCUS, hwnd, OBJID_CLIENT, 
                GetIndexFromChild(_pmtbTracked->GetFlags() & SMSET_TOP, iHotItem)); 
        }
    }

    return TRUE;
}


void CMenuBand::_OnSelectArrow(int iDir)
{
    _fKeyboardSelected = TRUE;
    int iIndex;

    if (!_pmtbTracked)
    {
        if (iDir < 0)
        {
            SetTracked(_pmtbBottom);
            iIndex = ToolBar_ButtonCount(_pmtbTracked->_hwndMB) - 1;
        }
        else
        {
            SetTracked(_pmtbTop);
            iIndex = 0;
        }

        // This can happen when going to the chevron.
        if (_pmtbTracked)
            _pmtbTracked->SetHotItem(iDir, iIndex, -1, HICF_ARROWKEYS);
    }
    else
    {
        HWND hwnd = _pmtbTracked->_hwndMB;
        iIndex = ToolBar_GetHotItem(hwnd);
        int iCount = ToolBar_ButtonCount(hwnd);
    
        // Set the hot item explicitly since this is invoked by the 
        // keyboard and the mouse could be anywhere.

        // cycle iIndex by iDir (add extra iCount to avoid negative number problems
        iIndex = (iIndex + iCount + iDir) % iCount; 

        ToolBar_SetHotItem(hwnd, iIndex);
    }

    if (_pmtbTracked)
    {
        NotifyWinEvent(EVENT_OBJECT_FOCUS, _pmtbTracked->_hwndMB, OBJID_CLIENT, 
            GetIndexFromChild(_pmtbTracked->GetFlags() & SMSET_TOP, iIndex));
    }
    _fKeyboardSelected = FALSE;
}

void CMenuBand::_CancelMode(DWORD dwType)
{
    // Tell the hosting site to cancel this level
    if (_fParentIsNotASite)
        UIActivateIO(FALSE, NULL);
    else
        _SiteOnSelect(dwType);
}    

HRESULT CMenuBand::OnPosRectChangeDB (LPRECT prc)
{
    // We want the HMENU portion to ALWAYS have the maximum allowed.
    RECT rcMenu = {0};
    SIZE sizeMenu = {0};
    SIZE sizeSF = {0};
    SIZE sizeMax;

    if (_pmtbMenu)
        _pmtbMenu->GetSize(&sizeMenu);

    if (_pmtbShellFolder)
        _pmtbShellFolder->GetSize(&sizeSF);

    if (sizeSF.cx > sizeMenu.cx)
        sizeMax = sizeSF;
    else
        sizeMax = sizeMenu;

    if (_pmtbMenu)
    {
        if (_pmtbMenu->GetFlags() & SMSET_TOP)
        {

            rcMenu.bottom = sizeMenu.cy;
            rcMenu.right = prc->right;
        }
        else
        {
            rcMenu.bottom = prc->bottom;
            rcMenu.right = prc->right;

            rcMenu.top = prc->bottom - sizeMenu.cy;
            rcMenu.left = 0;
        }

        _pmtbMenu->SetWindowPos(&sizeMax, &rcMenu, 0);
    }

    if (_pmtbShellFolder)
    {
        RECT rc = *prc;

        if (_pmtbShellFolder->GetFlags() & SMSET_TOP)
        {
            rc.bottom = prc->bottom - RECTHEIGHT(rcMenu) + 1;
        }
        else
        {
            rc.top = prc->top + RECTHEIGHT(rcMenu);
        }

        _pmtbShellFolder->SetWindowPos(&sizeMax, &rc, 0);
    }

    return NOERROR;
}


HRESULT IUnknown_OnSelect(IUnknown* punk, DWORD dwType, REFGUID guid)
{
    HRESULT hres;
    IMenuPopup * pmp;

    hres = IUnknown_QueryService(punk, guid, IID_IMenuPopup, 
                                 (LPVOID *)&pmp);
    if (SUCCEEDED(hres))
    {
        pmp->OnSelect(dwType);
        pmp->Release();
    }

    return hres;
}

HRESULT CMenuBand::_SiteOnSelect(DWORD dwType)
{
    return IUnknown_OnSelect(_punkSite, dwType, SID_SMenuPopup);
}

HRESULT CMenuBand::_SubMenuOnSelect(DWORD dwType)
{
    IMenuPopup* pmp = _pmpSubMenu;
    if (_pmpTrackPopup)
        pmp = _pmpTrackPopup;

    return IUnknown_OnSelect(pmp, dwType, SID_SMenuPopup);
}

HRESULT CMenuBand::GetTop(CMenuToolbarBase** ppmtbTop)
{
    *ppmtbTop = _pmtbTop;

    if (*ppmtbTop)
    {
        (*ppmtbTop)->AddRef();
        return NOERROR;
    }

    return E_FAIL;
}

HRESULT CMenuBand::GetBottom(CMenuToolbarBase** ppmtbBottom)
{
    *ppmtbBottom = _pmtbBottom;

    if (*ppmtbBottom)
    {
        (*ppmtbBottom)->AddRef();
        return NOERROR;
    }

    return E_FAIL;

}

HRESULT CMenuBand::GetTracked(CMenuToolbarBase** ppmtbTracked)
{
    *ppmtbTracked = _pmtbTracked;

    if (*ppmtbTracked)
    {
        (*ppmtbTracked)->AddRef();
        return NOERROR;
    }

    return E_FAIL;

}

HRESULT CMenuBand::GetParentSite(REFIID riid, void** ppvObj)
{
    if (_punkSite)
        return _punkSite->QueryInterface(riid, ppvObj);

    return E_FAIL;
}

HRESULT CMenuBand::GetState(BOOL* pfVertical, BOOL* pfOpen)
{
    *pfVertical = _fVertical;
    *pfOpen = _fMenuMode;
    return NOERROR;
}

HRESULT CMenuBand::DoDefaultAction(VARIANT* pvarChild)
{
    if (pvarChild->lVal != CHILDID_SELF)
    {
        CMenuToolbarBase* pmtb = (pvarChild->lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
        int idCmd = GetButtonCmd(pmtb->_hwndMB, (pvarChild->lVal & ~TOOLBAR_MASK) - 1);

        SendMessage(pmtb->_hwndMB, TB_SETHOTITEM2, idCmd, HICF_OTHER | HICF_TOGGLEDROPDOWN);
    }
    else
    {
        _CancelMode(MPOS_CANCELLEVEL);
    }

    return NOERROR;
}

HRESULT CMenuBand::GetSubMenu(VARIANT* pvarChild, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    CMenuToolbarBase* pmtb = (pvarChild->lVal & TOOLBAR_MASK)? _pmtbTop : _pmtbBottom;
    int idCmd = GetButtonCmd(pmtb->_hwndMB, (pvarChild->lVal & ~TOOLBAR_MASK) - 1);

    *ppvObj = NULL;

    if (idCmd != -1 && pmtb)
    {
        hres = pmtb->v_GetSubMenu(idCmd, &SID_SMenuBandChild, riid, ppvObj);
    }

    return hres;
}

HRESULT CMenuBand::IsEmpty()
{
    BOOL fReturn = TRUE;
    if (_pmtbShellFolder)
        fReturn = _pmtbShellFolder->IsEmpty();

    if (fReturn && _pmtbMenu)
        fReturn = _pmtbMenu->IsEmpty();

    return fReturn? S_OK : S_FALSE;
}

/*----------------------------------------------------------
Purpose: IShellMenu2::GetSubMenu method
*/

HRESULT CMenuBand::GetSubMenu(UINT idCmd, REFIID riid, void** ppvObj)
{
    return E_NOTIMPL;
}

HRESULT CMenuBand::SetToolbar(HWND hwnd, DWORD dwFlags)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMenuToolbarBase *pmtb = ToolbarMenu_Create(hwnd);
    if (pmtb)
    {
        hr = SetMenuToolbar(SAFECAST(pmtb, IWinEventHandler*), dwFlags);
        // DONT release! The menus break com identity rules because of a foobar when they were
        // initially designed.
    }
    return hr;
}

HRESULT CMenuBand::SetMinWidth(int cxMenu)
{
    return E_NOTIMPL;
}

HRESULT CMenuBand::SetNoBorder(BOOL fNoBorder)
{
    return E_NOTIMPL;
}

HRESULT CMenuBand::SetTheme(LPCWSTR pszTheme)
{
    return E_NOTIMPL;
}


//----------------------------------------------------------------------------
// CMenuBandMetrics
//
//----------------------------------------------------------------------------


COLORREF GetDemotedColor()
{
    WORD iHue;
    WORD iLum;
    WORD iSat;
    COLORREF clr = (COLORREF)GetSysColor(COLOR_MENU);
    HDC hdc = GetDC(NULL);

    // Office CommandBars use this same algorithm for their "intellimenus"
    // colors.  We prefer to call them "expando menus"...

    if (hdc)
    {
        int cColors = GetDeviceCaps(hdc, BITSPIXEL);
        
        ReleaseDC(NULL, hdc);
        
        switch (cColors)
        {
        case 4:     // 16 Colors
        case 8:     // 256 Colors
            // Default to using Button Face
            break;
            
        default:    // 256+ colors
            
            ColorRGBToHLS(clr, &iHue, &iLum, &iSat);
            
            if (iLum > 220)
                iLum -= 20;
            else if (iLum <= 20)
                iLum += 40;
            else
                iLum += 20;
            
            clr = ColorHLSToRGB(iHue, iLum, iSat);
            break;
        }
    }
    
    return  clr;
}


ULONG CMenuBandMetrics::AddRef()
{
    return ++_cRef;
}

ULONG CMenuBandMetrics::Release()
{
    ASSERT(_cRef > 0);
    if (--_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CMenuBandMetrics::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = SAFECAST(this, IUnknown*);
    }
    else if (IsEqualIID(riid, CLSID_MenuBandMetrics))
    {
        *ppvObj = this;
    }
    else
    {
        *ppvObj = NULL;
        return E_FAIL;
    }

    AddRef();
    return S_OK;
}

CMenuBandMetrics::CMenuBandMetrics(HWND hwnd)
                : _cRef(1)
{
    _SetMenuFont();
    _SetArrowFont(hwnd);
    _SetChevronFont(hwnd);
#ifndef DRAWEDGE
    _SetPaintMetrics(hwnd);
#endif
    _SetTextBrush(hwnd);
    _SetColors();

    HIGHCONTRAST hc = {sizeof(HIGHCONTRAST)};

    if (SystemParametersInfoA(SPI_GETHIGHCONTRAST, sizeof(hc), &hc, 0))
    {
        _fHighContrastMode = (HCF_HIGHCONTRASTON & hc.dwFlags);
    }
}

CMenuBandMetrics::~CMenuBandMetrics()
{
    if (_hFontMenu)
        DeleteObject(_hFontMenu);

    if (_hFontArrow)
        DeleteObject(_hFontArrow);

    if (_hFontChevron)
        DeleteObject(_hFontChevron);

    if (_hbrText)
        DeleteObject(_hbrText);

#ifndef DRAWEDGE
    if (_hPenHighlight)
        DeleteObject(_hPenHighlight);

    if (_hPenShadow)
        DeleteObject(_hPenShadow);
#endif
}

HFONT CMenuBandMetrics::_CalcFont(HWND hwnd, LPCTSTR pszFont, DWORD dwCharSet, TCHAR ch, int* pcx, 
                                  int* pcy, int* pcxMargin, int iOrientation, int iWeight)
{
    ASSERT(hwnd);

    HFONT hFontOld, hFontRet = NULL;
    TEXTMETRIC tm;
    RECT rect={0};

    int cx = 0, cy = 0, cxM = 0;

    HDC hdc = GetDC(hwnd);

    if (hdc)
    {
        hFontOld = (HFONT)SelectObject(hdc, _hFontMenu);
        GetTextMetrics(hdc, &tm);

        // Set the font height (based on original USER code)
        cy = ((tm.tmHeight + tm.tmExternalLeading + GetSystemMetrics(SM_CYBORDER)) & 0xFFFE) - 1;

        // Use the menu font's avg character width as the margin.
        cxM = tm.tmAveCharWidth; // Not exactly how USER does it, but close

        // Shlwapi wraps the ansi/unicode behavior.
        hFontRet = CreateFontWrap(cy, 0, iOrientation, 0, iWeight, 0, 0, 0, dwCharSet, 0, 0, 0, 0, pszFont);
        if (EVAL(hFontRet))
        {
            // Calc width of arrow using this new font
            SelectObject(hdc, hFontRet);
            if (EVAL(DrawText(hdc, &ch, 1, &rect, DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_VCENTER)))
                cx = rect.right;
            else
                cx = tm.tmMaxCharWidth;
        }
        else
        {
            cx = tm.tmMaxCharWidth;
        }
    
        SelectObject(hdc, hFontOld);   
        ReleaseDC(hwnd, hdc);
    }

    *pcx = cx;
    *pcy = cy;
    *pcxMargin = cxM;
    
    return hFontRet;

}


/*
    Call after _SetMenuFont()
*/
void CMenuBandMetrics::_SetChevronFont(HWND hwnd)
{
    ASSERT(!_hFontChevron);
    TCHAR szPath[MAX_PATH];

    NONCLIENTMETRICSA ncm;

    ncm.cbSize = sizeof(ncm);
    // Should only fail with bad parameters...
    EVAL(SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
   
    // Obtain the font's metrics
    SHAnsiToTChar(ncm.lfMenuFont.lfFaceName, szPath, ARRAYSIZE(szPath));
    _hFontChevron = _CalcFont(hwnd, szPath, DEFAULT_CHARSET, CH_MENUARROW, &_cxChevron, &_cyChevron, 
        &_cxChevron, -900, FW_NORMAL);
}

/*
    Call after _SetMenuFont()
*/
void CMenuBandMetrics::_SetArrowFont(HWND hwnd)
{
    ASSERT(!_hFontArrow);
    ASSERT(_hFontMenu);
   
    // Obtain the font's metrics
    if (_hFontMenu)
    {
        _hFontArrow = _CalcFont(hwnd, szfnMarlett, SYMBOL_CHARSET, CH_MENUARROW, &_cxArrow, &_cyArrow, 
            &_cxMargin, 0, FW_NORMAL);
    }
    else
    {
        _cxArrow = _cyArrow = _cxMargin = 0;
    }
}

void CMenuBandMetrics::_SetMenuFont()
{
    NONCLIENTMETRICSA ncm;

    ncm.cbSize = sizeof(ncm);
    // Should only fail with bad parameters...
    EVAL(SystemParametersInfoA(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0));
    // Should only fail under low mem conditions...
    
    EVAL(_hFontMenu = CreateFontIndirectA(&ncm.lfMenuFont));
}

void CMenuBandMetrics::_SetColors()
{
    _clrBackground = GetSysColor(COLOR_MENU);
    _clrMenuText = GetSysColor(COLOR_MENUTEXT);
    _clrDemoted = GetDemotedColor();
}


#ifndef DRAWEDGE
// Office "IntelliMenu" style
void CMenuBandMetrics::_SetPaintMetrics(HWND hwnd)
{
    DWORD dwSysHighlight = GetSysColor(COLOR_3DHIGHLIGHT);
    DWORD dwSysShadow = GetSysColor(COLOR_3DSHADOW);

    _hPenHighlight = CreatePen(PS_SOLID, 1, dwSysHighlight);
    _hPenShadow = CreatePen(PS_SOLID, 1, dwSysShadow);
}
#endif

void CMenuBandMetrics::_SetTextBrush(HWND hwnd)
{
    _hbrText = CreateSolidBrush(GetSysColor(COLOR_MENUTEXT));
}


CMenuBandState::CMenuBandState()                
{ 
    // We will default to NOT show the keyboard cues. This
    // is overridden based on the User Settings.
    _fKeyboardCue = FALSE;
}

CMenuBandState::~CMenuBandState()
{
    ATOMICRELEASE(_ptFader);

    ATOMICRELEASE(_pScheduler);

    if (IsWindow(_hwndToolTip))
        DestroyWindow(_hwndToolTip);

    if (IsWindow(_hwndWorker)) // JANK : Fix for bug #101302
        DestroyWindow(_hwndWorker);
}

int CMenuBandState::GetKeyboardCue()
{
    return _fKeyboardCue;
}

void CMenuBandState::SetKeyboardCue(BOOL fKC)
{
    _fKeyboardCue = fKC;
}

IShellTaskScheduler* CMenuBandState::GetScheduler()
{
    if (!_pScheduler)
    {
        CoCreateInstance(CLSID_ShellTaskScheduler, NULL, CLSCTX_INPROC,
                               IID_IShellTaskScheduler, (void **) &_pScheduler);
    }

    if (_pScheduler)
        _pScheduler->AddRef();


    return _pScheduler;
}

BOOL CMenuBandState::FadeRect(PRECT prc, PFNFADESCREENRECT pfn, LPVOID pvParam)
{
    BOOL    fFade = FALSE;
    SystemParametersInfo(SPI_GETSELECTIONFADE, 0, &fFade, 0);
    if (g_bRunOnNT5 && _ptFader && fFade)
    {
        // Set the callback into the fader window. Do this each time, as the pane 
        // may have changed between fades
        if (_ptFader->FadeRect(prc, pfn, pvParam))
        {
            IShellTaskScheduler* pScheduler = GetScheduler();
            if (pScheduler)
            {
                fFade = pScheduler->AddTask(_ptFader, TASKID_Fader, 
                    ITSAT_DEFAULT_LPARAM, ITSAT_DEFAULT_PRIORITY) == S_OK;
            }
        }
    }

    return fFade;
}

void CMenuBandState::CreateFader(HWND hwnd)
{
    // We do this on first show, because in the Constuctor of CMenuBandState,
    // the Window classes might not be registered yet (As is the case with start menu).
    if (g_bRunOnNT5 && !_ptFader)
    {
        _ptFader = new CFadeTask();
    }
}


void CMenuBandState::CenterOnButton(HWND hwndTB, BOOL fBalloon, int idCmd, LPTSTR pszTitle, LPTSTR pszTip)
{
    // Balloon style holds presidence over info tips
    if (_fTipShown && _fBalloonStyle)
        return;

    if (!_hwndToolTip)
    {
        _hwndToolTip = CreateWindow(TOOLTIPS_CLASS, NULL,
                                         WS_POPUP | TTS_NOPREFIX | TTS_ALWAYSTIP | TTS_BALLOON,
                                         CW_USEDEFAULT, CW_USEDEFAULT,
                                         CW_USEDEFAULT, CW_USEDEFAULT,
                                         NULL, NULL, g_hinst,
                                         NULL);

        if (_hwndToolTip) 
        {
            // set the version so we can have non buggy mouse event forwarding
            SendMessage(_hwndToolTip, CCM_SETVERSION, COMCTL32_VERSION, 0);
            SendMessage(_hwndToolTip, TTM_SETMAXTIPWIDTH, 0, (LPARAM)300);

        }
    }

    if (_hwndToolTip)
    {
        // Collapse the previous tip because we're going to be doing some stuff to it before displaying again.
        SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);

        // Balloon tips don't have a border, but regular tips do. Swap now...
        SHSetWindowBits(_hwndToolTip, GWL_STYLE, TTS_BALLOON | WS_BORDER, (fBalloon) ? TTS_BALLOON : WS_BORDER);

        if (pszTip && pszTip[0])
        {
            POINT   ptCursor;
            RECT    rcItemScreen, rcItemTB;
            TOOLINFO ti = {0};
            ti.cbSize = SIZEOF(ti);

            // This was pretty bad: I kept adding tools, but never deleteing them. Now we get rid of the current
            // one then add the new one.
            if (SendMessage(_hwndToolTip, TTM_ENUMTOOLS, 0, (LPARAM)&ti))
            {
                SendMessage(_hwndToolTip, TTM_DELTOOL, 0, (LPARAM)&ti);   // Delete the current tool.
            }

            SendMessage(hwndTB, TB_GETRECT, idCmd, (LPARAM)&rcItemScreen);
            rcItemTB = rcItemScreen;
            MapWindowPoints(hwndTB, HWND_DESKTOP, (POINT*)&rcItemScreen, 2);

            ti.cbSize = IsOS(OS_WHISTLERORGREATER)?SIZEOF(ti):TTTOOLINFOW_V2_SIZE;
            ti.uFlags = TTF_IDISHWND | TTF_TRANSPARENT | (fBalloon? TTF_TRACK : 0);
            
            // Check if the cursor is within the bounds of the hot item.
            // If it is, then proceed as usual.
            // If it isn't, then the hot item was activated via the keyboard, so the tooltip
            // shouldn't be hung from the cursor.  Stick it on the hot item instead.
            
            // Set the vertical offset to use later.
            // Notice the correction for the bottom: gsierra wanted it up a couple of pixels.
            int nOffset; 
            nOffset = -3;
            
            GetCursorPos(&ptCursor);
            if (!PtInRect(&rcItemScreen, ptCursor))
            {
                ti.uFlags |= TTF_TRACK;

                // The tooltip doesn't seem to pick up the hot item's rect right, so
                // do it manually.
                ti.uFlags ^= TTF_IDISHWND;      // turn this off, so ti.rect is used.
                ti.rect = rcItemTB;

                // Force the tool tip to track along the bottom.
                nOffset = 1;
            }

            SendMessage(_hwndToolTip, TTM_TRACKPOSITION, 0, MAKELONG((rcItemScreen.left + rcItemScreen.right)/2, rcItemScreen.bottom + nOffset));

            ti.hwnd = hwndTB;
            ti.uId = (UINT_PTR)hwndTB;
            SendMessage(_hwndToolTip, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);

            ti.lpszText = pszTip;
            SendMessage(_hwndToolTip, TTM_UPDATETIPTEXT, 0, (LPARAM)&ti);

            SendMessage(_hwndToolTip, TTM_SETTITLE, TTI_INFO, (LPARAM)pszTitle);

            SetWindowPos(_hwndToolTip, HWND_TOPMOST,
                         0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)TRUE, (LPARAM)&ti);
            _fTipShown = TRUE;
            _fBalloonStyle = fBalloon;
        }
    }

}

void CMenuBandState::HideTooltip(BOOL fAllowBalloonCollapse)
{
    if (_hwndToolTip && _fTipShown)
    {
        // Now we're going to latch the Balloon style. The rest of menuband blindly
        // collapses the tooltip when selection changes. Here's where we say "Don't collapse
        // the chevron balloon tip because of a selection change."
        if ((_fBalloonStyle && fAllowBalloonCollapse) || !_fBalloonStyle)
        {
            SendMessage(_hwndToolTip, TTM_TRACKACTIVATE, (WPARAM)FALSE, (LPARAM)0);
            _fTipShown = FALSE;
        }
    }
}

void CMenuBandState::PutTipOnTop()
{
    // Force the tooltip to the topmost.
    if (_hwndToolTip)
    {
        SetWindowPos(_hwndToolTip, HWND_TOPMOST,
                     0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }
}

HWND CMenuBandState::GetWorkerWindow(HWND hwndParent)
{
    if (!_hwndSubclassed)
        return NULL;

    if (!_hwndWorker)
    {
        // We need a worker window, so that dialogs show up on top of our menus.
        // HiddenWndProc is included from sftbar.h
        _hwndWorker = SHCreateWorkerWindow(HiddenWndProc, _hwndSubclassed, 
            WS_EX_TOOLWINDOW, WS_POPUP, 0, (void*)_hwndSubclassed);
    }

    //hwndParent is unused at this time. I plan on using it to prevent the parenting to the subclassed window.

    return _hwndWorker;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\menuisf.h ===
#ifndef _MENUISF_H
#define _MENUISF_H

#include "iface.h"
#include "caggunk.h"
#include "menubar.h"


//  Object that uses TrackPopupMenu as its implementation for IMenuPopup.
//

class CTrackPopupBar : public CMenuDeskBar
{
public:
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (REFIID riid, LPVOID * ppvObj);
    STDMETHOD_(ULONG,AddRef) () ;
    STDMETHOD_(ULONG,Release) ();

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppvObj);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * phwnd) { return E_NOTIMPL; }
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL bEnterMode) { return E_NOTIMPL; }

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    
    CTrackPopupBar(void* pvContext, int id, HMENU hmenu, HWND hwnd);
    ~CTrackPopupBar();
    
    HMENU GetPopupMenu() { return GetSubMenu(_hmenu, _id); };
    void SelectFirstItem();
    
protected:
    int     _id;
    HMENU   _hmenu;
    HWND    _hwndParent;
    void*   _pvContext;
    
    // Popup message to indicate - "Ignore next MENUSELECT clear msg"
    UINT _nMBIgnoreNextDeselect;
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\menusite.h ===
#ifndef _MENUSITE_H_
#define _MENUSITE_H_

//#define WANT_CBANDSITE_CLASS

//#include "bandsite.h"
#include "cwndproc.h"

// MenuSite will never have more than one client.


class CMenuSite : public IBandSite,
                  public IDeskBarClient,
                  public IOleCommandTarget,
                  public IInputObject,
                  public IInputObjectSite,
                  public IWinEventHandler,
                  public IServiceProvider,
                  public CImpWndProc
{

public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IInputObject methods ***
    virtual STDMETHODIMP UIActivateIO(BOOL fActivate, LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO();
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);

    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd);
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode);

    // *** IDeskBarClient methods ***
    virtual STDMETHODIMP SetDeskBarSite(IUnknown* punkSite);
    virtual STDMETHODIMP SetModeDBC(DWORD dwMode);
    virtual STDMETHODIMP UIActivateDBC(DWORD dwState);
    virtual STDMETHODIMP GetSize(DWORD dwWhich, LPRECT prc);

    // *** IWinEventHandler Methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IBandSite ***
    virtual STDMETHODIMP AddBand(IUnknown* punk);
    virtual STDMETHODIMP EnumBands(UINT uBand, DWORD* pdwBandID);
    virtual STDMETHODIMP QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName);
    virtual STDMETHODIMP SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState);
    virtual STDMETHODIMP RemoveBand(DWORD dwBandID);
    virtual STDMETHODIMP GetBandObject(DWORD dwBandID, REFIID riid, LPVOID *ppvObj);
    virtual STDMETHODIMP SetBandSiteInfo(const BANDSITEINFO * pbsinfo);
    virtual STDMETHODIMP GetBandSiteInfo(BANDSITEINFO * pbsinfo);


    CMenuSite();
    
protected:
    virtual ~CMenuSite();
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _CreateSite(HWND hwndParent);
    void _CacheSubActiveBand(IUnknown * punk);


    IUnknown*   _punkSite;
    IUnknown*   _punkSubActive;
    IDeskBand*  _pdb;
    IWinEventHandler*   _pweh;
    HWND        _hwndChild;

    int         _cRef;    

    friend HRESULT CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
};

#endif  // _MENUSITE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\menubar.cpp ===
#include "priv.h"
#include "sccls.h"
#include "basebar.h"
#include "bands.h"
#include "menubar.h"
#include "menuband.h"
#include "isfband.h"

#include "apithk.h"
// APPCOMPAT (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "oleacc.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

#define THISCLASS CMenuDeskBar
#define SUPERCLASS CBaseBar


// Don't fade the menu if it's larger than this magical number. Based on experiments
// on a Pentium II - 233
#define MAGICAL_NO_FADE_HEIGHT  600

// For TraceMsg
#define DM_POPUP   DM_TRACE

#define UP    0
#define DOWN  1
#define LEFT  2
#define RIGHT 3

#ifdef ENABLE_CHANNELS
IDeskBand * ChannelBand_Create(LPCITEMIDLIST pidl);
#endif  // ENABLE_CHANNELS

// Used by performance timing mode
extern DWORD g_dwStopWatchMode;  // Shell performance mode
extern HMENU g_hmenuStopWatch;
extern UINT g_idCmdStopWatch;

HRESULT CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    CMenuDeskBar *pwbar = new CMenuDeskBar();
    if (pwbar)
    {
        *ppunk = SAFECAST(pwbar, IMenuPopup*);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}


CMenuDeskBar::CMenuDeskBar() : SUPERCLASS()
{
    _dwMode = DBIF_VIEWMODE_VERTICAL; 
    
    _iIconSize = BMICON_SMALL;
}

CMenuDeskBar::~CMenuDeskBar()
{
    SetSite(NULL);
}


STDMETHODIMP CMenuDeskBar::QueryInterface(REFIID riid, void **ppvObj)
{
    HRESULT hres;
    static const QITAB qit[] = {
        QITABENT(THISCLASS, IMenuPopup),
        QITABENT(THISCLASS, IObjectWithSite),
        QITABENT(THISCLASS, IBanneredBar),
        QITABENT(THISCLASS, IInitializeObject),
        { 0 },
    };

    hres = QISearch(this, (LPCQITAB)qit, riid, ppvObj);
    if (FAILED(hres))
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);

    return hres;
}


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubmenu method

*/
STDMETHODIMP CMenuDeskBar::SetSubMenu(IMenuPopup* pmp, BOOL fSet)
{
    if (fSet)
    {
        if (_pmpChild)
            _pmpChild->Release();
        
        _pmpChild = pmp;
        _pmpChild->AddRef();    
    }
    else
    {
        if (_pmpChild && SHIsSameObject(pmp, _pmpChild))
        {
            _pmpChild->Release();
            _pmpChild = NULL;
        }
    }
    return S_OK;
}


void CMenuDeskBar::_PopDown()
{
    DAD_ShowDragImage(FALSE);
    if (_pmpChild)
        _pmpChild->OnSelect(MPOS_CANCELLEVEL);
    
//    ShowWindow(_hwnd, SW_HIDE);
    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);
    ShowDW(FALSE);
    if (_pmpParent)
    {
        _pmpParent->SetSubMenu(this, FALSE);
    }
    UIActivateIO(FALSE, NULL);
    _fActive = FALSE;
    DAD_ShowDragImage(TRUE);
}


/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

*/
STDMETHODIMP CMenuDeskBar::OnSelect(DWORD dwSelectType)
{
    switch (dwSelectType)
    {
    case MPOS_CHILDTRACKING:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;
        
    case MPOS_SELECTRIGHT:
    case MPOS_SELECTLEFT:
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_EXECUTE:
    case MPOS_FULLCANCEL:
        _PopDown();
        if (_pmpParent)
            _pmpParent->OnSelect(dwSelectType);
        break;

    case MPOS_CANCELLEVEL:
        _PopDown();
        break;
        
    }
    
    return S_OK;
} 

void SetExpandedBorder(HWND hwnd, BOOL fExpanded)
{
#ifdef MAINWIN
    // IEUNIX : WS_DLGFRAME implementaion looks ugly on UNIX.
    fExpanded = TRUE;
#endif

    DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(hwnd, GWL_EXSTYLE);

    if (fExpanded)
    {
        dwStyle |= WS_BORDER;
        dwStyle &= ~WS_DLGFRAME;
    }
    else
    {
        dwStyle &= ~WS_BORDER;
        dwStyle |= WS_DLGFRAME;
    }

    SetWindowLong(hwnd, GWL_STYLE, dwStyle);
    SetWindowLong(hwnd, GWL_EXSTYLE, dwExStyle);

    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
        SWP_FRAMECHANGED | SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER);
    UpdateWindow(hwnd);
}

void CMenuDeskBar::_OnCreate()
{
    if (!_fFlatMenuMode)
        SetExpandedBorder(_hwnd, _fExpanded);
}


DWORD CMenuDeskBar::_GetClassStyle()
{
    DWORD dwStyle = CS_SAVEBITS; // Faster repaint for menus when they go away
    
    if (IsOS(OS_WHISTLERORGREATER))
    {
        dwStyle |= CS_DROPSHADOW;   // Cool dropshadow effect on whistler....
    }

    return dwStyle;
}

DWORD CMenuDeskBar::_GetExStyle()
{
#ifndef MAINWIN
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST;
#else
    return WS_EX_TOOLWINDOW | WS_EX_TOPMOST | WS_EX_MW_UNMANAGED_WINDOW;
#endif
}

// We use the following structure to pass a whole bunch of information from 
// the GetPopupWindowPosition to WillFit function. We have WillFit function 
// to cut the amount of duplicate code in getpopup window position. The order 
// in which different the sides are checked is the only difference for popping 
// up a window on a particular side.
//
// Having this function helps us to do that check by means of a parameter instead 
// of repeating portions of code again and again.

typedef struct  {
    RECT rcAvail;           // Available dimensions b/t monitor edge and exclude edge
    SIZE sizeAdjust;          // Size of menu edge
    int  cyMonitor;         // Size of monitor 
    int  cxMonitor;
    int  cx;                // Size of menu
    int  cy;
    int  cyExtendDiff;      // Difference b/t calc'd size and available size
    RECT *prcResult;
    RECT *prcExclude;       // Exclude rect
    RECT *prcMonitor;
} PopupInfo;

#define TOP     0
#define BOTTOM  1
#define LEFT    2
#define RIGHT   3 

/*----------------------------------------------------------
Purpose: Attempt to fit and position a menu in the given direction
         relative to an exclude rect.

         Setting fForce to TRUE will cause the menu size to be adjusted
         to fit, if necessary.

         This function only sets the top and left coords, not the bottom
         and right coords.
         
         Returns TRUE if the desired direction can be accomplished.

*/
BOOL WillFit(PopupInfo * pinfo, int side, BOOL fForce)
{
    BOOL bRet = FALSE;
    LPRECT prcResult = pinfo->prcResult;
    
    pinfo->cyExtendDiff = 0;
    
    switch(side)
    {
    case TOP:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.top;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    

            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;    
        }

        // Can the menu be positioned above?
        if (pinfo->cy <= pinfo->rcAvail.top)
        {
            // Yes
            prcResult->top  = pinfo->prcExclude->top - pinfo->cy;
            
            goto AdjustHorzPos;
        }
        break;
        
    case BOTTOM:
        pinfo->cyExtendDiff = pinfo->cy - pinfo->rcAvail.bottom;
        if (fForce)
        {
            // Doesn't make sense to subtract a negative value
            ASSERT(pinfo->cyExtendDiff >= 0);    
            
            // +2 for some breathing room at the edge of the screen
            pinfo->cy -= pinfo->cyExtendDiff + 2;
        }

        // Can the menu be positioned below?
        if (pinfo->cy <= pinfo->rcAvail.bottom)
        {
            // Yes
            prcResult->top = pinfo->prcExclude->bottom;

AdjustHorzPos:            
            prcResult->left = max(pinfo->prcExclude->left, pinfo->prcMonitor->left);

            // Can the menu be positioned relative to its left edge (hanging right)?
            if (prcResult->left + pinfo->cx >= pinfo->prcMonitor->right)
            {
                // No; move it in so it is on the screen
                //  (cx has already been adjusted to fit inside the monitor dimensions)
                prcResult->left = pinfo->prcMonitor->right - pinfo->cx - 1;
            }
            bRet = TRUE;
        }
        break;
        
    case LEFT:
        // Can the menu be positioned to the left?
        if (pinfo->cx <= pinfo->rcAvail.left || fForce)
        {
            // Yes
            
            // When cascading left, the menu does not overlap.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->left - pinfo->cx - 1;

            goto AdjustVerticalPos;
        }
        break;

    case RIGHT:
        // Can the menu be positioned to the right?
        if (pinfo->cx  <=  pinfo->rcAvail.right || fForce)
        {
            // Yes
            
            // Adjust the menu to slightly overlap the parent menu.  Also align
            // so the client rect is vertically aligned with the exclude top.
            prcResult->left = pinfo->prcExclude->right - pinfo->sizeAdjust.cx;

AdjustVerticalPos:            
            prcResult->top = pinfo->prcExclude->top - pinfo->sizeAdjust.cy;

            // Can the menu be positioned relative to its top edge (hanging down)?
            if (prcResult->top + pinfo->cy >= pinfo->prcMonitor->bottom)
            {
                // No; can it be positioned relative to its bottom edge (hanging up)?
                prcResult->top = pinfo->prcExclude->bottom + pinfo->sizeAdjust.cy - pinfo->cy;
                
                if (prcResult->top < pinfo->prcMonitor->top)
                {
                    // No; move the menu so it fits, but isn't vertically snapped.
                    //  (cy has already been adjusted to fit inside the monitor
                    //  dimensions)
                    prcResult->top = pinfo->prcMonitor->bottom - pinfo->cy - 1;
                }
            }
            
            bRet = TRUE;

        }
        break;
    }
    return bRet;

}


void CMenuDeskBar::_GetPopupWindowPosition(RECT* prcDesired, RECT* prcExclude, 
                                           RECT *prcResult, SIZE * psizeAdjust, UINT uSide) 
{
    PopupInfo info;
    MONITORINFO mi;
    HMONITOR hMonitor;
    RECT rcMonitor;
    int cyExtendDiff = 0;

    // Is this going to display the banner bitmap?
    if (_iIconSize == BMICON_LARGE)
    {
        // Yes; add that to the dimensions
        prcDesired->right += _sizeBmp.cx;
    }

    // First get the monitor information
    hMonitor = MonitorFromRect(prcExclude, MONITOR_DEFAULTTONEAREST);
    mi.cbSize = sizeof(mi);
    if (GetMonitorInfo(hMonitor, &mi))
    {
        rcMonitor = mi.rcMonitor;

        // Set the result rectangle same as the desired window
        prcResult->left = prcDesired->left;
        prcResult->top  = prcDesired->top;

        // Calculate some sizes needed for calculation
        info.rcAvail.left   = prcExclude->left - rcMonitor.left;
        info.rcAvail.right  = rcMonitor.right - prcExclude->right;
        info.rcAvail.top    = prcExclude->top - rcMonitor.top;
        info.rcAvail.bottom = rcMonitor.bottom - prcExclude->bottom;

        info.sizeAdjust = *psizeAdjust;
    
        info.cyMonitor = RECTHEIGHT(rcMonitor); 
        info.cxMonitor = RECTWIDTH(rcMonitor);

        info.cx  = RECTWIDTH(*prcDesired);
        info.cy = RECTHEIGHT(*prcDesired);

        // If the desired rect is bigger than monitor then clip it to the monitor size
        if (info.cy > info.cyMonitor)
            info.cy = info.cyMonitor;

        if (info.cx > info.cxMonitor)
            info.cx = info.cxMonitor;

        info.prcResult = prcResult;
        info.prcExclude = prcExclude;
        info.prcMonitor = &rcMonitor;

        //Now Adjust the rectangle for the correct position
        switch(uSide)
        {
        int iSide;

        case MENUBAR_TOP:
    
            if (WillFit(&info, TOP, FALSE))
            {
                _uSide = MENUBAR_TOP;
            }
            else 
            {
                // We couldn't fit it above, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, BOTTOM, FALSE))
                    _uSide = MENUBAR_BOTTOM;
                // We can't fit it below either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
            }
            break;

        case MENUBAR_BOTTOM:
    
            if (WillFit(&info, BOTTOM, FALSE))
            {
                _uSide = MENUBAR_BOTTOM;
            }
            else
            {   
                // We couldn't fit it below, how badly did we fall short?
                cyExtendDiff = info.cyExtendDiff;
                if (WillFit(&info, TOP, FALSE))
                    _uSide = MENUBAR_TOP;

                // We can't fit it above either, which dir was closest?
                // If they are equal, default to requested direction
                else if (info.cyExtendDiff < cyExtendDiff)
                {
                    _uSide = MENUBAR_TOP;
                    WillFit(&info, TOP, TRUE);
                }
                else
                {
                    _uSide = MENUBAR_BOTTOM;
                    WillFit(&info, BOTTOM, TRUE);
                }
            }
            break;

        case MENUBAR_LEFT:

            if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) > (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;

        case MENUBAR_RIGHT:

            if (WillFit(&info, RIGHT, FALSE))
            {
                _uSide = MENUBAR_RIGHT;
            }
            else if (WillFit(&info, LEFT, FALSE))
            {
                _uSide = MENUBAR_LEFT;
            }
            else
            {
                // fit where have most room and can show most of menu.

                if ((info.cx - (info.prcExclude)->right) >= (info.prcExclude)->left)
                {
                    _uSide = MENUBAR_RIGHT;
                    iSide = RIGHT;
                }
                else
                {
                    _uSide = MENUBAR_LEFT;
                    iSide = LEFT;
                }
                WillFit(&info, iSide, TRUE);
            }
            break;
        }
    
        // Finally set the bottom and right

        if (prcResult->top < rcMonitor.top)
            prcResult->top = rcMonitor.top;
        if (prcResult->left < rcMonitor.left)
            prcResult->left = rcMonitor.left;

        prcResult->bottom = prcResult->top  + info.cy;
        prcResult->right  = prcResult->left + info.cx;

        if (prcResult->bottom > rcMonitor.bottom)
        {
            // -2 for some breathing room at the edge of the screen
            prcResult->bottom = rcMonitor.bottom - 2;
            prcResult->top = prcResult->bottom - info.cy;
        }
    }
}

HRESULT CMenuDeskBar::_PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));

    BOOL bSetFocus = (dwFlags & MPPF_SETFOCUS);
    RECT rcDesired;
    RECT rcExclude;
    RECT rc;
    SIZE sizeAdjust;
    UINT uAnimateSide;

    BOOL bMirroredWindow=IS_WINDOW_RTL_MIRRORED(_hwnd);

    static const iPosition[] = {MENUBAR_TOP, MENUBAR_LEFT, MENUBAR_RIGHT, MENUBAR_BOTTOM};

    if (dwFlags & MPPF_POS_MASK)
    {
        UINT uPosIndex = ((dwFlags & MPPF_POS_MASK) >> 29) - 1;
        ASSERT(uPosIndex < 4);
        _uSide = iPosition[uPosIndex];
    }

    if (bSetFocus)
        SetForegroundWindow(_hwnd);
    
    _pt = *(POINT*)ppt;

    // Get the size of the ideal client rect of the child
    RECT rcChild = {0};

    // (scotth): This only sets the bottom and the right values
    _pDBC->GetSize(DBC_GS_IDEAL, &rcChild);

    DWORD dwStyle = GetWindowLong(_hwnd, GWL_STYLE);
    DWORD dwExStyle = GetWindowLong(_hwnd, GWL_EXSTYLE);

    // Adjust for the window border style
    rcDesired = rcChild;        // use rcDesired as a temp variable
    if (!_fNoBorder)
    {
        AdjustWindowRectEx(&rcChild, dwStyle, FALSE, dwExStyle);
    }

    // Calculate the edge of the menu border, and add a fudge factor so
    // left/right-cascaded menus overlap the parent menu a bit and are
    // correctly aligned vertically.

    sizeAdjust.cx = (RECTWIDTH(rcChild) - RECTWIDTH(rcDesired)) / 2;
    sizeAdjust.cy = (RECTHEIGHT(rcChild) - RECTHEIGHT(rcDesired)) / 2;

    if (prcExclude)
    {
        CopyRect(&rcExclude, (RECT*)prcExclude);

        //
        // If mirroring is enabled, let's mirror this guy
        // by simulating a different mirrored rect. This is
        // only for dropdown menus. [samera]
        //  
        if (bMirroredWindow)           
        {
            if ((_uSide != MENUBAR_LEFT)    &&
                (_uSide != MENUBAR_RIGHT) )
            {  
                int x;
                int iW  = rcExclude.right-rcExclude.left;
                int icW = (rcChild.right-rcChild.left);


                if( icW > iW )
                {
                    x = icW - iW;
                    rcExclude.left  -= x ;
                    rcExclude.right -= x ;
                }
                else
                {
                    x = iW - icW;
                    rcExclude.left  += x;
                    rcExclude.right += x;
                }

                ppt->x = rcExclude.left;
            }

        }

        TraceMsg(DM_POPUP, "Parent Side is %d ", _uSide);
        switch(_uSide) 
        {
        case MENUBAR_LEFT :
            rcDesired.left = rcExclude.left - rcChild.right;  // right is width
            rcDesired.top  = rcExclude.top;
            break;

        case MENUBAR_RIGHT :
            rcDesired.left = rcExclude.right;
            rcDesired.top  = rcExclude.top;
            break;
            
        case MENUBAR_TOP:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.top - rcChild.bottom;  // bottom is height
            break;

        case MENUBAR_BOTTOM:
            rcDesired.left = rcExclude.left;
            rcDesired.top  = rcExclude.bottom;
            break;

        default:
            rcDesired.left   = _pt.x;
            rcDesired.top    = _pt.y;
        }
    }
    else
    {
        SetRectEmpty(&rcExclude);

        rcDesired.left   = _pt.x;
        rcDesired.top    = _pt.y;
    }

    rcDesired.right  =  rcDesired.left + RECTWIDTH(rcChild);
    rcDesired.bottom =  rcDesired.top + RECTHEIGHT(rcChild);

    _GetPopupWindowPosition(&rcDesired, &rcExclude, &rc, &sizeAdjust, _uSide);

    UINT uFlags = SWP_NOOWNERZORDER;
    if (!bSetFocus)
        uFlags |= SWP_NOACTIVATE;

    //
    // Open the menus properly. In case of a RTL mirrored window,
    // flip the animation side. [samera]
    //
    if( bMirroredWindow )
    {
        switch( _uSide )
        {
        case MENUBAR_LEFT:
            uAnimateSide = MENUBAR_RIGHT;
        break;
        case MENUBAR_RIGHT:
            uAnimateSide = MENUBAR_LEFT;
        break;
        default:
            uAnimateSide = _uSide;
        }
    }
    else
    {
        uAnimateSide = _uSide;
    }

    TraceMsg(TF_MENUBAND, "CMenuBar::_PositionWindow (%d,%d,%d,%d)",
        rc.left, rc.top, rc.right, rc.bottom);

    // Last minuite tweak. Since we're in large icon, we need to add this
    // so that the bitmap is painted correctly.
    if(_iIconSize == BMICON_LARGE && _fExpanded)
        rc.right += 1;

    // We _DO_ want to do a Z-Order position when this flag is specified. This is
    // for full repositioning where we need to preserve the overlap state of all bands.
    // Otherwize we just want to size the bar without changing it's z-order.
    if (!(dwFlags & MPPF_FORCEZORDER) && 
        (S_OK == IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild,
         &CGID_MenuBand, MBANDCID_ISINSUBMENU, 0, NULL, NULL)))
    {
        uFlags |= SWP_NOZORDER;
    }

    // If it's bigger than this magical number, then we don't animate. change to taste
  
    if (RECTHEIGHT(rc) > MAGICAL_NO_FADE_HEIGHT)
        dwFlags |= MPPF_NOANIMATE;

    AnimateSetMenuPos(_hwnd, &rc, uFlags, uAnimateSide, dwFlags & MPPF_NOANIMATE);

    // Save information so we can later resize this window
    // We already have: _pt, _uSide
    if (prcExclude)
    {
        _fExcludeRect = TRUE;
        CopyRect(&_rcExclude, (RECT*)prcExclude);
    }
    else
        _fExcludeRect = FALSE;
    return S_OK;
} 

/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

*/
STDMETHODIMP CMenuDeskBar::Popup(POINTL* ppt, RECTL* prcExclude, DWORD dwFlags)
{
    HRESULT hr;

    // Is the caller telling us to reposition?
    if (dwFlags & MPPF_REPOSITION)
    {
        if (ppt == NULL)
            ppt = (POINTL*)&_pt;

        if (prcExclude == NULL)
            prcExclude = (RECTL*)&_rcExclude;

        // Yes; Then we don't need to do any First show stuff.
        _PositionWindow(ppt, prcExclude, dwFlags);
        return S_OK;
    }

    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));



    if (g_dwProfileCAP & 0x00002000) 
        StartCAP();

    if (g_dwStopWatchMode)
        StopWatch_Start(SWID_MENU, TEXT("Menu Start"), SPMODE_SHELL | SPMODE_DEBUGOUT);
    
    if (_pmpParent) 
    {
        _pmpParent->SetSubMenu(this, TRUE);
    }

    IOleCommandTarget* poct;
    hr = IUnknown_QueryService(_punkChild, SID_SMenuBandChild, IID_PPV_ARG(IOleCommandTarget, &poct));

    if (SUCCEEDED(hr))
    {
        // We need to do this before the ShowDW. This saves us from doing the setting twice
        // Because in the ShowDW of MenuBand, we actually go an initialize the toolbar with
        // the current default setting which should be "No Keyboard Cues." If we set the state
        // here, then the state will be "Show keyboard cues." Then we will update the toolbar. 
        if (dwFlags & MPPF_KEYBOARD)
            poct->Exec(&CGID_MenuBand, MBANDCID_KEYBOARD, 0, NULL, NULL);
    }
    else
    {
        ASSERT(poct == NULL);
    }
    
    _NotifyModeChange(_dwMode);
    hr = ShowDW(TRUE);

    if (SUCCEEDED(hr) && _pmpParent)
    {
        VARIANT varg;
        // If this Exec fails, don't panic; it just means we use the default side
        if (SUCCEEDED(IUnknown_Exec(_pmpParent, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &varg)))
        {
            if (varg.vt == VT_I4)
            {
                _uSide = (UINT) varg.lVal;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        IEPlaySound(TEXT("MenuPopup"), TRUE);

        _PositionWindow(ppt, prcExclude, dwFlags);

        // Set focus
        UIActivateIO(TRUE, NULL);
    
        _fActive = TRUE;

        // Select the first/last item?
        if ((dwFlags & (MPPF_INITIALSELECT | MPPF_FINALSELECT)) && poct)
        {
            DWORD nCmd = (dwFlags & MPPF_INITIALSELECT) ? MBSI_FIRSTITEM : MBSI_LASTITEM;
            poct->Exec(&CGID_MenuBand, MBANDCID_SELECTITEM, nCmd, NULL, NULL);
        }
    }

    ATOMICRELEASE(poct);
    
    if (g_dwStopWatchMode)
    {
        TCHAR szMenu[32];
        TCHAR szText[256];

        *szMenu = '\0';
        if(g_hmenuStopWatch != NULL)
            GetMenuString(g_hmenuStopWatch, 0, szMenu, ARRAYSIZE(szMenu)-1, MF_BYPOSITION);

        StringCchPrintf(szText, ARRAYSIZE(szText), TEXT("Menu %d %s%sStop"), g_idCmdStopWatch, szMenu, *szMenu ?TEXT(" ") :TEXT(""));
        StopWatch_Stop(SWID_MENU, (LPCTSTR)szText, SPMODE_SHELL | SPMODE_DEBUGOUT);
    }

    if (g_dwProfileCAP & 0x00002000) 
        StopCAP();
        
    return hr;
} 


/*----------------------------------------------------------
Purpose: IInputObjectSite::OnFocusChangeIS

Returns: 
Cond:    --
*/
HRESULT CMenuDeskBar::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IObjectWithSite::SetSite method

*/
STDMETHODIMP CMenuDeskBar::SetSite(IUnknown* punkSite)
{
    ASSERT(NULL == punkSite || IS_VALID_CODE_PTR(punkSite, IUnknown));

    if (_fShow)
        _PopDown();

    ATOMICRELEASE(_punkSite);
    ATOMICRELEASE(_pmpParent);
    
    _punkSite = punkSite;
    
    if (_punkSite)
    {    
        _punkSite->AddRef();
        IUnknown_QueryService(_punkSite, SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &_pmpParent));
    }
    else
    {
        CloseDW(0);
    }
        
    return S_OK;
} 


/*----------------------------------------------------------
Purpose: IObjectWithSite::GetSite method

*/
STDMETHODIMP CMenuDeskBar::GetSite(REFIID riid, LPVOID* ppvSite)
{
    if (_punkSite)
    {
        return _punkSite->QueryInterface(riid, ppvSite);
    }

    *ppvSite = NULL;
    return E_FAIL;
} 

void CMenuDeskBar::AdjustForTheme()
{
    if (_fFlatMenuMode)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_BORDER);
    }
    else if (!_fExpanded)
    {
        SHSetWindowBits(_hwnd, GWL_STYLE, WS_CLIPCHILDREN | WS_DLGFRAME | WS_BORDER, WS_CLIPCHILDREN | WS_DLGFRAME);
    }
}


/*----------------------------------------------------------
Purpose: IOleCommandTarget::Exec method

*/
STDMETHODIMP CMenuDeskBar::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    if (pguidCmdGroup == NULL) 
    {
        
    } 
    else if (IsEqualGUID(CGID_DeskBarClient, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBCID_EMPTY:
            // if we have no bands left, close
            OnSelect(MPOS_FULLCANCEL);
            return S_OK;

        default:
            return OLECMDERR_E_NOTSUPPORTED;
        }
    }

    else if (IsEqualGUID(CGID_MENUDESKBAR, *pguidCmdGroup))
    {
        switch(nCmdID)
        {
            case MBCID_GETSIDE :
                pvarargOut->vt = VT_I4;
                pvarargOut->lVal = _GetSide();
                return S_OK;

            case MBCID_RESIZE:
                if (_fActive)
                {
                    if (_fExcludeRect)
                        _PositionWindow((POINTL *)&_pt, (RECTL *)&_rcExclude, 0);
                    else
                        _PositionWindow((POINTL *)&_pt, NULL, 0);
                }
                return S_OK;

            case MBCID_SETEXPAND:
                if ((BOOL)_fExpanded != (BOOL)nCmdexecopt && !_fFlatMenuMode)
                {
                    _fExpanded = nCmdexecopt;

                    SetExpandedBorder(_hwnd, _fExpanded);
                }
                return S_OK;

            case MBCID_SETFLAT:
                {
                    _fFlatMenuMode = BOOLIFY(nCmdexecopt);
                    AdjustForTheme();
                }
                break;

            case MBCID_NOBORDER:
                {
                    _fNoBorder = BOOLIFY(nCmdexecopt);
                    SetWindowPos(_hwnd, NULL, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_FRAMECHANGED);
                }
                break;

            default : 
                return OLECMDERR_E_NOTSUPPORTED;

        }   
    }
    
    return SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}    

    
/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuPopup)) 
    {
        return QueryInterface(riid, ppvObj);
    }
    else if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
             IsEqualIID(guidService, SID_SMenuBandBottomSelected)||
             IsEqualIID(guidService, SID_SMenuBandChild))
    {
        // SID_SMenuBandBottom queries down
        return IUnknown_QueryService(_punkChild, guidService, riid, ppvObj);
    }
    else
    {
        HRESULT hres = SUPERCLASS::QueryService(guidService, riid, ppvObj);
        
        if (FAILED(hres))
        {
            hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
        }
        
        return hres;
    }
        
} 

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetIconSize(DWORD iIcon)
{
    HRESULT hres;

    _iIconSize = iIcon;

    hres = IUnknown_QueryServiceExec(_punkChild, SID_SMenuBandChild, &CGID_MenuBand, 
        MBANDCID_SETICONSIZE, iIcon == BMICON_SMALL? ISFBVIEWMODE_SMALLICONS: ISFBVIEWMODE_LARGEICONS, NULL, NULL);


    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuDeskBar::SetBitmap(HBITMAP hBitmap)
{
    ASSERT(hBitmap);
    BITMAP bm;
    _hbmp = hBitmap;

    if (_hbmp)
    {
        if(!GetObject(_hbmp, sizeof(bm), &bm))
            return E_FAIL;
        _sizeBmp.cx = bm.bmWidth;
        _sizeBmp.cy = bm.bmHeight;

        // Hack to get color
        HDC hdc = GetDC(_hwnd);
        if (hdc)
        {
            HDC hdcMem = CreateCompatibleDC(hdc);
            if (hdcMem)
            {
                HBITMAP hbmpOld = (HBITMAP)SelectObject(hdcMem, _hbmp);
                _rgb = GetPixel(hdcMem, 0, 0);
                SelectObject(hdcMem, hbmpOld);
                DeleteDC(hdcMem);
            }
            ReleaseDC(_hwnd, hdc);
        }
    }

    return NOERROR;
}

void CMenuDeskBar::_OnSize()
{
    RECT rc;

    if (!_hwndChild)
        return;

    GetClientRect(_hwnd, &rc);

    if(_iIconSize == BMICON_LARGE)
    {
        rc.left += _sizeBmp.cx;
        if (_fExpanded)
            rc.left++;
    }

    SetWindowPos(_hwndChild, 0,
            rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
            SWP_NOACTIVATE|SWP_NOZORDER|SWP_FRAMECHANGED);

    rc.right = rc.left;
    rc.left -= _sizeBmp.cx;
    if (_fShow)
        InvalidateRect(_hwnd, &rc, TRUE);
}

LRESULT CMenuDeskBar::_DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags)
{
    HDC hdcmem;
    HBITMAP hbmpOld;
    RECT rc;
    HBRUSH   hbrush;
    int iDC = SaveDC(hdc);

    GetClientRect(hwnd, &rc);

    //Create a compatable DC
    hdcmem = CreateCompatibleDC(hdc);
    if(hdcmem)
    {
        // Offset the stuff we're paining if we're expanded
        BYTE bOffset = 0;
        // Store this for the Bar fill cycle
        int cyBitmap = 0;

        if (!_fFlatMenuMode)
        {
            bOffset = _fExpanded? 1 : 0;
        }

        if (_sizeBmp.cy <= RECTHEIGHT(rc) + 1)
        {
            //Select the bitmap into the memory DC
            hbmpOld = (HBITMAP)SelectObject(hdcmem, _hbmp);

            //Blit to the window
            BitBlt(hdc, bOffset, rc.bottom - _sizeBmp.cy - bOffset, _sizeBmp.cx, _sizeBmp.cy, hdcmem, 0, 0, SRCCOPY);

            // Ok, We need to subtract this value to see how much we need to paint for the banner.
            cyBitmap = _sizeBmp.cy;

            //Restore the DC
            SelectObject(hdcmem, hbmpOld);
        }

        rc.right = _sizeBmp.cx + bOffset;

        if (_fExpanded && !_fFlatMenuMode && !_fNoBorder)
            DrawEdge(hdc, &rc, BDR_RAISEDINNER, BF_LEFT | BF_TOP | BF_BOTTOM);

        //Paint the rest
        hbrush = CreateSolidBrush(_rgb);
        if(hbrush)
        {
            rc.bottom -= cyBitmap + bOffset;

            if (_fExpanded)
            {
                rc.left += bOffset;
                rc.top += bOffset;
            }

            FillRect(hdc, &rc, hbrush);
            DeleteObject(hbrush);
        }


        //Delete the DC.
        DeleteDC(hdcmem);
    }

    RestoreDC(hdc, iDC);
    return 0;
}

void CMenuDeskBar::_DoNCPaint(HWND hwnd, HDC hdc)
{
    if (!_fNoBorder)
    {
        RECT rc;

        // Since we need to paint the border, we get the window rect
        GetWindowRect(hwnd, &rc);
        // then change the rect so that it represents values relative to 
        // the origin.
        OffsetRect(&rc, -rc.left, -rc.top);

        if (hdc)
        {
            if (_fFlatMenuMode)
            {
                SHOutlineRect(hdc, &rc, GetSysColor(COLOR_3DSHADOW));
            }
            else 
                DrawEdge(hdc, &rc, BDR_RAISEDOUTER, BF_RECT);
        }
    }
}


LRESULT CMenuDeskBar::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    
    LRESULT lres;

    switch (uMsg) 
    {
#ifdef MAINWIN
    case WM_NCPAINTSPECIALFRAME:
        // In  case  of  motif look  the  MwPaintBorder paints a Etched In
        // border if WM_NCPAINTSPECIALFRAME returns FALSE. We are handling
        // this message here and drawing the Etched Out frame explicitly.
        // wParam - HDC
        if (MwCurrentLook() == LOOK_MOTIF)
        {
            MwPaintSpecialEOBorder( hwnd, (HDC)wParam );
            return TRUE;
        }
        break;
#endif

    case WM_GETOBJECT:
        if ((DWORD)lParam == OBJID_MENU)
        {
            IAccessible* pacc;
            if (SUCCEEDED(QueryService(SID_SMenuBandChild, IID_PPV_ARG(IAccessible, &pacc))))
            {
                lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(pacc, IAccessible*));
                pacc->Release();

                return lres;
            }
        }
        break;


    case WM_NCCREATE:
        //
        // Since this is a mirrored menu, then open it
        // on the left (mirrored) edge if possible. WillFit(...) will
        // ensure this for us [samera]
        //
        // Mirror the menu initially if its window is mirrored
        //
        ASSERT(_uSide == 0);
        if (IS_WINDOW_RTL_MIRRORED(_hwnd))
            _uSide = MENUBAR_LEFT;
        else
            _uSide = MENUBAR_RIGHT;
        break;

    case WM_ACTIVATE:
        if (LOWORD(wParam) == WA_INACTIVE) 
        {
            if (_fActive && !_pmpChild) 
            {
                
                // if we were active, and the thing going active now
                // is not one of our parent menubars, then cancel everything.
                
                // if it's a parent of ours going active, assume that
                // they will tell us to die when they want us to...
                if (!_IsMyParent((HWND)lParam))
                    OnSelect(MPOS_FULLCANCEL);
            }
        } 
        else 
        {
            if (_pmpChild) 
            {
                // if we're becoming active, and we have a child, that child should go away
                _pmpChild->OnSelect(MPOS_CANCELLEVEL);
            }
        }
        break;

    case WM_PRINTCLIENT:
        if (_iIconSize == BMICON_LARGE)
        {
            _DoPaint(hwnd, (HDC)wParam, (DWORD)lParam);
            return 0;
        }
        break;

    case WM_PAINT:
        // Paint the banner if we're in showing large icons
        if (_iIconSize == BMICON_LARGE)
        {
            PAINTSTRUCT ps;
            BeginPaint(hwnd, &ps);
            _DoPaint(hwnd, ps.hdc, 0);
            EndPaint(hwnd, &ps);
            return 0;
        }
        break;

   case WM_PRINT:
        if ((_fFlatMenuMode || _fExpanded) && PRF_NONCLIENT & lParam)
        {
            HDC hdc = (HDC)wParam;

            DefWindowProcWrap(hwnd, WM_PRINT, wParam, lParam);

            // Do this after so that we look right...
            _DoNCPaint(hwnd, hdc);

            return 1;
        }
        break;

    case WM_NCCALCSIZE:
        if (_fNoBorder)
        {
            return 0;
        }
        else
        {
            return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
        }
        break;

    case WM_NCPAINT:
        if (_fNoBorder)
        {
            return 0;
        }
        else if (_fExpanded || _fFlatMenuMode)
        {    
            HDC hdc;    
            hdc = GetWindowDC(hwnd);
            if (hdc)
            {
                _DoNCPaint(hwnd, hdc);
                ReleaseDC(hwnd, hdc);
            }
            return 1;
        } 
        break;

    case WM_NCHITTEST:
        lres = SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);

        switch (lres)
        {
        case HTBOTTOM:
        case HTBOTTOMLEFT:
        case HTBOTTOMRIGHT:
        case HTLEFT:
        case HTRIGHT:
        case HTTOP:
        case HTTOPLEFT:
        case HTTOPRIGHT:
            // Don't allow the window to be resized
            lres = HTBORDER;
            break;

        case HTTRANSPARENT:
            // Don't let a click go thru to the window underneath
            lres = HTCLIENT;
            break;

        }
        return lres;

        // HACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACKHACK
        // (lamadio) 1.25.99
        // This hack is here to fix a problem on down level Windows with Integrated
        // IE4.01, IE5 and Office 2000.
        // The bug revolves around Start Menu not being destroyed when Explorer.exe shuts
        // down. Start Menu unregisters itself at CloseDW, but since the menubar never gets
        // destroyed, Start Menu never deregisters itself.
        // When an System service, such as MSTASK.dll keeps shell32 alive in the background,
        // it leaves an outstanding reference to a change notify. When a new user logs in,
        // O2k and IE5 fire up group conv, generating more than 10 change notify events in the
        // start menu. This causes the batching code to be fired up: Which does not really
        // work without the shell started. GroupConv also adds these events using memory 
        // alloced from it's process heap. Since there is an outstanding change notify handler
        // these pidls get forced to be handled. Shell32 then faults derefing a bad pidl.
        // By detecting an Endsession, we can eliminate this problem. Doing a SetClient(NULL)
        // cause Menubar to free it's references to MenuSite. Menusite, calls CloseDW on menuband
        // menuband then causes MNFolder to unregister itself. Since no one is listening any more
        // the crash is avoided.

    case WM_ENDSESSION:
        if (wParam != 0)
        {
            SetClient(NULL);
        }
        break;

    }
    
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
} 

IMenuPopup* CMenuDeskBar::_GetMenuBarParent(IUnknown* punk)
{
    IMenuPopup *pmp = NULL;
    IObjectWithSite* pows;
    punk->QueryInterface(IID_PPV_ARG(IObjectWithSite, &pows));

    if (pows)
    {    
        IServiceProvider* psp;
        pows->GetSite(IID_PPV_ARG(IServiceProvider, &psp));
        
        if (psp)
        {    
            psp->QueryService(SID_SMenuPopup, IID_PPV_ARG(IMenuPopup, &pmp));
            psp->Release();
        }
        
        pows->Release();
    }
    
    return pmp;
}


// this assumes that hwnd is a toplevel window and that the menudeskbars are also 
// the only hosts and are themselves toplevel
BOOL CMenuDeskBar::_IsMyParent(HWND hwnd)
{
    BOOL fRet = FALSE;
    if (hwnd)
    {
        HWND hwndMenu;
        
        IMenuPopup *pmpParent = _pmpParent;
        if (pmpParent)
            pmpParent->AddRef();
        
        while (pmpParent && !fRet &&
               SUCCEEDED(IUnknown_GetWindow(pmpParent, &hwndMenu)))
        {
            if (hwndMenu == hwnd)
            {
                fRet = TRUE;
            }
            
            IMenuPopup* pmpNext = _GetMenuBarParent(pmpParent);
            pmpParent->Release();
            pmpParent = pmpNext;
        }
    }

    return fRet;
}

IMenuPopup* CreateMenuPopup(IMenuPopup* pmpParent, IShellFolder* psf, LPCITEMIDLIST pidl, 
                            BANDINFOSFB * pbi, BOOL bMenuBand)
{
    return CreateMenuPopup2(pmpParent, NULL, psf, pidl, pbi, bMenuBand);
}

IMenuPopup* CreateMenuPopup2(IMenuPopup* pmpParent, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, 
                            BANDINFOSFB * pbi, BOOL bMenuBand)
{
    
    ASSERT(pmb == NULL || IS_VALID_CODE_PTR(pmb, IMenuBand));
    ASSERT(psf == NULL || IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(pmpParent == NULL || IS_VALID_CODE_PTR(pmpParent, IMenuPopup));
    ASSERT(pidl && IS_VALID_PIDL(pidl));
    ASSERT(pbi == NULL || IS_VALID_READ_PTR(pbi, BANDINFOSFB));

    IMenuPopup* pmp = NULL;
    IDeskBand *pdb = NULL;
    IBandSite *pbs = NULL;
    HRESULT hres = E_FAIL;

    if (!pdb) 
    {
        TraceMsg(TF_MENUBAND, "CreateMenuPopup2 : Did not find a this (0x%x) band.", pidl);

        if (bMenuBand)
        {
            pdb = CMenuBand_Create(psf, pidl, FALSE);
        }
        else
            pdb = CISFBand_CreateEx(psf, pidl);

        if (pdb) 
        {
            if (pbi) 
            {
                IShellFolderBand *pisfBand;
                if (SUCCEEDED(pdb->QueryInterface(IID_IShellFolderBand, (LPVOID*)&pisfBand))) 
                {
                    pisfBand->SetBandInfoSFB(pbi);
                    pisfBand->Release();
                }
            }

            if (!pmpParent) 
            {
                const CLSID * pclsid;

                if (bMenuBand)
                    pclsid = &CLSID_MenuBandSite;
                else
                    pclsid = &CLSID_RebarBandSite;

                CoCreateInstance(*pclsid, NULL, CLSCTX_INPROC_SERVER, IID_IBandSite, (LPVOID*)&pbs);

                if (pbs) 
                {

                    if (bMenuBand)
                    {
                        BANDSITEINFO bsinfo;

                        // Don't show the gripper for vertical menubands
                        bsinfo.dwMask = BSIM_STYLE;
                        bsinfo.dwStyle = BSIS_NOGRIPPER | BSIS_NODROPTARGET;
                        pbs->SetBandSiteInfo(&bsinfo);
                    }

                    CMenuDeskBar *pcmdb = new CMenuDeskBar();
                    if (pcmdb)
                    {
                        if (SUCCEEDED(pcmdb->SetClient(pbs))) 
                            pcmdb->QueryInterface(IID_IMenuPopup, (LPVOID *)&pmp);

                        pcmdb->Release();
                    }
                }
            }

            if (pbs) 
            {
                pbs->AddBand(pdb);
            }
        }
    }
    
    ATOMICRELEASE(pdb);
    ATOMICRELEASE(pbs);
    if (!pmp)
        IUnknown_Set((IUnknown**) &pmp, pmpParent);
    

    return pmp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\menuisf.cpp ===
#include "priv.h"
#include "sccls.h"
#include "iface.h"
#include "resource.h"
#include "caggunk.h"
#include "menuisf.h"
#include "menubar.h"
#include "menuband.h"
#include "iaccess.h"
#include "apithk.h"

//=================================================================
// Implementation of CMenuAgent
//
//  The single global object of this class (g_menuagent) is the
//  manager of the message filter proc used to track mouse and
//  keyboard messages on behalf of CTrackPopupBar while a menu is
//  in a modal menu loop in TrackPopupMenu.
//
//  We track these messages so we can pop out of the menu, behaving
//  as if the visual menu bar consisted of a homogeneous menu
//  object.
//
//=================================================================

extern "C" void DumpMsg(LPCTSTR pszLabel, MSG * pmsg);

struct CMenuAgent
{
public:
    HHOOK       _hhookMsg;
    HWND        _hwndSite;          // hwnd to receive forwarded messages
    HWND        _hwndParent;
    CTrackPopupBar * _ptpbar;
    IMenuPopup * _pmpParent;
    void*       _pvContext;
    HANDLE      _hEvent;

    BITBOOL     _fEscHit: 1;

    // we need to keep track of whether the last selected
    // menu item was on a popup or not.  we can do this by storing the 
    // last WM_MENUSELECT flags
    UINT        _uFlagsLastSelected; 
    HMENU       _hmenuLastSelected;
    POINT       _ptLastMove;

    void    Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, HWND hwndParent, HWND hwndSite);
    void    Reset(void* pvContext);
    void    CancelMenu(void* pvContext);

    static LRESULT CALLBACK MsgHook(int nCode, WPARAM wParam, LPARAM lParam);

//private:
    void _OnMenuSelect(HMENU hmenu, int i, UINT uFlags);
    BOOL _OnKey(WPARAM vkey);
};

// Just one of these, b/c we only need one message filter
CMenuAgent g_menuagent = { 0 };     


/*----------------------------------------------------------
Purpose: Initialize the message filter hook

*/
void CMenuAgent::Init(void* pvContext, CTrackPopupBar * ptpbar, IMenuPopup * pmpParent, 
                      HWND hwndParent, HWND hwndSite)
{
    TraceMsg(TF_MENUBAND, "Initialize CMenuAgent");

    ASSERT(IS_VALID_READ_PTR(ptpbar, CTrackPopupBar));
    ASSERT(IS_VALID_CODE_PTR(pmpParent, IMenuPopup));
    ASSERT(IS_VALID_HANDLE(hwndSite, WND));

    if (_pvContext != pvContext)
    {
        // When switching contexts, we need to collapse the old menu. This keeps us from
        // hosing the menubands when switching from one browser to another.
        CancelMenu(_pvContext);
        ATOMICRELEASE(_ptpbar);
        ATOMICRELEASE(_pmpParent);
        _pvContext = pvContext;
    }

    pmpParent->SetSubMenu(ptpbar, TRUE);

    _hwndSite = hwndSite;
    _hwndParent = hwndParent;

    // Since the message hook wants to forward messages to the toolbar,
    // we need to ask the pager control to do this
    Pager_ForwardMouse(_hwndSite, TRUE);

    _pmpParent = pmpParent;
    _pmpParent->AddRef();

    _ptpbar = ptpbar;
    _ptpbar->AddRef();

    // HACKHACKHACKHACKHACK (lamadio)
    // On Windows 9x kernel can't handle the reentrancy problem where you have two hooks
    // in two separate processes. When one process looses focus, we collapse the Menu.
    // After that we remove our hook. Problem is: Between the Loosing focus and
    // removing the hook, the other IE process popped up a menu and installed a hook
    // the two hooks mutilate each other.
    if (IsOS(OS_WINDOWS))
    {
        ASSERT(_hEvent == NULL);
        
        _hEvent = OpenEventA(EVENT_ALL_ACCESS, FALSE, "Shell.MenuAgent");

        if (!_hEvent)   //event routines return NULL on failure.
            // Don't need to use SHGetAllAccessSA since this
            // is Win9x-only code anyway
            _hEvent = CreateEventA(NULL, TRUE, TRUE, "Shell.MenuAgent");

        if (_hEvent)
            WaitForSingleObject(_hEvent, INFINITE);
    }

    if (NULL == _hhookMsg)
    {
        if (_hEvent)
            ResetEvent(_hEvent);
        _hhookMsg = SetWindowsHookEx(WH_MSGFILTER, MsgHook, HINST_THISDLL, 0);
        if (!_hhookMsg && _hEvent)
        {
            SetEvent(_hEvent);
            CloseHandle(_hEvent);
            _hEvent = NULL;
        }
    }

    _fEscHit = FALSE;

    GetCursorPos(&_ptLastMove);
}    


/*----------------------------------------------------------
Purpose: Reset the menu agent; no longer track mouse and keyboard
         messages.  The menuband calls this when it exits menu mode.

*/
void CMenuAgent::Reset(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        _pmpParent->SetSubMenu(_ptpbar, FALSE);

        // The only time to not send MPOS_FULLCANCEL is if the escape
        // key caused the menu to terminate.

        if ( !_fEscHit )
            _pmpParent->OnSelect(MPOS_FULLCANCEL);

        // Eat any mouse-down/up sequence left in the queue.  This is how 
        // we keep the toolbar from getting a mouse-down if the user 
        // clicks on the same menuitem as what is currently popped down.
        // (E.g., click File, then click File again.  W/o this, the menu
        // would never toggle up.)

        MSG msg;

        while (PeekMessage(&msg, _hwndSite, WM_LBUTTONDOWN, WM_LBUTTONUP, PM_REMOVE))
            ;   // Do nothing

        Pager_ForwardMouse(_hwndSite, FALSE);

        _hwndSite = NULL;
        _hwndParent = NULL;

        ATOMICRELEASE(_pmpParent);
        ATOMICRELEASE(_ptpbar);

        if (_hhookMsg)
        {
            TraceMsg(TF_MENUBAND, "CMenuAgent: Hook removed");

            UnhookWindowsHookEx(_hhookMsg);
            _hhookMsg = NULL;

            if (_hEvent)
            {
                SetEvent(_hEvent);
                CloseHandle(_hEvent);
                _hEvent = NULL;
            }
        }

        _pvContext = NULL;
    }
}    


/*----------------------------------------------------------
Purpose: Make the menu go away

*/
void CMenuAgent::CancelMenu(void* pvContext)
{
    if (_pvContext == pvContext)
    {
        if (_hwndParent)
        {
            ASSERT(IS_VALID_HANDLE(_hwndParent, WND));

            TraceMsg(TF_MENUBAND, "Sending cancel mode to menu");

            // Use PostMessage so USER32 doesn't RIP on us in 
            // MsgHook when it returns from the WM_MOUSEMOVE
            // that triggered this code path in the first place.

            PostMessage(_hwndParent, WM_CANCELMODE, 0, 0);

            // Disguise this as if the escape key was hit,
            // since this is called when the mouse hovers over
            // another menu sibling.
            _fEscHit = TRUE;

            _pmpParent->SetSubMenu(_ptpbar, FALSE);
        }
    }
}    

// store away the identity of the selected menu item.
// if uFlags & MF_POPUP then i is the index.
// otherwise it's the command and we need to convert it to the index.
// we store index always because some popups don't have ids

void CMenuAgent::_OnMenuSelect(HMENU hmenu, int i, UINT uFlags)
{
    _uFlagsLastSelected = uFlags;
    _hmenuLastSelected = hmenu;
}

BOOL CMenuAgent::_OnKey(WPARAM vkey)
{
    //
    // If the menu window is RTL mirrored, then the arrow keys should
    // be mirrored to reflect proper cursor movement. [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(_hwndSite))
    {
        switch (vkey)
        {
        case VK_LEFT:
          vkey = VK_RIGHT;
          break;

        case VK_RIGHT:
          vkey = VK_LEFT;
          break;
        }
    }

    switch (vkey)
    {
    case VK_RIGHT:
        if (!_hmenuLastSelected || !(_uFlagsLastSelected & MF_POPUP) || (_uFlagsLastSelected & MF_DISABLED) ) 
        {
            // if the currently selected item does not have a cascade, then 
            // we need to cancel out of all of this and tell the top menu bar to go right
            _pmpParent->OnSelect(MPOS_SELECTRIGHT);
        }
        break;
        
    case VK_LEFT:
        if (!_hmenuLastSelected || _hmenuLastSelected == _ptpbar->GetPopupMenu()) {
            // if the currently selected menu item is in our top level menu,
            // then we need to cancel out of all this menu loop and tell the top menu bar
            // to go left 
            _pmpParent->OnSelect(MPOS_SELECTLEFT);
        }
        break;
        
    default:
        return FALSE;
        
    }
    
    return TRUE;
}


/*----------------------------------------------------------
Purpose: Message hook used to track keyboard and mouse messages
         while in a TrackPopupMenu modal loop.

*/
LRESULT CMenuAgent::MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRet = 0;
    MSG * pmsg = (MSG *)lParam;

    switch (nCode)
    {
    case MSGF_MENU:
#ifdef DEBUG
        if (IsFlagSet(g_dwDumpFlags, DF_MSGHOOK))
            DumpMsg(TEXT("MsgHook"), pmsg);
#endif

        switch (pmsg->message)
        {
        case WM_MENUSELECT:
            // keep track of the items as the are selected.
            g_menuagent._OnMenuSelect(GET_WM_MENUSELECT_HMENU(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_CMD(pmsg->wParam, pmsg->lParam),
                                      GET_WM_MENUSELECT_FLAGS(pmsg->wParam, pmsg->lParam));
            break;
            
        case WM_LBUTTONDOWN:
        case WM_RBUTTONDOWN:
            // Since we've received this msg, any previous escapes
            // (like escaping out of a cascaded menu) should be cleared
            // to prevent a false reason for termination.
            g_menuagent._fEscHit = FALSE;
            break;

        case WM_KEYDOWN:
            if (g_menuagent._OnKey(pmsg->wParam))
                break;
            
        case WM_SYSKEYDOWN:
            g_menuagent._fEscHit = (VK_ESCAPE == pmsg->wParam);
            break;

        case WM_MOUSEMOVE:
            // HACKHACK (isn't all of this a hack?): ignore zero-move
            // mouse moves, so the mouse does not contend with the keyboard.

            POINT pt;
            
            // In screen coords....
            pt.x = GET_X_LPARAM(pmsg->lParam);
            pt.y = GET_Y_LPARAM(pmsg->lParam);

            if (g_menuagent._ptLastMove.x == pt.x && 
                g_menuagent._ptLastMove.y == pt.y)
            {
                TraceMsg(TF_MENUBAND, "CMenuAgent: skipping dup mousemove");
                break;
            }
            g_menuagent._ptLastMove = pt;

            // Since we got a WM_MOUSEMOVE, we need to tell the Menuband global message hook.
            // We need to do this because this message hook steels all of the messages, and
            // the Menuband message hook never updates it's internal cache for removing duplicate
            // WM_MOUSEMOVE messages which cause problems as outlined in CMsgFilter::_HandleMouseMessages
            GetMessageFilter()->AcquireMouseLocation();

            // Forward the mouse moves to the toolbar so the toolbar still
            // has a chance to hot track.  Must convert the points to the 
            // toolbar's client space.
            
            ScreenToClient(g_menuagent._hwndSite, &pt);

            SendMessage(g_menuagent._hwndSite, pmsg->message, pmsg->wParam, 
                        MAKELPARAM(pt.x, pt.y));
            break;
        }
        break;

    default:
        if (0 > nCode)
            return CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);
        break;
    }

    // Pass it on to the next hook in the chain
    if (0 == lRet)
        lRet = CallNextHookEx(g_menuagent._hhookMsg, nCode, wParam, lParam);

    return lRet;
}    



//=================================================================
// Implementation of a menu deskbar object that uses TrackPopupMenu.
//
// This object uses traditional USER32 menus (via TrackPopupMenu)
// to implement menu behavior.  It uses the CMenuAgent object to 
// help get its work done.  Since the menu deskbar site (_punkSite) 
// sits in a modal loop while any menu is up, it needs to know when
// to quit its loop.  The child object accomplishes this by sending
// an OnSelect(MPOS_FULLCANCEL).
//
// The only time that TrackPopupMenu returns (but we don't want to
// send an MPOS_FULLCANCEL) is if it's b/c the Escape key was hit.
// This just means cancel the current level.  Returning from Popup
// is sufficient for this case.  Otherwise, all other cases of
// returning from TrackPopupMenu means we send a MPOS_FULLCANCEL.
//
// Summary:
//
//  1) User clicked outside the menu.  This is a full cancel.
//  2) User hit the Alt key.  This is a full cancel.
//  3) User hit the Esc key.  This just cancels the current level.
//     (TrackPopupMenu handles this fine.  No notification needs
//     to be sent b/c we want the top-level menu to stay in its
//     modal loop.)
//  4) User selected a menu item.  This is a full cancel.
//
//=================================================================


#undef THISCLASS
#undef SUPERCLASS
#define SUPERCLASS  CMenuDeskBar

// Constructor
CTrackPopupBar::CTrackPopupBar(void *pvContext, int id, HMENU hmenu, HWND hwnd)
{
    _hmenu = hmenu;
    _hwndParent = hwnd;
    _id = id;
    _pvContext = pvContext;
    _nMBIgnoreNextDeselect = RegisterWindowMessage(TEXT("CMBIgnoreNextDeselect"));
}

// Destructor
CTrackPopupBar::~CTrackPopupBar()
{
    SetSite(NULL);
}


STDMETHODIMP_(ULONG) CTrackPopupBar::AddRef()
{
    return SUPERCLASS::AddRef();
}

STDMETHODIMP_(ULONG) CTrackPopupBar::Release()
{
    return SUPERCLASS::Release();
}

STDMETHODIMP CTrackPopupBar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CTrackPopupBar, IMenuPopup),
        QITABENT(CTrackPopupBar, IObjectWithSite),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
    {
        hres = SUPERCLASS::QueryInterface(riid, ppvObj);
    }

    return hres;
}

/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CTrackPopupBar::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    if (IsEqualGUID(guidService, SID_SMenuBandChild)) 
    {
        if (IsEqualIID(riid, IID_IAccessible))
        {
            HRESULT hres = E_OUTOFMEMORY;
            CAccessible* pacc = new CAccessible(_hmenu, _id);

            if (pacc)
            {
                hres = pacc->InitAcc();
                if (SUCCEEDED(hres))
                {
                    hres = pacc->QueryInterface(riid, ppvObj);
                }
                pacc->Release();
            }

            return hres;
        }
        else
            return QueryInterface(riid, ppvObj);
    }
    else
        return SUPERCLASS::QueryService(guidService, riid, ppvObj);
}

/*----------------------------------------------------------
Purpose: IMenuPopup::OnSelect method

         This allows the parent menubar to tell us when to
         bail out of the TrackPopupMenu
*/
STDMETHODIMP CTrackPopupBar::OnSelect(DWORD dwType)
{
    switch (dwType)
    {
    case MPOS_CANCELLEVEL:
    case MPOS_FULLCANCEL:
        g_menuagent.CancelMenu(_pvContext);
        break;

    default:
        TraceMsg(TF_WARNING, "CTrackPopupBar doesn't handle this MPOS_ value: %d", dwType);
        break;
    }
    return S_OK;    
}    


/*----------------------------------------------------------
Purpose: IMenuPopup::SetSubMenu method

*/
STDMETHODIMP CTrackPopupBar::SetSubMenu(IMenuPopup * pmp, BOOL bSet)
{
    return E_NOTIMPL;
}    

// HACKHACK: DO NOT TOUCH! This is the only way to select
// the first item for a user menu. TrackMenuPopup by default does
// not select the first item. We pump these messages to our window. 
// User snags these messages, and thinks the user pressed the down button
// and selects the first item for us. The lParam is needed because Win95 gold
// validated this message before using it. Another solution would be to listen
// to WM_INITMENUPOPUP and look for the HWND of the menu. Then send that 
// window the private message MN_SELECTFIRSTVALIDITEM. But thats nasty compared 
// to this. - lamadio 1.5.99
void CTrackPopupBar::SelectFirstItem()
{
    HWND hwndFocus = GetFocus();
    // pulled the funny lparam numbers out of spy's butt.
    if (hwndFocus) {
        PostMessage(hwndFocus, WM_KEYDOWN, VK_DOWN, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_DOWN, 0xD1500001);
#ifdef UNIX
        /* HACK HACK
         * The above PostMessages were causing the second menu item
         * to be selected if you access the menu from the keyboard.
         * The following PostMessages will nullify the above effect.
         * This is to make sure that menus in shdocvw work properly
         * with user32 menus.
         */
        PostMessage(hwndFocus, WM_KEYDOWN, VK_UP, 0x11500001);
        PostMessage(hwndFocus, WM_KEYUP, VK_UP, 0xD1500001);
#endif /* UNIX */
    }
}
           
DWORD GetBuildNumber()
{
    OSVERSIONINFO osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    if (GetVersionEx(&osvi))
        return osvi.dwBuildNumber;
    else
        return 0;
}

/*----------------------------------------------------------
Purpose: IMenuPopup::Popup method

         Invoke the menu.
*/
STDMETHODIMP CTrackPopupBar::Popup(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags)
{
    static dwBuildNumber = GetBuildNumber();
    ASSERT(IS_VALID_READ_PTR(ppt, POINTL));
    ASSERT(NULL == prcExclude || IS_VALID_READ_PTR(prcExclude, RECTL));
    ASSERT(IS_VALID_CODE_PTR(_pmpParent, IMenuPopup));

    // We must be able to talk to the parent menu bar 
    if (NULL == _pmpParent)
        return E_FAIL;

    ASSERT(IS_VALID_HANDLE(_hmenu, MENU));
    ASSERT(IS_VALID_CODE_PTR(_punkSite, IUnknown));
    
    HMENU hmenu = GetSubMenu(_hmenu, _id);
    HWND hwnd;
    TPMPARAMS tpm;
    TPMPARAMS * ptpm = NULL;

    // User32 does not want to fix this for compatibility reasons,
    // but TrackPopupMenu does not snap to the nearest monitor on Single and Multi-Mon
    // systems. This has the side effect that if we pass a non-visible coordinate, then
    // User places menu at a random location on screen. So instead, we're going to bias
    // the point to the monitor.

    MONITORINFO mi = {0};
    mi.cbSize = sizeof(mi);

    HMONITOR hMonitor = MonitorFromPoint(*((POINT*)ppt), MONITOR_DEFAULTTONEAREST);
    GetMonitorInfo(hMonitor, &mi);

    if (ppt->x >= mi.rcMonitor.right)
        ppt->x = mi.rcMonitor.right;

    if (ppt->y >= mi.rcMonitor.bottom)
        ppt->y = mi.rcMonitor.bottom;

    if (ppt->x <= mi.rcMonitor.left)
        ppt->x = mi.rcMonitor.left;

    if (ppt->y <= mi.rcMonitor.top)
        ppt->y = mi.rcMonitor.top;


    if (prcExclude)
    {
        tpm.cbSize = SIZEOF(tpm);
        tpm.rcExclude = *((LPRECT)prcExclude);
        ptpm = &tpm;
    }

    // The forwarding code in CShellBrowser::_ShouldForwardMenu
    // and CDocObjectHost::_ShouldForwardMenu expects the first
    // WM_MENUSELECT to be sent for the top-level menu item.
    // 
    // We need to fake an initial menu select on the top menu band
    // to mimic USER and satisfy this expectation.
    //
    UINT uMSFlags = MF_POPUP;
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(_id, uMSFlags), (LPARAM)_hmenu);
    
    SendMessage(_hwndParent, _nMBIgnoreNextDeselect, NULL, NULL);

    // Initialize the menu agent
    IUnknown_GetWindow(_punkSite, &hwnd);
    
    VARIANTARG v = {0};
    UINT uFlags = TPM_VERTICAL | TPM_TOPALIGN;
    UINT uAnimateFlags = 0;
    if (SUCCEEDED(IUnknown_Exec(_punkSite, &CGID_MENUDESKBAR, MBCID_GETSIDE, 0, NULL, &v))) {
        if (v.vt == VT_I4 && 
            (v.lVal == MENUBAR_RIGHT ||
             v.lVal == MENUBAR_LEFT))
        {
            uFlags = TPM_TOPALIGN;
        }

        switch (v.lVal)
        {
        case MENUBAR_LEFT:      uAnimateFlags = TPM_HORNEGANIMATION;
            break;
        case MENUBAR_RIGHT:     uAnimateFlags = TPM_HORPOSANIMATION;
            break;
        case MENUBAR_TOP:       uAnimateFlags = TPM_VERNEGANIMATION;
            break;
        case MENUBAR_BOTTOM:    uAnimateFlags = TPM_VERPOSANIMATION;
            break;
        }
    }

    g_menuagent.Init(_pvContext, this, _pmpParent, _hwndParent, hwnd);

    ASSERT(IS_VALID_HANDLE(hmenu, MENU));
    if (dwFlags & MPPF_INITIALSELECT)
        SelectFirstItem();

    // This feature only works on build 1794 or greater.
    if (g_bRunOnNT5 && dwBuildNumber >= 1794 && dwFlags & MPPF_NOANIMATE)
        uFlags |= TPM_NOANIMATION;

#ifndef MAINWIN

    if (g_bRunOnMemphis || g_bRunOnNT5)
        uFlags |= uAnimateFlags;

    TrackPopupMenuEx(hmenu, uFlags,
                   ppt->x, ppt->y, _hwndParent, ptpm);
#else
    // Current MainWin's implementation of TrackPopupMenuEx is buggy.
    // I failed to fix it, so I replaced the call by TrackPopupMenu,
    // that provides partial functionality.
    // Hopefully, jluu will be able to fix it.
    TrackPopupMenu(hmenu, uFlags, ppt->x, ppt->y, 0, _hwndParent, 
                   &ptpm->rcExclude);
#endif

    // Tell the parent that the menu is now gone
    SendMessage(_hwndParent, WM_MENUSELECT, MAKEWPARAM(0, 0xFFFF), NULL);

    g_menuagent.Reset(_pvContext);

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\menusite.cpp ===
#include "priv.h"
#include "sccls.h"
#include "menusite.h"

CMenuSite::CMenuSite() : _cRef(1)
{
}


CMenuSite::~CMenuSite()
{
    // Make sure that SetDeskBarSite(NULL) was called
    ASSERT(_punkSite == NULL);
    ASSERT(_punkSubActive == NULL);
    ASSERT(_pweh == NULL);
    ASSERT(_pdb == NULL);
    ASSERT(_hwnd == NULL);
}


STDAPI CMenuBandSite_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    CMenuSite *pbs = new CMenuSite();
    if (pbs)
    {
        *ppunk = SAFECAST(pbs, IOleWindow*);
        return S_OK;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}


/*----------------------------------------------------------
Purpose: IUnknown::QueryInterface method

*/
STDMETHODIMP CMenuSite::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CMenuSite, IBandSite),
        QITABENT(CMenuSite, IDeskBarClient),
        QITABENT(CMenuSite, IOleCommandTarget),
        QITABENT(CMenuSite, IInputObject),
        QITABENT(CMenuSite, IInputObjectSite),
        QITABENT(CMenuSite, IWinEventHandler),
        QITABENT(CMenuSite, IServiceProvider),
        QITABENT(CMenuSite, IOleWindow),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}


/*----------------------------------------------------------
Purpose: IUnknown::AddRef method

*/
STDMETHODIMP_(ULONG) CMenuSite::AddRef(void)
{
    _cRef++;
    return _cRef;
}


/*----------------------------------------------------------
Purpose: IUnknown::Release method

*/
STDMETHODIMP_(ULONG) CMenuSite::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}


/*----------------------------------------------------------
Purpose: IServiceProvider::QueryService method

*/
STDMETHODIMP CMenuSite::QueryService(REFGUID guidService, REFIID riid, void **ppvObj)
{
    HRESULT hres = E_FAIL;

    *ppvObj = NULL;     // assume error

    if (IsEqualIID(guidService, SID_SMenuBandBottom) ||
        IsEqualIID(guidService, SID_SMenuBandBottomSelected)||
        IsEqualIID(guidService, SID_SMenuBandChild))
    {
        if (_punkSubActive)
            hres = IUnknown_QueryService(_punkSubActive, guidService, riid, ppvObj);
    }
    else
    {
        ASSERT(_punkSite);
        hres = IUnknown_QueryService(_punkSite, guidService, riid, ppvObj);
    }

    return hres;
}    


/*----------------------------------------------------------
Purpose: IOleCommandTarget::QueryStatus

*/
STDMETHODIMP CMenuSite::QueryStatus(const GUID *pguidCmdGroup,
        ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    ASSERT(_punkSite);

    return IUnknown_QueryStatus(_punkSite, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}

/*----------------------------------------------------------
Purpose: IOleCommandTarget::Exec

*/
STDMETHODIMP CMenuSite::Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    ASSERT(_punkSite);

    return IUnknown_Exec(_punkSite, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
}


/*----------------------------------------------------------
Purpose: IInputObjectSite::OnFocusChangeIS

         This function is called by the client band to negotiate
         which band in this bandsite gets the focus.  Typically
         this function will then change its focus to the given
         client band.

         CMenuSite only maintains one and only one band, which
         is set at AddBand time, so this function is a nop.

*/
STDMETHODIMP CMenuSite::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    // Return S_OK since the menu site only ever has one band.
    // No need to negotiate which other band in this bandsite 
    // might have the "activation".
    return S_OK;
}


/*----------------------------------------------------------
Purpose: IInputObject::UIActivateIO method

*/
STDMETHODIMP CMenuSite::UIActivateIO(BOOL fActivate, LPMSG lpMsg)
{
    ASSERT(NULL == lpMsg || IS_VALID_WRITE_PTR(lpMsg, MSG));

    // Forward onto the client band
    return IUnknown_UIActivateIO(_punkSubActive, fActivate, lpMsg);
}


/*----------------------------------------------------------
Purpose: IInputObject::HasFocusIO

         Since the menuband can never have true activation (from
         the browser's perspective) this always returns S_FALSE.

         See comments in CMenuBand::UIActivateIO for more details
         about this.

*/
STDMETHODIMP CMenuSite::HasFocusIO()
{
    return S_FALSE;
}


/*----------------------------------------------------------
Purpose: IInputObject::TranslateAcceleratorIO

         Menubands cannot ever have the activation, so this method 
         should never be called.
*/
STDMETHODIMP CMenuSite::TranslateAcceleratorIO(LPMSG lpMsg)
{
    AssertMsg(0, TEXT("Menuband has the activation but it shouldn't!"));

    return S_FALSE;
}


// Utility Functions

void CMenuSite::_CacheSubActiveBand(IUnknown * punk)
{
    if (SHIsSameObject(punk, _punkSubActive))
        return;
    
    IUnknown_SetSite(_punkSubActive, NULL);

    ATOMICRELEASE(_punkSubActive);
    ATOMICRELEASE(_pdb);
    ATOMICRELEASE(_pweh);
    _hwndChild = NULL;

    if (punk != NULL) 
    {
        EVAL(SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IDeskBand, &_pdb))));
        EVAL(SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IWinEventHandler, &_pweh))));

        IUnknown_SetSite(punk, SAFECAST(this, IOleWindow*));
        IUnknown_GetWindow(punk, &_hwndChild);

        _punkSubActive = punk;
        _punkSubActive->AddRef();
    }
}


/*----------------------------------------------------------
Purpose: IBandSite::AddBand

*/
STDMETHODIMP CMenuSite::AddBand(IUnknown* punk)
{
    _CacheSubActiveBand(punk);

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IBandSite::EnumBands

*/
STDMETHODIMP CMenuSite::EnumBands(UINT uBand, DWORD* pdwBandID)
{
    HRESULT hres = NOERROR;

    // The menusite only holds one band ever
    if (0 == uBand)
        *pdwBandID = 0;
    else
        hres = E_FAIL;

    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::QueryBand

*/
HRESULT CMenuSite::QueryBand(DWORD dwBandID, IDeskBand** ppstb, DWORD* pdwState, LPWSTR pszName, int cchName)
{
    HRESULT hres = E_NOINTERFACE;

    ASSERT(dwBandID == 0);
    ASSERT(IS_VALID_WRITE_PTR(ppstb, IDeskBand *));

    if (_punkSubActive && 0 == dwBandID)
    {
        hres = _punkSubActive->QueryInterface(IID_PPV_ARG(IDeskBand, ppstb));
        *pdwState = BSSF_VISIBLE; // Only band....

        if (cchName > 0)
            *pszName = L'\0';
    }
    else
        *ppstb = NULL;

    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandState

*/
HRESULT CMenuSite::SetBandState(DWORD dwBandID, DWORD dwMask, DWORD dwState)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::RemoveBand

*/
HRESULT CMenuSite::RemoveBand(DWORD dwBandID)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandObject

*/
HRESULT CMenuSite::GetBandObject(DWORD dwBandID, REFIID riid, LPVOID *ppvObj)
{
    HRESULT hres;

    ASSERT(dwBandID == 0);

    if (_punkSubActive && 0 == dwBandID)
        hres = _punkSubActive->QueryInterface(riid, ppvObj);
    else
    {
        *ppvObj = NULL;
        hres = E_NOINTERFACE;
    }
    return hres;
}


/*----------------------------------------------------------
Purpose: IBandSite::SetBandSiteInfo

*/
HRESULT CMenuSite::SetBandSiteInfo(const BANDSITEINFO * pbsinfo)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IBandSite::GetBandSiteInfo

*/
HRESULT CMenuSite::GetBandSiteInfo(BANDSITEINFO * pbsinfo)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IOleWindow::GetWindow

*/
HRESULT CMenuSite::GetWindow(HWND * lphwnd)
{
    ASSERT(IS_VALID_HANDLE(_hwnd, WND));

    *lphwnd = _hwnd;
    return NOERROR;
}

/*----------------------------------------------------------
Purpose: IOleWindow::ContextSensitiveHelp

*/
HRESULT CMenuSite::ContextSensitiveHelp(BOOL fEnterMode)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::SetDeskBarSite

*/
HRESULT CMenuSite::SetDeskBarSite(IUnknown* punkSite)
{
    if (punkSite)
    {
        ATOMICRELEASE(_punkSite);

        HWND hwnd;
        IUnknown_GetWindow(punkSite, &hwnd);

        if (hwnd)
        {
            _CreateSite(hwnd);

            _punkSite = punkSite;
            _punkSite->AddRef();
        }
    }
    else
    {
        if (_pdb)
        {
            _pdb->CloseDW(0);
        }
        _CacheSubActiveBand(NULL);      // This is asymetric by design

        if (_hwnd)
        {
            DestroyWindow(_hwnd);
            _hwnd = NULL;
        }

        ATOMICRELEASE(_punkSite);
    }

    return _hwnd ? NOERROR : E_FAIL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::SetModeDBC

*/
HRESULT CMenuSite::SetModeDBC(DWORD dwMode)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: IDeskBarClient::UIActivateDBC

*/
HRESULT CMenuSite::UIActivateDBC(DWORD dwState)
{
    HRESULT hr = S_OK;

    ASSERT(_pdb);
    if (_pdb)
        hr = _pdb->ShowDW(0 != dwState);

    return hr;
}

/*----------------------------------------------------------
Purpose: IDeskBarClient::GetSize

*/
HRESULT CMenuSite::GetSize(DWORD dwWhich, LPRECT prc)
{
    if (dwWhich == DBC_GS_IDEAL)
    {
        if (_pdb)
        {
            DESKBANDINFO dbi = {0};
            _pdb->GetBandInfo(0, 0, &dbi);
            prc->right = dbi.ptMaxSize.x;
            prc->bottom = dbi.ptMaxSize.y;
        }
    }

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent

*/
HRESULT CMenuSite::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    if (_pweh)
        return _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

    return NOERROR;
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner

*/
HRESULT CMenuSite::IsWindowOwner(HWND hwnd)
{
    if (_hwnd == hwnd || (_pweh && _pweh->IsWindowOwner(hwnd) != S_FALSE))
        return S_OK;
    else
        return S_FALSE;
}


LRESULT CMenuSite::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;

    EnterModeless();

    switch(uMsg)
    {
    case WM_SIZE:
        {
            IMenuPopup* pmp;

            if (_punkSubActive && SUCCEEDED(_punkSubActive->QueryInterface(IID_PPV_ARG(IMenuPopup, &pmp))))
            {
                RECT rc = {0};

                GetClientRect(_hwnd, &rc);

                pmp->OnPosRectChangeDB(&rc);
                pmp->Release();
            }
            lres = 1;
        }
        break;

    case WM_NOTIFY:
        hwnd = ((LPNMHDR)lParam)->hwndFrom;
        break;
        
    case WM_COMMAND:
        hwnd = GET_WM_COMMAND_HWND(wParam, lParam);
        break;
        
    default:
        ExitModeless();
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);
        break;
    }

    if (hwnd && _pweh && _pweh->IsWindowOwner(hwnd) == S_OK) 
    {
        _pweh->OnWinEvent(hwnd, uMsg, wParam, lParam, &lres);
    }

    ExitModeless();
    return lres;
}


void CMenuSite::_CreateSite(HWND hwndParent)
{
    if (_hwnd)
    {
        ASSERT(IS_VALID_HANDLE(_hwnd, WND));    // just to be safe...
        return;
    }

    WNDCLASS  wc = {0};
    wc.style            = 0;
    wc.lpfnWndProc      = s_WndProc;
    //wc.cbClsExtra       = 0;
    wc.cbWndExtra       = SIZEOF(CMenuSite*);
    wc.hInstance        = HINST_THISDLL;
    wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground    = (HBRUSH) (COLOR_MENU+1);
    //wc.lpszMenuName     =  NULL;
    wc.lpszClassName    = TEXT("MenuSite");
    //wc.hIcon            = NULL;

    SHRegisterClass(&wc);

    _hwnd = CreateWindow(TEXT("MenuSite"), NULL, WS_VISIBLE | WS_CHILD, 0, 0, 0, 0, 
        hwndParent, NULL, HINST_THISDLL, (LPVOID)SAFECAST(this, CImpWndProc*));

    ASSERT(_hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\menubar.h ===
#ifndef _menubar_h
#define _menubar_h


#ifdef __cplusplus

#include "iface.h"
#include "basebar.h"

IMenuPopup* CreateMenuPopup(IMenuPopup *pmpParent, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
IMenuPopup* CreateMenuPopup2(IMenuPopup *pmpParent, IMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, BANDINFOSFB * pbi, BOOL bMenuBand);
HRESULT FindBandInBandSite(IMenuPopup* pmpParent, IBandSite** ppbs, LPCITEMIDLIST pidl, REFIID riid, void** ppvOut);
HRESULT ShowBandInBandSite(IUnknown* punkBS, IUnknown* punkDB);


class CMenuDeskBar : 
        public CBaseBar
        ,public IMenuPopup
        ,public IObjectWithSite
        ,public IBanneredBar
        ,public IInitializeObject
{
public:    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CBaseBar::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CBaseBar::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, LPVOID* ppvObj);
    
    // *** IOleWindow methods ***
    virtual STDMETHODIMP GetWindow(HWND * lphwnd) { return CBaseBar::GetWindow(lphwnd); };
    virtual STDMETHODIMP ContextSensitiveHelp(BOOL fEnterMode) { return CBaseBar::ContextSensitiveHelp(fEnterMode); };

    // *** IDeskBar methods ***
    STDMETHODIMP SetClient(IUnknown* punk) { return CBaseBar::SetClient(punk); };
    STDMETHODIMP GetClient(IUnknown** ppunkClient) { return CBaseBar::GetClient(ppunkClient); };
    STDMETHODIMP OnPosRectChangeDB (LPRECT prc) { return CBaseBar::OnPosRectChangeDB(prc); };

    // *** IInputObjectSite methods (override) ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IMenuPopup methods ***
    virtual STDMETHODIMP Popup(POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);
    virtual STDMETHODIMP OnSelect(DWORD dwSelectType);
    virtual STDMETHODIMP SetSubMenu(IMenuPopup* pmp, BOOL fSet);

    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown * pUnkSite);
    STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
        DWORD nCmdID, DWORD nCmdexecopt,
        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);
    
    // *** IBanneredBar methods ***
    virtual STDMETHODIMP SetIconSize(DWORD iIcon);
    virtual STDMETHODIMP GetIconSize(DWORD* piIcon)
        { ASSERT(piIcon); *piIcon = _iIconSize; return NOERROR;};
    virtual STDMETHODIMP SetBitmap(HBITMAP hBitmap);
    virtual STDMETHODIMP GetBitmap(HBITMAP* phBitmap)
        { ASSERT(phBitmap); *phBitmap = _hbmp; return NOERROR;};

    // *** IInitializeObject methods ***
    // This is for Backwards compatility with Start Menu.
    STDMETHODIMP Initialize() { return NOERROR; }


    CMenuDeskBar();

    
protected:
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void _OnCreate();
    virtual void _OnSize();
    virtual DWORD _GetExStyle();
    virtual DWORD _GetClassStyle();
 
    void    _AllowMessageThrough(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void    _GetPopupWindowPosition(RECT* rcDesired, RECT* rcExclude, RECT *prcResult, SIZE * psizeEdge, UINT uside); 
    void    _PopDown();
    BOOL    _IsMyParent(HWND hwnd);  
    IMenuPopup* _GetMenuBarParent(IUnknown* punk);
    UINT    _GetSide() { return _uSide;};
    HRESULT _PositionWindow(POINTL *ppt, RECTL* prcExclude, DWORD dwFlags);
    LRESULT _DoPaint(HWND hwnd, HDC hdc, DWORD dwFlags);
    void _DoNCPaint(HWND hwnd, HDC hdc);
    void _SelectItem(BOOL bFirst);
    void AdjustForTheme();

    virtual ~CMenuDeskBar();
            
    POINT   _pt;
    IMenuPopup* _pmpParent;
    IMenuPopup* _pmpChild;
    IUnknown* _punkSite;
    UINT    _uSide;


    HBITMAP _hbmp;
    DWORD   _iIconSize;
    SIZE    _sizeBmp;
    COLORREF    _rgb;

    BITBOOL _fActive: 1;

    RECT    _rcExclude;
    BITBOOL _fExcludeRect: 1;  // TRUE: _rcExclude contains valid 
    BITBOOL _fExpanded: 1;
    BITBOOL _fFlatMenuMode: 1;
    BOOL    _fNoBorder;

    friend HRESULT CMenuDeskBar_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi);
};

HRESULT TrackShellMenu(HWND hwnd, LPRECT prc, IShellMenu* psm, DWORD dwFlags);

#endif // __cplusplus
#endif // _menubar_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\mnbandid.h ===
#define ISFBIDM_LARGE           0x0001
#define ISFBIDM_SMALL           0x0002
#define ISFBIDM_LOGOS           0x0003
#define ISFBIDM_SHOWTEXT        0x0004
#define ISFBIDM_REFRESH         0x0005
#define ISFBIDM_OPEN            0x0006

#define MENU_ISFBAND            0x102
#define MENU_MNFOLDERCONTEXT    0x10D

// mnfolder context menu commands
#define MNIDM_RESORT            0x0001
#define MNIDM_LAST              0x0001

#define IDS_QLINKS              0x3061
#define IDS_EMPTY               0x3251
#define IDS_FAVS_ADDTOFAVORITES 0x3297
#define IDS_FAVS_INVALIDFN      0x329C
#define IDS_LINKSBANDTEXT       0x3352

#define DLG_ISFBANDRENAME       0x102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\mnbase.h ===
#ifndef MNBASE
#define MNBASE


// Characters for _DrawMenuGlyph
#define CH_MENUARROWA    '8'
#define CH_MENUARROW     TEXT(CH_MENUARROWA)
#define CH_MENUCHECKA    'a'
#define CH_MENUCHEVRONA  187

class CMenuBand;    // Forward Declare
class CMenuBandMetrics;

#define LIST_GAP 8      // from Observation

class CMenuToolbarBase: public IWinEventHandler, public IObjectWithSite
{
public:

    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID riid, void ** ppvSite);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd) PURE;
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

    // Other public methods

    CMenuToolbarBase(CMenuBand* pmb, DWORD dwFlags);

    // Returns the HWND and Converts the pt to child.
    virtual void v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear) PURE;
    virtual BOOL v_TrackingSubContextMenu() PURE;
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate);
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons) PURE;
    virtual void v_UpdateButtons(BOOL fNegotiateSize) PURE;
    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** pObj) PURE;
    virtual HRESULT v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam) PURE;
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd) PURE;
    virtual HRESULT v_ExecItem(int iCmd) PURE;
    virtual DWORD v_GetFlags(int iCmd) PURE;
    virtual void v_Refresh() PURE;
    virtual void v_Close();
    virtual void v_OnEmptyToolbar();
    virtual void v_OnDeleteButton(LPVOID pData) {};
    virtual HRESULT v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags) 
        { return E_NOTIMPL; };

    virtual void NegotiateSize();
    virtual void SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags);
    virtual void GetSize(SIZE*);
    virtual void CreateToolbar(HWND hwndParent);
    virtual void SetParent(HWND hwndParent);
    virtual HRESULT GetShellFolder(LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj) {return E_FAIL;};
    virtual HRESULT GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags) { return E_FAIL; };
    virtual HRESULT SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags) { return E_FAIL;};
    virtual void Expand(BOOL fExpand) {};

    HRESULT GetSubMenu(int idCmd, GUID* pguidService, REFIID riid, void** ppvObj);

    HRESULT PositionSubmenu(int idCmd);
    void Activate(BOOL fActivate);
    void SetMenuBandMetrics(CMenuBandMetrics* pmbm);
    void PostPopup(int idCmd, BOOL bSetItem, BOOL bInitialSelect);
    void PopupClose(void);
    HRESULT PopupOpen(int nCmd);
    void PopupHelper(int idCmd, BOOL bInitialSelect);
    void KillPopupTimer();
    void SetToTop(BOOL bToTop);
    void EmptyToolbar();        // override
    DWORD GetFlags(void)          { return _dwFlags; };
    BOOL DontShowEmpty()           { return _fDontShowEmpty; };
    void DontShowEmpty(BOOL fDontShowEmpty) { _fDontShowEmpty = BOOLIFY(fDontShowEmpty); };
    BOOL GetChevronID()               { return _idCmdChevron;  };
    int GetValidHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags);
    BOOL SetHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags);
    void SetKeyboardCue();
    inline virtual BOOL ShowAmpersand() { return FALSE; }

    virtual ~CMenuToolbarBase() {};

    BOOL IsEmpty()      { return _fEmpty; };

    HWND        _hwndMB;
   
protected:
    static void s_FadeCallback(DWORD dwStep, LPVOID pvParam);

    virtual void v_CalcWidth(int* pcxMin, int* pcxMax);
    virtual int  v_GetDragOverButton() PURE;
    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch) PURE;
    virtual HRESULT v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj) PURE;
    
    // Window Proc Overrides
    LRESULT _DropDownOrExec(UINT idCmd, BOOL bKeyboard);
    LRESULT _OnCustomDraw(NMCUSTOMDRAW * pnmcd);
    void    _PaintButton(HDC hdc, int idCmd, LPRECT prc, DWORD dwMBIF);
    LRESULT _OnWrapHotItem(NMTBWRAPHOTITEM* pnmwh);
    LRESULT _OnWrapAccelerator(NMTBWRAPACCELERATOR* pnmwa);
    LRESULT _OnDupAccelerator(NMTBDUPACCELERATOR* pnmda);
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnDropDown(LPNMTOOLBAR pnmtb);
    virtual LRESULT _OnTimer( WPARAM wParam );
    virtual void _FlashChevron();
    virtual LRESULT _DefWindowProcMB(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL    _OnKey(BOOL bDown, UINT vk, UINT uFlags);
    void    _OnSelectArrow(int iDir);
    void    _FireEvent(BYTE bEvent);

    // Utility Functions
    void    _DoPopup(int idCmd, BOOL bInitialSelect);
    virtual void    _SetFontMetrics();
    virtual void    _SetToolbarState();
    void    _PressBtn(int idBtn, BOOL bDown);
    HRESULT _SetMenuBand(IShellMenu* psm);
    BOOL    _SetTimer(int nTimer);

    void    _DrawMenuArrowGlyph( HDC hdc, RECT * prc, COLORREF rgbText );
    void    _DrawMenuGlyph( HDC hdc, HFONT hFont, RECT * prc, 
                               CHAR ch, COLORREF rgbText,
                               LPSIZE psize);

    int     _CalcChevronSize();
    void    _DrawChevron(HDC hdc, LPRECT prect, BOOL fFocus, BOOL fSelected);

    BOOL    _HandleObscuredItem(int idCmd);

    CMenuBand*  _pcmb;
    DEBUG_CODE (int _cRef);     // To debug references to the sub objects.
    DWORD       _dwFlags;           // SMSET_* flags
    UINT        _uIconSizeMB;
    UINT        _nItemTimer;
    int         _idCmdChevron;     // -1 if no chevron exists
    int         _cPromotedItems;    // Number of promoted items.
    BYTE        _cFlashCount;
    int         _idCmdLastClicked;
    int         _iLastClickedTime;
    int         _idCmdDragging;        

    BITBOOL     _fHasDemotedItems: 1;
    BITBOOL     _fVerticalMB: 1;
    BITBOOL     _fTopLevel: 1;
    BITBOOL     _fEmpty : 1;
    BITBOOL     _fHasSubMenu: 1;
    BITBOOL     _fEditMode : 1;
    BITBOOL     _fClickHandled: 1;
    BITBOOL     _fProcessingWrapHotItem: 1;
    BITBOOL     _fEmptyingToolbar : 1;
    BITBOOL     _fMulticolumnMB : 1;
    BITBOOL     _fExpandTimer: 1;   // There is an expand timer.
    BITBOOL     _fIgnoreHotItemChange: 1;
    BITBOOL     _fShowMB: 1;
    BITBOOL     _fFirstTime: 1;
    BITBOOL     _fHasDrop: 1;
    BITBOOL     _fRefreshInfo: 1;
    BITBOOL     _fDontShowEmpty: 1;
    BITBOOL     _fSuppressUserMonitor: 1;
    BITBOOL     _fHorizInVerticalMB: 1;     // TRUE: Don't set EX_Vertical on the Toolbar
};


int     GetButtonCmd(HWND hwndTB, int iPos);
void*   ItemDataFromPos(HWND hwndTB, int iPos);
BOOL    SetHotItem(HWND hwnd, int iDir, int iIndex, int iCount, DWORD dwFlags);
long    GetIndexFromChild(BOOL fTop, int iIndex);

// UEM Parameters
#define UEM_TIMEOUT         0
#define UEM_HOT_ITEM        1
#define UEM_HOT_FOLDER      2

#define UEM_RESET           -1

#endif  // MNBASE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\mnbase.cpp ===
#include "priv.h"
#include "sccls.h"
#include "menuband.h"
#include "itbar.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "apithk.h"
#include "menuisf.h"
#include "iaccess.h"
#include "uemapp.h"

#ifdef UNIX
#include "unixstuff.h"
#endif

// Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"

#define DM_MISC     0               // miscellany

#define MAXUEMTIMEOUT 2000

/*----------------------------------------------------------
Purpose: Return the button command given the position.

*/
int GetButtonCmd(HWND hwnd, int iPos)
{
    ASSERT(IsWindow(hwnd));
    int nRet = -1;          // Punt on failure

    TBBUTTON tbb;
    if (ToolBar_GetButton(hwnd, iPos, &tbb))
    {
        nRet = tbb.idCommand;
    }
    return nRet;
}    



void* ItemDataFromPos(HWND hwndTB, int iPos)
{
    TBBUTTONINFO tbbi;
    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
    if (ToolBar_GetButtonInfo(hwndTB, iPos, &tbbi) >= 0)
    {
        return (void*)tbbi.lParam;
    }

    return NULL;
}

long GetIndexFromChild(BOOL fTop, int iIndex)
{
    return  (fTop? TOOLBAR_MASK: 0) | iIndex + 1;
}

//--------------------------------------------------------------------------------
//
// CMenuToolbarBase
//
//--------------------------------------------------------------------------------

CMenuToolbarBase::CMenuToolbarBase(CMenuBand* pmb, DWORD dwFlags) : _pcmb(pmb)
{
#ifdef DEBUG
    _cRef = 1;
#endif
    _dwFlags = dwFlags;
    _nItemTimer = -1;
    _idCmdChevron = -1;
    _fFirstTime = TRUE;
}

// *** IObjectWithSite methods ***

HRESULT CMenuToolbarBase::SetSite(IUnknown *punkSite)
{
    ASSERT(punkSite && IS_VALID_READ_PTR(punkSite, CMenuBand*));

    // We are guaranteed the lifetime of this object is contained within
    // the menuband, so we don't addref pcmb.
    if (SUCCEEDED(punkSite->QueryInterface(CLSID_MenuBand, (LPVOID*)&_pcmb))) {
        punkSite->Release();
    } else {
        ASSERT(0);
    }

    

    _fVerticalMB = !BOOLIFY(_pcmb->_dwFlags & SMINIT_HORIZONTAL);
    _fTopLevel = BOOLIFY(_pcmb->_dwFlags & SMINIT_TOPLEVEL);
    
    return S_OK;
}

HRESULT CMenuToolbarBase::GetSite(REFIID riid, void ** ppvSite)
{
    if (!_pcmb)
        return E_FAIL;

    return _pcmb->QueryInterface(riid, ppvSite);
}

// *** IUnknown methods ***

STDMETHODIMP_(ULONG) CMenuToolbarBase::AddRef()
{
    DEBUG_CODE(_cRef++);
    if (_pcmb)
    {
        return _pcmb->AddRef();
    }

    return 0;
}


STDMETHODIMP_(ULONG) CMenuToolbarBase::Release()
{
    ASSERT(_cRef > 0);
    DEBUG_CODE(_cRef--);

    if (_pcmb)
    {
        return _pcmb->Release();
    }

    return 0;
}

HRESULT CMenuToolbarBase::QueryInterface(REFIID riid, void** ppvObj)
{
    HRESULT hres;
    if (IsEqualGUID(riid, CLSID_MenuToolbarBase) && ppvObj) 
    {
        AddRef();
        *ppvObj = (LPVOID)this;
        hres = S_OK;
    }
    else
        hres = _pcmb->QueryInterface(riid, ppvObj);

    return hres;
}

void CMenuToolbarBase::SetToTop(BOOL bToTop)
{
    // A menu toolbar can be at the top or the bottom of the menu.
    // This is an exclusive attribute.
    if (bToTop)
    {
        _dwFlags |= SMSET_TOP;
        _dwFlags &= ~SMSET_BOTTOM;
    }
    else
    {
        _dwFlags |= SMSET_BOTTOM;
        _dwFlags &= ~SMSET_TOP;
    }
}


void CMenuToolbarBase::KillPopupTimer()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Killing Popout Timer...", this);
    KillTimer(_hwndMB, MBTIMER_POPOUT);
    _nItemTimer = -1;
}


void CMenuToolbarBase::SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags)
{
    if (_hwndMB)
    {
        ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
        DWORD rectWidth = RECTWIDTH(*prc);
        TraceMsg(TF_MENUBAND, "CMTB::SetWindowPos %d - (%d,%d,%d,%d)", psize?psize->cx:0,
            prc->left, prc->top, prc->right, prc->bottom);
        ::SetWindowPos(_hwndMB, NULL, prc->left, prc->top, 
            rectWidth, RECTHEIGHT(*prc), SWP_NOZORDER | SWP_NOACTIVATE | dwFlags);
        // hackhack:  we only do this when multicolumn.  this call is to facilitate the size negotiation between 
        // static menu and folder menu.  Set the width of the toolbar to the width of the button in case 
        // of non-multicolumn.
        if (!(_fMulticolumnMB) && psize)
            ToolBar_SetButtonWidth(_hwndMB, psize->cx, psize->cx);

        // Force this to redraw. I put this here because the HMenu portion was painting after the shell
        // folder portion was done enumerating the folder, which is pretty slow. I wanted the HMENU portion
        // to paint right away...
        RedrawWindow(_hwndMB, NULL, NULL, RDW_UPDATENOW);
    }
}

// NOTE: if psize is (0,0) we use tb button size as param in figuring out ideal tb size
//   else we use max of psize length and tb button length as our metric
void CMenuToolbarBase::GetSize(SIZE* psize)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    if (EVAL(_hwndMB))
    {
        LRESULT lButtonSize;

        lButtonSize = SendMessage(_hwndMB, TB_GETBUTTONSIZE, 0, 0);
        if (psize->cx || psize->cy) 
        {
            int cx = max(psize->cx, LOWORD(lButtonSize));
            int cy = max(psize->cy, HIWORD(lButtonSize));
            lButtonSize = MAKELONG(cx, cy);
        }

        if (_fVerticalMB)
        {
            psize->cx = LOWORD(lButtonSize);
            SendMessage(_hwndMB, TB_GETIDEALSIZE, TRUE, (LPARAM)psize);
        }
        else
        {
            psize->cy = HIWORD(lButtonSize);
            SendMessage(_hwndMB, TB_GETIDEALSIZE, FALSE, (LPARAM)psize);
        }

        TraceMsg(TF_MENUBAND, "CMTB::GetSize (%d, %d)", psize->cx, psize->cy);
    }
}


/*----------------------------------------------------------
Purpose: Timer handler.  Used to pop open/close cascaded submenus.

*/
LRESULT CMenuToolbarBase::_OnTimer(WPARAM wParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    switch (wParam) 
    {

    case MBTIMER_INFOTIP:
        {
            // Do we have a hot item to display the tooltip for?
            int iHotItem = ToolBar_GetHotItem(_hwndMB);
            KillTimer(_hwndMB, wParam);
            if (iHotItem >= 0)
            {
                // Yep.
                TCHAR szTip[MAX_PATH];
                int idCmd = GetButtonCmd(_hwndMB, iHotItem);

                // Ask the superclass for the tip
                if (S_OK == v_GetInfoTip(idCmd, szTip, ARRAYSIZE(szTip)))
                {
                    // Now display it. Yawn.
                    _pcmb->_pmbState->CenterOnButton(_hwndMB, FALSE, idCmd, NULL, szTip);
                }
            }
        }
        break;

    case MBTIMER_CHEVRONTIP:
        KillTimer(_hwndMB, wParam);
       _pcmb->_pmbState->HideTooltip(TRUE);
       break;
 
    case MBTIMER_FLASH:
        {
            _cFlashCount++;
            if (_cFlashCount == COUNT_ENDFLASH)
            {
                _cFlashCount = 0;
                KillTimer(_hwndMB, wParam);
                ToolBar_MarkButton(_hwndMB, _idCmdChevron, FALSE);
                _SetTimer(MBTIMER_UEMTIMEOUT);

                // Now that we've flashed, let's show the Chevron tip.
                // This is for a confused user: If they've hovered over an item for too long,
                // or this is the first time they've seen intellimenus, then we flash and display
                // the tooltip. We only want to display this if we are shown: We would end up with
                // and dangling tooltip if you happen to move to another menu while it was flashing.
                // Ummm, is the Chevron still visible?
                if (_fShowMB && _idCmdChevron != -1)
                {
                    TCHAR szTip[MAX_PATH];
                    TCHAR szTitle[MAX_PATH];
                    if (S_OK == v_CallCBItem(_idCmdChevron, SMC_CHEVRONGETTIP, (WPARAM)szTitle, (LPARAM)szTip))
                    {
                        _pcmb->_pmbState->CenterOnButton(_hwndMB, TRUE, _idCmdChevron, szTitle, szTip);
                        _SetTimer(MBTIMER_CHEVRONTIP);
                    }
                }
            }
            else
                ToolBar_MarkButton(_hwndMB, _idCmdChevron, (_cFlashCount % 2) == 0);
        }
        break;

    case MBTIMER_UEMTIMEOUT:
        {
            POINT pt;
            RECT rect;

            // Don't fire timeouts when we're in edit mode.
            if (_fEditMode)
            {
                KillTimer(_hwndMB, wParam);
                break;
            }

            GetWindowRect(_hwndMB, &rect);
            GetCursorPos(&pt);
            if (PtInRect(&rect, pt))
            {
                TraceMsg(TF_MENUBAND, "*** UEM TimeOut. At Tick Count (%d) ***", GetTickCount());
                _FireEvent(UEM_TIMEOUT);
            }
            else
            {
                TraceMsg(TF_MENUBAND, " *** UEM TimeOut. At Tick Count (%d)."
                    " Mouse outside menu. Killing *** ", GetTickCount());
                KillTimer(_hwndMB, wParam);
            }
        }
        break;


    case MBTIMER_EXPAND:
        KillTimer(_hwndMB, wParam);
        if (_fShowMB)
        {
            v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
            Expand(TRUE);
            _fClickHandled = TRUE;
            _SetTimer(MBTIMER_CLICKUNHANDLE); 
        }
        break;

    case MBTIMER_DRAGPOPDOWN:
        // There has not been a drag enter in this band for a while, 
        // so we'll try to cancel the menus.
        KillTimer(_hwndMB, wParam);
        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBDragCancel, 0, 0);
        break;

    case MBTIMER_DRAGOVER:
        {
            TraceMsg(TF_MENUBAND, "CMenuToolbarBase::OnTimer(DRAG)");
            KillTimer(_hwndMB, wParam);
            DAD_ShowDragImage(FALSE);
            // Does this item cascade?
            int idBtn = GetButtonCmd(_hwndMB, v_GetDragOverButton());
            if (v_GetFlags(idBtn) & SMIF_SUBMENU)
            {
                TraceMsg(TF_MENUBAND, "CMenuToolbarBase::OnTimer(DRAG): Is a submenu");
                // Yes; pop it open
                if (!_fVerticalMB)
                    _pcmb->_fInvokedByDrag = TRUE;
                _DoPopup(idBtn, FALSE);
            }
            else if (idBtn == _idCmdChevron)
            {
                Expand(TRUE);

            }
            else
            {
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
            }
        }
        break;

    case MBTIMER_POPOUT:
        {
            int nItemTimer = _nItemTimer;
            KillPopupTimer();

            // Popup a new submenu?
            if (-1 != nItemTimer)
            {
                if (nItemTimer != _pcmb->_nItemCur)
                {
                    // Yes;  post message since the currently expanded submenu
                    // may be a CTrackPopup object, which posts its cancel mode.

                    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Timer went off.  Expanding...", this);
                    PostPopup(nItemTimer, FALSE, FALSE);
                }
            }
            else 
            {
                // No; just collapse the currently open submenu
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnTimer sending MPOS_CANCELLEVEL to submenu popup", this);
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
            }
            break;
        }
    
    case MBTIMER_CLOSE:
        KillTimer(_hwndMB, wParam);

        TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnTimer sending MPOS_FULLCANCEL", this);

        if (_fVerticalMB)
            _pcmb->_SiteOnSelect(MPOS_FULLCANCEL);
        else
        {
            _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
        }
        break;
    }
        
    return 1;
}


void CMenuToolbarBase::_DrawMenuArrowGlyph( HDC hdc, RECT * prc, COLORREF rgbText )
{
    SIZE size = {_pcmb->_pmbm->_cxArrow, _pcmb->_pmbm->_cyArrow};

    //
    // If the DC is mirrred, then the Arrow should be mirrored
    // since it is done thru TextOut, NOT the 2D graphics APIs [samera]
    //

    _DrawMenuGlyph(hdc, 
                   _pcmb->_pmbm->_hFontArrow,
                   prc, 
                   (IS_DC_RTL_MIRRORED(hdc)) ? CH_MENUARROWRTLA :
                   CH_MENUARROWA, 
                   rgbText, 
                   &size);
}


void CMenuToolbarBase::_DrawMenuGlyph( HDC hdc, HFONT hFont, RECT * prc, 
                               CHAR ch, COLORREF rgbText,
                               LPSIZE psize)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_pcmb->_pmbm->_hFontArrow)
    {
        SIZE    size;
        int cx, cy, y, x;
        HFONT hFontOld;
        int iOldBk = SetBkMode(hdc, TRANSPARENT);
        hFontOld = (HFONT)SelectObject(hdc, hFont);
        if (psize == NULL)
        {
            GetTextExtentPoint32A( hdc, &ch, 1, &size);
            psize = &size;
        }

        cy = prc->bottom - prc->top;
        y = prc->top  + ((cy - psize->cy) / 2);

        cx = prc->right - prc->left;
        x = prc->left + ((cx - psize->cx) /2);
    
        COLORREF rgbOld = SetTextColor(hdc, rgbText);

#ifndef UNIX
        TextOutA(hdc, x, y, &ch, 1);
#else
        // Paint motif look arrow.
        PaintUnixMenuArrow( hdc, prc, (DWORD)rgbText );
#endif
    
        SetTextColor(hdc, rgbOld);
        SetBkMode(hdc, iOldBk);
        SelectObject(hdc, hFontOld);
    }
}

void CMenuToolbarBase::SetMenuBandMetrics(CMenuBandMetrics* pmbm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // This can be called before the toolbar is created. 
    // So we'll check this condition. When the toolbar is created, then
    // the toolbar will get the metrics at that point.
    if (!_hwndMB)
        return;

    //Loop through toolbar.
    for (int iButton = ToolBar_ButtonCount(_hwndMB)-1; iButton >= 0; iButton--)
    {
        IOleCommandTarget* poct;

        int idCmd = GetButtonCmd(_hwndMB, iButton);

        // If it's not a seperator, see if there is a sub menu.
        if (idCmd != -1 &&
            SUCCEEDED(v_GetSubMenu(idCmd, NULL, IID_IOleCommandTarget, (void**)&poct)))
        {
            VARIANT Var;
            Var.vt = VT_UNKNOWN;
            Var.punkVal = SAFECAST(pmbm, IUnknown*);

            // Exec to set new Metrics.
            poct->Exec(&CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);
            poct->Release();
        }
    }

    _SetFontMetrics();
    // return
}

void CMenuToolbarBase::_SetFontMetrics()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_hwndMB && _pcmb->_pmbm)
    {
        SendMessage(_hwndMB, WM_SETFONT, (WPARAM)_pcmb->_pmbm->_hFontMenu, FALSE);
    }
}


void CMenuToolbarBase::CreateToolbar(HWND hwndParent)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT( _hwndMB != NULL );
    DWORD dwToolBarStyle = TBSTYLE_TRANSPARENT;

    // if we're set up as a popup, don't do any transparent stuff
    if (_fVerticalMB) 
    {
        dwToolBarStyle  = TBSTYLE_CUSTOMERASE;    // Vertical Toolbars don't get Transparent
        DWORD dwExtendedStyle = 0;

        // This is for TBMenu which actually has a Horizontal menubar within the 
        // Vertical menuband.
        if (!_fHorizInVerticalMB)
            dwExtendedStyle |= TBSTYLE_EX_VERTICAL;

        if (_fMulticolumnMB)
            dwExtendedStyle |= TBSTYLE_EX_MULTICOLUMN;

        ToolBar_SetExtendedStyle(_hwndMB, 
            dwExtendedStyle, TBSTYLE_EX_VERTICAL | TBSTYLE_EX_MULTICOLUMN);

        ToolBar_SetListGap(_hwndMB, LIST_GAP);
    }

    SHSetWindowBits(_hwndMB, GWL_STYLE, 
        TBSTYLE_TRANSPARENT | TBSTYLE_CUSTOMERASE, dwToolBarStyle );

    ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));

    v_UpdateIconSize(_pcmb->_uIconSize, FALSE);
    _SetFontMetrics();
}


HRESULT CMenuToolbarBase::_SetMenuBand(IShellMenu* psm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = E_FAIL;
    IBandSite* pmbs = NULL;
    if (!_pcmb->_pmpSubMenu)
    {
        hres = CoCreateInstance(CLSID_MenuDeskBar, NULL, CLSCTX_INPROC_SERVER, IID_IMenuPopup, (void**)&_pcmb->_pmpSubMenu);
        if (SUCCEEDED(hres))
        {
            IUnknown_SetSite(_pcmb->_pmpSubMenu, SAFECAST(_pcmb, IOleCommandTarget*));
            hres = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_IBandSite, (void**)&pmbs);
            if (SUCCEEDED(hres))
            {
                hres = _pcmb->_pmpSubMenu->SetClient(pmbs);
                // Don't release pmbs here. We are using below
            }
            // Menu band will Release _pmpSubMenu.
        }
    }
    else
    {
        IUnknown* punk;
        _pcmb->_pmpSubMenu->GetClient(&punk);
        if (punk)
        {
            hres = punk->QueryInterface(IID_IBandSite, (void**)&pmbs);
            punk->Release();
        }
    }

    if (pmbs)
    {
        if (SUCCEEDED(hres))
            hres = pmbs->AddBand(psm);

        pmbs->Release();
    }
 
    return hres;
}

HRESULT CMenuToolbarBase::GetSubMenu(int idCmd, GUID* pguidService, REFIID riid, void** ppvObj)
{
    // pguidService is for asking a for specifically the Shell Folder portion or the Static portion
    HRESULT hres = E_FAIL;
    if (v_GetFlags(idCmd) & SMIF_TRACKPOPUP ||
        _pcmb->_dwFlags & SMINIT_DEFAULTTOTRACKPOPUP)
    {
        hres = v_CreateTrackPopup(idCmd, riid, (void**)ppvObj);
        if (SUCCEEDED(hres))
        {
            _pcmb->SetTrackMenuPopup((IUnknown*)*ppvObj);
        }
    }
    else
    {
        IShellMenu* psm;
        hres = v_GetSubMenu(idCmd, pguidService, IID_IShellMenu, (void**)&psm);
        if (SUCCEEDED(hres)) 
        {
            TraceMsg(TF_MENUBAND, "GetUIObject psm %#lx", psm);
            _pcmb->SetTracked(this);

            hres = _SetMenuBand(psm);
            psm->Release();

            // Did we succeed in getting a menupopup?
            if (SUCCEEDED(hres))
            {
                // Yep; Sweet!
                _pcmb->_pmpSubMenu->QueryInterface(riid, ppvObj);

                HWND hwnd;
                IUnknown_GetWindow(_pcmb->_pmpSubMenu, &hwnd);
                PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBAutomation, (WPARAM)hwnd, (LPARAM)-1);
            }
        }
    }

    return hres;
}

HRESULT CMenuToolbarBase::PositionSubmenu(int idCmd)
{
    IMenuPopup* pmp = NULL;
    HRESULT hres = E_FAIL;
    DWORD dwFlags = 0;

    if (_pcmb->_fInSubMenu)
    {
        // Since the selection has probrably changed, we use the cached item id
        // to calculate the postion rect
        idCmd = _pcmb->_nItemSubMenu;
        dwFlags = MPPF_REPOSITION | MPPF_NOANIMATE;
        pmp = _pcmb->_pmpSubMenu;
        pmp->AddRef();

        ASSERT(pmp);    // If _fInSubmenu is set, then this must be valid
        hres = S_OK;
    }
    else
    {
        // Only do these when we're not repositioning.
        if (_pcmb->_fInitialSelect)
            dwFlags |= MPPF_INITIALSELECT;

        if (g_bRunOnNT5 && !_pcmb->_fCascadeAnimate)
            dwFlags |= MPPF_NOANIMATE;

        _pcmb->_nItemSubMenu = idCmd;

        hres = GetSubMenu(idCmd, NULL, IID_IMenuPopup, (void**)&pmp);
    }

    ASSERT(idCmd != -1);    // Make sure at this point we have an item.


    if (SUCCEEDED(hres))
    {
        ASSERT(pmp);

        // Make sure the menuitem is pressed
        _PressBtn(idCmd, TRUE);

        RECT rc;
        RECT rcTB;
        RECT rcTemp;
        POINT pt;

        SendMessage(_hwndMB, TB_GETRECT, idCmd, (LPARAM)&rc);
        GetClientRect(_hwndMB, &rcTB);

        // Is the button rect within the boundries of the
        // visible toolbar?
        if (!IntersectRect(&rcTemp, &rcTB, &rc))
        {
            // No; Then we need to bias that rect into
            // the visible region of the toolbar.
            // We only want to bias one side
            if (rc.left > rcTB.right)
            {
                rc.left = rcTB.right - (rc.right - rc.left);
                rc.right = rcTB.right;
            }
        }


        MapWindowPoints(_hwndMB, HWND_DESKTOP, (POINT*)&rc, 2);

        if (_fVerticalMB) 
        {
            pt.x = rc.right;
            pt.y = rc.top;
        } 
        else 
        {
            //
            // If the shell dropdown (toolbar button) menus are mirrored,
            // then take the right edge as the anchor point
            //
            if (IS_WINDOW_RTL_MIRRORED(_hwndMB))
                pt.x = rc.right;
            else
                pt.x = rc.left;
            pt.y = rc.bottom;
        }

        // Since toolbar buttons expand almost to the end of the basebar,
        // shrink the exclude rect so if overlaps.
        // NOTE: the items are GetSystemMetrics(SM_CXEDGE) larger than before. So adjust to that.

        if (_pcmb->_fExpanded)
            InflateRect(&rc, -GetSystemMetrics(SM_CXEDGE), 0);

        // We want to stop showing the chevron tip when we cascade into another menu
        _pcmb->_pmbState->HideTooltip(TRUE);

        // Only animate the first show at this level.
        _pcmb->_fCascadeAnimate = FALSE;

        hres = pmp->Popup((POINTL*)&pt, (RECTL*)&rc, dwFlags);
        pmp->Release();

    }
    return hres;
}
/*----------------------------------------------------------
Purpose: Cascade to the _nItemCur item's menu popup.

         If the popup call was modal, S_FALSE is returned; otherwise
         it is S_OK, or error.

*/
HRESULT CMenuToolbarBase::PopupOpen(int idBtn)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = E_FAIL;


    // Tell the current submenu popup to cancel.  This must be done 
    // before the PostMessage b/c CTrackPopupBar itself posts a message
    // which it must receive before we receive our post.
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): PostPopup sending MPOS_CANCELLEVEL to submenu popup", this);
    if (_pcmb->_fInSubMenu)
        _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);

    hres = PositionSubmenu(idBtn);

    // Modal?
    if (S_FALSE == hres)
    {
        // Yes; take the capture back
        GetMessageFilter()->RetakeCapture();

        // return S_OK so we stay in the menu mode
        hres = S_OK;
    }
    else if (FAILED(hres))
        _PressBtn(idBtn, FALSE);

    // Since CTrackPopupBar is modal, it should be a useless blob 
    // of bits in memory by now...
    _pcmb->SetTrackMenuPopup(NULL);
   
    return hres;
}


/*----------------------------------------------------------
Purpose: Called to hide a modeless menu.

*/
void CMenuToolbarBase::PopupClose(void)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (-1 != _pcmb->_nItemCur)
    {
        _PressBtn(_pcmb->_nItemCur, FALSE);
        NotifyWinEvent(EVENT_OBJECT_FOCUS, _hwndMB, OBJID_CLIENT, 
            GetIndexFromChild(_dwFlags & SMSET_TOP, ToolBar_CommandToIndex(_hwndMB, _pcmb->_nItemCur)));

        _pcmb->_fInSubMenu = FALSE;
        _pcmb->_fInvokedByDrag = FALSE;
        _pcmb->_nItemCur = -1;
    }
}    


LRESULT CMenuToolbarBase::_OnWrapHotItem(NMTBWRAPHOTITEM* pnmwh)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_fProcessingWrapHotItem || 
        (_pcmb->_pmtbTop == _pcmb->_pmtbBottom && !_fHasDemotedItems))
        return 0;

    _fProcessingWrapHotItem = TRUE;


    // If we want ourselves to not be wrapped into (Like for empty items) 
    // Then forward the wrap message to the other toolbar
    if (_pcmb->_pmtbTracked->_dwFlags & SMSET_TOP && !(_pcmb->_pmtbBottom->_fDontShowEmpty))
    {
        _pcmb->SetTracked(_pcmb->_pmtbBottom);
    }
    else if (!(_pcmb->_pmtbTop->_fDontShowEmpty))
    {
        _pcmb->SetTracked(_pcmb->_pmtbTop);
    }

    int iIndex;

    if (pnmwh->iDir < 0)
    {
        HWND hwnd = _pcmb->_pmtbTracked->_hwndMB;
        iIndex = ToolBar_ButtonCount(hwnd) - 1;
        int idCmd = GetButtonCmd(hwnd, iIndex);

        // We do not want to wrap onto a chevron.
        if (idCmd == _idCmdChevron)
            iIndex -= 1;

    }
    else
    {
        iIndex = 0;
    }

    _pcmb->_pmtbTracked->SetHotItem(pnmwh->iDir, iIndex, -1, pnmwh->nReason);


    _fProcessingWrapHotItem = FALSE;

    return 1;
}


LRESULT CMenuToolbarBase::_OnWrapAccelerator(NMTBWRAPACCELERATOR* pnmwa)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    int iHotItem = -1;
    int iNumTopAccel = 0;
    int iNumBottomAccel = 0;

    if (_pcmb->_fProcessingDup)
        return 0;

    // Check to see if there is only one toolbar.
    if (_pcmb->_pmtbTop == _pcmb->_pmtbBottom)
        return 0;

    ToolBar_HasAccelerator(_pcmb->_pmtbTop->_hwndMB, pnmwa->ch, &iNumTopAccel);
    ToolBar_HasAccelerator(_pcmb->_pmtbBottom->_hwndMB, pnmwa->ch, &iNumBottomAccel);

    _pcmb->_fProcessingDup = TRUE;

    CMenuToolbarBase* pmbtb = NULL;
    if (_pcmb->_pmtbTracked->_dwFlags & SMSET_TOP)
    {
        ToolBar_MapAccelerator(_pcmb->_pmtbBottom->_hwndMB, pnmwa->ch, &iHotItem);
        pmbtb = _pcmb->_pmtbBottom;
    }
    else
    {
        ToolBar_MapAccelerator(_pcmb->_pmtbTop->_hwndMB, pnmwa->ch, &iHotItem);
        pmbtb = _pcmb->_pmtbTop;
    }

    _pcmb->_fProcessingDup = FALSE;

    if (iHotItem != -1)
    {
        _pcmb->SetTracked(pmbtb);
        int idCmd = ToolBar_CommandToIndex(pmbtb->_hwndMB, iHotItem);
        DWORD dwFlags = HICF_ACCELERATOR;

        // If either (but not both) toolbars have the accelerator, and it is exactly one,
        // then cause the drop down.
        if ( (iNumTopAccel >= 1) ^ (iNumBottomAccel >= 1) &&
             (iNumTopAccel == 1 || iNumBottomAccel == 1) )
            dwFlags |= HICF_TOGGLEDROPDOWN;

        SendMessage(pmbtb->_hwndMB, TB_SETHOTITEM2, idCmd, dwFlags);
        pnmwa->iButton = -1;
        return 1;
    }

    return 0;
}


LRESULT CMenuToolbarBase::_OnDupAccelerator(NMTBDUPACCELERATOR* pnmda)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (_pcmb->_fProcessingDup || (_pcmb->_pmtbBottom == _pcmb->_pmtbTop))
        return 0;

    _pcmb->_fProcessingDup = TRUE;

    int iNumTopAccel = 0;
    int iNumBottomAccel = 0;
    
    if (_pcmb->_pmtbTop)
        ToolBar_HasAccelerator(_pcmb->_pmtbTop->_hwndMB, pnmda->ch, &iNumTopAccel);

    if (_pcmb->_pmtbBottom)
        ToolBar_HasAccelerator(_pcmb->_pmtbBottom->_hwndMB, pnmda->ch, &iNumBottomAccel);


    _pcmb->_fProcessingDup = FALSE;

    if (0 == iNumTopAccel && 0 == iNumBottomAccel)
    {
        // We want to return 1 if Both of them have one. 
        //Otherwise, return 0, and let the toolbar handle it itself.
        return 0;
    }

    pnmda->fDup = TRUE;

    return 1;
}

/*----------------------------------------------------------
Purpose: Handle WM_NOTIFY

*/
LRESULT CMenuToolbarBase::_OnNotify(LPNMHDR pnm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    LRESULT lres = 0;
    CMBMsgFilter* pmf = GetMessageFilter();

    // These are notifies we handle even when disengaged from the message hook.
    switch (pnm->code)
    {
    case NM_CUSTOMDRAW:
        // We now custom draw even the TopLevelMenuBand (for the correct font)
        lres = _OnCustomDraw((NMCUSTOMDRAW*)pnm);
        break;
    }
    
    
    // Is the Global Message filter Disengaged? This will happen when the Subclassed window
    // looses activation to a dialog box of some kind.
    if (lres == 0 && !pmf->IsEngaged())
    {
        // Yes; We've lost activation so we don't want to track like a normal menu...

        // For hot item change, return 1 so that the toolbar does not change the hot item.
        if (pnm->code == TBN_HOTITEMCHANGE && _pcmb->_fMenuMode)
            return 1;

        // For all other items, don't do anything....
        return 0;
    }

    switch (pnm->code)
    {
    case NM_RELEASEDCAPTURE:
        pmf->RetakeCapture();
        break;

    case NM_KEYDOWN:
        BLOCK
        {
            LPNMKEY pnmk = (LPNMKEY)pnm;
            lres = _OnKey(TRUE, pnmk->nVKey, pnmk->uFlags);
        }
        break;

    case NM_CHAR:
        {
            LPNMCHAR pnmc = (LPNMCHAR)pnm;
            if (pnmc->ch == TEXT(' '))
                return TRUE;

            if (pnmc->dwItemNext == -1 &&
                !_pcmb->_fVertical)
            {
                // If it's horizontal, then it must be top level.
                ASSERT(_pcmb->_fTopLevel);
                _pcmb->_CancelMode(MPOS_FULLCANCEL);
            }
        }
        break;

    case TBN_HOTITEMCHANGE:
        lres = _OnHotItemChange((LPNMTBHOTITEM)pnm);
        break;

    case NM_LDOWN:
        // We need to kill the expand timer, because the user might
        // move out of the chevron and accidentally select another item.
        if ( (int)((LPNMCLICK)pnm)->dwItemSpec == _idCmdChevron && _idCmdChevron != -1)
        {
            KillTimer(_hwndMB, MBTIMER_EXPAND);
            _fIgnoreHotItemChange = TRUE;
        }
        break;

    case NM_CLICK:
        {
            int idCmd = (int)((LPNMCLICK)pnm)->dwItemSpec;
            _fIgnoreHotItemChange = FALSE;
            if ( idCmd == -1 )
            {
                _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
                _pcmb->SetTracked(NULL);
                lres = 1;
            }
            else if ( idCmd == _idCmdChevron )
            {
                // Retake the capture on the button-up, b/c the toolbar took
                // it away for a moment.
                pmf->RetakeCapture();

                v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
                Expand(TRUE);
                _fClickHandled = TRUE;
                _SetTimer(MBTIMER_CLICKUNHANDLE);
                lres = 1;
            }
            else if (!_fEmpty)
            {
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): upclick %d", this, idCmd);

                // Retake the capture on the button-up, b/c the toolbar took
                // it away for a moment.
                pmf->RetakeCapture();

                if (v_GetFlags(idCmd) & SMIF_SUBMENU)     // Submenus support double click
                {
                    if (_iLastClickedTime == 0) // First time it was clicked
                    {
                        _iLastClickedTime = GetTickCount();
                        _idCmdLastClicked = idCmd;
                    }
                    // Did they click on the same item twice?
                    else if (idCmd != _idCmdLastClicked)
                    {
                        _iLastClickedTime = _idCmdLastClicked = 0;
                    }
                    else
                    {
                        // Was this item double clicked on?
                        if ((GetTickCount() - _iLastClickedTime) < GetDoubleClickTime())
                        {
                            // We need to post this back to ourselves, because
                            // the Tray will become in active when double clicking
                            // on something like programs. This happens because the 
                            // Toolbar will set capture back to itself and the tray
                            // doesn't get any more messages.
                            PostMessage(_hwndMB, g_nMBExecute, idCmd, 0);
                            _fClickHandled = TRUE;
                        }

                        _iLastClickedTime = _idCmdLastClicked = 0;
                    }
                }

                // Sent on the button-up.  Handle the same way.
                if (!_fClickHandled && -1 != idCmd)
                    _DropDownOrExec(idCmd, FALSE);

                _fClickHandled = FALSE;
                lres = 1;
            }
        }
        break;

    case TBN_DROPDOWN:
        lres = _OnDropDown((LPNMTOOLBAR)pnm);
        break;

#ifdef UNICODE
    case TBN_GETINFOTIPA:
        {
            LPNMTBGETINFOTIPA pnmTT = (LPNMTBGETINFOTIPA)pnm;
            UINT uiCmd = pnmTT->iItem;
            TCHAR szTip[MAX_PATH];

            if ( S_OK == v_GetInfoTip(pnmTT->iItem, szTip, ARRAYSIZE(szTip)) )
            {
                SHUnicodeToAnsi(szTip, pnmTT->pszText, pnmTT->cchTextMax);
            }
            else
            {
                // Set the lpszText to NULL to prevent the toolbar from setting
                // the button text by default
                pnmTT->pszText = NULL;
            }


            lres = 1;
            break;

        }
#endif
    case TBN_GETINFOTIP:
        {
            LPNMTBGETINFOTIP pnmTT = (LPNMTBGETINFOTIP)pnm;
            UINT uiCmd = pnmTT->iItem;

            if ( S_OK != v_GetInfoTip(pnmTT->iItem, pnmTT->pszText, pnmTT->cchTextMax) )
            {
                // Set the lpszText to NULL to prevent the toolbar from setting
                // the button text by default
                pnmTT->pszText = NULL;
            }
            lres = 1;
            break;
        }

    case NM_RCLICK:
        // When we go into a context menu, stop monitoring.
        KillTimer(_hwndMB, MBTIMER_EXPAND);
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
        break;

    case TBN_WRAPHOTITEM:
        lres = _OnWrapHotItem((NMTBWRAPHOTITEM*)pnm);
        break;

    case TBN_WRAPACCELERATOR:
        lres = _OnWrapAccelerator((NMTBWRAPACCELERATOR*)pnm);
        break;

    case TBN_DUPACCELERATOR:
        lres = _OnDupAccelerator((NMTBDUPACCELERATOR*)pnm);
        break;

    case TBN_DRAGOVER:
        // This message is sent when drag and drop within the toolbar indicates that it
        // is about to mark a button. Since this gets messed up because of LockWindowUpdate
        // we tell it not to do anything.
        lres = 1;
        break;
    }

    return(lres);
}


BOOL CMenuToolbarBase::_SetTimer(int nTimer)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    long lTimeOut;

#ifndef UNIX
    // If we're on NT5 or Win98, use the cool new SPI
    if (SystemParametersInfo(SPI_GETMENUSHOWDELAY, 0, &g_lMenuPopupTimeout, 0)) {
        // Woo-hoo, all done.
    }
    else if (g_lMenuPopupTimeout == -1)
#endif
    {
        // NT4 or Win95.  Grovel the registry (yuck).
        DWORD dwType;
        TCHAR szDelay[6]; // int is 5 characters + null.
        DWORD cbSize = ARRAYSIZE(szDelay);

        g_lMenuPopupTimeout = MBTIMER_TIMEOUT;

        if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"),
            TEXT("MenuShowDelay"), &dwType, (void*)szDelay, &cbSize))
        {
            g_lMenuPopupTimeout = (UINT)StrToInt(szDelay);
        }
    }

    lTimeOut = g_lMenuPopupTimeout;

    switch (nTimer)
    {
    case MBTIMER_EXPAND:
    case MBTIMER_DRAGPOPDOWN:
        lTimeOut *= 2;
        if (lTimeOut < MAXUEMTIMEOUT)
            lTimeOut = MAXUEMTIMEOUT;
        break;

    case MBTIMER_UEMTIMEOUT:
            if (!_fHasDemotedItems || _pcmb->_pmbState->GetExpand() || _fEditMode)
                return TRUE;
            lTimeOut *= 5;

            // We want a minimum of MAXUEMTIMEOUT for people who set the expand rate to zero
            if (lTimeOut < MAXUEMTIMEOUT)
                lTimeOut = MAXUEMTIMEOUT;
            TraceMsg(TF_MENUBAND, "*** UEM SetTimeOut to (%d) milliseconds" 
                "at Tick Count (%d).*** ", GetTickCount());
            break;

    case MBTIMER_CHEVRONTIP:
        lTimeOut = 60 * 1000;    // Please make the intellimenu's balloon tip go 
                                 // away after one minute of no action.
        break;

    case MBTIMER_INFOTIP:
        lTimeOut = 500;    // Half a second hovering over an item?
        break;
    }

    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): Setting %d Timer to %d milliseconds at tickcount %d", 
        this, nTimer, lTimeOut, GetTickCount());
    return (BOOL)SetTimer(_hwndMB, nTimer, lTimeOut, NULL);
}

BOOL CMenuToolbarBase::_HandleObscuredItem(int idCmd)
{
    RECT rc;
    GetClientRect(_hwndMB, &rc);

    int iButton = (int)SendMessage(_hwndMB, TB_COMMANDTOINDEX, idCmd, 0);

    if (SHIsButtonObscured(_hwndMB, &rc, iButton)) 
    {
        // clear hot item
        ToolBar_SetHotItem(_hwndMB, -1);

        _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
        _pcmb->_CancelMode(MPOS_FULLCANCEL);        // This is for the track menus.

        HWND hwnd = _pcmb->_pmbState->GetSubclassedHWND();

        PostMessage(hwnd? hwnd: _hwndMB, g_nMBOpenChevronMenu, (WPARAM)idCmd, 0);

        return TRUE;
    }

    return FALSE;
}


LRESULT CMenuToolbarBase::_OnHotItemChange(NMTBHOTITEM * pnmhot)
{
	ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    LRESULT lres = 0;

#ifdef UNIX
    // IEUNIX : If this is a mouse move check if the left button is pressed
    // deviating from Windows behavior to be motif compliant.
    if (_fVerticalMB && (pnmhot->dwFlags & HICF_MOUSE) && !(pnmhot->dwFlags & HICF_LMOUSE))
        return 1;
#endif

    if (_pcmb->_fMenuMode && _pcmb->_fShow && !_fIgnoreHotItemChange)
    {
        // Always kill the expand timer when something changes
        KillTimer(_hwndMB, MBTIMER_EXPAND);
        KillTimer(_hwndMB, MBTIMER_INFOTIP);

        // Is this toolbar being entered?
        if (!(pnmhot->dwFlags & HICF_LEAVING))
        {
            // Yes; set it to be the currently tracking toolbar
            TraceMsg(TF_MENUBAND, "CMTB::OnHotItemChange. Setting Tracked....", this);
            _pcmb->SetTracked(this);

            _pcmb->_pmbState->HideTooltip(FALSE);
            _SetTimer(MBTIMER_INFOTIP);
        }

        // If the Toolbar has keybaord focus, we need to send OBJID_CLIENT so that we track correctly.
        if (!(pnmhot->dwFlags & HICF_LEAVING))
        {
            NotifyWinEvent(EVENT_OBJECT_FOCUS, _hwndMB, OBJID_CLIENT, 
                GetIndexFromChild(_dwFlags & SMSET_TOP, ToolBar_CommandToIndex(_hwndMB, pnmhot->idNew)));
        }

        DEBUG_CODE( TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHANGE (state:%#02lx, %d-->%d)", 
                             this, pnmhot->dwFlags, 
                             (pnmhot->dwFlags & HICF_ENTERING) ? -1 : pnmhot->idOld, 
                             (pnmhot->dwFlags & HICF_LEAVING) ? -1 : pnmhot->idNew); )

        // While in edit mode, we do not automatically cascade 
        // submenus, unless while dropping.  But the dropping case
        // is handled in HitTest, not here.  So don't deal with that
        // here.

        // Is this because an accelerator key was hit?
        if (pnmhot->dwFlags & HICF_ACCELERATOR)
        {
            KillPopupTimer();
            KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
            // Yes; now that TBSTYLE_DROPDOWN is used, let _DropDownOrExec handle it
            // in response to TBN_DROPDOWN.
        }
        // Is this because direction keys were hit?
        else if (pnmhot->dwFlags & HICF_ARROWKEYS)
        {
            // Yes
            KillPopupTimer();
            KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);

            if (!_fVerticalMB && 
                _HandleObscuredItem(pnmhot->idNew))
            {
                lres = 1;
            }
            else
            {
                // It doesn't make sense that we would get these keyboard
                // notifications if there is a submenu open...it should get
                // the messages
                ASSERT(!_pcmb->_fInSubMenu);
                v_SendMenuNotification(pnmhot->idNew, FALSE);

                // Since the only way that the chevron can get the highlight is
                // through a keyboard down, then we expand.
                if (_fHasDemotedItems && pnmhot->idNew == (int)_idCmdChevron)
                {
                    v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
                    Expand(TRUE);
                    lres = 1;       // We already handled the hot item change
                }
            }

            _pcmb->_pmbState->HideTooltip(FALSE);
            _SetTimer(MBTIMER_INFOTIP);
        }
        // Is this because the mouse moved or an explicit sendmessage?
        else if (!(pnmhot->dwFlags & HICF_LEAVING) && 
                 (pnmhot->idNew != _pcmb->_nItemCur || // Ignore if we're moving over same item
                  (_nItemTimer != -1 && _pcmb->_nItemCur == pnmhot->idNew)))     // we need to go through here to reset if the user went back to the cascaded guy
        {
            // Yes
            if (!_fVerticalMB)    // Horizontal menus will always have an underlying hmenu
            {
                if (_HandleObscuredItem(pnmhot->idNew))
                {
                    lres = 1;
                }
                else if (_pcmb->_fInSubMenu)
                {
                    // Only popup a menu since we're already in one (as mouse
                    // moves across bar).

                    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHG: Posting CMBPopup message", this);
                    PostPopup(pnmhot->idNew, FALSE, _pcmb->_fKeyboardSelected);  // Will handle menu notification on receipt of message
                }
                else
                    v_SendMenuNotification(pnmhot->idNew, FALSE);
            }
            else if (!_fEditMode)
            {
                v_SendMenuNotification(pnmhot->idNew, FALSE);

                // check to see if we have just entered a new item and it is a sub-menu...

                // Did we already set a timer?
                if (-1 != _nItemTimer)
                {
                    // Yes; kill it b/c the mouse moved to another item
                    KillPopupTimer();
                }

                // if we're not over the currently expanded guy
                // Have we moved over an item that expands OR
                // are we moving away from a cascaded item?
                DWORD dwFlags = v_GetFlags(pnmhot->idNew);
                // Reset the stupid user timer
                KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);

                // UEMStuff
                if (!(dwFlags & SMIF_SUBMENU))
                {
                    _SetTimer(MBTIMER_UEMTIMEOUT);
                    _FireEvent(UEM_HOT_ITEM);
                }

                if ( (pnmhot->dwFlags & HICF_MOUSE) && _pcmb->_nItemCur != pnmhot->idNew) 
                {
                    if (dwFlags & SMIF_SUBMENU || _pcmb->_fInSubMenu)
                    {
                        // Is this the only item in the menu?
                        if ( _cPromotedItems == 1 && 
                            !(_fHasDemotedItems && _pcmb->_fExpanded) && 
                            dwFlags & SMIF_SUBMENU)
                        {
                            // Yes; Then we want to pop it open immediatly, 
                            // instead of waiting for the timeout
                            PostPopup(pnmhot->idNew, FALSE, FALSE);
                        }
                        else if (_SetTimer(MBTIMER_POPOUT))
                        {
                            // No; fire a timer to open/close the submenu
                            TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHG: Starting timer for id=%d", this, pnmhot->idNew);
                            if (v_GetFlags(pnmhot->idNew) & SMIF_SUBMENU)
                                _nItemTimer = pnmhot->idNew;
                            else
                                _nItemTimer = -1;
                        }
                    }
                    
                    if (_fHasDemotedItems && pnmhot->idNew == (int)_idCmdChevron)
                    {
                        _SetTimer(MBTIMER_EXPAND);
                    }

                    _pcmb->_pmbState->HideTooltip(FALSE);
                    _SetTimer(MBTIMER_INFOTIP);
                }

            }
        }
        else if (pnmhot->dwFlags & HICF_LEAVING)
        {
            v_SendMenuNotification(pnmhot->idOld, TRUE);

            if (-1 != _nItemTimer && !_fEditMode)
            {
                // kill the cascading menu popup timer...
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): TBN_HOTITEMCHG: Killing timer", this);
            
                KillPopupTimer();
            }
            _pcmb->_pmbState->HideTooltip(FALSE);
        }

        if ( !(pnmhot->dwFlags & HICF_LEAVING) )
            _pcmb->_SiteOnSelect(MPOS_CHILDTRACKING);
    }

    return lres;
}    

void CMenuToolbarBase::s_FadeCallback(DWORD dwStep, LPVOID pvParam)
{
    CMenuToolbarBase* pmtb = (CMenuToolbarBase*)pvParam;

    if (pmtb && dwStep == FADE_BEGIN)    // Paranoia
    {
        // Command has been posted.  Exit menu.
        pmtb->_pcmb->_SiteOnSelect(MPOS_EXECUTE);
    }
}   

LRESULT CMenuToolbarBase::_DropDownOrExec(UINT idCmd, BOOL bKeyboard)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _DropDownOrExec %d", this, idCmd);

    // Don't do anything when we're in edit mode
    if (_fEditMode)
        return 0;

    if ( v_GetFlags(idCmd) & SMIF_SUBMENU )
    {
        v_SendMenuNotification(idCmd, FALSE);
        
        PostPopup(idCmd, FALSE, bKeyboard);
    }
    else if (idCmd != -1)
    {
        RECT rc;
        AddRef();   // I might get released in the call.

        // Fading Selection
        IEPlaySound(TEXT("MenuCommand"), TRUE);
        SendMessage(_hwndMB, TB_GETRECT, idCmd, (LPARAM)&rc);
        MapWindowPoints(_hwndMB, HWND_DESKTOP, (POINT*)&rc, 2);

        if (!(GetKeyState(VK_SHIFT) < 0))
        {
            // Were we able to fade?
            if (!_pcmb->_pmbState->FadeRect(&rc, s_FadeCallback, this))
            {
                // No; Then we blow away the menus here instead of the Fade callback
                // Command has been posted.  Exit menu.
                _pcmb->_SiteOnSelect(MPOS_EXECUTE);
            }
        }

        if (g_dwProfileCAP & 0x00002000) 
            StartCAP();
        v_ExecItem(idCmd);
        if (g_dwProfileCAP & 0x00002000) 
            StopCAP();

        Release();
    }
    else
        MessageBeep(MB_OK);

    return 0;
}


/*----------------------------------------------------------
Purpose: Handles TBN_DROPDOWN, which is sent on the button-down.

*/
LRESULT CMenuToolbarBase::_OnDropDown(LPNMTOOLBAR pnmtb)
{
    DWORD dwInput = _fTopLevel ? 0 : -1;    // -1: don't track, 0: do
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    LRESULT lres = 0;

    // Expected behavior with the mouse:
    //
    // 1) For cascading menuitems-
    //    a) expand on button-down
    //    b) collapse on button-up (horizontal menu only)
    //    c) if the button-down occurs on the item that is
    //       already selected, then assume the click indicates
    //       a drag/drop scenario
    // 2) For other menuitems-
    //    a) execute on button-up

#ifdef DEBUG
    if (_fTopLevel) {
        // browser menu comes thru here; start menu goes elsewhere (via tray.c)
        //ASSERT(!_fVertical);
        TraceMsg(DM_MISC, "cmtbb._odd: _fTopLevel(1) mouse=%d", GetKeyState(VK_LBUTTON) < 0);
    }
#endif
    // Is this because the mouse button was used?
    if (GetKeyState(VK_LBUTTON) < 0)
    {
        // Yes

        // Assume it won't be handled.  This will allow the toolbar
        // to see the button-down as a potential drag and drop.
        lres = TBDDRET_TREATPRESSED;

        // Clicking on same item that is currently expanded?
        if (pnmtb->iItem == _pcmb->_nItemCur)
        {

            // Is this horizontal?
            if (!_fVerticalMB)
            {
                // Yes; toggle the dropdown
                _pcmb->_SubMenuOnSelect(MPOS_FULLCANCEL);
                
                // Say it is handled, so the button will toggle
                lres = TBDDRET_DEFAULT;
            }
            
            _fClickHandled = TRUE;
            
            // Otherwise don't do anything more, user might be starting a 
            // drag-drop procedure on the cascading menuitem
        }
        else
        {
            if (v_GetFlags(pnmtb->iItem) & SMIF_SUBMENU)
            {
                // Handle on the button-down
                _fClickHandled = TRUE;
                lres = _DropDownOrExec(pnmtb->iItem, FALSE);
            }
        }

        if (dwInput != -1)
            dwInput = UIBL_INPMOUSE;
    }
    else
    {
        // No; must be the keyboard
        _fClickHandled = TRUE;
        lres = _DropDownOrExec(pnmtb->iItem, TRUE);

        if (dwInput != -1)
            dwInput = UIBL_INPMENU;
    }

    // browser menu (*not* start menu) alt+key, mouse
    if (dwInput != -1)
        UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_UIINPUT, dwInput);

    return lres;
}    


/*----------------------------------------------------------
Purpose: Handle WM_KEYDOWN/WM_KEYUP

Returns: TRUE if handled
*/
BOOL CMenuToolbarBase::_OnKey(BOOL bDown, UINT vk, UINT uFlags)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    int idCmd;
    HWND hwnd = _hwndMB;

    _pcmb->_pmbState->SetKeyboardCue(TRUE);

    //
    // If the menu window is RTL mirrored, then the arrow keys should
    // be mirrored to reflect proper cursor movement. [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwnd))
    {
        switch (vk)
        {
        case VK_LEFT:
          vk = VK_RIGHT;
          break;

        case VK_RIGHT:
          vk = VK_LEFT;
          break;
        }
    }

    switch (vk)
    {
    case VK_LEFT:
        if (_fVerticalMB)
        {
            _pcmb->_SiteOnSelect(MPOS_SELECTLEFT);
            return TRUE;
        }
        break;

    case VK_RIGHT:
        if (_fVerticalMB)
            goto Cascade;
        break;

    case VK_DOWN:
    case VK_UP:
        if (!_fVerticalMB)
        {
Cascade:
            idCmd = GetButtonCmd(hwnd, ToolBar_GetHotItem(hwnd));
            if (v_GetFlags(idCmd) & SMIF_SUBMENU)
            {
                // Enter the submenu
                TraceMsg(TF_MENUBAND, "(pmb=%#08lx): _OnKey: Posting CMBPopup message", this);
                
                PostPopup(idCmd, FALSE, TRUE);
            }
            else if (VK_RIGHT == vk)
            {
                // Nothing to cascade to, move to next sibling menu
                _pcmb->_SiteOnSelect(MPOS_SELECTRIGHT);
            }
            return TRUE;
        }
        else
        {
#if 0
            _pcmb->_OnSelectArrow(vk == VK_UP? -1 : 1);
            return TRUE;
#endif
        }
        break;

    case VK_SPACE:

        if (!_pcmb->_fExpanded && _fHasDemotedItems)
        {
            v_CallCBItem(_idCmdChevron, SMC_CHEVRONEXPAND, 0, 0);
            Expand(TRUE);
        }
        else
        {
            // Toolbars map the spacebar to VK_RETURN.  Menus don't except
            // in the horizontal menubar.
            if (_fVerticalMB)
                MessageBeep(MB_OK);
        }
        return TRUE;

#if 0
    case VK_RETURN:
        // Handle this now, rather than letting the toolbar handle it.
        // This way we don't have to rely on WM_COMMAND, which doesn't
        // convey whether it was invoked by the keyboard or the mouse.
        idCmd = GetButtonCmd(hwnd, ToolBar_GetHotItem(hwnd));
        _DropDownOrExec(idCmd, TRUE);
        return TRUE;
#endif
    }

    return FALSE;
}    

/*----------------------------------------------------------
Purpose: There are two flavors of this function: _DoPopup and
         PostPopup.  Both cancel the existing submenu (relative 
         to this band) and pops open a new submenu.  _DoPopup
         does it atomically.  PostPopup posts a message to
         handle it.

*/
void CMenuToolbarBase::_DoPopup(int idCmd, BOOL bInitialSelect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (-1 != idCmd)
    {
        PopupHelper(idCmd, bInitialSelect);
    }
}    


/*----------------------------------------------------------
Purpose: See the _DoPopup comment
*/
void CMenuToolbarBase::PostPopup(int idCmd, BOOL bSetItem, BOOL bInitialSelect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (-1 != idCmd)
    {
        _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
        _pcmb->SetTracked(this);
        HWND hwnd = _pcmb->_pmbState->GetSubclassedHWND();

        PostMessage(hwnd? hwnd: _hwndMB, g_nMBPopupOpen, idCmd, MAKELPARAM(bSetItem, bInitialSelect));
    }
}    


/*----------------------------------------------------------
Purpose: Helper function to finally invoke submenu.  Use _DoPopup
         or PostPopup
*/
void CMenuToolbarBase::PopupHelper(int idCmd, BOOL bInitialSelect)
{
    // We do not want to pop open a sub menu if we are not displayed. This is especially
    // a problem during drag and drop.
    if (_fShowMB)
    {
        _pcmb->_nItemNew = idCmd;
        ASSERT(-1 != _pcmb->_nItemNew);
        _pcmb->SetTracked(this);
        _pcmb->_fPopupNewMenu = TRUE;
        _pcmb->_fInitialSelect = BOOLIFY(bInitialSelect);
        _pcmb->UIActivateIO(TRUE, NULL);
        _FireEvent(UEM_HOT_FOLDER);
        _SetTimer(MBTIMER_UEMTIMEOUT);
    }
}

void    CMenuToolbarBase::_PaintButton(HDC hdc, int idCmd, LPRECT prc, DWORD dwSMIF)
{
    if (!_pcmb->_fExpanded)
        return;

    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    RECT rcClient;
    GetClientRect(_hwndMB, &rcClient);
#ifndef DRAWEDGE
    // Draw Left Edge
    HPEN hPenOld = (HPEN)SelectObject(hdc, _pcmb->_pmbm->_hPenHighlight);
    MoveToEx(hdc, prc->left, prc->top, NULL);
    LineTo(hdc, prc->left, prc->bottom);
#endif

    if (!(dwSMIF & SMIF_DEMOTED))
    {
#ifdef DRAWEDGE
        DWORD dwEdge = BF_RIGHT;

        // Don't paint the edge next to the bitmap.
        if (_uIconSizeMB == ISFBVIEWMODE_SMALLICONS)
            dwEdge |= BF_LEFT;


        RECT rc = *prc;
#else
        // Draw Right Edge:
        SelectObject(hdc, _pcmb->_pmbm->_hPenShadow);
        MoveToEx(hdc, prc->right-1, prc->top, NULL);
        LineTo(hdc, prc->right-1, prc->bottom);
#endif

        HWND hwnd = _hwndMB;
        int iPos = ToolBar_CommandToIndex(hwnd, idCmd);
        if (iPos == -1)
        {
            iPos = ToolBar_ButtonCount(hwnd) - 1;
        }

        if (iPos >= 0)
        {
            int iNumButtons = ToolBar_ButtonCount(hwnd);
            int idCmd2 = GetButtonCmd(hwnd, iPos + 1);
            CMenuToolbarBase* pmtb = this;
            BOOL    fOverflowed = FALSE;

            // Situations for Drawing the Bottom line
            // 1) This button is at the bottom.
            // 2) This button is at the bottom and the toolbar
            //      below is not visible (_fDontShowEmpty).
            // 3) This button is at the bottom and the button
            //      at the top of the bottom toolbar is demoted.
            // 4) The button below this one in the toolbar is
            //      demoted.
            // 5) The botton below this one is demoted and we're
            //      not expanded
    
            if (iPos + 1 >= iNumButtons)
            {
                if (_pcmb->_pmtbBottom != this &&
                    !_pcmb->_pmtbBottom->_fDontShowEmpty)
                {
                    pmtb = _pcmb->_pmtbBottom;
                    hwnd = pmtb->_hwndMB;
                    idCmd2 = GetButtonCmd(hwnd, 0);
                }
                else
                    fOverflowed = TRUE;
            }
            else if (prc->bottom == rcClient.bottom &&
                _pcmb->_pmtbBottom == this)   // This button is at the top.
                fOverflowed = TRUE;


            DWORD dwFlags = pmtb->v_GetFlags(idCmd2);

            if ((_pcmb->_fExpanded && dwFlags & SMIF_DEMOTED) || 
                 fOverflowed)
            {
#ifdef DRAWEDGE
                dwEdge |= BF_BOTTOM;
#else
                int iLeft = prc->left;
                if (iPos != iNumButtons - 1)   
                    iLeft ++;   // Move the next line in.

                MoveToEx(hdc, iLeft, prc->bottom-1, NULL);
                LineTo(hdc, prc->right-1, prc->bottom-1);
#endif
            }

            // Situations for Drawing the Top line
            // 1) This button is at the top.
            // 2) This button is at the top and the toolbar
            //      above is not visible (_fDontShowEmpty).
            // 3) This button is at the top and the button
            //      at the bottom of the top toolbar is demoted.
            // 4) The button above this one in the toolbar is
            //      demoted.
            // 5) If the button above this is demoted, and we're
            //      not expanded

            fOverflowed = FALSE; 

            if (iPos - 1 < 0)
            {
                if (_pcmb->_pmtbTop != this && 
                    !_pcmb->_pmtbTop->_fDontShowEmpty)
                {
                    pmtb = _pcmb->_pmtbTop;
                    hwnd = pmtb->_hwndMB;
                    idCmd2 = GetButtonCmd(hwnd, ToolBar_ButtonCount(hwnd) - 1);
                }
                else
                    fOverflowed = TRUE; // There is nothing at the top of this menu, draw the line.
            }
            else
            {
                hwnd = _hwndMB;
                idCmd2 = GetButtonCmd(hwnd, iPos - 1);
                pmtb = this;

                if (prc->top == rcClient.top &&
                    _pcmb->_pmtbTop == this)   // This button is at the top.
                    fOverflowed = TRUE;
            }

            dwFlags = pmtb->v_GetFlags(idCmd2);

            if ((_pcmb->_fExpanded && dwFlags & SMIF_DEMOTED) ||
                fOverflowed)
            {
#ifdef DRAWEDGE
                dwEdge |= BF_TOP;
#else
                SelectObject(hdc, _pcmb->_pmbm->_hPenHighlight);
                MoveToEx(hdc, prc->left, prc->top, NULL);
                LineTo(hdc, prc->right-1, prc->top);
#endif
            }
        }

#ifdef DRAWEDGE
        DrawEdge(hdc, &rc, BDR_RAISEDINNER, dwEdge);
#endif
    }

#ifndef DRAWEDGE
    SelectObject(hdc, hPenOld);
#endif
}

LRESULT CMenuToolbarBase::_OnCustomDraw(NMCUSTOMDRAW * pnmcd)
{
    // Make it look like a menu
    NMTBCUSTOMDRAW * ptbcd = (NMTBCUSTOMDRAW *)pnmcd;
    DWORD dwRet = 0;
        
    // Edit mode never hot tracks, and the selected item being
    // moved has a black frame around it.  Items that cascade are 
    // still highlighted normally, even in edit mode.

    DWORD dwSMIF = v_GetFlags((UINT)pnmcd->dwItemSpec);

    switch(pnmcd->dwDrawStage)
    {
    case CDDS_PREPAINT:
        dwRet = CDRF_NOTIFYITEMDRAW | CDRF_NOTIFYPOSTPAINT;
        break;

    case CDDS_ITEMPREPAINT:
        if (_fVerticalMB)
        {
            if (pnmcd->dwItemSpec == -1)
            {
                // a -1 is sent with a seperator
                RECT rc = pnmcd->rc;
                rc.top += 3;    // Hard coded in toolbar.
                rc.left += GetSystemMetrics(SM_CXEDGE);
                rc.right -= GetSystemMetrics(SM_CXEDGE);
                DrawEdge(pnmcd->hdc, &rc, EDGE_ETCHED, BF_TOP);

                _PaintButton(pnmcd->hdc, -1, &pnmcd->rc, dwSMIF);

                dwRet = CDRF_SKIPDEFAULT;
            }
            else
            {
                ptbcd->clrText = _pcmb->_pmbm->_clrMenuText;

                // This is for Darwin Ads.
                if (dwSMIF & SMIF_ALTSTATE)
                {
                    ptbcd->clrText = GetSysColor(COLOR_BTNSHADOW);
                }

                ptbcd->rcText.right = ptbcd->rcText.right - _pcmb->_pmbm->_cxMargin;
                ptbcd->clrBtnFace = _pcmb->_pmbm->_clrBackground;
                if (_fHasSubMenu)
                    ptbcd->rcText.right -= _pcmb->_pmbm->_cxArrow;

                if ( _fHasDemotedItems && _idCmdChevron == (int)pnmcd->dwItemSpec)
                {
                    _DrawChevron(pnmcd->hdc, &pnmcd->rc, 
                        (BOOL)(pnmcd->uItemState & CDIS_HOT) ||
                         (BOOL)(pnmcd->uItemState & CDIS_MARKED), 
                        (BOOL)(pnmcd->uItemState & CDIS_SELECTED) );

                    dwRet |= CDRF_SKIPDEFAULT;

                }
                else
                {
#ifdef MARK_DRAGGED_ITEM
                    // We have no good way to undo this on a multi pane drop.
                    if (_idCmdDragging != -1 &&
                        _idCmdDragging == (int)pnmcd->dwItemSpec)
                        pnmcd->uItemState |= CDIS_HOT;
#endif

                    // Yes; draw with highlight
                    if (pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT))
                    {
#ifdef UNIX
                        if( MwCurrentLook() == LOOK_MOTIF )
                            SelectMotifMenu(pnmcd->hdc, &pnmcd->rc, TRUE );
                        else
#endif
                        {
                            ptbcd->clrHighlightHotTrack = GetSysColor(COLOR_HIGHLIGHT);
                            ptbcd->clrBtnFace = GetSysColor(COLOR_HIGHLIGHT);
                            ptbcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                            dwRet |= TBCDRF_HILITEHOTTRACK;
                        }
                    }


                    // Is this menu empty?
                    if (_fEmpty)
                    {
                        // Yes, draw the empty string as disabled.
                        pnmcd->uItemState |= CDIS_DISABLED;
                        ptbcd->clrText = ptbcd->clrBtnFace;

                        // Don't draw the etched effect if it is selected
                        if (pnmcd->uItemState & CDIS_HOT)
                            dwRet |= TBCDRF_NOETCHEDEFFECT;
                    }

                    // When this item is demoted, we only want to paint his background
                    // then we are in edit mode _OR_ it is not selected, checked or hot.
                    if (dwSMIF & SMIF_DEMOTED)
                    {
                        BOOL fDrawDemoted = TRUE;
                        if (_fEditMode)
                            fDrawDemoted = TRUE;

                        if (pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT))
                            fDrawDemoted = FALSE;

                        if (fDrawDemoted)
                        {
                            ptbcd->clrBtnFace = _pcmb->_pmbm->_clrDemoted;
                            SHFillRectClr(pnmcd->hdc, &pnmcd->rc, ptbcd->clrBtnFace);
                        }
                    }

                    // We draw our own highlighting
                    dwRet |= (TBCDRF_NOEDGES | TBCDRF_NOOFFSET);
                }
            }
        }
        else
        {
            // If g_fRunOnMemphis or g_fRunOnNT5 are not defined then the menus will
            // never be grey.
            if (!_pcmb->_fAppActive)
                // menus from user use Button Shadow for non active menus
                ptbcd->clrText = GetSysColor(COLOR_3DSHADOW);
            else
                ptbcd->clrText = _pcmb->_pmbm->_clrMenuText;

            // If we're in high contrast mode, make the menu bar look like
            // veritcal items on select.
            if (_pcmb->_pmbm->_fHighContrastMode)
            {
                // Yes; draw with highlight
                if (pnmcd->uItemState & (CDIS_CHECKED | CDIS_SELECTED | CDIS_HOT))
                {
#ifdef UNIX
                    if( MwCurrentLook() == LOOK_MOTIF )
                        SelectMotifMenu(pnmcd->hdc, &pnmcd->rc, TRUE );
                    else
#endif
                    {
                        ptbcd->clrHighlightHotTrack = GetSysColor(COLOR_HIGHLIGHT);
                        ptbcd->clrBtnFace = GetSysColor(COLOR_HIGHLIGHT);
                        ptbcd->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
                        dwRet |= TBCDRF_HILITEHOTTRACK;
                    }
                }
            }
        }
        dwRet |= CDRF_NOTIFYPOSTPAINT | TBCDRF_NOMARK;
        break;
    case CDDS_ITEMPOSTPAINT:
        if (_fVerticalMB)
        {
            RECT rc = pnmcd->rc;
            COLORREF rgbText;
            if (pnmcd->uItemState & (CDIS_SELECTED | CDIS_HOT))
                rgbText = GetSysColor( COLOR_HIGHLIGHTTEXT );
            else
                rgbText = _pcmb->_pmbm->_clrMenuText;

            // Is this item Checked?
            if (dwSMIF & SMIF_CHECKED)
            {
                rc.right = rc.left + (rc.bottom - rc.top);
                _DrawMenuGlyph(pnmcd->hdc, _pcmb->_pmbm->_hFontArrow
                    , &rc, CH_MENUCHECKA, rgbText, NULL);
                rc = pnmcd->rc;
            }
    
            // Is this a cascading item?
            if (dwSMIF & SMIF_SUBMENU)
            {
                // Yes; draw the arrow
                RECT rcT = rc;
        
                rcT.left = rcT.right - _pcmb->_pmbm->_cxArrow;
                _DrawMenuArrowGlyph(pnmcd->hdc, &rcT, rgbText);
            }

            _PaintButton(pnmcd->hdc, (UINT)pnmcd->dwItemSpec, &rc, dwSMIF);
        }
        break;
    case CDDS_PREERASE:
        {
            RECT rcClient;
            GetClientRect(_hwndMB, &rcClient);
            ptbcd->clrBtnFace = _pcmb->_pmbm->_clrBackground;
            SHFillRectClr(pnmcd->hdc, &rcClient, _pcmb->_pmbm->_clrBackground);
            dwRet = CDRF_SKIPDEFAULT;
        }
        break;
    }
    return dwRet;
}    



void CMenuToolbarBase::_PressBtn(int idBtn, BOOL bDown)
{
    if (!_fVerticalMB)
    {
        DWORD dwState = ToolBar_GetState(_hwndMB, idBtn);

        if (bDown)
            dwState |= TBSTATE_PRESSED;
        else
            dwState &= ~TBSTATE_PRESSED;

        ToolBar_SetState(_hwndMB, idBtn, dwState);

        // Avoid ugly late repaints
        UpdateWindow(_hwndMB);
    }
}    


/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the menuband.
*/
STDMETHODIMP CMenuToolbarBase::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    HRESULT hres = S_FALSE;

    EnterModeless();

    switch (uMsg)
    {
    case WM_SETTINGCHANGE:
        if ((SHIsExplorerIniChange(wParam, lParam) == EICH_UNKNOWN) || 
            (wParam == SPI_SETNONCLIENTMETRICS))
        {
            v_UpdateIconSize(-1, TRUE);
            v_Refresh();
            goto L_WM_SYSCOLORCHANGE;
        }
        break;

    case WM_SYSCOLORCHANGE:
    L_WM_SYSCOLORCHANGE:
        ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));
        SendMessage(_hwndMB, uMsg, wParam, lParam);
        InvalidateRect(_hwndMB, NULL, TRUE);
        hres = S_OK;
        break;

    case WM_PALETTECHANGED:
        InvalidateRect( _hwndMB, NULL, FALSE );
        SendMessage( _hwndMB, uMsg, wParam, lParam );
        hres = S_OK;
        break;

    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        hres = S_OK;
        break;
    }

    ExitModeless();

    return hres;
}


void CMenuToolbarBase::v_CalcWidth(int* pcxMin, int* pcxMax)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT(IS_VALID_WRITE_PTR(pcxMin, int));
    ASSERT(IS_VALID_WRITE_PTR(pcxMax, int));

     
    *pcxMin = 0;
    *pcxMax = 0;

    if (_fVerticalMB && _pcmb->_pmbm && _pcmb->_pmbm->_hFontMenu)
    {
        HIMAGELIST himl;
        int cel;
        int cxItemMax = 0;
        HWND hwnd = _hwndMB;
        
        ASSERT(hwnd);
        
        HDC hdc = GetDC(hwnd);

        if (hdc)
        {
            HFONT hFontOld = (HFONT) SelectObject(hdc, _pcmb->_pmbm->_hFontMenu);

            if (hFontOld)
            {
                TCHAR sz[MAX_PATH];
                cel = ToolBar_ButtonCount(hwnd);

                // Find the maximum length text
                for(int i = 0; i < cel; i++)
                {
                    int idCmd = GetButtonCmd(hwnd, i);
                    if (_idCmdChevron != idCmd &&
                        !(!_pcmb->_fExpanded && v_GetFlags(idCmd) & SMIF_DEMOTED))
                    {
                        UINT cch = (UINT)SendMessage(hwnd, TB_GETBUTTONTEXT, idCmd, NULL);
                        if (cch != 0 && cch < ARRAYSIZE(sz))
                        {
                            if (SendMessage(hwnd, TB_GETBUTTONTEXT, idCmd, (LPARAM)sz) > 0)
                            {
                                RECT rect = {0};
                                DWORD dwDTFlags = DT_CALCRECT | DT_SINGLELINE | DT_LEFT | DT_VCENTER;
                                if (ShowAmpersand())
                                    dwDTFlags |= DT_NOPREFIX;
                                DrawText(hdc, sz, -1, &rect, dwDTFlags);
                                cxItemMax = max(rect.right, cxItemMax);
                            }
                        }
                    }
                }

                SelectObject(hdc, hFontOld);
            }
            ReleaseDC(hwnd, hdc);
        }
        
        himl = (HIMAGELIST)SendMessage(hwnd, TB_GETIMAGELIST, 0, 0);
        if (himl)
        {
            int cy;
            
            // Start with the width of the button
            ImageList_GetIconSize(himl, pcxMin, &cy);

            // We want at least a bit of space around the icon
            if (_uIconSizeMB != ISFBVIEWMODE_SMALLICONS)
            {
                // Old FSMenu code took the height of the larger of 
                // the icon and text then added 2.
                ToolBar_SetPadding(hwnd, 0, 0);
                *pcxMin += 10;
            }
            else 
            {
                // Old FSMenu code took the height of the larger of 
                // the icon and text then added cySpacing, which defaults to 6.
                ToolBar_SetPadding(hwnd, 0, 4);
                *pcxMin += 3 * GetSystemMetrics(SM_CXEDGE);
            }
        }

        
        RECT rect = {0};
        int cxDesired = _pcmb->_pmbm->_cxMargin + cxItemMax + _pcmb->_pmbm->_cxArrow;
        int cxMax = 0;
           
        if (SystemParametersInfoA(SPI_GETWORKAREA, 0, &rect, 0))
        {
            // We're figuring a third of the screen is a good max width
            cxMax = (rect.right-rect.left) / 3;
        }

        *pcxMin += min(cxDesired, cxMax) + LIST_GAP;
        *pcxMax = *pcxMin;
    }
    TraceMsg(TF_MENUBAND, "CMenuToolbarBase::v_CalcWidth(%d, %d)", *pcxMin, *pcxMax);
}


void CMenuToolbarBase::_SetToolbarState()
{
    SHSetWindowBits(_hwndMB, GWL_STYLE, TBSTYLE_LIST, TBSTYLE_LIST);
}


void CMenuToolbarBase::v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    POINT pt;
    
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    GetWindowRect(_hwndMB, &rc);

    if (PtInRect(&rc, pt))
    {
        ScreenToClient(_hwndMB, &pt);
        SendMessage(_hwndMB, uMsg, wParam, MAKELONG(pt.x, pt.y));
    }
}

void CMenuToolbarBase::NegotiateSize()
{
    RECT rc;
    GetClientRect(GetParent(_hwndMB), &rc);
    _pcmb->OnPosRectChangeDB(&rc);

    // If we came in here it's because the Menubar did not change sizes or position.

}

void CMenuToolbarBase::SetParent(HWND hwndParent) 
{ 
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    if (hwndParent)
    {
        if (!_hwndMB)
            CreateToolbar(hwndParent);
    }
    else
    {
        // As an optimization, we implement "disowning" ourselves
        // as just moving ourselves offscreen.  The previous parent
        // still owns us.  The parent is invariably the menusite.
        RECT rc = {-1,-1,-1,-1};
        SetWindowPos(NULL, &rc, 0);
    }

    // We want to set the parent all the time because we don't want to destroy the 
    // window with it's parent..... Sizing to -1,-1,-1,-1 causes it not to be displayed.
    if (_hwndMB)
    {
        ::SetParent(_hwndMB, hwndParent); 
        SendMessage(_hwndMB, TB_SETPARENT, (WPARAM)hwndParent, NULL);
    }
}


void CMenuToolbarBase::v_OnEmptyToolbar()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    for (int iNumButtons = ToolBar_ButtonCount(_hwndMB) -1;
         iNumButtons >= 0; 
         iNumButtons--)
    {
        // HACKHACK (lamadio): For some reason, _fEmptyingToolbar gets set to FALSE.
        // We then Do a TB_DELETEBUTTON, which sends a notify. This does go through on
        // the top level menubands (Start Menu, Browser menu bar), and deletes the 
        // associated data. We then try and delete it again.
        // So now, I set null into the sub menu, so that the other code gracefully fails.

        TBBUTTONINFO tbbi;
        tbbi.cbSize = SIZEOF(tbbi);
        tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
        ToolBar_GetButtonInfo(_hwndMB, iNumButtons, &tbbi);

        LPVOID pData = (LPVOID)tbbi.lParam;
        tbbi.lParam = NULL;

        ToolBar_SetButtonInfo(_hwndMB, iNumButtons, &tbbi);

        SendMessage(_hwndMB, TB_DELETEBUTTON, iNumButtons, 0);
        v_OnDeleteButton(pData);
    }
}

void CMenuToolbarBase::EmptyToolbar()
{
    if (_hwndMB)
    {
        _fEmptyingToolbar = TRUE;
        v_OnEmptyToolbar();
        _fEmptyingToolbar = FALSE;
    }
}

void CMenuToolbarBase::v_Close()
{
    EmptyToolbar();
    if (_hwndMB)
    {
        //Kill timers to prevent race condition
        KillTimer(_hwndMB, MBTIMER_POPOUT);
        KillTimer(_hwndMB, MBTIMER_DRAGOVER);
        KillTimer(_hwndMB, MBTIMER_EXPAND);
        KillTimer(_hwndMB, MBTIMER_ENDEDIT);
        KillTimer(_hwndMB, MBTIMER_CLOSE);
        KillTimer(_hwndMB, MBTIMER_CLICKUNHANDLE);
        KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);

        DestroyWindow(_hwndMB);
        _hwndMB = NULL;
    }
}

void CMenuToolbarBase::Activate(BOOL fActivate)
{
    if (fActivate == FALSE)
    {
        _fEditMode = FALSE;
    }
}

int CMenuToolbarBase::_CalcChevronSize()
{

    int dSeg;
    int dxy = _pcmb->_pmbm->_cyChevron;

    dxy -= 4;
    dSeg = dxy / 4;

    return dSeg * 4 + 4;
}

void CMenuToolbarBase::_DrawChevron(HDC hdc, LPRECT prect, BOOL fFocus, BOOL fSelected)
{
    RECT rcBox = *prect;
    RECT rcDrop;

    const int dExtra = 3;
    int dxy;

    rcBox.left += dExtra;
    rcBox.right -= dExtra;
    dxy = _CalcChevronSize();

    rcDrop.left = ((rcBox.right + rcBox.left) >> 1) - (dxy/4);
    rcDrop.right = rcDrop.left + dxy - 1;

    int dSeg = ((RECTWIDTH(rcDrop) - 2) >> 2);

    rcDrop.top = (rcBox.top + rcBox.bottom)/2 - (2 * dSeg + 1);
    //rcDrop.bottom = rcBox.top;

    if (fFocus)
    {
        InflateRect(&rcBox, 0, -3);
        SHFillRectClr(hdc, &rcBox, _pcmb->_pmbm->_clrDemoted);
        DrawEdge(hdc, &rcBox, fSelected? BDR_SUNKENINNER : BDR_RAISEDINNER, BF_RECT);

        if (fSelected)
        {
            rcDrop.top += 1;
            rcDrop.left += 1;
        }
    }

    HBRUSH hbrOld = SelectBrush(hdc, _pcmb->_pmbm->_hbrText);


    int y = rcDrop.top + 1;
    int xBase = rcDrop.left+ dSeg;

    for (int x = -dSeg; x <= dSeg; x++)
    {
        PatBlt(hdc, xBase + x, y, 1, dSeg, PATCOPY);
        PatBlt(hdc, xBase + x, y+(dSeg<<1), 1, dSeg, PATCOPY);

        y += (x >= 0) ? -1 : 1;
    }

    SelectBrush(hdc, hbrOld);
}


// Takes into accout Separators, hidden and Disabled items
/*----------------------------------------------------------
Purpose: This function sets the nearest legal button to be
         the hot item, skipping over any separators, or hidden
         or disabled buttons.
    

*/

int CMenuToolbarBase::GetValidHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags)
{
    if (iIndex == MBSI_LASTITEM)
    {
        // -2 is special value meaning "last item on toolbar"
        int cButtons = (int)SendMessage(_hwndMB, TB_BUTTONCOUNT, 0, 0);
        iIndex = cButtons - 1;
    }

    while ( (iCount == -1 || iIndex < iCount) && iIndex >= 0)
    {
        TBBUTTON tbb;

        // Toolbar will trap out of bounds condition when iCount is -1
        if (!SendMessage(_hwndMB, TB_GETBUTTON, iIndex, (LPARAM)&tbb))
            return -1;

        int idCmd = GetButtonCmd(_hwndMB, iIndex);


        if (tbb.fsState & TBSTATE_ENABLED && 
            !(tbb.fsStyle & TBSTYLE_SEP || 
              tbb.fsState & TBSTATE_HIDDEN) &&
              !(v_GetFlags(idCmd) & SMIF_DEMOTED && !_pcmb->_fExpanded) )
        {
            return iIndex;
        }
        else
            iIndex += iDir;
    }

    return -1;
}

BOOL CMenuToolbarBase::SetHotItem(int iDir, int iIndex, int iCount, DWORD dwFlags)
{
    int iPos = GetValidHotItem(iDir, iIndex, iCount, dwFlags);
    if (iPos >= 0)
        SendMessage(_hwndMB, TB_SETHOTITEM2, iPos, dwFlags);

    return (BOOL)(iPos >= 0);
}


static const BYTE g_rgsStateMap[][3] = 
{
#if defined(FIRST)
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    {  4,  1,  2},      // State 2
    { 11,  5,  2},      // State 3
    { 10,  1,  6},      // State 4
    {  7,  1,  2},      // State 5
    {  8,  1,  2},      // State 6
    { 11,  9,  2},      // State 7
    { 10,  1, 10},      // State 8
    { 11,  1,  2},      // State 9
    { 10,  1,  2},      // State 10     // End State
    { 12,  1,  2},      // State 11     // Flash.
    { 10,  1,  2},      // State 12
#elif defined(SECOND)
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    {  4,  1,  2},      // State 2
    { 11,  5,  6},      // State 3
    { 10,  5,  6},      // State 4
    {  7,  5,  6},      // State 5
    {  8,  9,  6},      // State 6
    { 11,  9,  8},      // State 7
    { 10,  9, 10},      // State 8
    { 11,  9,  8},      // State 9
    { 10, 10, 10},      // State 10     // End State
    { 10,  9,  8},      // State 11     // Flash.
    { 10,  9,  8},      // State 12
    { 10,  9,  8},      // State 13
#elif defined(THIRD)
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    { 12,  1,  2},      // State 2
    { 11,  5,  6},      // State 3
    { 10,  5,  6},      // State 4
    {  7,  5,  6},      // State 5
    { 13,  5,  6},      // State 6
    { 11,  9,  8},      // State 7
    { 10,  9, 10},      // State 8
    { 11,  9,  8},      // State 9
    { 10, 10, 10},      // State 10     // End State
    { 10,  9,  8},      // State 11     // Flash.
    {  4,  1,  2},      // State 12
    {  8,  5,  6},      // State 13
#else
//     T,  I,  F
    {  0,  1,  2},      // State 0
    {  3,  1,  2},      // State 1
    {  4,  1,  2},      // State 2
    { 11,  5,  6},      // State 3
    { 10,  5,  6},      // State 4
    {  7,  5,  6},      // State 5
    {  8,  5,  6},      // State 6
    { 11,  9,  8},      // State 7
    { 10,  9, 10},      // State 8
    { 11,  9,  8},      // State 9
    { 10, 10, 10},      // State 10     // End State
    {  4,  3,  4},      // State 11     // Flash.
#endif
};

#define MAX_STATE 13

void CMenuToolbarBase::_FireEvent(BYTE bEvent)
{
    // We don't want to expand and cover up any dialogs.
    if (_fSuppressUserMonitor)
        return;

    if (!_fHasDemotedItems)
        return;

    if (UEM_RESET == bEvent)
    {
        TraceMsg(TF_MENUBAND, "CMTB::UEM Reset state to 0");
        _pcmb->_pmbState->SetUEMState(0);
        return;
    }

    ASSERT(bEvent >= UEM_TIMEOUT && 
            bEvent <= UEM_HOT_FOLDER);

    BYTE bOldState = _pcmb->_pmbState->GetUEMState();
    BYTE bNewState = g_rgsStateMap[_pcmb->_pmbState->GetUEMState()][bEvent];

    ASSERT(bOldState >= 0 &&  bOldState <= MAX_STATE);

    TraceMsg(TF_MENUBAND, "*** UEM OldState (%d), New State (%d) ***", bOldState, bNewState);

    _pcmb->_pmbState->SetUEMState(bNewState);

    switch (bNewState)
    {
    case 10:    // End State
        TraceMsg(TF_MENUBAND, "*** UEM Entering State 10. Expanding *** ", bOldState, bNewState);
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
        if (_pcmb->_fInSubMenu)
        {
            IUnknown_QueryServiceExec(_pcmb->_pmpSubMenu, SID_SMenuBandChild,
                &CGID_MenuBand, MBANDCID_EXPAND, 0, NULL, NULL);
        }
        else
        {
            Expand(TRUE);
        }
        _pcmb->_pmbState->SetUEMState(0);
        break;

    case 11:   // Flash
        // This gets reset when the flash is done...
        TraceMsg(TF_MENUBAND, "*** UEM Entering State 11 Flashing *** ");
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
        _FlashChevron();
        break;
    }
}


void CMenuToolbarBase::_FlashChevron()
{
    if (_idCmdChevron != -1)
    {
        _cFlashCount = 0;
        ToolBar_MarkButton(_hwndMB, _idCmdChevron, FALSE);
        SetTimer(_hwndMB, MBTIMER_FLASH, MBTIMER_FLASHTIME, NULL);
    }
}


LRESULT CMenuToolbarBase::_DefWindowProcMB(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // Are we being asked for the IAccessible for the client?
    if (uMsg == WM_GETOBJECT && (OBJID_CLIENT == (DWORD)lParam))
    {
        // Don't process OBJID_MENU. By the time we get here, we ARE the menu.
        LRESULT lres = 0;
        CAccessible* pacc = new CAccessible(SAFECAST(_pcmb, IMenuBand*));
        if (pacc)
        {
            lres = pacc->InitAcc();
            if (SUCCEEDED((HRESULT)lres))
            {
                lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(pacc, IAccessible*));

                // The correct OLEAcc has been checked into the NT builds, so Oleacc
                // no longer assumes transfer sematics
                if (FAILED((HRESULT)lres))
                    pacc->Release();
            }
            else
            {   // Failed to initialize
                pacc->Release();
            }
        }

        return lres;
    }

    return 0;
}

void CMenuToolbarBase::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    // HACKHACK (lamadio): When we create the menubands, we do not set the
    // TOP level band's fonts until a refresh. This code here fixes it.
    if (_fFirstTime && _pcmb->_fTopLevel)
    {
        SetMenuBandMetrics(_pcmb->_pmbm);
    }

    if (fShow)
    {
        SetKeyboardCue();
        _pcmb->_pmbState->PutTipOnTop();
    }
    else
    {
        _fHasDrop = FALSE;
        KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
        KillTimer(_hwndMB, MBTIMER_INFOTIP);    // Don't show it if we're not displayed :-)
        _pcmb->_pmbState->HideTooltip(TRUE);
    }

    _fSuppressUserMonitor = FALSE;

#ifdef UNIX
    if (_fVerticalMB)
    {
        ToolBar_SetHotItem(_hwndMB, 0);
    }
#endif
}

void CMenuToolbarBase::SetKeyboardCue()
{
    if (_pcmb->_pmbState)
    {
        SendMessage(GetParent(_hwndMB), WM_CHANGEUISTATE, 
            MAKEWPARAM(_pcmb->_pmbState->GetKeyboardCue() ? UIS_CLEAR : UIS_SET,
            UISF_HIDEACCEL), 0);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\mnstatic.cpp ===
#include "priv.h"
#include "sccls.h"
#include "mnstatic.h"
#include "menuband.h"
#include "itbar.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "apithk.h"
#include "menuisf.h"

HMENU g_hmenuStopWatch = NULL;
UINT g_idCmdStopWatch = 0;

//***   IDTTOIDM -- convert idtCmd to idmMenu
// NOTES
//  as an optimization, we make the toolbar idtCmd the same as the menu idm.
// this macro (hopefully) makes things a bit clearer in the code by making
// the type conversion explicit.
#define IDTTOIDM(idtBtn)   (idtBtn)

BOOL TBHasImage(HWND hwnd, int iImageIndex);

//------------------------------------------------------------------------
//
// CMenuStaticToolbar::CMenuStaticData class
//
//------------------------------------------------------------------------


CMenuStaticToolbar::CMenuStaticData::~CMenuStaticData()
{
    ATOMICRELEASE(_punkSubMenu);
}


void CMenuStaticToolbar::CMenuStaticData::SetSubMenu(IUnknown* punk)
{
    ATOMICRELEASE(_punkSubMenu);
    _punkSubMenu = punk;
    if (_punkSubMenu)
        _punkSubMenu->AddRef();
}


HRESULT CMenuStaticToolbar::CMenuStaticData::GetSubMenu(const GUID* pguidService, REFIID riid, void** ppvObj)
{
    if (_punkSubMenu)
    {
        if (pguidService)
        {
            return IUnknown_QueryService(_punkSubMenu, *pguidService, riid, ppvObj);
        }
        else
            return _punkSubMenu->QueryInterface(riid, ppvObj);
    }
    else
        return E_NOINTERFACE;
}



//------------------------------------------------------------------------
//
// CMenuStaticToolbar
//
//------------------------------------------------------------------------



CMenuStaticToolbar::CMenuStaticToolbar(CMenuBand* pmb, HMENU hmenu, HWND hwnd, UINT idCmd, DWORD dwFlags)
    : CMenuToolbarBase(pmb, dwFlags)
{
    _hmenu = hmenu;
    _hwndMenuOwner = hwnd;
    _idCmd = idCmd;
    _iDragOverButton = -1;
    _fDirty = TRUE;
}


CMenuStaticToolbar::~CMenuStaticToolbar()
{
    if (!(_dwFlags & SMSET_DONTOWN))
    {
        DestroyMenu(_hmenu);
    }
}


STDMETHODIMP CMenuStaticToolbar::QueryInterface(REFIID riid, void** ppvObj)
{
    static const QITAB qit[] = 
    {
        QITABENT(CMenuStaticToolbar, IDropTarget),
        { 0 },
    };

    // BUGBUG: If you QI MenuStatic for a drop target, you get a different
    // one than if you QI MenuShellFolder. This breaks COM identity rules.
    // Proper fix would be to implement a drop target that encapsulates both.
    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    if (FAILED(hres))
        hres = CMenuToolbarBase::QueryInterface(riid, ppvObj);

    return hres;
}

void CMenuStaticToolbar::_CheckSeparators()
{
    if (_fHasTopSep)
    {
        if (_pcmb->_pmtbTop->DontShowEmpty() )
        {
            if (!_fTopSepRemoved)
            {
                SendMessage(_hwndMB, TB_DELETEBUTTON, 0, 0);
                _fTopSepRemoved = TRUE;
            }
        }
        else
        {
            if (_fTopSepRemoved)
            {
                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(mii);
                mii.fType = MFT_SEPARATOR;
                _Insert(0, &mii);
                _fTopSepRemoved = FALSE;
            }
        }
    }

    if (_fHasBottomSep)
    {
        if (_pcmb->_pmtbBottom->DontShowEmpty() )
        {
            if (!_fBottomSepRemoved)
            {
                SendMessage(_hwndMB, TB_DELETEBUTTON, ToolBar_ButtonCount(_hwndMB) - 1, 0);
                _fBottomSepRemoved = TRUE;
            }
        }
        else
        {
            if (_fBottomSepRemoved)
            {
                MENUITEMINFO mii = {0};
                mii.cbSize = sizeof(mii);
                mii.fType = SMIT_SEPARATOR;
                _Insert(-1, &mii);
                _fBottomSepRemoved = FALSE;
            }
        }
    }
}


void CMenuStaticToolbar::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    CMenuToolbarBase::v_Show(fShow, fForceUpdate);
    _fShowMB = fShow;
    if (fShow)
    {
        _fFirstTime = FALSE;
        _fClickHandled = FALSE;
        _FillToolbar();
        _pcmb->SetTracked(NULL);
        ToolBar_SetHotItem(_hwndMB, -1);

        // Have the menubar think about changing its height
        IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
            MBCID_SETEXPAND, (int)_pcmb->_fExpanded, NULL, NULL);

        if (fForceUpdate)
            v_UpdateButtons(FALSE);
#if 0
        // need top level frame available for D&D if possible.
        _hwndDD = GetParent(_hwndMB);
        IOleWindow *pOleWindow;
        HRESULT hr = IUnknown_QueryService(_pcmb->_punkSite, SID_STopLevelBrowser
                                                , IID_IOleWindow, (void **)&pOleWindow);
        if(SUCCEEDED(hr))
        { 
            ASSERT(pOleWindow);
            pOleWindow->GetWindow(&_hwndDD);
            pOleWindow->Release();
        }
#endif
        CDelegateDropTarget::Init();
    }
    else
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
    // n.b. for !fShow, we don't kill the tracked site chain.  we
    // count on this in startmnu.cpp!CStartMenuCallback::_OnExecItem,
    // where we walk up the chain to find all hit 'nodes'.  if we need
    // to change this we could fire a 'pre-exec' event.
}

void CMenuStaticToolbar::_Insert(int iIndex, MENUITEMINFO* pmii)
{
    CMenuStaticData* pmsd = new CMenuStaticData();
    if (pmsd)
    {
        BYTE bTBStyle = TBSTYLE_BUTTON | TBSTYLE_DROPDOWN;

        SMINFO sminfo = {0};
        sminfo.dwMask = SMIM_TYPE | SMIM_FLAGS | SMIM_ICON;


        // These are somethings that the callback does not fill in:
        if ( pmii->hSubMenu )
            sminfo.dwFlags |= SMIF_SUBMENU;

        if ( pmii->fState & MFS_CHECKED)
            sminfo.dwFlags |= SMIF_CHECKED;

        if (pmii->fState & MFS_DISABLED || pmii->fState & MFS_GRAYED)
            sminfo.dwFlags |= SMIF_DISABLED;

        if ( pmii->fType & MFT_SEPARATOR)
        {
            sminfo.dwType = SMIT_SEPARATOR;
            bTBStyle &= ~TBSTYLE_BUTTON;
            bTBStyle |= TBSTYLE_SEP;
        }
        else
            sminfo.dwType = SMIT_STRING;

        if (!_fVerticalMB)
            bTBStyle |= TBSTYLE_AUTOSIZE;

        if (S_OK != CallCB(pmii->wID, SMC_GETINFO, 0, (LPARAM)&sminfo))
        {
            sminfo.iIcon = -1;
        }

        pmsd->_dwFlags = sminfo.dwFlags;

        // Now add it to the toolbar
        TBBUTTON tbb = {0};

        tbb.iBitmap = sminfo.iIcon;
        tbb.idCommand = pmii->wID;
        tbb.dwData = (DWORD_PTR)pmsd;
        tbb.fsState = (sminfo.dwFlags & SMIF_HIDDEN)?TBSTATE_HIDDEN : TBSTATE_ENABLED;
        tbb.fsStyle = bTBStyle; 

        TCHAR szMenuString[MAX_PATH];

        if (pmii->fType & MFT_OWNERDRAW)
        {
            // dwTypeData is user defined 32 bit value, not a string if MFT_OWNERDRAW is set
            // then the (unicode) string is the very first element in a structure dwItemData
            // points to
            LPWSTR pwsz = (LPWSTR)pmii->dwItemData;
            SHUnicodeToTChar(pwsz, szMenuString, ARRAYSIZE(szMenuString));
            tbb.iString = (INT_PTR)(szMenuString);
        }
        else
            tbb.iString = (INT_PTR)(LPTSTR)pmii->dwTypeData;

        SendMessage(_hwndMB, TB_INSERTBUTTON, iIndex, (LPARAM)&tbb);
    }
}


/*----------------------------------------------------------
Purpose: GetMenu method

*/
HRESULT CMenuStaticToolbar::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{
    if (phmenu)
        *phmenu = _hmenu;
    if (phwnd)
        *phwnd = _hwndMenuOwner;
    if (pdwFlags)
        *pdwFlags = _dwFlags;

    return NOERROR;
}

HRESULT CMenuStaticToolbar::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{
    // When we are merging in a new menu, we need to destroy the old one if we own it.
    if (_hmenu && !(_dwFlags & SMSET_DONTOWN))
    {
        DestroyMenu(_hmenu);
    }

    _hmenu = hmenu;
    // If we're processing a change notify, we cannot do anything that will modify state.
    if (_pcmb->_pmbState && 
        _pcmb->_pmbState->IsProcessingChangeNotify())
    {
        _fDirty = TRUE;
    }
    else
    {
        EmptyToolbar();
        _pcmb->_fInSubMenu = FALSE;
        IUnknown_SetSite(_pcmb->_pmpSubMenu, NULL);
        ATOMICRELEASE(_pcmb->_pmpSubMenu);

        if (_fShowMB)
            _FillToolbar();

        BOOL fSmooth = FALSE;
#ifdef CLEARTYPE    // Don't use SPI_CLEARTYPE because it's defined because of APIThk, but not in NT.
        SystemParametersInfo(SPI_GETCLEARTYPE, 0, &fSmooth, 0);
#endif

        // This causes a paint to occur right away instead of waiting until the
        // next message dispatch which could take a noticably long time.
        RedrawWindow(_hwndMB, NULL, NULL, (fSmooth? RDW_ERASE: 0) | RDW_INVALIDATE | RDW_UPDATENOW);  
    }
    return NOERROR;
}


CMenuStaticToolbar::CMenuStaticData* CMenuStaticToolbar::_IDToData(int idCmd)
{
    CMenuStaticData* pmsd= NULL;

    // Initialize to NULL in case the GetButtonInfo Fails. We won't fault because
    // the lParam is just stack garbage. 
    TBBUTTONINFO tbbi = {0};
    int iPos;

    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_LPARAM;

    iPos = ToolBar_GetButtonInfo(_hwndMB, idCmd, &tbbi);
    if (iPos >= 0)
        pmsd = (CMenuStaticData*)tbbi.lParam;

    return pmsd;
}

HRESULT CMenuStaticToolbar::v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj) 
{
    HRESULT hres = E_OUTOFMEMORY;
    int iPos = (int)SendMessage(_hwndMB, TB_COMMANDTOINDEX, idCmd, 0);

    if (iPos >= 0)
    {
        CTrackPopupBar* ptpb = new CTrackPopupBar(_pcmb->_pmbState->GetContext(), iPos, _hmenu, _hwndMenuOwner);

        if (ptpb)
        {
            hres = ptpb->QueryInterface(riid, ppvObj);
            if (SUCCEEDED(hres))
                IUnknown_SetSite(SAFECAST(ptpb, IMenuPopup*), SAFECAST(_pcmb, IMenuPopup*));

            PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), g_nMBAutomation, (WPARAM)_hmenu, (LPARAM)iPos);
            ptpb->Release();
        }
    }

    return hres;
}

HRESULT CMenuStaticToolbar::v_GetSubMenu(int idCmd, const GUID* pguidService, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    CMenuStaticData* pmsd = _IDToData(idCmd);

    ASSERT(IS_VALID_WRITE_PTR(ppvObj, void*));

    *ppvObj = NULL;

    if (pmsd)
    {
        // Get the cached submenu
        hres = pmsd->GetSubMenu(pguidService, riid, ppvObj);

        // Did that fail?
        if (FAILED(hres) && (pmsd->_dwFlags & SMIF_SUBMENU) && 
            IsEqualGUID(riid, IID_IShellMenu))
        {
            // Yes; ask the callback for it
            hres = CallCB(idCmd, SMC_GETOBJECT, (WPARAM)&riid, (LPARAM)ppvObj);

            if (S_OK != hres)
            {
                hres = E_OUTOFMEMORY;   // Set to error case incase something happens

                // Callback didn't handle it, try and see if we can get it
                MENUITEMINFO mii;
                mii.cbSize = sizeof(MENUITEMINFO);
                mii.fMask = MIIM_SUBMENU | MIIM_ID;
                if (GetMenuItemInfoWrap(_hmenu, idCmd, MF_BYCOMMAND, &mii) && mii.hSubMenu)
                {
                    IShellMenu* psm = (IShellMenu*)new CMenuBand();
                    if (psm)
                    {
                        UINT uIdAncestor = _pcmb->_uIdAncestor;
                        if (uIdAncestor == ANCESTORDEFAULT)
                            uIdAncestor = idCmd;

                        psm->Initialize(_pcmb->_psmcb, idCmd, uIdAncestor, SMINIT_VERTICAL);
                        psm->SetMenu(mii.hSubMenu, _hwndMenuOwner, SMSET_TOP | SMSET_DONTOWN);
                        hres = psm->QueryInterface(riid, ppvObj);
                        psm->Release();
                    }
                }
            }

            if (*ppvObj)
            {
                // Cache it now
                pmsd->SetSubMenu((IUnknown*)*ppvObj);

                // Initialize the fonts
                VARIANT Var;
                Var.vt = VT_UNKNOWN;
                Var.byref = SAFECAST(_pcmb->_pmbm, IUnknown*);
                IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);

                // Set the CMenuBandState  into the new menuband
                Var.vt = VT_INT_PTR;
                Var.byref = _pcmb->_pmbState;
                IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETSTATEOBJECT, 0, &Var, NULL);

            }
        }
    }

    return hres;
}


HRESULT CMenuStaticToolbar::v_GetInfoTip(int idCmd, LPTSTR psz, UINT cch)
{
    return CallCB(idCmd, SMC_GETINFOTIP, (WPARAM)psz, (LPARAM)cch);
}


HRESULT CMenuStaticToolbar::v_ExecItem(int idCmd)
{
    HRESULT hres = CallCB(idCmd, SMC_EXEC, 0, 0);

    if (S_OK != hres && _hwndMenuOwner)
    {
        PostMessage(_hwndMenuOwner, WM_COMMAND, idCmd, 0);
        hres = NOERROR;
    }

    return hres;
}

DWORD CMenuStaticToolbar::v_GetFlags(int idCmd)
{
    CMenuStaticData* pmsd = _IDToData(idCmd);

    // Toolbar is allowed to pass a bad command in the case of erasing the background
    if (pmsd)
    {
        return pmsd->_dwFlags;
    }
    else
        return 0;
}


void CMenuStaticToolbar::v_SendMenuNotification(UINT idCmd, BOOL fClear)
{
    if (S_FALSE == CallCB(idCmd, SMC_SELECTITEM, (WPARAM)fClear, 0))
    {
        UINT uFlags = (UINT)-1;
        if (v_GetFlags(idCmd) & SMIF_SUBMENU)
             uFlags = MF_POPUP;

        if (!fClear)
            uFlags = MF_HILITE;

        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), WM_MENUSELECT,
            MAKEWPARAM(idCmd, uFlags), fClear? NULL : (LPARAM)_hmenu);

    }
}

BOOL CMenuStaticToolbar::v_TrackingSubContextMenu()
{
    return (_pcm != NULL);
}

void CMenuStaticToolbar::CreateToolbar(HWND hwndParent)
{
    if (!_hwndMB)
    {
        _hwndMB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, TEXT("Menu"),
                                 WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                 CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                 CCS_NORESIZE  | TBSTYLE_REGISTERDROP,
                                 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);

        if (!_hwndMB)
        {
            TraceMsg(TF_MENUBAND, "CMenuStaticToolbar::CreateToolbar: Failed to Create Toolbar");
            return;
        }

        SendMessage(_hwndMB, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndMB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        // Set the format to ANSI or UNICODE as appropriate.
        ToolBar_SetUnicodeFormat(_hwndMB, DLL_IS_UNICODE);

        _SubclassWindow(_hwndMB);
        _RegisterWindow(_hwndMB, NULL, SHCNE_UPDATEIMAGE);
        SIZE size;
        RECT rc;

        SystemParametersInfoA(SPI_GETWORKAREA, SIZEOF(RECT), &rc, FALSE);
        //HACKHACK:  THIS WILL FORCE NO WRAP TO HAPPEN FOR PROPER WIDTH CALC WHEN PAGER IS PRESENT.
        size.cx = RECTWIDTH(rc);
        size.cy = 32000;
        ToolBar_SetBoundingSize(_hwndMB, &size);
        CMenuToolbarBase::CreateToolbar(hwndParent);
    }
    else if (GetParent(_hwndMB) != hwndParent)
    {
        ::SetParent(_hwndMB, hwndParent);
    }
}


STDMETHODIMP CMenuStaticToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    if (SHCNE_UPDATEIMAGE == lEvent) // global
    {
        if (pidl1)
        {
            int iImage = *(int UNALIGNED *)((BYTE *)pidl1 + 2);

            IEInvalidateImageList();    // We may need to use different icons.
            if ( pidl2 )
            {
                iImage = SHHandleUpdateImage( pidl2 );
                if ( iImage == -1 )
                {
                    return E_FAIL;
                }
            }
            
            if (iImage == -1 || TBHasImage(_hwndMB, iImage))
            {
                v_Refresh();
            }
        } 
        else
        {
            v_Refresh();
        }

        return S_OK;
    }

    return E_FAIL;
}


LRESULT CMenuStaticToolbar::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    switch(uMessage)
    {
    case WM_TIMER:
        if (_OnTimer(wParam)) 
            return 1;
        break;
    case WM_GETOBJECT:
        // Yet another poor design choice on the part of the accessibility team.
        // Typically, if you do not answer a WM_* you return 0. They choose 0 as their success
        // code.
        return _DefWindowProcMB(hwnd, uMessage, wParam, lParam);
        break;

    }

    return CNotifySubclassWndProc::_DefWindowProc(hwnd, uMessage, wParam, lParam);
}


//***
// NOTES
//  idtCmd is currently always -1.  we'll need other values when we're
// called from CallCB.  however we can't do that until we fix mnfolder.cpp.
HRESULT CMenuStaticToolbar::v_GetState(int idtCmd, LPSMDATA psmd)
{
    psmd->dwMask = SMDM_HMENU;

    psmd->hmenu = _hmenu;
    psmd->hwnd = _hwndMenuOwner;
    psmd->uIdParent = _idCmd;
    if (idtCmd == -1)
        idtCmd = GetButtonCmd(_hwndMB, ToolBar_GetHotItem(_hwndMB));
    psmd->uId = IDTTOIDM(idtCmd);
    psmd->punk = SAFECAST(_pcmb, IShellMenu*);
    psmd->punk->AddRef();

    return S_OK;
}

HRESULT CMenuStaticToolbar::CallCB(UINT idCmd, DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    if (!_pcmb->_psmcb)
        return S_FALSE;

    SMDATA smd;
    HRESULT hres = S_FALSE;

    // todo: call v_GetState (but see comment in mnfolder.cpp)
    smd.dwMask = SMDM_HMENU;

    smd.hmenu = _hmenu;
    smd.hwnd = _hwndMenuOwner;
    smd.uIdParent = _idCmd;
    smd.uIdAncestor = _pcmb->_uIdAncestor;
    smd.uId = idCmd;
    smd.punk = SAFECAST(_pcmb, IShellMenu*);
    smd.pvUserData = _pcmb->_pvUserData;

    hres = _pcmb->_psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    return hres;
}

HRESULT CMenuStaticToolbar::v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    int idm;

    idm = IDTTOIDM(idtCmd);
    return CallCB(idm, uMsg, wParam, lParam);
}



void CMenuStaticToolbar::v_UpdateButtons(BOOL fNegotiateSize)
{
    if (_hwndMB)
    {
        _SetToolbarState();
        int cxMin, cxMax;
        v_CalcWidth(&cxMin, &cxMax);

        SendMessage(_hwndMB, TB_SETBUTTONWIDTH, 0, MAKELONG(cxMin, cxMax));
        SendMessage(_hwndMB, TB_AUTOSIZE, 0, 0);

        // Should we renegotiate size? AND are we vertical,
        // because we cannot renegoitate when horizontal.
        if (fNegotiateSize && _fVerticalMB)
            NegotiateSize();
    }
}


BOOL CMenuStaticToolbar::v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    if (-1 == uIconSize)
        uIconSize = _uIconSizeMB;
    BOOL fChanged = (_uIconSizeMB != uIconSize);
    
    _uIconSizeMB = uIconSize;

    if (_hwndMB)
    {
        HIMAGELIST himl = NULL;
        if (_fVerticalMB)
        {
            HIMAGELIST himlLarge, himlSmall;

            // set the imagelist size
            Shell_GetImageLists(&himlLarge, &himlSmall);
            himl = (_uIconSizeMB == ISFBVIEWMODE_LARGEICONS ) ? himlLarge : himlSmall;
        }

        // sending a null himl is significant..  it means no image list
        SendMessage(_hwndMB, TB_SETIMAGELIST, 0, (LPARAM)himl);
                
        if (fUpdateButtons)
            v_UpdateButtons(TRUE);
    }
    
    return fChanged;
}


void CMenuStaticToolbar::_OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode) 
{
    LPNMTBDISPINFO pdi = (LPNMTBDISPINFO)pnm;
    CMenuStaticData* pdata = (CMenuStaticData*)pdi->lParam;
    
    if(pdi->dwMask & TBNF_IMAGE) 
    {
        if (_fVerticalMB)
        {
            SMINFO smi;
            smi.dwMask = SMIM_ICON;
            if (CallCB(pdi->idCommand, SMC_GETINFO, 0, (LPARAM)&smi) == S_OK)
                pdi->iImage = smi.iIcon;
            else
                pdi->iImage = -1;
        }
        else
            pdi->iImage = -1;

    }
    
    if(pdi->dwMask & TBNF_TEXT) 
    {
        if(pdi->pszText) 
        {
            if(fUnicode) 
            {
                pdi->pszText[0] = TEXT('\0');
            }
            else 
            {
                pdi->pszText[0] = 0;
            }
        }
    }
    pdi->dwMask |= TBNF_DI_SETITEM;

    return;
}

LRESULT CMenuStaticToolbar::_OnGetObject(NMOBJECTNOTIFY* pon)
{
    pon->hResult = QueryInterface(*pon->piid, &pon->pObject);

    return 1;
}


LRESULT CMenuStaticToolbar::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;

    switch (pnm->code)
    {
    case TBN_DRAGOUT:
        lres = 0;
        break;
    
    case TBN_DELETINGBUTTON:
    {
        if (!_fEmptyingToolbar)
        {
            TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
            CMenuStaticData* pmsd = (CMenuStaticData*)ptbn->tbButton.dwData;
            if (pmsd)
                delete pmsd;
        }
        break;    
    }

    case NM_TOOLTIPSCREATED:
        SHSetWindowBits(((NMTOOLTIPSCREATED*)pnm)->hwndToolTips, GWL_STYLE, TTS_ALWAYSTIP | TTS_TOPMOST, TTS_ALWAYSTIP | TTS_TOPMOST);
        SendMessage(((NMTOOLTIPSCREATED*)pnm)->hwndToolTips, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)MAXSHORT);        
        break;

    case NM_RCLICK:
        lres = _OnContextMenu(NULL, GetMessagePos());
        break;

    case NM_CUSTOMDRAW:
        lres =  _OnCustomDraw((NMCUSTOMDRAW*)pnm);
        g_hmenuStopWatch = _hmenu;
        g_idCmdStopWatch = _idCmd;
        break;
    
    case  TBN_GETDISPINFOA:
        _OnGetDispInfo(pnm,  FALSE);
        break;
    
    case  TBN_GETDISPINFOW:
        _OnGetDispInfo(pnm,  TRUE);
        break;

    case TBN_GETOBJECT:
        lres = _OnGetObject((NMOBJECTNOTIFY*)pnm);
        break;

    case TBN_MAPACCELERATOR:
        lres = _OnAccelerator((NMCHAR*)pnm);
        break;

    default:
        lres = CMenuToolbarBase::_OnNotify(pnm);

    }

    return(lres);
}

void CMenuStaticToolbar::_FillToolbar()
{
    if (_fDirty && _hmenu && _hwndMB && !_pcmb->_fClosing)
    {
        EmptyToolbar();
        BOOL_PTR fRedraw = SendMessage(_hwndMB, WM_SETREDRAW, FALSE, 0);

        TCHAR szName[MAX_PATH];
        MENUITEMINFO mii;
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE | MIIM_STATE | MIIM_DATA;

        int iCount = GetMenuItemCount(_hmenu);
        for (int i = 0; i < iCount; i++)
        {
            mii.dwTypeData = szName;
            mii.cch = ARRAYSIZE(szName);
            if (GetMenuItemInfoWrap(_hmenu, i, MF_BYPOSITION, &mii))
            {
                if (mii.fType & MFT_SEPARATOR)
                {
                    if (i == 0)
                        _fHasTopSep = TRUE;
                    else if (i == iCount - 1)
                        _fHasBottomSep = TRUE;
                }

                _Insert(i, &mii);
            }
        }

        if (iCount == 0)
            _fEmpty = TRUE;

        SendMessage(_hwndMB, WM_SETREDRAW, fRedraw, 0);

        _fDirty = FALSE;
        v_UpdateButtons(FALSE);
        _pcmb->ResizeMenuBar();
    }
}

void CMenuStaticToolbar::v_OnDeleteButton(LPVOID pData)
{
    CMenuStaticData* pmsd = (CMenuStaticData*)pData;
    if (pmsd)
        delete pmsd;
}

void CMenuStaticToolbar::v_OnEmptyToolbar()
{
    CMenuToolbarBase::v_OnEmptyToolbar();
    _fDirty = TRUE;
    _fHasTopSep = FALSE;
    _fHasBottomSep = FALSE;
    _fTopSepRemoved = FALSE;
    _fBottomSepRemoved = FALSE;
}

void CMenuStaticToolbar::v_Close()
{
    if (_hwndMB)
    {
        _UnregisterWindow(_hwndMB);
        _UnsubclassWindow(_hwndMB);
    }
    CMenuToolbarBase::v_Close();
}

void CMenuStaticToolbar::v_Refresh()
{
    EmptyToolbar();
    _FillToolbar();
}


/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner method

         Processes messages passed on from the menuband.
*/
STDMETHODIMP CMenuStaticToolbar::IsWindowOwner(HWND hwnd) 
{ 
    if ( hwnd == _hwndMB || hwnd == HWND_BROADCAST) 
    {
        return S_OK;
    }
    else
    {
        return S_FALSE;
    }
}




/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetWindowsDDT

*/
HRESULT CMenuStaticToolbar::GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll) 
{ 
    *phwndLock = _hwndMB;
    *phwndScroll = _hwndMB; 
    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::HitTestDDT

*/
HRESULT CMenuStaticToolbar::HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect)
{
    switch (nEvent)
    {
    case HTDDT_ENTER:
        // OLE is in its modal drag/drop loop, and it has the capture.
        // We shouldn't take the capture back during this time.
        if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP))
        {
            _pcmb->_pmbState->HasDrag(TRUE);
            GetMessageFilter()->PreventCapture(TRUE);
            if (_pcmb->_pmtbShellFolder &&
                _pcmb->_pmtbShellFolder->DontShowEmpty())
            {
                DAD_ShowDragImage(FALSE);
                _pcmb->_pmtbShellFolder->DontShowEmpty(FALSE);
                _pcmb->ResizeMenuBar();
                UpdateWindow(_hwndMB);
                DAD_ShowDragImage(TRUE);
            }
            return S_OK;
        }
        else
            return S_FALSE;

    case HTDDT_OVER:
        {
            TBINSERTMARK tbim;
            *pdwEffect = DROPEFFECT_NONE;

            POINT pt = *ppt;

            if (!ToolBar_InsertMarkHitTest(_hwndMB, &pt, &tbim))
            {
                int idCmd = GetButtonCmd(_hwndMB, tbim.iButton);
                if (v_GetFlags(idCmd) & SMIF_DROPCASCADE &&
                    tbim.iButton != _iDragOverButton)
                {
                    DAD_ShowDragImage(FALSE);
                    _pcmb->SetTracked(this);
                    _iDragOverButton = tbim.iButton;
                    SetTimer(_hwndMB, MBTIMER_DRAGOVER, MBTIMER_TIMEOUT, NULL);
                    _pcmb->_SiteOnSelect(MPOS_CHILDTRACKING);
                    BOOL_PTR fOldAnchor = ToolBar_SetAnchorHighlight(_hwndMB, FALSE);
                    ToolBar_SetHotItem(_hwndMB, _iDragOverButton);
                    ToolBar_SetAnchorHighlight(_hwndMB, fOldAnchor);
                    UpdateWindow(_hwndMB);
                    DAD_ShowDragImage(TRUE);
                }
            }
        }
        break;

    case HTDDT_LEAVE:
        // We can take the capture back anytime now
        _pcmb->_pmbState->HasDrag(FALSE);
        _SetTimer(MBTIMER_DRAGPOPDOWN);
        GetMessageFilter()->PreventCapture(FALSE);
        _iDragOverButton = -1;
#if 0
        DAD_ShowDragImage(FALSE);
        ToolBar_SetHotItem(_hwndMB, -1);
        DAD_ShowDragImage(TRUE);
#endif
        break;
    }
    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetObjectDDT

*/
HRESULT CMenuStaticToolbar::GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj)
{
    return E_NOTIMPL;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::OnDropDDT

*/
HRESULT CMenuStaticToolbar::OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, 
                            DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return E_NOTIMPL;
}



HRESULT CMenuStaticToolbar::v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    HRESULT hres = S_FALSE;

    if (NULL == psmd)
    {
        if (dwFlags & SMINV_REFRESH)
        {
            // Refresh the whole thing
            v_Refresh();
            hres = TRUE;
        }
    }

    // Are we dealing with an Hmenu?
    // Have we filled it yet?  (If not, then we can skip the invalidate
    // here, because we'll catch it when we fill it.)
    else if ((psmd->dwMask & SMDM_HMENU) && !_fDirty)
    {
        // Yes; What are they asking for?

        int iPos = -1;   // Assume this is a position
        int idCmd = -1;

        // Did they pass an ID instead of a position?
        if (dwFlags & SMINV_ID)
        {
            // Yes; Crack out the position.
            iPos = GetMenuPosFromID(_hmenu, psmd->uId);
            idCmd = psmd->uId;
        }

        if (dwFlags & SMINV_POSITION)
        {
            iPos = psmd->uId;
            idCmd = GetMenuItemID(_hmenu, iPos);
        }


        if (dwFlags & SMINV_REFRESH)
        {
            // Do they want to refresh a sepcific button?
            if (idCmd >= 0)
            {
                // Yes;

                // First delete the old one if it exists.
                int iTBPos = ToolBar_CommandToIndex(_hwndMB, idCmd);

                if (iTBPos >= 0)
                    SendMessage(_hwndMB, TB_DELETEBUTTON, iTBPos, 0);

                // Now Insert a new one
                MENUITEMINFO mii;
                TCHAR szName[MAX_PATH];
                mii.cbSize = sizeof(mii);
                mii.cch = ARRAYSIZE(szName);
                mii.dwTypeData = szName;
                mii.fMask = MIIM_ID | MIIM_SUBMENU | MIIM_TYPE | MIIM_STATE | MIIM_DATA;

                // This can fail...
                if (GetMenuItemInfoWrap(_hmenu, iPos, MF_BYPOSITION, &mii))
                {
                    _Insert(iPos, &mii);
                    hres = S_OK;
                }
            }
            else
            {
                // No; Refresh the whole thing
                v_Refresh();
            }

            if (!_fShowMB)
                _pcmb->_fForceButtonUpdate = TRUE;

            _pcmb->ResizeMenuBar();
        }
    }

    return hres;
}

void CMenuStaticToolbar::GetSize(SIZE* psize)
{
    _CheckSeparators();

    CMenuToolbarBase::GetSize(psize);
}

LRESULT CMenuStaticToolbar::_OnAccelerator(NMCHAR* pnmChar)
{
    SMDATA smdOut = {0};
    SMDATA smd = {0};
    smd.punk = SAFECAST(_pcmb, IShellMenu*);
    smd.uIdParent = _pcmb->_uId;

    if (_pcmb->_psmcb &&
        S_FALSE != _pcmb->_psmcb->CallbackSM(&smd, SMC_MAPACCELERATOR, (WPARAM)pnmChar->ch, (LPARAM)&smdOut))
    {
        pnmChar->dwItemNext = ToolBar_CommandToIndex(_hwndMB, smdOut.uId);;
        return TRUE;
    }

    return FALSE;
}

LRESULT CMenuStaticToolbar::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    MyLockSetForegroundWindow(FALSE);

    if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_CONTEXTMENU))
    {
        RECT rc;
        LPRECT prcExclude = NULL;
        POINT pt;
        int i;

        if (lParam != (LPARAM)-1) 
        {
            pt.x = GET_X_LPARAM(lParam);
            pt.y = GET_Y_LPARAM(lParam);

            POINT pt2 = pt;
            MapWindowPoints(HWND_DESKTOP, _hwndMB, &pt2, 1);

            i = ToolBar_HitTest(_hwndMB, &pt2);
        } 
        else 
        {
            // keyboard context menu.
            i = (int)SendMessage(_hwndMB, TB_GETHOTITEM, 0, 0);
            if (i >= 0) 
            {
                SendMessage(_hwndMB, TB_GETITEMRECT, i, (LPARAM)&rc);
                MapWindowPoints(_hwndMB, HWND_DESKTOP, (LPPOINT)&rc, 2);
                pt.x = rc.left;
                pt.y = rc.bottom;
                prcExclude = &rc;
            }
        }
        if (i >= 0)
        {
            UINT idCmd = GetButtonCmd(_hwndMB, i);
            if (S_OK == CallCB(idCmd, SMC_GETOBJECT, (WPARAM)(GUID*)&IID_IContextMenu, (LPARAM)(VOID**)(&_pcm)))
            {
                TPMPARAMS tpm;
                TPMPARAMS * ptpm = NULL;

                if (prcExclude)
                {
                    tpm.cbSize = SIZEOF(tpm);
                    tpm.rcExclude = *((LPRECT)prcExclude);
                    ptpm = &tpm;
                }
                HMENU hmenu = CreatePopupMenu();
                if (hmenu)
                {
                    KillTimer(_hwndMB, MBTIMER_INFOTIP);
                    _pcmb->_pmbState->HideTooltip(FALSE);

                    _pcm->QueryContextMenu(hmenu, 0, 0, -1, 0);

                    idCmd = TrackPopupMenuEx(hmenu,
                        TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
                        pt.x, pt.y, _hwndMB, ptpm);

                    CMINVOKECOMMANDINFO ici = {
                        SIZEOF(CMINVOKECOMMANDINFO),
                        0,
                        _hwndMB,
                        MAKEINTRESOURCEA(idCmd),
                        NULL, NULL,
                        SW_NORMAL,
                    };

                    _pcm->InvokeCommand(&ici);

                    DestroyMenu(hmenu);
                }

                ATOMICRELEASE(_pcm);
            }
        }

        GetMessageFilter()->RetakeCapture();
    }

    return lres;
}

STDMETHODIMP CMenuStaticToolbar::OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    if (WM_CONTEXTMENU == dwMsg)
    {
        *plres = _OnContextMenu(wParam, lParam);
    }
    else
        return CMenuToolbarBase::OnWinEvent(hwnd, dwMsg, wParam, lParam, plres);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\qlink.h ===
#ifndef QLINK_H_
#define QLINK_H_

// Length of the text under each quick links
#define MAX_QL_TEXT_LENGTH      256
#define MAX_QL_WIDTH            92


HRESULT CQuickLinks_CreateInstance(IDeskBand **ppunk);
#define QLCMD_SINGLELINE 1

#endif // QLINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\mnfolder.cpp ===
#include "priv.h"
#include "sccls.h"
#include "menuband.h"
#include "itbar.h"
#include "dpastuff.h"       // COrderList_*
#include "resource.h"
#include "mnbase.h"
#include "oleacc.h"
#include "apithk.h"
#include "menuisf.h"
#include "mnfolder.h"
#include "icotask.h"
#include "mluisupp.h"

#define PGMP_RECALCSIZE  200

#define SIL_GetType(pidl)       (ILIsEmpty(pidl) ? 0 : (pidl)->mkid.abID[0])


//-------------------------------------------------------------------------
//
//  Non-Member functions
//
//-------------------------------------------------------------------------


HRESULT IUnknown_RefreshParent(IUnknown* punk, LPCITEMIDLIST pidl, DWORD dwFlags)
{
    IShellMenu* psm;
    HRESULT hres = IUnknown_QueryService(punk, SID_SMenuBandParent, 
            IID_IShellMenu, (void **)&psm);
    if (SUCCEEDED(hres))
    {
        LPITEMIDLIST pidlParent = ILClone(pidl);
        if (pidlParent)
        {
            SMDATA smd;
            ILRemoveLastID(pidlParent);
            smd.dwMask = SMDM_SHELLFOLDER;
            smd.pidlFolder = pidlParent;
            smd.pidlItem = ILFindLastID(pidl);
            hres = psm->InvalidateItem(&smd, dwFlags);
            ILFree(pidlParent);
        }
        psm->Release();
    }

    return hres;
}



//-------------------------------------------------------------------------
//
//  CMenuData class
//
//-------------------------------------------------------------------------


void CMenuData::SetSubMenu(IUnknown* punk)
{
    ATOMICRELEASE(_punkSubmenu);
    _punkSubmenu = punk;
    if (_punkSubmenu)
        _punkSubmenu->AddRef();
}

HRESULT CMenuData::GetSubMenu(const GUID* pguidService, REFIID riid, void** ppv)
{
    // pguidService is for asking specifically for the Shell Folder portion or the Static portion
    if (_punkSubmenu)
    {
        if (pguidService)
        {
            return IUnknown_QueryService(_punkSubmenu, *pguidService, riid, ppv);
        }
        else
            return _punkSubmenu->QueryInterface(riid, ppv);
    }
    else
        return E_NOINTERFACE;
}

CMenuData::~CMenuData()
{
    ATOMICRELEASE(_punkSubmenu);
}

STDMETHODIMP CMenuSFToolbar::QueryInterface(REFIID riid, void** ppvObj)
{
    HRESULT hres = CMenuToolbarBase::QueryInterface(riid, ppvObj);
    
    if (FAILED(hres))
        hres = CSFToolbar::QueryInterface(riid, ppvObj); 
    
    return hres;
}

//-------------------------------------------------------------------------
//
//  CMenuSFToolbar class
//
//-------------------------------------------------------------------------


STDMETHODIMP CMenuSFToolbar::SetSite(IUnknown* punkSite)
{
    HRESULT hres = CMenuToolbarBase::SetSite(punkSite);
    if (SUCCEEDED(hres)) 
    {
        _fMulticolumnMB = BOOLIFY(_pcmb->_dwFlags & SMINIT_MULTICOLUMN);
        _fMulticolumn = _fMulticolumnMB;
        _fVertical = _fVerticalMB;
        if (_fVerticalMB)
            _dwStyle |= CCS_VERT;

    }
    return hres;
}

CMenuSFToolbar::CMenuSFToolbar(CMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, HKEY hKey, DWORD dwFlags) 
    : CMenuToolbarBase(pmb, dwFlags)
{
    // Change this to IStream
    _hKey = hKey;

    // Do we have a place to persist our reorder?
    if (_hKey == NULL)
    {
        // No, then don't allow it.
        _fAllowReorder = FALSE;
    }


    _dwStyle |= TBSTYLE_REGISTERDROP;
    _dwStyle &= ~TBSTYLE_TOOLTIPS;      // We handle our own tooltips.

    _iDefaultIconIndex = -1;

    SetShellFolder(psf, pidl);

    _AfterLoad();
}

HRESULT CMenuSFToolbar::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hres = CSFToolbar::SetShellFolder(psf, pidl);
    ATOMICRELEASE(_pasf2);

    if (psf)
        psf->QueryInterface(IID_IAugmentedShellFolder2, (void**)&_pasf2);

    return hres;
}


CMenuSFToolbar::~CMenuSFToolbar()
{
    ASSERT(_pcmb->_cRef == 0 || _pcmb->_pmtbShellFolder == NULL);
    _hwndWorkerWindow = NULL;       // This is destroyed by the _pmbState destructor. 
                                    // Prevent a double delete which happens in the base class.
    ATOMICRELEASE(_pasf2);
    if (_hKey)
        RegCloseKey(_hKey);
}


void CMenuSFToolbar::v_Close()
{
    // We should save this so that we know when a new item is added.
    _SaveOrderStream();
    CMenuToolbarBase::EmptyToolbar();
    _UnregisterToolbar();

    if (_hwndPager)
    {
        DestroyWindow(_hwndPager);  // Should Destroy Toolbar.
    }
    else if (_hwndMB)
    {
        // In the MultiColumn case, there is no pager so we have to 
        // manually destroy the Toolbar
        DestroyWindow(_hwndMB);
    }

    _hwndPager = NULL;
    _hwndMB = NULL;
    _hwndTB = NULL;
}


PIBDATA CMenuSFToolbar::_CreateItemData(PORDERITEM poi)
{
    return (PIBDATA)new CMenuData(poi);
}


HRESULT CMenuSFToolbar::_AfterLoad()
{
    HRESULT hres = CSFToolbar::_AfterLoad();

    if (SUCCEEDED(hres))
        _LoadOrderStream();

    return hres;
}


HRESULT CMenuSFToolbar::_LoadOrderStream()
{
    OrderList_Destroy(&_hdpaOrder);
    IStream* pstm;
    HRESULT hres = E_FAIL;

    if (_hKey)
    {
        // We use "Menu" for Backwards compatibility with shdoc401 start menu, but having no
        // sub key is more correct (Other places use it) so on NT5 we use the new method.
        pstm = SHOpenRegStream(_hKey, (_pcmb->_dwFlags & SMINIT_LEGACYMENU) ? TEXT("Menu") : TEXT(""),
            TEXT("Order"), STGM_READ);
    }
    else
    {
        if (S_FALSE == CallCB(NULL, SMC_GETSFOBJECT, (WPARAM)(GUID*)&IID_IStream, (LPARAM)(void**)&pstm))
            pstm = NULL;
    }

    if (pstm)
    {
        hres = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);
        _fHasOrder = FALSE;
        _fAllowReorder = TRUE;

        // Check to see if we have a persisted order. If we don't have a persisted order,
        // then all of the items are -1. If just one of those has a number other than
        // -1, then we do have "Order" and should use that instead of alphabetizing.
        if (_hdpaOrder)
        {
            for (int i = 0; !_fHasOrder && i < DPA_GetPtrCount(_hdpaOrder); i++) 
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpaOrder, i);
                if (poi->nOrder != MNFOLDER_NORODER)
                    _fHasOrder = TRUE;
            }
        }
        pstm->Release();
    }
    return hres;
}

HRESULT CMenuSFToolbar::_SaveOrderStream()
{
    IStream* pstm;
    HRESULT hres = E_FAIL;

    // Persist the new order out to the registry
    // It is reasonable to assume that if we don't have an _hdpa we have
    // not filled the toolbar yet. Since we have not filled it, we haven't changed
    // the order, so we don't need to persist out that order information.
    if(_hdpa)
    {
        // Always save this information
        _FindMinPromotedItems(TRUE);

        // Did we load an order stream when we initialized this pane?
        if (!_fHasOrder)
        {
            // No; Then we do not want to persist the order. We will initialize
            // all of the order items to -1. This is backward compatible because
            // IE 4 will merge alphabetically, but revert to a persited order when saving.
            for (int i = 0; i < DPA_GetPtrCount(_hdpa); i++) 
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);
                poi->nOrder = MNFOLDER_NORODER;
            }
        }

        if (_hKey)
        {
            pstm = SHOpenRegStream(_hKey, (_pcmb->_dwFlags & SMINIT_LEGACYMENU) ? TEXT("Menu") : TEXT(""), 
                TEXT("Order"), STGM_CREATE | STGM_WRITE);
        }
        else
        {
            if (S_OK != CallCB(NULL, SMC_GETSFOBJECT, (WPARAM)(GUID*)&IID_IStream, (LPARAM)(void**)&pstm))
                pstm = NULL;
        }

        if (pstm)
        {
            hres = OrderList_SaveToStream(pstm, _hdpaOrder ? _hdpaOrder : _hdpa, _psf);
            if (SUCCEEDED(hres))
            {
                CallCB(NULL, SMC_SETSFOBJECT, (WPARAM)(GUID*)&IID_IStream, (LPARAM)(void**)&pstm);
            }
            pstm->Release();
        }
    }

    if (SUCCEEDED(hres))
        hres = CSFToolbar::_SaveOrderStream();

    return hres;
}


void CMenuSFToolbar::_Dropped(int nIndex, BOOL fDroppedOnSource)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    ASSERT(_fDropping);

    CSFToolbar::_Dropped(nIndex, fDroppedOnSource);

    IEPlaySound(TEXT("MoveMenuItem"), FALSE);

    // Set this to false here because it is ugly that we don't behave like a menu right after a drop.
    _fEditMode = FALSE;

    // Notify the toplevel menuband of the drop in case it was popped open
    // because of the drag/drop event.  
    //
    // (There are some functionality/activation problems if we keep the
    // menu up after this case.  So to avoid those things at this late date,
    // we're going to cancel the menu after a timeout.)

    IOleCommandTarget * poct;
    
    _pcmb->QueryService(SID_SMenuBandTop, IID_IOleCommandTarget, (LPVOID *)&poct);

    if (poct)
    {
        poct->Exec(&CGID_MenuBand, MBANDCID_ITEMDROPPED, 0, NULL, NULL);
        poct->Release();
    }

    _pcmb->_fDragEntered = FALSE;
}


HMENU CMenuSFToolbar::_GetContextMenu(IContextMenu* pcm, int* pid)
{
    *pid += MNIDM_LAST;
    HMENU hmenu = CSFToolbar::_GetContextMenu(pcm, pid);
    HMENU hmenu2 = LoadMenuPopup_PrivateNoMungeW(MENU_MNFOLDERCONTEXT);
    
    // now find the properties insertion point and 
    int iCount = GetMenuItemCount(hmenu);
    for (int i = 0; i < iCount; i++) {
        TCHAR szCommand[40];
        UINT id = GetMenuItemID(hmenu, i);
        if (IsInRange(id, *pid, 0x7fff )) {
            id -= *pid;
            ContextMenu_GetCommandStringVerb(pcm, id, szCommand, ARRAYSIZE(szCommand));
            if (!lstrcmpi(szCommand, TEXT("properties"))) {
                break;
            }
        }
    }
    Shell_MergeMenus(hmenu, hmenu2, i, 0, 0x7FFF, 0);
    DestroyMenu(hmenu2);
    return hmenu;
}

void CMenuSFToolbar::_OnDefaultContextCommand(int idCmd)
{
    switch (idCmd) 
    {
    case MNIDM_RESORT:
        {
            // We used to blow away the order stream and refill, but since we use the order stream
            // for calculating the presence of new items, this promoted all of the items were were 
            // sorting.

            HDPA hdpa = _hdpa;

            // For some reason we have an _hdpaOrder, so use that for persisting out
            // to the registry..
            if (_hdpaOrder)
                hdpa = _hdpaOrder;

            _SortDPA(hdpa);
            OrderList_Reorder(hdpa);
            _fChangedOrder = TRUE;

            // This call knows about _hdpa and _hdpaOrder
            _SaveOrderStream();
            // MIKESH: this is needed because otherwise FillToolbar will use the current _hdpa
            // and nothing gets changed...  I think it's because OrderItem_Compare returns failure on some of the pidls
            CMenuToolbarBase::EmptyToolbar();
            _SetDirty(TRUE);
            _LoadOrderStream();
            if (_fShow)
            {
                _FillToolbar();
            }
            break;
        }
    }
}

LRESULT CMenuSFToolbar::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    //
    // When the NoSetTaskbar restriction is set, this code will disallow 
    // Context menus. It querys up to the Start menu to ask for permission
    // to set.
    LRESULT lres = 0;

    //  No UEM on Context Menus. This avoids the problem where we expand the menubands
    // with a context menu present.
    _fSuppressUserMonitor = TRUE;

    // Allow the selected item to blow away the menus. This is explicitly for the Verbs "Open"
    // "Print" and such that launch another process. Inprocess commands are unaffected by this.
    MyLockSetForegroundWindow(FALSE);

    BOOL fOwnerIsTopmost = (WS_EX_TOPMOST & GetWindowLong(_pcmb->_pmbState->GetSubclassedHWND(), GWL_EXSTYLE));

    if (fOwnerIsTopmost)
    {
        ::SetWindowPos(_pcmb->_pmbState->GetSubclassedHWND(), HWND_NOTOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);
    }

    KillTimer(_hwndMB, MBTIMER_INFOTIP);
    _pcmb->_pmbState->HideTooltip(FALSE);

    if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_CONTEXTMENU))
        lres = CSFToolbar::_OnContextMenu(wParam, lParam);

    if (fOwnerIsTopmost)
    {
        ::SetWindowPos(_pcmb->_pmbState->GetSubclassedHWND(), HWND_TOPMOST, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE);

        IUnknown_QueryServiceExec(SAFECAST(_pcmb, IOleCommandTarget*), SID_SMenuBandTop,
            &CGID_MenuBand, MBANDCID_REPOSITION, TRUE, NULL, NULL);
    }

    // Take the capture back after the context menu
    GetMessageFilter()->RetakeCapture();
    return lres;
}


HRESULT CMenuSFToolbar::_GetInfo(LPCITEMIDLIST pidl, SMINFO* psminfo)
{
    HRESULT hres;

    if (psminfo->dwMask & SMIM_TYPE)
    {
        psminfo->dwType = SMIT_STRING;
    }

    if (psminfo->dwMask & SMIM_FLAGS)
    {
        psminfo->dwFlags = SMIF_ICON | SMIF_DROPTARGET;
    }

    if (psminfo->dwMask & SMIM_ICON)
    {
        psminfo->dwMask &= ~SMIM_ICON;
        psminfo->iIcon = -1;
    }

    DWORD dwAttr = SFGAO_FOLDER | SFGAO_FILESYSTEM | SFGAO_BROWSABLE;

    // Folders that behave like shortcuts should not be considered 
    // as cascading menu items.  Channels are an example.

    // HACKHACK: to detect channels, we originally planned to GetUIObject
    // IShellLink.  But this doesn't work on browser-only b/c it doesn't
    // pipe down to the shell extension.   So as a hack, we'll key off
    // the absence of SFGAO_FILESYSTEM.

    // Is this a folder?
    // And is it NOT a browseable folder? If it's a Browseable folder, this means that it's a namespace
    // such as the Internet Namespace. The Internet name space's shell folder does not return real items, so it
    // makes it useless in menus. So, filter it out, and treat it like an item.
    hres = _psf->GetAttributesOf(1, &pidl, &dwAttr);
    if (SUCCEEDED(hres) && 
        IsFlagSet(dwAttr, SFGAO_FOLDER) && 
        !IsFlagSet(dwAttr, SFGAO_BROWSABLE))
    {
        // Since SHIsExpandableFolder is such an expensive call, and we only need
        // it for legacy Channels support, only do this call where channels are:
        // Favorites menu and Start Menu | Favorites.
        if (_dwFlags & SMSET_HASEXPANDABLEFOLDERS)
        {
            // on integrated install, check to see if the item supports 
            // is an expandable folder.  
            if (WhichPlatform() == PLATFORM_INTEGRATED) 
            {

                // Yes; but does it also behave like a shortcut?
                if (SHIsExpandableFolder(_psf, pidl))
                    psminfo->dwFlags |= SMIF_SUBMENU;

            } 
            else if (IsFlagSet(dwAttr, SFGAO_FILESYSTEM)) 
            {

                // On browse only, we don't rev the shell, so we rely upon
                // the filesystem bit...
                // this is a bit of a hack, and then disallows you from
                // doing things like having controlpanel be in the menu
                // but it's the best we can do.
                psminfo->dwFlags |= SMIF_SUBMENU;

            }
        }
        else
        {
            // We're going to assume that if it's a folder, it really is a folder.
            psminfo->dwFlags |= SMIF_SUBMENU;
        }
    }

    CallCB(pidl, SMC_GETSFINFO, 0, (LPARAM)psminfo);

    return hres;
}


/*----------------------------------------------------------
Purpose: This function determines the toolbar button style for the
         given pidl.  

         Returns S_OK if pdwMIFFlags is also set (i.e., the object
         supported IMenuBandItem to provide more info).  S_FALSE if only
         *pdwStyle is set.

*/
HRESULT CMenuSFToolbar::_TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwStyle, DWORD* pdwState, DWORD * pdwMIFFlags, int * piIcon)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    HRESULT hres = S_FALSE;
    DWORD dwStyle = TBSTYLE_BUTTON | TBSTYLE_DROPDOWN | TBSTYLE_NOPREFIX;

    *pdwState = TBSTATE_ENABLED;
    *pdwMIFFlags = 0;
    *piIcon = -1;

    if (pidl)
    {
        SMINFO sminfo;
        sminfo.dwMask = SMIM_TYPE | SMIM_FLAGS | SMIM_ICON;

        if (SUCCEEDED(_GetInfo(pidl, &sminfo)))
        {
            *pdwMIFFlags = sminfo.dwFlags;

            if (sminfo.dwFlags & SMIF_ACCELERATOR)
                dwStyle &= ~TBSTYLE_NOPREFIX;

            if (sminfo.dwType & SMIT_SEPARATOR)
            {
                dwStyle &= ~TBSTYLE_BUTTON;
                dwStyle |= TBSTYLE_SEP;
            }

            if (sminfo.dwFlags & SMIF_ICON)
                *piIcon = sminfo.iIcon;

            if (sminfo.dwFlags & SMIF_DEMOTED &&
                !_pcmb->_fExpanded)
            {
                *pdwState |= TBSTATE_HIDDEN;
                _fHasDemotedItems = TRUE;
            }

            if (sminfo.dwFlags & SMIF_HIDDEN)
                *pdwState |= TBSTATE_HIDDEN;

            hres = S_OK;
        }
    }
    else
    {
        // For null pidls ("empty" menuitems), there is no icon. 
        // SMIF_DROPTTARGET is set so the user can drop into an empty submenu.
        *pdwMIFFlags = SMIF_DROPTARGET;

        // Return S_OK so the pdwMIFFlags is examined.  
        hres = S_OK;
    }
    *pdwStyle = dwStyle;

    return hres;
}


BOOL CMenuSFToolbar::_FilterPidl(LPCITEMIDLIST pidl)
{
    // BUGBUG raymondc PERF?  Can we short-circuit the filter?
    return S_OK == CallCB(pidl, SMC_FILTERPIDL, 0, 0);
}


void CMenuSFToolbar::_FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags)
{
    _fHasSubMenu = FALSE;

    CallCB(NULL, SMC_BEGINENUM, (WPARAM)&dwEnumFlags, 0);
    CSFToolbar::_FillDPA(hdpa, hdpaSort, dwEnumFlags);
    CallCB(NULL, SMC_ENDENUM, 0, 0);
    if (0 == DPA_GetPtrCount(hdpa) && _psf)
    {
        OrderList_Append(hdpa, NULL, -1);     // Add a bogus pidl
        _fEmpty = TRUE;
        _fHasDemotedItems = FALSE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = TRUE;

    }
    else
    {
        _fEmpty = FALSE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = FALSE;
    }
}

void CMenuSFToolbar::_AddChevron()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // Does this menu get a chevron button?
    if (_fHasDemotedItems && !_pcmb->_fExpanded && _idCmdChevron == -1)
    {
        // Yes; (we shouldn't get here if the menu is empty)
        ASSERT(!_fEmpty);   

        // Add the chevron to the top or the bottom
        if (_dwFlags & SMSET_TOP && _pcmb->_pmtbTop != _pcmb->_pmtbBottom)
            _AddOrderItemTB(NULL, 0, NULL);      // add to top
        else
            _AddOrderItemTB(NULL, -1, NULL);     // append to bottom
    }
}

void CMenuSFToolbar::_RemoveChevron()
{
    if (-1 != _idCmdChevron)
    {
        // Yes; remove the chevron
        int iPos = ToolBar_CommandToIndex(_hwndTB, _idCmdChevron);
        InlineDeleteButton(iPos);
        _idCmdChevron = -1;
    }
}


void CMenuSFToolbar::_ToolbarChanged()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _pcmb->_fForceButtonUpdate = TRUE;
    // We shouldn't change the size of the menubar while we're in the middle
    // of a delete. Wait until we're done...
    if (!_fPreventToolbarChange && _fShow && !_fEmptyingToolbar)
    {
        RECT rcOld;
        RECT rcNew;
        HWND hwndP;



        // Resize the MenuBar
        hwndP = _hwndPager ? GetParent(_hwndPager): GetParent(_hwndTB);
        GetClientRect(hwndP, &rcOld);
        _pcmb->ResizeMenuBar();
        GetClientRect(hwndP, &rcNew);

        // If the rect sizes haven't changed, then we need to re-layout the
        // band because the button widths may have changed.
        if (EqualRect(&rcOld, &rcNew))
            NegotiateSize();

        // This pane may have changed sizes. If there is a sub menu, then
        // we need to have them reposition themselves
        if (_pcmb->_fInSubMenu && _pcmb->_pmtbTracked)
        {
            _pcmb->_pmtbTracked->PositionSubmenu(-1);
            IUnknown_QueryServiceExec(_pcmb->_pmpSubMenu, SID_SMenuBandChild,
                &CGID_MenuBand, MBANDCID_REPOSITION, 0, NULL, NULL);
        }
    }
}

void CMenuSFToolbar::_FillToolbar()
{
    // Don't fill the toolbar if we're not dirty or we're emptying the toolbar
    // If we try and fill the toolbar while we're emptying we enter a race condition
    // where we could AV. This fixes a bug where when dragging a folder into the
    // start menu, and cascade a menu, we empty one toolbar, which causes the
    // other toolbar to get destroyed, unregister itself, flush the change notify
    // queue, causing the original window to empty again... (lamadio) 7.16.98
    if (_fDirty && !_fEmptyingToolbar)
    {
        LPITEMIDLIST pidlItem = NULL;
        IShellMenu* psmSubMenu = NULL;
        // Populating the menu will take a long time since we're hitting
        // the disk.  Give the user some feedback if the cursor is
        // IDC_ARROW.  (If the cursor is something else, then don't
        // mess with it.)  Note that we have to use (HCURSOR)-1 as a
        // sentinel, because it's possible that the current cursor is NULL.

        // Prevent _ToolbarChanged from Doing things. (Perf)
        _fPreventToolbarChange = TRUE;

        // Are we in a sub menu? If we are, then we don't want to blow away
        // that menu, so we save it away do the fill and put it back in.
        // This is so that if it's displayed we won't collapse it unless absoluley
        // necessary.
        if (_pcmb->_fInSubMenu)
        {
            CMenuData* pdata = (CMenuData*)_IDToPibData(_pcmb->_nItemSubMenu);

            // This can be null if the fill toolbar was because you right clicked this item and clicked
            // delete...
            if (pdata)
            {
                // If we hit this, then _nItemSubMenu is out of sync. Figure out how
                // that got set to a non-sub menu item...
                ASSERT(pdata->GetFlags() & SMIF_SUBMENU);

                // Hold onto this shell menu. We'll try and reuse it...
                pdata->GetSubMenu(NULL, IID_IShellMenu, (void**)&psmSubMenu);
                pidlItem = ILClone(pdata->GetPidl());
            }
        }

        // Remove the chevron...
        _RemoveChevron();

        // Reset this bit. Fill toolbar will set it if there are items.
        _fHasDemotedItems = FALSE;

        CSFToolbar::_FillToolbar();


        // If we had a Chevron before we refreshed the toolbar, 
        // then we need to add it back. To Short circuit the add
        // we need to set the id to -1
        _idCmdChevron = -1;
        _AddChevron();
        if (_hwndPager)
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);

        _fPreventToolbarChange = FALSE;

        // Are we lucky?
        if (pidlItem)
        {
            if (psmSubMenu)
            {
                // BUGBUG(lamadio): Unify this code with _ReBindToFolder.

                // Great, we have all of the information we need. Now see if this pidl wasn't
                // one slated for death: Is it now in the toolbar?
                TBBUTTONINFO tbinfo = {0};
                tbinfo.dwMask = TBIF_COMMAND | TBIF_LPARAM;
                LPCITEMIDLIST pcidl = _GetButtonFromPidl(pidlItem, &tbinfo, NULL);
                if (pcidl)
                {
                    LPITEMIDLIST pidlFull = NULL;
                    IShellFolder* psf;
                    if(_pasf2)
                    {
                        LPITEMIDLIST pidlFolder, pidlChild;
                        _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlChild, NULL);
                        pidlFull = ILCombine(pidlFolder, pidlChild);
                        ILFree(pidlChild);
                        ILFree(pidlFolder);
                    }
                    else 
                    {
                        pidlFull = ILCombine(_pidl, pcidl);
                    }

                    // We need to bind to this pidl because it may have become merged. This will 
                    // spontaniously show both namespaces. Pretty cool huh? Love object reuse...

                    _psf->BindToObject(pidlItem, NULL, IID_IShellFolder, (void**)&psf);

                    if (psf)
                    {
                        if (pidlFull)
                        {
                            // Force the New information into the Sub Menu. This will cause a reenum.
                            if (SUCCEEDED(psmSubMenu->SetShellFolder(psf, pidlFull, NULL, 0)))
                            {
                                // If this Eval fires, then this item was inserted into the
                                // toolbar with a null pointer, or it was in the process of being
                                // removed.
                                CMenuData* pmd = (CMenuData*)tbinfo.lParam;
                                if (EVAL(pmd))
                                {
                                    // Make sure to store the Sub menu pointer back in the item it came from.
                                    pmd->SetSubMenu(psmSubMenu);
                                    _pcmb->_nItemSubMenu = tbinfo.idCommand;
                                }
                            }
                        }

                        psf->Release();
                    }

                    ILFree(pidlFull);
                }
                else
                {
                    _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
                }
                psmSubMenu->Release();
            }
            ILFree(pidlItem);
        }



        _ToolbarChanged();
    }
}

void CMenuSFToolbar::v_OnDeleteButton(LPVOID pData)
{
    CMenuData* pmd = (CMenuData*)pData;
    ASSERT(pmd && IS_VALID_CODE_PTR(pmd, CMenuData));

    if (pmd)
        delete pmd;
}

void CMenuSFToolbar::v_OnEmptyToolbar()
{
    CMenuToolbarBase::v_OnEmptyToolbar();
    OrderList_Destroy(&_hdpa);
    _fDirty = TRUE;
    _nNextCommandID = 0;
}


void CMenuSFToolbar::_ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax)
{
    // We overload this function because a NULL pidl is a place hold for
    // (Empty) When there are no items, or the Chevron when there are items.

    if (pidl)
    {
        CSFToolbar::_ObtainPIDLName(pidl, psz, cchMax);
    }
    else if (_fHasDemotedItems) // Chevron Case.
    {
        StringCchCopy(psz, cchMax, TEXT(">>")); // truncation ok, this is just for display
    }
    else    // Empty Case
    {
        MLLoadString(IDS_EMPTY, psz, cchMax);
    }
}        


void CMenuSFToolbar::v_NewItem(LPCITEMIDLIST pidl)
{
    // This is called when an item is present in the filesystem
    // that is not in the order stream. This occurs when an item is
    // created when the menu is not up.

    // BUGBUG (lamadio): IntelliMenus: New items are going to have a weird Promotion state
    // if there are multiple clients. Each client is going to be the create, and try to increment this.
    // We have to syncronize access to this. I'm not sure how to do this.

    // New items get promoted.
    CallCB(pidl, SMC_NEWITEM, 0, 0);

    // Since this is a new item, we want to increment the promoted items
    // so that we can do chevron tracking.
    _cPromotedItems++;
}

void CMenuSFToolbar::_SetDirty(BOOL fDirty)
{
    if (fDirty)
        _pcmb->_fForceButtonUpdate = TRUE;

    CSFToolbar::_SetDirty(fDirty);
}

void CMenuSFToolbar::_OnFSNotifyAdd(LPCITEMIDLIST pidl)
{
    DWORD dwEnumFlags = SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _RemoveChevron();
    CallCB(NULL, SMC_BEGINENUM, (WPARAM)&dwEnumFlags, 0);
    CSFToolbar::_OnFSNotifyAdd(pidl);
    CallCB(NULL, SMC_ENDENUM, 0, 0);
    _AddChevron();

    // When we add something to this, we want to promote our parent.
    IUnknown_RefreshParent(_pcmb->_punkSite, _pidl, SMINV_PROMOTE);

    _SaveOrderStream();
}

UINT ToolBar_GetVisibleCount(HWND hwnd)
{
    UINT cVis = 0;
    int cItems = ToolBar_ButtonCount(hwnd) - 1;
    for (; cItems >= 0; cItems--)
    {
        TBBUTTONINFO tbinfo;
        tbinfo.cbSize = sizeof(tbinfo);
        tbinfo.dwMask = TBIF_BYINDEX | TBIF_STATE;
        if (ToolBar_GetButtonInfo(hwnd, cItems, &tbinfo))
        {
            if (!(tbinfo.fsState & TBSTATE_HIDDEN))
            {
                cVis ++;
            }
        }
    }

    return cVis;
}

void CMenuSFToolbar::_OnFSNotifyRemove(LPCITEMIDLIST pidl)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    int i;
    _RemoveChevron();
    // Check to see if this item is a promoted guy...
    LPITEMIDLIST pidlButton = _GetButtonFromPidl(pidl, NULL, &i);
    if (pidlButton)
    {
        int idCmd = GetButtonCmd(_hwndMB, i);

        // Is he promoted?
        if (!(v_GetFlags(idCmd) & SMIF_DEMOTED))
        {
            // Yes, then we need to decrement the promoted count because
            // we are removing a promoted guy.
            _cPromotedItems--;

            // We should expand if we go to zero
            if (_cPromotedItems == 0)
            {
                // Demote the parent
                IUnknown_RefreshParent(_pcmb->_punkSite, _pidl, SMINV_DEMOTE | SMINV_NEXTSHOW);
                Expand(TRUE);
            }
        }

        if (_pcmb->_fInSubMenu && _pcmb->_nItemSubMenu == idCmd)
            _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);
    }

    CSFToolbar::_OnFSNotifyRemove(pidl);

    //Oooppsss, we removed the only string. Replace with our "(Empty)"
    // handler....
    if (0 == DPA_GetPtrCount(_hdpa) && _psf && _fVerticalMB)
    {
        ASSERT(_fEmpty == FALSE);
        // If we are Empty, then we cannot have any demoted items
        // NOTE: We can have no demoted items and not be empty, so one does
        // not imply the other.
        _fHasDemotedItems = FALSE;
        _AddPidl(NULL, 0);
        _fEmpty = TRUE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = TRUE;
    }

    if (_dwFlags & SMSET_COLLAPSEONEMPTY &&
        ToolBar_GetVisibleCount(_hwndMB) == 0)
    {
        // When we don't want to be shown when empty, collapse.
        _pcmb->_SiteOnSelect(MPOS_FULLCANCEL);
    }
    _AddChevron();
}


void CMenuSFToolbar::NegotiateSize()
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    RECT rc;
    HWND hwndP;

    hwndP = _hwndPager ? GetParent(_hwndPager): GetParent(_hwndTB);
    GetClientRect(hwndP, &rc);
    _pcmb->OnPosRectChangeDB(&rc);
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::DragEnter

       Informs Menuband that a drag has entered it's window.

*/
STDMETHODIMP CMenuSFToolbar::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _pcmb->_fDragEntered = TRUE;
    IOleCommandTarget * poct;
    
    _pcmb->QueryService(SID_SMenuBandTop, IID_IOleCommandTarget, (LPVOID *)&poct);

    if (poct)
    {
        poct->Exec(&CGID_MenuBand, MBANDCID_DRAGENTER, 0, NULL, NULL);
        poct->Release();
    }

    return CSFToolbar::DragEnter(pdtobj, grfKeyState, pt, pdwEffect);
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::DragLeave

        Informs Menuband that a drag has left it's window.

*/
STDMETHODIMP CMenuSFToolbar::DragLeave(void)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    _pcmb->_fDragEntered = FALSE;
    IOleCommandTarget * poct;
    
    _pcmb->QueryService(SID_SMenuBandTop, IID_IOleCommandTarget, (LPVOID *)&poct);

    if (poct)
    {
        poct->Exec(&CGID_MenuBand, MBANDCID_DRAGLEAVE, 0, NULL, NULL);
        poct->Release();
    }

    return CSFToolbar::DragLeave();
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::HitTestDDT

         Returns the ID to pass to GetObject.
30
*/
HRESULT CMenuSFToolbar::HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR *pdwId, DWORD *pdwEffect)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    TBINSERTMARK tbim;
    DWORD dwFlags = 0;
    BOOL fOnButton = FALSE;

    // If we're in drag and drop, Take UEM out of the picture
    _fSuppressUserMonitor = TRUE;

    // Unlike the CISFBand implementation, we always want to insert 
    // b/t the menu items.  So we return a negative index so the
    // GetObject method will treat all the drops as if we're dropping
    // in b/t the items, even if the cursor is over a menuitem.

    switch (nEvent)
    {
    case HTDDT_ENTER:
        // OLE is in its modal drag/drop loop, and it has the capture.
        // We shouldn't take the capture back during this time.
        if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) &&
            (S_FALSE == CallCB(NULL, SMC_SFDDRESTRICTED, NULL, NULL)))
        {
            // Since we've been entered, set the global state as
            // having the drag. If at some point the whole menu
            // heirarchy does not have the drag inside of it, we want to 
            // collapse the menu. This is to prevent the hanging menu syndrome.
            _pcmb->_pmbState->HasDrag(TRUE);
            KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
            GetMessageFilter()->PreventCapture(TRUE);
            return S_OK;
        }
        else
            return S_FALSE;

    case HTDDT_OVER:
        BLOCK
        {
            int iButton;

            *pdwEffect = DROPEFFECT_NONE;

            POINT pt = *ppt;
            ClientToScreen(_hwndTB, &pt);
            if (WindowFromPoint(pt) == _hwndPager ) 
            {
                iButton = IBHT_PAGER;
            } 
            else 
            {
                // Are we sitting BETWEEN buttons?
                if (ToolBar_InsertMarkHitTest(_hwndTB, ppt, &tbim))
                {
                    // Yes.

                    // Is this on the source button?
                    if (!(tbim.dwFlags & TBIMHT_BACKGROUND) && 
                        tbim.iButton == _iDragSource)
                    {
                        iButton = IBHT_SOURCE; // Yes; don't drop on the source button
                    }
                    else
                    {
                        iButton = tbim.iButton;
                    }
                }
                // No we're either sitting on a button or the background. Button?
                else if (tbim.iButton != -1 && !(tbim.dwFlags & TBIMHT_BACKGROUND))
                {
                    // On a Button. Cool.
                    iButton = tbim.iButton;
                    fOnButton = TRUE;
                }

                // Can this drop target even accept the drop?
                int idBtn = GetButtonCmd(_hwndTB, tbim.iButton);
                dwFlags = v_GetFlags(idBtn);
                if ( _idCmdChevron != idBtn &&
                    !(dwFlags & (SMIF_DROPTARGET | SMIF_DROPCASCADE)) ||
                    ((_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) ||
                    (S_OK == CallCB(NULL, SMC_SFDDRESTRICTED, NULL, NULL))))
                {
                    // No
                    return E_FAIL;
                }
            }
            *pdwId = iButton;
        }
        break;

    case HTDDT_LEAVE:
        // If the dropped occured in this band, then we don't want to collapse the menu
        if (!_fHasDrop)
        {
            // Since we've been left, set the global state. If moving between panes
            // then the pane that will be entered will reset this within the timeout period
            _pcmb->_pmbState->HasDrag(FALSE);
            _SetTimer(MBTIMER_DRAGPOPDOWN);
        }

        // We can take the capture back anytime now
        GetMessageFilter()->PreventCapture(FALSE);

        if (!_fVerticalMB)
        {
            tbim = _tbim;
        }
        else
        {
            // Turn off the insertion mark
            tbim.iButton = -1;
            tbim.dwFlags = 0;
            DAD_ShowDragImage(FALSE);
            ToolBar_SetInsertMark(_hwndTB, &tbim);
            UpdateWindow(_hwndTB);
            DAD_ShowDragImage(TRUE);
        }
        break;
    }

    // Did the drop target change?
    if (tbim.iButton != _tbim.iButton || tbim.dwFlags != _tbim.dwFlags)
    {
        DAD_ShowDragImage(FALSE);
        // Yes

        // If we're sitting on a button, highlight it. Otherwise remove the hightlight.
        //ToolBar_SetHotItem(_hwndTB, fOnButton? tbim.iButton : -1);

        // No.
        // We pop open submenus here during drag and drop.  But only
        // if the button has changed (not the flags).  Otherwise we'd
        // get flashing submenus as the cursor moves w/in a single item.
        if (tbim.iButton != _tbim.iButton)
        {
            _SetTimer(MBTIMER_DRAGOVER);
            BOOL_PTR fOldAnchor = ToolBar_SetAnchorHighlight(_hwndTB, FALSE);
            ToolBar_SetHotItem(_hwndTB, -1);
            _pcmb->_SiteOnSelect(MPOS_CHILDTRACKING);
            ToolBar_SetAnchorHighlight(_hwndTB, fOldAnchor);
        }

        // for now I don't want to rely on non-filesystem IShellFolder
        // implementations to call our OnChange method when a drop occurs,
        // so don't even show the insert mark.
        // We do not want to display the Insert mark if we do not allow reorder.
        if ((_fFSNotify || _iDragSource >= 0) && (dwFlags & SMIF_DROPTARGET) && _fAllowReorder)
        {
            ToolBar_SetInsertMark(_hwndTB, &tbim);
        }

        if (ppt)
            _tbim = tbim;

        UpdateWindow(_hwndTB);
        DAD_ShowDragImage(TRUE);
    }

    if (!_fVerticalMB && HTDDT_LEAVE == nEvent)
    {
        // Cursor leaving menuband, reset
        _tbim.iButton = -1;
        _iDragSource = -1;
    }

    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetObjectDDT

*/
HRESULT CMenuSFToolbar::GetObjectDDT(DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = E_NOINTERFACE;
    int nID = (int)dwId;

    *ppvObj = NULL;

    if (nID == IBHT_PAGER)
    {
        SendMessage(_hwndPager, PGM_GETDROPTARGET, 0, (LPARAM)ppvObj);
    }
    // Is the target the source?
    else if (IBHT_SOURCE != nID && IBHT_BACKGROUND != nID)
    {
        // No; does the shellfolder support IDropTarget?
        // We want to pass the subclassed HWND, because all we want the parent of the context menus to be
        // the Subclassed window. This is so we don't loose focus and collapse.
        hres = _psf->CreateViewObject(_pcmb->_pmbState->GetWorkerWindow(_hwndMB), riid, ppvObj);
    }

    if (*ppvObj)
        hres = S_OK;

    //TraceMsg(TF_BAND, "ISFBand::GetObject(%d) returns %x", dwId, hres);

    return hres;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::OnDropDDT

Returns: S_OK if the drop was handled.  Otherwise S_FALSE.
*/
HRESULT CMenuSFToolbar::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // Since the modal drag-drop loop released the capture, take it
    // back so we behave properly.
    KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
    HRESULT hres = S_FALSE;

    // We need to say that the last drag leave is really the drop.
    _fHasDrop = TRUE;
    _idCmdDragging = -1;
    MyLockSetForegroundWindow(TRUE);

    // Only send an hwnd to the callback if the drop source is external
    if (!(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) &&
        (S_FALSE == CallCB(NULL, SMC_SFDDRESTRICTED, (WPARAM)pdtobj,
                           (LPARAM)(_iDragSource < 0 ? GetHWNDForUIObject() : NULL)) ))
    {

        _RemoveChevron();
        hres = CSFToolbar::OnDropDDT(pdt, pdtobj, pgrfKeyState, pt, pdwEffect);
        _AddChevron();
    }

    return hres;
}


PIBDATA CMenuSFToolbar::_AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb)
{
    PIBDATA pibd = CSFToolbar::_AddOrderItemTB(poi, index, ptbb);

    if (pibd)
    {
        if (pibd->GetFlags() & SMIF_SUBMENU) 
        {
            _fHasSubMenu = TRUE;
        }

        // A null pidl means one of two things:
        //   1) a menu item called "(Empty)", or
        //   2) a chevron button

        // Are we adding the chevron button?
        if (!pibd->GetPidl() && _fHasDemotedItems)
        {
            // Yes; the chevron is either the first item in the toolbar or the last item.
            int iPos = (index == 0) ? 0 : ToolBar_ButtonCount(_hwndTB) - 1;

            _idCmdChevron = GetButtonCmd(_hwndTB, iPos);
        }
    }

    return pibd;
}


BOOL CMenuSFToolbar::_AddPidl(LPITEMIDLIST pidl, int index)
{
    BOOL bRet;
    
    // Is this item being added to an empty menu?
    if (_fEmpty)
    {
        // Yes; remove the empty menu item
        InlineDeleteButton(0);
        DPA_DeletePtr(_hdpa, 0);
        _fEmpty = FALSE;
        if (_dwFlags & SMSET_NOEMPTY)
            _fDontShowEmpty = FALSE;

        bRet = CSFToolbar::_AddPidl(pidl, index);

        // Failed to add new item?
        if (!bRet)
        {
            // Yes; add the empty menu item back
            OrderList_Append(_hdpa, NULL, -1);     // Add a bogus pidl
            _fEmpty = TRUE;
            _fHasDemotedItems = FALSE;
            if (_dwFlags & SMSET_NOEMPTY)
                _fDontShowEmpty = TRUE;
        }
        
    }
    else
        bRet = CSFToolbar::_AddPidl(pidl, index);

    return bRet;
}

BOOL CMenuSFToolbar::_ReBindToFolder(LPCITEMIDLIST pidl)
{

    // We may be able to share this code with the code in _FillToolbar, but the difference is,
    // in Fill Toolbar, the Toolbar Button does not have a Sub Menu. We reinitialize one we save away,
    // and force it back into the child button. Here, we have the luxury of having the Sub Menu still
    // in the toolbar button. I may be able to extract common code into a separate function. Left
    // as an exercise to the reader.

    // Need special Handling for this. We need to free the sub menu and
    // rebind to it ifit's up.
    BOOL fBound = FALSE;
    TBBUTTONINFO tbinfo = {0};
    tbinfo.dwMask = TBIF_COMMAND | TBIF_LPARAM;
    LPCITEMIDLIST pidlItem = _GetButtonFromPidl(ILFindLastID(pidl), &tbinfo, NULL);
    if (pidlItem)
    {
        CMenuData* pmd = (CMenuData*)tbinfo.lParam;
        if (EVAL(pmd))
        {
            IShellFolderBand* psfb;

            // We have the Toolbar button into, we should see if it has a sub menu associated with it.
            if (SUCCEEDED(pmd->GetSubMenu(&SID_MenuShellFolder, IID_IShellFolderBand, (void**)&psfb)))
            {
                // It does. Then reuse!
                LPITEMIDLIST pidlFull = NULL;
                IShellFolder* psf = NULL;
                if(_pasf2)
                {
                    LPITEMIDLIST pidlFolder, pidlChild;
                    // Remember: Folder pidls must be unwrapped. 
                   _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlChild, NULL);
                   pidlFull = ILCombine(pidlFolder, pidlChild);
                   ILFree(pidlChild);
                   ILFree(pidlFolder);
                }
                else
                {
                    // Not a wrapped guy, Sweet!
                    pidlFull = ILCombine(_pidl, pidlItem);
                }

                _psf->BindToObject(pidlItem, NULL, IID_IShellFolder, (void**)&psf);

                if (psf)
                {
                    if (pidlFull)
                    {
                        fBound = SUCCEEDED(psfb->InitializeSFB(psf, pidlFull));
                        if (fBound)
                        {
                            _pcmb->_nItemSubMenu = tbinfo.idCommand;
                        }
                    }

                    psf->Release();
                }
                ILFree(pidlFull);
                psfb->Release();
            }
        }
    }

    return fBound;
}


HRESULT CMenuSFToolbar::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = CSFToolbar::OnTranslatedChange(lEvent, pidl1, pidl2);
    

    // Deal with SubMenus:

    if (SUCCEEDED(hres))
    {
        switch(lEvent)
        {
        case SHCNE_RENAMEFOLDER:
            if (_IsChildID(pidl2, TRUE))
            {
                _ReBindToFolder(pidl2);
            }
            break;

        case SHCNE_RMDIR:
            if (_IsChildID(pidl1, TRUE))
            {
                _ReBindToFolder(pidl1);
            }
            break;

        case SHCNE_EXTENDED_EVENT:
            {
                SHChangeDWORDAsIDList UNALIGNED * pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl1;
                if (pidl2 && _IsChildID(pidl2, TRUE))
                {
                    if (!SHChangeMenuWasSentByMe(this, pidl1))
                    {
                        DWORD dwFlags = SMINV_NOCALLBACK;   // So that we don't doubly increment
                        SMDATA smd = {0};
                        smd.dwMask = SMDM_SHELLFOLDER;
                        smd.pidlFolder = _pidl;
                        smd.pidlItem = ILFindLastID(pidl2);


                        // Syncronize Promotion state.
                        if (pdwidl->dwItem1 == SHCNEE_PROMOTEDITEM)
                        {
                            dwFlags |= SMINV_PROMOTE;
                        }
                        else if (pdwidl->dwItem1 == SHCNEE_DEMOTEDITEM)
                        {
                            dwFlags |= SMINV_DEMOTE;
                        }


                        // Are we actually doing something?
                        if (SMINV_NOCALLBACK != dwFlags)
                        {
                            v_InvalidateItem(&smd, dwFlags);
                        }
                    }
                }
            }
            break;


        default:
            break;
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: IShellChangeNotify::OnChange

*/
HRESULT CMenuSFToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = E_FAIL;

    // If we're in the middle of being destroyed, don't process this.
    if (!_hwndMB)
        return S_OK;

    _pcmb->_pmbState->PushChangeNotify();

    SMCSHCHANGENOTIFYSTRUCT shns;
    shns.lEvent = lEvent;
    shns.pidl1  = pidl1;
    shns.pidl2  = pidl2;
    CallCB(NULL, SMC_SHCHANGENOTIFY, NULL, (LPARAM)&shns);  // Ignore return value. Notify only.

    // Since we may be removing the selected item, we want the selection to move to the next item
    int iHot = ToolBar_GetHotItem(_hwndMB);

    hres = CSFToolbar::OnChange(lEvent, pidl1, pidl2);

    // BUGBUG(lamadio): Investigate moving this into the OnTranslateChange handler. Saves us
    // from having to wrap them again.... This could be a big perf win....

    // Is this a child of this toolbar is some shape or form?
    // 1) The changing pidl is a child of this pane.
    // 2) What the pidl is changing to is in this pane (For renames)
    // 3) Updatedirs. Recursive change notifies must forward update dirs all the way down the chain.
    // 4) EXTENDED events with a pidl2 == NULL. This means Reorder all your items.
    if (_IsChildID(pidl1, FALSE) || 
        (pidl2 && _IsChildID(pidl2, FALSE)) || 
        lEvent == SHCNE_UPDATEDIR ||
        (lEvent == SHCNE_EXTENDED_EVENT &&
         pidl2 == NULL)) 
    {
        // We need to forward this down then.
        HRESULT hresInner = _pcmb->ForwardChangeNotify(lEvent, pidl1, pidl2);


        // Did either of us handle this change?
        if (SUCCEEDED(hresInner) || SUCCEEDED(hres))
        {
            hres = S_OK;
        }
        else if (lEvent != SHCNE_EXTENDED_EVENT)    // Don't bother with extended events...
        {   
            // Ok so neither of us handled this?
            // Must be the SHChangeNotifyCollapsing code that collapses
            // the Directory Create and item create into a single item create.
            // We need to force an update dir on ourselves so that we get this change.
            hres = CSFToolbar::OnChange(SHCNE_UPDATEDIR, pidl1, pidl2);
        }
    }

    // Set the hot item back, wrapping if necessary.
    if (ToolBar_GetHotItem(_hwndMB) != iHot)
        SetHotItem(1, iHot, -1, 0);

    _pcmb->_pmbState->PopChangeNotify();

    return hres;
}

void CMenuSFToolbar::_OnDragBegin(int iItem, DWORD dwPreferedEffect)
{
    // During drag and drop, allow dialogs to collapse menu.
    MyLockSetForegroundWindow(FALSE);

    CSFToolbar::_OnDragBegin(iItem, DROPEFFECT_MOVE);
    if (_fEditMode)
        SetTimer(_hwndTB, MBTIMER_ENDEDIT, MBTIMER_ENDEDITTIME, 0);
}


void CMenuSFToolbar::v_SendMenuNotification(UINT idCmd, BOOL fClear)
{
    if (fClear)
    {
        // If we're clearing, tell the browser 
        PostMessage(_pcmb->_pmbState->GetSubclassedHWND(), WM_MENUSELECT,
            MAKEWPARAM(0, -1), NULL);

    }
    else
    {
        PIBDATA pibdata = _IDToPibData(idCmd);
        LPCITEMIDLIST pidl;
    
        // Only send notifications for non submenu items
        if (EVAL(pibdata) && (pidl = pibdata->GetPidl()))
        {
            CallCB(pidl, SMC_SFSELECTITEM, 0, 0);
            // Don't free Pidl
        }
    }
}    


LRESULT CMenuSFToolbar::_OnGetObject(NMOBJECTNOTIFY* pnmon)
{
    pnmon->hResult = QueryInterface(*pnmon->piid, &pnmon->pObject);

    return 1;
}


LRESULT CMenuSFToolbar::_OnNotify(LPNMHDR pnm)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    LRESULT lres = 0;

    // These are notifies we handle even when disengaged from the message hook.
    switch (pnm->code)
    {
    case TBN_DELETINGBUTTON:
        if (_fEmptyingToolbar)
            return 0;
        else
            goto DoDefault;
        break;

    case TBN_GETDISPINFOA:
    case TBN_GETDISPINFOW:
    case NM_CUSTOMDRAW:
        goto DoDefault;
    }

    // Pager notifications MUST be forwarded even when the message hook is disengaged.
    if((pnm->code <= PGN_FIRST)  && (pnm->code >= PGN_LAST)) 
    {
        goto DoNotify;
    }
    
    
    // Is the Global Message filter Disengaged? This will happen when the Subclassed window
    // looses activation to a dialog box of some kind.
    if (lres == 0 && !GetMessageFilter()->IsEngaged())
    {
        // Yes; We've lost activation so we don't want to track like a normal menu...
        // For hot item change, return 1 so that the toolbar does not change the hot item.
        if (pnm->code == TBN_HOTITEMCHANGE && _pcmb->_fMenuMode)
            return 1;

        // For all other items, don't do anything....
        return 0;
    }

DoNotify:
    switch (pnm->code)
    {
    case PGN_SCROLL:
        KillTimer(_hwndMB, MBTIMER_DRAGPOPDOWN);
        if (_pcmb->_fInSubMenu)
            _pcmb->_SubMenuOnSelect(MPOS_CANCELLEVEL);

        _fSuppressUserMonitor = TRUE;
        break;

    case TBN_GETOBJECT:
        lres = _OnGetObject((NMOBJECTNOTIFY*)pnm);
        break;

    case TBN_DRAGOUT:
        {
            TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
            if (!_fEmpty && ptbn->iItem != _idCmdChevron &&
                !(_pcmb->_dwFlags & SMINIT_RESTRICT_DRAGDROP) &&
                (S_FALSE == CallCB(NULL, SMC_SFDDRESTRICTED, NULL, NULL)))
            {

                // We're now in edit mode
                _fEditMode = TRUE;
                _idCmdDragging = ptbn->iItem;
                _MarkItem(ptbn->iItem);

                lres = 1;       // Allow the drag to occur
                goto DoDefault;
            }
            else
                lres = 0;   // Do not allow the drag out.
        }
        break;
   
    default:
DoDefault:
        lres = CMenuToolbarBase::_OnNotify(pnm);
        if (lres == 0)
        {
            lres = CSFToolbar::_OnNotify(pnm);
        }
        break;
    }

    return lres;
}


void CMenuSFToolbar::CreateToolbar(HWND hwndParent)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    CSFToolbar::_CreateToolbar(hwndParent);
    if (_hwndPager)
    {
        SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_DRAGNDROP, PGS_DRAGNDROP);
        SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_AUTOSCROLL, PGS_AUTOSCROLL);
        SHSetWindowBits(_hwndPager, GWL_STYLE, PGS_HORZ|PGS_VERT,
           _fVertical ? PGS_VERT : PGS_HORZ);
    }

    _hwndMB = _hwndTB;

    CMenuToolbarBase::CreateToolbar(hwndParent);

    // By "Registering optimized" means that someone else is going to pass the change to us, 
    // we don't need to register for it. This is for the disjoint Fast Items | Programs menu case.
    // We still need top level change notify registration for Favorites, Documents, Printers and Control
    // Panel (Depending on their visibility)
    //

    if (_pcmb->_uId == MNFOLDER_IS_PARENT || 
        (_dwFlags & SMSET_DONTREGISTERCHANGENOTIFY))
        _fRegisterChangeNotify = FALSE;

    // This is a good as spot as any to do this:
    _RegisterToolbar();
}


HKEY CMenuSFToolbar::_GetKey(LPCITEMIDLIST pidl)
{
    HKEY hMenuKey;
    DWORD dwDisp;
    TCHAR szDisplay[MAX_PATH];

    if (!_hKey)
        return NULL;

    _ObtainPIDLName(pidl, szDisplay, ARRAYSIZE(szDisplay));
    RegCreateKeyEx(_hKey, szDisplay, NULL, NULL,
        REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
        NULL, &hMenuKey, &dwDisp);
    TraceMsg(TF_MENUBAND, "%d is setting %s\'s Key to %d", _hKey, szDisplay, hMenuKey);
    return hMenuKey;
}


//***
// NOTES
//  idtCmd is currently always -1.  we'll need other values when we're
// called from CallCB.  however we can't do that until we move idtCmd
// 'down' into CallCB.
HRESULT CMenuSFToolbar::v_GetState(int idtCmd, LPSMDATA psmd)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    HRESULT hres = E_FAIL;
    CMenuData* pdata;
    LPITEMIDLIST pidl = NULL;

    psmd->dwMask = SMDM_SHELLFOLDER;

    if (idtCmd == -1)
        idtCmd = GetButtonCmd(_hwndTB, ToolBar_GetHotItem(_hwndTB));

    pdata = (CMenuData*)_IDToPibData(idtCmd);
    if (EVAL(pdata))
    {
        pidl = pdata->GetPidl();
        ASSERT(IS_VALID_PIDL(pidl));
    }

    if (pidl)
    {
        if( _pasf2 && S_OK == _pasf2->UnWrapIDList(pidl, 1, &psmd->psf, &psmd->pidlFolder, &psmd->pidlItem, NULL))
        {
            /*NOTHING*/
            ;
        }
        else
        {
            // Then it must be a straight ShellFolder.
            psmd->psf = _psf;
            if (EVAL(psmd->psf))
                psmd->psf->AddRef();
            psmd->pidlFolder = ILClone(_pidl);
            psmd->pidlItem = ILClone(ILFindLastID(pidl));
        }

        psmd->uIdParent = _pcmb->_uId;
        psmd->punk = SAFECAST(_pcmb, IShellMenu*);
        psmd->punk->AddRef();

        hres = S_OK;
    }

    return hres;
}

HRESULT CMenuSFToolbar::CallCB(LPCITEMIDLIST pidl, DWORD dwMsg, WPARAM wParam, LPARAM lParam)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    if (!_pcmb->_psmcb)
        return S_FALSE;

    SMDATA smd;
    HRESULT hres = S_FALSE;
    BOOL fDestroy = FALSE;

    // todo: call v_GetState (but need idCmd for pidl)
    smd.dwMask = SMDM_SHELLFOLDER;

    if (pidl)
    {
        // We used to unwrap the pidl here in the case of AUGMISF, but why? In the Callback, we only
        // needed the Full pidl for Executing and for Darwin. The unwrap is an expensive call that in
        // the majority case wasn't even used. Put it on the client to unwrap it. Start Menu is the
        // only user of Augmented shell folders anyway....
        smd.psf = _psf;
        smd.pidlFolder = _pidl;
        smd.pidlItem = (LPITEMIDLIST)pidl;
    }
    else
    {
        // Null pidl means tell the callback about me...
        smd.pidlItem = ILClone(ILFindLastID(_pidl));
        smd.pidlFolder = ILClone(_pidl);
        ILRemoveLastID(smd.pidlFolder);
        smd.psf = NULL; // Incase bind fails.
        IEBindToObject(smd.pidlFolder, &smd.psf);
        fDestroy = TRUE;
    }

    smd.uIdParent = _pcmb->_uId;
    smd.uIdAncestor = _pcmb->_uIdAncestor;

    smd.punk = SAFECAST(_pcmb, IShellMenu*);
    smd.pvUserData = _pcmb->_pvUserData;

    hres = _pcmb->_psmcb->CallbackSM(&smd, dwMsg, wParam, lParam);

    if (fDestroy)
    {
        ATOMICRELEASE(smd.psf);
        ILFree(smd.pidlFolder);
        ILFree(smd.pidlItem);
    }
    
    return hres;
}

HRESULT CMenuSFToolbar::v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hres = E_FAIL;
    CMenuData* pdata = (CMenuData*)_IDToPibData(idtCmd);
    ASSERT(pdata);
    ASSERT(pdata->GetPidl() == NULL || IS_VALID_PIDL(pdata->GetPidl()));

    if (pdata)
        hres = CallCB(pdata->GetPidl(), uMsg, wParam, lParam);
    return hres;
}

HRESULT CMenuSFToolbar::v_GetSubMenu(int idCmd, const GUID* pguidService, REFIID riid, void** ppvObj)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);
    HRESULT hres = E_FAIL;

    ASSERT(IS_VALID_WRITE_PTR(ppvObj, void*));

    *ppvObj = NULL;

    ASSERT(pdata);
    if (pdata && pdata->GetFlags() & SMIF_SUBMENU)
    {
        hres = pdata->GetSubMenu(pguidService, riid, (void**)ppvObj);
        if ( FAILED(hres) && IsEqualGUID(riid, IID_IShellMenu))
        {
            hres = CallCB(pdata->GetPidl(), SMC_GETSFOBJECT, (WPARAM)&riid, (LPARAM)ppvObj);
            if (SUCCEEDED(hres))
            {
                BOOL fCache = TRUE;
                if (S_OK != hres)
                {
                    hres = E_FAIL;
                    IShellMenu* psm = (IShellMenu*) new CMenuBand();
                    if (psm)
                    {
                        IShellFolder* psf = NULL;
                        LPITEMIDLIST pidlItem = pdata->GetPidl();
                        LPITEMIDLIST pidlFolder = _pidl;
                        BOOL fDestroy = FALSE;
                        IShellMenuCallback* psmcb;

                        // Ask the callback if they want to supply a different callback
                        // object for this sub menu. If they do, then use what they 
                        // pass back NOTE: If they pass back S_OK, it's perfectly Ok,
                        // for them to pass back a NULL psmcb. This means, I don't want
                        // my child to have a callback. Use the default.
                        // If they don't handle it, then use their pointer.
                        if (S_FALSE == CallCB(pdata->GetPidl(), SMC_GETSFOBJECT, 
                            (WPARAM)&IID_IShellMenuCallback, (LPARAM)&psmcb))
                        {
                            psmcb = _pcmb->_psmcb;
                            if (psmcb)
                                psmcb->AddRef();
                        }


                        // This has to be before the unwrap because it does name resolution through
                        // the Augmented ISF.
                        HKEY hMenuKey = _GetKey(pidlItem);
                        
                        if (_pasf2)
                        {
                            if (S_OK == _pasf2->UnWrapIDList(pdata->GetPidl(), 1, &psf, &pidlFolder, &pidlItem, NULL))
                            {
                                psf->Release(); // I don't need this
                                psf = NULL;
                                fDestroy = TRUE;
                            }

                            _pasf2->BindToObject(pdata->GetPidl(), NULL, IID_IShellFolder, (LPVOID*)&psf);
                        }

                        // Inherit the flags from the parent...
                        DWORD dwFlags = SMINIT_VERTICAL | 
                            (_pcmb->_dwFlags & (SMINIT_RESTRICT_CONTEXTMENU | 
                                                SMINIT_RESTRICT_DRAGDROP    | 
                                                SMINIT_MULTICOLUMN));

                        LPITEMIDLIST pidlFull = ILCombine(pidlFolder, pidlItem);
                        if (psf == NULL)
                        {
                            hres = _psf->BindToObject(pidlItem, NULL, IID_IShellFolder, (void**)&psf);
                        }

                        DWORD dwAttrib = SFGAO_FILESYSTEM;
                        LPCITEMIDLIST pidlWrappedItem = pdata->GetPidl();
                        // _psf can be an augmented shell folder. Use the wrapped item....
                        _psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlWrappedItem, &dwAttrib);

                        // We need to sniff the pidl to see if it's a junction
                        // The format of a Filesytem pidl is 
                        //  WORD cb;
                        //  BYTE bFlags;
                        // if (pidl->bFlags & Namespace Junction)
                        //      ...Or...
                        // It's not in the filesystem.

                        if (SIL_GetType(pidlItem) & 0x80 || !(dwAttrib & SFGAO_FILESYSTEM))
                        {
                            // We're not going to persist anything
                            RegCloseKey(hMenuKey);
                            hMenuKey = NULL;
                            psmcb = NULL;   // We're not going to pass a callback. NOTE: We don't need to release this
                            dwFlags &= ~SMINIT_MULTICOLUMN; // No multi on FShortcut...
                            fCache = FALSE;
                        }
                        UINT uIdAncestor = _pcmb->_uIdAncestor;
                        if (uIdAncestor == ANCESTORDEFAULT)
                            uIdAncestor = idCmd;

                        psm->Initialize(psmcb, MNFOLDER_IS_PARENT, uIdAncestor, dwFlags);
                        
                        if (psf)
                        {
                            psm->SetShellFolder(psf, pidlFull, hMenuKey, 
                                _dwFlags & (SMSET_HASEXPANDABLEFOLDERS | SMSET_USEBKICONEXTRACTION));
                            hres = psm->QueryInterface(riid, ppvObj);
                            psf->Release();
                        }
                        ILFree(pidlFull);

                        psm->Release();
                        if (psmcb)
                            psmcb->Release();

                        if (fDestroy)
                        {
                            ILFree(pidlFolder);
                            ILFree(pidlItem);
                        }
                    }
                }

                if (*ppvObj)
                {
                    if (fCache)
                    {
                        pdata->SetSubMenu((IUnknown*)*ppvObj);
                    }

                    VARIANT Var;
                    Var.vt = VT_UNKNOWN;
                    Var.byref = SAFECAST(_pcmb->_pmbm, IUnknown*);

                    // Set the CMenuBandMetrics into the new menuband
                    IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETFONTS, 0, &Var, NULL);

                    // Set the CMenuBandState  into the new menuband
                    Var.vt = VT_INT_PTR;
                    Var.byref = _pcmb->_pmbState;
                    IUnknown_Exec((IUnknown*)*ppvObj, &CGID_MenuBand, MBANDCID_SETSTATEOBJECT, 0, &Var, NULL);


                }
            }
        }
    }

    return hres;
}


DWORD CMenuSFToolbar::v_GetFlags(int idCmd)
{
    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);

    // Toolbar is allowed to pass a bad command in the case of background erase
    if (pdata)
        return pdata->GetFlags();
    else
        return 0;

//  BUGBUG (lamadio): Should I query each time? For like Volitile items?
//    SMINFO SMINFO = {SMIM_FLAGS};
//    CallCB(pdata->GetPidl(), SMC_GETFSINFO, (WPARAM)idCmd, (LPARAM)&SMINFO);

}


// This is to tell all other clients that we updated the promotion state of something.
void CMenuSFToolbar::BroadcastIntelliMenuState(LPCITEMIDLIST pidlItem, BOOL fPromoted)
{
    LPITEMIDLIST pidlFolder;
    LPITEMIDLIST pidlItemUnwrapped;
    LPITEMIDLIST pidlFull;

    if( _pasf2 && S_OK == _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlItemUnwrapped, NULL))
    {

        pidlFull = ILCombine(pidlFolder, pidlItemUnwrapped);
        ILFree(pidlFolder);
        ILFree(pidlItemUnwrapped);
    }
    else
    {

        pidlFull = ILCombine(_pidl, pidlItem);
    }

    SHSendChangeMenuNotify(this,
                           fPromoted ? SHCNEE_PROMOTEDITEM : SHCNEE_DEMOTEDITEM,
                           0, pidlFull);

    ILFree(pidlFull);

}

HRESULT CMenuSFToolbar::v_ExecItem(int idCmd)
{
    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);
    HRESULT hres = E_FAIL;
    if (pdata && !_fEmpty && idCmd != _idCmdChevron)
    {
        // STRESS: pdata was becomming 0x8 for some reason after the InvokeDefault.
        // I assume that this call was causing a flush, which frees our list of pidls.
        // So, I'm cloning it. I also changed the order, so that we'll just fire the
        // UEM event.

        LPITEMIDLIST pidl = ILClone(pdata->GetPidl());
        if (pidl)
        {
            ASSERT(IS_VALID_PIDL(pidl));

            SMDATA smd;
            smd.dwMask = SMDM_SHELLFOLDER;
            smd.pidlFolder = _pidl;
            smd.pidlItem = pidl;
            v_InvalidateItem(&smd, SMINV_PROMOTE | SMINV_FORCE);

            hres = CallCB(pidl, SMC_SFEXEC, 0, 0);

            // Did the Callback handle this execute for us?
            if (hres == S_FALSE) 
            {
                // No, Ok, do it ourselves.
                hres = SHInvokeDefaultCommand(_hwndTB, _psf, pidl);
            }

            ILFree(pidl);
        }

    }

    return hres;
}


HRESULT CMenuSFToolbar::v_GetInfoTip(int idCmd, LPTSTR psz, UINT cch)
{
    CMenuData* pdata = (CMenuData*)_IDToPibData(idCmd);
    HRESULT hres = E_FAIL;

    if (_fEmpty || !pdata)
        return hres;

    hres = CallCB(pdata->GetPidl(), SMC_GETSFINFOTIP, (WPARAM)psz, (LPARAM)cch);

    if (S_FALSE == hres)
    {
        hres = E_FAIL;
        if (GetInfoTip(_psf, pdata->GetPidl(), psz, cch))
        {
            hres = NOERROR;
        }
    } 

    return hres;

}


void CMenuSFToolbar::v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    POINT pt;
    HWND    hwndFwd;
    
    // These are in screen coords
    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    hwndFwd = _hwndPager ? _hwndPager : _hwndTB;
    GetWindowRect(hwndFwd, &rc);

    if (PtInRect(&rc, pt))
    {
        MapWindowPoints(NULL, hwndFwd, &pt, 1);
        HWND hwnd = ChildWindowFromPoint(hwndFwd, pt);

        if (hwnd) 
        {
            MapWindowPoints(hwndFwd, hwnd, &pt, 1);
        }
        else
        {
            hwnd = hwndFwd;
        }

        SendMessage(hwnd, uMsg, wParam, MAKELONG(pt.x, pt.y));
    }
}


HRESULT CMenuSFToolbar::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch(uMsg)
    {
    case WM_SYSCOLORCHANGE:
        if (_hwndPager)
            Pager_SetBkColor(_hwndPager, GetSysColor(COLOR_MENU));

        // Change the color, so that we can see it.
        ToolBar_SetInsertMarkColor(_hwndMB, GetSysColor(COLOR_MENUTEXT));
        break;
    }
    HRESULT hres = CMenuToolbarBase::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    if (hres != S_OK)
        hres = CSFToolbar::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);

    return hres;
}


BOOL CMenuSFToolbar::v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons) 
{ 
    if (uIconSize == -1) 
        uIconSize = _uIconSize; 
    _uIconSizeMB = uIconSize;
    return _UpdateIconSize(uIconSize, fUpdateButtons); 
}

 
HRESULT CMenuSFToolbar::GetShellFolder(LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj)
{
    HRESULT hres = E_FAIL;
    *ppvObj = NULL;
    if (_psf)
    {
        hres = _psf->QueryInterface(riid, ppvObj);
    }

    if(SUCCEEDED(hres) && ppidl)
    {
        *ppidl = ILClone(_pidl);
        if (! *ppidl)
        {
            (*(IUnknown**)ppvObj)->Release();
            
            hres = E_FAIL;
        }
    }

    return hres;
}


LRESULT CMenuSFToolbar::_OnTimer(WPARAM wParam)
{
    switch(wParam)
    {
    case MBTIMER_ENDEDIT:
        KillTimer(_hwndTB, wParam);
        _fEditMode = FALSE;
        break;

    case MBTIMER_CLICKUNHANDLE:
        KillTimer(_hwndTB, wParam);
        _fClickHandled = FALSE;
        break;

    default:
        return CMenuToolbarBase::_OnTimer(wParam);
    }
    return 1;
}


LRESULT CMenuSFToolbar::_OnDropDown(LPNMTOOLBAR pnmtb)
{
    if (GetAsyncKeyState(VK_LBUTTON) < 0 && _fEditMode)
    {
        // Are we in edit mode?
        if (_fEditMode)
        {
            // Yes, mark the item as the item that is subject to moving
            _MarkItem(pnmtb->iItem);
        }
        return TBDDRET_TREATPRESSED;
    }
    
    return CMenuToolbarBase::_OnDropDown(pnmtb);
}


/*----------------------------------------------------------
Purpose: In the context of a menuband, marking means putting
         a black rectangle around the item currently being dragged.

*/
void CMenuSFToolbar::_MarkItem(int idCmd)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // Un-highlight the previously moved button
    if (0 <= _pcmb->_nItemMove)
    {
        // Should item move be a member of SFToolbar?
        ToolBar_MarkButton(_hwndTB, _pcmb->_nItemMove, FALSE);
        _pcmb->_nItemMove = -1;
    }
    
    if (_fEditMode)    
    {
        _pcmb->_nItemMove = idCmd;
        ToolBar_MarkButton(_hwndTB, _pcmb->_nItemMove, TRUE);
    }
}    


STDMETHODIMP CMenuSFToolbar::IsWindowOwner(HWND hwnd) 
{ 
    if (_hwndTB == hwnd || _hwndPager == hwnd || HWND_BROADCAST == hwnd) 
    {
        return S_OK;
    } 
    else 
    {
        return S_FALSE;
    } 
}


void CMenuSFToolbar::SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags)
{
    if (!_hwndPager)
    {
        CMenuToolbarBase::SetWindowPos(psize, prc, dwFlags);
        return;
    }
    DWORD rectWidth = RECTWIDTH(*prc);

    TraceMsg(TF_MENUBAND, "CMSFTB::SetWindowPos %d - (%d,%d,%d,%d)", psize?psize->cx:0,
        prc->left, prc->top, prc->right, prc->bottom);

    ShowWindow(_hwndPager, SW_SHOW);
    ::SetWindowPos(_hwndPager, NULL, prc->left, prc->top, 
        rectWidth, RECTHEIGHT(*prc), SWP_NOZORDER | SWP_NOACTIVATE | dwFlags);
    if (psize)
        SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(psize->cx, psize->cx));

    SendMessage(_hwndPager, PGMP_RECALCSIZE, 0L, 0L);
}


void CMenuSFToolbar::SetParent(HWND hwndParent)
{ 
    int nCmdShow = SW_SHOW;
    if (hwndParent)
    {
        if (!_hwndTB)
            CreateToolbar(hwndParent);
        else
        {
            // make sure width is set correctly . . . 
            SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(_cxMin, _cxMax));
        }
    }
    else
    {
        // As an optimization, we implement "disowning" ourselves
        // as just moving ourselves offscreen.  The previous parent
        // still owns us.  The parent is invariably the menusite.
        RECT rc = {-1,-1,-1,-1};
        SetWindowPos(NULL, &rc, 0);
        nCmdShow = SW_HIDE;
    }


    HWND hwnd = _hwndPager ? _hwndPager: _hwndTB;
    
    if (IsWindow(hwnd)) // JANK : Fix for bug #98253
    {
       ::SetParent(hwnd, hwndParent); 
       SendMessage(hwnd, TB_SETPARENT, (WPARAM)hwndParent, NULL);
       ShowWindow(hwnd, nCmdShow);
    }
}

void CMenuSFToolbar::Expand(BOOL fExpand)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first
    TBBUTTON tbb;

    DAD_ShowDragImage(FALSE);

    // Since we're not sure if the Chevron is going to be visible we should remove it here
    // Later we'll add it back in if it's needed.
    _RemoveChevron();

    // Loop through and apply the fExpand
    int iNumButtons = ToolBar_ButtonCount(_hwndTB);

    // We reset these when iterating.
    _cPromotedItems = 0;
    _fHasDemotedItems = FALSE;

    int iHotItem = ToolBar_GetHotItem(_hwndMB);

//    SendMessage(_hwndMB, WM_SETREDRAW, FALSE, 0);

    for (int i = 0; i < iNumButtons; i++)
    {
        if (!ToolBar_GetButton(_hwndMB, i, &tbb))
            continue;

        CMenuData* pmd = (CMenuData*)tbb.dwData;

        // Get the toolbar state. Toolbar can set things like
        // TBSTATE_WRAP that we would go nuke.
        DWORD dwState = tbb.fsState;
        DWORD dwFlags = pmd ? pmd->GetFlags() : 0;

        if (dwFlags & SMIF_DEMOTED)
        {
            // Are we expanding?
            if (fExpand)
            {
                //Yes; Enable the button and remove the hidden state
                dwState |= TBSTATE_ENABLED;
                dwState &= ~TBSTATE_HIDDEN;
            }
            else
            {
                //No; Remove the Enabled state and hide the button
                dwState |= TBSTATE_HIDDEN;
                dwState &= ~TBSTATE_ENABLED;
            }

            _fHasDemotedItems = TRUE;
        }
        else if (dwFlags & SMIF_HIDDEN)
        {
            dwState |= TBSTATE_HIDDEN;
            dwState &= ~TBSTATE_ENABLED;
        }
        else if (tbb.idCommand != _idCmdChevron)
        {
            dwState |= TBSTATE_ENABLED;
            dwState &= ~TBSTATE_HIDDEN;
            _cPromotedItems++;
        }

        // If the state has changed, then set it into the toolbar.
        if (dwState != tbb.fsState)
            ToolBar_SetState(_hwndTB, tbb.idCommand, dwState);
    }

    // _fExpand means "Draw as Expanded". We do not want to 
    // draw expanded when we have no demoted items.

    _pcmb->_fExpanded = _fHasDemotedItems? fExpand : FALSE;

    if (fExpand)
    {
        if (_pcmb->_pmbState)
        {
            _pcmb->_pmbState->SetExpand(TRUE);
            _pcmb->_pmbState->HideTooltip(TRUE);
        }
    }
    else
    {
        _AddChevron();
    }

    // Have the menubar think about changing its height
    IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
        MBCID_SETEXPAND, _fHasDemotedItems?(int)_pcmb->_pmbState->GetExpand():FALSE, NULL, NULL);

//    SendMessage(_hwndMB, WM_SETREDRAW, TRUE, 0);
    _ToolbarChanged();
    ToolBar_SetHotItem(_hwndMB, iHotItem);
    if (_hwndPager)
        UpdateWindow(_hwndPager);
    UpdateWindow(_hwndTB);
//    DAD_ShowDragImage(TRUE);
}


void CMenuSFToolbar::GetSize(SIZE* psize)
{
    CMenuToolbarBase::GetSize(psize);

    if (_fEmpty && _fDontShowEmpty)
    {
        psize->cy = 0;
        TraceMsg(TF_MENUBAND, "CMSFT::GetSize (%d, %d)", psize->cx, psize->cy);
    }
}

void CMenuSFToolbar::_RefreshInfo()
{
    int cButton = ToolBar_ButtonCount(_hwndMB);
    for (int iButton = 0; iButton < cButton; iButton++)
    {
        int idCmd = GetButtonCmd(_hwndTB, iButton);

        if (idCmd != _idCmdChevron)
        {
            // Get the information from that button.
            CMenuData* pmd = (CMenuData*)_IDToPibData(idCmd);

            if (pmd)
            {
                SMINFO sminfo;
                sminfo.dwMask = SMIM_FLAGS;
                if (SUCCEEDED(_GetInfo(pmd->GetPidl(), &sminfo)))
                {
                    pmd->SetFlags(sminfo.dwFlags);
                }
            }
        }
    }
}

void CMenuSFToolbar::_FindMinPromotedItems(BOOL fSetOrderStream)
{
    // We need to iterate through the buttons and set the Promoted flag.
    int cButton = ToolBar_ButtonCount(_hwndMB);
    for (int iButton = 0; iButton < cButton; iButton++)
    {
        int idCmd = GetButtonCmd(_hwndTB, iButton);

        if (idCmd != _idCmdChevron)
        {
            // Get the information from that button.
            CMenuData* pmd = (CMenuData*)_IDToPibData(idCmd);

            if (pmd)
            {
                PORDERITEM poi = pmd->GetOrderItem();

                if (fSetOrderStream)
                {
                    DWORD dwFlags = pmd->GetFlags();
                    OrderItem_SetFlags(poi, dwFlags);
                }
                else    // Query the order stream
                {
                    DWORD dwFlags = OrderItem_GetFlags(poi);
                    DWORD dwOldFlags = pmd->GetFlags();

                    // When reading the flags from the registry, we only care about the demote flag.
                    if (dwFlags & SMIF_DEMOTED)
                    {
                        dwOldFlags |= SMIF_DEMOTED;
                    }
                    else if (!(dwOldFlags & SMIF_SUBMENU)) // Don't promote sub menus.
                    {
                        // Force a promote
                        CallCB(pmd->GetPidl(), SMC_PROMOTE, 0, 0);
                        dwOldFlags &= ~SMIF_DEMOTED;
                    }

                    pmd->SetFlags(dwOldFlags);

                }
            }
        }
    }

}

void CMenuSFToolbar::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    CMenuToolbarBase::v_Show(fShow, fForceUpdate);

    if (fShow)
    {
        BOOL fDirty = _fDirty;
        _fClickHandled = FALSE;
        _RegisterToolbar();
        _FillToolbar();
        _pcmb->SetTracked(NULL);  // Since hot item is NULL
        ToolBar_SetHotItem(_hwndTB, -1);

        if (_fEmpty && (_dwFlags & SMSET_NOEMPTY))
        {
            _fDontShowEmpty = TRUE;
        }
        else if (_fRefreshInfo && !fDirty)         // Do we need to refresh our information?
        {
            // Yes;
            _RefreshInfo();
        }

        // HACKHACK (lamadio) : There is a sizing issue, where the sizing between the
        // toolbars gets preemted by a resize of the menubar before the size calculation completes.
        // So:
        //  ShowDW  -   Asks each toolbar to calc it's width
        //  CMenuSFToolbar::v_Show - Does a _FillToolbar. Since (in this senario) an item
        //              Has been added, it calls _ToolbarChanged
        //  _ToolbarChanged -   This says to the menubar, I've changed sizes, recalc.
        //  ResizeMenuBar   - In the depths, it eventually calls OnPosRectChanged, which asks each
        //              Toolbar what it's size is. Since the menu portion has not calculated it yet,
        //              It has the old size which is has the old size of the sftoolbar. So everything
        //              Gets reset to that size.
        //

        // We only want to Call expand if we are dirty or the expand state has changed. We
        // call for the Dirty case, because Expand does some neat stuff in calculating the
        // number of promoted items. If the state has changed, we want to reflect that.
        BOOL fExpand = _pcmb->_pmbState ? _pcmb->_pmbState->GetExpand() : FALSE;
        if ((BOOL)_pcmb->_fExpanded != fExpand || fDirty || _fRefreshInfo)
        {
            fForceUpdate = TRUE;
            Expand(fExpand);
        }

        // Only do this in the beginning.
        if (_fFirstTime)
        {
            CallCB(NULL, SMC_GETMINPROMOTED, 0, (LPARAM)&_cMinPromotedItems);

            if (_cPromotedItems < _cMinPromotedItems)
            {
                _FindMinPromotedItems(FALSE);
                Expand(fExpand);
            }
        }

        // Have the menubar think about changing its height
        // we need to do this here because the menubar may have changed it's
        // expand state independant of the pane.
        IUnknown_QueryServiceExec(_pcmb->_punkSite, SID_SMenuPopup, &CGID_MENUDESKBAR, 
            MBCID_SETEXPAND, (int)_pcmb->_fExpanded, NULL, NULL);
    
        // If we're dirty, have our parent consider promoting itself if there
        // are promoted items in the menu, or demoting itself if there arn't.
        // Don't worry, the parent won't do anything if it's already in that state.
        if ( fDirty )
        {
            IUnknown_RefreshParent(_pcmb->_punkSite, _pidl,
            ((_cPromotedItems == 0)? SMINV_DEMOTE : SMINV_PROMOTE) | SMINV_NEXTSHOW);
        }


        // If it is empty, we want to auto expand.
        // We have to do this before the update buttons, so that the size is calculate correctly.
        if (_cPromotedItems == 0 && !_pcmb->_fExpanded)
            Expand(TRUE);

        if (fForceUpdate)
            _UpdateButtons();

        if (_fHasDemotedItems)
        {
            if (S_OK == CallCB(NULL, SMC_DISPLAYCHEVRONTIP, 0, 0))
            {
                _FlashChevron();
            }
        }

        _fFirstTime = FALSE;
        _fRefreshInfo = FALSE;
    }
    else
    {
        KillTimer(_hwndMB, MBTIMER_UEMTIMEOUT);
    }
    _fShowMB = _fShow = fShow;


    // Reset these so we don't have stale information for the next drag drop cycle. NT #287914 (lamadio) 3.22.99
    _tbim.iButton = -1;
    _tbim.dwFlags = 0;

    _idCmdDragging = -1;

    // n.b. for !fShow, we don't kill the tracked site chain.  we
    // count on this in startmnu.cpp!CStartMenuCallback::_OnExecItem,
    // where we walk up the chain to find all hit 'nodes'.  if we need
    // to change this we could fire a 'pre-exec' event.
}


void CMenuSFToolbar::v_UpdateButtons(BOOL fNegotiateSize) 
{
    CSFToolbar::_UpdateButtons();
    if (_hwndTB && fNegotiateSize && _fVerticalMB)
        NegotiateSize();
}


// this method invalidates a single item in the toolbar
HRESULT CMenuSFToolbar::v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{
    ASSERT(_pcmb); // if you hit this assert, you haven't initialized yet.. call SetSite first

    // Default to not not handling this event.
    HRESULT hres = S_FALSE;

    if (NULL == psmd)
    {
        if (dwFlags & SMINV_REFRESH)
        {
            // bugbug: Needs to be optimized
            _Refresh();
            hres = S_OK;
        }
    }

    // CMenuSFToolbar only handles ShellFolder items.
    // Is this a shell folder?
    else if (psmd->dwMask & SMDM_SHELLFOLDER)
    {
        // Yes;
        int i;
        LPITEMIDLIST pidlButton = NULL;
        SMINFO sminfo;
        sminfo.dwMask = SMIM_FLAGS;

        // Since this pidl is comming from an outside source, 
        // we may need to translate it to a wrapped pidl.

        // Do we have a pidl Translator?
        if (_ptscn)
        {
            // Yes; 
            LPITEMIDLIST pidlTranslated;
            LPITEMIDLIST pidlDummy = NULL;
            LPITEMIDLIST pidlToTranslate = ILCombine(psmd->pidlFolder, psmd->pidlItem);
            if (pidlToTranslate)
            {
                LONG lEvent = 0, lEvent2;
                LPITEMIDLIST pidlDummy1, pidlDummy2;
                if (SUCCEEDED(_ptscn->TranslateIDs(&lEvent, pidlToTranslate, NULL, &pidlTranslated, &pidlDummy,
                                                   &lEvent2, &pidlDummy1, &pidlDummy2)))
                {
                    // Get the button in the toolbar that corresponds to this pidl.
                    pidlButton = _GetButtonFromPidl(ILFindLastID(pidlTranslated), NULL, &i);

                    // if pidl does not get translated TranslateIDs returns the same pidl passed
                    // to the function
                    if (pidlTranslated != pidlToTranslate)
                        ILFree(pidlTranslated);
                    // Don't need to delete pidlDummy because it's not set.
                    ASSERT(pidlDummy == NULL);
                    ASSERT(pidlDummy1 == NULL);
                    ASSERT(pidlDummy2 == NULL);
                }

                ILFree(pidlToTranslate);
            }
        }

        // Did we come from a non-augmented shell folder, or
        // did the caller pass a wrapped pidl? 
        if (!pidlButton)
        {
            // Seems like it, we'll try to find the pidl they passed in

            // Get the button in the toolbar that corresponds to this pidl.
            pidlButton = _GetButtonFromPidl(psmd->pidlItem, NULL, &i);
        }

        // Did we find this pidl in the toolbar?
        if (pidlButton)
        {

            int idCmd = GetButtonCmd(_hwndTB, i);

            // Yes, Get the information from that button.
            CMenuData* pmd = (CMenuData*)_IDToPibData(idCmd);

            if (pmd)
            {
                BOOL fRefresh = FALSE;
                DWORD dwFlagsUp = dwFlags;
                DWORD dwOldItemFlags = pmd->GetFlags();
                DWORD dwNewItemFlags = dwOldItemFlags;
                if ((dwFlags & SMINV_DEMOTE) && 
                    (!(dwOldItemFlags & SMIF_DEMOTED) || dwFlags & SMINV_FORCE))
                {
                    if (!(dwFlags & SMINV_NOCALLBACK))
                    {
                        CallCB(pidlButton, SMC_DEMOTE, 0, 0);
                        BroadcastIntelliMenuState(pidlButton, FALSE);
                    }
                    dwNewItemFlags |= SMIF_DEMOTED;
                    dwFlagsUp |= SMINV_DEMOTE;
                }
                else if ((dwFlags & SMINV_PROMOTE) && 
                         ((dwOldItemFlags & SMIF_DEMOTED) || dwFlags & SMINV_FORCE))
                {
                    if (!(dwFlags & SMINV_NOCALLBACK))
                    {
                        CallCB(pidlButton, SMC_PROMOTE, 0, 0);
                        BroadcastIntelliMenuState(pidlButton, TRUE);
                    }

                    dwNewItemFlags &= ~SMIF_DEMOTED;
                    dwFlagsUp |= SMINV_PROMOTE;
                }

                // Was it promoted and now Demoted or
                // Was it demoted and now promoted
                if ((dwNewItemFlags & SMIF_DEMOTED) ^
                     (dwOldItemFlags & SMIF_DEMOTED))
                {
                    fRefresh = TRUE;
                    if (dwNewItemFlags & SMIF_DEMOTED)
                    {
                        // Yes; Then decrement the Promoted count
                        _cPromotedItems--;

                        // If we're decementing, then we not have a demoted item.
                        _fHasDemotedItems = TRUE;

                        // Have we dropped off the face of the earth?
                        if (_cPromotedItems == 0)
                        {
                            dwFlagsUp |= SMINV_DEMOTE;
                            Expand(TRUE);
                        }
                        else
                        {
                            fRefresh = FALSE;
                        }
                    }
                    else
                    {
                        int cButtons = ToolBar_ButtonCount(_hwndMB);
                        _cPromotedItems++;
                        if (cButtons == _cPromotedItems)
                        {

                            // if the button count is the number of promoted items,
                            // then we can't have any demoted items
                            // then we need to reset the _fHasDemotedItems flag so that
                            // we don't get a chevron and stuff...

                            _fHasDemotedItems = FALSE;
                        }

                        dwFlagsUp |= SMINV_PROMOTE;
                        fRefresh = TRUE;
                    }

                }

                if (fRefresh || dwFlags & SMINV_FORCE)
                    IUnknown_RefreshParent(_pcmb->_punkSite, _pidl, dwFlagsUp);

                if (dwOldItemFlags != dwNewItemFlags || dwFlags & SMINV_FORCE)
                {
                    if (dwFlags & SMINV_NEXTSHOW || !_fShow)
                    {
                        _fRefreshInfo = TRUE;
                    }
                    else
                    {
                        // Since we updated the flags, set them into the cache
                        pmd->SetFlags(dwNewItemFlags);

                        // Based on the new flags, do we enable?
                        DWORD dwState = ToolBar_GetState(_hwndTB, idCmd);
                        dwState |= TBSTATE_ENABLED;
                        if (dwNewItemFlags & SMIF_DEMOTED &&
                            !_pcmb->_fExpanded)
                        {
                            // No; We're not expanded and this is a demoted item
                            dwState |= TBSTATE_HIDDEN;
                            dwState &= ~TBSTATE_ENABLED;
                            _fHasDemotedItems = TRUE;

                            // Just in case the chevron is not there, we should
                            // try and add it. This call will never add more than 1
                            _AddChevron();
                        }
                        else if (!_fHasDemotedItems)
                        {
                            _RemoveChevron();
                        }

                        // Adjust the state of the button in the toolbar.
                        ToolBar_SetState(_hwndTB, idCmd, dwState);

                        _ToolbarChanged();
                    }
                }
            }
        }

        // We handled this one.
        hres = S_OK;
    }

    return hres;
}


LRESULT CMenuSFToolbar::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    switch (uMessage)
    {
    case WM_GETOBJECT:
        // Yet another poor design choice on the part of the accessibility team.
        // Typically, if you do not answer a WM_* you return 0. They choose 0 as their success
        // code.
        return _DefWindowProcMB(hwnd, uMessage, wParam, lParam);
        break;
    }

    return CSFToolbar::_DefWindowProc(hwnd, uMessage, wParam, lParam);
}

void CMenuSFToolbar::_SetFontMetrics()
{
    CMenuToolbarBase::_SetFontMetrics();

    if (_hwndPager && _pcmb->_pmbm)
        Pager_SetBkColor(_hwndPager, _pcmb->_pmbm->_clrBackground);
}

int CMenuSFToolbar::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iIcon = -1;


    // If we don't have a pibdata, or we can't get an icon return.
    if (!pibdata || pibdata->GetNoIcon())
        return -1;

    if (_dwFlags & SMSET_USEBKICONEXTRACTION)
    {
        LPITEMIDLIST pidlItem = pibdata->GetPidl();
        // If the caller is using background icon extraction, we need them to provide a
        // default icon that we are going to display until we get the real one. This is 
        // specifically to make favorites fast.
        if (_iDefaultIconIndex == -1)
        {
            TCHAR szIconPath [MAX_PATH];

            if (S_OK == CallCB(NULL, SMC_DEFAULTICON, (WPARAM)szIconPath, (LPARAM)&iIcon))
            {
                _iDefaultIconIndex = Shell_GetCachedImageIndex(szIconPath, iIcon, 0);
            }
        }

        iIcon = _iDefaultIconIndex;

        DWORD dwAttrib = 0;

        if (pidlItem && SUCCEEDED(_psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlItem, &dwAttrib)))
        {
            if (dwAttrib & SFGAO_FOLDER)
                iIcon = II_FOLDER;
        }

        IShellTaskScheduler* pScheduler = _pcmb->_pmbState->GetScheduler();

        if (pScheduler)
        {
            IShellFolder* psf = NULL;
            LPITEMIDLIST pidlFolder = _pidl;
            LPITEMIDLIST pidlItemUnwrapped;

            // Since this can be an augmented shell folder, we should do the correct thing so that
            // the icon extraction with the full pidl takes place correctly. 
            if( _pasf2 && 
                S_OK == _pasf2->UnWrapIDList(pidlItem, 1, NULL, &pidlFolder, &pidlItemUnwrapped, NULL))
            {

                pidlItem = ILCombine(pidlFolder, pidlItemUnwrapped);
                ILFree(pidlFolder);
                ILFree(pidlItemUnwrapped);
            }
            else
            {
                psf = _psf;
            }

            // AddIconTask takes ownership of the pidl when psf is NULL and will free it.
            HRESULT hres = AddIconTask(pScheduler, psf, pidlFolder, pidlItem, 
                s_IconCallback, (LPVOID)_hwndTB, iCommandID, NULL);

            pScheduler->Release();

            if (FAILED(hres))
            {
                // If that call failed for some reason, default to the shell32 impl.
                goto DoSyncMap;
            }
        }
        else
            goto DoSyncMap;

    }
    else
    {
    DoSyncMap:
        iIcon = CSFToolbar::_GetBitmap(iCommandID, pibdata, fUseCache);
    }

    return iIcon;
} 

void CMenuSFToolbar::s_IconCallback(LPVOID pvData, UINT uId, UINT iIconIndex)
{
    HWND hwnd = (HWND)pvData;
    if (hwnd && IsWindow(hwnd))
    {
        DAD_ShowDragImage(FALSE);
        SendMessage(hwnd, TB_CHANGEBITMAP, uId, iIconIndex);
        DAD_ShowDragImage(TRUE);
    }

}

HWND CMenuSFToolbar::GetHWNDForUIObject()   
{ 
    HWND hwnd = _pcmb->_pmbState->GetWorkerWindow(_hwndMB);
    if (hwnd)
        ::SetWindowPos(hwnd, HWND_TOPMOST, 0, 0, 0, 0, SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE);
    return hwnd;
}

HWND CMenuSFToolbar::CreateWorkerWindow()
{ 
    return GetHWNDForUIObject();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\mnstatic.h ===
#ifndef MENUST
#define MENUST

#include "mnbase.h"
#include "cwndproc.h"
#include "droptgt.h"

class CMenuBand;

class CMenuStaticToolbar : public CMenuToolbarBase,
                           public CDelegateDropTarget,
                           public CNotifySubclassWndProc
{
public:

    // *** IUnknown (override) ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CMenuToolbarBase::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CMenuToolbarBase::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);

    // *** CDelegateDropTarget Methods ***
    virtual HRESULT GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll);
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect);
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, 
                            DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    //*** IWinEventHandler (override) ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

    // Other public methods
    virtual void GetSize(SIZE* psize);

    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear);
    virtual BOOL v_TrackingSubContextMenu();
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons);
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate);
    virtual void v_UpdateButtons(BOOL fNegotiateSize);

    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual void CreateToolbar(HWND hwndParent);

    virtual void v_Close(); // override
    virtual void    v_OnEmptyToolbar();        // override
    virtual void v_OnDeleteButton(LPVOID pData);
    virtual HRESULT v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags);

    virtual HRESULT GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual HRESULT SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    inline virtual BOOL ShowAmpersand()   { return FALSE; }

    CMenuStaticToolbar(CMenuBand* pmb, HMENU hmenu, HWND hwnd, UINT idCmd, DWORD dwFlags);

protected:
    class CMenuStaticData
    {
    public:
        ~CMenuStaticData();
        void SetSubMenu(IUnknown* punk);
        HRESULT GetSubMenu(const GUID* pguidService, REFIID riid, void** ppvObj);
        IUnknown*   _punkSubMenu;
        DWORD       _dwFlags;
    };

    HWND    _hwndMenuOwner;
    HWND    _hwndDD;
    HMENU   _hmenu;
    UINT    _idCmd;
    int     _iDragOverButton;
    IContextMenu* _pcm;

    BITBOOL _fHasTopSep: 1;
    BITBOOL _fHasBottomSep: 1;
    BITBOOL _fTopSepRemoved: 1;
    BITBOOL _fBottomSepRemoved: 1;
    BITBOOL _fDirty: 1;


    LRESULT _OnAccelerator(NMCHAR* pnmChar);
    LRESULT (*_lpfnWndProc)(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CMenuStaticData* _IDToData(int idCmd);
    HRESULT CallCB(UINT idCmd, DWORD dwMsg, WPARAM wParam, LPARAM lParam);

protected:
    virtual ~CMenuStaticToolbar();

    // Window Proc and message handlers
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnNotify(LPNMHDR pnm);

    virtual int  v_GetDragOverButton()
        { return _iDragOverButton; };

    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch);
    virtual HRESULT v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd);
    virtual HRESULT v_ExecItem(int iCmd);
    virtual DWORD v_GetFlags(int iCmd);
    virtual void v_Refresh();
    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** ppvObj);
    virtual HRESULT v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj);

    LRESULT _OnGetObject(NMOBJECTNOTIFY*);
    LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    void _FillToolbar();
    void _OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode);
    void _Insert(int iIndex, MENUITEMINFO* pmii);
    void _CheckSeparators();
};


#endif // MENUST
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\mnfolder.h ===
#ifndef MENUSF
#define MENUSF

#include "mnbase.h"
#include "sftbar.h"

class CMenuData : public IBDATA
{
protected:
    IUnknown* _punkSubmenu;

public:
    CMenuData(PORDERITEM poi) : IBDATA(poi) {};
    virtual ~CMenuData();

    void SetSubMenu(IUnknown* pmb2);
    HRESULT GetSubMenu(const GUID* pguidService, REFIID riid, void**);
};

class CMenuBand;

class CMenuSFToolbar :  public CSFToolbar,
                        public CMenuToolbarBase
{
public:

    // *** IUnknown (override) ***
    //   This deliberately forwards AddRef and Release to CMenuToolbarBase, and
    //   forwards QI separately to CSFToolbar.
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CMenuToolbarBase::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CMenuToolbarBase::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IShellChangeNotify methods ***
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // *** IWinEventHandler methods (override) ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

    // *** CDelegateDropTarget methods ***
    virtual STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    virtual STDMETHODIMP DragLeave(void);
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect);
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    // Other public methods
    virtual HWND v_GetHWND() 
        { return _hwndTB; };

    virtual void v_ForwardMouseMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear);
    virtual BOOL v_TrackingSubContextMenu()  { return (BOOL) ( _pcm2 ? 1 : 0 );}; // Win64: should be ok since _pcm2 used as boolean in all contexts
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons);
    virtual void v_Close();
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate);
    virtual void v_UpdateButtons(BOOL fNegotiateSize);
    virtual void NegotiateSize();
    virtual void Expand(BOOL fExpand);

    virtual void GetSize(SIZE* size);
    virtual void SetWindowPos(LPSIZE psize, LPRECT prc, DWORD dwFlags);
    virtual void CreateToolbar(HWND hwndParent);

    virtual void    SetParent(HWND hwndParent);
    virtual HRESULT GetShellFolder(LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual void    v_OnEmptyToolbar();        // override
    virtual void v_OnDeleteButton(LPVOID pData);
    virtual HRESULT v_InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual HRESULT SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl);
    inline virtual BOOL ShowAmpersand()   { return TRUE; }

    // Change HKEY to IStream*
    CMenuSFToolbar(CMenuBand* pmb, IShellFolder* psf, LPCITEMIDLIST pidl, HKEY hKey, DWORD dwFlags);

protected:
    ~CMenuSFToolbar();

    // Window Proc Overrides
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferedEffect);
    virtual void _OnFSNotifyAdd(LPCITEMIDLIST pidl);
    virtual void _OnFSNotifyRemove(LPCITEMIDLIST pidl);
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    virtual void _FillToolbar();
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnTimer(WPARAM wParam);
    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW * pnmcd) 
        { return CMenuToolbarBase::_OnCustomDraw(pnmcd); };
    virtual void    _SetToolbarState()
        { CMenuToolbarBase::_SetToolbarState(); };

    virtual void EmptyToolbar()
        { CMenuToolbarBase::EmptyToolbar(); };

    virtual int  v_GetDragOverButton()
        { return _tbim.iButton; };

    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** pObj);
    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch);
    virtual HRESULT v_CallCBItem(int idtCmd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd);

    virtual HRESULT v_ExecItem(int iCmd);
    virtual DWORD v_GetFlags(int iCmd);
    virtual void v_Refresh() 
        { _Refresh(); };
    virtual void v_CalcWidth(int* pcxMin, int* pcxMax) 
        { CMenuToolbarBase::v_CalcWidth(pcxMin, pcxMax); };

    // Utility Functions
    virtual BOOL _AddPidl(LPITEMIDLIST pidl, int index);
    virtual PIBDATA _AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb);
    virtual void _Dropped(int nIndex, BOOL fDroppedOnSource);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, DWORD * pdwStyle, 
        DWORD* pdwState, DWORD * pdwFlags,int* piIcon);

    virtual void _ToolbarChanged();
    virtual void _FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags);
    virtual BOOL _FilterPidl(LPCITEMIDLIST pidl);
    virtual void _ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax);
    virtual HMENU _GetContextMenu(IContextMenu* pcm, int* pid);
    virtual void _OnDefaultContextCommand(int idCmd);
    virtual void v_NewItem(LPCITEMIDLIST pidl);
    virtual void _SetDirty(BOOL fDirty);
    virtual void _SetFontMetrics();
    virtual int  _GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache);
    virtual HWND GetHWNDForUIObject();
    virtual HWND CreateWorkerWindow();

    static  void s_IconCallback(LPVOID pvData, UINT uId, UINT iIconIndex);

    void _AddChevron();
    void _RemoveChevron();
    void _RefreshInfo();

    void BroadcastIntelliMenuState(LPCITEMIDLIST pidlItem, BOOL fPromoted);

    BOOL _ReBindToFolder(LPCITEMIDLIST pidl);
    
    virtual HRESULT _LoadOrderStream();
    virtual HRESULT _SaveOrderStream();

    virtual HRESULT _AfterLoad();
    HRESULT _GetInfo(LPCITEMIDLIST pidl, SMINFO* pmbiinfo);
    HRESULT CallCB(LPCITEMIDLIST pidl, DWORD dwMsg, WPARAM wParam, LPARAM lParam);
    HKEY _GetKey(LPCITEMIDLIST pidl);
    void _MarkItem(int idCmd);
    LRESULT _OnGetObject(NMOBJECTNOTIFY*);
    void _FindMinPromotedItems(BOOL fSetOrderStream);


    virtual LRESULT _OnDropDown(LPNMTOOLBAR pnmtb);

    virtual HRESULT v_CreateTrackPopup(int, REFIID, void**) 
        { AssertMsg(0, TEXT("MenuSF trying to get a TrackPopup")); return E_FAIL; };

    virtual PIBDATA _CreateItemData(PORDERITEM poi);

    // Member Variables
    HKEY    _hKey;
    BITBOOL _fPreventToolbarChange: 1;

    IAugmentedShellFolder2* _pasf2;

    int     _iDefaultIconIndex;

    int     _cMinPromotedItems;

};

#define MNFOLDER_NORODER   -5       // Some random negative number to denote there is no order
#define MNFOLDER_IS_PARENT -1       // -1 is passed to the child as uIdParent so that 
                                    // it knows it's not rooted at a static menu
#endif  // MENUSF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\qlink.cpp ===
#include "priv.h"
#include "sccls.h"
#include "itbar.h"
#include "itbdrop.h"
#include "qlink.h"
#include "resource.h"
#include "dpastuff.h"

#include "bands.h"
#include "isfband.h"
#include "bandprxy.h"
#include "uemapp.h"

#include "mluisupp.h"

#define SUPERCLASS CISFBand

#define DM_PERSIST      DM_TRACE        // trace IPS::Load, ::Save, etc.


class CQuickLinks : public CISFBand
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CISFBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CISFBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    
    // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID);
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pstm, BOOL fClearDirty);
    
    // *** IDockingWindow methods (override) ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw) { return CISFBand::CloseDW(dw); };
    
    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite) { return CISFBand::SetSite(punkSite); };

    // *** IOleCommandTarget ***
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup,
                              DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn,
                              VARIANTARG *pvarargOut);
    
    // *** IDeskBand methods ***
    virtual STDMETHODIMP GetBandInfo(DWORD dwBandID, DWORD fViewMode, 
                                   DESKBANDINFO* pdbi);

    // *** IDelegateDropTarget ***
    virtual HRESULT OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);
protected:    
    CQuickLinks();
    virtual ~CQuickLinks();

    HRESULT _GetTitleW(LPWSTR pwzTitle, DWORD cchSize);
    HRESULT _InternalInit(void);

    virtual HRESULT _LoadOrderStream();
    virtual HRESULT _SaveOrderStream();
    virtual BOOL    _AllowDropOnTitle() { return TRUE; };
    virtual HRESULT _GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum);

private:    
    BITBOOL    _fIsInited :1;
    BITBOOL    _fSingleLine :1;

    friend HRESULT CQuickLinks_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);    // for ctor
};

#define MAX_QL_SITES            5   // Number of Sites on the quick link bar

#define SZ_REGKEY_SPECIALFOLDERS  TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders")

HRESULT SHGetSpecialFolderPathEx(LPTSTR pszPath, DWORD cchSize, DWORD dwCSIDL, LPCTSTR pszFolderName)
{
    HRESULT hr = S_OK;
    
    if (SHGetSpecialFolderPath(NULL, pszPath, CSIDL_FAVORITES, TRUE))
        return hr;

    cchSize *= sizeof(TCHAR);   // Count of chars to count of bytes.
    if (ERROR_SUCCESS != SHGetValue(HKEY_CURRENT_USER, SZ_REGKEY_SPECIALFOLDERS, pszFolderName, NULL, pszPath, &cchSize))
        hr = E_FAIL;

    TraceMsg(TF_BAND|TF_GENERAL, "CQuickLinks SHGetSpecialFolderPath(CSIDL_FAVORITES), Failed so getting Fav dir from registry. Path=%s; hr=%#8lx", pszPath, hr);
    
    return hr;
}

#define LINKS_FOLDERNAME_KEY   TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar")
#define LINKS_FOLDERNAME_VALUE TEXT("LinksFolderName")

// _GetTitleW and QuickLinks_GetFolder call this. 
// if we ever go back to ANSI days we'll get a build break
// right now we are saving some space by not having A version that's not used
void QuickLinks_GetName(LPTSTR pszName, DWORD cchSize, BOOL bSetup)
{
    DWORD cb = cchSize * SIZEOF(TCHAR);
    // try to get the name of the folder from the registry (in case of upgrade to a different
    // language we cannot use the resource)
    if (SHGetValue(HKEY_CURRENT_USER, LINKS_FOLDERNAME_KEY, LINKS_FOLDERNAME_VALUE, NULL, (void *)pszName, &cb) != ERROR_SUCCESS)
    {
        // no luck, try the HKLM if we are doing per user registration, maybe setup stored the old links folder name there
        cb = cchSize * SIZEOF(TCHAR);
        if (!bSetup || SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"), TEXT("LinkFolderName"), NULL, (void *)pszName, &cb) != ERROR_SUCCESS)
        {
            // if everything else fails load it from the resource
            MLLoadString(IDS_QLINKS, pszName, cchSize);
        }
    }
}

HRESULT QuickLinks_GetFolder(LPTSTR pszPath, DWORD cchSize, BOOL bSetup = FALSE)
{
    TCHAR szQuickLinks[MAX_PATH];

    if (SUCCEEDED(SHGetSpecialFolderPathEx(pszPath, cchSize, CSIDL_FAVORITES, TEXT("Favorites"))))
    {
        QuickLinks_GetName(szQuickLinks, ARRAYSIZE(szQuickLinks), bSetup);
        if (PathCombine(pszPath, pszPath, szQuickLinks))
        {
            return S_OK;
        }
    }    
    
    return E_FAIL;
}

#define QL_BUFFER (MAX_QL_TEXT_LENGTH + MAX_URL_STRING + MAX_TOOLTIP_STRING + 3)

//
// Load strings needed for quick links
//
// returns TRUE/FALSE if it was user specified (false used to load the default
// urls, but now we leave that to branding dll
BOOL QLLoadLinkName(HUSKEY hUSKey, int i, LPTSTR pszTitle, UINT cchTitle, LPTSTR pszURL, UINT cchURL)
{
    CHAR szScratch[QL_BUFFER];
    DWORD dwcbData = SIZEOF(szScratch);
    CHAR * pszTemp;
    TCHAR szRegValues[12];

    // In IE3, links did not have its own folder.  Instead, links were stored in the registry as a
    // set of binary streams of ANSI strings.
    StringCchPrintf(szRegValues, ARRAYSIZE(szRegValues), TEXT("%d"), i+1);      // ok to truncate
    if (hUSKey && 
        (ERROR_SUCCESS == SHRegQueryUSValue(hUSKey, szRegValues, NULL, (LPBYTE)szScratch, &dwcbData, FALSE, NULL, 0)))
    {
        int nNULLs = 0;
        pszTemp = szScratch;
        DWORD j;
        for (j = 0; j < dwcbData; j++)
        {
#ifdef MAINWIN
            // Because of the limitations of the MainWin registry, we'll put '*' instead of '\0'.
            if (*pszTemp == TEXT('*'))
                *pszTemp = '\0';
#endif
            nNULLs += (UINT)(*pszTemp++ == TEXT('\0'));
        }

        // make sure we have 3 strings with a double NULL at the end
        if (nNULLs > 3)
        {
            pszTemp = szScratch;
            SHAnsiToTChar(pszTemp, pszTitle, cchTitle);
            pszTemp += lstrlenA(pszTemp) + 1;
            SHAnsiToTChar(pszTemp, pszURL, cchURL);
            return TRUE;
        }
    }
    return FALSE;
}

void ImportQuickLinks()
{
    TCHAR szQuickLinksDir[MAX_PATH];

    if (FAILED(QuickLinks_GetFolder(szQuickLinksDir, ARRAYSIZE(szQuickLinksDir), TRUE)))
        return;
        
    // need to write the folder name to the registry so we can use it w/ different plug ui languages
    LPTSTR pszQLinks;
    DWORD cb;

    PathRemoveBackslash(szQuickLinksDir);
    pszQLinks = PathFindFileName(szQuickLinksDir);
    if (pszQLinks)
    {
        cb = (lstrlen(pszQLinks)+1) * sizeof(TCHAR);
        SHSetValue(HKEY_CURRENT_USER, LINKS_FOLDERNAME_KEY, LINKS_FOLDERNAME_VALUE, REG_SZ, (void *)pszQLinks, cb);
    }

    if (!PathFileExists(szQuickLinksDir) &&
        CreateDirectory(szQuickLinksDir, NULL))
    {
        HUSKEY hUSKey = NULL;

        if (ERROR_SUCCESS == SHRegOpenUSKey(TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar\\Links"), KEY_QUERY_VALUE, NULL, &hUSKey, FALSE))
        {
            // we found the key, there's something to migrate
            for (int i = 0; i < MAX_QL_SITES; i++)
            {
                // this was user specified...  convert it
                LPITEMIDLIST pidl;
                TCHAR szURLTemp[MAX_URL_STRING];
                TCHAR szTitle[MAX_QL_TEXT_LENGTH];

                if (QLLoadLinkName(hUSKey, i, szTitle, ARRAYSIZE(szTitle), szURLTemp, ARRAYSIZE(szURLTemp)))
                {
                    WCHAR szURL[MAX_URL_STRING];
                    if (SUCCEEDED(URLSubstitution(szURLTemp, szURL, ARRAYSIZE(szURL), URLSUB_ALL)) &&
                        SUCCEEDED(IECreateFromPath(szURL, &pidl)))
                    {
                        CreateShortcutInDir(pidl, szTitle, szQuickLinksDir, NULL, FALSE);
                        ILFree(pidl);
                    }
                }
            }
            SHRegCloseUSKey(hUSKey);

            // all converted, delete the key
            SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar\\Links"));
        }
    }
    else
    {
        // ie4 -> ieX upgrade
        // create a value in hkcu\sw\ms\ie\toolbar to indicate that we should preserve the order from the links stream
        // not the one from the favorites\links that we are using for links starting w/ ie5
        BOOL bVal = TRUE;
        // we don't care if this fails. if it does we'll just just favorites\links order stream
        SHSetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"), 
                   TEXT("SaveLinksOrder"), REG_BINARY, (DWORD *)&bVal, SIZEOF(bVal));
    }
}

HRESULT CQuickLinks::_InternalInit(void)
{
    HRESULT hr = S_OK;

    if (!_fIsInited && !_psf)
    {
        TCHAR szPath[MAX_PATH];

        hr = QuickLinks_GetFolder(szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlQLinks;

            if (!PathFileExists(szPath))
                CreateDirectory(szPath, NULL);

            if (SUCCEEDED(IECreateFromPath(szPath, &pidlQLinks)))
            {
                InitializeSFB(NULL, pidlQLinks);
                ILFree(pidlQLinks);
            }
        }
    }
    _fIsInited = TRUE;

    return hr;
}

CQuickLinks::CQuickLinks() :
    SUPERCLASS()
{
    
#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in CQuickLinks ctor");
        DEBUG_BREAK;
    }
#endif
    
    ASSERT(!_fIsInited);
    _fCascadeFolder = TRUE;
    _fVariableWidth = TRUE;

    _pguidUEMGroup = &UEMIID_BROWSER;
    
}

CQuickLinks::~CQuickLinks()
{
}

STDAPI CQuickLinks_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    CQuickLinks * p = new CQuickLinks();
    if (p) 
    {
        *ppunk = SAFECAST(p, IDeskBand *);
        return NOERROR;
    }
    *ppunk = NULL;
    return E_OUTOFMEMORY;
}

HRESULT CQuickLinks::_LoadOrderStream()
{
    HRESULT hr = E_FAIL;

    if (_pidl && _psf) {
        IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, _pidl, REG_SUBKEY_FAVORITESA, STGM_READ);

        if (pstm) {
            OrderList_Destroy(&_hdpaOrder);

            hr = OrderList_LoadFromStream(pstm, &_hdpaOrder, _psf);

            pstm->Release();
        }
    }

    return hr;
}

HRESULT CQuickLinks::_SaveOrderStream()
{
    HRESULT hr = E_FAIL;

    if (_pidl && (_hdpa || _hdpaOrder)) {
        IStream* pstm = OpenPidlOrderStream((LPCITEMIDLIST)CSIDL_FAVORITES, _pidl, REG_SUBKEY_FAVORITESA, STGM_CREATE | STGM_WRITE);

        if (pstm) {
            hr = OrderList_SaveToStream(pstm, (_hdpa ? _hdpa : _hdpaOrder), _psf);

            pstm->Release();
        }
    }

    if (SUCCEEDED(hr))
        hr = SUPERCLASS::_SaveOrderStream();

    return hr;
}

HRESULT CQuickLinks::_GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum)
{
    HRESULT hres;
    
    ASSERT(_psf);
    // Pass in a NULL hwnd so the enumerator does not show any UI while
    // we're filling a band.    
    hres = IShellFolder_EnumObjects(_psf, NULL, dwEnumFlags, ppenum);
    // we could have failed because our folder does not exist
    // that can happen if someone delted/renamed links while there is 
    // stream in the registry that saves the pidl - we get the pidl and
    // bind to it (bind does not hit the disk so it succeeds even though
    // the file does not exist
    if (FAILED(hres) && hres != E_OUTOFMEMORY)
    {
        TCHAR szPath[MAX_PATH];

        ASSERT(_pidl);
        if (SHGetPathFromIDList(_pidl, szPath) && !PathFileExists(szPath))
        {
            hres = QuickLinks_GetFolder(szPath, ARRAYSIZE(szPath));
            if (SUCCEEDED(hres))
            {
                LPITEMIDLIST pidlQLinks;
            
                if (!PathFileExists(szPath))
                    CreateDirectory(szPath, NULL);

                hres = IECreateFromPath(szPath, &pidlQLinks);
                if (SUCCEEDED(hres))
                {
                    hres = InitializeSFB(NULL, pidlQLinks);
                    if (SUCCEEDED(hres))
                    {
                        hres = _psf->EnumObjects(NULL, dwEnumFlags, ppenum);
                    }
                    ILFree(pidlQLinks);
                }
            }
        }
    }
    return hres;
}

//*** CQuickLinks::IPersistStream
HRESULT CQuickLinks::Load(IStream *pstm)
{
    HRESULT hr = S_OK;

    hr = SUPERCLASS::Load(pstm);

    // This forces a refresh
    _fIsInited = FALSE;
    ATOMICRELEASE(_psf);
    _InternalInit();



    // if we are on our first run through (i.e. this reg key exists)
    // we load the order stream from our old location (used in ie4) and avoid overwriting it w/ favorites stream
    // so user can have their custom order preserved on upgrade (they are more likely to customize links bar 
    // order then favorites/links so we picked that one)
    if (SHGetValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"), 
                   TEXT("SaveLinksOrder"), NULL, NULL, NULL) == ERROR_SUCCESS)
    {
        SHDeleteValue(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\Toolbar"), TEXT("SaveLinksOrder"));
        // must persist old order stream in the new location (fav/links)
        _SaveOrderStream();
    }
    else
    {
        _LoadOrderStream();
    }

    return hr;
}

HRESULT CQuickLinks::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hr = SUPERCLASS::Save(pstm, fClearDirty);

    _SaveOrderStream();

    return hr;
}

HRESULT CQuickLinks::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_QuickLinks;
    return S_OK;
}

// *** IUnknown Interface ***
HRESULT CQuickLinks::QueryInterface(REFIID riid, void **ppvObj)
{
    return SUPERCLASS::QueryInterface(riid, ppvObj);
}

// command target
STDMETHODIMP CQuickLinks::Exec(const GUID *pguidCmdGroup, DWORD nCmdID,
    DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hres = S_FALSE;
    if (pguidCmdGroup)
    {
        if (IsEqualGUID(*pguidCmdGroup, CLSID_QuickLinks)) 
        {
            switch (nCmdID) 
            {
            case QLCMD_SINGLELINE:
                _fSingleLine = (nCmdexecopt == 1);
                return S_OK;
            }
        }
        else if (IsEqualGUID(*pguidCmdGroup, CGID_ISFBand))
        {
            switch(nCmdID)
            {
            case ISFBID_SETORDERSTREAM:
                hres = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
                _SaveOrderStream();
                break;
            }
        }
    }

    if (hres ==  S_FALSE)
        hres = SUPERCLASS::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);

    return hres;
}

// *** IDockingWindow Interface ***
HRESULT CQuickLinks::ShowDW(BOOL fShow)
{
    if (fShow)
        _InternalInit();

    return SUPERCLASS::ShowDW(fShow);
}

    
HRESULT CQuickLinks::_GetTitleW(LPWSTR pwzTitle, DWORD cchSize)
{
    QuickLinks_GetName(pwzTitle, cchSize, FALSE);
    return S_OK;
}


HRESULT CQuickLinks::GetBandInfo(DWORD dwBandID, DWORD fViewMode, DESKBANDINFO* pdbi) 
{
   HRESULT hres = SUPERCLASS::GetBandInfo(dwBandID, fViewMode, pdbi);
   
   if (_hwndTB && _fSingleLine) {
       LRESULT lButtonSize = SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0L);
       pdbi->ptMinSize.y = HIWORD(lButtonSize);
       
       pdbi->dwModeFlags &= ~DBIMF_VARIABLEHEIGHT;
   }
   return hres;
    
}

HRESULT CQuickLinks::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hr;
    BOOL    fIsSafe = TRUE;

    // if we are not the source of the drop and the Links folder does not exist we need to create it
    if (_iDragSource == -1)
    {
        TCHAR szPath[MAX_PATH];

        hr = QuickLinks_GetFolder(szPath, ARRAYSIZE(szPath));
        if (SUCCEEDED(hr))
        {
            if (!PathFileExists(szPath))
                CreateDirectory(szPath, NULL);

            LPITEMIDLIST pidl;
            if (SUCCEEDED(SHPidlFromDataObject(pdtobj, &pidl, NULL, 0)))
            {
                fIsSafe = IEIsLinkSafe(_hwnd, pidl, ILS_LINK);
                ILFree(pidl);
            }
        }
        else
        {
            fIsSafe = FALSE;
        }
    }

    if (fIsSafe)
    {
        hr = SUPERCLASS::OnDropDDT(pdt, pdtobj, pgrfKeyState, pt, pdwEffect);
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\resdll\makefile.inc ===
..\browselc.rc : $(SDK_LIB_PATH)\exdisp.tlb $(BROWSEUI_DEP)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\sftbar.h ===
#ifndef CSFTOOLBAR
#define CSFTOOLBAR

#include "iface.h"
#include "bands.h"
#include "cwndproc.h"
#include "droptgt.h"

// Each CISFBand toolbar button lParam points to one of these.
class IBDATA
{
protected:

    DWORD        _dwFlags;      // Class specific flags
    BITBOOL      _fNoIcon:1;
    PORDERITEM   _poi;

public:
    IBDATA(PORDERITEM poi)                  { _poi = poi; }
    virtual ~IBDATA()                       { /* Don't Delete Me */ }

    LPITEMIDLIST GetPidl()                  { return _poi ? _poi->pidl : NULL; }
    void         SetOrderItem(PORDERITEM poi) { _poi = poi; }
    DWORD        GetFlags()                 { return _dwFlags; }
    void         SetFlags(DWORD dwFlags)    { _dwFlags = dwFlags; }
    BOOL         GetNoIcon()                { return _fNoIcon; }
    void         SetNoIcon(BOOL b)          { _fNoIcon = BOOLIFY(b); }
    PORDERITEM   GetOrderItem()             { return _poi ; }
};

typedef IBDATA * PIBDATA;

// Special HitTest results
#define IBHT_SOURCE         (-32768)
#define IBHT_BACKGROUND     (-32767)
#define IBHT_PAGER          (-32766)
#define IBHT_OUTSIDEWINDOW  (-32765)

class CSFToolbar :  public IWinEventHandler, 
                    public IShellChangeNotify, 
                    public CDelegateDropTarget, 
                    public IContextMenu, 
                    public IShellFolderBand,
                    public CNotifySubclassWndProc
{
public:
    // *** IUnknown methods (override) ***
    virtual STDMETHODIMP_(ULONG) AddRef(void)  PURE;
    virtual STDMETHODIMP_(ULONG) Release(void) PURE;
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent (HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IShellChangeNotify methods ***
    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    // *** CDelegateDropTarget ***
    virtual HRESULT GetWindowsDDT (HWND * phwndLock, HWND * phwndScroll);
    virtual HRESULT HitTestDDT (UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect);
    virtual HRESULT GetObjectDDT (DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj);
    virtual HRESULT OnDropDDT (IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect);

    // *** IContextMenu methods ***
    virtual STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
    virtual STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO lpici);
    virtual STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax);

    // *** IShellFolderBand ***
    virtual STDMETHODIMP InitializeSFB(LPSHELLFOLDER psf, LPCITEMIDLIST pidl) { return SetShellFolder(psf, pidl); };
    virtual STDMETHODIMP SetBandInfoSFB(BANDINFOSFB * pbi)  { return E_NOTIMPL; };
    virtual STDMETHODIMP GetBandInfoSFB(BANDINFOSFB * pbi)  { return E_NOTIMPL; };

    // Toolbar Management
    virtual HRESULT SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl);
    virtual void    EmptyToolbar();

protected:
    CSFToolbar();
    virtual    ~CSFToolbar();

    virtual    void _CreateToolbar(HWND hwndParent);
    virtual HWND _CreatePager(HWND hwndParent);
    void    _DestroyToolbar();
    virtual void    _FillToolbar();
    void    _UnregisterToolbar();
    void    _RegisterToolbar();
    void    _RegisterChangeNotify();
    void    _UnregisterChangeNotify();      // Unregisters 

    void    _Refresh();
    void    _ReleaseShellFolder();

    virtual BOOL _AddPidl(LPITEMIDLIST pidl, int index);
    virtual PIBDATA _AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb);
    virtual void _FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags);
    virtual PIBDATA _CreateItemData(PORDERITEM poi);
    virtual HWND GetHWNDForUIObject() { return _hwndTB; };
    virtual HRESULT _LoadOrderStream() { return E_NOTIMPL; };
    virtual HRESULT _SaveOrderStream();
    virtual BOOL    _AllowDropOnTitle() { return FALSE; };
    virtual HRESULT _GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum);

    LPITEMIDLIST    _pidl;
    IShellFolder*    _psf;
    ITranslateShellChangeNotify*    _ptscn;

    HWND            _hwndPager;
    HWND            _hwndTB;
    HWND            _hwndToolTips;

    DWORD           _dwStyle;           // style bits to be ORd in when _hwndTB is created
    TBINSERTMARK    _tbim;
    int             _iDragSource;
    HDPA            _hdpaOrder;         // current order list (if non-default)
    HDPA            _hdpa;              // current set of items, mirrors _hwndTB content
    long            _lEvents;

    int             _iButtonCur;
    IContextMenu    *_pcmSF;
    IContextMenu2 * _pcm2;

    int             _nNextCommandID;
    int             _idCmdSF;
    int             _cxMin;
    int             _cxMax;
    HWND            _hwndDD;
    HWND            _hwndWorkerWindow;

    // Flags
    BITBOOL         _fNoShowText :1;    // TRUE iff no text with icon
    BITBOOL         _fShow :1;          // TRUE when ShowDW has happened
    BITBOOL         _fDirty :1;         // TRUE iff hidden contents modified
    BITBOOL         _fCheckIds :1;      // TRUE iff _GetCommandID has wrapped
    BITBOOL         _fFSNotify :1;      // TRUE to receive FS Notifications
    BITBOOL         _fFSNRegistered :1; // are we already registered?
    BITBOOL         _fAccelerators :1;  // whether to show & as accel or as &
    BITBOOL         _fAllowRename :1;   // TRUE to query _psf for IContextMenu of _pidl
    BITBOOL         _fDropping :1;      // TRUE while doing drop.
    BITBOOL         _fDropped :1;       // TRUE if we have reordered, _hdpaOrder may not have been created yet
    BITBOOL         _fNoNameSort :1;    // TRUE if band should _not_ sort icons by name
    BITBOOL         _fVariableWidth :1; 
    BITBOOL         _fNoIcons :1;       // turns off icons
    BITBOOL         _fVertical :1;      // TRUE: band is displayed vertically
    BITBOOL         _fMulticolumn : 1;
    BITBOOL         _fHasOrder: 1;
    BITBOOL         _fPSFBandDesktop :1;// TRUE iff _psfBand came from desktop
                                            //          this implies psfDesktop->BindToObject(_pidl)
                                            //          results in the correct ISF
    BITBOOL         _fRegisterChangeNotify: 1;  // TRUE: We will register for change notify.
    BITBOOL         _fAllowReorder: 1;
    BITBOOL         _fChangedOrder: 1;      // Only send change notifies if we actually changed the order
    UINT            _uIconSize : 2;     // Large/Small/Logo


    // Virtual Function Overrides for Window Subclass
    virtual LRESULT _OnHotItemChange(NMTBHOTITEM * pnmhot);
    virtual HRESULT OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual LRESULT _OnTimer(WPARAM wParam);
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    virtual LRESULT _OnCustomDraw(NMCUSTOMDRAW* pnmcd);
    virtual void _OnDragBegin(int iItem, DWORD dwPreferedEffect);
    virtual void _OnToolTipsCreated(NMTOOLTIPSCREATED* pnm);
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnCommand(WPARAM wParam, LPARAM lParam) { return 0; };
    virtual void _OnFSNotifyAdd(LPCITEMIDLIST pidl);
    virtual void _OnFSNotifyRemove(LPCITEMIDLIST pidl);
    virtual void _OnFSNotifyRename(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo);
    virtual void _OnFSNotifyUpdate(LPCITEMIDLIST pidl);
    virtual HRESULT _OnRenameFolder(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    virtual HMENU _GetContextMenu(IContextMenu* pcm, int* pid);
    virtual void _OnDefaultContextCommand(int idCmd);
    virtual LRESULT _OnContextMenu(WPARAM wParam, LPARAM lParam);
    
    // Helper Functions
    int     _GetCommandID();
    virtual void    _ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax);
    BOOL    _IsParentID(LPCITEMIDLIST pidl);
    BOOL    _IsChildID(LPCITEMIDLIST pidlChild, BOOL fImmediate);
    BOOL    _IsEqualID(LPCITEMIDLIST pidl);
    LPVOID  _GetUIObjectOfPidl(LPCITEMIDLIST pidl, REFIID riid);
    HMENU   _GetBaseContextMenu();
    HRESULT _GetTopBrowserWindow(HWND* phwnd);
    HRESULT _OnOpen(int id, BOOL fExplore);
    HRESULT _HandleSpecialCommand(IContextMenu* pcm, PPOINT ppt, int id, int idCmd);
    LRESULT _DoContextMenu(IContextMenu* pcm, LPPOINT ppt, int id, LPRECT prcExclude);
    void _SortDPA(HDPA hdpa);
    virtual HWND CreateWorkerWindow();

    BOOL_PTR InlineDeleteButton(int iIndex);

    static INT_PTR CALLBACK _RenameDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _OnRename(LPPOINT ppt, int id);
    UINT    _IndexToID(int iIndex);
    LPCITEMIDLIST _IDToPidl(UINT uiCmd, int *piPos = NULL);
    PIBDATA _IDToPibData(UINT uiCmd, int * piPos = NULL);
    PIBDATA _PosToPibData(UINT iPos);
    void    _RememberOrder();
    void    _UpdateButtons();
    void    _OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode);
    LPITEMIDLIST _GetButtonFromPidl(LPCITEMIDLIST pidl, TBBUTTONINFO * ptbbi, int * pIndex);
    DWORD   _GetAttributesOfPidl(LPCITEMIDLIST pidl, DWORD dwAttribs);
    BOOL    _UpdateShowText(BOOL fNoShowText);



    // Virtual Helper Functions
    virtual int     _GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache);
    virtual void    _SetDirty(BOOL fDirty);
    virtual HMENU   _GetContextMenu();
    virtual BOOL    _UpdateIconSize(UINT uIconSize, BOOL fUpdateButton);
    virtual HRESULT _TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags, int* piIcon);
    virtual BOOL    _FilterPidl(LPCITEMIDLIST pidl);
    virtual int     _DefaultInsertIndex();
    virtual void    _ToolbarChanged() { };
    virtual void    _Dropped(int nIndex, BOOL fDroppedOnSource);
    virtual HRESULT _AfterLoad();
    virtual void    v_CalcWidth(int* pcxMin, int* pcxMax);
    virtual void    _SetToolbarState();
    virtual void    v_NewItem(LPCITEMIDLIST pidl) {};

    static void s_NewItem(LPVOID pvParam, LPCITEMIDLIST pidl);
};

BOOL TBHasImage(HWND hwnd, int iImageIndex);
LRESULT CALLBACK HiddenWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\sftbar.cpp ===
#include "priv.h"
#include "sccls.h"

#include "iface.h"
#include "itbdrop.h"
#include "sftbar.h"
#include "resource.h"
#include "dpastuff.h"
#include "shlwapi.h"
#include "cobjsafe.h"
#include <iimgctx.h>
#include "uemapp.h"

#include "mluisupp.h"

extern UINT g_idFSNotify;

#define TF_SFTBAR   0x10000000      // Same ID as the AugMISF stuff

#define PGMP_RECALCSIZE  200

// do not set CMD_ID_FIRST to 0.  we use this to see if anything is selected
#define CMD_ID_FIRST    1
#define CMD_ID_LAST     0x7fff

CSFToolbar::CSFToolbar()
{
#ifdef CASCADE_DEBUG
    _fCascadeFolder = TRUE;
#endif
    _dwStyle = TBSTYLE_TOOLTIPS;
    _fDirty = TRUE; // we havn't enumerated, so our state is dirty
    _fRegisterChangeNotify = TRUE;
    _fAllowReorder = TRUE;

    _tbim.iButton = -1;
    _iDragSource = -1;
    _lEvents = SHCNE_DRIVEADD|SHCNE_CREATE|SHCNE_MKDIR|SHCNE_DRIVEREMOVED|
               SHCNE_DELETE|SHCNE_RMDIR|SHCNE_RENAMEITEM|SHCNE_RENAMEFOLDER|
               SHCNE_MEDIAINSERTED|SHCNE_MEDIAREMOVED|SHCNE_NETUNSHARE|SHCNE_NETSHARE|
               SHCNE_UPDATEITEM|SHCNE_UPDATEIMAGE|SHCNE_ASSOCCHANGED|
               SHCNE_UPDATEDIR|SHCNE_EXTENDED_EVENT;
}

CSFToolbar::~CSFToolbar()
{
    ATOMICRELEASE(_pcmSF);

    _ReleaseShellFolder();

    ILFree(_pidl);

    ASSERT(NULL == _hdpa);

    if (_hwndWorkerWindow)
        DestroyWindow(_hwndWorkerWindow);

    OrderList_Destroy(&_hdpaOrder);
}

HRESULT CSFToolbar::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CSFToolbar, IWinEventHandler),
        QITABENT(CSFToolbar, IShellChangeNotify),
        QITABENT(CSFToolbar, IDropTarget),
        QITABENT(CSFToolbar, IContextMenu),
        QITABENT(CSFToolbar, IShellFolderBand),
        { 0 },
    };

    return QISearch(this, qit, riid, ppvObj);
}

HRESULT CSFToolbar::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidl)
{
    HRESULT hres = E_INVALIDARG;
    // Save the old values
    LPITEMIDLIST pidlSave = _pidl;
    IShellFolder *psfSave = _psf;
    ITranslateShellChangeNotify *ptscnSave = _ptscn;

    _psf = NULL;
    _pidl = NULL;
    _ptscn = NULL;
    
    ASSERT(NULL == psf || IS_VALID_CODE_PTR(psf, IShellFolder));
    ASSERT(NULL == pidl || IS_VALID_PIDL(pidl));

    if (psf || pidl)
    {
        if (psf)
        {
            _psf = psf;
            _psf->AddRef();

            _psf->QueryInterface(IID_ITranslateShellChangeNotify, (LPVOID *)&_ptscn);
        }
            
        if (pidl)
            _pidl = ILClone(pidl);
        hres = S_OK;
    }

    if (SUCCEEDED(hres))
    {
        ILFree(pidlSave);
        if (psfSave)
            psfSave->Release();
        if (ptscnSave)
            ptscnSave->Release();
    }
    else
    {
        ASSERT(_psf == NULL);
        ASSERT(_pidl == NULL);
        ASSERT(_ptscn == NULL);
        // we failed -- restore the old values
        _psf = psfSave;
        _pidl = pidlSave;
        _ptscn = ptscnSave;
    }

    // This code is here for ShellFolderToolbar reuse. When setting a new shell folder
    // into an existing band, we will refresh. Note that this is a noop on a new band.

    _RememberOrder();
    _SetDirty(TRUE);
    if (_fShow)
        _FillToolbar();
    return hres;
}

HWND CSFToolbar::_CreatePager(HWND hwndParent)
{
    if (!_fMulticolumn)
    {
        _hwndPager = CreateWindowEx(0, WC_PAGESCROLLER, NULL,
                                 WS_CHILD | WS_TABSTOP |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS,
                                 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);
        if (_hwndPager)
        {
            hwndParent = _hwndPager;
        }
    }

    return hwndParent;
}

void CSFToolbar::_CreateToolbar(HWND hwndParent)
{
    if (!_hwndTB)
    {

        hwndParent = _CreatePager(hwndParent);

        _hwndTB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                 WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                                 WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
                                 CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                 CCS_NORESIZE | _dwStyle,
                                 0, 0, 0, 0, hwndParent, (HMENU) 0, HINST_THISDLL, NULL);
        if (_hwndPager)
            SendMessage(_hwndPager, PGM_SETCHILD, 0, (LPARAM)_hwndTB);

        if (!_hwndTB)
        {
            TraceMsg(TF_ERROR, "_hwndTB failed");
            return;
        }
        
        SendMessage(_hwndTB, TB_BUTTONSTRUCTSIZE,    SIZEOF(TBBUTTON), 0);

        // Set the format to ANSI or UNICODE as appropriate.
        ToolBar_SetUnicodeFormat(_hwndTB, DLL_IS_UNICODE);
        if (_hwndPager)
        {
            // Set the format to ANSI or UNICODE as appropriate.
            ToolBar_SetUnicodeFormat(_hwndPager, DLL_IS_UNICODE);
        }

        
#if 0 // Not going to do this for IE5.
        ToolBar_SetExtendedStyle(_hwndTB, 
            TBSTYLE_EX_HIDECLIPPEDBUTTONS, 
            TBSTYLE_EX_HIDECLIPPEDBUTTONS);
#endif

        // Make sure we're on the same wavelength.
        SendMessage(_hwndTB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        RECT rc;
        SIZE size;

        SystemParametersInfoA(SPI_GETWORKAREA, SIZEOF(RECT), &rc, FALSE);
        if (!_hwndPager)
        {
            size.cx = RECTWIDTH(rc);
            size.cy = GetSystemMetrics(SM_CYSCREEN) - (2 * GetSystemMetrics(SM_CYEDGE));    // Need to subrtact off the borders
        }
        else
        {
            //HACKHACK:  THIS WILL FORCE NO WRAP TO HAPPEN FOR PROPER WIDTH CALC WHEN PAGER IS PRESENT.
            size.cx = RECTWIDTH(rc);
            size.cy = 32000;
        }
        ToolBar_SetBoundingSize(_hwndTB, &size);
    }
    else
    {
        if (_hwndPager && GetParent(_hwndPager) != hwndParent)
            SetParent(_hwndPager, hwndParent);
    }

    if (FAILED(_GetTopBrowserWindow(&_hwndDD)))
        _hwndDD = GetParent(_hwndTB);
}


#define MAX_COMMANDID 0xFFFF // We're allowed one word of command ids (tested at 5)
int  CSFToolbar::_GetCommandID()
{
    int id = -1;

    if (!_fCheckIds)
    {
        id = _nNextCommandID++;
    }
    else
    {
        // We are reusing command ids and must verify that
        // the current one is not in use. This is slow, but
        // I assume the number of buttons on one of these
        // bands is relatively few.
        //
        for (int i = 0 ; i <= MAX_COMMANDID ; i++)
        {
            TBBUTTONINFO tbbiDummy = {0};

            tbbiDummy.cbSize = SIZEOF(tbbiDummy);
            tbbiDummy.dwMask = 0; // we don't care about data, just existence

            if (-1 != ToolBar_GetButtonInfo(_hwndTB, _nNextCommandID, &tbbiDummy))
            {
                // A button by this id wasn't found, so the id must be free
                //
                id = _nNextCommandID++;
                break;
            }

            _nNextCommandID++;
            _nNextCommandID %= MAX_COMMANDID;
        }
    }

    if (_nNextCommandID > MAX_COMMANDID)
    {
        _nNextCommandID = 0;
        _fCheckIds = TRUE;
    }

    return(id);
}


/*----------------------------------------------------------
Purpose: This function determines the toolbar button style for the
         given pidl.  

         Returns S_OK if pdwMIFFlags is also set (i.e., the object
         supported IMenuBandItem to provide more info).  S_FALSE if only
         *pdwTBStyle is set.

*/
HRESULT CSFToolbar::_TBStyleForPidl(LPCITEMIDLIST pidl, 
                                   DWORD * pdwTBStyle, DWORD* pdwTBState, DWORD * pdwMIFFlags,int* piIcon)
{
    HRESULT hres = S_FALSE;
    DWORD dwStyle = TBSTYLE_BUTTON;
    if (!_fAccelerators)
        dwStyle |= TBSTYLE_NOPREFIX;

    *pdwMIFFlags = 0;
    *pdwTBStyle = dwStyle;
    *piIcon = -1;
    *pdwTBState = TBSTATE_ENABLED;

    return hres;
}


PIBDATA CSFToolbar::_CreateItemData(PORDERITEM poi)
{
    return new IBDATA(poi);
}


PIBDATA CSFToolbar::_AddOrderItemTB(PORDERITEM poi, int index, TBBUTTON* ptbb)
{
    TCHAR szName[MAX_PATH];

    // We need to do this even for NULL because _ObtainPIDLName cooks
    // up the word "(Empty)" as necessary.
    _ObtainPIDLName(poi ? poi->pidl : NULL, szName, SIZECHARS(szName));

    TBBUTTON tbb = {0};
    DWORD dwMIFFlags;
    DWORD dwStyle;
    DWORD dwState;
    int iIcon;
    int iCommandID = _GetCommandID();
    BOOL bNoIcon = FALSE;
    
    if (!ptbb)
        ptbb = &tbb;

    if (S_OK == _TBStyleForPidl(poi ? poi->pidl : NULL, &dwStyle, &dwState, &dwMIFFlags,&iIcon) &&
        !(dwMIFFlags & SMIF_ICON))
    {
        bNoIcon = TRUE;
    }

    PIBDATA pibdata = _CreateItemData(poi);
    if (pibdata)
    {
        pibdata->SetFlags(dwMIFFlags);
        pibdata->SetNoIcon(bNoIcon);

        if(!bNoIcon && iIcon != -1)
            ptbb->iBitmap = iIcon;
        else
            ptbb->iBitmap = I_IMAGECALLBACK;

        ptbb->idCommand = iCommandID;
        ptbb->fsState = (BYTE)dwState;
        ptbb->fsStyle = (BYTE)dwStyle;
        ptbb->dwData = (DWORD_PTR)pibdata;
        ptbb->iString = (INT_PTR)szName;

        // Disregard variablewidth if we are vertical
        if (_fVariableWidth && !_fVertical)
            ptbb->fsStyle |= TBSTYLE_AUTOSIZE;

        if (ptbb->idCommand != -1)
        {
            if (SendMessage(_hwndTB, TB_INSERTBUTTON, index, (LPARAM)ptbb))
            {
                TraceMsg(TF_BAND, "SFToolbar::_AddPidl %d 0x%x [%s]", ptbb->idCommand, ptbb->dwData, ptbb->iString);                                    
            } 
            else 
            {
                delete pibdata;
                pibdata = NULL;
            }
        }

    }

    return pibdata;
}

void CSFToolbar::_ObtainPIDLName(LPCITEMIDLIST pidl, LPTSTR psz, int cchMax)
{
    STRRET strret;
    
    if SUCCEEDED(_psf->GetDisplayNameOf(pidl, SHGDN_NORMAL, &strret))
    {
        StrRetToBuf(&strret, pidl, psz, cchMax);
    }
}

int CSFToolbar::_GetBitmap(int iCommandID, PIBDATA pibdata, BOOL fUseCache)
{
    int iBitmap;

    if(_fNoIcons || pibdata->GetNoIcon())
        iBitmap = -1;
    else
    {
        iBitmap = OrderItem_GetSystemImageListIndex(pibdata->GetOrderItem(), _psf, fUseCache);
    }

    return iBitmap;
}

void CSFToolbar::_OnGetDispInfo(LPNMHDR pnm, BOOL fUnicode) 
{
    LPNMTBDISPINFO pdi = (LPNMTBDISPINFO)pnm;
    PIBDATA pibdata = (PIBDATA)pdi->lParam;
    LPITEMIDLIST pidl = pibdata->GetPidl();
    
    if(pdi->dwMask & TBNF_IMAGE) 
    {
        pdi->iImage = _GetBitmap(pdi->idCommand, pibdata, TRUE);
    }
    
    if(pdi->dwMask & TBNF_TEXT) {
        if(pdi->pszText) {
            if(fUnicode) {
                pdi->pszText[0] = TEXT('\0');
            }else {
                pdi->pszText[0] = 0;
            }
        }
    }
    pdi->dwMask |= TBNF_DI_SETITEM;

    return;
   

}


// Adds pidl as a new button, handles ILFree(pidl) for the caller
//
BOOL CSFToolbar::_AddPidl(LPITEMIDLIST pidl, int index)
{
    if (_hdpa)
    {
        PORDERITEM poi = OrderItem_Create(pidl, index);
        if (poi)
        {
            int iPos = DPA_InsertPtr(_hdpa, index, poi);
            if (-1 != iPos)
            {
                // If we did not load an order, then new items should
                // show up alphabetically in the list, not at the bottom.
                if (!_fHasOrder)
                {
                    // Sort by name
                    _SortDPA(_hdpa);

                    // Find the index of the order item. We use this index as
                    // the toolbar insert index.
                    index = DPA_GetPtrIndex(_hdpa, poi);
                }

                if (_AddOrderItemTB(poi, index, NULL))
                {
                    return TRUE;
                }
                
                DPA_DeletePtr(_hdpa, iPos);
            }

            OrderItem_Free(poi);

            return FALSE;
        }
    }

    ILFree(pidl);

    return FALSE;
}

BOOL CSFToolbar::_FilterPidl(LPCITEMIDLIST pidl)
{
    return FALSE;
}

void CSFToolbar::s_NewItem(LPVOID pvParam, LPCITEMIDLIST pidl)
{
    CSFToolbar* psft = (CSFToolbar*)pvParam;
    psft->v_NewItem(pidl);
}

HRESULT CSFToolbar::_GetIEnumIDList(DWORD dwEnumFlags, IEnumIDList **ppenum)
{
    ASSERT(_psf);
    // Pass in a NULL hwnd so the enumerator does not show any UI while
    // we're filling a band.    
    return IShellFolder_EnumObjects(_psf, NULL, dwEnumFlags, ppenum);
}

void CSFToolbar::_FillDPA(HDPA hdpa, HDPA hdpaSort, DWORD dwEnumFlags)
{
    IEnumIDList* penum;
    int cItems = 0;
    BOOL f9x = IsOS(OS_WINDOWS);

    if (!_psf)
        return;

    if (SUCCEEDED(_GetIEnumIDList(dwEnumFlags, &penum)))
    {
        LPITEMIDLIST pidl;
        ULONG ul;

        while (S_OK == penum->Next(1, &pidl, &ul))
        {
            cItems++;
            if (_FilterPidl(pidl) || !OrderList_Append(hdpa, pidl, -1))
            {
                TraceMsg(TF_MENUBAND, "SFToolbar (0x%x)::_FillDPA : Did not Add Pidl (0x%x).", this, pidl);
                ILFree(pidl);
            }
            // Windows 9x issue
            if (cItems > 1000 && f9x)
            {
                // Here's the deal:
                // When enumerating NTdev, we have 10,000 items. If each item is 20 pixels
                // long, we end up with 200,000 pixels. Windows can only display 32,000 pixels,
                // or 1,600 items in the default case. I'm limiting to 1,000 items = 20,000 so that
                // we have some room for reasonable font sizes.
                break;
            }
        }

        penum->Release();
    }

    ORDERINFO   oinfo;
    int iInsertIndex = _tbim.iButton + 1;               // This is the button where the cursor sat. 
                                                        // So, We want to insert after that
    if (iInsertIndex >= ToolBar_ButtonCount(_hwndTB))   // But, if it's at the end,
        iInsertIndex = -1;                              // Convert the insert to an append.
                                                        //      - Comments in rhyme by lamadio

    oinfo.psf = _psf;
    (oinfo.psf)->AddRef();
    oinfo.dwSortBy = (_fHasOrder || _fDropping)? ((_fNoNameSort ? OI_SORTBYORDINAL : OI_SORTBYNAME)): OI_MERGEBYNAME;
    OrderList_Merge(hdpa, hdpaSort, _fDropping ? iInsertIndex : _DefaultInsertIndex(), (LPARAM) &oinfo,
        s_NewItem, (LPVOID)this);
    ATOMICRELEASE(oinfo.psf);
}


// This function re-enumerates the IShellFolder, keeping things ordered correctly.
// At some point it may reduce flicker by not removing buttons that don't change.
//
void CSFToolbar::_FillToolbar()
{
    HDPA hdpaSort;
    HDPA hdpa;

    if (!_fDirty || !_psf)
        return;

    
    // If we have an order array, use that, otherwise
    // use the currently viewed items
    if (_hdpaOrder)
        hdpaSort = _hdpaOrder; // already sorted by name
    else
    {
        hdpaSort = _hdpa;
        _SortDPA(hdpaSort);
    }

    hdpa = DPA_Create(hdpaSort ? DPA_GetPtrCount(hdpaSort) : 12);
    if (hdpa)
    {
        _FillDPA(hdpa, hdpaSort, SHCONTF_FOLDERS|SHCONTF_NONFOLDERS);

        // NOTE: if many buttons were moved at the same time
        // the notifications may be spread out as the files
        // are copied and we'd only insert the first time.
        // This is probably okay.
        //
        _fDropping = FALSE;

        // For the case of dragging a new item into the band (or one
        // just showing up) we could re-sort _hdpa by ordinal (which
        // would match the current button order), and iterate through hdpa
        // to see where a button needs to be inserted or removed.
        // This would be way less flicker and toolbar painting
        // than always blowing away the current buttons and reinserting them...
        //
        // For now be lazy and do extra work.
        //
        // remove buttons and replace _hdpa with hdpa
        if (_hdpa)
        {
            EmptyToolbar();
            ASSERT(!_hdpa);
        }
        _hdpa = hdpa;

        SendMessage(_hwndTB, WM_SETREDRAW, FALSE, 0);

        // add buttons back in
        DEBUG_CODE( BOOL bFailed = FALSE; )
        int i = 0;
        while (i < DPA_GetPtrCount(_hdpa))
        {
            PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);

//            ASSERT(bFailed || poi->nOrder == i);

            if (_AddOrderItemTB(poi, -1, NULL))
            {
                i++;
            }
            else
            {
                DPA_DeletePtr(_hdpa, i);
                DEBUG_CODE( bFailed = TRUE; )
            }
        }
                
    }
    SendMessage(_hwndTB, WM_SETREDRAW, TRUE, 0);

    // if we used an _hdpaOrder then we don't need it any more
    OrderList_Destroy(&_hdpaOrder);
    
    _UpdateButtons();
    _SetDirty(FALSE);

    _ToolbarChanged();
    TraceMsg(TF_BAND, "SFToolbar::_FillToolbar found %d items", DPA_GetPtrCount(_hdpa));
}

void CSFToolbar::EmptyToolbar()
{
    if (_hwndTB)
    {
        TraceMsg(TF_BAND, "SFToolbar::EmptyToolbar %d items", _hdpa ? DPA_GetPtrCount(_hdpa) : 0);

        while (InlineDeleteButton(0))
        {
            // delete the buttons
        }
    }

    OrderList_Destroy(&_hdpa);

    _fDirty = TRUE;
    
    _nNextCommandID = 0;
}

void CSFToolbar::_SetDirty(BOOL fDirty)
{
    _fDirty = fDirty;
}

UINT CSFToolbar::_IndexToID(int iIndex)
{
    TBBUTTON tbb;

    if (SendMessage(_hwndTB, TB_GETBUTTON, iIndex, (LPARAM)&tbb))
    {
        return tbb.idCommand;
    }
    return (UINT)-1;
}

// if ptbbi is specified, dwMask must be filled in
//
LPITEMIDLIST CSFToolbar::_GetButtonFromPidl(LPCITEMIDLIST pidl, TBBUTTONINFO * ptbbi, int * pIndex)
{
    int i;

    if (!_hdpa)
        return NULL;

    for (i = DPA_GetPtrCount(_hdpa)-1 ; i >= 0 ; i--)
    {
        HRESULT hres;
        PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);

        ASSERT(poi);
        if (poi->pidl) {
            hres = _psf->CompareIDs(0, pidl, poi->pidl);
            if (ResultFromShort(0) == hres)
            {
                if (pIndex)
                    *pIndex = i;

                if (ptbbi)
                {
                    int id = _IndexToID(i);

                    if (id != -1) {
                        ptbbi->cbSize = SIZEOF(*ptbbi);
                        if (-1 == ToolBar_GetButtonInfo(_hwndTB, id, ptbbi))
                        {
                            ZeroMemory(ptbbi, SIZEOF(*ptbbi));
                        }
                    }
                    else
                    {
                        ZeroMemory(ptbbi, SIZEOF(*ptbbi));
                    }
                }

                return poi->pidl;
            }
        }
    }

    return NULL;
}

// On an add, tack the new button on the end
void CSFToolbar::_OnFSNotifyAdd(LPCITEMIDLIST pidl)
{
    // be paranoid and make sure we don't duplicate an item
    //
    if (!_GetButtonFromPidl(pidl, NULL, NULL))
    {
        LPITEMIDLIST pidlNew;

        if (_fFSNotify && !_ptscn)
        {
            if (FAILED(SHGetRealIDL(_psf, pidl, &pidlNew)))
                pidlNew = NULL;
        }
        else
        {
            pidlNew = ILClone(pidl);
        }

        if (pidlNew)
        {
            if (!_FilterPidl(pidlNew))
            {
                int index = _DefaultInsertIndex();

                if (_fDropping)
                {
                    if (-1 == _tbim.iButton)
                        index = 0; // if qlinks has no items, _tbim.iButton is -1, but you can't insert there...
                    else if (_tbim.dwFlags & TBIMHT_AFTER)
                        index = _tbim.iButton + 1;
                    else
                        index = _tbim.iButton;
                }

                // We need to store this as the new order because a drag and drop has occured.
                // We will store this order and use it until the end of time.
                if (_fDropping)
                {
                    _fHasOrder = TRUE;
                    _fChangedOrder = TRUE;
                }


                _AddPidl(pidlNew, index);
                
                OrderList_Reorder(_hdpa);
           
                if (_fDropping)
                {
                    _Dropped(index, FALSE);
                    _fDropping = FALSE;
                }
            }
            else
            {
                ILFree(pidlNew);
            }
        }
    }
}


// This function syncronously removes the button, and deletes it's contents.
// This avoids Reentrancy problems, as well as Leaks caused by unhooked toolbars
BOOL_PTR CSFToolbar::InlineDeleteButton(int iIndex)
{
    BOOL_PTR fRet = FALSE;
    TBBUTTONINFO tbbi = {0};
    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_LPARAM | TBIF_BYINDEX;
    if (ToolBar_GetButtonInfo(_hwndTB, iIndex, &tbbi) >= 0)
    {
        PIBDATA pibdata = (PIBDATA)tbbi.lParam;
        tbbi.lParam = NULL;

        ToolBar_SetButtonInfo(_hwndTB, iIndex, &tbbi);

        fRet = SendMessage(_hwndTB, TB_DELETEBUTTON, iIndex, 0);

        if (pibdata)
            delete pibdata;

    }

    return fRet;
}

// On a remove, rip out the old button and adjust existing ones
void CSFToolbar::_OnFSNotifyRemove(LPCITEMIDLIST pidl)
{
    int i;
    LPITEMIDLIST pidlButton = _GetButtonFromPidl(pidl, NULL, &i);
    if (pidlButton)
    {
        // remove it from the DPA before nuking the button. There is a rentrancy issue here.
        DPA_DeletePtr(_hdpa, i);
        InlineDeleteButton(i);
        ILFree(pidlButton);
        _fChangedOrder = TRUE;
    }
}

// On a rename, just change the text of the old button
//
void CSFToolbar::_OnFSNotifyRename(LPCITEMIDLIST pidlFrom, LPCITEMIDLIST pidlTo)
{
    TBBUTTONINFO tbbi = {0};
    LPITEMIDLIST pidlButton;
    int i;
    
    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_COMMAND | TBIF_LPARAM;
    pidlButton = _GetButtonFromPidl(pidlFrom, &tbbi, &i);
    if (pidlButton)
    {
        LPITEMIDLIST pidlNew;

        if (_fFSNotify && !_ptscn)
        {
            if (FAILED(SHGetRealIDL(_psf, pidlTo, &pidlNew)))
                pidlNew = NULL;
        }
        else
        {
            pidlNew = ILClone(pidlTo);
        }

        if (pidlNew)
        {
            LPITEMIDLIST pidlFree = pidlNew;
            PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, i);
            if (EVAL(poi))
            {
                pidlFree = poi->pidl;
                poi->pidl = pidlNew;
            
                STRRET strret;
                TCHAR szName[MAX_PATH];
                if (SUCCEEDED(_psf->GetDisplayNameOf(pidlNew, SHGDN_NORMAL, &strret)) &&
                    SUCCEEDED(StrRetToBuf(&strret, pidlNew, szName, ARRAYSIZE(szName))))
                {
                    // _GetButtonFromPidl filled in tbbi.cbSize and tbbi.idCommand
                    //
                    PIBDATA pibdata = (PIBDATA)tbbi.lParam;
                    if (pibdata)
                        pibdata->SetOrderItem(poi);

                    tbbi.dwMask = TBIF_TEXT;
                    tbbi.pszText = szName;
                    EVAL(ToolBar_SetButtonInfo(_hwndTB, tbbi.idCommand, &tbbi));
                    // Just so that it's new location gets persisted
                    _fChangedOrder = TRUE;
                }
            }

            ILFree(pidlFree);
        }
    }
}

// On a complete update remove the old button and add it again
//
void CSFToolbar::_OnFSNotifyUpdate(LPCITEMIDLIST pidl)
{
    TBBUTTONINFO tbbi = {0};

    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_COMMAND;
    LPITEMIDLIST pidlButton = _GetButtonFromPidl(pidl, &tbbi, NULL);
    if (pidlButton)
    {
        STRRET strret;
        TCHAR szName[MAX_PATH];

        if (SUCCEEDED(_psf->GetDisplayNameOf(pidlButton, SHGDN_NORMAL, &strret)) &&
            SUCCEEDED(StrRetToBuf(&strret, pidlButton, szName, ARRAYSIZE(szName))))
        {
            int iBitmap = _GetBitmap(tbbi.idCommand, _IDToPibData(tbbi.idCommand, NULL), FALSE);
            if (iBitmap >= 0)
            {
                tbbi.dwMask = TBIF_IMAGE | TBIF_TEXT;
                tbbi.iImage = iBitmap;
                tbbi.pszText = szName;

                ToolBar_SetButtonInfo(_hwndTB, tbbi.idCommand, &tbbi);
            }
        }
    }
}

void CSFToolbar::_Refresh()
{
    if (!_hdpa)
        return;

    _RememberOrder();

    _SetDirty(TRUE);
    if (_fShow)
        _FillToolbar();
}

LRESULT CSFToolbar::_OnTimer(WPARAM wParam)
{
    return 0;
}

LRESULT CSFToolbar::_DefWindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) 
    {
    case WM_DRAWITEM:
    case WM_MEASUREITEM:
    case WM_INITMENUPOPUP:
    case WM_MENUSELECT:
        if (_pcm2)
            _pcm2->HandleMenuMsg(uMsg, wParam, lParam);
        break;

    case WM_MENUCHAR:
        {
            LRESULT lres = 0;
            IContextMenu3* pcm3;
            if (_pcm2 && SUCCEEDED(_pcm2->QueryInterface(IID_IContextMenu3, (void**)&pcm3)))
            {
                pcm3->HandleMenuMsg2(uMsg, wParam, lParam, &lres);
                pcm3->Release();
            }
            return lres;
        }
        break;
    
    case WM_TIMER:
        if (_OnTimer(wParam)) 
        {
            return 1;
        }
        break;
    }
    
    return CNotifySubclassWndProc::_DefWindowProc(hwnd, uMsg, wParam, lParam);
}

/*----------------------------------------------------------
Purpose:
For future use. when renaming a parent of this shell folder
 we should rebind to it and refill us.

S_OK    Indicates successful handling of this notification
S_FALSE Indicates the notification is not a handled situation.
        The caller should handle the notification in this case.
Other   Failure code indicates a problem.  Caller should abort
        operation or handle the notification itself.

*/
HRESULT CSFToolbar::_OnRenameFolder(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    return S_FALSE;
}

HRESULT CSFToolbar::OnChange(LONG lEvent, LPCITEMIDLIST pidlOrg1, LPCITEMIDLIST pidlOrg2)
{
    HRESULT hres;
    LPITEMIDLIST pidl1 = (LPITEMIDLIST)pidlOrg1;
    LPITEMIDLIST pidl2 = (LPITEMIDLIST)pidlOrg2;
    LPITEMIDLIST pidl1ToFree = NULL;        // Used if we allocate a pidl that needs to be freed. (::TranslateIDs())
    LPITEMIDLIST pidl2ToFree = NULL;
    LPITEMIDLIST pidlOut1Event2 = NULL;        // Used if we allocate a pidl that needs to be freed. (::TranslateIDs())
    LPITEMIDLIST pidlOut2Event2 = NULL;
    LONG lEvent2 = (LONG)-1;
    if (_ptscn)
    {
        hres = _ptscn->TranslateIDs(&lEvent, pidlOrg1, pidlOrg2, &pidl1, &pidl2,
                                    &lEvent2, &pidlOut1Event2, &pidlOut2Event2);
            
        if (FAILED(hres))
            return hres;
        else
        {
            // if pidl1 doesn't equal pidlOrg1, then pidl1 was allocated and needs to be freed.
            pidl1ToFree = ((pidlOrg1 == pidl1) ? NULL : pidl1);
            pidl2ToFree = ((pidlOrg2 == pidl2) ? NULL : pidl2);
        }

        ASSERT(NULL == pidl1 || IS_VALID_PIDL(pidl1));
        ASSERT(NULL == pidl2 || IS_VALID_PIDL(pidl2));
    }

    hres = OnTranslatedChange(lEvent, pidl1, pidl2);

    // Do we have a second event to process?
    if (SUCCEEDED(hres) && lEvent2 != (LONG)-1)
    {
        // Yes, then go do it.
        hres = OnTranslatedChange(lEvent2, pidlOut1Event2, pidlOut2Event2);
    }
    ILFree(pidlOut1Event2);
    ILFree(pidlOut2Event2);
    ILFree(pidl1ToFree);
    ILFree(pidl2ToFree);

    return hres;
}

#ifdef DEBUG
void DBPrPidl(LPCSTR szPre, LPCITEMIDLIST pidl)
{
    TCHAR szName[MAX_PATH];

    szName[0] = '\0';
    if (pidl)
        SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szName, SIZECHARS(szName), NULL);

    TraceMsg(TF_WARNING, "%hs%s", szPre, szName);
    return;
}
#endif

HRESULT CSFToolbar::OnTranslatedChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hres = S_OK;
    BOOL fSizeChanged = FALSE;

    TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: lEvent=%x", lEvent);

    // If we weren't given a pidl we won't register for
    // SHChangeNotify calls, but our IShellChange interface
    // can still be QI()d so someone could errantly call us.
    //
    // If we change to using QS() for IShellChange interface
    // then we can put this check there...
    //
    if (NULL == _pidl)
    {
        // HACKHACK (scotth): resource-based menus (CMenuISF) don't set _pidl.
        //                    Right now allow SHCNE_UPDATEDIR thru...
        if (SHCNE_UPDATEDIR == lEvent)
            goto HandleUpdateDir;

        TraceMsg(TF_WARNING, "CSFToolbar::OnChange - _pidl is NULL");
        hres = E_FAIL;
        goto CleanUp;
    }

    if ( lEvent != SHCNE_UPDATEIMAGE && lEvent != SHCNE_RENAMEITEM && lEvent != SHCNE_RENAMEFOLDER &&
         lEvent != SHCNE_UPDATEDIR && lEvent != SHCNE_MEDIAREMOVED && lEvent != SHCNE_MEDIAINSERTED &&
         lEvent != SHCNE_EXTENDED_EVENT)
    {
        // We only handle notifications for immediate kids. (except SHCNE_RENAMEFOLDER)
        //
        
        if (!_IsChildID(pidl1, TRUE))
        {
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Not a child. Bailing");
            hres = E_FAIL;
            goto CleanUp;
        }
    }

    // Have we been shown yet?
    if (_hdpa == NULL)
    {
        // No. Well, then punt this. We'll catch it on the first enum.
        hres = E_FAIL;
        goto CleanUp;
    }

    switch (lEvent)
    {
    case SHCNE_EXTENDED_EVENT:
        {
            SHChangeDWORDAsIDList UNALIGNED * pdwidl = (SHChangeDWORDAsIDList UNALIGNED *)pidl1;
            if (pdwidl->dwItem1 == SHCNEE_ORDERCHANGED)
            {
                TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Reorder event");

                // Do this first so that we can say "We can handle it". This prevents the 
                // mnfolder code that works around a bug in some installers where they don't
                // send a Create Folder before the create item in that folder. It causes an
                // update dir...
                if (!pidl2 || ILIsEqual(_pidl, pidl2))
                {
                    // if this reorder came from us, blow it off
                    if (!SHChangeMenuWasSentByMe(this, pidl1))
                    {
                        // load new order stream
                        _LoadOrderStream();

                        // rebuild toolbar
                        _SetDirty(TRUE);
                        if (_fShow)
                            _FillToolbar();
                    }
                    hres = S_OK;
                }
            }
        }
        break;

    case SHCNE_DRIVEADD:
    case SHCNE_CREATE:
    case SHCNE_MKDIR:
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Adding item");
        pidl1 = ILFindLastID(pidl1);
        _OnFSNotifyAdd(pidl1);
        fSizeChanged = TRUE;
        break;

    case SHCNE_DRIVEREMOVED:
    case SHCNE_DELETE:
    case SHCNE_RMDIR:
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Removing item");
        pidl1 = ILFindLastID(pidl1);
        _OnFSNotifyRemove(pidl1);
        fSizeChanged = TRUE;
        break;

    case SHCNE_RENAMEFOLDER:
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameFolder");
        // Break if notif is handled or if this is not for our kid.
        //
        hres = _OnRenameFolder(pidl1, pidl2);
        if (S_OK == hres)
        {
            fSizeChanged = TRUE;
            break;
        }

        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameFolder Falling through to RenameItem");
        // fall through
    case SHCNE_RENAMEITEM:
    {
        TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: RenameItem");
        BOOL fOurKid1, fOurKid2;
        LPCITEMIDLIST p1 = pidl1;
        LPCITEMIDLIST p2 = pidl2;

        pidl1 = ILFindLastID(pidl1);
        pidl2 = ILFindLastID(pidl2);

        // An item can be renamed out of this folder.
        // Convert that into a remove.
        //

        fOurKid1 = _IsChildID(p1, TRUE);
        fOurKid2 = _IsChildID(p2, TRUE);
        if (fOurKid1 && fOurKid2)
        {
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Both are children");
            _OnFSNotifyRename(pidl1, pidl2);
            fSizeChanged = TRUE;
            hres = S_OK;
            break;
        }
        else if (fOurKid1)
        {
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Only one is a child. Removing pidl 1");
            _OnFSNotifyRemove(pidl1);
            fSizeChanged = TRUE;
            break;
        }
        else if (fOurKid2)
        {
            // An item can be renamed into this folder.
            // Convert that into an add.
            //
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Only one is a child. Adding pidl2");
            _OnFSNotifyAdd(pidl2);
            fSizeChanged = TRUE;
            break;
        }
        else 
        {
            // (we get here for guys below us who we don't care about,
            // and also for the fallthru from SHCNE_RENAMEFOLDER)
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: Rename: Not our children");
            /*NOTHING*/
            hres = E_FAIL;
        }
        break;
    }

    case SHCNE_MEDIAINSERTED:
    case SHCNE_MEDIAREMOVED:
    case SHCNE_NETUNSHARE:
        if (_IsEqualID(pidl1))
            goto HandleUpdateDir;

    case SHCNE_NETSHARE:
    case SHCNE_UPDATEITEM:
        
        if (_IsChildID(pidl1, TRUE)) 
        {
            pidl1 = ILFindLastID(pidl1);

            _OnFSNotifyUpdate(pidl1);
            fSizeChanged = TRUE;
        }
        break;

    case SHCNE_UPDATEDIR:
        // in OnChange we picked off update dir notify and we didn't translate ids
        // now we can use ILIsEqual -- translate ids won't translate pidls in case
        // of update dir because it looks for immediate child of its, and fails when
        // it receives its own pidl

        // NOTE: When sftbar is registered recursivly, we only get the pidl of the
        // top pane. It is forwarded down to the children. Since this is now a "Child"
        // of the top pane, we check to see if this pidl is a child of that pidl, hence the
        // ILIsParent(pidl1, _pidl)
        // HACKHACK, HUGE HACK: normaly w/ update dir pidl2 is NULL but in start menu
        // augmergeisf can change some other notify (e.g. rename folder) to update dir
        // in which case pidl2 is not null and we have to see if it is our child to do the
        // update (11/18/98) reljai
        if (_IsEqualID(pidl1) ||                    // Calling UpdateDir on _THIS_ folder
            _IsChildID(pidl1, FALSE) ||             // BUGBUG (lamadio) Is this needed?
            (pidl2 && _IsChildID(pidl2, FALSE)) ||  // A changed to update (see comment)
            _IsParentID(pidl1))                     // Some parent in the chain (because it's recursive)
        {
HandleUpdateDir:
            // NOTE: if a series of UPDATEIMAGE notifies gets
            //       translated to UPDATEDIR and we flicker-perf
            //       _FillToolbar, we may lose image updates
            //       (in which case, _Refresh would fix it)
            //
            TraceMsg(TF_SFTBAR, "CSFTBar::OnTranslateChange: ******* Evil Update Dir *******");
            _Refresh();
            // don't set this here because filltoolbar will update
            //fSizeChanged = TRUE;
        }
        break;

    case SHCNE_ASSOCCHANGED:
        IEInvalidateImageList();    // We may need to use different icons.
        _Refresh(); // full refresh for now.
        break;

    case SHCNE_UPDATEIMAGE: // global
        if (pidl1)
        {
            int iImage = *(int UNALIGNED *)((BYTE *)pidl1 + 2);

            IEInvalidateImageList();    // We may need to use different icons.
            if ( pidl2 )
            {
                iImage = SHHandleUpdateImage( pidl2 );
                if ( iImage == -1 )
                {
                    break;
                }
            }
            
            if (iImage == -1 || TBHasImage(_hwndTB, iImage))
                _Refresh();
        } else
            _Refresh();
        // BUGBUG do we need an _UpdateButtons and fSizeChanged?
        break;

    default:
        hres = E_FAIL;
        break;
    }

    if (fSizeChanged)
    {
        if (_hwndPager)
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);
        _ToolbarChanged();
    }

CleanUp:
    return hres;
}

BOOL TBHasImage(HWND hwnd, int iImageIndex)
{
    BOOL fRefresh = FALSE;
    for (int i = ToolBar_ButtonCount(hwnd) - 1 ; i >= 0 ; i--)
    {
        TBBUTTON tbb;
        if (SendMessage(hwnd, TB_GETBUTTON, i, (LPARAM)&tbb)) 
        {
            if (tbb.iBitmap == iImageIndex) 
            {
                fRefresh = TRUE;
                break;
            }
        }
    }

    return fRefresh;
}

void CSFToolbar::_SetToolbarState()
{
    SHSetWindowBits(_hwndTB, GWL_STYLE, TBSTYLE_LIST, 
                  (_uIconSize != ISFBVIEWMODE_SMALLICONS || _fNoShowText) ? 0 : TBSTYLE_LIST);
}

int CSFToolbar::_DefaultInsertIndex()
{
    return DA_LAST;
}

BOOL CSFToolbar::_IsParentID(LPCITEMIDLIST pidl)
{
    // Is the pidl passed in a parent of one of the IDs in the namespace
    // or the only one i've got?
    if (_ptscn)
        return S_OK == _ptscn->IsEqualID(NULL, pidl);
    else
        return ILIsParent(pidl, _pidl, FALSE);
}

BOOL CSFToolbar::_IsEqualID(LPCITEMIDLIST pidl)
{
    if (_ptscn)
        return S_OK == _ptscn->IsEqualID(pidl, NULL);
    else
        return ILIsEqual(_pidl, pidl);
}

BOOL CSFToolbar::_IsChildID(LPCITEMIDLIST pidlChild, BOOL fImmediate)
{
    if (_ptscn)
        return S_OK == _ptscn->IsChildID(pidlChild, fImmediate);
    else
        return ILIsParent(_pidl, pidlChild, fImmediate);
}

void CSFToolbar::v_CalcWidth(int* pcxMin, int* pcxMax)
{
    ASSERT(IS_VALID_WRITE_PTR(pcxMin, int));
    ASSERT(IS_VALID_WRITE_PTR(pcxMax, int));
    // Calculate a decent button width given current state
    HIMAGELIST himl;
    int cxMax = 0;
    int cxMin = 0;

    himl = (HIMAGELIST)SendMessage(_hwndTB, TB_GETIMAGELIST, 0, 0);
    if (himl)
    {
        int cy;
        // Start with the width of the button
        ImageList_GetIconSize(himl, &cxMax, &cy);

        // We want at least a bit of space around the icon
        if (_uIconSize != ISFBVIEWMODE_SMALLICONS)
            cxMax += 20;
        else 
            cxMax += 4 * GetSystemMetrics(SM_CXEDGE);

    }

    // Add in any additional space needed
    // Text takes up a bit more space
    if (!_fNoShowText)
    {
        cxMax += 20;

        // Horizontal text takes up a lot
        // if we're smallicon with text (horizontal button)
        // mode, use the minimized metric to mimic the taskbar
        if (_uIconSize == ISFBVIEWMODE_SMALLICONS)
            cxMax = GetSystemMetrics(SM_CXMINIMIZED);
    }

    *pcxMin = cxMin;
    *pcxMax = cxMax;
}

// Adjust buttons based on current state.
//
void CSFToolbar::_UpdateButtons()
{
    if (_hwndTB)
    {
        // set "list" (text on right) or not (text underneath)
        // NOTE: list mode always displays some text, don't do it if no text
        _SetToolbarState();

        v_CalcWidth(&_cxMin, &_cxMax);

        SendMessage(_hwndTB, TB_SETBUTTONWIDTH, 0, MAKELONG(_cxMin, _cxMax));

        // We just changed the layout
        //
        SendMessage(_hwndTB, TB_AUTOSIZE, 0, 0);
        if (_hwndPager)
        {
            LRESULT lButtonSize = SendMessage(_hwndTB, TB_GETBUTTONSIZE, 0, 0);
            Pager_SetScrollInfo(_hwndPager, 50, 1, HIWORD(lButtonSize));
            SendMessage(_hwndPager, PGMP_RECALCSIZE, (WPARAM) 0, (LPARAM) 0);
        }
    }
}

/*----------------------------------------------------------
Purpose: Helper function that calls IShellFolder::GetUIObjectOf().

Returns: pointer to the requested interface
         NULL if failed
*/
LPVOID CSFToolbar::_GetUIObjectOfPidl(LPCITEMIDLIST pidl, REFIID riid)
{
    LPCITEMIDLIST * apidl = &pidl;
    LPVOID pv;
    if (FAILED(_psf->GetUIObjectOf(GetHWNDForUIObject(), 1, apidl, riid, 0, &pv)))
    {
        pv = NULL;
    }

    return(pv);
}

INT_PTR CALLBACK CSFToolbar::_RenameDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
    {
        ASSERT(lParam);
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDD_NAME);
        HWND hwndEdit = GetDlgItem(hDlg, IDD_NAME);
        SendMessage(hwndEdit, EM_LIMITTEXT, MAX_PATH - 1, 0);

        TCHAR szText[MAX_PATH + 80];
        TCHAR szTemplate[80];
        HWND hwndLabel = GetDlgItem(hDlg, IDD_PROMPT);
        GetWindowText(hwndLabel, szTemplate, ARRAYSIZE(szTemplate));
        StringCchPrintf(szText, ARRAYSIZE(szText), szTemplate, lParam); // truncation ok, it's just display text
        SetWindowText(hwndLabel, szText);
        SetWindowText(hwndEdit, (LPTSTR)lParam);
        break;
    }

    case WM_DESTROY:
        SHRemoveDefaultDialogFont(hDlg);
        return FALSE;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_NAME:
        {
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_UPDATE)
            {
                LPTSTR lpstrName = (LPTSTR) GetWindowLongPtr(hDlg, DWLP_USER);
                EnableOKButtonFromID(hDlg, IDD_NAME);
                GetDlgItemText(hDlg, IDD_NAME, lpstrName, MAX_PATH);
            }
            break;
        }

        case IDOK:
        {
            TCHAR szTmp[MAX_PATH];
            StringCchCopy(szTmp, ARRAYSIZE(szTmp), (LPTSTR) GetWindowLongPtr(hDlg, DWLP_USER)); // truncation is ok, this is just a renaming something
            if (PathCleanupSpec(NULL,szTmp))
            {
               HWND hwnd;

               MLShellMessageBox(hDlg,
                                 MAKEINTRESOURCE(IDS_FAVS_INVALIDFN),
                                 MAKEINTRESOURCE(IDS_FAVS_ADDTOFAVORITES), MB_OK | MB_ICONHAND);
               hwnd = GetDlgItem(hDlg, IDD_NAME);
               SetWindowText(hwnd, TEXT('\0'));
               EnableWindow(GetDlgItem(hDlg, IDOK), FALSE);
               SetFocus(hwnd);
               break;
            }
        }
        // fall through

        case IDCANCEL:
            EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
            break;

        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


// This window proc is used for a temporary worker window that is used to position dialogs 
// as well as maintain the correct Z-Order
// NOTE: This is used in mnfolder as well.
LRESULT CALLBACK HiddenWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        // Make sure activation tracks back to the parent.
    case WM_ACTIVATE:
        {
            if (WA_ACTIVE != LOWORD(wParam))
                goto DefWnd;

            SetActiveWindow(GetParent(hwnd));
            return FALSE;
        }

    case WM_WINDOWPOSCHANGING:
        {
            WINDOWPOS* pwp = (WINDOWPOS*)lParam;
            pwp->flags |= SWP_NOOWNERZORDER;
        }
        break;
    }

DefWnd:
    return DefWindowProc(hwnd, uMsg, wParam, lParam);

}

HWND CSFToolbar::CreateWorkerWindow()
{
    if (!_hwndWorkerWindow)
    {
        _hwndWorkerWindow = SHCreateWorkerWindow(HiddenWndProc, GetHWNDForUIObject(), WS_EX_TOOLWINDOW /*| WS_EX_TOPMOST */, WS_POPUP, 0, _hwndTB);
    }

    return _hwndWorkerWindow;
}

HRESULT CSFToolbar::_OnRename(POINT *ppt, int id)
{
    ASSERT(_psf);
    
    TCHAR szName[MAX_PATH];
    LPCITEMIDLIST pidl = _IDToPidl(id);
    
    _ObtainPIDLName(pidl, szName, ARRAYSIZE(szName));

    // create a temp window so that placement of the dialog will be close to the point.
    // do this so that we'll use USER's code to get placement correctly w/ respect to multimon and work area
    _hwndWorkerWindow = CreateWorkerWindow();

    SetWindowPos(_hwndWorkerWindow, NULL, ppt->x, ppt->y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

    // Now the horrible work of disabling our UI parent window so we can go modal.
    // In an ideal world, we would pass our true parent window and USER will do
    // all the work of modality, but we have to use our worker window thingie
    // to get the dialog positioned correctly with respect to multimon,
    // so we have to find the modal parent and disable him the hard way.
    //
    IUnknown *punkSite;
    IUnknown *punkTLB;

    // Doesn't matter what we SAFECAST "this" to; just pick something to keep the compiler happy
    IUnknown_GetSite(SAFECAST(this, IWinEventHandler*), IID_PPV_ARG(IUnknown, &punkSite));
    IUnknown_QueryService(punkSite, SID_STopLevelBrowser, IID_PPV_ARG(IUnknown, &punkTLB));

    // Tell OLE to go modal
    HRESULT hrModeless = IUnknown_EnableModless(punkTLB, FALSE);

    // Tell USER to go modal
    HWND hwndDisable;
    IUnknown_GetWindow(punkTLB, &hwndDisable);
    BOOL bPrevEnabled = FALSE;
    while (hwndDisable && (GetWindowLong(hwndDisable, GWL_STYLE) & WS_CHILD))
        hwndDisable = GetParent(hwndDisable);
    if (hwndDisable)
        bPrevEnabled = !EnableWindow(hwndDisable, FALSE);

    while (1) 
    {
        if (DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(DLG_ISFBANDRENAME), _hwndWorkerWindow, _RenameDlgProc, (LPARAM)szName) != IDOK)
            break;

        WCHAR wsz[MAX_PATH];
        SHTCharToUnicode(szName, wsz, ARRAYSIZE(wsz));

        if (SUCCEEDED(_psf->SetNameOf(_hwndWorkerWindow, pidl, wsz, 0, NULL))) 
        {
            SHChangeNotifyHandleEvents();
            _SaveOrderStream();
            break;
        }
    }

    // (must undo modality in reverse order)

    // Tell USER to return to modeless (as appropriate)
    if (hwndDisable)
        EnableWindow(hwndDisable, bPrevEnabled);

    // Tell OLE to return to modeless (as appropriate)
    if (SUCCEEDED(hrModeless))
        IUnknown_EnableModless(punkTLB, TRUE);

    ATOMICRELEASE(punkTLB);
    ATOMICRELEASE(punkSite);

    return S_OK;
}


BOOL CSFToolbar::_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons)
{
    BOOL fChanged = (_uIconSize != uIconSize);
    
    _uIconSize = uIconSize;

    TraceMsg(TF_BAND, "ISFBand::_UpdateIconSize going %hs", (_uIconSize == ISFBVIEWMODE_LARGEICONS ? "LARGE" : (_uIconSize == ISFBVIEWMODE_SMALLICONS ? "SMALL" : "LOGOS")));

    if (_hwndTB)
    {
        HIMAGELIST himl = NULL;
        if (!_fNoIcons)
        {
            HIMAGELIST himlLarge, himlSmall;

            // set the imagelist size
            Shell_GetImageLists(&himlLarge, &himlSmall);
            himl = (_uIconSize == ISFBVIEWMODE_LARGEICONS ) ? himlLarge : himlSmall;
        }

        // sending a null himl is significant..  it means no image list
        SendMessage(_hwndTB, TB_SETIMAGELIST, 0, (LPARAM)himl);
                
        if (fUpdateButtons)
            _UpdateButtons();
    }
    
    return fChanged;
}

HMENU CSFToolbar::_GetContextMenu(IContextMenu* pcm, int* pid)
{
    HMENU hmenu = CreatePopupMenu();
    if (hmenu) {

        UINT fFlags = CMF_CANRENAME;
        if (0 > GetKeyState(VK_SHIFT))
            fFlags |= CMF_EXTENDEDVERBS;

        pcm->QueryContextMenu(hmenu, 0, *pid, CMD_ID_LAST, fFlags);
    }
    return hmenu;
}

void CSFToolbar::_OnDefaultContextCommand(int idCmd)
{
}

HRESULT CSFToolbar::_GetTopBrowserWindow(HWND* phwnd)
{
    IUnknown * punkSite;

    HRESULT hr = IUnknown_GetSite(SAFECAST(this, IWinEventHandler*), IID_IUnknown, (void**)&punkSite);
    if (SUCCEEDED(hr))
    {
        hr = SHGetTopBrowserWindow(punkSite, phwnd);
        punkSite->Release();
    }

    return hr;
}

HRESULT CSFToolbar::_OnOpen(int id, BOOL fExplore)
{
    HRESULT hr = E_FAIL;
    LPCITEMIDLIST pidl = _IDToPidl(id);
    if (pidl)
    {
        IUnknown* punkSite;

        hr = IUnknown_GetSite(SAFECAST(this, IWinEventHandler*), IID_IUnknown, (void**)&punkSite);
        if (SUCCEEDED(hr))
        {
            DWORD dwFlags = SBSP_DEFBROWSER | SBSP_DEFMODE;
            if (fExplore)
                dwFlags |= SBSP_EXPLOREMODE;

            hr = SHNavigateToFavorite(_psf, pidl, punkSite, dwFlags);

            punkSite->Release();
        }
    }

    return hr;
}

HRESULT CSFToolbar::_HandleSpecialCommand(IContextMenu* pcm, PPOINT ppt, int id, int idCmd)
{
    TCHAR szCommandString[40];

    HRESULT hres = ContextMenu_GetCommandStringVerb(pcm,
        idCmd,
        szCommandString,
        ARRAYSIZE(szCommandString));

    if (SUCCEEDED(hres))
    {
        if (lstrcmpi(szCommandString, TEXT("rename")) == 0)
            return _OnRename(ppt, id);
        else if (lstrcmpi(szCommandString, TEXT("open")) == 0)
            return _OnOpen(id, FALSE);
        else if (lstrcmpi(szCommandString, TEXT("explore")) == 0)
            return _OnOpen(id, TRUE);
    }

    return S_FALSE;
}

LRESULT CSFToolbar::_DoContextMenu(IContextMenu* pcm, LPPOINT ppt, int id, LPRECT prcExclude)
{
    LRESULT lres = 0;
    int idCmdFirst = CMD_ID_FIRST;
    HMENU hmContext = _GetContextMenu(pcm, &idCmdFirst);
    if (hmContext)
    {
        int idCmd;

        if (_hwndToolTips)
            SendMessage(_hwndToolTips, TTM_ACTIVATE, FALSE, 0L);

        TPMPARAMS tpm;
        TPMPARAMS * ptpm = NULL;

        if (prcExclude)
        {
            tpm.cbSize = SIZEOF(tpm);
            tpm.rcExclude = *((LPRECT)prcExclude);
            ptpm = &tpm;
        }
        idCmd = TrackPopupMenuEx(hmContext,
            TPM_RETURNCMD | TPM_RIGHTBUTTON | TPM_LEFTALIGN,
            ppt->x, ppt->y, _hwndTB, ptpm);

        if (_hwndToolTips)
            SendMessage(_hwndToolTips, TTM_ACTIVATE, TRUE, 0L);
        
        if (idCmd)
        {
            if (idCmd < idCmdFirst)
            {
                _OnDefaultContextCommand(idCmd);
            }
            else
            {
                idCmd -= idCmdFirst;

                if (_HandleSpecialCommand(pcm, ppt, id, idCmd) != S_OK)
                {
                    _hwndWorkerWindow = CreateWorkerWindow();

                    SetWindowPos(_hwndWorkerWindow, NULL, ppt->x, ppt->y, 0, 0, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);

                    CMINVOKECOMMANDINFO ici = {
                        SIZEOF(CMINVOKECOMMANDINFO),
                        0,
                        _hwndWorkerWindow,
                        MAKEINTRESOURCEA(idCmd),
                        NULL, NULL,
                        SW_NORMAL,
                    };

                    pcm->InvokeCommand(&ici);
                }
            }
        }

        // if we get this far
        // we need to return handled so that WM_CONTEXTMENU doesn't come through
        lres = 1;
        
        DestroyMenu(hmContext);
    }

    return lres;
}


LRESULT CSFToolbar::_OnContextMenu(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    RECT rc;
    LPRECT prcExclude = NULL;
    POINT pt;
    int i;

    if (lParam != (LPARAM)-1) {
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);

        POINT pt2 = pt;
        MapWindowPoints(HWND_DESKTOP, _hwndTB, &pt2, 1);

        i = ToolBar_HitTest(_hwndTB, &pt2);
    } else {
        // keyboard context menu.
        i = (int)SendMessage(_hwndTB, TB_GETHOTITEM, 0, 0);
        if (i >= 0) {
            SendMessage(_hwndTB, TB_GETITEMRECT, i, (LPARAM)&rc);
            MapWindowPoints(_hwndTB, HWND_DESKTOP, (LPPOINT)&rc, 2);
            pt.x = rc.left;
            pt.y = rc.bottom;
            prcExclude = &rc;
        }
    }

    TraceMsg(TF_BAND, "NM_RCLICK %d,%d = %d", pt.x, pt.y, i);

    if (i >= 0)
    {
        UINT id = _IndexToID(i);
        LPCITEMIDLIST pidl = _IDToPidl(id, NULL);

        if (pidl)
        {
            LPCONTEXTMENU pcm = (LPCONTEXTMENU)_GetUIObjectOfPidl(pidl, IID_IContextMenu);
            if (pcm)
            {
                // grab pcm2 for owner draw support
                pcm->QueryInterface(IID_IContextMenu2, (LPVOID *)&_pcm2);

                ToolBar_MarkButton(_hwndTB, id, TRUE);

                lres = _DoContextMenu(pcm, &pt, id, prcExclude);

                ToolBar_MarkButton(_hwndTB, id, FALSE);

                if (lres)
                    _FlushNotifyMessages(_hwndTB);

                ATOMICRELEASE(_pcm2);
                pcm->Release();
            }
        }
    }

    return lres;
}


LRESULT CSFToolbar::_OnCustomDraw(NMCUSTOMDRAW* pnmcd)
{
    return CDRF_DODEFAULT;
}

void CSFToolbar::_OnDragBegin(int iItem, DWORD dwPreferedEffect)
{
    LPCITEMIDLIST pidl = _IDToPidl(iItem, &_iDragSource);
    ToolBar_SetHotItem(_hwndTB, _iDragSource);

    if (_hwndTB)
        DragDrop(_hwndTB, _psf, pidl, dwPreferedEffect, NULL);
    
    _iDragSource = -1;
}

LRESULT CSFToolbar::_OnHotItemChange(NMTBHOTITEM * pnm)
{
    LPNMTBHOTITEM  lpnmhi = (LPNMTBHOTITEM)pnm;

    if (_hwndPager && (lpnmhi->dwFlags & (HICF_ARROWKEYS | HICF_ACCELERATOR)) )
    {
        int iOldPos, iNewPos;
        RECT rc, rcPager;
        int heightPager;            
        
        int iSelected = lpnmhi->idNew;        
        iOldPos = (int)SendMessage(_hwndPager, PGM_GETPOS, (WPARAM)0, (LPARAM)0);
        iNewPos = iOldPos;
        SendMessage(_hwndTB, TB_GETITEMRECT, (WPARAM)iSelected, (LPARAM)&rc);
        
        if (rc.top < iOldPos) 
        {
             iNewPos =rc.top;
        }
        
        GetClientRect(_hwndPager, &rcPager);
        heightPager = RECTHEIGHT(rcPager);
        
        if (rc.top >= iOldPos + heightPager)  
        {
             iNewPos += (rc.bottom - (iOldPos + heightPager)) ;
        }
        
        if (iNewPos != iOldPos)
            SendMessage(_hwndPager, PGM_SETPOS, (WPARAM)0, (LPARAM)iNewPos);
    }

    return 0;
}

void CSFToolbar::_OnToolTipsCreated(NMTOOLTIPSCREATED* pnm)
{
    _hwndToolTips = pnm->hwndToolTips;
    SHSetWindowBits(_hwndToolTips, GWL_STYLE, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX);

    // set the AutoPopTime (the duration of showing the tooltip) to a large value
    SendMessage(_hwndToolTips, TTM_SETDELAYTIME, TTDT_AUTOPOP, (LPARAM)MAXSHORT);
}

LRESULT CSFToolbar::_OnNotify(LPNMHDR pnm)
{
    LRESULT lres = 0;

    //The following statement traps all pager control notification messages.
    if((pnm->code <= PGN_FIRST)  && (pnm->code >= PGN_LAST)) 
    {
        return SendMessage(_hwndTB, WM_NOTIFY, (WPARAM)0, (LPARAM)pnm);
    }

    switch (pnm->code)
    {
    case TBN_DRAGOUT:
    {
        TBNOTIFY *ptbn = (TBNOTIFY*)pnm;
        _OnDragBegin(ptbn->iItem, 0);
        lres = 1;
        break;
    }
    
    case TBN_HOTITEMCHANGE:
        _OnHotItemChange((LPNMTBHOTITEM)pnm);
        break;


    case TBN_GETINFOTIP:
    {
        LPNMTBGETINFOTIP pnmTT = (LPNMTBGETINFOTIP)pnm;
        UINT uiCmd = pnmTT->iItem;
        DWORD dwFlags = _fNoShowText ? QITIPF_USENAME | QITIPF_LINKNOTARGET : QITIPF_LINKNOTARGET;

        if (!GetInfoTipEx(_psf, dwFlags, _IDToPidl(uiCmd), pnmTT->pszText, pnmTT->cchTextMax))
        {
            TBBUTTONINFO tbbi = { 0};
    
            tbbi.cbSize = SIZEOF(tbbi);
            tbbi.dwMask = TBIF_TEXT;
            tbbi.pszText = pnmTT->pszText;
            tbbi.cchText = pnmTT->cchTextMax;
    
            lres = (-1 != ToolBar_GetButtonInfo(_hwndTB, uiCmd, &tbbi));
        }

        break;
    }

    //BUGBUG: Right now I am calling the same function for both A and W version if this notification supports 
    // Strings then  it needs to thunk. Right now its only used for image
    case  TBN_GETDISPINFOA:
        _OnGetDispInfo(pnm,  FALSE);
        break;
    case  TBN_GETDISPINFOW:
        _OnGetDispInfo(pnm,  TRUE);
        break;
        
    case NM_TOOLTIPSCREATED:
        _OnToolTipsCreated((NMTOOLTIPSCREATED*)pnm);
        break;

    case NM_RCLICK:
        lres = _OnContextMenu(NULL, GetMessagePos());
        break;

    case NM_CUSTOMDRAW:
        return _OnCustomDraw((NMCUSTOMDRAW*)pnm);

    }

    return(lres);
}

DWORD CSFToolbar::_GetAttributesOfPidl(LPCITEMIDLIST pidl, DWORD dwAttribs)
{
    if (FAILED(_psf->GetAttributesOf(1, &pidl, &dwAttribs)))
        dwAttribs = 0;

    return dwAttribs;

}

PIBDATA CSFToolbar::_PosToPibData(UINT iPos)
{
    ASSERT(IsWindow(_hwndTB));

    // Initialize to NULL in case the GetButton Fails.
    TBBUTTON tbb = {0};
    PIBDATA pibData = NULL;
    
    if (ToolBar_GetButton(_hwndTB, iPos, &tbb))
    {
        pibData = (PIBDATA)tbb.dwData;
    }

    return pibData;
}

PIBDATA CSFToolbar::_IDToPibData(UINT uiCmd, int * piPos)
{
    PIBDATA pibdata = NULL;

    // Initialize to NULL in case the GetButtonInfo Fails.
    TBBUTTONINFO tbbi = {0};
    int iPos;

    tbbi.cbSize = SIZEOF(tbbi);
    tbbi.dwMask = TBIF_LPARAM;

    iPos = ToolBar_GetButtonInfo(_hwndTB, uiCmd, &tbbi);
    if (iPos >= 0)
        pibdata = (PIBDATA)tbbi.lParam;

    if (piPos)
        *piPos = iPos;

    return pibdata;
}    


LPCITEMIDLIST CSFToolbar::_IDToPidl(UINT uiCmd, int *piPos)
{
    LPCITEMIDLIST pidl;
    PIBDATA pibdata = _IDToPibData(uiCmd, piPos);

    if (pibdata)
        pidl = pibdata->GetPidl();
    else
        pidl = NULL;

    return pidl;
}

/*----------------------------------------------------------
Purpose: IWinEventHandler::OnWinEvent method

         Processes messages passed on from the bandsite.
*/
HRESULT CSFToolbar::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    *plres = 0;
    // We are addref'n here because during the course of the
    // Context menu, the view could be changed which free's the menu.
    // We will release after we're sure the this pointer is no longer needed.
    AddRef();
    
    switch (uMsg) {
    case WM_WININICHANGE:
        if ((SHIsExplorerIniChange(wParam, lParam) == EICH_UNKNOWN) || 
            (wParam == SPI_SETNONCLIENTMETRICS))
        {
            _UpdateIconSize(_uIconSize, TRUE);
            _Refresh();
            goto L_WM_SYSCOLORCHANGE;
        }
        break;

    case WM_SYSCOLORCHANGE:
    L_WM_SYSCOLORCHANGE:
        SendMessage(_hwndTB, uMsg, wParam, lParam);
        InvalidateRect(_hwndTB, NULL, TRUE);
        break;

    case WM_PALETTECHANGED:
        InvalidateRect( _hwndTB, NULL, FALSE );
        SendMessage( _hwndTB, uMsg, wParam, lParam );
        break;
        
    case WM_COMMAND:
        *plres = _OnCommand(wParam, lParam);
        break;
        
    case WM_NOTIFY:
        *plres = _OnNotify((LPNMHDR)lParam);
        break;

    case WM_CONTEXTMENU:
        *plres = _OnContextMenu(wParam, lParam);
        break;
    }

    Release();
    return S_OK;
} 


// Map the information loaded (or ctor) into _psf, [_pidl]
//
HRESULT CSFToolbar::_AfterLoad()
{
    HRESULT hres = S_OK;

    // if we have a pidl then we need to get ready
    // for notifications...
    //
    if (_pidl)
    {
        // pidls must be rooted off the desktop
        //
        _fFSNotify = TRUE;

        // shortcut -- just specifying a pidl is good enough
        //
        if (!_psf)
        {
            _fPSFBandDesktop = TRUE;
            hres = IEBindToObject(_pidl, &_psf);
        }
    }

    return(hres);
}
// IDropTarget implementation
//

/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetWindowsDDT

*/
HRESULT CSFToolbar::GetWindowsDDT(HWND * phwndLock, HWND * phwndScroll)
{
    *phwndLock = _hwndTB;
    *phwndScroll = _hwndTB;
    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::HitTestDDT

*/
HRESULT CSFToolbar::HitTestDDT(UINT nEvent, LPPOINT ppt, DWORD_PTR * pdwId, DWORD *pdwEffect)
{
    TBINSERTMARK tbim;

    switch (nEvent)
    {
    case HTDDT_ENTER:
        return S_OK;

    case HTDDT_OVER:
        {
            int iButton = IBHT_BACKGROUND; // assume we hit the background

            // if we're the source, this may be a move operation
            //
            *pdwEffect = (_iDragSource >= 0) ? DROPEFFECT_MOVE : DROPEFFECT_NONE;
            if (!ToolBar_InsertMarkHitTest(_hwndTB, ppt, &tbim))
            {
                if (tbim.dwFlags & TBIMHT_BACKGROUND)
                {
                    RECT rc;
                    GetClientRect(_hwndTB, &rc);

                    // are we outside the toolbar window entirely?
                    if (!PtInRect(&rc, *ppt))
                    {
                        // rebar already did the hittesting so we are on the rebar
                        // but not the toolbar => we are in the title part
                        if (!_AllowDropOnTitle())
                        {
                            // yes; don't allow drop here
                            iButton = IBHT_OUTSIDEWINDOW;
                            *pdwEffect = DROPEFFECT_NONE;
                        }

                        // set tbim.iButton to invalid value so we don't draw insert mark
                        tbim.iButton = -1;
                    }
                }
                else
                {
                    // nope, we hit a real button
                    //
                    if (tbim.iButton == _iDragSource)
                    {
                        iButton = IBHT_SOURCE; // don't drop on the source button
                    }
                    else
                    {
                        iButton = tbim.iButton;
                    }
                    tbim.iButton = IBHT_BACKGROUND;

                    // we never force a move operation if we're on a real button
                    *pdwEffect = DROPEFFECT_NONE;
                }
            }

            *pdwId = iButton;
        }
        break;

    case HTDDT_LEAVE:
        // Reset
        tbim.iButton = IBHT_BACKGROUND;
        tbim.dwFlags = 0;
        break;

    default:
        return E_INVALIDARG;
    }

    // update ui
    if (tbim.iButton != _tbim.iButton || tbim.dwFlags != _tbim.dwFlags)
    {
        if (ppt)
            _tbim = tbim;

        // for now I don't want to rely on non-filesystem IShellFolder
        // implementations to call our OnChange method when a drop occurs,
        // so don't even show the insert mark.
        //
        if (_fFSNotify || _iDragSource >= 0)
        {
            DAD_ShowDragImage(FALSE);
            ToolBar_SetInsertMark(_hwndTB, &tbim);
            DAD_ShowDragImage(TRUE);
        }
    }

    return S_OK;
}


/*----------------------------------------------------------
Purpose: CDelegateDropTarget::GetObjectDDT

*/
HRESULT CSFToolbar::GetObjectDDT(DWORD_PTR dwId, REFIID riid, LPVOID * ppvObj)
{
    HRESULT hres = E_NOINTERFACE;

    *ppvObj = NULL;

    if ((IBHT_SOURCE == dwId) || (IBHT_OUTSIDEWINDOW == dwId))
    {
        // do nothing
    }
    else if (IBHT_BACKGROUND == dwId)
    {
        // nash:41937: not sure how, but _psf can be NULL...
        if (EVAL(_psf))
            hres = _psf->CreateViewObject(_hwndTB, riid, ppvObj);
    }
    else
    {
        LPCITEMIDLIST pidl = _IDToPidl((UINT)dwId, NULL);

        if (pidl)
        {
            *ppvObj = _GetUIObjectOfPidl(pidl, riid);

            if (*ppvObj)
                hres = S_OK;
        }
    }

    //TraceMsg(TF_BAND, "SFToolbar::GetObject(%d) returns %x", dwId, hres);

    return hres;
}

HRESULT CSFToolbar::_SaveOrderStream()
{
    if (_fChangedOrder)
    {
        // Notify everyone that the order changed
        SHSendChangeMenuNotify(this, SHCNEE_ORDERCHANGED, 0, _pidl);
        _fChangedOrder = FALSE;
        return S_OK;
    }
    else
        return S_FALSE;
}

void CSFToolbar::_Dropped(int nIndex, BOOL fDroppedOnSource)
{
    _fDropped = TRUE;
    _fChangedOrder = TRUE;

    // Save new order stream
    _SaveOrderStream();

    if (fDroppedOnSource)
        _FlushNotifyMessages(_hwndTB);
}

/*----------------------------------------------------------
Purpose: CDelegateDropTarget::OnDropDDT

*/
HRESULT CSFToolbar::OnDropDDT(IDropTarget *pdt, IDataObject *pdtobj, DWORD * pgrfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // Are we NOT the drag source? 
    if (_iDragSource == -1)
    {
        // No, we're not. Well, then the source may be the chevron menu
        // representing the hidden items in this menu. Let's check
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHPidlFromDataObject2(pdtobj, &pidl)))
        {
            // We've got a pidl, Are we the parent? Do we have a button?
            int iIndex;
            if (ILIsParent(_pidl, pidl, TRUE) &&
                _GetButtonFromPidl(ILFindLastID(pidl), NULL, &iIndex))
            {
                // We are the parent! Then let's copy that down and set it
                // as the drag source so that down below we reorder.
                _iDragSource = iIndex;
            }
            ILFree(pidl);
        }
    }

    if (_iDragSource >= 0)
    {
        if (_fAllowReorder)
        {
            TraceMsg(TF_BAND, "SFToolbar::OnDrop reorder %d to %d %s", _iDragSource, _tbim.iButton, _tbim.dwFlags & TBIMHT_AFTER ? "A" : "B");

            int iNewLocation = _tbim.iButton;
            if (_tbim.dwFlags & TBIMHT_AFTER)
                iNewLocation++;

            if (iNewLocation > _iDragSource)
                iNewLocation--;

            if (ToolBar_MoveButton(_hwndTB, _iDragSource, iNewLocation))
            {
                PORDERITEM poi = (PORDERITEM)DPA_FastGetPtr(_hdpa, _iDragSource);
                DPA_DeletePtr(_hdpa, _iDragSource);
                DPA_InsertPtr(_hdpa, iNewLocation, poi);

                OrderList_Reorder(_hdpa);

                // If we're dropping again, then we don't need the _hdpaOrder...
                OrderList_Destroy(&_hdpaOrder);

                // A reorder has occurred. We need to use the order stream as the order...
                _fHasOrder = TRUE;
                _fDropping = TRUE;
                _Dropped(iNewLocation, TRUE);     
                _fDropping = FALSE;
                _RememberOrder();
                _SetDirty(TRUE);
            }
        }

        // Don't forget to reset this!
        _iDragSource = -1;

        DragLeave();
    }
    else
    {
        // We want to override the default to be LINK (SHIFT+CONTROL)
        if ((GetPreferedDropEffect(pdtobj) == 0) &&
            !(*pgrfKeyState & (MK_CONTROL | MK_SHIFT | MK_ALT)))
        {
            // NOTE: not all data objects will allow us to call SetData()
            _SetPreferedDropEffect(pdtobj, DROPEFFECT_LINK);
        }

        _fDropping = TRUE;
        return S_OK;
    }

    return S_FALSE;
}

void CSFToolbar::_SortDPA(HDPA hdpa)
{
    // If we don't have a _psf, then we certainly can't sort it
    // If we don't have a hdpa, then we certainly can't sort it
    // If the hdpa is empty, then there's no point in sorting it
    if (_psf && hdpa && DPA_GetPtrCount(hdpa))
    {
        ORDERINFO   oinfo;
        oinfo.psf = _psf;
        (oinfo.psf)->AddRef();
        oinfo.dwSortBy = (_fNoNameSort ? OI_SORTBYORDINAL : OI_SORTBYNAME);
        DPA_Sort(hdpa, OrderItem_Compare, (LPARAM)&oinfo);
        ATOMICRELEASE(oinfo.psf);
    }
}

void CSFToolbar::_RememberOrder()
{
    OrderList_Destroy(&_hdpaOrder);

    if (_hdpa)
    {
        _hdpaOrder = OrderList_Clone(_hdpa);
        _SortDPA(_hdpaOrder);
    }
}

HMENU CSFToolbar::_GetBaseContextMenu()
{
    HMENU hmenu = LoadMenuPopup_PrivateNoMungeW(MENU_ISFBAND);
    // no logo view, remove the menu item...
    HMENU hView = GetSubMenu( hmenu, 0 );
    DeleteMenu( hView, ISFBIDM_LOGOS, MF_BYCOMMAND );
    return hmenu;
}

HMENU CSFToolbar::_GetContextMenu()
{
    HMENU hmenuSrc = _GetBaseContextMenu();
    if (hmenuSrc)
    {
        MENUITEMINFO mii;

        mii.cbSize = SIZEOF(mii);
        mii.fMask = MIIM_STATE;
        mii.fState = MF_CHECKED;

        UINT uCmdId = ISFBIDM_LOGOS;
        if ( _uIconSize != ISFBVIEWMODE_LOGOS )
            uCmdId = (_uIconSize == ISFBVIEWMODE_LARGEICONS ? ISFBIDM_LARGE : ISFBIDM_SMALL);
            
        SetMenuItemInfo(hmenuSrc, uCmdId, MF_BYCOMMAND, &mii);
        if (!_fNoShowText)
            SetMenuItemInfo(hmenuSrc, ISFBIDM_SHOWTEXT, MF_BYCOMMAND, &mii);
        
        if (!_fFSNotify || !_pidl || ILIsEmpty(_pidl))
            DeleteMenu(hmenuSrc, ISFBIDM_OPEN, MF_BYCOMMAND);

        HMENU hView = GetSubMenu( hmenuSrc, 0 );
        DeleteMenu( hView, ISFBIDM_LOGOS, MF_BYCOMMAND );


    }

    return hmenuSrc;
}
// IContextMenu implementation
//
HRESULT CSFToolbar::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HMENU hmenuSrc = _GetContextMenu();
    int i = 0;
    if ( hmenuSrc )
    {
        i += Shell_MergeMenus(hmenu, hmenuSrc, indexMenu, idCmdFirst, idCmdLast, MM_ADDSEPARATOR);
        DestroyMenu(hmenuSrc);
    }
    
    if (!_pcmSF && _fAllowRename && _psf)
    {
        _psf->CreateViewObject(_hwndTB, IID_IContextMenu, (LPVOID*)&_pcmSF);
    }
    
    if (_pcmSF)
    {
        HRESULT hresT;
        
        _idCmdSF = i - idCmdFirst;
        hresT = _pcmSF->QueryContextMenu(hmenu, indexMenu + i, i, 0x7fff, CMF_BANDCMD);
        if (SUCCEEDED(hresT))
            i += HRESULT_CODE(hresT);
    }
    
    return i;
}

BOOL CSFToolbar::_UpdateShowText(BOOL fNoShowText)
{
    BOOL fChanged = (!_fNoShowText != !fNoShowText);
        
    _fNoShowText = (fNoShowText != 0);

    TraceMsg(TF_BAND, "ISFBand::_UpdateShowText turning text %hs", _fNoShowText ? "OFF" : "ON");

    if (_hwndTB)
    {
        SendMessage(_hwndTB, TB_SETMAXTEXTROWS, _fNoShowText ? 0 : 1, 0L);

        _UpdateButtons();
    }
    
    return fChanged;
}

HRESULT CSFToolbar::InvokeCommand(LPCMINVOKECOMMANDINFO lpici)
{
    BOOL fChanged = FALSE;
    int idCmd = -1;

    if (!HIWORD(lpici->lpVerb))
        idCmd = LOWORD(lpici->lpVerb);

    switch (idCmd)
    {
    case ISFBIDM_REFRESH:
        _Refresh();
        break;
        
    case ISFBIDM_OPEN:
        OpenFolderPidl(_pidl);
        break;
                
    case ISFBIDM_LARGE:
        fChanged = _UpdateIconSize(ISFBVIEWMODE_LARGEICONS, TRUE);
        break;
    case ISFBIDM_SMALL:
        fChanged = _UpdateIconSize(ISFBVIEWMODE_SMALLICONS, TRUE);
        break;

    case ISFBIDM_SHOWTEXT:
        fChanged = _UpdateShowText(!_fNoShowText);
        break;
        
    default:
        if (_pcmSF && idCmd >= _idCmdSF)
        {
            LPCSTR  lpOldVerb = lpici->lpVerb;
            
            lpici->lpVerb = MAKEINTRESOURCEA(idCmd -= _idCmdSF);
            
            _pcmSF->InvokeCommand(lpici);
            _FlushNotifyMessages(_hwndTB);

            lpici->lpVerb = lpOldVerb;
        }
        else
            TraceMsg(TF_BAND, "SFToolbar::InvokeCommand %d not handled", idCmd);
        break;
    }
    
    // Our minimum sizes have changed, notify the bandsite
    //
    if (fChanged)
        _ToolbarChanged();

    return(S_OK);
}

HRESULT CSFToolbar::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pwReserved, LPSTR pszName, UINT cchMax)
{
    return(E_NOTIMPL);
}


void CSFToolbar::_RegisterToolbar()
{
    // Since _SubclassWindow protects against multiply subclassing, 
    // This call is safe, and ensures that the toolbar is subclassed before
    // even trying to register it for change notify.
    if (_hwndTB && _SubclassWindow(_hwndTB) && _fRegisterChangeNotify)
        _RegisterChangeNotify();
    CDelegateDropTarget::Init();
}

void CSFToolbar::_UnregisterToolbar()
{
    if (_hwndTB)
    {
        if (_fRegisterChangeNotify) 
            _UnregisterChangeNotify();
        _UnsubclassWindow(_hwndTB);
    }
}

void CSFToolbar::_RegisterChangeNotify()
{
    // Since we want to register for change notify ONLY once,
    // and only if this is a file system toolbar.
    if (!_fFSNRegistered && _fFSNotify)
    {
        if (_ptscn)
            _ptscn->Register(_hwndTB, g_idFSNotify, _lEvents);
        else
            _RegisterWindow(_hwndTB, _pidl, _lEvents);

        _fFSNRegistered = TRUE;
    }
}

void CSFToolbar::_UnregisterChangeNotify()
{
    // Only unregister if we have been registered.
    if (_hwndTB && _fFSNRegistered && _fFSNotify)
    {
        _fFSNRegistered = FALSE;
        if (_ptscn)
            _ptscn->Unregister();
        else
            _UnregisterWindow(_hwndTB);

    }
}


void CSFToolbar::_ReleaseShellFolder()
{
    if (_psf)
    {
        IUnknown_SetOwner(_psf, NULL);
        ATOMICRELEASE(_psf);
    }
    ATOMICRELEASE(_ptscn);
}    

/*----------------------------------------------------------
Purpose: IWinEventHandler::IsWindowOwner method.

*/
HRESULT CSFToolbar::IsWindowOwner(HWND hwnd)
{
    if (hwnd == _hwndTB ||
        hwnd == _hwndToolTips ||
        hwnd == _hwndPager)
        return S_OK;
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\tbmenu.cpp ===
#include "priv.h"
#include "resource.h"
#include "tbmenu.h"
#include "isfband.h"
#include "isfmenu.h"
#include "util.h"

#include "mluisupp.h"
#define SMFORWARD(x) if (!_psm) { return E_FAIL; } else return _psm->x

#define SUPERCLASS CMenuToolbarBase

CToolbarMenu::CToolbarMenu(DWORD dwFlags, HWND hwndTB) :
   CMenuToolbarBase(NULL, dwFlags),
   _hwndSubject(hwndTB)  // this is the toolbar that we are customizing
{
}

void CToolbarMenu::GetSize(SIZE* psize)
{
    ASSERT(_hwndMB);

    if (SendMessage(_hwndMB, TB_GETTEXTROWS, 0, 0) == 0) {
        // no text labels, so set a min width to make menu look 
        // pretty.  use min width of 4 * button width.
        LRESULT lButtonSize = SendMessage(_hwndMB, TB_GETBUTTONSIZE, 0, 0);
        LONG cxMin = 4 * LOWORD(lButtonSize);
        psize->cx = max(psize->cx, cxMin);
    }
    SUPERCLASS::GetSize(psize);
}

void CToolbarMenu::v_Show(BOOL fShow, BOOL fForceUpdate)
{
    if (fShow)
    {
        _fClickHandled = FALSE;
        _FillToolbar();
        _pcmb->SetTracked(NULL);  // Since hot item is NULL
        ToolBar_SetHotItem(_hwndMB, -1);
        if (fForceUpdate)
            v_UpdateButtons(TRUE);
    }
}

void CToolbarMenu::v_Close()
{
    _UnsubclassWindow(_hwndMB);
}


void CToolbarMenu::v_UpdateButtons(BOOL fNegotiateSize)
{
}


HRESULT CToolbarMenu::v_CallCBItem(int idtCmd, UINT dwMsg, WPARAM wParam, LPARAM lParam)
{
    return S_OK;
}

HRESULT CToolbarMenu::v_GetState(int idtCmd, LPSMDATA psmd)
{
    ASSERT(0);
    return E_NOTIMPL;
}

HRESULT CToolbarMenu::v_ExecItem(int idCmd)
{
    HRESULT hres = E_FAIL;
    TraceMsg(TF_TBMENU, "CToolbarMenu::v_ExecItem \tidCmd: %d", idCmd);
    return hres;
}

void CToolbarMenu::CreateToolbar(HWND hwndParent)
{
    if (!_hwndMB)
    {
        DWORD dwStyle = (WS_VISIBLE | WS_CHILD | TBSTYLE_FLAT |
                         WS_CLIPCHILDREN | WS_CLIPSIBLINGS | CCS_NODIVIDER | 
                         CCS_NOPARENTALIGN | CCS_NORESIZE  | TBSTYLE_REGISTERDROP | TBSTYLE_TOOLTIPS);

        INT_PTR nRows = SendMessage(_hwndSubject, TB_GETTEXTROWS, 0, 0);

        if (nRows > 0)
        {
            // We have text labels; make it TBSTYLE_LIST.  The base class will
            // set TBSTYLE_EX_VERTICAL for us.
            ASSERT(_fHorizInVerticalMB == FALSE);
            dwStyle |= TBSTYLE_LIST;
        }
        else
        {
            // No text labels; make it horizontal and TBSTYLE_WRAPABLE.  Set
            // _fHorizInVerticalMB so that the base class does not try and set
            // TBSTYLE_EX_VERTICAL.
            _fHorizInVerticalMB = TRUE;
            dwStyle |= TBSTYLE_WRAPABLE;
        }

        _hwndMB = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, TEXT("Menu"), dwStyle,
                                 0, 0, 0, 0, hwndParent, (HMENU) FCIDM_TOOLBAR, HINST_THISDLL, NULL);

        if (!_hwndMB)
        {
            TraceMsg(TF_TBMENU, "CToolbarMenu::CreateToolbar: Failed to Create Toolbar");
            return;
        }

        HWND hwndTT = (HWND)SendMessage(_hwndMB, TB_GETTOOLTIPS, 0, 0);
        SHSetWindowBits(hwndTT, GWL_STYLE, TTS_ALWAYSTIP, TTS_ALWAYSTIP);
        SendMessage(_hwndMB, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndMB, TB_SETMAXTEXTROWS, nRows, 0);
        SendMessage(_hwndMB, CCM_SETVERSION, COMCTL32_VERSION, 0);

        SendMessage(_hwndMB, TB_SETEXTENDEDSTYLE, TBSTYLE_EX_DRAWDDARROWS, TBSTYLE_EX_DRAWDDARROWS);

        int cPimgs = (int)SendMessage(_hwndSubject, TB_GETIMAGELISTCOUNT, 0, 0);
        for (int i = 0; i < cPimgs; i++)
        {
            HIMAGELIST himl = (HIMAGELIST)SendMessage(_hwndSubject, TB_GETIMAGELIST, i, 0);
            SendMessage(_hwndMB, TB_SETIMAGELIST, i, (LPARAM)himl);
            HIMAGELIST himlHot = (HIMAGELIST)SendMessage(_hwndSubject, TB_GETHOTIMAGELIST, i, 0);
            SendMessage(_hwndMB, TB_SETHOTIMAGELIST, i, (LPARAM)himlHot);
        }

        _SubclassWindow(_hwndMB);

        // Set the format to ANSI
        ToolBar_SetUnicodeFormat(_hwndMB, 0);

        CMenuToolbarBase::CreateToolbar(hwndParent);
        
    }
    else if (GetParent(_hwndMB) != hwndParent)
    {
        ::SetParent(_hwndMB, hwndParent);
    }
}


LRESULT CToolbarMenu::_DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = CMenuToolbarBase::_DefWindowProcMB(hwnd, uMessage, wParam, lParam);

    if (lRes == 0)
        lRes = CNotifySubclassWndProc::_DefWindowProc(hwnd, uMessage, wParam, lParam);

    return lRes;
}

#define MAXLEN 256

void CToolbarMenu::_FillToolbar()
{
    RECT rcTB;
    TCHAR pszBuf[MAXLEN+1];
    LPTSTR psz;
    TBBUTTON tb;
    INT_PTR i, iCount;

    iCount = SendMessage(_hwndSubject, TB_BUTTONCOUNT, 0, 0L);
    GetClientRect(_hwndSubject, &rcTB);

    for (i = 0; i < iCount; i++) {
        if (SHIsButtonObscured(_hwndSubject, &rcTB, i)) {
            SendMessage(_hwndSubject, TB_GETBUTTON, i, (LPARAM)&tb);
            if (!(tb.fsStyle & BTNS_SEP)) {

                // autosize buttons look ugly here
                tb.fsStyle &= ~BTNS_AUTOSIZE;

                // need to rip off wrap bit; new toolbar will
                // figure out where wrapping should happen
                tb.fsState &= ~TBSTATE_WRAP;

                if (tb.iString == -1) {
                    // no string
                    psz = NULL;
                } else if (HIWORD(tb.iString)) {
                    // it's a string pointer
                    psz = (LPTSTR) tb.iString;
                } else {
                    // it's an index into toolbar string array
                    SendMessage(_hwndSubject, TB_GETSTRING, MAKELONG(MAXLEN, tb.iString), (LPARAM)pszBuf);
                    psz = pszBuf;
                }
                if (psz)
                    tb.iString = (INT_PTR)psz;
                else
                    tb.iString = -1;

                if (tb.iBitmap == -1) {
                    int id = GetDlgCtrlID(_hwndSubject);

                    NMTBDISPINFO  tbgdi = {0};
                    tbgdi.hdr.hwndFrom  = _hwndSubject;
                    tbgdi.hdr.idFrom    = id;
                    tbgdi.hdr.code      = TBN_GETDISPINFO;
                    tbgdi.dwMask        = TBNF_IMAGE;
                    tbgdi.idCommand     = tb.idCommand;
                    tbgdi.iImage        = 0;
                    tbgdi.lParam        = tb.dwData;

                    SendMessage(GetParent(_hwndSubject), WM_NOTIFY, (WPARAM)id, (LPARAM)&tbgdi);

                    if(tbgdi.dwMask & TBNF_DI_SETITEM)
                        tb.iBitmap = tbgdi.iImage;
                }

                SendMessage(_hwndMB, TB_ADDBUTTONS, 1, (LPARAM)&tb);
            }
        }
    }
}

STDMETHODIMP CToolbarMenu::IsWindowOwner(HWND hwnd) 
{ 
    if ( hwnd == _hwndMB) 
        return S_OK;
    else 
        return S_FALSE; 
}

void CToolbarMenu::_CancelMenu()
{
    IMenuPopup* pmp;
    if (EVAL(SUCCEEDED(_pcmb->QueryInterface(IID_IMenuPopup, (LPVOID*)&pmp)))) {
        // tell menuband it's time to die
        pmp->OnSelect(MPOS_FULLCANCEL);
        pmp->Release();
    }
}

STDMETHODIMP CToolbarMenu::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    HRESULT hres = S_FALSE;
    ASSERT(plres);

    switch (uMsg) {

    case WM_COMMAND:
        PostMessage(GetParent(_hwndSubject), WM_COMMAND, wParam, (LPARAM)_hwndSubject);
        _CancelMenu();
        hres = S_OK;
        break;

    case WM_NOTIFY:
        {
            LPNMHDR pnmh = (LPNMHDR) lParam;

            switch (pnmh->code) {

            case TBN_DROPDOWN:
                _fTrackingSubMenu = TRUE;
                pnmh->hwndFrom = _hwndSubject;
                MapWindowPoints(_hwndMB, _hwndSubject, (LPPOINT) &((LPNMTOOLBAR)pnmh)->rcButton, 2);
                *plres = SendMessage(GetParent(_hwndSubject), WM_NOTIFY, wParam, (LPARAM)pnmh);
                _CancelMenu();
                hres = S_OK;
                _fTrackingSubMenu = FALSE;
                break;

            case NM_CUSTOMDRAW:
                // override mnbase custom draw shiznits
                *plres = 0;
                hres = S_OK;
                break;

            default:
                goto DoDefault;
            }

            break;
        }
DoDefault:
    default:
        hres = SUPERCLASS::OnWinEvent(hwnd, uMsg, wParam, lParam, plres);
    }

    return hres;
}

CMenuToolbarBase* ToolbarMenu_Create(HWND hwnd)
{
    return new CToolbarMenu(0, hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\tbmenu.h ===
#ifndef CToolbarMenu_H
#define CToolbarMenu_H

#include "menuband.h"
#include "mnbase.h"
#include "cwndproc.h"

#define TF_TBMENU   0

class CToolbarMenu :    public CMenuToolbarBase,
                        public CNotifySubclassWndProc
                    
{

public:
    // *** IUnknown (override) ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CMenuToolbarBase::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void) { return CMenuToolbarBase::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj) { return CMenuToolbarBase::QueryInterface(riid, ppvObj); };

    // *** IWinEventHandler methods (override) ***
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres);

       virtual BOOL v_TrackingSubContextMenu() { return _fTrackingSubMenu; };
    
    virtual void v_Show(BOOL fShow, BOOL fForceUpdate) ;
    virtual BOOL v_UpdateIconSize(UINT uIconSize, BOOL fUpdateButtons) { return FALSE; };
    virtual void v_UpdateButtons(BOOL fNegotiateSize) ;
    virtual HRESULT v_GetSubMenu(int iCmd, const GUID* pguidService, REFIID riid, void** pObj) {return E_FAIL;};
    virtual HRESULT v_CallCBItem(int idtCmd, UINT dwMsg, WPARAM wParam, LPARAM lParam) ;
    virtual HRESULT v_GetState(int idtCmd, LPSMDATA psmd);
    virtual HRESULT v_ExecItem(int iCmd);
    virtual DWORD v_GetFlags(int iCmd) { return 0; };
    virtual void v_Close(); // override


    virtual int  v_GetDragOverButton() { ASSERT(0); return 0;};
    virtual HRESULT v_GetInfoTip(int iCmd, LPTSTR psz, UINT cch) {return E_NOTIMPL;};
    virtual HRESULT v_CreateTrackPopup(int idCmd, REFIID riid, void** ppvObj) {ASSERT(0); return E_NOTIMPL;};
    virtual void v_Refresh() {/*ASSERT(0);*/};
    virtual void v_SendMenuNotification(UINT idCmd, BOOL fClear) {};
    
    CToolbarMenu(DWORD dwFlags, HWND hwndTB);


protected:

    virtual STDMETHODIMP OnChange(LONG lEvent, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2) { return E_NOTIMPL;    }
    virtual LRESULT _DefWindowProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);


    virtual void CreateToolbar(HWND hwndParent);
    virtual void GetSize(SIZE* psize);

    void _CancelMenu();
    void _FillToolbar();

    HWND _hwndSubject;
    BITBOOL _fTrackingSubMenu:1;

    friend CMenuToolbarBase* ToolbarMenu_Create(HWND hwnd);
};

class CTrackShellMenu : public ITrackShellMenu,
                        public IShellMenu2,
                        public IObjectWithSite,
                        public IServiceProvider
{
public:
    // *** IUnknown ***
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellMenu methods ***
    virtual STDMETHODIMP Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags);
    virtual STDMETHODIMP GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, 
                                    UINT* puIdAncestor, DWORD* pdwFlags);
    virtual STDMETHODIMP SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags);
    virtual STDMETHODIMP GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj);
    virtual STDMETHODIMP SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags);
    virtual STDMETHODIMP InvalidateItem(LPSMDATA psmd, DWORD dwFlags);
    virtual STDMETHODIMP GetState(LPSMDATA psmd);
    virtual STDMETHODIMP SetMenuToolbar(IUnknown* punk, DWORD dwFlags);

    // *** ITrackShellMenu methods ***
    virtual STDMETHODIMP SetObscured(HWND hwndTB, IUnknown* punkBand, DWORD dwSMSetFlags);
    virtual STDMETHODIMP Popup(HWND hwnd, POINTL *ppt, RECTL *prcExclude, DWORD dwFlags);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);
    virtual STDMETHODIMP GetSite(REFIID ridd, void** ppvObj) { *ppvObj = NULL; return E_NOTIMPL; };

    // *** IServiceProvider methods ***
    virtual STDMETHODIMP QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj);

    // *** IShellMenu2 methods ***
    virtual STDMETHODIMP GetSubMenu(UINT idCmd, REFIID riid, void **ppvObj);
    virtual STDMETHODIMP SetToolbar(HWND hwnd, DWORD dwFlags);
    virtual STDMETHODIMP SetMinWidth(int cxMenu);
    virtual STDMETHODIMP SetNoBorder(BOOL fNoBorder);
    virtual STDMETHODIMP SetTheme(LPCWSTR pszTheme);

    CTrackShellMenu();
private:
    virtual ~CTrackShellMenu();

    IShellMenu*     _psmClient;
    IShellMenu*     _psm;
    IShellMenu2*    _psm2;
    IUnknown*       _punkSite;
    int             _cRef;
    HMENU           _hmenu;
    BITBOOL         _fDestroyTopLevel : 1;
};

HRESULT ToolbarMenu_Popup(HWND hwnd, LPRECT prc, IUnknown* punk, HWND hwndTB, int idMenu, DWORD dwFlags);
CMenuToolbarBase* ToolbarMenu_Create(HWND hwnd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\legacy\track.cpp ===
#include "priv.h"
#include "tbmenu.h"
#include "isfband.h"
#include "isfmenu.h"

#include "mluisupp.h"
#define SMFORWARD(x) if (!_psm) { return E_FAIL; } else return _psm->x

typedef struct
{
    WNDPROC pfnOriginal;
    IMenuBand* pmb;
} MENUHOOK;

#define SZ_MENUHOOKPROP TEXT("MenuHookProp")

LRESULT CALLBACK MenuHookWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MENUHOOK* pmh = (MENUHOOK*)GetProp(hwnd, SZ_MENUHOOKPROP);

    if (pmh)
    {
        MSG msg;
        LRESULT lres;

        msg.hwnd = hwnd;
        msg.message = uMsg;
        msg.wParam = wParam;
        msg.lParam = lParam;

        if (pmh->pmb->TranslateMenuMessage(&msg, &lres) == S_OK)
            return lres;

        wParam = msg.wParam;
        lParam = msg.lParam;
        return CallWindowProc(pmh->pfnOriginal, hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

HRESULT HookMenuWindow(HWND hwnd, IMenuBand* pmb)
{
    HRESULT hres = E_FAIL;

    ASSERT(IsWindow(hwnd));

    // make sure we haven't already hooked this window
    if (GetProp(hwnd, SZ_MENUHOOKPROP) == NULL)
    {
        MENUHOOK* pmh = new MENUHOOK;
        if (pmh)
        {
            pmh->pfnOriginal = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_WNDPROC);
            pmh->pmb = pmb;

            SetProp(hwnd, SZ_MENUHOOKPROP, pmh);

            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)MenuHookWndProc);

            hres = S_OK;
        }
    }
    return hres;
}

void UnHookMenuWindow(HWND hwnd)
{

    MENUHOOK* pmh = (MENUHOOK*)GetProp(hwnd, SZ_MENUHOOKPROP);
    if (pmh)
    {
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pmh->pfnOriginal);
        SetProp(hwnd, SZ_MENUHOOKPROP, NULL);
        delete pmh;
    }

}


// This class is here to implement a "Menu Filter". We need this because the old style of 
// implementing obscured Menus does not work because user munges the WM_INITMENUPOPUP information
// based on the relative position within the HMENU. So here we keep that information, we just hide the item.

class CShellMenuCallbackWrapper : public IShellMenuCallback,
                                  public CObjectWithSite
{
    int _cRef;
    IShellMenuCallback* _psmc;
    HWND    _hwnd;
    RECT    _rcTB;
    ~CShellMenuCallbackWrapper()
    {
        ATOMICRELEASE(_psmc);
    }

public:
    CShellMenuCallbackWrapper(HWND hwnd, IShellMenuCallback* psmc) : _cRef(1)
    {
        _psmc = psmc;
        if (_psmc)
            _psmc->AddRef();
        _hwnd = hwnd;
        GetClientRect(_hwnd, &_rcTB);
    }

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj)
    {
        static const QITAB qit[] = 
        {
            QITABENT(CShellMenuCallbackWrapper, IShellMenuCallback),
            QITABENT(CShellMenuCallbackWrapper, IObjectWithSite),
            { 0 },
        };

        return QISearch(this, qit, riid, ppvObj);
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        _cRef++;
        return _cRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        ASSERT(_cRef > 0);
        _cRef--;

        if (_cRef > 0)
            return _cRef;

        delete this;
        return 0;
    }

    // *** CObjectWithSite methods (override)***
    STDMETHODIMP SetSite(IUnknown* punk)            {   return IUnknown_SetSite(_psmc, punk);   }
    STDMETHODIMP GetSite(REFIID riid, void** ppObj) {   return IUnknown_GetSite(_psmc, riid, ppObj); }

    // *** IShellMenuCallback methods ***
    STDMETHODIMP CallbackSM(LPSMDATA psmd, UINT uMsg, WPARAM wParam, LPARAM lParam)
    {
        HRESULT hres = S_FALSE;
        
        if (_psmc)
            hres = _psmc->CallbackSM(psmd, uMsg, wParam, lParam);

        if (uMsg == SMC_GETINFO)
        {
            SMINFO* psminfo = (SMINFO*)lParam;
            int iPos = (int)SendMessage(_hwnd, TB_COMMANDTOINDEX, psmd->uId, 0);

            if (psminfo->dwMask & SMIM_FLAGS &&
                iPos >= 0 && 
                !SHIsButtonObscured(_hwnd, &_rcTB, iPos))
            {
                psminfo->dwFlags |= SMIF_HIDDEN;
                hres = S_OK;
            }
        }

        return hres;
    }
};



//
// CTrackShellMenu implementation
//


STDAPI  CTrackShellMenu_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    HRESULT hres = E_OUTOFMEMORY;
    CTrackShellMenu* pObj = new CTrackShellMenu();
    if (pObj)
    {
        hres = pObj->QueryInterface(IID_PPV_ARG(IUnknown, ppunk));
        pObj->Release();
    }

    return hres;
}

CTrackShellMenu::CTrackShellMenu() : _cRef(1)
{ 
    if (SUCCEEDED(CoCreateInstance(CLSID_MenuBand, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellMenu, &_psm))))
    {
        _psm->QueryInterface(IID_PPV_ARG(IShellMenu2, &_psm2));
    }
}

CTrackShellMenu::~CTrackShellMenu()
{
    ATOMICRELEASE(_psm2);
    ATOMICRELEASE(_psm);
    ATOMICRELEASE(_psmClient);
    ASSERT(!_punkSite);     // else someone neglected to call matching SetSite(NULL)
}

ULONG CTrackShellMenu::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CTrackShellMenu::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CTrackShellMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CTrackShellMenu, IShellMenu, ITrackShellMenu), 
        QITABENT(CTrackShellMenu, ITrackShellMenu),   
        QITABENT(CTrackShellMenu, IShellMenu2),   
        QITABENT(CTrackShellMenu, IObjectWithSite),
        QITABENT(CTrackShellMenu, IServiceProvider),
        { 0 },
    };

    HRESULT hres = QISearch(this, qit, riid, ppvObj);

    return hres;
}

// *** IServiceProvider methods ***
HRESULT CTrackShellMenu::QueryService(REFGUID guidService,
                                  REFIID riid, void **ppvObj)
{
    return IUnknown_QueryService(_psm, guidService, riid, ppvObj);
}

// *** IShellMenu methods ***
STDMETHODIMP CTrackShellMenu::Initialize(IShellMenuCallback* psmc, UINT uId, UINT uIdAncestor, DWORD dwFlags)
{ SMFORWARD(Initialize(psmc, uId, uIdAncestor, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetMenuInfo(IShellMenuCallback** ppsmc, UINT* puId, UINT* puIdAncestor, DWORD* pdwFlags)
{ SMFORWARD(GetMenuInfo(ppsmc, puId, puIdAncestor, pdwFlags)); }

STDMETHODIMP CTrackShellMenu::SetShellFolder(IShellFolder* psf, LPCITEMIDLIST pidlFolder, HKEY hkey, DWORD dwFlags)
{ SMFORWARD(SetShellFolder(psf, pidlFolder, hkey, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetShellFolder(DWORD* pdwFlags, LPITEMIDLIST* ppidl, REFIID riid, void** ppvObj)
{ SMFORWARD(GetShellFolder(pdwFlags, ppidl, riid, ppvObj)); }

STDMETHODIMP CTrackShellMenu::SetMenu(HMENU hmenu, HWND hwnd, DWORD dwFlags)
{ SMFORWARD(SetMenu(hmenu, hwnd, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetMenu(HMENU* phmenu, HWND* phwnd, DWORD* pdwFlags)
{ SMFORWARD(GetMenu(phmenu, phwnd, pdwFlags)); }

STDMETHODIMP CTrackShellMenu::InvalidateItem(LPSMDATA psmd, DWORD dwFlags)
{ SMFORWARD(InvalidateItem(psmd, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetState(LPSMDATA psmd)
{ SMFORWARD(GetState(psmd)); }

STDMETHODIMP CTrackShellMenu::SetMenuToolbar(IUnknown* punk, DWORD dwFlags)
{ SMFORWARD(SetMenuToolbar(punk, dwFlags)); }

STDMETHODIMP CTrackShellMenu::GetSubMenu(UINT idCmd, REFIID riid, void **ppvObj)
{
    if (_psm2)
    {
        return _psm2->GetSubMenu(idCmd, riid, ppvObj);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetToolbar(HWND hwnd, DWORD dwFlags)
{
    if (_psm2)
    {
        return _psm2->SetToolbar(hwnd, dwFlags);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetMinWidth(int cxMenu)
{
    if (_psm2)
    {
        return _psm2->SetMinWidth(cxMenu);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetNoBorder(BOOL fNoBorder)
{
    if (_psm2)
    {
        return _psm2->SetNoBorder(fNoBorder);
    }
    else
    {
        return E_NOTIMPL;
    }
}

STDMETHODIMP CTrackShellMenu::SetTheme(LPCWSTR pszTheme)
{
    if (_psm2)
    {
        return _psm2->SetTheme(pszTheme);
    }
    else
    {
        return E_NOTIMPL;
    }
}

// *** ITrackShellMenu methods ***
HRESULT CTrackShellMenu::SetObscured(HWND hwndTB, IUnknown* punkBand, DWORD dwSMSetFlags)
{
    HRESULT hr = E_OUTOFMEMORY;

    // Make sure we created the Inner Shell Menu
    if (!_psm)
        return hr;

    if (punkBand && 
        SUCCEEDED(punkBand->QueryInterface(IID_PPV_ARG(IShellMenu, &_psmClient))))
    {
        UINT uId, uIdAncestor;
        DWORD dwFlags;
        IShellMenuCallback* psmcb;

        hr = _psmClient->GetMenuInfo(&psmcb, &uId, &uIdAncestor, &dwFlags);
        if (SUCCEEDED(hr))
        {
            IShellMenuCallback* psmcbClone = NULL;
            if (psmcb)
            {
                if (S_FALSE == psmcb->CallbackSM(NULL, SMC_GETOBJECT, 
                    (WPARAM)&IID_IShellMenuCallback,
                    (LPARAM)(LPVOID*)&psmcbClone))
                {
                    psmcbClone = psmcb;
                    psmcbClone->AddRef();
                }
            }

            dwFlags &= ~SMINIT_HORIZONTAL;

            CShellMenuCallbackWrapper* psmcw = new CShellMenuCallbackWrapper(hwndTB, psmcbClone);

            // We want the bands to think it is:
            // Top level - because it has no menuband parent
            // Vertical  - because it's not a menubar
            dwFlags |= SMINIT_TOPLEVEL | SMINIT_VERTICAL;
            hr = _psm->Initialize(psmcw, uId, ANCESTORDEFAULT, dwFlags);

            if (SUCCEEDED(hr))
            {
                HWND hwndOwner;
                HMENU hmenuObscured;
                hr = _psmClient->GetMenu(&hmenuObscured, &hwndOwner, NULL);
                if (SUCCEEDED(hr))
                {
                    hr = _psm->SetMenu(hmenuObscured, hwndOwner, dwSMSetFlags | SMSET_DONTOWN);   // Menuband takes ownership;
                }
            }

            if (psmcb)
                psmcb->Release();

            if (psmcbClone)
                psmcbClone->Release();

            if (psmcw)
                psmcw->Release();

        }
    }
    else
    {
        IShellMenu2 *psm2;
        hr = _psm->QueryInterface(IID_PPV_ARG(IShellMenu2, &psm2));
        if (SUCCEEDED(hr))
        {
            hr = psm2->SetToolbar(hwndTB, dwSMSetFlags);
            psm2->Release();
        }
    }

    return hr;
}

HRESULT CTrackShellMenu::Popup(HWND hwnd, POINTL *ppt, RECTL *prcExclude, DWORD dwFlags)
{
    IMenuBand* pmb;
    HRESULT hres = E_INVALIDARG;


    if (!_psm)
        return hres;

    hres = _psm->QueryInterface(IID_PPV_ARG(IMenuBand, &pmb));
    if (FAILED(hres))
        return hres;

    HWND hwndParent = GetTopLevelAncestor(hwnd);

    // Did the user set a menu into the Shell Menu?
    HWND hwndSubclassed = NULL;
    GetMenu(NULL, &hwndSubclassed, NULL);
    if (hwndSubclassed == NULL)
    {
        // No; We need to artificially set one so that the message filtering and stuff works
        SetMenu(NULL, hwndParent, 0);
    }

    SetForegroundWindow(hwndParent);

    IMenuPopup* pmp;
    hres = CoCreateInstance(CLSID_MenuDeskBar, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IMenuPopup, &pmp));
    if (SUCCEEDED(hres))
    {
        IBandSite* pbs;
        hres = CoCreateInstance(CLSID_MenuBandSite, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IBandSite, &pbs));
        if (SUCCEEDED(hres)) 
        {
            hres = pmp->SetClient(pbs);
            if (SUCCEEDED(hres)) 
            {
                IDeskBand* pdb;
                hres = _psm->QueryInterface(IID_PPV_ARG(IDeskBand, &pdb));
                if (SUCCEEDED(hres)) 
                {
                    hres = pbs->AddBand(pdb);
                    pdb->Release();
                }
            }
            pbs->Release();
        }

        // If we've got a site ourselves, have MenuDeskBar use that.
        if (_punkSite)
            IUnknown_SetSite(pmp, _punkSite);

        if (SUCCEEDED(hres))
        {
            CMBMsgFilter* pmf = GetMessageFilter();
            void* pvContext = GetMessageFilter()->GetContext();
            hres = HookMenuWindow(hwndParent, pmb);
            if (SUCCEEDED(hres))
            {
                // This collapses any modal menus before we proceed. When switching between
                // Chevron menus, we need to collapse the previous menu. Refer to the comment
                // at the function definition.
                pmf->ForceModalCollapse();

                pmp->Popup(ppt, (LPRECTL)prcExclude, dwFlags);

                pmf->SetModal(TRUE);

                MSG msg;
                while (GetMessage(&msg, NULL, 0, 0)) 
                {
                    HRESULT hres = pmb->IsMenuMessage(&msg);
                    if (hres == E_FAIL)
                    {
                        // menuband says it's time to pack up and go home.
                        // re-post this message so that it gets handled after
                        // we've cleaned up the menu (avoid re-entrancy issues &
                        // let rebar restore state of chevron button to unpressed)
                        PostMessage(msg.hwnd, msg.message, msg.wParam, msg.lParam);
                        break;
                    }
                    else if (hres != S_OK) 
                    {
                        // menuband didn't handle this one
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }

                hres = S_OK;
                UnHookMenuWindow(hwndParent);
                // We cannot change the context when modal, so unset the modal flag so that we can undo the context block.
                pmf->SetModal(FALSE); 
                pmf->SetContext(pvContext, TRUE);
            }
            pmb->Release();
        }

        if (_psmClient)
        {
            // This is to fix a bug where if there is a cached ISHellMenu in the submenu,
            // and you share the callback (For example, Broweser menu callback and the
            // favorites menu being shared between the browser bar and the chevron menu)
            // when on menu collapsed, we were destroying the sub menu by doing a set site.
            // since we no longer do the set site on the sub menu, we need a way to say "Reset
            // your parent". and this is the best way.
            IUnknown_Exec(_psmClient, &CGID_MenuBand, MBANDCID_REFRESH, 0, NULL, NULL);
        }

        // This call is required regardless of whether we had a _punkSite above;
        // MenuDeskBar does its cleanup on SetSite(NULL).
        IUnknown_SetSite(pmp, NULL);
        pmp->Release();
    }

    return hres;
}

// *** IObjectWithSite methods ***
HRESULT CTrackShellMenu::SetSite(IUnknown* punkSite)
{
    ASSERT(NULL == punkSite || IS_VALID_CODE_PTR(punkSite, IUnknown));

    ATOMICRELEASE(_punkSite);

    _punkSite = punkSite;

    if (punkSite)
        punkSite->AddRef();

    return S_OK;
}

BOOL IsISFBand(IUnknown* punk)
{
    OLECMD rgCmds[] = {
        ISFBID_PRIVATEID, 0,
    };

    IUnknown_QueryStatus(punk, &CGID_ISFBand, SIZEOF(rgCmds), rgCmds, NULL);

    return BOOLIFY(rgCmds[0].cmdf);
}

HRESULT DoISFBandStuff(ITrackShellMenu* ptsm, IUnknown* punk)
{
    HRESULT hr = E_INVALIDARG;

    if (punk && ptsm)
    {
        IShellFolderBand* psfb;
        hr = punk->QueryInterface(IID_PPV_ARG(IShellFolderBand, &psfb));

        if (SUCCEEDED(hr))
        {
            BANDINFOSFB bi;
            bi.dwMask = ISFB_MASK_IDLIST | ISFB_MASK_SHELLFOLDER;

            hr = psfb->GetBandInfoSFB(&bi);

            if (SUCCEEDED(hr))
            {
                CISFMenuCallback* pCallback = new CISFMenuCallback();

                if (pCallback)
                {
                    hr = pCallback->Initialize(punk);

                    if (SUCCEEDED(hr))
                    {
                        ptsm->Initialize(SAFECAST(pCallback, IShellMenuCallback*), 0, 
                            ANCESTORDEFAULT, SMINIT_VERTICAL | SMINIT_TOPLEVEL);

                        hr = ptsm->SetShellFolder(bi.psf, bi.pidl, NULL, SMSET_COLLAPSEONEMPTY);
                    }
                    pCallback->Release();
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

                bi.psf->Release();
                ILFree(bi.pidl);
            }

            psfb->Release();
        }
    }

    return hr;
}


// An API for internal use.
HRESULT ToolbarMenu_Popup(HWND hwnd, LPRECT prc, IUnknown* punk, HWND hwndTB, int idMenu, DWORD dwFlags)
{
    HRESULT hres = E_OUTOFMEMORY;
    ITrackShellMenu* ptsm;
    if (SUCCEEDED(CoCreateInstance(CLSID_TrackShellMenu, NULL, CLSCTX_INPROC_SERVER,
        IID_PPV_ARG(ITrackShellMenu, &ptsm))))
    {
        hres = S_OK;
        if (IsISFBand(punk))
        {
            hres = DoISFBandStuff(ptsm, punk);
        }
        else if (hwndTB)
        {
            ptsm->Initialize(NULL, 0, ANCESTORDEFAULT, SMINIT_TOPLEVEL | SMINIT_VERTICAL | SMINIT_RESTRICT_DRAGDROP);
            hres = ptsm->SetObscured(hwndTB, punk, SMSET_TOP);
        }

        IUnknown* punkSite;
        if (SUCCEEDED(IUnknown_GetSite(punk, IID_PPV_ARG(IUnknown, &punkSite))))
            IUnknown_SetSite(ptsm, punkSite);

        HMENU hmenu = idMenu ? LoadMenuPopup(idMenu) : NULL;

        if (SUCCEEDED(hres) && hmenu)
            hres = ptsm->SetMenu(hmenu, hwnd, SMSET_BOTTOM);

        if (SUCCEEDED(hres))
        {
            DWORD dwPopupFlags = MPPF_BOTTOM;

            // select first/last menu item if specified
            if (dwFlags == DBPC_SELECTFIRST)
            {
                dwPopupFlags |= MPPF_INITIALSELECT;
            }
            else if (dwFlags == DBPC_SELECTLAST)
            {
                dwPopupFlags |= MPPF_FINALSELECT;
            }
            else if (dwFlags != 0)
            {
                VARIANT var;
                var.vt = VT_I4;
                var.lVal = dwFlags;
                IShellMenu2* psm2;
                if (SUCCEEDED(ptsm->QueryInterface(IID_PPV_ARG(IShellMenu2, &psm2))))
                {
                    IUnknown_QueryServiceExec(psm2, SID_SMenuBandChild, &CGID_MenuBand, MBANDCID_SELECTITEM, 0, &var, NULL);
                    psm2->Release();
                }
            }

            POINTL ptPop = {prc->left, prc->bottom};
            hres = ptsm->Popup(hwnd, &ptPop, (LPRECTL)prc, dwPopupFlags);
        }

        IUnknown_SetSite(ptsm, NULL);
        ptsm->Release();
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\tools\uadump.cpp ===
#include "priv.h"
#include "resource.h"
#include "itbar.h"
#include "itbdrop.h"

#include <stdlib.h>
#include <stdio.h>

struct valstr {
    int     val;
    char *  str;
};

#define TABENT(id)  { id, # id },
struct valstr ValStrTab[] = {
    // these guys come from doing:
    // qgrep IDM_ *.h unicpp/*.h ../inc/*.h
    // qgrep DVM_ *.h unicpp/*.h ../inc/*.h
    // magic editor commands to change to the right format:
    //  g/#define/s/.*#define /TABENT(/
    //  g/TABENT/s/\([^ ]*\).*/\1)/

#if 0
    // itbar.h
    TABENT(CITIDM_ONINTERNET)
    TABENT(CITIDM_THEATER)
    TABENT(CITIDM_TEXTLABELS)
    TABENT(CITIDM_VIEWTOOLS)
    TABENT(CITIDM_VIEWADDRESS)
    TABENT(CITIDM_VIEWLINKS)
    TABENT(CITIDM_SHOWTOOLS)
    TABENT(CITIDM_SHOWADDRESS)
    TABENT(CITIDM_SHOWLINKS)
    TABENT(CITIDM_EDITPAGE)
    TABENT(CITIDM_BRANDSIZE)
    TABENT(CITIDM_VIEWMENU)
    TABENT(CITIDM_VIEWAUTOHIDE)
    TABENT(CITIDM_GETMINROWHEIGHT)
    TABENT(CITIDM_SHOWMENU)
    TABENT(CITIDM_STATUSCHANGED)
    TABENT(CITIDM_GETDEFAULTBRANDCOLOR)
    TABENT(CITIDM_DISABLESHOWMENU)
    TABENT(CITIDM_SET_DIRTYBIT)
    TABENT(CITIDM_VIEWTOOLBARCUSTOMIZE)
#endif
    // itbdrop.h
    TABENT(TBIDM_BACK)
    TABENT(TBIDM_FORWARD)
    TABENT(TBIDM_HOME)
    TABENT(TBIDM_SEARCH)
    TABENT(TBIDM_STOPDOWNLOAD)
    TABENT(TBIDM_REFRESH)
    TABENT(TBIDM_FAVORITES)
#ifdef TBIDM_PRINT // old-style (pre-chee) toolbar
    TABENT(TBIDM_PRINT)
#endif
    TABENT(TBIDM_THEATER)
#ifdef TBIDM_PRINT
    TABENT(TBIDM_EDIT)
    TABENT(TBIDM_SHOWTOOLS)
    TABENT(TBIDM_HIDETOOLS)
    TABENT(TBIDM_MAILNEWS)
    TABENT(TBIDM_FONTS)
#endif
    TABENT(TBIDM_HISTORY)
#if defined(ENABLE_CHANNELS) && defined(TBIDM_CHANNELS)
    TABENT(TBIDM_CHANNELS)
#endif
#ifdef TBIDM_PRINT
    TABENT(TBIDM_QUICKLINK1)
    TABENT(TBIDM_QUICKLINK2)
    TABENT(TBIDM_QUICKLINK3)
    TABENT(TBIDM_QUICKLINK4)
    TABENT(TBIDM_QUICKLINK5)
#endif
    // resource.h
    TABENT(BSIDM_CLOSEBAND)
    TABENT(BSIDM_SHOWTITLEBAND)
    TABENT(BSIDM_IEAK_DISABLE_DDCLOSE)
    TABENT(BSIDM_IEAK_DISABLE_MOVE)
    TABENT(ISFBIDM_LARGE)
    TABENT(ISFBIDM_SMALL)
    TABENT(ISFBIDM_LOGOS)
    TABENT(ISFBIDM_SHOWTEXT)
    TABENT(ISFBIDM_REFRESH)
    TABENT(ISFBIDM_OPEN)
    TABENT(DBIDM_NEWFOLDERBAND)
    TABENT(DBIDM_DESKTOPBAND)
    TABENT(DBIDM_LAUNCHBAND)
    TABENT(DBIDM_NEWBANDFIXEDLAST)
    TABENT(MNIDM_RESORT)
    TABENT(MNIDM_LAST)
    TABENT(IDM_AB_FIRST)
    TABENT(IDM_AB_LEFT)
    TABENT(IDM_AB_TOP)
    TABENT(IDM_AB_RIGHT)
    TABENT(IDM_AB_BOTTOM)
    TABENT(IDM_AB_BOTTOMMOST)
    TABENT(IDM_AB_TOPMOST)
    TABENT(IDM_AB_REGULAR)
    TABENT(IDM_AB_AUTOHIDE)
    TABENT(IDM_AB_CLOSE)
    TABENT(IDM_AB_ENABLEMODELESS)
    TABENT(IDM_AB_DISABLEMODELESS)
    TABENT(IDM_AB_ACTIVATE)
    TABENT(IDM_AB_LAST)
    TABENT(DVIDM_GOHOME)
    TABENT(FCIDM_DROPDRIVELIST)
    TABENT(DVIDM_OPEN)
    TABENT(DVIDM_SAVE)
    TABENT(DVIDM_SAVEASFILE)
    TABENT(DVIDM_PAGESETUP)
    TABENT(DVIDM_PRINT)
    TABENT(DVIDM_PROPERTIES)
    TABENT(DVIDM_CUT)
    TABENT(DVIDM_COPY)
    TABENT(DVIDM_PASTE)
    TABENT(DVIDM_REFRESH)
    TABENT(DVIDM_STOPDOWNLOAD)
    TABENT(DVIDM_ZOOMIN)
    TABENT(DVIDM_ZOOMOUT)
    TABENT(DVIDM_NEWWINDOW)
    TABENT(DVIDM_NEWMESSAGE)
    TABENT(DVIDM_SEND)
    TABENT(DVIDM_SENDPAGE)
    TABENT(DVIDM_SENDSHORTCUT)
    TABENT(DVIDM_DESKTOPSHORTCUT)
    TABENT(DVIDM_SENDTO)
    TABENT(DVIDM_SENDTOFIRST)
    TABENT(DVIDM_SENDTOLAST)
    TABENT(DVIDM_HELPABOUT)
    TABENT(DVIDM_HELPSEARCH)
    TABENT(DVIDM_HELPTUTORIAL)
    TABENT(DVIDM_HELPMSWEB)
    TABENT(DVIDM_HELPREPAIR)
    TABENT(DVIDM_HELPMSWEBLAST)
    TABENT(DVIDM_SUITE_APP_FIRST)
    TABENT(DVIDM_NEW)
    TABENT(DVIDM_NEWPOST)
    TABENT(DVIDM_NEWAPPOINTMENT)
    TABENT(DVIDM_NEWMEETING)
    TABENT(DVIDM_NEWCONTACT)
    TABENT(DVIDM_NEWTASK)
    TABENT(DVIDM_NEWTASKREQUEST)
    TABENT(DVIDM_NEWJOURNAL)
    TABENT(DVIDM_NEWNOTE)
    TABENT(DVIDM_CALL)
    TABENT(DVIDM_SUITE_APP_LAST)
    TABENT(DVIDM_NONSUITE_APP_FIRST)
    TABENT(DVIDM_NONSUITE_APP_LAST)
    TABENT(DVIDM_MSHTML_FIRST)
    TABENT(DVIDM_MSHTML_LAST)
    TABENT(FCIDM_FIRST)
    TABENT(FCIDM_LAST)
    TABENT(FCIDM_BROWSER_FILE)
    TABENT(FCIDM_FILECLOSE)
    TABENT(FCIDM_PREVIOUSFOLDER)
    TABENT(FCIDM_DELETE)
    TABENT(FCIDM_RENAME)
    TABENT(FCIDM_PROPERTIES)
    TABENT(FCIDM_VIEWOFFLINE)
    TABENT(FCIDM_FILENSCBANDSEP)
    // IE4 shipped with FCIDM_NEXTCTL as 0xA030 and we can not change it
    TABENT(FCIDM_NEXTCTL)
    TABENT(FCIDM_BACKSPACE)
#ifdef TEST_AMBIENTS
    TABENT(FCIDM_VIEWLOCALOFFLINE)
    TABENT(FCIDM_VIEWLOCALSILENT)
#endif
    TABENT(FCIDM_BROWSER_EDIT)
    TABENT(FCIDM_MOVE)
    TABENT(FCIDM_COPY)
    TABENT(FCIDM_PASTE)
    TABENT(FCIDM_SELECTALL)
    TABENT(FCIDM_LINK)
    TABENT(FCIDM_EDITPAGE)
    // APPCOMPAT:: IOmega relies on FCIDM_REFRESH was WM_COMMAND of A065
    TABENT(FCIDM_W95REFRESH)
    TABENT(FCIDM_BROWSER_TOOLS)
    TABENT(FCIDM_CONNECT)
    TABENT(FCIDM_DISCONNECT)
    TABENT(FCIDM_CONNECT_SEP)
    TABENT(FCIDM_GETSTATUSBAR)
    // IE4 shipped with FCIDM_FINDFILES as 0xA0085 and we can not change it
    TABENT(FCIDM_FINDFILES)
    // IE4 shipped with FCIDM_FINDFILES as 0xA0086 and we can not change it
    TABENT(FCIDM_FINDCOMPUTER)
    TABENT(FCIDM_SETSTATUSBAR)
    TABENT(FCIDM_PERSISTTOOLBAR)
    TABENT(FCIDM_MENU_TOOLS_FINDFIRST)
    TABENT(FCIDM_MENU_TOOLS_FINDLAST)
    TABENT(FCIDM_BROWSER_HELP)
    TABENT(FCIDM_HELPSEARCH)
    TABENT(FCIDM_HELPABOUT)
    TABENT(FCIDM_BROWSER_EXPLORE)
    TABENT(FCIDM_NAVIGATEBACK)
    TABENT(FCIDM_NAVIGATEFORWARD)
    TABENT(FCIDM_BROWSEROPTIONS)
    TABENT(FCIDM_LINKSSEPARATOR)
    TABENT(FCIDM_STARTPAGE)
    TABENT(FCIDM_UPDATEPAGE)
    TABENT(FCIDM_CHANNELGUIDE)
    TABENT(FCIDM_MAIL)
    TABENT(FCIDM_NEWS)
    TABENT(FCIDM_MAILNEWSSEPARATOR)
    TABENT(FCIDM_NEWMESSAGE)
    TABENT(FCIDM_SENDLINK)
    TABENT(FCIDM_SENDDOCUMENT)
    TABENT(FCIDM_SEARCHSIMILAR)
    TABENT(FCIDM_OPEN_SUBSCRIPTION)
    TABENT(FCIDM_MYCOMPUTER)
    TABENT(FCIDM_SEARCHMENU)
    TABENT(FCIDM_RECENTFIRST)
    TABENT(FCIDM_RECENTLAST)
    TABENT(FCIDM_RECENTMENU)
    TABENT(FCIDM_FAVS_FIRST)
    TABENT(FCIDM_ORGANIZEFAVORITES)
    TABENT(FCIDM_ADDTOFAVORITES)
    TABENT(FCIDM_FAVS_MORE)
    TABENT(FCIDM_FAVORITEFIRST)
    TABENT(FCIDM_UPDATESUBSCRIPTIONS)
    TABENT(FCIDM_SORTBY)
    TABENT(FCIDM_SORTBYNAME)
    TABENT(FCIDM_SORTBYVISIT)
    TABENT(FCIDM_SORTBYDATE)
    TABENT(FCIDM_FAVAUTOARRANGE)
    TABENT(FCIDM_SUBSCRIPTIONS)
    TABENT(FCIDM_SUBSCRIBE)
    TABENT(FCIDM_FAVORITELAST)
    TABENT(FCIDM_FAVORITE_ITEM)
    TABENT(FCIDM_FAVORITECMDFIRST)
    TABENT(FCIDM_FAVORITECMDLAST)
    TABENT(FCIDM_FAVS_LAST)
    TABENT(FCIDM_BROWSER_VIEW)
    TABENT(FCIDM_VIEWTOOLBAR)
    TABENT(FCIDM_VIEWSTATUSBAR)
    TABENT(FCIDM_VIEWOPTIONS)
    TABENT(FCIDM_VIEWTOOLS)
    TABENT(FCIDM_VIEWADDRESS)
    TABENT(FCIDM_VIEWLINKS)
    TABENT(FCIDM_VIEWTEXTLABELS)
#ifdef TBIDM_PRINT
    TABENT(FCIDM_VIEWTBCUST)
#endif
    TABENT(FCIDM_VIEWAUTOHIDE)
    TABENT(FCIDM_VIEWMENU)
    TABENT(FCIDM_STOP)
    TABENT(FCIDM_VIEWTREE)
    TABENT(FCIDM_VIEWSEARCH)
    TABENT(FCIDM_CUSTOMIZEFOLDER)
    TABENT(FCIDM_VIEWFONTS)
    // 1a is FCIDM_STOP
    TABENT(FCIDM_THEATER)
    TABENT(FCIDM_JAVACONSOLE)
    TABENT(FCIDM_VIEWTOOLBARCUSTOMIZE)
    TABENT(FCIDM_REFRESH)
    TABENT(FCIDM_ADDTOFAVNOUI)
    TABENT(FCIDM_VIEWITBAR)
    TABENT(FCIDM_SEARCHFIRST)
    TABENT(FCIDM_SEARCHLAST)
#ifdef FCIDM_PERFOLDERSEARCHFIRST
    TABENT(FCIDM_PERFOLDERSEARCHFIRST)
    TABENT(FCIDM_PERFOLDERSEARCHLAST)
#endif
    TABENT(FCIDM_VIEWBROWSERBARS)
    TABENT(FCIDM_VBBSEARCHBAND)
    TABENT(FCIDM_VBBFAVORITESBAND)
    TABENT(FCIDM_VBBHISTORYBAND)
#if defined(ENABLE_CHANNELS) && defined(FCIDM_VBBCHANNELSBAND)
    TABENT(FCIDM_VBBCHANNELSBAND)
#endif
    TABENT(FCIDM_VBBEXPLORERBAND)
    TABENT(FCIDM_VBBALL)
#ifdef FCIDM_VBBNONE
    TABENT(FCIDM_VBBNONE)
#endif
    TABENT(FCIDM_VBBFIXFIRST)
    TABENT(FCIDM_VBBFIXLAST)
    TABENT(FCIDM_VBBDYNFIRST)
    TABENT(FCIDM_VBBDYNLAST)
    TABENT(IDM_AC_FIRST)
    TABENT(IDM_AC_UNDO)
    TABENT(IDM_AC_CUT)
    TABENT(IDM_AC_COPY)
    TABENT(IDM_AC_PASTE)
    TABENT(IDM_AC_DELETE)
    TABENT(IDM_AC_SELECTALL)
    TABENT(IDM_AC_COMPLETIONS)
    TABENT(IDM_AC_FIRSTCOMPITEM)
    TABENT(IDM_AC_LASTCOMPITEM)
    TABENT(FCIDM_APPS_FIRST)
    TABENT(FCIDM_CONTACTS)
    TABENT(FCIDM_CALENDAR)
    TABENT(FCIDM_TASKS)
    TABENT(FCIDM_JOURNAL)
    TABENT(FCIDM_NOTES)
    TABENT(FCIDM_CALL)
    TABENT(FCIDM_APPS_LAST)
    TABENT(FCIDM_FILECTX_FIRST)
    TABENT(FCIDM_FILECTX_LAST)
    TABENT(FSIDM_NEWFOLDER)
    TABENT(FSIDM_NEWLINK)
    TABENT(FSIDM_NEWOTHER)
    TABENT(IDM_BROWBAND_REFRESH)
    TABENT(IDM_BROWBAND_OPENNEW)
};
#undef TABENT

void PrTab(struct valstr *pvs, int n);

int _cdecl main()
{
    PrTab(ValStrTab, ARRAYSIZE(ValStrTab));
    return 0;
}

void PrTab(struct valstr *pvs, int n)
{
    for (; n > 0; n--, pvs++) {
        printf("%s\t0x%x\r\n", pvs->str, pvs->val);
    }
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\commonimagelist.h ===
#ifndef COMMONIMAGELIST_H
#define COMMONIMAGELIST_H

class CImageListValidation 
{
public:
	DWORD wMagic;
	CImageListValidation() : wMagic(IMAGELIST_SIG) { }

	// it is critical that we zero out wMagic in the destructor
	// Yes, the memory is theoretically being freed, but setting
	// it to zero ensures that CImageListBase::IsValid()
	// will never mistake a freed imagelist for a valid one
	~CImageListValidation() {wMagic = 0; }

};

// CImageListBase must begin with CImageListValidation for compat reasons
// We put the IUnknown immediately afterwards so all the people who derive
// from it will agree on where to find QueryInterface et al.
class CImageListBase : public IUnknown, public CImageListValidation
{
public:
    BOOL IsValid() 
    { 
        return this && !IsBadWritePtr(this, sizeof(*this)) && wMagic == IMAGELIST_SIG; 
    }
};


#ifndef offsetofclass
// (Magic stolen from atlbase.h because we don't use ATL2.1 any more)
#define offsetofclass(base, derived) ((ULONG_PTR)(static_cast<base*>((derived*)8))-8)
#endif


// Since we know that IUnknown is implemented on CImageListBase, we find out where exactly 
// the validation layer is by this macro. 
#define FindImageListBase(punk) (CImageListBase*)(CImageListValidation*)((UINT_PTR)punk - offsetofclass(CImageListValidation, CImageListBase));


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\ccver.h ===
//
//  ccver.h
//
//  App compat hack.  Apps, as always, mess up the major/minor version
//  check, so they think that 5.0 is less than 4.71 because they use
//
//    if (major < 4 && minor < 71) Fail();
//
//
//  So we artificially add 80 to our minor version, so 5.0 becomes 5.80,
//  etc.  Note that the hex version is 0x050, since 0x50 = 80 decimal.
//
//
//  The C preprocessor isn't smart enough to extract the commas out of
//  a value string, so we just do it all by hand and assert that nobody
//  has messed with <ntverp.h> or <ieverp.h> in a significant way.
//

#define VER_FILEVERSION             5,82,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_FILEVERSION_STR         "5.82"
#define VER_FILEVERSION_W           0x0552
#define VER_FILEVERSION_DW          (0x05520000 | VER_PRODUCTBUILD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\ccontrol.h ===
class CControl
{
protected:
    
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    void _OnPaint(HDC hdc);

    virtual ~CControl() {};
    virtual void v_OnNCPaint() {};
    virtual void v_OnPaint(HDC hdc) = 0;
    virtual LRESULT v_OnCreate() = 0;
    virtual void v_OnSize(int x, int y) = 0;
    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam) { return 0;};
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam) { return 0;};
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam);
    
    virtual BOOL v_OnNCCalcSize(WPARAM wParam, LPARAM lParam, LRESULT* plres);

    //Data Members
    CONTROLINFO ci;     // common control header info
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\policy_6.0\sources.inc ===
!IF 0
Copyright (c) Microsoft Corporation
!ENDIF

TARGETTYPE=NOTARGET
TARGETPATH=$(_OBJ_DIR)
SOURCES=

SXS_MANIFEST=..\controls.manifest
SXS_REDIRECTED_ASSEMBLY_NAME=Microsoft.Windows.Common-Controls
SXS_ASSEMBLY_NAME=policy.6.0.$(SXS_REDIRECTED_ASSEMBLY_NAME)
# We don't want "6\0\" in the directory tree.
SXS_SHORT_ASSEMBLY_NAME=policy.Microsoft.Windows.Common-Controls
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_ASSEMBLY_IS_POLICY=1
SXS_ASSEMBLY_VERSION=6.0
SXS_ASSEMBLY_VERSION_PART_3=100

SXS_MANIFEST_DEFINES=$(SXS_MANIFEST_DEFINES) \
 -DSXS_REDIRECTED_ASSEMBLY_NAME="\"$(SXS_REDIRECTED_ASSEMBLY_NAME)\"" \

#
# This is set because there exists a wow6432 specific assembly.
#
SXS_LOG_WOWBINS_W_ASMS_PREFIX=w
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_

BOOL NT5_AnimateWindow(IN HWND hwnd, IN DWORD dWTime, IN DWORD dwFlags);
#define AnimateWindow   NT5_AnimateWindow

// Other functions
STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes);
STDAPI_(void) CoolTooltipBubble(IN HWND hwnd, IN LPCRECT prc, BOOL fAllowFade, BOOL fAllowAnimate);
STDAPI_(BOOL) NT5_QueueUserWorkItem(LPTHREAD_START_ROUTINE Function,
    PVOID Context, BOOL PreferIo);
#define CCQueueUserWorkItem NT5_QueueUserWorkItem

STDAPI_(int)
NT5_GetCalendarInfoA(LCID lcid, CALID calid, CALTYPE cal,
                     LPSTR pszBuf, int cchBuf, LPDWORD pdwOut);


// =========================================================================
// things supported since NT5 and Memphis

#define PrivateDFCS_HOT             0x1000
#define PrivateSPI_GETSELECTIONFADE 0x1014

#define PrivateWM_CHANGEUISTATE     0x0127
#define PrivateWM_UPDATEUISTATE     0x0128
#define PrivateWM_QUERYUISTATE      0x0129

#define PrivateUIS_SET              1
#define PrivateUIS_CLEAR            2
#define PrivateUIS_INITIALIZE       3

#define PrivateUISF_HIDEFOCUS       0x1
#define PrivateUISF_HIDEACCEL       0x2

#define PrivateDT_HIDEPREFIX        0x00100000
#define PrivateDT_PREFIXONLY        0x00200000

#define PrivateSPI_GETCLEARTYPE          116
#define PrivateDFCS_TRANSPARENT        0x0800

#define PrivateCAL_RETURN_NUMBER         LOCALE_RETURN_NUMBER
#define PrivateCAL_ITWODIGITYEARMAX      0x00000030
#define PrivateLOCALE_SYEARMONTH         0x00001006

#define PrivateSM_IMMENABLED        82

#if (WINVER >= 0x0500)

// for files in nt5api and w5api dirs, use the definition in sdk include.
// And make sure our private define is in sync with winuser.h.

#if DFCS_HOT != PrivateDFCS_HOT
#error inconsistant DFCS_HOT in winuser.h
#endif

#if SPI_GETSELECTIONFADE != PrivateSPI_GETSELECTIONFADE
#error inconsistant SPI_GETSELECTIONFADE in winuser.h
#endif

// We are checking this in at the same time that user is. This is to prevent
// sync problems.
#ifdef SPI_GETCLEARTYPE
    #if SPI_GETCLEARTYPE != PrivateSPI_GETCLEARTYPE
        #error inconsistant SPI_GETCLEARTYPE in winuser.h
    #endif
#else
    #define SPI_GETCLEARTYPE        PrivateSPI_GETCLEARTYPE
#endif

#if PrivateCAL_RETURN_NUMBER    != CAL_RETURN_NUMBER || \
    PrivateCAL_ITWODIGITYEARMAX != CAL_ITWODIGITYEARMAX
#error inconsistent CAL_RETURN_NUMBER/CAL_ITWODIGITYEARMAX in winnls.h
#endif

#if LOCALE_SYEARMONTH != PrivateLOCALE_SYEARMONTH
#error inconsistant LOCALE_SYEARMONTH in winnls.h
#endif

#ifdef SM_IMMENABLED
    #if SM_IMMENABLED != PrivateSM_IMMENABLED
        #error inconsistant SM_IMMENABLED in winuser.h
    #endif
#else
    #define SM_IMMENABLED       PrivateSM_IMMENABLED
#endif

#else

#define COLOR_HOTLIGHT  GetCOLOR_HOTLIGHT()
#define DFCS_HOT        PrivateDFCS_HOT
#define SPI_GETSELECTIONFADE    PrivateSPI_GETSELECTIONFADE

#define WM_CHANGEUISTATE        PrivateWM_CHANGEUISTATE     
#define WM_UPDATEUISTATE        PrivateWM_UPDATEUISTATE
#define WM_QUERYUISTATE         PrivateWM_QUERYUISTATE      

#define UIS_SET                 PrivateUIS_SET              
#define UIS_CLEAR               PrivateUIS_CLEAR            
#define UIS_INITIALIZE          PrivateUIS_INITIALIZE       

#define UISF_HIDEFOCUS          PrivateUISF_HIDEFOCUS       
#define UISF_HIDEACCEL          PrivateUISF_HIDEACCEL       

#define DT_HIDEPREFIX           PrivateDT_HIDEPREFIX
#define DT_PREFIXONLY           PrivateDT_PREFIXONLY

#define CAL_RETURN_NUMBER       PrivateCAL_RETURN_NUMBER
#define CAL_ITWODIGITYEARMAX    PrivateCAL_ITWODIGITYEARMAX
#define LOCALE_SYEARMONTH       PrivateLOCALE_SYEARMONTH
#define SPI_GETCLEARTYPE        PrivateSPI_GETCLEARTYPE
#define DFCS_TRANSPARENT        PrivateDFCS_TRANSPARENT

#define SM_IMMENABLED           PrivateSM_IMMENABLED

#endif // (WINVER >= 0x0500)
int GetCOLOR_HOTLIGHT();


// =========================================================================
// things supported since NT4 and Memphis

#define PrivateWM_MOUSEWHEEL            0x020A
#define PrivateSPI_GETWHEELSCROLLLINES  104

#if (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

// for files in w5api and all nt* dirs, use the definition in sdk include.
// And make sure our private define is in sync with winuser.h.

#if WM_MOUSEWHEEL != PrivateWM_MOUSEWHEEL
#error inconsistant WM_MOUSEWHEEL in winuser.h
#endif

#if SPI_GETWHEELSCROLLLINES != PrivateSPI_GETWHEELSCROLLLINES
#error inconsistant SPI_GETWHEELSCROLLLINES in winuser.h
#endif

#else

#define WM_MOUSEWHEEL           PrivateWM_MOUSEWHEEL
#define SPI_GETWHEELSCROLLLINES PrivateSPI_GETWHEELSCROLLLINES

#endif // (_WIN32_WINNT >= 0x0400) || (_WIN32_WINDOWS > 0x0400)

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\ccverp.h ===
//
// Version numbering for comctl32.dll
//

#ifndef FEATURE_IE40

#undef VER_PRODUCTBETA_STR
#undef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_DW

//
// NT SUR, IE 3.0
//

#define COMCTL32_BUILD_NUMBER	   1146

#define VER_PRODUCTVERSION          4,70,COMCTL32_BUILD_NUMBER,1

#define VER_PRODUCTBETA_STR         ""
#define VER_PRODUCTVERSION_STR      "4.70"
#define VER_PRODUCTVERSION_W        (0x0446)
#define VER_PRODUCTVERSION_DW       (0x04460000 | COMCTL32_BUILD_NUMBER)

#endif  // FEATURE_IE40
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\apithk.c ===
//
//  APITHK.C
//
//  This file has API thunks that allow comctl32 to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//

#include "ctlspriv.h"       // Don't use precompiled header here

typedef BOOL (* PFNANIMATEWINDOW)(HWND hwnd, DWORD dwTime, DWORD dwFlags);

/*----------------------------------------------------------
Purpose: Thunk for NT 5's AnimateWindow.

Returns: 
Cond:    --
*/
BOOL
NT5_AnimateWindow(
    IN HWND hwnd,
    IN DWORD dwTime,
    IN DWORD dwFlags)
{
    BOOL bRet = FALSE;
    static PFNANIMATEWINDOW pfn = NULL;

    if (NULL == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        
        if (hmod)
            pfn = (PFNANIMATEWINDOW)GetProcAddress(hmod, "AnimateWindow");
    }

    if (pfn)
        bRet = pfn(hwnd, dwTime, dwFlags);

    return bRet;    
}

/*----------------------------------------------------------
Purpose: Shows the tooltip.  On NT4/Win95, this is a standard
         show window.  On NT5/Memphis, this slides the tooltip
         bubble from an invisible point.

Returns: --
Cond:    --
*/

#define CMS_TOOLTIP 135

void SlideAnimate(HWND hwnd, LPCRECT prc)
{
    DWORD dwPos, dwFlags;

    dwPos = GetMessagePos();
    if (GET_Y_LPARAM(dwPos) > prc->top + (prc->bottom - prc->top) / 2)
    {
        dwFlags = AW_VER_NEGATIVE;
    } 
    else
    {
        dwFlags = AW_VER_POSITIVE;
    }

    AnimateWindow(hwnd, CMS_TOOLTIP, dwFlags | AW_SLIDE);
}

STDAPI_(void) CoolTooltipBubble(IN HWND hwnd, IN LPCRECT prc, BOOL fAllowFade, BOOL fAllowAnimate)
{
    ASSERT(prc);

    if (g_bRunOnNT5 || g_bRunOnMemphis)
    {
        BOOL fAnimate = TRUE;
        SystemParametersInfo(SPI_GETTOOLTIPANIMATION, 0, &fAnimate, 0);
        if (fAnimate)
        {
            fAnimate = FALSE;
            SystemParametersInfo(SPI_GETTOOLTIPFADE, 0, &fAnimate, 0);
            if (fAnimate && fAllowFade)
            {
                AnimateWindow(hwnd, CMS_TOOLTIP, AW_BLEND);
            }
            else if (fAllowAnimate)
            {
                SlideAnimate(hwnd, prc);
            }
            else
                goto UseSetWindowPos;
        }
        else
            goto UseSetWindowPos;
    }
    else
    {
UseSetWindowPos:
        SetWindowPos(hwnd, NULL, 0, 0, 0, 0, 
                     SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOSIZE|SWP_NOMOVE|SWP_NOZORDER);
    }
}



/*----------------------------------------------------------
Purpose: Get the COLOR_HOTLIGHT system color index from NT5 or Memphis.
         Get COLOR_HIGHLIGHT from NT4 or Win95, where COLOR_HOTLIGHT is not defined.

Returns: --
Cond:    --
*/
int GetCOLOR_HOTLIGHT()
{
    return (g_bRunOnNT5 || g_bRunOnMemphis) ? COLOR_HOTLIGHT : COLOR_HIGHLIGHT;
}


STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes)
{
    if (g_bRunOnNT5 || g_bRunOnMemphis)
    {
        HCURSOR hcur = LoadCursor(NULL, IDC_HAND);  // from USER, system supplied
        if (hcur)
            return hcur;
    }

    return LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_HAND_INTERNAL));
}

typedef BOOL (*PFNQUEUEUSERWORKITEM)(LPTHREAD_START_ROUTINE Function,
    PVOID Context, BOOL PreferIo);

STDAPI_(BOOL) NT5_QueueUserWorkItem(LPTHREAD_START_ROUTINE Function,
    PVOID Context, BOOL PreferIo)
{
    BOOL bRet = FALSE;
    static PFNQUEUEUSERWORKITEM pfn = (PFNQUEUEUSERWORKITEM)-1;

    if ((PFNQUEUEUSERWORKITEM)-1 == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));
        
        if (hmod)
            pfn = (PFNQUEUEUSERWORKITEM)GetProcAddress(hmod, "QueueUserWorkItem");
        else
            pfn = NULL;
    }

    if (pfn)
        bRet = pfn( Function, Context, PreferIo);

    return bRet;    
}

//
//  Here's how CAL_ITWODIGITYEARMAX works.
//
//  If a two-digit year is input from the user, we put it into the range
//  (N-99) ... N.  for example, if the maximum value is 2029, then all
//  two-digit numbers will be coerced into the range 1930 through 2029.
//
//  Win95 and NT4 don't have GetCalendarInfo, but they do have
//  EnumCalendarInfo, so you'd think we could avoid the GetProcAddress
//  by enumerating the one calendar we care about.
//
//  Unfortunately, Win98 has a bug where EnumCalendarInfo can't enumerate
//  the maximum two-digit year value!  What a lamer!
//
//  So we're stuck with GetProcAddress.
//
//  But wait, Win98 exports GetCalendarInfoW but doesn't implement it!
//  Double lame!
//
//  So we have to use the Ansi version exclusively.  Fortunately, we
//  are only interested in numbers (so far) so there is no loss of amenity.
//
//  First, here's the dummy function that emulates GetCalendarInfoA
//  on Win95 and NT4.
//

STDAPI_(int)
Emulate_GetCalendarInfoA(LCID lcid, CALID calid, CALTYPE cal,
                         LPSTR pszBuf, int cchBuf, LPDWORD pdwOut)
{
    //
    //  In the absence of the API, we go straight for the information
    //  in the registry.
    //
    BOOL fSuccess = FALSE;
    HKEY hkey;

    ASSERT(cal == CAL_RETURN_NUMBER + CAL_ITWODIGITYEARMAX);
    ASSERT(pszBuf == NULL);
    ASSERT(cchBuf == 0);

    if (RegOpenKeyExA(HKEY_CURRENT_USER,
                      "Control Panel\\International\\Calendars\\TwoDigitYearMax",
                      0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        char szKey[16];
        char szBuf[64];
        DWORD dwSize;

        if (SUCCEEDED(StringCchPrintfA(szKey, ARRAYSIZE(szKey), "%d", calid)))
        {
            dwSize = sizeof(szBuf);
            if (RegQueryValueExA(hkey, szKey, 0, NULL, (LPBYTE)szBuf, &dwSize) == ERROR_SUCCESS)
            {
                *pdwOut = StrToIntA(szBuf);
                fSuccess = TRUE;
            }
        }

        RegCloseKey(hkey);
    }
    return fSuccess;

}

typedef int (CALLBACK *GETCALENDARINFOA)(LCID, CALID, CALTYPE, LPSTR, int, LPDWORD);

GETCALENDARINFOA _GetCalendarInfoA;

STDAPI_(int)
NT5_GetCalendarInfoA(LCID lcid, CALID calid, CALTYPE cal,
                     LPSTR pszBuf, int cchBuf, LPDWORD pdwOut)
{
    // This is the only function our emulator supports
    ASSERT(cal == CAL_RETURN_NUMBER + CAL_ITWODIGITYEARMAX);
    ASSERT(pszBuf == NULL);
    ASSERT(cchBuf == 0);

    if (_GetCalendarInfoA == NULL)
    {
        HMODULE hmod = GetModuleHandle(TEXT("KERNEL32"));

        //
        //  Must keep in a local to avoid thread races.
        //
        GETCALENDARINFOA pfn = NULL;

        if (hmod)
            pfn = (GETCALENDARINFOA)
                    GetProcAddress(hmod, "GetCalendarInfoA");

        //
        //  If function is not available, then use our fallback
        //
        if (pfn == NULL)
            pfn = Emulate_GetCalendarInfoA;

        ASSERT(pfn != NULL);
        _GetCalendarInfoA = pfn;
    }

    return _GetCalendarInfoA(lcid, calid, cal, pszBuf, cchBuf, pdwOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\animate.c ===
#include "ctlspriv.h"
#include "rlefile.h"

#define RectWid(_rc)    ((_rc).right-(_rc).left)
#define RectHgt(_rc)    ((_rc).bottom-(_rc).top)

typedef struct {
    HWND        hwnd;                   // my window
    int         id;                     // my id
    HWND        hwndP;                  // my owner (get notify messages)
    DWORD       style;

    BOOL        fFirstPaint;            // TRUE until first paint.
    RLEFILE     *prle;

    CRITICAL_SECTION    crit;

    RECT        rc;
    int         NumFrames;
    int         Rate;

    int         iFrame;
    int         PlayCount;
    int         PlayFrom;
    int         PlayTo;
    HANDLE      PaintThread;
    HANDLE      hStopEvent;

}   ANIMATE;

#define Enter(p)    EnterCriticalSection(&p->crit)
#define Leave(p)    LeaveCriticalSection(&p->crit)

#define OPEN_WINDOW_TEXT 42
#define Ani_UseThread(p) (!((p)->style & ACS_TIMER))

LRESULT CALLBACK AnimateWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);

BOOL HandleOpen(ANIMATE *p, HINSTANCE hInst, LPCTSTR pszName, UINT flags);
BOOL HandleStop(ANIMATE *p);
BOOL HandlePlay(ANIMATE *p, int from, int to, int count);
void HandlePaint(ANIMATE *p, HDC hdc);
int  HandleTick(ANIMATE *p);

#pragma code_seg(CODESEG_INIT)

TCHAR c_szAnimateClass[] = ANIMATE_CLASS;

BOOL FAR PASCAL InitAnimateClass(HINSTANCE hInstance)
{
    WNDCLASS wc;

    wc.lpfnWndProc   = AnimateWndProc;
    wc.lpszClassName = c_szAnimateClass;
    wc.style         = CS_DBLCLKS | CS_GLOBALCLASS;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(LPVOID);
    wc.hInstance     = hInstance;       // use DLL instance if in DLL
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
    wc.lpszMenuName  = NULL;

    RegisterClass(&wc);

    return TRUE;
}
#pragma code_seg()

BOOL HandleOpen(ANIMATE *p, HINSTANCE hInst, LPCTSTR pszName, UINT flags)
{
    TCHAR ach[MAX_PATH];

    //
    // use window text as file name
    //
    if (flags == OPEN_WINDOW_TEXT)
    {
        GetWindowText(p->hwnd, ach, ARRAYSIZE(ach));
        pszName = ach;
    }

    if (hInst == NULL)
        hInst = (HINSTANCE)GetWindowLongPtr(p->hwnd, GWLP_HINSTANCE);

    HandleStop(p);              // stop a play first

    if (p->prle)
    {
        RleFile_Free(p->prle);
        p->prle = NULL;
    }

    p->iFrame = 0;
    p->NumFrames = 0;

    if (pszName == NULL || (!IS_INTRESOURCE(pszName) && *pszName == 0))
        return FALSE;
    //
    //  now open the file/resource we got.
    //
    p->prle = RleFile_New();

    if (p->prle == NULL)
        return FALSE;

    if (!RleFile_OpenFromResource(p->prle, hInst, pszName, TEXT("AVI")) &&
        !RleFile_OpenFromFile(p->prle, pszName))
    {
        RleFile_Free(p->prle);
        p->prle = NULL;
        return FALSE;
    }
    else
    {
        p->NumFrames = RleFile_NumFrames(p->prle);
        p->Rate = (int)RleFile_Rate(p->prle);
        SetRect(&p->rc, 0, 0, RleFile_Width(p->prle), RleFile_Height(p->prle));
    }

    //
    // handle a transparent color
    //
    if ((p->style & ACS_TRANSPARENT) && p->hwndP)
    {
        HDC hdc;
        HDC hdcM;
        HBITMAP hbm;
        COLORREF rgbS, rgbD;

        hdc = GetDC(p->hwnd);

        //
        //  create a bitmap and draw image into it.
        //  get upper left pixel and make that transparent.
        //
        hdcM= CreateCompatibleDC(hdc);
        hbm = CreateCompatibleBitmap(hdc, 1, 1);
        SelectObject(hdcM, hbm);
        HandlePaint(p, hdcM);
        rgbS = GetPixel(hdcM, 0, 0);
        DeleteDC(hdcM);
        DeleteObject(hbm);

        SendMessage(p->hwndP, GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC),
            GET_WM_CTLCOLOR_MPS(hdc, p->hwnd, CTLCOLOR_STATIC));

        rgbD = GetBkColor(hdc);


        ReleaseDC(p->hwnd, hdc);

        //
        // now replace the color
        //
        RleFile_ChangeColor(p->prle, rgbS, rgbD);
    }

    //
    //  ok it worked, resize window.
    //
    if (p->style & ACS_CENTER)
    {
        RECT rc;
        GetClientRect(p->hwnd, &rc);
        OffsetRect(&p->rc, (rc.right-p->rc.right)/2,(rc.bottom-p->rc.bottom)/2);
    }
    else
    {
        RECT rc;
        rc = p->rc;
        AdjustWindowRectEx(&rc, GetWindowStyle(p->hwnd), FALSE, GetWindowExStyle(p->hwnd));
        SetWindowPos(p->hwnd, NULL, 0, 0, RectWid(rc), RectHgt(rc),
            SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE);
    }

    if (p->style & ACS_AUTOPLAY)
    {
        PostMessage(p->hwnd, ACM_PLAY, (UINT_PTR)-1, MAKELONG(0, -1));
    }
    else
    {
        InvalidateRect(p->hwnd, NULL, TRUE);
    }

    return TRUE;
}

void DoNotify(ANIMATE *p, int cmd)
{
    if (p->hwndP)
        PostMessage(p->hwndP, WM_COMMAND, GET_WM_COMMAND_MPS(p->id, p->hwnd, cmd));
}

BOOL HandleStop(ANIMATE *p)
{
    if (p == NULL || !p->PaintThread)
        return FALSE;

    if (Ani_UseThread(p)) {
        // set thread up to terminate between frames
        Enter( p );
        p->PlayCount = 0;
        Leave( p );
        if (p->hStopEvent)
            SetEvent(p->hStopEvent);
        WaitForSingleObject(p->PaintThread, INFINITE);
        // PORT QSY  RAID 4167
        // Under certain situations, both the CloseHandle()
        // and ExitThread() call try to remove MainWin internal
        // objects.
        // This is a work-around for preview 1.
        // I've raised another bug RAID  4250 for OE RTW 
        CloseHandle(p->PaintThread);

        // PORT QSY
        p->PaintThread = NULL;
        if (p->hStopEvent)
            CloseHandle(p->hStopEvent);
        p->hStopEvent = NULL;
    } else {
        KillTimer(p->hwnd, HandleToUlong(p->PaintThread)); // really was a UINT
        p->PaintThread = 0;
        DoNotify(p, ACN_STOP);
    }
    return TRUE;
}

int PlayThread(ANIMATE *p)
{
    int result;
    
    DoNotify(p, ACN_START);

    while (result = HandleTick(p))
    {
        // Sleep for a bit (4 seconds) longer if we are hidden
        //
        // Old code here slept, which can block the UI thread
        // if the app tries to stop/shutdown/change the animation
        // right near the beginning of the sleep.
        //        Sleep((result < 0 ? p->Rate+4000 : p->Rate));
        // Do a timed wait for the stop event instead
        //
        if (p->hStopEvent)
            WaitForSingleObject(p->hStopEvent, (result < 0 ? p->Rate+4000 : p->Rate));
        else
            Sleep((result < 0 ? p->Rate+4000 : p->Rate));
    }

    DoNotify(p, ACN_STOP);
    return 0;
}

BOOL HandlePlay(ANIMATE *p, int from, int to, int count)
{
    if (p == NULL || p->prle == NULL)
        return FALSE;

    HandleStop(p);

    if (from >= p->NumFrames)
        from = p->NumFrames-1;

    if (to == -1)
        to = p->NumFrames-1;

    if (to < 0)
        to = 0;

    if (to >= p->NumFrames)
        to = p->NumFrames-1;

    p->PlayCount = count;
    p->PlayTo    = to;
    if (from >= 0) {
        p->iFrame = from;
        p->PlayFrom  = from;
    } else
        from = p->PlayFrom;

    if ( (from == to) || !count )
    {
        InvalidateRect(p->hwnd, NULL, TRUE);
        return TRUE;
    }

    InvalidateRect(p->hwnd, NULL, FALSE);
    UpdateWindow(p->hwnd);

    if (Ani_UseThread(p))
    {
        DWORD dw;
        p->hStopEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
        p->PaintThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PlayThread, (void*)p, 0, &dw);
    }
    else
    {
        DoNotify(p, ACN_START);
        p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate, NULL);
    }
    return TRUE;
}

void HandleFirstPaint(ANIMATE *p)
{
    if (p->fFirstPaint)
    {
        p->fFirstPaint = FALSE;

        if (p->NumFrames == 0 &&
            (p->style & WS_CHILD))
        {
            HandleOpen(p, NULL, NULL, OPEN_WINDOW_TEXT);
        }
    }
}

void HandlePaint(ANIMATE *p, HDC hdc)
{
    if( p && p->prle )
    {
        Enter( p );
        RleFile_Paint( p->prle, hdc, p->iFrame, p->rc.left, p->rc.top );
        Leave( p );
    }
}

void HandleErase(ANIMATE * p, HDC hdc)
{
    HBRUSH hbr;
    RECT rc;

    hbr = (HBRUSH)SendMessage(p->hwndP, GET_WM_CTLCOLOR_MSG(CTLCOLOR_STATIC),
        GET_WM_CTLCOLOR_MPS(hdc, p->hwnd, CTLCOLOR_STATIC));
    GetClientRect(p->hwnd, &rc);
    FillRect(hdc, &rc, hbr);
}

void HandlePrint(ANIMATE *p, HDC hdc)
{
    HandleFirstPaint(p);
    HandlePaint(p, hdc);
}

int HandleTick(ANIMATE *p)
// - if something to do but we are hidden
// returns 0 if nothing left
// + if something to do
{
    int result = 0;

    if( p && p->prle )
    {
        HDC hdc;
        RECT dummy;

        Enter( p );
        hdc = GetDC( p->hwnd );

        if( GetClipBox( hdc, &dummy ) != NULLREGION )
        {
            // do a full repaint on first frame
            if( p->iFrame == p->PlayFrom )
                HandlePaint( p, hdc );
            else
                RleFile_Draw( p->prle, hdc, p->iFrame, p->rc.left, p->rc.top );

            if( p->iFrame >= p->PlayTo )
            {
                if( p->PlayCount > 0 )
                    p->PlayCount--;

                if( p->PlayCount != 0 )
                    p->iFrame = p->PlayFrom;
            }
            else
                p->iFrame++;


            // Something to do? and visible, return + value
            result = ( p->PlayCount != 0 );
        }
        else
        {
            // Something to do? but hidden, so return - value
            p->iFrame = p->PlayFrom;

            result = -( p->PlayCount != 0 );
        }

        ReleaseDC( p->hwnd, hdc );
        Leave( p );
    }

    return result;
}

void NEAR Ani_OnStyleChanged(ANIMATE* p, WPARAM gwl, LPSTYLESTRUCT pinfo)
{
    if (gwl == GWL_STYLE) {
        p->style = pinfo->styleNew;
    }
}

LRESULT CALLBACK AnimateWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    ANIMATE *p = (ANIMATE *)GetWindowPtr(hwnd, 0);
    HDC hdc;
    PAINTSTRUCT ps;

    // First, the messages that can handle p == NULL.
    // All these handlers must end with a "return" or a "goto DoDefault".

    switch (msg) {
    case WM_NCCREATE:

        #define lpcs ((LPCREATESTRUCT)lParam)

        p = (ANIMATE *)LocalAlloc(LPTR, sizeof(ANIMATE));

        if (!p)
            return 0;       // WM_NCCREATE failure is 0

        // note, zero init memory from above
        p->hwnd = hwnd;
        p->hwndP = lpcs->hwndParent;
        p->id = PtrToUlong(lpcs->hMenu);        // really was an int
        p->fFirstPaint = TRUE;
        p->style = lpcs->style;

        // Must do this before SetWindowBits because that will recursively
        // cause us to receive WM_STYLECHANGED and possibly even WM_SIZE
        // messages.
        InitializeCriticalSection(&p->crit);

        SetWindowPtr(hwnd, 0, p);

        //
        // UnMirror the control, if it is mirrored. We shouldn't mirror
        // a movie! [samera]
        //
        SetWindowBits(hwnd, GWL_EXSTYLE, RTL_MIRRORED_WINDOW, 0);

        goto DoDefault;

    case WM_CLOSE:
        Animate_Stop(hwnd);
        goto DoDefault;

    case WM_NCHITTEST:
        return HTTRANSPARENT;

    case WM_GETOBJECT:
        if( lParam == OBJID_QUERYCLASSNAMEIDX )
            return MSAA_CLASSNAMEIDX_ANIMATE;
        goto DoDefault;
    }

    // Okay, now the messages that cannot handle p == NULL.
    // We check p == NULL once and for all.

    if (!p) goto DoDefault;

    switch (msg) {
    case WM_DESTROY:
        Animate_Close(hwnd);
        DeleteCriticalSection(&p->crit);
        LocalFree((HLOCAL)p);
        SetWindowPtr(hwnd, 0, 0);
        break;

    case WM_ERASEBKGND:
        HandleErase(p, (HDC)wParam);
        return(1);

    case WM_PAINT:
        HandleFirstPaint(p);
        hdc = BeginPaint(hwnd, &ps);
        HandlePaint(p, hdc);
        EndPaint(hwnd, &ps);
        return 0;

    case WM_PRINTCLIENT:
        HandlePrint(p, (HDC)wParam);
        return 0;

    case WM_STYLECHANGED:
        Ani_OnStyleChanged(p, wParam, (LPSTYLESTRUCT)lParam);
        return 0L;
        
    case WM_SIZE:
        if (p->style & ACS_CENTER)
        {
            OffsetRect(&p->rc, (LOWORD(lParam)-RectWid(p->rc))/2-p->rc.left,
                       (HIWORD(lParam)-RectHgt(p->rc))/2-p->rc.top);
            InvalidateRect(hwnd, NULL, TRUE);
        }
        break;

    case WM_TIMER:
    {
        int result;
        result = HandleTick(p);
        if (!result)
        {
            HandleStop(p);
        }
        else if (result < 0)
        {
            p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate+4000, NULL);
        } else
        {
            p->PaintThread = (HANDLE)SetTimer(p->hwnd, 42, (UINT)p->Rate, NULL);
        }
    }
        break;

    case ACM_OPENA:
    {
        WCHAR szFileNameW[MAX_PATH];
        LPTSTR lpFileName = szFileNameW;

        if (!IS_INTRESOURCE(lParam)) 
        {
            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)lParam, -1, szFileNameW, ARRAYSIZE(szFileNameW));
        } 
        else 
        {
            lpFileName = (LPTSTR) lParam;
        }
        
        return HandleOpen(p, (HINSTANCE)wParam, lpFileName, 0);
    }

    case ACM_OPEN:
        return HandleOpen(p, (HINSTANCE)wParam, (LPCTSTR)lParam, 0);

    case ACM_STOP:
        return HandleStop(p);

    case ACM_PLAY:
        return HandlePlay(p, (int)(SHORT)LOWORD(lParam), (int)(SHORT)HIWORD(lParam), (int)wParam);

    }

DoDefault:
    return DefWindowProc(hwnd, msg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\comboex.c ===
#include "ctlspriv.h"

#define EDIT_SELECTALL( hwnd )  Edit_SetSel(hwnd, 0, 0);  \
                                Edit_SetSel(hwnd, 0, -1);

const TCHAR FAR c_szComboBox[] = TEXT("combobox");
const TCHAR FAR c_szComboBoxEx[] = WC_COMBOBOXEX;


#define COMBO_MARGIN        4
#define COMBO_WIDTH         g_cxSmIcon
#define COMBO_HEIGHT        g_cySmIcon
#define COMBO_BORDER        3

typedef struct {
    LPTSTR pszText;
    int iImage;
    int iSelectedImage;
    int iOverlay;
    int iIndent;
    LPARAM lParam;
} CEITEM, *PCEITEM;


typedef struct {
    CONTROLINFO ci;
    HWND hwndCombo;
    HWND hwndEdit;
    DWORD dwExStyle;
    HIMAGELIST himl;
    HFONT hFont;
    int cxIndent;
    WPARAM iSel;
    CEITEM cei;
    BOOL fEditItemSet       :1;
    BOOL fEditChanged       :1;
    BOOL fFontCreated       :1;
    BOOL fInEndEdit         :1;
    BOOL fInDrop            :1;
} COMBOEX, *PCOMBOBOXEX;


void ComboEx_OnWindowPosChanging(PCOMBOBOXEX pce, LPWINDOWPOS pwp);
HFONT ComboEx_GetFont(PCOMBOBOXEX pce);
BOOL ComboEx_OnGetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem);
int ComboEx_ComputeItemHeight(PCOMBOBOXEX pce, BOOL);
int ComboEx_OnFindStringExact(PCOMBOBOXEX pce, int iStart, LPCTSTR lpsz);
int WINAPI ShellEditWordBreakProc(LPTSTR lpch, int ichCurrent, int cch, int code);

LRESULT CALLBACK ComboSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
LRESULT CALLBACK EditSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);
int ComboEx_StrCmp(PCOMBOBOXEX pce, LPCTSTR psz1, LPCTSTR psz2);

#define ComboEx_Editable(pce) (((pce)->ci.style & CBS_DROPDOWNLIST) == CBS_DROPDOWN)

void ComboEx_OnSetFont(PCOMBOBOXEX pce, HFONT hFont, BOOL fRedraw)
{
    int iHeight;
    HFONT hfontOld = NULL;

    if (pce->fFontCreated)
        hfontOld = ComboEx_GetFont(pce);

    if (!hFont) {
        LOGFONT lf;
        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(lf), &lf, FALSE);
        hFont = CreateFontIndirect(&lf);
        pce->fFontCreated = TRUE;
    } else {
        pce->fFontCreated = FALSE;
    }
    pce->ci.uiCodePage = GetCodePageForFont(hFont);

    SendMessage(pce->hwndCombo, WM_SETFONT, (WPARAM)hFont, fRedraw);
    if (pce->hwndEdit)
    {
        SendMessage(pce->hwndEdit, WM_SETFONT, (WPARAM)hFont, fRedraw);
        SendMessage(pce->hwndEdit, EM_SETMARGINS, EC_USEFONTINFO, 0L);
    }

    iHeight = ComboEx_ComputeItemHeight(pce, FALSE);
    SendMessage(pce->ci.hwnd, CB_SETITEMHEIGHT, (WPARAM)-1, (LPARAM)iHeight);
    SendMessage(pce->hwndCombo, CB_SETITEMHEIGHT, 0, (LPARAM)iHeight);

    // do this last so that we don't have a nuked font as we try to create the new one
    if (hfontOld)
        DeleteObject(hfontOld);
}


void ComboEx_OnDestroy(PCOMBOBOXEX pce)
{
    // don't need do destroy hwndCombo.. it will be destroyed along with us.
    SendMessage(pce->hwndCombo, CB_RESETCONTENT, 0, 0);
    // we may still have string allocated for the item in the edit box so free it
    if (pce->cei.pszText)
        Str_Set(&(pce->cei.pszText), NULL);
    if (pce->fFontCreated) {
        DeleteObject(ComboEx_GetFont(pce));
    }

    if (pce->hwndEdit)
        RemoveWindowSubclass(pce->hwndEdit,  EditSubclassProc,  0);

    if (pce->hwndCombo)
        RemoveWindowSubclass(pce->hwndCombo, ComboSubclassProc, 0);

    SetWindowPtr(pce->ci.hwnd, 0, 0);
    LocalFree(pce);
}

// this gets the client rect without the scrollbar part and the border
void ComboEx_GetComboClientRect(PCOMBOBOXEX pce, LPRECT lprc)
{
    GetClientRect(pce->hwndCombo, lprc);
    InflateRect(lprc, -g_cxEdge, -g_cyEdge);
    lprc->right -= g_cxScrollbar;
}

// returns the edit box (creating it if necessary) or NULL if the combo does
// not have an edit box
HWND ComboEx_GetEditBox(PCOMBOBOXEX pce)
{
    HFONT hfont;
    DWORD dwStyle;
    DWORD dwExStyle = 0;

    if (pce->hwndEdit)
        return(pce->hwndEdit);

    if (!ComboEx_Editable(pce))
        return(NULL);

    dwStyle = WS_VISIBLE | WS_CLIPSIBLINGS | WS_CHILD | ES_LEFT;

    if (pce->ci.style & CBS_AUTOHSCROLL)
        dwStyle |= ES_AUTOHSCROLL;
    if (pce->ci.style & CBS_OEMCONVERT)
        dwStyle |= ES_OEMCONVERT;

    dwExStyle = pce->ci.dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    pce->hwndEdit = CreateWindowEx(dwExStyle, c_szEdit, c_szNULL, dwStyle, 0, 0, 0, 0,
                                   pce->hwndCombo, IntToPtr_(HMENU, GetDlgCtrlID(pce->ci.hwnd)), HINST_THISDLL, 0);

    if (!pce->hwndEdit ||
        !SetWindowSubclass(pce->hwndEdit, EditSubclassProc, 0, (DWORD_PTR)pce))
    {
        return NULL;
    }

    hfont = ComboEx_GetFont(pce);
    if (hfont)
        FORWARD_WM_SETFONT(pce->hwndEdit, hfont,
                           FALSE, SendMessage);

    return(pce->hwndEdit);
}

///
/// the edit box handling...
/*

 we want the edit box up on CBN_SETFOCUS and CBN_CLOSEUP
 remove it on CBN_DROPDOWN and on CBN_KILLFOCUS

 this assumes that CBN_SETFOCUS and CBN_KILLFOCUS will come before and after
 CBN_DROPDOWN and CBN_CLOSEUP respectively
 */

// Really a BOOL return value
LRESULT ComboEx_EndEdit(PCOMBOBOXEX pce, int iWhy)
{
    NMCBEENDEDIT    nm;
    LRESULT         fRet;

    if (!ComboEx_GetEditBox(pce))
        return(FALSE);

    pce->fInEndEdit = TRUE;

    GetWindowText(pce->hwndEdit, nm.szText, ARRAYSIZE(nm.szText));

    nm.fChanged = pce->fEditChanged;
    nm.iWhy = iWhy;

    nm.iNewSelection = ComboEx_OnFindStringExact(pce, ComboBox_GetCurSel(pce->hwndCombo) - 1, nm.szText);
    fRet = BOOLFROMPTR(CCSendNotify(&pce->ci, CBEN_ENDEDIT, &nm.hdr));

    pce->fInEndEdit = FALSE;

    if (!fRet) 
    {
        if (nm.iNewSelection != ComboBox_GetCurSel(pce->hwndCombo))
        {
            if (nm.iNewSelection != -1)
            {
                SendMessage(pce->ci.hwnd, CB_SETCURSEL, nm.iNewSelection, 0);
            }
            else
            {
                //if the selection is -1 and if we do a CB_SETCURSEL  on comboboxex then it nukes the text in
                //the edit window. Which is not the desired behavior. We need to update the Current Selection in the                 
                //child combobox but leave the text as it is.
                SendMessage(pce->hwndCombo, CB_SETCURSEL, nm.iNewSelection,0);
            }
        }
        pce->fEditChanged = FALSE;
    }
    InvalidateRect(pce->hwndCombo, NULL, FALSE);

    return(fRet);
}

void ComboEx_SizeEditBox(PCOMBOBOXEX pce)
{
    RECT rc;
    int cxIcon = 0, cyIcon = 0;

    ComboEx_GetComboClientRect(pce, &rc);
    InvalidateRect(pce->hwndCombo, &rc, TRUE); // erase so that the selection highlight is erased
    if (pce->himl && !(pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT))
    {
        // Make room for icons.
        ImageList_GetIconSize(pce->himl, &cxIcon, &cyIcon);
        if (cxIcon)
            cxIcon += COMBO_MARGIN;
    }

    // combobox edit field is one border in from the entire combobox client
    // rect -- thus add one border to edit control's left side
    rc.left += g_cxBorder + cxIcon;
    rc.bottom -= g_cyBorder;
    rc.top = rc.bottom - ComboEx_ComputeItemHeight(pce, TRUE) - g_cyBorder;
    SetWindowPos(pce->hwndEdit, NULL, rc.left, rc.top, RECTWIDTH(rc), RECTHEIGHT(rc),
                 SWP_NOACTIVATE | SWP_NOZORDER | SWP_SHOWWINDOW);

}

BOOL ComboEx_GetCurSelText(PCOMBOBOXEX pce, LPTSTR pszText, int cchText)
{

    COMBOBOXEXITEM cei;
    BOOL bRet = TRUE;

    cei.mask = CBEIF_TEXT;
    cei.pszText = pszText;
    cei.cchTextMax = cchText;
    cei.iItem = ComboBox_GetCurSel(pce->hwndCombo);
    
    if (cei.iItem == -1 ) 
    {
        pszText[0] = 0;
        bRet = FALSE;
    } 
    else 
    {
        ComboEx_OnGetItem(pce, &cei);
    }
    return bRet;
}

void ComboEx_UpdateEditText(PCOMBOBOXEX pce, BOOL fClearOnNoSel)
{
    if (!pce->fInEndEdit)
    {
        TCHAR szText[CBEMAXSTRLEN];

        HWND hwndEdit = ComboEx_Editable(pce) ? pce->hwndEdit : pce->hwndCombo;

        if (ComboEx_GetCurSelText(pce, szText, ARRAYSIZE(szText)) || fClearOnNoSel) {
            SendMessage(hwndEdit, WM_SETTEXT, 0, (LPARAM)szText);
            EDIT_SELECTALL( hwndEdit );
        }
    }
}

BOOL ComboEx_BeginEdit(PCOMBOBOXEX pce)
{
    if (!ComboEx_GetEditBox(pce))
        return(FALSE);

    SetFocus(pce->hwndEdit);
    return(TRUE);
}

BOOL ComboSubclass_HandleButton(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    RECT rc;
    POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam)};

    ComboEx_GetComboClientRect(pce, &rc);
    InflateRect(&rc, g_cxEdge, g_cyEdge);

    if (PtInRect(&rc, pt)) {

        //
        //  CheckForDragBegin yields, so we must revalidate on the way back.
        //
        HWND hwndCombo = pce->hwndCombo;
        if (CheckForDragBegin(pce->hwndCombo, LOWORD(lParam), HIWORD(lParam)))
        {
            NMCBEDRAGBEGIN  nmcbebd;
            LRESULT fRet;

            nmcbebd.iItemid = -1;
            GetWindowText(pce->hwndEdit, nmcbebd.szText, ARRAYSIZE(nmcbebd.szText));

            // BUGBUG - raymondc - why do we ignore the return code?
            fRet = CCSendNotify(&pce->ci, CBEN_DRAGBEGIN, &nmcbebd.hdr);
            return TRUE;
        }
        // CheckForDragBegin yields, so revalidate before continuing
        else if (IsWindow(hwndCombo)) {

            // a click on our border should start edit mode as well
            if (ComboEx_Editable(pce)) {
                if (!ComboEx_BeginEdit(pce))
                    SetFocus(pce->hwndCombo);
                return TRUE;
            }
            return FALSE;
        }
   }
   return FALSE;
}

BOOL ComboSubclass_HandleCommand(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);
    HWND hwnd = GET_WM_COMMAND_HWND(wParam, lParam);

    switch (uCmd)
    {
        case EN_SETFOCUS:
            if (!pce->fInDrop)
            {
                EDIT_SELECTALL( pce->hwndEdit );
                CCSendNotify(&pce->ci, CBEN_BEGINEDIT, NULL);
                pce->fEditChanged = FALSE;
            }
            break;

        case EN_KILLFOCUS:
        {
            HWND hwndFocus;
            hwndFocus = GetFocus();
            if (hwndFocus != pce->hwndCombo)
            {
                ComboEx_EndEdit(pce, CBENF_KILLFOCUS);
                SendMessage(pce->hwndCombo, WM_KILLFOCUS, (WPARAM)hwndFocus, 0);
            }

            break;
        }

        case EN_CHANGE:
        {
            TCHAR szTextOrig[CBEMAXSTRLEN];
            TCHAR szTextNow[CBEMAXSTRLEN];
            WPARAM iItem;

            iItem = ComboBox_GetCurSel(pce->hwndCombo);

            if(iItem == -1)
            {
                if (pce->fEditItemSet && pce->cei.pszText) 
                {
                    Str_GetPtr(pce->cei.pszText, szTextOrig, ARRAYSIZE(szTextOrig));
                }
                else
                {
                    szTextOrig[0] = TEXT('\0');
                }
            }
            else 
            {
                ComboEx_GetCurSelText(pce,szTextOrig, ARRAYSIZE(szTextOrig));
            }

            GetWindowText(pce->hwndEdit, szTextNow, ARRAYSIZE(szTextNow));
            pce->fEditChanged = (ComboEx_StrCmp(pce, szTextOrig, szTextNow) != 0);
            SendMessage(pce->ci.hwndParent, WM_COMMAND,
                    GET_WM_COMMAND_MPS(idCmd, pce->ci.hwnd, CBN_EDITCHANGE));

            break;
        }
    }

    return(hwnd == pce->hwndEdit);
}

void EraseWindow(HWND hwnd, HDC hdc, COLORREF clr)
{
    RECT rc;
    GetClientRect(hwnd, &rc);
    FillRectClr(hdc, &rc, clr);
}

LRESULT CALLBACK EditSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    PCOMBOBOXEX pce = (PCOMBOBOXEX)dwRefData;

    if (uMsg == WM_SETFONT ||
        uMsg == WM_WININICHANGE) {
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    }

    switch(uMsg) {
    case WM_ERASEBKGND:
        EraseWindow(hwnd, (HDC)wParam, GetSysColor(COLOR_WINDOW));
        break;

    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, EditSubclassProc, 0);
        break;

    case WM_CHAR:
        switch ((TCHAR)wParam) {
        case TEXT('\n'):
        case TEXT('\r'):
            // return... don't go to wndproc because
            // the edit control beeps on enter
            return 0;
        }
        break;

    case WM_SIZE:
        if (GetFocus() != hwnd) {
            Edit_SetSel(pce->hwndEdit, 0, 0);    // makesure everything is scrolled over first
        }
        break;

    case WM_KEYDOWN:
        switch(wParam) {
        case VK_RETURN:
            if (!ComboEx_EndEdit(pce, CBENF_RETURN))
                // we know we have an edit window, so FALSE return means
                // app returned FALSE to CBEN_ENDEDIT notification
                ComboEx_BeginEdit(pce);
            break;

        case VK_ESCAPE:
            pce->fEditChanged = FALSE;
            if (!ComboEx_EndEdit(pce, CBENF_ESCAPE)) {
                if(pce->fEditItemSet) {
                    if(pce->cei.pszText) {
                        SendMessage(pce->hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)pce->cei.pszText);
                        EDIT_SELECTALL( pce->hwndEdit );
                    }
                    RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
                }else {
                    ComboEx_BeginEdit(pce);
                }
            }
            break;

        // Pass these to the combobox itself to make it work properly...
        case VK_HOME:
        case VK_END:
            if (!pce->fInDrop)
                break;

        case VK_F4:
        case VK_UP:
        case VK_DOWN:
        case VK_PRIOR:
        case VK_NEXT:
            if (pce->hwndCombo)
                return SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
            break;
        }
        break;

    case WM_LBUTTONDOWN:
        if (GetFocus() != pce->hwndEdit)
        {
            SetFocus(pce->hwndEdit);
            // since we disabled autoselection on first click in address bar,
            // we should not eat this message. This allows the dragging to begin with
            // the first click.
            return(0L); // eat this message
        }
        break;

    case WM_SYSKEYDOWN:
        switch(wParam) {
        // Pass these to the combobox itself to make it work properly...
        case VK_UP:
        case VK_DOWN:
            {
                LRESULT lR;
                if (pce->hwndCombo)
                {
                    lR=SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
                    //notify of navigation key usage
                    CCNotifyNavigationKeyUsage(&(pce->ci), UISF_HIDEFOCUS);
                    return lR;
                }
            }
        }
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT ComboEx_GetLBText(PCOMBOBOXEX pce, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    DWORD cchResult = CB_ERR;
    TCHAR szText[CBEMAXSTRLEN];

    COMBOBOXEXITEM cei;
    cei.mask = CBEIF_TEXT;
    cei.pszText = szText;
    cei.cchTextMax = ARRAYSIZE(szText);
    cei.iItem = (INT_PTR)wParam;

    if (ComboEx_OnGetItem(pce, &cei))
    {
        cchResult = lstrlen(szText);

        if (lParam && (uMsg == CB_GETLBTEXT))
        {
            // REVIEW: trusts that the lParam points to a buffer of sufficient
            // size to support the string and null terminator.
            StringCchCopy((LPTSTR)lParam, cchResult+1, szText);
        }
    }

    return cchResult;
}

LRESULT CALLBACK ComboSubclassProc(HWND hwnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    PCOMBOBOXEX pce = (PCOMBOBOXEX)dwRefData;

    switch (uMsg) {

    case WM_ERASEBKGND:
        EraseWindow(hwnd, (HDC)wParam, GetSysColor(COLOR_WINDOW));
        break;

    case CB_GETLBTEXT:
    case CB_GETLBTEXTLEN:
        return ComboEx_GetLBText(pce, uMsg, wParam, lParam);

    case WM_RBUTTONDOWN:
        //Fall Thru
    case WM_LBUTTONDOWN:
        if (ComboSubclass_HandleButton(pce, wParam, lParam)) {
            return 0;
        }
        break;

    case WM_COMMAND:
        if (ComboSubclass_HandleCommand(pce, wParam, lParam))
            return 0;
        break;

    case WM_DESTROY:
        RemoveWindowSubclass(hwnd, ComboSubclassProc, 0);
        break;

    case WM_SETCURSOR:
        if (pce) {
            NMMOUSE nm = {0};
            nm.dwHitInfo = lParam;
            if (CCSendNotify(&pce->ci, NM_SETCURSOR, &nm.hdr))
                return 0;
        }
        break;
    }

    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

BOOL ComboEx_OnCreate(HWND hwnd, LPCREATESTRUCT lpcs)
{
    PCOMBOBOXEX pce;
    DWORD dwStyle;
    DWORD dwExStyle = 0;

    pce = (PCOMBOBOXEX)LocalAlloc(LPTR, sizeof(COMBOEX));
    if (!pce)
        return FALSE;

    SetWindowPtr(hwnd, 0, pce);

    // BUGBUG: force off borders off ourself
    lpcs->style &= ~(WS_BORDER | WS_VSCROLL | WS_HSCROLL | CBS_UPPERCASE | CBS_LOWERCASE);
    SetWindowLong(hwnd, GWL_STYLE, lpcs->style);
    CIInitialize(&pce->ci, hwnd, lpcs);

    // or in CBS_SIMPLE because we can never allow the sub combo box
    // to have just drop down.. it's either all simple or dropdownlist
    dwStyle = CBS_OWNERDRAWFIXED | CBS_SIMPLE | CBS_NOINTEGRALHEIGHT | WS_VISIBLE |WS_VSCROLL | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;

    dwStyle |= (lpcs->style & (CBS_DROPDOWNLIST | CBS_HASSTRINGS | WS_CHILD));

    if ((lpcs->style & CBS_DROPDOWNLIST) == CBS_SIMPLE)
        dwStyle |= (lpcs->style & (CBS_AUTOHSCROLL | CBS_OEMCONVERT | CBS_UPPERCASE | CBS_LOWERCASE));

    dwExStyle = lpcs->dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

    pce->hwndCombo = CreateWindowEx(dwExStyle, c_szComboBox, lpcs->lpszName,
                                    dwStyle,
                                    0, 0, lpcs->cx, lpcs->cy,
                                    hwnd, lpcs->hMenu, lpcs->hInstance, 0);

    if (!pce->hwndCombo ||
        !SetWindowSubclass(pce->hwndCombo, ComboSubclassProc, 0, (DWORD_PTR)pce) ||
        (!ComboEx_GetEditBox(pce) && ComboEx_Editable(pce)))
    {
        ComboEx_OnDestroy(pce);
        return FALSE;
    }

    ComboEx_OnSetFont(pce, NULL, FALSE);
    pce->cxIndent = 10;
    pce->iSel = -1;

    ComboEx_OnWindowPosChanging(pce, NULL);
    return TRUE;
}


HIMAGELIST ComboEx_OnSetImageList(PCOMBOBOXEX pce, HIMAGELIST himl)
{
    int iHeight;
    HIMAGELIST himlOld = pce->himl;

    pce->himl = himl;

    iHeight = ComboEx_ComputeItemHeight(pce, FALSE);
    SendMessage(pce->ci.hwnd, CB_SETITEMHEIGHT, (WPARAM)-1, iHeight);
    SendMessage(pce->hwndCombo, CB_SETITEMHEIGHT, 0, iHeight);

    InvalidateRect(pce->hwndCombo, NULL, TRUE);

    if (pce->hwndEdit)
        ComboEx_SizeEditBox(pce);

    return himlOld;
}

void ComboEx_OnDrawItem(PCOMBOBOXEX pce, LPDRAWITEMSTRUCT pdis)
{
    HDC hdc = pdis->hDC;
    RECT rc = pdis->rcItem;
    TCHAR szText[CBEMAXSTRLEN];
    int offset = 0;
    int xString, yString, xCombo;
    int cxIcon = 0, cyIcon = 0;
    int iLen;
    BOOL fSelected = FALSE;
    SIZE sizeText;
    COMBOBOXEXITEM cei;
    BOOL fNoText = FALSE;
    BOOL fEnabled = IsWindowEnabled(pce->hwndCombo);
    BOOL fRTLReading = FALSE;
    UINT OldTextAlign;

    // Setup the dc before we use it.
    fRTLReading = GetWindowLong(pdis->hwndItem, GWL_EXSTYLE) & WS_EX_RTLREADING;
    if (fRTLReading) {
        OldTextAlign = GetTextAlign(hdc);
        SetTextAlign(hdc, OldTextAlign|TA_RTLREADING);
    }

    rc.top += g_cyBorder;

    szText[0] = 0;
    if (pdis->itemID != -1)
    {
        cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE| CBEIF_INDENT;
        cei.pszText = szText;
        cei.cchTextMax = ARRAYSIZE(szText);
        cei.iItem = pdis->itemID;

        ComboEx_OnGetItem(pce, &cei);

        if (pce->iSel == (int)pdis->itemID ||
            ((pce->iSel == -1) && ((int)pdis->itemID == ComboBox_GetCurSel(pce->hwndCombo))))
            fSelected = TRUE;
    }
    else {
        if(pce->fEditItemSet) {
            cei.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_OVERLAY | CBEIF_SELECTEDIMAGE| CBEIF_INDENT;
            cei.pszText = szText;
            cei.cchTextMax = ARRAYSIZE(szText);
            cei.iItem = pdis->itemID;

            ComboEx_OnGetItem(pce, &cei);
        }
    }

    if (pce->himl && !(pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT))
    {
        ImageList_GetIconSize(pce->himl, &cxIcon, &cyIcon);
        if (cxIcon)
            cxIcon += COMBO_MARGIN;
    }

    // if we're not drawing the edit box, figure out how far to indent
    // over
    if (!(pdis->itemState & ODS_COMBOBOXEDIT))
    {
        offset = (pce->cxIndent * cei.iIndent) + COMBO_BORDER;
    }
    else
    {
        if (pce->hwndEdit)
            fNoText = TRUE;

        if (pce->dwExStyle & CBES_EX_NOEDITIMAGEINDENT)
            cxIcon = 0;
    }

    xCombo = rc.left + offset;
    rc.left = xString = xCombo + cxIcon;
    iLen = lstrlen(szText);
    GetTextExtentPoint(hdc, szText, iLen, &sizeText);

    rc.right = rc.left + sizeText.cx;
    rc.left--;
    rc.right++;

    if (pdis->itemAction != ODA_FOCUS)
    {
        int yMid;
        BOOL fTextHighlight = FALSE;;

        yMid = (rc.top + rc.bottom) / 2;
        // center the string within rc
        yString = yMid - (sizeText.cy/2);

        if (pdis->itemState & ODS_SELECTED) {
            if (!(pdis->itemState & ODS_COMBOBOXEDIT) ||
                !ComboEx_Editable(pce)) {
                fTextHighlight = TRUE;
            }
        }

        if ( !fEnabled ) {
            SetBkColor(hdc, g_clrBtnFace);
            SetTextColor(hdc, GetSysColor(COLOR_GRAYTEXT));
        } else {
            SetBkColor(hdc, GetSysColor(fTextHighlight ?
                            COLOR_HIGHLIGHT : COLOR_WINDOW));
            SetTextColor(hdc, GetSysColor(fTextHighlight ?
                            COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));
        }

        if ((pdis->itemState & ODS_COMBOBOXEDIT) &&
                (rc.right > pdis->rcItem.right))
        {
            // Need to clip as user does not!
            rc.right = pdis->rcItem.right;
        }

        if (!fNoText) {
            ExtTextOut(hdc, xString, yString, ETO_OPAQUE | ETO_CLIPPED, &rc, szText, iLen, NULL);
        }

        if (pce->himl && (pdis->itemID != -1 || pce->fEditItemSet) &&
            !((pce->dwExStyle & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT)) &&
              (pdis->itemState & ODS_COMBOBOXEDIT))) {

            DWORD fTransparent = 0;

            if ((pdis->itemState & ODS_COMBOBOXEDIT) && !fEnabled) {
                fTransparent = ILD_TRANSPARENT;
            }

            if (pce->himl && (pdis->itemID != -1 || pce->fEditItemSet) &&
                !((pce->dwExStyle & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT))))
            {
                ImageList_Draw(pce->himl,
                               (fSelected) ? cei.iSelectedImage : cei.iImage,
                               hdc, xCombo, yMid - (cyIcon/2),
                               INDEXTOOVERLAYMASK(cei.iOverlay) |
                               fTransparent |
                               ((pdis->itemState & ODS_SELECTED) ? (ILD_SELECTED | ILD_FOCUS) : ILD_NORMAL));
            }
        }
    }


    if ((pdis->itemAction == ODA_FOCUS ||
        (pdis->itemState & ODS_FOCUS)) &&
        !(CCGetUIState(&(pce->ci)) & UISF_HIDEFOCUS)
        )
    {
        if (!fNoText) {
            DrawFocusRect(hdc, &rc);
        }
    }

    // Restore the text align in the dc.
    if (fRTLReading) {
        SetTextAlign(hdc, OldTextAlign);
    }
}

int ComboEx_ComputeItemHeight(PCOMBOBOXEX pce, BOOL fTextOnly)
{
    HDC hdc;
    HFONT hfontOld;
    int dyDriveItem;
    SIZE siz;

    hdc = GetDC(NULL);
    hfontOld = ComboEx_GetFont(pce);
    if (hfontOld)
        hfontOld = SelectObject(hdc, hfontOld);

    GetTextExtentPoint(hdc, TEXT("W"), 1, &siz);
    dyDriveItem = siz.cy;

    if (hfontOld)
        SelectObject(hdc, hfontOld);
    ReleaseDC(NULL, hdc);

    if (fTextOnly)
        return dyDriveItem;

    dyDriveItem += COMBO_BORDER;

    // now take into account the icon
    if (pce->himl) {
        int cxIcon = 0, cyIcon = 0;
        ImageList_GetIconSize(pce->himl, &cxIcon, &cyIcon);

        if (dyDriveItem < cyIcon)
            dyDriveItem = cyIcon;
    }

    return dyDriveItem;
}

void ComboEx_OnMeasureItem(PCOMBOBOXEX pce, LPMEASUREITEMSTRUCT pmi)
{

    pmi->itemHeight = ComboEx_ComputeItemHeight(pce, FALSE);

}

void ComboEx_ISetItem(PCOMBOBOXEX pce, PCEITEM pcei, PCOMBOBOXEXITEM pceItem)
{
    if (pceItem->mask & CBEIF_INDENT)
        pcei->iIndent = pceItem->iIndent;
    if (pceItem->mask & CBEIF_IMAGE)
        pcei->iImage = pceItem->iImage;
    if (pceItem->mask & CBEIF_SELECTEDIMAGE)
        pcei->iSelectedImage = pceItem->iSelectedImage;
    if (pceItem->mask & CBEIF_OVERLAY)
        pcei->iOverlay = pceItem->iOverlay;

    if (pceItem->mask & CBEIF_TEXT) {
        Str_Set(&pcei->pszText, pceItem->pszText);
    }

    if (pceItem->mask & CBEIF_LPARAM) {
        pcei->lParam = pceItem->lParam;
    }

}

#define ComboEx_GetItemPtr(pce, iItem) \
        ((PCEITEM)SendMessage((pce)->hwndCombo, CB_GETITEMDATA, iItem, 0))
#define ComboEx_Count(pce) \
        ((int)SendMessage((pce)->hwndCombo, CB_GETCOUNT, 0, 0))


BOOL ComboEx_OnGetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    PCEITEM pcei;
    NMCOMBOBOXEX nm;

    if(pceItem->iItem != -1) {
        pcei = ComboEx_GetItemPtr(pce, pceItem->iItem);
    }
    else {
        pcei = &(pce->cei);
    }

    if ((!pcei) || (pcei == (PCEITEM)-1))
        return FALSE;

    nm.ceItem.mask = 0;

    if (pceItem->mask & CBEIF_TEXT) {

        if (pcei->pszText == LPSTR_TEXTCALLBACK) {
            nm.ceItem.mask |= CBEIF_TEXT;
        } else {
            if(pceItem->iItem != -1) {
                Str_GetPtr(pcei->pszText, pceItem->pszText, pceItem->cchTextMax);
            }else {
                SendMessage(pce->hwndEdit, WM_GETTEXT, (WPARAM)pceItem->cchTextMax, (LPARAM)pceItem->pszText);
            }
        }
    }

    if (pceItem->mask & CBEIF_IMAGE) {

        if (pcei->iImage == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_IMAGE;
        }
        pceItem->iImage = pcei->iImage;

    }

    if (pceItem->mask & CBEIF_SELECTEDIMAGE) {

        if (pcei->iSelectedImage == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_SELECTEDIMAGE;
        }
        pceItem->iSelectedImage = pcei->iSelectedImage;
    }

    if (pceItem->mask & CBEIF_OVERLAY) {

        if (pcei->iOverlay == I_IMAGECALLBACK) {
            nm.ceItem.mask |= CBEIF_OVERLAY;
        }
        pceItem->iOverlay = pcei->iOverlay;
    }

    if (pceItem->mask & CBEIF_INDENT) {

        if (pcei->iIndent == I_INDENTCALLBACK) {
            nm.ceItem.mask |= CBEIF_INDENT;
            pceItem->iIndent = 0;
        } else {
            pceItem->iIndent = pcei->iIndent;
        }
    }

    if (pceItem->mask & CBEIF_LPARAM) {
        pceItem->lParam = pcei->lParam;
    }



    // is there anything to call back for?
    if (nm.ceItem.mask) {
        UINT uMask = nm.ceItem.mask;

        nm.ceItem = *pceItem;
        nm.ceItem.lParam = pcei->lParam;
        nm.ceItem.mask = uMask;

        if ((nm.ceItem.mask & CBEIF_TEXT) &&
            nm.ceItem.cchTextMax) {
            // null terminate just in case they don't respond
            *nm.ceItem.pszText = 0;
        }

        CCSendNotify(&pce->ci, CBEN_GETDISPINFO, &nm.hdr);

        if (nm.ceItem.mask & CBEIF_INDENT)
            pceItem->iIndent = nm.ceItem.iIndent;

        if (nm.ceItem.mask & CBEIF_IMAGE)
            pceItem->iImage = nm.ceItem.iImage;

        if (nm.ceItem.mask & CBEIF_SELECTEDIMAGE)
            pceItem->iSelectedImage = nm.ceItem.iSelectedImage;

        if (nm.ceItem.mask & CBEIF_OVERLAY)
            pceItem->iOverlay = nm.ceItem.iOverlay;

        if (nm.ceItem.mask & CBEIF_TEXT)
        {
            if (pceItem->mask & CBEIF_TEXT)
                pceItem->pszText = CCReturnDispInfoText(nm.ceItem.pszText, pceItem->pszText, pceItem->cchTextMax);
            else
                pceItem->pszText = nm.ceItem.pszText;
        }

        if (nm.ceItem.mask & CBEIF_DI_SETITEM) {

            ComboEx_ISetItem(pce, pcei, &nm.ceItem);
        }
    }
    return TRUE;

}

BOOL ComboEx_OnGetItemA(PCOMBOBOXEX pce, PCOMBOBOXEXITEMA pceItem)
{
    LPWSTR pwszText;
    LPSTR pszTextSave;
    BOOL fRet;

    if (!(pceItem->mask & CBEIF_TEXT)) {
        return ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)pceItem);
    }

    pwszText = (LPWSTR)LocalAlloc(LPTR, (pceItem->cchTextMax+1)*sizeof(WCHAR));
    if (!pwszText)
        return FALSE;
    pszTextSave = pceItem->pszText;
    ((PCOMBOBOXEXITEM)pceItem)->pszText = pwszText;
    fRet = ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)pceItem);
    pceItem->pszText = pszTextSave;

    if (fRet) {
        // BUGBUG: WCTMB failes w/ ERROR_INSUFFICIENT_BUFFER whereas the native-A implementation truncates
        WideCharToMultiByte(CP_ACP, 0, pwszText, -1,
                            (LPSTR)pszTextSave, pceItem->cchTextMax, NULL, NULL);
    }
    LocalFree(pwszText);
    return fRet;

}

BOOL ComboEx_OnSetItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    if(pceItem->iItem != -1) {
        PCEITEM pcei = ComboEx_GetItemPtr(pce, pceItem->iItem);
        UINT rdwFlags = 0;

        if (pcei == (PCEITEM)-1)
            return FALSE;

        ComboEx_ISetItem(pce, pcei, pceItem);

        if (rdwFlags & (CBEIF_INDENT | CBEIF_IMAGE |CBEIF_SELECTEDIMAGE | CBEIF_TEXT | CBEIF_OVERLAY)) {
            rdwFlags = RDW_ERASE | RDW_INVALIDATE;
        }
        // BUGBUG: do something better..

        if (rdwFlags) {
            RedrawWindow(pce->hwndCombo, NULL, NULL, rdwFlags);
        }

        if (pceItem->iItem == ComboBox_GetCurSel(pce->hwndCombo))
            ComboEx_UpdateEditText(pce, FALSE);
        // BUGUBG: notify item changed
        return TRUE;

  } else {

        pce->cei.iImage = -1;
        pce->cei.iSelectedImage = -1;

        ComboEx_ISetItem(pce, &(pce->cei), pceItem);

        pce->fEditItemSet = TRUE;

        if (!pce->hwndEdit){
            Str_Set(&pce->cei.pszText, NULL);
            pce->fEditItemSet = FALSE;
            return(CB_ERR);
        }

        if(pce->cei.pszText) {
            SendMessage(pce->hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)pce->cei.pszText);
            EDIT_SELECTALL( pce->hwndEdit );
        }
        RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
        return TRUE;

   }
}

void ComboEx_HandleDeleteItem(PCOMBOBOXEX pce, LPDELETEITEMSTRUCT pdis)
{
    PCEITEM pcei = (PCEITEM)pdis->itemData;
    if (pcei) {
        NMCOMBOBOXEX nm;

        Str_Set(&pcei->pszText, NULL);

        nm.ceItem.iItem = pdis->itemID;
        nm.ceItem.mask = CBEIF_LPARAM;
        nm.ceItem.lParam = pcei->lParam;
        CCSendNotify(&pce->ci, CBEN_DELETEITEM, &nm.hdr);

        LocalFree(pcei);
    }
}

LRESULT ComboEx_OnInsertItem(PCOMBOBOXEX pce, PCOMBOBOXEXITEM pceItem)
{
    LRESULT iRet;
    PCEITEM pcei = (PCEITEM)LocalAlloc(LPTR, sizeof(CEITEM));

    if (!pcei)
        return -1;

    pcei->iImage = -1;
    pcei->iSelectedImage = -1;
    //pcei->iOverlay = 0;
    //pcei->iIndent = 0;

    ComboEx_ISetItem(pce, pcei, pceItem);

    iRet = ComboBox_InsertString(pce->hwndCombo, pceItem->iItem, pcei);
    if (iRet != -1) {
        NMCOMBOBOXEX nm;

        nm.ceItem = *pceItem;
        CCSendNotify(&pce->ci, CBEN_INSERTITEM, &nm.hdr);
    }
    return iRet;
}


void ComboEx_OnWindowPosChanging(PCOMBOBOXEX pce, LPWINDOWPOS pwp)
{
    RECT rcWindow, rcClient;
    RECT rc;
    int  cxInner;
    int cy;

    GetWindowRect(pce->ci.hwnd, &rcWindow);

    if (pwp) {
        // check to see if our size & position aren't actually changing (rebar, for one, 
        // does lots of DeferWindowPos calls that don't actually change our size or position
        // but still generate WM_WINDOWPOSCHANGING msgs).  we avoid flicker by bailing here.
        RECT rcWp;
        SetRect(&rcWp, pwp->x, pwp->y, pwp->x + pwp->cx, pwp->y + pwp->cy);
        MapWindowRect(GetParent(pce->ci.hwnd), HWND_DESKTOP, (LPPOINT)&rcWp);
        if (EqualRect(&rcWp, &rcWindow)) {
            // this is a noop, so bail
            return;
        }
    }

    GetClientRect(pce->ci.hwnd, &rcClient);

    if (pwp)
        cxInner = pwp->cx + RECTWIDTH(rcWindow) - RECTWIDTH(rcClient);
    else
        cxInner = RECTWIDTH(rcClient);

    GetWindowRect(pce->hwndCombo, &rc);
    if (cxInner) {

        // don't size the inner combo if width is 0; otherwise, the below
        // computation will make the comboEX the height of the inner combo
        // top + inner combo dropdown instead of JUST the inner combo top
        cy = (pwp && ((pce->ci.style & CBS_DROPDOWNLIST) == CBS_SIMPLE)) ?  pwp->cy : RECTHEIGHT(rc);

        SetWindowPos(pce->hwndCombo, NULL, 0, 0, cxInner, cy,
                                          SWP_NOACTIVATE | (pce->hwndEdit ? SWP_NOREDRAW : 0));
    }

    GetWindowRect(pce->hwndCombo, &rc);

    cy = RECTHEIGHT(rc) + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));

    if (pwp) {
        if (cy < pwp->cy || !(pce->dwExStyle & CBES_EX_NOSIZELIMIT)) {
            pwp->cy = cy;
        }
    } else {

        if (cy < RECTHEIGHT(rcWindow) || !(pce->dwExStyle & CBES_EX_NOSIZELIMIT)) {
            SetWindowPos(pce->ci.hwnd, NULL, 0, 0,
                         RECTWIDTH(rcWindow),
                         cy,
                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
    }

    if (pce->hwndEdit)
    {
        ComboEx_SizeEditBox(pce);
        InvalidateRect(pce->hwndCombo, NULL, TRUE);
    }
}

LRESULT ComboEx_HandleCommand(PCOMBOBOXEX pce, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;
    UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

    if (!pce)
        return 0;

    if (uCmd == CBN_SELCHANGE)
        // update the edit text before forwarding this notification 'cause in
        // a normal combobox, the edit control will have already been updated
        // upon receipt of this notification
        ComboEx_UpdateEditText(pce, FALSE);

    lres = SendMessage(pce->ci.hwndParent, WM_COMMAND, GET_WM_COMMAND_MPS(idCmd, pce->ci.hwnd, uCmd));

    switch (uCmd) {

    case CBN_DROPDOWN:
        pce->iSel = ComboBox_GetCurSel(pce->hwndCombo);
        ComboEx_EndEdit(pce, CBENF_DROPDOWN);
        if (GetFocus() == pce->hwndEdit)
            SetFocus(pce->hwndCombo);
        pce->fInDrop = TRUE;
        break;

    case CBN_KILLFOCUS:
        ComboEx_EndEdit(pce, CBENF_KILLFOCUS);
        break;

    case CBN_CLOSEUP:
        pce->iSel = -1;
        ComboEx_BeginEdit(pce);
        pce->fInDrop = FALSE;
        break;

    case CBN_SETFOCUS:
        ComboEx_BeginEdit(pce);
        break;

    }

    return lres;
}

LRESULT ComboEx_OnGetItemData(PCOMBOBOXEX pce, WPARAM i)
{
    PCEITEM pcei = (PCEITEM)SendMessage(pce->hwndCombo, CB_GETITEMDATA, i, 0);
    if (pcei == NULL || pcei == (PCEITEM)CB_ERR) {
        return CB_ERR;
    }

    return pcei->lParam;
}

LRESULT ComboEx_OnSetItemData(PCOMBOBOXEX pce, int i, LPARAM lParam)
{
    PCEITEM pcei = (PCEITEM)SendMessage(pce->hwndCombo, CB_GETITEMDATA, i, 0);
    if (pcei == NULL || pcei == (PCEITEM)CB_ERR) {
        return CB_ERR;
    }
    pcei->lParam = lParam;
    return 0;
}

int ComboEx_OnFindStringExact(PCOMBOBOXEX pce, int iStart, LPCTSTR lpsz)
{
    int i;
    int iMax = ComboEx_Count(pce);
    TCHAR szText[CBEMAXSTRLEN];
    COMBOBOXEXITEM cei;

    if (iStart < 0)
        iStart = -1;

    cei.mask = CBEIF_TEXT;
    cei.pszText = szText;
    cei.cchTextMax = ARRAYSIZE(szText);

    for (i = iStart + 1 ; i < iMax; i++) {
        cei.iItem = i;
        if (ComboEx_OnGetItem(pce, &cei)) {
            if (!ComboEx_StrCmp(pce, lpsz, szText)) {
                return i;
            }
        }
    }

    for (i = 0; i <= iStart; i++) {
        cei.iItem = i;
        if (ComboEx_OnGetItem(pce, &cei)) {
            if (!ComboEx_StrCmp(pce, lpsz, szText)) {
                return i;
            }
        }
    }

    return CB_ERR;
}

int ComboEx_StrCmp(PCOMBOBOXEX pce, LPCTSTR psz1, LPCTSTR psz2)
{
    if (pce->dwExStyle & CBES_EX_CASESENSITIVE) {
        return lstrcmp(psz1, psz2);
    }
    return lstrcmpi(psz1, psz2);
}

DWORD ComboEx_OnSetExStyle(PCOMBOBOXEX pce, DWORD dwExStyle, DWORD dwExMask)
{
    DWORD dwRet;
    DWORD dwChange;

    if (dwExMask)
        dwExStyle = (pce->dwExStyle & ~ dwExMask) | (dwExStyle & dwExMask);

    dwRet = pce->dwExStyle;
    dwChange = (pce->dwExStyle ^ dwExStyle);

    pce->dwExStyle = dwExStyle;
    if (dwChange & (CBES_EX_NOEDITIMAGE | CBES_EX_NOEDITIMAGEINDENT)) {
        InvalidateRect(pce->ci.hwnd, NULL, TRUE);
        if (pce->hwndEdit)
        {
            ComboEx_SizeEditBox(pce);
            InvalidateRect(pce->hwndEdit, NULL, TRUE);
        }
    }

    if (dwChange & CBES_EX_PATHWORDBREAKPROC)
        SetPathWordBreakProc(pce->hwndEdit, (pce->dwExStyle & CBES_EX_PATHWORDBREAKPROC));

    return dwRet;
}

HFONT ComboEx_GetFont(PCOMBOBOXEX pce)
{
    if (pce->hwndCombo)
        return (HFONT)SendMessage(pce->hwndCombo, WM_GETFONT, 0, 0);

    return NULL;
}

LRESULT CALLBACK ComboExWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;
    PCOMBOBOXEX pce = (PCOMBOBOXEX)GetWindowPtr(hwnd, 0);

    if (!pce) {
        if (uMsg != WM_NCCREATE &&
            uMsg != WM_CREATE)
            goto DoDefault;
    }

    switch (uMsg) {
        HANDLE_MSG(pce, WM_SETFONT, ComboEx_OnSetFont);

    case WM_ENABLE:
        if (pce->hwndCombo)
            EnableWindow(pce->hwndCombo, (BOOL) wParam);
        if (pce->hwndEdit)
            EnableWindow(pce->hwndEdit, (BOOL) wParam);
        break;

    case WM_WININICHANGE:
        InitGlobalMetrics(wParam);
        // only need to re-create this font if we created it in the first place
        // and somebody changed the font (or did a wildcard change)
        //
        // NOTE: Some people broadcast a nonclient metrics change when they
        //       change the icon title logfont, so watch for both.
        //
        if (pce && pce->fFontCreated &&
            ((wParam == 0 && lParam == 0) ||
             wParam == SPI_SETICONTITLELOGFONT ||
             wParam == SPI_SETNONCLIENTMETRICS))
        {
            ComboEx_OnSetFont(pce, NULL, TRUE);
        }
        break;

    case WM_SYSCOLORCHANGE:
        InitGlobalColors();
        break;

    case WM_NOTIFYFORMAT:
        return CIHandleNotifyFormat(&pce->ci, lParam);
        break;

    case WM_NCCREATE:
        // strip off the scroll bits
        SetWindowBits(hwnd, GWL_STYLE, WS_BORDER | WS_VSCROLL | WS_HSCROLL, 0);
        goto DoDefault;

    case WM_CREATE:
        CCCreateWindow();
        if (!ComboEx_OnCreate(hwnd, (LPCREATESTRUCT)lParam))
            lres = -1; // OnCreate falied. Fail WM_CREATE
        break;


    case WM_DESTROY:
        ASSERT(pce);
        CCDestroyWindow();
        ComboEx_OnDestroy(pce);
        break;

    case WM_WINDOWPOSCHANGING:
        ComboEx_OnWindowPosChanging(pce, (LPWINDOWPOS)lParam);
        break;

    case WM_DRAWITEM:
        ComboEx_OnDrawItem(pce, (LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_MEASUREITEM:
        ComboEx_OnMeasureItem(pce, (LPMEASUREITEMSTRUCT)lParam);
        break;

    case WM_COMMAND:
        return ComboEx_HandleCommand(pce, wParam, lParam);

    case WM_GETFONT:
        return (LRESULT)ComboEx_GetFont(pce);

    case WM_SETFOCUS:
        if (pce->hwndCombo)
            SetFocus(pce->hwndCombo);
        break;

    case WM_DELETEITEM:
        ComboEx_HandleDeleteItem(pce, (LPDELETEITEMSTRUCT)lParam);
        return TRUE;

    case WM_UPDATEUISTATE:
        //not sure need to set bit, will probably not use it, on the other hand this
        //  is consistent with remaining of common controls and not very expensive
        CCOnUIState(&(pce->ci), WM_UPDATEUISTATE, wParam, lParam);

        goto DoDefault;
    // this is for backcompat only.
    case CBEM_SETEXSTYLE:
        return ComboEx_OnSetExStyle(pce, (DWORD)wParam, 0);
        
    case CBEM_SETEXTENDEDSTYLE:
        return ComboEx_OnSetExStyle(pce, (DWORD)lParam, (DWORD)wParam);

    case CBEM_GETEXTENDEDSTYLE:
        return pce->dwExStyle;

    case CBEM_GETCOMBOCONTROL:
        return (LRESULT)pce->hwndCombo;

    case CBEM_SETIMAGELIST:
        return (LRESULT)ComboEx_OnSetImageList(pce, (HIMAGELIST)lParam);

    case CBEM_GETIMAGELIST:
        return (LRESULT)pce->himl;

    case CBEM_GETITEMA:
        return ComboEx_OnGetItemA(pce, (PCOMBOBOXEXITEMA)lParam);

    case CBEM_GETITEM:
        return ComboEx_OnGetItem(pce, (PCOMBOBOXEXITEM)lParam);

    case CBEM_SETITEMA: {
            LRESULT lResult;
            LPWSTR lpStrings;
            UINT   uiCount;
            LPSTR  lpAnsiString = (LPSTR) ((PCOMBOBOXEXITEM)lParam)->pszText;

           if ((((PCOMBOBOXEXITEM)lParam)->mask & CBEIF_TEXT) &&
               (((PCOMBOBOXEXITEM)lParam)->pszText != LPSTR_TEXTCALLBACK)) {

                uiCount = lstrlenA(lpAnsiString)+1;
                lpStrings = LocalAlloc(LPTR, (uiCount) * sizeof(TCHAR));

                if (!lpStrings)
                    return -1;

                MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lpAnsiString, uiCount,
                                   lpStrings, uiCount);

                ((PCOMBOBOXEXITEMA)lParam)->pszText = (LPSTR)lpStrings;
                lResult = ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);
                ((PCOMBOBOXEXITEMA)lParam)->pszText = lpAnsiString;
                LocalFree(lpStrings);

                return lResult;
            } else {
                return ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);
            }
        }
    case CBEM_SETITEM:
        return ComboEx_OnSetItem(pce, (PCOMBOBOXEXITEM)lParam);

    case CBEM_INSERTITEMA: {
            LRESULT lResult;
            LPWSTR lpStrings;
            UINT   uiCount;
            LPSTR  lpAnsiString = (LPSTR) ((PCOMBOBOXEXITEM)lParam)->pszText;

            if (!lpAnsiString || lpAnsiString == (LPSTR)LPSTR_TEXTCALLBACK)
                return ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);

            uiCount = lstrlenA(lpAnsiString)+1;
            lpStrings = LocalAlloc(LPTR, (uiCount) * sizeof(TCHAR));

            if (!lpStrings)
                return -1;

            MultiByteToWideChar(CP_ACP, 0, (LPCSTR) lpAnsiString, uiCount,
                               lpStrings, uiCount);

            ((PCOMBOBOXEXITEMA)lParam)->pszText = (LPSTR)lpStrings;
            lResult = ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);
            ((PCOMBOBOXEXITEMA)lParam)->pszText = lpAnsiString;
            LocalFree(lpStrings);

            return lResult;
        }

    case CBEM_INSERTITEM:
        return ComboEx_OnInsertItem(pce, (PCOMBOBOXEXITEM)lParam);



    case CBEM_GETEDITCONTROL:
        return (LRESULT)pce->hwndEdit;

    case CBEM_HASEDITCHANGED:
        return pce->fEditChanged;

    case CB_GETITEMDATA:
        return ComboEx_OnGetItemData(pce, (int)wParam);

    case CB_SETITEMDATA:
        return ComboEx_OnSetItemData(pce, (int)wParam, lParam);

    case CB_LIMITTEXT:
        if (ComboEx_GetEditBox(pce))
            Edit_LimitText(pce->hwndEdit, wParam);
        break;

    case CB_FINDSTRINGEXACT:
    {
        LPCTSTR psz = (LPCTSTR)lParam;
        return ComboEx_OnFindStringExact(pce, (int)wParam, psz);
    }

    case CB_SETITEMHEIGHT:
        lres = SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
        if (wParam == (WPARAM)-1) {
            RECT rcWindow, rcClient;
            int cy;

            GetWindowRect(pce->hwndCombo, &rcWindow);
            cy = RECTHEIGHT(rcWindow);

            GetWindowRect(pce->ci.hwnd, &rcWindow);
            GetClientRect(pce->ci.hwnd, &rcClient);

            cy = cy + (RECTHEIGHT(rcWindow) - RECTHEIGHT(rcClient));

            SetWindowPos(pce->ci.hwnd, NULL, 0, 0,
                         RECTWIDTH(rcWindow),
                         cy,
                         SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOZORDER);
        }
        break;

    case CB_INSERTSTRING:
    case CB_ADDSTRING:
    case CB_SETEDITSEL:
    case CB_FINDSTRING:
    case CB_DIR:
        // override to do nothing
        break;

    case CB_SETCURSEL:
    case CB_RESETCONTENT:
    case CB_DELETESTRING:
        lres = SendMessage(pce->hwndCombo, uMsg, wParam, lParam);
        ComboEx_UpdateEditText(pce, uMsg == CB_SETCURSEL);
        break;

    case WM_SETTEXT:
        if (!pce->hwndEdit)
            return(CB_ERR);
        
        lres = SendMessage(pce->hwndEdit, uMsg, wParam, lParam);
        EDIT_SELECTALL( pce->hwndEdit );
        RedrawWindow(pce->hwndCombo, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
        return(lres);

    case WM_CUT:
    case WM_COPY:
    case WM_PASTE:
    case WM_GETTEXT:
    case WM_GETTEXTLENGTH:
        if (!pce->hwndEdit)
            return 0;
        return(SendMessage(pce->hwndEdit, uMsg, wParam, lParam));

    case WM_SETREDRAW:
        if (pce->hwndEdit)
            SendMessage(pce->hwndEdit, uMsg, wParam, lParam);
        break;

    case CB_GETEDITSEL:
        if (pce->hwndEdit)
            return SendMessage(pce->hwndEdit, EM_GETSEL, wParam, lParam);
        // else fall through

    // Handle it being in a dialog...
    // BUGBUG:: May want to handle it differently when edit control has
    // focus...
    case WM_GETDLGCODE:
    case CB_SHOWDROPDOWN:
    case CB_SETEXTENDEDUI:
    case CB_GETEXTENDEDUI:
    case CB_GETDROPPEDSTATE:
    case CB_GETDROPPEDCONTROLRECT:
    case CB_GETCURSEL:
    case CB_GETCOUNT:
    case CB_SELECTSTRING:
    case CB_GETITEMHEIGHT:
    case CB_SETDROPPEDWIDTH:
        return SendMessage(pce->hwndCombo, uMsg, wParam, lParam);

    case CB_GETLBTEXT:
    case CB_GETLBTEXTLEN:
        return ComboEx_GetLBText(pce, uMsg, wParam, lParam);

    default:
        if (CCWndProc(&pce->ci, uMsg, wParam, lParam, &lres))
            return lres;

DoDefault:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return lres;
}


BOOL InitComboExClass(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = ComboExWndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = c_szComboBoxEx;
    wc.hbrBackground   = (HBRUSH)(COLOR_WINDOW + 1); // NULL;
    wc.style           = CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(PCOMBOBOXEX);
    wc.cbClsExtra      = 0;

    RegisterClass(&wc);
    return TRUE;

}

//---------------------------------------------------------------------------
// SetPathWordBreakProc does special break processing for edit controls.
//
// The word break proc is called when ctrl-(left or right) arrow is pressed in the
// edit control.  Normal processing provided by USER breaks words at spaces or tabs,
// but for us it would be nice to break words at slashes, backslashes, & periods too
// since it may be common to have paths or url's typed in.
void WINAPI SetPathWordBreakProc(HWND hwndEdit, BOOL fSet)
{
    FARPROC lpfnOld;
    // Don't shaft folks who set their own break proc - leave it alone.
    lpfnOld = (FARPROC)SendMessage(hwndEdit, EM_GETWORDBREAKPROC, 0, 0L);

    if (fSet) {
        if (!lpfnOld)
            SendMessage(hwndEdit, EM_SETWORDBREAKPROC, 0, (LPARAM)ShellEditWordBreakProc);
    } else {
        if (lpfnOld == (FARPROC)ShellEditWordBreakProc)
            SendMessage(hwndEdit, EM_SETWORDBREAKPROC, 0, 0L);
    }
}

BOOL IsDelimiter(TCHAR ch)
{
    return (ch == TEXT(' ')  ||
            ch == TEXT('\t') ||
            ch == TEXT('.')  ||
            ch == TEXT('/')  ||
            ch == TEXT('\\'));
}

int WINAPI ShellEditWordBreakProc(LPTSTR lpch, int ichCurrent, int cch, int code)
{
    LPTSTR lpchT = lpch + ichCurrent;
    int iIndex;
    BOOL fFoundNonDelimiter = FALSE;
    static BOOL fRight = FALSE;  // hack due to bug in USER

    switch (code) {
        case WB_ISDELIMITER:
            fRight = TRUE;
            // Simple case - is the current character a delimiter?
            iIndex = (int)IsDelimiter(*lpchT);
            break;

        case WB_LEFT:
            // Move to the left to find the first delimiter.  If we are
            // currently at a delimiter, then skip delimiters until we
            // find the first non-delimiter, then start from there.
            //
            // Special case for fRight - if we are currently at a delimiter
            // then just return the current word!
            while ((lpchT = CharPrev(lpch, lpchT)) != lpch) {
                if (IsDelimiter(*lpchT)) {
                    if (fRight || fFoundNonDelimiter)
                        break;
                } else {
                    fFoundNonDelimiter = TRUE;
                    fRight = FALSE;
                }
            }
            iIndex = (int) (lpchT - lpch);

            // We are currently pointing at the delimiter, next character
            // is the beginning of the next word.
            if (iIndex > 0 && iIndex < cch)
                iIndex++;

            break;

        case WB_RIGHT:
            fRight = FALSE;

            // If we are not at a delimiter, then skip to the right until
            // we find the first delimiter.  If we started at a delimiter, or
            // we have just finished scanning to the first delimiter, then
            // skip all delimiters until we find the first non delimiter.
            //
            // Careful - the string passed in to us may not be NULL terminated!
            fFoundNonDelimiter = !IsDelimiter(*lpchT);
            if (lpchT != (lpch + cch)) {
                while ((lpchT = FastCharNext(lpchT)) != (lpch + cch)) {
                    if (IsDelimiter(*lpchT)) {
                        fFoundNonDelimiter = FALSE;
                    } else {
                        if (!fFoundNonDelimiter)
                            break;
                    }
                }
            }
            // We are currently pointing at the next word.
            iIndex = (int) (lpchT - lpch);
            break;
    }

    return iIndex;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\comctl32.inc ===
#
#  Common settings for comctl32
#

# Now the NT version have FE_IME etc. defined
C_DEFINES       = $(C_DEFINES) -DFE_IME -DDBCS

C_DEFINES       = $(C_DEFINES) -DFONT_LINK

# Turn structure validation ON in debug builds
#
!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DVSTF
!endif

USE_LIBCMT      = 1

!include $(CCSHELL_DIR)\common.inc

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc

# we want to run on downlevel platforms
WIN32_IE_VERSION=0x501
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\cstrings.h ===
extern TCHAR const FAR c_szNULL[];
extern TCHAR const FAR c_szSpace[];
extern TCHAR const FAR c_szTabControlClass[];
extern TCHAR const FAR c_szListViewClass[];
extern TCHAR const FAR c_szHeaderClass[];
extern TCHAR const FAR c_szTreeViewClass[];
extern TCHAR const FAR c_szStatusClass[];
extern TCHAR const FAR c_szSToolTipsClass[];
extern TCHAR const FAR c_szToolbarClass[];
extern TCHAR const FAR c_szReBarClass[];
extern TCHAR const FAR c_szEllipses[];
extern TCHAR const FAR c_szShell[];
extern TCHAR const FAR c_szEdit[];
extern TCHAR const FAR c_szSelect[];

extern const TCHAR FAR s_szUpdownClass[];
extern const TCHAR FAR s_szBUTTONLISTBOX[];
#define s_szEllipses c_szEllipses
#ifdef WANT_SUCKY_HEADER
extern const TCHAR FAR s_szHeaderClass[];
#endif
extern const TCHAR FAR s_szHOTKEY_CLASS[];
extern const TCHAR FAR s_szSTrackBarClass[];
extern const TCHAR FAR s_szPROGRESS_CLASS[];

extern const TCHAR FAR c_szCC32Subclass[];

#define CCHELLIPSES 3
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\commctrl.c ===
/***************************************************************************
 *  msctls.c
 *
 *      Utils library initialization code
 *
 ***************************************************************************/

#include "ctlspriv.h"

HINSTANCE g_hinst = 0;

CRITICAL_SECTION g_csDll = {{0},0, 0, NULL, NULL, 0 };

ATOM g_aCC32Subclass = 0;

BOOL g_bRunOnNT5 = FALSE;
BOOL g_bRemoteSession = FALSE;

UINT g_uiACP = CP_ACP;

// Is Mirroring enabled
BOOL g_bMirroredOS = FALSE;


#define PAGER //For Test Purposes

//
// Global DCs used during mirroring an Icon.
//
HDC g_hdc=NULL, g_hdcMask=NULL;

// per process mem to store PlugUI information
LANGID g_PUILangId = MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL);

BOOL PASCAL InitAnimateClass(HINSTANCE hInstance);
BOOL ListView_Init(HINSTANCE hinst);
BOOL TV_Init(HINSTANCE hinst);
BOOL InitComboExClass(HINSTANCE hinst);
BOOL PASCAL Header_Init(HINSTANCE hinst);
BOOL PASCAL Tab_Init(HINSTANCE hinst);
int InitIPAddr(HANDLE hInstance);

#ifdef PAGER
BOOL InitPager(HINSTANCE hinst);
#endif
BOOL InitNativeFontCtl(HINSTANCE hinst);
void UnregisterClasses();

#define DECLARE_DELAYED_FUNC(_ret, _fn, _args, _nargs) \
_ret (__stdcall * g_pfn##_fn) _args = NULL; \
_ret __stdcall _fn _args                \
{                                       \
     if (!g_pfn##_fn) {                  \
        AssertMsg(g_pfn##_fn != NULL, TEXT("GetProcAddress failed")); \
        return 0; \
     }     \
     return g_pfn##_fn _nargs; \
}
    
#define LOAD_DELAYED_FUNC(_ret, _fn, _args) \
    (*(FARPROC*)&(g_pfn##_fn) = GetProcAddress(hinst, #_fn))


DECLARE_DELAYED_FUNC(BOOL, ImmNotifyIME, (HIMC himc, DWORD dw1, DWORD dw2, DWORD dw3), (himc, dw1, dw2, dw3));
DECLARE_DELAYED_FUNC(HIMC, ImmAssociateContext, (HWND hwnd, HIMC himc), (hwnd, himc));
DECLARE_DELAYED_FUNC(BOOL, ImmReleaseContext, (HWND hwnd, HIMC himc), (hwnd, himc));
DECLARE_DELAYED_FUNC(HIMC, ImmGetContext, (HWND hwnd), (hwnd));
DECLARE_DELAYED_FUNC(LONG, ImmGetCompositionStringA, (HIMC himc, DWORD dw1, LPVOID p1, DWORD dw2), (himc, dw1, p1, dw2) );
DECLARE_DELAYED_FUNC(BOOL, ImmSetCompositionStringA, (HIMC himc, DWORD dw1, LPCVOID p1, DWORD dw2, LPCVOID p2, DWORD dw3), (himc, dw1, p1, dw2, p2, dw3));
DECLARE_DELAYED_FUNC(LONG, ImmGetCompositionStringW, (HIMC himc, DWORD dw1, LPVOID p1, DWORD dw2), (himc, dw1, p1, dw2) );
DECLARE_DELAYED_FUNC(BOOL, ImmSetCompositionStringW, (HIMC himc, DWORD dw1, LPCVOID p1, DWORD dw2, LPCVOID p2, DWORD dw3), (himc, dw1, p1, dw2, p2, dw3));
DECLARE_DELAYED_FUNC(BOOL, ImmSetCandidateWindow, (HIMC himc, LPCANDIDATEFORM pcf), (himc, pcf));
DECLARE_DELAYED_FUNC(HIMC, ImmCreateContext, (void), ());
DECLARE_DELAYED_FUNC(BOOL, ImmDestroyContext, (HIMC himc), (himc));
    

BOOL g_fDBCSEnabled = FALSE;
BOOL g_fMEEnabled = FALSE;
BOOL g_fDBCSInputEnabled = FALSE;
#ifdef FONT_LINK
BOOL g_bComplexPlatform = FALSE;
#endif

#if defined(FE_IME)
void InitIme()
{
    g_fMEEnabled = GetSystemMetrics(SM_MIDEASTENABLED);
    
    g_fDBCSEnabled = g_fDBCSInputEnabled = GetSystemMetrics(SM_DBCSENABLED);

    if (!g_fDBCSInputEnabled && g_bRunOnNT5)
        g_fDBCSInputEnabled =  GetSystemMetrics(SM_IMMENABLED);
    
    // We load imm32.dll per process, but initialize proc pointers just once.
    // this is to solve two different problems.
    // 1) Debugging process on win95 would get our shared table trashed
    //    if we rewrite proc address each time we get loaded.
    // 2) Some lotus application rely upon us to load imm32. They do not
    //    load/link to imm yet they use imm(!)
    //
    if (g_fDBCSInputEnabled) {
        HANDLE hinst = LoadLibrary(TEXT("imm32.dll"));
        if (! g_pfnImmSetCandidateWindow && 
           (! hinst || 
            ! LOAD_DELAYED_FUNC(HIMC, ImmCreateContext, (void)) ||
            ! LOAD_DELAYED_FUNC(HIMC, ImmDestroyContext, (HIMC)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmNotifyIME, (HIMC, DWORD, DWORD, DWORD)) ||
            ! LOAD_DELAYED_FUNC(HIMC, ImmAssociateContext, (HWND, HIMC)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmReleaseContext, (HWND, HIMC)) ||
            ! LOAD_DELAYED_FUNC(HIMC, ImmGetContext, (HWND)) ||
            ! LOAD_DELAYED_FUNC(LONG, ImmGetCompositionStringA, (HIMC, DWORD, LPVOID, DWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCompositionStringA, (HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD)) ||
            ! LOAD_DELAYED_FUNC(LONG, ImmGetCompositionStringW, (HIMC, DWORD, LPVOID, DWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCompositionStringW, (HIMC, DWORD, LPCVOID, DWORD, LPCVOID, DWORD)) ||
            ! LOAD_DELAYED_FUNC(BOOL, ImmSetCandidateWindow, (HIMC, LPCANDIDATEFORM)))) {

            // if we were unable to load then bail on using IME.
            g_fDBCSEnabled = FALSE;
            g_fDBCSInputEnabled = FALSE;

        }
    }
}
#else
#define InitIme() 0
#endif


#ifdef DEBUG

// Verify that the localizers didn't accidentally change
// DLG_PROPSHEET from a DIALOG to a DIALOGEX.  _RealPropertySheet
// relies on this (as well as any apps which parse the dialog template
// in their PSCB_PRECREATE handler).

BOOL IsSimpleDialog(LPCTSTR ptszDialog)
{
    HRSRC hrsrc;
    LPDLGTEMPLATE pdlg;
    BOOL fSimple = FALSE;

    if ( (hrsrc = FindResource(HINST_THISDLL, ptszDialog, RT_DIALOG)) &&
         (pdlg = LoadResource(HINST_THISDLL, hrsrc)))
    {
        fSimple = HIWORD(pdlg->style) != 0xFFFF;
    }
    return fSimple;
}

//
//  For sublanguages to work, every language in our resources must contain
//  a SUBLANG_NEUTRAL variation so that (for example) Austria gets
//  German dialog boxes instead of English ones.
//
//  The DPA is really a DSA of WORDs, but DPA's are easier to deal with.
//  We just collect all the languages into the DPA, and study them afterwards.
//
BOOL CALLBACK CheckLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    HDPA hdpa = (HDPA)lparam;
    DPA_AppendPtr(hdpa, (LPVOID)(UINT_PTR)wIdLang);
    return TRUE;
}

void CheckResourceLanguages(void)
{
    HDPA hdpa = DPA_Create(8);
    if (hdpa) {
        int i, j;
        EnumResourceLanguages(HINST_THISDLL, RT_DIALOG,
                              MAKEINTRESOURCE(DLG_PROPSHEET), CheckLangProc,
                              (LPARAM)hdpa);

        // Walk the language list.  For each language we find, make sure
        // there is a SUBLANG_NEUTRAL version of it somewhere else
        // in the list.  We use an O(n^2) algorithm because this is debug
        // only code and happens only at DLL load.

        for (i = 0; i < DPA_GetPtrCount(hdpa); i++) {
            UINT_PTR uLangI = (UINT_PTR)DPA_FastGetPtr(hdpa, i);
            BOOL fFound = FALSE;

            //
            //  It is okay to have English (American) with no
            //  English (Neutral) because Kernel32 uses English (American)
            //  as its fallback, so we fall back to the correct language
            //  after all.
            //
            if (uLangI == MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US))
                continue;

            //
            //  If this language is already the Neutral one, then there's
            //  no point looking for it - here it is!
            //
            if (SUBLANGID(uLangI) == SUBLANG_NEUTRAL)
                continue;

            //
            //  Otherwise, this language is a dialect.  See if there is
            //  a Neutral version elsewhere in the table.
            //
            for (j = 0; j < DPA_GetPtrCount(hdpa); j++) {
                UINT_PTR uLangJ = (UINT_PTR)DPA_FastGetPtr(hdpa, j);
                if (PRIMARYLANGID(uLangI) == PRIMARYLANGID(uLangJ) &&
                    SUBLANGID(uLangJ) == SUBLANG_NEUTRAL) {
                    fFound = TRUE; break;
                }
            }

            //
            //  If this assertion fires, it means that the localization team
            //  added support for a new language but chose to specify the
            //  language as a dialect instead of the Neutral version.  E.g.,
            //  specifying Romanian (Romanian) instead of Romanian (Neutral).
            //  This means that people who live in Moldavia will see English
            //  strings, even though Romanian (Romanian) would almost
            //  certainly have been acceptable.
            //
            //  If you want to support multiple dialects of a language
            //  (e.g., Chinese), you should nominate one of the dialects
            //  as the Neutral one.  For example, we currently support
            //  both Chinese (PRC) and Chinese (Taiwan), but the Taiwanese
            //  version is marked as Chinese (Neutral), so people who live in
            //  Singapore get Chinese instead of English.  Sure, it's
            //  Taiwanese Chinese, but at least it's Chinese.
            //
            AssertMsg(fFound, TEXT("Localization bug: No SUBLANG_NEUTRAL for language %04x"), uLangI);
        }

        DPA_Destroy(hdpa);
    }
}

#endif


BOOL IsRunningIn16BitProcess()
{
    NTSTATUS status;
    ULONG    ulVDMFlags = 0;
    status = NtQueryInformationProcess(GetCurrentProcess(), ProcessWx86Information, &ulVDMFlags, sizeof(ulVDMFlags), NULL);
    return (NT_SUCCESS(status) && (ulVDMFlags != 0));
}


int _ProcessAttach(HANDLE hInstance)
{
    g_hinst = hInstance;

    g_uiACP = GetACP();

#ifdef DEBUG
    CcshellGetDebugFlags();

    g_dwBreakFlags = 0;    // We do not want to break in comctl32 version 5 at ALL. Too many bad callers.
#endif


    InitializeCriticalSection(&g_csDll);

    g_bRunOnNT5 = staticIsOS(OS_WIN2000ORGREATER);
#ifdef FONT_LINK
    g_bComplexPlatform =  BOOLFROMPTR(GetModuleHandle(TEXT("LPK.DLL")));
#endif

    //
    // Check if the mirroring APIs exist on the current
    // platform.
    //
    g_bMirroredOS = IS_MIRRORING_ENABLED();

    //
    //  Must detect Terminal Server before initializing global metrics
    //  because we need to force some features off if running Terminal Server.
    //
    {
        typedef BOOL (__stdcall * PFNPROCESSIDTOSESSIONID)(DWORD, PDWORD);
        PFNPROCESSIDTOSESSIONID ProcessIdToSessionId =
                    (PFNPROCESSIDTOSESSIONID)
                    GetProcAddress(GetModuleHandle(TEXT("KERNEL32")),
                                   "ProcessIdToSessionId");
        DWORD dwSessionId;
        g_bRemoteSession = ProcessIdToSessionId &&
                           ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId) &&
                           dwSessionId != 0;
    }

    InitGlobalMetrics(0);
    InitGlobalColors();
    
    InitIme();

#ifdef DEBUG
    ASSERT(IsSimpleDialog(MAKEINTRESOURCE(DLG_WIZARD)));
    ASSERT(IsSimpleDialog(MAKEINTRESOURCE(DLG_PROPSHEET)));
    CheckResourceLanguages();
#endif
    if (IsRunningIn16BitProcess())
    {
        // This is a 16bit process. We need to artificially init the common controls
        INITCOMMONCONTROLSEX icce;
        icce.dwSize = sizeof(icce);
        icce.dwICC = ICC_WIN95_CLASSES;
        InitCommonControlsEx(&icce);
    }

    return TRUE;
}



void _ProcessDetach(HANDLE hInstance)
{
    //
    // Cleanup cached DCs. No need to synchronize the following section of
    // code since it is only called in DLL_PROCESS_DETACH which is 
    // synchronized by the OS Loader.
    //
    if (g_hdc)
        DeleteDC(g_hdc);

    if (g_hdcMask)
        DeleteDC(g_hdcMask);

    g_hdc = g_hdcMask = NULL;

    UnregisterClasses();
    DeleteCriticalSection(&g_csDll);
}


// DllEntryPoint
STDAPI_(BOOL) DllMain(HANDLE hDll, DWORD dwReason, LPVOID pvReserverd)
{
    switch(dwReason) 
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hDll);
        return _ProcessAttach(hDll);

    case DLL_PROCESS_DETACH:
        _ProcessDetach(hDll);
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    default:
        break;

    }

    return TRUE;

}


/* Stub function to call if all you want to do is make sure this DLL is loaded
 */
void WINAPI InitCommonControls(void)
{
}

STDAPI_(void) FixupSubclassRecordsAfterLogoff();

BOOL InitForWinlogon(HINSTANCE hInstance)
{
    //  Some people like to use comctl32 from inside winlogon, and
    //  for C2 security reasons, all global atoms are nuked from the
    //  window station when you log off.
    //
    //  So the rule is that all winlogon clients of comctl32 must
    //  call InitCommonControlsEx(ICC_WINLOGON_REINIT) immediately
    //  before doing any common control things (creating windows
    //  or property sheets/wizards) from winlogon.

    FixupSubclassRecordsAfterLogoff();


    InitGlobalMetrics(0);
    InitGlobalColors();

    return TRUE;
}

/* InitCommonControlsEx creates the classes. Only those classes requested are created!
** The process attach figures out if it's an old app and supplies ICC_WIN95_CLASSES.
*/
typedef BOOL (PASCAL *PFNINIT)(HINSTANCE);
typedef struct {
    PFNINIT pfnInit;
    LPCTSTR pszName;
    DWORD   dwClassSet;
    BOOL    fRegistered;
} INITCOMMONCONTROLSINFO;

#define MAKEICC(pfnInit, pszClass, dwFlags) { pfnInit, pszClass, dwFlags, FALSE }

INITCOMMONCONTROLSINFO icc[] =
{
     // Init function      Class name         Requested class sets which use this class
MAKEICC(InitToolbarClass,  TOOLBARCLASSNAME,  ICC_BAR_CLASSES),
MAKEICC(InitReBarClass,    REBARCLASSNAME,    ICC_COOL_CLASSES),
MAKEICC(InitToolTipsClass, TOOLTIPS_CLASS,    ICC_TREEVIEW_CLASSES|ICC_BAR_CLASSES|ICC_TAB_CLASSES),
MAKEICC(InitStatusClass,   STATUSCLASSNAME,   ICC_BAR_CLASSES),
MAKEICC(ListView_Init,     WC_LISTVIEW,       ICC_LISTVIEW_CLASSES),
MAKEICC(Header_Init,       WC_HEADER,         ICC_LISTVIEW_CLASSES),
MAKEICC(Tab_Init,          WC_TABCONTROL,     ICC_TAB_CLASSES),
MAKEICC(TV_Init,           WC_TREEVIEW,       ICC_TREEVIEW_CLASSES),
MAKEICC(InitTrackBar,      TRACKBAR_CLASS,    ICC_BAR_CLASSES),
MAKEICC(InitUpDownClass,   UPDOWN_CLASS,      ICC_UPDOWN_CLASS),
MAKEICC(InitProgressClass, PROGRESS_CLASS,    ICC_PROGRESS_CLASS),
MAKEICC(InitHotKeyClass,   HOTKEY_CLASS,      ICC_HOTKEY_CLASS),
MAKEICC(InitAnimateClass,  ANIMATE_CLASS,     ICC_ANIMATE_CLASS),
MAKEICC(InitDateClasses,   DATETIMEPICK_CLASS,ICC_DATE_CLASSES),
MAKEICC(InitDateClasses,   MONTHCAL_CLASS,    0),
MAKEICC(InitComboExClass,  WC_COMBOBOXEX,     ICC_USEREX_CLASSES),
MAKEICC(InitIPAddr,        WC_IPADDRESS,      ICC_INTERNET_CLASSES),
MAKEICC(InitPager,         WC_PAGESCROLLER,   ICC_PAGESCROLLER_CLASS),
MAKEICC(InitNativeFontCtl, WC_NATIVEFONTCTL,  ICC_NATIVEFNTCTL_CLASS),

//
//  These aren't really classes.  They're just goofy flags.
//
MAKEICC(InitForWinlogon,   NULL,              ICC_WINLOGON_REINIT),
};



//------------------------------------------------------------------------------
//
// Get the activation context associated with the .dll/.exe this
// function is linked into -- that is, the activation context
// that was active when it was loaded.
//
// This is a tiny wrapper around QueryActCtx.
//
// This context can also be gotten via
// GetCurrentActCtx in DllMain(dll_process_attach).
//
BOOL GetModuleActCtx(OUT HANDLE *phActCtx)
{
    ACTIVATION_CONTEXT_BASIC_INFORMATION actCtxBasicInfo = {0};
    BOOL fRet = QueryActCtxW(QUERY_ACTCTX_FLAG_ACTCTX_IS_HMODULE|QUERY_ACTCTX_FLAG_NO_ADDREF,
                             HINST_THISDLL,
                             NULL,
                             ActivationContextBasicInformation,
                             &actCtxBasicInfo,
                             sizeof(actCtxBasicInfo),
                             NULL);

    if (fRet && phActCtx)
    {
        *phActCtx = actCtxBasicInfo.hActCtx;
    }

    return fRet;
}


//------------------------------------------------------------------------------
BOOL ActivateModuleActCtx(OUT ULONG_PTR *pulCookie)
{
    BOOL   fRet    = FALSE;
    HANDLE hActCtx = NULL;

    ASSERT(pulCookie != NULL);
    *pulCookie = 0;

    if (GetModuleActCtx(&hActCtx))
    {
        fRet = ActivateActCtx(hActCtx, pulCookie);
    }

    return fRet;
}

BOOL WINAPI InitCommonControlsEx(LPINITCOMMONCONTROLSEX picce)
{
    int       i;
    BOOL      fRet = TRUE;
    ULONG_PTR ulCookie = 0;

    if (!picce ||
        (picce->dwSize != sizeof(INITCOMMONCONTROLSEX)) ||
        (picce->dwICC & ~ICC_ALL_VALID))
    {
        DebugMsg(DM_WARNING, TEXT("comctl32 - picce is bad"));
        return FALSE;
    }

    if (!ActivateModuleActCtx(&ulCookie))
    {
        return FALSE;
    }

    __try
    {
        for (i = 0; i < ARRAYSIZE(icc); i++)
        {
            if (picce->dwICC & icc[i].dwClassSet)
            {
                if (!icc[i].pfnInit(HINST_THISDLL))
                {
                    fRet = FALSE;
                    break;
                }
                else
                {
                    icc[i].fRegistered = TRUE;
                }
            }
        }
    }
    __finally
    {
        DeactivateActCtx(0, ulCookie);
    }

    return fRet;
}

//
// InitMUILanguage / GetMUILanguage implementation
//
// we have a per process PUI language setting. For NT it's just a global
// initialized with LANG_NEUTRAL and SUBLANG_NEUTRAL
// For Win95 it's DPA slot for the current process.
// InitMUILanguage sets callers preferred language id for common control
// GetMUILangauge returns what the caller has set to us 
// 
void WINAPI
InitMUILanguage(LANGID wLang)
{
    ENTERCRITICAL;
    g_PUILangId = wLang;
    LEAVECRITICAL;
}
LANGID WINAPI
GetMUILanguage(void)
{
    return g_PUILangId;
}
// end MUI functions

//
//  Unlike Win9x, WinNT does not automatically unregister classes
//  when a DLL unloads.  We have to do it manually.  Leaving the
//  class lying around means that if an app loads our DLL, then
//  unloads it, then reloads it at a different address, all our
//  leftover RegisterClass()es will point the WndProc at the wrong
//  place and we fault at the next CreateWindow().
//
//  This is not purely theoretical - NT4/FE hit this bug.
//
void UnregisterClasses()
{
    int i;

    for (i=0 ; i < ARRAYSIZE(icc) ; i++)
    {
        if (icc[i].pszName && icc[i].fRegistered)
        {
            UnregisterClass(icc[i].pszName, HINST_THISDLL);
        }
    }
}

#if defined(DEBUG)
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    ASSERTNONCRITICAL;
    return SendMessageW(hWnd, Msg, wParam, lParam);
}
#endif // defined(DEBUG)

#define COMPILE_MULTIMON_STUBS
#include "multimon.h"


BOOL WINAPI RegisterClassNameW(LPCWSTR pszClass)
{
    int  i;
    BOOL fRet = FALSE;

    for (i = 0; i < ARRAYSIZE(icc) ; i++)
    {
        if (lstrcmpi(icc[i].pszName, pszClass) == 0)
        {
            if (icc[i].pfnInit(HINST_THISDLL))
            {
                icc[i].fRegistered = TRUE;
                fRet = TRUE;
            }

            break;
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\cstrings.c ===
#include "ctlspriv.h"

const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szTabControlClass[] = WC_TABCONTROL;
const TCHAR c_szListViewClass[] = WC_LISTVIEW;
const TCHAR c_szHeaderClass[] = WC_HEADER;
const TCHAR c_szTreeViewClass[] = WC_TREEVIEW;
const TCHAR c_szStatusClass[] = STATUSCLASSNAME;
const TCHAR c_szSToolTipsClass[] = TOOLTIPS_CLASS;
const TCHAR c_szToolbarClass[] = TOOLBARCLASSNAME;
const TCHAR c_szReBarClass[] = REBARCLASSNAME;
const TCHAR c_szEllipses[] = TEXT("...");
const TCHAR c_szShell[] = TEXT("Shell");
const TCHAR c_szEdit[] = TEXT("EDIT");
const TCHAR c_szSelect[] = TEXT("CCSelect");
const TCHAR s_szUpdownClass[] = UPDOWN_CLASS;
const TCHAR s_szHOTKEY_CLASS[] = HOTKEY_CLASS;
const TCHAR s_szSTrackBarClass[] = TRACKBAR_CLASS;
const TCHAR s_szPROGRESS_CLASS[] = PROGRESS_CLASS;
const TCHAR c_szCC32Subclass[] = TEXT("CC32SubclassInfo");
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\ctlspriv.h ===
#undef STRICT
#define STRICT

/* disable "non-standard extension" warnings in our code
 */
#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif

#define _COMCTL32_
#define _INC_OLE
#define _SHLWAPI_
#define CONST_VTABLE


#ifndef WINVER
// This stuff must run on Win95
// The NT build process already have these set as 0x0400
#define WINVER              0x0400
#endif

#define CC_INTERNAL

// so winbase.h declares QueryActCtx, ActivateActCtx, etc.
#define _WIN32_FUSION 0x0100

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <ole2.h>               // to get IStream for image.c
#include <commctrl.h>
#define NO_SHLWAPI_UNITHUNK     // We have our own private thunks
#include <shlwapi.h>

#include <port32.h>


#define DISALLOW_Assert
#include <debug.h>
#include <winerror.h>
#include <ccstock.h>
#if defined(FE_IME)
#include <imm.h>
#endif
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus


#include "multimon.h"   // support for multiple monitor APIs on non-mm OSes
#include "thunk.h"      // Ansi / Wide string conversions
#include "apithk.h"
#include "mem.h"
#include "rcids.h"
#include "cstrings.h"
#include <crtfree.h>

#include "shpriv.h"

#include <strsafe.h>

#ifndef DS_BIDI_RTL
#define DS_BIDI_RTL  0x8000
#endif

#ifdef FONT_LINK
//
//  CodePages
//
#define CP_OEM_437       437
#define CP_IBM852        852
#define CP_IBM866        866
#define CP_THAI          874
#define CP_JAPAN         932
#define CP_CHINA         936
#define CP_KOREA         949
#define CP_TAIWAN        950
#define CP_EASTEUROPE    1250
#define CP_RUSSIAN       1251
#define CP_WESTEUROPE    1252
#define CP_GREEK         1253
#define CP_TURKISH       1254
#define CP_HEBREW        1255
#define CP_ARABIC        1256
#define CP_BALTIC        1257
#define CP_VIETNAMESE    1258
#define CP_RUSSIANKOI8R  20866
#define CP_RUSSIANKOI8RU 21866
#define CP_ISOEASTEUROPE 28592
#define CP_ISOTURKISH    28593
#define CP_ISOBALTIC     28594
#define CP_ISORUSSIAN    28595
#define CP_ISOARABIC     28596
#define CP_ISOGREEK      28597
#define CP_JAPANNHK      50220
#define CP_JAPANESC      50221
#define CP_JAPANSIO      50222
#define CP_KOREAISO      50225
#define CP_JAPANEUC      51932
#define CP_CHINAHZ       52936
#define CP_MAC_ROMAN     10000
#define CP_MAC_JAPAN     10001
#define CP_MAC_GREEK     10006
#define CP_MAC_CYRILLIC  10007
#define CP_MAC_LATIN2    10029
#define CP_MAC_TURKISH   10081
#define CP_DEFAULT       CP_ACP
#define CP_GETDEFAULT    GetACP()
#define CP_JOHAB         1361
#define CP_SYMBOL        42
#define CP_UTF8          65001
#define CP_UTF7          65000
#define CP_UNICODELITTLE 1200
#define CP_UNICODEBIG    1201

#define OEM437_CHARSET   254
#endif   //FONT_LINK

//
// inside comctl32 we always call _TrackMouseEvent...
//
#ifndef TrackMouseEvent
#define TrackMouseEvent _TrackMouseEvent
#endif

#define DCHF_LARGE          0x00000001  // default is small
#define DCHF_TOPALIGN       0x00000002  // default is center-align
#define DCHF_HORIZONTAL     0x00000004  // default is vertical
#define DCHF_HOT            0x00000008  // default is flat
#define DCHF_PUSHED         0x00000010  // default is flat
#define DCHF_FLIPPED        0x00000020  // if horiz, default is pointing right
                                        // if vert, default is pointing up
#define DCHF_TRANSPARENT    0x00000040
#define DCHF_INACTIVE       0x00000080
#define DCHF_NOBORDER       0x00000100

extern void DrawCharButton(HDC hdc, LPRECT lprc, UINT wControlState, TCHAR ch);
extern void DrawScrollArrow(HDC hdc, LPRECT lprc, UINT wControlState);
extern void DrawChevron(HDC hdc, LPRECT lprc, DWORD dwState);

//
// BOGUS -- This are all in \win\core\access\inc32\winable.h, but it's too
// tricky to mess with the build process.  The IE guys are not enlisted in
// core, just shell, so they won't be able to build COMCTL32 if we include
// that file.
//
extern void MyNotifyWinEvent(UINT, HWND, LONG, LONG_PTR);

#define     OBJID_WINDOW                ((LONG)0x00000000)
#define     OBJID_SYSMENU               ((LONG)0xFFFFFFFF)
#define     OBJID_TITLEBAR              ((LONG)0xFFFFFFFE)
#define     OBJID_MENU                  ((LONG)0xFFFFFFFD)
#define     OBJID_CLIENT                ((LONG)0xFFFFFFFC)
#define     OBJID_VSCROLL               ((LONG)0xFFFFFFFB)
#define     OBJID_HSCROLL               ((LONG)0xFFFFFFFA)
#define     OBJID_SIZEGRIP              ((LONG)0xFFFFFFF9)
#define     OBJID_CARET                 ((LONG)0xFFFFFFF8)
#define     OBJID_CURSOR                ((LONG)0xFFFFFFF7)
#define     OBJID_ALERT                 ((LONG)0xFFFFFFF6)
#define     OBJID_SOUND                 ((LONG)0xFFFFFFF5)
#define     OBJID_QUERYCLASSNAMEIDX     ((LONG)0xFFFFFFF4)


#define EVENT_OBJECT_CREATE             0x8000
#define EVENT_OBJECT_DESTROY            0x8001
#define EVENT_OBJECT_SHOW               0x8002
#define EVENT_OBJECT_HIDE               0x8003
#define EVENT_OBJECT_REORDER            0x8004
#define EVENT_OBJECT_FOCUS              0x8005
#define EVENT_OBJECT_SELECTION          0x8006
#define EVENT_OBJECT_SELECTIONADD       0x8007
#define EVENT_OBJECT_SELECTIONREMOVE    0x8008
#define EVENT_OBJECT_SELECTIONWITHIN    0x8009
#define EVENT_OBJECT_STATECHANGE        0x800A
#define EVENT_OBJECT_LOCATIONCHANGE     0x800B
#define EVENT_OBJECT_NAMECHANGE         0x800C
#define EVENT_OBJECT_DESCRIPTIONCHANGE  0x800D
#define EVENT_OBJECT_VALUECHANGE        0x800E

#define EVENT_SYSTEM_SOUND              0x0001
#define EVENT_SYSTEM_ALERT              0x0002
#define EVENT_SYSTEM_SCROLLINGSTART     0x0012
#define EVENT_SYSTEM_SCROLLINGEND       0x0013

// Secret SCROLLBAR index values
#define INDEX_SCROLLBAR_SELF            0
#define INDEX_SCROLLBAR_UP              1
#define INDEX_SCROLLBAR_UPPAGE          2
#define INDEX_SCROLLBAR_THUMB           3
#define INDEX_SCROLLBAR_DOWNPAGE        4
#define INDEX_SCROLLBAR_DOWN            5

#define INDEX_SCROLLBAR_MIC             1
#define INDEX_SCROLLBAR_MAC             5

#define INDEX_SCROLLBAR_LEFT            7
#define INDEX_SCROLLBAR_LEFTPAGE        8
#define INDEX_SCROLLBAR_HORZTHUMB       9
#define INDEX_SCROLLBAR_RIGHTPAGE       10
#define INDEX_SCROLLBAR_RIGHT           11

#define INDEX_SCROLLBAR_HORIZONTAL      6
#define INDEX_SCROLLBAR_GRIP            12

#define CHILDID_SELF                    0
#define INDEXID_OBJECT                  0
#define INDEXID_CONTAINER               0

#ifndef WM_GETOBJECT
#define WM_GETOBJECT                    0x003D
#endif

#define MSAA_CLASSNAMEIDX_BASE 65536L

#define MSAA_CLASSNAMEIDX_STATUS     (MSAA_CLASSNAMEIDX_BASE+11)
#define MSAA_CLASSNAMEIDX_TOOLBAR    (MSAA_CLASSNAMEIDX_BASE+12)
#define MSAA_CLASSNAMEIDX_PROGRESS   (MSAA_CLASSNAMEIDX_BASE+13)
#define MSAA_CLASSNAMEIDX_ANIMATE    (MSAA_CLASSNAMEIDX_BASE+14)
#define MSAA_CLASSNAMEIDX_TAB        (MSAA_CLASSNAMEIDX_BASE+15)
#define MSAA_CLASSNAMEIDX_HOTKEY     (MSAA_CLASSNAMEIDX_BASE+16)
#define MSAA_CLASSNAMEIDX_HEADER     (MSAA_CLASSNAMEIDX_BASE+17)
#define MSAA_CLASSNAMEIDX_TRACKBAR   (MSAA_CLASSNAMEIDX_BASE+18)
#define MSAA_CLASSNAMEIDX_LISTVIEW   (MSAA_CLASSNAMEIDX_BASE+19)
#define MSAA_CLASSNAMEIDX_UPDOWN     (MSAA_CLASSNAMEIDX_BASE+22)
#define MSAA_CLASSNAMEIDX_TOOLTIPS   (MSAA_CLASSNAMEIDX_BASE+24)
#define MSAA_CLASSNAMEIDX_TREEVIEW   (MSAA_CLASSNAMEIDX_BASE+25)
//
// End BOGUS insertion from \win\core\access\inc32\winable.h
//

#ifdef MAXINT
#undef MAXINT
#endif
#define MAXINT  (int)0x7FFFFFFF
// special value for pt.y or cyLabel indicating recomputation needed
// NOTE: icon ordering code considers (RECOMPUTE, RECOMPUTE) at end
// of all icons
//
#define RECOMPUTE  (DWORD)MAXINT
#define SRECOMPUTE ((short)0x7FFF)

#define RECTWIDTH(rc) ((rc).right - (rc).left)
#define RECTHEIGHT(rc) ((rc).bottom - (rc).top)
#define ABS(i)  (((i) < 0) ? -(i) : (i))
#define BOUND(x,low,high)   max(min(x, high),low)

#define LPARAM_TO_POINT(lParam, pt)       ((pt).x = LOWORD(lParam), \
                                           (pt).y = HIWORD(lParam))

// common control info stuff

typedef struct tagControlInfo {
    HWND        hwnd;
    HWND        hwndParent;
    DWORD       style;
    DWORD       dwCustom;
    BITBOOL     bUnicode : 1;
    BITBOOL     bInFakeCustomDraw:1;
    UINT        uiCodePage;
    DWORD       dwExStyle;
    LRESULT     iVersion;
    WORD        wUIState;
} CONTROLINFO, FAR *LPCONTROLINFO;

BOOL CCGetUIState(LPCONTROLINFO pControlInfo);

BOOL CCNotifyNavigationKeyUsage(LPCONTROLINFO pControlInfo, WORD wFlag);

BOOL NEAR PASCAL CCOnUIState(LPCONTROLINFO pCI, UINT uMessage, WPARAM wParam, LPARAM lParam);

BOOL CCWndProc(CONTROLINFO* pci, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres);
void FAR PASCAL CIInitialize(LPCONTROLINFO lpci, HWND hwnd, LPCREATESTRUCT lpcs);
LRESULT FAR PASCAL CIHandleNotifyFormat(LPCONTROLINFO lpci, LPARAM lParam);
DWORD NEAR PASCAL CICustomDrawNotify(LPCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd);
DWORD CIFakeCustomDrawNotify(LPCONTROLINFO lpci, DWORD dwStage, LPNMCUSTOMDRAW lpnmcd);
UINT RTLSwapLeftRightArrows(CONTROLINFO *pci, WPARAM wParam);
UINT CCSwapKeys(WPARAM wParam, UINT vk1, UINT vk2);
LPTSTR CCReturnDispInfoText(LPTSTR pszSrc, LPTSTR pszDest, UINT cchDest);

void FillRectClr(HDC hdc, LPRECT prc, COLORREF clr);

void CCCreateWindow();
void CCDestroyWindow();


//
// helpers for drag-drop enabled controls
//
typedef LRESULT (*PFNDRAGCB)(HWND hwnd, UINT code, WPARAM wp, LPARAM lp);
#define DPX_DRAGHIT   (0)  // WP = (unused)  LP = POINTL*         ret = item id
#define DPX_GETOBJECT (1)  // LP = nmobjectnotify   ret = HRESULT
#define DPX_SELECT    (2)  // WP = item id   LP = DROPEFFECT_     ret = (unused)
#define DPX_ENTER     (3)  // WP = (unused)  LP = (unused)        ret = BOOL
#define DPX_LEAVE     (4)  // WP = (unused)  LP = (unused)        ret = (unused)


// ddproxy.cpp

DECLARE_HANDLE(HDRAGPROXY);

STDAPI_(HDRAGPROXY) CreateDragProxy(HWND hwnd, PFNDRAGCB pfn, BOOL bRegister);
STDAPI_(void) DestroyDragProxy(HDRAGPROXY hdp);
STDAPI GetDragProxyTarget(HDRAGPROXY hdp, IDropTarget **ppdtgt);
STDAPI GetItemObject(CONTROLINFO *, UINT, const IID *, LPNMOBJECTNOTIFY);


#define SWAP(x,y, _type)  { _type i; i = x; x = y; y = i; }

//
// This is for widened dispatch loop stuff
//
typedef MSG MSG32;
typedef MSG32 FAR *     LPMSG32;

#define GetMessage32(lpmsg, hwnd, min, max, f32)        GetMessage(lpmsg, hwnd, min, max)
#define PeekMessage32(lpmsg, hwnd, min, max, flags, f32)       PeekMessage(lpmsg, hwnd, min, max, flags)
#define TranslateMessage32(lpmsg, f32)  TranslateMessage(lpmsg)
#define DispatchMessage32(lpmsg, f32)   DispatchMessage(lpmsg)
#define CallMsgFilter32(lpmsg, u, f32)  CallMsgFilter(lpmsg, u)
#define IsDialogMessage32(hwnd, lpmsg, f32)   IsDialogMessage(hwnd, lpmsg)


//
// This is a very important piece of performance hack for non-DBCS codepage.
//
// was !defined(DBCS) || defined(UNICODE)
// NB - These are already macros in Win32 land.
#undef AnsiNext
#undef AnsiPrev

#define AnsiNext(x) ((x)+1)
#define AnsiPrev(y,x) ((x)-1)
#define IsDBCSLeadByte(x) ((x), FALSE)

// FastCharNext and FastCharPrev are like CharNext and CharPrev except that
// they don't check if you are at the beginning/end of the string.

#define FastCharNext(pch) ((pch)+1)
#define FastCharPrev(pchStart, pch) ((pch)-1)

#define CH_PREFIX TEXT('&')


#define lstrfns_StrEndN         lstrfns_StrEndNW
#define ChrCmpI                 ChrCmpIW

BOOL ChrCmpIA(WORD w1, WORD wMatch);
BOOL ChrCmpIW(WCHAR w1, WCHAR wMatch);
void  TruncateString(char *sz, int cch); // from strings.c

void FAR PASCAL InitGlobalMetrics(WPARAM);
void FAR PASCAL InitGlobalColors();

BOOL FAR PASCAL InitToolbarClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitReBarClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitToolTipsClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitStatusClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitHeaderClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitButtonListBoxClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitTrackBar(HINSTANCE hInstance);
BOOL FAR PASCAL InitUpDownClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitProgressClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitHotKeyClass(HINSTANCE hInstance);
BOOL FAR PASCAL InitToolTips(HINSTANCE hInstance);
BOOL FAR PASCAL InitDateClasses(HINSTANCE hinst);

BOOL NEAR PASCAL ChildOfActiveWindow(HWND hwnd);

/* cutils.c */
HFONT CCGetHotFont(HFONT hFont, HFONT *phFontHot);
HFONT CCCreateStatusFont(void);
BOOL CCForwardEraseBackground(HWND hwnd, HDC hdc);
void CCPlaySound(LPCTSTR lpszName);
BOOL FAR PASCAL CheckForDragBegin(HWND hwnd, int x, int y);
void FAR PASCAL NewSize(HWND hWnd, int nHeight, LONG style, int left, int top, int width, int height);
BOOL FAR PASCAL MGetTextExtent(HDC hdc, LPCTSTR lpstr, int cnt, int FAR * pcx, int FAR * pcy);
void FAR PASCAL RelayToToolTips(HWND hwndToolTips, HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);
void FAR PASCAL StripAccelerators(LPTSTR lpszFrom, LPTSTR lpszTo, BOOL fAmpOnly);
UINT GetCodePageForFont (HFONT hFont);
void* CCLocalReAlloc(void* p, UINT uBytes);
LONG GetMessagePosClient(HWND hwnd, LPPOINT ppt);
void FAR PASCAL FlipRect(LPRECT prc);
DWORD SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue);
BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc);
void CCInvalidateFrame(HWND hwnd);
void FlipPoint(LPPOINT lppt);
void CCSetInfoTipWidth(HWND hwndOwner, HWND hwndToolTips);
#define CCResetInfoTipWidth(hwndOwner, hwndToolTips) \
    SendMessage(hwndToolTips, TTM_SETMAXTIPWIDTH, 0, -1)

// Incremental search
typedef struct ISEARCHINFO {
    int iIncrSearchFailed;
    LPTSTR pszCharBuf;                  // isearch string lives here
    int cbCharBuf;                      // allocated size of pszCharBuf
    int ichCharBuf;                     // number of live chars in pszCharBuf
    DWORD timeLast;                     // time of last input event
#if defined(FE_IME)
    BOOL fReplaceCompChar;
#endif

} ISEARCHINFO, *PISEARCHINFO;

#if defined(FE_IME)
BOOL FAR PASCAL IncrementSearchImeCompStr(PISEARCHINFO pis, BOOL fCompStr, LPTSTR lpszCompChar, LPTSTR FAR *lplpstr);
#endif
BOOL FAR PASCAL IncrementSearchString(PISEARCHINFO pis, UINT ch, LPTSTR FAR *lplpstr);
int FAR PASCAL GetIncrementSearchString(PISEARCHINFO pis, LPTSTR lpsz);
int FAR PASCAL GetIncrementSearchStringA(PISEARCHINFO pis, UINT uiCodePage, LPSTR lpsz);
void FAR PASCAL IncrementSearchBeep(PISEARCHINFO pis);

#define IncrementSearchFree(pis) ((pis)->pszCharBuf ? Free((pis)->pszCharBuf) : 0)

// For RTL mirroring use
void MirrorBitmapInDC( HDC hdc , HBITMAP hbmOrig );

// Locale manipulation (prsht.c)
//
//  The "proper thread locale" is the thread locale we should
//  be using for our UI elements.
//
//  If you need to change the thread locale temporarily
//  to the proper thread locale, use
//
//  LCID lcidPrev;
//  CCSetProperThreadLocale(&lcidPrev);
//  munge munge munge
//  CCRestoreThreadLocale(lcidPrev);
//
//  If you just want to retrieve the proper thread locale,
//  call CCGetProperThreadLocale(NULL).
//
//
LCID CCGetProperThreadLocale(OPTIONAL LCID *plcidPrev);

__inline void CCSetProperThreadLocale(LCID *plcidPrev) {
    SetThreadLocale(CCGetProperThreadLocale(plcidPrev));
}

#define CCRestoreThreadLocale(lcid) SetThreadLocale(lcid)

int CCLoadStringExInternal(HINSTANCE hInst, UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang);
int CCLoadStringEx(UINT uID, LPWSTR lpBuffer, int nBufferMax, WORD wLang);
int LocalizedLoadString(UINT uID, LPWSTR lpBuffer, int nBufferMax);
HRSRC FindResourceExRetry(HMODULE hmod, LPCTSTR lpType, LPCTSTR lpName, WORD wLang);

// assign most unlikely used value for the fake sublang id
#define SUBLANG_JAPANESE_ALTFONT 0x3f // max within 6bit

// used to get resource lang of shell32
#define DLG_EXITWINDOWS         1064

//
// Plug UI Setting funcions (commctrl.c)
//
LANGID WINAPI GetMUILanguage(void);

//
// Tooltip thunking api's
//

BOOL ThunkToolTipTextAtoW (LPTOOLTIPTEXTA lpTttA, LPTOOLTIPTEXTW lpTttW, UINT uiCodePage);


HWND GetDlgItemRect(HWND hDlg, int nIDItem, LPRECT prc);

//
// Global variables
//
extern HINSTANCE g_hinst;
extern UINT uDragListMsg;
extern int g_iIncrSearchFailed;

#define g_bRunOnNT TRUE
#define g_bRunOnMemphis FALSE
extern BOOL g_bRunOnNT5;
extern BOOL g_bRemoteSession;
extern UINT g_uiACP;

//
// Is Mirroring APIs enabled (BiDi Memphis and NT5 only)
//
extern BOOL g_bMirroredOS;

#ifdef FONT_LINK
extern BOOL g_bComplexPlatform;
#endif

//
// Icon mirroring stuff
//
extern HDC g_hdc;
extern HDC g_hdcMask;


#define HINST_THISDLL   g_hinst

#ifdef DEBUG
#undef SendMessage
#define SendMessage  SendMessageD
#ifdef __cplusplus
extern "C"
{
#endif
LRESULT WINAPI SendMessageD(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
int WINAPI Str_GetPtr0(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf);
#ifdef __cplusplus
}
#endif
#else  // !DEBUG
#define Str_GetPtr0     Str_GetPtr
#endif // DEBUG / !DEBUG

// REVIEW, should this be a function? (inline may generate a lot of code)
#define CBBITMAPBITS(cx, cy, cPlanes, cBitsPerPixel)    \
        (((((cx) * (cBitsPerPixel) + 15) & ~15) >> 3)   \
        * (cPlanes) * (cy))

#define WIDTHBYTES(cx, cBitsPerPixel)   \
        ((((cx) * (cBitsPerPixel) + 31) / 32) * 4)

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))                          /* ;Internal */

#define InRange(id, idFirst, idLast)      ((UINT)((id)-(idFirst)) <= (UINT)((idLast)-(idFirst)))

void FAR PASCAL ColorDitherBrush_OnSysColorChange();
extern HBRUSH g_hbrMonoDither;              // gray dither brush from image.c
void FAR PASCAL InitDitherBrush();
void FAR PASCAL TerminateDitherBrush();


#ifndef DT_NOFULLWIDTHCHARBREAK
#define DT_NOFULLWIDTHCHARBREAK     0x00080000
#endif  // DT_NOFULLWIDTHCHARBREAK

#define SHDT_DRAWTEXT       0x0001
#define SHDT_ELLIPSES       0x0002
#define SHDT_CLIPPED        0x0004
#define SHDT_SELECTED       0x0008
#define SHDT_DESELECTED     0x0010
#define SHDT_DEPRESSED      0x0020
#define SHDT_EXTRAMARGIN    0x0040
#define SHDT_TRANSPARENT    0x0080
#define SHDT_SELECTNOFOCUS  0x0100
#define SHDT_HOTSELECTED    0x0200
#define SHDT_DTELLIPSIS     0x0400
#define SHDT_RTLREADING     0x0800
#define SHDT_NODBCSBREAK    0x1000

void WINAPI SHDrawText(HDC hdc, LPCTSTR pszText, RECT FAR* prc,
        int fmt, UINT flags, int cyChar, int cxEllipses,
        COLORREF clrText, COLORREF clrTextBk);


// notify.c
LRESULT WINAPI CCSendNotify(CONTROLINFO * pci, int code, LPNMHDR pnm);
BOOL CCReleaseCapture(CONTROLINFO * pci);


// treeview.c, listview.c for FE_IME code
LPTSTR GET_COMP_STRING(HIMC hImc, DWORD dwFlags);

// lvicon.c in-place editing
#define SEIPS_WRAP          0x0001
#ifdef DEBUG
#define SEIPS_NOSCROLL      0x0002      // Flag is used only in DEBUG
#endif
void FAR PASCAL SetEditInPlaceSize(HWND hwndEdit, RECT FAR *prc, HFONT hFont, UINT seips);
HWND FAR PASCAL CreateEditInPlaceWindow(HWND hwnd, LPCTSTR lpText, int cbText, LONG style, HFONT hFont);
void RescrollEditWindow(HWND hwndEdit);

// Global System metrics.

extern int g_cxEdge;
extern int g_cyEdge;
extern int g_cxBorder;
extern int g_cyBorder;
extern int g_cxScreen;
extern int g_cyScreen;
extern int g_cxDoubleClk;
extern int g_cyDoubleClk;

extern int g_cxSmIcon;
extern int g_cySmIcon;
//extern int g_cxIcon;
//extern int g_cyIcon;
extern int g_cxFrame;
extern int g_cyFrame;
extern int g_cxIconSpacing, g_cyIconSpacing;
extern int g_cxScrollbar, g_cyScrollbar;
extern int g_cxIconMargin, g_cyIconMargin;
extern int g_cyLabelSpace;
extern int g_cxLabelMargin;
//extern int g_cxIconOffset, g_cyIconOffset;
extern int g_cxVScroll;
extern int g_cyHScroll;
extern int g_cxHScroll;
extern int g_cyVScroll;
extern int g_fDragFullWindows;
extern int g_fDBCSEnabled;
extern int g_fMEEnabled;
extern int g_fDBCSInputEnabled;

extern COLORREF g_clrWindow;
extern COLORREF g_clrWindowText;
extern COLORREF g_clrWindowFrame;
extern COLORREF g_clrGrayText;
extern COLORREF g_clrBtnText;
extern COLORREF g_clrBtnFace;
extern COLORREF g_clrBtnShadow;
extern COLORREF g_clrBtnHighlight;
extern COLORREF g_clrHighlight;
extern COLORREF g_clrHighlightText;
extern COLORREF g_clrInfoText;
extern COLORREF g_clrInfoBk;
extern COLORREF g_clr3DDkShadow;
extern COLORREF g_clr3DLight;

extern HBRUSH g_hbrGrayText;
extern HBRUSH g_hbrWindow;
extern HBRUSH g_hbrWindowText;
extern HBRUSH g_hbrWindowFrame;
extern HBRUSH g_hbrBtnFace;
extern HBRUSH g_hbrBtnHighlight;
extern HBRUSH g_hbrBtnShadow;
extern HBRUSH g_hbrHighlight;

extern HFONT g_hfontSystem;
#define WHEEL_DELTA     120
extern UINT g_msgMSWheel;
extern UINT g_ucScrollLines;
extern int  gcWheelDelta;
extern UINT g_uDragImages;

#ifdef __cplusplus
}
#endif // __cplusplus

typedef LRESULT (CALLBACK *SUBCLASSPROC)(HWND hWnd, UINT uMsg, WPARAM wParam,
    LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData);

STDAPI_(BOOL) WINAPI SetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR dwRefData);
STDAPI_(BOOL) WINAPI GetWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass, UINT_PTR uIdSubclass,
    DWORD_PTR *pdwRefData);
STDAPI_(BOOL) WINAPI RemoveWindowSubclass(HWND hWnd, SUBCLASSPROC pfnSubclass,
    UINT_PTR uIdSubclass);
STDAPI_(LRESULT) WINAPI DefSubclassProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

#define CDIS_SHOWKEYBOARDCUES   0x0200


// TRACE FLAGS
//
#define TF_MONTHCAL     0x00000100  // MonthCal and DateTimePick
#define TF_BKIMAGE      0x00000200  // ListView background image
#define TF_TOOLBAR      0x00000400  // Toolbar stuff
#define TF_PAGER        0x00000800  // Pager  Stuff
#define TF_REBAR        0x00001000  // Rebar
#define TF_LISTVIEW     0x00002000  // Listview
#define TF_TREEVIEW     0x00004000  // Treeview
#define TF_STATUS       0x00008000  // Status bar

// Prototype flags
#define PTF_FLATLOOK    0x00000001  // Overall flatlook
#define PTF_NOISEARCHTO 0x00000002  // No incremental search timeout

#include <platform.h>

// Dummy union macros for code compilation on platforms not
// supporting nameless stuct/union

#ifdef NONAMELESSUNION
#define DUMMYUNION_MEMBER(member)   DUMMYUNIONNAME.member
#define DUMMYUNION2_MEMBER(member)  DUMMYUNIONNAME2.member
#define DUMMYUNION3_MEMBER(member)  DUMMYUNIONNAME3.member
#define DUMMYUNION4_MEMBER(member)  DUMMYUNIONNAME4.member
#define DUMMYUNION5_MEMBER(member)  DUMMYUNIONNAME5.member
#else
#define DUMMYUNION_MEMBER(member)    member
#define DUMMYUNION2_MEMBER(member)   member
#define DUMMYUNION3_MEMBER(member)   member
#define DUMMYUNION4_MEMBER(member)   member
#define DUMMYUNION5_MEMBER(member)   member
#endif

#define ALLOC_NULLHEAP(heap, size) Alloc( size )
#define COLOR_STRUCT DWORD
#define QUAD_PART(a) ((a)##.QuadPart)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\cutils.c ===
/*
**  CUTILS.C
**
**  Common utilities for common controls
**
*/

#include "ctlspriv.h"
#include "advpub.h"             // For REGINSTALL
#include <ntverp.h>
#include "ccver.h"              // App compat version hacks

#ifndef SSW_EX_IGNORESETTINGS
#define SSW_EX_IGNORESETTINGS   0x00040000  // ignore system settings to turn on/off smooth scroll
#endif


//
// Globals - REVIEW_32
//

BOOL g_fAnimate;
BOOL g_fSmoothScroll;

int g_cxEdge;
int g_cyEdge;
int g_cxBorder;
int g_cyBorder;
int g_cxScreen;
int g_cyScreen;
int g_cxFrame;
int g_cyFrame;
int g_cxVScroll;
int g_cyHScroll;
int g_cxIcon, g_cyIcon;
int g_cxSmIcon, g_cySmIcon;
int g_cxIconSpacing, g_cyIconSpacing;
int g_cxIconMargin, g_cyIconMargin;
int g_cyLabelSpace;
int g_cxLabelMargin;
int g_cxDoubleClk;
int g_cyDoubleClk;
int g_cxScrollbar;
int g_cyScrollbar;
int g_fDragFullWindows;


COLORREF g_clrWindow;
COLORREF g_clrWindowText;
COLORREF g_clrWindowFrame;
COLORREF g_clrGrayText;
COLORREF g_clrBtnText;
COLORREF g_clrBtnFace;
COLORREF g_clrBtnShadow;
COLORREF g_clrBtnHighlight;
COLORREF g_clrHighlight;
COLORREF g_clrHighlightText;
COLORREF g_clrInfoText;
COLORREF g_clrInfoBk;
COLORREF g_clr3DDkShadow;
COLORREF g_clr3DLight;

HBRUSH g_hbrGrayText;
HBRUSH g_hbrWindow;
HBRUSH g_hbrWindowText;
HBRUSH g_hbrWindowFrame;
HBRUSH g_hbrBtnFace;
HBRUSH g_hbrBtnHighlight;
HBRUSH g_hbrBtnShadow;
HBRUSH g_hbrHighlight;


DWORD  g_dwHoverSelectTimeout;

HFONT g_hfontSystem;

#define CCS_ALIGN (CCS_TOP | CCS_NOMOVEY | CCS_BOTTOM)

int TrueMapWindowPoints(HWND hwndFrom, HWND hwndTo, LPPOINT lppt, UINT cPoints);

// Note that the default alignment is CCS_BOTTOM
//
void FAR PASCAL NewSize(HWND hWnd, int nThickness, LONG style, int left, int top, int width, int height)
{
    // Resize the window unless the user said not to
    //
    if (!(style & CCS_NORESIZE))
    {
        RECT rc, rcWindow, rcBorder;

        // Remember size that was passed in and don't bother calling SetWindowPos if we're not
        // actually going to change the window size
        int leftSave = left;
        int topSave = top;
        int widthSave = width;
        int heightSave = height;

        // Calculate the borders around the client area of the status bar
        GetWindowRect(hWnd, &rcWindow);
        rcWindow.right -= rcWindow.left;  // -> dx
        rcWindow.bottom -= rcWindow.top;  // -> dy

        GetClientRect(hWnd, &rc);

        //
        // If the window is mirrored, mirror the anchor point
        // since it will be passed to SWP which accepts screen
        // ccordinates. This mainly fixes the display of status bar
        // and others. [samera]
        //
        if (IS_WINDOW_RTL_MIRRORED(hWnd))
        {
            TrueMapWindowPoints(hWnd, NULL, (LPPOINT)&rc.left, 1);
        }
        else
        {
            ClientToScreen(hWnd, (LPPOINT)&rc);
        }

        rcBorder.left = rc.left - rcWindow.left;
        rcBorder.top  = rc.top  - rcWindow.top ;
        rcBorder.right  = rcWindow.right  - rc.right  - rcBorder.left;
        rcBorder.bottom = rcWindow.bottom - rc.bottom - rcBorder.top ;

        if (style & CCS_VERT)
            nThickness += rcBorder.left + rcBorder.right;
        else
            nThickness += rcBorder.top + rcBorder.bottom;

        // Check whether to align to the parent window
        //
        if (style & CCS_NOPARENTALIGN)
        {
            // Check out whether this bar is top aligned or bottom aligned
            //
            switch (style & CCS_ALIGN)
            {
            case CCS_TOP:
            case CCS_NOMOVEY:
                break;

            default: // CCS_BOTTOM
                if(style & CCS_VERT)
                    left = left + width - nThickness;
                else
                    top = top + height - nThickness;
            }
        }
        else
        {
            // It is assumed there is a parent by default
            //
            GetClientRect(GetParent(hWnd), &rc);

            // Don't forget to account for the borders
            //
            if(style & CCS_VERT)
            {
                top = -rcBorder.right;
                height = rc.bottom + rcBorder.top + rcBorder.bottom;
            }
            else
            {
                left = -rcBorder.left;
                width = rc.right + rcBorder.left + rcBorder.right;
            }

            if ((style & CCS_ALIGN) == CCS_TOP)
            {
                if(style & CCS_VERT)
                    left = -rcBorder.left;
                else
                    top = -rcBorder.top;
            }
            else if ((style & CCS_ALIGN) != CCS_NOMOVEY)
            {
                if (style & CCS_VERT)
                    left = rc.right - nThickness + rcBorder.right;
                else
                    top = rc.bottom - nThickness + rcBorder.bottom;
            }
        }
        if (!(style & CCS_NOMOVEY) && !(style & CCS_NODIVIDER))
        {
            if (style & CCS_VERT)
                left += g_cxEdge;
            else
                top += g_cyEdge;      // double pixel edge thing
        }

        if(style & CCS_VERT)
            width = nThickness;
        else
            height = nThickness;

        SetWindowPos(hWnd, NULL, left, top, width, height, SWP_NOZORDER);
    }
}


BOOL FAR PASCAL MGetTextExtent(HDC hdc, LPCTSTR lpstr, int cnt, int FAR * pcx, int FAR * pcy)
{
    BOOL fSuccess;
    SIZE size = {0,0};
    
    if (cnt == -1)
        cnt = lstrlen(lpstr);
    
    fSuccess=GetTextExtentPoint(hdc, lpstr, cnt, &size);
    if (pcx)
        *pcx=size.cx;
    if (pcy)
        *pcy=size.cy;

    return fSuccess;
}


// these are the default colors used to map the dib colors
// to the current system colors

#define RGB_BUTTONTEXT      (RGB(000,000,000))  // black
#define RGB_BUTTONSHADOW    (RGB(128,128,128))  // dark grey
#define RGB_BUTTONFACE      (RGB(192,192,192))  // bright grey
#define RGB_BUTTONHILIGHT   (RGB(255,255,255))  // white
#define RGB_BACKGROUNDSEL   (RGB(000,000,255))  // blue
#define RGB_BACKGROUND      (RGB(255,000,255))  // magenta

#define FlipColor(rgb)      (RGB(GetBValue(rgb), GetGValue(rgb), GetRValue(rgb)))

#define MAX_COLOR_MAPS      16

// This is almost the same as LoadImage(..., LR_MAP3DCOLORS) except that
//
//  -   The app can specify a custom color map,
//  -   The default color map maps colors beyond the 3D colors,
//
HBITMAP WINAPI CreateMappedBitmap(HINSTANCE hInstance, INT_PTR idBitmap,
      UINT wFlags, LPCOLORMAP lpColorMap, int iNumMaps)
{
  HDC                   hdc, hdcMem = NULL;
  HANDLE                h;
  COLOR_STRUCT FAR      *p;
  COLOR_STRUCT FAR      *lpTable;
  LPBYTE                lpBits;
  HANDLE                hRes;
  LPBITMAPINFOHEADER    lpBitmapInfo;
  HBITMAP               hbm = NULL, hbmOld;
  int numcolors, i;
  int wid, hgt;
  LPBITMAPINFOHEADER    lpMungeInfo;
  int                   offBits;
  COLOR_STRUCT          rgbMaskTable[16];
  COLOR_STRUCT          rgbBackground;

  static const COLORMAP SysColorMap[] = {
    {RGB_BUTTONTEXT,    COLOR_BTNTEXT},     // black
    {RGB_BUTTONSHADOW,  COLOR_BTNSHADOW},   // dark grey
    {RGB_BUTTONFACE,    COLOR_BTNFACE},     // bright grey
    {RGB_BUTTONHILIGHT, COLOR_BTNHIGHLIGHT},// white
    {RGB_BACKGROUNDSEL, COLOR_HIGHLIGHT},   // blue
    {RGB_BACKGROUND,    COLOR_WINDOW}       // magenta
  };
  #define NUM_DEFAULT_MAPS (sizeof(SysColorMap)/sizeof(COLORMAP))
  COLORMAP DefaultColorMap[NUM_DEFAULT_MAPS];
  COLORMAP DIBColorMap[MAX_COLOR_MAPS];

  h = FindResource(hInstance, MAKEINTRESOURCE(idBitmap), RT_BITMAP);
  if (!h)
      return NULL;

  hRes = LoadResource(hInstance, h);

  /* Lock the bitmap and get a pointer to the color table. */
  lpBitmapInfo = (LPBITMAPINFOHEADER)LockResource(hRes);
  if (!lpBitmapInfo)
        return NULL;

  // munge on a copy of the color table instead of the original
  // (prevent possibility of "reload" with messed table
  offBits = (int)lpBitmapInfo->biSize + ((1 << (lpBitmapInfo->biBitCount)) * sizeof(RGBQUAD));
  lpMungeInfo = GlobalAlloc(GPTR, offBits);
  if (!lpMungeInfo)
        goto Exit1;
  hmemcpy(lpMungeInfo, lpBitmapInfo, offBits);

  /* Get system colors for the default color map */
  if (!lpColorMap) {
        lpColorMap = DefaultColorMap;
    iNumMaps = NUM_DEFAULT_MAPS;
    for (i=0; i < iNumMaps; i++) {
      lpColorMap[i].from = SysColorMap[i].from;
      lpColorMap[i].to = GetSysColor((int)SysColorMap[i].to);
    }
  }

  /* Transform RGB color map to a BGR DIB format color map */
  if (iNumMaps > MAX_COLOR_MAPS)
    iNumMaps = MAX_COLOR_MAPS;

  /*
   1) their definition of COLORMAP is based on COLORREFs but a
      DIB color map is RGBQUAD
   2) FlipColor as per definition above does not flip at all
      since it goes from COLORREF to COLORREF
   so we are better doing nothing, this the(Jose)
   */
  for (i=0; i < iNumMaps; i++) {
    DIBColorMap[i].to = FlipColor(lpColorMap[i].to);
    DIBColorMap[i].from = FlipColor(lpColorMap[i].from);
  }

  // use the table in the munging buffer
  lpTable = p = (COLOR_STRUCT FAR *)(((LPBYTE)lpMungeInfo) + lpMungeInfo->biSize);

  /* Replace button-face and button-shadow colors with the current values
   */
  numcolors = 16;

  // if we are creating a mask, build a color table with white
  // marking the transparent section (where it used to be background)
  // and black marking the opaque section (everything else).  this
  // table is used below to build the mask using the original DIB bits.
  if (wFlags & CMB_MASKED) {
      rgbBackground = FlipColor(RGB_BACKGROUND);
      for (i = 0; i < 16; i++) {
          if (p[i] == rgbBackground)
              rgbMaskTable[i] = 0xFFFFFF;       // transparent section
          else
              rgbMaskTable[i] = 0x000000;       // opaque section
      }
  }

  while (numcolors-- > 0) {
      for (i = 0; i < iNumMaps; i++) {
          if ((*p & 0x00FFFFFF) == DIBColorMap[i].from) {
          *p = DIBColorMap[i].to;
              break;
          }
      }
      p++;
  }

  /* First skip over the header structure */
  lpBits = (LPBYTE)(lpBitmapInfo) + offBits;

  /* Create a color bitmap compatible with the display device */
  i = wid = (int)lpBitmapInfo->biWidth;
  hgt = (int)lpBitmapInfo->biHeight;
  hdc = GetDC(NULL);
  hdcMem = CreateCompatibleDC(hdc);
  if (!hdcMem)
      goto cleanup;

  // if creating a mask, the bitmap needs to be twice as wide.
  if (wFlags & CMB_MASKED)
      i = wid*2;

// discardable bitmaps aren't much use anymore...
//
//  if (wFlags & CMB_DISCARDABLE)
//      hbm = CreateDiscardableBitmap(hdc, i, hgt);
//  else
  if (wFlags & CMB_DIBSECTION)
  {
    // Have to edit the header slightly, since CreateDIBSection supports
    // only BI_RGB and BI_BITFIELDS.  This is the same whackery that USER
    // does in LoadImage.
    LPVOID pvDummy;
    DWORD dwCompression = lpMungeInfo->biCompression;
    if (dwCompression != BI_BITFIELDS)
      lpMungeInfo->biCompression = BI_RGB;
    hbm = CreateDIBSection(hdc, (LPBITMAPINFO)lpMungeInfo, DIB_RGB_COLORS,
                           &pvDummy, NULL, 0);
    lpMungeInfo->biCompression = dwCompression;
  }

  // If CMB_DIBSECTION failed, then create a DDB instead.  Not perfect,
  // but better than creating nothing.  We also get here if the caller
  // didn't ask for a DIB section.
  if (hbm == NULL)
      hbm = CreateCompatibleBitmap(hdc, i, hgt);

  if (hbm) {
      hbmOld = SelectObject(hdcMem, hbm);

      // set the main image
      StretchDIBits(hdcMem, 0, 0, wid, hgt, 0, 0, wid, hgt, lpBits,
                 (LPBITMAPINFO)lpMungeInfo, DIB_RGB_COLORS, SRCCOPY);

      // if building a mask, replace the DIB's color table with the
      // mask's black/white table and set the bits.  in order to
      // complete the masked effect, the actual image needs to be
      // modified so that it has the color black in all sections
      // that are to be transparent.
      if (wFlags & CMB_MASKED) {
          hmemcpy(lpTable, (DWORD FAR *)rgbMaskTable, 16 * sizeof(RGBQUAD));
          StretchDIBits(hdcMem, wid, 0, wid, hgt, 0, 0, wid, hgt, lpBits,
                 (LPBITMAPINFO)lpMungeInfo, DIB_RGB_COLORS, SRCCOPY);
          BitBlt(hdcMem, 0, 0, wid, hgt, hdcMem, wid, 0, 0x00220326);   // DSna
      }
      SelectObject(hdcMem, hbmOld);
  }

cleanup:
  if (hdcMem)
      DeleteObject(hdcMem);
  ReleaseDC(NULL, hdc);

  GlobalFree(lpMungeInfo);

Exit1:
  UnlockResource(hRes);
  FreeResource(hRes);

  return hbm;
}

// moved from shelldll\dragdrop.c

// should caller pass in message that indicates termination
// (WM_LBUTTONUP, WM_RBUTTONUP)?
//
// in:
//      hwnd    to do check on
//      x, y    in client coordinates
//
// returns:
//      TRUE    the user began to drag (moved mouse outside double click rect)
//      FALSE   mouse came up inside click rect
//
// BUGBUG, should support VK_ESCAPE to cancel

BOOL PASCAL CheckForDragBegin(HWND hwnd, int x, int y)
{
    RECT rc;
    int dxClickRect = GetSystemMetrics(SM_CXDRAG);
    int dyClickRect = GetSystemMetrics(SM_CYDRAG);

    if (dxClickRect < 4)
    {
        dxClickRect = dyClickRect = 4;
    }

    // See if the user moves a certain number of pixels in any direction

    SetRect(&rc, x - dxClickRect, y - dyClickRect, x + dxClickRect, y + dyClickRect);
    MapWindowRect(hwnd, HWND_DESKTOP, &rc); // client -> screen

    //
    //  SUBTLE!  We use PeekMessage+WaitMessage instead of GetMessage,
    //  because WaitMessage will return when there is an incoming
    //  SendMessage, whereas GetMessage does not.  This is important,
    //  because the incoming message might've been WM_CAPTURECHANGED.
    //

    SetCapture(hwnd);
    do {
        MSG32 msg32;
        if (PeekMessage32(&msg32, NULL, 0, 0, PM_REMOVE, TRUE))
        {
            // See if the application wants to process the message...
            if (CallMsgFilter32(&msg32, MSGF_COMMCTRL_BEGINDRAG, TRUE) != 0)
                continue;

            switch (msg32.message) {
            case WM_LBUTTONUP:
            case WM_RBUTTONUP:
            case WM_LBUTTONDOWN:
            case WM_RBUTTONDOWN:
                ReleaseCapture();
                return FALSE;

            case WM_MOUSEMOVE:
                if (IsWindow(hwnd) && !PtInRect(&rc, msg32.pt)) {
                    ReleaseCapture();
                    return TRUE;
                }
                break;

            default:
                TranslateMessage32(&msg32, TRUE);
                DispatchMessage32(&msg32, TRUE);
                break;
            }
        }
        else WaitMessage();

        // WM_CANCELMODE messages will unset the capture, in that
        // case I want to exit this loop
    } while (IsWindow(hwnd) && GetCapture() == hwnd);

    return FALSE;
}


/* Regular StrToInt; stops at first non-digit. */

int WINAPI StrToInt(LPCTSTR lpSrc)      // atoi()
{

#define ISDIGIT(c)  ((c) >= TEXT('0') && (c) <= TEXT('9'))

    int n = 0;
    BOOL bNeg = FALSE;

    if (*lpSrc == TEXT('-')) {
        bNeg = TRUE;
        lpSrc++;
    }

    while (ISDIGIT(*lpSrc)) {
        n *= 10;
        n += *lpSrc - TEXT('0');
        lpSrc++;
    }
    return bNeg ? -n : n;
}

//
// Wrappers for StrToInt
//

int WINAPI StrToIntA(LPCSTR lpSrc)      // atoi()
{
    LPWSTR lpString;
    INT    iResult;

    lpString = ProduceWFromA (CP_ACP, lpSrc);

    if (!lpString) {
        return 0;
    }

    iResult = StrToIntW(lpString);

    FreeProducedString (lpString);

    return iResult;

}


//
// From zmouse.h in the Magellan SDK
//

#define MSH_MOUSEWHEEL TEXT("MSWHEEL_ROLLMSG")

// Class name for Magellan/Z MSWHEEL window
// use FindWindow to get hwnd to MSWHEEL
#define MOUSEZ_CLASSNAME  TEXT("MouseZ")           // wheel window class
#define MOUSEZ_TITLE      TEXT("Magellan MSWHEEL") // wheel window title

#define MSH_WHEELMODULE_CLASS (MOUSEZ_CLASSNAME)
#define MSH_WHEELMODULE_TITLE (MOUSEZ_TITLE)

#define MSH_SCROLL_LINES  TEXT("MSH_SCROLL_LINES_MSG")

#define DI_GETDRAGIMAGE TEXT("ShellGetDragImage")       // Copied from Shlobj.w

UINT g_msgMSWheel;
UINT g_ucScrollLines = 3;                        /* default */
int  gcWheelDelta;
UINT g_uDragImages;

void FAR PASCAL InitGlobalMetrics(WPARAM wParam)
{
    static BOOL fInitMouseWheel;
    static HWND hwndMSWheel;
    static UINT msgMSWheelGetScrollLines;

    if (!fInitMouseWheel)
    {
        fInitMouseWheel = TRUE;

        if (g_bRunOnNT || g_bRunOnMemphis)
            g_msgMSWheel = WM_MOUSEWHEEL;
        else
        {
            g_msgMSWheel = RegisterWindowMessage(MSH_MOUSEWHEEL);
            msgMSWheelGetScrollLines = RegisterWindowMessage(MSH_SCROLL_LINES);
            hwndMSWheel = FindWindow(MSH_WHEELMODULE_CLASS, MSH_WHEELMODULE_TITLE);
        }
    }

    g_uDragImages = RegisterWindowMessage(DI_GETDRAGIMAGE);

    if (g_bRunOnNT || g_bRunOnMemphis)
    {
        SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &g_ucScrollLines, 0);
    }
    else if (hwndMSWheel && msgMSWheelGetScrollLines)
    {
        g_ucScrollLines =
              (UINT)SendMessage(hwndMSWheel, msgMSWheelGetScrollLines, 0, 0);
    }

    // bug fix HACK: these are NOT members of USER's NONCLIENTMETRICS struct
    g_cxIcon = GetSystemMetrics(SM_CXICON);
    g_cyIcon = GetSystemMetrics(SM_CYICON);
    g_cxSmIcon = GetSystemMetrics(SM_CXSMICON);
    g_cySmIcon = GetSystemMetrics(SM_CYSMICON);

    g_cxIconSpacing = GetSystemMetrics( SM_CXICONSPACING );
    g_cyIconSpacing = GetSystemMetrics( SM_CYICONSPACING );

    // Full window drag stays off if running remotely
    if (!g_bRemoteSession &&
        (wParam == 0 || wParam == SPI_SETDRAGFULLWINDOWS)) {
        SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, sizeof(g_fDragFullWindows), &g_fDragFullWindows, 0);
    }

    // Smooth scrolling stays off if running remotely
    if (!g_bRemoteSession) {
        HKEY hkey;

        g_fSmoothScroll = TRUE;

        if (RegOpenKeyEx(HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"), 0, KEY_READ, &hkey) == ERROR_SUCCESS) {
            DWORD dwSize = sizeof(g_fSmoothScroll);
            RegQueryValueEx(hkey, TEXT("SmoothScroll"), 0, NULL, (LPBYTE)&g_fSmoothScroll, &dwSize);
            RegCloseKey(hkey);
        }
    }

    if (g_bRemoteSession)
    {
        // Nobody should've turned these on
        ASSERT(g_fDragFullWindows == FALSE);
        ASSERT(g_fSmoothScroll == FALSE);
    }

    // BUGBUG: some of these are also not members of NONCLIENTMETRICS
    if ((wParam == 0) || (wParam == SPI_SETNONCLIENTMETRICS))
    {
        NONCLIENTMETRICS ncm;

        // REVIEW, make sure all these vars are used somewhere.
        g_cxEdge = GetSystemMetrics(SM_CXEDGE);
        g_cyEdge = GetSystemMetrics(SM_CYEDGE);
        g_cxBorder = GetSystemMetrics(SM_CXBORDER);
        g_cyBorder = GetSystemMetrics(SM_CYBORDER);
        g_cxScreen = GetSystemMetrics(SM_CXSCREEN);
        g_cyScreen = GetSystemMetrics(SM_CYSCREEN);
        g_cxFrame  = GetSystemMetrics(SM_CXFRAME);
        g_cyFrame  = GetSystemMetrics(SM_CYFRAME);

        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

        g_cxVScroll = g_cxScrollbar = (int)ncm.iScrollWidth;
        g_cyHScroll = g_cyScrollbar = (int)ncm.iScrollHeight;

        // this is true for 4.0 modules only
        // for 3.x modules user lies and adds one to these values
        // ASSERT(g_cxVScroll == GetSystemMetrics(SM_CXVSCROLL));
        // ASSERT(g_cyHScroll == GetSystemMetrics(SM_CYHSCROLL));

        g_cxIconMargin = g_cxBorder * 8;
        g_cyIconMargin = g_cyEdge;
        g_cyLabelSpace = g_cyIconMargin + (g_cyEdge);
        g_cxLabelMargin = g_cxEdge;

        g_cxDoubleClk = GetSystemMetrics(SM_CXDOUBLECLK);
        g_cyDoubleClk = GetSystemMetrics(SM_CYDOUBLECLK);
    }

    //NT 4.0 has this SPI_GETMOUSEHOVERTIME
    SystemParametersInfo(SPI_GETMOUSEHOVERTIME, 0, &g_dwHoverSelectTimeout, 0);
}

void FAR PASCAL InitGlobalColors()
{
    g_clrWindow = GetSysColor(COLOR_WINDOW);
    g_clrWindowText = GetSysColor(COLOR_WINDOWTEXT);
    g_clrWindowFrame = GetSysColor(COLOR_WINDOWFRAME);
    g_clrGrayText = GetSysColor(COLOR_GRAYTEXT);
    g_clrBtnText = GetSysColor(COLOR_BTNTEXT);
    g_clrBtnFace = GetSysColor(COLOR_BTNFACE);
    g_clrBtnShadow = GetSysColor(COLOR_BTNSHADOW);
    g_clrBtnHighlight = GetSysColor(COLOR_BTNHIGHLIGHT);
    g_clrHighlight = GetSysColor(COLOR_HIGHLIGHT);
    g_clrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
    g_clrInfoText = GetSysColor(COLOR_INFOTEXT);
    g_clrInfoBk = GetSysColor(COLOR_INFOBK);
    g_clr3DDkShadow = GetSysColor(COLOR_3DDKSHADOW);
    g_clr3DLight = GetSysColor(COLOR_3DLIGHT);

    g_hbrGrayText = GetSysColorBrush(COLOR_GRAYTEXT);
    g_hbrWindow = GetSysColorBrush(COLOR_WINDOW);
    g_hbrWindowText = GetSysColorBrush(COLOR_WINDOWTEXT);
    g_hbrWindowFrame = GetSysColorBrush(COLOR_WINDOWFRAME);
    g_hbrBtnFace = GetSysColorBrush(COLOR_BTNFACE);
    g_hbrBtnHighlight = GetSysColorBrush(COLOR_BTNHIGHLIGHT);
    g_hbrBtnShadow = GetSysColorBrush(COLOR_BTNSHADOW);
    g_hbrHighlight = GetSysColorBrush(COLOR_HIGHLIGHT);
    g_hfontSystem = GetStockObject(SYSTEM_FONT);
}

void FAR PASCAL RelayToToolTips(HWND hwndToolTips, HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    if(hwndToolTips) {
        MSG msg;
        msg.lParam = lParam;
        msg.wParam = wParam;
        msg.message = wMsg;
        msg.hwnd = hWnd;
        SendMessage(hwndToolTips, TTM_RELAYEVENT, 0, (LPARAM)(LPMSG)&msg);
    }
}

#define DT_SEARCHTIMEOUT    1000L       // 1 seconds

__inline BOOL IsISearchTimedOut(PISEARCHINFO pis)
{
    return GetMessageTime() - pis->timeLast > DT_SEARCHTIMEOUT &&
           !IsFlagSet(g_dwPrototype, PTF_NOISEARCHTO);

}

int FAR PASCAL GetIncrementSearchString(PISEARCHINFO pis, LPTSTR lpsz)
{
    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf && lpsz) 
    {
        // REVIEW: trusts that the lParam points to a buffer of sufficient
        // size to support the string and null terminator.
        StringCchCopy(lpsz, pis->ichCharBuf+1, pis->pszCharBuf);
    }
    return pis->ichCharBuf;
}

#if defined(FE_IME) 
// Now only Korean version is interested in incremental search with composition string.
BOOL FAR PASCAL IncrementSearchImeCompStr(PISEARCHINFO pis, BOOL fCompStr, LPTSTR lpszCompStr, LPTSTR FAR *lplpstr)
{
    BOOL fRestart = FALSE;

    if (!pis->fReplaceCompChar && IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf == 0)
    {
        fRestart = TRUE;
        pis->fReplaceCompChar = FALSE;
    }
    pis->timeLast = GetMessageTime();

    // Is there room for new character plus zero terminator?
    //
    if (!pis->fReplaceCompChar && pis->ichCharBuf + 1 + 1 > pis->cbCharBuf)
    {
        LPTSTR psz = ReAlloc(pis->pszCharBuf, sizeof(TCHAR)*(pis->cbCharBuf + 16));
        if (!psz)
            return fRestart;

        pis->cbCharBuf += 16;
        pis->pszCharBuf = psz;
    }

    if (pis->fReplaceCompChar)
    {
        if (lpszCompStr[0])
        {
            pis->pszCharBuf[pis->ichCharBuf-1] = lpszCompStr[0];
            pis->pszCharBuf[pis->ichCharBuf] = 0;
        }
        else
        {
            pis->ichCharBuf--;
            pis->pszCharBuf[pis->ichCharBuf] = 0;
        }
    }
    else
    {
        pis->pszCharBuf[pis->ichCharBuf++] = lpszCompStr[0];
        pis->pszCharBuf[pis->ichCharBuf] = 0;
    }

    pis->fReplaceCompChar = (fCompStr && lpszCompStr[0]);

    if (pis->ichCharBuf == 1 && pis->fReplaceCompChar)
        fRestart = TRUE;

    *lplpstr = pis->pszCharBuf;

    return fRestart;

}
#endif FE_IME

/*
 * Thunk for LVM_GETISEARCHSTRINGA
 */
int FAR PASCAL GetIncrementSearchStringA(PISEARCHINFO pis, UINT uiCodePage, LPSTR lpsz)
{
    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf && lpsz) {
        ConvertWToAN( uiCodePage, lpsz, pis->ichCharBuf, pis->pszCharBuf, pis->ichCharBuf );
        lpsz[pis->ichCharBuf] = '\0';
    }
    return pis->ichCharBuf;
}

// Beep only on the first failure.

void FAR PASCAL IncrementSearchBeep(PISEARCHINFO pis)
{
    if (!pis->iIncrSearchFailed)
    {
        pis->iIncrSearchFailed = TRUE;
        MessageBeep(0);
    }
}

//
//  IncrementSearchString - Add or clear the search string
//
//      ch == 0:  Reset the search string.  Return value meaningless.
//
//      ch != 0:  Append the character to the search string, starting
//                a new search string if we timed out the last one.
//                lplpstr receives the string so far.
//                Return value is TRUE if a new search string was
//                created, or FALSE if we appended to an existing one.
//

BOOL FAR PASCAL IncrementSearchString(PISEARCHINFO pis, UINT ch, LPTSTR FAR *lplpstr)
{
    BOOL fRestart = FALSE;

    if (!ch) {
        pis->ichCharBuf =0;
        pis->iIncrSearchFailed = 0;
        return FALSE;
    }

    if (IsISearchTimedOut(pis))
    {
        pis->iIncrSearchFailed = 0;
        pis->ichCharBuf = 0;
    }

    if (pis->ichCharBuf == 0)
        fRestart = TRUE;

    pis->timeLast = GetMessageTime();

    // Is there room for new character plus zero terminator?
    //
    if (pis->ichCharBuf + 1 + 1 > pis->cbCharBuf)
    {
        LPTSTR psz = ReAlloc(pis->pszCharBuf, ((pis->cbCharBuf + 16) * sizeof(TCHAR)));
        if (!psz)
            return fRestart;

        pis->cbCharBuf += 16;
        pis->pszCharBuf = psz;
    }

    pis->pszCharBuf[pis->ichCharBuf++] = (TCHAR)ch;
    pis->pszCharBuf[pis->ichCharBuf] = 0;

    *lplpstr = pis->pszCharBuf;

    return fRestart;
}

// strips out the accelerators.  they CAN be the same buffers.
void PASCAL StripAccelerators(LPTSTR lpszFrom, LPTSTR lpszTo, BOOL fAmpOnly)
{

    BOOL fRet = FALSE;

    while ( *lpszTo = *lpszFrom ) {
        if (!fAmpOnly && (g_fDBCSInputEnabled))
        {
            if (*lpszFrom == TEXT('(') && *(lpszFrom+1)==CH_PREFIX)
            {
                int i;
                LPTSTR psz = lpszFrom+2;

                for(i=0; i<2 && *psz;i++, psz=FastCharNext(psz))
                    ;


                if (*psz == '\0') {
                    *lpszTo = 0;
                    break;
                }
                else if (i == 2 && *psz == TEXT(')'))
                {
                    lpszTo--;
                    lpszFrom = psz+1;
                    continue;
                }
            }
        }

        if (*lpszFrom == TEXT('\t')) {
            *lpszTo = TEXT('\0');
            break;
        }

        if ( (*lpszFrom++ != CH_PREFIX) || (*lpszFrom == CH_PREFIX) ) {
            lpszTo++;
        }
    }
}


void ScrollShrinkRect(int x, int y, LPRECT lprc)
{
    if (lprc) {
        if (x > 0) {
            lprc->left += x;
        } else {
            lprc->right += x;
        }

        if (y > 0) {
            lprc->top += y;
        } else {
            lprc->bottom += y;
        }

    }
}



// common control info helpers
void FAR PASCAL CIInitialize(LPCONTROLINFO lpci, HWND hwnd, LPCREATESTRUCT lpcs)
{
    lpci->hwnd = hwnd;
    lpci->hwndParent = lpcs->hwndParent;
    lpci->style = lpcs->style;
    lpci->uiCodePage = CP_ACP;
    lpci->dwExStyle = lpcs->dwExStyle;

    lpci->bUnicode = lpci->hwndParent &&
                     SendMessage (lpci->hwndParent, WM_NOTIFYFORMAT,
                                 (WPARAM)lpci->hwnd, NF_QUERY) == NFR_UNICODE;

    if (lpci->hwndParent)
    {
        LRESULT lRes = SendMessage(lpci->hwndParent, WM_QUERYUISTATE, 0, 0);
            lpci->wUIState = LOWORD(lRes);
    }
}

LRESULT FAR PASCAL CIHandleNotifyFormat(LPCONTROLINFO lpci, LPARAM lParam)
{
    if (lParam == NF_QUERY) {
        return NFR_UNICODE;
    } else if (lParam == NF_REQUERY) {
        LRESULT uiResult;

        uiResult = SendMessage (lpci->hwndParent, WM_NOTIFYFORMAT,
                                (WPARAM)lpci->hwnd, NF_QUERY);

        lpci->bUnicode = BOOLIFY(uiResult == NFR_UNICODE);

        return uiResult;
    }
    return 0;
}

UINT CCSwapKeys(WPARAM wParam, UINT vk1, UINT vk2)
{
    if (wParam == vk1)
        return vk2;
    if (wParam == vk2)
        return vk1;
    return (UINT)wParam;
}

UINT RTLSwapLeftRightArrows(CONTROLINFO *pci, WPARAM wParam)
{
    if (pci->dwExStyle & RTL_MIRRORED_WINDOW) {
        return CCSwapKeys(wParam, VK_LEFT, VK_RIGHT);
    }
    return (UINT)wParam;
}

//
//  New for v5.01:
//
//  Accessibility (and some other callers, sometimes even us) relies on
//  a XXM_GETITEM call filling the buffer and not just redirecting the
//  pointer.  Accessibility is particularly impacted by this because they
//  live outside the process, so the redirected pointer means nothing
//  to them.  Here, we copy the result back into the app buffer and return
//  the raw pointer.  The caller will return the raw pointer back to the
//  app, so the answer is in two places, either the app buffer, or in
//  the raw pointer.
//
//  Usage:
//
//      if (nm.item.mask & LVIF_TEXT)
//          pitem->pszText = CCReturnDispInfoText(nm.item.pszText,
//                              pitem->pszText, pitem->cchTextMax);
//
LPTSTR CCReturnDispInfoText(LPTSTR pszSrc, LPTSTR pszDest, UINT cchDest)
{
    // Test pszSrc != pszDest first since the common case is that they
    // are equal.
    if (pszSrc != pszDest && !IsFlagPtr(pszSrc) && !IsFlagPtr(pszDest))
        StrCpyN(pszDest, pszSrc, cchDest);
    return pszSrc;
}

#define SUBSCROLLS 100
#define abs(x) ( ( x > 0 ) ? x : -x)


#define DEFAULT_MAXSCROLLTIME ((GetDoubleClickTime() / 2) + 1)  // Ensure >= 1
#define DEFAULT_MINSCROLL 8
int SmoothScrollWindow(PSMOOTHSCROLLINFO psi)
{
    int dx = psi->dx;
    int dy = psi->dy;
    LPCRECT lprcSrc = psi->lprcSrc;
    LPCRECT lprcClip = psi->lprcClip;
    HRGN hrgnUpdate = psi->hrgnUpdate;
    LPRECT lprcUpdate = psi->lprcUpdate;
    UINT fuScroll = psi->fuScroll;
    int iRet = SIMPLEREGION;
    RECT rcUpdate;
    RECT rcSrc;
    RECT rcClip;
    int xStep;
    int yStep;
    int iSlicesDone = 0;
    int iSlices;
    DWORD dwTimeStart, dwTimeNow;
    HRGN hrgnLocalUpdate;
    UINT cxMinScroll = psi->cxMinScroll;
    UINT cyMinScroll = psi->cyMinScroll;
    UINT uMaxScrollTime = psi->uMaxScrollTime;
    int iSubScrolls;
    PFNSMOOTHSCROLLPROC pfnScrollProc;

    if (!lprcUpdate)
        lprcUpdate = &rcUpdate;
    SetRectEmpty(lprcUpdate);

    if (psi->cbSize != sizeof(SMOOTHSCROLLINFO))
        return 0;

    // check the defaults
    if (!(psi->fMask & SSIF_MINSCROLL )
        || cxMinScroll == SSI_DEFAULT)
        cxMinScroll = DEFAULT_MINSCROLL;

    if (!(psi->fMask & SSIF_MINSCROLL)
        || cyMinScroll == SSI_DEFAULT)
        cyMinScroll = DEFAULT_MINSCROLL;

    if (!(psi->fMask & SSIF_MAXSCROLLTIME)
        || uMaxScrollTime == SSI_DEFAULT)
        uMaxScrollTime = DEFAULT_MAXSCROLLTIME;

    if (uMaxScrollTime < SUBSCROLLS)
        uMaxScrollTime = SUBSCROLLS;


    if ((!(fuScroll & SSW_EX_IGNORESETTINGS)) &&
        (!g_fSmoothScroll)) {
        fuScroll |= SSW_EX_IMMEDIATE;
    }

    if ((psi->fMask & SSIF_SCROLLPROC) && psi->pfnScrollProc) {
        pfnScrollProc = psi->pfnScrollProc;
    } else {
        pfnScrollProc = ScrollWindowEx;
    }

#ifdef ScrollWindowEx
#undef ScrollWindowEx
#endif

    if (fuScroll & SSW_EX_IMMEDIATE) {
        return pfnScrollProc(psi->hwnd, dx, dy, lprcSrc, lprcClip, hrgnUpdate,
                             lprcUpdate, LOWORD(fuScroll));
    }

    // copy input rects locally
    if (lprcSrc)  {
        rcSrc = *lprcSrc;
        lprcSrc = &rcSrc;
    }
    if (lprcClip) {
        rcClip = *lprcClip;
        lprcClip = &rcClip;
    }

    if (!hrgnUpdate)
        hrgnLocalUpdate = CreateRectRgn(0,0,0,0);
    else
        hrgnLocalUpdate = hrgnUpdate;

    //set up initial vars
    dwTimeStart = GetTickCount();

    if (fuScroll & SSW_EX_NOTIMELIMIT) {
        xStep = cxMinScroll * (dx < 0 ? -1 : 1);
        yStep = cyMinScroll * (dy < 0 ? -1 : 1);
    } else {
        iSubScrolls = (uMaxScrollTime / DEFAULT_MAXSCROLLTIME) * SUBSCROLLS;
        if (!iSubScrolls)
            iSubScrolls = SUBSCROLLS;
        xStep = dx / iSubScrolls;
        yStep = dy / iSubScrolls;
    }

    if (xStep == 0 && dx)
        xStep = dx < 0 ? -1 : 1;

    if (yStep == 0 && dy)
        yStep = dy < 0 ? -1 : 1;

    while (dx || dy) {
        int x,y;
        RECT rcTempUpdate;

        if (fuScroll & SSW_EX_NOTIMELIMIT) {
            x = xStep;
            y = yStep;
            if (abs(x) > abs(dx))
                x = dx;

            if (abs(y) > abs(dy))
                y = dy;

        } else {
            int iTimePerScroll = uMaxScrollTime / iSubScrolls;
            if (!iTimePerScroll)
                iTimePerScroll = 1;
            
            dwTimeNow = GetTickCount();

            iSlices = ((dwTimeNow - dwTimeStart) / iTimePerScroll) - iSlicesDone;
            if (iSlices < 0)
                iSlices = 0;


            do {

                int iRet = 0;

                iSlices++;
                if ((iSlicesDone + iSlices) <= iSubScrolls) {
                    x = xStep * iSlices;
                    y = yStep * iSlices;

                    // this could go over if we rounded ?Step up to 1(-1) above
                    if (abs(x) > abs(dx))
                        x = dx;

                    if (abs(y) > abs(dy))
                        y = dy;

                } else {
                    x = dx;
                    y = dy;
                }

                //DebugMsg(DM_TRACE, "SmoothScrollWindowCallback %d", iRet);

                if (x == dx && y == dy)
                    break;

                if ((((UINT)(abs(x)) >= cxMinScroll) || !x) &&
                    (((UINT)(abs(y)) >= cyMinScroll) || !y))
                    break;

            } while (1);
        }

        if (pfnScrollProc(psi->hwnd, x, y, lprcSrc, lprcClip, hrgnLocalUpdate, &rcTempUpdate, LOWORD(fuScroll)) == ERROR) {
            iRet = ERROR;
            goto Bail;
        }

        // we don't need to do this always because if iSlices >= iSlicesDone, we'll have scrolled blanks
        //if (iSlices < iSlicesDone)
        RedrawWindow(psi->hwnd, NULL, hrgnLocalUpdate, RDW_ERASE | RDW_ERASENOW | RDW_INVALIDATE);

        UnionRect(lprcUpdate, &rcTempUpdate, lprcUpdate);

        ScrollShrinkRect(x,y, (LPRECT)lprcSrc);
        ScrollShrinkRect(x,y, (LPRECT)lprcClip);

        dx -= x;
        dy -= y;
        iSlicesDone += iSlices;
    }

Bail:

    if (fuScroll & SW_SCROLLCHILDREN) {
        RedrawWindow(psi->hwnd, lprcUpdate, NULL, RDW_INVALIDATE);
    }

    if (hrgnLocalUpdate != hrgnUpdate)
        DeleteObject(hrgnLocalUpdate);

    return iRet;
}



typedef BOOL (WINAPI *PLAYSOUNDFN)(LPCTSTR lpsz, HANDLE hMod, DWORD dwFlags);
typedef UINT (WINAPI *UINTVOIDFN)();

TCHAR const c_szWinMMDll[] = TEXT("winmm.dll");
char const c_szPlaySound[] = "PlaySoundW";
char const c_szwaveOutGetNumDevs[] = "waveOutGetNumDevs";
extern TCHAR const c_szExplorer[];

BOOL g_fNeverPlaySound = FALSE;

void CCPlaySound(LPCTSTR lpszName)
{
    if (g_fNeverPlaySound == FALSE)
    {
        TCHAR szSubKey[MAX_PATH];
        TCHAR szFileName[MAX_PATH];
        DWORD cbFileName = SIZEOF(szFileName);
        TCHAR szFmt[]    = TEXT("AppEvents\\Schemes\\Apps\\.Default\\%s\\.current");

        // check the registry first
        // if there's nothing registered, we blow off the play,
        // but we don't set the MM_DONTLOAD flag so taht if they register
        // something we will play it
        if (ARRAYSIZE(szSubKey) > (lstrlen(szFmt) + lstrlen(lpszName)))
        {
            StringCchPrintf(szSubKey, ARRAYSIZE(szSubKey), szFmt, lpszName);
            if ((RegQueryValue(HKEY_CURRENT_USER, szSubKey, szFileName, &cbFileName) == ERROR_SUCCESS)) 
            {
                PLAYSOUNDFN pfnPlaySound;
                UINTVOIDFN  pfnwaveOutGetNumDevs;
                HANDLE      hMM;
            
                hMM = GetModuleHandle(c_szWinMMDll);
                if (!hMM)
                {
                    hMM = LoadLibrary(c_szWinMMDll);
                }
            
                if (hMM)
                {
                    /// are there any devices?
                    pfnwaveOutGetNumDevs = (UINTVOIDFN)GetProcAddress(hMM, c_szwaveOutGetNumDevs);
                    pfnPlaySound = (PLAYSOUNDFN)GetProcAddress(hMM, c_szPlaySound);

                    if (!pfnPlaySound || !pfnwaveOutGetNumDevs || !pfnwaveOutGetNumDevs())
                    {
                        g_fNeverPlaySound = TRUE;
                    }
                    else
                    {
                        pfnPlaySound(szFileName, NULL, SND_FILENAME | SND_ASYNC);
                    }
                }
            }
        }
    }
}


BOOL CCForwardEraseBackground(HWND hwnd, HDC hdc)
{
    HWND hwndParent = GetParent(hwnd);
    LRESULT lres = 0;

    if (hwndParent)
    {
        // Adjust the origin so the parent paints in the right place
        POINT pt = {0,0};

        MapWindowPoints(hwnd, hwndParent, &pt, 1);
        OffsetWindowOrgEx(hdc, 
                          pt.x, 
                          pt.y, 
                          &pt);

        lres = SendMessage(hwndParent, WM_ERASEBKGND, (WPARAM) hdc, 0L);

        SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
    }
    return(lres != 0);
}

HFONT CCGetHotFont(HFONT hFont, HFONT *phFontHot)
{
    if (!*phFontHot) {
        LOGFONT lf;

        // create the underline font
        GetObject(hFont, sizeof(lf), &lf);
#ifndef DONT_UNDERLINE
        lf.lfUnderline = TRUE;
#endif
        *phFontHot = CreateFontIndirect(&lf);
    }
    return *phFontHot;
}


HFONT CCCreateStatusFont(void)
{
    NONCLIENTMETRICS ncm;

    ncm.cbSize = sizeof(NONCLIENTMETRICS);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(ncm), &ncm, 0);

    return CreateFontIndirect(&ncm.lfStatusFont);
}

void* CCLocalReAlloc(void* p, UINT uBytes)
{
    if (uBytes) {
        if (p) {
            return LocalReAlloc(p, uBytes, LMEM_MOVEABLE | LMEM_ZEROINIT);
        } else {
            return LocalAlloc(LPTR, uBytes);
        }
    } else {
        if (p)
            LocalFree(p);
        return NULL;
    }
}

/*----------------------------------------------------------
Purpose: This function provides the commctrl version info.  This
         allows the caller to distinguish running NT SUR vs.
         Win95 shell vs. Nashville, etc.

         This API was not supplied in Win95 or NT SUR, so
         the caller must GetProcAddress it.  If this fails,
         the caller is running on Win95 or NT SUR.

Returns: NO_ERROR
         ERROR_INVALID_PARAMETER if pinfo is invalid

Cond:    --
*/

// All we have to do is declare this puppy and CCDllGetVersion does the rest
// Note that we use VER_FILEVERSION_DW because comctl32 uses a funky
// version scheme
DLLVER_DUALBINARY(VER_FILEVERSION_DW, VER_PRODUCTBUILD_QFE);

//
// Translate the given font to a code page used for thunking text
//
UINT GetCodePageForFont(HFONT hFont)
{
    LOGFONT lf;
    TCHAR szFontName[LF_FACESIZE];
    CHARSETINFO csi;
    DWORD dwSize, dwType;
    HKEY hKey;


    if (!GetObject (hFont, sizeof(lf), &lf))
    {
        return CP_ACP;
    }


    //
    // Check for font substitutes
    //

    StringCchCopy(szFontName, ARRAYSIZE(szFontName), lf.lfFaceName);

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\FontSubstitutes"),
                     0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(szFontName);
        RegQueryValueEx(hKey, lf.lfFaceName, NULL, &dwType,
                        (LPBYTE) szFontName, &dwSize);

        RegCloseKey (hKey);
    }


    //
    //  This is to fix office for locales that use non 1252 versions
    //  of Ms Sans Serif and Ms Serif.  These fonts incorrectly identify
    //  themselves as having an Ansi charset, so TranslateCharsetInfo will
    //  return the wrong value.
    //
    //  NT bug 260697: Office 2000 uses Tahoma.
    //
    if ((lf.lfCharSet == ANSI_CHARSET) &&
        (!lstrcmpi(L"Helv", szFontName) ||
         !lstrcmpi(L"Ms Sans Serif", szFontName) ||
         !lstrcmpi(L"Ms Serif", szFontName) ||
         !lstrcmpi(L"Tahoma", szFontName)))
    {
        return CP_ACP;
    }
    //
    //  This is to fix FE office95a and Pro. msofe95.dll sets wrong charset when create
    //  listview control. so TranslateCharsetInfo will return the wrong value.
    //  Korea  : DotumChe.
    //  Taiwan : New MingLight
    //  China  : SongTi

    if ((lf.lfCharSet == SHIFTJIS_CHARSET) &&
        (!lstrcmpi(L"\xb3cb\xc6c0\xccb4", lf.lfFaceName))        || // Korea
        (!lstrcmpi(L"\x65b0\x7d30\x660e\x9ad4", lf.lfFaceName))  || // Taiwan
        (!lstrcmpi(L"\x5b8b\x4f53", lf.lfFaceName)))                // PRC
    {
        return CP_ACP;
    }

    if (!TranslateCharsetInfo((DWORD FAR *) lf.lfCharSet, &csi, TCI_SRCCHARSET))
    {
        return CP_ACP;
    }

    return csi.ciACP;
}

typedef void (CALLBACK* NOTIFYWINEVENTPROC)(UINT, HWND, LONG, LONG_PTR);

#define DONOTHING_NOTIFYWINEVENT ((NOTIFYWINEVENTPROC)1)

// --------------------------------------------------------------------------
//
//  MyNotifyWinEvent()
//
//  This tries to get the proc address of NotifyWinEvent().  If it fails, we
//  remember that and do nothing.
//
//  NOTE TO NT FOLKS:
//  Don't worry about this code.  It will do nothing on NT, nothing yet
//  that is.  Active Accessibility will be ported to NT for Service Pack #1
//  or at worst #2 after NT SUR ships, this code will work magically when
//  that is done/
//
// --------------------------------------------------------------------------
void MyNotifyWinEvent(UINT event, HWND hwnd, LONG idContainer, LONG_PTR idChild)
{
    static NOTIFYWINEVENTPROC s_pfnNotifyWinEvent = NULL;

    if (!s_pfnNotifyWinEvent)
    {
        HMODULE hmod;

        if (hmod = GetModuleHandle(TEXT("USER32")))
            s_pfnNotifyWinEvent = (NOTIFYWINEVENTPROC)GetProcAddress(hmod,
                "NotifyWinEvent");

        if (!s_pfnNotifyWinEvent)
            s_pfnNotifyWinEvent = DONOTHING_NOTIFYWINEVENT;
    }

    if (s_pfnNotifyWinEvent != DONOTHING_NOTIFYWINEVENT)
        (* s_pfnNotifyWinEvent)(event, hwnd, idContainer, idChild);
}


LONG GetMessagePosClient(HWND hwnd, LPPOINT ppt)
{
    LPARAM lParam;
    POINT pt;
    if (!ppt)
        ppt = &pt;
    
    lParam = GetMessagePos();
    ppt->x = GET_X_LPARAM(lParam);
    ppt->y = GET_Y_LPARAM(lParam);
    ScreenToClient(hwnd, ppt);

    return MAKELONG(ppt->x, ppt->y);
}


LPTSTR StrDup(LPCTSTR lpsz)
{
    DWORD  cchRet = lstrlen(lpsz) + 1;
    LPTSTR lpszRet = (LPTSTR)LocalAlloc(LPTR, cchRet * sizeof(TCHAR));
    if (lpszRet) 
    {
        StringCchCopy(lpszRet, cchRet, lpsz);
    }
    return lpszRet;
}

LPSTR StrDupA(LPCSTR lpsz)
{
    DWORD cchRet = lstrlenA(lpsz) + 1;
    LPSTR lpszRet = (LPSTR)LocalAlloc(LPTR, cchRet * sizeof(CHAR));
    if (lpszRet) 
    {
        StringCchCopyA(lpszRet, cchRet, lpsz);
    }
    return lpszRet;
}


HWND GetDlgItemRect(HWND hDlg, int nIDItem, LPRECT prc) //relative to hDlg
{
    HWND hCtrl = NULL;
    if (prc)
    {
        hCtrl = GetDlgItem(hDlg, nIDItem);
        if (hCtrl)
        {
            GetWindowRect(hCtrl, prc);
            MapWindowRect(NULL, hDlg, prc);
        }
        else
            SetRectEmpty(prc);
    }
    return hCtrl;
} 


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            hr = pfnri(g_hinst, szSection, NULL);
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


/*----------------------------------------------------------
Purpose: Install/uninstall user settings

*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    if (bInstall)
    {
        // Delete any old registration entries, then add the new ones.
        // Keep ADVPACK.DLL loaded across multiple calls to RegInstall.
        // (The inf engine doesn't guarantee DelReg/AddReg order, that's
        // why we explicitly unreg and reg here.)
        //
        CallRegInstall("RegDll");
    }
    else
    {
        CallRegInstall("UnregDll");
    }

    return S_OK;    
}    



//---------------------------------------------------------------------------------------
void FAR PASCAL FlipRect(LPRECT prc)
{
    SWAP(prc->left, prc->top, int);
    SWAP(prc->right, prc->bottom, int);
}


//---------------------------------------------------------------------------------------
//
//  Returns previous window bits.

DWORD SetWindowBits(HWND hWnd, int iWhich, DWORD dwBits, DWORD dwValue)
{
    DWORD dwStyle;
    DWORD dwNewStyle;

    dwStyle = GetWindowLong(hWnd, iWhich);
    dwNewStyle = ( dwStyle & ~dwBits ) | (dwValue & dwBits);
    if (dwStyle != dwNewStyle) {
        dwStyle = SetWindowLong(hWnd, iWhich, dwNewStyle);
    }
    return dwStyle;
}

//---------------------------------------------------------------------------------------

BOOL CCDrawEdge(HDC hdc, LPRECT lprc, UINT edge, UINT flags, LPCOLORSCHEME lpclrsc)
{
    RECT    rc, rcD;
    UINT    bdrType;
    COLORREF clrTL, clrBR;    

    //
    // Enforce monochromicity and flatness
    //    

    // if (oemInfo.BitCount == 1)
    //    flags |= BF_MONO;
    if (flags & BF_MONO)
        flags |= BF_FLAT;    

    CopyRect(&rc, lprc);

    //
    // Draw the border segment(s), and calculate the remaining space as we
    // go.
    //
    if (bdrType = (edge & BDR_OUTER))
    {
DrawBorder:
        //
        // Get colors.  Note the symmetry between raised outer, sunken inner and
        // sunken outer, raised inner.
        //

        if (flags & BF_FLAT)
        {
            if (flags & BF_MONO)
                clrBR = (bdrType & BDR_OUTER) ? g_clrWindowFrame : g_clrWindow;
            else
                clrBR = (bdrType & BDR_OUTER) ? g_clrBtnShadow: g_clrBtnFace;
            
            clrTL = clrBR;
        }
        else
        {
            // 5 == HILIGHT
            // 4 == LIGHT
            // 3 == FACE
            // 2 == SHADOW
            // 1 == DKSHADOW

            switch (bdrType)
            {
                // +2 above surface
                case BDR_RAISEDOUTER:           // 5 : 4
                    clrTL = ((flags & BF_SOFT) ? g_clrBtnHighlight : g_clr3DLight);
                    clrBR = g_clr3DDkShadow;     // 1
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // +1 above surface
                case BDR_RAISEDINNER:           // 4 : 5
                    clrTL = ((flags & BF_SOFT) ? g_clr3DLight : g_clrBtnHighlight);
                    clrBR = g_clrBtnShadow;       // 2
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnHighlight;
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnShadow;
                    }                                            
                    break;

                // -1 below surface
                case BDR_SUNKENOUTER:           // 1 : 2
                    clrTL = ((flags & BF_SOFT) ? g_clr3DDkShadow : g_clrBtnShadow);
                    clrBR = g_clrBtnHighlight;      // 5
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                // -2 below surface
                case BDR_SUNKENINNER:           // 2 : 1
                    clrTL = ((flags & BF_SOFT) ? g_clrBtnShadow : g_clr3DDkShadow);
                    clrBR = g_clr3DLight;        // 4
                    if (lpclrsc) {
                        if (lpclrsc->clrBtnShadow != CLR_DEFAULT)
                            clrTL = lpclrsc->clrBtnShadow;
                        if (lpclrsc->clrBtnHighlight != CLR_DEFAULT)
                            clrBR = lpclrsc->clrBtnHighlight;                        
                    }
                    break;

                default:
                    return(FALSE);
            }
        }

        //
        // Draw the sides of the border.  NOTE THAT THE ALGORITHM FAVORS THE
        // BOTTOM AND RIGHT SIDES, since the light source is assumed to be top
        // left.  If we ever decide to let the user set the light source to a
        // particular corner, then change this algorithm.
        //
            
        // Bottom Right edges
        if (flags & (BF_RIGHT | BF_BOTTOM))
        {            
            // Right
            if (flags & BF_RIGHT)
            {       
                rc.right -= g_cxBorder;
                // PatBlt(hdc, rc.right, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rcD.left = rc.right;
                rcD.right = rc.right + g_cxBorder;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom;

                FillRectClr(hdc, &rcD, clrBR);
            }
            
            // Bottom
            if (flags & BF_BOTTOM)
            {
                rc.bottom -= g_cyBorder;
                // PatBlt(hdc, rc.left, rc.bottom, rc.right - rc.left, g_cyBorder, PATCOPY);
                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.bottom;
                rcD.bottom = rc.bottom + g_cyBorder;

                FillRectClr(hdc, &rcD, clrBR);
            }
        }
        
        // Top Left edges
        if (flags & (BF_TOP | BF_LEFT))
        {
            // Left
            if (flags & BF_LEFT)
            {
                // PatBlt(hdc, rc.left, rc.top, g_cxBorder, rc.bottom - rc.top, PATCOPY);
                rc.left += g_cxBorder;

                rcD.left = rc.left - g_cxBorder;
                rcD.right = rc.left;
                rcD.top = rc.top;
                rcD.bottom = rc.bottom; 

                FillRectClr(hdc, &rcD, clrTL);
            }
            
            // Top
            if (flags & BF_TOP)
            {
                // PatBlt(hdc, rc.left, rc.top, rc.right - rc.left, g_cyBorder, PATCOPY);
                rc.top += g_cyBorder;

                rcD.left = rc.left;
                rcD.right = rc.right;
                rcD.top = rc.top - g_cyBorder;
                rcD.bottom = rc.top;

                FillRectClr(hdc, &rcD, clrTL);
            }
        }
        
    }

    if (bdrType = (edge & BDR_INNER))
    {
        //
        // Strip this so the next time through, bdrType will be 0.
        // Otherwise, we'll loop forever.
        //
        edge &= ~BDR_INNER;
        goto DrawBorder;
    }

    //
    // Fill the middle & clean up if asked
    //
    if (flags & BF_MIDDLE)    
        FillRectClr(hdc, &rc, (flags & BF_MONO) ? g_clrWindow : g_clrBtnFace);

    if (flags & BF_ADJUST)
        CopyRect(lprc, &rc);

    return(TRUE);
}

//---------------------------------------------------------------------------------------
//CCInvalidateFrame -- SWP_FRAMECHANGED, w/o all the extra params
//
void CCInvalidateFrame(HWND hwnd)
{
    SetWindowPos(hwnd, NULL, 0, 0, 0, 0, SWP_FRAMECHANGED|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_NOACTIVATE);
    return;
}

//---------------------------------------------------------------------------------------
// FlipPoint - flip the x and y coordinates of a point
//
void FlipPoint(LPPOINT lppt)
{
    SWAP(lppt->x, lppt->y, int);
}

//
//  When we want to turn a tooltip into an infotip, we set its
//  width to 300 "small pixels", where there are 72 small pixels
//  per inch when you are in small fonts mode.
//
//  Scale this value based on the magnification in effect
//  on the owner's monitor.  But never let the tooltip get
//  bigger than 3/4 of the screen.
//
void CCSetInfoTipWidth(HWND hwndOwner, HWND hwndToolTips)
{
    HDC hdc = GetDC(hwndOwner);
    int iWidth = MulDiv(GetDeviceCaps(hdc, LOGPIXELSX), 300, 72);
    int iMaxWidth = GetDeviceCaps(hdc, HORZRES) * 3 / 4;
    SendMessage(hwndToolTips, TTM_SETMAXTIPWIDTH, 0, min(iWidth, iMaxWidth));
    ReleaseDC(hwndOwner, hdc);
}

// Mirror a bitmap in a DC (mainly a text object in a DC)
//
// [samera]
//
void MirrorBitmapInDC( HDC hdc , HBITMAP hbmOrig )
{
  HDC     hdcMem;
  HBITMAP hbm;
  BITMAP  bm;


  if( !GetObject( hbmOrig , sizeof(BITMAP) , &bm ))
    return;

  hdcMem = CreateCompatibleDC( hdc );

  if( !hdcMem )
    return;

  hbm = CreateCompatibleBitmap( hdc , bm.bmWidth , bm.bmHeight );

  if( !hbm )
  {
    DeleteDC( hdcMem );
    return;
  }

  //
  // Flip the bitmap
  //
  SelectObject( hdcMem , hbm );
  SET_DC_RTL_MIRRORED(hdcMem);

  BitBlt( hdcMem , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdc , 0 , 0 , SRCCOPY );

  SET_DC_LAYOUT(hdcMem,0);

  //
  // BUGBUG : The offset by 1 is to solve the off-by-one (in hdcMem) problem. Solved.
  // [samera]
  //
  BitBlt( hdc , 0 , 0 , bm.bmWidth , bm.bmHeight ,
          hdcMem , 0 , 0 , SRCCOPY );


  DeleteDC( hdcMem );
  DeleteObject( hbm );

  return;
}

// returns TRUE if handled
BOOL CCWndProc(CONTROLINFO* pci, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plres)
{
    if (uMsg >= CCM_FIRST && uMsg < CCM_LAST) {
        LRESULT lres = 0;
        switch (uMsg) {
        case CCM_SETUNICODEFORMAT:
            lres = pci->bUnicode;
            pci->bUnicode = BOOLFROMPTR(wParam);
            break;

        case CCM_GETUNICODEFORMAT:
            lres = pci->bUnicode;
            break;
            
        case CCM_SETVERSION:
            if (wParam <= COMCTL32_VERSION) {
                lres = pci->iVersion;
                pci->iVersion = (int)wParam;
            } else 
                lres = -1;
            break;
            
        case CCM_GETVERSION:
            lres = pci->iVersion;
            break;

        }
        
        ASSERT(plres);
        *plres = lres;
        
        return TRUE;
    }
    
    return FALSE;
}

// The return value tells if the state changed or not (TRUE == change)
BOOL NEAR PASCAL CCOnUIState(LPCONTROLINFO pControlInfo,
                                  UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    WORD wOldUIState = pControlInfo->wUIState;

    // That's the only message we handle
    if (WM_UPDATEUISTATE == uMessage)
    {
        switch (LOWORD(wParam))
        {
            case UIS_SET:
                pControlInfo->wUIState |= HIWORD(wParam);
                break;

            case UIS_CLEAR:
                pControlInfo->wUIState &= ~(HIWORD(wParam));
                break;
        }
    }

    // These message always need to be passed to DefWindowProc
    return (wOldUIState != pControlInfo->wUIState);
}

BOOL CCNotifyNavigationKeyUsage(LPCONTROLINFO pControlInfo, WORD wFlag)
{
    BOOL fRet = FALSE;

    // do something only if not already in keyboard mode
    if ((CCGetUIState(pControlInfo) & (UISF_HIDEFOCUS | UISF_HIDEACCEL)) != wFlag)
    {
        SendMessage(pControlInfo->hwndParent, WM_CHANGEUISTATE, 
            MAKELONG(UIS_CLEAR, wFlag), 0);

        pControlInfo->wUIState &= ~(HIWORD(wFlag));

        // we did the notify
        fRet = TRUE;
    }

    return fRet;
}

BOOL CCGetUIState(LPCONTROLINFO pControlInfo)
{
    return pControlInfo->wUIState;
}

LONG g_dwWindowCount = 0;

void CCCreateWindow()
{
    if (InterlockedIncrement(&g_dwWindowCount) == 1)
    {
        // If the count goes to one, Refresh the global metrics
        InitGlobalColors();
        InitGlobalMetrics(0);
    }
}

void CCDestroyWindow()
{
    ASSERT( 0 != g_dwWindowCount );
    InterlockedDecrement(&g_dwWindowCount);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\dlgcvt.h ===
#ifndef _INC_COMCTL32_DLGCVT_H
#define _INC_COMCTL32_DLGCVT_H



#ifndef _INC_WINDOWSX
#   include <windowsx.h>
#endif
#ifndef __CCSTOCK_H__
#   include <ccstock.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif 

HRESULT CvtDlgToDlgEx(LPDLGTEMPLATE pTemplate, LPDLGTEMPLATEEX *ppTemplateExOut, int iCharset);

#ifdef __cplusplus
} // extern "C"
#endif



#endif // _INC_COMCTL32_DLGCVT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\dlgcset.cpp ===
//
// File: dlgcset.cpp
//
// This file contains the code that implements CNativeFont class.
//
// history:
//     7-21-97 created; 
// 
#include "ctlspriv.h"
#include "ccontrol.h"

#define THISCLASS CNativeFont
#define SUPERCLASS CControl

typedef enum 
{
    FAS_NOTINITIALIZED = 0,
    FAS_DISABLED,
    FAS_ENABLED,
} FASTATUS;

class CNativeFont : public CControl
{
public:
    //Function Memebers
    virtual LRESULT v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT NativeFontWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
protected:
    
    CNativeFont();
    
    //Function Members    

    virtual void v_OnPaint(HDC hdc) ;
    virtual LRESULT v_OnCreate();
    virtual void v_OnSize(int x, int y)  {};

    virtual LRESULT v_OnCommand(WPARAM wParam, LPARAM lParam);
    virtual LRESULT v_OnNotify(WPARAM wParam, LPARAM lParam);
    virtual DWORD v_OnStyleChanged(WPARAM wParam, LPARAM lParam) { return 0; };    
    
    HRESULT _GetNativeDialogFont(HWND hDlg);
    static HRESULT _GetFontAssocStatus(FASTATUS  *uiAssoced);
    static BOOL _SetFontEnumProc(HWND hwnd, LPARAM lparam);
    static LRESULT _SubclassDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uIdSubclass, ULONG_PTR dwRefData);

    HFONT   m_hfontOrg;
    HFONT   m_hfontNative;
    HFONT   m_hfontDelete;
    typedef struct {
                HFONT hfontSet;
                DWORD dwStyle;
            } NFENUMCHILDDATA;
    static FASTATUS _s_uiFontAssocStatus;
};

// static variable initialization
FASTATUS CNativeFont::_s_uiFontAssocStatus = FAS_NOTINITIALIZED;

// reg keys
static const TCHAR s_szRegFASettings[] = TEXT("System\\CurrentControlSet\\Control\\FontAssoc\\Associated Charset");

CNativeFont::CNativeFont(void)
{
    m_hfontOrg = NULL;
    m_hfontNative = NULL;
    m_hfontDelete = NULL;
}

LRESULT THISCLASS::NativeFontWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CNativeFont *pn = (CNativeFont *)GetWindowLongPtr(hwnd, 0);
    if (uMsg == WM_CREATE) {
        ASSERT(!pn);
        pn = new CNativeFont();
        if (!pn)
            return 0L;
    } 

    if (pn) {
        return pn->v_WndProc(hwnd, uMsg, wParam, lParam);
    }

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void THISCLASS::v_OnPaint(HDC hdc)
{
    return;
}

LRESULT THISCLASS::v_OnCommand(WPARAM wParam, LPARAM lParam)
{
    // forward to parent (do we really need this?)
    return SendMessage(ci.hwndParent, WM_COMMAND, wParam, lParam);
}

LRESULT THISCLASS::v_OnNotify(WPARAM wParam, LPARAM lParam)
{
    // forward to parent
    LPNMHDR lpNmhdr = (LPNMHDR)lParam;
    
    return SendNotifyEx(ci.hwndParent, (HWND) -1,
                         lpNmhdr->code, lpNmhdr, ci.bUnicode);
}

LRESULT THISCLASS::v_OnCreate()
{
    return TRUE;
}

BOOL THISCLASS::_SetFontEnumProc(HWND hwnd, LPARAM lparam)
{
     NFENUMCHILDDATA *  pdt = (NFENUMCHILDDATA *)lparam; 
     BOOL bMatch = FALSE;
     
     if (pdt && pdt->hfontSet)
     {
         if (pdt->dwStyle & NFS_ALL)
         {
             bMatch = TRUE;
         }
         else
         {
             TCHAR szClass[32];
             
             GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
             
             if (pdt->dwStyle & NFS_EDIT)
             {
                 bMatch |= (lstrcmpi(TEXT("Edit"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("RichEdit20A"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("RichEdit20W"), szClass) == 0);
             }
             
             if (pdt->dwStyle & NFS_STATIC)
                 bMatch |= (lstrcmpi(TEXT("Static"), szClass) == 0);
             
             if (pdt->dwStyle & NFS_BUTTON)
                 bMatch |= (lstrcmpi(TEXT("Button"), szClass) == 0);

             if (pdt->dwStyle & NFS_LISTCOMBO)
             {
                 bMatch |= (lstrcmpi(TEXT("ListBox"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("ComboBox"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("ComboBoxEx32"), szClass) == 0);
                 bMatch |= (lstrcmpi(TEXT("SysListView32"), szClass) == 0);
             }
         }

         if (bMatch) 
             SendMessage(hwnd, WM_SETFONT, (WPARAM)pdt->hfontSet, MAKELPARAM(FALSE, 0));

         return TRUE;
     }
     else
         return FALSE;
}

LRESULT THISCLASS::_SubclassDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uIdSubclass, ULONG_PTR dwRefData)
{
    LRESULT lret = 0;
    CNativeFont * pnf = (CNativeFont *)dwRefData;
    
    if (pnf)
    {
    
        switch (uMsg)
        {
            case WM_INITDIALOG:
                // we enumerate its children so they get font 
                // in native charset selected if necessary
                // 
                if (S_OK == pnf->_GetNativeDialogFont(hdlg))
                {
                    // S_OK means we have different charset from 
                    // the default of the platform on which we're 
                    // running.
                    NFENUMCHILDDATA dt;
                    dt.hfontSet = pnf->m_hfontNative;
                    dt.dwStyle = pnf->ci.style;
                    EnumChildWindows(hdlg, pnf->_SetFontEnumProc, (LPARAM)&dt);
                }
                // we no longer need subclass procedure.
                // assumes no one has subclassed this dialog by now
                break;

            case WM_DESTROY:
                // if we've created a font, we have to clean it up.
                if (pnf->m_hfontDelete)
                {
                    NFENUMCHILDDATA dt;
                
                    dt.hfontSet = pnf->m_hfontOrg;
                    dt.dwStyle = pnf->ci.style;
                    // just in case anyone is still alive
                    EnumChildWindows(hdlg, pnf->_SetFontEnumProc, (LPARAM)&dt);
                    DeleteObject(pnf->m_hfontDelete);
                    pnf->m_hfontDelete = NULL;
                }
                RemoveWindowSubclass(hdlg, pnf->_SubclassDlgProc, 0);

                break;
        }
    
        lret = DefSubclassProc(hdlg, uMsg, wParam, lParam);
    }
 
    return lret;
}

LRESULT THISCLASS::v_WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hdlg;
    
    switch (uMsg)
    {
        case WM_CREATE:
        // subclass the parent dialog just to get notified for WM_INITDIALOG
            hdlg = GetParent(hwnd);
            if (hdlg)
            {
                // if we had an error just do nothing, we have to succeed in creating
                // window anyway otherwise dialog fails.
                SetWindowSubclass(hdlg, _SubclassDlgProc, 0, (ULONG_PTR)this);
            }
            break;
    }
    return SUPERCLASS::v_WndProc(hwnd, uMsg, wParam, lParam);
}

// _GetNativeDialogFont
//
// Retreive font handle in platform native character set
//
// returns S_OK if the given dialogbox requires setting font
//              in native charset
//         S_FALSE if the given dialogbox already has native
//              charset.
//         E_FAIL if anyother error occurs
//
HRESULT THISCLASS::_GetNativeDialogFont(HWND hDlg)
{
    HRESULT hres = E_FAIL;
    
    if(!m_hfontNative)
    {
        HFONT hfontNative, hfont = GetWindowFont(hDlg);
        LOGFONT lf, lfNative;
        FASTATUS uiFAStat = FAS_NOTINITIALIZED;
        GetObject(hfont, sizeof(LOGFONT), &lf);

        SystemParametersInfo(SPI_GETICONTITLELOGFONT, sizeof(LOGFONT), &lfNative, 0);
        
        // there are two cases we don't want to create/set font
        // for the platform native character set.
        // 1) we already have matching character set
        // 2) the platform has 'font assoc' enabled or 'font link'
        //    and our client wants to use it instead of
        //    setting the right character set. (NFS_USEFONTASSOC)
        //    this solution sometimes provides better
        //    appearance (thought it is broken in its 
        //    font metrics) because it would use 
        //    'western font' as is.
        if (ci.style & NFS_USEFONTASSOC)
        {
            _GetFontAssocStatus(&uiFAStat);
        }

        if ( uiFAStat == FAS_ENABLED
           || lfNative.lfCharSet == lf.lfCharSet)
        {
                
            m_hfontOrg = m_hfontNative = hfont;
        }
        else
        {
            // we have non-native charset for the platform
            // Save away the original font first.
            m_hfontOrg = hfont;
            
            // Use the height of original dialog font
            lfNative.lfHeight = lf.lfHeight;
            if (!(hfontNative=CreateFontIndirect(&lfNative)))
            {
                hfontNative = hfont;
            }

            // save it away so we can delete it later
            if (hfontNative != hfont)
                m_hfontDelete = hfont;
        
            // set this variable to avoid calling createfont twice
            // if we get called again.
            m_hfontNative = hfontNative;
        }
    }

    return hres = (m_hfontNative == m_hfontOrg ? S_FALSE : S_OK);
}

//
// _GetFontAssocStatus
//
// synopsis: check to see if the platform has "Font Association"
//           enabled or 'Font Link' capability
//
HRESULT THISCLASS::_GetFontAssocStatus(FASTATUS  *puiAssoced)
{
    HRESULT hr = S_OK;
    ASSERT(puiAssoced);
    
    // I assume the setting won't change without rebooting
    // the system
    //
    if (FAS_NOTINITIALIZED == _s_uiFontAssocStatus)
    {
        if (g_bRunOnNT5)
        {
            // NT5 has fontlink functionality
            _s_uiFontAssocStatus = FAS_ENABLED;
        }
        else
        {
            HKEY hkey;
            TCHAR szYesOrNo[16] = {0};
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                              s_szRegFASettings,
                             0, KEY_READ, &hkey) == ERROR_SUCCESS) 
            {
                DWORD dwSize = sizeof(szYesOrNo);
                RegQueryValueEx(hkey, TEXT("ANSI(00)"), 0, NULL, (LPBYTE)szYesOrNo, &dwSize);
                RegCloseKey(hkey);
            }
            else
            {
                // this only indicates the reg func failed
                // we can't always assume the key is there (Western)
                //
                hr = S_FALSE; 
            }
        
            if (SUCCEEDED(hr) && !lstrcmpi(szYesOrNo, TEXT("yes")))
            {
                // font assoc is enabled
                _s_uiFontAssocStatus = FAS_ENABLED;
            }
            else
                _s_uiFontAssocStatus = FAS_DISABLED;
        }
    }
    *puiAssoced = _s_uiFontAssocStatus;

    return hr;
}

extern "C" {
    
BOOL InitNativeFontCtl(HINSTANCE hinst)
{
    WNDCLASS wc;

    wc.lpfnWndProc     = THISCLASS::NativeFontWndProc;
    wc.hCursor         = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon           = NULL;
    wc.lpszMenuName    = NULL;
    wc.hInstance       = hinst;
    wc.lpszClassName   = WC_NATIVEFONTCTL;
    wc.hbrBackground   = (HBRUSH)(COLOR_BTNFACE + 1); // NULL;
    wc.style           = CS_GLOBALCLASS;
    wc.cbWndExtra      = sizeof(LPVOID);
    wc.cbClsExtra      = 0;

    RegisterClass(&wc);

    return TRUE;
}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\dlgcvt.cpp ===
//
// This module provides the following functions:
//
//      CvtDlgToDlgEx - Converts a DLGTEMPLATE to a DLGTEMPLATEEX
//
//
#include "ctlspriv.h"


#include "dlgcvt.h"

//
// Define the amount (bytes) the stream buffer grows when required.
// It will grow enough to satisfy the required write PLUS this
// amount.
//
#ifdef DEBUG
#   define STREAM_GROW_BYTES 32     // Exercise stream growth.
#else
#   define STREAM_GROW_BYTES 512
#endif

//
// Simple MIN/MAX inline helpers.
//

template <class T>
inline const T& MIN(const T& a, const T& b)
{
    return a < b ? a : b;
}

template <class T>
inline const T& MAX(const T& a, const T& b)
{
    return a > b ? a : b;
}

//
// This class implements a simple dynamic stream that grows as you
// add data to it.  It's modeled after the strstream class provided
// by the C++ std lib.  Unlike the std lib implementation, this one
// doesn't require C++ EH to be enabled.  If comctl32 compiled with
// C++ EH enabled, I would have used strstream instead.
// [brianau - 10/5/98]
// 
class CByteStream
{
    public:
        explicit CByteStream(int cbDefGrow = 512);
        ~CByteStream(void);

        //
        // Used as argument to AlignXXXX member functions.
        //
        enum AlignType { eAlignWrite, eAlignRead };
        //
        // Basic read/write functions.
        //
        int Read(LPVOID pb, int cb);
        int Write(const VOID *pb, int cb);
        //
        // Determine if there was an error when reading or 
        // writing to the stream.
        //
        bool ReadError(void) const
            { return m_bReadErr; }

        bool WriteError(void) const
            { return m_bWriteErr; }
        //
        // Reset the stream read or write pointer.
        //
        void ResetRead(void)
            { m_pbRead = m_pbBuf; m_bReadErr = false; }

        void ResetWrite(void)
            { m_pbWrite = m_pbBuf; m_bWriteErr = false; }
        //
        // Reset the stream.
        //
        void Reset(void);
        //
        // These functions align the read and write stream pointers.
        //
        void AlignReadWord(void)
            { Align(eAlignRead, sizeof(WORD)); }

        void AlignReadDword(void)
            { Align(eAlignRead, sizeof(DWORD)); }

        void AlignReadQword(void)
            { Align(eAlignRead, sizeof(ULONGLONG)); }

        void AlignWriteWord(void)
            { Align(eAlignWrite, sizeof(WORD)); }

        void AlignWriteDword(void)
            { Align(eAlignWrite, sizeof(DWORD)); }

        void AlignWriteQword(void)
            { Align(eAlignWrite, sizeof(ULONGLONG)); }

        //
        // GetBuffer returns the address of the stream buffer in memory.
        // The buffer is "frozen" so it will not be released if the stream
        // object is destroyed.  At this point, you own the buffer.
        // If bPermanent is false, you can call ReleaseBuffer to return 
        // control of the buffer to the stream object.
        //
        LPBYTE GetBuffer(bool bPermanent = false);
        //
        // ReleaseBuffer returns control of the buffer obtained with GetBuffer
        // to the stream object.
        //
        bool ReleaseBuffer(LPBYTE pbBuf);
        //
        // Overload the insertion and extraction operators so we can
        // work like a normal std lib stream class.
        //
        template <class T>
        CByteStream& operator >> (T& x)
            { Read(&x, sizeof(x)); return *this; }

        template <class T>
        CByteStream& operator << (const T& x)
            { Write(&x, sizeof(x)); return *this; }

    private:
        int    m_cbDefGrow;  // Default amount (bytes) to grow when expanding buffer.
        LPBYTE m_pbBuf;      // Addr of allocated buffer.
        LPBYTE m_pbRead;     // Addr for next read.
        LPBYTE m_pbWrite;    // Addr for next write.
        LPBYTE m_pbEnd;      // Addr of byte following last byte in buffer.
        bool   m_bWriteErr;  // Any read errors?
        bool   m_bReadErr;   // Any write errors?
        bool   m_bOwnsBuf;   // true == delete buffer in dtor.

        //
        // Expand the buffer as needed.
        //
        bool GrowBuffer(int cb = 0);
        //
        // Align the read or write buffer pointer.
        // Used internally by the AlignXXXXX member functions.
        //
        void Align(AlignType a, size_t n);
        //
        // Internal consistency checks for debug builds.
        //
        void Validate(void) const;
        //
        // Prevent copy.
        //
        CByteStream(const CByteStream& rhs);
        CByteStream& operator = (const CByteStream& rhs);
};


//
// Class for converting in-memory dialog templates between the two
// structures DLGTEMPLATE <-> DLGTEMPLATEEX.
//
// Currently, the object only converts from DLGTEMPLATE -> DLGTEMPLATEEX.
// It would be simple to create the code for the inverse conversion.  However,
// it's currently not needed so I didn't create it.
//
class CDlgTemplateConverter
{
    public:
        explicit CDlgTemplateConverter(int iCharSet = DEFAULT_CHARSET)
            : m_iCharset(iCharSet),
              m_stm(STREAM_GROW_BYTES) { }

        ~CDlgTemplateConverter(void) { }

        HRESULT DlgToDlgEx(LPDLGTEMPLATE pTemplateIn, LPDLGTEMPLATEEX *ppTemplateOut);

        HRESULT DlgExToDlg(LPDLGTEMPLATEEX pTemplateIn, LPDLGTEMPLATE *ppTemplateOut)
            { return E_NOTIMPL; }

    private:
        int         m_iCharset;
        CByteStream m_stm;       // For converted template.

        HRESULT DlgHdrToDlgEx(CByteStream& s, LPWORD *ppw);
        HRESULT DlgItemToDlgEx(CByteStream& s, LPWORD *ppw);
        HRESULT DlgExHdrToDlg(CByteStream& s, LPWORD *ppw)
            { return E_NOTIMPL; }
        HRESULT DlgExItemToDlg(CByteStream& s, LPWORD *ppw)
            { return E_NOTIMPL; }
        //
        // Copy a string from pszW into a CByteStream object.
        // Copies at most cch chars.  If cch is -1, assumes the string is 
        // nul-terminated and will copy all chars in string including
        // terminating NULL.
        //
        int CopyStringW(CByteStream& stm, LPWSTR pszW, int cch = -1);
        //
        // Prevent copy.
        //
        CDlgTemplateConverter(const CDlgTemplateConverter& rhs);
        CDlgTemplateConverter& operator = (const CDlgTemplateConverter& rhs);
};


//
// Generic alignment function.
// Give it an address and an alignment size and it returns
// the address adjusted for the requested alignment.
//
// n :  2 = 16-bit
//      4 = 32-bit
//      8 = 64-bit
//
LPVOID Align(LPVOID pv, size_t n)
{
    const ULONG_PTR x = static_cast<ULONG_PTR>(n) - 1;
    return reinterpret_cast<LPVOID>((reinterpret_cast<ULONG_PTR>(pv) + x) & ~x);
}

inline LPVOID AlignWord(LPVOID pv)
{
    return ::Align(pv, sizeof(WORD));
}

inline LPVOID AlignDWord(LPVOID pv)
{
    return ::Align(pv, sizeof(DWORD));
}

inline LPVOID AlignQWord(LPVOID pv)
{
    return ::Align(pv, sizeof(ULONGLONG));
}



CByteStream::CByteStream(
    int cbDefGrow
    ) : m_cbDefGrow(MAX(cbDefGrow, 1)),
        m_pbBuf(NULL),
        m_pbRead(NULL),
        m_pbWrite(NULL),
        m_pbEnd(NULL),
        m_bWriteErr(false),
        m_bReadErr(false),
        m_bOwnsBuf(true) 
{ 

}


CByteStream::~CByteStream(
    void
    )
{
    if (m_bOwnsBuf && NULL != m_pbBuf)
    {
        LocalFree(m_pbBuf);
    }
}

//
// Simple checks to validate stream state.
// In non-debug builds, this will be a no-op.
// Use ASSERT_VALIDSTREAM macro.
//
void
CByteStream::Validate(
    void
    ) const
{
    ASSERT(m_pbEnd >= m_pbBuf);
    ASSERT(m_pbWrite >= m_pbBuf);
    ASSERT(m_pbRead >= m_pbBuf);
    ASSERT(m_pbWrite <= m_pbEnd);
    ASSERT(m_pbRead <= m_pbEnd);
}

#ifdef DEBUG
#   define ASSERT_VALIDSTREAM(ps)  ps->Validate()
#else
#   define ASSERT_VALIDSTREAM(ps)
#endif

//
// Read "cb" bytes from the stream and write them to 
// the location specified in "pb".  Return number
// of bytes read.  Note that if we don't "own" the
// buffer (i.e. the client has called GetBuffer but
// not ReleaseBuffer), no read will occur.
//
int 
CByteStream::Read(
    LPVOID pb,
    int cb
    )
{
    ASSERT_VALIDSTREAM(this);

    int cbRead = 0;
    if (m_bOwnsBuf)
    {
        cbRead = MIN(static_cast<int>(m_pbEnd - m_pbRead), cb);
        CopyMemory(pb, m_pbRead, cbRead);
        m_pbRead += cbRead;
        if (cb != cbRead)
            m_bReadErr = true;
    }

    ASSERT_VALIDSTREAM(this);

    return cbRead;
}


//
// Write "cb" bytes from location "pb" into the stream.
// Return number of bytes written.  Note that if we don't "own" the
// buffer (i.e. the client has called GetBuffer but
// not ReleaseBuffer), no write will occur.
//
int 
CByteStream::Write(
    const VOID *pb,
    int cb
    )
{
    ASSERT_VALIDSTREAM(this);

    int cbWritten = 0;
    if (m_bOwnsBuf)
    {
        if (m_pbWrite + cb < m_pbEnd || 
            GrowBuffer(static_cast<int>(m_pbEnd - m_pbBuf) + cb + m_cbDefGrow))
        {
            CopyMemory(m_pbWrite, pb, cb);
            m_pbWrite += cb;
            cbWritten = cb;
        }
        else
            m_bWriteErr = true;
    }

    ASSERT_VALIDSTREAM(this);

    return cbWritten;
}

//
// Reallocate the buffer by cb or m_cbDefGrow.
// Copy existing contents to new buffer.  All internal
// pointers are updated.
//
bool 
CByteStream::GrowBuffer(
    int cb               // optional.  Default is 0 causing us to use m_cbDefGrow.
    )
{
    bool bResult         = false;
    int cbGrow           = 0 < cb ? cb : m_cbDefGrow;
    ULONG_PTR ulReadOfs  = m_pbRead - m_pbBuf;
    ULONG_PTR ulWriteOfs = m_pbWrite - m_pbBuf;
    ULONG_PTR cbAlloc    = m_pbEnd - m_pbBuf;
    LPBYTE pNew = static_cast<LPBYTE>(LocalAlloc(LPTR, cbAlloc + cbGrow));
    if (NULL != pNew)
    {
        if (NULL != m_pbBuf)
        {
            CopyMemory(pNew, m_pbBuf, cbAlloc);
            LocalFree(m_pbBuf);
        }
        m_pbBuf   = pNew;
        m_pbRead  = m_pbBuf + ulReadOfs;
        m_pbWrite = m_pbBuf + ulWriteOfs;
        m_pbEnd   = m_pbBuf + cbAlloc + cbGrow;
        bResult   = true;
    }

    ASSERT_VALIDSTREAM(this);
    return bResult;
}

//
// Align the read or write pointer on the stream.
// The write pointer is aligned by padding skipped bytes with 0.
//
void
CByteStream::Align(
    CByteStream::AlignType a,
    size_t n
    )
{
    static const BYTE fill[8] = {0};
    if (m_bOwnsBuf)
    {
        switch(a)
        {
            case eAlignWrite:
                Write(fill, static_cast<int>(reinterpret_cast<LPBYTE>(::Align(m_pbWrite, n)) - m_pbWrite));
                break;

            case eAlignRead:
                m_pbRead = reinterpret_cast<LPBYTE>(::Align(m_pbRead, n));
                if (m_pbRead >= m_pbEnd)
                    m_bReadErr = true;
                break;

            default:
                break;
        }
    }
    ASSERT_VALIDSTREAM(this);
}


//
// Caller takes ownership of the buffer.
//
LPBYTE 
CByteStream::GetBuffer(
    bool bPermanent       // optional.  Default is false.
    )
{ 
    LPBYTE pbRet = m_pbBuf;
    if (bPermanent)
    {
        //
        // Caller now permanently owns the buffer.
        // Can't return it through ReleaseBuffer().
        // Reset the internal stream control values.
        //
        m_pbBuf = m_pbWrite = m_pbRead = m_pbEnd = NULL;
        m_bWriteErr = m_bReadErr = false;
        m_bOwnsBuf = true;
    }
    else
    {
        //
        // Caller now owns the buffer but it can be returned
        // through ReleaseBuffer().
        //
        m_bOwnsBuf = false; 
    }
    return pbRet; 
}


//
// Take back ownership of the buffer.
// Returns:  
//
//      true   = CByteStream object took back ownership.
//      false  = CByteStream object couldn't take ownership.
//
bool 
CByteStream::ReleaseBuffer(
    LPBYTE pbBuf
    )
{
    if (pbBuf == m_pbBuf)
    {
        m_bOwnsBuf = true;
        return true;
    }
    return false;
}
     

//
// Reset the stream.
//
void 
CByteStream::Reset(
    void
    )
{
    if (NULL != m_pbBuf)
    {
        LocalFree(m_pbBuf);
    }
    m_pbBuf = m_pbWrite = m_pbRead = m_pbEnd = NULL;
    m_bWriteErr = m_bReadErr = false;
    m_bOwnsBuf = true;
}


//
// Copy one or more WORDs from the location provided in "pszW" into
// the stream.  If cch is -1, it's assumed that the string is nul-terminated.
// Returns the number of WCHARs written.
//    
int 
CDlgTemplateConverter::CopyStringW(
    CByteStream& stm,
    LPWSTR pszW,
    int cch
    )
{
    if (-1 == cch)
        cch = lstrlenW(pszW) + 1;
    return stm.Write(pszW, cch * sizeof(WCHAR)) / sizeof(WCHAR);
}

//
// Convert a DLGTEMPLATE structure to a DLGTEMPLATEEX structure.
// pti is the address of the DLGTEMPLATE to be converted.
// ppto points to a LPDLGTEMPLATEEX ptr to receive the address of the
// converted template structure.  Caller is responsible for freeing
// this buffer with LocalFree.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgToDlgEx(
    LPDLGTEMPLATE pti,
    LPDLGTEMPLATEEX *ppto
    )
{
    HRESULT hr = NOERROR;
    LPWORD pw = reinterpret_cast<LPWORD>(pti);
    *ppto = NULL;

    //
    // Reset the stream.
    //
    m_stm.Reset();
    //
    // Convert DLGTEMPLATE -> DLGTEMPLATEEX
    //
    hr = DlgHdrToDlgEx(m_stm, &pw);
    //
    // Convert each DLGITEMTEMPLATE -> DLGITEMTEMPLATEEX
    //
    for (int i = 0; i < pti->cdit && SUCCEEDED(hr); i++)
    {
        pw = reinterpret_cast<LPWORD>(::AlignDWord(pw));
        m_stm.AlignWriteDword();
        hr = DlgItemToDlgEx(m_stm, &pw);
    }

    if (SUCCEEDED(hr))
    {
        //
        // Return the buffer to the caller.  Buffer is permanently
        // detached from the stream object so the stream's dtor
        // won't free it.
        //
        *ppto = reinterpret_cast<LPDLGTEMPLATEEX>(m_stm.GetBuffer(true));    
    }
    return hr;
};


//
// Convert DLGTEMPLATE -> DLGTEMPLATEEX
//
// s   = Stream to hold converted template.
// ppw = Address of current read pointer into the template being converted.
//       On exit, the referenced pointer is updated with the current read location.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgHdrToDlgEx(
    CByteStream& s,
    LPWORD *ppw
    )
{
    LPWORD pw = *ppw;
    LPDLGTEMPLATE pt = reinterpret_cast<LPDLGTEMPLATE>(pw);

    //
    // Convert the fixed-length stuff.
    //
    s << static_cast<WORD>(1)                        // wDlgVer
      << static_cast<WORD>(0xFFFF)                   // wSignature
      << static_cast<DWORD>(0)                       // dwHelpID
      << static_cast<DWORD>(pt->dwExtendedStyle)
      << static_cast<DWORD>(pt->style)
      << static_cast<WORD>(pt->cdit)
      << static_cast<short>(pt->x)
      << static_cast<short>(pt->y)
      << static_cast<short>(pt->cx)
      << static_cast<short>(pt->cy);

    //
    // Arrays are always WORD aligned.
    //
    pw = reinterpret_cast<LPWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGTEMPLATE)));
    s.AlignWriteWord();

    //
    // Copy the menu array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            //
            // Fall through...
            //
        case 0x0000:
            s << *pw++;
            break;
                        
        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy the class array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            //
            // Fall through...
            //
        case 0x0000:
            s << *pw++;
            break;
            
        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy the title array.
    //
    switch(*pw)
    {
        case 0x0000:
            s << *pw++;
            break;

        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy font information if it's present.
    //
    if (DS_SETFONT & pt->style)
    {
        s << *pw++;                              // pt size
        s << static_cast<WORD>(FW_NORMAL);       // weight (default, not in DLGTEMPLATE)
        s << static_cast<BYTE>(FALSE);           // italic (default, not in DLGTEMPLATE)
        s << static_cast<BYTE>(m_iCharset);        // charset (default if not given, 
                                                 //          not in DLGTEMPLATE)
        pw += CopyStringW(s, (LPWSTR)pw);
    }

    *ppw = pw;

    return s.WriteError() ? E_OUTOFMEMORY : NOERROR;
}


//
// Convert DLGITEMTEMPLATE -> DLGITEMTEMPLATEEX
//
// s   = Stream to hold converted template.
// ppw = Address of current read pointer into the template being converted.
//       On exit, the referenced pointer is updated with the current read location.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT
CDlgTemplateConverter::DlgItemToDlgEx(
    CByteStream& s,
    LPWORD *ppw
    )
{
    LPWORD pw = *ppw;
    LPDLGITEMTEMPLATE pit = reinterpret_cast<LPDLGITEMTEMPLATE>(pw);

    //
    // Convert the fixed-length stuff.
    //
    s << static_cast<DWORD>(0)                     // dwHelpID
      << static_cast<DWORD>(pit->dwExtendedStyle)
      << static_cast<DWORD>(pit->style)
      << static_cast<short>(pit->x)
      << static_cast<short>(pit->y)
      << static_cast<short>(pit->cx)
      << static_cast<short>(pit->cy)
      << static_cast<DWORD>(pit->id);

    //
    // Arrays are always word aligned.
    //
    pw = reinterpret_cast<LPWORD>(::AlignWord(reinterpret_cast<LPBYTE>(pw) + sizeof(DLGITEMTEMPLATE)));
    s.AlignWriteWord();

    //
    // Copy the class array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            s << *pw++;   // Class code.
            break;
            
        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy the title array.
    //
    switch(*pw)
    {
        case 0xFFFF:
            s << *pw++;
            s << *pw++;   // Resource ordinal value.
            break;
            
        default:
            pw += CopyStringW(s, (LPWSTR)pw);
            break;
    };
    //
    // Copy the creation data.
    // *pw is either 0 or the number of bytes of creation data,
    // including *pw.
    //
    switch(*pw)
    {
        case 0x0000:
            s << *pw++;
            break;

        default:
            pw += s.Write(pw, *pw) / sizeof(WORD);
            break;
    };

    *ppw = pw;

    return s.WriteError() ? E_OUTOFMEMORY : NOERROR;
}


//
// This is the public function for converting a DLGTEMPLATE to
// a DLGTEMPLATEEX.
//
// Returns:  E_OUTOFMEMORY, NOERROR
//
HRESULT 
CvtDlgToDlgEx(
    LPDLGTEMPLATE pTemplate, 
    LPDLGTEMPLATEEX *ppTemplateExOut,
    int iCharset
    )
{
    CDlgTemplateConverter dtc(iCharset);
    return dtc.DlgToDlgEx(pTemplate, ppTemplateExOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\da.c ===
// Dynamic Array APIs
#include "ctlspriv.h"

//
// Heapsort is a bit slower, but it doesn't use any stack or memory...
// Mergesort takes a bit of memory (O(n)) and stack (O(log(n)), but very fast...
//
#define MERGESORT

#ifdef DEBUG
#define DSA_MAGIC   ('S' | ('A' << 8))
#define IsDSA(pdsa) ((pdsa) && (pdsa)->magic == DSA_MAGIC)
#define DPA_MAGIC   ('P' | ('A' << 8))
#define IsDPA(pdpa) ((pdpa) && (pdpa)->magic == DPA_MAGIC)
#else
#define IsDSA(pdsa)
#define IsDPA(pdsa)
#endif


typedef struct {
    void FAR* FAR* pp;
    PFNDPACOMPARE pfnCmp;
    LPARAM lParam;
    int cp;
#ifdef MERGESORT
    void FAR* FAR* ppT;
#endif
} SORTPARAMS;

BOOL NEAR DPA_QuickSort(SORTPARAMS FAR* psp);
BOOL NEAR DPA_QuickSort2(int i, int j, SORTPARAMS FAR* psp);
BOOL NEAR DPA_HeapSort(SORTPARAMS FAR* psp);
void NEAR DPA_HeapSortPushDown(int first, int last, SORTPARAMS FAR* psp);
BOOL NEAR DPA_MergeSort(SORTPARAMS FAR* psp);
void NEAR DPA_MergeSort2(SORTPARAMS FAR* psp, int iFirst, int cItems);



//========== Dynamic structure array ====================================

// Dynamic structure array

typedef struct _DSA {
// NOTE: The following field MUST be defined at the beginning of the
// structure in order for GetItemCount() to work.
//
    int cItem;		// # of elements in dsa

    void FAR* aItem;	// memory for elements
    int cItemAlloc;	// # items which fit in aItem
    int cbItem;		// size of each item
    int cItemGrow;	// # items to grow cItemAlloc by
#ifdef DEBUG
    UINT magic;
#endif
} DSA;

#define DSA_PITEM(pdsa, index)    ((void FAR*)(((BYTE FAR*)(pdsa)->aItem) + ((index) * (pdsa)->cbItem)))


#ifdef DEBUG
#define BF_ONDAVALIDATE     0x00001000

void DABreakFn(void)
{
    if (IsFlagSet(g_dwBreakFlags, BF_ONDAVALIDATE))
        ASSERT(0);
}

#define DABreak()    DABreakFn()
#else
#define DABreak()
#endif


HDSA WINAPI DSA_Create(int cbItem, int cItemGrow)
{
    HDSA pdsa = Alloc(sizeof(DSA));

    ASSERT(cbItem);

    if (pdsa)
    {
        ASSERT(pdsa->cItem == 0);
        ASSERT(pdsa->cItemAlloc == 0);
        pdsa->cbItem = cbItem;
        pdsa->cItemGrow = (cItemGrow == 0 ? 1 : cItemGrow);
        ASSERT(pdsa->aItem == NULL);
#ifdef DEBUG
        pdsa->magic = DSA_MAGIC;
#endif
    }
    return pdsa;
}

BOOL WINAPI DSA_Destroy(HDSA pdsa)
{

    if (pdsa == NULL)       // allow NULL for low memory cases
        return TRUE;

    // Components rely on not having to check for NULL
    ASSERT(IsDSA(pdsa));

#ifdef DEBUG
    pdsa->cItem = 0;
    pdsa->cItemAlloc = 0;
    pdsa->cbItem = 0;
    pdsa->magic = 0;
#endif
    if (pdsa->aItem && !Free(pdsa->aItem))
        return FALSE;

    return Free(pdsa);
}

void WINAPI DSA_EnumCallback(HDSA pdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData)
{
    int i;
    
    if (!pdsa)
        return;
    
    ASSERT(IsDSA(pdsa));

    for (i = 0; i < pdsa->cItem; i++) {
        if (!pfnCB(DSA_GetItemPtr(pdsa, i), pData))
            break;
    }
}

void WINAPI DSA_DestroyCallback(HDSA pdsa, PFNDSAENUMCALLBACK pfnCB, LPVOID pData)
{
    DSA_EnumCallback(pdsa, pfnCB, pData);
    DSA_Destroy(pdsa);
}


BOOL WINAPI DSA_GetItem(HDSA pdsa, int index, void FAR* pitem)
{
    ASSERT(IsDSA(pdsa));
    ASSERT(pitem);

    if (index < 0 || index >= pdsa->cItem)
    {
#ifdef DEBUG
        // Don't assert if index == pdsa->cItems as some clients simply want to walk the list and no need to call getcount...

        if (index != pdsa->cItem)
        {
            DebugMsg(DM_ERROR, TEXT("DSA: GetItem: Invalid index: %d"), index);
            DABreak();
        }
#endif
        return FALSE;
    }

    hmemcpy(pitem, DSA_PITEM(pdsa, index), pdsa->cbItem);
    return TRUE;
}

void FAR* WINAPI DSA_GetItemPtr(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: GetItemPtr: Invalid index: %d"), index);
        // DABreak();   // caller knows 
        return NULL;
    }
    return DSA_PITEM(pdsa, index);
}

BOOL WINAPI DSA_SetItem(HDSA pdsa, int index, void FAR* pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: SetItem: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index >= pdsa->cItem)
    {
        if (index + 1 > pdsa->cItemAlloc)
        {
            int cItemAlloc = (((index + 1) + pdsa->cItemGrow - 1) / pdsa->cItemGrow) * pdsa->cItemGrow;

            void FAR* aItemNew = ReAlloc(pdsa->aItem, cItemAlloc * pdsa->cbItem);
            if (!aItemNew)
                return FALSE;

            pdsa->aItem = aItemNew;
            pdsa->cItemAlloc = cItemAlloc;
        }
        pdsa->cItem = index + 1;
    }

    hmemcpy(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return TRUE;
}

int WINAPI DSA_InsertItem(HDSA pdsa, int index, void FAR* pitem)
{
    ASSERT(pitem);
    ASSERT(IsDSA(pdsa));

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: InsertItem: Invalid index: %d"), index);
        DABreak();
        return -1;
    }

    if (index > pdsa->cItem)
        index = pdsa->cItem;

    if (pdsa->cItem + 1 > pdsa->cItemAlloc)
    {
        void FAR* aItemNew = ReAlloc(pdsa->aItem,
                (pdsa->cItemAlloc + pdsa->cItemGrow) * pdsa->cbItem);
        if (!aItemNew)
            return -1;

        pdsa->aItem = aItemNew;
        pdsa->cItemAlloc += pdsa->cItemGrow;
    }

    if (index < pdsa->cItem)
    {
        hmemcpy(DSA_PITEM(pdsa, index + 1), DSA_PITEM(pdsa, index),
            (pdsa->cItem - index) * pdsa->cbItem);
    }
    pdsa->cItem++;
    hmemcpy(DSA_PITEM(pdsa, index), pitem, pdsa->cbItem);

    return index;
}

BOOL WINAPI DSA_DeleteItem(HDSA pdsa, int index)
{
    ASSERT(IsDSA(pdsa));

    if (index < 0 || index >= pdsa->cItem)
    {
        DebugMsg(DM_ERROR, TEXT("DSA: DeleteItem: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index < pdsa->cItem - 1)
    {
        hmemcpy(DSA_PITEM(pdsa, index), DSA_PITEM(pdsa, index + 1),
            (pdsa->cItem - (index + 1)) * pdsa->cbItem);
    }
    pdsa->cItem--;

    if (pdsa->cItemAlloc - pdsa->cItem > pdsa->cItemGrow)
    {
        void FAR* aItemNew = ReAlloc(pdsa->aItem,
                (pdsa->cItemAlloc - pdsa->cItemGrow) * pdsa->cbItem);
        if (aItemNew)
            pdsa->aItem = aItemNew;
        else
        {
            // If the shrink fails, then just continue with the old (slightly
            // too big) allocation.  Go ahead and let cItemAlloc decrease
            // so we don't keep trying to realloc smaller
        }
        pdsa->cItemAlloc -= pdsa->cItemGrow;
    }
    return TRUE;
}

BOOL WINAPI DSA_DeleteAllItems(HDSA pdsa)
{
    ASSERT(IsDSA(pdsa));

    if (pdsa->aItem && !Free(pdsa->aItem))
        return FALSE;

    pdsa->aItem = NULL;
    pdsa->cItem = pdsa->cItemAlloc = 0;
    return TRUE;
}


//================== Dynamic pointer array implementation ===========

typedef struct _DPA {
// NOTE: The following two fields MUST be defined in this order, at
// the beginning of the structure in order for the macro APIs to work.
//
    int cp;
    void FAR* FAR* pp;

    HANDLE hheap;        // Heap to allocate from if NULL use shared

    int cpAlloc;
    int cpGrow;
#ifdef DEBUG
    UINT magic;
#endif
} DPA;



HDPA WINAPI DPA_Create(int cpGrow)
{
    return DPA_CreateEx(cpGrow, NULL);
}

// Should nuke the standard DPA above...
HDPA WINAPI DPA_CreateEx(int cpGrow, HANDLE hheap)
{
    HDPA pdpa;
    if (hheap == NULL)
    {
        hheap = GetProcessHeap();
        pdpa = ALLOC_NULLHEAP(hheap, sizeof(DPA));
    }
    else
        pdpa = ControlAlloc(hheap, sizeof(DPA));
    if (pdpa)
    {
        ASSERT(pdpa->cp == 0);
        ASSERT(pdpa->cpAlloc == 0);
        pdpa->cpGrow = (cpGrow < 8 ? 8 : cpGrow);
        ASSERT(pdpa->pp == NULL);
        pdpa->hheap = hheap;
#ifdef DEBUG
        pdpa->magic = DPA_MAGIC;
#endif
    }
    return pdpa;
}

BOOL WINAPI DPA_Destroy(HDPA pdpa)
{
    if (pdpa == NULL)       // allow NULL for low memory cases, still assert
        return TRUE;

    ASSERT(IsDPA(pdpa));
    ASSERT(pdpa->hheap);

#ifdef DEBUG
    pdpa->cp = 0;
    pdpa->cpAlloc = 0;
    pdpa->magic = 0;
#endif
    if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))
        return FALSE;

    return ControlFree(pdpa->hheap, pdpa);
}

HDPA WINAPI DPA_Clone(HDPA pdpa, HDPA pdpaNew)
{
    BOOL fAlloc = FALSE;

    if (!pdpaNew)
    {
        pdpaNew = DPA_CreateEx(pdpa->cpGrow, pdpa->hheap);
        if (!pdpaNew)
            return NULL;

        fAlloc = TRUE;
    }

    if (!DPA_Grow(pdpaNew, pdpa->cpAlloc)) {
        if (!fAlloc)
            DPA_Destroy(pdpaNew);
        return NULL;
    }

    pdpaNew->cp = pdpa->cp;
    hmemcpy(pdpaNew->pp, pdpa->pp, pdpa->cp * sizeof(void FAR*));

    return pdpaNew;
}

void FAR* WINAPI DPA_GetPtr(HDPA pdpa, INT_PTR index)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa || index < 0 || index >= pdpa->cp)
        return NULL;

    return pdpa->pp[index];
}

int WINAPI DPA_GetPtrIndex(HDPA pdpa, void FAR* p)
{
    void FAR* FAR* pp;
    void FAR* FAR* ppMax;

    ASSERT(IsDPA(pdpa));
    if (pdpa && pdpa->pp)
    {
        pp = pdpa->pp;
        ppMax = pp + pdpa->cp;
        for ( ; pp < ppMax; pp++)
        {
            if (*pp == p)
                return (int) (pp - pdpa->pp);
        }
    }
    return -1;
}

BOOL WINAPI DPA_Grow(HDPA pdpa, int cpAlloc)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (cpAlloc > pdpa->cpAlloc)
    {
        void FAR* FAR* ppNew;

        cpAlloc = ((cpAlloc + pdpa->cpGrow - 1) / pdpa->cpGrow) * pdpa->cpGrow;

        if (pdpa->pp)
            ppNew = (void FAR* FAR*)ControlReAlloc(pdpa->hheap, pdpa->pp, cpAlloc * sizeof(void FAR*));
        else
            ppNew = (void FAR* FAR*)ControlAlloc(pdpa->hheap, cpAlloc * sizeof(void FAR*));
        if (!ppNew)
            return FALSE;

        pdpa->pp = ppNew;
        pdpa->cpAlloc = cpAlloc;

        //
        // Grow more agressively as we get bigger, up to a maximum of
        // 512 at a time.  Note, we'll only hit our outer bound growth
        // at a time limit once we've already got that many items in the
        // DPA anyway...
        //
        if (pdpa->cpGrow < 256)
        {
            pdpa->cpGrow = pdpa->cpGrow << 1;
        }
    }
    return TRUE;
}

BOOL WINAPI DPA_SetPtr(HDPA pdpa, int index, void FAR* p)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: SetPtr: Invalid index: %d"), index);
        DABreak();
        return FALSE;
    }

    if (index >= pdpa->cp)
    {
        if (!DPA_Grow(pdpa, index + 1))
            return FALSE;
        // If we grew by more than one, must zero-init all the stuff in the middle
        ZeroMemory(pdpa->pp + pdpa->cp, sizeof(LPVOID) * (index - pdpa->cp));
        pdpa->cp = index + 1;
    }

    pdpa->pp[index] = p;

    return TRUE;
}

int WINAPI DPA_InsertPtr(HDPA pdpa, int index, void FAR* p)
{
    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return -1;

    if (index < 0)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: InsertPtr: Invalid index: %d"), index);
        DABreak();
        return -1;
    }
    if (index > pdpa->cp)
        index = pdpa->cp;

    // Make sure we have room for one more item
    //
    if (pdpa->cp + 1 > pdpa->cpAlloc)
    {
        if (!DPA_Grow(pdpa, pdpa->cp + 1))
            return -1;
    }

    // If we are inserting, we need to slide everybody up
    //
    if (index < pdpa->cp)
    {
        hmemcpy(&pdpa->pp[index + 1], &pdpa->pp[index],
            (pdpa->cp - index) * sizeof(void FAR*));
    }

    pdpa->pp[index] = p;
    pdpa->cp++;

    return index;
}

void FAR* WINAPI DPA_DeletePtr(HDPA pdpa, int index)
{
    void FAR* p;

    ASSERT(IsDPA(pdpa));

    if (!pdpa)
        return FALSE;

    if (index < 0 || index >= pdpa->cp)
    {
        DebugMsg(DM_ERROR, TEXT("DPA: DeltePtr: Invalid index: %d"), index);
        DABreak();
        return NULL;
    }

    p = pdpa->pp[index];

    if (index < pdpa->cp - 1)
    {
        hmemcpy(&pdpa->pp[index], &pdpa->pp[index + 1],
            (pdpa->cp - (index + 1)) * sizeof(void FAR*));
    }
    pdpa->cp--;

    if (pdpa->cpAlloc - pdpa->cp > pdpa->cpGrow)
    {
        void FAR* FAR* ppNew;
        ppNew = ControlReAlloc(pdpa->hheap, pdpa->pp, (pdpa->cpAlloc - pdpa->cpGrow) * sizeof(void FAR*));

        if (ppNew)
            pdpa->pp = ppNew;
        else
        {
            // If the shrink fails, then just continue with the old (slightly
            // too big) allocation.  Go ahead and let cpAlloc decrease
            // so we don't keep trying to realloc smaller
        }
        pdpa->cpAlloc -= pdpa->cpGrow;
    }
    return p;
}

BOOL WINAPI DPA_DeleteAllPtrs(HDPA pdpa)
{
    if (!pdpa)
        return FALSE;

    ASSERT(IsDPA(pdpa));

    if (pdpa->pp && !ControlFree(pdpa->hheap, pdpa->pp))
        return FALSE;
    pdpa->pp = NULL;
    pdpa->cp = pdpa->cpAlloc = 0;
    return TRUE;
}

void WINAPI DPA_EnumCallback(HDPA pdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData)
{
    int i;
    
    if (!pdpa)
        return;
    
    ASSERT(IsDPA(pdpa));

    for (i = 0; i < pdpa->cp; i++) {
        if (!pfnCB(DPA_FastGetPtr(pdpa, i), pData))
            break;
    }
}

void WINAPI DPA_DestroyCallback(HDPA pdpa, PFNDPAENUMCALLBACK pfnCB, LPVOID pData)
{
    DPA_EnumCallback(pdpa, pfnCB, pData);
    DPA_Destroy(pdpa);
}


typedef struct _DPASTREAMHEADER
{
    DWORD cbSize;       // Size of entire stream
    DWORD dwVersion;    // For versioning
    int   celem;
} DPASTREAMHEADER;

#define DPASTREAM_VERSION   1


/*----------------------------------------------------------
Purpose: Saves the DPA to a stream by writing out a header,
         and then calling the given callback to write each
         element.

         The callback can end the write early by returning 
         something other than S_OK.  Returning an error will
         cancel the entire write.  Returning S_FALSE will 
         stop the write.

Returns: S_OK or S_FALSE for success.  
         S_FALSE only if callback stops early
         errors
*/
HRESULT
WINAPI
DPA_SaveStream(
    IN HDPA         pdpa,
    IN PFNDPASTREAM pfn,
    IN IStream *    pstm,
    IN LPVOID       pvInstData)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_HANDLE(pdpa, DPA) &&
        IS_VALID_CODE_PTR(pstm, IStream *) &&
        IS_VALID_CODE_PTR(pfn, PFNDPASTREAM))
    {
        DPASTREAMHEADER header;
        LARGE_INTEGER dlibMove = { 0 };
        ULARGE_INTEGER ulPosBegin;

        // Get the current seek position, so we can update the header
        // once we know how much we've written
        hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, &ulPosBegin);
        if (SUCCEEDED(hres))
        {
            // Write the header (we will update some of this once we're
            // finished)
            header.cbSize = 0;
            header.dwVersion = DPASTREAM_VERSION;
            header.celem = 0;

            // First write out the header
            hres = pstm->lpVtbl->Write(pstm, &header, sizeof(header), NULL);

            if (SUCCEEDED(hres))
            {
                DPASTREAMINFO info;
                int cel = DPA_GetPtrCount(pdpa);
                LPVOID * ppv = DPA_GetPtrPtr(pdpa);

                // This keeps the count of what is actually written
                info.iPos = 0;

                // Write each element
                for (; 0 < cel; cel--, ppv++) 
                {
                    info.pvItem = *ppv;
                    hres = pfn(&info, pstm, pvInstData);

                    // Returning S_FALSE from callback means it didn't
                    // write anything for this element, so don't increment 
                    // the iPos (which refers to the count written).

                    if (S_OK == hres)
                        info.iPos++;
                    else if (FAILED(hres))
                    {
                        hres = S_FALSE;
                        break;
                    }
                }

                if (FAILED(hres))
                {
                    // Reposition pointer to beginning
                    dlibMove.LowPart = ulPosBegin.LowPart;
                    dlibMove.HighPart = ulPosBegin.HighPart;
                    pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                }
                else
                {
                    ULARGE_INTEGER ulPosEnd;

                    // Calculate how much was written
                    hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, 
                                              &ulPosEnd);
                    if (SUCCEEDED(hres))
                    {
                        // We only save the low part
                        ASSERT(ulPosEnd.HighPart == ulPosBegin.HighPart);

                        // Update the header
                        header.celem = info.iPos;
                        header.cbSize = ulPosEnd.LowPart - ulPosBegin.LowPart;

                        dlibMove.LowPart = ulPosBegin.LowPart;
                        dlibMove.HighPart = ulPosBegin.HighPart;
                        pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                        pstm->lpVtbl->Write(pstm, &header, sizeof(header), NULL);

                        // Reposition pointer
                        dlibMove.LowPart = ulPosEnd.LowPart;
                        dlibMove.HighPart = ulPosEnd.HighPart;
                        pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                    }
                }
            }
        }
    }

    return hres;
}


/*----------------------------------------------------------
Purpose: Loads the DPA from a stream by calling the given callback 
         to read each element.

         The callback can end the read early by returning 
         something other than S_OK.  

Returns: S_OK on success
         S_FALSE if the callback aborted early or the stream ended
           abruptly. DPA is partially filled.
         error on anything else
*/
HRESULT
WINAPI
DPA_LoadStream(
    OUT HDPA *      ppdpa,
    IN PFNDPASTREAM pfn,
    IN IStream *    pstm,
    IN LPVOID       pvInstData)
{
    HRESULT hres = E_INVALIDARG;

    if (IS_VALID_WRITE_PTR(ppdpa, HDPA) &&
        IS_VALID_CODE_PTR(pstm, IStream *) &&
        IS_VALID_CODE_PTR(pfn, PFNDPASTREAM))
    {
        DPASTREAMHEADER header;
        LARGE_INTEGER dlibMove = { 0 };
        ULARGE_INTEGER ulPosBegin;
        ULONG cbRead;

        *ppdpa = NULL;

        // Get the current seek position so we can position pointer 
        // correctly upon error.
        hres = pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_CUR, &ulPosBegin);
        if (SUCCEEDED(hres))
        {
            // Read the header
            hres = pstm->lpVtbl->Read(pstm, &header, sizeof(header), &cbRead);
            if (SUCCEEDED(hres))
            {
                if (sizeof(header) > cbRead ||
                    sizeof(header) > header.cbSize ||
                    DPASTREAM_VERSION != header.dwVersion)
                {
                    hres = E_FAIL;
                }
                else
                {
                    // Create the list 
                    HDPA pdpa = DPA_Create(header.celem);
                    if ( !pdpa || !DPA_Grow(pdpa, header.celem))
                        hres = E_OUTOFMEMORY;
                    else
                    {
                        // Read each element
                        DPASTREAMINFO info;
                        LPVOID * ppv = DPA_GetPtrPtr(pdpa);

                        for (info.iPos = 0; info.iPos < header.celem; ) 
                        {
                            info.pvItem = NULL;
                            hres = pfn(&info, pstm, pvInstData);

                            // Returning S_FALSE from the callback means
                            // it skipped this stream element.
                            // Don't increment iPos (which refers to the
                            // count read).
                            if (S_OK == hres)
                            {
                                *ppv = info.pvItem;

                                info.iPos++;
                                ppv++;    
                            }
                            else if (FAILED(hres))
                            {
                                hres = S_FALSE;
                                break;
                            }
                        }

                        pdpa->cp = info.iPos;
                        *ppdpa = pdpa;
                    }
                }

                // Reposition pointer if we failed
                if (S_OK != hres)
                {
                    if (S_FALSE == hres)
                    {
                        // Position pointer to the end
                        dlibMove.LowPart = ulPosBegin.LowPart + header.cbSize;
                    }
                    else
                    {
                        // Position pointer to beginning 
                        dlibMove.LowPart = ulPosBegin.LowPart;
                    }
                    dlibMove.HighPart = ulPosBegin.HighPart;
                    pstm->lpVtbl->Seek(pstm, dlibMove, STREAM_SEEK_SET, NULL);
                }
            }
        }

        ASSERT(SUCCEEDED(hres) && *ppdpa ||
               FAILED(hres) && NULL == *ppdpa);
    }

    return hres;
}



/*----------------------------------------------------------
Purpose: Merge two DPAs.  This takes two arrays and merges the
         source array into the destination.   

         Merge options:

          DPAM_SORTED       The arrays are already sorted; don't sort
          DPAM_UNION        The resulting array is the union of all elements
                            in both arrays.
          DPAM_INTERSECT    Only elements in the source array that intersect
                            with the dest array are merged.  
          DPAM_NORMAL       Like DPAM_INTERSECT except the dest array 
                            also maintains its original, additional elements.


Returns: S_OK for success.  
         errors if merge fails

Cond:    --
*/
BOOL
WINAPI
DPA_Merge(
    IN HDPA          pdpaDest,
    IN HDPA          pdpaSrc,
    IN DWORD         dwFlags,
    IN PFNDPACOMPARE pfnCompare,
    IN PFNDPAMERGE   pfnMerge,
    IN LPARAM        lParam)
{
    BOOL bRet = FALSE;

    if (IS_VALID_HANDLE(pdpaSrc, DPA) &&
        IS_VALID_HANDLE(pdpaDest, DPA) &&
        IS_VALID_CODE_PTR(pfnCompare, PFNDPACOMPARE) &&
        IS_VALID_CODE_PTR(pfnMerge, PFNDPAMERGE))
    {
        int iSrc;
        int iDest;
        int nCmp;
        LPVOID * ppvSrc;
        LPVOID * ppvDest;

        bRet = TRUE;

        // Are the arrays already sorted?
        if ( !(dwFlags & DPAM_SORTED) )
        {
            // No; sort them
            DPA_Sort(pdpaSrc, pfnCompare, lParam);
            DPA_Sort(pdpaDest, pfnCompare, lParam);
        }

        // This merges in-place. The size of the resulting DPA 
        // depends on the options:
        //
        //   DPAM_NORMAL    Same size as the dest DPA before 
        //                  the merge.  
        //
        //   DPAM_UNION     Min size is the larger of the two.
        //                  Max size is the sum of the two.
        //
        //   DPAM_INTERSECT Min size is zero.
        //                  Max size is the smaller of the two.
        // 
        // We iterate backwards to minimize the amount of moves we 
        // incur by calling DPA_DeletePtr.
        //

        iSrc = pdpaSrc->cp - 1;
        iDest = pdpaDest->cp - 1;
        ppvSrc = &DPA_FastGetPtr(pdpaSrc, iSrc);
        ppvDest = &DPA_FastGetPtr(pdpaDest, iDest);

        while (0 <= iSrc && 0 <= iDest)
        {
            LPVOID pv;

            nCmp = pfnCompare(*ppvDest, *ppvSrc, lParam);

            if (0 == nCmp)
            {
                // Elements match; merge them.  
                pv = pfnMerge(DPAMM_MERGE, *ppvDest, *ppvSrc, lParam);
                if (NULL == pv)
                {
                    bRet = FALSE;
                    break;
                }
                *ppvDest = pv;

                iSrc--;
                ppvSrc--;
                iDest--;
                ppvDest--;
            }
            else if (0 < nCmp)
            {
                // pvSrc < pvDest. The source array doesn't have pvDest.
                if (dwFlags & DPAM_INTERSECT)
                {
                    // Delete pvDest 
                    pfnMerge(DPAMM_DELETE, DPA_DeletePtr(pdpaDest, iDest), NULL, lParam);
                }
                else
                {
                    ; // Keep it (do nothing)
                }

                // Move onto the next element in the dest array
                iDest--;
                ppvDest--;
            }
            else
            {
                // pvSrc > pvDest. The dest array doesn't have pvSrc.
                if (dwFlags & DPAM_UNION)
                {
                    // Add pvSrc
                    pv = pfnMerge(DPAMM_INSERT, *ppvSrc, NULL, lParam);
                    if (NULL == pv)
                    {
                        bRet = FALSE;
                        break;
                    }

                    DPA_InsertPtr(pdpaDest, iDest+1, pv);
                    // DPA_InsertPtr may end up reallocating the pointer array
                    // thus making ppvDest invalid
                    ppvDest = &DPA_FastGetPtr(pdpaDest, iDest);
                }
                else
                {
                    ;  // Skip it (do nothing)
                }

                // Move onto the next element in the source array
                iSrc--;
                ppvSrc--;
            }
        }
        // there are some items left in src
        if ((dwFlags & DPAM_UNION) && 0 <= iSrc)
        {
            for (; 0 <= iSrc; iSrc--, ppvSrc--)
            {
                LPVOID pv = pfnMerge(DPAMM_INSERT, *ppvSrc, NULL, lParam);
                if (NULL == pv)
                {
                    bRet = FALSE;
                    break;
                }
                DPA_InsertPtr(pdpaDest, 0, pv);
            }
        }
    }

    return bRet;
}


BOOL WINAPI DPA_Sort(HDPA pdpa, PFNDPACOMPARE pfnCmp, LPARAM lParam)
{
    SORTPARAMS sp;

    sp.cp = pdpa->cp;
    sp.pp = pdpa->pp;
    sp.pfnCmp = pfnCmp;
    sp.lParam = lParam;

#ifdef USEQUICKSORT
    return DPA_QuickSort(&sp);
#endif
#ifdef USEHEAPSORT
    return DPA_HeapSort(&sp);
#endif
#ifdef MERGESORT
    return DPA_MergeSort(&sp);
#endif
}

#ifdef USEQUICKSORT

BOOL NEAR DPA_QuickSort(SORTPARAMS FAR* psp)
{
    return DPA_QuickSort2(0, psp->cp - 1, psp);
}

BOOL NEAR DPA_QuickSort2(int i, int j, SORTPARAMS FAR* psp)
{
    void FAR* FAR* pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;

    int iPivot;
    void FAR* pFirst;
    int k;
    int result;

    iPivot = -1;
    pFirst = pp[i];
    for (k = i + 1; k <= j; k++)
    {
        result = (*pfnCmp)(pp[k], pFirst, lParam);

        if (result > 0)
        {
            iPivot = k;
            break;
        }
        else if (result < 0)
        {
            iPivot = i;
            break;
        }
    }

    if (iPivot != -1)
    {
        int l = i;
        int r = j;
        void FAR* pivot = pp[iPivot];

        do
        {
            void FAR* p;

            p = pp[l];
            pp[l] = pp[r];
            pp[r] = p;

            while ((*pfnCmp)(pp[l], pivot, lParam) < 0)
                l++;
            while ((*pfnCmp)(pp[r], pivot, lParam) >= 0)
                r--;
        } while (l <= r);

        if (l - 1 > i)
            DPA_QuickSort2(i, l - 1, psp);
        if (j > l)
            DPA_QuickSort2(l, j, psp);
    }
    return TRUE;
}
#endif  // USEQUICKSORT

#ifdef USEHEAPSORT

void NEAR DPA_HeapSortPushDown(int first, int last, SORTPARAMS FAR* psp)
{
    void FAR* FAR* pp = psp->pp;
    LPARAM lParam = psp->lParam;
    PFNDPACOMPARE pfnCmp = psp->pfnCmp;
    int r;
    int r2;
    void FAR* p;

    r = first;
    while (r <= last / 2)
    {
        int wRTo2R;
        r2 = r * 2;

        wRTo2R = (*pfnCmp)(pp[r-1], pp[r2-1], lParam);

        if (r2 == last)
        {
            if (wRTo2R < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
            }
            break;
        }
        else
        {
            int wR2toR21 = (*pfnCmp)(pp[r2-1], pp[r2+1-1], lParam);

            if (wRTo2R < 0 && wR2toR21 >= 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2-1]; pp[r2-1] = p;
                r = r2;
            }
            else if ((*pfnCmp)(pp[r-1], pp[r2+1-1], lParam) < 0 && wR2toR21 < 0)
            {
                p = pp[r-1]; pp[r-1] = pp[r2+1-1]; pp[r2+1-1] = p;
                r = r2 + 1;
            }
            else
            {
                break;
            }
        }
    }
}

BOOL NEAR DPA_HeapSort(SORTPARAMS FAR* psp)
{
    void FAR* FAR* pp = psp->pp;
    int c = psp->cp;
    int i;

    for (i = c / 2; i >= 1; i--)
        DPA_HeapSortPushDown(i, c, psp);

    for (i = c; i >= 2; i--)
    {
        void FAR* p = pp[0]; pp[0] = pp[i-1]; pp[i-1] = p;

        DPA_HeapSortPushDown(1, i - 1, psp);
    }
    return TRUE;
}
#endif  // USEHEAPSORT

#if defined(MERGESORT)

#define SortCompare(psp, pp1, i1, pp2, i2) \
    (psp->pfnCmp(pp1[i1], pp2[i2], psp->lParam))

//
//  This function merges two sorted lists and makes one sorted list.
//   psp->pp[iFirst, iFirst+cItes/2-1], psp->pp[iFirst+cItems/2, iFirst+cItems-1]
//
void NEAR DPA_MergeThem(SORTPARAMS FAR* psp, int iFirst, int cItems)
{
    //
    // Notes:
    //  This function is separated from DPA_MergeSort2() to avoid comsuming
    // stack variables. Never inline this.
    //
    int cHalf = cItems/2;
    int iIn1, iIn2, iOut;
    LPVOID * ppvSrc = &psp->pp[iFirst];

    // Copy the first part to temp storage so we can write directly into
    // the final buffer.  Note that this takes at most psp->cp/2 DWORD's
    hmemcpy(psp->ppT, ppvSrc, cHalf*sizeof(LPVOID));

    for (iIn1=0, iIn2=cHalf, iOut=0;;)
    {
        if (SortCompare(psp, psp->ppT, iIn1, ppvSrc, iIn2) <= 0) {
            ppvSrc[iOut++] = psp->ppT[iIn1++];

            if (iIn1==cHalf) {
                // We used up the first half; the rest of the second half
                // should already be in place
                break;
            }
        } else {
            ppvSrc[iOut++] = ppvSrc[iIn2++];
            if (iIn2==cItems) {
                // We used up the second half; copy the rest of the first half
                // into place
                hmemcpy(&ppvSrc[iOut], &psp->ppT[iIn1], (cItems-iOut)*sizeof(LPVOID));
                break;
            }
        }
    }
}

//
//  This function sorts a give list (psp->pp[iFirst,iFirst-cItems-1]).
//
void NEAR DPA_MergeSort2(SORTPARAMS FAR* psp, int iFirst, int cItems)
{
    //
    // Notes:
    //   This function is recursively called. Therefore, we should minimize
    //  the number of local variables and parameters. At this point, we
    //  use one local variable and three parameters.
    //
    int cHalf;

    switch(cItems)
    {
    case 1:
        return;

    case 2:
        // Swap them, if they are out of order.
        if (SortCompare(psp, psp->pp, iFirst, psp->pp, iFirst+1) > 0)
        {
            psp->ppT[0] = psp->pp[iFirst];
            psp->pp[iFirst] = psp->pp[iFirst+1];
            psp->pp[iFirst+1] = psp->ppT[0];
        }
        break;

    default:
        cHalf = cItems/2;

        // Sort each half
        DPA_MergeSort2(psp, iFirst, cHalf);
        DPA_MergeSort2(psp, iFirst+cHalf, cItems-cHalf);
        // Then, merge them.
        DPA_MergeThem(psp, iFirst, cItems);
        break;
    }
}

BOOL NEAR DPA_MergeSort(SORTPARAMS FAR* psp)
{
    if (psp->cp==0)
        return TRUE;

    // Note that we divide by 2 below; we want to round down
    psp->ppT = LocalAlloc(LPTR, psp->cp/2 * sizeof(LPVOID));
    if (!psp->ppT)
        return FALSE;

    DPA_MergeSort2(psp, 0, psp->cp);
    LocalFree(psp->ppT);
    return TRUE;
}
#endif // MERGESORT

// Search function
//
int WINAPI DPA_Search(HDPA pdpa, void FAR* pFind, int iStart,
            PFNDPACOMPARE pfnCompare, LPARAM lParam, UINT options)
{
    int cp = DPA_GetPtrCount(pdpa);

    ASSERT(pfnCompare);
    ASSERT(0 <= iStart);

    // Only allow these wierd flags if the list is sorted
    ASSERT((options & DPAS_SORTED) || !(options & (DPAS_INSERTBEFORE | DPAS_INSERTAFTER)));

    if (!(options & DPAS_SORTED))
    {
        // Not sorted: do linear search.
        int i;

        for (i = iStart; i < cp; i++)
        {
            if (0 == pfnCompare(pFind, DPA_FastGetPtr(pdpa, i), lParam))
                return i;
        }
        return -1;
    }
    else
    {
        // Search the array using binary search.  If several adjacent
        // elements match the target element, the index of the first
        // matching element is returned.

        int iRet = -1;      // assume no match
        BOOL bFound = FALSE;
        int nCmp = 0;
        int iLow = 0;       // Don't bother using iStart for binary search
        int iMid = 0;
        int iHigh = cp - 1;

        // (OK for cp == 0)
        while (iLow <= iHigh)
        {
            iMid = (iLow + iHigh) / 2;

            nCmp = pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid), lParam);

            if (0 > nCmp)
                iHigh = iMid - 1;       // First is smaller
            else if (0 < nCmp)
                iLow = iMid + 1;        // First is larger
            else
            {
                // Match; search back for first match
                bFound = TRUE;
                while (0 < iMid)
                {
                    if (0 != pfnCompare(pFind, DPA_FastGetPtr(pdpa, iMid-1), lParam))
                        break;
                    else
                        iMid--;
                }
                break;
            }
        }

        if (bFound)
        {
            ASSERT(0 <= iMid);
            iRet = iMid;
        }

        // Did the search fail AND
        // is one of the strange search flags set?
        if (!bFound && (options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)))
        {
            // Yes; return the index where the target should be inserted
            // if not found
            if (0 < nCmp)       // First is larger
                iRet = iLow;
            else
                iRet = iMid;
            // (We don't distinguish between the two flags anymore)
        }
        else if ( !(options & (DPAS_INSERTAFTER | DPAS_INSERTBEFORE)) )
        {
            // Sanity check with linear search
            ASSERT(DPA_Search(pdpa, pFind, iStart, pfnCompare, lParam, options & ~DPAS_SORTED) == iRet);
        }
        return iRet;
    }
}

//===========================================================================
//
// String ptr management routines
//
// Copy as much of *psz to *pszBuf as will fit
//
// Warning:  this same code is duplicated below.
//
int WINAPI Str_GetPtr(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf)
{
    int cchToCopy;

    if (!pszCurrent)
    {
        ASSERT(FALSE);
        
        if (cchBuf > 0)
            *pszBuf = TEXT('\0');

        return 0;
    }

    cchToCopy = lstrlen(pszCurrent);

    // if pszBuf is NULL, or they passed cchBuf = 0, return the needed buff size
    if (!pszBuf || !cchBuf)
        return cchToCopy + 1;
    
    if (cchToCopy >= cchBuf)
        cchToCopy = cchBuf - 1;

    hmemcpy(pszBuf, pszCurrent, cchToCopy * SIZEOF(TCHAR));
    pszBuf[cchToCopy] = TEXT('\0');

    return cchToCopy + 1;
}

#ifdef DEBUG
//
//  Str_GetPtr0 is just like Str_GetPtr except that it doesn't assert if
//  pszCurrent = NULL.
//
int WINAPI Str_GetPtr0(LPCTSTR pszCurrent, LPTSTR pszBuf, int cchBuf)
{
    return Str_GetPtr(pszCurrent ? pszCurrent : c_szNULL, pszBuf, cchBuf);
}
#endif

//
// If we are build Unicode, then this is the ANSI version
// of the above function.
//

int WINAPI Str_GetPtrA(LPCSTR pszCurrent, LPSTR pszBuf, int cchBuf)
{
    int cchToCopy;

    if (!pszCurrent)
    {
        ASSERT(FALSE);

        if (cchBuf > 0)
            *pszBuf = '\0';

        return 0;
    }

    cchToCopy = lstrlenA(pszCurrent);

    // if pszBuf is NULL, or they passed cchBuf = 0, return the needed buff size
    if (!pszBuf || !cchBuf)
        return cchToCopy + 1;
    
    if (cchToCopy >= cchBuf)
        cchToCopy = cchBuf - 1;

    // BUGBUG: Must call TruncateString, as we may be in the middle of DBCS char
    hmemcpy(pszBuf, pszCurrent, cchToCopy * SIZEOF(CHAR));
    pszBuf[cchToCopy] = TEXT('\0');

    return cchToCopy + 1;
}


//
// This function is not exported.
//

BOOL Str_Set(LPTSTR *ppsz, LPCTSTR psz)
{
    if (!psz || (psz == LPSTR_TEXTCALLBACK))
    {
        if (*ppsz)
        {
            if (*ppsz != (LPSTR_TEXTCALLBACK))
                LocalFree(*ppsz);
        }
        *ppsz = (LPTSTR)psz;
    }
    else
    {
        LPTSTR pszNew = *ppsz;
        UINT cbNew = (lstrlen(psz) + 1) * sizeof(TCHAR);

        if (pszNew == LPSTR_TEXTCALLBACK)
            pszNew = NULL;
        
        pszNew = CCLocalReAlloc(pszNew, cbNew);

        if (!pszNew)
            return FALSE;

        StringCbCopy(pszNew, cbNew, psz);
        *ppsz = pszNew;
    }
    return TRUE;
}

// Set *ppszCurrent to a copy of pszNew, and free the previous value, if necessary
//
// WARNING:  This same code is duplicated below
//
BOOL WINAPI Str_SetPtr(LPTSTR * ppszCurrent, LPCTSTR pszNew)
{
    LPTSTR pszOld;
    LPTSTR pszNewCopy = NULL;

    if (pszNew)
    {
        int cchNewCopy = lstrlen(pszNew);

        // alloc a new buffer w/ room for the null terminator
        pszNewCopy = (LPTSTR) Alloc((cchNewCopy + 1) * SIZEOF(TCHAR));

        if (!pszNewCopy)
            return FALSE;

        StringCchCopy(pszNewCopy, cchNewCopy+1, pszNew);
    }
    
    pszOld = InterlockedExchangePointer((LPVOID *)ppszCurrent, pszNewCopy);

    if (pszOld)
        Free(pszOld);

    return TRUE;
}

BOOL WINAPI Str_SetPtrA(LPSTR * ppszCurrent, LPCSTR pszNew)
{
    LPSTR pszOld;
    LPSTR pszNewCopy = NULL;

    if (pszNew)
    {
        int cchNewCopy = lstrlenA(pszNew);

        // alloc a new buffer w/ room for the null terminator
        pszNewCopy = (LPSTR) Alloc((cchNewCopy + 1) * SIZEOF(CHAR));

        if (!pszNewCopy)
            return FALSE;

        StringCchCopyA(pszNewCopy, cchNewCopy+1, pszNew);
    }

    pszOld = InterlockedExchangePointer((LPVOID *)ppszCurrent, pszNewCopy);

    if (pszOld)
        Free(pszOld);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\ddproxy.cpp ===
#include "ctlspriv.h"
#include "olestuff.h"

//------------------------------------------------------------------------------

STDAPI GetItemObject(CONTROLINFO *pci, UINT uMsg, const IID *piid, LPNMOBJECTNOTIFY pnon)
{
    pnon->piid = piid;
    pnon->pObject = NULL;
    pnon->hResult = E_NOINTERFACE;

    CCSendNotify(pci, uMsg, &pnon->hdr);

    ASSERT(SUCCEEDED(pnon->hResult) ? (pnon->pObject != NULL) : (pnon->pObject == NULL));
    
    return pnon->hResult;
}

//------------------------------------------------------------------------------

class CDragProxy : public IDropTarget
{

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IDropTarget
    STDMETHODIMP DragEnter(IDataObject *, DWORD, POINTL, DWORD *);
    STDMETHODIMP DragOver(DWORD, POINTL, DWORD *);
    STDMETHODIMP DragLeave();
    STDMETHODIMP Drop(IDataObject *, DWORD, POINTL, DWORD *);

    CDragProxy(HWND hwnd, PFNDRAGCB pfn);
    BOOL Register();
    void RevokeAndFreeCB();

private:
    ~CDragProxy();

    int          _cRef;             // object reference count
    HWND         _hwnd;             // window that owns us
    PFNDRAGCB    _pfnCallback;      // callback for that window
    IDataObject *_pdtobj;           // data object being dragged
    IDropTarget *_pdtgtItem;        // drop target of item under mouse
    int          _idItem;           // id of item under mouse
    DWORD        _dwFlags;
    int          _idDefault;        // id to use when outside a drag etc
    DWORD        _dwEffectItem;     // DROPEFFECT returned for item under mouse
    DWORD        _fKeysLast;        // key flags from last DragOver
    POINTL       _ptLast;           // location of last DragOver
    DWORD        _dwEffectLast;     // effect available from last DragOver
    HMODULE      _hmodOLE;          // OLE32 ref, also indicates we did a Register()

    void SetTargetItem(int id, DWORD dwFlags);
    void SetDropTarget(IDropTarget *pdt);
    void UpdateSelection(DWORD dwEffect);
    LRESULT CallCB(UINT code, WPARAM wp, LPARAM lp);
};

//------------------------------------------------------------------------------

STDAPI_(HDRAGPROXY) CreateDragProxy(HWND hwnd, PFNDRAGCB pfn, BOOL bRegister)
{
    CDragProxy *pdp = new CDragProxy(hwnd, pfn);

    //
    // register as needed
    //
    if (pdp && bRegister && !pdp->Register())
    {
        pdp->Release();
        pdp = NULL;
    }

    return (HDRAGPROXY)pdp;
}

STDAPI_(void) DestroyDragProxy(HDRAGPROXY hdp)
{
    if (hdp)
    {
        ((CDragProxy *)hdp)->RevokeAndFreeCB();
        ((CDragProxy *)hdp)->Release();
    }
}

STDAPI GetDragProxyTarget(HDRAGPROXY hdp, IDropTarget **ppdtgt)
{
    if (hdp)
    {
        *ppdtgt = SAFECAST((CDragProxy *)hdp, IDropTarget *);
        ((CDragProxy *)hdp)->AddRef();
        return NOERROR;
    }

    *ppdtgt = NULL;
    return E_FAIL;
}


//------------------------------------------------------------------------------

CDragProxy::CDragProxy(HWND hwnd, PFNDRAGCB pfn)
    :   _hwnd(hwnd), _pfnCallback(pfn),
        _cRef(1), 
        _hmodOLE(NULL),
        _pdtobj(NULL), 
        _pdtgtItem(NULL),
        _dwEffectItem(DROPEFFECT_NONE)
{
    _idDefault = _idItem = (int)CallCB(DPX_DRAGHIT, 0, 0);
}

CDragProxy::~CDragProxy()
{
    DragLeave();

}

HRESULT CDragProxy::QueryInterface(REFIID iid, void **ppv)
{
    if (IsEqualIID(iid, IID_IDropTarget) || IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = SAFECAST(this, IDropTarget *);
    }
    else 
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    _cRef++;
    return NOERROR;
}

ULONG CDragProxy::AddRef()
{
    return ++_cRef;
}

ULONG CDragProxy::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CDragProxy::DragEnter(IDataObject *pdo, DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    //
    // some sanity
    //
    ASSERT(!_pdtgtItem);
    ASSERT(!_pdtobj);

    if (!pdo)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    //
    // make sure our callback will allow us to do d/d now
    //
    if (!CallCB(DPX_ENTER, 0, 0))
        return E_FAIL;

    //
    // save away the data object
    //
    pdo->AddRef();
    _pdtobj = pdo;

    //
    // and process this like a DragOver
    //
    DragOver(fKeys, pt, pdwEffect);

    //
    // always succeed DragEnter
    //
    return NOERROR;
}

HRESULT CDragProxy::DragLeave()
{
    //
    // release any drop target that we are holding
    //
    SetDropTarget(NULL);
    _idItem = _idDefault;

    //
    // if we had a data object then we were actually dragging
    //
    if (_pdtobj)
    {
        CallCB(DPX_LEAVE, 0, 0);

        IDataObject* p = _pdtobj;
        _pdtobj = NULL;
        p->Release();
    }

    //
    // all done
    //
    return NOERROR;
}

HRESULT CDragProxy::DragOver(DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    DWORD dwFlags = 0;
    HRESULT hres;
    int id;
    ASSERT(_pdtobj);

    //
    // save the current drag state
    //
    _fKeysLast    = fKeys;
    _ptLast       = pt;
    _dwEffectLast = *pdwEffect;

    //
    // make sure we have the correct drop target for this location
    //
    id = (int)CallCB(DPX_DRAGHIT, (WPARAM)&dwFlags, (LPARAM)&pt);
    SetTargetItem(id, dwFlags);
    //
    // do we have a target to drop on?
    //
    if (_pdtgtItem)
    {
        //
        // forward the DragOver along to the item's drop target (if any)
        //
        hres = _pdtgtItem->DragOver(fKeys, pt, pdwEffect);
    }
    else
    {
        //
        // can't drop here
        //
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    //
    // and update our selection state accordingly
    //
    UpdateSelection(*pdwEffect);

    return hres;
}

HRESULT CDragProxy::Drop(IDataObject *pdo, DWORD fKeys, POINTL pt, DWORD *pdwEffect)
{
    HRESULT hres;

    AddRef();

    //
    // do we have a target to drop on?
    //
    if (_pdtgtItem)
    {
        // From a comment in browseui, there's apparently a chance to put up UI
        // which could cause us to get re-entered.  Hard to believe, but see if
        // this fixes the fault:
        //
        IDropTarget * pdtCur = _pdtgtItem;
        _pdtgtItem = NULL;
        
        //
        // do the drop
        //
        hres = pdtCur->Drop(pdo, fKeys, pt, pdwEffect);

        //
        // we call our DragLeave below but we don't want the item's to be
        // called (since it already saw the Drop) so we release right away
        //
        pdtCur->Release();
    }
    else
    {
        //
        // can't drop here
        //
        *pdwEffect = DROPEFFECT_NONE;
        hres = NOERROR;
    }

    //
    // now clean up
    //
    DragLeave();

    Release();
    
    return hres;
}

void CDragProxy::SetTargetItem(int id, DWORD dwFlags)
{
    //
    // anything to do?
    //
    if (id == _idItem && dwFlags == _dwFlags)
        return;

    //
    // deselect the old item (if any)
    //
    // the GETOBJECT below could take a long time and we don't want a
    // lingering highlight on the object we are leaving
    //

    UpdateSelection(DROPEFFECT_NONE);

    //
    // get a drop target for the new item
    //
    _idItem = id;
    _dwFlags = dwFlags;

    NMOBJECTNOTIFY non;
    non.iItem = id;
    non.dwFlags = dwFlags;
    if (!_pdtobj || FAILED((HRESULT)CallCB(DPX_GETOBJECT, 0, (LPARAM)&non)))
        non.pObject = NULL;

        //
    // use this drop target (if any)
    //
    SetDropTarget((IDropTarget*)non.pObject);

    //
    // release our ref from the GETOBJECT above
    //
    if (non.pObject)
        ((IDropTarget*)non.pObject)->Release();
}

void CDragProxy::SetDropTarget(IDropTarget *pdt)
{
    //
    // NOTE: we intentionally skip the test for drop-target equality here
    // this allows controls owners to share a target among multiple items
    // while retaining the proper leave/enter sequence...
    //
    // BOGUS: we should actually compare here when the Internet Toolbar gets
    //  fixed (see comment in CDragProxy::SetTargetItem).  anybody who wants
    //  to share a target like this should just do the right hit-testing in
    //  their DragOver implementation
    //


    //
    // make sure nothing is selected
    //
    UpdateSelection(DROPEFFECT_NONE);

    //
    // leave/release the old item
    //
    if (_pdtgtItem)
    {
        _pdtgtItem->DragLeave();
        _pdtgtItem->Release();
    }

    //
    // store the new item
    //
    _pdtgtItem = pdt;

    //
    // addref/enter the new item
    //
    if (_pdtgtItem)
    {
        ASSERT(_pdtobj);    // must have a data object by now

        _pdtgtItem->AddRef();

        DWORD dwEffect = _dwEffectLast;
        if (FAILED(_pdtgtItem->DragEnter(_pdtobj, _fKeysLast, _ptLast, &dwEffect)))
            dwEffect = DROPEFFECT_NONE;

        //
        // update the selection
        //
        UpdateSelection(dwEffect);
    }
}

void CDragProxy::UpdateSelection(DWORD dwEffect)
{
    //
    // anything to do?
    //
    if (dwEffect == _dwEffectItem)
        return;

    //
    // update the flags and tell the callback they changed
    //
    _dwEffectItem = dwEffect;
    CallCB(DPX_SELECT, (WPARAM)_idItem, (LPARAM)dwEffect);
}

LRESULT CDragProxy::CallCB(UINT code, WPARAM wp, LPARAM lp)
{
    return _pfnCallback ? _pfnCallback(_hwnd, code, wp, lp) : (LRESULT)-1;
}

BOOL CDragProxy::Register()
{
    _hmodOLE = PrivLoadOleLibrary();
    if (_hmodOLE)
    {
        if (SUCCEEDED(PrivCoInitialize(_hmodOLE)))
        {
            if (SUCCEEDED(PrivRegisterDragDrop(_hmodOLE, _hwnd, this)))
                return TRUE;

            PrivCoUninitialize(_hmodOLE);
        }

        PrivFreeOleLibrary(_hmodOLE);
        _hmodOLE = NULL;
    }

    return FALSE;
}

void CDragProxy::RevokeAndFreeCB()
{
    if (_hmodOLE)
    {
        PrivRevokeDragDrop(_hmodOLE, _hwnd);
        PrivCoUninitialize(_hmodOLE);
        PrivFreeOleLibrary(_hmodOLE);
    }
    _pfnCallback = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\draglist.c ===
#include "ctlspriv.h"

#define DF_ACTUALLYDRAG	0x0001
#define DF_DEFERRED	0x0002

#define INITLINESPERSECOND	6
#define VERTCHANGENUMLINES	25

#define TIMERID		238
#define TIMERLEN	50

#define DX_INSERT	16
#define DY_INSERT	16


typedef struct {
    HWND hwndDrag;
    UINT uFlags;
} DRAGPROP, *PDRAGPROP;

UINT uDragListMsg = 0;
const TCHAR szDragListMsgString[] = DRAGLISTMSGSTRING;

BOOL NEAR PASCAL PtInLBItem(HWND hLB, int nItem, POINT pt, int xInflate, int yInflate)
{
  RECT rc;

  if (nItem < 0)
      nItem = (int)SendMessage(hLB, LB_GETCURSEL, 0, 0L);

  if (SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc) == LB_ERR)
      return(FALSE);

  InflateRect(&rc, xInflate, yInflate);

  return(PtInRect(&rc, pt));
}


/*
 * DragListSubclassProc
 * --------------------
 *
 * Window procedure for subclassed list boxes
 */
LRESULT CALLBACK DragListSubclassProc(HWND hLB, UINT uMsg, WPARAM wParam,
      LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
  PDRAGPROP pDragProp;
  DRAGLISTINFO sNotify;
  BOOL bDragging;
  POINT pt;

  pDragProp = (PDRAGPROP)dwRefData;
  bDragging = pDragProp->hwndDrag == hLB;

  switch (uMsg)
    {
      case WM_NCDESTROY:
        if (bDragging)
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);	/* cancel drag */

        RemoveWindowSubclass(hLB, DragListSubclassProc, 0);

        if (pDragProp)
            LocalFree((HLOCAL)pDragProp);
        break;

      case WM_LBUTTONDOWN:
        {
          int nItem;

          if (bDragging)				/* nested button-down */
              SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);	/* cancel drag */

          SetFocus(hLB);

          pt.x = GET_X_LPARAM(lParam);
          pt.y = GET_Y_LPARAM(lParam);
          ClientToScreen(hLB, &pt);
          nItem = LBItemFromPt(hLB, pt, FALSE);

          if (nItem >= 0)
            {
              SendMessage(hLB, LB_SETCURSEL, nItem, 0L);
              if (GetWindowLong(hLB, GWL_STYLE) & LBS_NOTIFY)
                  SendMessage(GetParent(hLB), WM_COMMAND,
                              GET_WM_COMMAND_MPS(GetDlgCtrlID(hLB), hLB, LBN_SELCHANGE));
              sNotify.uNotification = DL_BEGINDRAG;
              goto QueryParent;
            }
          else
              goto FakeDrag;
        }

      case WM_TIMER:
        if (wParam != TIMERID)
            break;
        lParam = GetMessagePosClient(hLB, &pt);


        // fall through
      case WM_MOUSEMOVE:
	if (bDragging)
	  {
	    HWND hwndParent;
	    LRESULT lResult;

	    /* We may be just simulating a drag, but not actually doing
	     * anything.
	     */
	    if (!(pDragProp->uFlags&DF_ACTUALLYDRAG))
		return(0L);

	    /* We don't want to do any dragging until the user has dragged
	     * outside of the current selection.
	     */
	    if (pDragProp->uFlags & DF_DEFERRED)
	      {
                pt.x = GET_X_LPARAM(lParam);
                pt.y = GET_Y_LPARAM(lParam);
		if (PtInLBItem(hLB, -1, pt, 0, 4))
		    return 0;
		pDragProp->uFlags &= ~DF_DEFERRED;
	      }

	    sNotify.uNotification = DL_DRAGGING;

QueryParent:
	    hwndParent = GetParent(hLB);
	    sNotify.hWnd = hLB;

            sNotify.ptCursor.x = GET_X_LPARAM(lParam);
            sNotify.ptCursor.y = GET_Y_LPARAM(lParam);
	    ClientToScreen(hLB, &sNotify.ptCursor);

            lResult = SendMessage(hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
		  (LPARAM)(LPDRAGLISTINFO)&sNotify);

	    if (uMsg == WM_LBUTTONDOWN)
	      {
		/* Some things may not be draggable
		 */
		if (lResult)
		  {
		    SetTimer(hLB, TIMERID, TIMERLEN, NULL);
		    pDragProp->uFlags = DF_DEFERRED | DF_ACTUALLYDRAG;
		  }
		else
		  {
FakeDrag:
		    pDragProp->uFlags = 0;
		  }

		/* Set capture and change mouse cursor
		 */
		pDragProp->hwndDrag = hLB;

		SetCapture(hLB);
	      }
	    else
	      {
		switch (lResult)
		  {
		    case DL_STOPCURSOR:
                      SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_NO)));
		      break;

		    case DL_COPYCURSOR:
                      SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_COPY)));
		      break;

		    case DL_MOVECURSOR:
                      SetCursor(LoadCursor(HINST_THISDLL, MAKEINTRESOURCE(IDC_MOVE)));
		      break;

		    default:
		      break;
		  }
	      }

	    /* Don't call the def proc, since it may try to change the
	     * selection or set timers or things like that.
	     */
	    return(0L);
	  }
	break;

      case  WM_RBUTTONDOWN:
      case  WM_LBUTTONUP:
	/* if we are capturing mouse - release it and check for acceptable place
	 * where mouse is now to decide drop or not
	 */
	if (bDragging)
	  {
	    HWND hwndParent;

	    pDragProp->hwndDrag = NULL;
	    KillTimer(hLB, TIMERID);
	    ReleaseCapture();
	    SetCursor(LoadCursor(NULL, IDC_ARROW));

	    hwndParent = GetParent(hLB);

	    sNotify.uNotification = uMsg==WM_LBUTTONUP ? DL_DROPPED : DL_CANCELDRAG;
	    sNotify.hWnd = hLB;
            sNotify.ptCursor.x = GET_X_LPARAM(lParam);
            sNotify.ptCursor.y = GET_Y_LPARAM(lParam);
	    ClientToScreen(hLB, &sNotify.ptCursor);

	    SendMessage(hwndParent, uDragListMsg, GetDlgCtrlID(hLB),
		  (LPARAM)(LPDRAGLISTINFO)&sNotify);

	    /* We need to make sure to return 0 in case this is from a
	     * keyboard message.
	     */
	    return(0L);
	  }
	break;

      case WM_GETDLGCODE:
	if (bDragging)
          {
            return (DefSubclassProc(hLB, uMsg, wParam, lParam) |
                DLGC_WANTMESSAGE);
          }
	break;

      case WM_KEYDOWN:
        if (wParam == VK_ESCAPE)
          {
            SendMessage(hLB, WM_RBUTTONDOWN, 0, 0L);
          }
        // fall through
      case WM_CHAR:
      case WM_KEYUP:
	/* We don't want the listbox processing this if we are dragging.
	 */
	if (bDragging)
	    return(0L);
	break;

      default:
	break;
    }

  return(DefSubclassProc(hLB, uMsg, wParam, lParam));
}


BOOL WINAPI MakeDragList(HWND hLB)
{
  PDRAGPROP pDragProp;

  if (!uDragListMsg)
      uDragListMsg = RegisterWindowMessage(szDragListMsgString);

  /* Check that we have not already subclassed this window.
   */
  if (GetWindowSubclass(hLB, DragListSubclassProc, 0, NULL))
      return(TRUE);

  pDragProp = (PDRAGPROP)LocalAlloc(LPTR, sizeof(DRAGPROP));
  if (!pDragProp)
      return(FALSE);

  if (!SetWindowSubclass(hLB, DragListSubclassProc, 0, (DWORD_PTR)pDragProp))
  {
      LocalFree((HLOCAL)pDragProp);
      return(FALSE);
  }

  return(TRUE);
}


int WINAPI LBItemFromPt(HWND hLB, POINT pt, BOOL bAutoScroll)
{
  static LONG dwLastScroll = 0;

  RECT rc;
  DWORD dwNow;
  int nItem;
  WORD wScrollDelay, wActualDelay;

  ScreenToClient(hLB, &pt);
  GetClientRect(hLB, &rc);

  nItem = (int)SendMessage(hLB, LB_GETTOPINDEX, 0, 0L);

  /* Is the point in the LB client area?
   */
  if (PtInRect(&rc, pt))
    {
      /* Check each visible item in turn.
       */
      for ( ; ; ++nItem)
	{
	  if (SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc)
		== LB_ERR)
	      break;

	  if (PtInRect(&rc, pt))
	      return(nItem);
	}
    }
  else
    {
      /* If we want autoscroll and the point is directly above or below the
       * LB, determine the direction and if it is time to scroll yet.
       */
      if (bAutoScroll && (UINT)pt.x<(UINT)rc.right)
	{
	  if (pt.y <= 0)
	    {
	      --nItem;
	    }
	  else
	    {
	      ++nItem;
	      pt.y = rc.bottom - pt.y;
	    }
	  wScrollDelay = (WORD)(1000 /
		(INITLINESPERSECOND - pt.y/VERTCHANGENUMLINES));

	  dwNow = GetTickCount();
	  wActualDelay = (WORD)(dwNow - dwLastScroll);

	  if (wActualDelay > wScrollDelay)
	    {
	      /* This will the actual number of scrolls per second to be
	       * much closer to the required number.
	       */
	      if (wActualDelay > wScrollDelay * 2)
		  dwLastScroll = dwNow;
	      else
		  dwLastScroll += wScrollDelay;

	      SendMessage(hLB, LB_SETTOPINDEX, nItem, 0L);
	    }
	}
    }

  return(-1);
}


void WINAPI DrawInsert(HWND hwndParent, HWND hLB, int nItem)
{
  static POINT ptLastInsert;
  static int nLastInsert = -1;

  RECT rc;

  /* Erase the old mark if necessary
   */
  if (nLastInsert>=0 && nItem!=nLastInsert)
    {
      rc.left = ptLastInsert.x;
      rc.top = ptLastInsert.y;
      rc.right = rc.left + DX_INSERT;
      rc.bottom = rc.top + DY_INSERT;

      /* Need to update immediately in case the insert rects overlap.
       */
      InvalidateRect(hwndParent, &rc, TRUE);
      UpdateWindow(hwndParent);

      nLastInsert = -1;
    }

  /* Draw a new mark if necessary
   */
  if (nItem!=nLastInsert && nItem>=0)
    {
      HICON hInsert = NULL;

      if (!hInsert)
	  hInsert = LoadIcon(HINST_THISDLL, MAKEINTRESOURCE(IDI_INSERT));

      if (hInsert)
	{
	  HDC hDC;

	  GetWindowRect(hLB, &rc);
	  ScreenToClient(hLB, (LPPOINT)&rc);
	  ptLastInsert.x = rc.left - DX_INSERT;

	  SendMessage(hLB, LB_GETITEMRECT, nItem, (LPARAM)(LPRECT)&rc);
	  ptLastInsert.y = rc.top - DY_INSERT/2;

	  nLastInsert = nItem;

	  ClientToScreen(hLB, &ptLastInsert);
	  ScreenToClient(hwndParent, &ptLastInsert);

	  hDC = GetDC(hwndParent);
	  DrawIcon(hDC, ptLastInsert.x, ptLastInsert.y, hInsert);
	  ReleaseDC(hwndParent, hDC);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\comctl32\v5\flat_sb.c ===
#include "ctlspriv.h"
#include "flat_sb.h"

//  Following interfaces are imported from newwsbctl.c and newsb.c. These
//  functions are for internal use only.

void FlatSB_Internal_CalcSBStuff(WSBState *, BOOL);
void FlatSB_Internal_DoScroll(WSBState *, int, int, BOOL);
void FlatSB_Internal_EndScroll(WSBState *, BOOL);
void FlatSB_Internal_DrawArrow(WSBState *, HDC, CONST RECT *, int, int);
void FlatSB_Internal_DrawElevator(WSBState *, HDC, LPRECT, BOOL);
void FlatSB_Internal_DrawGroove(WSBState *, HDC, LPRECT, BOOL);
void FlatSB_Internal_DrawSize(WSBState *, HDC, int, int);
void FlatSB_Internal_DrawScrollBar(WSBState *, HDC, BOOL, BOOL);
void FlatSB_Internal_DrawThumb(WSBState *, BOOL);
void FlatSB_Internal_DrawThumb2(WSBState *, HDC, BOOL, UINT);
UINT FlatSB_Internal_GetSBFlags(WSBState *, BOOL);
BOOL FlatSB_Internal_EnableScrollBar(WSBState *, int, UINT);
WSBState * FlatSB_Internal_InitPwSB(HWND);
void FlatSB_Internal_RedrawScrollBar(WSBState *, BOOL);
void FlatSB_Internal_SBTrackInit(WSBState *, HWND, LPARAM, int, BOOL);
void FlatSB_Internal_TrackBox(WSBState *, int message, WPARAM, LPARAM);
void FlatSB_Internal_TrackThumb(WSBState *, int message, WPARAM, LPARAM);
BOOL FlatSB_Internal_IsSizeBox(HWND);

LRESULT FlatSB_Internal_SetScrollBar(WSBState *, int, LPSCROLLINFO, BOOL);
LRESULT CALLBACK FlatSB_SubclassWndProc(HWND, UINT, WPARAM, LPARAM, WPARAM, ULONG_PTR);

void FlatSB_Internal_NotifyWinEvent(WSBState *pWState, UINT event, LONG_PTR idChild)
{
    MyNotifyWinEvent(event, pWState->sbHwnd,
                     pWState->fTrackVert ? OBJID_VSCROLL : OBJID_HSCROLL,
                     idChild);
}

#define IsHottrackable(STYLE)   ((STYLE == FSB_FLAT_MODE) || (STYLE == FSB_ENCARTA_MODE))

HRESULT WINAPI UninitializeFlatSB(HWND hwnd)
{
    SCROLLINFO hsi, vsi;
    WSBState * pWState;
    int style, vFlags, hFlags;
    BOOL hValid = FALSE, vValid = FALSE;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)
        return S_FALSE;
    else if (pWState == WSB_UNINIT_HANDLE)   {
        RemoveWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0);
        return S_FALSE;
    }

    if (pWState->fTracking)
        return E_FAIL;          //  Can't do this!

    style = pWState->style;
    vsi.cbSize = hsi.cbSize = sizeof(SCROLLINFO);
    vsi.fMask = hsi.fMask = SIF_ALL | SIF_DISABLENOSCROLL;

    hValid = FlatSB_GetScrollInfo(hwnd, SB_HORZ, &hsi);
    hFlags = FlatSB_Internal_GetSBFlags(pWState, SB_HORZ);
    vValid = FlatSB_GetScrollInfo(hwnd, SB_VERT, &vsi);
    vFlags = FlatSB_Internal_GetSBFlags(pWState, SB_VERT);

    DeleteObject(pWState->hbm_Bkg);
    DeleteObject(pWState->hbr_Bkg);
    LocalFree((HLOCAL)pWState);
    RemoveWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0);

    if (vValid) {
        SetScrollInfo(hwnd, SB_VERT, &vsi, FALSE);
        EnableScrollBar(hwnd, SB_VERT, vFlags);
    }

    if (hValid) {
        SetScrollInfo(hwnd, SB_HORZ, &hsi, FALSE);
        EnableScrollBar(hwnd, SB_HORZ, hFlags);
    }

    SetWindowBits(hwnd, GWL_STYLE, WS_HSCROLL | WS_VSCROLL, style & (WS_HSCROLL | WS_VSCROLL));

    //  Force the WM_NCCALCSIZE/WM_NCPAINT to be sent.
    CCInvalidateFrame(hwnd);
    return S_OK;
}

//
//  For accessibility - We keep the original USER scrollbars around and
//  keep USER's view of the scrollbar in sync with the flat view.  This
//  means keeping the WS_[HV]SCROLL styles on the window, forwarding
//  all scrollbar APIs into USER, etc.  That way, when OLEACC asks USER
//  for the scrollbar state, USER returns values that match the flat_sb
//  values.
//
//  Even though the styles are enabled, the UI isn't affected since we
//  take over all nonclient painting and hit-testing so USER never gets
//  a chance to paint or hit-test the scrollbars that we took over.
//
BOOL WINAPI InitializeFlatSB(HWND hwnd)
{
    int newStyle, style;
    SCROLLINFO hsi, vsi, siTmp;
    WSBState * pWState;
    BOOL hValid = FALSE, vValid = FALSE;

    style = GetWindowLong(hwnd, GWL_STYLE);
    siTmp.cbSize = vsi.cbSize = hsi.cbSize = sizeof(SCROLLINFO);
    vsi.fMask = hsi.fMask = SIF_ALL | SIF_DISABLENOSCROLL;

    if (style & WS_HSCROLL)
        hValid = GetScrollInfo(hwnd, SB_HORZ, &hsi);

    if (style & WS_VSCROLL)
        vValid = GetScrollInfo(hwnd, SB_VERT, &vsi);

    newStyle = style & (WS_VSCROLL | WS_HSCROLL);
    style &= ~(WS_VSCROLL | WS_HSCROLL);

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (!vValid && !hValid)   {
        if (NULL == pWState)    {
            if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR)WSB_UNINIT_HANDLE))
                return FALSE;
        } else  {
            //  It seems to me unreasonable to do nothing while the caller wants
            //  to init again the flat SB we are already using.
        }
        return TRUE;
    }

    if ((NULL == pWState) || (WSB_UNINIT_HANDLE == pWState))    {
        pWState = FlatSB_Internal_InitPwSB(hwnd);
        if ((WSBState *)NULL == pWState)
            return FALSE;

        if (!SetWindowSubclass(hwnd,FlatSB_SubclassWndProc, 0,(ULONG_PTR)pWState)) {
            DeleteObject(pWState->hbm_Bkg);
            DeleteObject(pWState->hbr_Bkg);
            LocalFree((HLOCAL)pWState);
            return FALSE;
        }
    }

    pWState->style = newStyle;
    if (hValid)
        FlatSB_Internal_SetScrollBar(pWState, SB_HORZ, &hsi, FALSE);

    if (vValid)
        FlatSB_Internal_SetScrollBar(pWState, SB_VERT, &vsi, FALSE);

    //  Force the WM_NCCALCSIZE/WM_NCPAINT to be sent.
    CCInvalidateFrame(hwnd);

    return TRUE;
}


LRESULT FlatSB_NCDestroyProc(WSBState * pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    ASSERT(pWState);

    if (pWState != WSB_UNINIT_HANDLE)   {
        DeleteObject(pWState->hbm_Bkg);
        DeleteObject(pWState->hbr_Bkg);
        LocalFree((HLOCAL)pWState);
    }

    RemoveWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0);
    return DefSubclassProc(hwnd, WM_NCDESTROY, wParam, lParam);
}

LRESULT FlatSB_NCCalcProc(WSBState * pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    RECT * rc = (RECT *) lParam;
    NCCALCSIZE_PARAMS * pnc = (NCCALCSIZE_PARAMS *)lParam;
    RECT    rcClient, rcWin;
    LRESULT lres;
    DWORD dwStyle;

    //  ZDC:
    //
    //  Note:
    //      It's said that if wParam is true, new rgrc[1|2] are also
    //      computed. Since I didn't see the implementation in the 'user'
    //      code, I leave it unimplemented.


    if ((BOOL)wParam == TRUE)
        CopyRect(&rcWin, &(pnc->rgrc[0]));
    else
        CopyRect(&rcWin, rc);

    dwStyle = SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, 0);

    // Save pnc->rgrc[0] to keep USER happy (see below)
    CopyRect(&rcClient, &pnc->rgrc[0]);

    lres = DefSubclassProc(hwnd, WM_NCCALCSIZE, wParam, lParam);

    SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, dwStyle);

    // USER does funky internal state munging during the WM_NCCALCSIZE
    // and we want USER's internal state to see the scrollbars even though
    // we're drawing them.  So give USER one last look at the original
    // values so he will think the scroll bars are really there.  This
    // sets internal WFVPRESENT and WFHPRESENT flags that OLEACC secretly
    // looks at via the undocumented GetScrollBarInfo().
    DefSubclassProc(hwnd, WM_NCCALCSIZE, FALSE, (LPARAM)&rcClient);

    if ((BOOL)wParam == TRUE)
        CopyRect(&rcClient, &(pnc->rgrc[0]));
    else
        CopyRect(&rcClient, rc);

    pWState->style &= ~(WFVPRESENT | WFHPRESENT);
    if (TestSTYLE(pWState->style, WS_VSCROLL)
        && (rcClient.right - rcClient.left >= pWState->x_VSBArrow)) {
        pWState->style |= WFVPRESENT;
        rcClient.right -= pWState->x_VSBArrow;
    }

    if (TestSTYLE(pWState->style, WS_HSCROLL)
        && (rcClient.bottom - rcClient.top > pWState->y_HSBArrow)) {
        pWState->style |= WFHPRESENT;
        rcClient.bottom -= pWState->y_HSBArrow;
    }

    if ((BOOL)wParam == TRUE)
        CopyRect(&(pnc->rgrc[0]), &rcClient);
    else
        CopyRect(rc, &rcClient);

    pWState->rcClient.top = rcClient.top - rcWin.top;
    pWState->rcClient.bottom = rcClient.bottom - rcWin.top;
    pWState->rcClient.left = rcClient.left - rcWin.left;
    pWState->rcClient.right = rcClient.right - rcWin.left;

    return lres;
}


LRESULT FlatSB_NCPaintProc(WSBState * pWState, HWND hwnd, WPARAM wParam,  LPARAM lParam)
{
    HDC     hdc;
    int     oldLoc, newLoc;
    LRESULT lres;
    DWORD dwStyle;
    RECT rcClient;

    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    //
    //  DefWindowProc(WM_NCPAINT) is going to try to draw USER's scrollbars,
    //  and will draw them in the wrong place if our scrollbar width is
    //  different from the system default width.  (Argh.)
    //
    //  So remove the scrollbar styles, do the paint, then put them back.
    //
    dwStyle = SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, 0);

    GetWindowRect(hwnd, &rcClient);
    DefSubclassProc(hwnd, WM_NCCALCSIZE, FALSE, (LPARAM)&rcClient);

    lres = DefSubclassProc(hwnd, WM_NCPAINT, wParam, lParam);

    SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, dwStyle);

    GetWindowRect(hwnd, &rcClient);
    DefSubclassProc(hwnd, WM_NCCALCSIZE, FALSE, (LPARAM)&rcClient);

//  hdc = GetDCEx(hwnd, (HRGN) wParam, DCX_WINDOW |
//                DCX_INTERSECTRGN | DCX_LOCKWINDOWUPDATE);

    //  ZDC:
    //
    //  Note:
    //      For some reason(wParam == 1) the statements above did not give
    //      the result we expected. I am not sure if it's the only case that
    //      GetDCEx will disappoint us.

    hdc = GetWindowDC(hwnd);
    newLoc = WSB_MOUSELOC_OUTSIDE;
    oldLoc = pWState->locMouse;

    if (TestSTYLE(pWState->style, WFHPRESENT)
        && TestSTYLE(pWState->style, WFVPRESENT))   {
        int cxFrame, cyFrame;

        cxFrame = pWState->rcClient.right;
        cyFrame = pWState->rcClient.bottom;
        FlatSB_Internal_DrawSize(pWState, hdc, cxFrame, cyFrame);
    }

    if (TestSTYLE(pWState->style, WFHPRESENT))  {
        FlatSB_Internal_DrawScrollBar(pWState, hdc, FALSE, FALSE);
        if (pWState->fHActive)
            newLoc = pWState->locMouse;
    }

    if (TestSTYLE(pWState->style, WFVPRESENT))  {
        pWState->locMouse = oldLoc;
        FlatSB_Internal_DrawScrollBar(pWState, hdc, TRUE, FALSE);
        if (pWState->fVActive)
            newLoc = pWState->locMouse;
    }
    pWState->locMouse = newLoc;

    ReleaseDC(hwnd, hdc);

    return lres;
}

LRESULT FlatSB_NCHitTestProc(WSBState *pWState, HWND hwnd, WPARAM wParam, LPARAM lParam, BOOL fTrack);

VOID CALLBACK TimerMouseLeave(
    HWND hwnd,  // handle of window for timer messages
    UINT uMsg,  // WM_TIMER message
    UINT_PTR idEvent,  // timer identifier
    DWORD dwTime   // current system time
)
{
    WSBState * pWState;

    if (idEvent != IDWSB_TRACK)
        return;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if ((pWState == (WSBState *)NULL) || (pWState == WSB_UNINIT_HANDLE))    {
        KillTimer(hwnd, IDWSB_TRACK);
        return;
    }

    if (pWState->fTracking) {
        return;
    }

    FlatSB_NCHitTestProc(pWState, hwnd, 0, 0, TRUE);
    return;
}

LRESULT FlatSB_NCHitTestProc(WSBState *pWState, HWND hwnd, WPARAM wParam, LPARAM lParam, BOOL fTTrack)
{
    LRESULT lres, lHTCode=HTBOTTOMRIGHT;
    RECT    rcTest, rcWindow;
    POINT   pt;
    BOOL    fVChanged = FALSE, fHChanged = FALSE;
    BOOL    fWinActive = ChildOfActiveWindow(hwnd);
    int     newLoc, oldLoc;

    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    GetWindowRect(hwnd, &rcWindow);
    if (fTTrack) {
        lres = HTNOWHERE;
        if (fWinActive)
            GetCursorPos(&pt);
        else    {
            pt.x = rcWindow.left - 1;      //  NOWHERE --- to fool CalcSBtuff2
            pt.y = rcWindow.top - 1;
        }
    } else    {
        lres = DefSubclassProc(hwnd, WM_NCHITTEST, wParam, lParam);
        pt.x = GET_X_LPARAM(lParam);
        pt.y = GET_Y_LPARAM(lParam);
    }

    //
    // If this is a RTL mirrored window, then measure
    // the client coordinates from the visual right edge.
    // [samera]
    //
    if (IS_WINDOW_RTL_MIRRORED(hwnd)) {
        pt.x = rcWindow.right - pt.x;
        lHTCode = HTBOTTOMLEFT;
    } else {
        pt.x -= rcWindow.left;
    }
    pt.y -= rcWindow.top;

    if (fTTrack && fWinActive && (pt.x == pWState->ptMouse.x) && (pt.y == pWState->ptMouse.y))
        return lres /* Meaningless result*/;

    //  We shouldn't get HTVSCROLL / HTHSCROLL for system scrollbar here.
    if (lres != HTNOWHERE)  {
        goto Redraw;
    }

    if (TestSTYLE(pWState->style, WFVPRESENT))  {
        rcTest.left = pWState->rcClient.right;
        rcTest.right = pWState->rcClient.right + pWState->x_VSBArrow;
        rcTest.top = pWState->rcClient.top;
        rcTest.bottom = pWState->rcClient.bottom;

        if (PtInRect(&rcTest, pt))  {
            lres = HTVSCROLL;
            goto Redraw;
        }
    }

    if (TestSTYLE(pWState->style, WFHPRESENT))  {
        rcTest.left = pWState->rcClient.left;
        rcTest.right = pWState->rcClient.right;
        rcTest.top = pWState->rcClient.bottom;
        rcTest.bottom = pWState->rcClient.bottom + pWState->y_HSBArrow;

        if (PtInRect(&rcTest, pt))  {
            lres = HTHSCROLL;
            goto Redraw;
        }
    }

    if (TestSTYLE(pWState->style, WFHPRESENT) && TestSTYLE(pWState->style, WFVPRESENT))
    {
        rcTest.left = pWState->rcClient.right;
        rcTest.right = pWState->rcClient.right + pWState->x_VSBArrow;
        rcTest.top = pWState->rcClient.bottom;
        rcTest.bottom = pWState->rcClient.bottom + pWState->y_HSBArrow;

        if (PtInRect(&rcTest, pt))  {
            if (!FlatSB_Internal_IsSizeBox(hwnd))
                lres = HTSIZE;
            else
                lres = lHTCode;
            goto Redraw;
        }
    }

    lres = HTNOWHERE;

Redraw:
    if(pWState->fTracking)
        return lres;

    if (!fWinActive) {
        fVChanged = pWState->fVActive; pWState->fVActive = FALSE;
        fHChanged = pWState->fHActive; pWState->fHActive = FALSE;
    } else  {
        switch (lres)   {
        case HTVSCROLL:
            fVChanged = TRUE; pWState->fVActive = TRUE;
            fHChanged = pWState->fHActive; pWState->fHActive = FALSE;
            break;
        case HTHSCROLL:
            fVChanged = pWState->fVActive; pWState->fVActive = FALSE;
            fHChanged = TRUE; pWState->fHActive = TRUE;
            break;
        default:
            fVChanged = pWState->fVActive; pWState->fVActive = FALSE;
            fHChanged = pWState->fHActive; pWState->fHActive = FALSE;
            break;
        }
    }

    pWState->ptMouse.x = pt.x;
    pWState->ptMouse.y = pt.y;

    newLoc = WSB_MOUSELOC_OUTSIDE;
    oldLoc = pWState->locMouse;
    if (fVChanged && IsHottrackable(pWState->vStyle))  {

        FlatSB_Internal_RedrawScrollBar(pWState, TRUE);
        if (pWState->fVActive)
            newLoc = pWState->locMouse;
    }

    if (fHChanged && IsHottrackable(pWState->hStyle))  {
        pWState->locMouse = oldLoc;
        FlatSB_Internal_RedrawScrollBar(pWState, FALSE);
        if (pWState->fHActive)
            newLoc = pWState->locMouse;
    }
    pWState->locMouse = newLoc;

    if (pWState->fVActive || pWState->fHActive) {
        if (pWState->hTrackSB == 0)
            pWState->hTrackSB = SetTimer(hwnd, IDWSB_TRACK,
                        GetDoubleClickTime()/2,
                        TimerMouseLeave);
    } else  {
        if (pWState->hTrackSB)  {
            KillTimer(hwnd, IDWSB_TRACK);
            pWState->hTrackSB = 0;
        }
    }

    return lres;
}

LRESULT FlatSB_SysCommandProc(WSBState * pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;
    unsigned uCmdType;
    int     hitArea;

    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    uCmdType = (unsigned) wParam & 0xFFF0;        // type of system command requested
    hitArea = (int) wParam & 0x000F;
    if (uCmdType != SC_HSCROLL && uCmdType != SC_VSCROLL)
        return DefSubclassProc(hwnd, WM_SYSCOMMAND, wParam, lParam);
    else
        //  There are some initialization we may need.
#define SC_INVALID 0
        lres = DefSubclassProc(hwnd, WM_SYSCOMMAND, (WPARAM)SC_INVALID, lParam);
#undef  SC_INVALID

    FlatSB_Internal_SBTrackInit(pWState, hwnd, lParam, hitArea, GetKeyState(VK_SHIFT) < 0);
    return 0;
}

LRESULT FlatSB_CancelModeProc(WSBState * pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    LRESULT lres;

    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    lres = DefSubclassProc(hwnd, WM_CANCELMODE, wParam, lParam);

    //  A good citizen of Subclass, we have to wait the DefSubclassProc
    //  release capture first!

    if (pWState->pfnSB)
        FlatSB_Internal_EndScroll(pWState, TRUE);

    return lres;
}

//
//  This updates the system metrics and points pPWState->pwmet at the
//  application metrics or system metrics, depending on whether a
//  screenreader is running.
//
void FlatSB_InitWSBMetrics(WSBState *pWState)
{
    BOOL fScreenRead;

    pWState->metSys.cxHSBThumb = GetSystemMetrics(SM_CXHTHUMB);
    pWState->metSys.cyVSBThumb = GetSystemMetrics(SM_CYVTHUMB);
    pWState->metSys.cxVSBArrow = GetSystemMetrics(SM_CXVSCROLL);
    pWState->metSys.cyVSBArrow = GetSystemMetrics(SM_CYVSCROLL);
    pWState->metSys.cxHSBArrow = GetSystemMetrics(SM_CXHSCROLL);
    pWState->metSys.cyHSBArrow = GetSystemMetrics(SM_CYHSCROLL);

    fScreenRead = FALSE;
    SystemParametersInfo(SPI_GETSCREENREADER, 0, &fScreenRead, 0);

    // If a screen reader is running, then the active metrics are the
    // system metrics; otherwise, it's the app metrics.
    pWState->pmet = fScreenRead ? &pWState->metSys : &pWState->metApp;

}

LRESULT FlatSB_OnSettingChangeProc(WSBState *pWState, HWND hwnd, WPARAM wParam, LPARAM lParam)
{
    ASSERT(pWState);
    ASSERT(pWState != WSB_UNINIT_HANDLE);

    FlatSB_InitWSBMetrics(pWState);

    // These new metrics will most likely have altered our frame, so
    // recompute our frame stuff too
    CCInvalidateFrame(hwnd);

    return DefSubclassProc(hwnd, WM_SETTINGCHANGE, wParam, lParam);
}

LRESULT FlatSB_OnScrollProc(WSBState *pWState, HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (GET_WM_HSCROLL_HWND(wParam, lParam) == NULL && !pWState->fInDoScroll) {
        // Somebody on the outside (probably USER) changed our scroll stuff,
        // so re-sync with the USER values.
        if (GET_WM_HSCROLL_CODE(wParam, lParam) == SB_ENDSCROLL)
            FlatSB_NCPaintProc(pWState, hwnd, (WPARAM)1, 0);
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}

LRESULT CALLBACK FlatSB_SubclassWndProc
(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam,
    WPARAM uIdSubclass,
    ULONG_PTR dwRefData
)
{
    WSBState * pWState = (WSBState *)dwRefData;

    ASSERT (dwRefData);

    if (pWState == (WSBState *)NULL)
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);
    else if (pWState == WSB_UNINIT_HANDLE && uMsg != WM_NCDESTROY)
        return DefSubclassProc(hwnd, uMsg, wParam, lParam);

    switch (uMsg)
    {
    case WM_NCDESTROY:
        return FlatSB_NCDestroyProc(pWState, hwnd, wParam, lParam);
    case WM_NCCALCSIZE:
        return FlatSB_NCCalcProc(pWState, hwnd, wParam, lParam);
    case WM_NCPAINT:
        return FlatSB_NCPaintProc(pWState, hwnd, wParam, lParam);
    case WM_NCHITTEST:
        return FlatSB_NCHitTestProc(pWState, hwnd, wParam, lParam, FALSE);
    case WM_SYSCOMMAND:
        return FlatSB_SysCommandProc(pWState, hwnd, wParam, lParam);
    case WM_CANCELMODE:
        return FlatSB_CancelModeProc(pWState, hwnd, wParam, lParam);
    case WM_SETTINGCHANGE:
        return FlatSB_OnSettingChangeProc(pWState, hwnd, wParam, lParam);

    case WM_VSCROLL:
    case WM_HSCROLL:
        return FlatSB_OnScrollProc(pWState, hwnd, uMsg, wParam, lParam);
    }
    return DefSubclassProc(hwnd, uMsg, wParam, lParam);
}


//=------------------------------------------------------------------
//  Start of drawing functions.
//=-------------------------------------------------------------------


#define WSB_BUTTON_UPARROW      DFCS_SCROLLUP
#define WSB_BUTTON_DOWNARROW    DFCS_SCROLLDOWN
#define WSB_BUTTON_LEFTARROW    DFCS_SCROLLLEFT
#define WSB_BUTTON_RIGHTARROW   DFCS_SCROLLRIGHT

#define WSB_RESTING_MODE        0
#define WSB_HOTTRACKED_MODE     1
#define WSB_MOUSEDOWN_MODE      2
#define WSB_DISABLED_MODE       3

void FlatSB_Internal_DrawBox(HDC hdc, CONST RECT * prct, int mode)
{
    HBRUSH hbrOld, hbrEdge, hbrFace;
    int w, h, l, t;

    if (prct->left > prct->right)
        return;
    else if (prct->top > prct->bottom)
        return;

    l = prct->left;
    t = prct->top;
    w = prct->right - prct->left;
    h = prct->bottom - prct->top;

    switch (mode)   {
    case WSB_HOTTRACKED_MODE:
        hbrEdge = GetSysColorBrush(COLOR_3DSHADOW);
        hbrFace = hbrEdge;
        break;
    case WSB_MOUSEDOWN_MODE:
        hbrEdge = GetSysColorBrush(COLOR_3DSHADOW);
        hbrFace = (HBRUSH)GetStockObject(BLACK_BRUSH);
        break;
    case WSB_DISABLED_MODE:
        hbrEdge = GetSysColorBrush(COLOR_3DHILIGHT);
        hbrFace = GetSysColorBrush(COLOR_3DFACE);
        break;
    case WSB_RESTING_MODE:
    default:
        hbrEdge = GetSysColorBrush(COLOR_3DSHADOW);
        hbrFace = GetSysColorBrush(COLOR_3DFACE);
        break;
    }
    hbrOld = SelectObject(hdc, hbrEdge);
    PatBlt(hdc, l, t, w, 1, PATCOPY);
    PatBlt(hdc, l, t, 1, h, PATCOPY);
    PatBlt(hdc, l, t + h - 1, w, 1, PATCOPY);
    PatBlt(hdc, l + w - 1, t, 1, h, PATCOPY);

    SelectObject(hdc, hbrFace);
    PatBlt(hdc, l + 1, t + 1, w - 2, h - 2, PATCOPY);
    SelectObject(hdc, hbrOld);
}

void FlatSB_Internal_DrawEncartaBox(HDC hdc, CONST RECT * prct, int mode)
{
    HBRUSH hbrOld, hbrLite, hbrDark, hbrFace;

    int w, h, l, t;

    if (prct->left > prct->right)
        return;
    else if (prct->top > prct->bottom)
        return;

    l = prct->left;
    t = prct->top;
    w = prct->right - prct->left;
    h = prct->bottom - prct->top;

    switch (mode)   {
    case WSB_HOTTRACKED_MODE:
        hbrLite = GetSysColorBrush(COLOR_3DHILIGHT);
        hbrDark = GetSysColorBrush(COLOR_3DSHADOW);
        break;
    case WSB_MOUSEDOWN_MODE:
        hbrDark = GetSysColorBrush(COLOR_3DHILIGHT);
        hbrLite = GetSysColorBrush(COLOR_3DSHADOW);
        break;
    case WSB_DISABLED_MODE:
        hbrDark = hbrLite = GetSysColorBrush(COLOR_3DHILIGHT);
        break;
    case WSB_RESTING_MODE:
    default:
        hbrDark = hbrLite = GetSysColorBrush(COLOR_3DSHADOW);
        break;
    }

    hbrFace = GetSysColorBrush(COLOR_3DFACE);

    hbrOld = SelectObject(hdc, hbrLite);
    PatBlt(hdc, l, t, w, 1, PATCOPY);
    PatBlt(hdc, l, t, 1, h, PATCOPY);

    SelectObject(hdc, hbrDark);
    PatBlt(hdc, l, t + h - 1, w, 1, PATCOPY);
    PatBlt(hdc, l + w - 1, t, 1, h, PATCOPY);

    SelectObject(hdc, hbrFace);
    PatBlt(hdc, l + 1, t + 1, w - 2, h - 2, PATCOPY);

    SelectObject(hdc, hbrOld);
}

void FlatSB_Internal_DrawArrow(WSBState * pWState, HDC hdc, CONST RECT * rcArrow, int buttonIndex, int extraModeBits)
{
    COLORREF rgb;
    LPCTSTR strIndex;
    HFONT   hFont, hOldFont;
    int     x, y, cx, cy, iOldBk, c;
    BOOL    fDisabled = extraModeBits & DFCS_INACTIVE;
    BOOL    fMouseDown = extraModeBits & DFCS_PUSHED;
    BOOL    fHotTracked;
    int     mode, style;

    if (rcArrow->left >= rcArrow->right)
        return;
    else if (rcArrow->top >= rcArrow->bottom)
        return;

    if (buttonIndex == WSB_BUTTON_LEFTARROW || buttonIndex == WSB_BUTTON_RIGHTARROW)
        style = pWState->hStyle;
    else
        style = pWState->vStyle;

    switch (buttonIndex)    {
    case WSB_BUTTON_LEFTARROW:
        fHotTracked = (pWState->locMouse == WSB_MOUSELOC_ARROWLF);
        strIndex = TEXT("3");
        break;
    case WSB_BUTTON_RIGHTARROW:
        fHotTracked = (pWState->locMouse == WSB_MOUSELOC_ARROWRG);
        strIndex = TEXT("4");
        break;
    case WSB_BUTTON_UPARROW:
        fHotTracked = (pWState->locMouse == WSB_MOUSELOC_ARROWUP);
        strIndex = TEXT("5");
        break;
    case WSB_BUTTON_DOWNARROW:
        fHotTracked = (pWState->locMouse == WSB_MOUSELOC_ARROWDN);
        strIndex = TEXT("6");
        break;
    default:
        return;
    }

    if (!fDisabled && fHotTracked && pWState->fHitOld)
        fMouseDown = TRUE;

    if (style == FSB_REGULAR_MODE) {
        RECT rc;

        CopyRect(&rc, rcArrow);
        if (fDisabled)
            DrawFrameControl(hdc, &rc, DFC_SCROLL, buttonIndex | DFCS_INACTIVE);
        else if (fMouseDown)
            DrawFrameControl(hdc, &rc, DFC_SCROLL, buttonIndex | DFCS_FLAT);
        else
            DrawFrameControl(hdc, &rc, DFC_SCROLL, buttonIndex);
        return;
    }

    if (fDisabled)
        mode = WSB_DISABLED_MODE;
    else if (fMouseDown)
        mode = WSB_MOUSEDOWN_MODE;
    else if (fHotTracked)
        mode = WSB_HOTTRACKED_MODE;
    else
        mode = WSB_RESTING_MODE;

    if (style == FSB_ENCARTA_MODE)  {
        FlatSB_Internal_DrawEncartaBox(hdc, rcArrow, mode);
    } else  {
        FlatSB_Internal_DrawBox(hdc, rcArrow, mode);
    }

    cx = rcArrow->right - rcArrow->left;
    cy = rcArrow->bottom - rcArrow->top;
    c = min(cx, cy);

    if (c < 4)      // Couldn't fill in a char after drawing the edges.
        return;

    x = rcArrow->left + ((cx - c) / 2) + 2;
    y = rcArrow->top + ((cy - c) / 2) + 2;

    c -= 4;

    if (style == FSB_FLAT_MODE) {
        switch (mode)   {
        case WSB_RESTING_MODE:
            rgb = RGB(0, 0, 0);
            break;
        case WSB_HOTTRACKED_MODE:
        case WSB_MOUSEDOWN_MODE:
            rgb = RGB(255, 255, 255);
            break;
        case WSB_DISABLED_MODE:
            rgb = GetSysColor(COLOR_3DSHADOW);
            break;
        default:
            rgb = RGB(0, 0, 0);
            break;
        }
    } else  {   //  FSB_ENCARTA_MODE
        switch (mode)   {
        case WSB_DISABLED_MODE:
            rgb = GetSysColor(COLOR_3DSHADOW);
            break;
        case WSB_RESTING_MODE:
        case WSB_HOTTRACKED_MODE:
        case WSB_MOUSEDOWN_MODE:
        default:
            rgb = RGB(0, 0, 0);
            break;
        }
    }

    hFont = CreateFont(c, 0, 0, 0, FW_NORMAL, 0, 0, 0, SYMBOL_CHARSET, 0, 0, 0, 0, WSB_SYS_FONT);
    iOldBk = SetBkMode(hdc, TRANSPARENT);
    hOldFont = SelectObject(hdc, hFont);

    rgb = SetTextColor(hdc, rgb);
    TextOut(hdc, x, y, strIndex, 1);

    SetBkMode(hdc, iOldBk);
    SelectObject(hdc, hOldFont);
    DeleteObject(hFont);

    return;
}

void FlatSB_Internal_DrawElevator(WSBState * pWState, HDC hdc, LPRECT lprc, BOOL fVert)
{
    BOOL    fHit;
    int     mode;
    int     style;

    fHit = (fVert)?(pWState->locMouse == WSB_MOUSELOC_V_THUMB)
                  :(pWState->locMouse == WSB_MOUSELOC_H_THUMB);

    style = (fVert)?pWState->vStyle:pWState->hStyle;
    switch (style)  {
    case FSB_FLAT_MODE:
    case FSB_ENCARTA_MODE:
        if ((pWState->cmdSB == SB_THUMBPOSITION) && (fVert == pWState->fTrackVert))
            mode = WSB_HOTTRACKED_MODE;
        else
            mode = (fHit)?WSB_HOTTRACKED_MODE:WSB_RESTING_MODE;

        if (style == FSB_FLAT_MODE)
            FlatSB_Internal_DrawBox(hdc, lprc, mode);
        else
            FlatSB_Internal_DrawEncartaBox(hdc, lprc, mode);
        break;
    case FSB_REGULAR_MODE:
    default:
        {
            RECT rc;

            CopyRect(&rc, lprc);
            DrawFrameControl(hdc, &rc, DFC_BUTTON, DFCS_BUTTONPUSH);
        }
        break;
    }
}

//=-------------------------------------------------------------
//  FlatSB_Internal_DrawSize
//      Draw the size grip if needed.
//=-------------------------------------------------------------

void FlatSB_Internal_DrawSize(WSBState * pWState, HDC hdc, int x, int y)
{
    HBRUSH  hbrSave, hbr3DFACE;
    RECT    rcWindow;
    HWND    hwnd = pWState->sbHwnd;
    int     style;

    style = GetWindowLong(hwnd, GWL_STYLE);
    if (!FlatSB_Internal_IsSizeBox(hwnd))
    {
        hbr3DFACE = GetSysColorBrush(COLOR_3DFACE);
        hbrSave = SelectObject(hdc, hbr3DFACE);
        PatBlt(hdc, x, y, pWState->x_VSBArrow, pWState->y_HSBArrow, PATCOPY);
        SelectBrush(hdc, hbrSave);
    }
    else
    {
        rcWindow.left = x;
        rcWindow.right = x + pWState->x_VSBArrow;
        rcWindow.top = y;
        rcWindow.bottom = y + pWState->y_HSBArrow;
        DrawFrameControl(hdc, &rcWindow, DFC_SCROLL, DFCS_SCROLLSIZEGRIP);
    }
}

//=-------------------------------------------------------------
//  FlatSB_Internal_DrawGroove
//      Draw lines & middle of the thumb groove
//=-------------------------------------------------------------

void FlatSB_Internal_DrawGroove(WSBState * pWState, HDC hdc, LPRECT prct, BOOL fVert)
{
    HBRUSH   hbrLight;
    COLORREF cBkg, cFg;
    HPALETTE oldPal = 0;

    if (fVert)  {
        hbrLight = pWState->hbr_VSBBkg;
        cBkg = pWState->col_VSBBkg;
    } else  {
        hbrLight = pWState->hbr_HSBBkg;
        cBkg = pWState->col_HSBBkg;
    }

    if (hbrLight == (HBRUSH)NULL)   {
        hbrLight = GetSysColorBrush(COLOR_3DLIGHT);
        FillRect(hdc, prct, hbrLight);
        return;
    }

    if (pWState->hPalette != (HPALETTE)NULL)    {
        oldPal = SelectPalette(hdc, pWState->hPalette, TRUE);
        RealizePalette(hdc);
    }

    cFg = SetTextColor(hdc, GetSysColor(COLOR_3DFACE));
    cBkg = SetBkColor(hdc, cBkg);
    FillRect(hdc, prct, hbrLight);
    if (oldPal != (HPALETTE)NULL)
        SelectPalette(hdc, oldPal, TRUE);

    SetTextColor(hdc, cFg);
    SetBkColor(hdc, cBkg);
}


//=-------------------------------------------------------------------
//  Following functions are ported from winsbctl.c in user code.
//=-------------------------------------------------------------------


//=-------------------------------------------------------------------------
//  SBPosFromPx() -
//=-------------------------------------------------------------------------

int FlatSB_Internal_SBPosFromPx(WSBState * pWState, int px)
{
    int * pw;

    if (pWState->fTrackVert)
        pw = &(pWState->sbVMinPos);
    else
        pw = &(pWState->sbHMinPos);

    if (px < pWState->pxUpArrow)
        return pw[SBO_MIN];

    if (px >= pWState->pxDownArrow)
            return (pw[SBO_MAX] - (pw[SBO_PAGE]?pw[SBO_PAGE] - 1 : 0));

    return (pw[SBO_MIN] + DMultDiv(pw[SBO_MAX] - pw[SBO_MIN] - (pw[SBO_PAGE]?pw[SBO_PAGE] - 1 : 0),
                                   px - pWState->pxUpArrow,
                                   pWState->cpxSpace)
           );
}

//=-------------------------------------------------------------------------
//  InvertScrollHilite()
//=-------------------------------------------------------------------------

void FlatSB_Internal_InvertScrollHilite(WSBState * pWState)
{
    HWND hwnd = pWState->sbHwnd;
    HDC hdc;

    // Don't invert if the thumb is all the way at the top or bottom
    // or you will end up inverting the line between the arrow and the thumb.
    if (!IsRectEmpty(&(pWState->rcTrack)))
    {
        hdc = GetWindowDC(hwnd);
        InvertRect(hdc, &(pWState->rcTrack));
        ReleaseDC(hwnd, hdc);
    }
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_MoveThumb()
//=-------------------------------------------------------------------------

void FlatSB_Internal_MoveThumb(WSBState * pWState, int px)
{
    HWND    hwnd = pWState->sbHwnd;
    HDC     hdc;

    if (px == pWState->pxOld)
        return;

pxReCalc:

    pWState->posNew = FlatSB_Internal_SBPosFromPx(pWState, px);

    /* Tentative position changed -- notify the guy. */
    if (pWState->posNew != pWState->posOld) {
        FlatSB_Internal_DoScroll(pWState, SB_THUMBTRACK, pWState->posNew, pWState->fTrackVert);
        if (!pWState->fTracking)
            return;

        pWState->posOld = pWState->posNew;

        //
        // Anything can happen after the SendMessage above in DoScroll!
        // Make sure that the SBINFO structure contains data for the
        // window being tracked -- if not, recalculate data in SBINFO
        // If fVertSB is TRUE, the last CalcSBStuff call is for SB_VERT.
        // If fTrackVert != fVertSB, we got garbage in pWState.
        //

        if (pWState->fTrackVert != pWState->fVertSB)
            FlatSB_Internal_CalcSBStuff(pWState, pWState->fTrackVert);

        // when we yield, our range can get messed with
        // so make sure we handle this

        if (px >= pWState->pxDownArrow - pWState->cpxThumb) {
            px = pWState->pxDownArrow - pWState->cpxThumb;
            goto pxReCalc;
        }
    }

    hdc = GetWindowDC(hwnd);

    pWState->pxThumbTop = px;
    pWState->pxThumbBottom = pWState->pxThumbTop + pWState->cpxThumb;

    //  At this point, the disable flags are always going to be 0 --
    //  we're in the middle of tracking.

    //  We are Okay in this case, since in DrawElevator we decide the mode by
    //  cmd == SB_THUMBPOSITION.
    FlatSB_Internal_DrawThumb2(pWState, hdc, pWState->fTrackVert, 0);
    ReleaseDC(hwnd, hdc);

    pWState->pxOld = px;
}

//=-------------------------------------------------------------------------
//  DrawInvertScrollArea() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_DrawInvertScrollArea(WSBState * pWState, BOOL fHit, int cmd)
{
    HWND hwnd = pWState->sbHwnd;
    HDC  hdc;

    if ((cmd != SB_LINEUP) && (cmd != SB_LINEDOWN))
    {
        FlatSB_Internal_InvertScrollHilite(pWState);
        FlatSB_Internal_NotifyWinEvent(pWState, EVENT_OBJECT_STATECHANGE,
                         cmd == SB_PAGEUP ? INDEX_SCROLLBAR_UPPAGE
                                          : INDEX_SCROLLBAR_DOWNPAGE);
        return;
    }

    hdc = GetWindowDC(hwnd);
    if (cmd == SB_LINEUP) {
        if (pWState->fTrackVert)   {
            FlatSB_Internal_DrawArrow(pWState, hdc, &(pWState->rcTrack), DFCS_SCROLLUP, (fHit) ? DFCS_PUSHED : 0);
        } else  {
            FlatSB_Internal_DrawArrow(pWState, hdc, &(pWState->rcTrack), DFCS_SCROLLLEFT, (fHit) ? DFCS_PUSHED : 0);
        }
    } else {
        if (pWState->fTrackVert)   {
            FlatSB_Internal_DrawArrow(pWState, hdc, &(pWState->rcTrack), DFCS_SCROLLDOWN, (fHit) ? DFCS_PUSHED : 0);
        } else  {
            FlatSB_Internal_DrawArrow(pWState, hdc, &(pWState->rcTrack), DFCS_SCROLLRIGHT, (fHit) ? DFCS_PUSHED : 0);
        }
    }

    FlatSB_Internal_NotifyWinEvent(pWState, EVENT_OBJECT_STATECHANGE,
                     cmd == SB_LINEUP ? INDEX_SCROLLBAR_UP : INDEX_SCROLLBAR_DOWN);

    ReleaseDC(hwnd, hdc);

}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_EndScroll() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_EndScroll(WSBState * pWState, BOOL fCancel)
{
    HWND hwnd = pWState->sbHwnd;
    BOOL fVert = pWState->fTrackVert;
    int oldcmd;

    if (pWState->fTracking)
    {
        oldcmd = pWState->cmdSB;
        pWState->cmdSB = 0;

        //  will not have capture if called by CancelModeProc
        if (GetCapture() == hwnd)
            ReleaseCapture();

        if (pWState->pfnSB == FlatSB_Internal_TrackThumb)
        {
            if (fCancel)    {
                pWState->posOld = pWState->posStart;
            }

            FlatSB_Internal_DoScroll(pWState, SB_THUMBPOSITION, pWState->posOld, fVert);
            FlatSB_Internal_DrawThumb(pWState, fVert);
        }
        else if (pWState->pfnSB == FlatSB_Internal_TrackBox)
        {
            DWORD   lpt;
            RECT    rcWindow;
            POINT   pt;

            if (pWState->hTimerSB)
                KillTimer(hwnd, IDSYS_SCROLL);

            lpt = GetMessagePos();

            ASSERT(hwnd != GetDesktopWindow());

            GetWindowRect(hwnd, &rcWindow);
            pt.x = GET_X_LPARAM(lpt) - rcWindow.left;
            pt.y = GET_Y_LPARAM(lpt) - rcWindow.top;

            if (PtInRect(&(pWState->rcTrack), pt))  {
                pWState->fHitOld = FALSE;
                FlatSB_Internal_DrawInvertScrollArea(pWState, FALSE, oldcmd);
            }
        }

        //  Always send SB_ENDSCROLL message.
        pWState->pfnSB = NULL;

        //  Anything can happen here. Client can call GetScrollInfo for THUMBPOSITION, and we
        //  should return 0, so we should set pfnSB to NULL first.
        FlatSB_Internal_DoScroll(pWState, SB_ENDSCROLL, 0, fVert);
        pWState->fTracking = FALSE;
        pWState->fHitOld = FALSE;

        FlatSB_Internal_NotifyWinEvent(pWState, EVENT_SYSTEM_SCROLLINGEND,
                                       INDEXID_CONTAINER);
        //  Redraw the components.
        FlatSB_NCHitTestProc(pWState, hwnd, 0, 0, TRUE);
    }
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_DoScroll() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_DoScroll(WSBState *pWState, int cmd, int pos, BOOL fVert)
{
    if (pWState->sbHwnd)
    {
        pWState->fInDoScroll++;
        SendMessage(pWState->sbHwnd, (fVert ? WM_VSCROLL : WM_HSCROLL), (WPARAM)(LOWORD(pos) << 16 | (cmd & 0xffff)), (LPARAM)NULL);
        pWState->fInDoScroll--;
    }
}


//=-------------------------------------------------------------------------
//  TimerScroll()
//=--------------------------------------------------------------------------

VOID CALLBACK TimerScroll(HWND hwnd, UINT message, UINT_PTR id, DWORD time)
{
    LONG    pos;
    POINT   pt;
    UINT    dblClkTime, dtScroll;
    WSBState * pWState;
    RECT    rcWindow;


    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if ((pWState == (WSBState *)NULL) || (pWState == WSB_UNINIT_HANDLE))    {
        KillTimer(hwnd, IDSYS_SCROLL);
        return;
    }

    ASSERT(hwnd != GetDesktopWindow());

    pos = GetMessagePos();
    pt.x = GET_X_LPARAM(pos), pt.y = GET_Y_LPARAM(pos);
    dblClkTime = GetDoubleClickTime();
    dtScroll = (dblClkTime * 4) / 5;
    GetWindowRect(hwnd, &rcWindow);

    pt.x -= rcWindow.left;
    pt.y -= rcWindow.top;

    pos = LOWORD(pt.y) << 16 | LOWORD(pt.x);
    FlatSB_Internal_TrackBox(pWState, WM_NULL, 0, (LPARAM) pos);

    if (pWState->fHitOld)
    {
        pWState->hTimerSB = SetTimer(hwnd, IDSYS_SCROLL, dtScroll / 8, TimerScroll);
        FlatSB_Internal_DoScroll(pWState, pWState->cmdSB, 0, pWState->fTrackVert);
    }
    return;
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_TrackBox() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_TrackBox(WSBState * pWState, int message, WPARAM wParam, LPARAM lParam)
{
    HWND hwnd = pWState->sbHwnd;
    BOOL fHit, fVert = pWState->fTrackVert;
    BOOL fHitOld = pWState->fHitOld;
    POINT pt;
    int cmsTimer;
    UINT dblClkTime, dtScroll;

    if (message && (message < WM_MOUSEFIRST || message > WM_MOUSELAST))
        return;

    dblClkTime = GetDoubleClickTime();
    dtScroll = (dblClkTime * 4) / 5;

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);

    fHit = PtInRect(&(pWState->rcTrack), pt);

    if (fHit != fHitOld)   {
        pWState->fHitOld = fHit;
        FlatSB_Internal_DrawInvertScrollArea(pWState, fHit, pWState->cmdSB);
    }

    cmsTimer = dtScroll / 8;

    switch (message)
    {
        case WM_LBUTTONUP:
            FlatSB_Internal_EndScroll(pWState, FALSE);
            break;

        case WM_LBUTTONDOWN:
            pWState->hTimerSB = 0;
            cmsTimer = dtScroll;

            /*** FALL THRU ***/

        case WM_MOUSEMOVE:
            if (fHit && (fHit != fHitOld))
            {
                /* We moved back into the normal rectangle: reset timer */
                pWState->hTimerSB = SetTimer(hwnd, IDSYS_SCROLL, cmsTimer, TimerScroll);
                FlatSB_Internal_DoScroll(pWState, pWState->cmdSB, 0, fVert);
            }
    }
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_TrackThumb() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_TrackThumb(WSBState * pWState, int message, WPARAM wParam, LPARAM lParam)
{
    HWND    hwnd = pWState->sbHwnd;
    BOOL    fVert = pWState->fTrackVert;
    POINT   pt;

    if (message < WM_MOUSEFIRST || message > WM_MOUSELAST)
        return;

    // Make sure that the SBINFO structure contains data for the
    // window being tracked -- if not, recalculate data in SBINFO
    if (pWState->fTrackVert != pWState->fVertSB)
        FlatSB_Internal_CalcSBStuff(pWState, pWState->fTrackVert);

    pt.x = GET_X_LPARAM(lParam);
    pt.y = GET_Y_LPARAM(lParam);
     if (!PtInRect(&(pWState->rcTrack), pt))
        pWState->px = pWState->pxStart;
    else
    {
        pWState->px = (fVert ? GET_Y_LPARAM(lParam) : GET_X_LPARAM(lParam)) + pWState->dpxThumb;
        if (pWState->px < pWState->pxUpArrow)
            pWState->px = pWState->pxUpArrow;
        else if (pWState->px >= (pWState->pxDownArrow - pWState->cpxThumb))
            pWState->px = pWState->pxDownArrow - pWState->cpxThumb;
    }

    FlatSB_Internal_MoveThumb(pWState, pWState->px);

    if (message == WM_LBUTTONUP)
        FlatSB_Internal_EndScroll(pWState, FALSE);
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_SBTrackLoop() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_SBTrackLoop(WSBState * pWState, LPARAM lParam)
{
    HWND    hwnd = pWState->sbHwnd;
    MSG     msg;
    int     cmd, newlParam;
    POINT   pt;

    if (!pWState->fTracking)
        return;

    FlatSB_Internal_NotifyWinEvent(pWState, EVENT_SYSTEM_SCROLLINGSTART,
                                   INDEXID_CONTAINER);

    (*(pWState->pfnSB))(pWState, WM_LBUTTONDOWN, 0, lParam);

    while (GetCapture() == hwnd)
    {
        if (!GetMessage(&msg, NULL, 0, 0))
            break;

        if (!CallMsgFilter(&msg, MSGF_SCROLLBAR)) {
            cmd = msg.message;

            if (msg.hwnd == hwnd &&
                ((cmd >= WM_MOUSEFIRST && cmd <= WM_MOUSELAST) ||
                (cmd >= WM_KEYFIRST && cmd <= WM_KEYLAST  )    ))
            {
            // Process Key
#define ALT_PRESSED 0x20000000L
                if (cmd >= WM_SYSKEYDOWN
                    && cmd <= WM_SYSDEADCHAR
                    && msg.lParam & ALT_PRESSED)
                    cmd -= (WM_SYSKEYDOWN - WM_KEYDOWN);
#undef ALT_PRESSED
                if (!pWState->fTracking)
                    return;

                // Change to coordinates according to left-top corner of the window.
                pt.x = GET_X_LPARAM(msg.lParam) + pWState->rcClient.left;
                pt.y = GET_Y_LPARAM(msg.lParam) + pWState->rcClient.top;

                newlParam = LOWORD(pt.y) << 16 | LOWORD(pt.x);

                (*(pWState->pfnSB))(pWState, cmd, msg.wParam, (LPARAM)newlParam);
            } else {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
    }
}

//=-------------------------------------------------------------------------
//  FlatSB_Internal_SBTrackInit() -
//=-------------------------------------------------------------------------

void FlatSB_Internal_SBTrackInit(WSBState * pWState, HWND hwnd, LPARAM lParam, int hitArea, BOOL fDirect)
{
    int     hitX = GET_X_LPARAM(lParam);
    int     hitY = GET_Y_LPARAM(lParam);
    int     px;
    int    *pwX;
    int    *pwY;
    int     wDisable;   // Scroll bar disable flags;
    RECT    rcWindow;
    BOOL    fVert;
    POINT   pt;

    // hitArea = 0 indicates a scroll bar control
    // otherwise, curArea will have the hit test area

    if (hitArea == HTHSCROLL)
        fVert = FALSE;
    else if (hitArea == HTVSCROLL)
        fVert = TRUE;
    else
        return;

    ASSERT(hwnd != GetDesktopWindow());

    GetWindowRect(hwnd, &rcWindow);
    pt.x = GET_X_LPARAM(lParam) - rcWindow.left;
    pt.y = GET_Y_LPARAM(lParam) - rcWindow.top;
    lParam = LOWORD(pt.y) << 16 | LOWORD(pt.x);

    wDisable = FlatSB_Internal_GetSBFlags(pWState, fVert);

    if ((wDisable & ESB_DISABLE_BOTH) == ESB_DISABLE_BOTH)  {
        // Whole Scroll Bar is disabled -- do not respond
        pWState->pfnSB = NULL;
        pWState->fTracking = FALSE;
        return;
    }

    pWState->hTimerSB = 0;
    pWState->fHitOld = FALSE;
    pWState->fTracking = FALSE;

    //  For the case we click on scroll bar of a nonactive window. The mode is set to FLAT
    //  by HitTestProc. This will work because we set the tracking flag right away.
    if (fVert)  {
        pWState->fVActive = TRUE;   pWState->fHActive = FALSE;
    } else  {
        pWState->fHActive = TRUE;   pWState->fVActive = FALSE;
    }

    //  This will give us the right locMouse. We will keep it till EndScroll.
    FlatSB_Internal_CalcSBStuff(pWState, fVert);

    //  From now till EndScroll, CalcSBStuff won't compute new locMouse.
    pWState->pfnSB = FlatSB_Internal_TrackBox;
    pWState->fTracking = TRUE;

    // Initialize rcSB to the Rectangle of the Entire Scroll Bar
    pwX = (int *)&(pWState->rcSB);
    pwY = pwX + 1;

    if (!fVert)
        pwX = pwY--;

    pwX[0] = pWState->pxLeft;
    pwY[0] = pWState->pxTop;
    pwX[2] = pWState->pxRight;
    pwY[2] = pWState->pxBottom;

    px = (fVert ? pt.y : pt.x);

    pWState->px = px;
    if (px < pWState->pxUpArrow)
    {   // The click occurred on Left/Up arrow
        if(wDisable & LTUPFLAG)
        {   // Disabled -- do not respond
            pWState->pfnSB = NULL;
            pWState->fTracking = FALSE;
            return;
        }

        // LINEUP -- make rcSB the Up Arrow's Rectangle
        pWState->cmdSB = SB_LINEUP;
        pwY[2] = pWState->pxUpArrow;
    }
    else if (px >= pWState->pxDownArrow)
    {   // The click occurred on Right/Down arrow
        if(wDisable & RTDNFLAG)
        {   // Disabled -- do not respond
            pWState->pfnSB = NULL;
            pWState->fTracking = FALSE;
            return;
        }

        // LINEDOWN -- make rcSB the Down Arrow's Rectangle
        pWState->cmdSB = SB_LINEDOWN;
        pwY[0] = pWState->pxDownArrow;
    }
    else if (px < pWState->pxThumbTop)
    {
        // PAGEUP -- make rcSB the rectangle between Up Arrow and Thumb
        pWState->cmdSB = SB_PAGEUP;

        pwY[0] = pWState->pxUpArrow;
        pwY[2] = pWState->pxThumbTop;
    }
    else if (px < pWState->pxThumbBottom)
    {
DoThumbPos:
        if (pWState->pxDownArrow - pWState->pxUpArrow <= pWState->cpxThumb) {
            // Not enough room -- elevator isn't there
            pWState->pfnSB = NULL;
            pWState->fTracking = FALSE;
            return;
        }
        // THUMBPOSITION -- we're tracking with the thumb
        pWState->cmdSB = SB_THUMBPOSITION;
        pWState->fTrackVert = fVert;
        CopyRect(&(pWState->rcTrack), &(pWState->rcSB));

        if (pWState->sbGutter < 0) {
            // Negative gutter means "infinite size"
            pWState->rcTrack.top = MINLONG;
            pWState->rcTrack.left = MINLONG;
            pWState->rcTrack.right = MAXLONG;
            pWState->rcTrack.bottom = MAXLONG;
        } else
        if (fVert)
            InflateRect(&(pWState->rcTrack),
                        (pWState->rcTrack.right - pWState->rcTrack.left) * pWState->sbGutter,
                        pWState->y_VSBThumb * pWState->sbGutter);
        else
            InflateRect(&(pWState->rcTrack),
                        pWState->x_HSBThumb * pWState->sbGutter,
                        (pWState->rcTrack.bottom - pWState->rcTrack.top) * pWState->sbGutter);

        pWState->pfnSB = FlatSB_Internal_TrackThumb;
        pWState->pxOld  = pWState->pxStart  = pWState->pxThumbTop;
        pWState->posOld = pWState->posNew = pWState->posStart = fVert?pWState->sbVThumbPos:pWState->sbHThumbPos;
        pWState->dpxThumb = pWState->pxThumbTop - pWState->px;

        SetCapture(hwnd);
        FlatSB_Internal_DoScroll(pWState, SB_THUMBTRACK, pWState->posOld, fVert);
        FlatSB_Internal_DrawThumb(pWState, fVert);
    }
    else if (px < pWState->pxDownArrow)
    {
        // PAGEDOWN -- make rcSB the rectangle between Thumb and Down Arrow
        pWState->cmdSB = SB_PAGEDOWN;

        pwY[0] = pWState->pxThumbBottom;
        pwY[2] = pWState->pxDownArrow;
    }

    // NT5-style tracking:  Shift+Click = "Go here"
    if (g_bRunOnNT5 && fDirect && pWState->cmdSB != SB_LINEUP && pWState->cmdSB != SB_LINEDOWN) {
        if (pWState->cmdSB != SB_THUMBPOSITION) {
            goto DoThumbPos;
        }
        pWState->dpxThumb = -(pWState->cpxThumb / 2);
    }

    if (pWState->cmdSB != SB_THUMBPOSITION) {
        pWState->fTrackVert = fVert;
        SetCapture(hwnd);
        CopyRect(&(pWState->rcTrack), &(pWState->rcSB));
    }

    FlatSB_Internal_SBTrackLoop(pWState, lParam);
}

//=-------------------------------------------------------------------------
//  GetScroll...() -
//=-------------------------------------------------------------------------

int WINAPI FlatSB_GetScrollPos(HWND hwnd, int code)
{
    WSBState * pWState;

    ASSERT (code != SB_CTL);

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return GetScrollPos(hwnd, code);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        return 0;
    } else if (pWState->sbHwnd != hwnd) {
        return 0;
    } else  {
        return ((code == SB_VERT)?pWState->sbVThumbPos:pWState->sbHThumbPos);
    }
}

BOOL WINAPI FlatSB_GetScrollPropPtr(HWND hwnd, int propIndex, PINT_PTR pValue)
{
    WSBState * pWState;

    if (!pValue)
        return FALSE;
    else
        *pValue = 0;    //  If we can't set it, we reset it.

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return FALSE;
    } else if (pWState == WSB_UNINIT_HANDLE) {
        pWState = FlatSB_Internal_InitPwSB(hwnd);
        if (pWState == (WSBState *)NULL)
            return FALSE;
        else if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0,  (ULONG_PTR)pWState)) {
            DeleteObject(pWState->hbm_Bkg);
            DeleteObject(pWState->hbr_Bkg);
            LocalFree((HLOCAL)pWState);
            return FALSE;
        } else  {
        //  Fall through.
        }
    } else if (pWState->sbHwnd != hwnd) {
        return FALSE;
    }

    switch (propIndex)  {
    case WSB_PROP_CYVSCROLL:
        *pValue = pWState->metApp.cyVSBArrow;
        break;
    case WSB_PROP_CXVSCROLL:
        *pValue = pWState->metApp.cxVSBArrow;
        break;
    case WSB_PROP_CYHSCROLL:
        *pValue = pWState->metApp.cyHSBArrow;
        break;
    case WSB_PROP_CXHSCROLL:
        *pValue = pWState->metApp.cxHSBArrow;
        break;
    case WSB_PROP_CXHTHUMB:
        *pValue = pWState->metApp.cxHSBThumb;
        break;
    case WSB_PROP_CYVTHUMB:
        *pValue = pWState->metApp.cyVSBThumb;
        break;
    case WSB_PROP_WINSTYLE:
        //  To check if a scrollbar is present, the WF(HV)PRESENT bits may
        //  be more useful than WS_(HV)SCROLL bits.
        *pValue = pWState->style;
        break;
    case WSB_PROP_HSTYLE:
        *pValue = pWState->hStyle;
        break;
    case WSB_PROP_VSTYLE:
        *pValue = pWState->vStyle;
        break;
    case WSB_PROP_HBKGCOLOR:
        *pValue = pWState->col_HSBBkg;
        break;
    case WSB_PROP_VBKGCOLOR:
        *pValue = pWState->col_VSBBkg;
        break;
    case WSB_PROP_PALETTE:
        *pValue = (INT_PTR)pWState->hPalette;
        break;
    case WSB_PROP_GUTTER:
        *pValue = pWState->sbGutter;
        break;
    default:
        return FALSE;
    }
    return TRUE;
}

#ifdef _WIN64

BOOL WINAPI FlatSB_GetScrollProp(HWND hwnd, int propIndex, LPINT pValue)
{
    INT_PTR iValue;
    BOOL fRc;

    if (!pValue)
        return FALSE;

#ifdef DEBUG
    if (propIndex == WSB_PROP_PALETTE)
    {
        TraceMsg(TF_ERROR, "FlatSB_GetScrollProp(WSB_PROP_PALETTE): Use GetScrollPropPtr for Win64 compat");
    }
#endif

    fRc = FlatSB_GetScrollPropPtr(hwnd, propIndex, &iValue);
    *pValue = (int)iValue;

    return fRc;
}
#endif

BOOL WINAPI FlatSB_GetScrollRange(HWND hwnd, int code, LPINT lpposMin, LPINT lpposMax)
{
    int     *pw;
    WSBState * pWState;

    ASSERT(code != SB_CTL);
    if (!lpposMin || !lpposMax)
        return FALSE;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return GetScrollRange(hwnd, code, lpposMin, lpposMax);
//        *lpposMin = 0;
//        *lpposMax = 0;
    } else if (pWState == WSB_UNINIT_HANDLE) {
        *lpposMin = 0;
        *lpposMax = 0;
    } else if (pWState->sbHwnd != hwnd) {
        return FALSE;
    } else {
        pw = (code == SB_VERT) ? &(pWState->sbVMinPos) : &(pWState->sbHMinPos);
        *lpposMin = pw[SBO_MIN];
        *lpposMax = pw[SBO_MAX];
    }

    return TRUE;
}

BOOL WINAPI FlatSB_GetScrollInfo(HWND hwnd, int fnBar, LPSCROLLINFO lpsi)
{
    int *pw;
    WSBState * pWState;

    ASSERT(fnBar != SB_CTL);

    //  ZDC@Oct. 10, Detect GP faults here.
    if ((LPSCROLLINFO)NULL == lpsi)
        return FALSE;

    if (lpsi->cbSize < sizeof (SCROLLINFO))
        return FALSE;

    //  ZDC@Oct. 11, Don't zero out buffer anymore.
    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return GetScrollInfo(hwnd, fnBar, lpsi);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        return FALSE;
    } else if (pWState->sbHwnd != hwnd) {
        return FALSE;
    } else if (fnBar == SB_VERT)    {
        pw = &(pWState->sbVMinPos);
    } else if (fnBar == SB_HORZ)    {
        pw = &(pWState->sbHMinPos);
    } else {
        return FALSE;
    }

    if (lpsi->fMask & SIF_RANGE)
        lpsi->nMin = pw[SBO_MIN], lpsi->nMax = pw[SBO_MAX];
    if (lpsi->fMask & SIF_POS)
        lpsi->nPos = pw[SBO_POS];
    if (lpsi->fMask & SIF_PAGE)
        lpsi->nPage = pw[SBO_PAGE];
    // ZDC@Oct 9, Add support for SIF_TRACKPOS
    if (lpsi->fMask & SIF_TRACKPOS) {
        //  This is the olny place that pfnSB is used instead of fTracking.
        if (pWState->pfnSB != NULL) {
            if ((fnBar == SB_VERT) && pWState->fTrackVert)
                lpsi->nTrackPos = pWState->posNew;
            else if ((fnBar == SB_HORZ) && !(pWState->fTrackVert))
                lpsi->nTrackPos = pWState->posNew;
            else
                lpsi->nTrackPos = pw[SBO_POS];
        } else
            lpsi->nTrackPos = pw[SBO_POS];
    }

    return TRUE;
}

BOOL WINAPI FlatSB_ShowScrollBar(HWND hwnd, int fnBar, BOOL fShow)
{
    BOOL fChanged = FALSE;
    int newStyle = 0;
    WSBState * pWState;

    ASSERT(fnBar != SB_CTL);

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)
        return ShowScrollBar(hwnd, fnBar, fShow);

    switch (fnBar) {
    case SB_VERT:
        newStyle = WS_VSCROLL;
        break;
    case SB_HORZ:
        newStyle = WS_HSCROLL;
        break;
    case SB_BOTH:
        newStyle = WS_VSCROLL | WS_HSCROLL;
        break;
    default:
        return FALSE;
    }

    if (pWState == WSB_UNINIT_HANDLE) {
        if (fShow)  {
            pWState = FlatSB_Internal_InitPwSB(hwnd);
            if (pWState == (WSBState *)NULL)
                return FALSE;
            else if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0,  (ULONG_PTR)pWState)) {
                DeleteObject(pWState->hbm_Bkg);
                DeleteObject(pWState->hbr_Bkg);
                LocalFree((HLOCAL)pWState);
                return FALSE;
            }
        } else  {
            return FALSE;
        }
    }

    if (!fShow) {
        if (pWState->style & newStyle) {
            fChanged = TRUE;
            pWState->style &= ~newStyle;
        }
    } else {
        if ((pWState->style & newStyle) != newStyle)    {
            fChanged = TRUE;
            pWState->style |= newStyle;
        }
    }

    if (fChanged) {
        // Keep USER scrollbars in sync for accessibility
        ShowScrollBar(hwnd, fnBar, fShow);
        CCInvalidateFrame(hwnd);
    }

    return TRUE;
}

//=------------------------------------------------------------------
//  Following functions are ported from winsb.c in user code.
//=------------------------------------------------------------------

//=--------------------------------------------------------------
// InitPwSB
//     [in]    hwnd
// Note:
//     This function is only a memory allocating func. It won't
//     do any check. On the other hand, this function should be
//     called before any consequent functions are used.
//=--------------------------------------------------------------

WSBState * FlatSB_Internal_InitPwSB(HWND hwnd)
{
    int     patGray[4];
    HBITMAP hbm;
    WSBState * pw;

    pw = (WSBState *)LocalAlloc(LPTR, sizeof(WSBState));
    // The buffer should already be zero-out.

    if (pw == (WSBState *)NULL)
        return pw;

    patGray[0] = 0x005500AA;
    patGray[1] = 0x005500AA;
    patGray[2] = 0x005500AA;
    patGray[3] = 0x005500AA;

    pw->sbVMaxPos = pw->sbHMaxPos = 100;
    pw->sbHwnd = hwnd;

    // We start out with app metrics equal to system metrics
    FlatSB_InitWSBMetrics(pw);
    pw->metApp = pw->metSys;

    //
    //  NT5's gutter is 8; Win9x's and NT4's gutter is 2.
    //
    pw->sbGutter = g_bRunOnNT5 ? 8 : 2;

    // ZDC
    //     make sure get hbm_Bkg and hbr_Bkg deleted.
    hbm = CreateBitmap(8, 8, 1, 1, (LPSTR)patGray);

    if ((HBITMAP)NULL == hbm)   {
        LocalFree((HLOCAL)pw);
        return NULL;
    }

    pw->hbr_VSBBkg = CreatePatternBrush(hbm);
    if ((HBRUSH)NULL == pw->hbr_VSBBkg)  {
        DeleteObject(hbm);
        LocalFree((HLOCAL)pw);
        return NULL;
    }

    pw->hbr_Bkg = pw->hbr_HSBBkg = pw->hbr_VSBBkg;
    pw->col_VSBBkg = pw->col_HSBBkg = RGB(255, 255, 255);
    pw->hbm_Bkg = hbm;
    pw->hStyle = pw->vStyle = FSB_FLAT_MODE;    //  Default state: Flat.
    pw->ptMouse.x = -1;
    pw->ptMouse.y = -1;

    return(pw);
}

void FlatSB_Internal_RedrawScrollBar(WSBState * pWState, BOOL fVert)
{
    HDC hdc;

    hdc = GetWindowDC(pWState->sbHwnd);
    FlatSB_Internal_DrawScrollBar(pWState, hdc, fVert, TRUE);
    ReleaseDC(pWState->sbHwnd, hdc);
}

//=-------------------------------------------------------------
// FlatSB_Internal_GetSBFlags
//=-------------------------------------------------------------

UINT FlatSB_Internal_GetSBFlags(WSBState * pWState, BOOL fVert)
{
    int wFlags;

    if (pWState == (WSBState *)NULL)    {
        return(0);
    }

    wFlags = pWState->sbFlags;

    return(fVert ? (wFlags & WSB_VERT) >> 2 : wFlags & WSB_HORZ);
}

//=--------------------------------------------------------------
//  return TRUE if there is a change.
//=--------------------------------------------------------------

BOOL WINAPI FlatSB_EnableScrollBar(HWND hwnd, int wSBflags, UINT wArrows)
{
    WSBState * pWState;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return EnableScrollBar(hwnd, wSBflags, wArrows);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        if (wArrows == ESB_ENABLE_BOTH)
            //  Leave it to later calls.
            return FALSE;
        else    {
            pWState = FlatSB_Internal_InitPwSB(hwnd);
            if (pWState == (WSBState *)NULL)
                return FALSE;
            else if (!SetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0,  (ULONG_PTR)pWState)) {
                DeleteObject(pWState->hbm_Bkg);
                DeleteObject(pWState->hbr_Bkg);
                LocalFree((HLOCAL)pWState);
                return FALSE;
            }
        }
    } else if (hwnd != pWState->sbHwnd) {
        return FALSE;
    }

    return FlatSB_Internal_EnableScrollBar(pWState, wSBflags, wArrows);
}

//=-------------------------------------------------------------
// FlatSB_Internal_EnableScrollBar
//
// Note:
//     The func will simply fail in case of uninitialized pointer
//     pWState is passed.
//     Since we now use WSBState * as handle, we always hope it's
//     valid already.
//
//     The following func is implemented following the comments in
//     winsbctl.c and the comment of the in MSDN library. In
//     access\inc16\windows.h you can find:
//     #define SB_DISABLE_MASK ESB_DISABLE_BOTH    // 0x03
//
//     The sbFlags is slightly different with rgwScroll[SB_FLAGS].
//=-------------------------------------------------------------

BOOL FlatSB_Internal_EnableScrollBar(WSBState * pWState, int wSBflags, UINT wArrows)
{
    int     wOldFlags;
    int     style;
    BOOL    bRetValue = FALSE;
    BOOL    bDrawHBar = FALSE;
    BOOL    bDrawVBar = FALSE;
    HDC     hdc;
    HWND    hwnd;

    ASSERT (wSBflags != SB_CTL);

    wOldFlags = pWState->sbFlags;
    hwnd = pWState->sbHwnd;

    style = GetWindowLong(hwnd, GWL_STYLE);

    switch (wSBflags)   {
    case SB_HORZ:
    case SB_BOTH:
        if (wArrows == ESB_ENABLE_BOTH)
            pWState->sbFlags &= ~WSB_HORZ;
        else
            pWState->sbFlags |= wArrows;

        if (wOldFlags != pWState->sbFlags)
        {
            bRetValue = TRUE;

            if (TestSTYLE(pWState->style, WFHPRESENT)
                && !TestSTYLE(style, WS_MINIMIZE)
                && IsWindowVisible(hwnd))
                bDrawHBar = TRUE;
        }

        if (wSBflags == SB_HORZ)
            break;
        else
            wOldFlags = pWState->sbFlags;       //  Fall through

    case SB_VERT:
        if (wArrows == ESB_ENABLE_BOTH)
            pWState->sbFlags &= ~WSB_VERT;
        else
            pWState->sbFlags |= (wArrows<<2);

        if (wOldFlags != pWState->sbFlags)
        {
            bRetValue = TRUE;

            if (TestSTYLE(pWState->style, WFVPRESENT)
                && !TestSTYLE(style, WS_MINIMIZE)
                && IsWindowVisible(hwnd))
                bDrawVBar = TRUE;
        }
        break;
    default:
        return FALSE;
    }

    if (bDrawVBar || bDrawHBar) {
        int oldLoc = pWState->locMouse;
        int newLoc;

        if (!(hdc = GetWindowDC(hwnd)))
            return(FALSE);

        newLoc = oldLoc;
        if (bDrawHBar)  {
            FlatSB_Internal_DrawScrollBar(pWState, hdc, FALSE, FALSE);
            if (pWState->fHActive)
                newLoc = pWState->locMouse;
        }
        if (bDrawVBar) {
            pWState->locMouse = oldLoc;
            FlatSB_Internal_DrawScrollBar(pWState, hdc, TRUE, FALSE);
            if (pWState->fVActive)
                newLoc = pWState->locMouse;
        }
        pWState->locMouse = newLoc;

        ReleaseDC(hwnd, hdc);
    }

    // Keep USER scrollbar in sync for accessibility
    if (bRetValue)
        EnableScrollBar(hwnd, wSBflags, wArrows);

    return bRetValue;
}

//=-------------------------------------------------------------
// FlatSB_Internal_DrawThumb2
//=-------------------------------------------------------------

void FlatSB_Internal_DrawThumb2(WSBState * pWState, HDC hdc, BOOL fVert, UINT wDisable)
{
    int     *pLength;
    int     *pWidth;
    HWND    hwnd;
    HBRUSH  hbr;

    hwnd = pWState->sbHwnd;
    hbr = (fVert)?pWState->hbr_VSBBkg:pWState->hbr_HSBBkg;

    // Bail out if the scrollbar has an empty rect
    if ((pWState->pxTop >= pWState->pxBottom)
        || (pWState->pxLeft >= pWState->pxRight))
        return;

    pLength = (int *) &(pWState->rcSB);
    if (fVert)
        pWidth = pLength++;
    else
        pWidth = pLength + 1;

    pWidth[0] = pWState->pxLeft;
    pWidth[2] = pWState->pxRight;

    // If both scroll arrows are disabled or if there isn't enough room for
    // the thumb, just erase the whole slide area and return
    if (((wDisable & LTUPFLAG) && (wDisable & RTDNFLAG)) ||
        ((pWState->pxDownArrow - pWState->pxUpArrow) < pWState->cpxThumb))
    {
        pLength[0] = pWState->pxUpArrow;
        pLength[2] = pWState->pxDownArrow;

        FlatSB_Internal_DrawGroove(pWState, hdc, &(pWState->rcSB), fVert);
        return;
    }

    //  UI designers want a at least 1 pixel gap between arrow and thumb.
    //  Have to do this :(
    if (pWState->pxUpArrow <= pWState->pxThumbTop)
    {
        // Fill in space above Thumb
        pLength[0] = pWState->pxUpArrow;
        pLength[2] = pWState->pxThumbTop;

        FlatSB_Internal_DrawGroove(pWState, hdc, &(pWState->rcSB), fVert);
    }

    if (pWState->pxThumbBottom <= pWState->pxDownArrow)
    {
        // Fill in space below Thumb
        pLength[0] = pWState->pxThumbBottom;
        pLength[2] = pWState->pxDownArrow;

        FlatSB_Internal_DrawGroove(pWState, hdc, &(pWState->rcSB), fVert);
    }

    // Draw elevator
    pLength[0] = pWState->pxThumbTop;
    pLength[2] = pWState->pxThumbBottom;

    FlatSB_Internal_DrawElevator(pWState, hdc, &(pWState->rcSB), fVert);

    // If we're tracking a page scroll, then we've obliterated the hilite.
    // We need to correct the hiliting rectangle, and rehilite it.

    if ((pWState->cmdSB == SB_PAGEUP || pWState->cmdSB == SB_PAGEDOWN)
        && pWState->fTrackVert == fVert)
    {
        pLength = (int *) &pWState->rcTrack;

        if (fVert)
            pLength++;

        if (pWState->cmdSB == SB_PAGEUP)
            pLength[2] = pWState->pxThumbTop;
        else
            pLength[0] = pWState->pxThumbBottom;

        if (pLength[0] < pLength[2])
            InvertRect(hdc, &(pWState->rcTrack));
    }
}

//=-------------------------------------------------------------
// DrawSB2
//=-------------------------------------------------------------

void FlatSB_Internal_DrawSB2(WSBState * pWState, HDC hdc, BOOL fVert, BOOL fRedraw, int oldLoc)
{
    int     cLength;
    int     cWidth;
    int     cpxArrow;
    int     *pwX;
    int     *pwY;
    int     newLoc = pWState->locMouse;
    UINT    wDisable = FlatSB_Internal_GetSBFlags(pWState, fVert);
    HBRUSH  hbrSave;
    HWND    hwnd;
    RECT    rc, * prcSB;

    hwnd = pWState->sbHwnd;
    cLength = (pWState->pxBottom - pWState->pxTop) / 2;
    cWidth = (pWState->pxRight - pWState->pxLeft);

    if ((cLength <= 0) || (cWidth <= 0))
        return;

    cpxArrow = (fVert) ? pWState->y_VSBArrow : pWState->x_HSBArrow;

    if (cLength > cpxArrow)
        cLength = cpxArrow;
    prcSB = &(pWState->rcSB);
    pwX = (int *)prcSB;
    pwY = pwX + 1;
    if (!fVert)
        pwX = pwY--;

    pwX[0] = pWState->pxLeft;
    pwY[0] = pWState->pxTop;
    pwX[2] = pWState->pxRight;
    pwY[2] = pWState->pxBottom;

    hbrSave = SelectObject(hdc, GetSysColorBrush(COLOR_BTNTEXT));

    CopyRect(&rc, prcSB);
    if (fVert)
    {
        rc.bottom = rc.top + cLength;
        if (!fRedraw || newLoc == WSB_MOUSELOC_ARROWUP
                     || oldLoc == WSB_MOUSELOC_ARROWUP)
            FlatSB_Internal_DrawArrow(pWState, hdc, &rc, DFCS_SCROLLUP,
               ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));

        rc.bottom = prcSB->bottom;
        rc.top = prcSB->bottom - cLength;
        if (!fRedraw || newLoc == WSB_MOUSELOC_ARROWDN
                     || oldLoc == WSB_MOUSELOC_ARROWDN)
            FlatSB_Internal_DrawArrow(pWState, hdc, &rc, DFCS_SCROLLDOWN,
               ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
    }
    else
    {
        rc.right = rc.left + cLength;
        if (!fRedraw || newLoc == WSB_MOUSELOC_ARROWLF
                     || oldLoc == WSB_MOUSELOC_ARROWLF)
            FlatSB_Internal_DrawArrow(pWState, hdc, &rc, DFCS_SCROLLLEFT,
                ((wDisable & LTUPFLAG) ? DFCS_INACTIVE : 0));

        rc.right = prcSB->right;
        rc.left = prcSB->right - cLength;
        if (!fRedraw || newLoc == WSB_MOUSELOC_ARROWRG
                     || oldLoc == WSB_MOUSELOC_ARROWRG)
            FlatSB_Internal_DrawArrow(pWState, hdc, &rc, DFCS_SCROLLRIGHT,
                ((wDisable & RTDNFLAG) ? DFCS_INACTIVE : 0));
    }

    SelectObject(hdc, hbrSave);

    if (!fRedraw)
        FlatSB_Internal_DrawThumb2(pWState, hdc, fVert, wDisable);
    else if (!fVert  || newLoc == WSB_MOUSELOC_H_THUMB
                     || oldLoc == WSB_MOUSELOC_H_THUMB)
        FlatSB_Internal_DrawThumb2(pWState, hdc, fVert, wDisable);
    else if (fVert   || newLoc == WSB_MOUSELOC_V_THUMB
                     || oldLoc == WSB_MOUSELOC_V_THUMB)
        FlatSB_Internal_DrawThumb2(pWState, hdc, fVert, wDisable);
    else
        return;
}

//=-------------------------------------------------------------
// FlatSB_Internal_CalcSBStuff2
//=-------------------------------------------------------------

void FlatSB_Internal_CalcSBStuff2(WSBState * pWState, LPRECT lprc, BOOL fVert)
{
    int     cpxThumb;    // Height of (V)scroll bar thumb.
    int     cpxArrow;    // Height of (V)scroll bar arrow.
    int     cpxSpace;    // The space in scroll bar;
    int     pxTop;
    int     pxBottom;
    int     pxLeft;
    int     pxRight;
    int     pxUpArrow;
    int     pxDownArrow;
    int     pxThumbTop;
    int     pxThumbBottom;
    int     pxMouse;
    int     locMouse;
    int     dwRange, page, relPos;
    BOOL    fSBActive;

    if (fVert) {
        pxTop    = lprc->top;
        pxBottom = lprc->bottom;
        pxLeft   = lprc->left;
        pxRight  = lprc->right;
        cpxArrow = pWState->y_VSBArrow;
        cpxThumb = pWState->y_VSBThumb;
        relPos = pWState->sbVThumbPos - pWState->sbVMinPos;
        page = pWState->sbVPage;
        dwRange = pWState->sbVMaxPos - pWState->sbVMinPos + 1;
        pxMouse = pWState->ptMouse.y;
        fSBActive = pWState->fVActive;
    } else {
        // For horiz scroll bars, "left" & "right" are "top" and "bottom",
        // and vice versa.
        pxTop    = lprc->left;
        pxBottom = lprc->right;
        pxLeft   = lprc->top;
        pxRight  = lprc->bottom;
        cpxArrow = pWState->x_HSBArrow;
        cpxThumb = pWState->x_HSBThumb;
        relPos = pWState->sbHThumbPos - pWState->sbHMinPos;
        page = pWState->sbHPage;
        dwRange = pWState->sbHMaxPos - pWState->sbHMinPos + 1;
        pxMouse = pWState->ptMouse.x;
        fSBActive = pWState->fHActive;
    }

    // For the case of short scroll bars that don't have enough
    // room to fit the full-sized up and down arrows, shorten
    // their sizes to make 'em fit

    cpxArrow = min((pxBottom - pxTop) >> 1, cpxArrow);

    pxUpArrow   = pxTop    + cpxArrow;
    pxDownArrow = pxBottom - cpxArrow;

    cpxSpace = pxDownArrow - pxUpArrow;
    if (page)
    {
        // JEFFBOG -- This is the one and only place where we should
        // see 'range'.  Elsewhere it should be 'range - page'.
        cpxThumb = max(DMultDiv(cpxSpace, page, dwRange),
                        min(cpxThumb, MINITHUMBSIZE));
    }
    cpxSpace -= cpxThumb;

    pxThumbTop = DMultDiv(relPos, cpxSpace, dwRange - (page ? page : 1)) + pxUpArrow;
    pxThumbBottom = pxThumbTop + cpxThumb;

    // Save it to local structure
    pWState->pxLeft     = pxLeft;
    pWState->pxRight    = pxRight;
    pWState->pxTop      = pxTop;
    pWState->pxBottom   = pxBottom;
    pWState->pxUpArrow  = pxUpArrow;
    pWState->pxDownArrow    = pxDownArrow;
    pWState->pxThumbTop = pxThumbTop;
    pWState->pxThumbBottom  = pxThumbBottom;
    pWState->cpxArrow   = cpxArrow;
    pWState->cpxThumb   = cpxThumb;
    pWState->cpxSpace   = cpxSpace;
    pWState->fVertSB    = fVert;

    if (pWState->fTracking) {
        return;
    } else if (!fSBActive)  {
        locMouse = WSB_MOUSELOC_OUTSIDE;
    } else if (pxMouse < pxTop) {
        locMouse = WSB_MOUSELOC_OUTSIDE;
    } else if (pxMouse < pxUpArrow) {
        locMouse = WSB_MOUSELOC_ARROWUP;
    } else if (pxMouse < pxThumbTop) {
        locMouse = WSB_MOUSELOC_V_GROOVE;
    } else if (pxMouse >= pxBottom) {
        locMouse = WSB_MOUSELOC_OUTSIDE;
    } else if (pxMouse >= pxDownArrow) {
        locMouse = WSB_MOUSELOC_ARROWDN;
    } else if (pxMouse >= pxThumbBottom) {
        locMouse = WSB_MOUSELOC_V_GROOVE;
    } else    {   //   pxThumbTop <= pxMouse < pxThumbBottom
        if (pxDownArrow - pxUpArrow <= cpxThumb)    {   //  No space for thumnb.
            locMouse = WSB_MOUSELOC_V_GROOVE;
        } else  {
            locMouse = WSB_MOUSELOC_V_THUMB;
        }
    }
    if ((!fVert) && locMouse)
        locMouse += 4;

    pWState->locMouse = locMouse;
}

//=-------------------------------------------------------------
// FlatSB_Internal_CalcSBStuff
//
// Note:
//  We won't call InitPwSB in this func.
//=-------------------------------------------------------------

void FlatSB_Internal_CalcSBStuff(WSBState * pWState, BOOL fVert)
{
    HWND    hwnd;
    RECT    rcT;
    int     style;

    if (pWState == (WSBState *)NULL)
        return;

    hwnd = pWState->sbHwnd;
    style = GetWindowLong(hwnd, GWL_STYLE);

    if (fVert)
    {
        // Only add on space if vertical scrollbar is really there.
        rcT.right = rcT.left = pWState->rcClient.right;
        if (TestSTYLE(pWState->style, WFVPRESENT))
            rcT.right += pWState->x_VSBArrow;
        rcT.top = pWState->rcClient.top;
        rcT.bottom = pWState->rcClient.bottom;
    }
    else
    {
        // Only add on space if horizontal scrollbar is really there.
        rcT.bottom = rcT.top = pWState->rcClient.bottom;
        if (TestSTYLE(pWState->style, WFHPRESENT))
            rcT.bottom += pWState->y_HSBArrow;

        rcT.left = pWState->rcClient.left;
        rcT.right = pWState->rcClient.right;
    }

    FlatSB_Internal_CalcSBStuff2(pWState, &rcT, fVert);
}

//=-------------------------------------------------------------
// FlatSB_Internal_DrawThumb
//=-------------------------------------------------------------

void FlatSB_Internal_DrawThumb(WSBState * pWState, BOOL fVert)
{
    HWND    hwnd = pWState->sbHwnd;
    HDC     hdc;
    UINT    wDisableFlags;

    hdc = (HDC) GetWindowDC(hwnd);
    FlatSB_Internal_CalcSBStuff(pWState, fVert);

    wDisableFlags = FlatSB_Internal_GetSBFlags(pWState, fVert);
    FlatSB_Internal_DrawThumb2(pWState, hdc, fVert, wDisableFlags);
    ReleaseDC(hwnd, hdc);
}

BOOL FlatSB_Internal_SBSetParms(int * pw, SCROLLINFO si, BOOL * lpfScroll, LRESULT * lplres, BOOL bOldPos)
{
    // pass the struct because we modify the struct but don't want that
    // modified version to get back to the calling app

    BOOL fChanged = FALSE;

    if (bOldPos)
        // save previous position
        *lplres = pw[SBO_POS];

    if (si.fMask & SIF_RANGE)
    {
        // if the range MAX is below the range MIN -- then treat is as a
        // zero range starting at the range MIN.
        if (si.nMax < si.nMin)
            si.nMax = si.nMin;

        if ((pw[SBO_MIN] != si.nMin) || (pw[SBO_MAX] != si.nMax))
        {
            pw[SBO_MIN] = si.nMin;
            pw[SBO_MAX] = si.nMax;

            if (!(si.fMask & SIF_PAGE))
            {
                si.fMask |= SIF_PAGE;
                si.nPage = pw[SBO_PAGE];
            }

            if (!(si.fMask & SIF_POS))
            {
                si.fMask |= SIF_POS;
                si.nPos = pw[SBO_POS];
            }

            fChanged = TRUE;
        }
    }

    if (si.fMask & SIF_PAGE)
    {
        unsigned dwMaxPage = abs(pw[SBO_MAX] - pw[SBO_MIN]) + 1;

        if (si.nPage > dwMaxPage)
            si.nPage = dwMaxPage;

        if (pw[SBO_PAGE] != (int) si.nPage)
        {
            pw[SBO_PAGE] = (int) si.nPage;

            if (!(si.fMask & SIF_POS))
            {
                si.fMask |= SIF_POS;
                si.nPos = pw[SBO_POS];
            }

            fChanged = TRUE;
        }
    }

    if (si.fMask & SIF_POS)
    {
        // Clip pos to posMin, posMax - (page - 1).
        int lMaxPos = pw[SBO_MAX] - ((pw[SBO_PAGE]) ? pw[SBO_PAGE] - 1 : 0);

        // * BOGUS -- show this to SIMONK -- the following doesn't generate *
        // * proper code so I had to use the longer form                    *
        // * si.nPos = min(max(si.nPos, pw[SBO_MIN]), lMaxPos);             *

        if (si.nPos < pw[SBO_MIN])
            si.nPos = pw[SBO_MIN];
        else if (si.nPos > lMaxPos)
            si.nPos = lMaxPos;

        if (pw[SBO_POS] != si.nPos)
        {
            pw[SBO_POS] = si.nPos;
            fChanged = TRUE;
        }
    }

    if (!(bOldPos))
        // Return the new position
        *lplres = pw[SBO_POS];

    if (si.fMask & SIF_RANGE)
    {
        if (*lpfScroll = (pw[SBO_MIN] != pw[SBO_MAX]))
            goto checkPage;
    }
    else if (si.fMask & SIF_PAGE)
checkPage:
        *lpfScroll = (pw[SBO_PAGE] <= (pw[SBO_MAX] - pw[SBO_MIN]));

    return(fChanged);
}


//=-------------------------------------------------------------
// FlatSB_Internal_SetScrollBar
//
// Note:
//     This func is called by SetScrollPos/Range/Info. We let
//     the callers take care of checking pWState.
//     Return 0 if failed.
//=-------------------------------------------------------------

LRESULT FlatSB_Internal_SetScrollBar(WSBState *pWState, int code, LPSCROLLINFO lpsi, BOOL fRedraw)
{
    BOOL    fVert;
    int     *pw;
    BOOL    fOldScroll;
    BOOL    fScroll;
    BOOL    bReturnOldPos = TRUE;
    LRESULT lres;
    int     wfScroll;
    HWND    hwnd = pWState->sbHwnd;

    ASSERT (code != SB_CTL);

    // window must be visible to redraw
    if (fRedraw)
        fRedraw = IsWindowVisible(hwnd);

    fVert = (code != SB_HORZ);
    bReturnOldPos = (lpsi->fMask == SIF_POS);

    wfScroll = (fVert) ? WS_VSCROLL : WS_HSCROLL;

    fScroll = fOldScroll = (TestSTYLE(pWState->style, wfScroll)) ? TRUE : FALSE;

    // Don't do anything if we're NOT setting the range and the scroll doesn't
    // exist.
    if (!(lpsi->fMask & SIF_RANGE) && !fOldScroll)
    {
        return(0);
    }

    pw = &(pWState->sbFlags);

    // user.h: SBO_VERT = 5, SBO_HORZ = 1;
    //  pw += (fVert) ? SBO_VERT : SBO_HORZ;
    pw += (fVert)? 5 : 1;

    // Keep USER scrollbars in sync for accessibility
    SetScrollInfo(hwnd, code, lpsi, FALSE);

    if (!FlatSB_Internal_SBSetParms(pw, *lpsi, &fScroll, &lres, bReturnOldPos))
    {
        // no change -- but if REDRAW is specified and there's a scrollbar,
        // redraw the thumb
        if (fOldScroll && fRedraw)
            goto redrawAfterSet;

        return(lres);
    }

    if (fScroll)
        pWState->style |= wfScroll;
    else
        pWState->style &= ~wfScroll;

    // Keep style bits in sync so OLEACC can read them
    SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, pWState->style);

    if (lpsi->fMask & SIF_DISABLENOSCROLL)
    {
        if (fOldScroll)
        {
            pWState->style |= wfScroll;

            // Keep style bits in sync so OLEACC can read them
            SetWindowBits(hwnd, GWL_STYLE, WS_VSCROLL | WS_HSCROLL, pWState->style);

            FlatSB_Internal_EnableScrollBar(pWState, code, (fScroll) ? ESB_ENABLE_BOTH : ESB_DISABLE_BOTH);
        }
    }
    else if (fOldScroll ^ fScroll)
    {
        CCInvalidateFrame(hwnd);
        return(lres);
    }

    if (fScroll && fRedraw && (fVert ? TestSTYLE(pWState->style, WFVPRESENT) : TestSTYLE(pWState->style, WFHPRESENT)))
    {
redrawAfterSet:

        // Don't send this, since USER already sent one for us when we
        // called SetScrollBar.
        // FlatSB_Internal_NotifyWinEvent(pWState, EVENT_OBJECT_VALUECHANGE, INDEX_SCROLLBAR_SELF);

        // Bail out if the caller is trying to change a scrollbar which is
        // in the middle of tracking.  We'll hose FlatSB_Internal_TrackThumb() otherwise.

        // BUGBUG: CalcSBStuff will change locMouse!
        if (pWState->pfnSB == FlatSB_Internal_TrackThumb)
        {
            FlatSB_Internal_CalcSBStuff(pWState, fVert);
            return(lres);
        }
        FlatSB_Internal_DrawThumb(pWState, fVert);
    }

    return(lres);
}

//=-------------------------------------------------------------
//  SetScrollPos()
//=-------------------------------------------------------------

int WINAPI FlatSB_SetScrollPos(HWND hwnd, int code, int pos, BOOL fRedraw)
{
    SCROLLINFO  si;
    WSBState * pWState;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return SetScrollPos(hwnd, code, pos, fRedraw);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        return 0;
    } else if (hwnd != pWState->sbHwnd) {
        return 0;
    }

    si.cbSize = sizeof(si);
    si.fMask = SIF_POS;
    si.nPos = pos;
    
    return (int)FlatSB_Internal_SetScrollBar(pWState, code, &si, fRedraw);
}

//=-------------------------------------------------------------
//  SetScrollRange()
//=-------------------------------------------------------------

BOOL WINAPI FlatSB_SetScrollRange(HWND hwnd, int code, int nMin, int nMax, BOOL fRedraw)
{
    SCROLLINFO si;
    WSBState * pWState;

    GetWindowSubclass(hwnd, FlatSB_SubclassWndProc, 0, (ULONG_PTR *)&pWState);
    if (pWState == (WSBState *)NULL)    {
        return SetScrollRange(hwnd, code, nMin, nMax, fRedraw);
    } else if (pWState == WSB_UNINIT_HANDLE) {
        pWState = FlatSB_Internal_InitPwSB(hwnd);
        i