essage ( & t_Msg , NULL , 0 , 0 );

				if ( t_Result != 0 && t_Result != -1 )
                {
                    TranslateMessage ( & t_Msg ) ;
                    DispatchMessage ( & t_Msg ) ;
                }

                BOOL t_Timeout = FALSE ;

                while ( ! t_Timeout & t_Status & ! t_Processed )
                {
                    t_Event = WaitForMultipleObjects (

                        t_TaskEventArrayLength ,
                        t_TaskEventArray ,
                        FALSE ,
                        0
                    ) ;

                    ULONG t_HandleIndex = t_Event - WAIT_OBJECT_0 ;

                    if ( t_Event == 0xFFFFFFFF )
                    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle" ) ;
)

                        DWORD t_Error = GetLastError () ;
                        t_Status = FALSE ;
                    }
                    else if ( t_Event == WAIT_TIMEOUT)
                    {
                        t_Timeout = TRUE ;
                    }
                    else if ( t_HandleIndex < t_TaskEventArrayLength )
                    {
                        HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
                        t_Status = WaitAcknowledgementDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
                    }
                    else
                    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle index" ) ;
)
                        t_Status = FALSE ;
                    }
                }
            }
        }
        else if ( t_HandleIndex < t_TaskEventArrayLength )
        {
            HANDLE t_Handle = t_TaskEventArray [ t_HandleIndex ] ;
            t_Status = WaitAcknowledgementDispatch ( t_ThreadObject , t_Handle , t_Processed ) ;
        }
        else
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Handle index" ) ;
)

            t_Status = FALSE ;
        }

        delete [] t_TaskEventArray ;
    }

    return t_Status ;
}

BOOL SnmpAbstractTaskObject :: WaitAcknowledgementDispatch ( SnmpThreadObject *a_ThreadObject , HANDLE a_Handle , BOOL &a_Processed )
{
    BOOL t_Status = TRUE ;

    if ( a_Handle == m_AcknowledgementEvent.GetHandle () )
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nWait: Completed" );
)

        m_AcknowledgementEvent.Process () ;
        a_Processed = TRUE ;
    }
    else if ( a_ThreadObject && ( a_Handle == a_ThreadObject->GetHandle () ) )
    {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nTask Wait: Refreshing handles" );
)
        a_ThreadObject->Process () ;
        a_ThreadObject->ConstructEventContainer () ;
    }
    else
    {
        SnmpAbstractTaskObject *t_TaskObject = a_ThreadObject->GetTaskObject ( a_Handle ) ;
        if ( t_TaskObject )
        {
            a_ThreadObject->RotateTask ( t_TaskObject ) ;
            a_ThreadObject->ConstructEventContainer () ;
            t_TaskObject->Process () ;
        }
        else
        {
DebugMacro8(

    SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( __FILE__,__LINE__,  L"\nSnmpAbstractTaskObject :: Illegal Task" ) ;
)
            t_Status = FALSE ;
        }
    }

    return t_Status ;
}

SnmpTaskObject::SnmpTaskObject ( 
    const wchar_t *a_GlobalTaskNameStart, 
    const wchar_t *a_GlobalTaskNameComplete ,
    const wchar_t *a_GlobalTaskNameAcknowledge,
    DWORD a_timeout

): SnmpAbstractTaskObject(a_GlobalTaskNameComplete, a_GlobalTaskNameAcknowledge,a_timeout), m_Event(a_GlobalTaskNameStart)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\common\thrdlog\include\snmpevt.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __SNMPTHREAD_SNMPEVT_H__
#define __SNMPTHREAD_SNMPEVT_H__

#ifdef SNMPTHRD_INIT
class __declspec ( dllexport ) SnmpEventObject
#else
class __declspec ( dllimport ) SnmpEventObject
#endif
{
private:

	HANDLE m_event ;

protected:
public:

	SnmpEventObject ( const wchar_t *globalEventName = NULL ) ;
	virtual ~SnmpEventObject () ;

	HANDLE GetHandle () ;
	void Set () ;
	void Clear () ;

	virtual void Process () ;
	virtual BOOL Wait () ;
	virtual void Complete () ;
} ;

#endif //__SNMPTHREAD_SNMPEVT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\generator.cpp ===
//
//
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"
#include <snmptempl.h>

#include <wbemidl.h>
#include <smir.h>

#include <bool.hpp>
#include <newString.hpp>
	
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objectType.hpp>
#include <objectTypeV1.hpp>
#include <objectTypeV2.hpp>
#include <objectIdentity.hpp>
#include <trapType.hpp>
#include <notificationType.hpp>
#include <group.hpp>
#include <notificationGroup.hpp>
#include <module.hpp>


#include <stackValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMessage.hpp>
#include <errorContainer.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <abstractParseTree.hpp>
#include <oidTree.hpp>
#include <parseTree.hpp>

#include "main.hpp"
#include "generator.hpp"


// These functions are local to this file
static void CleanUpSmir(ISmirAdministrator *pAdminInt,
			ISmirModHandle *pModHandleInt);
static STDMETHODIMP GenerateModule (ISmirAdministrator *pAdminInt, 
				ISmirSerialiseHandle *pSerializeInt,
				const SIMCModule *module);
static STDMETHODIMP GenerateModuleNotifications (ISmirAdministrator *pAdminInt, 
				ISmirSerialiseHandle *pSerializeInt,
				const SIMCModule *module);
static char *GetImportModulesString(const SIMCModule *module);

static STDMETHODIMP GenerateObjectGroup(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			ISmirModHandle *pModHandleInt,  
			SIMCObjectGroup * group);
static STDMETHODIMP GenerateScalarGroup(ISmirAdministrator *pAdminInt,
				ISmirSerialiseHandle *pSerializeInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCObjectGroup * group,
				SIMCScalarMembers *scalars);
static STDMETHODIMP GenerateScalar(SIMCScalar *scalar,
				IWbemClassObject *scalarClass,
				BOOL mapInaccessibleToo,
				BOOL mapObsoleteToo);
static STDMETHODIMP GenerateTable(ISmirAdministrator *pAdminInt,
				ISmirSerialiseHandle *pSerializeInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCObjectGroup * group,
				SIMCTable *table);

static STDMETHODIMP CreatePropertyAndMapSyntaxClause(IWbemClassObject *scalarClass,
					SIMCSymbol **syntax,
					wchar_t *objectName);
static STDMETHODIMP MapSyntaxAttributes(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCTypeReference *btRef,
		SIMCDefinedTypeReference *dtRef,
		SIMCModule::TypeClass typeClass,
		SIMCModule::PrimitiveType primitiveType,
		BOOL isTextualConvention);
static STDMETHODIMP MapSizeTypeSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCSizeType *sizeType,
		const char *const displayHintAttribute);
static STDMETHODIMP MapRangeTypeSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCRangeType *rangeType,
		const char *const displayHintAttribute);
static STDMETHODIMP MapEnumeratedSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCEnumOrBitsType *enumType,
		const char *const displayHintAttribute);
static STDMETHODIMP MapBitsSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCEnumOrBitsType *enumType,
		const char *const displayHintAttribute);
static void SetPropertyType(VARTYPE &varType , const BSTR &type, 
							  const BSTR &textualConvention,
							  const char * enumerationPropertyValue);
static STDMETHODIMP MapOidValue(IWbemQualifierSet *attributeSet,
				const SIMCCleanOidValue &oidValue);
static STDMETHODIMP MapStatusClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapAccessClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapDescriptionClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapReferenceClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapUnitsClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapIndexClause(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeType *objectType,
				IWbemClassObject *tableClass);
static BOOL ContainsImpliedClause(const SIMCObjectTypeV2 *objectType);
static STDMETHODIMP MapIndexClauseV1(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV1 *objectType,
				IWbemClassObject *tableClass);
static STDMETHODIMP MapIndexClauseV2(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV2 *objectType,
				IWbemClassObject *tableClass);
static STDMETHODIMP MapAugmentsClauseV2(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV2 *objectType,
				SIMCTable *augmentedTable,
				IWbemClassObject *tableClass);
static HRESULT MapIndexTypeReference(SIMCTable *table, 
					IWbemClassObject *tableClass,
					SIMCSymbol **syntaxSymbol,
					long ordinal);
static HRESULT MapIndexValueReference(SIMCTable *table, 
					IWbemClassObject *tableClass, 
					SIMCSymbol **symbol,
					long ordinal);

static STDMETHODIMP MapDefValClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType);
static STDMETHODIMP MapIntegerDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCIntegerValue *value);
static STDMETHODIMP MapOctetStringDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCOctetStringValue *value);
static STDMETHODIMP MapBooleanDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCBooleanValue *value);
static STDMETHODIMP MapNullDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCNullValue *value);
static STDMETHODIMP MapOidDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCOidValue *value);
static STDMETHODIMP MapBitsDefVal(IWbemQualifierSet *attributeSet, 
									 SIMCBitsValue *value);
static STDMETHODIMP SetDefValAttribute( IWbemQualifierSet *attributeSet,
									   const char * const str);
static STDMETHODIMP GenerateNotificationType(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement);
static STDMETHODIMP GenerateNotificationAttributes(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass);
static STDMETHODIMP GenerateExNotificationAttributes(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *exNotificationClass);
static STDMETHODIMP GenerateNotificationProperties(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass);
static STDMETHODIMP GenerateExNotificationProperties(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *exNotificationClass);
static STDMETHODIMP GenerateNotificationObject(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			SIMCSymbol **object,
			int varBindIndex,
			IWbemClassObject *notificationClass);
static STDMETHODIMP GenerateExNotificationObject(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			SIMCSymbol **object,
			int varBindIndex,
			IWbemClassObject *exNotificationClass);

//Sets the "key" attribute of a property
static STDMETHODIMP MakeKey(IWbemQualifierSet *);

//Sets the "virtual_key" and "key" attribute of a property
static STDMETHODIMP MakeVirtualKey(IWbemQualifierSet *);

//Sets the "key_order" attribute of a property
static STDMETHODIMP SetKeyOrder(IWbemQualifierSet *, long ordinal);

// Sets the "provider" attribute of a class
static STDMETHODIMP SetProvider(IWbemQualifierSet *attributeSet, OLECHAR FAR *value);

//Sets the "dynamic" attribute of a class
static STDMETHODIMP MakeDynamic(IWbemQualifierSet *attributeSet);

// Sets the "object_identifier" attribute of a notification class
static STDMETHODIMP SetObjectIdentifierAttribute (IWbemQualifierSet *attributeSet, SIMCSymbol **object);

// Sets the "object_identifier" attribute of a notification class
static STDMETHODIMP SetCIMTYPEAttribute (IWbemQualifierSet *attributeSet, LPCWSTR pszRefClassName);

// Sets the "VarBindIndex" attribute of a notification class
static STDMETHODIMP SetVarBindIndexAttribute (IWbemQualifierSet *attributeSet, int varBindIndex);

// Returns TRUE if the symbol resolves ultimately to the NULL type
static BOOL IsNullTypeReference(SIMCSymbol ** symbol);

// This is required due to the HMOM limitation
static char *ConvertHyphensToUnderscores(const char *const input);

// This is a global, set by the /z switch	  
BOOL simc_debug;
// The globals for this file
static const SIMCOidTree *oidTree;
static SIMCParseTree *parseTree;
static const SIMCUI *UI;
static BOOL generateMof;
static BOOL notificationsOnly;		// Set by the /o switch
static BOOL extendedNotifications;	// Set by the /ext switch
static BOOL notifications;			// Set by the /t switch

// A routine to convert BSTRs to ANSI
char * ConvertBstrToAnsi(const BSTR& unicodeString)
{
	int textLength = wcstombs ( NULL , unicodeString , 0 ) ;
	char *textBuffer = new char [ textLength + 1 ] ;
	textLength = wcstombs ( textBuffer , unicodeString , textLength + 1 ) ;

	return textBuffer ;
}

// And to convert an ansi string to BSTR   
BSTR ConvertAnsiToBstr(const char * const input)
{
	if( input == NULL)
		return NULL;
	unsigned long len = strlen(input);
	BSTR retVal;
	wchar_t *temp = new wchar_t[len+1];
	if(mbstowcs(temp, input, len+1) != len)
	{
		delete []temp;
		return NULL;
	}
	else
	{
		retVal = SysAllocString(temp);
		delete []temp;
		return retVal;
	}
}

// This is required due to the HMOM limitation
static char *ConvertHyphensToUnderscores(const char * const input)
{
	if(!input)
		return NULL;
	char * retVal = NewString(input);
	if(retVal)
	{
		int i = 0;
		while(retVal[i])
		{
			if( retVal[i] == '-')
				retVal[i] = '_';
			i++;
		}
	}
	return retVal;
}

// Checks whether the object has an ACCESS clause which
// is "not-accessible" or "accessible-for-notify"
BOOL IsInaccessibleObject(SIMCObjectTypeType *objectType)
{

	switch(SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			switch( ((SIMCObjectTypeV1 *)objectType)->GetAccess())
			{
				case SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE:
					return TRUE;
				default:
					return FALSE;
			}
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			switch( ((SIMCObjectTypeV2 *)objectType)->GetAccess())
			{
				case SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE:
				case SIMCObjectTypeV2::ACCESS_FOR_NOTIFY:
					return TRUE;
				default:
					return FALSE;
			}
			break;
	}
	return FALSE;
}

// Checks whether the object has a STATUS clause which
// is "obsolete"
BOOL IsObsoleteObject(SIMCObjectTypeType *objectType)
{

	switch(SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			switch( ((SIMCObjectTypeV1 *)objectType)->GetStatus())
			{
				case SIMCObjectTypeV1::STATUS_OBSOLETE:
					return TRUE;
				default:
					return FALSE;
			}
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			switch( ((SIMCObjectTypeV2 *)objectType)->GetStatus())
			{
				case SIMCObjectTypeV2::STATUS_OBSOLETE:
					return TRUE;
				default:
					return FALSE;
			}
			break;
	}
	return FALSE;
}

// The only non-static function in this file
STDMETHODIMP GenerateClassDefinitions (ISMIRWbemConfiguration *a_Configuration , const SIMCUI& theUI, SIMCParseTree& theParseTree, BOOL _generateMof)
{
	// Initialize the Global variables first
	oidTree = theParseTree.GetOidTree();
	parseTree = &theParseTree;
	UI = &theUI;
	generateMof = _generateMof;
	notificationsOnly = UI->DoNotificationsOnly();
	extendedNotifications = UI->DoExtendedNotifications();
	notifications = UI->DoNotifications();

	SIMCModule * mainModule = theParseTree.GetModuleOfFile(theUI.GetInputFileName());

	// Create the administrator, to load the module
	ISmirAdministrator *pAdminInt = NULL ;
	HRESULT result = a_Configuration->QueryInterface (IID_ISMIR_Administrative,(PPVOID)&pAdminInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "CoCreate() on Administrator failed" << endl;
		return result;
	}

	// If generating MOF, get the serialize handle
	ISmirSerialiseHandle *pSerializeInt;
	if(generateMof)
	{
		result = pAdminInt->GetSerialiseHandle(&pSerializeInt, theUI.ClassDefinitionsOnly());
		if(FAILED(result))
		{
			if(simc_debug)
				cerr << "CoCreate() on Serialize failed" << endl;
			pAdminInt->Release();
			return result;
		}
	}


	// Generate the classes in  the module
	if( !notificationsOnly)
		result = GenerateModule (pAdminInt, pSerializeInt, mainModule);

	// Generate notification classes
	if( SUCCEEDED(result) )
	{
		if( notifications || extendedNotifications)
			result = GenerateModuleNotifications(pAdminInt, pSerializeInt, mainModule);
	}

	// Generate MOF if necessary
	if(generateMof && !FAILED(result))
	{
		// Output the text
		BSTR text;
		if(FAILED(pSerializeInt->GetText(&text)))
		{
			if(simc_debug)
				cerr << "GetText() Failed" << endl;
			pAdminInt->Release();
			pSerializeInt->Release();
			return result;
		}
		else
		{
			char * textStr = ConvertBstrToAnsi(text);
			if(textStr)
			{
				// Microsoft copyright 
				cout << MICROSOFT_COPYRIGHT << endl << "//" << endl;

				// MOF Header
				cout << "//\tMOF Generated for module \"" <<
					mainModule->GetModuleName() << 
					"\" by smi2smir version " << versionString << endl << "//" << endl;

				if(theUI.GenerateContextInfo())
				{
					cout << "//\tCommand-line: " << theUI.GetCommandLine()	<< endl;
					cout << "//\tDate and Time (dd/mm/yy:hh:mm:ss) : " <<
						theUI.GetDateAndTime() << endl;
					cout <<	"//\tHost : " << theUI.GetHostName() <<
						", User : " << theUI.GetUserName() << endl;
					cout << "//\tProcess Directory : " << 
						theUI.GetProcessDirectory() << endl << endl << endl;
				}

				// MOF Body
				cout << textStr << endl;
			}
		}

		pSerializeInt->Release();
	}

	pAdminInt->Release();
	return result;
}


static STDMETHODIMP GenerateModule (ISmirAdministrator *pAdminInt, 
									ISmirSerialiseHandle *pSerializeInt,
									const SIMCModule *module  )
{
	// Create a module, to get the module handle.
	ISmirModHandle	*pModHandleInt=NULL;
	HRESULT result = CoCreateInstance (CLSID_SMIR_ModHandle , NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
			IID_ISMIR_ModHandle,(PPVOID)&pModHandleInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "CoCreate() on Module failed" << endl;
		return result;
	}
	
	// Set the module characteristics ...
	BSTR	organization		= ConvertAnsiToBstr(module->GetOrganization());
	BSTR	contactInfo			= ConvertAnsiToBstr(module->GetContactInfo());
	BSTR	lastUpdated			= ConvertAnsiToBstr(module->GetLastUpdated());
	BSTR	description			= ConvertAnsiToBstr(module->GetDescription());
	BSTR	moduleIdentityName	= ConvertAnsiToBstr(module->GetModuleIdentityName());
	char 	*moduleNameMangled	= ConvertHyphensToUnderscores(module->GetModuleName());
	BSTR	moduleName			= ConvertAnsiToBstr(moduleNameMangled);
	delete moduleNameMangled;

	// Revision clause takes a little more effort, since all the revision clauses have to
	// be concatenated.
	CString revisionValue = "";
	const SIMCRevisionList * theRevisionList = module->GetRevisionList();
	if(theRevisionList && !theRevisionList->IsEmpty())
	{
		SIMCRevisionElement *nextElement;
		POSITION p = theRevisionList->GetHeadPosition();
		while(p)
		{
			nextElement = theRevisionList->GetNext(p);
			revisionValue += nextElement->GetRevision();
			revisionValue += "\r\n";
			revisionValue += nextElement->GetDescription();
 			revisionValue += "\r\n";
		}
	}
	BSTR	revisionClause	= ConvertAnsiToBstr(revisionValue);

	//	... moduleIdentityOidValue ...
	SIMCCleanOidValue moduleIdentityOidValue;
	if( !module->GetModuleIdentityValue(moduleIdentityOidValue))
	{
		SysFreeString(organization);
		SysFreeString(contactInfo);
		SysFreeString(lastUpdated);
		SysFreeString(description);
		SysFreeString(moduleIdentityName);
		SysFreeString(moduleName);
	
		if(simc_debug)
			cerr << "GetModuleIdentityValue() failed" << endl;
		pModHandleInt->Release();
		return WBEM_E_FAILED;
	}

	char * oidValueString = CleanOidValueToString(moduleIdentityOidValue);
	BSTR moduleIdentityValue = ConvertAnsiToBstr(oidValueString);
	//delete []oidValueString;

	// ... imports 
	char * importModulesString = GetImportModulesString(module);
	BSTR importModulesValue;
	if(importModulesString)
		importModulesValue = ConvertAnsiToBstr(importModulesString);
	else
		importModulesValue = ConvertAnsiToBstr("");


	pModHandleInt->SetName(moduleName);
	pModHandleInt->SetModuleOID(moduleIdentityValue);
	pModHandleInt->SetModuleIdentity(moduleIdentityName);
	pModHandleInt->SetOrganisation(organization);
	pModHandleInt->SetContactInfo(contactInfo);
	if(!UI->SuppressText()) pModHandleInt->SetDescription(description);
	pModHandleInt->SetLastUpdate(lastUpdated);
	pModHandleInt->SetRevision(revisionClause);
	pModHandleInt->SetSnmpVersion(module->GetSnmpVersion());
	pModHandleInt->SetModuleImports(importModulesValue);

	// if(importModulesString) delete importModulesString;

	SysFreeString(organization);
	SysFreeString(contactInfo);
	SysFreeString(lastUpdated);
	SysFreeString(description);
	SysFreeString(moduleIdentityName);
	SysFreeString(moduleName);
	SysFreeString(moduleIdentityValue);
	SysFreeString(importModulesValue);
	SysFreeString(revisionClause);

	if(generateMof)
	{
		if(FAILED(result = pAdminInt->AddModuleToSerialise(pModHandleInt, pSerializeInt)))
		{
			if(simc_debug) cerr << "GenerateModule(): AddModuleToSerialize() failed" << endl;
			pModHandleInt->Release();
			return result;
		}
	}
	else
	{
		switch(result = pAdminInt->AddModule(pModHandleInt) )
		{
			case WBEM_E_FAILED:
				if(simc_debug) cerr << "GenerateModule(): AddModule() failed: WBEM_E_FAILED" << endl;
				pModHandleInt->Release();
				return result;

			case E_INVALIDARG:
				if(simc_debug) cerr << "GenerateModule(): AddModule() failed: E_INVALIDARG" << endl;
				pModHandleInt->Release();
				return result;

			case E_UNEXPECTED:
				if(simc_debug) cerr << "GenerateModule(): AddModule() failed: E_UNEXPECTED" << endl;
				pModHandleInt->Release();
				return result;
		}
	}

	SIMCGroupList * groupList = module->GetObjectGroupList();
	if(!groupList)
	{
		pModHandleInt->Release();
		return S_OK;
	}

	POSITION p = groupList->GetHeadPosition();
	while(p)
	{
		if( FAILED(GenerateObjectGroup(pAdminInt, pSerializeInt, pModHandleInt, groupList->GetNext(p))))
		{
			CleanUpSmir(pAdminInt, pModHandleInt);
			pModHandleInt->Release();
			return WBEM_E_FAILED;
		}
	}

	pModHandleInt->Release();
	return S_OK;
}

static char *GetImportModulesString(const SIMCModule *module)
{
	strstream outStream;
	const SIMCModuleNameList * importModulesList = module->GetImportModuleNameList();
	if(!importModulesList)
		return NULL;

	POSITION p = importModulesList->GetHeadPosition();
	CString nextModuleName;
	long index = importModulesList->GetCount();
	while(p)
	{
		nextModuleName = importModulesList->GetNext(p);
		index --;
		outStream << nextModuleName;
		if(index)
			outStream << ",";
	}

	outStream << ends;
	return outStream.str();
}


static STDMETHODIMP GenerateObjectGroup(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			ISmirModHandle *pModHandleInt,  
			SIMCObjectGroup * group)
{

	SIMCScalarMembers *scalars = group->GetScalarMembers();
	HRESULT result;

	ISmirGroupHandle	*pGroupHandleInt=NULL;
	result = CoCreateInstance (CLSID_SMIR_GroupHandle , NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
				IID_ISMIR_GroupHandle,(PPVOID)&pGroupHandleInt);
	
    if (FAILED(result))
    {
		if(simc_debug) cerr << " GenererateObjectGroup(): Failed to CoCreate ISMIR Group" << endl;
		return result;
	}


	//fill in the group details
	BSTR groupName; 
	BSTR groupOid; 
	BSTR status; 
	BSTR description; 
	BSTR reference;

	char *groupNameMangled = ConvertHyphensToUnderscores(group->GetObjectGroupName());
	// Name
	groupName = ConvertAnsiToBstr(groupNameMangled);
	delete groupNameMangled;
	if(FAILED(pGroupHandleInt->SetName(groupName)) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetName()" << endl;
		SysFreeString(groupName);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}
	SysFreeString(groupName);
	
	// OID Value
	char * oidValueString = CleanOidValueToString(*group->GetGroupValue());
	groupOid = ConvertAnsiToBstr(oidValueString);
	// delete oidValueString;
	if(FAILED(pGroupHandleInt->SetGroupOID(groupOid)) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetGroupOid()" << endl;
		SysFreeString(groupOid);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}
	SysFreeString(groupOid);


	// Status
	status = ConvertAnsiToBstr(group->GetStatusString());
	if(FAILED(pGroupHandleInt->SetStatus(status)) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetGroupOid()" << endl;
		SysFreeString(status);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}
	SysFreeString(status);


	// Description
	description = ConvertAnsiToBstr(group->GetDescription());
	if(FAILED(pGroupHandleInt->SetDescription(description) ) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetDescription()" << endl;
		SysFreeString(description);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}
	SysFreeString(description);


	// Reference 
	reference = ConvertAnsiToBstr(group->GetReference());
	
	if(FAILED(pGroupHandleInt->SetReference(reference)) )
	{
		if(simc_debug) cerr << "GenerateObjectGroup(): Failed to SetReference()" << endl;
		SysFreeString(reference);
		pGroupHandleInt->Release();
		return WBEM_E_FAILED;
	}

	SysFreeString(reference);

	// NOW ADD THE GROUP
	if(generateMof )
	{
		result = pAdminInt->AddGroupToSerialise(pModHandleInt, pGroupHandleInt, pSerializeInt);
		switch(result)
		{
			case E_INVALIDARG:
				if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
				pGroupHandleInt->Release();
				return result;
			case E_UNEXPECTED:
				if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
				pGroupHandleInt->Release();
				return result;
			case S_OK:
				break;
		}
	}
	else 
	{
		result = pAdminInt->AddGroup(pModHandleInt, pGroupHandleInt);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
			pGroupHandleInt->Release();
			return result;
		}
	}

	// CREATE THE CLASSES IN THE GROUP

	// THE SCALAR CLASSES
	if(scalars && !scalars->IsEmpty())
	{	
		result = GenerateScalarGroup(pAdminInt, pSerializeInt, pGroupHandleInt, group, scalars);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateObjectGroup(): GenerateScalars failed" << endl;
			pGroupHandleInt->Release();
			return result;
		}
		
	}

	// THE TABLE CLASSES
	SIMCTableMembers *tables = group->GetTableMembers();
	SIMCTable *nextTable;
	if(tables)
	{
		POSITION p = tables->GetHeadPosition();
		while(p)
		{
			nextTable = tables->GetNext(p);
			if( FAILED(GenerateTable(pAdminInt,  pSerializeInt, pGroupHandleInt, 
						group, nextTable) ))
			{
				pGroupHandleInt->Release();
				return WBEM_E_FAILED;
			}
		}
	}
	pGroupHandleInt->Release();
	return S_OK;
}

static STDMETHODIMP GenerateScalarGroup(ISmirAdministrator *pAdminInt,
				ISmirSerialiseHandle *pSerializeInt,
				ISmirGroupHandle *pGroupHandleInt,
				SIMCObjectGroup * group,
				SIMCScalarMembers *scalars)
{
	// Form the name of the scalar group
	SIMCSymbol *namedNode = group->GetNamedNode();
	// Use the module of one of the scalars as the module name, and not
	// the named node's module since this can be somthing else
	SIMCModule *module = scalars->GetHead()->GetSymbol()->GetModule();

	const char * const moduleName = module->GetModuleName();
	const char * const namedNodeName = namedNode->GetSymbolName();

	// Create a scalar class

	// Set the scalar group name	
	char *scalarGroupName = new char[strlen(GROUP_NAME_PREPEND_STRING) +
					strlen(moduleName) + 1 + strlen(namedNodeName) +1 ];
	strcpy(scalarGroupName, GROUP_NAME_PREPEND_STRING);
	strcat(scalarGroupName, moduleName);
	strcat(scalarGroupName, "_");
	strcat(scalarGroupName, namedNodeName);

	BSTR groupName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(scalarGroupName));
	delete scalarGroupName;

	ISmirClassHandle *scalarClassHandle = NULL ;
	HRESULT result = pAdminInt->CreateWBEMClass(groupName, &scalarClassHandle);

	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Get Scalar class failed" << endl;
		return result;
	}

	IWbemClassObject *scalarClass = NULL ;

	result = scalarClassHandle->GetWBEMClass ( & scalarClass ) ;
  	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): GetWBEMClass failed" << endl;
		scalarClassHandle->Release();
		return result;
	}

	// ---------------- Set Attributes of the class ------------------
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetQualifierSet (&attributeSet);
  	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): GetAttribSet failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		return result;
	}

	VARIANT variant;
	// "description"
	VariantInit(&variant);

	if(!UI->SuppressText())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr("");
		result = attributeSet->Put ( DESCRIPTION_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateScalarGroup(): Put description failed" << endl;
			scalarClassHandle->Release();
			scalarClass->Release();
			attributeSet->Release();
			return result;
		}
	}
	// "module_name"
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(moduleName);
	result = attributeSet->Put ( MODULE_NAME_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION ) ;
	VariantClear ( & variant ) ;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Put module_name failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return result;
	}

	// "singleton"
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	result = attributeSet->Put ( SINGLETON_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION ) ;
	VariantClear ( & variant ) ;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Put singleton failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return result;
	}

	// "group_objectid"
	char *groupOidStr = (char *)CleanOidValueToString(*group->GetGroupValue());
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(groupOidStr);
	result = attributeSet->Put ( GROUP_OBJECTID_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear ( & variant ) ;
	// delete []groupOidStr;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Put group_objectid failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return result;
	}

	// "dynamic"
	if(FAILED(MakeDynamic(attributeSet)))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Make Dynamic failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return WBEM_E_FAILED;
	}

	// "provider"
	if(FAILED(SetProvider(attributeSet, SNMP_INSTANCE_PROVIDER)))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Make Provider failed" << endl;
		scalarClassHandle->Release();
		scalarClass->Release();
		attributeSet->Release();
		return WBEM_E_FAILED;
	}


	// Set the properties of the class
	SIMCScalar *nextScalar;
	POSITION p = scalars->GetHeadPosition();
	while(p)
	{
		nextScalar = scalars->GetNext(p);
		if( GenerateScalar(nextScalar, scalarClass, FALSE, FALSE) 
							== WBEM_E_FAILED)
		{
			scalarClassHandle->Release();
			scalarClass->Release();
			attributeSet->Release();
			return WBEM_E_FAILED;
		}
	}

	scalarClass->Release();
	attributeSet->Release();
 
   	// Add the class to the Group

	if(generateMof)
	{
		if(FAILED(pAdminInt->AddClassToSerialise(pGroupHandleInt, scalarClassHandle, pSerializeInt)))
		{
			if(simc_debug) cerr << "GenerateScalarGroup(): AddClassToSerialise() Failed" << endl;
			scalarClassHandle->Release();
			return WBEM_E_FAILED;
		}
	}
	else
	{
		if(FAILED(pAdminInt->AddClass(pGroupHandleInt, scalarClassHandle)))
		{
			//pGroupHandleInt->AddRef();
			if(simc_debug) cerr << "GenerateScalarGroup(): AddClass() Failed" << endl;
			scalarClassHandle->Release();
			return WBEM_E_FAILED;
		}
	}

	scalarClassHandle->Release();
	return S_OK;	
}

static STDMETHODIMP SetProvider(IWbemQualifierSet *attributeSet, OLECHAR FAR *providerName)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = SysAllocString(providerName);
	HRESULT result = attributeSet->Put ( PROVIDER_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	if (FAILED(result))
		if(simc_debug) cerr << "MakeKey(): Put Provider failed" << endl;
	
	return result;
}

// Sets the "object_identifier" attribute of a notification class
static STDMETHODIMP SetCIMTYPEAttribute (IWbemQualifierSet *attributeSet, LPCWSTR pszRefClassName)
{
	LPWSTR pszRefValue = new WCHAR[wcslen(pszRefClassName) + wcslen(L"ref:") + 1] ;
	wcscpy(pszRefValue, L"ref:");
	wcscat(pszRefValue, pszRefClassName);

	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = SysAllocString(pszRefValue);
	delete [] pszRefValue;

	HRESULT result = attributeSet->Put ( CIMTYPE_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	if (FAILED(result))
		if(simc_debug) cerr << "MakeKey(): Put CIMTYPE for REF failed" << endl;
	
	return result;
}
 
static STDMETHODIMP MakeDynamic(IWbemQualifierSet *attributeSet)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	HRESULT result = attributeSet->Put ( DYNAMIC_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	if (FAILED(result))
		if(simc_debug) cerr << "MakeKey(): Put Dynamic failed" << endl;
	
	return result;
}



static STDMETHODIMP GenerateScalar(SIMCScalar *scalar,
				IWbemClassObject *scalarClass, 
				BOOL  mapInaccessibleToo,
				BOOL mapObsoleteToo)
{

	SIMCSymbol *scalarSymbol = scalar->GetSymbol();
	SIMCSymbol **scalarSymbolP = &scalarSymbol;
	SIMCCleanOidValue *oidValue = scalar->GetOidValue();

	SIMCBuiltInValueReference *bvRef;
	SIMCSymbol **typeRefSymbol;
	if( SIMCModule::IsValueReference(scalarSymbolP, typeRefSymbol, bvRef) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	SIMCTypeReference *btRef;
	if( SIMCModule::IsTypeReference(typeRefSymbol, btRef) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	SIMCSymbol **btRefP = (SIMCSymbol**)&btRef;
	if( SIMCModule::GetSymbolClass(btRefP) != SIMCModule::SYMBOL_BUILTIN_TYPE_REF)
		return WBEM_E_FAILED;

	SIMCType *theType = ((SIMCBuiltInTypeReference *)btRef)->GetType();
	SIMCModule::TypeClass typeClass = SIMCModule::GetTypeClass(theType);

	// Dont map certain objects based on access clause
	if(!mapInaccessibleToo)
	{
		switch(typeClass)
		{
			case SIMCModule::TYPE_OBJECT_TYPE_V1:
				if( ((SIMCObjectTypeV1*)theType)->GetAccess() == SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE)
					return S_OK;
				break;
			case SIMCModule::TYPE_OBJECT_TYPE_V2:
				if( ((SIMCObjectTypeV2*)theType)->GetAccess() == SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE ||
					((SIMCObjectTypeV2*)theType)->GetAccess() == SIMCObjectTypeV2::ACCESS_FOR_NOTIFY )
					return S_OK;
				break;
			default:
				return WBEM_E_FAILED;
		}
	}

	// Dont map certain objects based on status clause
	if(!mapObsoleteToo)
	{
		switch(typeClass)
		{
			case SIMCModule::TYPE_OBJECT_TYPE_V1:
				if( ((SIMCObjectTypeV1*)theType)->GetStatus() == SIMCObjectTypeV1::STATUS_OBSOLETE)
					return S_OK;
				break;
			case SIMCModule::TYPE_OBJECT_TYPE_V2:
				if( ((SIMCObjectTypeV2*)theType)->GetStatus() == SIMCObjectTypeV1::STATUS_OBSOLETE  )
					return S_OK;
				break;
			default:
				return WBEM_E_FAILED;
		}
	}

	SIMCObjectTypeType *objectType = (SIMCObjectTypeType *)theType;
	// Set the PROPERTY NAME corresponding to the OBJECT-TYPE identifier
	wchar_t * objectName = ConvertAnsiToBstr(scalarSymbol->GetSymbolName());
	if(!objectName)
	{
		if(simc_debug) cerr << "GenerateScalar(): ConvertAnsiToBstr - objectName failed" 
			<< endl;
		return WBEM_E_FAILED;
	}

	// Have to decide the 'type' of the property based on the
	// SYNTAX clause of the OBJECT-TYPE.
	HRESULT result = CreatePropertyAndMapSyntaxClause(scalarClass,
				objectType->GetSyntax(),
				objectName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalar() : MapSyntaxClause() failed" << endl;
		return result;
	}

	// Get the attribute set
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalar(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}


	// Map the oid value
	if( FAILED(result = MapOidValue(attributeSet, *oidValue)) )
	{
		if(simc_debug) cerr << "GenerateScalar() : MapOidValue() failed" << endl;
		attributeSet->Release();
		return result;
	}
			
	// Map Access Clause
	if( FAILED(result = MapAccessClause(attributeSet, objectType)) )
	{
		if(simc_debug) cerr << "GenerateScalar() : MapAccess() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Description Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapDescriptionClause(attributeSet, objectType)) )
		{
			if(simc_debug) cerr << "GenerateScalar() : MapDescriptionClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Units Clause (SNMPv2 only)
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapUnitsClause(attributeSet, objectType)) )
		{
			if(simc_debug) cerr << "GenerateScalar() : MapUnitsClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Reference Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapReferenceClause(attributeSet, objectType)) )
		{
			if(simc_debug) cerr << "GenerateScalar() : MapReferenceClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Status Clause
	if( FAILED(result = MapStatusClause(attributeSet, objectType))  )
	{
		if(simc_debug) cerr << "GenerateScalar() : MapStatusClause() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Defval Clause
	if( FAILED(result = MapDefValClause(attributeSet, objectType))  )
	{
		if(simc_debug) cerr << "GenerateScalar() : MapDefvalClause() failed" << endl;
		attributeSet->Release();
		return result;
	}

	attributeSet->Release();
	return S_OK;
}

static STDMETHODIMP MakeKey(IWbemQualifierSet *attributeSet)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	HRESULT result = attributeSet->Put ( KEY_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	return result;
}

static STDMETHODIMP MakeVirtualKey(IWbemQualifierSet *attributeSet)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	HRESULT result = attributeSet->Put ( VIRTUAL_KEY_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	if(FAILED(result))
	{
		VariantClear(&variant);
		return result;
	}
	result = attributeSet->Put ( KEY_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	return result;
}


static STDMETHODIMP MapOidValue(IWbemQualifierSet *attributeSet,
				const SIMCCleanOidValue &oidValue)
{
	char * oidStringValue = CleanOidValueToString(oidValue);
	if(!oidStringValue)
	{
		if(simc_debug) cerr << "MapOidValueClause(): CleanOidValueToString() failed" << endl;
		return WBEM_E_FAILED;
	}
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(oidStringValue);
	HRESULT result = attributeSet->Put ( OBJECT_IDENTIFIER_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	// delete []oidStringValue;
	if (FAILED(result))
		if(simc_debug) cerr << "MapOidValueClause(): Put object_identifier failed" << endl;
	
	return result;
}


static STDMETHODIMP CreatePropertyAndMapSyntaxClause(IWbemClassObject *scalarClass,
					SIMCSymbol **syntax,
					wchar_t *objectName)
{
	const char * const syntaxSymbolName = (*syntax)->GetSymbolName();

	SIMCTypeReference *typeRef  = NULL;
	SIMCDefinedTypeReference * defTypeRef = NULL;
	SIMCModule::PrimitiveType primitiveType = SIMCModule::PRIMITIVE_INVALID;
	SIMCModule::TypeClass typeClass = SIMCModule::TYPE_INVALID;
	BOOL isTextualConvention = false;
	
	switch(SIMCModule::GetSymbolClass(syntax))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF: 
			typeRef = (SIMCTypeReference *)(*syntax);
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			isTextualConvention = TRUE;
			// FALL THRU
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		{
			defTypeRef = (SIMCDefinedTypeReference*)(*syntax);
			switch(defTypeRef->GetStatus())
			{
				case RESOLVE_IMPORT:
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					return WBEM_E_FAILED;
				case RESOLVE_CORRECT:
					typeRef = defTypeRef->GetRealType();
			}
		}
		break;
		default:
			return WBEM_E_FAILED;
	}

	SIMCSymbol **typeRefP = (SIMCSymbol**)&typeRef;
	switch(SIMCModule::GetSymbolClass(typeRefP))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			switch(typeClass = SIMCModule::GetTypeClass(type))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					primitiveType = SIMCModule::GetPrimitiveType(typeRef);
					break;
				case SIMCModule::TYPE_SIZE:
				case SIMCModule::TYPE_RANGE:
					switch( ((SIMCSubType *)type)->GetStatus())
					{
						case RESOLVE_CORRECT: 
							break;
						default:
							return WBEM_E_FAILED;
					}
					primitiveType = 
						SIMCModule::GetPrimitiveType(((SIMCSubType *)type)->GetRootType());
					break;
				case SIMCModule::TYPE_ENUM_OR_BITS:
				{
                    switch( ((SIMCEnumOrBitsType *)type)->GetEnumOrBitsType() )
					{
						case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
							primitiveType = SIMCModule::PRIMITIVE_INTEGER;
							break;
						case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
							primitiveType = SIMCModule::PRIMITIVE_BITS;
							break;
						default:
							return WBEM_E_FAILED;
					}
				}
				break;
				default:
					return WBEM_E_FAILED;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			typeClass = SIMCModule::TYPE_PRIMITIVE;
			primitiveType = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
		}
		break;
		default:
			return WBEM_E_FAILED;
	}
	return MapSyntaxAttributes(scalarClass, objectName, syntaxSymbolName,
				typeRef, defTypeRef,
				typeClass, primitiveType, isTextualConvention); 
}

static STDMETHODIMP MapSyntaxAttributes(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCTypeReference *btRef,
		SIMCDefinedTypeReference *dtRef,
		SIMCModule::TypeClass typeClass,
		SIMCModule::PrimitiveType primitiveType,
		BOOL isTextualConvention)
{

	// "type" and "encoding" attributes are directly based on the 
	// "textual_convention" attribute. "object_syntax" attribute 
	// requires some more work
	char *typeAttribute = NULL, *textualConventionAttribute = NULL, *encodingAttribute = NULL,
			*objectSyntaxAttribute = NULL, *displayHintAttribute = NULL;

	// Set the display_hint attribute in case of a textual convention
	if(isTextualConvention)
	{
		SIMCTextualConvention *theTC = (SIMCTextualConvention *)dtRef;
		displayHintAttribute = (char *)theTC->GetDisplayHint();
	}


	switch(typeClass)
	{
		case SIMCModule::TYPE_PRIMITIVE:
		{

			if(symbolName[0] != '*')
				objectSyntaxAttribute = NewString(symbolName);
			else
				objectSyntaxAttribute = NewString(btRef->GetSymbolName());

			if(objectSyntaxAttribute)
			{
				// Tackle 2 the special casees since MOF attributes can't have spaces in them
				if(strcmp(objectSyntaxAttribute, "OCTET STRING") == 0 )
				{
					delete objectSyntaxAttribute;
					objectSyntaxAttribute = NewString(OCTETSTRING_TYPE);
				}
				else if(strcmp(objectSyntaxAttribute, "OBJECT IDENTIFIER") == 0 )
				{
					delete objectSyntaxAttribute;
					objectSyntaxAttribute = NewString(OBJECTIDENTIFIER_TYPE);
				}

				switch(primitiveType)
				{
					case SIMCModule::PRIMITIVE_INTEGER:
						textualConventionAttribute = NewString(INTEGER_TYPE);
						typeAttribute = NewString(VT_I4_TYPE);
						encodingAttribute = NewString(INTEGER_TYPE);
						break;
					case SIMCModule::PRIMITIVE_OID:
						textualConventionAttribute = NewString(OBJECTIDENTIFIER_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OBJECTIDENTIFIER_TYPE);
						break;
					case SIMCModule::PRIMITIVE_OCTET_STRING:
						textualConventionAttribute = NewString(OCTETSTRING_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_NULL:
						textualConventionAttribute = NewString(NULL_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(NULL_TYPE);
						break;
					case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
						textualConventionAttribute = NewString(NetworkAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(NetworkAddress_TYPE);
						break;
					case SIMCModule::PRIMITIVE_IP_ADDRESS:
						textualConventionAttribute = NewString(IpAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(IpAddress_TYPE);
						break;
					case SIMCModule::PRIMITIVE_COUNTER:
						textualConventionAttribute = NewString(Counter_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Counter_TYPE);
						break;
					case SIMCModule::PRIMITIVE_GAUGE:
						textualConventionAttribute = NewString(Gauge_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Gauge_TYPE);
						break;
					case SIMCModule::PRIMITIVE_TIME_TICKS:
						textualConventionAttribute = NewString(TimeTicks_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(TimeTicks_TYPE);
						break;
					case SIMCModule::PRIMITIVE_OPAQUE:
						textualConventionAttribute = NewString(Opaque_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(Opaque_TYPE);
						break;
					case SIMCModule::PRIMITIVE_DISPLAY_STRING:
						textualConventionAttribute = NewString(DisplayString_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
						textualConventionAttribute = NewString(PhysAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_MAC_ADDRESS:
						textualConventionAttribute = NewString(MacAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_DATE_AND_TIME:
						textualConventionAttribute = NewString(DateAndTime_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_INTEGER_32:
						textualConventionAttribute = NewString(Integer32_TYPE);
						typeAttribute = NewString(VT_I4_TYPE);
						encodingAttribute = NewString(Integer32_TYPE);
						break;
					case SIMCModule::PRIMITIVE_UNSIGNED_32:
						textualConventionAttribute = NewString(Unsigned32_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Unsigned32_TYPE);
						break;
					case SIMCModule::PRIMITIVE_COUNTER_32:
						textualConventionAttribute = NewString(Counter32_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Counter32_TYPE);
						break;
					case SIMCModule::PRIMITIVE_COUNTER_64:
						textualConventionAttribute = NewString(Counter64_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(Counter64_TYPE);
						break;
					case SIMCModule::PRIMITIVE_GAUGE_32:
						textualConventionAttribute = NewString(Gauge32_TYPE);
						typeAttribute = NewString(VT_UI4_TYPE);
						encodingAttribute = NewString(Gauge32_TYPE);
						break;
					case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
						textualConventionAttribute = NewString(SnmpUDPAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:
						textualConventionAttribute = NewString(SnmpIPXAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:
						textualConventionAttribute = NewString(SnmpOSIAddress_TYPE);
						typeAttribute = NewString(VT_BSTR_TYPE);
						encodingAttribute = NewString(OCTETSTRING_TYPE);
						break;
					default:
						return WBEM_E_FAILED;
				}
			}
			break;
		}
		case SIMCModule::TYPE_ENUM_OR_BITS:
		{
			SIMCEnumOrBitsType *enumOrBits = (SIMCEnumOrBitsType *)
					((SIMCBuiltInTypeReference *)btRef)->GetType();
			switch(enumOrBits->GetEnumOrBitsType())
			{
				case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
					return MapEnumeratedSyntax(scalarClass, objectName, symbolName,
						enumOrBits, displayHintAttribute);
				case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
					return MapBitsSyntax(scalarClass, objectName, symbolName,
						enumOrBits, displayHintAttribute);
				default:
					return WBEM_E_FAILED;
			}
		}
		break;

		case SIMCModule::TYPE_SIZE:
			return MapSizeTypeSyntax(scalarClass, objectName, symbolName,
				(SIMCSizeType *)((SIMCBuiltInTypeReference *)btRef)->GetType(), displayHintAttribute);
		case SIMCModule::TYPE_RANGE:
			return MapRangeTypeSyntax(scalarClass, objectName, symbolName,
				(SIMCRangeType *)((SIMCBuiltInTypeReference *)btRef)->GetType(), displayHintAttribute);
		default:
			if(simc_debug) cerr << "MapSyntaxAttributes() : Could not get a valid primitive type" << endl;
				return WBEM_E_FAILED;

	}

 	VARIANT typeVariant, 
			textualConventionVariant, 
			encodingVariant,
			objectSyntaxVariant,
			displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	if(displayHintAttribute)
		VariantInit(&displayHintVariant);

	typeVariant.vt =				VT_BSTR ;
	textualConventionVariant.vt =	VT_BSTR ;
	encodingVariant.vt =			VT_BSTR ;
	objectSyntaxVariant.vt =		VT_BSTR ;
	if(displayHintAttribute)
		displayHintVariant.vt =			VT_BSTR ;

	typeVariant.bstrVal =				ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal =	ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal =			ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal =		ConvertAnsiToBstr(objectSyntaxAttribute);
	if(displayHintAttribute)
		displayHintVariant.bstrVal =	ConvertAnsiToBstr(displayHintAttribute);

	// Create the property
	VARTYPE varType = VT_NULL ;
	SetPropertyType(varType, typeVariant.bstrVal, 
		textualConventionVariant.bstrVal, NULL);
	HRESULT result = scalarClass->Put (objectName, 0, NULL, varType);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateScalar(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapSyntaxAttributes(): Unknown return value" << endl;	  
		return WBEM_E_FAILED;
	}

	result = attributeSet->Put( CIMTYPE_ATTRIBUTE, &typeVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE, &textualConventionVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant , WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put(OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant, WBEM_CLASS_DO_PROPAGATION);
	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	attributeSet->Release();
	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;
	// Do not delete the displayHintAttribute since it was not allocated,
	// but is a part of the TC object
	
	VariantClear (&typeVariant) ;
	VariantClear (&textualConventionVariant) ;
	VariantClear (&encodingVariant) ;
	VariantClear (&objectSyntaxVariant) ;
	if(displayHintAttribute)
		VariantClear (&displayHintVariant);
	return result;

}

static void SetPropertyType(VARTYPE &varType,const BSTR &type, 
							  const BSTR &textualConvention,
							  const char * propertyValue)
{
	varType = VT_NULL ;
	CString typeStr(type); 
	if( typeStr == VT_I4_TYPE )
		varType = VT_I4 ;
	else if( typeStr == VT_UI4_TYPE )
		varType = VT_UI4 ;
	else if ( typeStr == VT_ARRAY_OR_VT_I4_TYPE )
		varType = VT_ARRAY | VT_I4;
	else if ( typeStr == VT_BSTR_TYPE )
		varType = VT_BSTR ;
}

	
static STDMETHODIMP MapSizeTypeSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCSizeType *sizeType,
		const char *const displayHintAttribute)
{
	VARIANT typeVariant; 
	VARIANT	textualConventionVariant; 
	VARIANT	encodingVariant;
	VARIANT	objectSyntaxVariant;
	VARIANT	fixedLengthVariant;
	VARIANT	variableLengthVariant;
	VARIANT displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	VariantInit(&fixedLengthVariant);
	VariantInit(&variableLengthVariant);
	if(displayHintAttribute) VariantInit(&displayHintVariant);

	switch(sizeType->GetStatus())
	{
		case RESOLVE_CORRECT:
			break;
		default:
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&fixedLengthVariant);
			VariantClear (&variableLengthVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}


	SIMCSymbol ** typeSymbol = sizeType->GetType();
	SIMCTypeReference *tRef =  NULL;
	SIMCDefinedTypeReference *dtRef = NULL;
	switch(SIMCModule::GetSymbolClass(typeSymbol))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			tRef = (SIMCTypeReference *)(*typeSymbol);
			break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			dtRef = (SIMCDefinedTypeReference *)(*typeSymbol);
			if( dtRef->GetStatus() != RESOLVE_CORRECT)
				return WBEM_E_FAILED;
			tRef = dtRef->GetRealType();
			break;

		default:
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&fixedLengthVariant);
			VariantClear (&variableLengthVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}

	char	*typeAttribute, 
			*textualConventionAttribute, 
			*encodingAttribute,
			*objectSyntaxAttribute, 
			*variableLengthAttribute= NULL;
	long fixedLengthAttribute = 0;
	
	// Set the objectSyntax attribute	
	if(*symbolName != '*')
		objectSyntaxAttribute = NewString(symbolName);
	else
	{
		if(dtRef)
			objectSyntaxAttribute = NewString(dtRef->GetSymbolName());
		else
			objectSyntaxAttribute = NewString(tRef->GetSymbolName());
	}

 	// Tackle 2 the special cases since MOF attributes can't have spaces in them
	if(objectSyntaxAttribute && strcmp(objectSyntaxAttribute, "OCTET STRING") == 0 )
	{
		delete objectSyntaxAttribute;
		objectSyntaxAttribute = NewString(OCTETSTRING_TYPE);
	}
	else if(objectSyntaxAttribute && strcmp(objectSyntaxAttribute, "OBJECT IDENTIFIER") == 0 )
	{
		delete objectSyntaxAttribute;
		objectSyntaxAttribute = NewString(OBJECTIDENTIFIER_TYPE);
	}

	// Set the other attributes
	SIMCTypeReference *rootTypeRef = sizeType->GetRootType();
	switch(SIMCModule::GetSymbolClass((SIMCSymbol **)(&rootTypeRef)) )
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass(((SIMCBuiltInTypeReference *)rootTypeRef)->GetType()) )
			{
				case SIMCModule::TYPE_PRIMITIVE:
					switch(SIMCModule::GetPrimitiveType(rootTypeRef))
					{
						case SIMCModule::PRIMITIVE_INTEGER:
							textualConventionAttribute = NewString(INTEGER_TYPE);
							typeAttribute = NewString(VT_I4_TYPE);
							encodingAttribute = NewString(INTEGER_TYPE);
							break;
						case SIMCModule::PRIMITIVE_INTEGER_32:
							textualConventionAttribute = NewString(Integer32_TYPE);
							typeAttribute = NewString(VT_I4_TYPE);
							encodingAttribute = NewString(Integer32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_UNSIGNED_32:
							textualConventionAttribute = NewString(Unsigned32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Unsigned32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_OID:
							textualConventionAttribute = NewString(OBJECTIDENTIFIER_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OBJECTIDENTIFIER_TYPE);
							break;
						case SIMCModule::PRIMITIVE_OCTET_STRING:
							textualConventionAttribute = NewString(OCTETSTRING_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_NULL:
							textualConventionAttribute = NewString(NULL_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(NULL_TYPE);
							break;
						case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
							textualConventionAttribute = NewString(NetworkAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(NetworkAddress_TYPE);
							break;
						case SIMCModule::PRIMITIVE_IP_ADDRESS:
							textualConventionAttribute = NewString(IpAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(IpAddress_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER:
							textualConventionAttribute = NewString(Counter_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Counter_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER_32:
							textualConventionAttribute = NewString(Counter32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Counter32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER_64:
							textualConventionAttribute = NewString(Counter64_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(Counter64_TYPE);
							break;
						case SIMCModule::PRIMITIVE_GAUGE:
							textualConventionAttribute = NewString(Gauge_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Gauge_TYPE);
							break;
						case SIMCModule::PRIMITIVE_GAUGE_32:
							textualConventionAttribute = NewString(Gauge32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Gauge32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_TIME_TICKS:
							textualConventionAttribute = NewString(TimeTicks_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(TimeTicks_TYPE);
							break;
						case SIMCModule::PRIMITIVE_OPAQUE:
							textualConventionAttribute = NewString(Opaque_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(Opaque_TYPE);
							break;
						case SIMCModule::PRIMITIVE_DISPLAY_STRING:
							textualConventionAttribute = NewString(DisplayString_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
							textualConventionAttribute = NewString(PhysAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_MAC_ADDRESS:
							textualConventionAttribute = NewString(MacAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_DATE_AND_TIME:
							textualConventionAttribute = NewString(DateAndTime_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
							textualConventionAttribute = NewString(SnmpUDPAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:
							textualConventionAttribute = NewString(SnmpIPXAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:
							textualConventionAttribute = NewString(SnmpOSIAddress_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(OCTETSTRING_TYPE);
							break;
						default:
							VariantClear (&typeVariant) ;
							VariantClear (&textualConventionVariant) ;
							VariantClear (&encodingVariant) ;
							VariantClear (&objectSyntaxVariant) ;
							VariantClear (&fixedLengthVariant);
							if(displayHintAttribute) VariantClear (&displayHintVariant);
							return WBEM_E_FAILED;
					}
					break;

				default:
					VariantClear (&typeVariant) ;
					VariantClear (&textualConventionVariant) ;
					VariantClear (&encodingVariant) ;
					VariantClear (&objectSyntaxVariant) ;
					VariantClear (&fixedLengthVariant);
					VariantClear (&variableLengthVariant);
					if(displayHintAttribute) VariantClear (&displayHintVariant);
					return WBEM_E_FAILED;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			switch(SIMCModule::GetPrimitiveType(rootTypeRef->GetSymbolName()))
			{
				case SIMCModule::PRIMITIVE_DISPLAY_STRING:
					textualConventionAttribute = NewString(DisplayString_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
					textualConventionAttribute = NewString(PhysAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_MAC_ADDRESS:
					textualConventionAttribute = NewString(MacAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_DATE_AND_TIME:
					textualConventionAttribute = NewString(DateAndTime_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
					textualConventionAttribute = NewString(SnmpUDPAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:
					textualConventionAttribute = NewString(SnmpIPXAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:
					textualConventionAttribute = NewString(SnmpOSIAddress_TYPE);
					typeAttribute = NewString(VT_BSTR_TYPE);
					encodingAttribute = NewString(OCTETSTRING_TYPE);
					break;
				default:
					VariantClear (&typeVariant) ;
					VariantClear (&textualConventionVariant) ;
					VariantClear (&encodingVariant) ;
					VariantClear (&objectSyntaxVariant) ;
					VariantClear(&fixedLengthVariant);
					VariantClear(&variableLengthVariant);
					if(displayHintAttribute) VariantClear (&displayHintVariant);
					return WBEM_E_FAILED;
			}
		}
		break;
		default:
 			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear(&fixedLengthVariant);
			VariantClear(&variableLengthVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}

	if(sizeType->IsFixedSize())
		fixedLengthAttribute = sizeType->GetFixedSize();
	else
	{
		if(!(variableLengthAttribute = sizeType->ConvertSizeListToString()))
		{
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&fixedLengthVariant);
			VariantClear (&variableLengthVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
		}
	}
	


	typeVariant.vt =				VT_BSTR;
	textualConventionVariant.vt =	VT_BSTR;
	encodingVariant.vt =			VT_BSTR;
	objectSyntaxVariant.vt =		VT_BSTR;
	fixedLengthVariant.vt =			VT_I4;
	variableLengthVariant.vt =		VT_BSTR;
	if(displayHintAttribute) displayHintVariant.vt =			VT_BSTR;

	typeVariant.bstrVal = ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal = ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal = ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal = ConvertAnsiToBstr(objectSyntaxAttribute);
	if(fixedLengthAttribute)
		fixedLengthVariant.lVal = fixedLengthAttribute;
	else
		variableLengthVariant.bstrVal = ConvertAnsiToBstr(variableLengthAttribute);
	if(displayHintAttribute)
		displayHintVariant.bstrVal = ConvertAnsiToBstr(displayHintAttribute);

  	// Create the property
	VARTYPE varType = VT_NULL ;
	SetPropertyType(varType, typeVariant.bstrVal, 
		textualConventionVariant.bstrVal, NULL);
	HRESULT result = scalarClass->Put (objectName, 0, NULL, varType);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "MapSizeTypeSyntax(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapSizeTypeSyntax(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	result = attributeSet->Put( CIMTYPE_ATTRIBUTE, &typeVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE,&textualConventionVariant,WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant,WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
	{
		if(fixedLengthAttribute)
			result = attributeSet->Put( FIXED_LENGTH_ATTRIBUTE, &fixedLengthVariant,WBEM_CLASS_DO_PROPAGATION);
		else
			result = attributeSet->Put( VARIABLE_LENGTH_ATTRIBUTE, &variableLengthVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	attributeSet->Release();
	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;

	if(fixedLengthAttribute)
  		VariantClear(&fixedLengthVariant);
	else
	{
		// delete variableLengthAttribute;
		VariantClear(&variableLengthVariant);
	}

	VariantClear (&typeVariant);
	VariantClear (&textualConventionVariant);
	VariantClear (&encodingVariant);
	VariantClear (&objectSyntaxVariant);
	if(displayHintAttribute) VariantClear (&displayHintVariant);
	return result;
}

static STDMETHODIMP MapRangeTypeSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCRangeType *rangeType,
		const char * const displayHintAttribute)
{
	VARIANT typeVariant; 
	VARIANT	textualConventionVariant; 
	VARIANT	encodingVariant;
	VARIANT	objectSyntaxVariant;
	VARIANT	variableValueVariant;
	VARIANT displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	VariantInit(&variableValueVariant);
	if(displayHintAttribute) VariantInit(&displayHintVariant);

	switch(rangeType->GetStatus())
	{
		case RESOLVE_CORRECT:
			break;
		default:
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&variableValueVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}

	SIMCSymbol ** typeSymbol = rangeType->GetType();
	SIMCTypeReference *tRef =  NULL;
	SIMCDefinedTypeReference *dtRef = NULL;
	switch(SIMCModule::GetSymbolClass(typeSymbol))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			tRef = (SIMCTypeReference *)(*typeSymbol);
			break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
			dtRef = (SIMCDefinedTypeReference *)(*typeSymbol);
			if( dtRef->GetStatus() != RESOLVE_CORRECT)
				return WBEM_E_FAILED;
			tRef = dtRef->GetRealType();
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			dtRef = (SIMCTextualConvention *)(*typeSymbol);
			if( dtRef->GetStatus() != RESOLVE_CORRECT)
				return WBEM_E_FAILED;
			tRef = dtRef->GetRealType();
			break;
		default:
			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&variableValueVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}

	char *typeAttribute, *textualConventionAttribute, *encodingAttribute,
			*objectSyntaxAttribute, *variableValueAttribute;
	
	// Set the objectSyntax attribute	
	if(*symbolName != '*')
		objectSyntaxAttribute = NewString(symbolName);
	else
	{
		if(dtRef)
			objectSyntaxAttribute = NewString(dtRef->GetSymbolName());
		else
			objectSyntaxAttribute = NewString(tRef->GetSymbolName());
	}

	// Tackle 2 the special casees since MOF attributes can't have spaces in them
	if(objectSyntaxAttribute && strcmp(objectSyntaxAttribute, "OCTET STRING") == 0 )
	{
		delete objectSyntaxAttribute;
		objectSyntaxAttribute = NewString(OCTETSTRING_TYPE);
	}
	else if(objectSyntaxAttribute && strcmp(objectSyntaxAttribute, "OBJECT IDENTIFIER") == 0 )
	{
		delete objectSyntaxAttribute;
		objectSyntaxAttribute = NewString(OBJECTIDENTIFIER_TYPE);
	}

	SIMCTypeReference *rootTypeRef = rangeType->GetRootType();
	switch(SIMCModule::GetSymbolClass((SIMCSymbol **)(&rootTypeRef)))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass( ((SIMCBuiltInTypeReference *)rootTypeRef)->GetType() ) )
			{
				case SIMCModule::TYPE_PRIMITIVE:
					switch(SIMCModule::GetPrimitiveType(rootTypeRef))
					{
						case SIMCModule::PRIMITIVE_INTEGER:
							textualConventionAttribute = NewString(INTEGER_TYPE);
							typeAttribute = NewString(VT_I4_TYPE);
							encodingAttribute = NewString(INTEGER_TYPE);
							break;
						case SIMCModule::PRIMITIVE_INTEGER_32:
							textualConventionAttribute = NewString(Integer32_TYPE);
							typeAttribute = NewString(VT_I4_TYPE);
							encodingAttribute = NewString(Integer32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_UNSIGNED_32:
							textualConventionAttribute = NewString(Unsigned32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Unsigned32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER:
							textualConventionAttribute = NewString(Counter_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Counter_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER_32:
							textualConventionAttribute = NewString(Counter32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Counter32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_COUNTER_64:
							textualConventionAttribute = NewString(Counter64_TYPE);
							typeAttribute = NewString(VT_BSTR_TYPE);
							encodingAttribute = NewString(Counter64_TYPE);
							break;
						case SIMCModule::PRIMITIVE_GAUGE:
							textualConventionAttribute = NewString(Gauge_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Gauge_TYPE);
							break;
						case SIMCModule::PRIMITIVE_GAUGE_32:
							textualConventionAttribute = NewString(Gauge32_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(Gauge32_TYPE);
							break;
						case SIMCModule::PRIMITIVE_TIME_TICKS:
							textualConventionAttribute = NewString(TimeTicks_TYPE);
							typeAttribute = NewString(VT_UI4_TYPE);
							encodingAttribute = NewString(TimeTicks_TYPE);
							break;
						default:
							VariantClear (&typeVariant) ;
							VariantClear (&textualConventionVariant) ;
							VariantClear (&encodingVariant) ;
							VariantClear (&objectSyntaxVariant) ;
							VariantClear (&variableValueVariant);
							if(displayHintAttribute) VariantClear (&displayHintVariant);
							return WBEM_E_FAILED;
					}
					break;

				default:
					VariantClear (&typeVariant) ;
					VariantClear (&textualConventionVariant) ;
					VariantClear (&encodingVariant) ;
					VariantClear (&objectSyntaxVariant) ;
					VariantClear (&variableValueVariant);
					if(displayHintAttribute) VariantClear (&displayHintVariant);
					return WBEM_E_FAILED;
			}
		}
		break;
		default:
 			VariantClear (&typeVariant) ;
			VariantClear (&textualConventionVariant) ;
			VariantClear (&encodingVariant) ;
			VariantClear (&objectSyntaxVariant) ;
			VariantClear (&variableValueVariant);
			if(displayHintAttribute) VariantClear (&displayHintVariant);
			return WBEM_E_FAILED;
	}


	if(!(variableValueAttribute = rangeType->ConvertRangeListToString()))
	{
		VariantClear (&typeVariant) ;
		VariantClear (&textualConventionVariant) ;
		VariantClear (&encodingVariant) ;
		VariantClear (&objectSyntaxVariant) ;
		VariantClear (&variableValueVariant);
		if(displayHintAttribute) VariantClear (&displayHintVariant);
		return WBEM_E_FAILED;
	}
	


	typeVariant.vt =				VT_BSTR ;
	textualConventionVariant.vt =	VT_BSTR ;
	encodingVariant.vt =			VT_BSTR ;
	objectSyntaxVariant.vt =		VT_BSTR ;
	variableValueVariant.vt =		VT_BSTR ;
	if(displayHintAttribute) displayHintVariant.vt =			VT_BSTR ;

	typeVariant.bstrVal					= ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal	= ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal				= ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal			= ConvertAnsiToBstr(objectSyntaxAttribute);
	variableValueVariant.bstrVal		= ConvertAnsiToBstr(variableValueAttribute);
	if(displayHintAttribute)
		displayHintVariant.bstrVal = ConvertAnsiToBstr(displayHintAttribute);

  	// Create the property
	VARTYPE varType = VT_NULL ;
	SetPropertyType(varType,typeVariant.bstrVal, 
		textualConventionVariant.bstrVal, NULL);
	HRESULT result = scalarClass->Put (objectName, 0, NULL, varType);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "MapRangeTypeSyntax(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapRangeTypeSyntax(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	result = attributeSet->Put( CIMTYPE_ATTRIBUTE, &typeVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE, &textualConventionVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( VARIABLE_VALUE_ATTRIBUTE, &variableValueVariant,WBEM_CLASS_DO_PROPAGATION);

	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;
	// delete variableValueAttribute;

	VariantClear (&typeVariant) ;
	VariantClear (&textualConventionVariant) ;
	VariantClear (&encodingVariant) ;
	VariantClear (&objectSyntaxVariant) ;
	VariantClear (&variableValueVariant) ;
	if(displayHintAttribute) VariantClear (&displayHintVariant);
	attributeSet->Release();
	return result;
}


static STDMETHODIMP MapEnumeratedSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCEnumOrBitsType *enumType,
		const char *const displayHintAttribute)
{
	char *textualConventionAttribute = NewString(EnumeratedINTEGER_TYPE);
	char *typeAttribute = NewString(VT_BSTR_TYPE);
	char *encodingAttribute = NewString(INTEGER_TYPE);
	char * objectSyntaxAttribute;

	if(symbolName[0] != '*')
		objectSyntaxAttribute = NewString(symbolName);
	else
		objectSyntaxAttribute = NewString(EnumeratedINTEGER_TYPE);

	char * enumerationAttribute = enumType->ConvertToString();
	if(!enumerationAttribute)
		return WBEM_E_FAILED;
	

 	VARIANT typeVariant; 
	VARIANT	textualConventionVariant; 
	VARIANT	encodingVariant;
	VARIANT	objectSyntaxVariant;
	VARIANT	enumerationVariant;
	VARIANT	displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	VariantInit(&enumerationVariant);
	if(displayHintAttribute) VariantInit(&displayHintVariant);

	typeVariant.vt				= VT_BSTR ;
	textualConventionVariant.vt = VT_BSTR ;
	encodingVariant.vt			= VT_BSTR ;
	objectSyntaxVariant.vt		= VT_BSTR ;
	enumerationVariant.vt		= VT_BSTR ;
	if(displayHintAttribute) displayHintVariant.vt		= VT_BSTR ;

	typeVariant.bstrVal					= ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal	= ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal				= ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal			= ConvertAnsiToBstr(objectSyntaxAttribute);
	enumerationVariant.bstrVal			= ConvertAnsiToBstr(enumerationAttribute);
	if(displayHintAttribute )
		displayHintVariant.bstrVal			= ConvertAnsiToBstr(displayHintAttribute);

	// Set propertyValue to be equal to the first enumeration
	// Example: If enumerationAttribute is "up(1),down(2),unknown(3)",
	// then set *propertyValue to be "up(1)"
	char *propertyValue = NewString(enumerationAttribute);
	if(!propertyValue)
		return WBEM_E_FAILED;

	int i = 0;
	while( propertyValue[i] != '(' )
		i++;
	propertyValue[i] = NULL;

	// Create the property
	VARTYPE varType = VT_NULL ;
	SetPropertyType(varType,typeVariant.bstrVal, 
		textualConventionVariant.bstrVal, propertyValue);
	HRESULT result = scalarClass->Put (objectName, 0, NULL, varType);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "MapEnumeratedSyntax(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapEnumeratedSyntax(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}


	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE,&textualConventionVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( ENUMERATION_ATTRIBUTE, &enumerationVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant, WBEM_CLASS_DO_PROPAGATION);

	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	attributeSet->Release();
	VariantClear (&typeVariant) ;
	VariantClear (&textualConventionVariant) ;
	VariantClear (&encodingVariant) ;
	VariantClear (&objectSyntaxVariant) ;
	VariantClear (&enumerationVariant) ;
	if(displayHintAttribute) VariantClear (&displayHintVariant) ;

	delete propertyValue;
	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;
	// delete enumerationAttribute;
	
	return result;
}	


static STDMETHODIMP MapBitsSyntax(IWbemClassObject *scalarClass,
		wchar_t *objectName,
		const char * const symbolName,
		SIMCEnumOrBitsType *bitsType,
		const char *const displayHintAttribute)
{
	char *textualConventionAttribute = NewString(BITS_TYPE);
	char *typeAttribute = NewString(VT_ARRAY_OR_VT_BSTR_TYPE);
	char *encodingAttribute = NewString(OCTETSTRING_TYPE);
	char *objectSyntaxAttribute;

	if(symbolName[0] != '*')
		objectSyntaxAttribute = NewString(symbolName);
	else
		objectSyntaxAttribute = NewString(BITS_TYPE);

	char * enumerationAttribute = bitsType->ConvertToString();
	if(!enumerationAttribute)
		return WBEM_E_FAILED;
	

 	VARIANT typeVariant; 
	VARIANT	textualConventionVariant; 
	VARIANT	encodingVariant;
	VARIANT	objectSyntaxVariant;
	VARIANT	enumerationVariant;
 	VARIANT	displayHintVariant;

	VariantInit(&typeVariant);
	VariantInit(&textualConventionVariant);
	VariantInit(&encodingVariant);
	VariantInit(&objectSyntaxVariant);
	VariantInit(&enumerationVariant);
 	if(displayHintAttribute) VariantInit(&displayHintVariant);

	typeVariant.vt = VT_BSTR ;
	textualConventionVariant.vt = VT_BSTR ;
	encodingVariant.vt = VT_BSTR ;
	objectSyntaxVariant.vt = VT_BSTR ;
	enumerationVariant.vt = VT_BSTR;
	if(displayHintAttribute) displayHintVariant.vt = VT_BSTR;

	typeVariant.bstrVal					= ConvertAnsiToBstr(typeAttribute);
	textualConventionVariant.bstrVal	= ConvertAnsiToBstr(textualConventionAttribute);
	encodingVariant.bstrVal				= ConvertAnsiToBstr(encodingAttribute);
	objectSyntaxVariant.bstrVal			= ConvertAnsiToBstr(objectSyntaxAttribute);
	enumerationVariant.bstrVal			= ConvertAnsiToBstr(enumerationAttribute);
	if(displayHintAttribute)
		displayHintVariant.bstrVal		= ConvertAnsiToBstr(displayHintAttribute);

	// Set propertyValue to be equal to the first enumeration
	// Example: If enumerationAttribute is "up(1),down(2),unknown(3)",
	// then set *propertyValue to be "up(1)"
	char *propertyValue = NewString(enumerationAttribute);
	if(!propertyValue)
		return WBEM_E_FAILED;

	int i = 0;
	while( propertyValue[i] != '(' )
		i++;
	propertyValue[i] = NULL;

	// Create the property and map its value
	VARIANT variant;
	VariantInit(&variant);
	SIMCNamedNumberList *valueList = bitsType->GetListOfItems();
	LONG count = valueList->GetCount() ;
	SAFEARRAY *safeArray ;
	SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
	safeArrayBounds[0].lLbound = 0 ;
	safeArrayBounds[0].cElements = count ;
	safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

	POSITION p = valueList->GetHeadPosition();
	SIMCNamedNumberItem *item;
	for ( LONG index = 0 ; p ; index ++ )
	{
		item = valueList->GetNext(p);
		SafeArrayPutElement ( safeArray , &index , ConvertAnsiToBstr(item->_name) );
	}
	variant.vt = VT_ARRAY | VT_BSTR ;
	variant.parray = safeArray ; 		
	VARTYPE varType = VT_ARRAY | VT_BSTR ;
	HRESULT result = scalarClass->Put (objectName, 0, &variant,varType);
	VariantClear(&variant);

	if (FAILED(result))
	{
		if(simc_debug) cerr << "MapEnumeratedSyntax(): Put Property objectName failed" << endl;
		return result;
	}

	// Set the attributes of the property
	IWbemQualifierSet *attributeSet ;
	result = scalarClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapEnumeratedSyntax(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	if(SUCCEEDED(result))
		result = attributeSet->Put( TEXTUAL_CONVENTION_ATTRIBUTE, &textualConventionVariant, WBEM_CLASS_DO_PROPAGATION);

	if(SUCCEEDED(result))
		result = attributeSet->Put( ENCODING_ATTRIBUTE, &encodingVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( OBJECT_SYNTAX_ATTRIBUTE, &objectSyntaxVariant, WBEM_CLASS_DO_PROPAGATION);
	if(SUCCEEDED(result))
		result = attributeSet->Put( BITS_ATTRIBUTE, &enumerationVariant, WBEM_CLASS_DO_PROPAGATION);

	if(displayHintAttribute)
	{
		if(SUCCEEDED(result))
			result = attributeSet->Put(DISPLAY_HINT_ATTRIBUTE, &displayHintVariant, WBEM_CLASS_DO_PROPAGATION);
	}

	attributeSet->Release();
	VariantClear (&typeVariant) ;
	VariantClear (&textualConventionVariant) ;
	VariantClear (&encodingVariant) ;
	VariantClear (&objectSyntaxVariant) ;
	VariantClear (&enumerationVariant) ;
	if(displayHintAttribute) VariantClear (&displayHintVariant) ;

	delete propertyValue;
	delete typeAttribute;
	delete textualConventionAttribute;
	delete encodingAttribute;
	delete objectSyntaxAttribute;
	// delete enumerationAttribute;
	return result;
}	

static STDMETHODIMP MapAccessClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	HRESULT result;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BOOL ;
	variant.boolVal = VARIANT_TRUE;
	
	switch( SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			switch(((SIMCObjectTypeV1 *)objectType)->GetAccess())
			{
				case SIMCObjectTypeV1::ACCESS_WRITE_ONLY:
					result = attributeSet->Put( WRITE_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::ACCESS_READ_ONLY:
				case SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE:
					result = attributeSet->Put( READ_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::ACCESS_READ_WRITE:
					if(FAILED(result = attributeSet->Put( READ_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION)) )
					{
						VariantClear ( & variant ) ;
						return result;
					}
					result = attributeSet->Put( WRITE_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				default:
					VariantClear ( & variant ) ;
					return WBEM_E_FAILED;
			}
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			switch(((SIMCObjectTypeV2 *)objectType)->GetAccess())
			{
				case SIMCObjectTypeV2::ACCESS_INVALID:
					VariantClear ( & variant ) ;
					return WBEM_E_FAILED;

				case SIMCObjectTypeV2::ACCESS_READ_ONLY:
				case SIMCObjectTypeV2::ACCESS_READ_CREATE:
				case SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE:
				case SIMCObjectTypeV2::ACCESS_FOR_NOTIFY:
					result = attributeSet->Put( READ_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV2::ACCESS_READ_WRITE:
					if(FAILED(result = attributeSet->Put( READ_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION)) )
					{
						VariantClear ( & variant ) ;
						return result;
					}
					result = attributeSet->Put( WRITE_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				default:
					VariantClear ( & variant ) ;
					return WBEM_E_FAILED;

			}
			break;
	}

	return WBEM_E_FAILED;
}

static STDMETHODIMP MapDescriptionClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	const char * const description = objectType->GetDescription();
	if(!description)
		return S_OK;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(description);
	HRESULT result = attributeSet->Put( DESCRIPTION_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear (&variant) ;
	return result;	
}

static STDMETHODIMP MapReferenceClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	const char * reference = NULL;
	switch( SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			reference = ((SIMCObjectTypeV1 *)objectType)->GetReference();
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			reference = ((SIMCObjectTypeV2 *)objectType)->GetReference();
			break;
	}

	if(!reference)
		return S_OK;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(reference);
	HRESULT result = attributeSet->Put( REFERENCE_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear (&variant) ;
	return result;	
}

static STDMETHODIMP MapUnitsClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	const char * units = NULL;
	switch( SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			return S_OK;
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			units = ((SIMCObjectTypeV2 *)objectType)->GetUnitsClause();
			break;
	}

	if(!units)
		return S_OK;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(units);
	HRESULT result = attributeSet->Put(UNITS_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear (&variant) ;
	return result;	
}

static STDMETHODIMP MapStatusClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	
	HRESULT result;

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;

	switch( SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			switch(((SIMCObjectTypeV1 *)objectType)->GetStatus())
			{
				case SIMCObjectTypeV1::STATUS_INVALID:
					VariantClear(&variant);
					return WBEM_E_FAILED;

				case SIMCObjectTypeV1::STATUS_MANDATORY:
					variant.bstrVal = ConvertAnsiToBstr("mandatory");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::STATUS_OPTIONAL:
					variant.bstrVal = ConvertAnsiToBstr("optional");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::STATUS_DEPRECATED:
					variant.bstrVal = ConvertAnsiToBstr("deprecated");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV1::STATUS_OBSOLETE:
					variant.bstrVal = ConvertAnsiToBstr("obsolete");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;
			}
			break;
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			switch(((SIMCObjectTypeV2 *)objectType)->GetStatus())
			{
				case SIMCObjectTypeV2::STATUS_INVALID:
					VariantClear(&variant);
					return WBEM_E_FAILED;

				case SIMCObjectTypeV2::STATUS_CURRENT:
					variant.bstrVal = ConvertAnsiToBstr("current");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV2::STATUS_DEPRECATED:
					variant.bstrVal = ConvertAnsiToBstr("deprecated");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;

				case SIMCObjectTypeV2::STATUS_OBSOLETE:
					variant.bstrVal = ConvertAnsiToBstr("obsolete");
					result = attributeSet->Put( STATUS_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION);
					VariantClear(&variant ) ;
					return result;
			}
			break;
	}
	return WBEM_E_FAILED;
}

static STDMETHODIMP MapDefValClause(IWbemQualifierSet *attributeSet,
				SIMCObjectTypeType *objectType)
{
	
	SIMCSymbol **defValSymbol = objectType->GetDefVal();

	if(!defValSymbol)
		return S_OK;

	SIMCBuiltInValueReference *bvRef;

	switch(SIMCModule::GetSymbolClass(defValSymbol))
	{
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF :
			bvRef = (SIMCBuiltInValueReference*)(*defValSymbol);
			break;
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			if( ((SIMCDefinedValueReference *)(*defValSymbol))->GetStatus()
				!= RESOLVE_CORRECT)
			{
				if(simc_debug) cerr << "MapDefVal(): Could not get defined value" << endl;
				return WBEM_E_FAILED;
			}
			bvRef =  ((SIMCDefinedValueReference *)(*defValSymbol))->GetRealValue();
			break;
		default:
			if(simc_debug) cerr << "MapDefVal(): Could not get value ref" << endl;
			return WBEM_E_FAILED;
	}

	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR;
	SIMCValue *value = bvRef->GetValue();
	switch(SIMCModule::GetValueClass(value))
	{
		case SIMCModule::VALUE_INVALID:
			if(simc_debug) cerr << "MapDefVal(): Could not get value class" << endl;
			return WBEM_E_FAILED;
		case SIMCModule::VALUE_INTEGER:
			return MapIntegerDefVal(attributeSet, (SIMCIntegerValue *)value);
		case SIMCModule::VALUE_OCTET_STRING:
			return MapOctetStringDefVal(attributeSet, (SIMCOctetStringValue *)value);
		case SIMCModule::VALUE_BOOLEAN:
			return MapBooleanDefVal(attributeSet, (SIMCBooleanValue *)value);
		case SIMCModule::VALUE_NULL:
			return MapNullDefVal(attributeSet, (SIMCNullValue *)value);
		case SIMCModule::VALUE_OID:
			return MapOidDefVal(attributeSet, (SIMCOidValue *)value);
		case SIMCModule::VALUE_BITS:
			return MapBitsDefVal(attributeSet, (SIMCBitsValue *)value);
	}

	return WBEM_E_FAILED;

}


static STDMETHODIMP MapIntegerDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCIntegerValue *value)
{
	ostrstream outStream;

	if(value->IsUnsigned())
		outStream << ( (unsigned long)value->GetIntegerValue()) << ends;
	else
		outStream << value->GetIntegerValue() << ends;

	char *str = outStream.str();

	HRESULT result = SetDefValAttribute(attributeSet, str);
	// delete str;
	return result;

}

static STDMETHODIMP MapOctetStringDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCOctetStringValue *value)
{
	strstream outStream;
	outStream << value->GetOctetStringValue() << ends;
	char *str = outStream.str();

	HRESULT result = SetDefValAttribute(attributeSet, str);
	// if(str) delete str;
	return result;


}

static STDMETHODIMP MapNullDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCNullValue *value)
{
	return SetDefValAttribute(attributeSet, "NULL");
}

static STDMETHODIMP MapBooleanDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCBooleanValue *value)
{
	if( value->GetBooleanValue())
		return SetDefValAttribute(attributeSet, "TRUE");
	else
		return SetDefValAttribute(attributeSet, "FALSE");
}

static STDMETHODIMP MapOidDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCOidValue *value)
{
	 SIMCCleanOidValue cleanValue;
	 if(parseTree->GetCleanOidValue("", value, cleanValue, FALSE) != RESOLVE_CORRECT)
		 return WBEM_E_FAILED;

	 char *str = CleanOidValueToString(cleanValue);
	 HRESULT result = SetDefValAttribute(attributeSet, str);
	 // delete []str;
	 return result;
}

static STDMETHODIMP MapBitsDefVal( IWbemQualifierSet *attributeSet, 
									 SIMCBitsValue *value)
{
	const SIMCBitValueList * valueList = value->GetValueList();
	if(!valueList || valueList->IsEmpty())
		return S_OK;
	SIMCBitValue *headValue = valueList->GetHead();
	return SetDefValAttribute(attributeSet, headValue->_name);

}
static STDMETHODIMP SetDefValAttribute( IWbemQualifierSet *attributeSet,
									   const char * const str)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(str);
	HRESULT result = attributeSet->Put ( DEFVAL_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear(&variant);
	if (FAILED(result))
		if(simc_debug) cerr << "SetDefValAttribute(): Put DefVal" << endl;
	
	return result;
}

//------------------------------------------------------------------------------
//----------------  TABLE GENERATION -------------------------------------------
//------------------------------------------------------------------------------


static STDMETHODIMP GenerateTable(ISmirAdministrator *pAdminInt,
			  ISmirSerialiseHandle *pSerializeInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCObjectGroup * group,
				SIMCTable *table)
{

	// If the table contains an IMPLIED clause, then it should not
	// be mapped.
	SIMCObjectTypeV2 *objectTypeV2;
  	SIMCSymbol * rowSymbol = table->GetRowSymbol();
	SIMCSymbol **rowSymbolP = &rowSymbol;

	if(SIMCModule::IsObjectTypeV2(rowSymbolP, objectTypeV2) == RESOLVE_CORRECT)
	{
		if(ContainsImpliedClause(objectTypeV2))
			return S_OK;
	}

	// Create a class for the table
	// Form the name of the table group
	SIMCSymbol *tableNode = table->GetTableSymbol();
	SIMCModule *module = tableNode->GetModule();
	const char * const moduleName = module->GetModuleName();
	const char * const tableNodeName = tableNode->GetSymbolName();

	// Set the Table group name
	char *tableName = new char[strlen(GROUP_NAME_PREPEND_STRING) +
					strlen(moduleName) + 1 + strlen(tableNodeName) +1 ];
	strcpy(tableName, GROUP_NAME_PREPEND_STRING);
	strcat(tableName, moduleName);
	strcat(tableName, "_");
	strcat(tableName, tableNodeName);

	BSTR tableClassName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(tableName));
	delete []tableName;
	
	ISmirClassHandle *tableClassHandle = NULL ;
	HRESULT result = pAdminInt->CreateWBEMClass(tableClassName, &tableClassHandle);

	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateTableGroup(): Get Table class failed" << endl;
		tableClassHandle->Release();
		return result;
	}

	IWbemClassObject *tableClass = NULL ;

	result = tableClassHandle->GetWBEMClass ( & tableClass ) ;

	// ---------------- Set Attributes of the class ------------------
	IWbemQualifierSet *attributeSet ;
	result = tableClass->GetQualifierSet (&attributeSet);
 	if (FAILED(result))
	{
		// cerr << "GenerateTable(): GetAttribSet failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		return result;
	}


	// "description"
	// Form the description by concatenating the descriptions of the 
	// table and the row OBJECT-TYPES
	const char * const tableDescription = table->GetTableDescription();
	const char * const rowDescription = table->GetRowDescription();

	char * descriptionStr = new char [ 
		((tableDescription)? strlen(tableDescription): 0) + 
		((rowDescription)? strlen(rowDescription) : 0 )   +  2];
	descriptionStr[0] = NULL;
	if(tableDescription)
		strcat(descriptionStr, tableDescription);
	strcat(descriptionStr, "\n");
	if(rowDescription)
		strcat(descriptionStr, rowDescription);
  
	VARIANT variant ;
	VariantInit(&variant);

	if(!UI->SuppressText())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(descriptionStr);
		result = attributeSet->Put ( DESCRIPTION_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
		VariantClear ( & variant ) ;
		delete [] descriptionStr;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateTable(): Put description failed" << endl;
			tableClassHandle->Release();
			tableClass->Release();
			attributeSet->Release();
			return result;
		}
	}

	// "module_name"
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(moduleName);
	result = attributeSet->Put ( MODULE_NAME_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear ( & variant ) ;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateTable(): Put module_name failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		attributeSet->Release();
		return result;
	}

	// "group_objectid"
	char *groupOidStr = (char *)CleanOidValueToString(*group->GetGroupValue());
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(groupOidStr);
	result = attributeSet->Put ( GROUP_OBJECTID_ATTRIBUTE , &variant , WBEM_CLASS_DO_PROPAGATION ) ;
	VariantClear ( & variant ) ;
	// delete []groupOidStr;
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateTable(): Put group_objectid failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		attributeSet->Release();
		return result;
	}

	// "dynamic"
	if(FAILED(MakeDynamic(attributeSet)))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Make Dynamic failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		attributeSet->Release();
		return WBEM_E_FAILED;
	}

	// "provider"
	if(FAILED(SetProvider(attributeSet, SNMP_INSTANCE_PROVIDER)))
	{
		if(simc_debug) cerr << "GenerateScalarGroup(): Make Provider failed" << endl;
		tableClassHandle->Release();
		tableClass->Release();
		attributeSet->Release();
		return WBEM_E_FAILED;
	}

	//Finshed with the attributeSet...
	attributeSet->Release();

	// Set the properties/attributes of the class
	SIMCScalarMembers * columnMembers = table->GetColumnMembers();
	SIMCScalar *nextColumnObject;
	POSITION p = columnMembers->GetHeadPosition();
	while(p)
	{
		nextColumnObject = columnMembers->GetNext(p);
		if( GenerateScalar(nextColumnObject, tableClass, FALSE, FALSE) == WBEM_E_FAILED)
		{
			tableClassHandle->Release();
			tableClass->Release();
			return WBEM_E_FAILED;
		}
	}

	// Now deal with the index clause of the row object
	SIMCObjectTypeType *rowObject;
	if( SIMCModule::IsObjectType(rowSymbolP, rowObject) != RESOLVE_CORRECT )
	{
		tableClassHandle->Release();
		tableClass->Release();
		return WBEM_E_FAILED;
	}

	if (FAILED(MapIndexClause(pAdminInt, pGroupHandleInt, table, rowObject,
			tableClass)))
	{
		if(simc_debug) cerr << "Generatetable(): MapIndexClause() failed " << endl;
		tableClassHandle->Release();
		tableClass->Release();
		return WBEM_E_FAILED;
	}
	
	//finished with the tableclass object
	tableClass->Release();
	
	// Add the class to the Group
	//tableClassHandle->AddRef();

	if(generateMof)
	{
		//pSerializeInt->AddRef();
		if(FAILED(pAdminInt->AddClassToSerialise(pGroupHandleInt, tableClassHandle, pSerializeInt)))
		{
			if(simc_debug) cerr << "GenerateTable(): AddClassToSerialize() Failed" << endl;
			return WBEM_E_FAILED;
		}
	}
	else
	{
		//pGroupHandleInt->AddRef();
		if(FAILED(pAdminInt->AddClass(pGroupHandleInt, tableClassHandle)))
		{
			if(simc_debug) cerr << "GenerateTable(): AddClass() Failed" << endl;
			return WBEM_E_FAILED;
		}
	}

	tableClassHandle->Release();
	return S_OK;	
}


 
static STDMETHODIMP MapIndexClause(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeType *objectType,
				IWbemClassObject *tableClass)
{
	switch(SIMCModule::GetTypeClass(objectType))
	{
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			return MapIndexClauseV1(pAdminInt, pGroupHandleInt, table,
				(SIMCObjectTypeV1 *)objectType, tableClass);
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			return MapIndexClauseV2(pAdminInt, pGroupHandleInt, table,
				(SIMCObjectTypeV2 *)objectType, tableClass);
		default:
			return WBEM_E_FAILED;
	}
}

static STDMETHODIMP MapIndexClauseV1(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV1 *objectType,
				IWbemClassObject *tableClass)
{

	SIMCIndexList * indexList = objectType->GetIndexTypes();
	if(!indexList )
		return S_OK;

	SIMCSymbol **symbol;
	POSITION p = indexList->GetHeadPosition();
	
	HRESULT result = S_OK;
	SIMCIndexItem *indexItem;
	long ordinal = 0;
	while(p)
	{
		ordinal ++;

		indexItem = indexList->GetNext(p);
		symbol = indexItem->_item;
		SIMCModule::SymbolClass symbolClass = SIMCModule::GetSymbolClass(symbol);
		switch(symbolClass)
		{
			case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
				if(FAILED(MapIndexTypeReference(table, tableClass, symbol, ordinal)))
					result =  WBEM_E_FAILED;
				break;			

			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
				if( FAILED(MapIndexValueReference(table, tableClass, symbol, ordinal)) )
					result = WBEM_E_FAILED;
			break;
			default:
				return WBEM_E_FAILED;
		}

	}
	return result;
}

static STDMETHODIMP MapIndexClauseV2(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV2 *objectType,
				IWbemClassObject *tableClass)
{

	SIMCTable *augmentedTable = table->GetAugmentedTable();
	if(augmentedTable)
		return MapAugmentsClauseV2(pAdminInt, pGroupHandleInt, table, objectType,
						augmentedTable, tableClass);

	SIMCIndexListV2 * indexList = objectType->GetIndexTypes();
	if(!indexList )
		return S_OK;

	SIMCSymbol **symbol;
	POSITION p = indexList->GetHeadPosition();
	
	HRESULT result = S_OK;
	SIMCIndexItemV2 *indexItem;
	long ordinal = 0;
	while(p)
	{
		ordinal ++;

		indexItem = indexList->GetNext(p);
		symbol = indexItem->_item;
		SIMCModule::SymbolClass symbolClass = SIMCModule::GetSymbolClass(symbol);
		switch(symbolClass)
		{
			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
				if( FAILED(MapIndexValueReference(table, tableClass, symbol, ordinal)) )
					result = WBEM_E_FAILED;
			break;
			default:
				return WBEM_E_FAILED;
		}

	}
	return result;
}

static STDMETHODIMP MapAugmentsClauseV2(ISmirAdministrator *pAdminInt,
				ISmirGroupHandle *pGroupHandleInt,  
				SIMCTable *table,
				SIMCObjectTypeV2 *objectType,
				SIMCTable *augmentedTable,
				IWbemClassObject *tableClass)
{
	// Set the properties/attributes of the class
	SIMCScalarMembers * columnMembers = augmentedTable->GetColumnMembers();
	SIMCScalar *nextColumnObject;
	POSITION p = columnMembers->GetHeadPosition();
	while(p)
	{
		nextColumnObject = columnMembers->GetNext(p);
		if( GenerateScalar(nextColumnObject, tableClass, FALSE, FALSE) == WBEM_E_FAILED)
				return WBEM_E_FAILED;
	}
 
	// Now deal with the index clause of the row object
	SIMCSymbol * rowSymbol = augmentedTable->GetRowSymbol();
	SIMCSymbol **rowSymbolP = &rowSymbol;
	SIMCObjectTypeType *rowObject;
	if( SIMCModule::IsObjectType(rowSymbolP, rowObject) != RESOLVE_CORRECT )
		return WBEM_E_FAILED;

	if (FAILED(MapIndexClause(pAdminInt, pGroupHandleInt, augmentedTable, rowObject,
			tableClass)))
	{
		if(simc_debug) cerr << "MapAugmentsClauseV2(): MapIndexClause() failed " << endl;
		return WBEM_E_FAILED;
	}

	return S_OK;
}

static HRESULT MapIndexTypeReference(SIMCTable *table, 
					IWbemClassObject *tableClass, 
					SIMCSymbol **syntaxSymbol, 
					long ordinal)
{
	const char * const tableName = (table->GetTableSymbol())->GetSymbolName();
	
	// Form the name of the virtual object-type
	char temp[20];
	sprintf(temp, "_%ld", ordinal);
	char *objectNameStr = new char[strlen(tableName) + strlen(temp) + 1];
	strcpy(objectNameStr, tableName);
	strcat(objectNameStr, temp);
	wchar_t * objectName = ConvertAnsiToBstr(objectNameStr);
	delete []objectNameStr;
	if(!objectName)
	{
		if(simc_debug) cerr << "MapIndexTypeReference(): ConvertAnsiToBstr - objectName failed" 
			<< endl;
		return WBEM_E_FAILED;
	}


	HRESULT result = CreatePropertyAndMapSyntaxClause(tableClass,
				syntaxSymbol,
				objectName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapIndexTypeReference() : CreatePropertyAndMapSyntaxClause() failed" << endl;
		return result;
	}

	// Set the Attributes
	IWbemQualifierSet *attributeSet ;
	result = tableClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "MapIndexTypeReference(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	// Set the key_order atribute
	SetKeyOrder(attributeSet, ordinal);
	// Make it the key and virtual key
	MakeKey(attributeSet);
	MakeVirtualKey(attributeSet);
	attributeSet->Release();
	return result;
}


static HRESULT MapIndexValueReference(SIMCTable *table, 
					IWbemClassObject *tableClass, 
					SIMCSymbol **symbol,
					long ordinal)
{	/*
	if(table->IsColumnMember(*symbol))
		return MakeLocalColumnIndex(tableClass, *symbol, ordinal);
	else
		return MakeExternalColumnIndex (table, tableClass, *symbol, ordinal);
	*/

	SIMCObjectTypeType *objectType;

	if(SIMCModule::IsObjectType(symbol, objectType) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	HRESULT result;
	IWbemQualifierSet *attributeSet;
	BSTR symbolName = ConvertAnsiToBstr((*symbol)->GetSymbolName());
	
	if(IsInaccessibleObject(objectType) || IsObsoleteObject(objectType))
	{
		// First map the object

		SIMCCleanOidValue *oidValue = new SIMCCleanOidValue;
		if(!oidTree->GetOidValue((*symbol)->GetSymbolName(), 
									(*symbol)->GetModule()->GetModuleName(), *oidValue))
		{
			if(simc_debug) cerr << "MapIndexValueReference(): Could not get oidvalue" << endl;
			return WBEM_E_FAILED;
		}

		SIMCScalar dummy(*symbol, oidValue);

		// Map Inaccessible and Obsolete objects too
		result =  GenerateScalar(&dummy, tableClass, TRUE, TRUE);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "MapIndexValueReference(): GenrateScalar() Failed" << endl;
			return result;
		}
		result = tableClass->GetPropertyQualifierSet(symbolName, &attributeSet);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "MapIndexValueReference(): Could not get PropAttribute" << endl;
			return result;
		}
		result = MakeVirtualKey(attributeSet);
	}
	else
	{	
		// Generate a property for external objects
		BOOL internalObject = table->IsColumnMember(*symbol);
		if(!internalObject)
		{
			SIMCCleanOidValue *oidValue = new SIMCCleanOidValue;
			if(!oidTree->GetOidValue((*symbol)->GetSymbolName(), (*symbol)->GetModule()->GetModuleName(), *oidValue))
			{
				if(simc_debug) cerr << "MapIndexValueReference(): Could not get oidvalue" << endl;
				return WBEM_E_FAILED;
			}

			SIMCScalar dummy(*symbol, oidValue);

			result =  GenerateScalar(&dummy, tableClass, TRUE, TRUE);
			if(FAILED(result))
			{
				if(simc_debug) cerr << "MapIndexValueReference(): GenrateScalar() Failed" << endl;
				return result;
			}
		}

		result = tableClass->GetPropertyQualifierSet(symbolName, &attributeSet);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "MapIndexValueReference(): Could not get PropAttribute" << endl;
			return result;
		}

		if(internalObject)
			result = MakeKey(attributeSet);
		else
			result = MakeVirtualKey(attributeSet);

	}
	
	// Set the key_order atribute
	SetKeyOrder(attributeSet, ordinal);
	attributeSet->Release();
	return result;	
}

static STDMETHODIMP SetKeyOrder(IWbemQualifierSet *attributeSet, long ordinal)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4 ;
	variant.lVal = ordinal;
	HRESULT result = attributeSet->Put ( KEY_ORDER_ATTRIBUTE, &variant , WBEM_CLASS_DO_PROPAGATION) ;
	VariantClear ( & variant ) ;
	return result;
}


// Returns TRUE if :
//		1. the INDEX clause of the object contains an IMPLIED clause
//		2. the AUGMENTS clause of the object contains a table on which condition 1 or 2
//			holds good.
static BOOL ContainsImpliedClause(const SIMCObjectTypeV2 *objectType)
{
	SIMCIndexListV2 *indexList = objectType->GetIndexTypes();
	SIMCSymbol **augmentsSymbol = objectType->GetAugments();

	if(!indexList && !augmentsSymbol)
		return FALSE;

	if(indexList)
	{
		SIMCIndexItemV2 * item = indexList->GetTail();
		if(item->_implied)
			return TRUE;
		return FALSE;
	}

	if(augmentsSymbol)
	{
		SIMCObjectTypeV2 *objectTypeV2;
		if(SIMCModule::IsObjectTypeV2(augmentsSymbol, objectTypeV2) != RESOLVE_CORRECT)
			return FALSE;
		return ContainsImpliedClause(objectTypeV2);
	}

	return FALSE;
}

// Returns TRUE if the symbol resolves ultimately to the NULL type
static BOOL IsNullTypeReference(SIMCSymbol ** symbol)
{
	switch(	SIMCModule::GetSymbolClass(symbol) )
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCBuiltInTypeReference *btRef = NULL;
			btRef = (SIMCBuiltInTypeReference *)(*symbol);
			switch( SIMCModule::GetTypeClass(btRef->GetType()))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					return SIMCModule::GetPrimitiveType((*symbol)->GetSymbolName()) == SIMCModule::PRIMITIVE_NULL;
				default:
					return FALSE;
			}
			break;
		}
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		{
			SIMCDefinedTypeReference * dtRef = (SIMCDefinedTypeReference*)(*symbol);
			SIMCTypeReference *tRef = NULL;
			switch(dtRef->GetStatus())
			{
				case RESOLVE_CORRECT:
					tRef = dtRef->GetRealType();
					return SIMCModule::GetPrimitiveType(tRef->GetSymbolName()) == SIMCModule::PRIMITIVE_NULL;
					break;
				default:
					return FALSE;
			}
			break;
		}
		break;
	}

	return FALSE;
}


//
// Does all the cleaning up tasks associated with the SMIR.
// Currently, just deletes the specified module from the SMIR
//
static void CleanUpSmir(ISmirAdministrator *pAdminInt,
			ISmirModHandle *pModHandleInt)
{
	pAdminInt->DeleteModule(pModHandleInt);
}

//
// Generates the appropriate notification and extended notification classes
//
static STDMETHODIMP GenerateModuleNotifications (
			ISmirAdministrator *pAdminInt,			// To interact with the SMIR
			ISmirSerialiseHandle *pSerializeInt,	// To generate MOF
			const SIMCModule *module  )				// The parse tree for the module
{
	// Get the list of notifications from the module
	const SIMCNotificationList * listOfNotifications = module->GetNotificationTypeList();
	POSITION p = listOfNotifications->GetHeadPosition();
	SIMCNotificationElement *nextElement = NULL;
	HRESULT result = S_OK, retVal = S_OK;


	// Generate a class for every SNMPV2 NOTIFICATION-TYPE or a NOTIFICATION-TYPE
	// fabricated from SNMPV1 TRAP-TYPE
	while(p)
	{
		nextElement = listOfNotifications->GetNext(p);
		if(FAILED( result = GenerateNotificationType(pAdminInt, pSerializeInt, nextElement)))
		{
			retVal = result;
			if(simc_debug)
				cout << "FAILED to generate notification type" << endl;
		}

	}
	return retVal;
}


//
// Generate a class for an SIMCNotificationElement object. This object
// models an SNMPV2 NOTIFICATION-TYPE or a NOTIFICATION-TYPE fabricated from 
// an SNMPV1 TRAP-TYPE
//
static STDMETHODIMP GenerateNotificationType(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement)
{
	// First check to see if is "deprecated" or "obsolete" in which
	// case we dont need to map it.
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;
	switch(notificationType->GetStatus())
	{
		case SIMCNotificationTypeType::STATUS_OBSOLETE:
		case SIMCNotificationTypeType::STATUS_DEPRECATED:
			return S_OK;
		default:
			break;
	}


	const char * const notificationName = notificationSymbol->GetSymbolName();
	char 	*moduleNameMangled	= ConvertHyphensToUnderscores((notificationSymbol->GetModule())->GetModuleName());
	BSTR	moduleName			= ConvertAnsiToBstr(moduleNameMangled);
	HRESULT result = S_OK;


	// Create a notification class
	if(notifications)
	{
		// Set the notification class name
		char *mangledNotificationNameS = new char[strlen(GROUP_NAME_PREPEND_STRING) +
						strlen(moduleNameMangled) + 1 + strlen(notificationName) +1 + strlen(NOTIFICATION_SUFFIX) + 1];
		strcpy(mangledNotificationNameS, GROUP_NAME_PREPEND_STRING);
		strcat(mangledNotificationNameS, moduleNameMangled);
		strcat(mangledNotificationNameS, "_");
		strcat(mangledNotificationNameS, notificationName);
		strcat(mangledNotificationNameS, "_");
		strcat(mangledNotificationNameS, NOTIFICATION_SUFFIX);

		BSTR mangledNotificationName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(mangledNotificationNameS));
		delete []mangledNotificationNameS;

		// Create the notification class

		ISmirNotificationClassHandle *notificationClassHandle = NULL ;
		result = pAdminInt->CreateWBEMNotificationClass(mangledNotificationName, &notificationClassHandle);

		SysFreeString(mangledNotificationName);
		if(FAILED(result))
		{
			switch(result)
			{
				case E_INVALIDARG:
					if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
					return result;
				case E_UNEXPECTED:
					if(simc_debug) cerr << "GenerateObjectGroup(): AddGroup() failed" << endl;
					return result;
				case S_OK:
					break;
			}
			if(simc_debug) cerr << "GenerateNotificationType(): CreateWBEMNotification class failed" << endl;
			return result;
		}

		IWbemClassObject *notificationClass = NULL ;
		result = notificationClassHandle->GetWBEMNotificationClass ( &notificationClass ) ;
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GetWBEMNotificationClass failed" << endl;
			return result;
		}
		// Set the module name on the class handle
		notificationClassHandle->SetModule(moduleName);

		// Set the attributes of the class
		result = GenerateNotificationAttributes(pAdminInt, pSerializeInt, notificationElement,
			notificationClass);
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GenerateNotificationAttributes failed" << endl;
			notificationClassHandle->Release();
			return result;
		}

		// Set the properties of the class
		result = GenerateNotificationProperties(pAdminInt, pSerializeInt, notificationElement,
			notificationClass);
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GenerateNotificationProperties failed" << endl;
			notificationClassHandle->Release();
			return result;
		}

		if(generateMof)
			result = pAdminInt->AddNotificationClassToSerialise(notificationClassHandle,
						pSerializeInt);
		else
			result = pAdminInt->AddNotificationClass(notificationClassHandle);

		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): AddNotificationClass failed" << endl;
			notificationClass->Release();
			notificationClassHandle->Release();
			return result;
		}

		notificationClass->Release();
		notificationClassHandle->Release();

	}

	// Create an extended notification class
	if(extendedNotifications)
	{
		// Create the interrogator. This is used for the GetWBEMClass() function
		// when setting properties that are references
		ISmirInterrogator *pInterrogateInt = NULL;
		result = pAdminInt->QueryInterface ( IID_ISMIR_Interrogative,(PPVOID)&pInterrogateInt);

 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): CoCreate interrogator class failed" << endl;
			return result;
		}

		// Set the extended notification class name
		char *mangledNotificationNameS =new char[strlen(GROUP_NAME_PREPEND_STRING) +
						strlen(moduleNameMangled) + 1 + strlen(notificationName) +1 + strlen(EX_NOTIFICATION_SUFFIX) + 1];
		strcpy(mangledNotificationNameS, GROUP_NAME_PREPEND_STRING);
		strcat(mangledNotificationNameS, moduleNameMangled);
		strcat(mangledNotificationNameS, "_");
		strcat(mangledNotificationNameS, notificationName);
		strcat(mangledNotificationNameS, "_");
		strcat(mangledNotificationNameS, EX_NOTIFICATION_SUFFIX);

		BSTR mangledNotificationName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(mangledNotificationNameS));
		delete []mangledNotificationNameS;

		// Create the extended notification class

		ISmirExtNotificationClassHandle *exNotificationClassHandle = NULL ;
		result = pAdminInt->CreateWBEMExtNotificationClass(mangledNotificationName, &exNotificationClassHandle);

		SysFreeString(mangledNotificationName);
		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): Get ExNotification class failed" << endl;
			pInterrogateInt->Release();
			return result;
		}

		IWbemClassObject *exNotificationClass = NULL ;
		result = exNotificationClassHandle->GetWBEMExtNotificationClass ( & exNotificationClass ) ;
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GetWBEMExNotificationClass failed" << endl;
			return result;
		}

		// Set the module name on the class handle
		exNotificationClassHandle->SetModule(moduleName);

		// Set the attributes of the class
		result = GenerateExNotificationAttributes(pAdminInt, pInterrogateInt, pSerializeInt, notificationElement,
			exNotificationClass);
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GenerateExNotificationAttributes failed" << endl;
			exNotificationClassHandle->Release();
			pInterrogateInt->Release();
			return result;
		}

		// Set the properties of the class
		result = GenerateExNotificationProperties(pAdminInt, pInterrogateInt, pSerializeInt, notificationElement,
			exNotificationClass);
 		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): GenerateExNotificationProperties failed" << endl;
			exNotificationClass->Release();
			exNotificationClassHandle->Release();
			pInterrogateInt->Release();
			return result;
		}

		if(generateMof)
			result = pAdminInt->AddExtNotificationClassToSerialise(exNotificationClassHandle,
						pSerializeInt);
		else
			result = pAdminInt->AddExtNotificationClass(exNotificationClassHandle);

		if(FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationType(): AddExNotificationClass failed" << endl;
			exNotificationClass->Release();
			exNotificationClassHandle->Release();
			pInterrogateInt->Release();
			return result;
		}

		exNotificationClass->Release();
		exNotificationClassHandle->Release();
		pInterrogateInt->Release();
	}
	SysFreeString(moduleName);
	return result;
}

// Set the attributes of a notification class
static STDMETHODIMP GenerateNotificationAttributes(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass)
{
	// Get the description clause
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	// Set the various qualifiers
	IWbemQualifierSet *attributeSet ;
	HRESULT result = notificationClass->GetQualifierSet (&attributeSet);
  	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateNotificationAttributes(): GetAttribSet failed" << endl;
		return result;
	}
	VARIANT variant;
	VariantInit(&variant);

	// Set the Description attribute
	if(!UI->SuppressText() && notificationType->GetDescription())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(notificationType->GetDescription());
		result = attributeSet->Put ( DESCRIPTION_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationAttributes(): Put description failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Set the Reference attribute
	if(!UI->SuppressText() && notificationType->GetReference())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(notificationType->GetReference());
		result = attributeSet->Put ( REFERENCE_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateNotificationAttributes(): Put reference failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Set the "dynamic" attribute
	if(FAILED(result = MakeDynamic(attributeSet)))
	{
		if(simc_debug) cerr << "GenerateNotificationAttributes(): Make Dynamic failed" << endl;
		attributeSet->Release();
		return result;
	}

	// "provider"
	if(FAILED(result = SetProvider(attributeSet, SNMP_ENCAPSULATED_EVENT_PROVIDER)))
	{
		if(simc_debug) cerr << "GenerateNotificationAttributes(): Make Provider failed" << endl;
		attributeSet->Release();
		return result;
	}

 	attributeSet->Release();
	return result;

}

// Set the attributes of an extended notification class
static STDMETHODIMP GenerateExNotificationAttributes(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *exNotificationClass)
{
	// Get the description clause
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return WBEM_E_FAILED;

	// Get the Qualifier set
	IWbemQualifierSet *attributeSet ;
	HRESULT result = exNotificationClass->GetQualifierSet (&attributeSet);
  	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationAttributes(): GetAttribSet failed" << endl;
		return result;
	}

	VARIANT variant;
	VariantInit(&variant);

	// Set the Description attribute
	if(!UI->SuppressText() && notificationType->GetDescription())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(notificationType->GetDescription());
		result = attributeSet->Put ( DESCRIPTION_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION  ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateExNotificationAttributes(): Put description failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Set the Reference attribute
	if(!UI->SuppressText() && notificationType->GetReference())
	{
		variant.vt = VT_BSTR ;
		variant.bstrVal = ConvertAnsiToBstr(notificationType->GetReference());
		result = attributeSet->Put ( REFERENCE_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION  ) ;
		VariantClear ( & variant ) ;
		if (FAILED(result))
		{
			if(simc_debug) cerr << "GenerateExNotificationAttributes(): Put reference failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Set the "dynamic" attribute
	if(FAILED(result = MakeDynamic(attributeSet)))
	{
		if(simc_debug) cerr << "GenerateExNotificationAttributes(): Make Dynamic failed" << endl;
		attributeSet->Release();
		return result;
	}

	// "provider"
	if(FAILED(result = SetProvider(attributeSet, SNMP_REFERENT_EVENT_PROVIDER)))
	{
		if(simc_debug) cerr << "GenerateExNotificationAttributes(): Make Provider failed" << endl;
		attributeSet->Release();
		return result;
	}

 
 	attributeSet->Release();
	return result;

}

// Generate the "Identification" property and all the other properties of a notification class
static STDMETHODIMP GenerateNotificationProperties(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass)
{
	// Get the notification oid value 
	SIMCCleanOidValue *notificationOidValue = notificationElement->GetOidValue();
	char *notificationOidString = CleanOidValueToString(*notificationOidValue);

	// Create the "Identification" property
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(notificationOidString);
	VARTYPE varType = VT_BSTR ;
	// delete[] notificationOidString;
	HRESULT result = notificationClass->Put (IDENTIFICATION_NOTIFICATION_PROPERTY, 0, &variant, varType);
	VariantClear(&variant);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateNotificationProperties(): Put Property SnmpTrapOID failed" << endl;
		return result;
	}

	// Get the OBJECTS clause
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return E_FAIL;
	SIMCObjectsList *objects = notificationType->GetObjects();

	// Step thru the objects in the OBJECTS clause and generate appropriate properties
	if(!objects)
		return S_OK;
	POSITION p = objects->GetHeadPosition();
	SIMCObjectsItem *nextItem = NULL;
	SIMCSymbol ** object = NULL;
	int varBindIndex = 3; // Start at 3 according to the specifications
	while(p)
	{
		nextItem = objects->GetNext(p);
		object = nextItem->_item;
		result = GenerateNotificationObject(pAdminInt, pSerializeInt, notificationElement, object,
					varBindIndex++, notificationClass);
		if(FAILED(result))
			return result;
	}
	return result;
}


// Generate a property corresponding to an object in the OBJECTS clause
static STDMETHODIMP GenerateNotificationObject(ISmirAdministrator *pAdminInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			SIMCSymbol **object,
			int varBindIndex,
			IWbemClassObject *notificationClass)
{
	SIMCObjectTypeType *objType = NULL;
	switch(SIMCModule::IsObjectType(object, objType))
	{
		case RESOLVE_CORRECT:
			break;
		default:
			if(simc_debug)
				cout << "GenerateNotificationObject(): Object in Notification OBJECTS clause doesn't resolve properly" <<
					endl;
		return WBEM_E_FAILED;
	}

	// Set the PROPERTY NAME corresponding to the OBJECT-TYPE identifier
	wchar_t * objectName = ConvertAnsiToBstr((*object)->GetSymbolName());
	if(!objectName)
	{
		if(simc_debug) cerr << "GenerateNotificationObject(): ConvertAnsiToBstr - objectName failed" 
			<< endl;
		return WBEM_E_FAILED;
	}

	// Have to decide the 'type' of the property based on the
	// SYNTAX clause of the OBJECT-TYPE.
	HRESULT result = CreatePropertyAndMapSyntaxClause(notificationClass,
				objType->GetSyntax(),
				objectName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapSyntaxClause() failed" << endl;
		return result;
	}

	// Get the attribute set
	IWbemQualifierSet *attributeSet ;
	result = notificationClass->GetPropertyQualifierSet(objectName, &attributeSet);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateNotificationObject(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

			
	// Map Access Clause
	if( FAILED(result = MapAccessClause(attributeSet, objType)) )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapAccess() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Description Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapDescriptionClause(attributeSet, objType)) )
		{
			if(simc_debug) cerr << "GenerateNotificationObject() : MapDescriptionClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Reference Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapReferenceClause(attributeSet, objType)) )
		{
			if(simc_debug) cerr << "GenerateNotificationObject() : MapReferenceClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Status Clause
	if( FAILED(result = MapStatusClause(attributeSet, objType))  )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapStatusClause() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Defval Clause
	if( FAILED(result = MapDefValClause(attributeSet, objType))  )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapDefvalClause() failed" << endl;
		attributeSet->Release();
		return result;
	}


	// The "object_identifier" attribute
	if(FAILED(result = SetObjectIdentifierAttribute(attributeSet, object)))
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : SetObjectIdentifierAttribute() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// The "VarBindIndex" attribute
	if(FAILED(result = SetVarBindIndexAttribute(attributeSet, varBindIndex)))
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : SetVarBindIndexAttribute() failed" << endl;
		attributeSet->Release();
		return result;
	}

	attributeSet->Release();
	return S_OK;

}

static STDMETHODIMP SetObjectIdentifierAttribute (IWbemQualifierSet * attributeSet, SIMCSymbol **object)
{
	SIMCModule *module = (*object)->GetModule();
	SIMCObjectGroup *ownerGroup = module->GetObjectGroup(*object);
	SIMCTable *ownerTable = NULL;
	SIMCScalar *ownerScalar = NULL;
	char * snmpClassName = NULL;
	SIMCCleanOidValue *oidValue = NULL;
	if(!ownerGroup)
	{
		if(simc_debug)
			cout << "SetObjectIdentifierAttribute() : Could not get group for " << (*object)->GetSymbolName()
				<< endl;
		return WBEM_E_FAILED;
	}

	// See if it is a scalar
	if(ownerScalar = ownerGroup->GetScalar(*object))
	{
		// The oid value of the scalar
		oidValue = ownerScalar->GetOidValue();
	}
	// ... or a table
	else if(ownerTable = ownerGroup->GetTable(*object))
	{
		// And the oid value of the object
		SIMCScalar *columnScalar = ownerTable->GetColumnMember(*object);
		oidValue = columnScalar->GetOidValue();
	}
	else
	{
		if(simc_debug)
			cout << "SetObjectIdentifierAttribute() : Could not get table for " << (*object)->GetSymbolName()
				<< endl;
		return WBEM_E_FAILED;
	}


	// Set the "object_identifier" attribute
	VARIANT variant ;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(ConvertHyphensToUnderscores(snmpClassName));
	// Set the object_identifier attribute
	HRESULT result = MapOidValue(attributeSet, *oidValue);
	if( FAILED(result) )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapOidValue() failed" << endl;
		attributeSet->Release();
		return result;
	}
	return S_OK;
}

static STDMETHODIMP SetVarBindIndexAttribute (IWbemQualifierSet *attributeSet, int varBindIndex)
{
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_I4 ;
	variant.lVal = varBindIndex;
	HRESULT result = attributeSet->Put ( VAR_BIND_INDEX_NOTIFICATION_ATTRIBUTE, &variant, WBEM_CLASS_DO_PROPAGATION ) ;
	VariantClear(&variant);
	if(FAILED(result))
	{
		if(simc_debug)
			cout << "SetVarBindIndexAttribute() : Could not set VarBindIndex "<< endl;
		return WBEM_E_FAILED;
	}
	return S_OK;

}



// Generate all the properties of the Extended Notification class
static STDMETHODIMP GenerateExNotificationProperties(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			IWbemClassObject *notificationClass)
{
	// Get the notification oid value 
	SIMCCleanOidValue *notificationOidValue = notificationElement->GetOidValue();
	char *notificationOidString = CleanOidValueToString(*notificationOidValue);

	// Create the "Identification" property
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_BSTR ;
	variant.bstrVal = ConvertAnsiToBstr(notificationOidString);
	VARTYPE varType = VT_BSTR ;
	// delete[] notificationOidString;
	HRESULT result = notificationClass->Put (IDENTIFICATION_NOTIFICATION_PROPERTY, 0, &variant, varType);
	VariantClear(&variant);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationProperties(): Put Property SnmpTrapOID failed" << endl;
		return result;
	}

	// Get the OBJECTS clause
	SIMCSymbol *notificationSymbol = notificationElement->GetSymbol();
	SIMCNotificationTypeType *notificationType = NULL;
	if(SIMCModule::IsNotificationType(&notificationSymbol, notificationType) != RESOLVE_CORRECT)
		return E_FAIL;
	SIMCObjectsList *objects = notificationType->GetObjects();

	// Step thru the objects in the OBJECTS clause and generate appropriate properties
	if(!objects)
		return S_OK;
	POSITION p = objects->GetHeadPosition();
	SIMCObjectsItem *nextItem = NULL;
	SIMCSymbol ** object = NULL;
	int varBindIndex = 3; // Start at 3 according to the specifications
	while(p)
	{
		nextItem = objects->GetNext(p);
		object = nextItem->_item;
		result = GenerateExNotificationObject(pAdminInt, 
					pInterrogateInt, pSerializeInt, notificationElement, object,
					varBindIndex++, notificationClass);
		if(FAILED(result))
			return result;
	}

	
		
	return result;
}

// Generate the property in the entended notifications class, corresponding to the object in the OBJECTs clause
static STDMETHODIMP GenerateExNotificationObject(ISmirAdministrator *pAdminInt,
			ISmirInterrogator *pInterrogateInt,
			ISmirSerialiseHandle *pSerializeInt,
			SIMCNotificationElement * notificationElement,
			SIMCSymbol **object,
			int varBindIndex,
			IWbemClassObject *exNotificationClass)
{
	SIMCModule *module = (*object)->GetModule();
	SIMCObjectGroup *ownerGroup = module->GetObjectGroup(*object);
	SIMCTable *ownerTable = NULL;
	SIMCScalar *ownerScalar = NULL;
	char *snmpClassName = NULL;
	if(!ownerGroup)
	{
		if(simc_debug)
			cout << "GenerateExNotificationObject() : Could not get group for " << (*object)->GetSymbolName()
				<< endl;
		return WBEM_E_FAILED;
	}

	// See if it is a scalar
	if(ownerScalar = ownerGroup->GetScalar(*object))
	{
		// Form the name of the scalar class
		SIMCSymbol * namedNode = ownerGroup->GetNamedNode();
		const char * const namedNodeName = namedNode->GetSymbolName();
		SIMCModule *scalarModule = namedNode->GetModule();
		const char * const moduleName = scalarModule->GetModuleName();

		snmpClassName = new char[strlen(GROUP_NAME_PREPEND_STRING) +
					strlen(moduleName) + 1 + strlen(namedNodeName) +1 ];
		strcpy(snmpClassName, GROUP_NAME_PREPEND_STRING);
		strcat(snmpClassName, moduleName);
		strcat(snmpClassName, "_");
		strcat(snmpClassName, namedNodeName);

	}
	// ... or a table
	else if(ownerTable = ownerGroup->GetTable(*object))
	{
		// Form the name of the table group
		SIMCSymbol *tableNode = ownerTable->GetTableSymbol();
		SIMCModule *tableModule = tableNode->GetModule();
		const char * const moduleName = tableModule->GetModuleName();
		const char * const tableNodeName = tableNode->GetSymbolName();

		snmpClassName = new char[strlen(GROUP_NAME_PREPEND_STRING) +
					strlen(moduleName) + 1 + strlen(tableNodeName) +1 ];
		strcpy(snmpClassName, GROUP_NAME_PREPEND_STRING);
		strcat(snmpClassName, moduleName);
		strcat(snmpClassName, "_");
		strcat(snmpClassName, tableNodeName);
	}
	else
	{
		if(simc_debug)
			cout << "GenerateExNotificationObject() : Could not get table for " << (*object)->GetSymbolName()
				<< endl;
		return WBEM_E_FAILED;
	}


	// We have the class name now, we need to create a property of this type, and with the VarBindIndex
	// qualifier set to the appropriate value.
	// First, get the IWbemClassObject pointer
	IWbemClassObject *pClassBasis = NULL;
	BSTR theClassName = ConvertAnsiToBstr(ConvertHyphensToUnderscores(snmpClassName));
	delete[] snmpClassName;
	HRESULT result = pInterrogateInt->GetWBEMClass(&pClassBasis, theClassName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationObject(): Could not Get WBEM class" << endl;	  
		return result;
	}

	BSTR propertyName = ConvertAnsiToBstr((*object)->GetSymbolName());
	VARIANT variant;
	VariantInit(&variant);
	variant.vt = VT_UNKNOWN ;
	variant.punkVal = pClassBasis;
	VARTYPE varType = VT_UNKNOWN ;

	result = exNotificationClass->Put (propertyName, 0, NULL, CIM_REFERENCE );
	VariantClear(&variant);
	if (FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationProperties(): Put Property SnmpTrapOID failed" << endl;
		return result;
	}

	// Get the attribute set
	IWbemQualifierSet *attributeSet = NULL;
	result = exNotificationClass->GetPropertyQualifierSet(propertyName, &attributeSet);
	SysFreeString(propertyName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationObject(): Could not get prop attrib" << endl;	  
		return WBEM_E_FAILED;
	}

	// Set a CIMTYPE qualifier that is a strong reference
	result = SetCIMTYPEAttribute(attributeSet, theClassName);
	SysFreeString(theClassName);
	if(FAILED(result))
	{
		if(simc_debug) cerr << "GenerateExNotificationObject():SetCIMTYPEattributeSet FAILED with " << result << endl;	  
		return WBEM_E_FAILED;
	}

	SIMCObjectTypeType *objType = NULL;
	switch(SIMCModule::IsObjectType(object, objType))
	{
		case RESOLVE_CORRECT:
			break;
		default:
			if(simc_debug)
				cout << "GenerateExNotificationObject(): Object in Notification OBJECTS clause doesn't resolve properly" <<
					endl;
		return WBEM_E_FAILED;
	}

			
	// Map Access Clause
	if( FAILED(result = MapAccessClause(attributeSet, objType)) )
	{
		if(simc_debug) cerr << "GenerateExNotificationObject() : MapAccess() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// Map Description Clause
	if(!UI->SuppressText())
	{
		if( FAILED(result = MapDescriptionClause(attributeSet, objType)) )
		{
			if(simc_debug) cerr << "GenerateNotificationObject() : MapDescriptionClause() failed" << endl;
			attributeSet->Release();
			return result;
		}
	}

	// Map Status Clause
	if( FAILED(result = MapStatusClause(attributeSet, objType))  )
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : MapStatusClause() failed" << endl;
		attributeSet->Release();
		return result;
	}

	// The "VarBindIndex" attribute
	if(FAILED(result = SetVarBindIndexAttribute(attributeSet, varBindIndex)))
	{
		if(simc_debug) cerr << "GenerateNotificationObject() : SetVarBindIndexAttribute() failed" << endl;
		attributeSet->Release();
		return result;
	}

	attributeSet->Release();
	return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\resource.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\main.hpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
#ifndef SIMC_IMOS_GEN_H
#define SIMC_IMOS_GEN_H


const int INFO_MESSAGE_SIZE = 1024;
#define INFO_MESSAGES_DLL	"smimsgif.dll"

typedef void ** PPVOID;
typedef CList<CString, CString&> SIMCStringList;

void InformationMessage(int messageType, ...);

extern CString versionString;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\generator.hpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef SIMC_GENERATOR_H
#define SIMC_GENERATOR_H

extern BOOL simc_debug;

STDMETHODIMP GenerateClassDefinitions (ISMIRWbemConfiguration *a_Configuration , const SIMCUI& theUI, SIMCParseTree&, BOOL generateMof);
BSTR ConvertAnsiToBstr(const char * const input);
char * ConvertBstrToAnsi(const BSTR& unicodeString);

// prefixes, suffixes for group names, notification names etc
#define GROUP_NAME_PREPEND_STRING			"SNMP_"
#define NOTIFICATION_SUFFIX					"Notification"
#define EX_NOTIFICATION_SUFFIX				"ExtendedNotification"


// WBEM constants
#define WBEM_CLASS_NO_PROPAGATION WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS
#define WBEM_CLASS_DO_PROPAGATION WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE | WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS

// WBEM properties
#define NAME_PROPERTY		(L"__NAME")
#define CLASS_PROPERTY		(L"__CLASS")
#define DYNASTY_PROPERTY	(L"__DYNASTY")
#define PARENT_PROPERTY		(L"__PARENT")


// Property and Class Attributes
#define PROVIDER_ATTRIBUTE				(L"provider")
#define DYNAMIC_ATTRIBUTE				(L"dynamic")
#define MODULE_NAME_ATTRIBUTE			(L"module_name")
#define MODULE_IMPORTS_ATTRIBUTE		(L"module_imports")
#define GROUP_OBJECTID_ATTRIBUTE		(L"group_objectid")
#define KEY_ATTRIBUTE					(L"key")
#define KEY_ORDER_ATTRIBUTE				(L"key_order")
#define OBJECT_IDENTIFIER_ATTRIBUTE		(L"object_identifier")
#define CIMTYPE_ATTRIBUTE				(L"CIMType")
#define TEXTUAL_CONVENTION_ATTRIBUTE	(L"textual_convention")
#define DISPLAY_HINT_ATTRIBUTE			(L"display_hint")
#define ENCODING_ATTRIBUTE				(L"encoding")
#define OBJECT_SYNTAX_ATTRIBUTE			(L"object_syntax")
#define ODBC_SYNTAX_ATTRIBUTE			(L"odbc_syntax")
#define DEFVAL_ATTRIBUTE				(L"defval")
#define FIXED_LENGTH_ATTRIBUTE			(L"fixed_length")
#define VARIABLE_LENGTH_ATTRIBUTE		(L"variable_length")
#define VARIABLE_VALUE_ATTRIBUTE		(L"variable_value")
#define READ_ATTRIBUTE					(L"read")
#define WRITE_ATTRIBUTE					(L"write")
#define DESCRIPTION_ATTRIBUTE			(L"description")
#define UNITS_ATTRIBUTE					(L"units")
#define REFERENCE_ATTRIBUTE				(L"reference")
#define STATUS_ATTRIBUTE				(L"status")
#define ENUMERATION_ATTRIBUTE			(L"enumeration")
#define VIRTUAL_KEY_ATTRIBUTE			(L"virtual_key")
#define BITS_ATTRIBUTE					(L"bits")
#define SINGLETON_ATTRIBUTE				(L"singleton")


// Variant Types
#define VT_I4_TYPE					"sint32"
#define VT_UI4_TYPE					"uint32"
#define VT_NULL_TYPE				"VT_NULL"
#define VT_BSTR_TYPE				"string"
#define VT_ARRAY_OR_VT_BSTR_TYPE	"VT_BSTR"
#define VT_ARRAY_OR_VT_I4_TYPE		"VT_I4"

// Textual Convention Attribute Values
#define INTEGER_TYPE					"INTEGER"
#define OCTETSTRING_TYPE				"OCTETSTRING"
#define OBJECTIDENTIFIER_TYPE			"OBJECTIDENTIFIER"
#define NULL_TYPE						"NULL"
#define IpAddress_TYPE					"IpAddress"
#define Counter_TYPE					"Counter"
#define Gauge_TYPE						"Gauge"
#define TimeTicks_TYPE					"TimeTicks"
#define Opaque_TYPE						"Opaque"
#define NetworkAddress_TYPE				"NetworkAddress"
#define DisplayString_TYPE				"DisplayString"
#define MacAddress_TYPE					"MacAddress"
#define PhysAddress_TYPE				"PhysAddress"
#define EnumeratedINTEGER_TYPE			"EnumeratedINTEGER"
#define BITS_TYPE						"BITS"
#define Integer32_TYPE					"Integer32"
#define Unsigned32_TYPE					"Unsigned32"
#define Gauge32_TYPE					"Gauge32"
#define Counter32_TYPE					"Counter32"
#define Counter64_TYPE					"Counter64"
#define DateAndTime_TYPE				"DateAndTime"
#define SnmpUDPAddress_TYPE				"SnmpUDPAddress"
#define SnmpIPXAddress_TYPE				"SnmpIPXAddress"
#define SnmpOSIAddress_TYPE				"SnmpOSIAddress"

// Values for the PROVIDER_ATTRIBUTE
#define SNMP_INSTANCE_PROVIDER				(L"MS_SNMP_INSTANCE_PROVIDER")
#define SNMP_REFERENT_EVENT_PROVIDER		(L"MS_SNMP_REFERENT_EVENT_PROVIDER")
#define SNMP_ENCAPSULATED_EVENT_PROVIDER	(L"MS_SNMP_ENCAPSULATED_EVENT_PROVIDER")

// Notification class property/attribute names
#define DESCRIPTION_NOTIFICATION_ATTRIBUTE		(L"Description")
#define REFERENCE_NOTIFICATION_ATTRIBUTE		(L"Reference")
#define IDENTIFICATION_NOTIFICATION_PROPERTY	(L"Identification")
#define VAR_BIND_INDEX_NOTIFICATION_ATTRIBUTE	(L"VarBindIndex")

// Values for the KEY_TYPES_NOTIFICATION_ATTRIBUTE
#define INTEGER_KEY_TYPE						"INTEGER"
#define FIXED_STRING_KEY_TYPE					"FIXED_STRING"
#define VARIABLE_STRING_KEY_TYPE				"VARIABLE_STRING"
#define FIXED_OID_KEY_TYPE						"FIXED_OID"
#define VARIABLE_OID_KEY_TYPE					"VARIABLE_OID"
#define IP_ADDRESS_KEY_TYPE						"IP_ADDRESS"

// The Microsoft Copyright
#define MICROSOFT_COPYRIGHT						"// (c) 1998-2001 Microsoft Corporation.  All rights reserved."

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// All Rights Reserved.
//

 
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <limits.h>

#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>
							   
#include <windows.h>

#include <objbase.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\bool.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef BOOL_H
#define BOOL_H

/*
 * Just typedefs BOOL to an integer, and defines values for true and false
 */

typedef int BOOL;
#ifndef FALSE
const int FALSE = 0;
const int TRUE = !FALSE;
#endif

#endif // BOOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\exe\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>


#ifndef INITGUID
#define INITGUID
#endif

#ifdef INITGUID_DEFINED
#define INITGUID
#include <initguid.h>
#endif

#include <wchar.h>
#include <process.h> 
#include <wbemidl.h>
#include <objbase.h>
#include <initguid.h>

#include <bool.hpp>
#include <newString.hpp>
	
#include <ui.hpp>
#include <symbol.hpp>
#include <type.hpp>
#include <value.hpp>
#include <valueRef.hpp>
#include <typeRef.hpp>
#include <oidValue.hpp>
#include <objectType.hpp>
#include <objectTypeV1.hpp>
#include <objectTypeV2.hpp>
#include <objectIdentity.hpp>
#include <trapType.hpp>
#include <notificationType.hpp>
#include <group.hpp>
#include <notificationGroup.hpp>
#include <module.hpp>


#include <stackValues.hpp>
#include <lex_yy.hpp>
#include <ytab.hpp>
#include <errorMessage.hpp>
#include <errorContainer.hpp>
#include <scanner.hpp>
#include <parser.hpp>
#include <abstractParseTree.hpp>
#include <oidTree.hpp>
#include <parseTree.hpp>
#include <infoLex.hpp>
#include <infoYacc.hpp>
#include <moduleInfo.hpp>
#include <registry.hpp>

#include "smir.h"

#include "main.hpp"
#include "generator.hpp"
#include "smimsgif.hpp"

// The errors container used to hold the error messages. This is global too.
static SIMCErrorContainer errorContainer;
// The DLL that contains the information messages
static HINSTANCE infoMessagesDll = LoadLibrary(INFO_MESSAGES_DLL);
// The string that represents the version# of Smi2smir. This is obtained from
// the string resources of the exe.
CString versionString;

void SetEcho ()
{
	HANDLE t_Input = GetStdHandle( STD_INPUT_HANDLE );
	DWORD t_Mode = 0 ;
	BOOL t_Status = GetConsoleMode ( t_Input , & t_Mode ) ;
	t_Mode = t_Mode | ENABLE_ECHO_INPUT ;
	t_Status = SetConsoleMode ( t_Input , t_Mode ) ;
}

void SetNoEcho ()
{
	HANDLE t_Input = GetStdHandle( STD_INPUT_HANDLE );
	DWORD t_Mode = 0 ;
	BOOL t_Status = GetConsoleMode ( t_Input , & t_Mode ) ;
	t_Mode = t_Mode & ( 0xffffffff ^ ENABLE_ECHO_INPUT ) ;
	t_Status = SetConsoleMode ( t_Input , t_Mode ) ;
}


// A routine to generate information messages
void InformationMessage(int messageType, ...)
{
	if( !infoMessagesDll)
	{
		cerr << "smi2smir : Could not load \"" <<
			INFO_MESSAGES_DLL << "\".\n" << endl;
		return;
	}

	va_list argList;
	va_start(argList, messageType);

	char message[INFO_MESSAGE_SIZE];
	char messageText[INFO_MESSAGE_SIZE];
	const char *temp1, *temp2, *temp3;
	long temp4;

	if(!LoadString(infoMessagesDll, messageType, messageText, INFO_MESSAGE_SIZE))
		cerr << "smi2smir: Panic, unable to load message text from " << INFO_MESSAGES_DLL <<
			endl;

	SIMCErrorMessage e;
	if(messageType == FILE_NOT_FOUND || messageType == INVALID_MIB_FILE)
	{
		e.SetSeverityLevel(SIMCParseTree::FATAL);
		e.SetSeverityString("Fatal");
	}
	else
	{
		e.SetSeverityLevel(SIMCParseTree::INFORMATION);
		e.SetSeverityString("Information");
	}
	switch(messageType)
	{
		case SMIR_CONNECT_FAILED:
		case LISTING_MODULES:
		case LISTING_FAILED:
		case PURGE_SUCCEEDED:
		case PURGE_FAILED:
		case MODULE_LISTING:
		case MODULE_LISTING_NO_MODULES:
		case MIB_PATH_LISTING:
		case LISTING_MIB_PATHS:
		case LISTING_MIB_PATHS_NONE:
			temp1 = va_arg(argList, const char *);
			sprintf(message, messageText, temp1);
			break;
		case SMI2SMIR_INFO:
		case SYNTAX_CHECK_FAILED:
		case SYNTAX_CHECK_SUCCEEDED:
		case SEMANTIC_CHECK_FAILED:
		case SEMANTIC_CHECK_SUCCEEDED:
		case SMIR_LOAD_FAILED:
		case SMIR_LOAD_SUCCEEDED:
		case MOF_GENERATION_FAILED:
		case MOF_GENERATION_SUCCEEDED:
		case SYMBOL_RESOLUTION_FAILED:
		case DELETE_SUCCEEDED:
		case DELETE_FAILED:
		case DELETE_MODULE_NOT_FOUND:
		case FILE_NOT_FOUND:
		case MODULE_NAME_SUCCEEDED:
		case MODULE_INFO_FAILED:
		case DIRECTORY_ADDITION_SUCCEEDED:
		case DIRECTORY_ADDITION_FAILED:
		case DIRECTORY_DELETION_SUCCEEDED:
		case DIRECTORY_DELETION_FAILED:
		case INVALID_MIB_FILE:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			sprintf(message, messageText, temp1, temp2);
			break;
		case COMPILED_FILE:
		case DUPLICATE_MODULES:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			temp3 = va_arg(argList, const char *);
			sprintf(message, messageText, temp1, temp2, temp3);
			break;
		case NUMBER_OF_ENTRIES:
			temp1 = va_arg(argList, const char *);
			temp4 = va_arg(argList, long);
			sprintf(message, messageText, temp1, temp4);
			break;
	}
	va_end(argList);

	e.SetMessage(message);
	e.SetLineAndColumnValidity(FALSE);
	errorContainer.InsertMessage(e);
}


void CheckForDuplicateModules(SIMCFileMapList &dependencyList, const CString& applicationName)
{
	POSITION pOuter = dependencyList.GetHeadPosition();
	SIMCFileMapElement nextElement, laterElement;
	while(pOuter)
	{
		nextElement = dependencyList.GetNext(pOuter);
		POSITION pInner = pOuter, pTemp;
		while(pInner)
		{
			pTemp = pInner;
			laterElement = dependencyList.GetNext(pInner);
			if(laterElement.moduleName == nextElement.moduleName)
			{
				InformationMessage(DUPLICATE_MODULES, applicationName, 
					nextElement.moduleName,
					nextElement.fileName);
				if(pTemp == pOuter)
					pOuter = pInner;
				dependencyList.RemoveAt(pTemp);
			}
		}
	}
}

// Returns true if there's atleast one module in SMIR
BOOL AreModulesInSmir(ISMIRWbemConfiguration *a_Configuration, const CString& applicationName)
{

	// Create the interrogative interface 
	ISmirInterrogator *pInterrogateInt;
	HRESULT result = a_Configuration->QueryInterface(IID_ISMIR_Interrogative,(PPVOID)&pInterrogateInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "AreModulesInSmir(): CoCreate() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}

	// Create an enumerator
	IEnumModule *pEnumInt;
	result = pInterrogateInt->EnumModules(&pEnumInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "AreModulesInSmir(): EnumModules() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		pInterrogateInt->Release();
		return FALSE;
	}

	// If no modules return
	ISmirModHandle *nextModule = NULL;
	if(pEnumInt->Next(1, &nextModule, NULL) != S_OK)
	{
		pEnumInt->Release();
		pInterrogateInt->Release();
		return FALSE;
	}

	// Release all enumeration interfaces
	pEnumInt->Release();
	pInterrogateInt->Release();
	nextModule->Release();
	return TRUE;
}

// Lists all the modules in the SMIR
BOOL SIMCListSmir(ISMIRWbemConfiguration *a_Configuration , const CString& applicationName) 
{
	// Create the interrogative interface 
	ISmirInterrogator *pInterrogateInt;
	HRESULT result = a_Configuration->QueryInterface(IID_ISMIR_Interrogative,(PPVOID)&pInterrogateInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCListSmir(): CoCreate() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}

	IEnumModule *pEnumInt;
	result = pInterrogateInt->EnumModules(&pEnumInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCListSmir(): EnumModules() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		pInterrogateInt->Release();
		return FALSE;
	}


	BOOL first = true;
	ISmirModHandle *nextModule = NULL;
	BSTR moduleName;
	while(pEnumInt->Next(1, &nextModule, NULL) == S_OK)
	{
		if(nextModule->GetName(&moduleName) == S_OK)
		{
			if(first)
			{
				InformationMessage(LISTING_MODULES, applicationName);
				cout << endl;
				first = false;
			}

			char *moduleNameStr = ConvertBstrToAnsi(moduleName);
			InformationMessage(MODULE_LISTING, moduleNameStr);
			delete moduleNameStr;
			SysFreeString(moduleName);
		}
		
		nextModule->Release();
		nextModule = NULL;
	}

	if(first)
		InformationMessage(MODULE_LISTING_NO_MODULES, applicationName);

	pEnumInt->Release();
	pInterrogateInt->Release();

	return TRUE;
}

// Lists all the MIB paths (directories) in the registry
BOOL SIMCListMibPaths(const CString& applicationName) 
{

	SIMCStringList pathList;
	if(SIMCRegistryController::GetMibPaths(pathList))
	{
		// Successful in reading the MIB path list from registry
		POSITION p = pathList.GetHeadPosition();
		if(p) // There's atleast one MIB path
		{
			InformationMessage(LISTING_MIB_PATHS, applicationName);
			while(p)
				InformationMessage(MODULE_LISTING, pathList.GetNext(p));
		}
		else // There are no MIB paths in the registry
			InformationMessage(LISTING_MIB_PATHS_NONE, applicationName);
	}
	else // Failed to read the list of paths. Report that there are no paths
		InformationMessage(LISTING_MIB_PATHS_NONE, applicationName);
	
	return true;

}

// Deletes a specified module in the SMIR
BOOL SIMCDeleteModule(ISMIRWbemConfiguration *a_Configuration , const CString& applicationName, const CString& moduleName)
{
	// Create the administrator, to delete the module
	ISmirAdministrator *pAdminInt = NULL;
	HRESULT result=a_Configuration->QueryInterface(IID_ISMIR_Administrative,(PPVOID)&pAdminInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCDeleteModule() : CoCreate() failed on the Administrator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}

	// Create the Interrogator to get the module handle of the
	// module to be deleted
	ISmirInterrogator *pInterrogateInt = NULL;
	result = a_Configuration->QueryInterface(IID_ISMIR_Interrogative,(PPVOID)&pInterrogateInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCDeleteModule() : CoCreate() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}

	// Get the module handle using the enumerator and interrogator
	IEnumModule *pEnumInt = NULL;
	result = pInterrogateInt->EnumModules(&pEnumInt);
	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCDeleteModule() : EnumModules() failed on the Interrogator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		pAdminInt->Release();
		pInterrogateInt->Release();
		return FALSE;
	}

	ISmirModHandle *nextModule = NULL;
	BSTR moduleNameBstr;
	char * moduleNameAnsi;
	while( pEnumInt->Next(1, &nextModule, NULL) == S_OK  && nextModule)
	{
		nextModule->GetName(&moduleNameBstr);
		moduleNameAnsi = ConvertBstrToAnsi(moduleNameBstr);
		SysFreeString(moduleNameBstr);
		if(_stricmp(moduleNameAnsi, moduleName) == 0)
		{
			delete moduleNameAnsi;
			//nextModule->AddRef();
			BOOL retval = SUCCEEDED(pAdminInt->DeleteModule(nextModule));
			pAdminInt->Release();
			pInterrogateInt->Release();
			nextModule->Release();

			return retval;
		}
		
		nextModule->Release();
		nextModule = NULL;
	}
 	InformationMessage(DELETE_MODULE_NOT_FOUND, applicationName, moduleName);
	pAdminInt->Release();
	pInterrogateInt->Release();

	return FALSE;
	
}

// Deletes all the modules in the SMIR
BOOL SIMCPurgeSmir(ISMIRWbemConfiguration *a_Configuration , const CString& applicationName)
{

	// Create the administrator, to delete the modules
	ISmirAdministrator *pAdminInt = NULL;
	HRESULT result = a_Configuration->QueryInterface(IID_ISMIR_Administrative,(PPVOID)&pAdminInt);

	if(FAILED(result))
	{
		if(simc_debug)
			cerr << "SIMCPurgeSmir() : CoCreate() failed on the Admionistrator" << endl;
		InformationMessage(SMIR_CONNECT_FAILED, applicationName);
		return FALSE;
	}
 	
	BOOL retval = SUCCEEDED(pAdminInt->DeleteAllModules());
	pAdminInt->Release();

	return retval;
}

// Filters the errors based on the switches on the command-line
void FilterErrors(SIMCErrorContainer *errorContainer,
				  const SIMCUI& theUI)
{
	errorContainer->MoveToFirstMessage();
	SIMCErrorMessage e;
	int i = theUI.GetMaxDiagnosticCount();
	int maxSeverityLevel = theUI.GetDiagnosticLevel();
	while(errorContainer->GetNextMessage(e))
	{
		  if(e.GetSeverityLevel() == 3 )
			  cerr << e;
		  else if(e.GetSeverityLevel() <= maxSeverityLevel && i>0)
		  {
			  cerr << e;
			  i--;
		  }
	}
}

// Checks whether the main mib file and the subsidiary files are
// compilable, and adds them to the priority map
// Adds any files in the include directories to the priority map
BOOL PrepareSubsidiariesAndIncludes(const CString& applicationName,
									const CString& mainFileName,
									const SIMCFileList&	subsidiaryFiles,
									const SIMCPathList& includePaths,
									SIMCFileMapList& priorityMap)
{
	// Parse the subsidiaries and add em to dependency list or 
	//issue messages
	// Same with  includes?
	BOOL retVal = TRUE;
	FILE * fp = fopen(mainFileName, "r");
	if(fp)
	{
 		SIMCModuleInfoScanner smallScanner;
		SIMCModuleInfoParser smallParser;
		smallScanner.setinput(fp);
		if(smallParser.GetModuleInfo(&smallScanner))
			priorityMap.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), mainFileName));
		else
		{
			InformationMessage(INVALID_MIB_FILE, 
				applicationName, mainFileName);
			retVal = FALSE;
		}
		fclose(fp);
	}
	else
	{
		retVal = FALSE;
		InformationMessage(FILE_NOT_FOUND, applicationName, mainFileName);
	}

	POSITION pFiles = subsidiaryFiles.GetHeadPosition();
	CString nextFile;
	while(pFiles)
	{
		nextFile = subsidiaryFiles.GetNext(pFiles);
		fp = fopen(nextFile, "r");
		if(fp)
		{
 			SIMCModuleInfoScanner smallScanner;
			SIMCModuleInfoParser smallParser;
			smallScanner.setinput(fp);
			if(smallParser.GetModuleInfo(&smallScanner))
				priorityMap.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), nextFile));
			else
			{
				InformationMessage(INVALID_MIB_FILE, 
					applicationName, nextFile);
				retVal = FALSE;
			}
			fclose(fp);
		}
		else
		{
			retVal = FALSE;
			InformationMessage(FILE_NOT_FOUND, applicationName, nextFile);
		}
	}

	// Make sure that there arent any duplicates
	CheckForDuplicateModules(priorityMap, applicationName);

	// Now do the same for the files in the include list
	SIMCStringList suffixList;
	if(!SIMCRegistryController::GetMibSuffixes(suffixList))
		return retVal;

	POSITION pPaths = includePaths.GetHeadPosition();
	CString nextPath;
	while(pPaths)
	{
		nextPath = includePaths.GetNext(pPaths);
		SIMCRegistryController::RebuildDirectory(nextPath, 
			suffixList, priorityMap);
	}

	return retVal;

}

int _cdecl main( int argc, const char *argv[])
{
	SIMCUI theUI;

	// Parse the command-line
	if( !theUI.ProcessCommandLine(argc, argv))
		 return 1;

	// Create and initialize variables
	simc_debug = theUI.IsSimcDebug();
	SIMCParseTree theTree(&errorContainer);
	CString inputFileName = theUI.GetInputFileName(), 
			applicationName = theUI.GetApplicationName();
	long snmpVersion = theUI.GetSnmpVersion();
	BOOL retVal = TRUE, generateMof = FALSE;
	versionString = theUI.GetVersionNumber();

	ISMIRWbemConfiguration *t_Configuration = NULL ;

	switch (theUI.GetCommandArgument())
	{
/* 
 *	These commands access the SMIR so Authenticate first.
 */

		case SIMCUI::COMMAND_PURGE:
		case SIMCUI::COMMAND_DELETE:
		case SIMCUI::COMMAND_LIST:	
		case SIMCUI::COMMAND_GENERATE:
		case SIMCUI::COMMAND_GENERATE_CLASSES_ONLY:
		case SIMCUI::COMMAND_ADD:
		case SIMCUI::COMMAND_SILENT_ADD:	
		{
			HRESULT result = CoInitialize(NULL);

			result = CoCreateInstance (

				CLSID_SMIR_Database , NULL ,
				CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , 
				IID_ISMIRWbemConfiguration,
				(PPVOID)&t_Configuration
			) ;

			if ( SUCCEEDED ( result ) )
			{
#if 0
				cout << "Enter password:" << flush;
				char response[80];
				SetNoEcho ();
				cin.get(response, 80);
				SetEcho () ;
#endif
				result = t_Configuration->Authenticate (

					NULL,
					NULL,
					NULL,
					NULL,
					0 ,
					NULL,
					FALSE
				) ;

				if ( ! SUCCEEDED ( result ) )
				{
					InformationMessage(SMIR_CONNECT_FAILED, applicationName);
					if( theUI.GetCommandArgument() != SIMCUI::COMMAND_SILENT_ADD)
						FilterErrors(&errorContainer, theUI);
					return 1;
				}
			}
			else
			{
				if(result != S_OK)
				{
					InformationMessage(SMIR_CONNECT_FAILED, 
						applicationName);
					if( theUI.GetCommandArgument() != SIMCUI::COMMAND_SILENT_ADD)
						FilterErrors(&errorContainer, theUI);
					return 1;
				}
			}
		}
	}


	// Do the action specified on the command-line
	switch (theUI.GetCommandArgument())
	{
		case SIMCUI::COMMAND_HELP1:
		case SIMCUI::COMMAND_HELP2:
			theUI.Usage();
		break;

		case SIMCUI::COMMAND_PURGE:
		{
			// Check to see if there is atleast 1 module
			if(!AreModulesInSmir(t_Configuration, applicationName)) {
				InformationMessage(MODULE_LISTING_NO_MODULES, applicationName);
				retVal = FALSE;
				break;
			}

			// Confirm the purge
			if(!theUI.ConfirmedPurge()) {
				cout << applicationName << " : Version:" << versionString << ": Delete all modules from the SMIR? [y/n]" << flush;
				char response[80];
				cin.get(response, 80);
				if(strcmp(response, "y") != 0)
				{
					retVal = TRUE;
					break;
				}
			}

			// Get on with the purging now.
			if(!SIMCPurgeSmir(t_Configuration, applicationName) )
			{
				InformationMessage(PURGE_FAILED, applicationName);
				retVal = FALSE;
				break;
			}
			else
			{
				InformationMessage(PURGE_SUCCEEDED, applicationName);
				retVal = TRUE;
				break;
			}
		}
		break;
		
		case SIMCUI::COMMAND_DELETE:
		{
			InformationMessage(SMI2SMIR_INFO, applicationName, versionString);
			cout << endl;

			CString moduleName = theUI.GetModuleName();
			
			if(!SIMCDeleteModule(t_Configuration,applicationName, moduleName))
			{
				InformationMessage(DELETE_FAILED, applicationName, moduleName);
				retVal = FALSE;
				break;
			}
			else
			{
				InformationMessage(DELETE_SUCCEEDED, applicationName, moduleName);
				retVal = TRUE;
				break;
			}
		}
 		break;

		case SIMCUI::COMMAND_LIST:	
		{
			InformationMessage(SMI2SMIR_INFO, applicationName, versionString);
			cout << endl;
			
			if(!SIMCListSmir(t_Configuration,applicationName))
			{
				InformationMessage(LISTING_FAILED, applicationName);
				retVal = FALSE;
			}
			else
			{
				retVal = TRUE;
			}
		}
		break;
	
		case SIMCUI::COMMAND_MODULE_NAME:
			{
   				FILE *fp = fopen(inputFileName, "r");
				if(!fp)
				{
					InformationMessage(FILE_NOT_FOUND, applicationName, inputFileName);
					retVal = FALSE;
				}
				else
				{
					SIMCModuleInfoScanner smallScanner;
					smallScanner.setinput(fp);
					SIMCModuleInfoParser smallParser;


					if(smallParser.GetModuleInfo(&smallScanner))
						InformationMessage(MODULE_NAME_SUCCEEDED, applicationName, smallParser.GetModuleName() );
					else
					{
						retVal = FALSE;
						InformationMessage(MODULE_INFO_FAILED, applicationName, inputFileName);
					}
					fclose(fp);
				}
			}
			break;
			
		case SIMCUI::COMMAND_IMPORTS_INFO:
			{
   				FILE *fp = fopen(inputFileName, "r");
				if(!fp)
				{
					InformationMessage(FILE_NOT_FOUND, applicationName, inputFileName);
					retVal = FALSE;
				}
				else
				{
					SIMCModuleInfoScanner smallScanner;
					smallScanner.setinput(fp);
					SIMCModuleInfoParser smallParser;


					if(smallParser.GetModuleInfo(&smallScanner))
					{
						const SIMCStringList * importList = smallParser.GetImportModuleList();
						POSITION p = importList->GetHeadPosition();
						if(p) 
						{
							cout << "IMPORT MODULES" << endl;
							while(p)
								cout << "\t" << importList->GetNext(p) << endl;
						}
						else
							cout << "NO IMPORT MODULES" << endl;
					}
					else
					{
						retVal = FALSE;
						InformationMessage(MODULE_INFO_FAILED, applicationName, inputFileName);
					}
					fclose(fp);
				}
			}
			break;
	
		case SIMCUI::COMMAND_REBUILD_TABLE:
			InformationMessage(NUMBER_OF_ENTRIES, 
				applicationName, SIMCRegistryController::RebuildMibTable());
			break;
		
		case SIMCUI::COMMAND_LIST_MIB_PATHS:
			InformationMessage(SMI2SMIR_INFO, applicationName, versionString);
			cout << endl;

			SIMCListMibPaths(applicationName);

			break;
		
		case SIMCUI::COMMAND_LOCAL_CHECK:
			{

				//----------- 1. Do Syntax Checking -----------------------
   				FILE *fp = fopen(inputFileName, "r");
				if(!fp)
				{
					InformationMessage(FILE_NOT_FOUND, applicationName, inputFileName);
					retVal = FALSE;
				}
				else
				{
					fclose(fp);
					InformationMessage(COMPILED_FILE, applicationName, versionString, inputFileName);
					theTree.SetSnmpVersion(snmpVersion);
					if(!theTree.CheckSyntax(theUI.GetInputFileName()) )
					{
						retVal = FALSE;
						InformationMessage(SYNTAX_CHECK_FAILED, applicationName, inputFileName );
					}
					else
						InformationMessage(SYNTAX_CHECK_SUCCEEDED, applicationName, inputFileName);


					//----------- 2. Do Symbol resolution ----------------------
					if(retVal)
					{
						if(!theTree.Resolve(TRUE))
						{
							retVal = FALSE;
							InformationMessage(SYMBOL_RESOLUTION_FAILED, applicationName, 
									inputFileName);
						}
					}

					//------------ 3. Do Semantic Checking ----------------------
					if(retVal)
					{
						if(!theTree.CheckSemantics(TRUE))
						{
							retVal = FALSE;
							InformationMessage(SEMANTIC_CHECK_FAILED, applicationName, 
									inputFileName);
						}
						else
							InformationMessage(SEMANTIC_CHECK_SUCCEEDED, applicationName, 
									inputFileName);

					}
				}
			}
			break;

		case SIMCUI::COMMAND_EXTERNAL_CHECK: 
			{
   				if(theUI.AutoRefresh())
					InformationMessage(NUMBER_OF_ENTRIES, 
						applicationName, SIMCRegistryController::RebuildMibTable());

				SIMCFileMapList dependencyList, priorityList;

				const SIMCFileList * subsidiaryFiles = theUI.GetSubsidiaryFiles();
				const SIMCPathList * includePaths = theUI.GetPaths();
	
				// Make sure that the files that *have* to be compiled, exist
				// and are valid. Add the files in the includePaths to the
				// priority list
				// Bail out if the subsidiaries or the main file cant be processed
				if(!PrepareSubsidiariesAndIncludes(applicationName, inputFileName, 
					*subsidiaryFiles, *includePaths, priorityList))
				{
					retVal = FALSE;
					break;
				}

				FILE * fp = fopen(inputFileName, "r");
				if(fp)
				{
 					SIMCModuleInfoScanner smallScanner;
					smallScanner.setinput(fp);
					SIMCModuleInfoParser smallParser;
					CString dependentFile, dependentModule;
					if(smallParser.GetModuleInfo(&smallScanner))
					{
						fclose(fp); // Better close it rightnow, because of the recursion below

						// Add the current file to the dependency list
						dependencyList.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), inputFileName));
					}
				}

				// Do a depth first search for dependencies
				SIMCRegistryController::GetDependentModules(inputFileName, 
					dependencyList, priorityList);
				
				theTree.SetSnmpVersion(snmpVersion);
				POSITION p;
				p = dependencyList.GetHeadPosition();
				SIMCFileMapElement element;
				BOOL first = TRUE;
				while(p)
				{
					element = dependencyList.GetNext(p);
   					fp = fopen(element.fileName, "r");
					if(!fp)
					{
						if(first)
							retVal = FALSE;
						InformationMessage(FILE_NOT_FOUND, applicationName, element.fileName);
					}
					else
					{
						fclose(fp);
					
						InformationMessage(COMPILED_FILE, applicationName, versionString, element.fileName);
						if(!theTree.CheckSyntax(element.fileName) )
						{
							if(first)
								retVal = FALSE;
							InformationMessage(SYNTAX_CHECK_FAILED, applicationName, element.fileName);
						}
						else
							InformationMessage(SYNTAX_CHECK_SUCCEEDED, applicationName, element.fileName);
					}
					if(first)
						first = FALSE;
				}
					   
				if(retVal)
				{
					if(!theTree.Resolve(FALSE))
					{
						retVal = FALSE;
						InformationMessage(SYMBOL_RESOLUTION_FAILED, applicationName, 
								inputFileName);
					}
				}

				if(retVal)
				{
					if(!theTree.CheckSemantics(FALSE))
					{
						retVal = FALSE;
						InformationMessage(SEMANTIC_CHECK_FAILED, applicationName, 
								inputFileName);
					}
					else
						InformationMessage(SEMANTIC_CHECK_SUCCEEDED, applicationName, 
								inputFileName);
				}
			}
 			break;

		case SIMCUI::COMMAND_GENERATE:	//  Fall thru
		case SIMCUI::COMMAND_GENERATE_CLASSES_ONLY:
				generateMof = TRUE;
		case SIMCUI::COMMAND_ADD:		//  Fall thru
		case SIMCUI::COMMAND_SILENT_ADD:	

			{
				if(theUI.AutoRefresh())
					InformationMessage(NUMBER_OF_ENTRIES, 
						applicationName, SIMCRegistryController::RebuildMibTable());

				SIMCFileMapList dependencyList, priorityList;

				const SIMCFileList * subsidiaryFiles = theUI.GetSubsidiaryFiles();
				const SIMCPathList * includePaths = theUI.GetPaths();
	
				// Make sure that the files that *have* to be compiled, exist
				// and are valid. Add the files in the includePaths to the
				// priority list
				// Bail out if the subsidiaries or the main file cant be processed
				if(!PrepareSubsidiariesAndIncludes(applicationName, inputFileName, 
					*subsidiaryFiles, *includePaths, priorityList))
				{
					retVal = FALSE;
					break;
				}

				FILE * fp = fopen(inputFileName, "r");
				if(fp)
				{
 					SIMCModuleInfoScanner smallScanner;
					smallScanner.setinput(fp);
					SIMCModuleInfoParser smallParser;
					CString dependentFile, dependentModule;
					if(smallParser.GetModuleInfo(&smallScanner))
					{
						fclose(fp); // Better close it rightnow, because of the recursion below

						// Add the current file to the dependency list
						dependencyList.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), inputFileName));
					}
				}

				// Do a dpeth first seacrh for dependencies
				SIMCRegistryController::GetDependentModules(inputFileName, 
					dependencyList, priorityList);
				
				theTree.SetSnmpVersion(snmpVersion);

				POSITION p;
				p = dependencyList.GetHeadPosition();
				SIMCFileMapElement element;
				BOOL first = TRUE; // Special treatment for the first module
				while(p)
				{
					element = dependencyList.GetNext(p);
   					fp = fopen(element.fileName, "r");
					if(!fp)
					{
						InformationMessage(FILE_NOT_FOUND, applicationName, element.fileName);
						if(first)
							retVal = FALSE;
					}
					else
					{
						fclose(fp);
					
						InformationMessage(COMPILED_FILE, applicationName, versionString, element.fileName);
						if(!theTree.CheckSyntax(element.fileName) )
						{
							if(first)
								retVal = FALSE;
							InformationMessage(SYNTAX_CHECK_FAILED, applicationName, element.fileName);
						}
						else
							InformationMessage(SYNTAX_CHECK_SUCCEEDED, applicationName, element.fileName);
					}
					if(first)
						first = FALSE;
				}
					   
				if(retVal)
				{
					if(!theTree.Resolve(FALSE))
					{
						retVal = FALSE;
						InformationMessage(SYMBOL_RESOLUTION_FAILED, applicationName, 
								inputFileName);
					}
				}


				if(retVal)
				{
					if(!theTree.CheckSemantics(FALSE))
					{
						retVal = FALSE;
						InformationMessage(SEMANTIC_CHECK_FAILED, applicationName, 
								inputFileName);
					}
					else
						InformationMessage(SEMANTIC_CHECK_SUCCEEDED, applicationName, 
								inputFileName);
				}


				if(retVal && simc_debug) cout << theTree;

				// Load the module, or generate mof  
				if(retVal)
				{
					if(FAILED(GenerateClassDefinitions(t_Configuration,theUI, theTree, generateMof)))
					{
						retVal = FALSE;
						if(generateMof)
							InformationMessage(MOF_GENERATION_FAILED, applicationName, 
								inputFileName);
						else
							InformationMessage(SMIR_LOAD_FAILED, applicationName, 
								inputFileName);
					}
					else
					{
						if(generateMof)
							InformationMessage(MOF_GENERATION_SUCCEEDED, applicationName,
									inputFileName);
						else
							InformationMessage(SMIR_LOAD_SUCCEEDED, applicationName,
									inputFileName);
					}
				}
			}
			break;
		case SIMCUI::COMMAND_ADD_DIRECTORY:

			if(SIMCRegistryController::AddRegistryDirectory(theUI.GetDirectory()))
			{
				InformationMessage(DIRECTORY_ADDITION_SUCCEEDED, applicationName,
									theUI.GetDirectory());
				InformationMessage(NUMBER_OF_ENTRIES, 
					applicationName, SIMCRegistryController::RebuildMibTable());
			}
			else
			{
				InformationMessage(DIRECTORY_ADDITION_FAILED, applicationName,
									theUI.GetDirectory());
				retVal = FALSE;
			}
			break;

		case SIMCUI::COMMAND_DELETE_DIRECTORY_ENTRY:
			if(SIMCRegistryController::DeleteRegistryDirectory(theUI.GetDirectory()))
			{
				InformationMessage(DIRECTORY_DELETION_SUCCEEDED, applicationName,
									theUI.GetDirectory());
				InformationMessage(NUMBER_OF_ENTRIES, 
					applicationName, SIMCRegistryController::RebuildMibTable());
			}
			else
			{
				InformationMessage(DIRECTORY_DELETION_FAILED, applicationName,
									theUI.GetDirectory());
				retVal = FALSE;
			}
			 break;

		case SIMCUI::COMMAND_NONE:
		default: 	
			assert(0);
	}

	if ( t_Configuration )
	{
		t_Configuration->Release () ;
		CoUninitialize () ;
	}

	if( theUI.GetCommandArgument() != SIMCUI::COMMAND_SILENT_ADD)
		FilterErrors(&errorContainer, theUI);
	
	if (NULL != infoMessagesDll)
		FreeLibrary(infoMessagesDll);

	if (NULL != SIMCParseTree::semanticErrorsDll)
		FreeLibrary(SIMCParseTree::semanticErrorsDll);

	if (NULL != SIMCParser::semanticErrorsDll)
		FreeLibrary(SIMCParser::semanticErrorsDll);

	if (NULL != SIMCParser::syntaxErrorsDll)
		FreeLibrary(SIMCParser::syntaxErrorsDll);

	return (retVal)? 0 : 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\errorcontainer.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_ERROR_MESSAGE_CONTAINER_H
#define SIMC_ERROR_MESSAGE_CONTAINER_H

/*
 * This is basically a linked list of SIMCErrorMessage
 * objects
 */
class SIMCErrorContainer
{
	// A linked list of objects of class SIMCErrorMessage
	// And a pointer to the current position in the list
	CList<SIMCErrorMessage, const SIMCErrorMessage&> _listOfMessages;
	POSITION _currentMessage;

	public:
		// Construct an empty error container
		SIMCErrorContainer();

		// Insert a message at the head of the container
		BOOL InsertMessage(const SIMCErrorMessage& newMessage);

		// Empty the container
		void RemoveAll()
		{
			_listOfMessages.RemoveAll();
		}

		//  Get a count of the number of messages in the container
		inline int NumberOfMessages() const
		{
			return _listOfMessages.GetCount();
		}

		// Functions to iterate the container
		void MoveToFirstMessage();
		BOOL GetNextMessage(SIMCErrorMessage& nextMessage);

		// Debugging functions
		friend ostream& operator << ( ostream& outStream, 
			SIMCErrorContainer&);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\errormessage.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_ERROR_MESSAGE_H
#define SIC_ERROR_MESSAGE_H



// Models an error message generated by the various components of
// the SNMP Compiler
class SIMCErrorMessage
{
		// The text of the message
		char *_message;

		char *_inputStreamName; // Need not be a file name. Could be anything that the 
								// creator of this error message
								// thinks appropriate. Like "Standard Input".
		// The severity level, both a number as well as a
		// string representation are used. Example
		// 1 - "Fatal"
		// 2 - "Warning"
		char *_severityString;
		int _severityLevel;


		// Column and line numbers
		long _columnNumber;
		long _lineNumber;
		// An indication whether column and line numbers are valid in this
		// message. Example, for global messages, this may be true
		BOOL _lineAndColumnValid;

		// A unique ID for the message. May be used in documenting
		// errors.
		int _errorId;

	public:
		// Construct an empty error message
		SIMCErrorMessage()
		{
			_message = _inputStreamName = _severityString = NULL;
			_lineNumber = _columnNumber = _severityLevel = _errorId = 0;
			_lineAndColumnValid = TRUE;
		}

		// Construct a loaded error message
		SIMCErrorMessage(const char * const inputStreamName, 
				const char * const message,
				const char * const severityString,
				int errorId,
				int severityLevel,
				long lineNumber = 0, long columnNumber = 0 );
				
		// And a copy constructor)
		SIMCErrorMessage (const SIMCErrorMessage& rhs	);

		// Assigment of error messages
		const SIMCErrorMessage& operator = (const SIMCErrorMessage&);

		// Checking equality of errors
		BOOL operator == (const SIMCErrorMessage& rhs) const
		{
			return  _lineNumber == rhs._lineNumber &&
					_columnNumber == rhs._columnNumber &&
					_severityLevel == rhs._severityLevel &&
					_errorId == rhs._errorId &&
					strcmp(_severityString, rhs._severityString) == 0 &&
					strcmp(_message, rhs._message) == 0 &&
					strcmp(_inputStreamName, rhs._inputStreamName) == 0 ;
		}

		virtual ~SIMCErrorMessage();
		
		// Various get and set functions
		const char * GetMessage() const
		{
			return _message;
		}
		const char *GetInputStreamName() const
		{
			return _inputStreamName;
		}
		const char *GetSeverityString() const
		{
			return _severityString;
		}
		long GetLineNumber() const
		{
			return _lineNumber;
		}
		long GetColumnNumber() const
		{
			return _columnNumber;
		}

		int GetSeverityLevel() const
		{
			return _severityLevel;
		}

		int GetErrorId() const
		{
			return _errorId;
		}

		BOOL SetMessage( const char * const message);
		BOOL SetInputStreamName ( const char * const inputStreamName);
		BOOL SetSeverityString ( const char * const severityString);
		void SetLineNumber( const long lineNumber)
		{
			_lineNumber = lineNumber;
		}

		void SetColumnNumber( const long columnNumber)
		{
			_columnNumber = columnNumber;
		}

		void SetSeverityLevel( const int severityLevel)
		{
			_severityLevel = severityLevel;
		}

		void SetErrorId( const int errorId)
		{
			_errorId = errorId;
		}
	 
		void SetLineAndColumnValidity(BOOL value)
		{
			_lineAndColumnValid =  value;
		}

		// And a default output of the error message
		friend ostream& operator << 
			( ostream& outStream, const SIMCErrorMessage& errorMessage) ;
};

#endif // SIMC_ERROR_MESSAGE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\abstractparsetree.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_ABSTRACT_PARSE_TREE_H
#define SIMC_ABSTRACT_PARSE_TREE_H

/*
 * SIMCAbstractParseTree - This class is an abstract class which has
 * functions for checking the syntax and semantics of MIBs. However, only
 * the syntax-checking functions have an implementation in this class.
 * The semantic checking functions are left as pure virtual, and is up
 * to the derived class, to define, since different applications have
 * different meanings for the Semantic validity of a MIB. All syntax errors
 * are put in an SIMCErrorContainer object, which may be retrieved for
 * processing/reporting.
 */
class SIMCAbstractParseTree
{
	protected:	
		// The place to put error messages
		SIMCErrorContainer *_errorContainer;
	
		// A count of the various kinds of errors, for each call of Parse()
		// Note that there are 3 kinds of messages (fatal, warning, information)
		long _fatalCount, _warningCount, _informationCount;

		// The parse tree
		SIMCModuleList *_listOfModules;


		// This is the flag that decides the way in which the next module
		// is syntactically checked or semantically checked.
		// That is, CheckSyntax() this flag to make decisions. A user 
		// implementing the CheckSemantics() function in a derived class
		// might also find this helpful.
		// 1 indicates conformance to SnmpV1 rules,
		// 2 indicates conformance to SnmpV2 rules,
		// 0 indicates conformance to a union of of V1 and V2 rules, as
		// long as they dont contradict each other.
		int _snmpVersion;

		// Internal representation of the state of a parse tree.
		// Used to decide what methods are allowed to be called
		enum ParseTreeState
		{
			EMPTY,
			UNRESOLVED,
			UNCHECKED,
			FINAL
		};
		ParseTreeState _parseTreeState;

		// All the things to be wrapped up at the end of CheckSyntax()
		BOOL WrapUpSyntaxCheck( const SIMCParser& parser);


	
		// Dont allow instantiation. Used only by derived classes
		// Accept an error container to put in the error messages
		SIMCAbstractParseTree(SIMCErrorContainer *errorContainer)
			:	_errorContainer(errorContainer), _parseTreeState (EMPTY),
				_listOfModules(new SIMCModuleList),
				_fatalCount(0), _warningCount(0), _informationCount(0),
				_snmpVersion(0)
		{}


		 ~SIMCAbstractParseTree();
	public:
		
		// Get the current version setting of the parse tree.
		// This may be changed in between calls to CheckSyntax(),
		// using SetSnmpVersion()
		int GetSnmpVersion() const
		{
			return _snmpVersion;
		}

		// Set the SNMP version to which the parse tree checks its
		// conformance
		BOOL SetSnmpVersion( int x )
		{
			switch(x)
			{
				case 0:		// '0' means union of v1 and v2 SMIs
				case 1:
				case 2:
					_snmpVersion = x;
					return TRUE;
				default:
					_snmpVersion = 0;
					return FALSE;
			}
		}

		// Various ways of specifying input to the parse tree
		// Caution - Only the second one (specifying the name of
		// a file) has been tested. All error messages are written on
		// to the SIMCErrorContainer object, which can be retrieved using
		// GetErrorContainer() function. The user may process the error container
		// in between calls to CheckSyntax(), to after he finishes all his
		// CheckSyntax() calls.
		virtual BOOL CheckSyntax( ifstream& inputStream);
		virtual BOOL CheckSyntax(const CString& inputStreamName);
		virtual BOOL CheckSyntax(const int fileDescriptor);
		virtual BOOL CheckSyntax(FILE *fileStream);

		// Allow obfuscated code to be written using this class
		friend BOOL operator >> (ifstream& inputStream,
			SIMCAbstractParseTree& parseTree)
		{
			return parseTree.CheckSyntax(inputStream);
		}

		// These are the pure virtual functions in this class.
		// These are together used to check the semantics of the
		// MIB module(s).
		// Resolve() is called to set all the external references (IMPORTS)
		// in all the input modules, using their definitions in other input
		// modules, and also to set all forward references to a symbol. 
		// An "input module" is one that has been "entered" into
		// the  parse tree, using a successful call to CheckSyntax().
		// Once resolution has been done successfully, CheckSemantics() should
		// be called to check if the modules conform to the rules the user
		// wishes to impose. The user gets the modules (SIMCModule objects)
		// in the parse tree using GetModule(), GetModuleOfFile() or GetListOfModules(),
		// And goes through each symbol (SIMCSymbol object) in the symbol 
		// table of each module, He uses RTTI to determine the class of the 
		// symbol (ie., which derived class of SIMCSymbol, the object is really
		// an instance of), and checks to see if that object is valid.
		// In both these cases, the boolean argument indicates whether the
		// the resolution/checking should be done without the definitions
		// of IMPORTED symbols, or with them. A true value implies a local
		// check, without resolution of IMPORT symbols
		virtual BOOL Resolve(BOOL local) = 0;
		virtual BOOL CheckSemantics(BOOL local) = 0;

		// Returns the error container
		const SIMCErrorContainer* GetErrorContainer() const
		{
			return _errorContainer;
		}

		// This should not be typically called by a user
		ParseTreeState GetParseTreeState() const
		{
			return _parseTreeState;
		}

		// # of all the messages generated till now
		long GetCurrentDiagnosticCount() const
		{
			return _errorContainer->NumberOfMessages();
		}

		// # of each king of message, generated till now.
		long GetFatalCount() const
		{
			return _fatalCount;
		}
		long GetWarningCount() const
		{
			return _warningCount;
		}
		long GetInformationCount() const
		{
			return _informationCount;
		}


		// Retreiving the parse tree information for a module ,
		// by specifying the module name
		SIMCModule * GetModule(const char *const moduleName)
			const;
		
		// Retreiving the parse tree information for a module ,
		// by specifying the input file name, that was used
		SIMCModule * GetModuleOfFile(const char *const fileName)
			const;

		// Get the parse tree information for all the modules
		const SIMCModuleList *GetListOfModules() const
		{
			return _listOfModules;
		}

		// For debugging
		void WriteTree(ostream& outStream) const;
		friend ostream& operator<< (ostream& out, const SIMCAbstractParseTree& r)
		{
			r.WriteTree(out);
			return out;
		}

};

#endif // SIMC_ABSTRACT_PARSE_TREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\infolex.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef ModuleInfo_state_t
#define ModuleInfo_state_t unsigned char
#endif
#define YYNEWLINE 10

// MKS LEX prototype scanner header
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can define YY_PRESERVE to get System V UNIX lex compatibility,
//	if you need to change ModuleInfotext[] in your user actions
// This is quite a bit slower, though, so the default is without

#include <stdio.h>		// uses printf(), et cetera
#include <stdarg.h>		// uses va_list
#include <stdlib.h>		// uses exit()
#include <string.h>		// uses memmove()

#ifdef LEX_WINDOWS

// define, if not already defined
// the flag YYEXIT, which will allow
// graceful exits from ModuleInfolex()
// without resorting to calling exit();

#ifndef YYEXIT
#define YYEXIT	1
#endif // YYEXIT

// include the windows specific prototypes, macros, etc

#include <windows.h>

// the following is the handle to the current
// instance of a windows program. The user
// program calling ModuleInfolex must supply this!

extern HANDLE hInst;	

#endif /* LEX_WINDOWS */

class ModuleInfo_scan {
protected:

#ifdef LEX_WINDOWS

	// protected member function for actual scanning 

	int win_ModuleInfolex();

#endif /* LEX_WINDOWS */

	ModuleInfo_state_t * state;		// state buffer
	int	size;			// length of state buffer
	int	mustfree;		// set if space is allocated
	int	ModuleInfo_end;			// end of pushback
	int	ModuleInfo_start;		// start state
	int	ModuleInfo_lastc;		// previous char
#ifdef YYEXIT
	int ModuleInfoLexFatal;		// Lex Fatal Error Flag
#endif // YYEXIT
#ifndef YY_PRESERVE	// efficient default push-back scheme
	char save;		// saved ModuleInfotext[ModuleInfoleng]
#else			// slower push-back for ModuleInfotext mungers
	char *save;		// saved ModuleInfotext[]
	char *push;
#endif

public:
	char   *ModuleInfotext;		// ModuleInfotext text buffer
	FILE   *ModuleInfoin;			// input stream
	FILE   *ModuleInfoout;			// output stream
	int	ModuleInfolineno;		// line number
	int	ModuleInfoleng;			// ModuleInfotext token length

	ModuleInfo_scan(int = 100);	// constructor for this scanner
			// default token & pushback size is 100 bytes
	ModuleInfo_scan(int, char*, char*, ModuleInfo_state_t*);
				// constructor when tables are given

	~ModuleInfo_scan();		// destructor

	int	ModuleInfolex();		// begin a scan

	virtual int	ModuleInfogetc() {	// scanner source of input characters
		return getc(ModuleInfoin);
	}

	virtual int	ModuleInfowrap() { return 1; }	// EOF processing

	virtual void	ModuleInfoerror(char *,...);	// print error message

	virtual void	output(int c) { putc(c, ModuleInfoout); }

#ifdef YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and set error flag
		ModuleInfoerror(msg); ModuleInfoLexFatal = 1;
	}
#else // YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and stop
		ModuleInfoerror(msg); exit(1);
	}
#endif // YYEXIT
	virtual void	ECHO() {		// print matched input
		fputs((const char *) ModuleInfotext, ModuleInfoout);
	}
	int	input();		// user-callable get-input
	int	unput(int c);		// user-callable unput character
	void	ModuleInfo_reset();		// reset scanner
	void	setinput(FILE * in) {		// switch input streams
		ModuleInfoin = in;
	}
	void	setoutput(FILE * out) {	// switch output
		ModuleInfoout = out;
	}
	void	NLSTATE() { ModuleInfo_lastc = YYNEWLINE; }
	void	YY_INIT() {
		ModuleInfo_start = 0;
		ModuleInfoleng = ModuleInfo_end = 0;
		ModuleInfo_lastc = YYNEWLINE;
	}
	void	YY_USER() {		// set up ModuleInfotext for user
#ifndef YY_PRESERVE
		save = ModuleInfotext[ModuleInfoleng];
#else
		size_t n = ModuleInfo_end - ModuleInfoleng;
		push = save+size - n;
		if (n > 0)
			memmove(push, ModuleInfotext+ModuleInfoleng, n);
#endif
		ModuleInfotext[ModuleInfoleng] = 0;
	}
	void YY_SCANNER() {		// set up ModuleInfotext for scanner
#ifndef YY_PRESERVE
		ModuleInfotext[ModuleInfoleng] = save;
#else
		size_t n = save+size - push;
		if (n > 0)
			memmove(ModuleInfotext+ModuleInfoleng, push, n);
		ModuleInfo_end = ModuleInfoleng + n;
#endif
	}
	void	ModuleInfoless(int n) {		// trim input to 'n' bytes
		if (n >= 0 && n <= ModuleInfo_end) {
			YY_SCANNER();
			ModuleInfoleng = n;
			YY_USER();
		}
	}
	void	ModuleInfocomment(char *const mat); // skip comment input
	int	ModuleInfomapch(int delim, int escape);	// map C escapes
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\lex_yy.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef yy_state_t
#define yy_state_t unsigned char
#endif
#define YYNEWLINE 10

// MKS LEX prototype scanner header
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can define YY_PRESERVE to get System V UNIX lex compatibility,
//	if you need to change yytext[] in your user actions
// This is quite a bit slower, though, so the default is without

#include <stdio.h>		// uses printf(), et cetera
#include <stdarg.h>		// uses va_list
#include <stdlib.h>		// uses exit()
#include <string.h>		// uses memmove()

#ifdef LEX_WINDOWS

// define, if not already defined
// the flag YYEXIT, which will allow
// graceful exits from yylex()
// without resorting to calling exit();

#ifndef YYEXIT
#define YYEXIT	1
#endif // YYEXIT

// include the windows specific prototypes, macros, etc

#include <windows.h>

// the following is the handle to the current
// instance of a windows program. The user
// program calling yylex must supply this!

extern HANDLE hInst;	

#endif /* LEX_WINDOWS */

class yy_scan {
protected:

#ifdef LEX_WINDOWS

	// protected member function for actual scanning 

	int win_yylex();

#endif /* LEX_WINDOWS */

	yy_state_t * state;		// state buffer
	int	size;			// length of state buffer
	int	mustfree;		// set if space is allocated
	int	yy_end;			// end of pushback
	int	yy_start;		// start state
	int	yy_lastc;		// previous char
#ifdef YYEXIT
	int yyLexFatal;		// Lex Fatal Error Flag
#endif // YYEXIT
#ifndef YY_PRESERVE	// efficient default push-back scheme
	char save;		// saved yytext[yyleng]
#else			// slower push-back for yytext mungers
	char *save;		// saved yytext[]
	char *push;
#endif

public:
	char   *yytext;		// yytext text buffer
	FILE   *yyin;			// input stream
	FILE   *yyout;			// output stream
	int	yylineno;		// line number
	int	yyleng;			// yytext token length

	yy_scan(int = 100);	// constructor for this scanner
			// default token & pushback size is 100 bytes
	yy_scan(int, char*, char*, yy_state_t*);
				// constructor when tables are given

	~yy_scan();		// destructor

	int	yylex();		// begin a scan

	virtual int	yygetc() {	// scanner source of input characters
		return getc(yyin);
	}

	virtual int	yywrap() { return 1; }	// EOF processing

	virtual void	yyerror(char *,...);	// print error message

	virtual void	output(int c) { putc(c, yyout); }

#ifdef YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and set error flag
		yyerror(msg); yyLexFatal = 1;
	}
#else // YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and stop
		yyerror(msg); exit(1);
	}
#endif // YYEXIT
	virtual void	ECHO() {		// print matched input
		fputs((const char *) yytext, yyout);
	}
	int	input();		// user-callable get-input
	int	unput(int c);		// user-callable unput character
	void	yy_reset();		// reset scanner
	void	setinput(FILE * in) {		// switch input streams
		yyin = in;
	}
	void	setoutput(FILE * out) {	// switch output
		yyout = out;
	}
	void	NLSTATE() { yy_lastc = YYNEWLINE; }
	void	YY_INIT() {
		yy_start = 0;
		yyleng = yy_end = 0;
		yy_lastc = YYNEWLINE;
	}
	void	YY_USER() {		// set up yytext for user
#ifndef YY_PRESERVE
		save = yytext[yyleng];
#else
		size_t n = yy_end - yyleng;
		push = save+size - n;
		if (n > 0)
			memmove(push, yytext+yyleng, n);
#endif
		yytext[yyleng] = 0;
	}
	void YY_SCANNER() {		// set up yytext for scanner
#ifndef YY_PRESERVE
		yytext[yyleng] = save;
#else
		size_t n = save+size - push;
		if (n > 0)
			memmove(yytext+yyleng, push, n);
		yy_end = yyleng + n;
#endif
	}
	void	yyless(int n) {		// trim input to 'n' bytes
		if (n >= 0 && n <= yy_end) {
			YY_SCANNER();
			yyleng = n;
			YY_USER();
		}
	}
	void	yycomment(char *const mat); // skip comment input
	int	yymapch(int delim, int escape);	// map C escapes
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\moduleinfo.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_MODULE_INFO
#define SIMC_MODULE_INFO

/*
 * This file contains the SIMCModuleInfoScanner and SIMCModuleInfoParser 
 * classes, which are light-weight scanners and parsers of a module, 
 * as opposed to the heavy-weights SIMCScanner and SIMCParser.
 * The difference is that the latter are compler scanners and parsers
 * of SNMP modules, while the former just parse a module enough to
 * get the module name, and the information in the IMPORT section
 */

typedef CList<CString, CString&> SIMCStringList;

// The light-weight scanner. This is derived from the ModuleInfo_scan 
// that is generated by the MKS LEX utility, from the information in 
// the file infoLex.l 
class SIMCModuleInfoScanner : public ModuleInfo_scan
{
	public:
		virtual void ModuleInfoerror(char *,...)	
		{}
		virtual void output(int x)
		{}
};

// The light-weight parser. This is derived from the ModuleInfo_parse 
// that is generated by the MKS YACC utility, from the information in 
// the file infoYacc.y. This parser uses the above scanner 

class SIMCModuleInfoParser  : public ModuleInfo_parse
{
		CString moduleName;
		SIMCStringList 	importModules;

	public:

		// Parse the module. Once this function is called, the other
		// functions make sense.
		BOOL GetModuleInfo(SIMCModuleInfoScanner *infoScanner);

		const SIMCStringList * GetImportModuleList() const
		{
			return &importModules;
		}
		void AddImportModule(CString name)
		{
			importModules.AddTail(name);
		}
		CString GetModuleName() const
		{
			return moduleName;
		}
		void SetModuleName(const CString& name) 
		{
			moduleName = name;
		}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\module.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef SIMC_MODULE_H
#define SIMC_MODULE_H

/* This file contains the SIMCModule class, which basically
 * represents the parse tree for a single module.
 */


// Return value for many of the symbol-table methods. 
#define NOT_FOUND   0
#define AMBIGUOUS   1
#define UNAMBIGUOUS 2


class SIMCSymbol;
class SIMCType;
class SIMCSubType;
class SIMCEnumOrBitsType;
class SIMCValue;
class SIMCOidValue;
class SIMCOctetStringValue;
class SIMCDefinedTypeReference;
class SIMCDefinedValueReference;
class SIMCBuiltInTypeReference;
class SIMCBuiltInValueReference;
class SIMCObjectTypeType;
class SIMCObjectTypeV1;
class SIMCObjectTypeV2;
class SIMCObjectIdentityType;
class SIMCObjectGroup;
class SIMCOidTree;
class SIMCParseTree;

// Some typedefs
#ifndef SIMC_GROUP_LIST
#define SIMC_GROUP_LIST
typedef CList<SIMCObjectGroup *, SIMCObjectGroup*> SIMCGroupList;
ostream& operator << (ostream& outStream, const SIMCGroupList& obj);
#endif
typedef CList<SIMCModule *, SIMCModule *> SIMCModuleList;
typedef CList<CString, const CString&> SIMCModuleNameList;
typedef CMap <CString, LPCSTR, SIMCSymbol **, SIMCSymbol**> 
						SIMCSymbolTable;	


/* Each element in the list of revision clauses
 * in the MODULE-IDENTITY macro
 */
class SIMCRevisionElement
{
		char *_revision, *_description;

	public:
		SIMCRevisionElement( const char * revision, const char * description)
		{
			if(revision)
			   _revision = NewString(revision);
			else 
				_revision = NULL;
			if(description)
			   _description = NewString(description);
			else 
				_description = NULL;
		}

		~SIMCRevisionElement()
		{
			if(_revision)
				delete _revision;
			if(_description)
				delete _description;
		}

		const char * GetRevision() const
		{
			return _revision;
		}
		const char * GetDescription() const
		{
			return _description;
		}
};

// A list of revision clauses
typedef CList<SIMCRevisionElement *, SIMCRevisionElement *> SIMCRevisionList;

/* 
 * This class represents the parse tree information that results from the
 * parsing of a single MIB module. It basically contains.
 *
 *	1. A symbol table, for all the symbols in the module
 *	2. The values of various MODULE-IDENTITY clauses.  These are
 *		fabricated, if the MODULE-IDENTITY clause is absent in the module
 *	3. A list of object groups that are fabricated for this module, as per
 *		the rules in the "compiler requirements specification"
 */
class SIMCModule : public SIMCSymbol
{
		// The version of this module
		// 1 - SNMPv2 SMI
		// 2 - SNMPv2 SMI
		// 0 - Union of V1 and V2 SMIs
		int _snmpVersion;

		// The items from the MODULE-IDENTITY macro
		char * _lastUpdated;
		char * _organization;
		char * _contactInfo;
		char * _moduleIdentityName;
		char * _description;
		SIMCRevisionList _revisionList;
		SIMCCleanOidValue * _moduleIdentityValue;
		
		// This is null if it is the main input module, otherwise it points 
		// to the module that imported this module
		SIMCModule * _parentModule;

		// The names of the modules in the IMPORTS clause
		SIMCModuleNameList _namesOfImportModules;
		// The actual import modules
		SIMCModuleList *_listOfImportModules;

		// The Symbol table
		SIMCSymbolTable	*_symbolTable;

		// A value for the hash table (CMap) object that optimizes
		// its working
		static const int SYMBOLS_PER_MODULE;

		// The fabricated list OBJECT-GROUPS
		SIMCGroupList *_listOfObjectGroups;

		// All the NOTIFICATION-TYPEs in the module
		SIMCNotificationList *_listOfNotificationTypes;

		// Name of the file from which this was constructed
		char *_inputFileName;


	public:

		// Used in RTTIing a SIMCSymbol pointer
		enum SymbolClass
		{ 
			SYMBOL_INVALID,
			SYMBOL_UNKNOWN,
			SYMBOL_IMPORT,
			SYMBOL_MODULE,
			SYMBOL_BUILTIN_TYPE_REF,
			SYMBOL_DEFINED_TYPE_REF,
			SYMBOL_TEXTUAL_CONVENTION,
			SYMBOL_BUILTIN_VALUE_REF,
			SYMBOL_DEFINED_VALUE_REF
		};

		// Used in RTTIing a SIMCType pointer
		enum TypeClass 
		{
			TYPE_INVALID,
			TYPE_PRIMITIVE,
			TYPE_RANGE,
			TYPE_SIZE,
			TYPE_ENUM_OR_BITS,
			TYPE_SEQUENCE_OF,
			TYPE_SEQUENCE,
			TYPE_TRAP_TYPE,
			TYPE_NOTIFICATION_TYPE,
			TYPE_OBJECT_TYPE_V1,
			TYPE_OBJECT_TYPE_V2,
			TYPE_OBJECT_IDENTITY
		};

		// Used in RTTIing a SIMCValue pointer
		enum ValueClass 
		{
			VALUE_INVALID,
			VALUE_INTEGER,
			VALUE_OID,
			VALUE_OCTET_STRING,
			VALUE_BOOLEAN,
			VALUE_BITS,
			VALUE_NULL
		};

		enum PrimitiveType
		{
			PRIMITIVE_INVALID,
			PRIMITIVE_INTEGER,
			PRIMITIVE_OID,
			PRIMITIVE_OCTET_STRING,
			PRIMITIVE_BOOLEAN,
			PRIMITIVE_BITS,
			PRIMITIVE_NULL,
			PRIMITIVE_NETWORK_ADDRESS,
			PRIMITIVE_IP_ADDRESS,
			PRIMITIVE_COUNTER,
			PRIMITIVE_GAUGE,
			PRIMITIVE_TIME_TICKS,
			PRIMITIVE_OPAQUE,
			PRIMITIVE_DISPLAY_STRING,
			PRIMITIVE_PHYS_ADDRESS,
			PRIMITIVE_MAC_ADDRESS,

			PRIMITIVE_INTEGER_32,
			PRIMITIVE_COUNTER_32,
			PRIMITIVE_GAUGE_32,
			PRIMITIVE_COUNTER_64,
			PRIMITIVE_UNSIGNED_32,
			PRIMITIVE_DATE_AND_TIME,
			PRIMITIVE_SNMP_UDP_ADDRESS,
			PRIMITIVE_SNMP_OSI_ADDRESS,
			PRIMITIVE_SNMP_IPX_ADDRESS
		};


		SIMCModule(const char *const moduleName = NULL,
			const char * const inputFileName = NULL,
			SIMCSymbolTable *symbolTable = NULL,			
			SIMCModuleList *listOfImportModules = NULL,
			SIMCModule *parentModule = NULL,
			int snmpVersion = 0,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0);

		virtual ~SIMCModule();

		// Manipulate the SNMP version of the module
		int GetSnmpVersion() const
		{
			return _snmpVersion;
		}
		BOOL SetSnmpVersion( int x )
		{
			switch(x)
			{
				case 0:		// '0' means union of v1 and v2 SMIs
				case 1:
				case 2:
					_snmpVersion = x;
					return TRUE;
				default:
					_snmpVersion = 0;
					return FALSE;
			}
		}

		// Manipulate the name of this module
		const char * GetModuleName() const
		{	
			return GetSymbolName();
		}
		void SetModuleName(const char * const s) 
		{
			SetSymbolName(s);
		}

		// Manipulate the input file name of this module
		const char * GetInputFileName() const
		{	
			return _inputFileName;
		}
		void SetInputFileName(const char * const s) 
		{
			if(_inputFileName)
				delete []_inputFileName;
			_inputFileName = NewString(s);
		}

		// Manipulate the MODULE-IDENTITY clauses
		const char * GetLastUpdated() const
		{	
			return _lastUpdated;
		}
		void SetLastUpdated(const char * const s) 
		{
			if(_lastUpdated)
				delete [] _lastUpdated;
			_lastUpdated = NewString(s);
		}

		const char * GetOrganization() const
		{	
			return _organization;
		}
		void SetOrganization(const char * const s) 
		{
			if(_organization)
				delete [] _organization;
			_organization = NewString(s);
		}

		const char * GetContactInfo() const
		{	
			return _contactInfo;
		}
		void SetContactInfo(const char * const s) 
		{
			if(_contactInfo)
				delete [] _contactInfo;
			_contactInfo = NewString(s);
		}

		const char * GetDescription() const
		{	
			return _description;
		}
		void SetDescription(const char * const s) 
		{
			if(_description)
				delete [] _description;
			_description = NewString(s);
		}

		void AddRevisionClause(SIMCRevisionElement *revisionElement)
		{
			_revisionList.AddTail(revisionElement);
		}

		const SIMCRevisionList * GetRevisionList() const
		{
			return &_revisionList;
		}

		const char * GetModuleIdentityName() const
		{	
			return _moduleIdentityName;
		}
		void SetModuleIdentityName(const char * const s) 
		{
			if(_moduleIdentityName)
				delete [] _moduleIdentityName;
			_moduleIdentityName = NewString(s);
		}

		void SetModuleIdentityValue(SIMCCleanOidValue * value)
		{
			if(_moduleIdentityValue)
				delete _moduleIdentityValue;
			_moduleIdentityValue = value;
		}
		BOOL GetModuleIdentityValue( SIMCCleanOidValue& retVal) const
		{
			if( _moduleIdentityValue )
			{
				CleanOidValueCopy(retVal, *_moduleIdentityValue);
				return TRUE;
			}
			else
				return FALSE;
		}


		// Get the whole symbol table itself. Very rarely used
		SIMCSymbolTable* GetSymbolTable()  const
		{
			return _symbolTable;
		}

		// Get the list of import modules
		SIMCModuleList *GetListOfImportModules() const
		{
			return _listOfImportModules;
		}
		// Get the names of the import modules
		const SIMCModuleNameList* GetImportModuleNameList() const
		{
			return &_namesOfImportModules;
		}

		// If this module is created just because it appears in the
		// IMPORT clause of a parent module, then a pointer to the parent
		// module is returned. This has to be set by the user, of course
		const SIMCModule* GetParentModule() const
		{
			return _parentModule;
		}
		void SetParentModule( SIMCModule *parentModule);

		// Manipulate the list of import modules of this module
		void AddImportModule( SIMCModule * newModule);
		BOOL RemoveImportModule(SIMCModule *module);
		// This just adds to _namesOfImportModules
		void AddImportModuleName(const SIMCModule *newModule)
		{
			_namesOfImportModules.AddTail(newModule->GetModuleName());
		}
		SIMCModule *GetImportModule(const char * const name) const;
		
		// Manipulate the list of object groups of this module
		void AddObjectGroup(SIMCObjectGroup *group);
		// Gets the object group whose name is the speciified name
		SIMCObjectGroup *GetObjectGroup(const char * const name) const;
		SIMCGroupList *GetObjectGroupList() const
		{
			return _listOfObjectGroups;
		}
		// Returns the object group in which this symbol is present
		SIMCObjectGroup *GetObjectGroup(SIMCSymbol *symbol) const;

		// Manipulate the list of NOTIFICATION-TYPES in this module
		SIMCNotificationList *GetNotificationTypeList() const
		{
			return _listOfNotificationTypes;
		}


		// A debugging function
		virtual void WriteSymbol(ostream& outStream) const;

		//-------------SYMBOL TABLE RELATED METHODS ----------------------
		SIMCSymbol ** GetSymbol(  const char * const symbolName) const;
		int GetImportedSymbol( const char * const symbolName, SIMCSymbol ** &retVal1,
			 SIMCSymbol ** &retVal2) const;
		BOOL AddSymbol(SIMCSymbol * );
		BOOL RemoveSymbol(const char * const symbolName);
		BOOL RemoveSymbol(SIMCSymbol **);
		BOOL ReplaceSymbol(const char *const symbolName, SIMCSymbol *newSymbol);


		//------------ RTTI methods(static)------------------------------------
		static SymbolClass GetSymbolClass(SIMCSymbol **spp);
		static TypeClass GetTypeClass(SIMCType *t);
		static ValueClass GetValueClass(SIMCValue *v);
		
		//-------------- Methods used in semantic checking and resolution -----
		// These set the state of each symbol to one ofenum SIMCResolutionStatus
		// RESOLVE_UNSET,		// Haven't resolved it yet
		// RESOLVE_UNDEFINED,	// Could not resolve it
		// RESOLVE_IMPORT,		// Resolved to IMPORTS
		// RESOLVE_CORRECT		// Resolved properly
		// as defined in enum SIMCResolutionStatus, of SIMCSymbol
		BOOL SetResolutionStatus();
		static SIMCResolutionStatus SetResolutionStatus(SIMCSymbol **symbol);
		static SIMCResolutionStatus SetResolutionStatus(SIMCDefinedTypeReference * orig);
		static SIMCResolutionStatus SetResolutionStatus(SIMCDefinedValueReference *orig);

	private:
		// These are the recursive routines called by the above 2 methods
		static SIMCResolutionStatus SetResolutionStatusRec(SIMCDefinedTypeReference * orig,
											SIMCDefinedTypeReferenceList& checkedList);
		static SIMCResolutionStatus SetResolutionStatusRec(SIMCDefinedValueReference *orig,
											SIMCDefinedValueReferenceList& checkedList);
	
	public:
		// This sets the type that is the root of a subtype (range and size
		// constructs) or an ENUM or BITS type, and also the root value of a symbol that results from
		// successive assignment statements
		BOOL SetRootAll();
		static SIMCResolutionStatus SetRootSymbol(SIMCSymbol **symbol);
		static SIMCResolutionStatus SetRootSubType(SIMCSubType *s);

	private:
		static SIMCResolutionStatus SetRootSubTypeRec(SIMCSubType *s,
											SIMCSubTypeList& checkedList);
		static SIMCResolutionStatus SetRootEnumOrBitsRec(SIMCEnumOrBitsType *t,
											SIMCSubTypeList& checkedList);
	public:
		// This is a hack to take care of DEFVAL clauses
		BOOL SetDefVal();
		SIMCResolutionStatus SetDefVal(SIMCObjectTypeType *objType);

		// Returs the PrimitiveType of a symbol
		static PrimitiveType GetPrimitiveType(const SIMCTypeReference *typeRef);
		static PrimitiveType GetPrimitiveType(const char * const name);

		// Value checking functions
		static SIMCResolutionStatus IsIntegerValue(SIMCSymbol **s, int& retValue);
		static SIMCResolutionStatus IsObjectIdentifierValue(SIMCSymbol **s,
												SIMCOidValue* &retValue);
		static SIMCResolutionStatus IsNullValue(SIMCSymbol **s);
		static SIMCResolutionStatus IsOctetStringValue(SIMCSymbol **s, 
										SIMCOctetStringValue* &retValue);
		static SIMCResolutionStatus IsBitsValue(SIMCSymbol **s,
										SIMCBitsValue * &retValue);
		// Type checking functions
		static SIMCResolutionStatus IsObjectTypeV1(SIMCSymbol **value, 
											  SIMCObjectTypeV1 * &retValObjectType);
		static SIMCResolutionStatus IsObjectTypeV2(SIMCSymbol **value, 
											  SIMCObjectTypeV2 * &retValObjectType);
		static SIMCResolutionStatus IsObjectType(SIMCSymbol **value, 
											  SIMCObjectTypeType * &retValObjectType);
		static SIMCResolutionStatus IsTrapType(SIMCSymbol **value, 
											  SIMCTrapTypeType * &retValTrapType);
		static SIMCResolutionStatus IsNotificationType(SIMCSymbol **value, 
											  SIMCNotificationTypeType * &retValNotificationType);
		static SIMCResolutionStatus IsEnumType(SIMCSymbol **value, 
											  SIMCEnumOrBitsType * &retValEnumType);

		// Reference checking functions
		static SIMCResolutionStatus IsTypeReference(SIMCSymbol **symbol,
											SIMCTypeReference * &retVal);
		static SIMCResolutionStatus IsValueReference(SIMCSymbol **symbol,
											SIMCSymbol ** &retTypeRef,
											SIMCBuiltInValueReference *&retVal);
		static SIMCResolutionStatus IsSequenceTypeReference(SIMCSymbol **symbol,
											SIMCBuiltInTypeReference * &retVal1,
											SIMCSequenceType *&retVal2);
		static SIMCResolutionStatus IsSequenceOfTypeReference(SIMCSymbol **symbol,
											SIMCBuiltInTypeReference * &retVal1,
											SIMCSequenceOfType *&retVal2);
		// For fabrication of OBJECT-GROUPs
		static SIMCResolutionStatus IsNamedNode(SIMCSymbol **symbol);
		static SIMCResolutionStatus IsScalar(SIMCSymbol **symbol);
		static SIMCResolutionStatus IsTable(SIMCSymbol **symbol);
		static SIMCResolutionStatus IsRow(SIMCSymbol **symbol);

		// Other helpers
		static SIMCResolutionStatus IsNotZeroSizeObject(SIMCObjectTypeType *objectType);
		static SIMCResolutionStatus IsFixedSizeObject(SIMCObjectTypeType *objectType);

		// This fabricates NOTICFICATION-TYPEs from TRAP-TYPEs and then proceeds to
		// fabricate NOTIFICATION-GROUPs from them.
		BOOL FabricateNotificationGroups(SIMCParseTree& theParseTree,	
			const SIMCOidTree& theOidTree);


};

UINT AFXAPI HashKey(LPCSTR key);

#endif // SIMC_MODULE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\newstring.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef NEW_STRING_H
#define NEW_STRING_H

// Return a new string with the same contents as the argument
char *NewString (const char * const s);
// Return a new uninitialized string of the specified length
char *NewString(const int len);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\group.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_GROUP_H
#define SIMC_GROUP_H

/*
 * This file contains the SIMCScalar, SIMCTable and SIMCObjectGroup classes
 * Please read the "compiler requirements specification" for definitions of 
 * "object group", "named node" etc., since object groups are fabricated 
 * for MIB modules (both V1 and V2) as per the rules in that document.
 *
 */


/*
 * This is a scalar MIB object.
 */
class SIMCScalar
{
		// A pointer to the symbol in a module, that represents this
		// object
		SIMCSymbol *symbol;
		// The "clean" oid value of this scalar object. Note that
		// and "unclean" value may be obtained by  calling the
		// function SIMCModule.IsObjectIdentifierValue(), on the module
		// that defined this symbol.
		SIMCCleanOidValue *value;

	public:
		SIMCScalar(SIMCSymbol *s, SIMCCleanOidValue *v)
			: symbol(s), value(v)
		{}
	
		SIMCScalar()
			: symbol(NULL), value(NULL)
		{}

		~SIMCScalar()
		{
			if(value)
				delete value;
		}

		friend ostream& operator << (ostream& outStream, const SIMCScalar& obj);

		SIMCSymbol *GetSymbol() const
		{
			return symbol;
		}

		void SetSymbol(SIMCSymbol *s) 
		{
			symbol = s;
		}

		SIMCCleanOidValue *GetOidValue() const
		{
			return value;
		}
		void SetOidValue(SIMCCleanOidValue *v) 
		{
			value = v;
		}
};

typedef CList<SIMCScalar *,SIMCScalar *> SIMCScalarMembers;


/*
 * This class represents a MIB table object
 */
class SIMCTable
{
		// A pointer to a symbol that represents this MIB object in a module
		// Example :  ifTable
		SIMCSymbol *tableSymbol;
		// ... and its clean OID value
		SIMCCleanOidValue *tableValue;

		// The symbol or object that represents the row of the table
		// Example : ifEntry
		SIMCSymbol *rowSymbol;
		// ... and its clean OID value
		SIMCCleanOidValue *rowValue;

		// A list of the columns of the table
		SIMCScalarMembers *columnMembers;

		SIMCTable *augmentedTable; // If any, in SNMPv2 SMI
	
	public:
		SIMCTable(SIMCSymbol *ts, SIMCCleanOidValue *tv, SIMCSymbol *rs, SIMCCleanOidValue *rv,
					SIMCScalarMembers *cm)
			: tableSymbol(ts), tableValue(tv), rowSymbol(rs), rowValue(rv), columnMembers(cm),
				augmentedTable(NULL)
		{}
	
		SIMCTable()
			: tableSymbol(NULL), tableValue(NULL), rowSymbol(NULL), 
				rowValue(NULL), columnMembers(NULL), augmentedTable(NULL)
		{}

		~SIMCTable()
		{
			if(tableValue)
				delete tableValue;
			if(rowValue)
				delete rowValue;
		
			if(columnMembers)
			{
				SIMCScalar *nextScalar;
				while(!columnMembers->IsEmpty() )
				{
					nextScalar = columnMembers->RemoveHead();
					delete nextScalar;
				}
				delete columnMembers;
			}
		}



		friend ostream& operator << (ostream& outStream, const SIMCTable& obj);
	
		SIMCSymbol *GetTableSymbol() const
		{
			return tableSymbol;
		}

		void SetTableSymbol(SIMCSymbol *ts) 
		{
			tableSymbol = ts;
		}

		SIMCCleanOidValue *GetTableOidValue() const
		{
			return tableValue;
		}

		void SetTableOidValue(SIMCCleanOidValue *tv) 
		{
			tableValue = tv;
		}

		SIMCSymbol *GetRowSymbol() const
		{
			return rowSymbol;
		}

		void SetRowSymbol(SIMCSymbol *rs) 
		{
			rowSymbol = rs;
		}

		SIMCCleanOidValue *GetRowOidValue() const
		{
			return rowValue;
		}

		void SetRowOidValue(SIMCCleanOidValue *rv) 
		{
			rowValue = rv;
		}

		SIMCScalarMembers *GetColumnMembers() const
		{
			return columnMembers;
		}

		SIMCScalar *GetColumnMember(SIMCSymbol *columnSymbol) const;

		void AddColumnMember(SIMCScalar *cm) 
		{
			if(!columnMembers)
				columnMembers = new SIMCScalarMembers;
			columnMembers->AddTail(cm);
		}
		
		BOOL IsColumnMember(const SIMCSymbol *symbol) const;

		long GetColumnCount() const
		{
			if(columnMembers)
				return columnMembers->GetCount();
			else
				return 0;
		}
		
		SIMCTable *GetAugmentedTable() const
		{
			return augmentedTable;
		}

		void SetAugmentedTable(SIMCTable *ts) 
		{
			augmentedTable = ts;
		}

		const char * const GetTableDescription() const;
		const char * const GetRowDescription() const;
};

typedef CList<SIMCTable *, SIMCTable *> SIMCTableMembers;


// For generating a name for the object group, in case of the V1 SMI
#define OBJ_GROUP_FABRICATION_SUFFIX "V1ObjectGroup"
#define OBJ_GROUP_FABRICATION_SUFFIX_LEN  13


// And finally the object group itself. Please read the "compiler requirements
// specification" for a definitions of "object group", "named node" etc.
class SIMCObjectGroup
{
	public:
		enum ObjectGroupStatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	private:
		// Various clauses of the object group
		char *objectGroupName;	
		char *description;
		char *reference;
		SIMCSymbol *namedNode;
		SIMCCleanOidValue *namedNodeValue;
		SIMCScalarMembers *scalars;
		SIMCTableMembers *tables;
		ObjectGroupStatusType status;
		static const char * const StatusStringsTable[3];
		
	public:
		SIMCObjectGroup(SIMCSymbol *n, SIMCCleanOidValue *nv,  SIMCScalarMembers *sm, SIMCTableMembers *tm, 
					ObjectGroupStatusType s, const char * descriptionV, const char *referenceV)
			: namedNode(n), namedNodeValue(nv), scalars(sm), tables(tm), status(s)
		{
			objectGroupName = NewString(strlen(n->GetSymbolName()) + 
									OBJ_GROUP_FABRICATION_SUFFIX_LEN + 1);
			strcpy(objectGroupName, n->GetSymbolName());
			strcat(objectGroupName, OBJ_GROUP_FABRICATION_SUFFIX);

			description = NewString(descriptionV);
			reference = NewString(referenceV);
		}
		
		SIMCObjectGroup()
			: namedNode(NULL), namedNodeValue(NULL), scalars(NULL), tables(NULL), 
				status(STATUS_CURRENT), objectGroupName(NULL), description(NULL),
				reference(NULL)
		{}

		
		~SIMCObjectGroup()
		{
			if(objectGroupName)
				delete [] objectGroupName;
			if(description)
				delete [] description;
			if(reference)
				delete [] reference;

			if(scalars)
			{
				SIMCScalar *nextScalar;
				while(!scalars->IsEmpty() )
				{
					nextScalar = scalars->RemoveHead();
					delete nextScalar;
				}
				delete scalars;
			}

			if(tables)
			{
				SIMCTable *nextTable;
				while(!tables->IsEmpty() )
				{
					nextTable = tables->RemoveHead();
					delete nextTable;
				}
				delete tables;
			}

			if(namedNodeValue) delete namedNodeValue;


		}

		friend ostream& operator << (ostream& outStream, const SIMCObjectGroup& obj);
	
		SIMCSymbol *GetNamedNode() const
		{
			return namedNode;
		}
		
		void SetNamedNode(SIMCSymbol *nn) 
		{
			namedNode = nn;
			if(objectGroupName)
				delete [] objectGroupName;
			objectGroupName = NewString(strlen(nn->GetSymbolName()) + 
									OBJ_GROUP_FABRICATION_SUFFIX_LEN + 1);
			strcpy(objectGroupName, nn->GetSymbolName());
			strcat(objectGroupName, OBJ_GROUP_FABRICATION_SUFFIX);
		}
		
		const char * const GetObjectGroupName() const
		{
			return objectGroupName;
		}

		const char * const GetDescription() const
		{
			return description;
		}

		void SetDescription(const char * const descriptionV)
		{
			if(description)
				delete [] description;
			description = NewString(descriptionV);
		}

		const char * const GetReference() const
		{
			return reference;
		}

		void SetReference(const char * const referenceV)
		{
			if(reference)
				delete [] reference;
			reference = NewString(referenceV);
		}

		SIMCCleanOidValue *GetGroupValue() const
		{
			return namedNodeValue;
		}

		void SetGroupValue(SIMCCleanOidValue *val) 
		{
			namedNodeValue = val;
		}

		SIMCScalarMembers *GetScalarMembers() const
		{
			return scalars;
		}

		void AddScalar(SIMCScalar *s) 
		{
			if(!scalars)
				scalars = new SIMCScalarMembers;
			scalars->AddTail(s);
		}

		long GetScalarCount() const
		{
			if(scalars)
				return scalars->GetCount();
			else
				return 0;
		}

		SIMCTableMembers *GetTableMembers() const
		{
			return tables;
		}
	
		void AddTable(SIMCTable *t) 
		{
			if(!tables)
				tables = new SIMCTableMembers;
			tables->AddTail(t);
		}

		long GetTableCount() const
		{
			if(tables)
				return tables->GetCount();
			else
				return 0;
		}

	
		ObjectGroupStatusType GetStatus() const
		{
			return status;
		}

		void SetStatus(ObjectGroupStatusType s)
		{
			status = s;
		}	

		const char * const GetStatusString() const
		{
			switch(status)
			{
				case STATUS_CURRENT:
					return 	StatusStringsTable[STATUS_CURRENT-1];
				case STATUS_DEPRECATED:
					return 	StatusStringsTable[STATUS_DEPRECATED-1];
				case STATUS_OBSOLETE:
					return 	StatusStringsTable[STATUS_OBSOLETE-1];
				default:
					return NULL;
			}
			return NULL;
		}

		SIMCScalar *GetScalar(SIMCSymbol *objectSymbol) const;
		SIMCTable *GetTable(SIMCSymbol *objectSymbol) const;
		BOOL ObjectsInModule(const SIMCModule *theModule) const;
};

#ifndef SIMC_GROUP_LIST
#define SIMC_GROUP_LIST
typedef CList<SIMCObjectGroup *, SIMCObjectGroup*> SIMCGroupList;
ostream& operator << (ostream& outStream, const SIMCGroupList& obj);
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\notificationgroup.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef NOTIFICATION_GROUP
#define NOTIFICATION_GROUP

// This encapsulates one of the following:
// A V2 NOTIFICATION-TYPE invocation or
// A NOTIFICATION-TYPE fabricated from a V1 TRAP-TYPE invocation
class SIMCNotificationElement
{
		// A pointer to the symbol in a module, that represents this
		// NOTIFICATION-TYPE
		SIMCSymbol *symbol;
		
		// The "clean" oid value of this NOTIFICATION-TYPE. Note that
		// and "unclean" value may be obtained by  calling the
		// function SIMCModule.IsObjectIdentifierValue(), on the module
		// that defined this symbol.
		SIMCCleanOidValue *value;

		// Indicates whether this was fabricated from a TRAP-TYPE
		BOOL _fabricatedFromTrapType;
		// These 2 fields are valid only if fabricatedFromTrapType is true
		int _specificId;
		SIMCCleanOidValue *_enterpriseOid;

	public:
		SIMCNotificationElement(SIMCSymbol *s, SIMCCleanOidValue *v,
			BOOL fabricatedFromTrapType = FALSE)
			: symbol(s), value(v), _fabricatedFromTrapType(fabricatedFromTrapType)
		{
			// Set the specificId and the enterpriseOid fields
			_enterpriseOid = new SIMCCleanOidValue;
			_specificId = 0;
			if(fabricatedFromTrapType)
			{
				if(v->GetCount() >= 3)
				{
					POSITION lastPosition = v->GetHeadPosition();
					POSITION lastMinusOnePosition = NULL;
					POSITION lastMinusTwoPosition = NULL;

					while(lastPosition)
					{
						lastMinusTwoPosition = lastMinusOnePosition;
						lastMinusOnePosition = lastPosition;
						_specificId = v->GetNext(lastPosition);
						_enterpriseOid->AddTail(_specificId);
					}
					_enterpriseOid->RemoveTail();
					_enterpriseOid->RemoveTail();
				}
			}
		}
	
		SIMCNotificationElement()
			: symbol(NULL), value(NULL)
		{}

		~SIMCNotificationElement()
		{
			delete value;
			delete _enterpriseOid;
		}

		friend ostream& operator << (ostream& outStream, const SIMCNotificationElement& obj);

		SIMCSymbol *GetSymbol() const
		{
			return symbol;
		}

		void SetSymbol(SIMCSymbol *s) 
		{
			symbol = s;
		}

		SIMCCleanOidValue *GetOidValue() const
		{
			return value;
		}
		void SetOidValue(SIMCCleanOidValue *v) 
		{
			value = v;
		}
		BOOL IsFabricatedFromTrapType() const
		{
			return _fabricatedFromTrapType;
		}

		// This is valid only if IsFabricatedFromTrapType() returns TRUE
		int GetSpecificId() const
		{
			return _specificId;
		}

		// This is valid only if IsFabricatedFromTrapType() returns TRUE
		SIMCCleanOidValue * GetEnterpriseOid() const
		{
			return _enterpriseOid;
		}
};

typedef CList<SIMCNotificationElement *, SIMCNotificationElement *> SIMCNotificationList;



// And finally the notification group itself. 
class SIMCNotificationGroup
{
	public:
		enum NotificationGroupStatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	// For generating a name for the notification group, in case of the V1 SMI
	static const char *const NOTIFICATION_GROUP_FABRICATION_SUFFIX; 
	static const int NOTIFICATION_GROUP_FABRICATION_SUFFIX_LEN;

	private:
		// Various clauses of the notification group
		char *notificationGroupName;	
		char *description;
		char *reference;
		SIMCSymbol *enterpriseNode;
		SIMCCleanOidValue *enterpriseNodeValue;
		SIMCNotificationList *notifications;
		NotificationGroupStatusType status;
		static const char * const StatusStringsTable[3];
		
	public:
		SIMCNotificationGroup(SIMCSymbol *n, SIMCCleanOidValue *nv,   
			NotificationGroupStatusType s, const char * descriptionV, 
			const char *referenceV, SIMCNotificationList *notificationsV)
			: enterpriseNode(n), enterpriseNodeValue(nv),  status(s),
				notifications(notificationsV)
		{
			notificationGroupName = NewString(strlen(n->GetSymbolName()) + 
									NOTIFICATION_GROUP_FABRICATION_SUFFIX_LEN + 1);
			strcpy(notificationGroupName, n->GetSymbolName());
			strcat(notificationGroupName, NOTIFICATION_GROUP_FABRICATION_SUFFIX);

			description = NewString(descriptionV);
			reference = NewString(referenceV);
		}
		
		SIMCNotificationGroup()
			: enterpriseNode(NULL), enterpriseNodeValue(NULL), notifications(NULL), 
				status(STATUS_CURRENT), notificationGroupName(NULL), description(NULL),
				reference(NULL)
		{}

		
		~SIMCNotificationGroup()
		{
			delete [] notificationGroupName;
			delete [] description;
			delete [] reference;

			if(notifications)
			{
				SIMCNotificationElement *nextElement;
				while(!notifications->IsEmpty() )
				{
					nextElement = notifications->RemoveHead();
					delete nextElement;
				}
				delete notifications;
			}

			if(enterpriseNodeValue) delete enterpriseNodeValue;


		}

		friend ostream& operator << (ostream& outStream, const SIMCNotificationGroup& obj);
	
		SIMCSymbol *GetEnterpriseNode() const
		{
			return enterpriseNode;
		}
		
		void SetEnterpriseNode(SIMCSymbol *nn) 
		{
			enterpriseNode = nn;
			if(notificationGroupName)
				delete [] notificationGroupName;
			notificationGroupName = NewString(strlen(nn->GetSymbolName()) + 
									NOTIFICATION_GROUP_FABRICATION_SUFFIX_LEN + 1);
			strcpy(notificationGroupName, nn->GetSymbolName());
			strcat(notificationGroupName, NOTIFICATION_GROUP_FABRICATION_SUFFIX);
		}
		
		const char * const GetNotificationGroupName() const
		{
			return notificationGroupName;
		}

		const char * const GetDescription() const
		{
			return description;
		}

		void SetDescription(const char * const descriptionV)
		{
			delete [] description;
			description = NewString(descriptionV);
		}

		const char * const GetReference() const
		{
			return reference;
		}

		void SetReference(const char * const referenceV)
		{
			delete [] reference;
			reference = NewString(referenceV);
		}

		SIMCCleanOidValue *GetGroupValue() const
		{
			return enterpriseNodeValue;
		}

		void SetGroupValue(SIMCCleanOidValue *val) 
		{
			enterpriseNodeValue = val;
		}

		SIMCNotificationList *GetNotifications() const
		{
			return notifications;
		}

		void AddNotification(SIMCNotificationElement *s) 
		{
			if(!notifications)
				notifications = new SIMCNotificationList();
			notifications->AddTail(s);
		}

		long GetNotificationCount() const
		{
			if(notifications)
				return notifications->GetCount();
			else
				return 0;
		}

	
		NotificationGroupStatusType GetStatus() const
		{
			return status;
		}

		void SetStatus(NotificationGroupStatusType s)
		{
			status = s;
		}	

		const char * const GetStatusString() const
		{
			switch(status)
			{
				case STATUS_CURRENT:
					return 	StatusStringsTable[STATUS_CURRENT-1];
				case STATUS_DEPRECATED:
					return 	StatusStringsTable[STATUS_DEPRECATED-1];
				case STATUS_OBSOLETE:
					return 	StatusStringsTable[STATUS_OBSOLETE-1];
				default:
					return NULL;
			}
			return NULL;
		}
};

typedef CList<SIMCNotificationGroup *, SIMCNotificationGroup*> SIMCNotificationGroupList;

class SIMCModuleNotificationGroups
{
	SIMCNotificationGroupList theList;

	public:

		BOOL AddNotification(SIMCSymbol *notificationSymbol);
		const SIMCNotificationGroupList *GetNotificationGroupList() const;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\objectidentity.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef OBJECT_IDENTITY
#define OBJECT_IDENTITY

/* 
 * This class models the OBJECT-IDENTITY macro
 */
class SIMCObjectIdentityType : public SIMCType
{
	public:
		// Symbols for the STATUS clause
		enum StatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	private:

		// Various clauses of the OBJECT-IDENTITY macro
		StatusType _status;
		long _statusLine, _statusColumn;
		char *_description;
		long _descriptionLine, _descriptionColumn;
		char *_reference;
		long _referenceLine, _referenceColumn;

	public:
		SIMCObjectIdentityType( StatusType status,
									long statusLine, long statusColumn,
									char *description,
									long descriptionLine, long descriptionColumn,
									char *reference,
									long referenceLine, long referenceColumn);

	
		virtual ~SIMCObjectIdentityType();
		

		/*
		 *
		 * And a whole lotta functions to set/get the various clauses
		 * 
		 */
		void SetStatus(StatusType s)
		{
			_status = s;
		}

		StatusType GetStatus() const
		{
			return _status;
		}

		static StatusType StringToStatusType (const char * const s);

		long GetStatusLine() const
		{
			return _statusLine;
		}
		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}
		long GetStatusColumn() const
		{
			return _statusColumn;
		}
		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}

		void SetDescription( const char * const s)
		{
			if( _description)
				delete [] _description;
			_description = NewString(s);
		}
		const char * GetDescription() const
		{
			return _description;
		}
		long GetDescriptionLine() const
		{
			return _descriptionLine;
		}
		long GetDescriptionColumn() const
		{
			return _descriptionColumn;
		}
		void SetDescriptionLine(long x) 
		{
			 _descriptionLine = x;
		}
		void SetDescriptionColumn(long x) 
		{
			 _descriptionColumn = x;
		}

		void SetReference( const char * const s)
		{
			if( _reference)
				delete [] _reference;
			_reference = NewString(s);
		}
		const char * GetReference() const
		{
			return _reference;
		}
		long GetReferenceLine() const
		{
			return _referenceLine;
		}
		long GetReferenceColumn() const
		{
			return _referenceColumn;
		}
		void SetReferenceLine(long x) 
		{
			 _referenceLine = x;
		}
		void SetReferenceColumn(long x) 
		{
			 _referenceColumn = x;
		}

		// A debugging function
		void WriteType(ostream &outStream) const;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\infoyacc.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
const MI_BGIN = 257;
const MI_CCE = 258;
const MI_COMMA = 259;
const MI_DEFINITIONS = 260;
const MI_FROM = 261;
const MI_ID = 262;
const MI_IMPORTS = 263;
const MI_NAME = 264;
const MI_SEMICOLON = 265;
const MI_LBRACE = 266;
const MI_RBRACE = 267;
const MI_LPAREN = 268;
const MI_RPAREN = 269;
const MI_DOT = 270;
const MI_LITNUMBER = 271;
typedef union {
	char * yy_name;
} MODULEINFOSTYPE;
extern MODULEINFOSTYPE ModuleInfolval;

// C++ YACC parser header
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// ModuleInfo_parse => class defining a parsing object
//	ModuleInfo_parse needs a class ModuleInfo_scan, which defines the scanner.
// %prefix or option -p xx determines name of this class; if not used,
// defaults to 'ModuleInfo_scan'
//
// constructor fills in the tables for this grammar; give it a size
//    to determine size of state and value stacks. Default is 150 entries.
// destructor discards those state and value stacks
//
// int ModuleInfo_parse::ModuleInfoparse(ModuleInfo_scan *) invokes parse; if this returns,
//	it can be recalled to continue parsing at last point.
// void ModuleInfo_parse::ModuleInforeset() can be called to reset the parse;
//	call ModuleInforeset() before ModuleInfo_parse::ModuleInfoparse(ModuleInfo_scan *)
#include <stdio.h>		// uses printf(), et cetera
#include <stdlib.h>		// uses exit()

const MODULEINFOERRCODE = 256;		// YACC 'error' value

// You can use these macros in your action code
#define MODULEINFOERROR		goto ModuleInfoerrlabel
#define MODULEINFOACCEPT	MODULEINFORETURN(0)
#define MODULEINFOABORT		MODULEINFORETURN(1)
#define MODULEINFORETURN(val)	return(val)

#if MODULEINFODEBUG
typedef struct ModuleInfoNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} ModuleInfoNamedType;
typedef struct ModuleInfoTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} ModuleInfoTypedRules;
#endif

#ifdef YACC_WINDOWS

// include all windows prototypes, macros, constants, etc.

#include <windows.h>

// the following is the handle to the current
// instance of a windows program. The user
// program calling ModuleInfoparse must supply this!

extern HANDLE hInst;	

#endif	/* YACC_WINDOWS */


class ModuleInfo_parse {
protected:

#ifdef YACC_WINDOWS

	// protected member function for actual scanning 

	int	win_ModuleInfoparse(ModuleInfo_scan * ps);	// parse with given scanner

#endif	/* YACC_WINDOWS */

	int	mustfree;	// set if tables should be deleted
	int	size;		// size of state and value stacks
	int	reset;		// if set, reset state
	short	ModuleInfoi;		// table index
	short	ModuleInfostate;	// current state

	short	* stateStack;	// states stack
	MODULEINFOSTYPE	* valueStack;	// values stack
	short	* ModuleInfops;		// top of state stack
	MODULEINFOSTYPE * ModuleInfopv;		// top of value stack

	MODULEINFOSTYPE ModuleInfolval;		// saved ModuleInfolval
	MODULEINFOSTYPE	ModuleInfoval;		// $
	MODULEINFOSTYPE * ModuleInfopvt;	// $n
	int	ModuleInfochar;		// current token
	int	ModuleInfoerrflag;	// error flag
	int	ModuleInfonerrs;	// error count
#if MODULEINFODEBUG
	int	done;		// set from trace to stop parse
	int	rule, npop;	// reduction rule # and length
	short	* typeStack;	// type stack to mirror valueStack[]
	short	* ModuleInfotp;		// top of type stack
	char	* ModuleInfogetState(int);	// read 'states.out'
#endif
public:
#if MODULEINFODEBUG
	// C++ has trouble with initialized arrays inside classes
	static long * States;		// pointer to ModuleInfoStates[]
	static ModuleInfoTypedRules * Rules;	// pointer to ModuleInfoRules[]
	static ModuleInfoNamedType * TokenTypes; // pointer to ModuleInfoTokenTypes[]
	static int	ModuleInfontoken;	// number of tokens
	static int	ModuleInfonvar;		// number of variables (nonterminals)
	static int	ModuleInfonstate;	// number of YACC-generated states
	static int	ModuleInfonrule;	// number of rules in grammar

	char*	ModuleInfoptok(int);		// printable token string
	int	ModuleInfoExpandName(int, int, char *, int);
						// expand encoded string
	virtual int	ModuleInfoGetType(int);		// return type of token
	virtual void	ModuleInfoShowRead();		// see newly read token
	virtual void	ModuleInfoShowState();		// see state, value stacks
	virtual void	ModuleInfoShowReduce();		// see reduction
	virtual void	ModuleInfoShowGoto();		// see goto
	virtual void	ModuleInfoShowShift();		// see shift
	virtual void	ModuleInfoShowErrRecovery();	// see error recovery
	virtual void	ModuleInfoShowErrDiscard();	// see token discard in error
#endif
	ModuleInfo_scan* scan;			// pointer to scanner
	int	ModuleInfodebug;	// if set, tracing if compiled with MODULEINFODEBUG=1

	ModuleInfo_parse(int = 150);	// constructor for this grammar
	ModuleInfo_parse(int, short *, MODULEINFOSTYPE *);	// another constructor

	~ModuleInfo_parse();		// destructor

	int	ModuleInfoparse(ModuleInfo_scan * ps);	// parse with given scanner

	void	ModuleInforeset() { reset = 1; } // restore state for next ModuleInfoparse()

	void	setdebug(int y) { ModuleInfodebug = y; }

// The following are useful in user actions:

	void	ModuleInfoerrok() { ModuleInfoerrflag = 0; }	// clear error
	void	ModuleInfoclearin() { ModuleInfochar = -1; }	// clear input
	int	MODULEINFORECOVERING() { return ModuleInfoerrflag != 0; }
};
// end of .hpp header
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\notificationtype.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef NOTIFICATION_TYPE_TYPE
#define NOTIFICATION_TYPE_TYPE



/*
 * This file contains the class that models the NOTIFICATION-TYPE macro
 * and other associated classes
 */

// Each of the objects in the VARIABLES clause
class SIMCObjectsItem
{
	public:
		SIMCSymbol **_item;
		long _line, _column;
		SIMCObjectsItem( SIMCSymbol **item, long line, long column)
			: _item(item), _line(line), _column(column)
		{}
};

// A list of items in the OBJECTS clause
typedef  CList<SIMCObjectsItem *, SIMCObjectsItem *> SIMCObjectsList;

/*
 * This class models the NOTIFICATION-TYPE macro of SNMPV2 SMI. 
 */
class SIMCNotificationTypeType : public SIMCType
{
	public:
		// Symbols for the STATUS clause
		enum StatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	// These are for generating a name for the notification type, 
	// from a V1 SMI trap type
	static const char *const NOTIFICATION_TYPE_FABRICATION_SUFFIX;
	static const int NOTIFICATION_TYPE_FABRICATION_SUFFIX_LEN;
	
	private:
		// The various clauses of the NOTIFICATION-TYPE macro
		SIMCObjectsList *_objects;
		char * _description;
		long _descriptionLine, _descriptionColumn;
		char *_reference;
		long _referenceLine, _referenceColumn;
		StatusType _status;
		long _statusLine, _statusColumn;


	public:
		SIMCNotificationTypeType(SIMCObjectsList *objects,
							char * description,
							long descriptionLine, long descriptionColumn,
							char *reference,
							long referenceLine, long referenceColumn,
							StatusType status,
							long statusLine, long statusColumn);

		~SIMCNotificationTypeType();

		static StatusType StringToStatusType (const char * const s);

		SIMCObjectsList* GetObjects() const
		{
			return _objects;
		}

		char *GetDescription() const
		{
			return _description;
		}
		char *GetReference() const
		{
			return _reference;
		}

		virtual void WriteType(ostream& outStream) const;
		
		long GetDescriptionLine() const
		{
			return _descriptionLine;
		}

		void SetDescriptionLine( long x) 
		{
			_descriptionLine = x;
		}

		long GetDescriptionColumn() const
		{
			return _descriptionColumn;
		}

		void SetDescriptionColumn( long x) 
		{
			_descriptionColumn = x;
		}

		long GetReferenceLine() const
		{
			return _referenceLine;
		}

		void SetReferenceLine( long x) 
		{
			_referenceLine = x;
		}

		long GetReferenceColumn() const
		{
			return _referenceColumn;
		}

		void SetReferenceColumn( long x) 
		{
			_referenceColumn = x;
		}

		void SetStatus(StatusType s)
		{
			_status = s;
		}

		StatusType GetStatus() const
		{
			return _status;
		}

		long GetStatusLine() const
		{
			return _statusLine;
		}

		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}

		long GetStatusColumn() const
		{
			return _statusColumn;
		}

		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\objecttype.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_OBJECT_TYPE_TYPE
#define SIMC_OBJECT_TYPE_TYPE

typedef CList<SIMCSymbol *, SIMCSymbol *> SIMCIndexedObjectsList;

/*
 * This class is an abstract base class for a MIB object, defined using
 * the OBJECT-TYPE clause. It has stuff that is common to SNMPV1 objects
 * and SNMPv2 objects. The SIMCObjectTypeV1 and SIMCObjectTypeV2 classes
 * derive from this class and add the necessary functionality
 */
class SIMCObjectTypeType : public SIMCType
{
		// A pointer to the symbol that defines this object
		SIMCSymbol ** _syntax;

		// The various clauses of the OBJECT-TYPE
		char *_description;
		char *_reference;
		// the value in the defVal clause can refer to an enum item
		// If so _defVal is NULL, and _defValName contains the identifier of the
		// enum item, and _enumValue contains the integral value.
		// Otherwise, _defValName is NULL and _defVal contains a reference to the
		// symbol representing the value
		SIMCSymbol **_defVal;
		char *_defValName;
		SIMCResolutionStatus _defValStatus;
		long _syntaxLine, _syntaxColumn, _descriptionLine, _descriptionColumn,
			_referenceLine, _referenceColumn, _defValLine, _defValColumn;

		// This OBJECT-TYPE is referenced in the INDEX clause of these OBJECT-TYPEs
		SIMCIndexedObjectsList indexedObjectsList;

	protected:
		SIMCObjectTypeType( SIMCSymbol **syntax,
							long syntaxLine, long syntaxColumn,
							const char * const description,
							long descriptionLine, long descriptionColumn,
							const char * const reference,
							long referenceLine, long referenceColumn,
							const char * const defValName,
							SIMCSymbol **defVal,
							long defValLine, long defValColumn)
							: _syntax(syntax), _defVal(defVal),
								_syntaxLine(syntaxLine), _syntaxColumn(syntaxColumn),
								_descriptionLine(descriptionLine), 
								_descriptionColumn(descriptionColumn),
								_referenceLine(referenceLine), 
								_referenceColumn(referenceColumn),
								_defValLine(defValLine), _defValColumn(defValColumn)
		{
			if(_syntax)
				(*_syntax)->IncrementReferenceCount();
			if(_defVal)
				(*_defVal)->IncrementReferenceCount();
			_description = NewString(description);
			_reference = NewString(reference);
			_defValName = NewString(defValName);
			_defValStatus = RESOLVE_UNSET;
		}

	
		virtual ~SIMCObjectTypeType()
		{
			if(UseReferenceCount() && _syntax)
				(*_syntax)->DecrementReferenceCount();
			if(UseReferenceCount() && _defVal)
				(*_defVal)->DecrementReferenceCount();
			if(_description)
				delete [] _description;
			if(_reference)
				delete [] _reference;
			if(_defValName)
				delete [] _defValName;
		}

	public:

		/*
		 * 
		 * A whole lotta functions to get/set the various clauses
		 * of the OBJECT-TYPE macro
		 *
		 */
		void SetDescription( const char * const s)
		{
			if( _description)
				delete [] _description;
			_description = NewString(s);
		}

		const char * GetDescription() const
		{
			return _description;
		}

		void SetReference( const char * const s)
		{
			if( _reference)
				delete [] _reference;
			_reference = NewString(s);
		}

		const char * GetReference() const
		{
			return _reference;
		}
	
		void SetDefValName( const char * const s)
		{
			if( _defValName)
				delete [] _defValName;
			_defValName = NewString(s);
		}

		const char * GetDefValName() const
		{
			return _defValName;
		}

		void SetDefValStatus(SIMCResolutionStatus x)
		{
			_defValStatus = x;
		}

		SIMCResolutionStatus GetDefValStatus() const
		{
			return _defValStatus;
		}

		void SetSyntax( SIMCSymbol ** s)
		{
			if(_syntax && UseReferenceCount())
				(*_syntax)->DecrementReferenceCount();
			_syntax = s;
			if(_syntax)
				(*_syntax)->IncrementReferenceCount();

		}

		SIMCSymbol **GetSyntax() const
		{
			return _syntax;
		}

		void SetDefVal(SIMCSymbol **v)
		{
			if(_defVal && UseReferenceCount())
				(*_defVal)->DecrementReferenceCount();
			_defVal = v;
			if(_defVal)
				(*_defVal)->IncrementReferenceCount();
		}

		SIMCSymbol **GetDefVal() const
		{
			return _defVal;
		}

		void WriteType( ostream& outStream) const
		{
			outStream << "SIMCObjectType::operator<<() : NOT YET IMPLEMENTED" << endl;
		}
		
		// Set and Get for the line numbers
		long GetSyntaxLine() const
		{
			return _syntaxLine;
		}
		long GetSyntaxColumn() const
		{
			return _syntaxColumn;
		}
		long GetDescriptionLine() const
		{
			return _descriptionLine;
		}
		long GetDescriptionColumn() const
		{
			return _descriptionColumn;
		}
		long GetReferenceLine() const
		{
			return _referenceLine;
		}
		long GetReferenceColumn() const
		{
			return _referenceColumn;
		}
		long GetDefValLine() const
		{
			return _defValLine;
		}
		long GetDefValColumn() const
		{
			return _defValColumn;
		}

		void SetSyntaxLine(long x) 
		{
			 _syntaxLine = x;
		}
		void SetSyntaxColumn(long x) 
		{
			 _syntaxColumn = x;
		}
		void SetDescriptionLine(long x) 
		{
			 _descriptionLine = x;
		}
		void SetDescriptionColumn(long x) 
		{
			 _descriptionColumn = x;
		}
		void SetReferenceLine(long x) 
		{
			 _referenceLine = x;
		}
		void SetReferenceColumn(long x) 
		{
			 _referenceColumn = x;
		}
		void SetDefValLine(long x) 
		{
			 _defValLine = x;
		}
		void SetDefValColumn(long x) 
		{
			 _defValColumn = x;
		}
		void AddIndexedObjectType(SIMCSymbol *indexObjectType)
		{
			indexedObjectsList.AddTail(indexObjectType);
		}

		BOOL DoesIndexOtherObjects() const
		{
			return !indexedObjectsList.IsEmpty();
		}

		const SIMCIndexedObjectsList *GetIndexedObjects() const
		{
			return &indexedObjectsList;
		}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\objecttypev2.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_OBJECT_TYPE_V2
#define SIMC_OBJECT_TYPE_V2
/*
 * This file contains the SIMCObjectTypeV2 class that represents a
 * MIB object defined using the OBJECT-TYPE macro, as per the SNMPV2 SMI
 * It is derived from the SIMCObjectTypeType class.
 */

/* Each of the item in the INDEX clause */
class SIMCIndexItemV2
{
	public:
		SIMCSymbol ** _item;
		long _line, _column;
		BOOL _implied;
		SIMCIndexItemV2(SIMCSymbol **item, long line, long column, BOOL implied = FALSE)
			: _item(item), _line(line), _column(column), _implied(implied)
		{}
};

/* A list of index items. This forms the index clause */
typedef CList<SIMCIndexItemV2 *, SIMCIndexItemV2 *> SIMCIndexListV2;

/* 
 * This models a MIB object defined using the OBJECT-TYPE macro, as per
 * the SNMPV2 SMI rules.
 */
class SIMCObjectTypeV2 : public SIMCObjectTypeType
{
	public:
		// Symbols for the ACCESS clause
		enum AccessType
		{
			ACCESS_INVALID,	// Not used, except as a return value from function calls
			ACCESS_NOT_ACCESSIBLE,
			ACCESS_READ_ONLY,
			ACCESS_READ_WRITE,
			ACCESS_READ_CREATE,
			ACCESS_FOR_NOTIFY
		};

		// Symbols for the STATUS clause
		enum StatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_CURRENT,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	private:

		// Values for the various OBJECT-TYPE macro clauses
		AccessType _access;
		long _accessLine, _accessColumn;
		StatusType _status;
		long _statusLine, _statusColumn;
		SIMCIndexListV2 * _indexTypes;
		long _indexLine, _indexColumn;
		SIMCSymbol ** _augmentsClause;
		char * _unitsClause;
		long _unitsLine, _unitsColumn;

	public:
		SIMCObjectTypeV2( 	SIMCSymbol **syntax,
								    long syntaxLine, long syntaxColumn,
									const char * const units,
									long unitsLine, long unitsColumn,
									AccessType access,
									long accessLine, long accessColumn, 
									StatusType status,
									long statusLine, long statusColumn,
									SIMCIndexListV2 * indexTypes,
									long indexLine, long indexColumn,
									SIMCSymbol ** augmentsClause,
									const char * const description,
									long descriptionLine, long descriptionColumn,
									const char * const reference,
									long referenceLine, long referenceColumn,
									const char * const defValName,
									SIMCSymbol **defVal,
									long defValLine, long defValColumn);


	
		virtual ~SIMCObjectTypeV2();
		

		
		/*
		 *
		 * Lots of functions to get/set the various OBJECT-TYPE clauses
		 *
		 */
		void SetAccess(AccessType a)
		{
			_access = a;
		}

		AccessType GetAccess() const
		{
			return _access;
		}


		void SetStatus(StatusType s)
		{
			_status = s;
		}

		StatusType GetStatus() const
		{
			return _status;
		}

		void SetIndexTypes(SIMCIndexListV2 *l)
		{
			_indexTypes = l;
		}
	
		SIMCIndexListV2 * GetIndexTypes() const
		{
			return _indexTypes;
		}

		static AccessType StringToAccessType (const char * const s);

		static StatusType StringToStatusType (const char * const s);


		long GetAccessLine() const
		{
			return _accessLine;
		}

		void SetAccessLine(long x) 
		{
			_accessLine = x;
		}

		long GetAccessColumn() const
		{
			return _accessColumn;
		}

		void SetAccessColumn(long x) 
		{
			_accessColumn = x;
		}

		long GetStatusLine() const
		{
			return _statusLine;
		}

		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}

		long GetStatusColumn() const
		{
			return _statusColumn;
		}

		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}
		long GetIndexLine() const
		{
			return _indexLine;
		}

		void SetIndexLine(long x) 
		{
			_indexLine = x;
		}

		long GetIndexColumn() const
		{
			return _indexColumn;
		}

		void SetIndexColumn(long x) 
		{
			_indexColumn = x;
		}

		SIMCSymbol ** GetAugments() const
		{
			return _augmentsClause;
		}

		void SetAugments(SIMCSymbol **augmentsClause)
		{
			if(_augmentsClause && UseReferenceCount())
				(*_augmentsClause)->DecrementReferenceCount();
			_augmentsClause = augmentsClause;
			if(_augmentsClause)
				(*_augmentsClause)->IncrementReferenceCount();
		}

		long GetAugmentsLine() const
		{
			return _indexLine;
		}

		void SetAugmentsLine(long x) 
		{
			_indexLine = x;
		}

		long GetAugmentsColumn() const
		{
			return _indexColumn;
		}

		void SetAugmentsColumn(long x) 
		{
			_indexColumn = x;
		}

		const char *GetUnitsClause()
		{
			return _unitsClause;
		}
};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\oidtree.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_OID_TREE_H
#define SIMC_OID_TREE_H

/* 
 * This file contains the SIMCOidTree class, which is a class that
 * represents the OID tree of an SNMP MIB module, and the associated classes
 */


// Forward references
class SIMCOidTreeNode;
class SIMCParseTree;
class SIMCOidTree;
// Helpful typedefs
typedef CList<const SIMCSymbol **, const SIMCSymbol **> SIMCSymbolList;
typedef CList<SIMCOidTreeNode *, SIMCOidTreeNode *> SIMCNodeList;



// Each node in the OID tree
class SIMCOidTreeNode
{
		// The integer value of this node. Basically a component of the
		// OID value
		int _val;
		// A list of symbols that have an OID value represented by this node
		SIMCSymbolList _listOfSymbols;
		// A list of child nodes
		SIMCNodeList _listOfChildNodes;

	public:
		
		// You *have* to supply an integer value for this node
		SIMCOidTreeNode(int val)
			: _val(val)
		{}

		~SIMCOidTreeNode();

		// Add a symbol to the list of symbols that have this oid value
		void AddSymbol(const SIMCSymbol ** s)
		{
			_listOfSymbols.AddTail(s);
		}
		
		int GetValue() const
		{
			return _val;
		}

		const SIMCSymbolList *GetSymbolList() const
		{
			return &_listOfSymbols;
		}

		// Check whether the specified symbol is in the list of symbols
		// of this node
		BOOL HasSymbol(SIMCSymbol *symbol)
		{
			POSITION p = _listOfSymbols.GetHeadPosition();
			const SIMCSymbol **next;
			const char * const symbolName = symbol->GetSymbolName();
			const char * const moduleName = (symbol->GetModule())->GetModuleName();
			while(p)
			{
				next = _listOfSymbols.GetNext(p);
				if(strcmp((*next)->GetSymbolName(), symbolName) == 0 &&
					strcmp( ((*next)->GetModule())->GetModuleName(), moduleName) == 0)

					return TRUE;
			}
			return FALSE;
		}

		// Add a child node
		BOOL AddChild(int val)
		{
			POSITION p = _listOfChildNodes.GetHeadPosition();
			SIMCOidTreeNode * next;
			while(p)
			{
				next = _listOfChildNodes.GetNext(p);
				if( next->GetValue() == val )
					return FALSE;
			}
			_listOfChildNodes.AddTail(new SIMCOidTreeNode(val));
			return TRUE;
		}

		const SIMCNodeList * GetListOfChildNodes() const
		{
			return &_listOfChildNodes;
		}

		// Get a child node that has the specified value
		SIMCOidTreeNode *GetChild(int val) const
		{
			POSITION p = _listOfChildNodes.GetHeadPosition();
			SIMCOidTreeNode * next;
			while(p)
			{
				next = _listOfChildNodes.GetNext(p);
				if( next->GetValue() == val )
					return next;
			}
			return NULL;
		}

		// Check whether the specified symbol is an any of the child
		// nodes
		BOOL HasChild(SIMCSymbol *child)
		{
			POSITION p = _listOfChildNodes.GetHeadPosition();
			SIMCOidTreeNode * next;
			while(p)
			{
				next = _listOfChildNodes.GetNext(p);
				if( next->HasSymbol(child))
					return TRUE;
			}
			return FALSE;
		}

		// These functions make semantic checks on a node
		BOOL CheckNode(BOOL local, SIMCParseTree *const parseTree, 
								SIMCSymbol *parentSequence,
								SIMCSymbol *parentSequenceOf, 
								SIMCSymbol *ancestor);
		BOOL CheckSequenceProperty(BOOL local, SIMCParseTree *const parseTree, 
									SIMCSymbol *objectTypeSymbol, 
									SIMCObjectTypeType *objectType,
									SIMCBuiltInTypeReference *seqTypeRef);
		BOOL CheckSequenceOfProperty(BOOL local, SIMCParseTree *const parseTree, 
								   SIMCSymbol *objectTypeSymbol, 
								   SIMCBuiltInTypeReference *seqOfTypeRef);
		// These functions are used in the implementation of
		// SIMCOidTree functions and should never be called by
		// the user. the user should always call the corresponding
		// SIMCOidTree functions
		BOOL GetOidValue(const char * const symbolName,
						const char * const moduleName,
						SIMCCleanOidValue& val) const;

		SIMCOidTreeNode *GetParentOf(const SIMCOidTreeNode * node);
		SIMCOidTreeNode *GetParentOf(SIMCSymbol *symbol);

		
		// Gets all the object groups, from this node, downwards.
		// Never called by the user. Use the corresponding SIMCOidTree
		// functions
		BOOL GetObjectGroups(SIMCOidTree *tree,
			SIMCGroupList *groupList);
		// These functions deal with fabrication
		// Never called by the user. Use the corresponding SIMCOidTree
		// functions
		BOOL FabricateGroup(SIMCOidTree *tree,
			SIMCSymbol *namedNode, SIMCGroupList *groupList);
		BOOL FabricateTable(SIMCOidTree *tree, SIMCTable *table);
		BOOL FabricateRow(SIMCOidTree *tree, SIMCTable *table);

};


/* And the OID tree */
class SIMCOidTree
{
		SIMCOidTreeNode _root;

	public:

		SIMCOidTree() 
			: _root(0)
		{}

		// Gets the root of the OID tree
		const SIMCOidTreeNode * GetRoot() const
		{
			return &_root;
		}

		// Adds a symbol with the specified OID value to the OID tree
		BOOL AddSymbol(const SIMCSymbol ** s, const SIMCCleanOidValue& val);

		// Gets a list of symbols that have the specified OID value
		const SIMCSymbolList *GetSymbolList(const SIMCCleanOidValue& val);
		
		// Gets the OID value of a symbol, based on its name and its module name
		BOOL GetOidValue(const char * const symbolName, 
			const char * const moduleName,
			SIMCCleanOidValue& val) const;

		// Gets the parent node of the specified node
		SIMCOidTreeNode *GetParentOf(const SIMCOidTreeNode * node);
		// Gets the parent node of the specified symbol
		SIMCOidTreeNode *GetParentOf(SIMCSymbol *symbol);

		// Gets all the OBJECT-GROUPS that can be fabricated from
		// this tree.
		BOOL GetObjectGroups(SIMCGroupList *groupList);

		// Checks the semantics of the OID tree
		BOOL CheckOidTree(BOOL local, SIMCParseTree * const parseTree);
		// Checks the semantics of single node
		BOOL CheckNode(BOOL local, SIMCParseTree * const parseTree);

		// Never called by the user
		static void SetAugmentedTable(SIMCTable *table, 
			SIMCSymbol *augmentsSymbol,
			SIMCGroupList *groupList);

		// debugging functions
		friend ostream& operator<< (ostream& outStream, const SIMCOidTree& obj)
		{
			obj.WriteTree(outStream);
			return outStream;
		}
		void WriteTree(ostream& outStream) const;
		static void WriteSubTree(ostream& outStream, 
							   const SIMCOidTreeNode *subNode,
							   SIMCCleanOidValue& realValue);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\objecttypev1.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_OBJECT_TYPE_V1
#define SIMC_OBJECT_TYPE_V1

/*
 * This file contains the SIMCObjectTypeV1 class that represents a
 * MIB object defined using the OBJECT-TYPE macro, as per the SNMPV1 SMI
 * It is derived from the SIMCObjectTypeType class.
 */


/* Each of the item in the INDEX clause */
class SIMCIndexItem
{
	public:
		SIMCSymbol ** _item;
		long _line, _column;
		SIMCIndexItem(SIMCSymbol **item, long line, long column)
			: _item(item), _line(line), _column(column)
		{}
};

/* A list of index items. This forms the index clause */
typedef CList<SIMCIndexItem *, SIMCIndexItem *> SIMCIndexList;

/* 
 * This models a MIB object defined using the OBJECT-TYPE macro, as per
 * the SNMPV1 SMI rules.
 */
class SIMCObjectTypeV1 : public SIMCObjectTypeType
{
	public:
		// Symbols for the ACCESS clause
		enum AccessType
		{
			ACCESS_INVALID,	// Not used, except as a return value from function calls
			ACCESS_NOT_ACCESSIBLE,
			ACCESS_READ_ONLY,
			ACCESS_READ_WRITE,
			ACCESS_WRITE_ONLY
		};

		// Symbols for the STATUS clause
		enum StatusType
		{
			STATUS_INVALID, // Not used,
			STATUS_MANDATORY,
			STATUS_OPTIONAL,
			STATUS_DEPRECATED,
			STATUS_OBSOLETE
		};

	private:

		// Values for the various OBJECT-TYPE macro clauses
		AccessType _access;
		long _accessLine, _accessColumn;
		StatusType _status;
		long _statusLine, _statusColumn;
		SIMCIndexList * _indexTypes;
		long _indexLine, _indexColumn;

	public:
		SIMCObjectTypeV1( 	SIMCSymbol **syntax,
								    long syntaxLine, long syntaxColumn,
									AccessType access,
									long accessLine, long accessColumn, 
									StatusType status,
									long statusLine, long statusColumn,
									SIMCIndexList * indexTypes,
									long indexLine, long indexColumn,
									char *description,
									long descriptionLine, long descriptionColumn,
									char *reference,
									long referenceLine, long referenceColumn,
									char *defValName,
									SIMCSymbol **defVal,
									long defValLine, long defValColumn);


	
		virtual ~SIMCObjectTypeV1();
		

		/*
		 *
		 * Lots of functions to get/set the various OBJECT-TYPE clauses
		 *
		 */
		void SetAccess(AccessType a)
		{
			_access = a;
		}

		AccessType GetAccess() const
		{
			return _access;
		}


		void SetStatus(StatusType s)
		{
			_status = s;
		}

		StatusType GetStatus() const
		{
			return _status;
		}

		void SetIndexTypes(SIMCIndexList *l)
		{
			_indexTypes = l;
		}
	
		SIMCIndexList * GetIndexTypes() const
		{
			return _indexTypes;
		}

		static AccessType StringToAccessType (const char * const s);

		static StatusType StringToStatusType (const char * const s);


		long GetAccessLine() const
		{
			return _accessLine;
		}

		void SetAccessLine(long x) 
		{
			_accessLine = x;
		}

		long GetAccessColumn() const
		{
			return _accessColumn;
		}

		void SetAccessColumn(long x) 
		{
			_accessColumn = x;
		}

		long GetStatusLine() const
		{
			return _statusLine;
		}

		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}

		long GetStatusColumn() const
		{
			return _statusColumn;
		}

		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}
		long GetIndexLine() const
		{
			return _indexLine;
		}

		void SetIndexLine(long x) 
		{
			_indexLine = x;
		}

		long GetIndexColumn() const
		{
			return _indexColumn;
		}

		void SetIndexColumn(long x) 
		{
			_indexColumn = x;
		}


};




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\registry.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_REGISTRY_CONTROLLER
#define SIMC_REGISTRY_CONTROLLER

/* 
 * This file contains the classes that are used to manipulate the
 * registry by the SNMP Compiler. The compiler stores MIB dependency
 * information in the registry, as per the "compiler requirements spec"
 */

// The class that represents the mapping between a file name
// and a module name
class SIMCFileMapElement
{
	public:
		CString fileName;
		CString moduleName;
		SIMCFileMapElement(const CString mName, const CString fName)
			: moduleName(mName), fileName(fName)
		{}
		SIMCFileMapElement() {}
};

// A list of such mappings
typedef CList<SIMCFileMapElement, SIMCFileMapElement> SIMCFileMapList;


// The class that controls the registry, and has functions for retreiving
// mappings, adding/deleting mappings etc. from the registry. Most
// functions are static
class SIMCRegistryController
{
	private:

		// The keys in the registry that the SNMP compiler uses.
		// These are defined in the "compiler requirements spec"
		static const char *rootKeyName;
		static const char *filePaths;
		static const char *fileSuffixes;
		static const char *mibTable;
 		
		// Checks whether the file name is a path name
		static BOOL IsAbsolutePath(CString pathName);

		static BOOL GetMibFileFromMap(const SIMCFileMapList& theList, 
			const CString& module, 
			CString &file);

		static BOOL ShouldAddDependentFile(SIMCFileMapList& dependencyList,
				  const CString& dependentModule,
				  CString& dependentFile,
				  const SIMCFileMapList& priorityList);

		static BOOL IsModulePresent(SIMCFileMapList& dependencyList,
											  const CString& dependentModule);
		static BOOL IsFilePresent(SIMCFileMapList& dependencyList,
											  const CString& dependentFile);
		
	public:
		// Gets the entry from the lookup table
		static BOOL GetMibFileFromRegistry(const char * const moduleName, 
			CString &fullPathName);

		// Prints out the lookup table on to stdout
		static BOOL ListMibTable();

		// Gets the list of suffixes from teh registry
		static BOOL GetMibSuffixes(SIMCStringList & theList);

		// Gets the list of paths from teh registry
		static BOOL GetMibPaths(SIMCStringList & theList);

		// Deletes the lookup table from the registry
		static BOOL DeleteMibTable();

		// Deletes the lookup table and rebuilds it.
		// Returns the # of entries entered
		static long RebuildMibTable();

		// Builds the lookup table afresh, and gets it
		static long GetFileMap(SIMCFileMapList &theList);

		// Adds the mappings from a directory to theList
		static long RebuildDirectory(const CString& directory, 
					const SIMCStringList& suffixList,
					SIMCFileMapList &theList);

		// Adds the mapping of a file to theList
		static BOOL ProcessFile(const char * const fileName,
					SIMCFileMapList &theList);
		
		// Given a priority list of mappings, builds a dependency list
		// using a depth first search using the priority mappings first,
		// and then the registry lookup table to locate any required mib modules
		static BOOL GetDependentModules(const char * const fileName,
					SIMCFileMapList& dependencyList,
					const SIMCFileMapList& priorityList);
		
		// Deletes a specified directory from the list of paths in the registry
		static BOOL DeleteRegistryDirectory(const CString& directoryName);
		
		// Adds a specified directory to the list of paths in the registry
		static BOOL AddRegistryDirectory(const CString& directoryName);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\oidvalue.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_OID_VALUE
#define SIMC_OID_VALUE

/*
 * This file contains classes for modelling OID values
 * OID values are of 2 types, for purposes of the compiler
 * A clean oid value, is one in which the values of the individual components
 * are known presently. Hence a list of integers is all that is required to model
 * it, as is done by the SIMCCleanOidValue typedef.	It is referred to, as a
 * "clean" oid value, in the documentation.
 * However, while compiling a MIB, we might not know the values of
 * of all the components of an OID (these may be symbols that refer
 * to integer values, or to other oid values. Hence, we need to model this
 * too, as is done by the SIMCOidValue class. It is often referred to as
 * an "unclean" OID value in the documentation.
 */


// Each component of the SIMCOidValue Object. This is basically a
// pointer to SIMCSymbol*, with other associated information.
class SIMCOidComponent
{

		char *_name;
		long _nameLine, _nameColumn;
		// The symbol that represents this component.
		// It should resolve to an integer, or another oid value
		SIMCSymbol **_value;   
		long _valueLine, _valueColumn;

	public:
		SIMCOidComponent(SIMCSymbol **value, long valueLine, long valueColumn,
			char *name, long nameLine, long nameColumn)
			: _value(value), _valueLine(valueLine), _valueColumn(valueColumn),
				_nameLine(nameLine), _nameColumn(nameColumn)
		{
			if(name)
				_name = NewString(name);
			else
				_name = NULL;
		}

		virtual ~SIMCOidComponent()
		{
			if(_name)
				delete []_name;
		}

		SIMCSymbol ** GetValue() const
		{
			return _value;
		}

		long GetNameLine() const
		{
			return _nameLine;
		}

		void SetNameLine(long x)
		{
			_nameLine = x;
		}
		long GetNameColumn() const
		{
			return _nameColumn;
		}

		void SetNameColumn(long x)
		{
			_nameColumn = x;
		}
		long GetValueLine() const
		{
			return _valueLine;
		}

		void SetValueLine(long x)
		{
			_valueLine = x;
		}
		long GetValueColumn() const
		{
			return _valueColumn;
		}

		void SetValueColumn(long x)
		{
			_valueColumn = x;
		}

		friend ostream& operator << ( ostream& outStream, const SIMCOidComponent& obj);
};

typedef CList<SIMCOidComponent *, SIMCOidComponent*> SIMCOidComponentList;


// An "unclean" oid value
class SIMCOidValue : public SIMCValue
{

		SIMCOidComponentList  * _listOfComponents;


	public:

		SIMCOidValue( SIMCOidComponentList* listOfComponents, 
			long line = 0, long column = 0)
			: _listOfComponents(listOfComponents), 
			SIMCValue(line, column)
		{
			if(_listOfComponents)
			{
				SIMCOidComponent *next;
				POSITION p = _listOfComponents->GetHeadPosition(); 
				while(p)
				{
					next = _listOfComponents->GetNext(p);
					(*next->GetValue())->IncrementReferenceCount();
				}
			}
		}

		~SIMCOidValue()
		{
			if(_listOfComponents)
			{
				SIMCOidComponent *next;
				BOOL useReferenceCount = UseReferenceCount();
				while(!_listOfComponents->IsEmpty())
				{
					next = _listOfComponents->RemoveHead();
					if(useReferenceCount)
						(*next->GetValue())->DecrementReferenceCount();
					delete next;
				}
				delete _listOfComponents;
			}
		}

		void SetListOfComponents(SIMCOidComponentList *list)
		{
			_listOfComponents = list;
		}

		SIMCOidComponentList  *GetListOfComponents() const 
		{
			return _listOfComponents;
		}

		virtual void WriteValue( ostream& outStream) const;

};

/*
* A "clean" oid value
*/
typedef CList<int, int> SIMCCleanOidValue;

// Functions to operate on a clean OID value
ostream& operator << (ostream& outStream, const SIMCCleanOidValue& obj);
operator == (const SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs);
operator < (const SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs);
void AppendOid(SIMCCleanOidValue& to, const SIMCCleanOidValue& from);
char * CleanOidValueToString(const SIMCCleanOidValue& value);
SIMCCleanOidValue& CleanOidValueCopy(SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\parsetree.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_PARSE_TREE_H
#define SIMC_PARSE_TREE_H

typedef CList<int, int> SIMCCleanOidValue;
ostream& operator << (ostream& outStream, const SIMCCleanOidValue& obj);

/*
 * SIMCParseTree - This is derived from the SIMCAbstractParseTree class
 * and provides implementation of all the pure virtual functions in it (the
 * semantic checking functions).
 * It uses the dll "smierrsy.dll" to hold the strings for the error messages
 * that it generates while checking semantics.
 * It uses the error container of the base class to place these messages.
 */
class SIMCParseTree : public SIMCAbstractParseTree
{
		// An OID tree that spans all modules.
		// Constructed as an aid to semantic checking
		SIMCOidTree _theTree;

		// The lowest semantic error Id
		static const int SEMANTIC_ERROR_BASE;
		
		// The size of the buffer used to construct an error message
		static const int MESSAGE_SIZE;


	public:

		// The resource-only dll with semantic error text string table
		static  HINSTANCE semanticErrorsDll;

		// Accept an error container to put the error messages in.
		SIMCParseTree(SIMCErrorContainer * ec)
			: SIMCAbstractParseTree(ec)
		{
			if ( semanticErrorsDll == NULL )
				semanticErrorsDll = LoadLibrary(SIMCParser::semanticErrorsDllFile);
		}

		// Severity levels for the various erro messages generated
		// by this class
		enum SeverityLevel
		{
			INVALID,
			FATAL,
			WARNING,
			INFORMATION
		};

		// A function for constructing the error messages, to be put into
		// the error container
		void SemanticError(const char *const inputStreamName, int errorType,
			int lineNo,
			int columnNo,
			...);
	
		// Resolve the forward references and the external references. 
		// See the description in SIMCAbstractParseTree
		virtual BOOL Resolve(BOOL local);
		
	// Privately used functions, in Resolve()
	private:
		BOOL SetResolutionStatus();
		BOOL SetRootAll();
		BOOL SetDefVal();
		BOOL ResolveModule(SIMCModule *m, BOOL local);
		BOOL ResolveImportModule(SIMCModule *m, BOOL local);
		BOOL ResolveSymbol(SIMCSymbol **symbol, BOOL local);
		
	public:		
		// Check the Semantics of the modules 
		// See the description in SIMCAbstractParseTree
		virtual BOOL CheckSemantics(BOOL local = FALSE);

		// A user will rarely use this function. It gets him the
		// OID tree that spans all the modules fed into the
		// SIMCParseTree, till now.
		const SIMCOidTree *GetOidTree() const
		{
			return &_theTree;
		}
		// A user will rarely use this function. It converts an unclean
		// OID value (SIMCOidValue) (ie, one that has references to symbols)
		// to a clean OID value (SIMCCleanOidValue) (ie, one in which all the
		// components are integer values)
		SIMCResolutionStatus GetCleanOidValue( const char *const filename,
							SIMCOidValue * input,
							SIMCCleanOidValue& result,
							BOOL local); 

	
	// Privately used functions, in CheckSemantics()
	// These functions check the various MIB constructs.
	private:
		// Steps thru the symbol table and calls CheckSymbol() on each function
		BOOL CheckModule(SIMCModule *, BOOL);
		// Uses RTTI to check the type of the symbol and calls
		// CheckBuiltInTypeRef() or CheckDefinedTypeRef() or
		// CheckBuiltInValueRef() or CheckDefinedValueRef() or
		// CheckTextualConvention().
		BOOL CheckSymbol(SIMCSymbol **, BOOL);

		// Check type references
		BOOL CheckBuiltInTypeRef(SIMCBuiltInTypeReference *symbol, BOOL);
		BOOL CheckDefinedTypeRef(SIMCDefinedTypeReference *symbol, BOOL);
		BOOL CheckTextualConvention(SIMCTextualConvention *symbol, BOOL local);
		// Check types
		BOOL CheckRangeTypeV0(const char *const fileName,
			SIMCRangeType *rangeType, BOOL);
		BOOL CheckRangeTypeV1(const char *const fileName,
			SIMCRangeType *rangeType, BOOL);
		BOOL CheckRangeTypeV2(const char *const fileName,
			SIMCRangeType *rangeType, BOOL);
		BOOL CheckRangeRange(const SIMCRangeList *baseList);
		BOOL CheckSizeTypeV1(const char *const fileName,
			SIMCSizeType *sizeType, BOOL);
		BOOL CheckSizeTypeV0(const char *const fileName,
			SIMCSizeType *sizeType, BOOL);
		BOOL CheckSizeTypeV2(const char *const fileName,
			SIMCSizeType *sizeType, BOOL);
		BOOL CheckEnumTypeV0(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL);
		BOOL CheckEnumTypeV1(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL);
		BOOL CheckEnumTypeV2(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL);
		BOOL CheckBitsTypeV2(const char *const fileName,
			SIMCEnumOrBitsType *bitsType, BOOL local);
		BOOL CheckSequenceOfType(const char *const fileName,
			SIMCSequenceOfType *sequenceOfType, BOOL);
		BOOL CheckSequenceType(const char *const fileName,
			SIMCSequenceType *sequenceType, BOOL);
		BOOL CheckTrapType(const char *const fileName,
			SIMCTrapTypeType *trapType, BOOL);
		BOOL CheckNotificationType(const char *const fileName,
			SIMCNotificationTypeType *notificationType, BOOL);
		BOOL CheckObjectIdentityType(const char *const fileName, 
			SIMCObjectIdentityType *rhs, BOOL local);
		BOOL CheckObjectTypeV1(const char *const fileName,
			SIMCObjectTypeV1 *objectType, BOOL);
		BOOL CheckObjectTypeV2(const char *const fileName,
			SIMCObjectTypeV2 *objectType, BOOL);
		BOOL CheckObjectTypeV1Syntax(const char *const fileName,
			SIMCObjectTypeV1 *objectType, BOOL local);
		BOOL CheckObjectTypeV2Syntax(const char *const fileName,
			SIMCObjectTypeV2 *objectType, BOOL local);
		BOOL CheckObjectTypeV1Index(const char *const fileName,
			SIMCSymbol *objectTypeSymbol,
			SIMCObjectTypeV1 *objectType, BOOL local);
		BOOL CheckObjectTypeV2Index(const char *const fileName,
			SIMCSymbol *objectTypeSymbol,
			SIMCObjectTypeV2 *objectType, BOOL local);
		BOOL CheckObjectTypeDefVal(const char *const fileName,
			SIMCObjectTypeType *objectType, BOOL local);


		// Check value references
		BOOL CheckBuiltInValueRef(SIMCBuiltInValueReference *symbol, BOOL);
		BOOL CheckDefinedValueRef(SIMCDefinedValueReference *symbol, BOOL);
		
		BOOL CheckObjectTypeValueAssignmentV1(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCObjectTypeV1 *objectType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckObjectTypeValueAssignmentV2(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCObjectTypeV2 *objectType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckTrapTypeValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCTrapTypeType *trapType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckNotificationTypeValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCNotificationTypeType *notificationType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckObjectIdentityValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef, 
										SIMCBuiltInTypeReference *btRef,
										SIMCObjectIdentityType *type, 
										SIMCValue *value, 
										BOOL local);
		BOOL CheckEnumValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCEnumOrBitsType *enumType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckSubTypeValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef,
										SIMCBuiltInTypeReference *btRef,
										SIMCSubType *subType,
										SIMCValue *value,
										BOOL local);
		BOOL CheckPrimitiveValueAssignment(const char * const fileName, 
										SIMCBuiltInValueReference *bvRef, 
										SIMCTypeReference *btRef,
										SIMCValue *value, 
										BOOL local);
		BOOL CheckBitsTypeValueAssignment(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCEnumOrBitsType *bitsType,
								SIMCValue *value, 
								BOOL local);

		BOOL MatchSequenceObjectTypeSyntax(const char *const fileName,
					SIMCObjectTypeType *objectType, 
					SIMCTypeReference *typeRef,
					SIMCSequenceItem *item,
					BOOL local);
	
		BOOL CheckObjectSequenceItem( const char *const fileName,
								SIMCSequenceItem * item, 
								SIMCValueReference *parentObjectType,
								BOOL local);
		BOOL CheckObjectSequenceOfTypeV1(const char *const fileName,
								SIMCObjectTypeV1 *objType,
								SIMCSequenceOfType *sequenceOfType, 
								BOOL local);
		BOOL CheckObjectSequenceOfTypeV2(const char *const fileName,
								SIMCObjectTypeV2 *objType,
								SIMCSequenceOfType *sequenceOfType, 
								BOOL local);
		BOOL CheckObjectSequenceTypeV1(const char *const fileName,
								SIMCObjectTypeV1 *objType,
								SIMCSequenceType *sequenceType, 
								BOOL local);
		BOOL CheckObjectSequenceTypeV2(const char *const fileName,
								SIMCObjectTypeV2 *objType,
								SIMCSequenceType *sequenceType, 
								BOOL local);


		// Build the OID tree for all the modules.
		// Calls BuildModuleOidTree() on each module
		BOOL BuildOidTree(BOOL local);
		// Builds OID tree for a module
		BOOL BuildModuleOidTree(SIMCModule *m, BOOL);
		// Makes Semantic checks on the OID tree.
		BOOL CheckOidTree(BOOL local);
 
		// Converts TRAP-TYPEs, if any to NOTIFICATION-TYPES
		// Then fabricates NOTIFICATION-GROUPs from NOTIFICATION-TYPEs
		BOOL FabricateNotificationGroups();

		// The recursive routine called by GetCleanOidValue()
		SIMCResolutionStatus GetCleanOidValueRec( const char *const fileName,
								SIMCOidValue * input,
								SIMCCleanOidValue& result,
								BOOL local,
								SIMCSymbolList& checkedList); 
	

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\smierrsm.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smierrsm.rc
//
#define OBJ_TYPE_SYNTAX_RESOLUTION      1
#define OBJ_TYPE_INVALID_ACCESS         2
#define OBJ_TYPE_INVALID_STATUS         3
#define OBJ_TYPE_SINGULAR_COUNTER       4
#define OBJ_TYPE_ACCESSIBLE_TABLE       5
#define OBJ_TYPE_SEQUENCE_NO_INDEX      6
#define OBJ_TYPE_SEQUENCE_MULTI_REFERENCE 7
#define OBJ_TYPE_SEQUENCE_UNUSED        8
#define SEQUENCE_WRONG_CHILD            9
#define OBJ_TYPE_WRONG_CHILD            10
#define OBJ_TYPE_SEQUENCE_INVALID_SYNTAX 11
#define OBJ_TYPE_INDEX_UNNECESSARY      12
#define INVALID_SEQUENCE_OF             13
#define OBJ_TYPE_ZERO_IN_OID            14
#define ZERO_IN_OID                     14
#define OBJ_TYPE_DUPLICATE_OID          15
#define OBJ_TYPE_INVALID_DEFVAL         16
#define OBJ_TYPE_OID_RESOLUTION         17
#define TRAP_TYPE_ENTERPRISE_RESOLUTION 18
#define TRAP_TYPE_DUPLICATE_VALUES      19
#define TRAP_TYPE_VALUE_RESOLUTION      20
#define TRAP_TYPE_VARIABLES_RESOLUTION  21
#define VALUE_ASSIGN_MISMATCH           22
#define VALUE_ASSIGN_RESOLUTION         23
#define OID_NEGATIVE_INTEGER            24
#define OID_RESOLUTION                  25
#define OID_HEAD_ERROR                  26
#define IMPORT_UNUSED                   27
#define IMPORT_MODULE_ABSENT            28
#define IMPORT_CURRENT                  29
#define IMPORT_SYMBOL_ABSENT            30
#define IMPORT_KNOWN_WRONG_MODULE       31
#define ENUM_DUPLICATE_VALUE            32
#define ENUM_DUPLICATE_NAME             33
#define ENUM_ZERO_VALUE                 34
#define ENUM_NEGATIVE_VALUE             35
#define ENUM_RESOLUTION                 36
#define SIZE_TYPE_RESOLUTION            37
#define RANGE_TYPE_RESOLUTION           38
#define SIZE_INVALID_VALUE              39
#define SIZE_VALUE_RESOLUTION           40
#define RANGE_VALUE_RESOLUTION          41
#define RANGE_INVALID_BOUNDS            42
#define OBJ_TYPE_ACCESSIBLE_ROW         43
#define SYMBOL_REDEFINITION             44
#define KNOWN_REDEFINITION              45
#define KNOWN_UNDEFINED                 46
#define TYPE_UNREFERENCED               47
#define VALUE_UNREFERENCED              48
#define OBJ_TYPE_DEFVAL_NET_ADDR        49
#define SYMBOL_UNDEFINED                50
#define IMPORT_AMBIGUOUS_REFERENCE      51
#define OBJ_TYPE_DEFVAL_DISALLOWED      52
#define OBJ_TYPE_DEFVAL_RESOLUTION      53
#define OBJ_TYPE_INDEX_RESOLUTION       54
#define OBJ_TYPE_INDEX_SYNTAX           55
#define TYPE_UNRESOLVED                 56
#define VALUE_UNRESOLVED                57
#define SUBTYPE_ROOT_RESOLUTION         58
#define VALUE_ASSIGN_INVALID            60
#define RANGE_NEGATIVE_GAUGE            62
#define SIZE_INVALID_BOUNDS             63
#define SEQUENCE_ITEM_NO_OBJECT         64
#define SEQUENCE_TYPE_UNRESOLVED        65
#define INTEGER_TOO_BIG                 66
#define VALUE_ASSIGN_ENUM_INVALID       68
#define VALUE_ASSIGN_NEGATIVE_INTEGER   69
#define IR_MODULE_MISSING               70
#define IR_MODULE_MISSING_FATAL         70
#define IR_SYMBOL_MISSING               71
#define IR_SYMBOL_MISSING_FATAL         71
#define OBJ_TYPE_PRIMITIVE_CHILD        72
#define OBJ_TYPE_SEQUENCE_CHILD         73
#define OBJ_TYPE_SEQUENCE_NO_PARENT     74
#define OBJ_TYPE_SEQUENCE_EXTRA_CHILD   75
#define OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD 76
#define OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH 77
#define OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD 78
#define STANDARD_AMBIGUOUS_REFERENCE    79
#define IR_MODULE_MISSING_WARNING       80
#define IR_SYMBOL_MISSING_WARNING       81
#define OBJ_IDENTITY_INVALID_STATUS     82
#define MODULE_NO_GROUPS                83
#define MODULE_IDENTITY_MISSING         84
#define MODULE_NO_GROUPS_V1             85
#define MODULE_NO_GROUPS_V2             86
#define TC_INVALID_STATUS               87
#define INVALID_BIT_VALUE               88
#define AUGMENTS_CLAUSE_RESOLUTION      89
#define IMPLIED_USELESS                 90
#define IMPLIED_FIXED_SIZE              91
#define IMPLIED_POSSIBLE_ZERO_SIZE      92
#define V1_ENUM_ONLY_INTEGER            93
#define V2_ENUM_ROOT_RESOLUTION         94
#define V2_ENUM_CLOSURE                 95
#define V2_BITS_ROOT_RESOLUTION         96
#define BITS_VALUE_RESOLUTION           97
#define BITS_DUPLICATE_VALUE            98
#define BITS_DUPLICATE_NAME             99
#define ENUM_OR_BITS_RESOLUTION         100
#define RANGE_BIG_RANGE                 101
#define NOTIFICATION_TYPE_INVALID_STATUS 102
#define OBJECT_IDENTITY_VALUE_RESOLUTION 103
#define NOTIFICATION_TYPE_VALUE_RESOLUTION 104
#define NOTIFICATION_TYPE_OBJECTS_RESOLUTION 105
#define NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT 106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\scanner.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_SCANNER_H
#define SIMC_SCANNER_H 

class SIMCParser;

/*
 * This is the SIMCScanner class that forms the scanner (tokenizer)
 * used by the SIMCParser class, which is the parser. The SIMCScanner
 * class is derived form the yy_scan class that is generated by the 
 * MKS LEX utility from the information in the lex.l file.
 *
 * It adds functionality to it, like column numbers, naming the
 * input stream, and redefining yyerror().
 */
class SIMCScanner : public yy_scan
{
		CString _inputStreamName;

		// The parser that is making use of this scanner currently.
		// This value *has* to be set by the parser, if it makes
		// a call to yy_scan::yyerror, since this value is used there
		SIMCParser *_theParser;
	public:

		// Create s scanner, by specifying a parser. If this is specified
		// as null, it has to be set using the SetParser() function, before
		// it is used
		SIMCScanner(SIMCParser * parser = NULL);
		~SIMCScanner();

		// Various ways of setting the input that is scanned. This is used as
		// the source. NOTE: Only the second one has been tested (ie., the
		// one that specifies an input file name
		BOOL SetInput(ifstream& inputStream);
		BOOL SetInput(const CString& inputFile);
		BOOL SetInput(const int fd = 0);
		BOOL SetInput(FILE * fileStream);
		
		// Column number. Make it public, as is the LEX tradition
		long columnNo;
		virtual void output(int);

		// Sets the parse that uses this scanner currently
		void SetParser(SIMCParser *parser)
		{
			_theParser = parser;
		}
		SIMCParser *GetParser() const
		{
			return _theParser;
		}

		// The redefinition of yy_scan.yyerror() to suit our needs
		// of error reporting
		virtual void yyerror (char *fmt, ...);

		inline const char * const GetInputStreamName() const
		{
			return _inputStreamName;
		}
		void SetInputStreamName( const CString& streamName);
};
	

#endif SIMC_SCANNER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\parser.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_PARSER_H
#define SIMC_PARSER_H


/* This file contains the SIMCParse class, which is the parsing engine
 * for parsing MIB files, and it works with the SIMCScanner class, which
 * is the tokenizing engine
 */


/* 
 * The SIMCParser class is derived form the yy_parse class that is
 * generated by the MKS YACC utility, using the information
 * provided in the yacc.y file. This uses the class SIMCScanner as its
 * scanner. SIMCScanner is derived form the class yy_scan that is generated
 * by the MKS LEX utility, using the information provided by the lex.l
 * file.
 * This uses 2 dlls "smierrsy.dll" and "smierrsm.dll" to hold the
 * strings that represent the syntax errors and semantic errors
 * respectively.
 * It uses an SIMCErrorContainer object to put the error messages, it
 * generates.
 * It put the parse information generated for a single parse, info
 * an SIMCModule object.
 * It "knows" about the commonly occuring SMI symbols, like "ip",
 * "transmission" etc., as defined in the "compiler requirements spec".
 */

class SIMCParser : public yy_parse
{
	
	// The size of the buffer used to construct an error message
	static const int MESSAGE_SIZE;

	// The lowest syntax error Id
	static const int SYNTAX_ERROR_BASE;

	// The lowest parser semantic error Id
	static const int SEMANTIC_ERROR_BASE;

	// The text for the various severity levels enumerated by 
	// enum severityLevel
	static const char * const severityLevels[];

	// The place to put the error messages
	SIMCErrorContainer *_errorContainer;	

	// The information collected from the module
	SIMCModule * _module;

	// The flag that is used to decide whether to parse the next module as
	// a V1 or a V2 one. Used by Parse()
	int _snmpVersion;

	// Used to set those pesky references that are initially beleived to be forward
	// references, but actually are references to imported symbols.
	BOOL SetImportSymbols();

	// A count of errors, for each call of Parse()
	long _fatalCount, _warningCount, _informationCount;

	public:

		// The resource-only dll with parser error text string table
		static  HINSTANCE semanticErrorsDll;

		// The resource-only dll with syntax error text string table
		static  HINSTANCE syntaxErrorsDll;

 
		// You always need an error container and a scanner, to parse
		SIMCParser(SIMCErrorContainer * errorContainer, SIMCScanner * scanner);
		
		virtual ~SIMCParser();


 		// The names of the dlls
		static const char * const semanticErrorsDllFile;
		static const char * const syntaxErrorsDllFile;


		// The scanner associated with this parser
		SIMCScanner *_theScanner;

		// ---------------- The symbols known by the parser ---------------------
		SIMCModule	*other,		// Modules common to V1 and V2
					*rfc1155,	// These are V1 only
					*rfc1213, 
					*rfc1212, 
					*rfc1215, 
					*rfc1230, 
					*rfc1902,	// These are V2 only
					*rfc1903,
					*rfc1904,
					*rfc1906;

		SIMCSymbol	**objectIdentifierType,  // These are primitive ASN.1 types 
					**integerType, 
					**octetStringType,
					**nullType, 
					**bitsType, 
					**booleanType;

		SIMCSymbol							// These are V1 OIDs
					**isoV1, 				
					**ccittV1, 
					**jointIsoCcittV1,
					**internetV1, 
					**directoryV1, 
					**mgmtV1, 
					**experimentalV1,
					**privateV1, 
					**enterprisesV1, 
					**mib2V1, 
					**ipV1, 
					**interfacesV1,
					**transmissionV1,
					**zeroDotZeroV2,
					**orgV2,				// These are V2 OIDs
					**dodV2,
					**internetV2,
					**directoryV2,
					**mgmtV2,
					**mib2V2,
					**ipV2,
					**interfacesV2,
					**transmissionV2,
					**experimentalV2,
					**privateV2,
					**enterprisesV2,
					**securityV2,
					**snmpV2V2,
					**snmpDomainsV2,
					**snmpProxysV2,
					**snmpModulesV2,
					**snmpUDPDomainV2,
					**snmpCLNSDomainV2,
					**snmpCONSDomainV2,
					**snmpDDPDomainV2,
					**snmpIPXDomainV2,
					**rfc1157DomainV2,
					**rfc1157ProxyV2;

		SIMCSymbol	**trueValueReference,  // Some values 
					**falseValueReference, 
					**nullValueReference;
		
		// Symbols for the severity levels of the messages
		enum SeverityLevel
		{
			INVALID,
			FATAL,
			WARNING,
			INFORMATION
		};
		
		// Manipulate the SNMP version of this parser. Parsing is done based
		// on this value, as follows
		// 1 - SNMPv2 SMI
		// 2 - SNMPv2 SMI
		// 0 - Union of V1 and V2 SMIs
		int GetSnmpVersion() const
		{
			return _snmpVersion;
		}
		BOOL SetSnmpVersion( int x )
		{
			switch(x)
			{
				case 0:		// '0' means union of v1 and v2 SMIs
				case 1:
				case 2:
					_snmpVersion = x;
					return TRUE;
				default:
					_snmpVersion = 0;
					return FALSE;
			}
		}

		/*
		 * The main parsing function that is called by the user
		 * Return TRUE if the parse is successful. The GetModule() function
		 * may then be called to retrieve the parsed information.
		 * It it returns false, check the error container for error
		 * messages
		 */
		BOOL Parse();

		// A function to generate syntax error messages
		void SyntaxError(int errorType, 
			int lineNo = -1, 
			int columnNo = -1,
			char *lastToken = NULL, char *infoString = NULL);

		// Convert severity level to "readable" form
		const char * const GetSeverityString(int severityLevel)
		{
			return severityLevels[severityLevel];
		}

		// A function to generate semantic error messages
		void SemanticError(const char * const fileName, int errorType,
			int lineNo,
			int columnNo,
			...);

		// Get the parsed information, after a successful call to Parse()
		SIMCModule * GetModule() const;

		void SetErrorContainer(SIMCErrorContainer *errorContainer)
		{
			if(errorContainer)
				_errorContainer = errorContainer;
		}
		SIMCErrorContainer * GetErrorContainer() const
		{
			return _errorContainer;
		}
		void SetScanner( SIMCScanner * scanner)
		{
			_theScanner = scanner;
		}

		/*
		 * Utility functions that are used in Parse(), and also
		 * can be used by the user of this class.
		 *
		 */

		// TRUE, if the symbol specified, is viewed as a symbol
		// "known" to the parser, from the module specified, as per
		// SNMPV1 SMI rules
		static BOOL IsReservedSymbolV1(const char *const name,
						const char * const moduleName);
		// Returns the module in which this "known" symbol is defined, as
		// per the SNMPV1 SMI. Return null if the symbol is "unknown"
		const SIMCModule* IsReservedSymbolV1(const char * const symbolName);
		
		// TRUE, if the symbol specified, is viewed as a symbol
		// "known" to the parser, from the module specified, as per
		// SNMPV2 SMI rules
		static BOOL IsReservedSymbolV2(const char *const name,
						const char * const moduleName);
		// Returns the module in which this "known" symbol is defined, as
		// per the SNMPV2 SMI. Return null if the symbol is "unknown"
		const SIMCModule* IsReservedSymbolV2(const char * const symbolName);

		// Another way of using the above functions
		const SIMCModule* IsReservedSymbol(const char * const symbolName);
		BOOL IsReservedSymbol(const char *const name, const char * const moduleName);
		static BOOL IsReservedSymbol(long snmpVersion, const char *const name,
						const char * const moduleName);
	
		// TRUE, if the module specified, is viewed as a module
		// "known" to the parser, as per SNMPV1 SMI rules
		static BOOL IsReservedModuleV1(const char *const name);
		// TRUE, if the module specified, is viewed as a module
		// "known" to the parser, as per SNMPV2 SMI rules
		static BOOL IsReservedModuleV2(const char *const name);
		// Another way of using the above functions
		static BOOL IsReservedModule(long snmpVersion, const char *const name);
	
		// Used in error-tolerance. Never called by the user
		static const char * GetCorrectModuleNames(const char * const symbolName);

		// Helper functions
		void DoImportModule( SIMCModule *mainModule, SIMCModule *importModule);
		void CreateReservedModules();
		void RemoveExtraneousReservedModule(SIMCModule *module);

		// Generate a unique name of the form "*n" for an anonymnous symbol.
		// n is an integer
		char * GenerateSymbolName()
		{
			static long n = 1;
			char buf[25];
			buf[0] = '*';
			sprintf(buf+1, "%ld", n++);
			return NewString(buf);
		}
		


		long GetFatalCount() const
		{
			return _fatalCount;
		}
		long GetWarningCount() const
		{
			return _warningCount;
		}
		long GetInformationCount() const
		{
			return _informationCount;
		}


};


#endif // SIMC_PARSER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\smimsgif.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\pandorang\snmpProvider\Compilers\smi2smir\lib\smimsgif\smimsgif.rc
//
#define COMPILED_FILE                   1
#define SYNTAX_CHECK_FAILED             2
#define SEMANTIC_CHECK_FAILED           3
#define SMIR_LOAD_FAILED                4
#define SMIR_LOAD_SUCCEEDED             5
#define SYNTAX_CHECK_SUCCEEDED          6
#define SEMANTIC_CHECK_SUCCEEDED        7
#define SYMBOL_RESOLUTION_FAILED        8
#define SMIR_CONNECT_FAILED             9
#define LISTING_MODULES                 10
#define LISTING_FAILED                  11
#define DELETE_SUCCEEDED                12
#define DELETE_FAILED                   13
#define PURGE_SUCCEEDED                 14
#define PURGE_FAILED                    15
#define DELETE_MODULE_NOT_FOUND         16
#define SMI2SMIR_INFO                   17
#define FILE_NOT_FOUND                  18
#define MODULE_LISTING                  19
#define MOF_GENERATION_SUCCEEDED        20
#define MOF_GENERATION_FAILED           21
#define MODULE_NAME_SUCCEEDED           22
#define MODULE_INFO_FAILED              23
#define NUMBER_OF_ENTRIES               24
#define DUPLICATE_MODULES               25
#define DIRECTORY_ADDITION_SUCCEEDED    26
#define DIRECTORY_ADDITION_FAILED       27
#define DIRECTORY_DELETION_SUCCEEDED    28
#define DIRECTORY_DELETION_FAILED       29
#define INVALID_MIB_FILE                30
#define PURGE_CONFIRMATION              31
#define MODULE_LISTING_NO_MODULES       31
#define LISTING_MIB_PATHS               32
#define LISTING_MIB_PATHS_NONE          33
#define MIB_PATH_LISTING                34

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\smierrsy.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smierrsy.rc
//
#define SYNTAX_CLAUSE                   1
#define ACCESS_CLAUSE                   2
#define STATUS_CLAUSE                   3
#define DESCRIPTION_CLAUSE              4
#define REFERENCE_CLAUSE                5
#define INDEX_CLAUSE                    6
#define DEFVAL_CLAUSE                   7
#define SKIPPING_OBJECT_TYPE            8
#define ENTERPRISE_CLAUSE               9
#define VARIABLES_CLAUSE                10
#define SKIPPING_TRAP_TYPE              11
#define SEQUENCE_DEFINITION             12
#define OBJECT_IDENTIFIER_VALUE         13
#define LIST_IN_IMPORTS                 14
#define MISSING_MODULE_NAME             15
#define IMPORTS_SECTION                 16
#define INTEGER_ENUMERATION             17
#define SUB_TYPE_SPECIFICATION          18
#define SIZE_SPECIFICATION              19
#define V2_OBJECT_TYPE_DISALLOWED       20
#define NOTIFICATION_TYPE_DISALLOWED    22
#define MODULE_IDENTITY_DISALLOWED      23
#define OBJECT_IDENTITY_DISALLOWED      24
#define TEXTUAL_CONVENTION_DISALLOWED   25
#define OBJECT_GROUP_DISALLOWED         26
#define NOTIFICATION_GROUP_DISALLOWED   27
#define MODULE_COMPLIANCE_DISALLOWED    28
#define AGENT_CAPABILITIES_DISALLOWED   29
#define INSTEAD_OF_CCE                  30
#define SYNTAX_ERROR_MAX                31
#define ERROR_OBJECT_TYPE               31
#define SYNTAX_ERROR_MAX1               32
#define MAX_SYNTAX_ERROR                32
#define V1_OBJECT_TYPE_DISALLOWED       32
#define V1_TRAP_TYPE_DISALLOWED         33
#define MODULE_IDENTITY_ONLY_AFTER_IMPORTS 34
#define UNRECOGNIZED_CHARACTER          35
#define TOO_BIG_NUM                     36
#define UNTERMINATED_STRING             37
#define OBJECTS_CLAUSE                  38
#define NAME_INSTEAD_OF_ID              39

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\symbol.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#ifndef SIMC_SYMBOL_H
#define SIMC_SYMBOL_H

// These are the status for objects of classes SIMCDefinedValueReference
// and SIMCDefinedTypeReference
enum SIMCResolutionStatus
{
	RESOLVE_UNSET,		// Haven't resolved it yet
	RESOLVE_UNDEFINED,	// Could not resolve it
	RESOLVE_IMPORT,		// Resolved to IMPORTS
	RESOLVE_CORRECT,		// Resolved properly, to the type expected
	RESOLVE_FALSE		// Resolved properly, but not to the type expected
};


class SIMCModule;

// The base class for all the symbols that can occur in a module.
// It is an abstract class.	See the files "typeRef.hpp" and "valueRef.hpp"
// for classes derived from this
class SIMCSymbol
{
	
	public:
		enum SymbolType 
		{ 	
			PRIMITIVE, 	// Primitive ASN.1 type
			LOCAL, 		// Locally defined in this module
			IMPORTED, 	// From another module. The Internet SMI
						// definitions that the compiler 'knows' about,
						// lie in the IMPORTED category.
			MODULE_NAME
		};
	private:
		// Various charcteristics of a symbol
		char *_symbolName;
		SymbolType _symbolType; 
		SIMCModule *_module; 		// Null for a PRIMITIVE, LOCAL or MODULE_NAME symbol
		long _lineNumber, _columnNumber;
		long _referenceCount;

		// Used in mostly in the destructors of the derived classes.
		// Says whether the _referenceCount value should be uses at all
		BOOL _useReferenceCount;	

	protected:
		SIMCSymbol(const char * const symbolName, 
					SymbolType symbolType = LOCAL,
					SIMCModule *module = NULL,
					long _lineNumber = 0, long _columnNumber = 0,
					long _referenceCount = 0);

		SIMCSymbol(const SIMCSymbol& rhs);
	
	public:
		virtual ~SIMCSymbol();
		BOOL operator == (const SIMCSymbol& rhs) const;

		const char* GetSymbolName() const
		{
			return (_symbolName)? _symbolName : "";
		}

		SymbolType GetSymbolType() const
		{
			return _symbolType;
		}

		SIMCModule *GetModule() const
		{
			return _module;
		}

		long GetLineNumber() const
		{
			return _lineNumber;
		}

		long GetColumnNumber() const
		{
			return _columnNumber;
		}

		void SetLineNumber( long line)
		{
			_lineNumber = line;
		}

		void SetColumnNumber( long col)
		{
			_columnNumber = col;
		}

		BOOL SetSymbolName(const char * name)
		{
			if( _symbolName )
			{
				delete []_symbolName;
				_symbolName = NULL;
			}
			return  (_symbolName = NewString(name)) !=  NULL;
		}
		
		void SetSymbolType ( SymbolType x )
		{
			_symbolType = x;
		}
		void SetModule(SIMCModule * module)
		{
			_module = module;
		}
		
		long GetReferenceCount() const
		{
			return _referenceCount;
		}

		void SetReferenceCount(long refCount)
		{
			/*
			if( _symbolType == PRIMITIVE)
				return;
			*/
			_referenceCount = refCount;
			/*
			if( refCount == 0 )
				delete this;
			*/
		}

		long IncrementReferenceCount()
		{
			return ++_referenceCount;
		}
		
		long DecrementReferenceCount ()
		{
			return --_referenceCount;
		}
		
		void SetUseReferenceCount(BOOL val)
		{
			_useReferenceCount = val;
		}

		BOOL UseReferenceCount() const
		{
			return _useReferenceCount;
		}

		virtual void WriteSymbol(ostream&) const;
		
		friend ostream& operator << (ostream& outStream, const SIMCSymbol& symbol)
		{
			symbol.WriteSymbol(outStream);
			return outStream;
		}

		void WriteBrief(ostream& outStream) const;


};

// A forward-referenced symbol, whose details are
// not known presently
class SIMCUnknown : public SIMCSymbol
{

	public:
		SIMCUnknown(const char * const symbolName, 
					SymbolType symbolType = LOCAL,
					SIMCModule *module = NULL,
					long _lineNumber = 0, long _columnNumber = 0,
					long _referenceCount = 0)
					: SIMCSymbol( symbolName, symbolType,module, 
					 _lineNumber,  _columnNumber, _referenceCount)
		{}
		
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "UNKNOWN " ;
			SIMCSymbol::WriteSymbol(outStream);
		}

};

// An imported symbol, whose details are
// not known presently
class SIMCImport : public SIMCSymbol
{

	public:
		SIMCImport(const char * const symbolName, 
					SymbolType symbolType = LOCAL,
					SIMCModule *module = NULL,
					long _lineNumber = 0, long _columnNumber = 0,
					long _referenceCount = 0)
					: SIMCSymbol( symbolName, symbolType,module, 
					 _lineNumber,  _columnNumber, _referenceCount)
		{}
		
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "IMPORT " ;
			SIMCSymbol::WriteSymbol(outStream);
		}

};

#endif // SIMC_SYMBOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\traptype.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef TRAP_TYPE_TYPE
#define TRAP_TYPE_TYPE

/*
 * This file contains the class that models the TRAP-TYPE macro
 * and other associated classes
 */

// Each of the variables in the VARIABLES clause
class SIMCVariablesItem
{
	public:
		SIMCSymbol **_item;
		long _line, _column;
		SIMCVariablesItem( SIMCSymbol **item, long line, long column)
			: _item(item), _line(line), _column(column)
		{}
};

// A list of items in the VARIABLES clause
typedef  CList<SIMCVariablesItem *, SIMCVariablesItem *> SIMCVariablesList;

/*
 * This class models the TRAP-TYPE macro of SNMPV1 SMI. 
 */
class SIMCTrapTypeType : public SIMCType
{
		// The various clauses of the TRAP-TYPE macro
		SIMCSymbol ** _enterprise;
		long _enterpriseLine, _enterpriseColumn;
		SIMCVariablesList *_variables;
		char * _description;
		long _descriptionLine, _descriptionColumn;
		char *_reference;
		long _referenceLine, _referenceColumn;

	public:
		SIMCTrapTypeType( SIMCSymbol **enterprise,
							long enterpriseLine, long enterpriseColumn,
							SIMCVariablesList *variables,
							char * description,
							long descriptionLine, long descriptionColumn,
							char *reference,
							long referenceLine, long referenceColumn);

		~SIMCTrapTypeType();

		SIMCSymbol ** GetEnterprise() const
		{
			return _enterprise;
		}
		SIMCVariablesList* GetVariables() const
		{
			return _variables;
		}
		char *GetDescription() const
		{
			return _description;
		}
		char *GetReference() const
		{
			return _reference;
		}

		virtual void WriteType(ostream& outStream) const;
		
		long GetEnterpriseLine() const
		{
			return _enterpriseLine;
		}

		void SetEnterpriseLine( long x) 
		{
			_enterpriseLine = x;
		}

		long GetEnterpriseColumn() const
		{
			return _enterpriseColumn;
		}

		void SetEnterpriseColumn( long x) 
		{
			_enterpriseColumn = x;
		}

		long GetDescriptionLine() const
		{
			return _descriptionLine;
		}

		void SetDescriptionLine( long x) 
		{
			_descriptionLine = x;
		}

		long GetDescriptionColumn() const
		{
			return _descriptionColumn;
		}

		void SetDescriptionColumn( long x) 
		{
			_descriptionColumn = x;
		}

		long GetReferenceLine() const
		{
			return _referenceLine;
		}

		void SetReferenceLine( long x) 
		{
			_referenceLine = x;
		}

		long GetReferenceColumn() const
		{
			return _referenceColumn;
		}

		void SetReferenceColumn( long x) 
		{
			_referenceColumn = x;
		}


};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\stackvalues.hpp ===
//
//	Copyright (c) 1997-2001 Microsoft Corporation
//
#ifndef SIMC_STACK_VALUES_H
#define SIMC_STACK_VALUES_H

// The declarations for the various values passed up using the stack
// of the parser. A user of the parser never needs to understand the contents
// of this file.

// The $$ for the DefVal clause. This is a bit of a kludge.
class SIMCDefValInfo
{
	public:
		char *name;
		SIMCSymbol **symbol;
		long line, column;
		SIMCDefValInfo(char *n, SIMCSymbol **s, long l, long c)
			: symbol(s), line(l), column(c)
		{
			name = NewString(n);
		}
		~SIMCDefValInfo()
		{
			if(name)
				delete name;
		}
};

class SIMCIndexInfo
{
	public:
		SIMCIndexList *indexList;
		long line, column;
		SIMCIndexInfo(SIMCIndexList *list, long l, long c)
			: indexList(list), line(l), column(c)
		{}
};

class SIMCIndexInfoV2
{
	public:
		SIMCIndexListV2 *indexList;
		SIMCSymbol **augmentsClause;
		long line, column;
		SIMCIndexInfoV2(SIMCIndexListV2 *list, long l, long c, SIMCSymbol **augments = NULL)
			: indexList(list), line(l), column(c), augmentsClause(augments)
		{}
};

class SIMCNameInfo
{
	public:
		char *name;
		long line, column;
		SIMCNameInfo(char *n, long l, long c)
			: line(l), column(c)
		{
			name = NewString(n);
		}

		virtual ~SIMCNameInfo()
		{
			delete(name);
		}
};

class SIMCNumberInfo
{
	public:
		long number;
		BOOL isUnsigned;
		long line, column;
		SIMCNumberInfo(long n, long l, long c, BOOL u)
			: number(n), line(l), column(c), isUnsigned(u)
		{}

};

class SIMCHexStringInfo
{
	public:
		char *value;
		long line, column;
		SIMCHexStringInfo(char *v, long l, long c)
			: line(l), column(c)
		{
			value = NewString(v);
		}

		virtual ~SIMCHexStringInfo()
		{
			delete(value);
		}
};

typedef SIMCHexStringInfo SIMCBinaryStringInfo;


enum SIMCValueContents {	NAME_INFO, 
							NUMBER_INFO, 
							HEX_STRING_INFO, 
							BINARY_STRING_INFO,
							BIT_INFO
						};

class SIMCValueInfo
{
	public:
		enum SIMCValueContents contents;
		union
		{
			SIMCNameInfo *nameInfo;
			SIMCNumberInfo *numberInfo;
			SIMCHexStringInfo *hexStringInfo;
			SIMCBinaryStringInfo *binaryStringInfo;
			SIMCBitsValue *bitsValueInfo;
		};
};


class SIMCAccessInfo
{
	public:
		SIMCObjectTypeV1::AccessType a;
		long line, column;
		SIMCAccessInfo(SIMCObjectTypeV1::AccessType n, long l, long c)
			: a(n), line(l), column(c)
		{}

};

class SIMCAccessInfoV2
{
	public:
		SIMCObjectTypeV2::AccessType a;
		long line, column;
		SIMCAccessInfoV2(SIMCObjectTypeV2::AccessType n, long l, long c)
			: a(n), line(l), column(c)
		{}

};

class SIMCStatusInfo
{
	public:
		SIMCObjectTypeV1::StatusType a;
		long line, column;
		SIMCStatusInfo(SIMCObjectTypeV1::StatusType n, long l, long c)
			: a(n), line(l), column(c)
		{}

};

class SIMCStatusInfoV2
{
	public:
		SIMCObjectTypeV2::StatusType a;
		long line, column;
		SIMCStatusInfoV2(SIMCObjectTypeV2::StatusType n, long l, long c)
			: a(n), line(l), column(c)
		{}

};

class SIMCObjectIdentityStatusInfo
{
	public:
		SIMCObjectIdentityType::StatusType a;
		long line, column;
		SIMCObjectIdentityStatusInfo(SIMCObjectIdentityType::StatusType n, 
			long l, long c)
			: a(n), line(l), column(c)
		{}
};

class SIMCNotificationTypeStatusInfo
{
	public:
		SIMCNotificationTypeType::StatusType a;
		long line, column;
		SIMCNotificationTypeStatusInfo(SIMCNotificationTypeType::StatusType n, 
			long l, long c)
			: a(n), line(l), column(c)
		{}
};

class SIMCSymbolReference
{
	public:
		SIMCSymbol  **s;
		long line, column;
		SIMCSymbolReference(SIMCSymbol **n, long l, long c)
			: s(n), line(l), column(c)
		{}

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\typeref.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_TYPE_REFERENCE
#define SIMC_TYPE_REFERENCE

/*
 * This file contains classes  that model symbols that result from
 * a type assignement, or a TEXTUAL-CONVENTION definition. 
 * Refer to the "Compiler Design Spec" for more  detailed definitions
 * of a "defined type reference" and a "built-in type reference"
 * A defined type reference is caused by a type assignment statement
 * in which the RHS is just another symbol. A built-in type reference is
 * caused by a type assignment statement in which the RHS is a new type
 * constructed using sub-typing, enum or BITS constructs, SEQUENCE or SEQUENCE OF
 * constructs. 
 */


/* This is the base class for a defined or a built-in type reference
 * All type references are symbols. Hence this class is derived from 
 * SIMCSymbol
 */
class SIMCTypeReference : public SIMCSymbol
{
	protected:
		SIMCTypeReference(const char * const symbolName, 
					SymbolType symbolType = LOCAL,
					SIMCModule *module = NULL,
					long _lineNumber = 0, long _columnNumber = 0,
					long _referenceCount = 0)
					: SIMCSymbol(symbolName, symbolType, module, 
						_lineNumber, _columnNumber, _referenceCount)
		{}


		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "TYPE REFERENCE " ;
			SIMCSymbol::WriteSymbol( outStream);
		}


};



/* This class models a built-in type reference. So, it has a pointer
 * to the SIMCType object that resulted in this type reference
 */
class SIMCBuiltInTypeReference : public SIMCTypeReference
{
		
		SIMCType *_type;

	public:
		SIMCBuiltInTypeReference (SIMCType *type, 
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0)
			:  _type(type),
			SIMCTypeReference(symbolName, symbolType, module, 
				lineNumber, columnNumber, referenceCount)
		{}

		~SIMCBuiltInTypeReference()
		{
			delete _type;
		}

		SIMCType * GetType() const
		{
			return _type;
		}
		
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "BuiltinTypeReference " ;
			SIMCSymbol::WriteSymbol(outStream);

			outStream << "TYPE DETAILS "  << endl;
			outStream << (*_type) << endl;
			
		}
};


/* This class models a defined type reference, and hence has a pointer
 * to another symbol that was used in creating this defined type reference
 */
class SIMCDefinedTypeReference : public SIMCTypeReference
{
		// The symbol that was used to create this type reference
		SIMCSymbol ** _type;
		long _typeLine, _typeColumn;

		// the _type symbol itself may be another defined type reference
		// All defined type references have to finally end on a built-in
		// type reference. _realType is that type reference
		SIMCTypeReference *_realType;

		// What happened when an attempt was made to set _realType
		SIMCResolutionStatus _status;

	public:
		SIMCDefinedTypeReference (SIMCSymbol **type,
			long typeLine, long typeColumn,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0)
			:  _type(type), _typeLine(typeLine), _typeColumn(typeColumn),
				_realType(NULL), _status(RESOLVE_UNSET),
				SIMCTypeReference( symbolName, symbolType, module, 
					lineNumber, columnNumber, referenceCount)
		{
			if(_type)
				(*_type)->IncrementReferenceCount();
		}

		virtual ~SIMCDefinedTypeReference()
		{
			if(UseReferenceCount() && _type) 
				(*_type)->DecrementReferenceCount();
		}

		SIMCSymbol ** GetTypeReference() const
		{
			return _type;
		}
		
		SIMCTypeReference *GetRealType() const
		{
			return _realType;
		}

		void SetRealType(SIMCTypeReference *type)
		{
			_realType = type;
		}

		SIMCResolutionStatus GetStatus() const
		{
			return _status;
		}

		void SetStatus( SIMCResolutionStatus val)
		{
			_status = val;
		}
		long GetTypeLine() const
		{
			return _typeLine;
		}

		void SetTypeLine( long x) 
		{
			_typeLine = x;
		}

		long GetTypeColumn() const
		{
			return _typeColumn;
		}

		void SetTypeColumn( long x) 
		{
			_typeColumn = x;
		}
		

		virtual void WriteSymbol( ostream& outStream ) const;

};

typedef CList<SIMCDefinedTypeReference *, SIMCDefinedTypeReference *> SIMCDefinedTypeReferenceList;

/*
 * A TEXTUAL-CONVENTION macro is considered as a defined type reference
 * with extra clauses
 */
class SIMCTextualConvention : public SIMCDefinedTypeReference
{

	public:
		enum SIMCTCStatusType
		{
			TC_INVALID,
			TC_CURRENT,
			TC_DEPRECATED,
			TC_OBSOLETE
		};

	private:
		// Various clauses of the TEXTUAL-CONVENTION macro
		char * _displayHint;
		SIMCTCStatusType _status;
		long _statusLine;
		long _statusColumn;
		char * _description;
		char * _reference;

	public:
	   SIMCTextualConvention(const char * const displayHint,
			SIMCTCStatusType status,
			long statusLine, long statusColumn,
			const char * const description,
			const char * const reference,
			SIMCSymbol **type,
			long typeLine, long typeColumn,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0);

		virtual ~SIMCTextualConvention()
		{
			delete _displayHint;
			delete _description;
			delete _reference;
		}

		const char * GetDisplayHint() const
		{
			return _displayHint;
		}
		void SetDisplayHint(const char * const displayHint)
		{
			delete _displayHint;
			_displayHint = NewString(displayHint);
		}

		const char * GetDescription() const
		{
			return _description;
		}
		void SetDescription(const char * const description)
		{
			delete _description;
			_description = NewString(description);
		}

		const char * GetReference() const
		{
			return _reference;
		}
		void SetReference(const char * const reference)
		{
			delete _reference;
			_reference = NewString(reference);
		}

		SIMCTCStatusType GetStatus() const
		{
			return _status;
		}
		void SetStatus(SIMCTCStatusType status)
		{
			_status = status;
		}

		long GetStatusLine() const
		{
			return _statusLine;
		}

		void SetStatusLine(long x) 
		{
			_statusLine = x;
		}

		long GetStatusColumn() const
		{
			return _statusColumn;
		}

		void SetStatusColumn(long x) 
		{
			_statusColumn = x;
		}

		static SIMCTCStatusType StringToStatusType (const char * const s);


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\type.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_TYPE
#define SIMC_TYPE


/* This file contain the various classes that model some of the types that
* can occur in a MIB. These include :
*
*	SIMCPrimitiveType (INTEGER, OCTET STRING, OID, NULL etc)
*	SIMCRangeType
*	SIMCSizeType
*	SIMCEnumOrBitsType
*	SIMCSequenceType
*	SIMCSequenceOfType
*
*
*	The base class for all these types is the SIMCType class.
*	Some classes such as SIMCObjectTypeType, SIMCTrapTypeType are
*	declared in other files since they are considerably big.
*/



/*
 * This is the base class of all the types that can be defined in a
 * MIB.
 */
class SIMCType
{
	private:

		// Used mostly in the destructors of the derived classes. Indicates
		// whether the reference count should be considered valid.
		BOOL _useReferenceCount;	

	public:
		SIMCType() { _useReferenceCount = FALSE; }

		friend ostream& operator << (ostream& outStream, const SIMCType& obj)
		{
			obj.WriteType(outStream);
			return outStream;
		}

		void SetUseReferenceCount(BOOL val)
		{
			_useReferenceCount = val;
		}

		BOOL UseReferenceCount() const
		{
			return _useReferenceCount;
		}


		virtual void WriteType(ostream& outStream) const = 0;
		virtual ~SIMCType() {}
};

// INTEGER, OID, OCTET STRING, NULL etc., are instances of this class
class SIMCPrimitiveType : public SIMCType
{
	public:
	void WriteType(ostream& outStream) const
	{
		outStream << "SIMCPrimitiveType" << endl;
	}
};



class SIMCTypeReference;

// A common base class fror range and size subtypes
class SIMCSubType : public SIMCType
{
		// The immediate type used in forming the sub type
		SIMCSymbol ** _type;
		long _typeLine, _typeColumn;
		// The root of the type used in forming the sub type.
		// This has to be an SIMCPrimitiveType
		SIMCTypeReference *_rootType;
		// This is set when the based on whether the _rootType could
		// be determined for the _type
		SIMCResolutionStatus _status;
	
	protected:
		
		SIMCSubType( SIMCSymbol ** type, long typeLine, long typeColumn)
			: _type(type), _rootType(NULL), _status(RESOLVE_UNSET),
				_typeLine(typeLine), _typeColumn(typeColumn)
		{
			(*type)->IncrementReferenceCount();
		}

		virtual ~SIMCSubType()
		{
			if(UseReferenceCount())
				(*_type)->DecrementReferenceCount();
		}	
	public:
		
		SIMCSymbol **GetType() const
		{
			return _type;
		}
		SIMCTypeReference *GetRootType() const
		{
			return _rootType;
		}
		void SetRootType(SIMCTypeReference *root)
		{
			_rootType = root;
		}
		SIMCResolutionStatus GetStatus() const
		{
			return _status;
		}

		void SetStatus( SIMCResolutionStatus val)
		{
			_status = val;
		}

		long GetTypeLine() const
		{
			return _typeLine;
		}

		void SetTypeLine( long x) 
		{
			_typeLine = x;
		}

		long GetTypeColumn() const
		{
			return _typeColumn;
		}

		void SetTypeColumn( long x) 
		{
			_typeColumn = x;
		}
		
};

typedef CList<SIMCSubType *, SIMCSubType *> SIMCSubTypeList;

// Each item in a range or SIZE clause
class SIMCRangeOrSizeItem
{

	public:
		long _lowerBound, _upperBound;
		BOOL _isUnsignedL, _isUnsignedU;
		long _lbLine, _lbColumn, _ubLine, _ubColumn;
		SIMCRangeOrSizeItem(long l, BOOL isUnsignedL,
							long lbLine, long lbColumn,
							long u, BOOL isUnsignedU,
							long ubLine, long ubColumn)
			: _lowerBound(l), _upperBound(u), 
				_isUnsignedL(isUnsignedL), _isUnsignedU(isUnsignedU),
				_lbLine(lbLine), _lbColumn(lbColumn),
				_ubLine(ubLine), _ubColumn(ubColumn)
		{}
		friend ostream& operator << (ostream& outStream, const SIMCRangeOrSizeItem& obj);

};

typedef CList<SIMCRangeOrSizeItem *, SIMCRangeOrSizeItem *> SIMCSizeList;

// The SIZE type
class SIMCSizeType : public SIMCSubType
{
		SIMCSizeList *_listOfSizes;
	public:
		SIMCSizeType( SIMCSymbol **type,
						long typeLine, long typeColumn,
						SIMCSizeList *listOfSizes)
						: _listOfSizes(listOfSizes),
							SIMCSubType(type, typeLine, typeColumn)
		{}

		virtual ~SIMCSizeType();
		
		const SIMCSizeList *GetListOfSizes() const
		{
			return _listOfSizes;
		}
		void WriteType(ostream& outStream) const;
		char * ConvertSizeListToString() const;
		long GetFixedSize() const;
		BOOL IsFixedSize() const;
		long GetMaximumSize() const;
		BOOL IsNotZeroSizeObject() const;
};

typedef CList<SIMCRangeOrSizeItem *, SIMCRangeOrSizeItem *> SIMCRangeList;

// The range type
class SIMCRangeType : public SIMCSubType
{
		SIMCRangeList *_listOfRanges;
	public:
		SIMCRangeType( SIMCSymbol **type,
						long typeLine, long typeColumn,
						SIMCRangeList *listOfRanges)
						: _listOfRanges(listOfRanges),
							SIMCSubType(type, typeLine, typeColumn)
		{}

		virtual ~SIMCRangeType();
		
		const SIMCRangeList *GetListOfRanges() const
		{
			return _listOfRanges;
		}

		void WriteType(ostream& outStream) const;
		char * ConvertRangeListToString() const;
};

// This class represents each item of an ENUM or BITS construct
class SIMCNamedNumberItem
{
	public:
		SIMCSymbol **_value;
		long _valueLine, _valueColumn;
		char *_name;
		long _nameLine, _nameColumn;

		SIMCNamedNumberItem ( SIMCSymbol **value, long valueLine, long valueColumn,
						char *name, long nameLine, long nameColumn)
			: _value(value), _name(NewString(name)), 
				_valueLine(valueLine), _valueColumn(valueColumn), 
				_nameLine(nameLine), _nameColumn(nameColumn)
		{}

		virtual ~SIMCNamedNumberItem()
		{
			if(_name)
				delete [] _name;
		}
};

typedef CList<SIMCNamedNumberItem *, SIMCNamedNumberItem *> SIMCNamedNumberList;

// An ENUM or BITS definition. They're considered the same
class SIMCEnumOrBitsType : public SIMCSubType
{
		SIMCNamedNumberList * _listOfItems;

	public:
		enum EnumOrBitsType
		{
			ENUM_OR_BITS_UNKNOWN,
			ENUM_OR_BITS_IMPORT,
			ENUM_OR_BITS_ENUM,
			ENUM_OR_BITS_BITS
		};

	private:
		EnumOrBitsType	_enumOrBitsType;

	public:
		SIMCEnumOrBitsType (SIMCSymbol **type,
						long typeLine, long typeColumn,
						SIMCNamedNumberList * listOfItems,
						EnumOrBitsType enumOrBitsType);

		~SIMCEnumOrBitsType ();

		EnumOrBitsType GetEnumOrBitsType() const
		{
			return _enumOrBitsType;
		}

		void SetEnumOrBitsType( EnumOrBitsType enumOrBitsType)
		{
			_enumOrBitsType = enumOrBitsType;
		}

		SIMCSymbol **GetValue(const char * const name) const;
		SIMCResolutionStatus GetIdentifier(int x, const char * &retVal) const;

		SIMCNamedNumberList *GetListOfItems() const
		{
			return _listOfItems;
		}

		char * ConvertToString() const;
		BOOL CheckClosure(const SIMCEnumOrBitsType *rhs) const;
		long GetLengthOfLongestName() const;
		void WriteType(ostream& outStream) const
		{
			outStream << "SIMCEnumOrBitsType" << endl;
		}

};



// A type resulting from a SEQUENCE OF construct
class SIMCSequenceOfType : public SIMCType
{
		SIMCSymbol ** _type;
		long _typeLine, _typeColumn;
	public:
		SIMCSequenceOfType( SIMCSymbol ** type, long typeLine, long typeColumn)
			: _type(type), _typeLine(typeLine), _typeColumn(typeColumn)
		{
			if(type)
				(*type)->IncrementReferenceCount();
		}

		~SIMCSequenceOfType()
		{
			if(UseReferenceCount() && _type)
				(*_type)->DecrementReferenceCount();
		}	
		SIMCSymbol **GetType() const
		{
			return _type;
		}
		void WriteType(ostream& outStream) const
		{
			outStream << "SIMCSequenceOfType of ";
			(*_type)->WriteBrief(outStream);
			outStream << endl;
		}

		long GetTypeLine() const
		{
			return _typeLine;
		}

		void SetTypeLine( long x) 
		{
			_typeLine = x;
		}

		long GetTypeColumn() const
		{
			return _typeColumn;
		}

		void SetTypeColumn( long x) 
		{
			_typeColumn = x;
		}

};

// A type resulting form a SEQUENCE construct
class SIMCSequenceItem
{
	public:
		SIMCSymbol **_type;
		long _typeLine, _typeColumn;
		SIMCSymbol **_value;
		long _valueLine, _valueColumn;

		SIMCSequenceItem ( SIMCSymbol **type, long typeLine, long typeColumn,
			SIMCSymbol **value, long valueLine, long valueColumn)
			: _type(type), _typeLine(typeLine), _typeColumn(typeColumn),
			_value(value), _valueLine(valueLine), _valueColumn(valueColumn)
		{}

};

typedef CList<SIMCSequenceItem *, SIMCSequenceItem *> SIMCSequenceList;

class SIMCSequenceType : public SIMCType
{
		SIMCSequenceList * _listOfSequences;
	
	public:
		SIMCSequenceType (SIMCSequenceList * listOfSequences);

		~SIMCSequenceType ();

		SIMCSequenceList *GetListOfSequences() const
		{
			return _listOfSequences;
		}

		void WriteType(ostream& outStream) const
		{
			outStream << "SIMCSequenceType" << endl;
		}
		int GetNumberOfItems() const
		{
			if(_listOfSequences)
				return _listOfSequences->GetCount();
			return 0;
		}

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\ui.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_UI_H
#define SIMC_UI_H



typedef CList<CString, const CString&> SIMCFileList;
typedef CList<CString, const CString&> SIMCPathList;

/*
 * This class has methods for parsing and storing the information
 * in the command-line, used to invoke the SNMP compiler
 */
class SIMCUI
{

public:
	enum CommandArgumentType;

private:
	// Error Messages that can occur on the commandline
	// 1-to-1 correspondence with the symbolic error constants 
	// defined by the enum ErrorMessageSymbol below
	static const char * const commandLineErrors[];
	

	int _snmpVersion;
	BOOL _simcDebug;
	CString _inputFileOrModuleName;
	int _diagnosticLevel;
	long _diagnosticMaximumCount;
	CommandArgumentType _commandArgument;
	BOOL _suppressText;			// Set by the /s switch
	BOOL _classDefinitionsOnly; // Set by the /gc switch
	BOOL _notificationsOnly;	// Set by the /o switch
	BOOL _extendedNotifications;// Set by the /ext switch
	BOOL _notifications	;		// Set by the /t switche
	BOOL _autoRefresh;			// Set by the /auto switch
	BOOL _contextInfo;			// Set by the /c switch
	BOOL _authenticateUser;		// Set by the /u switch
	BOOL _confirmedPurge;		// Set by the /y switch
	// The exe in the command used to invoke the compiler. argv[0]
	CString _applicationName;
	CString _commandLine;
	CString _currentDirectory;
	CString _userName;
	CString _dateAndTime;
	CString _hostName;
	SIMCFileList _subsidiaryFiles;
	SIMCPathList _includePaths;
	CString _authenticationUserName;

	void CheckIncludePaths(int& nextArg, int argc, const char *argv[]);

public:

	// Symbolic constants for the various error messages on the command-line
	enum ErrorMessageSymbol
	{
		ERROR_NONE,
		USAGE,
		INVALID_ARGS,
		MISSING_DIAG_LEVEL,
		WRONG_DIAG_LEVEL,
		MISSING_DIAG_COUNT,
		WRONG_DIAG_COUNT,
		MISSING_FILE_NAME,
		MISSING_COMMAND_ARG,
		MISSING_MODULE_NAME,
		MISSING_INCLUDE_PATH,
		NOTIFICATIONS_ONLY_USELESS,
		INVALID_COMBINATION_OF_SWITCHES,
		INVALID_SWITCH,
		// And a delimiter. No error message corresponds to this.
		// Used to check up whether a symbolic value is within limits
		MAX_COMMAND_LINE_ERROR
	};
	
	// Symbolic constants for the action requested by the user on the module
	enum CommandArgumentType 
	{	
		COMMAND_NONE,
		COMMAND_LOCAL_CHECK,
		COMMAND_EXTERNAL_CHECK,
		COMMAND_ADD,
		COMMAND_SILENT_ADD,
		COMMAND_GENERATE,
		COMMAND_GENERATE_CLASSES_ONLY,
		COMMAND_DELETE,
		COMMAND_PURGE,
		COMMAND_LIST,
		COMMAND_HELP1,
		COMMAND_HELP2,
		COMMAND_MODULE_NAME,
		COMMAND_IMPORTS_INFO,
		COMMAND_REBUILD_TABLE,
		COMMAND_ADD_DIRECTORY,
		COMMAND_DELETE_DIRECTORY_ENTRY,
		COMMAND_LIST_MIB_PATHS,
		COMMAND_MAX
	};


	static CString commandArgumentStrings[COMMAND_MAX];
	static CString	diagnosticLevelSwitch, 
					maxDiagnosticCountSwitch,
					snmpV1VersionSwitch,
					snmpV2VersionSwitch,
					suppressTextSwitch,
					undocumentedDebugSwitch,
					includePathSwitch,
					autoSwitch,
					contextInfoSwitch,
					notificationsSwitch,
					notificationsOnlySwitch,
					extendedNotificationsSwitch,
					yesSwitch;
	
	SIMCUI();
	BOOL ProcessCommandLine(int argc, const char *argv[]);

	void Usage (ErrorMessageSymbol messageSymbol = ERROR_NONE, 
		const char *infoString = NULL, BOOL shouldAbort = TRUE);


	inline int GetSnmpVersion() const { return _snmpVersion; }
	

	// These two functions get/set the main input MIB module
	inline void SetInputFileName(const char * const inputFileName)
	{
		_inputFileOrModuleName = inputFileName;
	}
	inline CString GetInputFileName() const 
	{ 
		return _inputFileOrModuleName; 
	}

	inline CString GetApplicationName() const
	{
		return _applicationName;
	}

	inline CString GetCommandLine() const 
	{ 
		return _commandLine; 
	}

	inline CString GetUserName() const 
	{ 
		return _userName; 
	}

	inline BOOL AuthenticateUser () const 
	{ 
		return _authenticateUser; 
	}

	inline CString GetProcessDirectory() const 
	{ 
		return _currentDirectory; 
	}

	inline CString GetDateAndTime() const 
	{ 
		return _dateAndTime; 
	}

	inline CString GetHostName() const 
	{ 
		return _hostName; 
	}

	inline BOOL ConfirmedPurge()
	{
		return _confirmedPurge;
	}
	// This is set by the undocumented /z switch
	BOOL IsSimcDebug() const
	{
		return _simcDebug;
	}



	// These two set the diagnostic level of the errors generated
	// No symbolic constants here. As specified in the requirements 
	// spec, "diagnosticLevel" can be :
	// 0 - Fatal errors only
	// 1 - Fatal errors and Warnings
	// 2 - Fatal errors, Warnings and Information messages
	inline void SetDiagnosticLevel(const int diagnosticLevel = 0)
	{
		_diagnosticLevel = diagnosticLevel;
	}
	
	inline int GetDiagnosticLevel() const 
	{ 
		return _diagnosticLevel; 
	}
	
	// These two get/set the maximum diagnostic count 
	inline void SetMaxDiagnosticCount(const int diagnosticMaximumCount = INT_MAX)
	{
		_diagnosticMaximumCount = diagnosticMaximumCount;
	}
	inline long GetMaxDiagnosticCount() const 
	{ 
		return _diagnosticMaximumCount; 
	}

	// These two deal with the action to be taken on the main
	// input file.
	inline CommandArgumentType GetCommandArgument() const 
	{
		return _commandArgument;
	}
	inline void SetCommandArgument(CommandArgumentType commandArgument) 
	{
		_commandArgument = commandArgument;
	}

	// These two deal with the /s switch
	inline BOOL SuppressText() const
	{
		return _suppressText;
	}
	inline void SetSuppressText( BOOL suppressText = FALSE)
	{
		_suppressText = suppressText;
	}

	// These two deal with the /auto switch
	inline BOOL AutoRefresh() const
	{
		return _autoRefresh;
	}
	inline void SetAutoRefresh( BOOL autoRefresh = FALSE)
	{
		_autoRefresh = autoRefresh;
	}

	// These two get/set the module specified on the /d switch
	inline CString GetModuleName() const
	{
		return _inputFileOrModuleName;
	}
	inline void SetModuleName( const CString& moduleName)
	{
		_inputFileOrModuleName = moduleName;
	}

	// These two get/set the subsidiary files
	inline const SIMCFileList *GetSubsidiaryFiles() const
	{
		return &_subsidiaryFiles;
	}

	inline void AddSubsidiaryFile( const CString& fileName)
	{
		_subsidiaryFiles.AddTail(fileName);
	}

	// These two get/set the path specified on the /pa and /px switch
	inline CString GetDirectory() const
	{
		return _inputFileOrModuleName;
	}
	inline void SetDirectory( const CString& directory)
	{
		_inputFileOrModuleName = directory;
	}

	// These two get/set the paths specified on the /i switch
	inline const SIMCPathList *GetPaths() const
	{
		return &_includePaths;
	}

	inline void AddPath( const CString& path)
	{
		_includePaths.AddTail(path);
	}

	// This is set by the /gc switch
	inline BOOL ClassDefinitionsOnly() const
	{
		return _classDefinitionsOnly;
	}

	// This is set by the /c switch
	inline BOOL GenerateContextInfo() const
	{
		return _contextInfo;
	}

	// This is set by the /t switch
	inline BOOL DoNotifications() const
	{
		return _notifications;
	}

	// This is set by the /ext switch
	inline BOOL DoExtendedNotifications() const
	{
		return _extendedNotifications;
	}

	// This is set by the /o switch
	inline BOOL DoNotificationsOnly() const
	{
		return _notificationsOnly;
	}

	// This gets the FileVersion resource from the resource of the exe
	CString GetVersionNumber();

	friend ostream& operator << ( ostream&, const SIMCUI&);
};

#endif // SIMC_UI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\errorcontainer.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"


SIMCErrorContainer::SIMCErrorContainer()
{
	_currentMessage = NULL;
}


BOOL SIMCErrorContainer::InsertMessage(const SIMCErrorMessage& newMessage)
{	
	_listOfMessages.AddTail(newMessage);
	return TRUE;
}

void SIMCErrorContainer::MoveToFirstMessage()
{
	_currentMessage = _listOfMessages.GetHeadPosition();
}

int SIMCErrorContainer::GetNextMessage(SIMCErrorMessage& nextMessage)
{
	if (_currentMessage == NULL)
		return FALSE;
	nextMessage =  _listOfMessages.GetNext(_currentMessage);
	return TRUE;
}

ostream& operator << ( ostream& outStream, SIMCErrorContainer& object)
{
	object.MoveToFirstMessage();
	SIMCErrorMessage msg;

	while(object.GetNextMessage(msg))
		outStream << msg;

	return outStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\valueref.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_VALUE_REFERENCE
#define SIMC_VALUE_REFERENCE

/*
 * This file contains classes  that model symbols that result from
 * a value assignement. 
 * Refer to the "Compiler Design Spec" for more  detailed definitions
 * of a "defined value reference" and a "built-in value reference"
 * A defined value reference is caused by a value assignment statement
 * in which the RHS is just another symbol. A built-in value reference is
 * caused by a value assignment statement in which the RHS is a literal 
 * value
 */


/* This is the base class for a defined or a built-in value reference
 * All value references are symbols. Hence this class is derived from 
 * SIMCSymbol. It stores a pointer to a symbol that represents the
 * type of the value
 */
class SIMCValueReference: public SIMCSymbol
{
		SIMCSymbol **_type;
		long _typeLine, _typeColumn;

	protected:
		
		SIMCValueReference (SIMCSymbol **type,
			long typeLine, long typeColumn,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long _lineNumber = 0, long _columnNumber = 0,
			long _referenceCount = 0)
			: _type(type), _typeLine(typeLine), _typeColumn(typeColumn),
			SIMCSymbol( symbolName, symbolType, module, 
				_lineNumber, _columnNumber, _referenceCount)
		{
			if(_type)
				(*_type)->IncrementReferenceCount();
		}

		virtual ~SIMCValueReference ()
		{
			if(UseReferenceCount() && _type)
				(*_type)->DecrementReferenceCount();
		}

	public:	
		SIMCSymbol ** GetTypeReference() const
		{
			return _type;
		}
		const char *GetTypeName() const
		{
			return (*_type)->GetSymbolName();
		}
		long GetTypeLine() const
		{
			return _typeLine;
		}

		void SetTypeLine( long x) 
		{
			_typeLine = x;
		}

		long GetTypeColumn() const
		{
			return _typeColumn;
		}

		void SetTypeColumn( long x) 
		{
			_typeColumn = x;
		}
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "VALUE REFERENCE ";
			SIMCSymbol::WriteSymbol(outStream);
			outStream << endl;
			outStream << "\t TYPE DETAILS ";
			(*_type)->WriteBrief(outStream);
			outStream << endl;
		}
};

/* This class models a built-in value reference. So, it has a pointer
 * to the SIMCValue object that resulted in this value reference
 */

class SIMCBuiltInValueReference : public SIMCValueReference
{
		
		SIMCValue *_value;
		BOOL _isSharedValue; // Set on the basis of the constructor used

	public:
		SIMCBuiltInValueReference (SIMCSymbol **type,
			long typeLine, long typeColumn,
			SIMCValue *value,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long lineNumber = 0, long columnNumber = 0,
			long referenceCount = 0)
			:  _value(value), _isSharedValue(FALSE),
			SIMCValueReference( type, typeLine, typeColumn,
				symbolName, symbolType, module, 
				lineNumber, columnNumber, referenceCount)
		{}

		SIMCBuiltInValueReference(SIMCValueReference *symbol, 
			SIMCBuiltInValueReference *bvRef)
			: _value(bvRef->GetValue()), _isSharedValue(TRUE),
			SIMCValueReference(symbol->GetTypeReference(),
					symbol->GetTypeLine(), symbol->GetTypeColumn(),
					symbol->GetSymbolName(),
					symbol->GetSymbolType(), symbol->GetModule(),
					symbol->GetLineNumber(), symbol->GetColumnNumber(),
					symbol->GetReferenceCount())
		{}


		virtual ~SIMCBuiltInValueReference()
		{
			if(!_isSharedValue)
				delete _value;
		}

		SIMCValue * GetValue() const
		{
			return _value;
		}
		
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "BUILTINVALUE REFERENCE " ;
			SIMCValueReference::WriteSymbol(outStream);


			outStream << "\tVALUE DETAILS" << endl << (*_value) << endl;
		}

};

/* This class models a defined value reference, and hence has a pointer
 * to another symbol that was used in creating this defined value reference
 */
class SIMCDefinedValueReference : public SIMCValueReference
{
		SIMCSymbol ** _value;
		long _valueLine, _valueColumn;
		// the _value symbol itself may be another defined value reference
		// All defined value references have to finally end on a built-in
		// value reference. _realValue is that value reference
		SIMCBuiltInValueReference *_realValue;

		// What happened when an attempt was made to set _realType
		SIMCResolutionStatus _status;

	public:
		SIMCDefinedValueReference (SIMCSymbol **type,
			long typeLine, long typeColumn,
			SIMCSymbol  **value,
			long valueLine, long valueColumn,
			const char * const symbolName, 
			SymbolType symbolType = LOCAL,
			SIMCModule *module = NULL,
			long _lineNumber = 0, long _columnNumber = 0,
			long _referenceCount = 0)
			:  _value(value), _valueLine(valueLine), _valueColumn(valueColumn),
				_realValue(NULL), _status(RESOLVE_UNSET),
				SIMCValueReference( type, typeLine, typeColumn, 
					symbolName, symbolType, module, 
					_lineNumber, _columnNumber, _referenceCount)
		{
			if( _value )
				(*_value)->IncrementReferenceCount();
		}

		virtual ~SIMCDefinedValueReference()
		{
			if( UseReferenceCount() && _value )
				(*_value)->DecrementReferenceCount();
		}


		SIMCSymbol ** GetValueReference() const
		{
			return _value;
		}
		
		SIMCBuiltInValueReference * GetRealValue() const
		{
			return _realValue;
		}

		void SetRealValue(SIMCBuiltInValueReference *value)
		{
			_realValue = value;
		}
		SIMCResolutionStatus GetStatus() const
		{
			return _status;
		}

		void SetStatus( SIMCResolutionStatus val)
		{
			_status = val;
		}
		long GetValueLine() const
		{
			return _valueLine;
		}

		void SetValueLine( long x) 
		{
			_valueLine = x;
		}

		long GetValueColumn() const
		{
			return _valueColumn;
		}

		void SetValueColumn( long x) 
		{
			_valueColumn = x;
		}
		virtual void WriteSymbol( ostream& outStream ) const
		{
			outStream << "DEFINEDVALUEREFRENCE " ;
			SIMCValueReference::WriteSymbol(outStream);
			outStream << "\tVALUE DETAILS " ;
			(*_value)->WriteBrief(outStream);
			// SIMCValueReference::WriteSymbol(outStream);
			outStream << endl;

			switch(_status)
			{
				case RESOLVE_UNSET:
					outStream << "UNSET RESOLUTION" << endl;
					break;
				case RESOLVE_UNDEFINED:
					outStream << "UNDEFINED RESOLUTION" << endl;
					break;
				case RESOLVE_IMPORT:
					outStream << "RESOLVES TO IMPORT" << endl;
					break;
				case RESOLVE_CORRECT:
					outStream << "RESOLVES TO " << _realValue->GetSymbolName()
						<< endl;
					break;
			}

		}
};

typedef CList<SIMCDefinedValueReference *, SIMCDefinedValueReference *> SIMCDefinedValueReferenceList;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\abstractparsetree.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "smierrsy.hpp"
#include "smierrsm.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"
#include "abstractParseTree.hpp"

SIMCAbstractParseTree::~SIMCAbstractParseTree()
{
	if(_listOfModules)
	{
		SIMCModule *nextModule;
		while(!_listOfModules->IsEmpty() )
		{
			nextModule = _listOfModules->RemoveHead();
			delete nextModule;
		}
		delete _listOfModules;
	}
}

SIMCModule * SIMCAbstractParseTree::GetModule(
		const char *const moduleName) const
{
	POSITION p = _listOfModules->GetHeadPosition();

	SIMCModule * nextModule;
	while( p != NULL )
	{
		nextModule = _listOfModules->GetNext(p);
		if( strcmp(moduleName, nextModule->GetModuleName()) == 0 )
			return nextModule;
	}
	return NULL;
}

SIMCModule * SIMCAbstractParseTree::GetModuleOfFile(const char *const fileName) const
{
	POSITION p = _listOfModules->GetHeadPosition();

	SIMCModule * nextModule;
	while( p != NULL )
	{
		nextModule = _listOfModules->GetNext(p);
		if( strcmp(fileName, nextModule->GetInputFileName()) == 0 )
			return nextModule;
	}
	return NULL;
}



void SIMCAbstractParseTree::WriteTree(ostream& outStream) const
{
	const SIMCModuleList *x = GetListOfModules();
	SIMCModule *m;
	POSITION p = x->GetHeadPosition();
	while(p)
	{
		m = x->GetNext(p);
		outStream << (*m);
	}				
}

BOOL SIMCAbstractParseTree::CheckSyntax(ifstream& inputStream)
{
	SIMCScanner scanner;
	SIMCParser parser(_errorContainer, &scanner);
	if(!parser.SetSnmpVersion(_snmpVersion))
		return FALSE;
	if(!scanner.SetInput(inputStream))
		return FALSE;
	// parser->yydebug = 1;
	scanner.SetParser(&parser);
	if(parser.Parse())
		return WrapUpSyntaxCheck(parser);
	else
		return FALSE;
}

BOOL SIMCAbstractParseTree::CheckSyntax(const CString& inputFileName)
{
	SIMCScanner scanner;
	SIMCParser parser(_errorContainer, &scanner);
	if(!parser.SetSnmpVersion(_snmpVersion))
		return FALSE;
	if(!scanner.SetInput(inputFileName))
		return FALSE;
	// parser.yydebug = 1;
	scanner.SetParser(&parser);
	if(parser.Parse())
		return WrapUpSyntaxCheck(parser);
	else
		return FALSE;
}

BOOL SIMCAbstractParseTree::CheckSyntax(const int fileDescriptor)
{
	SIMCScanner scanner;
	SIMCParser parser(_errorContainer, &scanner);
	if(!parser.SetSnmpVersion(_snmpVersion))
		return FALSE;
	if(!scanner.SetInput(fileDescriptor))
		return FALSE;
	// parser.yydebug = 1;
	scanner.SetParser(&parser);
	if(parser.Parse())
		return WrapUpSyntaxCheck(parser);
	else
		return FALSE;
}

BOOL SIMCAbstractParseTree::CheckSyntax(FILE *fileStream)
{
	SIMCScanner scanner;
	SIMCParser parser(_errorContainer, &scanner);
	if(!parser.SetSnmpVersion(_snmpVersion))
		return FALSE;
	if(!scanner.SetInput(fileStream))
		return FALSE;
	// parser.yydebug = 1;
	scanner.SetParser(&parser);
	if(parser.Parse())
		return WrapUpSyntaxCheck(parser);
	else
		return FALSE;
}

BOOL SIMCAbstractParseTree::WrapUpSyntaxCheck( const SIMCParser& parser)
{	
	_fatalCount += parser.GetFatalCount();
	_warningCount += parser.GetWarningCount();
	_informationCount += parser.GetInformationCount();

	if (!parser.GetFatalCount()) // Parse() was  successful
	{
		_listOfModules->AddTail(parser.GetModule());
		// Set the new state
		_parseTreeState = UNRESOLVED;
		return TRUE;
	}
	else // State remamins the same
		return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\value.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifndef SIMC_VALUE
#define SIMC_VALUE


/* 
 * This file contains classes that model the various kinds of values that
 * can occur in a MIB module
 */

/*
 * The base class for all the values. Just stores the line and column number
 */
class SIMCValue
{

		long _line, _column;
		// Used in mostly in the destructors of the derived classes
		BOOL _useReferenceCount;	

	protected:

		SIMCValue( long line = 0, long column = 0)
			: _line(line), _column(column), _useReferenceCount(FALSE)
		{}

	public:

 		virtual ~SIMCValue() {}

		friend ostream& operator<< ( ostream& outStream, const SIMCValue& obj)
		{
			obj.WriteValue(outStream);
			return outStream;
		}

		long GetLine() const
		{
			return _line;
		}

		void SetLine( long x) 
		{
			_line = x;
		}
		long GetColumn() const
		{
			return _column;
		}

		void SetColumn( long x) 
		{
			_column = x;
		}

		void SetUseReferenceCount(BOOL val)
		{
			_useReferenceCount = val;
		}

		BOOL UseReferenceCount() const
		{
			return _useReferenceCount;
		}

		virtual void WriteValue(ostream& outStream) const
		{
			outStream << "line(" << _line << "), column(" << _column << ")";
		}
};

/* 
 * Value for the INTEGER type
 */
class SIMCIntegerValue : public SIMCValue
{

		long _val;

		/* A long value is used to store 32 bit unsigned, as well as signed
		* values. Hence this flag is required to indicate whether a minus sign
		* was present in front of this number in a MIB file. If this is false,
		* then the above long value should be treated as an unsigned value
		*/
		BOOL _isUnsigned;
	public:

		SIMCIntegerValue ( long x, BOOL isUnsigned, long line = 0, long column = 0)
			: _val(x), _isUnsigned(isUnsigned), SIMCValue(line, column)
		{}

		long GetIntegerValue() const { return _val; }
		void SetIntegerValue(long x) { _val = x; }
		BOOL IsUnsigned() const
		{
			return _isUnsigned;
		}
		virtual void WriteValue( ostream& outStream) const
		{
			outStream << "Integer (" << _val << "), ";
			SIMCValue::WriteValue(outStream);
			outStream << endl;
		}
		virtual BOOL operator == (const SIMCIntegerValue& rhs) const
		{
			return _val == rhs._val;
		}
};

BOOL IsLessThan(long a, BOOL aUnsigned, long b, BOOL bUnsigned);

/*
 * Value for the NULL type
 */
class SIMCNullValue : public SIMCValue
{

	public:

		SIMCNullValue ( long line = 0, long column = 0)
			: SIMCValue(line, column)
		{}

		virtual void WriteValue( ostream& outStream) const
		{
			outStream << "NULL value ";
			SIMCValue::WriteValue(outStream);
			outStream << endl;
		}
		virtual BOOL operator == (const SIMCIntegerValue& rhs) const
		{
			return TRUE;
		}
};

/*
 * Value for the BOOL type
 */
class SIMCBooleanValue : public SIMCValue
{
		BOOL _val;

	public:
	
		SIMCBooleanValue ( BOOL val, long line = 0, long column = 0 )
			: _val(val), SIMCValue(line, column)
		{}

		BOOL GetBooleanValue() const
		{
			return _val;
		}

		void SetBooleanValue(BOOL x) 
		{
			_val = x;
		}

		virtual void WriteValue( ostream& outStream) const
		{
			outStream << "BOOLEAN VALUE (" << ((_val)? "TRUE" : "FALSE") << 
					") ";
			SIMCValue::WriteValue(outStream);
			outStream << endl;
		}

		virtual BOOL operator == (const SIMCBooleanValue& rhs) const
		{
			if (_val)
				return  rhs._val;
			else
				return !rhs._val;
		}
};

/*
 * value for the OCTET STRING type
 */
class SIMCOctetStringValue : public SIMCValue
{

		char * _val;
		BOOL _binary;

	public:

		SIMCOctetStringValue ( BOOL binary, char * x, long line = 0, long column = 0)
			: _binary(binary), SIMCValue(line, column)
		{
			_val = NewString(x);
		}

		virtual ~SIMCOctetStringValue()
		{
			if(_val)
				delete []_val;
		}

		BOOL IsBinary() const
		{
			return _binary;
		}

		const char *GetOctetStringValue() const { return _val; }
		
		void SetOctetStringValue(BOOL binary, char * x) 
		{ 
			if(_val)
				delete _val;
			_val = NewString(x); 
			_binary = binary;
		}

		virtual void WriteValue( ostream& outStream) const
		{
			outStream << "Octet String (" << _val << "), ";
			SIMCValue::WriteValue(outStream);
			outStream << endl;
		}
		virtual BOOL operator == (const SIMCOctetStringValue& rhs) const
		{
			return (_binary == rhs._binary) &&(strcmp(_val, rhs._val) == 0);
		}
		int GetNumberOfOctets() const
		{
			if(_val)
			{
				int l = strlen(_val);
				if(!_binary)
					return l/2 + ((l%2)?1:0);
				return l/4 + ((l%4)?1:0);
			}
			else
				return 0;
		}

};

class SIMCBitValue
{
	public:
		CString	_name;
		long _line, _column;

		SIMCBitValue(const CString& name, long line, long column)
			: _name(name), _line(line), _column(column)
		{}
};

typedef CList<SIMCBitValue *, SIMCBitValue*> SIMCBitValueList;

class SIMCBitsValue : public SIMCValue
{
		SIMCBitValueList   *_valueList;

	public:
		SIMCBitsValue(SIMCBitValueList *valueList)
		{
			_valueList = valueList;
		}
		void AddValue( SIMCBitValue *value)
		{
			_valueList->AddTail(value);
		}

		const SIMCBitValueList * GetValueList() const
		{
			return _valueList;
		}
};


#endif // SIMC_VALUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\group.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>
#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "objectType.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"



const char * const SIMCObjectGroup::StatusStringsTable[] = 
{
	"current",
	"deprecated",
	"obsolete"
};



ostream& operator << (ostream& outStream, const SIMCScalar& obj)
{
	outStream << "SCALAR: " << obj.symbol->GetSymbolName() <<  "(" <<
		(obj.symbol->GetModule())->GetModuleName() << ")" << endl;
	return outStream;
}



ostream& operator << (ostream& outStream, const SIMCTable& obj)
{

	outStream << "TABLE: " << obj.tableSymbol->GetSymbolName() <<  "(" <<
		(obj.tableSymbol->GetModule())->GetModuleName() << ")" << endl;
	outStream << "\tROW: " << obj.rowSymbol->GetSymbolName() << "(" <<
		(obj.rowSymbol->GetModule())->GetModuleName() << ")"   << endl;
	outStream <<"\tCOLUMNS :" << (int)(obj.columnMembers)->GetCount() << endl;
	POSITION p = (obj.columnMembers)->GetHeadPosition();
	SIMCScalar *s;
	while(p)
	{
		s = (obj.columnMembers)->GetNext(p);
		outStream << (*s) ;
	}
	return outStream;
}

ostream& operator << (ostream& outStream, const SIMCObjectGroup& obj)
{

	 outStream << "Group: " << (obj.namedNode)->GetSymbolName() << endl;
	POSITION p;
	if(obj.scalars)
	{
		p = (obj.scalars)->GetHeadPosition();
		while(p)
			outStream << (*(obj.scalars)->GetNext(p)) ;
	}

	if(obj.tables)
	{
		p = (obj.tables)->GetHeadPosition();
		while(p)
			outStream << (*(obj.tables)->GetNext(p)) ;
	}
	outStream << "End of Group =================================" << endl;
	return outStream;
}

ostream& operator << (ostream& outStream, const SIMCGroupList& obj)
{
	outStream << "GROUPS:" << endl;

	POSITION p = obj.GetHeadPosition();
	while(p)
		outStream << (* obj.GetNext(p)) ;
	outStream << "END OF GROUPS" << endl;
	return outStream;
}

BOOL SIMCTable::IsColumnMember(const SIMCSymbol *symbol) const
{
	if(!columnMembers)
		return FALSE;

	SIMCScalar *nextScalar;
	POSITION p = columnMembers->GetHeadPosition();
	while(p)
	{
		nextScalar = columnMembers->GetNext(p);
		if((*nextScalar->GetSymbol()) == *symbol )
			return TRUE;
	}
	return FALSE;
}

const char * const SIMCTable::GetTableDescription() const
{
	SIMCSymbol **typeRef = ((SIMCValueReference *)tableSymbol)->GetTypeReference();
	SIMCTypeReference *btRef;
	if( SIMCModule::IsTypeReference(typeRef, btRef) != RESOLVE_CORRECT)
		return NULL;

	SIMCObjectTypeType *objType = ( SIMCObjectTypeType *) ((SIMCBuiltInTypeReference*)btRef)->GetType();
	return objType->GetDescription();
}


const char * const SIMCTable::GetRowDescription() const
{
	SIMCSymbol **typeRef = ((SIMCValueReference *)rowSymbol)->GetTypeReference();
	SIMCTypeReference *btRef;
	if( SIMCModule::IsTypeReference(typeRef, btRef) != RESOLVE_CORRECT)
		return NULL;

	SIMCObjectTypeType *objType = ( SIMCObjectTypeType *) ((SIMCBuiltInTypeReference*)btRef)->GetType();
	return objType->GetDescription();
}

SIMCScalar *SIMCTable::GetColumnMember(SIMCSymbol *columnSymbol) const
{
	if(!columnMembers)
		return NULL;

	POSITION p = columnMembers->GetHeadPosition();
	SIMCScalar *nextMember =  NULL;
	while(p)
	{
		nextMember = columnMembers->GetNext(p);
		if(nextMember->GetSymbol() == columnSymbol)
			return nextMember;
	}
	return NULL;
}

SIMCScalar *SIMCObjectGroup::GetScalar(SIMCSymbol *objectSymbol) const
{
	if(!scalars)
		return NULL;

	POSITION p = scalars->GetHeadPosition();
	SIMCScalar *nextScalar = NULL;
	while(p)
	{
		nextScalar = scalars->GetNext(p);
		if(nextScalar->GetSymbol() == objectSymbol)
			return nextScalar;
	}
	return NULL;
}

SIMCTable* SIMCObjectGroup::GetTable(SIMCSymbol *objectSymbol) const
{
	if(!tables)
		return NULL;

	POSITION p = tables->GetHeadPosition();
	SIMCTable *nextTable = NULL;
	while(p)
	{
		nextTable = tables->GetNext(p);
		if(nextTable->IsColumnMember(objectSymbol))
			return nextTable;
	}
	return NULL;
}

// This function checks whether any of the scalars or tables present in a group are
// defined in the module specified.
BOOL SIMCObjectGroup::ObjectsInModule(const SIMCModule *theModule) const
{
	// First check the scalars
	if(scalars) 
	{
		POSITION p = scalars->GetHeadPosition();
		SIMCScalar *nextScalar = NULL;
		while(p)
		{
			nextScalar = scalars->GetNext(p);
			if(nextScalar->GetSymbol()->GetModule() == theModule)
				return TRUE;
		}
	}

	// Then the tables. Only the root of the tables are checked
	if(tables)
	{
		POSITION p = tables->GetHeadPosition();
		SIMCTable *nextTable = NULL;
		while(p)
		{
			nextTable = tables->GetNext(p);
			if(nextTable->GetTableSymbol()->GetModule() == theModule)
				return TRUE;
		}
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\infolex.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"


#define INITIAL 0
const ModuleInfo_endst = 25;
const ModuleInfo_nxtmax = 310;
#define YY_LA_SIZE 4

static unsigned short ModuleInfo_la_act[] = {
 17, 16, 17, 2, 17, 3, 17, 4, 17, 5, 17, 6, 17, 7, 17, 8,
 17, 9, 17, 11, 17, 12, 17, 13, 17, 14, 15, 17, 17, 13, 12, 11,
 9, 1, 0, 10, 0
};

static unsigned char ModuleInfo_look[] = {
 0
};

static short ModuleInfo_final[] = {
 0, 0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 26,
 28, 29, 30, 31, 32, 33, 33, 34, 35, 36
};
#ifndef ModuleInfo_state_t
#define ModuleInfo_state_t unsigned char
#endif

static ModuleInfo_state_t ModuleInfo_begin[] = {
 0, 0, 0
};

static ModuleInfo_state_t ModuleInfo_next[] = {
 16, 16, 16, 16, 16, 16, 16, 16, 16, 13, 14, 16, 16, 16, 16, 16,
 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16,
 13, 16, 16, 16, 16, 16, 16, 16, 8, 9, 16, 16, 5, 1, 3, 16,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 2, 4, 16, 15, 16, 16,
 16, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 16, 16, 16, 16, 16,
 16, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 6, 16, 7, 16, 16,
 17, 21, 22, 25, 18, 25, 25, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 25, 25, 25, 25, 25, 25, 17, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 25, 25, 25, 25, 25, 25, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 19, 25, 25, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 25,
 25, 25, 25, 25, 25, 25, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 25, 25, 25, 25, 25, 25, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19,
 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 23, 25, 25, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 0
};

static ModuleInfo_state_t ModuleInfo_check[] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 13, 2, 21, 24, 12, ~0, ~0, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, ~0, ~0, ~0, ~0, ~0, ~0, 13, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, ~0, ~0, ~0, ~0, ~0, ~0, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
 12, 12, 11, ~0, ~0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, ~0,
 ~0, ~0, ~0, ~0, ~0, ~0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 ~0, ~0, ~0, ~0, ~0, ~0, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 1, ~0, ~0, 1, 1, 1,
 1, 1, 1, 1, 1, 1, 1, 0
};

static ModuleInfo_state_t ModuleInfo_default[] = {
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 13, 12, 11, 10, 25, 25, 25, 1, 0
};

static short ModuleInfo_base[] = {
 0, 253, 71, 311, 311, 311, 311, 311, 311, 311, 240, 165, 87, 119, 311, 311,
 311, 311, 311, 311, 311, 69, 311, 311, 86, 311
};



// MKS LEX prototype scanner code
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can redefine YY_INTERACTIVE to be 0 to get a very slightly
// faster scanner:
#ifndef YY_INTERACTIVE
#define	YY_INTERACTIVE	1
#endif

// You can compile with -DYY_DEBUG to get a print trace of the scanner
#ifdef YY_DEBUG
#undef YY_DEBUG
#define YY_DEBUG(fmt,a1,a2)	fprintf(stderr,fmt,a1,a2)
#else
#define YY_DEBUG(fmt,a1,a2)
#endif

const MIN_NUM_STATES = 20;

// Do *NOT* redefine the following:
#define	BEGIN		ModuleInfo_start =

#if 0 //removed because of build warnings
#define	REJECT		goto ModuleInfo_reject
#define	ModuleInfomore()	goto ModuleInfo_more
#endif


#ifndef	lint
static char *RCSid = "$Header$";
#endif

/* 
 * $Header$
 *
 *
 * $Log$
 */

/*
 *			  ISODE 8.0 NOTICE
 *
 *   Acquisition, use, and distribution of this module and related
 *   materials are subject to the restrictions of a license agreement.
 *   Consult the Preface in the User's Manual for the full terms of
 *   this agreement.
 *
 *
 *			4BSD/ISODE SNMPv2 NOTICE
 *
 *    Acquisition, use, and distribution of this module and related
 *    materials are subject to the restrictions given in the file
 *    SNMPv2-READ-ME.
 *
 */

#include <snmptempl.h>


#include <newString.hpp>
#include "infoLex.hpp"
#include "infoYacc.hpp"


MODULEINFOSTYPE ModuleInfolval;

struct table {
    char   *t_keyword;
    int	    t_value;
    int	    t_porting;
};

static struct table reserved[] = {
    "BEGIN", MI_BGIN, 0,
    "DEFINITIONS", MI_DEFINITIONS, 0,
    "FROM", MI_FROM, 0,
    "IMPORTS", MI_IMPORTS, 0,

    NULL, 0
};




// Constructor for ModuleInfo_scan. Set up tables
#if 0 //removed because of build warning
#pragma argsused
#endif

ModuleInfo_scan::ModuleInfo_scan(int sz, char* buf, char* sv, ModuleInfo_state_t* states)
{
	mustfree = 0;
	if ((size = sz) < MIN_NUM_STATES
	  || (ModuleInfotext = buf) == 0
	  || (state = states) == 0) {
		ModuleInfoerror("Bad space for scanner!");
		exit(1);
	}
#ifdef YY_PRESERVE
	save = sv;
#endif
}
// Constructor for ModuleInfo_scan. Set up tables
ModuleInfo_scan::ModuleInfo_scan(int sz)
{
	size = sz;
	ModuleInfotext = new char[sz+1];	// text buffer
	state = new ModuleInfo_state_t[sz+1];	// state buffer
#ifdef YY_PRESERVE
	save = new char[sz];	// saved ModuleInfotext[]
	push = save + sz;
#endif
	if (ModuleInfotext == NULL
#ifdef YY_PRESERVE
	  || save == NULL
#endif
	  || state == NULL) {
		ModuleInfoerror("No space for scanner!");
		exit(1);
	}
	mustfree = 1;
	ModuleInfo_end = 0;
	ModuleInfo_start = 0;
	ModuleInfo_lastc = YYNEWLINE;
	ModuleInfoin = stdin;
	ModuleInfoout = stdout;
	ModuleInfolineno = 1;
	ModuleInfoleng = 0;
}

// Descructor for ModuleInfo_scan
ModuleInfo_scan::~ModuleInfo_scan()
{
	if (mustfree) {
		mustfree = 0;
		delete(ModuleInfotext);
		delete(state);
#ifdef YY_PRESERVE
		delete(save);
#endif
	}
}

// Print error message, showing current line number
void
ModuleInfo_scan::ModuleInfoerror(char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
#ifdef LEX_WINDOWS
	// Windows has no concept of a standard error output!
	// send output to ModuleInfoout as a simple solution
	if (ModuleInfolineno)
		fprintf(ModuleInfoout, "%d: ", ModuleInfolineno);
	(void) vfprintf(ModuleInfoout, fmt, va);
	fputc('\n', ModuleInfoout);
#else /* LEX_WINDOWS */
	if (ModuleInfolineno)
		fprintf(stderr, "%d: ", ModuleInfolineno);
	(void) vfprintf(stderr, fmt, va);
	fputc('\n', stderr);
#endif /* LEX_WINDOWS */
	va_end(va);
}


#ifdef LEX_WINDOWS

// The initial portion of the lex scanner
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_ModuleInfolex() to acutally begin the
// scanning. When complete, win_ModuleInfolex() will return a
// value back to our new ModuleInfolex() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of ModuleInfolex().

int
ModuleInfo_scan::ModuleInfolex()
{
	int wReturnValue;
	HANDLE hRes_table;
	unsigned short *old_ModuleInfo_la_act;	// remember previous pointer values
	short *old_ModuleInfo_final;
	ModuleInfo_state_t *old_ModuleInfo_begin;
	ModuleInfo_state_t *old_ModuleInfo_next;
	ModuleInfo_state_t *old_ModuleInfo_check;
	ModuleInfo_state_t *old_ModuleInfo_default;
	short *old_ModuleInfo_base;

	// the following code will load the required
	// resources for a Windows based parser. 

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_ModuleInfoLEX", "ModuleInfoLEXTBL"));
	
	// return an error code if any
	// of the resources did not load 

	if (hRes_table == (HANDLE)NULL) 
		return (0);
	
	// the following code will lock the resources
	// into fixed memory locations for the scanner
	// (remember previous pointer locations)

	old_ModuleInfo_la_act = ModuleInfo_la_act;
	old_ModuleInfo_final = ModuleInfo_final;
	old_ModuleInfo_begin = ModuleInfo_begin;
	old_ModuleInfo_next = ModuleInfo_next;
	old_ModuleInfo_check = ModuleInfo_check;
	old_ModuleInfo_default = ModuleInfo_default;
	old_ModuleInfo_base = ModuleInfo_base;

	ModuleInfo_la_act = (unsigned short *)LockResource (hRes_table);
	ModuleInfo_final = (short *)(ModuleInfo_la_act + Sizeof_ModuleInfo_la_act);
	ModuleInfo_begin = (ModuleInfo_state_t *)(ModuleInfo_final + Sizeof_ModuleInfo_final);
	ModuleInfo_next = (ModuleInfo_state_t *)(ModuleInfo_begin + Sizeof_ModuleInfo_begin);
	ModuleInfo_check = (ModuleInfo_state_t *)(ModuleInfo_next + Sizeof_ModuleInfo_next);
	ModuleInfo_default = (ModuleInfo_state_t *)(ModuleInfo_check + Sizeof_ModuleInfo_check);
	ModuleInfo_base = (short *)(ModuleInfo_default + Sizeof_ModuleInfo_default);


	// call the standard ModuleInfolex() code

	wReturnValue = win_ModuleInfolex();

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previously saved pointers
	//

	ModuleInfo_la_act = old_ModuleInfo_la_act;
	ModuleInfo_final = old_ModuleInfo_final;
	ModuleInfo_begin = old_ModuleInfo_begin;
	ModuleInfo_next = old_ModuleInfo_next;
	ModuleInfo_check = old_ModuleInfo_check;
	ModuleInfo_default = old_ModuleInfo_default;
	ModuleInfo_base = old_ModuleInfo_base;

	return (wReturnValue);
}	// end ModuleInfolex()

// The actual lex scanner
// ModuleInfo_sbuf[0:ModuleInfoleng-1] contains the states corresponding to ModuleInfotext.
// ModuleInfotext[0:ModuleInfoleng-1] contains the current token.
// ModuleInfotext[ModuleInfoleng:ModuleInfo_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains ModuleInfotext[ModuleInfoleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 

int 
ModuleInfo_scan::win_ModuleInfolex()

#else /* LEX_WINDOWS */

// The actual lex scanner
// ModuleInfo_sbuf[0:ModuleInfoleng-1] contains the states corresponding to ModuleInfotext.
// ModuleInfotext[0:ModuleInfoleng-1] contains the current token.
// ModuleInfotext[ModuleInfoleng:ModuleInfo_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains ModuleInfotext[ModuleInfoleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 
int
ModuleInfo_scan::ModuleInfolex()
#endif /* LEX_WINDOWS */

{
	int c, i, ModuleInfobase;
	unsigned  ModuleInfost;		/* state */
	int ModuleInfofmin, ModuleInfofmax;	/* ModuleInfo_la_act indices of final states */
	int ModuleInfooldi, ModuleInfooleng;	/* base i, ModuleInfoleng before look-ahead */
	int ModuleInfoeof;		/* 1 if eof has already been read */



#ifdef YYEXIT
	ModuleInfoLexFatal = 0;
#endif
	ModuleInfoeof = 0;
	i = ModuleInfoleng;
	YY_SCANNER();

  ModuleInfo_again:
	if ((ModuleInfoleng = i) > 0) {
		ModuleInfo_lastc = ModuleInfotext[i-1];	// determine previous char
		while (i > 0)	//	// scan previously token
			if (ModuleInfotext[--i] == YYNEWLINE)	// fix ModuleInfolineno
				ModuleInfolineno++;
	}
	ModuleInfo_end -= ModuleInfoleng;		// adjust pushback
	memmove(ModuleInfotext, ModuleInfotext+ModuleInfoleng, (size_t) ModuleInfo_end);
	i = 0;

  ModuleInfo_contin:
	ModuleInfooldi = i;

	/* run the state machine until it jams */
	ModuleInfost = ModuleInfo_begin[ModuleInfo_start + (ModuleInfo_lastc == YYNEWLINE)];
	state[i] = (ModuleInfo_state_t) ModuleInfost;
	do {
		YY_DEBUG("<state %d, i = %d>\n", ModuleInfost, i);
		if (i >= size) {
			YY_FATAL("Token buffer overflow");
#ifdef YYEXIT
			if (ModuleInfoLexFatal)
				return -2;
#endif
		}	/* endif */

		/* get input char */
		if (i < ModuleInfo_end)
			c = ModuleInfotext[i];		/* get pushback char */
		else if (!ModuleInfoeof && (c = ModuleInfogetc()) != EOF) {
			ModuleInfo_end = i+1;
			ModuleInfotext[i] = (char)c;
		} else /* c == EOF */ {
			c = EOF;		/* just to make sure... */
			if (i == ModuleInfooldi) {	/* no token */
				ModuleInfoeof = 0;
				if (ModuleInfowrap())
					return 0;
				else
					goto ModuleInfo_again;
			} else {
				ModuleInfoeof = 1;	/* don't re-read EOF */
				break;
			}
		}
		YY_DEBUG("<input %d = 0x%02x>\n", c, c);

		/* look up next state */
		while ((ModuleInfobase = ModuleInfo_base[ModuleInfost]+(unsigned char)c) > ModuleInfo_nxtmax
		    || ModuleInfo_check[ModuleInfobase] != (ModuleInfo_state_t) ModuleInfost) {
			if (ModuleInfost == ModuleInfo_endst)
				goto ModuleInfo_jammed;
			ModuleInfost = ModuleInfo_default[ModuleInfost];
		}
		ModuleInfost = ModuleInfo_next[ModuleInfobase];
	  ModuleInfo_jammed: ;
	     state[++i] = (ModuleInfo_state_t) ModuleInfost;
	} while (!(ModuleInfost == ModuleInfo_endst || YY_INTERACTIVE &&
		ModuleInfo_base[ModuleInfost] > ModuleInfo_nxtmax && ModuleInfo_default[ModuleInfost] == ModuleInfo_endst));

	YY_DEBUG("<stopped %d, i = %d>\n", ModuleInfost, i);
	if (ModuleInfost != ModuleInfo_endst)
		++i;

  ModuleInfo_search:
	/* search backward for a final state */
	while (--i > ModuleInfooldi) {
		ModuleInfost = state[i];
		if ((ModuleInfofmin = ModuleInfo_final[ModuleInfost]) < (ModuleInfofmax = ModuleInfo_final[ModuleInfost+1]))
			goto ModuleInfo_found;	/* found final state(s) */
	}
	/* no match, default action */
	i = ModuleInfooldi + 1;
	output(ModuleInfotext[ModuleInfooldi]);
	goto ModuleInfo_again;

  ModuleInfo_found:
	YY_DEBUG("<final state %d, i = %d>\n", ModuleInfost, i);
	ModuleInfooleng = i;		/* save length for REJECT */
	
	// pushback look-ahead RHS, handling trailing context
	if ((c = (int)(ModuleInfo_la_act[ModuleInfofmin]>>9) - 1) >= 0) {
		unsigned char *bv = ModuleInfo_look + c*YY_LA_SIZE;
		static unsigned char bits [8] = {
			1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7
		};
		while (1) {
			if (--i < ModuleInfooldi) {	/* no / */
				i = ModuleInfooleng;
				break;
			}
			ModuleInfost = state[i];
			if (bv[(unsigned)ModuleInfost/8] & bits[(unsigned)ModuleInfost%8])
				break;
		}
	}

	/* perform action */
	ModuleInfoleng = i;
	YY_USER();
	switch (ModuleInfo_la_act[ModuleInfofmin] & 0777) {
	case 0:
	{   register int c, d;
					for (d = 0; c = input (); d = c == '-')
					{
						if (c == '\n' || (d && c == '-'))
							break;
					}
				}
	break;
	case 1:
	{
				return MI_CCE;
			}
	break;
	case 2:
	{
			    return MI_DOT;
			}
	break;
	case 3:
	{
			    return MI_SEMICOLON;
			}
	break;
	case 4:
	{
			    return MI_COMMA;
			}
	break;
	case 5:
	{
			    return MI_LBRACE;
			}
	break;
	case 6:
	{
			    return MI_RBRACE;
			}
	break;
	case 7:
	{
			    return MI_LPAREN;
			}
	break;
	case 8:
	{
			    return MI_RPAREN;
			}
	break;
	case 9:
	{
			    return MI_LITNUMBER;
			}
	break;
	case 10:
	{
			    return MI_LITNUMBER;
			}
	break;
	case 11:
	{   	// Rule 20
				
				register struct table *t;

				ModuleInfolval.yy_name = NewString(ModuleInfotext);

			    for (t = reserved; t -> t_keyword; t++)
					if (strcmp (t -> t_keyword, ModuleInfotext) == 0) 
						return t -> t_value;
			    return MI_ID;
			}
	break;
	case 12:
	{ 
			    return MI_NAME;
			}
	break;
	case 13:
	{}
	break;
	case 14:
	{}
	break;
	case 15:
	{
			    return '=';
			}
	break;
	case 16:
	{
			    return ':';
			}
	break;
	case 17:
	{   
			}
	break;


	}
	YY_SCANNER();
	i = ModuleInfoleng;
	goto ModuleInfo_again;			/* action fell though */

#if 0 //removed because of build warning
  ModuleInfo_reject:
#endif
	YY_SCANNER();
	i = ModuleInfooleng;			/* restore original ModuleInfotext */
	if (++ModuleInfofmin < ModuleInfofmax)
		goto ModuleInfo_found;		/* another final state, same length */
	else
		goto ModuleInfo_search;		/* try shorter ModuleInfotext */

#if 0 //removed because of build warning
  ModuleInfo_more:
#endif

	YY_SCANNER();
	i = ModuleInfoleng;
	if (i > 0)
		ModuleInfo_lastc = ModuleInfotext[i-1];
	goto ModuleInfo_contin;
}

/*
 * user callable input/unput functions.
 */
void
ModuleInfo_scan::ModuleInfo_reset()
{
	YY_INIT();
	ModuleInfolineno = 1;
}
/* get input char with pushback */
int
ModuleInfo_scan::input()
{
	int c;
#ifndef YY_PRESERVE
	if (ModuleInfo_end > ModuleInfoleng) {
		ModuleInfo_end--;
		memmove(ModuleInfotext+ModuleInfoleng, ModuleInfotext+ModuleInfoleng+1,
			(size_t) (ModuleInfo_end-ModuleInfoleng));
		c = save;
		YY_USER();
#else
	if (push < save+size) {
		c = *push++;
#endif
	} else
		c = ModuleInfogetc();
	ModuleInfo_lastc = c;
	if (c == YYNEWLINE)
		ModuleInfolineno++;
	return c;
}

/* pushback char */
int
ModuleInfo_scan::unput(int c)
{
#ifndef YY_PRESERVE
	if (ModuleInfo_end >= size) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		if (ModuleInfo_end > ModuleInfoleng) {
			ModuleInfotext[ModuleInfoleng] = save;
			memmove(ModuleInfotext+ModuleInfoleng+1, ModuleInfotext+ModuleInfoleng,
				(size_t) (ModuleInfo_end-ModuleInfoleng));
			ModuleInfotext[ModuleInfoleng] = 0;
		}
		ModuleInfo_end++;
		save = (char)c;
#else
	if (push <= save) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		*--push = c;
#endif
		if (c == YYNEWLINE)
			ModuleInfolineno--;
	}	/* endif */
	return c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\include\ytab.hpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
const ABSENT = 257;
const ANY = 258;
const APPLICATION = 259;
const BAR = 260;
const BGIN = 261;
const BIT = 262;
const BITSTRING = 263;
const _BOOLEAN = 264;
const BY = 265;
const CCE = 266;
const CHOICE = 267;
const COMMA = 268;
const COMPONENT = 269;
const COMPONENTS = 270;
const COMPONENTSOF = 271;
const CONTROL = 272;
const DECODER = 273;
const DEFAULT = 274;
const DEFINED = 275;
const DEFINITIONS = 276;
const DOT = 277;
const DOTDOT = 278;
const DOTDOTDOT = 279;
const ENCODER = 280;
const ENCRYPTED = 281;
const END = 282;
const ENUMERATED = 283;
const EXPORTS = 284;
const EXPLICIT = 285;
const FALSE_VAL = 286;
const FROM = 287;
const ID = 288;
const IDENTIFIER = 289;
const IMPLICIT = 290;
const IMPORTS = 291;
const INCLUDES = 292;
const INTEGER = 293;
const LANGLE = 294;
const LBRACE = 295;
const LBRACKET = 296;
const LITNUMBER = 297;
const LIT_HEX_STRING = 298;
const LIT_BINARY_STRING = 299;
const LITSTRING = 300;
const LPAREN = 301;
const MIN = 302;
const MAX = 303;
const NAME = 304;
const NIL = 305;
const OBJECT = 306;
const OCTET = 307;
const OCTETSTRING = 308;
const OF = 309;
const PARAMETERTYPE = 310;
const PREFIXES = 311;
const PRESENT = 312;
const PRINTER = 313;
const PRIVATE = 314;
const RBRACE = 315;
const RBRACKET = 316;
const REAL = 317;
const RPAREN = 318;
const SECTIONS = 319;
const SEMICOLON = 320;
const SEQUENCE = 321;
const SEQUENCEOF = 322;
const SET = 323;
const _SIZE = 324;
const STRING = 325;
const TAGS = 326;
const TRUE_VAL = 327;
const UNIVERSAL = 328;
const WITH = 329;
const PLUSINFINITY = 330;
const MINUSINFINITY = 331;
const MODULEID = 332;
const LASTUPDATE = 333;
const ORGANIZATION = 334;
const CONTACTINFO = 335;
const DESCRIPTION = 336;
const REVISION = 337;
const OBJECTIDENT = 338;
const STATUS = 339;
const REFERENCE = 340;
const OBJECTYPE = 341;
const SYNTAX = 342;
const BITSXX = 343;
const UNITS = 344;
const MAXACCESS = 345;
const ACCESS = 346;
const INDEX = 347;
const IMPLIED = 348;
const AUGMENTS = 349;
const DEFVAL = 350;
const NOTIFY = 351;
const OBJECTS = 352;
const TRAPTYPE = 353;
const ENTERPRISE = 354;
const VARIABLES = 355;
const TEXTCONV = 356;
const DISPLAYHINT = 357;
const OBJECTGROUP = 358;
const NOTIFYGROUP = 359;
const NOTIFICATIONS = 360;
const MODCOMP = 361;
const MODULE = 362;
const MANDATORY = 363;
const GROUP = 364;
const WSYNTAX = 365;
const MINACCESS = 366;
const AGENTCAP = 367;
const PRELEASE = 368;
const SUPPORTS = 369;
const INCLUDING = 370;
const VARIATION = 371;
const CREATION = 372;
typedef union {
	void			*yy_void;
	SIMCNumberInfo	*yy_number;
    int				yy_int;
	long			yy_long;
	SIMCModule		*yy_module;
	CList <SIMCModule *, SIMCModule *> *yy_module_list;
	SIMCSymbolReference *yy_symbol_ref;
	SIMCNameInfo * yy_name;
	SIMCHexStringInfo *yy_hex_string;
	SIMCBinaryStringInfo *yy_binary_string;
	SIMCAccessInfo *yy_access;
	SIMCAccessInfoV2 *yy_accessV2;
	SIMCStatusInfo *yy_status;
	SIMCStatusInfoV2 *yy_statusV2;
	SIMCObjectIdentityStatusInfo *yy_object_identity_status;
	SIMCNotificationTypeStatusInfo *yy_notification_type_status;
	SIMCIndexInfo		*yy_index;
	SIMCIndexInfoV2		*yy_indexV2;
	SIMCVariablesList	*yy_variables_list;
	SIMCObjectsList		*yy_objects_list;
	SIMCRangeOrSizeItem *yy_range_or_size_item;
	SIMCRangeList *yy_range_list;
	SIMCNamedNumberItem *yy_named_number_item;
	SIMCNamedNumberList *yy_named_number_list;
	SIMCDefValInfo *yy_def_val;
} YYSTYPE;
extern YYSTYPE yylval;

// C++ YACC parser header
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// yy_parse => class defining a parsing object
//	yy_parse needs a class yy_scan, which defines the scanner.
// %prefix or option -p xx determines name of this class; if not used,
// defaults to 'yy_scan'
//
// constructor fills in the tables for this grammar; give it a size
//    to determine size of state and value stacks. Default is 150 entries.
// destructor discards those state and value stacks
//
// int yy_parse::yyparse(yy_scan *) invokes parse; if this returns,
//	it can be recalled to continue parsing at last point.
// void yy_parse::yyreset() can be called to reset the parse;
//	call yyreset() before yy_parse::yyparse(yy_scan *)
#include <stdio.h>		// uses printf(), et cetera
#include <stdlib.h>		// uses exit()

const YYERRCODE = 256;		// YACC 'error' value

// You can use these macros in your action code
#define YYERROR		goto yyerrlabel
#define YYACCEPT	YYRETURN(0)
#define YYABORT		YYRETURN(1)
#define YYRETURN(val)	return(val)

#if YYDEBUG
typedef struct yyNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} yyNamedType;
typedef struct yyTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} yyTypedRules;
#endif

#ifdef YACC_WINDOWS

// include all windows prototypes, macros, constants, etc.

#include <windows.h>

// the following is the handle to the current
// instance of a windows program. The user
// program calling yyparse must supply this!

extern HANDLE hInst;	

#endif	/* YACC_WINDOWS */


class yy_parse {
protected:

#ifdef YACC_WINDOWS

	// protected member function for actual scanning 

	int	win_yyparse(yy_scan * ps);	// parse with given scanner

#endif	/* YACC_WINDOWS */

	int	mustfree;	// set if tables should be deleted
	int	size;		// size of state and value stacks
	int	reset;		// if set, reset state
	short	yyi;		// table index
	short	yystate;	// current state

	short	* stateStack;	// states stack
	YYSTYPE	* valueStack;	// values stack
	short	* yyps;		// top of state stack
	YYSTYPE * yypv;		// top of value stack

	YYSTYPE yylval;		// saved yylval
	YYSTYPE	yyval;		// $
	YYSTYPE * yypvt;	// $n
	int	yychar;		// current token
	int	yyerrflag;	// error flag
	int	yynerrs;	// error count
#if YYDEBUG
	int	done;		// set from trace to stop parse
	int	rule, npop;	// reduction rule # and length
	short	* typeStack;	// type stack to mirror valueStack[]
	short	* yytp;		// top of type stack
	char	* yygetState(int);	// read 'states.out'
#endif
public:
#if YYDEBUG
	// C++ has trouble with initialized arrays inside classes
	static long * States;		// pointer to yyStates[]
	static yyTypedRules * Rules;	// pointer to yyRules[]
	static yyNamedType * TokenTypes; // pointer to yyTokenTypes[]
	static int	yyntoken;	// number of tokens
	static int	yynvar;		// number of variables (nonterminals)
	static int	yynstate;	// number of YACC-generated states
	static int	yynrule;	// number of rules in grammar

	char*	yyptok(int);		// printable token string
	int	yyExpandName(int, int, char *, int);
						// expand encoded string
	virtual int	yyGetType(int);		// return type of token
	virtual void	yyShowRead();		// see newly read token
	virtual void	yyShowState();		// see state, value stacks
	virtual void	yyShowReduce();		// see reduction
	virtual void	yyShowGoto();		// see goto
	virtual void	yyShowShift();		// see shift
	virtual void	yyShowErrRecovery();	// see error recovery
	virtual void	yyShowErrDiscard();	// see token discard in error
#endif
	yy_scan* scan;			// pointer to scanner
	int	yydebug;	// if set, tracing if compiled with YYDEBUG=1

	yy_parse(int = 150);	// constructor for this grammar
	yy_parse(int, short *, YYSTYPE *);	// another constructor

	~yy_parse();		// destructor

	int	yyparse(yy_scan * ps);	// parse with given scanner

	void	yyreset() { reset = 1; } // restore state for next yyparse()

	void	setdebug(int y) { yydebug = y; }

// The following are useful in user actions:

	void	yyerrok() { yyerrflag = 0; }	// clear error
	void	yyclearin() { yychar = -1; }	// clear input
	int	YYRECOVERING() { return yyerrflag != 0; }
};
// end of .hpp header
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\errormessage.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"

#include <iostream.h>

#include "bool.hpp"
#include "newString.hpp"
#include "errorMessage.hpp"

SIMCErrorMessage::SIMCErrorMessage(const char * const inputStreamName, 
								   const char * const message,
								   const char * const severityString,
								   int errorId,
								   int severityLevel,
								   long lineNumber, long columnNumber)
				:	_errorId(errorId),
					_severityLevel(severityLevel),
					_lineNumber(lineNumber), 
					_columnNumber(columnNumber),
					_lineAndColumnValid(TRUE)
{
	if(inputStreamName)
	{
		if( !(_inputStreamName = NewString(inputStreamName)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_inputStreamName = NULL;

	if(message)
	{
		if( !(_message = NewString(message)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_message = NULL;

	if(severityString)
	{
		if( !(_severityString = NewString(severityString)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_severityString = NULL;

}
		
			
SIMCErrorMessage::~SIMCErrorMessage()
{
	if(_inputStreamName)
		delete[] _inputStreamName;
	if(_message)
		delete [] _message;
	if(_severityString)
		delete [] _severityString;
}

// And a copy constructor
SIMCErrorMessage::SIMCErrorMessage(const SIMCErrorMessage& rhs)
:	_errorId(rhs._errorId), _severityLevel(rhs._severityLevel),
	_lineNumber(rhs._lineNumber), _columnNumber(rhs._columnNumber),
	_lineAndColumnValid(rhs._lineAndColumnValid)
{
	if(rhs._inputStreamName)
	{
		if( !(_inputStreamName = NewString(rhs._inputStreamName)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_inputStreamName = NULL;

	if(rhs._message)
	{
		if( !(_message = NewString(rhs._message)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_message = NULL;

	if(rhs._severityString)
	{
		if( !(_severityString = NewString(rhs._severityString)))
			cerr << "SIMCErrorMessage(): Fatal Error. Not enough Memory" <<
				endl;
	}
	else
		_severityString = NULL;

}

const SIMCErrorMessage& SIMCErrorMessage::operator = (const SIMCErrorMessage& rhs)
{
	_errorId = rhs._errorId;
	_severityLevel = rhs._severityLevel;
	_lineNumber = rhs._lineNumber;
	_columnNumber = rhs._columnNumber;
	_lineAndColumnValid = rhs._lineAndColumnValid;

	if( _inputStreamName )
		delete []_inputStreamName;
	if(rhs._inputStreamName)
		_inputStreamName = NewString(rhs._inputStreamName);
	else
		_inputStreamName = NULL;

	if(_message)
		delete []_message;
	if(rhs._message)
		_message = NewString(rhs._message);
	else
		_message = NULL;

	if(_severityString)
		delete []_severityString;
	if(rhs._severityString)
		_severityString = NewString(rhs._severityString);
	else
		_severityString = NULL;

	return *this;
}

	
BOOL SIMCErrorMessage::SetMessage( const char * const message)
{
	if(_message)
		delete [] _message;
	if(message)
	{
		if( !(_message = NewString(message)))
			return FALSE;
	}
	else
		_message = NULL;
	return TRUE;
}
		
BOOL SIMCErrorMessage::SetInputStreamName( const char * const inputStreamName)
{
	if(_inputStreamName)
		delete [] _inputStreamName;
	if(inputStreamName)
	{
		if( !(_inputStreamName = NewString(inputStreamName)))
			return FALSE;
	}
	else
		_inputStreamName = NULL;
	return TRUE;
}
		
BOOL SIMCErrorMessage::SetSeverityString( const char * const severityString)
{
	if(_severityString)
		delete [] _severityString;
	if(severityString)
	{
		if( !(_severityString = NewString(severityString)))
			return FALSE;
	}
	else
		_severityString = NULL;
	return TRUE;
}
		
// And a default output of the error message
ostream& operator << 
		( ostream& outStream, const SIMCErrorMessage& errorMessage)
{
	if(errorMessage._lineAndColumnValid)
	{
		outStream << "<" << errorMessage._errorId  << "," <<
		errorMessage._severityString << ">: \"" <<
		errorMessage._inputStreamName << "\" (line " <<
		errorMessage._lineNumber << ", col " <<
		errorMessage._columnNumber << "): " <<
		errorMessage._message <<  endl;
	}
	else
		outStream << errorMessage._message;

	return outStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\moduleinfo.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"
#include <snmptempl.h>


#include "infoLex.hpp"
#include "infoYacc.hpp"
#include "moduleInfo.hpp"

BOOL SIMCModuleInfoParser::GetModuleInfo( SIMCModuleInfoScanner *tempScanner)
{
	if(ModuleInfoparse(tempScanner) != 0 ) 
		return FALSE;
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\lex_yy.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"


#define INITIAL 0
const yy_endst = 39;
const yy_nxtmax = 387;
#define YY_LA_SIZE 5

static unsigned short yy_la_act[] = {
 0, 26, 26, 25, 26, 5, 26, 6, 26, 7, 26, 8, 26, 9, 26, 10,
 26, 11, 26, 12, 26, 13, 26, 14, 26, 15, 26, 16, 26, 26, 20, 26,
 21, 26, 22, 26, 23, 24, 26, 26, 22, 21, 20, 19, 18, 16, 4, 3,
 2, 1, 17, 0
};

static unsigned char yy_look[] = {
 0
};

static short yy_final[] = {
 0, 0, 2, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27,
 29, 30, 32, 34, 36, 37, 39, 40, 41, 42, 43, 43, 43, 43, 43, 44,
 45, 46, 47, 48, 48, 49, 50, 51
};
#ifndef yy_state_t
#define yy_state_t unsigned char
#endif

static yy_state_t yy_begin[] = {
 0, 0, 0
};

static yy_state_t yy_next[] = {
 22, 22, 22, 22, 22, 22, 22, 22, 22, 19, 20, 22, 22, 22, 22, 22,
 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22,
 19, 22, 1, 22, 22, 22, 22, 16, 13, 14, 22, 22, 6, 2, 4, 22,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 3, 5, 12, 21, 22, 22,
 22, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 10, 22, 11, 22, 22,
 22, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 7, 9, 8, 22, 22,
 23, 33, 34, 35, 24, 36, 39, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 39, 30, 31, 39, 39, 39, 23, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 30, 31, 39, 39, 39, 39, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
 24, 24, 25, 39, 39, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 39,
 39, 39, 39, 39, 39, 39, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 39, 39, 39, 39, 39, 39, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
 27, 39, 39, 39, 39, 39, 39, 39, 39, 26, 26, 28, 28, 28, 28, 28,
 28, 28, 28, 39, 39, 39, 39, 29, 39, 39, 28, 28, 28, 28, 28, 28,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 39, 39, 39, 39, 39, 39,
 39, 28, 28, 28, 28, 28, 28, 39, 39, 39, 28, 28, 28, 28, 28, 28,
 32, 32, 32, 32, 32, 32, 32, 32, 32, 32, 39, 39, 39, 39, 39, 39,
 39, 28, 28, 28, 28, 28, 28, 37, 39, 39, 38, 38, 38, 38, 38, 38,
 38, 38, 38, 38, 0
};

static yy_state_t yy_check[] = {
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
 19, 4, 33, 3, 18, 35, 38, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, ~0, 29, 27, ~0, ~0, ~0, 19, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 29, 27, ~0, ~0, ~0, ~0, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
 18, 18, 17, ~0, ~0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, ~0,
 ~0, ~0, ~0, ~0, ~0, ~0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 ~0, ~0, ~0, ~0, ~0, ~0, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17, 17,
 16, ~0, ~0, ~0, ~0, ~0, ~0, ~0, ~0, 16, 16, 16, 16, 16, 16, 16,
 16, 16, 16, ~0, ~0, ~0, ~0, 28, ~0, ~0, 16, 16, 16, 16, 16, 16,
 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, ~0, ~0, ~0, ~0, ~0, ~0,
 ~0, 28, 28, 28, 28, 28, 28, ~0, ~0, ~0, 16, 16, 16, 16, 16, 16,
 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, ~0, ~0, ~0, ~0, ~0, ~0,
 ~0, 28, 28, 28, 28, 28, 28, 2, ~0, ~0, 2, 2, 2, 2, 2, 2,
 2, 2, 2, 2, 0
};

static yy_state_t yy_default[] = {
 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39, 39,
 39, 39, 39, 39, 39, 39, 39, 19, 18, 17, 16, 29, 39, 39, 39, 39,
 15, 39, 39, 39, 39, 39, 2, 0
};

static short yy_base[] = {
 0, 388, 330, 73, 83, 388, 388, 388, 388, 388, 388, 388, 388, 388, 388, 304,
 249, 165, 87, 119, 388, 388, 388, 388, 388, 388, 388, 81, 272, 74, 388, 388,
 388, 84, 388, 72, 388, 388, 89, 388
};



// MKS LEX prototype scanner code
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can redefine YY_INTERACTIVE to be 0 to get a very slightly
// faster scanner:
#ifndef YY_INTERACTIVE
#define	YY_INTERACTIVE	1
#endif

// You can compile with -DYY_DEBUG to get a print trace of the scanner
#ifdef YY_DEBUG
#undef YY_DEBUG
#define YY_DEBUG(fmt,a1,a2)	fprintf(stderr,fmt,a1,a2)
#else
#define YY_DEBUG(fmt,a1,a2)
#endif

const MIN_NUM_STATES = 20;

// Do *NOT* redefine the following:
#define	BEGIN		yy_start =

#if 0 //removed because of build warning
#define	REJECT		goto yy_reject
#define	yymore()	goto yy_more
#endif


#ifndef	lint
static char *RCSid = "$Header$";
#endif

/* 
 * $Header$
 *
 *
 * $Log$
 */

/*
 *			  ISODE 8.0 NOTICE
 *
 *   Acquisition, use, and distribution of this module and related
 *   materials are subject to the restrictions of a license agreement.
 *   Consult the Preface in the User's Manual for the full terms of
 *   this agreement.
 *
 *
 *			4BSD/ISODE SNMPv2 NOTICE
 *
 *    Acquisition, use, and distribution of this module and related
 *    materials are subject to the restrictions given in the file
 *    SNMPv2-READ-ME.
 *
 */

#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>

#include "smierrsy.hpp"
#include "scanner.hpp"
#include "parser.hpp"

#define theScanner ((SIMCScanner *)this)
#define theParser  ( theScanner->GetParser())

YYSTYPE yylval;

struct table {
    char   *t_keyword;
    int	    t_value;
    int	    t_porting;
};

static struct table reserved[] = {
    "ABSENT", ABSENT, 0,
    "ANY", ANY, 0,
    "APPLICATION", APPLICATION, 0, 	// For Tagged types
    "BEGIN", BGIN, 0,
    "BIT", BIT, 0,
    "BITSTRING", BITSTRING, 0,
    "BOOLEAN", _BOOLEAN, 0,
    "BY", BY, 0,
    "CHOICE", CHOICE, 0,
	
    "DEFAULT", DEFAULT, 0,
    "DEFINED", DEFINED, 0,
    "DEFINITIONS", DEFINITIONS, 0,

    "END", END, 0,
	
	"FALSE", FALSE_VAL, 0,
    "FROM", FROM, 0,
    "IDENTIFIER", IDENTIFIER, 0,
    "IMPLICIT", IMPLICIT, 0,
    "IMPORTS", IMPORTS, 0,
	
    "INTEGER", INTEGER, 0,
    "MIN", MIN, 0,
    "MAX", MAX, 0,
    "NULL", NIL, 0,
    "OBJECT", OBJECT, 0,
    "OCTET", OCTET, 0,
    "OCTETSTRING", OCTETSTRING, 0,
    "OF", OF, 0,
	
    "PRIVATE", PRIVATE, 0,				// For Tagged Types
    
    "SEQUENCE", SEQUENCE, 0,
    "SEQUENCEOF", SEQUENCEOF, 0,
    "SIZE", _SIZE, 0,
    "STRING", STRING, 0,
    "TAGS", TAGS, 0,
    "TRUE", TRUE_VAL, 0,
    "UNIVERSAL", UNIVERSAL, 0,			// For Tagged Types
    
	"MODULE-IDENTITY", MODULEID, 1,
    "LAST-UPDATED", LASTUPDATE, 0,
    "ORGANIZATION", ORGANIZATION, 0,
    "CONTACT-INFO", CONTACTINFO, 0,
    "DESCRIPTION", DESCRIPTION, 0,
    "REVISION", REVISION, 0,
    
    "OBJECT-IDENTITY", OBJECTIDENT, 1,
    "STATUS", STATUS, 0,
    "REFERENCE", REFERENCE, 0,

    "OBJECT-TYPE", OBJECTYPE, 1,
    "SYNTAX", SYNTAX, 0,
    "BITS", BITSXX, 0,
    "UNITS", UNITS, 0,
    "MAX-ACCESS", MAXACCESS, 0,
    "ACCESS", ACCESS, 0,		/* backwards compatibility */
    "INDEX", INDEX, 0,
    "IMPLIED", IMPLIED, 0,
    "AUGMENTS", AUGMENTS, 0,
    "DEFVAL", DEFVAL, 0,

    "NOTIFICATION-TYPE", NOTIFY, 1,
    "OBJECTS",      OBJECTS, 0,

    "TRAP-TYPE", TRAPTYPE, 1,		/* backwards compatibility */
    "ENTERPRISE", ENTERPRISE, 0,	/*   .. */
    "VARIABLES", VARIABLES, 0,		/*   .. */

    "TEXTUAL-CONVENTION", TEXTCONV, 1,
    "DISPLAY-HINT", DISPLAYHINT, 0,

    "OBJECT-GROUP", OBJECTGROUP, 1,

    "NOTIFICATION-GROUP", NOTIFYGROUP, 1,
    "NOTIFICATIONS", NOTIFICATIONS, 0,

    "MODULE-COMPLIANCE", MODCOMP, 1,
    "MODULE", MODULE, 0,
    "MANDATORY-GROUPS", MANDATORY, 0,
    "GROUP", GROUP, 0,
    "WRITE-SYNTAX", WSYNTAX, 0,
    "MIN-ACCESS", MINACCESS, 0,

    "AGENT-CAPABILITIES", AGENTCAP, 1,
    "PRODUCT-RELEASE", PRELEASE, 0,
    "SUPPORTS", SUPPORTS, 0,
    "INCLUDES", INCLUDING, 0,
    "VARIATION", VARIATION, 0,
    "CREATION-REQUIRES", CREATION, 0,

    NULL, 0
};

static int simc_debug = 0;

static BOOL CanFitInto32Bits(const char *  text)
{
	if(text[0] == '-')
	{
		// Check if > -2147483648
		text ++;
		unsigned long length = strlen(text);
		if(length < 10)
			return TRUE;
		else if(length > 10 )
			return FALSE;
		else
		{
			int index = 0;
	
			if(text[index] > '2')
				return FALSE;
			else if (text[index] < '2')
				return TRUE;
			index ++;

			if(text[index] > '1')
				return FALSE;
			else if (text[index] < '1')
				return TRUE;
			index ++;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '7')
				return FALSE;
			else if (text[index] < '7')
				return TRUE;
			index ++;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '8')
				return FALSE;
			else if (text[index] < '8')
				return TRUE;
			index ++;

			if(text[index] > '3')
				return FALSE;
			else if (text[index] < '3')
				return TRUE;
			index ++;

			if(text[index] > '6')
				return FALSE;
			else if (text[index] < '6')
				return TRUE;
			index ++;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '8')
				return FALSE;
			else if (text[index] < '8')
				return TRUE;

			return TRUE;
		}
	}
	else
	{
		// Check if < 4294967295
		unsigned long length = strlen(text);
		if(length < 10)
			return TRUE;
		else if(length > 10 )
			return FALSE;
		else
		{
			int index = 0;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '2')
				return FALSE;
			else if (text[index] < '2')
				return TRUE;
			index ++;

			if(text[index] > '9')
				return FALSE;
			else if (text[index] < '9')
				return TRUE;
			index ++;

			if(text[index] > '4')
				return FALSE;
			else if (text[index] < '4')
				return TRUE;
			index ++;

			if(text[index] > '9')
				return FALSE;
			else if (text[index] < '9')
				return TRUE;
			index ++;

			if(text[index] > '6')
				return FALSE;
			else if (text[index] < '6')
				return TRUE;
			index ++;

			if(text[index] > '7')
				return FALSE;
			else if (text[index] < '7')
				return TRUE;
			index ++;

			if(text[index] > '2')
				return FALSE;
			else if (text[index] < '2')
				return TRUE;
			index ++;

			if(text[index] > '9')
				return FALSE;
			else if (text[index] < '9')
				return TRUE;
			index ++;

			if(text[index] > '5')
				return FALSE;
			else if (text[index] < '5')
				return TRUE;

			return TRUE;
		}
	}
}
	



// Constructor for yy_scan. Set up tables
#if 0 //removed because build warning
#pragma argsused
#endif
yy_scan::yy_scan(int sz, char* buf, char* sv, yy_state_t* states)
{
	mustfree = 0;
	if ((size = sz) < MIN_NUM_STATES
	  || (yytext = buf) == 0
	  || (state = states) == 0) {
		yyerror("Bad space for scanner!");
		exit(1);
	}
#ifdef YY_PRESERVE
	save = sv;
#endif
}
// Constructor for yy_scan. Set up tables
yy_scan::yy_scan(int sz)
{
	size = sz;
	yytext = new char[sz+1];	// text buffer
	state = new yy_state_t[sz+1];	// state buffer
#ifdef YY_PRESERVE
	save = new char[sz];	// saved yytext[]
	push = save + sz;
#endif
	if (yytext == NULL
#ifdef YY_PRESERVE
	  || save == NULL
#endif
	  || state == NULL) {
		yyerror("No space for scanner!");
		exit(1);
	}
	mustfree = 1;
	yy_end = 0;
	yy_start = 0;
	yy_lastc = YYNEWLINE;
	yyin = stdin;
	yyout = stdout;
	yylineno = 1;
	yyleng = 0;
}

// Descructor for yy_scan
yy_scan::~yy_scan()
{
	if (mustfree) {
		mustfree = 0;
		delete(yytext);
		delete(state);
#ifdef YY_PRESERVE
		delete(save);
#endif
	}
}

// Print error message, showing current line number
void
yy_scan::yyerror(char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
#ifdef LEX_WINDOWS
	// Windows has no concept of a standard error output!
	// send output to yyout as a simple solution
	if (yylineno)
		fprintf(yyout, "%d: ", yylineno);
	(void) vfprintf(yyout, fmt, va);
	fputc('\n', yyout);
#else /* LEX_WINDOWS */
	if (yylineno)
		fprintf(stderr, "%d: ", yylineno);
	(void) vfprintf(stderr, fmt, va);
	fputc('\n', stderr);
#endif /* LEX_WINDOWS */
	va_end(va);
}


#ifdef LEX_WINDOWS

// The initial portion of the lex scanner
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yylex() to acutally begin the
// scanning. When complete, win_yylex() will return a
// value back to our new yylex() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yylex().

int
yy_scan::yylex()
{
	int wReturnValue;
	HANDLE hRes_table;
	unsigned short *old_yy_la_act;	// remember previous pointer values
	short *old_yy_final;
	yy_state_t *old_yy_begin;
	yy_state_t *old_yy_next;
	yy_state_t *old_yy_check;
	yy_state_t *old_yy_default;
	short *old_yy_base;

	// the following code will load the required
	// resources for a Windows based parser. 

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyLEX", "yyLEXTBL"));
	
	// return an error code if any
	// of the resources did not load 

	if (hRes_table == (HANDLE)NULL) 
		return (0);
	
	// the following code will lock the resources
	// into fixed memory locations for the scanner
	// (remember previous pointer locations)

	old_yy_la_act = yy_la_act;
	old_yy_final = yy_final;
	old_yy_begin = yy_begin;
	old_yy_next = yy_next;
	old_yy_check = yy_check;
	old_yy_default = yy_default;
	old_yy_base = yy_base;

	yy_la_act = (unsigned short *)LockResource (hRes_table);
	yy_final = (short *)(yy_la_act + Sizeof_yy_la_act);
	yy_begin = (yy_state_t *)(yy_final + Sizeof_yy_final);
	yy_next = (yy_state_t *)(yy_begin + Sizeof_yy_begin);
	yy_check = (yy_state_t *)(yy_next + Sizeof_yy_next);
	yy_default = (yy_state_t *)(yy_check + Sizeof_yy_check);
	yy_base = (short *)(yy_default + Sizeof_yy_default);


	// call the standard yylex() code

	wReturnValue = win_yylex();

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previously saved pointers
	//

	yy_la_act = old_yy_la_act;
	yy_final = old_yy_final;
	yy_begin = old_yy_begin;
	yy_next = old_yy_next;
	yy_check = old_yy_check;
	yy_default = old_yy_default;
	yy_base = old_yy_base;

	return (wReturnValue);
}	// end yylex()

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 

int 
yy_scan::win_yylex()

#else /* LEX_WINDOWS */

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 
int
yy_scan::yylex()
#endif /* LEX_WINDOWS */

{
	int c, i, yybase;
	unsigned  yyst;		/* state */
	int yyfmin, yyfmax;	/* yy_la_act indices of final states */
	int yyoldi, yyoleng;	/* base i, yyleng before look-ahead */
	int yyeof;		/* 1 if eof has already been read */



#ifdef YYEXIT
	yyLexFatal = 0;
#endif
	yyeof = 0;
	i = yyleng;
	YY_SCANNER();

  yy_again:
	if ((yyleng = i) > 0) {
		yy_lastc = yytext[i-1];	// determine previous char
		while (i > 0)	//	// scan previously token
			if (yytext[--i] == YYNEWLINE)	// fix yylineno
				yylineno++;
	}
	yy_end -= yyleng;		// adjust pushback
	memmove(yytext, yytext+yyleng, (size_t) yy_end);
	i = 0;

  yy_contin:
	yyoldi = i;

	/* run the state machine until it jams */
	yyst = yy_begin[yy_start + (yy_lastc == YYNEWLINE)];
	state[i] = (yy_state_t) yyst;
	do {
		YY_DEBUG("<state %d, i = %d>\n", yyst, i);
		if (i >= size) {
			YY_FATAL("Token buffer overflow");
#ifdef YYEXIT
			if (yyLexFatal)
				return -2;
#endif
		}	/* endif */

		/* get input char */
		if (i < yy_end)
			c = yytext[i];		/* get pushback char */
		else if (!yyeof && (c = yygetc()) != EOF) {
			yy_end = i+1;
			yytext[i] = (char)c;
		} else /* c == EOF */ {
			c = EOF;		/* just to make sure... */
			if (i == yyoldi) {	/* no token */
				yyeof = 0;
				if (yywrap())
					return 0;
				else
					goto yy_again;
			} else {
				yyeof = 1;	/* don't re-read EOF */
				break;
			}
		}
		YY_DEBUG("<input %d = 0x%02x>\n", c, c);

		/* look up next state */
		while ((yybase = yy_base[yyst]+(unsigned char)c) > yy_nxtmax
		    || yy_check[yybase] != (yy_state_t) yyst) {
			if (yyst == yy_endst)
				goto yy_jammed;
			yyst = yy_default[yyst];
		}
		yyst = yy_next[yybase];
	  yy_jammed: ;
	     state[++i] = (yy_state_t) yyst;
	} while (!(yyst == yy_endst || YY_INTERACTIVE &&
		yy_base[yyst] > yy_nxtmax && yy_default[yyst] == yy_endst));

	YY_DEBUG("<stopped %d, i = %d>\n", yyst, i);
	if (yyst != yy_endst)
		++i;

  yy_search:
	/* search backward for a final state */
	while (--i > yyoldi) {
		yyst = state[i];
		if ((yyfmin = yy_final[yyst]) < (yyfmax = yy_final[yyst+1]))
			goto yy_found;	/* found final state(s) */
	}
	/* no match, default action */
	i = yyoldi + 1;
	output(yytext[yyoldi]);
	goto yy_again;

  yy_found:
	YY_DEBUG("<final state %d, i = %d>\n", yyst, i);
	yyoleng = i;		/* save length for REJECT */
	
	// pushback look-ahead RHS, handling trailing context
	if ((c = (int)(yy_la_act[yyfmin]>>9) - 1) >= 0) {
		unsigned char *bv = yy_look + c*YY_LA_SIZE;
		static unsigned char bits [8] = {
			1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7
		};
		while (1) {
			if (--i < yyoldi) {	/* no / */
				i = yyoleng;
				break;
			}
			yyst = state[i];
			if (bv[(unsigned)yyst/8] & bits[(unsigned)yyst%8])
				break;
		}
	}

	/* perform action */
	yyleng = i;
	YY_USER();
	switch (yy_la_act[yyfmin] & 0777) {
	case 0:
	{	  // Rule 0
	
					theScanner->columnNo ++;
			    int	    c, len;
			    register char *cp, *ep, *pp;

			    if ((pp = (char *)malloc ((unsigned) (len = BUFSIZ)))
				    == NULL)
					yyerror ("out of memory");

			    for (ep = (cp = pp) + len - 1;;) 
				{
					if ((c = input ()) == EOF)
					{
						theParser->SyntaxError(UNTERMINATED_STRING, 
							yylineno, theScanner->columnNo);
						 
						return 0;

					}
					else
					{
						((SIMCScanner *) this)->columnNo++;
						if (c == '"')
							break;
		
						if (cp >= ep) 
						{
							register int curlen = (int)(cp - pp);
							register char *dp;

							if ((dp = (char *)realloc (pp,
									   (unsigned) (len += BUFSIZ)))
								== NULL)
								yyerror ("out of memory");
							cp = dp + curlen;
							ep = (pp = dp) + len - 1;
						}
						*cp++ = (char)c;
					}
			    }
			    *cp = NULL;
			    yylval.yy_name = new SIMCNameInfo(pp, yylineno,
								theScanner->columnNo - yyleng);
			    return LITSTRING;
			}
	break;
	case 1:
	{   register int c, d;
					theScanner->columnNo += 2;
					for (d = 0; c = input (); d = c == '-')
					{
						theScanner->columnNo++;
						if (c == '\n' || (d && c == '-'))
							break;
					}
				}
	break;
	case 2:
	{
				theScanner->columnNo += 3;
				return CCE;
			}
	break;
	case 3:
	{
				theScanner->columnNo += 3;
				return DOTDOTDOT;	
			}
	break;
	case 4:
	{
    			theScanner->columnNo += 2;
			    return DOTDOT;
			}
	break;
	case 5:
	{	theScanner->columnNo ++;
			    return DOT;
			}
	break;
	case 6:
	{
			    theScanner->columnNo ++;
			    return SEMICOLON;
			}
	break;
	case 7:
	{
			    theScanner->columnNo ++;
			    return COMMA;
			}
	break;
	case 8:
	{
				yylval.yy_name = new SIMCNameInfo(yytext, yylineno, 
						theScanner->columnNo);

			    theScanner->columnNo ++;
			    return LBRACE;
			}
	break;
	case 9:
	{
			    theScanner->columnNo ++;
			    return RBRACE;
			}
	break;
	case 10:
	{	// Rule 10
			    theScanner->columnNo ++;
			    return BAR;
			}
	break;
	case 11:
	{
			    theScanner->columnNo ++;
			    return LBRACKET;
			}
	break;
	case 12:
	{
			    theScanner->columnNo ++;
			    return RBRACKET;
			}
	break;
	case 13:
	{
			    theScanner->columnNo ++;
			    return LANGLE;
			}
	break;
	case 14:
	{
			    theScanner->columnNo ++;
			    return LPAREN;
			}
	break;
	case 15:
	{
			    theScanner->columnNo ++;
			    return RPAREN;
			}
	break;
	case 16:
	{
				long retVal;
			    theScanner->columnNo +=  yyleng;

				if(!CanFitInto32Bits(yytext) )			
					theParser->SyntaxError(TOO_BIG_NUM, 
						yylineno, theScanner->columnNo,
						NULL, yytext);

				sscanf (yytext, "%ld", &retVal);
				yylval.yy_number = new SIMCNumberInfo(retVal, 
							yylineno, theScanner->columnNo - yyleng, TRUE);
			    return LITNUMBER;
			}
	break;
	case 17:
	{
				long retVal;
			    theScanner->columnNo +=  yyleng;

				if(!CanFitInto32Bits(yytext) )			
					theParser->SyntaxError(TOO_BIG_NUM, 
						yylineno, theScanner->columnNo,
						NULL, yytext);

				sscanf (yytext, "%ld", &retVal);
				yylval.yy_number = new SIMCNumberInfo(retVal, 
							yylineno, theScanner->columnNo - yyleng, FALSE);
			    return LITNUMBER;
			}
	break;
	case 18:
	{   
				theScanner->columnNo +=  yyleng;
				
				yytext[yyleng-2] = NULL;	

				/*
				if(strlen(yytext+1) > 32 )			
					theParser->SyntaxError(TOO_BIG_NUM, 
						yylineno, theScanner->columnNo,
						NULL, yytext+1);
				*/
				yylval.yy_hex_string = new SIMCBinaryStringInfo(yytext, 
							yylineno, theScanner->columnNo - yyleng);
			    return LIT_BINARY_STRING;
			}
	break;
	case 19:
	{   
				theScanner->columnNo +=  yyleng;
				
				yytext[yyleng-2] = NULL;	// Remove the apostrophe and h 

				yylval.yy_hex_string = new SIMCHexStringInfo(yytext+1, 
							yylineno, theScanner->columnNo - yyleng);
			    return LIT_HEX_STRING;
			}
	break;
	case 20:
	{   	// Rule 20
				
				theScanner->columnNo += yyleng;
				register struct table *t;

				yylval.yy_name = new SIMCNameInfo(yytext, yylineno,
										theScanner->columnNo - yyleng);

			    for (t = reserved; t -> t_keyword; t++)
					if (strcmp (t -> t_keyword, yytext) == 0) 
					{
						if( simc_debug)
							cerr << "yylex(): Returning RESERVED_WORD" << 
								"(" << yytext << ")" << endl;
						return t -> t_value;
					}
			 	if( simc_debug)
					cerr << "yylex(): Returning ID" <<
								"(" << yytext << ")" << endl;
			    return ID;
			}
	break;
	case 21:
	{ 

				theScanner->columnNo += yyleng;
				  
				yylval.yy_name = new SIMCNameInfo(yytext, yylineno,
										theScanner->columnNo - yyleng);
			    return NAME;
			}
	break;
	case 22:
	{
					theScanner->columnNo +=  yyleng;
			}
	break;
	case 23:
	{
				theScanner->columnNo = 0;
			}
	break;
	case 24:
	{
				theScanner->columnNo++;
			    return '=';
			}
	break;
	case 25:
	{
			    theScanner->columnNo++;
			    return ':';
			}
	break;
	case 26:
	{   
				theParser->SyntaxError(UNRECOGNIZED_CHARACTER, 
					yylineno, theScanner->columnNo,
					yytext);
			}
	break;


	}
	YY_SCANNER();
	i = yyleng;
	goto yy_again;			/* action fell though */

#if 0 //removed because of build warning
  yy_reject:
#endif

	YY_SCANNER();
	i = yyoleng;			/* restore original yytext */
	if (++yyfmin < yyfmax)
		goto yy_found;		/* another final state, same length */
	else
		goto yy_search;		/* try shorter yytext */

#if 0 //removed because of build warning
  yy_more:
#endif

	YY_SCANNER();
	i = yyleng;
	if (i > 0)
		yy_lastc = yytext[i-1];
	goto yy_contin;
}

/*
 * user callable input/unput functions.
 */
void
yy_scan::yy_reset()
{
	YY_INIT();
	yylineno = 1;
}
/* get input char with pushback */
int
yy_scan::input()
{
	int c;
#ifndef YY_PRESERVE
	if (yy_end > yyleng) {
		yy_end--;
		memmove(yytext+yyleng, yytext+yyleng+1,
			(size_t) (yy_end-yyleng));
		c = save;
		YY_USER();
#else
	if (push < save+size) {
		c = *push++;
#endif
	} else
		c = yygetc();
	yy_lastc = c;
	if (c == YYNEWLINE)
		yylineno++;
	return c;
}

/* pushback char */
int
yy_scan::unput(int c)
{
#ifndef YY_PRESERVE
	if (yy_end >= size) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		if (yy_end > yyleng) {
			yytext[yyleng] = save;
			memmove(yytext+yyleng+1, yytext+yyleng,
				(size_t) (yy_end-yyleng));
			yytext[yyleng] = 0;
		}
		yy_end++;
		save = (char)c;
#else
	if (push <= save) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		*--push = c;
#endif
		if (c == YYNEWLINE)
			yylineno--;
	}	/* endif */
	return c;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\module.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "module.hpp"
#include "oidTree.hpp"
#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "parser.hpp"
#include "abstractParseTree.hpp"
#include "parseTree.hpp"
 
const int SIMCModule::SYMBOLS_PER_MODULE = 1000;



SIMCModule::SIMCModule(const char *const moduleName,
			const char *const inputFileName,
			SIMCSymbolTable *symbolTable,			
			CList < SIMCModule *,  SIMCModule *> *listOfImportModules,
			SIMCModule *parentModule,
			int snmpVersion,
			long lineNumber, long columnNumber,
			long referenceCount) 
				:	_snmpVersion(snmpVersion),
					_parentModule(parentModule),
					_description(NULL),
					_contactInfo(NULL),
					_lastUpdated(NULL),
					_organization(NULL),
					_moduleIdentityValue(NULL),
					_moduleIdentityName(NULL),
					SIMCSymbol(moduleName, MODULE_NAME, NULL, lineNumber,
								columnNumber, referenceCount)
{

	_inputFileName = NewString(inputFileName);
	_listOfObjectGroups = new SIMCGroupList;
	_listOfNotificationTypes = new SIMCNotificationList;

	if( symbolTable)
	{
		_symbolTable = symbolTable;
		// Set the module pointer of each symbol to this one
		POSITION p = _symbolTable->GetStartPosition();
		CString s;
		SIMCSymbol ** spp;
		while(p)
		{
			_symbolTable->GetNextAssoc(p, s, spp);
			(*spp)->SetModule(this);
		}
	}
	else // Create a new symbol table
	{
		_symbolTable = new SIMCSymbolTable;
		_symbolTable->InitHashTable(SYMBOLS_PER_MODULE);
	}

	// For each import module, set the current module as the parent
	// and increment the reference count of the module
	if(listOfImportModules)
	{
		_listOfImportModules = listOfImportModules;
		SIMCModule *m;
		POSITION p = _listOfImportModules->GetHeadPosition();
		while(p)
		{
			m = _listOfImportModules->GetNext(p);
			m->IncrementReferenceCount();
			m->SetParentModule(this);
		}
	}
	else
		_listOfImportModules = new CList < SIMCModule *,  SIMCModule *>;
}

SIMCModule::~SIMCModule()
{
	if(_inputFileName)
		delete [] _inputFileName;
	if(_moduleIdentityName)
		delete [] _moduleIdentityName;
	if(_description)
		delete [] _description;
	if(_contactInfo)
		delete [] _contactInfo;
	if(_lastUpdated)
		delete [] _lastUpdated;
	if(_organization)
		delete [] _organization;
	if( _moduleIdentityValue)
		delete _moduleIdentityValue;

	if(!_revisionList.IsEmpty())
	{
		POSITION p = _revisionList.GetHeadPosition();
		SIMCRevisionElement *element;
		while(p)
		{
			element = _revisionList.GetNext(p);
			delete element;
		}
	}


 	SIMCModule* m;
	if( _listOfImportModules)
	{
		while(!_listOfImportModules->IsEmpty() )
		{
			m = _listOfImportModules->RemoveHead();
			m->DecrementReferenceCount();
			delete m;
		}
		delete _listOfImportModules;
	}


	SIMCObjectGroup *nextGroup;
	if(_listOfObjectGroups)
	{
		while(!_listOfObjectGroups->IsEmpty() )
		{
			nextGroup = _listOfObjectGroups->RemoveHead();
			delete nextGroup;
		}
		delete _listOfObjectGroups;
	}

	SIMCNotificationElement *nextElement;
	if(_listOfNotificationTypes)
	{
		while(!_listOfNotificationTypes->IsEmpty() )
		{
			nextElement = _listOfNotificationTypes->RemoveHead();
			delete nextElement;
		}
		delete _listOfNotificationTypes;
	}

	if(_symbolTable)
	{
		SIMCSymbol **symbol;
		CString s;
		POSITION p;
		p = _symbolTable->GetStartPosition();
		while(p)
		{
			_symbolTable->GetNextAssoc(p, s, symbol);

			void *myTemp = (void *)(*symbol);

			if((*symbol)->GetModule() != this)
				continue;

			/* BUG : This has been commented and leads to memory leaks
			* Leaving it in was leading to a crash in destructor when
			* compiling the cisco-cipcsna-mib-v1smi MIB
			delete *symbol;
			delete symbol;
			*/
			_symbolTable->RemoveKey(s);
		}
		delete _symbolTable;	
	}

}


void SIMCModule::SetParentModule( SIMCModule * parentModule)
{
	if(_parentModule)
		_parentModule->DecrementReferenceCount();
	if(_parentModule = parentModule)
		_parentModule->IncrementReferenceCount();
}

 SIMCSymbol ** SIMCModule::GetSymbol(  const char* const symbolName) const
{
	SIMCSymbol ** x;
	if( _symbolTable->Lookup(CString(symbolName), x))
		return x;
	else
		return NULL;
}

int SIMCModule::GetImportedSymbol( const char * const symbolName,  SIMCSymbol ** &retVal1,
								  SIMCSymbol ** &retVal2) const
{
	if( ! _listOfImportModules )
		return NOT_FOUND;

	int retStatus = NOT_FOUND;
	SIMCSymbol ** retVal;
	
	SIMCModule *m;
	POSITION p = _listOfImportModules->GetHeadPosition();
	while(p)
	{
		m = _listOfImportModules->GetNext(p);
		if( retVal = m->GetSymbol(symbolName))
		{
			if( retStatus == NOT_FOUND )
			{
				retVal1 = retVal;
				retStatus = UNAMBIGUOUS;
			}
			else if (retStatus == UNAMBIGUOUS)
			{
				retStatus = AMBIGUOUS;
				retVal2 = retVal;
				return retStatus;
			}
		}
	}

	return retStatus;
}



void SIMCModule::AddImportModule( SIMCModule * newModule)
{
	_listOfImportModules->AddTail(newModule);
	newModule->IncrementReferenceCount();
	newModule->SetParentModule(this);

}

BOOL SIMCModule::RemoveImportModule(SIMCModule *module)
{
	POSITION p = _listOfImportModules->GetHeadPosition();
	POSITION temp;

	SIMCModule *next;
	while(p)
	{
		temp = p;
		 next = _listOfImportModules->GetNext(p);
		 if(module == next)
		 {
			 _listOfImportModules->RemoveAt(temp);
			 return TRUE;
		 }
	}

	return FALSE;
}

void SIMCModule::AddObjectGroup( SIMCObjectGroup * group)
{
	_listOfObjectGroups->AddTail(group);
}

SIMCModule *SIMCModule::GetImportModule(const char * const name) const
{
	POSITION p = _listOfImportModules->GetHeadPosition();
	SIMCModule *m;
	while(p)
	{
		m = _listOfImportModules->GetNext(p);
		if( strcmp(m->GetSymbolName(), name) == 0)
			return m;
	}
	return NULL;
}


// Gets the object group whose name is the speciified name
SIMCObjectGroup *SIMCModule::GetObjectGroup(const char * const name) const
{
	POSITION p = _listOfObjectGroups->GetHeadPosition();
	SIMCObjectGroup *m;
	while(p)
	{
		m = _listOfObjectGroups->GetNext(p);
		if( strcmp(m->GetObjectGroupName(), name) == 0)
			return m;
	}
	return NULL;
}

// Returns the object group in which this symbol is present
SIMCObjectGroup *SIMCModule::GetObjectGroup(SIMCSymbol *symbol) const
{
	POSITION p = _listOfObjectGroups->GetHeadPosition();
	SIMCObjectGroup *m;
	while(p)
	{
		m = _listOfObjectGroups->GetNext(p);
		if(m->GetScalar(symbol) || m->GetTable(symbol))
			return m;
	}
	return NULL;
}


BOOL SIMCModule::AddSymbol(SIMCSymbol * newSymbol)
{
	SIMCSymbol ** newSymbolP = new SIMCSymbol *;
	newSymbol->SetModule(this);
	*newSymbolP = newSymbol;
	(*_symbolTable)[CString(newSymbol->GetSymbolName())] = newSymbolP;
	return TRUE;
}

BOOL SIMCModule::RemoveSymbol(const char * const symbolName)
{
	return _symbolTable->RemoveKey(CString(symbolName));
}

BOOL SIMCModule::ReplaceSymbol(const char * const oldSymbol, 
							   SIMCSymbol * newSymbol)
{
	SIMCSymbol ** oldP = GetSymbol(oldSymbol);
	if(oldP)
	{
		delete *oldP;
		*oldP = newSymbol;
		return TRUE;
	}
	return FALSE;
}

void SIMCModule::WriteSymbol(ostream& outStream) const
{

	outStream << "BEGINNING PRINTING MODULE \"" << GetSymbolName() <<
		"\"" << endl;
	outStream << "\tParent Module : " <<
		((_parentModule)? (_parentModule)->GetSymbolName() : "NONE") << endl;
	outStream << "\tSNMP Version" << _snmpVersion << endl;

	POSITION p = (_listOfImportModules)->GetHeadPosition();

	if(_listOfObjectGroups)
		outStream << (*_listOfObjectGroups);
	
	outStream << "END OF MODULE " << GetSymbolName() << endl;

}

class SIMCTypeReference;
class SIMCValueReference;
class SIMCUnknown;
class SIMCBuiltInTypeReference;
class SIMCDefinedTypeReference;
class SIMCBuiltInValueReference;
class SIMCDefinedValueReference;
class SIMCTextualConvention;


SIMCModule::SymbolClass SIMCModule::GetSymbolClass(SIMCSymbol **spp) 
{
	if(!spp || !(*spp) )
		return SYMBOL_INVALID;

	if(typeid(**spp) == typeid(SIMCUnknown) )
		return SYMBOL_UNKNOWN;
	else if (typeid(**spp) == typeid(SIMCModule) )
		return SYMBOL_MODULE;
	else if (typeid(**spp) == typeid(SIMCBuiltInTypeReference) )
		return SYMBOL_BUILTIN_TYPE_REF;
	else if (typeid(**spp) == typeid(SIMCDefinedTypeReference) )
		return SYMBOL_DEFINED_TYPE_REF;
	else if (typeid(**spp) == typeid(SIMCTextualConvention) )
		return SYMBOL_TEXTUAL_CONVENTION;
	else if (typeid(**spp) == typeid(SIMCBuiltInValueReference) )
		return SYMBOL_BUILTIN_VALUE_REF;
	else if (typeid(**spp) == typeid(SIMCDefinedValueReference) )
		return SYMBOL_DEFINED_VALUE_REF;
	else if (typeid(**spp) == typeid(SIMCImport) )
		return SYMBOL_IMPORT;
	else 
		return SYMBOL_INVALID;
}

SIMCModule::TypeClass SIMCModule::GetTypeClass(SIMCType *t) 
{
	if(!t)
		return TYPE_INVALID;
	if(typeid(*t) == typeid(SIMCPrimitiveType) )
		return TYPE_PRIMITIVE;
	else if (typeid(*t) == typeid(SIMCRangeType) )
		return TYPE_RANGE;
	else if (typeid(*t) == typeid(SIMCSizeType) )
		return TYPE_SIZE;
	else if (typeid(*t) == typeid(SIMCEnumOrBitsType) )
		return TYPE_ENUM_OR_BITS;
	else if (typeid(*t) == typeid(SIMCSequenceOfType) )
		return TYPE_SEQUENCE_OF;
	else if (typeid(*t) == typeid(SIMCSequenceType) )
		return TYPE_SEQUENCE;
	else if (typeid(*t) == typeid(SIMCTrapTypeType) )
		return TYPE_TRAP_TYPE;
	else if (typeid(*t) == typeid(SIMCNotificationTypeType) )
		return TYPE_NOTIFICATION_TYPE;
	else if (typeid(*t) == typeid(SIMCObjectTypeV1) )
		return TYPE_OBJECT_TYPE_V1;
	else if (typeid(*t) == typeid(SIMCObjectTypeV2) )
		return TYPE_OBJECT_TYPE_V2;
	else if (typeid(*t) == typeid(SIMCObjectIdentityType) )
		return TYPE_OBJECT_IDENTITY;
	else if (typeid(*t) == typeid(SIMCEnumOrBitsType) )
		return TYPE_ENUM_OR_BITS;
	else 
		return TYPE_INVALID;
}


SIMCModule::ValueClass SIMCModule::GetValueClass(SIMCValue * v)
{
	if(!v)
		return VALUE_INVALID;
	else if( typeid(*v) == typeid(SIMCNullValue) )
		return VALUE_NULL;
	else if( typeid(*v) == typeid(SIMCIntegerValue) )
		return VALUE_INTEGER;
	else if( typeid(*v) == typeid(SIMCOidValue) )
		return VALUE_OID;
	else if( typeid(*v) == typeid(SIMCOctetStringValue) )
		return VALUE_OCTET_STRING;
	else if( typeid(*v) == typeid(SIMCBooleanValue) )
		return VALUE_BOOLEAN;
	else if( typeid(*v) == typeid(SIMCBitsValue) )
		return VALUE_BITS;
	else 
		return VALUE_INVALID;
};

SIMCModule::PrimitiveType SIMCModule::GetPrimitiveType(const char * const name)
{
	if(!name)
		return PRIMITIVE_INVALID;
	if( strcmp(name, "INTEGER") == 0 )
		return PRIMITIVE_INTEGER;
	else if (strcmp(name, "OBJECT IDENTIFIER") == 0 )
		return PRIMITIVE_OID;
	else if (strcmp(name, "BOOLEAN") == 0 )
		return PRIMITIVE_BOOLEAN;
	else if (strcmp(name, "OCTET STRING") == 0 )
		return PRIMITIVE_OCTET_STRING;
	else if (strcmp(name, "BITS") == 0 )
		return PRIMITIVE_BITS;
	else if (strcmp(name, "NULL") == 0 )
		return PRIMITIVE_NULL;
	else if (strcmp(name, "NetworkAddress") == 0 )
		return PRIMITIVE_NETWORK_ADDRESS;
	else if (strcmp(name, "IpAddress") == 0 )
		return PRIMITIVE_IP_ADDRESS ;
	else if (strcmp(name, "Counter") == 0 )
		return PRIMITIVE_COUNTER;
	else if (strcmp(name, "Gauge") == 0 )
		return PRIMITIVE_GAUGE;
	else if (strcmp(name, "TimeTicks") == 0 )
		return PRIMITIVE_TIME_TICKS;
	else if (strcmp(name, "Opaque") == 0 )
		return PRIMITIVE_OPAQUE;
	else if (strcmp(name, "DisplayString") == 0 )
		return PRIMITIVE_DISPLAY_STRING;
	else if (strcmp(name, "PhysAddress") == 0 )
		return PRIMITIVE_PHYS_ADDRESS;
	else if (strcmp(name, "MacAddress") == 0 )
		return PRIMITIVE_MAC_ADDRESS;
	else if (strcmp(name, "Integer32") == 0 )
		return PRIMITIVE_INTEGER_32;
	else if (strcmp(name, "Counter32") == 0 )
		return PRIMITIVE_COUNTER_32;
	else if (strcmp(name, "Gauge32") == 0 )
		return PRIMITIVE_GAUGE_32;
	else if (strcmp(name, "Counter64") == 0 )
		return PRIMITIVE_COUNTER_64;
	else if (strcmp(name, "Unsigned32") == 0 )
		return PRIMITIVE_UNSIGNED_32;
	else if (strcmp(name, "DateAndTime") == 0 )
		return PRIMITIVE_DATE_AND_TIME;
	else if (strcmp(name, "SnmpUDPAddress") == 0 )
		return PRIMITIVE_SNMP_UDP_ADDRESS;
	else if (strcmp(name, "SnmpOSIAddress") == 0 )
		return PRIMITIVE_SNMP_OSI_ADDRESS;
	else if (strcmp(name, "SnmpIPXAddress") == 0 )
		return PRIMITIVE_SNMP_IPX_ADDRESS;
	else 
		return PRIMITIVE_INVALID;
}

SIMCModule::PrimitiveType SIMCModule::GetPrimitiveType(const SIMCTypeReference *typeRef)
{
	SIMCSymbol **temp = (SIMCSymbol**)&typeRef;
	switch(GetSymbolClass(temp))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType * type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			switch(GetTypeClass(type))
			{
				case TYPE_INVALID:
				case TYPE_SEQUENCE_OF:
				case TYPE_SEQUENCE:
				case TYPE_TRAP_TYPE:
				case TYPE_NOTIFICATION_TYPE:
				case TYPE_OBJECT_TYPE_V1:
				case TYPE_OBJECT_TYPE_V2:
				case TYPE_OBJECT_IDENTITY:
				case TYPE_ENUM_OR_BITS:
					return PRIMITIVE_INVALID;
				case TYPE_PRIMITIVE:
					return GetPrimitiveType(typeRef->GetSymbolName());
				case TYPE_RANGE:
				case TYPE_SIZE:
				{
					SIMCTypeReference *rhs = ((SIMCSubType *)type)->GetRootType();
					if(rhs)
					{
						SIMCSymbol **tempRhs = (SIMCSymbol **)&rhs;
						switch(GetSymbolClass(tempRhs))
						{
							case SYMBOL_BUILTIN_TYPE_REF:
								return GetPrimitiveType((SIMCBuiltInTypeReference*)rhs);
							case SYMBOL_TEXTUAL_CONVENTION:
								return GetPrimitiveType(rhs->GetSymbolName());
						}
					}
					else
						return PRIMITIVE_INVALID;
				}
			}
		}
		break;
		case SYMBOL_TEXTUAL_CONVENTION:
			return GetPrimitiveType(typeRef->GetSymbolName());
	}
	return PRIMITIVE_INVALID;
}

SIMCResolutionStatus SIMCModule::SetResolutionStatus(SIMCDefinedTypeReference * orig)
{
	SIMCDefinedTypeReferenceList checkedList;
	return SetResolutionStatusRec(orig, checkedList);
}

SIMCResolutionStatus SIMCModule::SetResolutionStatusRec(SIMCDefinedTypeReference * orig,
									SIMCDefinedTypeReferenceList& checkedList)
{

	SIMCTypeReference *result = NULL;
	SIMCResolutionStatus retVal = orig->GetStatus();
	if(retVal != RESOLVE_UNSET)
		return retVal;

	POSITION pChecked = checkedList.GetHeadPosition();
	SIMCDefinedTypeReference *checkedSymbol;
	while(pChecked)
	{
		checkedSymbol = checkedList.GetNext(pChecked);
		if(checkedSymbol == orig)
		{
			orig->SetStatus(RESOLVE_UNDEFINED);
			orig->SetRealType(NULL);
			return RESOLVE_UNDEFINED;
		}
	}
	
	checkedList.AddTail(orig);

	SIMCSymbol **rhs = orig->GetTypeReference();
	switch(GetSymbolClass(rhs))
	{
		case SYMBOL_IMPORT:
			orig->SetStatus(RESOLVE_IMPORT);
			orig->SetRealType(NULL);
			return RESOLVE_IMPORT;
		case SYMBOL_BUILTIN_TYPE_REF:
			result = (SIMCTypeReference *)(*rhs);
			orig->SetStatus(RESOLVE_CORRECT);
			orig->SetRealType(result);
			return RESOLVE_CORRECT;
		case SYMBOL_DEFINED_TYPE_REF:
		case SYMBOL_TEXTUAL_CONVENTION:
		{
			if( GetPrimitiveType((*rhs)->GetSymbolName()) != PRIMITIVE_INVALID)
			{
				orig->SetStatus(retVal = RESOLVE_CORRECT);
				orig->SetRealType((SIMCTypeReference *)(*rhs));
				return retVal;
			}

			SIMCDefinedTypeReference *rhsRef = (SIMCDefinedTypeReference *)(*rhs);
			
			switch(rhsRef->GetStatus())
			{
				case RESOLVE_UNSET:
					retVal = SetResolutionStatusRec(rhsRef, checkedList);
					orig->SetStatus(retVal);
					orig->SetRealType(rhsRef->GetRealType());
					return retVal;
				default:
					retVal = rhsRef->GetStatus();
					orig->SetStatus(retVal);
					orig->SetRealType(rhsRef->GetRealType());
					return retVal;
			}
		}
		default:
			orig->SetStatus(RESOLVE_UNDEFINED);
			orig->SetRealType(NULL);
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::SetResolutionStatus(SIMCDefinedValueReference * orig)
{
	SIMCDefinedValueReferenceList checkedList;

	return SetResolutionStatusRec(orig, checkedList);
}


SIMCResolutionStatus SIMCModule::SetResolutionStatusRec(SIMCDefinedValueReference * orig,
									SIMCDefinedValueReferenceList& checkedList)

{
	SIMCBuiltInValueReference *result = NULL;
	SIMCResolutionStatus retVal = orig->GetStatus();
	if(retVal != RESOLVE_UNSET)
		return retVal;

	POSITION pChecked = checkedList.GetHeadPosition();
	SIMCDefinedValueReference *checkedSymbol;
	while(pChecked)
	{
		checkedSymbol = checkedList.GetNext(pChecked);
		if(checkedSymbol == orig)
		{
			orig->SetStatus(RESOLVE_UNDEFINED);
			orig->SetRealValue(NULL);
			return RESOLVE_UNDEFINED;
		}
	}
	
	checkedList.AddTail(orig);

	SIMCSymbol **rhs = orig->GetValueReference();
	switch(GetSymbolClass(rhs))
	{
		case SYMBOL_IMPORT:
			orig->SetStatus(RESOLVE_IMPORT);
			orig->SetRealValue(NULL);
			return RESOLVE_IMPORT;
		case SYMBOL_BUILTIN_VALUE_REF:
			result = (SIMCBuiltInValueReference *)(*rhs);
			orig->SetStatus(RESOLVE_CORRECT);
			orig->SetRealValue(result);
			return RESOLVE_CORRECT;
		case SYMBOL_DEFINED_VALUE_REF:
		case SYMBOL_TEXTUAL_CONVENTION:
		{
			SIMCDefinedValueReference *rhsRef = (SIMCDefinedValueReference *)(*rhs);
			switch(rhsRef->GetStatus())
			{
				case RESOLVE_UNSET:
					retVal = SetResolutionStatusRec(rhsRef, checkedList);
					orig->SetStatus(retVal);
					orig->SetRealValue(rhsRef->GetRealValue());
					return retVal;
				default:
					retVal = rhsRef->GetStatus();
					orig->SetStatus(retVal);
					orig->SetRealValue(rhsRef->GetRealValue());
					return retVal;
			}
		}
		default:
			orig->SetStatus(RESOLVE_UNDEFINED);
			orig->SetRealValue(NULL);
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::SetResolutionStatus(SIMCSymbol **symbol)
{
	switch(GetSymbolClass(symbol))
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_IMPORT:
		case SIMCModule::SYMBOL_MODULE:
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
				return RESOLVE_CORRECT;

		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			return SetResolutionStatus((SIMCDefinedTypeReference *)(*symbol));

		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			return SetResolutionStatus((SIMCDefinedValueReference *)(*symbol));

	}
	return RESOLVE_UNDEFINED;
}

BOOL SIMCModule::SetResolutionStatus()
{
	POSITION p = (_symbolTable)->GetStartPosition();
	SIMCSymbol **symbol;
	CString s;
	BOOL retVal = TRUE;
	while(p)
	{
		(_symbolTable)->GetNextAssoc(p, s, symbol);
		const char * const name = s;

		if(SetResolutionStatus(symbol) == RESOLVE_UNDEFINED)
			retVal = FALSE;
	}
	return retVal;
}

SIMCResolutionStatus SIMCModule::SetRootSubType(SIMCSubType *t)
{
	SIMCSubTypeList checkedList;
	switch(GetTypeClass(t))
	{
		case TYPE_ENUM_OR_BITS:
			return SetRootEnumOrBitsRec((SIMCEnumOrBitsType*)t, checkedList);
		case TYPE_RANGE:
		case TYPE_SIZE:
			return SetRootSubTypeRec(t, checkedList);
		default:
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::SetRootSubTypeRec(SIMCSubType *t,
							SIMCSubTypeList& checkedList)
{
	SIMCResolutionStatus retVal = t->GetStatus();
	if(retVal != RESOLVE_UNSET)
		return retVal;

	POSITION pChecked = checkedList.GetHeadPosition();
	SIMCSubType *checkedSymbol;
	while(pChecked)
	{
		checkedSymbol = checkedList.GetNext(pChecked);
		if(checkedSymbol == t)
		{
			t->SetStatus(RESOLVE_UNDEFINED);
			t->SetRootType(NULL);
			return RESOLVE_UNDEFINED;
		}
	}
	
	checkedList.AddTail(t);

	SIMCSymbol **s = t->GetType();
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_MODULE:
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
		{
			t->SetStatus(RESOLVE_UNDEFINED);
			t->SetRootType(NULL);
			return RESOLVE_UNDEFINED;
		}

		case SIMCModule::SYMBOL_IMPORT:
		{
			t->SetStatus(RESOLVE_IMPORT);
			t->SetRootType(NULL);
			return RESOLVE_IMPORT;
		}

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *rhs = ((SIMCBuiltInTypeReference*)(*s))->GetType();
			switch(GetTypeClass(rhs))
			{
				case TYPE_INVALID:
				case TYPE_ENUM_OR_BITS:
				case TYPE_SEQUENCE_OF:
				case TYPE_SEQUENCE:
				case TYPE_TRAP_TYPE:
				case TYPE_NOTIFICATION_TYPE:
				case TYPE_OBJECT_TYPE_V1:
				case TYPE_OBJECT_TYPE_V2:
				case TYPE_OBJECT_IDENTITY:
					t->SetStatus(RESOLVE_UNDEFINED);
					t->SetRootType(NULL);
					return RESOLVE_UNDEFINED;

				case TYPE_PRIMITIVE:
					t->SetRootType((SIMCBuiltInTypeReference*)(*s));
					t->SetStatus(RESOLVE_CORRECT);
					return RESOLVE_CORRECT;

				case TYPE_RANGE:
				case TYPE_SIZE:
				{
					if( ((SIMCSubType*)rhs)->GetStatus() == RESOLVE_UNSET)
						retVal = SetRootSubTypeRec((SIMCSubType*)rhs, checkedList);
					else
						retVal = ((SIMCSubType *)rhs)->GetStatus();
					t->SetRootType(((SIMCSubType*)rhs)->GetRootType());
					t->SetStatus(retVal);
					return retVal;
				}
			}
		}
		break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			if(GetPrimitiveType((*s)->GetSymbolName()) != PRIMITIVE_INVALID)
			{
				t->SetStatus(retVal = RESOLVE_CORRECT);
				t->SetRootType((SIMCTypeReference *)(*s));
				return retVal;
			}

			switch ( ((SIMCDefinedTypeReference*)(*s))->GetStatus())
			{
				case RESOLVE_UNSET:
				case RESOLVE_UNDEFINED:
					t->SetRootType(NULL);
					t->SetStatus(RESOLVE_UNDEFINED);
					return RESOLVE_UNDEFINED;
				case RESOLVE_IMPORT:
					t->SetRootType(NULL);
					t->SetStatus(RESOLVE_IMPORT);
					return RESOLVE_IMPORT;
				case RESOLVE_CORRECT:
				{
					SIMCTypeReference *sb =
						((SIMCDefinedTypeReference*)(*s))->GetRealType(); 

					SIMCSymbol **tempSb = (SIMCSymbol **)&sb;
					switch(GetSymbolClass(tempSb))
					{
						case SYMBOL_BUILTIN_TYPE_REF:
						{
							SIMCType *rhs = ((SIMCBuiltInTypeReference *)sb)->GetType();
							switch(GetTypeClass(rhs))
							{
								case TYPE_INVALID:
								case TYPE_ENUM_OR_BITS:
								case TYPE_SEQUENCE_OF:
								case TYPE_SEQUENCE:
								case TYPE_TRAP_TYPE:
								case TYPE_NOTIFICATION_TYPE:
								case TYPE_OBJECT_TYPE_V1:
								case TYPE_OBJECT_TYPE_V2:
								case TYPE_OBJECT_IDENTITY:
									t->SetStatus(RESOLVE_UNDEFINED);
									t->SetRootType(NULL);
									return RESOLVE_UNDEFINED;

								case TYPE_PRIMITIVE:
									t->SetRootType(sb);
									t->SetStatus(RESOLVE_CORRECT);
									return RESOLVE_CORRECT;

								case TYPE_RANGE:
								case TYPE_SIZE:
								{
									if( ((SIMCSubType*)rhs)->GetStatus() == RESOLVE_UNSET)
										retVal = SetRootSubTypeRec((SIMCSubType*)rhs, checkedList);
									else
										retVal = ((SIMCSubType*)rhs)->GetStatus();
									t->SetStatus(retVal);
									t->SetRootType(((SIMCSubType*)rhs)->GetRootType());
									return retVal;
								}
							}
						}
						break;
						case SYMBOL_TEXTUAL_CONVENTION:
						{
							t->SetRootType(sb);
							t->SetStatus(RESOLVE_CORRECT);
							return RESOLVE_CORRECT;
						}
						break;
					}
				}
			}
		}
	}	
	return RESOLVE_UNDEFINED;
}

SIMCResolutionStatus SIMCModule::SetRootEnumOrBitsRec(SIMCEnumOrBitsType *t,
							SIMCSubTypeList& checkedList)
{
	SIMCResolutionStatus retVal = t->GetStatus();
	if(retVal != RESOLVE_UNSET)
		return retVal;

	POSITION pChecked = checkedList.GetHeadPosition();
	SIMCSubType *checkedSymbol;
	while(pChecked)
	{
		checkedSymbol = checkedList.GetNext(pChecked);
		if(checkedSymbol == t)
		{
			t->SetStatus(RESOLVE_UNDEFINED);
			t->SetRootType(NULL);
			return RESOLVE_UNDEFINED;
		}
	}
	
	checkedList.AddTail(t);

	SIMCSymbol **s = t->GetType();
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_MODULE:
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
		{
			t->SetStatus(RESOLVE_UNDEFINED);
			t->SetRootType(NULL);
			return RESOLVE_UNDEFINED;
		}

		case SIMCModule::SYMBOL_IMPORT:
		{
			t->SetStatus(RESOLVE_IMPORT);
			t->SetRootType(NULL);
			t->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT);
			return RESOLVE_IMPORT;
		}

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *rhs = ((SIMCBuiltInTypeReference*)(*s))->GetType();
			switch(GetTypeClass(rhs))
			{
				case TYPE_INVALID:
				case TYPE_SEQUENCE_OF:
				case TYPE_SEQUENCE:
				case TYPE_TRAP_TYPE:
				case TYPE_NOTIFICATION_TYPE:
				case TYPE_OBJECT_TYPE_V1:
				case TYPE_OBJECT_TYPE_V2:
				case TYPE_OBJECT_IDENTITY:
				case TYPE_RANGE:
				case TYPE_SIZE:
					t->SetStatus(RESOLVE_UNDEFINED);
					t->SetRootType(NULL);
					return RESOLVE_UNDEFINED;

				case TYPE_PRIMITIVE:
					t->SetRootType((SIMCBuiltInTypeReference*)(*s));
					t->SetStatus(RESOLVE_CORRECT);
					switch(GetPrimitiveType((*s)->GetSymbolName()))
					{
						case SIMCModule::PRIMITIVE_INTEGER:
							((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM);
							break;
						case SIMCModule::PRIMITIVE_BITS:
							((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_BITS);
							break;
						default:
							((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_UNKNOWN);
							break;
					}
					return RESOLVE_CORRECT;
 				case TYPE_ENUM_OR_BITS:

				{
					if( ((SIMCSubType*)rhs)->GetStatus() == RESOLVE_UNSET)
						retVal = SetRootSubTypeRec((SIMCSubType*)rhs, checkedList);
					else
						retVal = ((SIMCSubType *)rhs)->GetStatus();
					t->SetRootType( ((SIMCSubType*)rhs)->GetRootType() );
					t->SetStatus(retVal);
					( (SIMCEnumOrBitsType *) t)->SetEnumOrBitsType( 
						((SIMCEnumOrBitsType *)rhs)->GetEnumOrBitsType()  );
					return retVal;
				}
			}
		}
		break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			if(GetPrimitiveType((*s)->GetSymbolName()) != PRIMITIVE_INVALID)
			{
				t->SetStatus(retVal = RESOLVE_CORRECT);
				t->SetRootType((SIMCTypeReference *)(*s));
				return retVal;
			}

			switch ( ((SIMCDefinedTypeReference*)(*s))->GetStatus())
			{
				case RESOLVE_UNSET:
				case RESOLVE_UNDEFINED:
					t->SetRootType(NULL);
					t->SetStatus(RESOLVE_UNDEFINED);
					return RESOLVE_UNDEFINED;
				case RESOLVE_IMPORT:
					t->SetRootType(NULL);
					t->SetStatus(RESOLVE_IMPORT);
					return RESOLVE_IMPORT;
				case RESOLVE_CORRECT:
				{
					SIMCTypeReference *sb =
						((SIMCDefinedTypeReference*)(*s))->GetRealType(); 
					SIMCSymbol **tempSb = (SIMCSymbol **)&sb;
					switch(GetSymbolClass(tempSb))
					{
						case SYMBOL_BUILTIN_TYPE_REF:
						{
							SIMCType *rhs = ((SIMCBuiltInTypeReference *)sb)->GetType();
							switch(GetTypeClass(rhs))
							{
								case TYPE_INVALID:
								case TYPE_SEQUENCE_OF:
								case TYPE_SEQUENCE:
								case TYPE_TRAP_TYPE:
								case TYPE_NOTIFICATION_TYPE:
								case TYPE_OBJECT_TYPE_V1:
								case TYPE_OBJECT_TYPE_V2:
								case TYPE_OBJECT_IDENTITY:
								case TYPE_RANGE:
								case TYPE_SIZE:
									t->SetStatus(RESOLVE_UNDEFINED);
									t->SetRootType(NULL);
									return RESOLVE_UNDEFINED;

								case TYPE_PRIMITIVE:
									t->SetRootType(sb);
									t->SetStatus(RESOLVE_CORRECT);
									switch(GetPrimitiveType(sb->GetSymbolName()) )
									{
										case SIMCModule::PRIMITIVE_INTEGER:
											((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM);
											break;
										case SIMCModule::PRIMITIVE_BITS:
											((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_BITS);
											break;
										default:
											((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(SIMCEnumOrBitsType::ENUM_OR_BITS_UNKNOWN);
											break;
									}
								return RESOLVE_CORRECT;
								case TYPE_ENUM_OR_BITS:
								{
									if( ((SIMCSubType*)rhs)->GetStatus() == RESOLVE_UNSET)
										retVal = SetRootSubTypeRec((SIMCSubType*)rhs, checkedList);
									else
										retVal = ((SIMCSubType*)rhs)->GetStatus();
									t->SetStatus(retVal);
									t->SetRootType(((SIMCSubType*)rhs)->GetRootType());
									((SIMCEnumOrBitsType *) t)->SetEnumOrBitsType(((SIMCEnumOrBitsType *)rhs)->GetEnumOrBitsType());
									return retVal;
								}
							}
						}
						break;
						case SYMBOL_TEXTUAL_CONVENTION:
						{
							t->SetRootType(sb);
							t->SetStatus(RESOLVE_CORRECT);
							return RESOLVE_CORRECT;
						}
						break;
					}
				}
			}
		}
	}	
	return RESOLVE_UNDEFINED;
}


SIMCResolutionStatus SIMCModule::SetRootSymbol(SIMCSymbol **symbol)
{

	switch(GetSymbolClass(symbol))
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_IMPORT:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_MODULE:
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			return RESOLVE_CORRECT;
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCBuiltInTypeReference *b = (SIMCBuiltInTypeReference *)(*symbol);
			TypeClass x = GetTypeClass(b->GetType());
			switch(x)
			{
				case TYPE_RANGE:
				case TYPE_SIZE:
				case TYPE_ENUM_OR_BITS:
					return SetRootSubType((SIMCSubType *)(b->GetType()) );
				default:
					return RESOLVE_CORRECT;
			}
		}
	}
	return RESOLVE_UNDEFINED;
}

BOOL SIMCModule::SetRootAll()
{
	POSITION p = (_symbolTable)->GetStartPosition();
	SIMCSymbol **symbol;
	CString s;
	BOOL retVal = TRUE;
	while(p)
	{
		(_symbolTable)->GetNextAssoc(p, s, symbol);
		if(SetRootSymbol(symbol) == RESOLVE_UNDEFINED)
			retVal = FALSE;
	}
	return retVal;
}

SIMCResolutionStatus SIMCModule::SetDefVal(SIMCObjectTypeType *objType)
{
	const char *name;
	SIMCSymbol ** enumValue;

	if( ! (name = objType->GetDefValName()) )
	{
		objType->SetDefValStatus(RESOLVE_CORRECT);
		return RESOLVE_CORRECT;
	}

	 SIMCSymbol ** syntax  = objType->GetSyntax();
	 SIMCEnumOrBitsType * enumType;
	 if(syntax)
	 {
		 if(IsEnumType(syntax, enumType) == RESOLVE_CORRECT)
		 {
			 if( enumValue = enumType->GetValue(name) )
			 {
				 objType->SetDefVal(enumValue);
				 objType->SetDefValStatus(RESOLVE_CORRECT);
				 return RESOLVE_CORRECT;
			 }
		 }
	 }

	 // If you reach here, then an enum item could not be found
	 // Try to set the symbolic reference
	SIMCSymbol **s;
	if( s = GetSymbol(name) )  // Symbol exists
	{
		objType->SetDefVal(s);
		objType->SetDefValName(NULL);
		objType->SetDefValStatus(RESOLVE_CORRECT);
		return RESOLVE_CORRECT;
	}

	// Symbol could not be resolved within the current module
	// Search in import modules.

	SIMCSymbol **import1, **import2;
	switch( GetImportedSymbol(name, import1, import2))
	{
		case NOT_FOUND:
		case AMBIGUOUS:
			objType->SetDefValStatus(RESOLVE_UNDEFINED);
			return RESOLVE_UNDEFINED;
		case UNAMBIGUOUS:
			objType->SetDefVal(import1);
			objType->SetDefValName(NULL);
			objType->SetDefValStatus(RESOLVE_CORRECT);
			return RESOLVE_CORRECT;
	}

	objType->SetDefValStatus(RESOLVE_UNDEFINED);
	return RESOLVE_UNDEFINED;
}

BOOL SIMCModule::SetDefVal()
{
	POSITION p = (_symbolTable)->GetStartPosition();
	SIMCSymbol **symbol;
	CString s;
	BOOL retVal = TRUE;
	SIMCObjectTypeType *objType;
	while(p)
	{
		(_symbolTable)->GetNextAssoc(p, s, symbol);
		if(IsObjectType(symbol, objType) == RESOLVE_CORRECT)
			retVal = SetDefVal(objType) && retVal;
	}
	return retVal;
}


SIMCResolutionStatus SIMCModule::IsIntegerValue(SIMCSymbol **s, int& retValue)
{
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		{
			SIMCBuiltInValueReference *b = (SIMCBuiltInValueReference*)(*s);
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_INTEGER:
					retValue =  ((SIMCIntegerValue *)v)->GetIntegerValue();
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			if(d->GetStatus() != RESOLVE_CORRECT && d->GetStatus() != RESOLVE_IMPORT)
				return RESOLVE_UNDEFINED;
			if(d->GetStatus() == RESOLVE_IMPORT)
				return RESOLVE_IMPORT;
			SIMCBuiltInValueReference *b = d->GetRealValue();
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_INTEGER:
					retValue =  ((SIMCIntegerValue *)v)->GetIntegerValue();
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		default:
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::IsNullValue(SIMCSymbol **s)
{
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		{
			SIMCBuiltInValueReference *b = (SIMCBuiltInValueReference*)(*s);
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_NULL:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			if(d->GetStatus() != RESOLVE_CORRECT && d->GetStatus() != RESOLVE_IMPORT)
				return RESOLVE_UNDEFINED;
			if(d->GetStatus() == RESOLVE_IMPORT)
				return RESOLVE_IMPORT;
			SIMCBuiltInValueReference *b = d->GetRealValue();
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_NULL:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		default:
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::IsObjectIdentifierValue(SIMCSymbol **s, SIMCOidValue * &retValue)
{
	retValue = NULL;
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		{
			SIMCBuiltInValueReference *b = (SIMCBuiltInValueReference*)(*s);
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_OID:
					retValue =  (SIMCOidValue *)v;
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			if(d->GetStatus() != RESOLVE_CORRECT && d->GetStatus() != RESOLVE_IMPORT)
				return RESOLVE_UNDEFINED;
			if(d->GetStatus() == RESOLVE_IMPORT)
				return RESOLVE_IMPORT;
			SIMCBuiltInValueReference *b = d->GetRealValue();
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_OID:
					retValue =  (SIMCOidValue *)v;
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		default:
			return RESOLVE_UNDEFINED;
	}
}

SIMCResolutionStatus SIMCModule::IsBitsValue(SIMCSymbol **s, SIMCBitsValue * &retValue)
{
	retValue = NULL;
	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		{
			SIMCBuiltInValueReference *b = (SIMCBuiltInValueReference*)(*s);
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_BITS:
					retValue =  (SIMCBitsValue *)v;
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			if(d->GetStatus() != RESOLVE_CORRECT && d->GetStatus() != RESOLVE_IMPORT)
				return RESOLVE_UNDEFINED;
			if(d->GetStatus() == RESOLVE_IMPORT)
				return RESOLVE_IMPORT;
			SIMCBuiltInValueReference *b = d->GetRealValue();
			SIMCValue *v = b->GetValue();
			switch(GetValueClass(v))
			{
				case VALUE_BITS:
					retValue =  (SIMCBitsValue *)v;
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_UNDEFINED;
			}
		}

		default:
			return RESOLVE_UNDEFINED;
	}
}



SIMCResolutionStatus SIMCModule::IsObjectTypeV1(SIMCSymbol **value, 
											  SIMCObjectTypeV1 * &retValObjectType)
{
	retValObjectType = NULL;


	// Check that the type of the symbol is indeed an OBJECT-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
				break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_OBJECT_TYPE_V1)
						return RESOLVE_UNDEFINED;
			else
				retValObjectType = (SIMCObjectTypeV1*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsObjectTypeV2(SIMCSymbol **value, 
											  SIMCObjectTypeV2 * &retValObjectType)
{
	retValObjectType = NULL;


	// Check that the type of the symbol is indeed an OBJECT-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
					break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_OBJECT_TYPE_V2)
						return RESOLVE_UNDEFINED;
			else
				retValObjectType = (SIMCObjectTypeV2*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsObjectType(SIMCSymbol **value, 
											  SIMCObjectTypeType * &retValObjectType)
{
	retValObjectType = NULL;


	// Check that the type of the symbol is indeed an OBJECT-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
					break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_OBJECT_TYPE_V1 &&
				SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_OBJECT_TYPE_V2)
						return RESOLVE_UNDEFINED;
			else
				retValObjectType = (SIMCObjectTypeType*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsTrapType(SIMCSymbol **value, 
											  SIMCTrapTypeType * &retValTrapType)
{
	retValTrapType = NULL;

	// Check that the type of the symbol is indeed an TRAP-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
					break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_TRAP_TYPE)
						return RESOLVE_UNDEFINED;
			else
				retValTrapType = (SIMCTrapTypeType*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsNotificationType(SIMCSymbol **value, 
											  SIMCNotificationTypeType * &retValNotificationType)
{
	retValNotificationType = NULL;

	// Check that the type of the symbol is indeed an NOTIFICATION-TYPE
	switch(GetSymbolClass(value))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCSymbol **typeRef = ((SIMCValueReference *)(*value))->GetTypeReference();
			SIMCType *type;
			switch(SIMCModule::GetSymbolClass(typeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
					type = ((SIMCBuiltInTypeReference *)(*typeRef))->GetType();
					break;
				default:
						return RESOLVE_UNDEFINED;
			}

			if( SIMCModule::GetTypeClass(type) != SIMCModule::TYPE_NOTIFICATION_TYPE)
						return RESOLVE_UNDEFINED;
			else
				retValNotificationType = (SIMCNotificationTypeType*)type;
		}
		break;
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsEnumType(SIMCSymbol **symbol, 
											  SIMCEnumOrBitsType * &retValEnumType)
{
	retValEnumType = NULL;
	SIMCTypeReference * bTypeRef;
	SIMCType *type;
	switch(IsTypeReference(symbol, bTypeRef))
	{
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			return RESOLVE_UNDEFINED;
			
		case RESOLVE_CORRECT:
		{
			SIMCSymbol **tempBTypeRef =  (SIMCSymbol **)&bTypeRef;
			switch(	GetSymbolClass(tempBTypeRef) )
			{
				case SYMBOL_BUILTIN_TYPE_REF:
				{
					type = ((SIMCBuiltInTypeReference *)bTypeRef)->GetType();
					switch( GetTypeClass(type) )
					{
						case TYPE_ENUM_OR_BITS:
							retValEnumType = (SIMCEnumOrBitsType *)type;
							return RESOLVE_CORRECT;
						default:
							return RESOLVE_UNDEFINED;
					}
				}
				break;
				case SYMBOL_TEXTUAL_CONVENTION:
				{
					return RESOLVE_UNDEFINED;
				}
				break;
			}
		}
		break;
	}
	return RESOLVE_UNDEFINED;

}

SIMCResolutionStatus SIMCModule::IsTypeReference(SIMCSymbol **symbol,
									SIMCTypeReference * &retVal)
{
	switch(SIMCModule::GetSymbolClass(symbol))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF: 
			retVal = (SIMCBuiltInTypeReference *)(*symbol);
			return RESOLVE_CORRECT;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SIMCDefinedTypeReference * valueDefTypeRef = (SIMCDefinedTypeReference*)(*symbol);
			switch(valueDefTypeRef->GetStatus())
			{
				case RESOLVE_IMPORT:
					return RESOLVE_IMPORT;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					return RESOLVE_UNDEFINED;
				case RESOLVE_CORRECT:
					retVal = valueDefTypeRef->GetRealType();
					return RESOLVE_CORRECT;
					break;
			}
			break;
		}
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_UNDEFINED;

}

SIMCResolutionStatus SIMCModule::IsValueReference(SIMCSymbol **s,
									SIMCSymbol ** &retTypeRef,
									SIMCBuiltInValueReference *&retVal)
{
	retTypeRef = NULL;
	retVal = NULL;

	switch(GetSymbolClass(s))
	{
		case SIMCModule::SYMBOL_IMPORT:
			return RESOLVE_IMPORT;

		case SYMBOL_BUILTIN_VALUE_REF:
			retVal = (SIMCBuiltInValueReference*)(*s);
			retTypeRef = ((SIMCBuiltInValueReference*)(*s))->GetTypeReference();
			return RESOLVE_CORRECT;

		case SYMBOL_DEFINED_VALUE_REF:
		{
			SIMCDefinedValueReference *d = (SIMCDefinedValueReference*)(*s);
			retTypeRef = d->GetTypeReference();

			switch(d->GetStatus())
			{
				case RESOLVE_IMPORT:
					return RESOLVE_IMPORT;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					return RESOLVE_UNDEFINED;
				case RESOLVE_CORRECT:
					retVal = d->GetRealValue();
					return RESOLVE_CORRECT;
			}
		}
		default:
			return RESOLVE_UNDEFINED;
	}
	return RESOLVE_UNDEFINED;
}

SIMCResolutionStatus SIMCModule::IsSequenceTypeReference(SIMCSymbol **symbol,
								SIMCBuiltInTypeReference * &retVal1,
								SIMCSequenceType *&retVal2)
{
	SIMCTypeReference *typeRef;
	switch(IsTypeReference(symbol, typeRef)	)
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
		case RESOLVE_CORRECT:
		{
			SIMCSymbol **tempTypeRef = (SIMCSymbol **)&typeRef;
			switch(GetSymbolClass(tempTypeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
				{
					retVal1 = (SIMCBuiltInTypeReference *)typeRef;
					SIMCType *type = ((SIMCBuiltInTypeReference *)retVal1)->GetType();
					switch(GetTypeClass(type))
					{
						case TYPE_SEQUENCE:
							retVal2 = (SIMCSequenceType *)type;
							return RESOLVE_CORRECT;
						default:
							return RESOLVE_UNDEFINED;
					}
				}
				break;
				case SYMBOL_TEXTUAL_CONVENTION:
				{
					return RESOLVE_UNDEFINED;
				}
				break;
			}
		}
	}
	return RESOLVE_UNDEFINED;
}


SIMCResolutionStatus SIMCModule::IsSequenceOfTypeReference(SIMCSymbol **symbol,
								SIMCBuiltInTypeReference * &retVal1,
								SIMCSequenceOfType *&retVal2)
{
	SIMCTypeReference *typeRef;
	switch(IsTypeReference(symbol, typeRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
		case RESOLVE_CORRECT:
		{
			SIMCSymbol **tempTypeRef = 	(SIMCSymbol **)&typeRef;
			switch(GetSymbolClass(tempTypeRef))
			{
				case SYMBOL_BUILTIN_TYPE_REF:
				{
					retVal1 = (SIMCBuiltInTypeReference *)typeRef;
					SIMCType *type = retVal1->GetType();
					switch(GetTypeClass(type))
					{
						case TYPE_SEQUENCE_OF:
							retVal2 = (SIMCSequenceOfType *)type;
							return RESOLVE_CORRECT;
						default:
							return RESOLVE_UNDEFINED;
					}
				}
				break;
				case SYMBOL_TEXTUAL_CONVENTION:
				{
					return RESOLVE_UNDEFINED;
				}
				break;
			}
		}
	}
	return RESOLVE_UNDEFINED;
}

SIMCResolutionStatus SIMCModule::IsNamedNode(SIMCSymbol **symbol)
{

	// See whether the symbol is a value reference
	SIMCBuiltInValueReference *bvRef;
	SIMCSymbol **dummy;
	switch(IsValueReference(symbol, dummy, bvRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	// See whether the type of the symbol is OID
	SIMCSymbol **typeRef = ((SIMCValueReference *)(*symbol))->GetTypeReference();
	SIMCTypeReference *btRef;
	switch(IsTypeReference(typeRef, btRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **tempBtRef = (SIMCSymbol**)&btRef;
	switch(GetSymbolClass(tempBtRef))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
		{
			if(GetPrimitiveType((SIMCBuiltInTypeReference *)btRef) != PRIMITIVE_OID &&
				GetTypeClass(((SIMCBuiltInTypeReference *)btRef)->GetType()) != TYPE_OBJECT_IDENTITY )
				return RESOLVE_UNDEFINED;
		}
		break;
		case SYMBOL_TEXTUAL_CONVENTION:
		{
			return RESOLVE_UNDEFINED;
		}
		break;
	}

	// See whether it's value is an OID
	if(SIMCModule::GetValueClass(bvRef->GetValue()) != SIMCModule::VALUE_OID)
		return RESOLVE_UNDEFINED;

	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsScalar(SIMCSymbol **symbol)
{
	SIMCObjectTypeType *objType;

	switch(IsObjectType(symbol, objType))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **syntaxSymbol = objType->GetSyntax();
	SIMCTypeReference *btRef;
	switch(IsTypeReference(syntaxSymbol, btRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **tempBtRef = (SIMCSymbol**)&btRef;
	switch(GetSymbolClass(tempBtRef))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(GetTypeClass(((SIMCBuiltInTypeReference *)btRef)->GetType()))
			{
				case TYPE_SEQUENCE:
				case TYPE_SEQUENCE_OF:
					return RESOLVE_UNDEFINED;
				default:
					return RESOLVE_CORRECT;
			}
		}
		break;
		case SYMBOL_TEXTUAL_CONVENTION:
		{
			return RESOLVE_CORRECT;
		}
		break;
	}


	

	return RESOLVE_CORRECT;
}

SIMCResolutionStatus SIMCModule::IsTable(SIMCSymbol **symbol)
{
	SIMCObjectTypeType *objType;

	switch(IsObjectType(symbol, objType))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **syntaxSymbol = objType->GetSyntax();
	SIMCBuiltInTypeReference *btRef;
	SIMCSequenceOfType *type;
	return IsSequenceOfTypeReference(syntaxSymbol, btRef, type);
}

SIMCResolutionStatus SIMCModule::IsRow(SIMCSymbol **symbol)
{
	SIMCObjectTypeType *objType;

	switch(IsObjectType(symbol, objType))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCSymbol **syntaxSymbol = objType->GetSyntax();
	SIMCBuiltInTypeReference *btRef;
	SIMCSequenceType *type;
	return IsSequenceTypeReference(syntaxSymbol, btRef, type);
}

SIMCResolutionStatus SIMCModule::IsFixedSizeObject(SIMCObjectTypeType *objectType)
{
	SIMCSymbol ** syntaxSymbol = objectType->GetSyntax();
	SIMCTypeReference *typeRef;
	switch(IsTypeReference(syntaxSymbol, typeRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCType *type = NULL;
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol**)&typeRef;
	switch(GetSymbolClass(tempTypeRef))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
			type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			break;
		case SYMBOL_TEXTUAL_CONVENTION:
			switch(GetPrimitiveType(typeRef->GetSymbolName()))
			{
				case PRIMITIVE_MAC_ADDRESS:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_FALSE;
			}
			break;
	}

	switch(GetTypeClass(type))
	{
		case TYPE_INVALID:
		case TYPE_SEQUENCE_OF:
		case TYPE_SEQUENCE:
		case TYPE_TRAP_TYPE:
		case TYPE_NOTIFICATION_TYPE:
		case TYPE_OBJECT_TYPE_V1:
		case TYPE_OBJECT_TYPE_V2:
		case TYPE_OBJECT_IDENTITY:
			return RESOLVE_FALSE;

		case TYPE_PRIMITIVE:
			switch(GetPrimitiveType(typeRef->GetSymbolName()))
			{
				case PRIMITIVE_INTEGER:
				case PRIMITIVE_BOOLEAN:
				case PRIMITIVE_BITS:
				case PRIMITIVE_NULL:
				case PRIMITIVE_IP_ADDRESS:
				case PRIMITIVE_TIME_TICKS:
				case PRIMITIVE_MAC_ADDRESS:
				case PRIMITIVE_INTEGER_32:
				case PRIMITIVE_COUNTER_32:
				case PRIMITIVE_GAUGE_32:
				case PRIMITIVE_COUNTER_64:
				case PRIMITIVE_UNSIGNED_32:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_FALSE;
			}
			break;
		case TYPE_RANGE:
		case TYPE_ENUM_OR_BITS:
			return RESOLVE_CORRECT;
		case TYPE_SIZE:
			return (((SIMCSizeType*)type)->IsFixedSize())? RESOLVE_CORRECT : RESOLVE_FALSE;
	}
	return RESOLVE_UNDEFINED;

}

SIMCResolutionStatus SIMCModule::IsNotZeroSizeObject(SIMCObjectTypeType *objectType)
{
	SIMCSymbol ** syntaxSymbol = objectType->GetSyntax();
	SIMCTypeReference *typeRef;
	switch(IsTypeReference(syntaxSymbol, typeRef))
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return RESOLVE_UNDEFINED;
		case RESOLVE_IMPORT:
			return RESOLVE_IMPORT;
	}

	SIMCType *type = NULL;
	SIMCSymbol **tempTypeRef = (SIMCSymbol**)&typeRef;
	switch(GetSymbolClass(tempTypeRef))
	{
		case SYMBOL_BUILTIN_TYPE_REF:
			type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			break;
		case SYMBOL_TEXTUAL_CONVENTION:
			switch(GetPrimitiveType(typeRef->GetSymbolName()))
			{
				case PRIMITIVE_MAC_ADDRESS:
				case PRIMITIVE_DATE_AND_TIME:
					return RESOLVE_CORRECT;
				default:
					return RESOLVE_FALSE;
			}
			break;
	}

	switch(GetTypeClass(type))
	{
		case TYPE_INVALID:
		case TYPE_SEQUENCE_OF:
		case TYPE_SEQUENCE:
		case TYPE_TRAP_TYPE:
		case TYPE_NOTIFICATION_TYPE:
		case TYPE_OBJECT_TYPE_V1:
		case TYPE_OBJECT_TYPE_V2:
		case TYPE_OBJECT_IDENTITY:
			return RESOLVE_FALSE;

		case TYPE_PRIMITIVE:
			switch(GetPrimitiveType(typeRef->GetSymbolName()))
			{
				case PRIMITIVE_INTEGER:
				case PRIMITIVE_BOOLEAN:
				case PRIMITIVE_BITS:
				case PRIMITIVE_IP_ADDRESS:
				case PRIMITIVE_TIME_TICKS:
				case PRIMITIVE_MAC_ADDRESS:
				case PRIMITIVE_INTEGER_32:
				case PRIMITIVE_COUNTER_32:
				case PRIMITIVE_GAUGE_32:
				case PRIMITIVE_COUNTER_64:
				case PRIMITIVE_UNSIGNED_32:
						return RESOLVE_CORRECT;
				default:
						return RESOLVE_FALSE;
			}
			break;
		case TYPE_RANGE:
		case TYPE_ENUM_OR_BITS:
			return RESOLVE_CORRECT;
		case TYPE_SIZE:
			return (((SIMCSizeType*)type)->IsNotZeroSizeObject())? RESOLVE_CORRECT : RESOLVE_FALSE;
	}
	return RESOLVE_UNDEFINED;

}

// This fabricates NOTICFICATION-TYPEs from TRAP-TYPEs and then proceeds to
// fabricate NOTIFICATION-GROUPs from them.
BOOL SIMCModule::FabricateNotificationGroups(SIMCParseTree& theParseTree,
											 const SIMCOidTree& theOidTree)
{

	// Get the symbol for the "INTEGER" type first
	SIMCSymbol **dummy = NULL;
	SIMCSymbol **integerType = NULL;
	if(GetImportedSymbol("INTEGER", integerType, dummy) != UNAMBIGUOUS)
		return FALSE;

	// Convert TRAP-TYPEs to NOTIFICATION-TYPEs and add  them to the list of  NOTIFICATION-TYPES
	// Add the NOTIFICATION-TYPEs without any change
	POSITION p = (_symbolTable)->GetStartPosition();
	SIMCSymbol **symbol = NULL;
	SIMCTrapTypeType *trapType = NULL;
	SIMCNotificationTypeType *notificationType = NULL;
	SIMCSymbol **trapTypeRefSymbol = NULL;
	SIMCBuiltInValueReference *trapIntegerValueRef = NULL;
	SIMCNotificationElement *nextElement = NULL;
	SIMCCleanOidValue *cleanNotificationValue = NULL;
	int trapValue;
	CString s;
	BOOL retVal = TRUE;
	while(p)
	{
		trapType = NULL;
		notificationType = NULL;
		cleanNotificationValue = NULL;

		// Get the next symbol
		(_symbolTable)->GetNextAssoc(p, s, symbol);

		// Is it a value reference? If so, we get the type of the value
		// This type may be SIMCTrapTypeType or SIMCNotificationTypeType or something else
		if(IsValueReference(symbol,	trapTypeRefSymbol,trapIntegerValueRef) 
			!= RESOLVE_CORRECT)
			continue;

		// Is the type SIMCTrapTypeType
		if(IsTrapType(symbol, trapType) == RESOLVE_CORRECT )
		{
			// Convert the TRAP-TYPE to a NOTIFICATION-TYPE

			// Get its integer value
			if(IsIntegerValue((SIMCSymbol **)&trapIntegerValueRef, trapValue) != RESOLVE_CORRECT)
				continue;


			// Create an OBJECTS clause form  the VARIBALES clause
			SIMCVariablesList *variablesList = trapType->GetVariables();
			SIMCObjectsList *objectsList = new SIMCObjectsList();
			POSITION p = variablesList->GetHeadPosition();
			while(p)
			{
				SIMCVariablesItem * nextVariable = variablesList->GetNext(p);
				SIMCObjectsItem *nextObject = new SIMCObjectsItem(nextVariable->_item,
					nextVariable->_line, nextVariable->_column);
				objectsList->AddTail(nextObject);
			}


			// Create the SIMCNotificationType object
			SIMCNotificationTypeType *notificationType = new SIMCNotificationTypeType(
			objectsList,
			trapType->GetDescription(), 
			trapType->GetDescriptionLine(), trapType->GetDescriptionColumn(),
			NULL, 0, 0,
			SIMCNotificationTypeType::STATUS_CURRENT, 0, 0);


			// Create a type reference to the SIMCNotificationTypeType
			SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
					notificationType, "+*", SIMCSymbol::LOCAL, this,
					(*trapTypeRefSymbol)->GetLineNumber(), (*trapTypeRefSymbol)->GetColumnNumber());
			SIMCSymbol **typeRefSymbol = new SIMCSymbol *;
			*typeRefSymbol = (SIMCSymbol *)typeRef;
			
			// Create a name for the value reference which represents the fabricated
			// NOTFICATION-TYPE
			char *fabricatedName = new char [s.GetLength() + 
				SIMCNotificationTypeType::NOTIFICATION_TYPE_FABRICATION_SUFFIX_LEN + 1];
			fabricatedName = strcpy(fabricatedName, s);
			fabricatedName = strcat(fabricatedName, SIMCNotificationTypeType::NOTIFICATION_TYPE_FABRICATION_SUFFIX);
		
			// Add an OID value reference of { enterpriseOid 0 trapValue }
			SIMCOidComponentList *oidList = new SIMCOidComponentList();
			oidList->AddTail(new SIMCOidComponent(trapType->GetEnterprise(),
				trapType->GetEnterpriseLine(), trapType->GetEnterpriseColumn(),
				"", trapType->GetEnterpriseLine(), trapType->GetEnterpriseColumn()));
			SIMCSymbol *zeroVal = new SIMCBuiltInValueReference(integerType, 0, 0, 
				new SIMCIntegerValue(0, TRUE),
				"", SIMCSymbol::LOCAL, this);		
			oidList->AddTail(new SIMCOidComponent(&zeroVal, 
				trapIntegerValueRef->GetLineNumber(), trapIntegerValueRef->GetColumnNumber(),
				"", 0, 0));
			oidList->AddTail(new SIMCOidComponent((SIMCSymbol **)&trapIntegerValueRef, 
				trapIntegerValueRef->GetLineNumber(), trapIntegerValueRef->GetColumnNumber(),
				"", 0, 0));

			SIMCOidValue *notificationOidValue = new  SIMCOidValue(oidList,
				trapIntegerValueRef->GetLineNumber(), trapIntegerValueRef->GetColumnNumber());

			SIMCSymbol ** s = GetSymbol(fabricatedName);	
			if(s) // Symbol exists in symbol table
			{
					retVal = FALSE;
					continue;
			}
			else
			{
				s = new SIMCSymbol *;
				*s = new SIMCBuiltInValueReference (
						typeRefSymbol, 
						typeRef->GetLineNumber(), typeRef->GetColumnNumber(), 
						notificationOidValue,
						fabricatedName, SIMCSymbol::LOCAL, this, 
						(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber());
			}

			// Now create an SIMCNotificationElement with an SIMCCleanOidValue in it
			// Before  that you need an SIMCCleanOidValue object

			// Get the OID value of the ENTERPRISE clause
			SIMCSymbol *enterpriseSymbol = *trapType->GetEnterprise();
			SIMCOidValue *enterpriseOid = NULL;
			if(IsObjectIdentifierValue(&enterpriseSymbol, enterpriseOid) != RESOLVE_CORRECT)
				continue;

			cleanNotificationValue = new SIMCCleanOidValue;
			if(theParseTree.GetCleanOidValue(_inputFileName, enterpriseOid,	*cleanNotificationValue,
								FALSE) != RESOLVE_CORRECT)
			{
				delete cleanNotificationValue;
				continue;
			}

			cleanNotificationValue->AddTail(0);
			cleanNotificationValue->AddTail(trapValue);
			nextElement = new SIMCNotificationElement(*s, cleanNotificationValue, TRUE);

		}
		// Or is the type SIMCNotificationTypeTyep
		else if	(IsNotificationType(symbol, notificationType) == RESOLVE_CORRECT)
		{
			cleanNotificationValue = new SIMCCleanOidValue;
			if(!theOidTree.GetOidValue((*symbol)->GetSymbolName(), 
				(*symbol)->GetModule()->GetModuleName(),
				*cleanNotificationValue)  )
			{
				delete cleanNotificationValue;
				continue;
			}
			nextElement = new SIMCNotificationElement(*symbol, cleanNotificationValue);
		}
		else // Do nothing
			continue;

		// Add the the fabricated or original notification type into the list of 
		// notification types
		_listOfNotificationTypes->AddTail(nextElement);

	}	// while()


	// Now fabricate the NOTIFICATION-GROUP macros. Not implemented yet.
	return retVal;

}


inline UINT AFXAPI HashKey(LPCSTR key)
{
	UINT hashVal = 0;

	int length = strlen(key);

	while (length--)
		hashVal += UINT(key[length]);

	return hashVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\infoyacc.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifdef MODULEINFOTRACE
#define MODULEINFODEBUG 1
#else
#ifndef MODULEINFODEBUG
#define MODULEINFODEBUG 1
#endif
#endif


#include <iostream.h>
#include <fstream.h>

#include "precomp.h"
#include <snmptempl.h>


#include "infoLex.hpp"
#include "infoYacc.hpp"
#include "moduleInfo.hpp"

#define theModuleInfo ((SIMCModuleInfoParser *)this)



extern MODULEINFOSTYPE ModuleInfolval;
#if MODULEINFODEBUG
enum MODULEINFO_Types { MODULEINFO_t_NoneDefined, MODULEINFO_t_yy_name
};
#endif
#if MODULEINFODEBUG
ModuleInfoTypedRules ModuleInfoRules[] = {
	{ "&00: %01 &00",  0},
	{ "%01: %02 &05 %03 &02 %04",  0},
	{ "%02: &07 &11 %05 &12",  1},
	{ "%02: &07 &11 &01 &12",  1},
	{ "%02: &07",  1},
	{ "%02: &09",  1},
	{ "%04: &08 %06 &10",  0},
	{ "%04: &08 &01 &10",  0},
	{ "%04: &08 %07 &10",  0},
	{ "%04: %08",  0},
	{ "%04: &07",  0},
	{ "%04: &09",  0},
	{ "%07: %09",  0},
	{ "%07: %08",  0},
	{ "%09: %09 %10",  0},
	{ "%09: %10",  0},
	{ "%10: %06 &06 %11",  0},
	{ "%10: &01 &06 %11",  0},
	{ "%11: &07 &11 %05 &12",  0},
	{ "%11: &07 &11 &01 &12",  0},
	{ "%11: &07",  0},
	{ "%06: %06 &04 %12",  0},
	{ "%06: %12",  0},
	{ "%12: &07",  0},
	{ "%12: &09",  0},
	{ "%05: %13 %05",  0},
	{ "%05: %13",  0},
	{ "%13: %14",  0},
	{ "%13: &09 &13 &16 &14",  0},
	{ "%13: &09 &13 %14 &14",  0},
	{ "%13: &16",  0},
	{ "%14: &07 &15 &09",  0},
	{ "%14: &09",  0},
	{ "%08:",  0},
	{ "%03: %15",  0},
	{ "%03: &03",  0},
	{ "%15: &17 &17",  0},
	{ "%15: &17 &18",  0},
	{ "%15: &18",  0},
{ "$accept",  0},{ "error",  0}
};
ModuleInfoNamedType ModuleInfoTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "MI_BGIN",  257,  0},
	{ "MI_CCE",  258,  0},
	{ "MI_COMMA",  259,  0},
	{ "MI_DEFINITIONS",  260,  0},
	{ "MI_FROM",  261,  0},
	{ "MI_ID",  262,  1},
	{ "MI_IMPORTS",  263,  0},
	{ "MI_NAME",  264,  1},
	{ "MI_SEMICOLON",  265,  0},
	{ "MI_LBRACE",  266,  0},
	{ "MI_RBRACE",  267,  0},
	{ "MI_LPAREN",  268,  0},
	{ "MI_RPAREN",  269,  0},
	{ "MI_DOT",  270,  0},
	{ "MI_LITNUMBER",  271,  0},
	{ "':'",  58,  0},
	{ "'='",  61,  0}

};
#endif
#if MODULEINFODEBUG
static char *	MODULEINFOStatesFile = "states.out";
long ModuleInfoStates[] = {
0L, 14L, 25L, 88L, 114L, 128L, 172L, 198L, 216L, 227L, 302L, 313L, 346L, 
368L, 390L, 401L, 429L, 440L, 451L, 477L, 495L, 539L, 554L, 577L, 600L, 
615L, 630L, 671L, 690L, 701L, 723L, 745L, 756L, 767L, 778L, 847L, 874L, 
897L, 920L, 931L, 942L, 953L, 964L, 975L, 1008L, 1026L, 1062L, 1116L, 
1134L, 1170L, 1185L, 1204L, 1222L, 1241L, 1259L, 1277L, 1296L, 1371L, 
1390L, 1409L, 1428L, 1472L, 1494L, 1516L, 1539L
};
const MODULEINFOMAX_READ = 75;
#endif
static short ModuleInfodef[] = {

	  40,   -1,   31,   38,   -5,   -9,  -13,    3
};
static short ModuleInfoex[] = {

	   0,    0,   -1,    1,    0,   37,   -1,    1,  265,   37, 
	  -1,    1,  265,   39,   -1,    1
};
static short ModuleInfoact[] = {

	  -1,  -40,  264,  262,  -30,  266,  -29,  260,  -27,  -28, 
	  -3,  -58,  271,  264,  262,  256,  -25,  -65,  -62,  258, 
	  61,   58,  -23,  270,  -22,  268,  -28,   -3,  -58,  271, 
	 264,  262,  -39,  267,  -38,  267,  -63,  -64,   61,   58, 
	  -5,  257,  -59,  264,  -28,  -60,  -20,  271,  264,  262, 
	 -36,   -6,  -45,  264,  263,  262,  -57,  269,  -56,  269, 
	 -18,  -33,  -53,  264,  262,  256,  -16,  -33,  -53,  264, 
	 262,  256,  -43,  265,  -14,  -42,  265,  261,  -13,  -12, 
	 -41,  265,  261,  259,  -14,  261,  -13,  -12,  261,  259, 
	  -8,  262,  -33,  -53,  264,  262,  -11,  266,  -10,  -28, 
	  -3,  -58,  271,  264,  262,  256,  -34,  267,  -35,  267,   -1
};
static short ModuleInfopact[] = {

	   5,    8,   25,   29,   53,   63,   69,   97,  109,  107, 
	 102,   91,   94,   91,   88,   85,   81,   76,   73,   59, 
	  57,   47,   43,   41,   38,   35,   33,   23,   19,   12, 
	   7,    2
};
static short ModuleInfogo[] = {

	  -2,  -31,  -24,  -37,  -54,   -9,  -26,   10,    3,  -15, 
	 -17,    6,  -19,  -46,  -44,    5,   -7,  -47,  -48,    6, 
	 -49,  -50,   11,  -51,  -52,   12,   -4,  -21,  -55,   21, 
	 -61,   -1
};
static short ModuleInfopgo[] = {

	   0,    0,    0,   21,   24,   21,   21,    3,    0,    1, 
	   1,    1,    3,    3,    3,    3,    3,   12,   16,   16, 
	  18,   18,   10,   10,   24,    6,   26,   26,   26,   26, 
	  28,   28,    2,    2,   30,   30,   30,   14,    6,   12, 
	   1,    0
};
static short ModuleInforlen[] = {

	   0,    0,    0,    1,    1,    4,    4,    1,    5,    4, 
	   4,    1,    3,    3,    3,    1,    1,    1,    2,    1, 
	   3,    3,    3,    1,    1,    2,    1,    4,    4,    1, 
	   3,    1,    1,    1,    2,    2,    1,    0,    1,    1, 
	   1,    2
};
#define MODULEINFOS0	31
#define MODULEINFODELTA	28
#define MODULEINFONPACT	32
#define MODULEINFONDEF	8

#define MODULEINFOr39	0
#define MODULEINFOr40	1
#define MODULEINFOr41	2
#define MODULEINFOr20	3
#define MODULEINFOr23	4
#define MODULEINFOr19	5
#define MODULEINFOr18	6
#define MODULEINFOr10	7
#define MODULEINFOr1	8
#define MODULEINFOrACCEPT	MODULEINFOr39
#define MODULEINFOrERROR	MODULEINFOr40
#define MODULEINFOrLR2	MODULEINFOr41
#if MODULEINFODEBUG
char * ModuleInfosvar[] = {
	"$accept",
	"ModuleDefinition",
	"ModuleIdentifier",
	"AllowedCCE",
	"Imports",
	"ObjectIDComponentList",
	"SymbolList",
	"SymbolsImported",
	"empty",
	"SymbolsFromModuleList",
	"SymbolsFromModule",
	"ImportModuleIdentifier",
	"Symbol",
	"ObjectSubID",
	"QualifiedName",
	"InsteadOfCCE",
	0
};
short ModuleInformap[] = {

	  39,   40,   41,   20,   23,   19,   18,   10,    1,    2, 
	   3,    5,    6,    7,    8,    9,   11,   13,   14,   15, 
	  16,   17,   21,   22,   24,   25,   27,   28,   29,   30, 
	  31,   32,   34,   35,   36,   37,   38,   33,   26,   12, 
	   4,    0
};
short ModuleInfosmap[] = {

	   2,    4,    9,   11,   26,   34,   43,   56,   62,   61, 
	  60,   54,   53,   51,   48,   47,   46,   45,   44,   30, 
	  29,   20,   19,   18,   15,   13,   12,    7,    6,    5, 
	   3,    0,   39,   63,   64,   32,   35,   23,   22,    1, 
	  55,   52,   50,   33,   31,   42,   49,   41,   59,   57, 
	  58,   40,   38,   21,   10,   37,   36,    8,   27,   28, 
	  17,   16,   25,   24,   14
};
int ModuleInfo_parse::ModuleInfontoken = 19;
int ModuleInfo_parse::ModuleInfonvar = 16;
int ModuleInfo_parse::ModuleInfonstate = 65;
int ModuleInfo_parse::ModuleInfonrule = 42;
#endif



// C++ YACC parser code
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// If MODULEINFODEBUG is defined as 1 and ModuleInfo_parse::ModuleInfodebug is set to 1,
// ModuleInfoparse() will print a travelogue of its actions as it reads
// and parses input.
//
// MODULEINFOSYNC can be defined to cause ModuleInfoparse() to attempt to always
// hold a lookahead token

const MODULEINFO_MIN_STATE_NUM = 20;	// not useful to be too small!

#if MODULEINFODEBUG
#ifdef MODULEINFOTRACE
long	* ModuleInfo_parse::States	= ModuleInfoStates;
#endif
ModuleInfoTypedRules * ModuleInfo_parse::Rules	= ModuleInfoRules;
ModuleInfoNamedType * ModuleInfo_parse::TokenTypes = ModuleInfoTokenTypes;

#define MODULEINFO_TRACE(fn) { done = 0; fn(); if (done) MODULEINFORETURN(-1); }
#endif

// Constructor for ModuleInfo_parse: user-provided tables
ModuleInfo_parse::ModuleInfo_parse(int sz, short * states, MODULEINFOSTYPE * stack)
{
	mustfree = 0;
	if ((size = sz) < MODULEINFO_MIN_STATE_NUM
	 || (stateStack = states) == (short *) 0
	 || (valueStack = stack) == (MODULEINFOSTYPE *) 0) {
		fprintf(stderr,"Bad state/stack given");
		exit(1);
	}
	reset = 1;		// force reset
#if MODULEINFODEBUG
	ModuleInfodebug = 0;
	typeStack = new short[size+1];
	if (typeStack == (short *) 0) {
		fprintf(stderr,"Cannot allocate typeStack");
		exit(1);
	}
#endif
}
// Constructor for ModuleInfo_parse: allocate tables with new
ModuleInfo_parse::ModuleInfo_parse(int sz)
{
	size = sz;
	reset = 1;		// force reset
	mustfree = 1;		// delete space in deconstructor
#if MODULEINFODEBUG
	ModuleInfodebug = 0;
	typeStack = new short[size+1];
#endif
	stateStack = new short[size+1];
	valueStack = new MODULEINFOSTYPE[size+1];

	if (stateStack == (short *) 0 || valueStack == (MODULEINFOSTYPE *) 0
#if MODULEINFODEBUG
		|| typeStack == (short *) 0
#endif
	    ) {
		fprintf(stderr,"Not enough space for parser stacks");
		exit(1);
	}
}
// Destructor for class ModuleInfo_parse
//	Free up space
ModuleInfo_parse::~ModuleInfo_parse()
{
	if (mustfree) {
		delete stateStack;
		delete valueStack;
	}
	stateStack = (short *) 0;
#if MODULEINFODEBUG
	delete typeStack;
#endif
}

#ifdef YACC_WINDOWS

// The initial portion of the yacc parser.
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_ModuleInfoparse() to acutally begin the
// parsing. When complete, win_ModuleInfoparse() will return a
// value back to our new ModuleInfoparse() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of ModuleInfoparse().

int
ModuleInfo_parse::ModuleInfoparse(ModuleInfo_scan* ps)
{
	int wReturnValue;
	HANDLE hRes_table;
	short *old_ModuleInfodef;		// the following are used for saving
	short *old_ModuleInfoex;		// the current pointers
	short *old_ModuleInfoact;
	short *old_ModuleInfopact;
	short *old_ModuleInfogo;
	short *old_ModuleInfopgo;
	short *old_ModuleInforlen;

	// the following code will load the required
	// resources for a Windows based parser.

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_ModuleInfoYACC", "ModuleInfoYACCTBL"));
	
	// return an error code if any
	// of the resources did not load

	if (hRes_table == (HANDLE)NULL)
		return (1);
	
	// the following code will lock the resources
	// into fixed memory locations for the parser
	// (also, save away the old pointer values)

	old_ModuleInfodef = ModuleInfodef;
	old_ModuleInfoex = ModuleInfoex;
	old_ModuleInfoact = ModuleInfoact;
	old_ModuleInfopact = ModuleInfopact;
	old_ModuleInfogo = ModuleInfogo;
	old_ModuleInfopgo = ModuleInfopgo;
	old_ModuleInforlen = ModuleInforlen;

	ModuleInfodef = (short *)LockResource (hRes_table);
	ModuleInfoex = (short *)(ModuleInfodef + Sizeof_ModuleInfodef);
	ModuleInfoact = (short *)(ModuleInfoex + Sizeof_ModuleInfoex);
	ModuleInfopact = (short *)(ModuleInfoact + Sizeof_ModuleInfoact);
	ModuleInfogo = (short *)(ModuleInfopact + Sizeof_ModuleInfopact);
	ModuleInfopgo = (short *)(ModuleInfogo + Sizeof_ModuleInfogo);
	ModuleInforlen = (short *)(ModuleInfopgo + Sizeof_ModuleInfopgo);

	// call the official ModuleInfoparse() function

	wReturnValue = win_ModuleInfoparse (ps);

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previous pointer values
	//

	ModuleInfodef = old_ModuleInfodef;
	ModuleInfoex = old_ModuleInfoex;
	ModuleInfoact = old_ModuleInfoact;
	ModuleInfopact = old_ModuleInfopact;
	ModuleInfogo = old_ModuleInfogo;
	ModuleInfopgo = old_ModuleInfopgo;
	ModuleInforlen = old_ModuleInforlen;

	return (wReturnValue);
}	// end ModuleInfoparse()


// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling ModuleInfoparse().
//	Call ModuleInforeset() before ModuleInfoparse() if you want a fresh start

int
ModuleInfo_parse::win_ModuleInfoparse(ModuleInfo_scan* ps)

#else /* YACC_WINDOWS */

// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling ModuleInfoparse().
//	Call ModuleInforeset() before ModuleInfoparse() if you want a fresh start
int
ModuleInfo_parse::ModuleInfoparse(ModuleInfo_scan* ps)

#endif /* YACC_WINDOWS */

{
	short	* ModuleInfop, * ModuleInfoq;		// table lookup
	int	ModuleInfoj;
#if MODULEINFODEBUG
	int	ModuleInforuletype = 0;
#endif

	if ((scan = ps) == (ModuleInfo_scan *) 0) {	// scanner
		fprintf(stderr,"No scanner");
		exit(1);
	}

	if (reset) {			// start new parse
		ModuleInfonerrs = 0;
		ModuleInfoerrflag = 0;
		ModuleInfops = stateStack;
		ModuleInfopv = valueStack;
#if MODULEINFODEBUG
		ModuleInfotp = typeStack;
#endif
		ModuleInfostate = MODULEINFOS0;
		ModuleInfoclearin();
		reset = 0;
	} else			// continue saved parse
		goto ModuleInfoNext;			// after action

ModuleInfoStack:
	if (++ModuleInfops > &stateStack[size]) {
		scan->ModuleInfoerror("Parser stack overflow");
		MODULEINFOABORT;
	}
	*ModuleInfops = ModuleInfostate;	/* stack current state */
	*++ModuleInfopv = ModuleInfoval;	/* ... and value */
#if MODULEINFODEBUG
	if (ModuleInfodebug) {
		*++ModuleInfotp = (short)ModuleInforuletype;	/* ... and type */
		MODULEINFO_TRACE(ModuleInfoShowState)
	}
#endif

	/*
	 * Look up next action in action table.
	 */
ModuleInfoEncore:
#ifdef MODULEINFOSYNC
	if (ModuleInfochar < 0) {
		if ((ModuleInfochar = scan->ModuleInfolex()) < 0) {
			if (ModuleInfochar == -2) MODULEINFOABORT;
			ModuleInfochar = 0;
		}	/* endif */
		ModuleInfolval = ::ModuleInfolval;
#if MODULEINFODEBUG
		if (ModuleInfodebug)
			ModuleInfoShowRead();	// show new input token
#endif
	}
#endif
#ifdef YACC_WINDOWS
	if (ModuleInfostate >= Sizeof_ModuleInfopact) 	/* simple state */
#else /* YACC_WINDOWS */
	if (ModuleInfostate >= sizeof ModuleInfopact/sizeof ModuleInfopact[0]) 	/* simple state */
#endif /* YACC_WINDOWS */
		ModuleInfoi = ModuleInfostate - MODULEINFODELTA;	/* reduce in any case */
	else {
		if(*(ModuleInfop = &ModuleInfoact[ModuleInfopact[ModuleInfostate]]) >= 0) {
			/* Look for a shift on ModuleInfochar */
#ifndef MODULEINFOSYNC
			if (ModuleInfochar < 0) {
				if ((ModuleInfochar = scan->ModuleInfolex()) < 0) {
					if (ModuleInfochar == -2) MODULEINFOABORT;
					ModuleInfochar = 0;
				}	/* endif */
				ModuleInfolval = ::ModuleInfolval;
#if MODULEINFODEBUG
				if (ModuleInfodebug)
					ModuleInfoShowRead();	// show new input token
#endif
			}
#endif
			ModuleInfoq = ModuleInfop;
			ModuleInfoi = (short)ModuleInfochar;
			while (ModuleInfoi < *ModuleInfop++)
				;
			if (ModuleInfoi == ModuleInfop[-1]) {
				ModuleInfostate = ~ModuleInfoq[ModuleInfoq-ModuleInfop];
#if MODULEINFODEBUG
				if (ModuleInfodebug) {
					ModuleInforuletype = ModuleInfoGetType(ModuleInfochar);
					MODULEINFO_TRACE(ModuleInfoShowShift)
				}
#endif
				ModuleInfoval = ModuleInfolval;		/* stack value */
				ModuleInfoclearin();		/* clear token */
				if (ModuleInfoerrflag)
					ModuleInfoerrflag--;	/* successful shift */
				goto ModuleInfoStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

#ifdef YACC_WINDOWS
		if (ModuleInfostate >= Sizeof_ModuleInfodef) 	/* simple state */
#else /* YACC_WINDOWS */
		if (ModuleInfostate >= sizeof ModuleInfodef /sizeof ModuleInfodef[0])
#endif /* YACC_WINDOWS */
			goto ModuleInfoError;
		if ((ModuleInfoi = ModuleInfodef[ModuleInfostate]) < 0)	 { /* default == reduce? */

			/* Search exception table */
			ModuleInfop = &ModuleInfoex[~ModuleInfoi];
#ifndef MODULEINFOSYNC
			if (ModuleInfochar < 0) {
				if ((ModuleInfochar = scan->ModuleInfolex()) < 0) {
					if (ModuleInfochar == -2) MODULEINFOABORT;
					ModuleInfochar = 0;
				}	/* endif */
				ModuleInfolval = ::ModuleInfolval;
#if MODULEINFODEBUG
				if (ModuleInfodebug)
					ModuleInfoShowRead();	// show new input token
#endif
			}
#endif
			while((ModuleInfoi = *ModuleInfop) >= 0 && ModuleInfoi != ModuleInfochar)
				ModuleInfop += 2;
			ModuleInfoi = ModuleInfop[1];
		}
	}

	ModuleInfoj = ModuleInforlen[ModuleInfoi];

#if MODULEINFODEBUG
	if (ModuleInfodebug) {
		npop = ModuleInfoj; rule = ModuleInfoi;
		MODULEINFO_TRACE(ModuleInfoShowReduce)
		ModuleInfotp -= ModuleInfoj;
	}
#endif
	ModuleInfops -= ModuleInfoj;		/* pop stacks */
	ModuleInfopvt = ModuleInfopv;		/* save top */
	ModuleInfopv -= ModuleInfoj;
	ModuleInfoval = ModuleInfopv[1];	/* default action $ = $1 */
#if MODULEINFODEBUG
	if (ModuleInfodebug)
		ModuleInforuletype = ModuleInfoRules[ModuleInformap[ModuleInfoi]].type;
#endif
	switch (ModuleInfoi) {		/* perform semantic action */
		
case MODULEINFOr1: {	/* ModuleDefinition :  ModuleIdentifier MI_DEFINITIONS AllowedCCE MI_BGIN Imports */

						theModuleInfo->SetModuleName(ModuleInfopvt[-4].yy_name);
						return 0;
					
} break;

case MODULEINFOr10: {	/* Imports :  MI_ID */

			delete ModuleInfopvt[0].yy_name;
		
} break;

case MODULEINFOr18: {	/* ImportModuleIdentifier :  MI_ID MI_LBRACE ObjectIDComponentList MI_RBRACE */

			theModuleInfo->AddImportModule(ModuleInfopvt[-3].yy_name);
			delete ModuleInfopvt[-3].yy_name;
		
} break;

case MODULEINFOr19: {	/* ImportModuleIdentifier :  MI_ID MI_LBRACE error MI_RBRACE */

			theModuleInfo->AddImportModule(ModuleInfopvt[-3].yy_name);
			delete ModuleInfopvt[-3].yy_name;
		
} break;

case MODULEINFOr20: {	/* ImportModuleIdentifier :  MI_ID */

			theModuleInfo->AddImportModule(ModuleInfopvt[0].yy_name);
			delete ModuleInfopvt[0].yy_name;
		
} break;

case MODULEINFOr23: {	/* Symbol :  MI_ID */

			delete ModuleInfopvt[0].yy_name;
		
} break;
	case MODULEINFOrACCEPT:
		MODULEINFOACCEPT;
	case MODULEINFOrERROR:
		goto ModuleInfoError;
	}
ModuleInfoNext:
	/*
	 *	Look up next state in goto table.
	 */

	ModuleInfop = &ModuleInfogo[ModuleInfopgo[ModuleInfoi]];
	ModuleInfoq = ModuleInfop++;
	ModuleInfoi = *ModuleInfops;
	while (ModuleInfoi < *ModuleInfop++)		/* busy little loop */
		;
	ModuleInfostate = ~(ModuleInfoi == *--ModuleInfop? ModuleInfoq[ModuleInfoq-ModuleInfop]: *ModuleInfoq);
#if MODULEINFODEBUG
	if (ModuleInfodebug)
		MODULEINFO_TRACE(ModuleInfoShowGoto)
#endif
	goto ModuleInfoStack;

#if 0 //removed because of build warning
ModuleInfoerrlabel:	;		/* come here from MODULEINFOERROR	*/
#endif

	ModuleInfoerrflag = 1;
	if (ModuleInfoi == MODULEINFOrERROR) {
		ModuleInfops--, ModuleInfopv--;
#if MODULEINFODEBUG
		if (ModuleInfodebug) ModuleInfotp--;
#endif
	}
	
ModuleInfoError:
	switch (ModuleInfoerrflag) {

	case 0:		/* new error */
		ModuleInfonerrs++;
		ModuleInfoi = (short)ModuleInfochar;
		scan->ModuleInfoerror("Syntax error");
		if (ModuleInfoi != ModuleInfochar) {
			/* user has changed the current token */
			/* try again */
			ModuleInfoerrflag++;	/* avoid loops */
			goto ModuleInfoEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		ModuleInfoerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; ModuleInfops > stateStack; ModuleInfops--, ModuleInfopv--
#if MODULEINFODEBUG
					, ModuleInfotp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*ModuleInfops >= Sizeof_ModuleInfopact) 	/* simple state */
#else /* YACC_WINDOWS */
			if (*ModuleInfops >= sizeof ModuleInfopact/sizeof ModuleInfopact[0])
#endif /* YACC_WINDOWS */
				continue;
			ModuleInfop = &ModuleInfoact[ModuleInfopact[*ModuleInfops]];
			ModuleInfoq = ModuleInfop;
			do
				;
			while (MODULEINFOERRCODE < *ModuleInfop++);
			if (MODULEINFOERRCODE == ModuleInfop[-1]) {
				ModuleInfostate = ~ModuleInfoq[ModuleInfoq-ModuleInfop];
				goto ModuleInfoStack;
			}
				
			/* no shift in this state */
#if MODULEINFODEBUG
			if (ModuleInfodebug && ModuleInfops > stateStack+1)
				MODULEINFO_TRACE(ModuleInfoShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (ModuleInfochar == 0)  /* but not EOF */
			break;
#if MODULEINFODEBUG
		if (ModuleInfodebug)
			MODULEINFO_TRACE(ModuleInfoShowErrDiscard)
#endif
		ModuleInfoclearin();
		goto ModuleInfoEncore;	/* try again in same state */
	}
	MODULEINFOABORT;

}
#if MODULEINFODEBUG
/*
 * Return type of token
 */
int
ModuleInfo_parse::ModuleInfoGetType(int tok)
{
	ModuleInfoNamedType * tp;
	for (tp = &ModuleInfoTokenTypes[ModuleInfontoken-1]; tp > ModuleInfoTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}

	
// Print a token legibly.
char *
ModuleInfo_parse::ModuleInfoptok(int tok)
{
	ModuleInfoNamedType * tp;
	for (tp = &ModuleInfoTokenTypes[ModuleInfontoken-1]; tp > ModuleInfoTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}
/*
 * Read state 'num' from MODULEINFOStatesFile
 */
#ifdef MODULEINFOTRACE

char *
ModuleInfo_parse::ModuleInfogetState(int num)
{
	int	size;
	char	*cp;
	static FILE *ModuleInfoStatesFile = (FILE *) 0;
	static char ModuleInfoReadBuf[MODULEINFOMAX_READ+1];

	if (ModuleInfoStatesFile == (FILE *) 0
	 && (ModuleInfoStatesFile = fopen(MODULEINFOStatesFile, "r")) == (FILE *) 0)
		return "ModuleInfoExpandName: cannot open states file";

	if (num < ModuleInfonstate - 1)
		size = (int)(States[num+1] - States[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(ModuleInfoStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(ModuleInfoStatesFile) - States[num]);
	}
	if (size < 0 || size > MODULEINFOMAX_READ)
		return "ModuleInfoExpandName: bad read size";
	if (fseek(ModuleInfoStatesFile, States[num], 0) < 0) {
	cannot_seek:
		return "ModuleInfoExpandName: cannot seek in states file";
	}

	(void) fread(ModuleInfoReadBuf, 1, size, ModuleInfoStatesFile);
	ModuleInfoReadBuf[size] = '\0';
	return ModuleInfoReadBuf;
}
#endif /* MODULEINFOTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode ModuleInfoStates and ModuleInfoRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
ModuleInfo_parse::ModuleInfoExpandName(int num, int isrule, char * buf, int len)
{
	int	i, n, cnt, type;
	char	* endp, * cp, * s;

	if (isrule)
		s = ModuleInfoRules[num].name;
	else
#ifdef MODULEINFOTRACE
		s = ModuleInfogetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = ModuleInfonvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = ModuleInfontoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= ModuleInfonvar)
					goto too_big;
				cp = ModuleInfosvar[n];
			} else if (n >= ModuleInfontoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = ModuleInfoTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef MODULEINFOTRACE
/*
 * Show current state of ModuleInfoparse
 */
void
ModuleInfo_parse::ModuleInfoShowState()
{
	(void) printf("state %d (%d), char %s (%d)\n%d stateStack entries\n",
		ModuleInfosmap[ModuleInfostate],ModuleInfostate,ModuleInfoptok(ModuleInfochar),ModuleInfochar,
		ModuleInfopv - valueStack);
}
// show results of reduction: ModuleInfoi is rule number
void
ModuleInfo_parse::ModuleInfoShowReduce()
{
	(void) printf("Reduce by rule %d (pop#=%d)\n", ModuleInformap[rule], npop);
}
// show read token
void
ModuleInfo_parse::ModuleInfoShowRead()
{
	(void) printf("read %s (%d)\n", ModuleInfoptok(ModuleInfochar), ModuleInfochar);
}
// show Goto
void
ModuleInfo_parse::ModuleInfoShowGoto()
{
	(void) printf("goto %d (%d)\n", ModuleInfosmap[ModuleInfostate], ModuleInfostate);
}
// show Shift
void
ModuleInfo_parse::ModuleInfoShowShift()
{
	(void) printf("shift %d (%d)\n", ModuleInfosmap[ModuleInfostate], ModuleInfostate);
}
// show error recovery
void
ModuleInfo_parse::ModuleInfoShowErrRecovery()
{
	(void) printf("Error recovery pops state %d (%d), uncovers %d (%d)\n",
		ModuleInfosmap[*(ModuleInfops-1)], *(ModuleInfops-1), ModuleInfosmap[ModuleInfostate], ModuleInfostate);
}
// show token discards in error processing
void
ModuleInfo_parse::ModuleInfoShowErrDiscard()
{
	(void) printf("Error recovery discards %s (%d), ",
		ModuleInfoptok(ModuleInfochar), ModuleInfochar);
}
#endif	/* ! MODULEINFOTRACE */
#endif	/* MODULEINFODEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\notificationtype.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "notificationType.hpp"


const char *const SIMCNotificationTypeType::NOTIFICATION_TYPE_FABRICATION_SUFFIX = "V1NotificationType";
const int SIMCNotificationTypeType::NOTIFICATION_TYPE_FABRICATION_SUFFIX_LEN  = 18;

SIMCNotificationTypeType::SIMCNotificationTypeType( SIMCObjectsList *objects,
					char * description,
					long descriptionLine, long descriptionColumn,
					char *reference,
					long referenceLine, long referenceColumn,
					StatusType status,
					long statusLine, long statusColumn)
					:	_objects(objects),
						_descriptionLine(descriptionLine), _descriptionColumn(descriptionColumn),
						_referenceLine(referenceLine), _referenceColumn(referenceColumn),
						_status(status),
						_statusLine(statusLine), _statusColumn(statusColumn)
{

	if (objects)
	{
		POSITION p = objects->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (objects->GetNext(p))->_item;
			(*s)->IncrementReferenceCount();
		}
	}

	_description = NewString(description);
	_reference = NewString(reference);
}

SIMCNotificationTypeType::~SIMCNotificationTypeType()
{

	if (UseReferenceCount() && _objects)
	{
		POSITION p = _objects->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (_objects->GetNext(p))->_item;
			(*s)->DecrementReferenceCount();
		}
	}

	if(_description)
		delete [] _description;
	if(_reference)
		delete [] _reference;
}

SIMCNotificationTypeType::StatusType SIMCNotificationTypeType::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "current") == 0)
			return STATUS_CURRENT;
		else if (strcmp(s, "deprecated") == 0)
			return STATUS_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return STATUS_OBSOLETE;
		else
			return STATUS_INVALID;
	}
	return STATUS_INVALID;
}

void SIMCNotificationTypeType::WriteType(ostream& outStream) const
{
	outStream << "SIMCNotificationTypeType::WriteType() : NOT YET IMPLEMENTED" << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\notificationgroup.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>
#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"



const char * const SIMCNotificationGroup::StatusStringsTable[] = 
{
	"current",
	"deprecated",
	"obsolete"
};

const char *const SIMCNotificationGroup::NOTIFICATION_GROUP_FABRICATION_SUFFIX = "V1NotificationGroup";
const int SIMCNotificationGroup::NOTIFICATION_GROUP_FABRICATION_SUFFIX_LEN = 19;


ostream& operator << (ostream& outStream, const SIMCNotificationElement& obj)
{
	outStream << "NOTIFICATION: " << obj.symbol->GetSymbolName() <<  "(" <<
		(obj.symbol->GetModule())->GetModuleName() << ")" << endl;
	return outStream;
}



ostream& operator << (ostream& outStream, const SIMCNotificationGroup& obj)
{

	 outStream << "Notification Group: " << (obj.enterpriseNode)->GetSymbolName() << endl;
	POSITION p;
	if(obj.notifications)
	{
		p = (obj.notifications)->GetHeadPosition();
		while(p)
			outStream << (*(obj.notifications)->GetNext(p)) ;
	}

	outStream << "End of Notification Group =================================" << endl;
	return outStream;
}

ostream& operator << (ostream& outStream, const SIMCNotificationList& obj)
{
	outStream << "NOTIFICATION GROUPS:" << endl;

	POSITION p = obj.GetHeadPosition();
	while(p)
		outStream << (* obj.GetNext(p)) ;
	outStream << "END OF NOTIFICATION GROUPS" << endl;
	return outStream;
}



BOOL SIMCModuleNotificationGroups::AddNotification(SIMCSymbol *notificationSymbol)
{
	// NOT IMPELEMNTED
	return FALSE;
}

const SIMCNotificationGroupList *SIMCModuleNotificationGroups::GetNotificationGroupList() const
{
	return &theList;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\newstring.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"
#include "newString.hpp"

char   *NewString (const char * const s)
{
    register char  *p;
	if(!s)
		return NULL;
    if (	(p = (char *) 
					new    char [(unsigned) (strlen (s) + 1) ] 
			) 
			== NULL
		)
    	return NULL;

    strcpy (p, s);
    return p;
}

char *NewString(const int len)
{
	if(len<1)
		return NULL;

	return new char[len];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\objectidentity.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "objectIdentity.hpp"



SIMCObjectIdentityType::SIMCObjectIdentityType( SIMCObjectIdentityType::StatusType status,
							long statusLine, long statusColumn,
							char *description,
							long descriptionLine, long descriptionColumn,
							char *reference,
							long referenceLine, long referenceColumn)
							:
							_status(status), _statusLine(statusLine),
							_statusColumn(statusColumn),
							_descriptionLine(descriptionLine),
							_descriptionColumn(descriptionColumn),
							_referenceLine(referenceLine),
							_referenceColumn(referenceColumn)

{
	_description = NewString(description);
	_reference = NewString(reference);
}


SIMCObjectIdentityType::~SIMCObjectIdentityType()
{
	if(_description)
		delete [] _description;
	if(_reference)
		delete [] _reference;
}

SIMCObjectIdentityType::StatusType SIMCObjectIdentityType::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "current") == 0)
			return STATUS_CURRENT;
		else if (strcmp(s, "deprecated") == 0)
			return STATUS_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return STATUS_OBSOLETE;
		else
			return STATUS_INVALID;
	}
	return STATUS_INVALID;
}

void SIMCObjectIdentityType::WriteType(ostream &outStream) const
{
	outStream << "OBJECT-IDENTITY type" << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\objecttypev1.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>
#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"




SIMCObjectTypeV1::SIMCObjectTypeV1( SIMCSymbol **syntax,
								    long syntaxLine, long syntaxColumn,
									SIMCObjectTypeV1::AccessType access,
									long accessLine, long accessColumn, 
									SIMCObjectTypeV1::StatusType status,
									long statusLine, long statusColumn,
									SIMCIndexList * indexTypes,
									long indexLine, long indexColumn,
									char *description,
									long descriptionLine, long descriptionColumn,
									char *reference,
									long referenceLine, long referenceColumn,
									char *defValName,
									SIMCSymbol **defVal,
									long defValLine, long defValColumn)
					: 	_access(access), _accessLine(accessLine), 
						_accessColumn(accessColumn),
						_status(status), _statusLine(statusLine),
						_statusColumn(statusColumn),
						_indexTypes(indexTypes),
						_indexLine(indexLine), _indexColumn(indexColumn),
						SIMCObjectTypeType( syntax, syntaxLine, syntaxColumn,
							description, descriptionLine, descriptionColumn,
							reference, referenceLine, referenceColumn,
							defValName, defVal, defValLine, defValColumn)
{ 
	if (indexTypes)
	{
		POSITION p = indexTypes->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (indexTypes->GetNext(p))->_item;
			(*s)->IncrementReferenceCount();

		}
	}
}


SIMCObjectTypeV1::~SIMCObjectTypeV1()
{
	if (UseReferenceCount() && _indexTypes)
	{
		POSITION p = _indexTypes->GetHeadPosition();
		SIMCSymbol **s;
		SIMCIndexItem *next;
		while(p)
		{
			next = 	_indexTypes->GetNext(p);
			s = next->_item;
			(*s)->DecrementReferenceCount();
			delete next;
		}
	}
}

SIMCObjectTypeV1::AccessType SIMCObjectTypeV1::StringToAccessType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "read-only") == 0)
			return ACCESS_READ_ONLY;
		else if (strcmp(s, "read-write") == 0)
			return ACCESS_READ_WRITE;
		else if (strcmp(s, "write-only") == 0)
			return ACCESS_WRITE_ONLY;
		else if (strcmp(s, "not-accessible") == 0)
			return ACCESS_NOT_ACCESSIBLE;
		else
			return ACCESS_INVALID;
	}
	return ACCESS_INVALID;
}


SIMCObjectTypeV1::StatusType SIMCObjectTypeV1::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "mandatory") == 0)
			return STATUS_MANDATORY;
		else if (strcmp(s, "optional") == 0)
			return STATUS_OPTIONAL;
		else if (strcmp(s, "deprecated") == 0)
			return STATUS_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return STATUS_OBSOLETE;
		else
			return STATUS_INVALID;
	}
	return STATUS_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\objecttypev2.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "objectType.hpp"
#include "objectTypeV2.hpp"




SIMCObjectTypeV2::SIMCObjectTypeV2( SIMCSymbol **syntax,
								    long syntaxLine, long syntaxColumn,
									const char * const unitsClause,
									long unitsLine, long unitsColumn,
									SIMCObjectTypeV2::AccessType access,
									long accessLine, long accessColumn, 
									SIMCObjectTypeV2::StatusType status,
									long statusLine, long statusColumn,
									SIMCIndexListV2 * indexTypes,
									long indexLine, long indexColumn,
									SIMCSymbol **augmentsClause,
									const char * const description,
									long descriptionLine, long descriptionColumn,
									const char * const reference,
									long referenceLine, long referenceColumn,
									const char * const defValName,
									SIMCSymbol **defVal,
									long defValLine, long defValColumn)
					: 	_unitsLine(unitsLine), _unitsColumn(unitsColumn),
						_access(access), _accessLine(accessLine), 
						_accessColumn(accessColumn),
						_status(status), _statusLine(statusLine),
						_statusColumn(statusColumn),
						_indexTypes(indexTypes),
						_indexLine(indexLine), _indexColumn(indexColumn),
						_augmentsClause(augmentsClause),
						SIMCObjectTypeType( syntax, syntaxLine, syntaxColumn,
							description, descriptionLine, descriptionColumn,
							reference, referenceLine, referenceColumn,
							defValName, defVal, defValLine, defValColumn)
{ 
	_unitsClause = NewString(unitsClause);
	if (indexTypes)
	{
		POSITION p = indexTypes->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (indexTypes->GetNext(p))->_item;
			(*s)->IncrementReferenceCount();

		}
	}
	
	if(augmentsClause)
		(*augmentsClause)->IncrementReferenceCount();

}


SIMCObjectTypeV2::~SIMCObjectTypeV2()
{
	if (UseReferenceCount() && _indexTypes)
	{
		POSITION p = _indexTypes->GetHeadPosition();
		SIMCSymbol **s;
		SIMCIndexItemV2 *next;
		while(p)
		{
			next = 	_indexTypes->GetNext(p);
			s = next->_item;
			(*s)->DecrementReferenceCount();
			delete next;
		}
	}

	if(UseReferenceCount() && _augmentsClause)
		(*_augmentsClause)->DecrementReferenceCount();

}

SIMCObjectTypeV2::AccessType SIMCObjectTypeV2::StringToAccessType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "read-only") == 0)
			return ACCESS_READ_ONLY;
		else if (strcmp(s, "read-write") == 0)
			return ACCESS_READ_WRITE;
		else if (strcmp(s, "read-create") == 0)
			return ACCESS_READ_CREATE;
		else if (strcmp(s, "accessible-for-notify") == 0)
			return ACCESS_FOR_NOTIFY;
		else if (strcmp(s, "not-accessible") == 0)
			return ACCESS_NOT_ACCESSIBLE;
		else
			return ACCESS_INVALID;
	}
	return ACCESS_INVALID;
}


SIMCObjectTypeV2::StatusType SIMCObjectTypeV2::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "current") == 0)
			return STATUS_CURRENT;
		else if (strcmp(s, "deprecated") == 0)
			return STATUS_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return STATUS_OBSOLETE;
		else
			return STATUS_INVALID;
	}
	return STATUS_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\oidvalue.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "module.hpp"

ostream& operator << ( ostream& outStream, 
	const SIMCOidComponent& obj)
{
	outStream << ( (obj._name)? obj._name : "")  << "(";
	(*obj._value)->WriteBrief(outStream);
	outStream << ")";
	return outStream;
}

void SIMCOidValue::WriteValue( ostream& outStream) const
{
	outStream << "OID  ";

	SIMCValue::WriteValue(outStream);

	outStream << endl;
	if( _listOfComponents)
	{
		POSITION p = _listOfComponents->GetHeadPosition();
		SIMCOidComponent *c;
		while(p)
		{
			c = _listOfComponents->GetNext(p);
			outStream << (*c) << ",";
		}	
	}
	outStream << endl;
}


ostream& operator << (ostream& outStream, const SIMCCleanOidValue& obj)
{
	// outStream << "OID VALUE: ";
	POSITION p = obj.GetHeadPosition();
	int i = obj.GetCount();
	while(p)
	{
		outStream << obj.GetNext(p);
		if(i-- != 1)
			outStream << ".";
	}
	outStream << endl;
	return outStream;
}

char *CleanOidValueToString(const SIMCCleanOidValue& obj)
{
	ostrstream outStream ;
	long index = obj.GetCount();
	POSITION p = obj.GetHeadPosition();
	while(p)
	{
		outStream << obj.GetNext(p) ;
		if ( index-- != 1  )
			outStream << ".";
	}

	outStream << ends ;
	return outStream.str();
}

void AppendOid(SIMCCleanOidValue& to, const SIMCCleanOidValue& from)
{
	POSITION p = from.GetHeadPosition();
	while(p)
		to.AddTail(from.GetNext(p));
}


operator == (const SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs)
{
	if( lhs.GetCount() != rhs.GetCount() )
		return FALSE;

	POSITION pLhs = lhs.GetHeadPosition();
	POSITION pRhs = rhs.GetHeadPosition();
	while( pLhs && pRhs )
		if( lhs.GetNext(pLhs) != rhs.GetNext(pRhs) )
			return FALSE;
	if( pRhs || pLhs )
		return FALSE;
	return TRUE;
}	
		
		
operator < (const SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs)
{

	POSITION pLhs = lhs.GetHeadPosition();
	POSITION pRhs = rhs.GetHeadPosition();
	while( pLhs && pRhs )
		if( lhs.GetNext(pLhs) >=  rhs.GetNext(pRhs) )
			return FALSE;
	if( pRhs )
		return TRUE;
	
	if( pLhs )
		return FALSE;

	return TRUE;
}	

SIMCCleanOidValue& CleanOidValueCopy(SIMCCleanOidValue & lhs, const SIMCCleanOidValue & rhs)
{

	lhs.RemoveAll();
	POSITION pRhs = rhs.GetHeadPosition();
	while( pRhs )
		lhs.AddTail(rhs.GetNext(pRhs));
	return lhs;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\oidtree.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"

#include "smierrsm.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"

#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"

#include "oidTree.hpp"
#include "abstractParseTree.hpp"
#include "parseTree.hpp"


SIMCOidTreeNode::~SIMCOidTreeNode()
{
	SIMCOidTreeNode * next;
	while(!_listOfChildNodes.IsEmpty())
	{
		next = _listOfChildNodes.RemoveHead();
		delete next;
	}
}

BOOL SIMCOidTree::AddSymbol(const SIMCSymbol ** s, const SIMCCleanOidValue& val)
{
	POSITION p = val.GetHeadPosition();
	int nextVal;
	SIMCOidTreeNode *current = &_root, *child;

	while(p)
	{
		nextVal = val.GetNext(p);

		if( child = current->GetChild(nextVal) )
		{
			current = child;
		}
		else
		{
			current->AddChild(nextVal);
			current = current->GetChild(nextVal);
		}
	}
	current->AddSymbol(s);
	return TRUE;
}

void SIMCOidTree::WriteSubTree(ostream& outStream, 
							   const SIMCOidTreeNode *subNode,
							   SIMCCleanOidValue& realValue)
{
	realValue.AddTail(subNode->GetValue());
	const SIMCSymbolList *symbols = subNode->GetSymbolList();
	POSITION p = symbols->GetHeadPosition();
	const SIMCSymbol **symbol;
	while(p)
	{
		symbol = symbols->GetNext(p);
		outStream << (*symbol)->GetSymbolName() << " :" << realValue << endl;
		outStream << "=============================================================" <<
			endl;
	}

	const SIMCNodeList *children = subNode->GetListOfChildNodes();
	p = children->GetHeadPosition();
	const SIMCOidTreeNode *next;
	while(p)
	{
		next = children->GetNext(p);
		WriteSubTree(outStream, next, realValue);
	}
	realValue.RemoveTail();
}

void SIMCOidTree::WriteTree(ostream& outStream) const
{
	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();
	SIMCCleanOidValue realValue;
	outStream << "==============================================================" <<
		endl;
	outStream << "BEGINNING OF OID TREE" << endl;
	const SIMCOidTreeNode *next;
	while(p)
	{
		next = children->GetNext(p);
		WriteSubTree(outStream, next, realValue);
	}
	outStream << "=============================================================" <<
		endl;
}

const SIMCSymbolList *SIMCOidTree::GetSymbolList(const SIMCCleanOidValue& val)
{
	POSITION pOid = val.GetHeadPosition();
	if(!pOid)
		return NULL;

	SIMCOidTreeNode *current = &_root;
	const SIMCNodeList *children;
	POSITION pChildren;
	SIMCOidTreeNode *nextChild;
	int nextCleanVal;
	while(pOid)
	{
		nextCleanVal = val.GetNext(pOid);
		children = current->GetListOfChildNodes();
		current = NULL;
		pChildren = children->GetHeadPosition();
		while(pChildren)
		{
			nextChild = children->GetNext(pChildren);
			if(nextChild->GetValue() == nextCleanVal)
			{
				current = nextChild;
				break;
			}
		}
		if(current == NULL)
			return NULL;
	}
	return current->GetSymbolList();
}


BOOL SIMCOidTreeNode::GetOidValue(const char * const symbolName,
									const char * const moduleName,
									SIMCCleanOidValue& val) const
{

	val.AddTail(GetValue());
	POSITION p = _listOfSymbols.GetHeadPosition();
	const SIMCSymbol **s;
	while(p)
	{
		s = _listOfSymbols.GetNext(p);
		if( strcmp((*s)->GetSymbolName(), symbolName) == 0 &&
			strcmp((*s)->GetModule()->GetModuleName(), moduleName) == 0 	)
			return TRUE;
	}


	p = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *nextNode;
	while(p)
	{
		nextNode = _listOfChildNodes.GetNext(p);
		if(nextNode->GetOidValue(symbolName, moduleName, val))
			return TRUE;
	}

	val.RemoveTail();
	return FALSE;
}

BOOL SIMCOidTree::GetOidValue(const char * const symbolName, 
								const char * const moduleName,
								SIMCCleanOidValue& val) const
{
	const SIMCNodeList *children = _root.GetListOfChildNodes();

	POSITION p = children->GetHeadPosition();
	SIMCOidTreeNode *nextNode;
	while(p)
	{
		nextNode = children->GetNext(p);
		if(nextNode->GetOidValue(symbolName, moduleName, val))
			return TRUE;
	}
	return FALSE;
}

SIMCOidTreeNode *SIMCOidTree::GetParentOf(const SIMCOidTreeNode * node)
{
	
	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode, *retVal;		
	while(p)
	{
		nextNode = children->GetNext(p);
		if(nextNode == node)
			return &_root;
		if(retVal = nextNode->GetParentOf(node))
			return retVal;
	}
	return NULL;
}

SIMCOidTreeNode *SIMCOidTree::GetParentOf(SIMCSymbol *symbol)
{
	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode, *retVal;		
	while(p)
	{
		nextNode = children->GetNext(p);
		if(nextNode->HasSymbol(symbol))
			return &_root;
		if(retVal = nextNode->GetParentOf(symbol))
			return retVal;
	}
	return NULL;
}

SIMCOidTreeNode *SIMCOidTreeNode::GetParentOf(const SIMCOidTreeNode * node)
{
	const SIMCNodeList *children = GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode, *retVal;		
	while(p)
	{
		nextNode = children->GetNext(p);
		if(nextNode == node)
			return (SIMCOidTreeNode *)this;
		if(retVal = nextNode->GetParentOf(node))
			return retVal;
	}
	return NULL;
}	

SIMCOidTreeNode *SIMCOidTreeNode::GetParentOf(SIMCSymbol *symbol)
{
	
	const SIMCNodeList *children = GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode, *retVal;		
	while(p)
	{
		nextNode = children->GetNext(p);
		// Check if it has the symbol
		if(nextNode->HasSymbol(symbol))
			return (SIMCOidTreeNode *)this;
		if(retVal = nextNode->GetParentOf(symbol))
			return retVal;
	}
	return NULL;
}



BOOL SIMCOidTree::CheckOidTree(BOOL local, SIMCParseTree * const parseTree)
{
	BOOL retVal = TRUE;

	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode;
	while(p)
	{
		nextNode = children->GetNext(p);
		if(!nextNode->CheckNode(local, parseTree, NULL, NULL, NULL))
			retVal = FALSE;
	}
	return retVal;
}

BOOL SIMCOidTreeNode::CheckNode(BOOL local, SIMCParseTree *const parseTree, 
								SIMCSymbol *parentSequence,
								SIMCSymbol *parentSequenceOf, 
								SIMCSymbol *ancestor)
{

	BOOL retVal = TRUE;

	// Check if there are more than one object-types
	SIMCSymbol *objectTypeSymbol = NULL;
	SIMCObjectTypeType *objectType;

	POSITION p = _listOfSymbols.GetHeadPosition();
	SIMCSymbol ** nextSymbol;
	while(p)
	{
		nextSymbol = (SIMCSymbol **)_listOfSymbols.GetNext(p);
		SIMCObjectTypeType *dummy;
		switch(SIMCModule::IsObjectType(nextSymbol, dummy))
		{
			case RESOLVE_CORRECT:
				if(objectTypeSymbol)
				{
					SIMCModule *temp = (*nextSymbol)->GetModule();
					parseTree->SemanticError(temp->GetInputFileName(),
						OBJ_TYPE_DUPLICATE_OID,
						(*nextSymbol)->GetLineNumber(), 
						(*nextSymbol)->GetColumnNumber(),
						objectTypeSymbol->GetSymbolName(), 
						(objectTypeSymbol->GetModule())->GetModuleName(),
						(*nextSymbol)->GetSymbolName(),
						temp->GetModuleName());
					retVal = TRUE;
				}
				else
				{
					objectTypeSymbol = *nextSymbol;
					objectType = dummy;
				}
		}
	}

	SIMCModule *module;
	SIMCSymbol **syntaxSymbol;
	SIMCTypeReference *btRef;
	SIMCModule::TypeClass objectTypeClass;
	SIMCType *type;
	long line, column;
	if(objectTypeSymbol)
	{
		syntaxSymbol = objectType->GetSyntax();
		module = objectTypeSymbol->GetModule();
		line = objectTypeSymbol->GetLineNumber();
		column = objectTypeSymbol->GetColumnNumber();
		const char * const inputFileName = module->GetInputFileName();
		const char * const symbolName = objectTypeSymbol->GetSymbolName();
		
		if(ancestor && !parentSequence && !parentSequenceOf)
		{
			parseTree->SemanticError(inputFileName, OBJ_TYPE_PRIMITIVE_CHILD,
				line, column, 
				symbolName, 
				ancestor->GetSymbolName(),
				(ancestor->GetModule())->GetModuleName());
			retVal = FALSE;
		}
		ancestor = objectTypeSymbol;

		if(SIMCModule::IsTypeReference(syntaxSymbol, btRef) == RESOLVE_CORRECT)
		{
			switch(SIMCModule::GetSymbolClass((SIMCSymbol**)&btRef))
			{
				case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				{
					switch(objectTypeClass = SIMCModule::GetTypeClass(type = 
										((SIMCBuiltInTypeReference *)btRef)->GetType()))
					{
						case SIMCModule::TYPE_SEQUENCE:

							// It better not have a SEQUENCE  or Scalar parent,
							// And it better have a SEQUENCE_OF parent
							if(parentSequence)
							{
								parseTree->SemanticError(inputFileName, OBJ_TYPE_SEQUENCE_CHILD,
									line, column, 
									symbolName,
									parentSequence->GetSymbolName(),
									(parentSequence->GetModule())->GetModuleName());
								retVal = FALSE;
							}
							if(!parentSequenceOf)
							{
								parseTree->SemanticError(inputFileName, OBJ_TYPE_SEQUENCE_NO_PARENT,
									line, column, 
									symbolName);
								retVal = FALSE;
							}
							if(!CheckSequenceProperty(local, parseTree, objectTypeSymbol, objectType, (SIMCBuiltInTypeReference *)btRef))
							{
								//cout << "CheckSequenceProperty returned FALSE" << endl;
								retVal = FALSE;
							}
							// Set the arguments for a recursive call
							parentSequence = objectTypeSymbol;
							parentSequenceOf = NULL;
							break;

						case SIMCModule::TYPE_SEQUENCE_OF:
							if(!CheckSequenceOfProperty(local, parseTree, objectTypeSymbol, (SIMCBuiltInTypeReference *)btRef))
							{
								//cout << "CheckSequenceOfProperty returned FALSE" << endl;
								retVal = FALSE;
							}
							parentSequence = NULL;
							parentSequenceOf = objectTypeSymbol;
							break;
						default:
							parentSequence = NULL;
							parentSequenceOf = NULL;
							break;
					}
				}
				break;
				default:
					parentSequence = NULL;
					parentSequenceOf = NULL;
					break;
			}
		}
	}

	SIMCOidTreeNode *nextChildNode;
	p = _listOfChildNodes.GetHeadPosition();
	while(p)
	{
		nextChildNode = _listOfChildNodes.GetNext(p);
		retVal = nextChildNode->CheckNode(local, parseTree, parentSequence, 
								parentSequenceOf, ancestor) && retVal;
	}
	return retVal;
}


BOOL SIMCOidTreeNode::CheckSequenceProperty(BOOL local, SIMCParseTree *const parseTree, 
						SIMCSymbol *objectTypeSymbol, 
						SIMCObjectTypeType *objectType, 
						SIMCBuiltInTypeReference *seqTypeRef)
{
	BOOL retVal = TRUE;
	SIMCSequenceType *seqType = (SIMCSequenceType *)seqTypeRef->GetType();
	
	// Make a list of OBJECT-TYPES below this node, and belong to the same module as
	// this node
	SIMCSymbolList listOfObjects;
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	const SIMCSymbolList *symbolList;
	POSITION pSymbols;
	SIMCSymbol **symbol;
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();

		SIMCObjectTypeType *dummy;
		while(pSymbols)
		{
			symbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsObjectType(symbol, dummy) == RESOLVE_CORRECT &&
				(*symbol)->GetModule() == objectTypeSymbol->GetModule())
				listOfObjects.AddTail((const SIMCSymbol **)symbol);
		}
	}

	// Now check if the members of the SEQUENCE are present in the list of OBJECTS
	// And also that the list does not have any ther objects.

	const char * const objectName = objectTypeSymbol->GetSymbolName();
	const char * const objectModuleName = (objectTypeSymbol->GetModule())->GetModuleName();

	SIMCSequenceList *list = seqType->GetListOfSequences();
	if(list)
	{
		POSITION pSeq = list->GetHeadPosition();
		SIMCSequenceItem *item;
		POSITION pObjects, temp;
		const SIMCSymbol ** nextSymbol;
		BOOL found;
		while(pSeq)
		{
			item = list->GetNext(pSeq);
			// See if the symbol is present in the list of objects collected above
			pObjects = listOfObjects.GetHeadPosition();
			found = FALSE;
			while(pObjects)
			{
				temp = pObjects;
				nextSymbol = listOfObjects.GetNext(pObjects);
				if( (**nextSymbol) == (**item->_value) )
				{
					found = TRUE;
					listOfObjects.RemoveAt(temp);
				}
			}
			if(!found)
			{
				parseTree->SemanticError((seqTypeRef->GetModule())->GetInputFileName(),
					SEQUENCE_WRONG_CHILD,
					item->_valueLine, item->_valueColumn,
					(*item->_value)->GetSymbolName(),
					objectName, objectModuleName);
				retVal = FALSE;
			}
		}
	}

	pSymbols = listOfObjects.GetHeadPosition();
	while(pSymbols)
	{
		symbol = (SIMCSymbol **)listOfObjects.GetNext(pSymbols);
		parseTree->SemanticError(((*symbol)->GetModule())->GetInputFileName(),
			OBJ_TYPE_SEQUENCE_EXTRA_CHILD,
			(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
			(*symbol)->GetSymbolName(),
			objectName, objectModuleName);
		retVal = FALSE;
	}

	return retVal;
}



BOOL SIMCOidTreeNode::CheckSequenceOfProperty(BOOL local, 
						SIMCParseTree * const parseTree, 
						SIMCSymbol *objectTypeSymbol, 
						SIMCBuiltInTypeReference *seqOfTypeRef)
{
	BOOL retVal = TRUE;

	// Store the names for error reporting
	const char * const objectName = objectTypeSymbol->GetSymbolName();
	const char * const objectModuleName = (objectTypeSymbol->GetModule())->GetModuleName();


	SIMCSequenceOfType *seqOfType = (SIMCSequenceOfType *)seqOfTypeRef->GetType();
	SIMCSymbol **seqSymbol = seqOfType->GetType();
	SIMCBuiltInTypeReference *seqTypeRef;
	SIMCSequenceType *seqType;
	if(SIMCModule::IsSequenceTypeReference(seqSymbol, seqTypeRef, seqType)
		!= RESOLVE_CORRECT)
		return FALSE;

	// Check if the node has exactly one OBJECT-TYPE as child, 
	// and that this OBJECT-TYPE has a syntax which is the same as seqType
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	const SIMCSymbolList *symbolList;
	POSITION pSymbols;
	SIMCSymbol **symbol;
	BOOL found = FALSE;
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();

		SIMCObjectTypeType *childObjType;
		while(pSymbols)
		{
			symbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsObjectType(symbol, childObjType) == RESOLVE_CORRECT &&
				(*symbol)->GetModule() == objectTypeSymbol->GetModule())
			{
				if(found)
				{
					parseTree->SemanticError(((*symbol)->GetModule())->GetInputFileName(),
						OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD,
						(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
						(*symbol)->GetSymbolName(),
						objectName, objectModuleName);
					retVal = FALSE;
				}
				else
				{
					// Check its syntax clause
					SIMCSymbol **childSyntaxSymbol = childObjType->GetSyntax();
					SIMCBuiltInTypeReference *childTypeRef;
					SIMCSequenceType *childSeqType;
					switch(SIMCModule::IsSequenceTypeReference(childSyntaxSymbol,
							childTypeRef, childSeqType) )
					{
						case RESOLVE_UNDEFINED:
						case RESOLVE_UNSET:
							parseTree->SemanticError(((*symbol)->GetModule())->GetInputFileName(),
								OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD,
								(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
								(*symbol)->GetSymbolName(),
								objectName, objectModuleName);
							retVal = FALSE;
							break;
						case RESOLVE_IMPORT:
							if(!local)
							{
								parseTree->SemanticError(((*symbol)->GetModule())->GetInputFileName(),
									OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD,
									(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
									(*symbol)->GetSymbolName(),
									objectName, objectModuleName);
								retVal = FALSE;
							}
							break;
						case RESOLVE_CORRECT:
							if( seqType != childSeqType)
							{
								parseTree->SemanticError((objectTypeSymbol->GetModule())->GetInputFileName(),
									OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH,
									objectTypeSymbol->GetLineNumber(), objectTypeSymbol->GetColumnNumber(),
									objectName,
									(*symbol)->GetSymbolName(),
									((*symbol)->GetModule())->GetModuleName());
								retVal = FALSE;
							}

							found = TRUE;
							break;
					}
				}
			}
		} // while(pSymbols)
	}
	return retVal;
}


BOOL SIMCOidTree::GetObjectGroups(SIMCGroupList *groupList)
{
	BOOL retVal = TRUE;

	const SIMCNodeList *children = _root.GetListOfChildNodes();
	POSITION p = children->GetHeadPosition();

	SIMCOidTreeNode *nextNode;
	while(p)
	{
		nextNode = children->GetNext(p);
		if(!nextNode->GetObjectGroups(this, groupList))
			retVal = FALSE;
	}

	// Now set the AUGMENTed tables of all these groups
	SIMCObjectGroup *nextGroup;
	SIMCTableMembers *tables;
	p = groupList->GetHeadPosition();
	while(p)	// For each OBJECT-GROUP
	{
		nextGroup = groupList->GetNext(p);
		tables = nextGroup->GetTableMembers();
		if(!tables)
			continue;
		POSITION pInner = tables->GetHeadPosition();
		SIMCTable *nextTable;
		SIMCSymbol * rowSymbol; 
		SIMCObjectTypeV2 *rowObjectType;
		while(pInner)	// For each table in the OBJECT-GROUP
		{
			nextTable = tables->GetNext(pInner);
			rowSymbol = nextTable->GetRowSymbol();
			SIMCSymbol **rowSymbolP = &rowSymbol;
			if(SIMCModule::IsObjectTypeV2(rowSymbolP, rowObjectType) != RESOLVE_CORRECT)
				continue;
			SIMCSymbol **augmentsSymbol = rowObjectType->GetAugments();
			if(!augmentsSymbol)
				continue;
			SetAugmentedTable(nextTable, *augmentsSymbol, groupList);
		}
	}
	return retVal;
}
	
void SIMCOidTree::SetAugmentedTable(SIMCTable *table, SIMCSymbol *augmentsSymbol,
									SIMCGroupList *groupList)
{
	SIMCObjectGroup *nextGroup;
	SIMCTableMembers *tables;
	POSITION p = groupList->GetHeadPosition();
	while(p)	// For each OBJECT-GROUP
	{
		nextGroup = groupList->GetNext(p);
		tables = nextGroup->GetTableMembers();
		if(!tables)
			continue;
		POSITION pInner = tables->GetHeadPosition();
		SIMCTable *nextTable;
		while(pInner)	// For each table in the OBJECT-GROUP
		{
			nextTable = tables->GetNext(pInner);
			if(augmentsSymbol == nextTable->GetRowSymbol())
				table->SetAugmentedTable(nextTable);
		}
	}

}

BOOL SIMCOidTreeNode::GetObjectGroups(SIMCOidTree *tree,
									  SIMCGroupList *groupList)
{
	BOOL retVal = TRUE;
	// The list of "named" nodes at this node
	SIMCSymbolList	namedNodes;
	SIMCSymbol **nextSymbol;
	const char * nextSymbolName;
	POSITION pSymbols = _listOfSymbols.GetHeadPosition();
	while(pSymbols)
	{
		nextSymbol = (SIMCSymbol **) _listOfSymbols.GetNext(pSymbols);
		nextSymbolName = (*nextSymbol)->GetSymbolName();
		if(*nextSymbolName == '*')
			continue;
		if(SIMCModule::IsNamedNode(nextSymbol) != RESOLVE_CORRECT)
			continue;

		// So it's a named node
		namedNodes.AddHead((const SIMCSymbol **)nextSymbol);
	}

	// Were there any named nodes collected above
	// TODO: WHY AM I ASSUMING ONLY ONE NAMED NODE????

	if( !namedNodes.IsEmpty())
		retVal = FabricateGroup(tree, (SIMCSymbol *)*namedNodes.GetHead(), groupList) 
								&& retVal;

	// Recurse on all the children
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		retVal = childNode->GetObjectGroups(tree, groupList) && retVal;
	}
	return retVal;
}


BOOL SIMCOidTreeNode::FabricateGroup(SIMCOidTree *tree,
								  SIMCSymbol *namedNode, 
								  SIMCGroupList *groupList)
{
	SIMCObjectGroup *theGroup = new SIMCObjectGroup;

	theGroup->SetNamedNode (namedNode);
	SIMCCleanOidValue *namedNodeValue = new SIMCCleanOidValue;
	if( !tree->GetOidValue(namedNode->GetSymbolName(), namedNode->GetModule()->GetModuleName(),*namedNodeValue))
	{
		delete theGroup;
		return FALSE;
	}
	theGroup->SetGroupValue(namedNodeValue);
	theGroup->SetReference("");
	theGroup->SetDescription("");
	theGroup->SetStatus(SIMCObjectGroup::STATUS_CURRENT);

	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	POSITION pSymbols;
	SIMCSymbol **nextSymbol;
	const SIMCSymbolList *symbolList;
	SIMCCleanOidValue *oidValue;
	SIMCScalar *scalar;
	SIMCTable *table;
	SIMCScalarMembers *scalars = new SIMCScalarMembers;
	SIMCTableMembers *tables= new SIMCTableMembers;
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();
		while(pSymbols)
		{
			nextSymbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsScalar(nextSymbol) == RESOLVE_CORRECT)
			{
				scalar = new SIMCScalar;
				oidValue = new SIMCCleanOidValue;
				scalar->SetSymbol(*nextSymbol);
				if(tree->GetOidValue((*nextSymbol)->GetSymbolName(), (*nextSymbol)->GetModule()->GetModuleName(), *oidValue))
				{
					scalar->SetOidValue(oidValue);
					theGroup->AddScalar(scalar);
					break;
				}
				else
				{
					delete scalar;
					delete oidValue;
				}
			}
			else if (SIMCModule::IsTable(nextSymbol) == RESOLVE_CORRECT)
			{
				table = new SIMCTable;
				oidValue = new SIMCCleanOidValue;				
				table->SetTableSymbol(*nextSymbol);
				if(!tree->GetOidValue((*nextSymbol)->GetSymbolName(), (*nextSymbol)->GetModule()->GetModuleName(),*oidValue))
				{
					delete oidValue;
					delete table;
				}
				else
				{
					table->SetTableOidValue(oidValue);
					if(childNode->FabricateTable(tree, table))
					{
						theGroup->AddTable(table);
						break;
					}
					else
					{
						delete oidValue;
						delete table;
					}
				}
			}
		}
	}

	if(theGroup->GetScalarCount()==0 && theGroup->GetTableCount()==0 )
	{
		delete theGroup;
		return TRUE;
	}
	else
	{
		groupList->AddTail(theGroup);
		return TRUE;
	}

}


BOOL SIMCOidTreeNode::FabricateTable(SIMCOidTree *tree, SIMCTable *table)
{
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	POSITION pSymbols;
	SIMCSymbol **nextSymbol;
	const SIMCSymbolList *symbolList;

	table->SetRowSymbol(NULL);
	// Search for a row OBJECT-TYPE
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();
		while(pSymbols)
		{
			nextSymbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsRow(nextSymbol) == RESOLVE_CORRECT)
			{
				table->SetRowSymbol(*nextSymbol);
				break;
			}
		}
		if(table->GetRowSymbol())
			break;
	}

	if(!table->GetRowSymbol())
		return FALSE;

	SIMCCleanOidValue *oidValue = new SIMCCleanOidValue;
	if(!tree->GetOidValue((*nextSymbol)->GetSymbolName(), (*nextSymbol)->GetModule()->GetModuleName(),*oidValue) )
	{
		delete oidValue;
		return FALSE;
	}

	table->SetRowOidValue(oidValue);

	if(childNode->FabricateRow(tree, table))
		return TRUE;
	else
	{
		delete oidValue;
		return FALSE;
	}
}

BOOL SIMCOidTreeNode::FabricateRow(SIMCOidTree *tree, SIMCTable *table)
{
	BOOL retVal = TRUE;
	POSITION pChildren = _listOfChildNodes.GetHeadPosition();
	SIMCOidTreeNode *childNode;
	POSITION pSymbols;
	SIMCSymbol **nextSymbol;
	const SIMCSymbolList *symbolList;
	SIMCObjectTypeType *objType;
	SIMCScalar *column;
	SIMCCleanOidValue *oidValue;

	// Add all columns to the list
	while(pChildren)
	{
		childNode = _listOfChildNodes.GetNext(pChildren);
		symbolList = childNode->GetSymbolList();
		pSymbols = symbolList->GetHeadPosition();
		while(pSymbols)
		{
			nextSymbol = (SIMCSymbol **)symbolList->GetNext(pSymbols);
			if(SIMCModule::IsObjectType(nextSymbol, objType) == RESOLVE_CORRECT)
			{
				column = new SIMCScalar;
				oidValue = new SIMCCleanOidValue;
				column->SetSymbol(*nextSymbol);
				if(!tree->GetOidValue((*nextSymbol)->GetSymbolName(), (*nextSymbol)->GetModule()->GetModuleName(),*oidValue) )
				{
					delete column;
					delete oidValue;
					retVal = FALSE;
					break;
				}
				else
				{
					column->SetOidValue(oidValue);
					table->AddColumnMember(column);
					break;
				}
			}
		}
	}
	return retVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\parser.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <stdarg.h>
#include <iostream.h>
#include <fstream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "smierrsy.hpp"
#include "smierrsm.hpp"


#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"


const int SIMCParser::MESSAGE_SIZE = 1024;
const int SIMCParser::SYNTAX_ERROR_BASE = 200;
const int SIMCParser::SEMANTIC_ERROR_BASE = 1000;
HINSTANCE SIMCParser::semanticErrorsDll = NULL ;

const char *const SIMCParser::severityLevels[] =
{
	"Fatal",
	"Warning",
	"Information"
};

const char * const SIMCParser::semanticErrorsDllFile = "smierrsm.dll";
const char * const SIMCParser::syntaxErrorsDllFile = "smierrsy.dll";

HINSTANCE SIMCParser::syntaxErrorsDll = NULL ;

SIMCParser::SIMCParser(SIMCErrorContainer * errorContainer,
			SIMCScanner * scanner)
	: _errorContainer(errorContainer), _snmpVersion(0), 
		_theScanner(scanner), _module(NULL)
{

	if ( syntaxErrorsDll == NULL )
			syntaxErrorsDll = LoadLibrary(syntaxErrorsDllFile);

	
	if ( semanticErrorsDll == NULL )
		semanticErrorsDll = LoadLibrary(semanticErrorsDllFile);

}

void SIMCParser::CreateReservedModules()
{
	rfc1155 = rfc1212 = rfc1213 = rfc1215 = rfc1230 = 
		rfc1902 = rfc1903 = rfc1904 = other = NULL;

	// These sets of symbols are "known" by the parser

	// --------------------- 1. Modules ------------------------------------
	
	switch(_snmpVersion)
	{
		case 1:
		{
				// V1 "well-known" modules
			rfc1155 = new SIMCModule("RFC1155-SMI", "INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1212 = new SIMCModule("RFC-1212",	"INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1213 = new SIMCModule("RFC1213-MIB",	"INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1215 = new SIMCModule("RFC-1215",	"INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1230 = new SIMCModule("RFC1230-MIB",	"INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1155->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1212->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1213->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1215->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1230->SetSymbolType(SIMCSymbol::PRIMITIVE);
		}
		break;
		case 2:
		{
				// V2 "well-known" modules
			rfc1902 = new SIMCModule("SNMPv2-SMI",	"INBUILT",	NULL, NULL, NULL, 2, 0, 0, 0);
			rfc1903 = new SIMCModule("SNMPv2-TC",	"INBUILT",	NULL, NULL, NULL, 2, 0, 0, 0);
			rfc1904 = new SIMCModule("SNMPv2-CONF",	"INBUILT",	NULL, NULL, NULL, 2, 0, 0, 0);
			rfc1906 = new SIMCModule("SNMPv2-TM",	"INBUILT",	NULL, NULL, NULL, 2, 0, 0, 0);
			rfc1902->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1903->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1904->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1906->SetSymbolType(SIMCSymbol::PRIMITIVE);
		}
		break;
		default:
				// V1 "well-known" modules
			rfc1155 = new SIMCModule("RFC1155-SMI", "INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1212 = new SIMCModule("RFC-1212",	"INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1213 = new SIMCModule("RFC1213-MIB",	"INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1215 = new SIMCModule("RFC-1215",	"INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1230 = new SIMCModule("RFC1230-MIB",	"INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
			rfc1155->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1212->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1213->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1215->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1230->SetSymbolType(SIMCSymbol::PRIMITIVE);
				// V2 "well-known" modules
			rfc1902 = new SIMCModule("SNMPv2-SMI",	"INBUILT",	NULL, NULL, NULL, 2, 0, 0, 0);
			rfc1903 = new SIMCModule("SNMPv2-TC",	"INBUILT",	NULL, NULL, NULL, 2, 0, 0, 0);
			rfc1904 = new SIMCModule("SNMPv2-CONF",	"INBUILT",	NULL, NULL, NULL, 2, 0, 0, 0);
			rfc1906 = new SIMCModule("SNMPv2-TM",	"INBUILT",	NULL, NULL, NULL, 2, 0, 0, 0);
			rfc1902->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1903->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1904->SetSymbolType(SIMCSymbol::PRIMITIVE);
			rfc1906->SetSymbolType(SIMCSymbol::PRIMITIVE);
	}
			// Basic ASN.1 types are here. Common to V1 and V2
	other	= new SIMCModule("BUILTIN",		"INBUILT",	NULL, NULL, NULL, 1, 0, 0, 0);
	other->SetSymbolType(SIMCSymbol::PRIMITIVE);


	// ------------------ 2. TYPES -----------------------------------------
			
			// Common to V1 and V2
	SIMCPrimitiveType *integerPType				= new SIMCPrimitiveType;
	SIMCPrimitiveType *objectIdentifierPType	= new SIMCPrimitiveType;
	SIMCPrimitiveType *octetStringPType			= new SIMCPrimitiveType;
	SIMCPrimitiveType *nullV1PType				= new SIMCPrimitiveType;
	SIMCPrimitiveType *bitsV2PType				= new SIMCPrimitiveType;
	SIMCPrimitiveType *booleanPType				= new SIMCPrimitiveType;
	other->AddSymbol(new SIMCBuiltInTypeReference( objectIdentifierPType,
									"OBJECT IDENTIFIER", 
									SIMCSymbol::PRIMITIVE,
									other, 0, 0, 0 ));
	other->AddSymbol(new SIMCBuiltInTypeReference( integerPType,
									"INTEGER",
									SIMCSymbol::PRIMITIVE,
									other, 0, 0, 0 ));
	other->AddSymbol(new SIMCBuiltInTypeReference(octetStringPType,
									"OCTET STRING",
									SIMCSymbol::PRIMITIVE,
									other, 0, 0, 0 ));
	other->AddSymbol(new SIMCBuiltInTypeReference( nullV1PType,
									"NULL",
									SIMCSymbol::PRIMITIVE,
									other, 0, 0, 0 ));
	other->AddSymbol(new SIMCBuiltInTypeReference( bitsV2PType,
									"BITS",
									SIMCSymbol::PRIMITIVE,
									other, 0, 0, 0 ));
	other->AddSymbol(new SIMCBuiltInTypeReference( booleanPType,
									"BOOLEAN",
									SIMCSymbol::PRIMITIVE,
									other, 0, 0, 0 ));

	objectIdentifierType =	other->GetSymbol("OBJECT IDENTIFIER");
	integerType =			other->GetSymbol("INTEGER");
	octetStringType =		other->GetSymbol("OCTET STRING");
	nullType =				other->GetSymbol("NULL");
	bitsType =				other->GetSymbol("BITS");
	booleanType =			other->GetSymbol("BOOLEAN");

			// V1
	if(_snmpVersion != 2 )
	{
		SIMCPrimitiveType *displayStringV1PType		= new SIMCPrimitiveType;
		SIMCPrimitiveType *macAddressV1PType		= new SIMCPrimitiveType;
		SIMCPrimitiveType *physAddressV1PType		= new SIMCPrimitiveType;
		SIMCPrimitiveType *networkAddressV1PType	= new SIMCPrimitiveType;
		SIMCPrimitiveType *ipAddressV1PType			= new SIMCPrimitiveType;
		SIMCPrimitiveType *counterV1PType			= new SIMCPrimitiveType;
		SIMCPrimitiveType *gaugeV1PType				= new SIMCPrimitiveType;
		SIMCPrimitiveType *timeTicksV1PType			= new SIMCPrimitiveType;
		SIMCPrimitiveType *opaqueV1PType			= new SIMCPrimitiveType;
 		SIMCPrimitiveType *trapTypeV1PType			= new SIMCPrimitiveType;
 		SIMCPrimitiveType *objectTypeV1PType		= new SIMCPrimitiveType;

		rfc1213->AddSymbol(new SIMCBuiltInTypeReference( displayStringV1PType,
										"DisplayString",
										SIMCSymbol::PRIMITIVE,
										rfc1213, 0, 0, 0 ));

		rfc1213->AddSymbol(new SIMCBuiltInTypeReference( physAddressV1PType,
										"PhysAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1213, 0, 0, 0 ));

		rfc1230->AddSymbol(new SIMCBuiltInTypeReference( macAddressV1PType,
										"MacAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1230, 0, 0, 0 ));

		rfc1155->AddSymbol(new SIMCBuiltInTypeReference( networkAddressV1PType,
										"NetworkAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1155, 0, 0, 0 ));

		rfc1155->AddSymbol(new SIMCBuiltInTypeReference( ipAddressV1PType,
										"IpAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1155, 0, 0, 0 ));

		rfc1155->AddSymbol(new SIMCBuiltInTypeReference( counterV1PType,
										"Counter",
										SIMCSymbol::PRIMITIVE,
										rfc1155, 0, 0, 0 ));

		rfc1155->AddSymbol(new SIMCBuiltInTypeReference( gaugeV1PType,
										"Gauge",
										SIMCSymbol::PRIMITIVE,
										rfc1155, 0, 0, 0 ));

		rfc1155->AddSymbol(new SIMCBuiltInTypeReference( opaqueV1PType,
										"Opaque",
										SIMCSymbol::PRIMITIVE,
										rfc1155, 0, 0, 0 ));

		rfc1155->AddSymbol(new SIMCBuiltInTypeReference( timeTicksV1PType,
										"TimeTicks",
										SIMCSymbol::PRIMITIVE,
										rfc1155, 0, 0, 0 ));

		rfc1212->AddSymbol(new SIMCBuiltInTypeReference( objectTypeV1PType,
										"OBJECT-TYPE",
										SIMCSymbol::PRIMITIVE,
										rfc1212, 0, 0, 0 ));

		rfc1215->AddSymbol(new SIMCBuiltInTypeReference( trapTypeV1PType,
										"TRAP-TYPE",
										SIMCSymbol::PRIMITIVE,
										rfc1215, 0, 0, 0 ));

	}

	if(_snmpVersion != 1)
	{
		SIMCBuiltInTypeReference * tempBTRef = NULL;
		SIMCTextualConvention *tempTC = NULL;
		SIMCSubType *tempSubType = NULL;
			// V2
		SIMCPrimitiveType *integer32V2PType			= new SIMCPrimitiveType;
		SIMCPrimitiveType *counter32V2PType			= new SIMCPrimitiveType;
		SIMCPrimitiveType *counter64V2PType			= new SIMCPrimitiveType;
		SIMCPrimitiveType *gauge32V2PType			= new SIMCPrimitiveType;
		SIMCPrimitiveType *unsigned32V2PType		= new SIMCPrimitiveType;
		SIMCPrimitiveType *ipAddressV2PType			= new SIMCPrimitiveType;
		SIMCPrimitiveType *timeTicksV2PType			= new SIMCPrimitiveType;
		SIMCPrimitiveType *opaqueV2PType			= new SIMCPrimitiveType;

		rfc1902->AddSymbol(new SIMCBuiltInTypeReference( integer32V2PType,
										"Integer32",
										SIMCSymbol::PRIMITIVE,
										rfc1902, 0, 0, 0 ));

		rfc1902->AddSymbol(new SIMCBuiltInTypeReference( ipAddressV2PType,
										"IpAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1902, 0, 0, 0 ));

		rfc1902->AddSymbol(new SIMCBuiltInTypeReference( counter32V2PType,
										"Counter32",
										SIMCSymbol::PRIMITIVE,
										rfc1902, 0, 0, 0 ));

		rfc1902->AddSymbol(new SIMCBuiltInTypeReference( timeTicksV2PType,
										"TimeTicks",
										SIMCSymbol::PRIMITIVE,
										rfc1902, 0, 0, 0 ));

		rfc1902->AddSymbol(new SIMCBuiltInTypeReference( opaqueV2PType,
										"Opaque",
										SIMCSymbol::PRIMITIVE,
										rfc1902, 0, 0, 0 ));

		rfc1902->AddSymbol(new SIMCBuiltInTypeReference( counter64V2PType,
										"Counter64",
										SIMCSymbol::PRIMITIVE,
										rfc1902, 0, 0, 0 ));

		rfc1902->AddSymbol(new SIMCBuiltInTypeReference( unsigned32V2PType,
										"Unsigned32",
										SIMCSymbol::PRIMITIVE,
										rfc1902, 0, 0, 0 ));

		rfc1902->AddSymbol(new SIMCBuiltInTypeReference( gauge32V2PType,
										"Gauge32",
										SIMCSymbol::PRIMITIVE,
										rfc1902, 0, 0, 0 ));

  		// And the V2 textual conventions
		
		// DisplayString
		SIMCSizeList * displayStringSizeList = new SIMCSizeList;
		displayStringSizeList->AddTail(new SIMCRangeOrSizeItem (
							0, TRUE, 0, 0,
							255, TRUE, 0, 0 ));
 		char *badNameDisplayString = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInTypeReference (
				tempSubType = new SIMCSizeType(octetStringType, 0, 0,  displayStringSizeList),
				badNameDisplayString, 
				SIMCSymbol::PRIMITIVE,
				rfc1903));
		tempSubType->SetStatus(RESOLVE_CORRECT);
		tempSubType->SetRootType((SIMCTypeReference *)(*octetStringType));

		rfc1903->AddSymbol(tempTC = new SIMCTextualConvention("255a",
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										rfc1903->GetSymbol(badNameDisplayString),
										0, 0,
										"DisplayString",
										SIMCSymbol::PRIMITIVE,
										rfc1903) );
		delete 	badNameDisplayString;
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType(tempTC);
										
		// PhysAddress
		rfc1903->AddSymbol(tempTC = new SIMCTextualConvention("1x:",
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										octetStringType,
										0, 0,
										"PhysAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1903) );
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType(tempTC);
		
		// MacAddress
		SIMCSizeList * macAddressSizeList = new SIMCSizeList;
		macAddressSizeList->AddTail(new SIMCRangeOrSizeItem (
							6, TRUE, 0, 0,
							6, TRUE, 0, 0 ));
 		char *badNameMacAddress = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInTypeReference (
				tempSubType = new SIMCSizeType(octetStringType, 0, 0,  macAddressSizeList),
				badNameMacAddress, 
				SIMCSymbol::PRIMITIVE,
				rfc1903));
		tempSubType->SetStatus(RESOLVE_CORRECT);
		tempSubType->SetRootType((SIMCTypeReference *)(*octetStringType));
		rfc1903->AddSymbol(tempTC = new SIMCTextualConvention("1x:",
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										rfc1903->GetSymbol(badNameMacAddress),
										0, 0,
										"MacAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1903) );
		delete 	badNameMacAddress;
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType(tempTC);
		
		// TruthValue
		char * badNameTruthValueOne = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(1, FALSE),
									badNameTruthValueOne,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameTruthValueTwo = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(2, FALSE),
									badNameTruthValueTwo,
									SIMCSymbol::LOCAL,
									rfc1903) );
		SIMCNamedNumberList *truthValueList = new SIMCNamedNumberList;
		truthValueList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameTruthValueOne),
								0, 0,
								"true", 0, 0) );
		truthValueList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameTruthValueTwo),
								0, 0,
								"false", 0, 0) );
		char *badNameTruthValue = GenerateSymbolName();
		rfc1903->AddSymbol(tempBTRef = new SIMCBuiltInTypeReference( 
									tempSubType = new SIMCEnumOrBitsType(integerType, 0, 0, 
									truthValueList, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
									badNameTruthValue, 
									SIMCSymbol::PRIMITIVE,
									rfc1903));
		tempSubType->SetStatus(RESOLVE_CORRECT);
		tempSubType->SetRootType((SIMCTypeReference *)(*integerType));

		rfc1903->AddSymbol( tempTC = new SIMCTextualConvention (NULL,
									SIMCTextualConvention::TC_CURRENT,
									0, 0,
									"", NULL,
									rfc1903->GetSymbol(badNameTruthValue),
									0, 0,
									"TruthValue",
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType(tempBTRef);
		delete badNameTruthValue;
		delete badNameTruthValueOne;
		delete badNameTruthValueTwo;
				
		// TestAndIncr
		SIMCRangeList * testAndIncrList = new SIMCRangeList;
		testAndIncrList->AddTail(new SIMCRangeOrSizeItem (
							0, TRUE, 0, 0,
							2147483647, TRUE, 0, 0 ));
 		char *badNameTestAndIncr = GenerateSymbolName();
		rfc1903->AddSymbol( tempBTRef = new SIMCBuiltInTypeReference (
				tempSubType = new SIMCRangeType(integerType, 0, 0,  testAndIncrList),
				badNameTestAndIncr, 
				SIMCSymbol::PRIMITIVE,
				rfc1903));
		tempSubType->SetStatus(RESOLVE_CORRECT);
		tempSubType->SetRootType((SIMCTypeReference *)(*integerType));
		rfc1903->AddSymbol( tempTC = new SIMCTextualConvention(NULL,
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										rfc1903->GetSymbol(badNameTestAndIncr),
										0, 0,
										"TestAndIncr",
										SIMCSymbol::LOCAL,
										rfc1903) );
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType(tempBTRef);
		delete 	badNameTestAndIncr;
	
		// AutonomousType
		rfc1903->AddSymbol( tempTC = new SIMCTextualConvention(NULL,
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										objectIdentifierType,
										0, 0,
										"AutonomousType",
										SIMCSymbol::LOCAL,
										rfc1903) );
		
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType((SIMCTypeReference *)(*objectIdentifierType));

		// InstancePointer
		rfc1903->AddSymbol( tempTC = new SIMCTextualConvention(NULL,
										SIMCTextualConvention::TC_OBSOLETE,
										0, 0,
										"", NULL, 
										objectIdentifierType,
										0, 0,
										"InstancePointer",
										SIMCSymbol::LOCAL,
										rfc1903) );
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType((SIMCTypeReference *)(*objectIdentifierType));
		
		// RowPointer
		rfc1903->AddSymbol( tempTC = new SIMCTextualConvention(NULL,
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										objectIdentifierType,
										0, 0,
										"RowPointer",
										SIMCSymbol::LOCAL,
										rfc1903) );
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType((SIMCTypeReference *)(*objectIdentifierType));
					
		// RowStatus. Wish me luck.
		char * badNameRowStatusOne = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(1, FALSE),
									badNameRowStatusOne,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameRowStatusTwo = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(2, FALSE),
									badNameRowStatusTwo,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameRowStatusThree = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(3, FALSE),
									badNameRowStatusThree,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameRowStatusFour = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(4, FALSE),
									badNameRowStatusFour,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameRowStatusFive = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(5, FALSE),
									badNameRowStatusFive,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameRowStatusSix = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(6, FALSE),
									badNameRowStatusSix,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		
		SIMCNamedNumberList *rowStatusList = new SIMCNamedNumberList;
		rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusOne),
								0, 0,
								"active", 0, 0) );
		rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusTwo),
								0, 0,
								"notInService", 0, 0) );
		rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusThree),
								0, 0,
								"notReady", 0, 0) );
		rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusFour),
								0, 0,
								"createAndGo", 0, 0) );
		rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusFive),
								0, 0,
								"createAndWait", 0, 0) );
		rowStatusList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameRowStatusSix),
								0, 0,
								"destroy", 0, 0) );
		char *badNameRowStatus = GenerateSymbolName();
		rfc1903->AddSymbol(tempBTRef = new SIMCBuiltInTypeReference( 
									tempSubType = new SIMCEnumOrBitsType(integerType, 0, 0, 
										rowStatusList, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
									badNameRowStatus, 
									SIMCSymbol::LOCAL,
									rfc1903));
  		tempSubType->SetStatus(RESOLVE_CORRECT);
		tempSubType->SetRootType((SIMCTypeReference *)(*integerType));

		rfc1903->AddSymbol( tempTC = new SIMCTextualConvention (NULL,
									SIMCTextualConvention::TC_CURRENT,
									0, 0,
									"", NULL,
									rfc1903->GetSymbol(badNameRowStatus),
									0, 0,
									"RowStatus",
									SIMCSymbol::LOCAL,
									rfc1903) );
 		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType(tempBTRef);
		delete badNameRowStatus;
		delete badNameRowStatusOne;
		delete badNameRowStatusTwo;
		delete badNameRowStatusThree;
		delete badNameRowStatusFour;
		delete badNameRowStatusFive;
		delete badNameRowStatusSix;


		// TimeStamp
		rfc1903->AddSymbol(tempTC = new SIMCTextualConvention( NULL,
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										rfc1902->GetSymbol("TimeTicks"),
										0, 0,
										"TimeStamp",
										SIMCSymbol::LOCAL,
										rfc1903) );
										
   		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType((SIMCTypeReference *)(*rfc1902->GetSymbol("TimeTicks")));

		// TimeInterval
		SIMCRangeList * timeIntervalList = new SIMCRangeList;
		timeIntervalList->AddTail(new SIMCRangeOrSizeItem (
							0, TRUE, 0, 0,
							2147483647, TRUE, 0, 0 ));
 		char *badNameTimeInterval = GenerateSymbolName();
		rfc1903->AddSymbol( tempBTRef = new SIMCBuiltInTypeReference (
				tempSubType = new SIMCRangeType(integerType, 0, 0,  timeIntervalList),
				badNameTimeInterval, 
				SIMCSymbol::LOCAL,
				rfc1903));
  		tempSubType->SetStatus(RESOLVE_CORRECT);
		tempSubType->SetRootType((SIMCTypeReference *)(*integerType));
		rfc1903->AddSymbol(tempTC = new SIMCTextualConvention(NULL,
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										rfc1903->GetSymbol(badNameTimeInterval),
										0, 0,
										"TimeInterval",
										SIMCSymbol::LOCAL,
										rfc1903) );
   		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType(tempBTRef);
 		delete 	badNameTimeInterval;


		// DateAndTime
		SIMCSizeList * dateAndTimeList = new SIMCSizeList;
		dateAndTimeList->AddTail(new SIMCRangeOrSizeItem (
							8, TRUE, 0, 0,
							8, TRUE, 0, 0 ));
		dateAndTimeList->AddTail(new SIMCRangeOrSizeItem (
							11, TRUE, 0, 0,
							11, TRUE, 0, 0 ));
 		char *badNameDateAndTime = GenerateSymbolName();
		rfc1903->AddSymbol( tempBTRef = new SIMCBuiltInTypeReference (
				tempSubType = new SIMCSizeType(octetStringType, 0, 0,  dateAndTimeList),
				badNameDateAndTime, 
				SIMCSymbol::PRIMITIVE,
				rfc1903));
  		tempSubType->SetStatus(RESOLVE_CORRECT);
		tempSubType->SetRootType((SIMCTypeReference *)(*octetStringType));
		SIMCTextualConvention *dateAndTimeTC;
		rfc1903->AddSymbol(dateAndTimeTC = new SIMCTextualConvention("2d-1d-1d,1d:1d:1d.1d,1a1d:1d",
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										rfc1903->GetSymbol(badNameDateAndTime),
										0, 0,
										"DateAndTime",
										SIMCSymbol::PRIMITIVE,
										rfc1903) );
		delete 	badNameDateAndTime;
		dateAndTimeTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		dateAndTimeTC->SetRealType(dateAndTimeTC);

		// StorageType
		char * badNameStorageTypeOne = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(1, FALSE),
									badNameStorageTypeOne,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameStorageTypeTwo = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(2, FALSE),
									badNameStorageTypeTwo,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameStorageTypeThree = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(3, FALSE),
									badNameStorageTypeThree,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameStorageTypeFour = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(4, FALSE),
									badNameStorageTypeFour,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		char * badNameStorageTypeFive = GenerateSymbolName();
		rfc1903->AddSymbol( new SIMCBuiltInValueReference( integerType,
									0, 0,
									new SIMCIntegerValue(5, FALSE),
									badNameStorageTypeFive,
									SIMCSymbol::PRIMITIVE,
									rfc1903) );
		
		SIMCNamedNumberList *storageTypeList = new SIMCNamedNumberList;
		storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeOne),
								0, 0,
								"other", 0, 0) );
		storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeTwo),
								0, 0,
								"volatile", 0, 0) );
		storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeThree),
								0, 0,
								"nonVolatile", 0, 0) );
		storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeFour),
								0, 0,
								"permanent", 0, 0) );
		storageTypeList->AddTail(new SIMCNamedNumberItem(  rfc1903->GetSymbol(badNameStorageTypeFive),
								0, 0,
								"readOnly", 0, 0) );

		char *badNameStorageType = GenerateSymbolName();
		rfc1903->AddSymbol(tempBTRef = new SIMCBuiltInTypeReference( 
									tempSubType = new SIMCEnumOrBitsType(integerType, 0, 0, 
										storageTypeList, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
									badNameStorageType, 
									SIMCSymbol::LOCAL,
									rfc1903));
    	tempSubType->SetStatus(RESOLVE_CORRECT);
		tempSubType->SetRootType((SIMCTypeReference *)(*integerType));

		rfc1903->AddSymbol( tempTC = new SIMCTextualConvention (NULL,
									SIMCTextualConvention::TC_CURRENT,
									0, 0,
									"", NULL,
									rfc1903->GetSymbol(badNameStorageType),
									0, 0,
									"StorageType",
									SIMCSymbol::LOCAL,
									rfc1903) );
		delete badNameStorageType;
		delete badNameStorageTypeOne;
		delete badNameStorageTypeTwo;
		delete badNameStorageTypeThree;
		delete badNameStorageTypeFour;
		delete badNameStorageTypeFive;
  		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType(tempBTRef);

		// TDomain
		rfc1903->AddSymbol(tempTC = new SIMCTextualConvention( NULL,
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										objectIdentifierType,
										0, 0,
										"TDomain",
										SIMCSymbol::LOCAL,
										rfc1903) );
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType((SIMCTypeReference *)(*objectIdentifierType));
		
		// TAddress
		SIMCSizeList * tAddressSizeList = new SIMCSizeList;
		tAddressSizeList->AddTail(new SIMCRangeOrSizeItem (
							1, TRUE, 0, 0,
							255, TRUE, 0, 0 ));
 		char *badNameTAddress = GenerateSymbolName();
		rfc1903->AddSymbol( tempBTRef = new SIMCBuiltInTypeReference (
				tempSubType = new SIMCSizeType(octetStringType, 0, 0,  tAddressSizeList),
				badNameTAddress, 
				SIMCSymbol::LOCAL,
				rfc1903));
  		tempSubType->SetStatus(RESOLVE_CORRECT);
		tempSubType->SetRootType((SIMCTypeReference *)(*octetStringType));
		rfc1903->AddSymbol(tempTC = new SIMCTextualConvention(NULL,
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										rfc1903->GetSymbol(badNameTAddress),
										0, 0,
										"TAddress",
										SIMCSymbol::LOCAL,
										rfc1903) );	   
		delete 	badNameTAddress;
 		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType(tempBTRef);

		// SnmpUDPAddress
		SIMCTextualConvention *SnmpUDPAddressTC;
		rfc1906->AddSymbol(SnmpUDPAddressTC = new SIMCTextualConvention("1d.1d.1d.1d/2d",
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										octetStringType,
										0, 0,
										"SnmpUDPAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1906) );
		SnmpUDPAddressTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		SnmpUDPAddressTC->SetRealType(SnmpUDPAddressTC);
										
		// SnmpOSIAddress
		SIMCTextualConvention *SnmpOSIAddressTC;
		rfc1906->AddSymbol(SnmpOSIAddressTC = new SIMCTextualConvention("*1x:/1x:",
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										octetStringType,
										0, 0,
										"SnmpOSIAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1906) );
		SnmpOSIAddressTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		SnmpOSIAddressTC->SetRealType(SnmpOSIAddressTC);
										
 		// SnmpNBPAddress
		rfc1906->AddSymbol(tempTC = new SIMCTextualConvention(NULL,
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										octetStringType,
										0, 0,
										"SnmpNBPAddress",
										SIMCSymbol::LOCAL,
										rfc1906) );
		tempTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		tempTC->SetRealType((SIMCTypeReference *)(*octetStringType));
										
		// SnmpIPXAddress
		SIMCTextualConvention *SnmpIPXAddressTC;
		rfc1906->AddSymbol(SnmpIPXAddressTC = new SIMCTextualConvention("4x.1x:1x:1x:1x:1x:1x.2d",
										SIMCTextualConvention::TC_CURRENT,
										0, 0,
										"", NULL, 
										octetStringType,
										0, 0,
										"SnmpIPXAddress",
										SIMCSymbol::PRIMITIVE,
										rfc1906) );
		SnmpIPXAddressTC->SIMCDefinedTypeReference::SetStatus(RESOLVE_CORRECT);
		SnmpIPXAddressTC->SetRealType(SnmpIPXAddressTC);
										
	}

									
	//--------------- 3. OBJECT IDENTIFIERS --------------------------------

	// V1 OIDs
	if(_snmpVersion != 2 )
	{
		SIMCIntegerValue	*one	= new SIMCIntegerValue(1, TRUE),
							*two	= new SIMCIntegerValue(2, TRUE),
							*three	= new SIMCIntegerValue(3, TRUE),
							*four	= new SIMCIntegerValue(4, TRUE),
							*six	= new SIMCIntegerValue(6, TRUE),
							*ten	= new SIMCIntegerValue(10, TRUE);
		char	*badNameOne,
				*badNameTwo, 
				*badNameThree, 
				*badNameFour,
				*badNameSix, 
				*badNameTen;

		rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, one,
			badNameOne = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, two,
			badNameTwo = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, three,
			badNameThree = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, four,
			badNameFour = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, six,
			badNameSix = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1155->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, ten,
			badNameTen = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));

		SIMCSymbol **oneVal		= rfc1155->GetSymbol(badNameOne);
		SIMCSymbol **twoVal		= rfc1155->GetSymbol(badNameTwo);
		SIMCSymbol **threeVal	= rfc1155->GetSymbol(badNameThree);
		SIMCSymbol **fourVal	= rfc1155->GetSymbol(badNameFour);
		SIMCSymbol **sixVal		= rfc1155->GetSymbol(badNameSix);
		SIMCSymbol **tenVal		= rfc1155->GetSymbol(badNameTen);

		delete badNameOne;
		delete badNameTwo;
		delete badNameThree;
		delete badNameFour;
		delete badNameSix;
		delete badNameTen;

		SIMCOidComponent 
			*isoCom				= new SIMCOidComponent(oneVal,  0, 0, "iso",			0, 0),
			*ccittCom			= new SIMCOidComponent(twoVal,  0, 0, "ccitt",			0, 0),
			*jointIsoCcittCom	= new SIMCOidComponent(threeVal,0, 0, "joint-iso-ccitt",0, 0), 
			*internetCom		= new SIMCOidComponent(oneVal,  0, 0, "internet",		0, 0),
			*orgCom				= new SIMCOidComponent(threeVal,0, 0, "org",			0, 0), 
			*dodCom				= new SIMCOidComponent(sixVal,  0, 0, "dod",			0, 0),
			*directoryCom		= new SIMCOidComponent(oneVal,  0, 0, "directory",		0, 0),
			*mgmtCom			= new SIMCOidComponent(twoVal,  0, 0, "mgmt",			0, 0),
			*experimentalCom	= new SIMCOidComponent(threeVal,0, 0, "experimental",	0, 0),
			*privateRCom		= new SIMCOidComponent(fourVal, 0, 0, "private",		0, 0),
			*enterprisesCom		= new SIMCOidComponent(oneVal,  0, 0, "enterprises",	0, 0),
			*mib2Com			= new SIMCOidComponent(oneVal,  0, 0, "mib-2",			0, 0),
			*interfacesCom		= new SIMCOidComponent(twoVal,  0, 0, "interfaces",		0, 0),
			*ipCom				= new SIMCOidComponent(fourVal, 0, 0, "ip",				0, 0),
			*transmissionCom	= new SIMCOidComponent(tenVal,  0, 0, "transmission",	0, 0);

		// The lists of components	for V1
		// iso
		SIMCOidComponentList *listForIso = new SIMCOidComponentList;
		listForIso->AddTail(isoCom);
		// ccitt
		SIMCOidComponentList *listForCcitt = new SIMCOidComponentList;
		listForCcitt->AddTail(ccittCom);
		// joint-iso-ccitt
		SIMCOidComponentList *listForJointIsoCcitt = new SIMCOidComponentList;
		listForJointIsoCcitt->AddTail(jointIsoCcittCom);
		// internet
		SIMCOidComponentList *listForInternet = new SIMCOidComponentList;
		listForInternet->AddTail(internetCom);
		// directory
		SIMCOidComponentList *listForDirectory = new SIMCOidComponentList;
		listForDirectory->AddTail(directoryCom);
		// mgmt
		SIMCOidComponentList *listForMgmt			= new SIMCOidComponentList;
		listForMgmt->AddTail(mgmtCom);
		// experimental
		SIMCOidComponentList *listForExperimental	= new SIMCOidComponentList;
		listForExperimental->AddTail(experimentalCom);
		// private
		SIMCOidComponentList *listForPrivate		= new SIMCOidComponentList;
		listForPrivate->AddTail(privateRCom);
		// enterprises
		SIMCOidComponentList *listForEnterprises	= new SIMCOidComponentList;
		listForEnterprises->AddTail(enterprisesCom);
		// mib-2
		SIMCOidComponentList *listForMib2			= new SIMCOidComponentList;
		listForMib2->AddTail(mib2Com);
		// interfaces
		SIMCOidComponentList *listForInterfaces		= new SIMCOidComponentList;
		listForInterfaces->AddTail(interfacesCom);
		// ip
		SIMCOidComponentList *listForIp				= new SIMCOidComponentList;
		listForIp->AddTail(ipCom);
		// transmission
		SIMCOidComponentList *listForTransmission	= new SIMCOidComponentList;
		listForTransmission->AddTail(transmissionCom);

		// And finally, the values
		rfc1155->AddSymbol( new SIMCBuiltInValueReference
								(objectIdentifierType, 0, 0,
								new SIMCOidValue(listForIso),
								"iso", SIMCSymbol::PRIMITIVE, rfc1155) );
		isoV1 = rfc1155->GetSymbol("iso");
		listForInternet->AddHead(dodCom);
		listForInternet->AddHead(orgCom);
		listForInternet->AddHead(new SIMCOidComponent ( isoV1, 0, 0, "iso", 0, 0));
		rfc1155->AddSymbol( new SIMCBuiltInValueReference
								(objectIdentifierType, 0, 0,
								new SIMCOidValue(listForCcitt),
								"ccitt", SIMCSymbol::PRIMITIVE, rfc1155) );
		ccittV1 = rfc1155->GetSymbol("ccitt");
		rfc1155->AddSymbol( new SIMCBuiltInValueReference
								(objectIdentifierType, 0, 0,
								new SIMCOidValue(listForJointIsoCcitt),
								"joint-iso-ccitt", SIMCSymbol::PRIMITIVE, rfc1155) );
		jointIsoCcittV1 = rfc1155->GetSymbol("joint-iso-ccitt");
		rfc1155->AddSymbol(	new SIMCBuiltInValueReference
								(objectIdentifierType, 0, 0,
								new SIMCOidValue(listForInternet),
								"internet", SIMCSymbol::PRIMITIVE, rfc1155) );
		internetV1 = rfc1155->GetSymbol("internet");

		listForDirectory->AddHead	(new SIMCOidComponent ( internetV1, 0, 0, "internet", 0, 0));
		listForMgmt->AddHead		(new SIMCOidComponent ( internetV1, 0, 0, "internet", 0, 0));
		listForExperimental->AddHead(new SIMCOidComponent ( internetV1, 0, 0, "internet", 0, 0));
		listForPrivate->AddHead		(new SIMCOidComponent ( internetV1, 0, 0, "internet", 0, 0));

		rfc1155->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType, 
							0, 0,
							new SIMCOidValue(listForDirectory),
							"directory", 
							SIMCSymbol::PRIMITIVE, rfc1155) );
		directoryV1 = rfc1155->GetSymbol("directory");

		rfc1155->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType, 
							0, 0,
							new SIMCOidValue(listForMgmt),
							"mgmt", 
							SIMCSymbol::PRIMITIVE, rfc1155) );
		mgmtV1 = rfc1155->GetSymbol("mgmt");
		listForMib2->AddHead(new SIMCOidComponent(mgmtV1, 0, 0, "mgmt", 0, 0));


		rfc1155->AddSymbol(new SIMCBuiltInValueReference (
								objectIdentifierType,
								0, 0,
								new SIMCOidValue(listForExperimental),
								"experimental", 
								SIMCSymbol::PRIMITIVE, rfc1155) 
							);
		experimentalV1 = rfc1155->GetSymbol("experimental");


		rfc1155->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType, 
							0, 0,
							new SIMCOidValue(listForPrivate),
							"private", 
							SIMCSymbol::PRIMITIVE, rfc1155) 
							);	
		privateV1 = rfc1155->GetSymbol("private");
		listForEnterprises->AddHead(new SIMCOidComponent(privateV1, 0, 0, "private", 0, 0));

		rfc1155->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForEnterprises),
							"enterprises", 
							SIMCSymbol::PRIMITIVE, rfc1155) 
							);
		enterprisesV1 = rfc1155->GetSymbol("enterprises");

		rfc1213->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForMib2),
							"mib-2", 
							SIMCSymbol::PRIMITIVE, rfc1213) 
							);	
		mib2V1 = rfc1213->GetSymbol("mib-2");

		listForIp->AddHead( new SIMCOidComponent (mib2V1, 0, 0, "mib-2", 0, 0));
		listForInterfaces->AddHead( new SIMCOidComponent (mib2V1, 0, 0, "mib-2", 0, 0));
		listForTransmission->AddHead(new SIMCOidComponent (mib2V1, 0, 0, "mib-2", 0, 0));

		rfc1213->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForIp),
							"ip", 
							SIMCSymbol::PRIMITIVE, rfc1213) 
							);	
		ipV1 = rfc1213->GetSymbol("ip");

		rfc1213->AddSymbol(new SIMCBuiltInValueReference ( 
							objectIdentifierType, 
							0, 0,
							new SIMCOidValue(listForInterfaces),
							"interfaces", 
							SIMCSymbol::PRIMITIVE, rfc1213) 
							);	
		interfacesV1 = rfc1213->GetSymbol("interfaces");

		rfc1213->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForTransmission),
							"transmission", 
							SIMCSymbol::PRIMITIVE, rfc1213) 
							);	
		transmissionV1 = rfc1213->GetSymbol("transmission");
	}
	if (_snmpVersion != 1)
	{
		// V2 OIDs
		SIMCIntegerValue	*zeroV2		= new SIMCIntegerValue(0, TRUE),
							*oneV2		= new SIMCIntegerValue(1, TRUE),
							*twoV2		= new SIMCIntegerValue(2, TRUE),
							*threeV2	= new SIMCIntegerValue(3, TRUE),
							*fourV2		= new SIMCIntegerValue(4, TRUE),
							*fiveV2		= new SIMCIntegerValue(5, TRUE),
							*sixV2		= new SIMCIntegerValue(6, TRUE),
							*tenV2		= new SIMCIntegerValue(10, TRUE);
		char	*badNameZeroV2,
				*badNameOneV2,
				*badNameTwoV2, 
				*badNameThreeV2, 
				*badNameFourV2,
				*badNameFiveV2,
				*badNameSixV2, 
				*badNameTenV2;

		rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, zeroV2,
			badNameZeroV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, oneV2,
			badNameOneV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, twoV2,
			badNameTwoV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, threeV2,
			badNameThreeV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, fourV2,
			badNameFourV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, fiveV2,
			badNameFiveV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, sixV2,
			badNameSixV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));
		rfc1902->AddSymbol(new SIMCBuiltInValueReference(integerType, 0, 0, tenV2,
			badNameTenV2 = GenerateSymbolName(), SIMCSymbol::PRIMITIVE, other));

		SIMCSymbol **zeroValV2		= rfc1902->GetSymbol(badNameZeroV2);
		SIMCSymbol **oneValV2		= rfc1902->GetSymbol(badNameOneV2);
		SIMCSymbol **twoValV2		= rfc1902->GetSymbol(badNameTwoV2);
		SIMCSymbol **threeValV2		= rfc1902->GetSymbol(badNameThreeV2);
		SIMCSymbol **fourValV2		= rfc1902->GetSymbol(badNameFourV2);
		SIMCSymbol **fiveValV2		= rfc1902->GetSymbol(badNameFiveV2);
		SIMCSymbol **sixValV2		= rfc1902->GetSymbol(badNameSixV2);
		SIMCSymbol **tenValV2		= rfc1902->GetSymbol(badNameTenV2);

		delete badNameZeroV2;
		delete badNameOneV2;
		delete badNameTwoV2;
		delete badNameThreeV2;
		delete badNameFourV2;
		delete badNameFiveV2;
		delete badNameSixV2;
		delete badNameTenV2;

		SIMCOidComponent
			*zero1ComV2			= new SIMCOidComponent(zeroValV2, 0, 0, "zero",			0, 0),
			*zero2ComV2			= new SIMCOidComponent(zeroValV2, 0, 0, "zero",			0, 0),
			*isoComV2			= new SIMCOidComponent(oneValV2,  0, 0, "iso",			0, 0),
			*orgComV2			= new SIMCOidComponent(threeValV2,0, 0, "org",			0, 0), 
			*dodComV2			= new SIMCOidComponent(sixValV2,  0, 0, "dod",			0, 0),
			*internetComV2		= new SIMCOidComponent(oneValV2,  0, 0, "internet",		0, 0),
			*directoryComV2		= new SIMCOidComponent(oneValV2,  0, 0, "directory",	0, 0),
 			*mgmtComV2			= new SIMCOidComponent(twoValV2,  0, 0, "mgmt",			0, 0),
			*mib2ComV2			= new SIMCOidComponent(oneValV2,  0, 0, "mib-2",		0, 0),
			*interfacesComV2	= new SIMCOidComponent(twoValV2,  0, 0, "interfaces",		0, 0),
			*ipComV2			= new SIMCOidComponent(fourValV2, 0, 0, "ip",				0, 0),
			*transmissionComV2	= new SIMCOidComponent(tenValV2,  0, 0, "transmission",	0, 0),
			*experimentalComV2	= new SIMCOidComponent(threeValV2,0, 0, "experimental",	0, 0),
			*privateComV2		= new SIMCOidComponent(fourValV2, 0, 0, "private",		0, 0),
			*enterprisesComV2	= new SIMCOidComponent(oneValV2,  0, 0, "enterprises",	0, 0),
			*securityComV2		= new SIMCOidComponent(fiveValV2, 0, 0, "security",		0, 0),
			*snmpV2ComV2		= new SIMCOidComponent(sixValV2,  0, 0, "snmpV2",		0, 0),
			*snmpDomainsComV2	= new SIMCOidComponent(oneValV2,  0, 0, "snmpDomains",	0, 0),
			*snmpProxysComV2	= new SIMCOidComponent(twoValV2,  0, 0, "snmpProxys",	0, 0),
			*snmpModulesComV2	= new SIMCOidComponent(threeValV2,0, 0, "snmpModules",	0, 0),
			*rfc1157ProxyComV2	= new SIMCOidComponent(oneValV2,  0, 0, "rfc1157Proxy",	0, 0),
			*snmpUDPDomainComV2	= new SIMCOidComponent(oneValV2,  0, 0, "snmpUDPDomain",0, 0),
			*snmpCLNSDomainComV2= new SIMCOidComponent(twoValV2,  0, 0, "snmpCLNSDomain",0, 0),
			*snmpCONSDomainComV2= new SIMCOidComponent(threeValV2,0, 0, "snmpCONSDomain",0, 0),
			*snmpDDPDomainComV2	= new SIMCOidComponent(fourValV2, 0, 0, "snmpDDPDomain",0, 0),
			*snmpIPXDomainComV2	= new SIMCOidComponent(fiveValV2, 0, 0, "snmpIPXDomain",0, 0),
			*rfc1157DomainComV2	= new SIMCOidComponent(sixValV2,  0, 0, "rfc1157Domain",0, 0);

		SIMCOidComponentList * listForZeroDotZeroV2		= new SIMCOidComponentList;
		SIMCOidComponentList * listForOrgV2				= new SIMCOidComponentList;
		SIMCOidComponentList * listForDodV2				= new SIMCOidComponentList;
		SIMCOidComponentList * listForInternetV2		= new SIMCOidComponentList;
		SIMCOidComponentList * listForDirectoryV2		= new SIMCOidComponentList;
		SIMCOidComponentList * listForMgmtV2			= new SIMCOidComponentList;
		SIMCOidComponentList * listForMib2V2			= new SIMCOidComponentList;
		SIMCOidComponentList * listForIpV2				= new SIMCOidComponentList;
		SIMCOidComponentList * listForInterfacesV2		= new SIMCOidComponentList;
		SIMCOidComponentList * listForTransmissionV2	= new SIMCOidComponentList;
		SIMCOidComponentList * listForExperimentalV2	= new SIMCOidComponentList;
		SIMCOidComponentList * listForPrivateV2			= new SIMCOidComponentList;
		SIMCOidComponentList * listForEnterprisesV2		= new SIMCOidComponentList;
		SIMCOidComponentList * listForSecurityV2		= new SIMCOidComponentList;
		SIMCOidComponentList * listForSnmpV2V2			= new SIMCOidComponentList;
		SIMCOidComponentList * listForSnmpDomainsV2		= new SIMCOidComponentList;
		SIMCOidComponentList * listForSnmpProxysV2		= new SIMCOidComponentList;
		SIMCOidComponentList * listForSnmpModulesV2		= new SIMCOidComponentList;
		SIMCOidComponentList * listForRfc1157ProxyV2	= new SIMCOidComponentList;
		SIMCOidComponentList * listForSnmpUDPDomainV2	= new SIMCOidComponentList;
		SIMCOidComponentList * listForSnmpCLNSDomainV2	= new SIMCOidComponentList;
		SIMCOidComponentList * listForSnmpCONSDomainV2	= new SIMCOidComponentList;
		SIMCOidComponentList * listForSnmpDDPDomainV2	= new SIMCOidComponentList;
		SIMCOidComponentList * listForSnmpIPXDomainV2	= new SIMCOidComponentList;
		SIMCOidComponentList * listForRfc1157DomainV2	= new SIMCOidComponentList;
		
		// zeroDotZero
 		listForZeroDotZeroV2->AddTail(zero1ComV2);
		listForZeroDotZeroV2->AddTail(zero2ComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForZeroDotZeroV2),
							"zeroDotZero", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		zeroDotZeroV2 = rfc1902->GetSymbol("zeroDotZero");


		// org
		listForOrgV2->AddTail(isoComV2);
		listForOrgV2->AddTail(orgComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForOrgV2),
							"org", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		orgV2 = rfc1902->GetSymbol("org");

		// dod
		listForDodV2->AddTail(new SIMCOidComponent(orgV2, 0, 0, "org", 0, 0));
		listForDodV2->AddTail(dodComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForDodV2),
							"dod", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		dodV2 = rfc1902->GetSymbol("dod");

		// internet
		listForInternetV2->AddTail(new SIMCOidComponent(dodV2, 0, 0, "dod", 0, 0));
		listForInternetV2->AddTail(internetComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForInternetV2),
							"internet", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		internetV2 = rfc1902->GetSymbol("internet");

		// directory
		listForDirectoryV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
		listForDirectoryV2->AddTail(directoryComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForDirectoryV2),
							"directory", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		directoryV2 = rfc1902->GetSymbol("directory");

		// mgmt
		listForMgmtV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
		listForMgmtV2->AddTail(mgmtComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForMgmtV2),
							"mgmt", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		mgmtV2 = rfc1902->GetSymbol("mgmt");

		// mib-2
		listForMib2V2->AddTail(new SIMCOidComponent(mgmtV2, 0, 0, "mgmt", 0, 0));
		listForMib2V2->AddTail(mib2ComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForMib2V2),
							"mib-2", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		mib2V2 = rfc1902->GetSymbol("mib-2");

		// ip
		listForIpV2->AddTail(new SIMCOidComponent(mib2V2, 0, 0, "mib-2", 0, 0));
		listForIpV2->AddTail(ipComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForIpV2),
							"ip", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		ipV2 = rfc1902->GetSymbol("ip");

		// interfaces
		listForInterfacesV2->AddTail(new SIMCOidComponent(mib2V2, 0, 0, "mib-2", 0, 0));
		listForInterfacesV2->AddTail(interfacesComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForInterfacesV2),
							"interfaces", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		interfacesV2 = rfc1902->GetSymbol("interfaces");


		// transmission
		listForTransmissionV2->AddTail(new SIMCOidComponent(mib2V2, 0, 0, "mib-2", 0, 0));
		listForTransmissionV2->AddTail(transmissionComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForTransmissionV2),
							"transmission", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		transmissionV2 = rfc1902->GetSymbol("transmission");

		// experimental
		listForExperimentalV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
		listForExperimentalV2->AddTail(experimentalComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForExperimentalV2),
							"experimental", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		experimentalV2 = rfc1902->GetSymbol("experimental");

		// private
		listForPrivateV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
		listForPrivateV2->AddTail(privateComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForPrivateV2),
							"private", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		privateV2 = rfc1902->GetSymbol("private");

		// enterprises
		listForEnterprisesV2->AddTail(new SIMCOidComponent(privateV2, 0, 0, "private", 0, 0));
		listForEnterprisesV2->AddTail(enterprisesComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForEnterprisesV2),
							"enterprises", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		enterprisesV2 = rfc1902->GetSymbol("enterprises");

		// security
		listForSecurityV2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
		listForSecurityV2->AddTail(securityComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSecurityV2),
							"security", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		securityV2 = rfc1902->GetSymbol("security");

		// snmpV2
		listForSnmpV2V2->AddTail(new SIMCOidComponent(internetV2, 0, 0, "internet", 0, 0));
		listForSnmpV2V2->AddTail(snmpV2ComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSnmpV2V2),
							"snmpV2", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		snmpV2V2 = rfc1902->GetSymbol("snmpV2");

 		// snmpDomains
		listForSnmpDomainsV2->AddTail(new SIMCOidComponent(snmpV2V2, 0, 0, "snmpV2", 0, 0));
		listForSnmpDomainsV2->AddTail(snmpDomainsComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSnmpDomainsV2),
							"snmpDomains", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		snmpDomainsV2 = rfc1902->GetSymbol("snmpDomains");

 		// snmpProxys
		listForSnmpProxysV2->AddTail(new SIMCOidComponent(snmpV2V2, 0, 0, "snmpV2", 0, 0));
		listForSnmpProxysV2->AddTail(snmpProxysComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSnmpProxysV2),
							"snmpProxys", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		snmpProxysV2 = rfc1902->GetSymbol("snmpProxys");

 		// snmpModules
		listForSnmpModulesV2->AddTail(new SIMCOidComponent(snmpV2V2, 0, 0, "snmpV2", 0, 0));
		listForSnmpModulesV2->AddTail(snmpModulesComV2);
		rfc1902->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSnmpModulesV2),
							"snmpModules", 
							SIMCSymbol::PRIMITIVE, rfc1902) 
							);	
		snmpModulesV2 = rfc1902->GetSymbol("snmpModules");

 		// snmpUDPDomain
		listForSnmpUDPDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
		listForSnmpUDPDomainV2->AddTail(snmpUDPDomainComV2);
		rfc1906->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSnmpUDPDomainV2),
							"snmpUDPDomain", 
							SIMCSymbol::PRIMITIVE, rfc1906) 
							);	
		snmpUDPDomainV2 = rfc1906->GetSymbol("snmpUDPDomain");

 		// snmpCLNSDomain
		listForSnmpCLNSDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
		listForSnmpCLNSDomainV2->AddTail(snmpCLNSDomainComV2);
		rfc1906->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSnmpCLNSDomainV2),
							"snmpCLNSDomain", 
							SIMCSymbol::PRIMITIVE, rfc1906) 
							);	
		snmpCLNSDomainV2 = rfc1906->GetSymbol("snmpCLNSDomain");

 		// snmpCONSDomain
		listForSnmpCONSDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
		listForSnmpCONSDomainV2->AddTail(snmpCONSDomainComV2);
		rfc1906->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSnmpCONSDomainV2),
							"snmpCONSDomain", 
							SIMCSymbol::PRIMITIVE, rfc1906) 
							);	
		snmpCONSDomainV2 = rfc1906->GetSymbol("snmpCONSDomain");

 		// snmpDDPDomain
		listForSnmpDDPDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
		listForSnmpDDPDomainV2->AddTail(snmpDDPDomainComV2);
		rfc1906->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSnmpDDPDomainV2),
							"snmpDDPDomain", 
							SIMCSymbol::PRIMITIVE, rfc1906) 
							);	
		snmpDDPDomainV2 = rfc1906->GetSymbol("snmpDDPDomain");

 		// snmpIPXDomain
		listForSnmpIPXDomainV2->AddTail(new SIMCOidComponent(snmpDomainsV2, 0, 0, "snmpDomains", 0, 0));
		listForSnmpIPXDomainV2->AddTail(snmpIPXDomainComV2);
		rfc1906->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForSnmpIPXDomainV2),
							"snmpIPXDomain", 
							SIMCSymbol::PRIMITIVE, rfc1906) 
							);	
		snmpIPXDomainV2 = rfc1906->GetSymbol("snmpIPXDomain");

 		// rfc1157Proxy
		listForRfc1157ProxyV2->AddTail(new SIMCOidComponent(snmpProxysV2, 0, 0, "snmpProxys", 0, 0));
		listForRfc1157ProxyV2->AddTail(rfc1157ProxyComV2);
		rfc1906->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForRfc1157ProxyV2),
							"rfc1157Proxy", 
							SIMCSymbol::PRIMITIVE, rfc1906) 
							);	
		rfc1157ProxyV2 = rfc1906->GetSymbol("rfc1157Proxy");

		// rfc1157Domain
		listForRfc1157DomainV2->AddTail(new SIMCOidComponent(rfc1157ProxyV2, 0, 0, "rfc1157Domain", 0, 0));
		listForRfc1157DomainV2->AddTail(rfc1157DomainComV2);
		rfc1906->AddSymbol(new SIMCBuiltInValueReference (
							objectIdentifierType,
							0, 0,
							new SIMCOidValue(listForRfc1157DomainV2),
							"rfc1157Domain", 
							SIMCSymbol::PRIMITIVE, rfc1906) 
							);	
		rfc1157DomainV2 = rfc1906->GetSymbol("rfc1157Domain");

	}

	/*------------------------- 4. Other Values --------------------- */	
	char	*trueBadName = GenerateSymbolName(), 
			*falseBadName = GenerateSymbolName(), 
			*nullBadName = GenerateSymbolName(); 
	SIMCValue *trueValue = new SIMCBooleanValue(TRUE);
	SIMCValue *falseValue = new SIMCBooleanValue(FALSE);
	SIMCValue *nullValue = new SIMCNullValue();

	other->AddSymbol( new SIMCBuiltInValueReference(booleanType,
						0, 0,
						trueValue,
						trueBadName) );
	other->AddSymbol( new SIMCBuiltInValueReference(booleanType,
						0, 0,
						falseValue,
						falseBadName) );
	other->AddSymbol( new SIMCBuiltInValueReference(nullType,
						0, 0,
						nullValue,
						nullBadName) );
	trueValueReference = other->GetSymbol(trueBadName);
	falseValueReference = other->GetSymbol(falseBadName);
	nullValueReference = other->GetSymbol(nullBadName);
}


SIMCParser::~SIMCParser()
{}

// Handles all syntax errors
void SIMCParser::SyntaxError(int errorType, int lineNo, int columnNo,
				 char *lastToken, char *infoString)
{	
	if( lineNo == -1 )
		lineNo = _theScanner->yylineno;
	if ( columnNo == -1 )
		columnNo = _theScanner->columnNo;
	if(!lastToken)
		lastToken = _theScanner->yytext;

	if (syntaxErrorsDll == NULL)
		cerr << "SIMCParser::SyntaxError(): Panic, NULL syntaxErrorsDll" << endl;

	if( errorType<=0 )
	{
		cerr << "Panic: Unknown Syntax error number:" << errorType << endl;
		return;
	}

	// Create and fill up the fields of an SIMCErrorMessage object
	SIMCErrorMessage errorMessage;
	errorMessage.SetInputStreamName(_theScanner->GetInputStreamName());
	errorMessage.SetLineNumber(lineNo);
 	errorMessage.SetColumnNumber(columnNo);
	errorMessage.SetErrorId(SYNTAX_ERROR_BASE + errorType);
	
	char message[MESSAGE_SIZE];
	char errorText[MESSAGE_SIZE];

	if(!LoadString(syntaxErrorsDll, errorType, errorText, MESSAGE_SIZE))
		cerr << "SIMCParser::SyntaxError(): Panic, unable to load error "
		<< "string" << endl;

	switch(errorType)
	{
		case SKIPPING_OBJECT_TYPE:	
		case SKIPPING_TRAP_TYPE:
			errorMessage.SetSeverityLevel(INFORMATION);
			errorMessage.SetSeverityString("Information");
			sprintf(message, "%s %s", errorText, infoString);
			errorMessage.SetMessage(message);
			_informationCount++;
			break;
		case TOO_BIG_NUM:
			errorMessage.SetSeverityLevel(FATAL);
			errorMessage.SetSeverityString("Fatal");
			sprintf(message, "%s %s", errorText, infoString);
			errorMessage.SetMessage(message);
			_fatalCount++;
			break;
		case NOTIFICATION_TYPE_DISALLOWED:	
		case MODULE_IDENTITY_DISALLOWED:
		case OBJECT_IDENTITY_DISALLOWED:
		case TEXTUAL_CONVENTION_DISALLOWED:
		case OBJECT_GROUP_DISALLOWED:
		case NOTIFICATION_GROUP_DISALLOWED:
		case MODULE_COMPLIANCE_DISALLOWED:
		case AGENT_CAPABILITIES_DISALLOWED:
		case ERROR_OBJECT_TYPE:
		case V1_OBJECT_TYPE_DISALLOWED:
		case V2_OBJECT_TYPE_DISALLOWED:
		case UNTERMINATED_STRING:
		case NAME_INSTEAD_OF_ID:
			errorMessage.SetSeverityLevel(FATAL);
			errorMessage.SetSeverityString("Fatal");
			errorMessage.SetMessage(errorText);
			_fatalCount++;
			break;
		case MODULE_IDENTITY_ONLY_AFTER_IMPORTS:
			errorMessage.SetSeverityLevel(WARNING);
			errorMessage.SetSeverityString("Warning");
			errorMessage.SetMessage(errorText);
			_warningCount++;
			break;
		case INSTEAD_OF_CCE:
			sprintf( message, "Unknown token \"%s\" %s", infoString, 
				errorText);
			errorMessage.SetSeverityLevel(WARNING);
			errorMessage.SetSeverityString("Warning");
			errorMessage.SetMessage(message);
			_warningCount++;
			break;

		case UNRECOGNIZED_CHARACTER:
			sprintf( message, "%s \"%s\"", errorText, 
				infoString);
			errorMessage.SetSeverityLevel(WARNING);
			errorMessage.SetSeverityString("Warning");
			errorMessage.SetMessage(message);
			_warningCount++;
			break;

		default:
			sprintf(message, "Syntax error in %s", errorText);
			if (lastToken)
			{
				strcat(message, ". Last token read is \"");
				strcat(message, lastToken);
				strcat(message, "\"");
			}
			errorMessage.SetMessage(message);
			errorMessage.SetSeverityLevel(FATAL);
			errorMessage.SetSeverityString("Fatal");
			_fatalCount++;
	}

	if( _errorContainer)
		_errorContainer->InsertMessage(errorMessage);
}

SIMCModule * SIMCParser::GetModule() const
{
	return _module;
}


BOOL SIMCParser::SetImportSymbols()
{
	BOOL retVal = TRUE;
	SIMCSymbolTable *symbolTable = _module->GetSymbolTable();
	POSITION p = symbolTable->GetStartPosition();
	SIMCSymbol **next, **import1, **import2;
	CString nextName;
	while(p)
	{
		symbolTable->GetNextAssoc(p, nextName, next);
		if( SIMCModule::GetSymbolClass(next) != SIMCModule::SYMBOL_UNKNOWN)
			continue;
		SIMCSymbol **ref;
		const SIMCModule *reservedModule;
		switch( _module->GetImportedSymbol(nextName, import1, import2))
		{
			case AMBIGUOUS:
				if(reservedModule = IsReservedSymbol(nextName))
				{
					SIMCSymbol *old = *next;
  					ref = _module->GetSymbol(nextName);
					import1 = reservedModule->GetSymbol(nextName);
					(*import1)->SetReferenceCount (
						(*import1)->GetReferenceCount() +
						(*ref)->GetReferenceCount() );
					*ref = *import1;
					SemanticError(_module->GetInputFileName(),
						STANDARD_AMBIGUOUS_REFERENCE,
						old->GetLineNumber(),
						old->GetColumnNumber(),
						(const char *)nextName,
						reservedModule->GetModuleName());
					delete old;
				}
				else
				{
					SemanticError(_module->GetInputFileName(),
						IMPORT_AMBIGUOUS_REFERENCE, 
						(*next)->GetLineNumber(),
						(*next)->GetColumnNumber(),
						(const char *)nextName);
					retVal = FALSE;
				}
				break;
			case UNAMBIGUOUS:
				ref = _module->GetSymbol(nextName);
				(*import1)->SetReferenceCount (
					(*import1)->GetReferenceCount() +
					(*ref)->GetReferenceCount() );
				delete *ref;
				*ref = *import1;
				break;
			case NOT_FOUND:
				SemanticError(_module->GetInputFileName(),
					SYMBOL_UNDEFINED, 
					(*next)->GetLineNumber(),
					(*next)->GetColumnNumber(),
					(const char *)nextName);
				retVal = FALSE;
		}
	}
	return retVal;
}

BOOL SIMCParser::IsReservedModuleV1(const char * const name)
{

	if(	strcmp(name, "RFC1155-SMI")	== 0 ||
		strcmp(name, "RFC1213-MIB") == 0 ||
		strcmp(name, "RFC-1212")	== 0 ||
		strcmp(name, "RFC-1215")	== 0 ||
		strcmp(name, "RFC1230-MIB") == 0 ||
		strcmp(name, "BUILTIN")		== 0 )

		return TRUE;
	else
		return FALSE;
}

BOOL SIMCParser::IsReservedModuleV2(const char * const name)
{

	if(	strcmp(name, "SNMPv2-SMI")	== 0 ||
		strcmp(name, "SNMPv2-CONF") == 0 ||
		strcmp(name, "SNMPv2-TC")	== 0 ||
		strcmp(name, "SNMPv2-TM")	== 0 ||
		strcmp(name, "BUILTIN")		== 0 )

		return TRUE;
	else
		return FALSE;
}

const SIMCModule* SIMCParser::IsReservedSymbolV1(const char * const name)
{
	if(	strcmp(name, "internet")		== 0 ||
		strcmp(name, "directory")		== 0 ||
		strcmp(name, "mgmt")			== 0 ||
		strcmp(name, "experimental")	== 0 ||
		strcmp(name, "private")			== 0 ||
		strcmp(name, "enterprises")		== 0 ||
		strcmp(name, "NetworkAddress")	== 0 ||
		strcmp(name, "IpAddress")		== 0 ||
		strcmp(name, "Counter")			== 0 ||
		strcmp(name, "Gauge")			== 0 ||
		strcmp(name, "TimeTicks")		== 0 ||
		strcmp(name, "Opaque")			== 0 )
	
		return rfc1155;	
	else if (	strcmp(name, "mib-2")			== 0 ||
				strcmp(name, "ip")				== 0 ||
				strcmp(name, "interfaces")		== 0 ||
				strcmp(name, "transmission")	== 0 ||
				strcmp(name, "DisplayString")	== 0 ||
				strcmp(name, "PhysAddress")		== 0 )
	
		return rfc1213;	
	else if (	strcmp(name, "OBJECT-TYPE")		== 0 )
	
		return rfc1212;	
	else if (	strcmp(name, "TRAP-TYPE")		== 0 )
	
		return rfc1215;	
	else if (	strcmp(name, "MacAddress")	== 0 )
	
		return rfc1230;	
	else
		return NULL;

}

const SIMCModule* SIMCParser::IsReservedSymbolV2(const char * const name)
{
	if(	strcmp(name, "zeroDotZero")		== 0 ||
		strcmp(name, "org")				== 0 ||
		strcmp(name, "dod")				== 0 ||
		strcmp(name, "internet")		== 0 ||
		strcmp(name, "directory")		== 0 ||
		strcmp(name, "mgmt")			== 0 ||
		strcmp(name, "mib-2")			== 0 ||
		strcmp(name, "transmission")	== 0 ||
		strcmp(name, "experimental")	== 0 ||
		strcmp(name, "private")			== 0 ||
		strcmp(name, "enterprises")		== 0 ||
		strcmp(name, "security")		== 0 ||
		strcmp(name, "snmpV2")			== 0 ||
		strcmp(name, "snmpDomains")		== 0 ||
		strcmp(name, "snmpProxys")		== 0 ||
		strcmp(name, "snmpModules")		== 0 ||
		strcmp(name, "Integer32")		== 0 ||
		strcmp(name, "IpAddress")		== 0 ||
		strcmp(name, "Counter32")		== 0 ||
		strcmp(name, "TimeTicks")		== 0 ||
		strcmp(name, "Unsigned32")		== 0 ||
		strcmp(name, "Counter64")		== 0 ||
		strcmp(name, "Gauge32")			== 0 ||
		strcmp(name, "Opaque")			== 0 ||
		strcmp(name, "MODULE-IDENTITY")	== 0 ||
		strcmp(name, "OBJECT-IDENTITY")	== 0 ||
		strcmp(name, "OBJECT-TYPE")		== 0 ||
		strcmp(name, "NOTIFICATION-TYPE")== 0)
	
		return rfc1902;
	
	else if (	strcmp(name, "DisplayString")		== 0 ||
				strcmp(name, "PhysAddress"		)	== 0 ||
				strcmp(name, "MacAddress")			== 0 ||
				strcmp(name, "TruthValue")			== 0 ||
				strcmp(name, "TestAndIncr")			== 0 ||
				strcmp(name, "AutonomousType")		== 0 ||
				strcmp(name, "InstancePointer")		== 0 ||
				strcmp(name, "VariablePointer")		== 0 ||
				strcmp(name, "RowPointer"		)	== 0 ||
				strcmp(name, "RowStatus")			== 0 ||
				strcmp(name, "TimeStamp"		)	== 0 ||
				strcmp(name, "TimeInterval")		== 0 ||
				strcmp(name, "DateAndTime")			== 0 ||
				strcmp(name, "StorageType")			== 0 ||
				strcmp(name, "TDomain")				== 0 ||
				strcmp(name, "TAddress")			== 0 )
	
		return rfc1903;	

	else if (	strcmp(name, "OBJECT-GROUP")		== 0 ||
				strcmp(name, "NOTIFICATION-GROUP")	== 0 ||
				strcmp(name, "MODULE-COMPLIANCE")	== 0 ||
				strcmp(name, "AGENT-CAPABILITIES")	== 0 )
	
		return rfc1904;	
	
	else if (	strcmp(name, "snmpUDPDomain")		== 0 ||
				strcmp(name, "SnmpUDPAddress")		== 0 ||
				strcmp(name, "snmpCLNSDomain")		== 0 ||
				strcmp(name, "snmpCONSDomain")		== 0 ||
				strcmp(name, "SnmpOSIAddress")		== 0 ||
				strcmp(name, "snmpDDPDomain")		== 0 ||
				strcmp(name, "SnmpNBPAddress")		== 0 ||
				strcmp(name, "snmpIPXDomain")		== 0 ||
				strcmp(name, "SnmpIPXAddress")		== 0 ||
				strcmp(name, "rfc1157Proxy")		== 0 ||
				strcmp(name, "rfc1157Domain")		== 0 )
		return rfc1906;	
	
	else
		return NULL;

}

BOOL  SIMCParser::IsReservedSymbolV1(const char * const name, 
	const char * const moduleName)
{
	if(	strcmp(name, "internet")		== 0 ||
		strcmp(name, "directory")		== 0 ||
		strcmp(name, "mgmt")			== 0 ||
		strcmp(name, "experimental")	== 0 ||
		strcmp(name, "private")			== 0 ||
		strcmp(name, "enterprises")		== 0 ||
		strcmp(name, "NetworkAddress")	== 0 ||
		strcmp(name, "IpAddress")		== 0 ||
		strcmp(name, "Counter")			== 0 ||
		strcmp(name, "Gauge")			== 0 ||
		strcmp(name, "TimeTicks")		== 0 ||
		strcmp(name, "Opaque")			== 0 )
	{
		if(strcmp(moduleName, "RFC1155-SMI") == 0 )
			return TRUE;
		else
			return FALSE;
	}
	else if (	strcmp(name, "mib-2")			== 0 ||
				strcmp(name, "ip")				== 0 ||
				strcmp(name, "interfaces")		== 0 ||
				strcmp(name, "transmission")	== 0 ||
				strcmp(name, "DisplayString")	== 0 ||
				strcmp(name, "PhysAddress")		== 0 )
	{
		if(		strcmp(moduleName, "RFC1213-MIB") == 0 )
			return TRUE;
		else
			return FALSE;
	}
	else if (	strcmp(name, "OBJECT-TYPE")		== 0 )
	{
		if(strcmp(moduleName, "RFC-1212") == 0 )
			return TRUE;
		else
			return FALSE;
	}
	else if (	strcmp(name, "TRAP-TYPE")		== 0 )
	{
		if(strcmp(moduleName, "RFC-1215") == 0 )
			return TRUE;
		else
			return FALSE;
	}
	else if (		strcmp(name, "MacAddress")	== 0 )
	{
		if(strcmp(moduleName, "RFC1230-MIB") == 0 )
			return TRUE;
		else
			return FALSE;
	}
	return FALSE;
}

BOOL  SIMCParser::IsReservedSymbolV2(const char * const name, 
	const char * const moduleName)
{
	if(	strcmp(name, "zeroDotZero")		== 0 ||
		strcmp(name, "org")				== 0 ||
		strcmp(name, "dod")				== 0 ||
		strcmp(name, "internet")		== 0 ||
		strcmp(name, "directory")		== 0 ||
		strcmp(name, "mgmt")			== 0 ||
		strcmp(name, "mib-2")			== 0 ||
		strcmp(name, "transmission")	== 0 ||
		strcmp(name, "experimental")	== 0 ||
		strcmp(name, "private")			== 0 ||
		strcmp(name, "enterprises")		== 0 ||
		strcmp(name, "security")		== 0 ||
		strcmp(name, "snmpV2")			== 0 ||
		strcmp(name, "snmpDomains")		== 0 ||
		strcmp(name, "snmpProxys")		== 0 ||
		strcmp(name, "snmpModules")		== 0 ||
		strcmp(name, "Integer32")		== 0 ||
		strcmp(name, "IpAddress")		== 0 ||
		strcmp(name, "Counter32")		== 0 ||
		strcmp(name, "TimeTicks")		== 0 ||
		strcmp(name, "Unsigned32")		== 0 ||
		strcmp(name, "Counter64")		== 0 ||
		strcmp(name, "Gauge32")			== 0 ||
		strcmp(name, "Opaque")			== 0 ||
		strcmp(name, "MODULE-IDENTITY")	== 0 ||
		strcmp(name, "OBJECT-IDENTITY")	== 0 ||
		strcmp(name, "OBJECT-TYPE")		== 0 ||
		strcmp(name, "NOTIFICATION-TYPE")== 0)
	
	{
		if( strcmp(moduleName, "SNMPv2-SMI") == 0)
			return TRUE;
		else
			return FALSE;
	}
	
	else if (	strcmp(name, "DisplayString")		== 0 ||
				strcmp(name, "PhysAddress"		)	== 0 ||
				strcmp(name, "MacAddress")			== 0 ||
				strcmp(name, "TruthValue")			== 0 ||
				strcmp(name, "TestAndIncr")			== 0 ||
				strcmp(name, "AutonomousType")		== 0 ||
				strcmp(name, "InstancePointer")		== 0 ||
				strcmp(name, "VariablePointer")		== 0 ||
				strcmp(name, "RowPointer"		)	== 0 ||
				strcmp(name, "RowStatus")			== 0 ||
				strcmp(name, "TimeStamp"		)	== 0 ||
				strcmp(name, "TimeInterval")		== 0 ||
				strcmp(name, "DateAndTime")			== 0 ||
				strcmp(name, "StorageType")			== 0 ||
				strcmp(name, "TDomain")				== 0 ||
				strcmp(name, "TAddress")			== 0 )
	
	{
		if( strcmp(moduleName, "SNMPv2-TC") == 0)
			return TRUE;
		else
			return FALSE;
	}

	else if (	strcmp(name, "OBJECT-GROUP")		== 0 ||
				strcmp(name, "NOTIFICATION-GROUP")	== 0 ||
				strcmp(name, "MODULE-COMPLIANCE")	== 0 ||
				strcmp(name, "AGENT-CAPABILITIES")	== 0 )
	
	{
		if( strcmp(moduleName, "SNMPv2-CONF") == 0)
			return TRUE;
		else
			return FALSE;
	}

	else if (	strcmp(name, "snmpUDPDomain")		== 0 ||
				strcmp(name, "SnmpUDPAddress")		== 0 ||
				strcmp(name, "snmpCLNSDomain")		== 0 ||
				strcmp(name, "snmpCONSDomain")		== 0 ||
				strcmp(name, "SnmpOSIAddress")		== 0 ||
				strcmp(name, "snmpDDPDomain")		== 0 ||
				strcmp(name, "SnmpNBPAddress")		== 0 ||
				strcmp(name, "snmpIPXDomain")		== 0 ||
				strcmp(name, "SnmpIPXAddress")		== 0 ||
				strcmp(name, "rfc1157Proxy")		== 0 ||
				strcmp(name, "rfc1157Domain")		== 0 )
	{
		if( strcmp(moduleName, "SNMPv2-TM") == 0)
			return TRUE;
		else
			return FALSE;
	}
	return FALSE;

}

BOOL SIMCParser::IsReservedSymbol(long snmpVersion, const char *const name,
				const char * const moduleName)
{
	switch(snmpVersion)
	{
		case 1:
			return IsReservedSymbolV1(name, moduleName);
		case 2:
			return IsReservedSymbolV2(name, moduleName);
		default:
			return IsReservedSymbolV1(name, moduleName) ||
				IsReservedSymbolV2(name, moduleName);
	}
}

BOOL SIMCParser::IsReservedModule(long snmpVersion, const char *const name)
{
	switch(snmpVersion)
	{
		case 1:
			return IsReservedModuleV1(name);
		case 2:
			return IsReservedModuleV2(name);
		default:
			return IsReservedModuleV1(name) ||
				IsReservedModuleV2(name);
	}
}

const SIMCModule* SIMCParser::IsReservedSymbol(const char * const symbolName)
{
	const SIMCModule *retVal;
	switch(_snmpVersion)
	{
		case 1:
			return IsReservedSymbolV1(symbolName);
		case 2:
			return IsReservedSymbolV2(symbolName);
		default:
			return (retVal = IsReservedSymbolV2(symbolName))? retVal : IsReservedSymbolV1(symbolName);
	}
}

BOOL SIMCParser::IsReservedSymbol(const char *const name, const char * const moduleName)
{
	return IsReservedSymbol(_snmpVersion, name, moduleName);
}

const char * SIMCParser::GetCorrectModuleNames(const char * const name)
{

	if(	strcmp(name, "internet")		== 0 ||
		strcmp(name, "directory")		== 0 ||
		strcmp(name, "mgmt")			== 0 ||
		strcmp(name, "experimental")	== 0 ||
		strcmp(name, "private")			== 0 ||
		strcmp(name, "enterprises")		== 0 ||
		strcmp(name, "IpAddress")		== 0 ||
		strcmp(name, "TimeTicks")		== 0 ||
		strcmp(name, "Opaque")			== 0 )
	{
		return "RFC1155-SMI\" or \"SNMPv2-SMI";
	}

	else if(strcmp(name, "NetworkAddress")	== 0 ||
			strcmp(name, "Counter")			== 0 ||
			strcmp(name, "Gauge")			== 0 )
		return "RFC1155-SMI";
	
	else if (strcmp(name, "mib-2")			== 0 ||
			strcmp(name, "transmission")	== 0 )
		return "RFC1213-MIB\" or \"SNMPv2-SMI";
	
	else if	(strcmp(name, "ip")				== 0 ||
			strcmp(name, "interfaces")		== 0 )
		return "RFC1213-MIB";

	else if (strcmp(name, "DisplayString")	== 0 ||
			strcmp(name, "PhysAddress")		== 0 )
		return "RFC1213-MIB\" or \"SNMPv2-TC";
	
	else if (	strcmp(name, "OBJECT-TYPE")		== 0 )
		return "RFC-1212 or SNMPv2-SMI";

	else if (	strcmp(name, "TRAP-TYPE")		== 0 )
		return "RFC-1215";

	else if (strcmp(name, "MacAddress")	== 0 )
		return "RFC1230-MIB\" or \"SNMPv2-TC";

	else if(	strcmp(name, "zeroDotZero")		== 0 ||
		strcmp(name, "org")				== 0 ||
		strcmp(name, "dod")				== 0 ||
		strcmp(name, "security")		== 0 ||
		strcmp(name, "snmpV2")			== 0 ||
		strcmp(name, "snmpDomains")		== 0 ||
		strcmp(name, "snmpProxys")		== 0 ||
		strcmp(name, "snmpModules")		== 0 ||
		strcmp(name, "Integer32")		== 0 ||
		strcmp(name, "Counter32")		== 0 ||
		strcmp(name, "Unsigned32")		== 0 ||
		strcmp(name, "Counter64")		== 0 ||
		strcmp(name, "Gauge32")			== 0 ||
		strcmp(name, "MODULE-IDENTITY")	== 0 ||
		strcmp(name, "OBJECT-IDENTITY")	== 0 ||
		strcmp(name, "NOTIFICATION-TYPE")== 0)
		return "SNMPv2-SMI";
	
	else if (	strcmp(name, "TruthValue")			== 0 ||
				strcmp(name, "TestAndIncr")			== 0 ||
				strcmp(name, "AutonomousType")		== 0 ||
				strcmp(name, "InstancePointer")		== 0 ||
				strcmp(name, "VariablePointer")		== 0 ||
				strcmp(name, "RowPointer"		)	== 0 ||
				strcmp(name, "RowStatus")			== 0 ||
				strcmp(name, "TimeStamp"		)	== 0 ||
				strcmp(name, "TimeInterval")		== 0 ||
				strcmp(name, "DateAndTime")			== 0 ||
				strcmp(name, "StorageType")			== 0 ||
				strcmp(name, "TDomain")				== 0 ||
				strcmp(name, "TAddress")			== 0 )
		return "SNMPv2-TC";

	else if (	strcmp(name, "OBJECT-GROUP")		== 0 ||
				strcmp(name, "NOTIFICATION-GROUP")	== 0 ||
				strcmp(name, "MODULE-COMPLIANCE")	== 0 ||
				strcmp(name, "AGENT-CAPABILITIES")	== 0 )
		return "SNMPv2-CONF";

	else if (	strcmp(name, "snmpUDPDomain")		== 0 ||
				strcmp(name, "SnmpUDPAddress")		== 0 ||
				strcmp(name, "snmpCLNSDomain")		== 0 ||
				strcmp(name, "snmpCONSDomain")		== 0 ||
				strcmp(name, "SnmpOSIAddress")		== 0 ||
				strcmp(name, "snmpDDPDomain")		== 0 ||
				strcmp(name, "SnmpNBPAddress")		== 0 ||
				strcmp(name, "snmpIPXDomain")		== 0 ||
				strcmp(name, "SnmpIPXAddress")		== 0 ||
				strcmp(name, "rfc1157Proxy")		== 0 ||
				strcmp(name, "rfc1157Domain")		== 0 )
		return "SNMPv2-TM";

	return NULL;
}

void SIMCParser::DoImportModule( SIMCModule *mainModule, SIMCModule *importModule)
{
	SIMCSymbolTable *importTable = importModule->GetSymbolTable();
	const char * const importModuleName = importModule->GetModuleName();
	POSITION p = importTable->GetStartPosition();
	SIMCSymbol **s;
	CString n;
	
	if(IsReservedModule(_snmpVersion, importModuleName))	 // For well known import modules
	{
		SIMCModule *wellKnownModule = mainModule->GetImportModule(importModuleName);
		// Remove all "known" symbols from the symbol table of the import table
		while(p)
		{
			importTable->GetNextAssoc(p, n, s);
			// The symbol is either well-known (reserved) or not
			if(IsReservedSymbol(_snmpVersion, n, importModuleName))
			{
				// Just delete the whole thing
				importTable->RemoveKey(n);
				delete *s;
				delete s;
			}
			else
			{
				wellKnownModule->AddSymbol(*s);
				importTable->RemoveKey(n);
				delete s;
			}
		}
		wellKnownModule->SetInputFileName(importModule->GetInputFileName());
		wellKnownModule->SetLineNumber(importModule->GetLineNumber());
		wellKnownModule->SetColumnNumber(importModule->GetLineNumber());
		delete importModule;
	}
	else // Not a well-known module
	{
		// Go ahead and add the whole module to the imports list
		mainModule->AddImportModule(importModule);
		// And provide a warning for well-known symbol
		while(p)
		{
			importTable->GetNextAssoc(p, n, s);
			// The symbol is either well-known (reserved) or not
			if(IsReservedSymbol(n))
			{
				SemanticError(mainModule->GetInputFileName(),
					IMPORT_KNOWN_WRONG_MODULE,
					(*s)->GetLineNumber(),
					(*s)->GetColumnNumber(),
					n,
					GetCorrectModuleNames(n));
			}
		}
	}

}


void SIMCParser::RemoveExtraneousReservedModule(SIMCModule *importModule)
{
	SIMCSymbolTable *importTable = importModule->GetSymbolTable();

	SIMCSymbol **s;
	CString n;
	POSITION p = importTable->GetStartPosition();
	while(p)
	{
		importTable->GetNextAssoc(p, n, s);
		if( (*s)->GetReferenceCount() )
			return;
	}
	 _module->RemoveImportModule(importModule);
	 delete importModule;
}

BOOL SIMCParser::Parse()
{
	if( syntaxErrorsDll == NULL)
	{
		cerr << "Parse(): FATAL ERROR smierrsy.dll not found" <<
			endl;
		return FALSE;
	}
 	if( semanticErrorsDll == NULL)
	{
		cerr << "Parse(): FATAL ERROR smierrsm.dll not found" <<
			endl;
		return FALSE;
	}

	_fatalCount = _warningCount = _informationCount = 0;

	_module = new SIMCModule;
	_module->SetInputFileName(_theScanner->GetInputStreamName());
	if(!_module->SetSnmpVersion(_snmpVersion))
		return FALSE;

	// Create and add the well-known modules
	CreateReservedModules();
	if(_snmpVersion != 2 )
	{
		_module->AddImportModule(rfc1155);
		_module->AddImportModule(rfc1213);
		_module->AddImportModule(rfc1212);
		_module->AddImportModule(rfc1215);
		_module->AddImportModule(rfc1230);
	}
	if(_snmpVersion != 1 )
	{
		_module->AddImportModule(rfc1902);
		_module->AddImportModule(rfc1903);
		_module->AddImportModule(rfc1904);
		_module->AddImportModule(rfc1906);
	}

	_module->AddImportModule(other);

	//yydebug = 1;
	int parseRetVal = yyparse(_theScanner);

	if(_snmpVersion == 2 && !_module->GetModuleIdentityName())
	{
		SemanticError(_module->GetInputFileName(),
			MODULE_IDENTITY_MISSING,
			_module->GetLineNumber(), _module->GetColumnNumber());
		parseRetVal = 1;
	}

	// Clean up
	if(!SetImportSymbols())
		parseRetVal = 1;

	if(_snmpVersion != 2 )
	{
		RemoveExtraneousReservedModule(rfc1155);
		RemoveExtraneousReservedModule(rfc1213);
		RemoveExtraneousReservedModule(rfc1212);
		RemoveExtraneousReservedModule(rfc1215);
		RemoveExtraneousReservedModule(rfc1230);
	}
	if(_snmpVersion != 1 )
	{
		RemoveExtraneousReservedModule(rfc1902);
		RemoveExtraneousReservedModule(rfc1903);
		RemoveExtraneousReservedModule(rfc1904);
		RemoveExtraneousReservedModule(rfc1906);
	}

	RemoveExtraneousReservedModule(other);

	if(_fatalCount == 0   && parseRetVal == 0)
		return TRUE;

	delete _module;
	_module = NULL;
	return FALSE;
}	

void SIMCParser::SemanticError(const char * const inputStreamName,
								int errorType, int lineNo,
								int columnNo, ...)
{
	va_list argList;
	va_start(argList, columnNo);
	SIMCErrorMessage e;
	e.SetInputStreamName(inputStreamName);
	e.SetLineNumber(lineNo);
 	e.SetColumnNumber(columnNo);
	e.SetErrorId(SEMANTIC_ERROR_BASE + errorType);

	char message[MESSAGE_SIZE];
	char errorText[MESSAGE_SIZE];
	const char *temp1, *temp2, *temp3, *temp4;

	if(!LoadString(semanticErrorsDll, errorType, errorText, MESSAGE_SIZE))
		cerr << "SIMCParser::SemanticError(): Panic, unable to load error "
		<< "string" << endl;
	switch(errorType)
	{
		case OBJ_TYPE_SINGULAR_COUNTER:
		case OBJ_TYPE_INDEX_UNNECESSARY:
		case ZERO_IN_OID:
		case IMPORT_UNUSED:
		case ENUM_ZERO_VALUE:
		case KNOWN_REDEFINITION:
		case KNOWN_UNDEFINED:
		case TYPE_UNREFERENCED:
		case VALUE_UNREFERENCED:
		case OBJ_TYPE_DEFVAL_NET_ADDR:
		case OBJ_TYPE_ACCESSIBLE_TABLE:
		case OBJ_TYPE_ACCESSIBLE_ROW:
		case IMPORT_KNOWN_WRONG_MODULE:
		case IR_MODULE_MISSING_WARNING:
		case IR_SYMBOL_MISSING_WARNING:
		case STANDARD_AMBIGUOUS_REFERENCE:
		case MODULE_NO_GROUPS_V1:
		case MODULE_NO_GROUPS_V2:
		case IMPLIED_USELESS:
		case OBJ_TYPE_DUPLICATE_OID: 			
		{
				e.SetSeverityLevel(WARNING);
				e.SetSeverityString("Warning");
				_warningCount++;
		}
		break;
		default:
		{
			e.SetSeverityLevel(FATAL);
			e.SetSeverityString("Fatal");
			_fatalCount++;
		}
		break;
	}

	switch(errorType)
	{
		case OBJ_TYPE_INDEX_UNNECESSARY: 
		case OBJ_TYPE_INVALID_DEFVAL: 
		case OBJ_TYPE_SYNTAX_RESOLUTION:
		case OBJ_TYPE_ACCESSIBLE_TABLE: 
		case OBJ_TYPE_ACCESSIBLE_ROW:
		case OBJ_TYPE_DEFVAL_NET_ADDR:
		case OBJ_TYPE_DEFVAL_DISALLOWED:
		case OBJ_TYPE_DEFVAL_RESOLUTION:
		case ZERO_IN_OID:
		case OID_NEGATIVE_INTEGER: 
		case ENUM_ZERO_VALUE: 
		case SIZE_INVALID_VALUE: 
		case SIZE_INVALID_BOUNDS:
		case RANGE_INVALID_BOUNDS:
		case RANGE_NEGATIVE_GAUGE:
		case SUBTYPE_ROOT_RESOLUTION:
		case INTEGER_TOO_BIG:
		case VALUE_ASSIGN_ENUM_INVALID:
		case MODULE_IDENTITY_MISSING:
			sprintf(message, errorText);
			break;
		case OBJ_TYPE_SINGULAR_COUNTER: 
		case OBJ_TYPE_INVALID_ACCESS: 
		case OBJ_TYPE_INVALID_STATUS: 
		case OBJ_TYPE_SEQUENCE_NO_INDEX: 
		case OBJ_TYPE_SEQUENCE_MULTI_REFERENCE: 
		case OBJ_TYPE_SEQUENCE_UNUSED: 
		case OBJ_TYPE_INDEX_RESOLUTION:
		case OBJ_TYPE_INDEX_SYNTAX:
		case SEQUENCE_ITEM_NO_OBJECT:
		case SEQUENCE_TYPE_UNRESOLVED:
		case INVALID_SEQUENCE_OF: 
		case TRAP_TYPE_ENTERPRISE_RESOLUTION: 
		case TRAP_TYPE_VALUE_RESOLUTION: 
		case TRAP_TYPE_VARIABLES_RESOLUTION: 
		case OID_RESOLUTION: 
		case OID_HEAD_ERROR: 
		case IMPORT_UNUSED: 
		case IMPORT_MODULE_ABSENT: 
		case IMPORT_CURRENT: 
		case ENUM_DUPLICATE_VALUE: 
		case ENUM_DUPLICATE_NAME: 
		case ENUM_RESOLUTION: 
		case SIZE_TYPE_RESOLUTION: 
		case RANGE_TYPE_RESOLUTION: 
		case SIZE_VALUE_RESOLUTION: 
		case RANGE_VALUE_RESOLUTION: 
		case SYMBOL_REDEFINITION: 
		case KNOWN_UNDEFINED: 
		case TYPE_UNREFERENCED: 
		case VALUE_UNREFERENCED: 
		case VALUE_ASSIGN_MISMATCH:
		case VALUE_ASSIGN_INVALID:
		case VALUE_ASSIGN_NEGATIVE_INTEGER:
		case SYMBOL_UNDEFINED: 
		case IMPORT_AMBIGUOUS_REFERENCE:
		case TYPE_UNRESOLVED:
		case VALUE_UNRESOLVED:
		case OBJ_TYPE_SEQUENCE_NO_PARENT:
		case TC_INVALID_STATUS:
		case NOTIFICATION_TYPE_INVALID_STATUS: 
			temp1 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1);
			break;
		case OBJ_TYPE_SEQUENCE_INVALID_SYNTAX: 
		case OBJ_TYPE_OID_RESOLUTION:
		case TRAP_TYPE_DUPLICATE_VALUES: 
		case VALUE_ASSIGN_RESOLUTION: 
		case IMPORT_SYMBOL_ABSENT: 
		case IMPORT_KNOWN_WRONG_MODULE: 
		case KNOWN_REDEFINITION:
		case IR_SYMBOL_MISSING_WARNING:
		case IR_SYMBOL_MISSING_FATAL:
		case STANDARD_AMBIGUOUS_REFERENCE:
		case IR_MODULE_MISSING_FATAL:
		case IR_MODULE_MISSING_WARNING:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1, temp2);
			break;
		case SEQUENCE_WRONG_CHILD:
		case OBJ_TYPE_PRIMITIVE_CHILD:
		case OBJ_TYPE_SEQUENCE_CHILD:
		case OBJ_TYPE_SEQUENCE_EXTRA_CHILD:
		case OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD:
		case OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH:
		case OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			temp3 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1, temp2, temp3);
			break;
		case OBJ_TYPE_DUPLICATE_OID: 			
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			temp3 = va_arg(argList, const char *);
			temp4 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1, temp2, temp3, temp4);
			break;
	}
	va_end(argList);

	e.SetMessage(message);
	if( _errorContainer  != NULL)
		_errorContainer->InsertMessage(e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\registry.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
/****************************************************************************
* This file contains the implementation of the SIMCRegistryCOntroller class
* which has functions that manipulate the information maintained
* in the registry by the mib compiler
*
*/


#include <stdio.h>

#include <iostream.h>
#include <strstrea.h>
#include <limits.h>

#include "precomp.h"
#include <snmptempl.h>

#include <winbase.h>
#include <winreg.h>

#include "infoLex.hpp"
#include "infoYacc.hpp"
#include "moduleInfo.hpp"
#include "ui.hpp"
#include "registry.hpp"

// Iniialize the static members of the class
const char * SIMCRegistryController::rootKeyName =
	"SOFTWARE\\Microsoft\\WBEM\\Providers\\SNMP\\Compiler";
const char * SIMCRegistryController::filePaths = "File Path";
const char *SIMCRegistryController::fileSuffixes = "File Suffixes";
const char *SIMCRegistryController::mibTable =
	"SOFTWARE\\Microsoft\\WBEM\\Providers\\SNMP\\Compiler\\MIB";


/* This returns the path to the MIB file that has the specified module name */
BOOL SIMCRegistryController::GetMibFileFromRegistry(const char * const moduleName, CString& retValue)
{
	HKEY mibTableKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					mibTable,
					0,
					KEY_READ,
					&mibTableKey) != ERROR_SUCCESS)
		return FALSE;

	unsigned long dwIndex = 0;
	char lpData[BUFSIZ];
	unsigned long  dataSize = BUFSIZ, lpType;

	if(RegQueryValueEx(mibTableKey,
		moduleName,	
		0,	 
		&lpType,	 
		(unsigned char *)lpData,	
		&dataSize) == ERROR_SUCCESS)
	{
		retValue = lpData;
		RegCloseKey(mibTableKey);
		return TRUE;
	}
	else 
	{
		RegCloseKey(mibTableKey);
		return FALSE;
	}
}


/* This dumps the contents of the MIB table to the standard output */
BOOL SIMCRegistryController::ListMibTable()
{
	HKEY mibTableKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					mibTable,
					0,
					KEY_READ,
					&mibTableKey) != ERROR_SUCCESS)
		return FALSE;

	unsigned long dwIndex = 0;
	char lpValueName[BUFSIZ], lpData[BUFSIZ];
	unsigned long  valueSize = BUFSIZ, dataSize = BUFSIZ, lpType;

	while( RegEnumValue(mibTableKey,	
				dwIndex ++,
				lpValueName,
				&valueSize,
				0,
				&lpType,
				(unsigned char *)lpData,
				&dataSize) == ERROR_SUCCESS )
		cout << lpValueName << ": " << lpData << endl;

	RegCloseKey(mibTableKey);
	return TRUE;

}

/* This returns the list of file suffixes in the registry that are possible
* for MIB files */
BOOL SIMCRegistryController::GetMibSuffixes(SIMCStringList & theList)
{
	HKEY rootKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					rootKeyName,
					0,
					KEY_READ,
					&rootKey) != ERROR_SUCCESS)
		return FALSE;

	unsigned long dwIndex = 0;
	char lpData[BUFSIZ];
	unsigned long  dataSize = BUFSIZ, lpType;

	if(RegQueryValueEx(rootKey,
		fileSuffixes,	
		0,	 
		&lpType,	 
		(unsigned char *)lpData,	
		&dataSize) == ERROR_SUCCESS)
	// Break the char string into a list of CStrings
	{
		unsigned long start = 0;
		while(start < dataSize-1)
		{
			theList.AddHead(CString(lpData + start));
			start += strlen(lpData + start);
			start++;
		}
		RegCloseKey(rootKey);
		return TRUE;
	}
	else 
	{
		RegCloseKey(rootKey);
		return FALSE;
	}
}


/* This returns the list of directories in the registry that are possible
* locations for MIB files */
BOOL SIMCRegistryController::GetMibPaths(SIMCStringList & theList)
{
	HKEY rootKey;
	if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					rootKeyName,
					0,
					KEY_READ,
					&rootKey) != ERROR_SUCCESS)
		return FALSE;

	unsigned long dwIndex = 0;
	char *lpData = NULL ;
	unsigned long  dataSize = 0, lpType;

	if(RegQueryValueEx(rootKey,
		filePaths,	
		0,	 
		&lpType,	 
		NULL,	
		&dataSize) == ERROR_SUCCESS)
	{
		if(lpData = new char[dataSize + 1])
		{
			if(RegQueryValueEx(rootKey,
				filePaths,	
				0,	 
				&lpType,	 
				(unsigned char *)lpData,	
				&dataSize) == ERROR_SUCCESS)
			// Break the char string into a list of CStrings
			{
				unsigned long start = 0;
				CString nextPath;
				if(dataSize != 0 ) 
				{
					while(start < dataSize-1)
					{
						nextPath = lpData + start;
						if(IsAbsolutePath(nextPath))
							theList.AddHead(nextPath);
						start += nextPath.GetLength();
						start++;
					}
				}
				RegCloseKey(rootKey);
				return TRUE;
			}
			delete [] lpData;
		}
	}
	else
	{
		RegCloseKey(rootKey);
		return FALSE;
	}
	return FALSE;
}

/* This deletes the entire MIB lookup table from the registry */
BOOL SIMCRegistryController::DeleteMibTable()
{
	// Delete the MIB key, thereby removing all its values.
	// And then create the key again.

	HKEY temp1;
	if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				mibTable,
				0,
				KEY_ALL_ACCESS,
				&temp1) == ERROR_SUCCESS)
	{
		RegCloseKey(temp1);
		if(RegDeleteKey(HKEY_LOCAL_MACHINE, mibTable) 
			!= ERROR_SUCCESS)
			return FALSE;
	}

	unsigned long temp2;
	if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		mibTable, 0, "REG_MULTI_SZ", REG_OPTION_NON_VOLATILE,	KEY_ALL_ACCESS,
		NULL, &temp1, &temp2) != ERROR_SUCCESS)
		return FALSE;

	RegCloseKey(temp1);

	return TRUE;
}


long SIMCRegistryController::GetFileMap(SIMCFileMapList& theList)
{
	SIMCStringList pathList;
	SIMCStringList suffixList;

	if(!GetMibPaths(pathList))
		return 0;

	if(!GetMibSuffixes(suffixList))
		return 0;

	POSITION p = pathList.GetHeadPosition();
	CString nextPath;
	long totalEntries = 0;
	while(p)
	{
		nextPath = pathList.GetNext(p);
		totalEntries += RebuildDirectory(nextPath, suffixList, theList);
	}

	return totalEntries;
}

// Deletes the lookup table and rebuilds it.
long SIMCRegistryController::RebuildMibTable()
{
	if(!DeleteMibTable())
		return 0;

	// DeleteMibTable() guarantees that the key exists. Just open it.
	HKEY mibTableKey;
	if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				mibTable,
				0,
				KEY_ALL_ACCESS,
				&mibTableKey) != ERROR_SUCCESS)
		return 0;

	SIMCFileMapList theList;
	GetFileMap(theList);
	POSITION p = theList.GetHeadPosition();
	SIMCFileMapElement nextElement;
	while(p)
	{
		nextElement = theList.GetNext(p);
		if(RegSetValueEx(mibTableKey, 
				nextElement.moduleName,
				NULL,REG_SZ, (unsigned char *)(const char * )nextElement.fileName,
				nextElement.fileName.GetLength()+1) 
				!= ERROR_SUCCESS)
			return 0;
	}
	return theList.GetCount();
}


BOOL SIMCRegistryController::IsAbsolutePath(CString pathName)
{
	if(pathName[1] == ':' && pathName[2] == '\\')
		return TRUE;
	return FALSE;
}

/* THis adds the MIB files in a specific drectory to the lookup table */
long SIMCRegistryController::RebuildDirectory(const CString& directory, 
											  const SIMCStringList& suffixList,
											  SIMCFileMapList &theList)
{

	// Save the current directory of the process
	char savedDirectory[BUFSIZ];
	long directoryLength = BUFSIZ;
	if(!GetCurrentDirectory(directoryLength, savedDirectory))
		return 0;

	// Cheange to the specified directory
	if(!SetCurrentDirectory(directory))
		return 0;

	// For all the suffixes
	POSITION p = suffixList.GetHeadPosition();
	long totalEntries = 0;
	CString regExp;
	char fullPathName[BUFSIZ], *dummy;
	long fullSize = BUFSIZ;
	HANDLE fp;
	WIN32_FIND_DATA fileData;
	while(p)
	{
		regExp = "*.";
		regExp += suffixList.GetNext(p);
		// For all the files in this directory, that match the suffix
		if( (fp = FindFirstFile(regExp, &fileData)) == INVALID_HANDLE_VALUE)
			continue;

		// Get the full path name of the file
		if(GetFullPathName(fileData.cFileName, fullSize, fullPathName, &dummy))		
		{
			if(ProcessFile(fullPathName, theList)) 
				totalEntries++;
		}

		while(FindNextFile(fp, &fileData))
		{
			if(GetFullPathName(fileData.cFileName, fullSize = BUFSIZ, fullPathName, &dummy))		
			{
				if(ProcessFile(fullPathName, theList))
					totalEntries++;
			}
		}
		FindClose(fp);
	}

	// Change back to the current directory
	SetCurrentDirectory(savedDirectory);

	return totalEntries;

}

/* This adds a specific MIB file to the lookup table */
BOOL SIMCRegistryController::ProcessFile(const char * const fileName, 
										 SIMCFileMapList &theList)
{
	FILE *fp = fopen(fileName, "r");
	if(fp)
	{
		SIMCModuleInfoScanner smallScanner;
		smallScanner.setinput(fp);
		SIMCModuleInfoParser smallParser;
		if(smallParser.GetModuleInfo(&smallScanner))
		{
			// Add the mapping to the list
			fclose(fp);
			theList.AddTail(SIMCFileMapElement(smallParser.GetModuleName(),
							fileName));
			return TRUE;
		}
		else
		{
			fclose(fp);
			return FALSE;
		}
	}
	return FALSE;
}

BOOL SIMCRegistryController::GetMibFileFromMap(const SIMCFileMapList& theList, 
	const CString& module, 
	CString &file)
{
	POSITION p = theList.GetHeadPosition();
	SIMCFileMapElement nextElement;
	while(p)
	{
		nextElement = theList.GetNext(p);
		if(nextElement.moduleName == module)
		{
			file = nextElement.fileName;
			return TRUE;
		}
	}
	return FALSE;

}

/* Adds the file corresponding to dependentModule to dependencyList, if 
* it isnt already there.*/
BOOL SIMCRegistryController::ShouldAddDependentFile(SIMCFileMapList& dependencyList,
											  const CString& dependentModule,
											  CString& dependentFile,
											  const SIMCFileMapList& priorityList)
{
	if(IsModulePresent(dependencyList, dependentModule))
		return FALSE;

	// First look in the priority list, for the file
	// And then in the registry lookup table
	if(GetMibFileFromMap(priorityList, dependentModule, dependentFile))
	{
		if(IsFilePresent(dependencyList, dependentFile))
			return FALSE;
		else
			return TRUE;
	}

	if(GetMibFileFromRegistry(dependentModule, dependentFile))
	{
		if(IsFilePresent(dependencyList, dependentFile))
			return FALSE;
		else
			return TRUE;
	}

	// The module is neither in the subsidiary files, nor in the
	// include directories, nor in the registry.
	return FALSE;
}

BOOL SIMCRegistryController::GetDependentModules(const char * const fileName,
					SIMCFileMapList& dependencyList,
					const SIMCFileMapList& priorityList)
{
	// All the subsidiary files and files in include directories are assumed
	// to be in priorityList

	FILE * fp = fopen(fileName, "r");
	if(fp)
	{
 		SIMCModuleInfoScanner smallScanner;
		smallScanner.setinput(fp);
		SIMCModuleInfoParser smallParser;
		CString dependentFile, dependentModule;
		if(smallParser.GetModuleInfo(&smallScanner))
		{
			fclose(fp); // Better close it rightnow, because of the recursion below

			// Add the current file to the dependency list
			// dependencyList.AddTail(SIMCFileMapElement(smallParser.GetModuleName(), fileName));

			// Look at the import modules
			const SIMCStringList * importList = smallParser.GetImportModuleList();
			POSITION p = importList->GetHeadPosition();
			while(p)
			{
				dependentModule = importList->GetNext(p);
				if(ShouldAddDependentFile(dependencyList,  dependentModule, dependentFile, priorityList))
				{
					FILE * Innerfp = fopen(dependentFile, "r");
					if(Innerfp)
					{
 						SIMCModuleInfoScanner smallInnerScanner;
						smallInnerScanner.setinput(Innerfp);
						SIMCModuleInfoParser smallInnerParser;
						if(smallInnerParser.GetModuleInfo(&smallInnerScanner))
						{
							fclose(Innerfp); // Better close it rightnow, because of the recursion below

							// Add the current file to the dependency list
							dependencyList.AddTail(SIMCFileMapElement(smallInnerParser.GetModuleName(), dependentFile));
							GetDependentModules(dependentFile, dependencyList, priorityList);
						}
					}
				}
			}
			return TRUE;
		}
		else
		{
			fclose(fp);
			return FALSE;
		}
	}
	else
		return FALSE;
	return FALSE;
}

BOOL SIMCRegistryController::DeleteRegistryDirectory(const CString& directoryName)
{
	// First Get the fully qualified path name from 'directoryName'
	char fullPathName[BUFSIZ], *dummy;
	long fullSize = 0;
	SIMCStringList theList;
	if(GetFullPathName(directoryName, BUFSIZ, fullPathName, &dummy))		
	{
		fullSize = strlen(fullPathName);
		HKEY rootKey;
		if( RegOpenKeyEx(HKEY_LOCAL_MACHINE,
						rootKeyName,
						0,
						KEY_ALL_ACCESS,
						&rootKey) != ERROR_SUCCESS)
			return FALSE;

		unsigned long dwIndex = 0;
		char *lpData = NULL;
		unsigned long  dataSize = BUFSIZ, lpType;

		BOOL found = FALSE;
		long length = 0;
		if(RegQueryValueEx(rootKey,
			filePaths,	
			0,	 
			&lpType,	 
			NULL,	
			&dataSize) == ERROR_SUCCESS)
		{
			if(lpData = new char[dataSize+1])
			{
				if(RegQueryValueEx(rootKey,
					filePaths,	
					0,	 
					&lpType,	 
					(unsigned char *)lpData,	
					&dataSize) == ERROR_SUCCESS)
				// Break the char string into a list of CStrings
				{
					unsigned long start = 0, resultLength = 0;
					while(start+1 < dataSize)
					{	
						CString nextPath(lpData + start);
						if(_strcmpi(nextPath, fullPathName) )
						{
							theList.AddTail(nextPath);
							resultLength += (nextPath.GetLength() + 1 );
						}
						else
							found = TRUE;
						start += strlen(lpData + start);
						start++;
					}

					if(!found)
					{
						RegCloseKey(rootKey);
						delete [] lpData;
						return FALSE;
					}

					char *temp = lpData;
					POSITION p = theList.GetHeadPosition();
					CString nextPath;
					while(p)
					{
						strcpy(temp, nextPath = theList.GetNext(p));
						temp += (nextPath.GetLength() + 1);
					}
					*temp = NULL;

					if(RegSetValueEx(rootKey, filePaths,
							NULL,REG_MULTI_SZ, 
							(unsigned char * )lpData,
							resultLength) 
							!= ERROR_SUCCESS)
					{
						RegCloseKey(rootKey);
						delete [] lpData;
						return FALSE;
					}
					else
					{
						delete [] lpData;
						RegCloseKey(rootKey);
						return TRUE;
					}
				}
				delete [] lpData;
			}
			else
			{
				RegCloseKey(rootKey);
				return FALSE;
			}
		}
		else
		{
			RegCloseKey(rootKey);
			return FALSE;
		}
	}
	else
		return FALSE;

	return FALSE;
}

BOOL SIMCRegistryController::AddRegistryDirectory(const CString& directoryName)
{
	// First Get the fully qualified path name from 'directoryName'
	char fullPathName[BUFSIZ], *dummy;
	long fullSize = 0;
	SIMCStringList theList;
	if(GetFullPathName(directoryName, BUFSIZ, fullPathName, &dummy))		
	{
		// Check whether the directory exists
		fullSize = strlen(fullPathName);
		HANDLE hDir = CreateFile (
			fullPathName,
			GENERIC_READ,
			FILE_SHARE_READ|FILE_SHARE_DELETE,
			NULL,
			OPEN_EXISTING,
			FILE_FLAG_BACKUP_SEMANTICS,
			NULL
		);

		if(hDir == INVALID_HANDLE_VALUE)
			return FALSE;
		else
			CloseHandle(hDir);

		// Check that the path is not a UNC name
		if(fullPathName[0] == '\\' && fullPathName[1] == '\\')
			return FALSE;

		// Open the root key. Create it if doesn't exist
		HKEY rootKey;
		unsigned long temp2;
		if(RegCreateKeyEx(HKEY_LOCAL_MACHINE,
			rootKeyName, 0, 
			"REG_SZ", 
			REG_OPTION_NON_VOLATILE,	
			KEY_ALL_ACCESS,
			NULL, &rootKey, &temp2) != ERROR_SUCCESS)
				return FALSE;

		unsigned long dwIndex = 0;
		char *lpData = NULL;
		unsigned long  dataSize = BUFSIZ, lpType;

		long length = 0;
		unsigned long resultLength = 0;
 		// If a directory list already exists, retrieve it
		if(RegQueryValueEx(rootKey,
			filePaths,	
			0,	 
			&lpType,	 
			NULL,	
			&dataSize) == ERROR_SUCCESS)
		{
			if(lpData = new char[dataSize + strlen(fullPathName) + 2])
			{
				if(RegQueryValueEx(rootKey,
					filePaths,	
					0,	 
					&lpType,	 
					(unsigned char *)lpData,	
					&dataSize) == ERROR_SUCCESS)
				{
					// Break the char string into a list of CStrings
					unsigned long start = 0;
					CString nextPath;
					while(start+1 < dataSize)
					{	
						nextPath = lpData + start;
						theList.AddTail(nextPath);
						resultLength += (nextPath.GetLength() + 1 );
						start += strlen(lpData + start);
						start++;
					}
				}
			}
			else
			{
				RegCloseKey(rootKey);
				return FALSE;
			}
		}
		else
		{
			// This is the first entry
			if(!(lpData = new char[strlen(fullPathName) + 2]))
			{
				RegCloseKey(rootKey);
				return FALSE;
			}
		}

		// Append the new directory to the existing list of directories
		char *temp = lpData;
		POSITION p = theList.GetHeadPosition();
		CString nextPath = "";
		while(p)
		{
			nextPath= theList.GetNext(p);
			if(nextPath.CompareNoCase(fullPathName) != 0) 
			{
				strcpy(temp, nextPath );
				temp += (nextPath.GetLength()+1);
			}
		}
		strcpy(temp, fullPathName);
		temp += fullSize;
		*(temp++) = NULL;
		resultLength = (unsigned long)(temp - lpData) + 1; 
		if(RegSetValueEx(rootKey, filePaths,
				NULL,REG_MULTI_SZ, 
				(unsigned char * )lpData,
				resultLength) 
				!= ERROR_SUCCESS)
		{
			RegCloseKey(rootKey);
			return FALSE;
		}
		else
			RegCloseKey(rootKey);
	}
	else
		return FALSE;

	return TRUE;
}

BOOL SIMCRegistryController::IsModulePresent(SIMCFileMapList& dependencyList,
											  const CString& dependentModule)
{
	POSITION p = dependencyList.GetHeadPosition();
	SIMCFileMapElement element;

	// See if the dependentModule isn't already there
	while(p)
	{
		element = dependencyList.GetNext(p);
		if( element.moduleName == dependentModule)
			return TRUE;
	}
	return FALSE;
}

BOOL SIMCRegistryController::IsFilePresent(SIMCFileMapList& dependencyList,
											  const CString& dependentFile)
{
	POSITION p = dependencyList.GetHeadPosition();
	SIMCFileMapElement element;

	// See if the dependentModule isn't already there
	while(p)
	{
		element = dependencyList.GetNext(p);
		if( element.fileName == dependentFile)
			return TRUE;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <io.h>
#include <iostream.h>
#include <fstream.h>
#include <strstrea.h>
#include <typeinfo.h>
#include <ole2.h>
#include <windows.h>
#include <limits.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\resource.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\scanner.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"


SIMCScanner::SIMCScanner(SIMCParser *parser)
	:	columnNo(0), _theParser(parser) 
{}


SIMCScanner::~SIMCScanner()
{
	if(yyin)
		fclose(yyin);
}

BOOL SIMCScanner::SetInput(ifstream& inputStream)
{
	_inputStreamName = "<ifstream>";
	if(_dup2(inputStream.fd(), _fileno(yyin)) == -1)
		return FALSE;
	return TRUE;
}
	
BOOL SIMCScanner::SetInput(const CString& inputFile)
{
	 _inputStreamName = inputFile;
	if(!freopen(inputFile, "r", yyin))
		return FALSE;
	return TRUE;
}

BOOL SIMCScanner::SetInput(const int fileDescriptor)
{
	_inputStreamName = "<file descriptor>";
	if(_dup2(fileDescriptor, _fileno(yyin)) == -1)
		return FALSE;
	return TRUE;
}

BOOL SIMCScanner::SetInput(FILE * fileStream)
{
	_inputStreamName = "<FILE stream>";
	yyin = fileStream;
	return TRUE;
}

void SIMCScanner::output(int character)
{
	cerr << "<1212, Fatal>: \"" <<  _inputStreamName << "\" (line " << yylineno <<
		", col " << columnNo << ": Unrecognized character \'" << char(character) << "\'" << 
		endl;
}

void SIMCScanner::yyerror(char *fmt, ...)
{
	if(!_theParser)
	{
		return;
	}

	if (_theParser->YYRECOVERING())
		cerr << "Recovering from Error" << endl;
	else
	{
		if( yyleng )
		{
			if( yyleng == 1 )
			{
				switch (yytext[0])
				{
					case '\n' : cerr << _inputStreamName << "(line " << yylineno << 
									") SYNTAX ERROR. " << 
									"Last character read is \\n" << 
									endl; 
								return;
					case '\t' : cerr << _inputStreamName << "(line " << yylineno << 
									") SYNTAX ERROR. " << 
									"Last character read is \\t" << 
									endl; 
								return;
				}
			}
			yytext[yyleng] = NULL;
			cerr << "SYNTAX ERROR on line: " << yylineno << 
				", Last token read is \"" << yytext << "\"" << endl;
		}
		else
			cerr << "SYNTAX ERROR: EOF reached before end of module" <<
			endl;
	}
}

void SIMCScanner::SetInputStreamName( const CString& streamName)
{
	_inputStreamName = streamName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\traptype.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "trapType.hpp"


SIMCTrapTypeType::SIMCTrapTypeType( SIMCSymbol **enterprise,
					long enterpriseLine, long enterpriseColumn,
					SIMCVariablesList *variables,
					char * description,
					long descriptionLine, long descriptionColumn,
					char *reference,
					long referenceLine, long referenceColumn)
					:	_enterprise(enterprise),
						_enterpriseLine(enterpriseLine), _enterpriseColumn(enterpriseColumn),
						_variables(variables),
						_descriptionLine(descriptionLine), _descriptionColumn(descriptionColumn),
						_reference(reference),
						_referenceLine(referenceLine), _referenceColumn(referenceColumn)

{
	if(enterprise)
		(*enterprise)->IncrementReferenceCount();

	_description = NewString(description);
	_reference = NewString(reference);

	if (variables)
	{
		POSITION p = variables->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (variables->GetNext(p))->_item;
			(*s)->IncrementReferenceCount();
		}
	}
}

SIMCTrapTypeType::~SIMCTrapTypeType()
{
	if(UseReferenceCount() && _enterprise)
		(*_enterprise)->DecrementReferenceCount();

	if (UseReferenceCount() && _variables)
	{
		POSITION p = _variables->GetHeadPosition();
		SIMCSymbol **s;
		while(p)
		{
			s = (_variables->GetNext(p))->_item;
			(*s)->DecrementReferenceCount();
		}
	}
}

void SIMCTrapTypeType::WriteType(ostream& outStream) const
{
	outStream << "SIMCTrapTypeType::WriteType() : NOT YET IMPLEMENTED" << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\symbol.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "module.hpp"

SIMCSymbol::SIMCSymbol(const char * const symbolName, 
					SymbolType symbolType,
					SIMCModule *module,
					long lineNumber, long columnNumber,
					long referenceCount)
					:	_symbolType(symbolType),
						_module(module), _lineNumber(lineNumber),
						_columnNumber(columnNumber),
						_referenceCount(referenceCount),
						_useReferenceCount(FALSE)
{
	if( symbolName )
	{
		if( !(_symbolName = NewString(symbolName)) )
			cerr << "SIMCSymbol(): Fatal Error" << endl;
	}
	else
		_symbolName = NULL;

}


SIMCSymbol::~SIMCSymbol()
{
	if( _symbolName )
		delete []_symbolName;
}

SIMCSymbol::SIMCSymbol(const SIMCSymbol& rhs)
					:	_symbolType(rhs._symbolType),
						_lineNumber(rhs._lineNumber),
						_columnNumber(rhs._columnNumber),
						_referenceCount(rhs._referenceCount)
{
	if( _symbolName )
		delete []_symbolName;

	if( rhs._symbolName )
	{
		if( !(_symbolName = NewString(rhs._symbolName)) )
			cerr << "SIMCSymbol(): Fatal Error" << endl;
	}
	else
		_symbolName = NULL;
	_module = rhs._module;
	_useReferenceCount = rhs._useReferenceCount;
}


BOOL SIMCSymbol::operator == (const SIMCSymbol& rhs) const
{
	if( strcmp(_symbolName, rhs._symbolName) == 0 &&
		strcmp(_module->GetModuleName(), (rhs._module)->GetModuleName()) == 0)
		return TRUE;
	return FALSE;
}

void SIMCSymbol::WriteSymbol(ostream& outStream) const
{
	outStream << "SYMBOL(" << _symbolName << 
		"), TYPE(" << int(_symbolType) <<
		"), MODULE(" << ((_module)? _module->GetModuleName() : "NONE") <<
		"), LINE(" << _lineNumber << 
		"), COLUMN(" << _columnNumber <<
		"), REF_COUNT(" << _referenceCount << ")" << endl;
}


void SIMCSymbol::WriteBrief(ostream& outStream) const
{
	outStream << _symbolName << "(";
	if(_module)
		outStream << _module->GetModuleName() ;
	else
		outStream << "<NONE>";
	outStream << ")" << endl;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\parsetree.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"

#include "smierrsy.hpp"
#include "smierrsm.hpp"


#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>
#include "scanner.hpp"
#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "parser.hpp"
#include "abstractParseTree.hpp"
#include "oidTree.hpp"
#include "parseTree.hpp"

HINSTANCE SIMCParseTree::semanticErrorsDll = NULL ;
const int SIMCParseTree::SEMANTIC_ERROR_BASE = 1000;
const int SIMCParseTree::MESSAGE_SIZE = 1024;

// Just a static function to remove underscores from a fabricated module identitiy name
static void RemoveUnderscores(CString &moduleIdentityName);

void SIMCParseTree::SemanticError(const char * const inputStreamName,
									int errorType, int lineNo,
									int columnNo, ...)
{
	va_list argList;
	va_start(argList, columnNo);
	SIMCErrorMessage e;
	e.SetInputStreamName(inputStreamName);
	e.SetLineNumber(lineNo);
 	e.SetColumnNumber(columnNo);
	e.SetErrorId(SEMANTIC_ERROR_BASE + errorType);

	char message[MESSAGE_SIZE];
	char errorText[MESSAGE_SIZE];
	const char *temp1, *temp2, *temp3, *temp4;

	if(!LoadString(semanticErrorsDll, errorType, errorText, MESSAGE_SIZE))
		cerr << "SIMCParseTree::SemantixError(): Panic, unable to load error "
		<< "string" << endl;

	// Set the severity level as warning for these
	switch(errorType)
	{
		case OBJ_TYPE_SINGULAR_COUNTER:
		case OBJ_TYPE_INDEX_UNNECESSARY:
		case ZERO_IN_OID:
		case IMPORT_UNUSED:
		case ENUM_ZERO_VALUE:
		case KNOWN_REDEFINITION:
		case KNOWN_UNDEFINED:
		case TYPE_UNREFERENCED:
		case VALUE_UNREFERENCED:
		case OBJ_TYPE_DEFVAL_NET_ADDR:
		case OBJ_TYPE_ACCESSIBLE_TABLE:
		case OBJ_TYPE_ACCESSIBLE_ROW:
		case IMPORT_KNOWN_WRONG_MODULE:
		case IR_MODULE_MISSING_WARNING:
		case IR_SYMBOL_MISSING_WARNING:
		case STANDARD_AMBIGUOUS_REFERENCE:
		case MODULE_NO_GROUPS_V1:
		case MODULE_NO_GROUPS_V2:
		case IMPLIED_USELESS:
		case OBJ_TYPE_DUPLICATE_OID: 			
		{
				e.SetSeverityLevel(WARNING);
				e.SetSeverityString("Warning");
				_warningCount++;
		}
		break;
		default:
		{
			e.SetSeverityLevel(FATAL);
			e.SetSeverityString("Fatal");
			_fatalCount++;
		}
		break;
	}

	switch(errorType)
	{
		case OBJ_TYPE_INDEX_UNNECESSARY: 
		case OBJ_TYPE_INVALID_DEFVAL: 
		case OBJ_TYPE_SYNTAX_RESOLUTION:
		case OBJ_TYPE_ACCESSIBLE_TABLE: 
		case OBJ_TYPE_ACCESSIBLE_ROW:
		case OBJ_TYPE_DEFVAL_NET_ADDR:
		case OBJ_TYPE_DEFVAL_DISALLOWED:
		case OBJ_TYPE_DEFVAL_RESOLUTION:
		case ZERO_IN_OID:
		case OID_NEGATIVE_INTEGER: 
		case ENUM_ZERO_VALUE: 
		case SIZE_INVALID_VALUE: 
		case SIZE_INVALID_BOUNDS:
		case RANGE_INVALID_BOUNDS:
		case RANGE_NEGATIVE_GAUGE:
		case SUBTYPE_ROOT_RESOLUTION:
		case INTEGER_TOO_BIG:
		case VALUE_ASSIGN_ENUM_INVALID:
		case IMPLIED_USELESS:
		case IMPLIED_FIXED_SIZE:
		case IMPLIED_POSSIBLE_ZERO_SIZE:
		case V1_ENUM_ONLY_INTEGER:
		case V2_ENUM_ROOT_RESOLUTION:
		case V2_ENUM_CLOSURE:
		case V2_BITS_ROOT_RESOLUTION:
		case ENUM_OR_BITS_RESOLUTION:
		case RANGE_BIG_RANGE:
			sprintf(message, errorText);
			break;
		case OBJ_TYPE_SINGULAR_COUNTER: 
		case OBJ_TYPE_INVALID_ACCESS: 
		case OBJ_TYPE_INVALID_STATUS: 
		case OBJ_TYPE_SEQUENCE_NO_INDEX: 
		case OBJ_TYPE_SEQUENCE_MULTI_REFERENCE: 
		case OBJ_TYPE_SEQUENCE_UNUSED: 
		case OBJ_TYPE_INDEX_RESOLUTION:
		case OBJ_TYPE_INDEX_SYNTAX:
		case SEQUENCE_ITEM_NO_OBJECT:
		case SEQUENCE_TYPE_UNRESOLVED:
		case INVALID_SEQUENCE_OF: 
		case TRAP_TYPE_ENTERPRISE_RESOLUTION: 
		case TRAP_TYPE_VALUE_RESOLUTION: 
		case TRAP_TYPE_VARIABLES_RESOLUTION: 
		case OID_RESOLUTION: 
		case OID_HEAD_ERROR: 
		case IMPORT_UNUSED: 
		case IMPORT_MODULE_ABSENT: 
		case IMPORT_CURRENT: 
		case ENUM_DUPLICATE_VALUE: 
		case ENUM_DUPLICATE_NAME: 
		case ENUM_RESOLUTION: 
		case SIZE_TYPE_RESOLUTION: 
		case RANGE_TYPE_RESOLUTION: 
		case SIZE_VALUE_RESOLUTION: 
		case RANGE_VALUE_RESOLUTION: 
		case SYMBOL_REDEFINITION: 
		case KNOWN_UNDEFINED: 
		case VALUE_ASSIGN_MISMATCH:
		case VALUE_ASSIGN_INVALID:
		case VALUE_ASSIGN_NEGATIVE_INTEGER:
		case SYMBOL_UNDEFINED: 
		case IMPORT_AMBIGUOUS_REFERENCE:
		case TYPE_UNRESOLVED:
		case VALUE_UNRESOLVED:
		case OBJ_TYPE_SEQUENCE_NO_PARENT:
		case MODULE_NO_GROUPS_V1:
		case MODULE_NO_GROUPS_V2:
		case INVALID_BIT_VALUE:
		case AUGMENTS_CLAUSE_RESOLUTION:
		case BITS_VALUE_RESOLUTION:
		case BITS_DUPLICATE_VALUE:
		case BITS_DUPLICATE_NAME:
		case NOTIFICATION_TYPE_INVALID_STATUS: 
		case OBJECT_IDENTITY_VALUE_RESOLUTION:
		case NOTIFICATION_TYPE_VALUE_RESOLUTION:
		case NOTIFICATION_TYPE_OBJECTS_RESOLUTION: 
		case NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT:
			temp1 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1);
			break;
		case TYPE_UNREFERENCED: 	   // Special cases, since the type/value name may be
		case VALUE_UNREFERENCED:		// a compiler generated name
			temp1 = va_arg(argList, const char *);
			if(*temp1 == '*')
				temp1 = "";
			else
				sprintf(message, errorText, temp1);
			break;
		case OBJ_TYPE_SEQUENCE_INVALID_SYNTAX: 
		case OBJ_TYPE_OID_RESOLUTION:
		case TRAP_TYPE_DUPLICATE_VALUES: 
		case VALUE_ASSIGN_RESOLUTION: 
		case IMPORT_SYMBOL_ABSENT: 
		case IMPORT_KNOWN_WRONG_MODULE: 
		case KNOWN_REDEFINITION:
		case IR_SYMBOL_MISSING_FATAL:
		case IR_SYMBOL_MISSING_WARNING:
		case STANDARD_AMBIGUOUS_REFERENCE:
		case IR_MODULE_MISSING_FATAL:
		case IR_MODULE_MISSING_WARNING:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1, temp2);
			break;
		case SEQUENCE_WRONG_CHILD:
		case OBJ_TYPE_PRIMITIVE_CHILD:
		case OBJ_TYPE_SEQUENCE_CHILD:
		case OBJ_TYPE_SEQUENCE_EXTRA_CHILD:
		case OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD:
		case OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH:
		case OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD:
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			temp3 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1, temp2, temp3);
			break;
		case OBJ_TYPE_DUPLICATE_OID: 			
			temp1 = va_arg(argList, const char *);
			temp2 = va_arg(argList, const char *);
			temp3 = va_arg(argList, const char *);
			temp4 = va_arg(argList, const char *);
			sprintf(message, errorText, temp1, temp2, temp3, temp4);
			break;
	}
	va_end(argList);

	e.SetMessage(message);
	if(_errorContainer)
		_errorContainer->InsertMessage(e);
}

BOOL SIMCParseTree::ResolveSymbol(SIMCSymbol **symbol, BOOL local)
{
	if(local)
		return TRUE;

	SIMCModule *temp = (*symbol)->GetModule();
	SIMCModule * importedModule = GetModule(temp->GetModuleName());
	if(!importedModule )
	{
		if((*symbol)->GetReferenceCount())
		{
			SemanticError(temp->GetInputFileName(), IR_MODULE_MISSING_FATAL,
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(), 
				temp->GetModuleName(),
				(*symbol)->GetSymbolName());
			return FALSE;
		}
		else
		{
			SemanticError(temp->GetInputFileName(), IR_MODULE_MISSING_WARNING,
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(), 
				temp->GetModuleName(),
				(*symbol)->GetSymbolName());
			return TRUE;
		}
	}
	
	SIMCSymbol **newRef = importedModule->GetSymbol(
									(*symbol)->GetSymbolName());

	if(!newRef)
	{
		if( (*symbol)->GetReferenceCount())
		{
			SemanticError(temp->GetInputFileName(), IR_SYMBOL_MISSING_FATAL,
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
				(*symbol)->GetSymbolName(), temp->GetModuleName());
			return FALSE;
		}
		else
		{
			SemanticError(temp->GetInputFileName(), IR_SYMBOL_MISSING_WARNING,
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
				(*symbol)->GetSymbolName(), temp->GetModuleName());
			return TRUE;
		}
	}
	(*newRef)->SetReferenceCount(
					(*newRef)->GetReferenceCount() +
					(*symbol)->GetReferenceCount() ); 
	//delete *symbol;
	(*symbol) = (*newRef);

	return TRUE;
}


BOOL SIMCParseTree::ResolveImportModule(SIMCModule *m, BOOL local)
{

	/* This commented statement is STATEMENT1 */
	if( m->GetSymbolType() == SIMCSymbol::PRIMITIVE)
		return TRUE;
	
	/* This statement is STATEMENT2 for Bug 28014*/
	/*
	if(!GetModule(m->GetModuleName()))
		return TRUE;
		*/

	const char *const moduleName = m->GetModuleName();
	SIMCSymbolTable * table = m->GetSymbolTable();
	POSITION p = table->GetStartPosition();
	SIMCSymbol **s;
	CString name;
	BOOL retVal = TRUE;
	while(p)
	{
		table->GetNextAssoc(p, name, s);
		if( !SIMCParser::IsReservedSymbol(_snmpVersion, (*s)->GetSymbolName(), moduleName ))
			retVal = ResolveSymbol(s, local) && retVal;
	}
	return retVal;
}

BOOL SIMCParseTree::ResolveModule(SIMCModule *m, BOOL local)
{
	SIMCSymbolTable * table = m->GetSymbolTable();
	POSITION p = table->GetStartPosition();
	SIMCSymbol **s;
	CString name;
	BOOL retVal = TRUE;
	while(p)
	{
		table->GetNextAssoc(p, name, s);
		if((*s)->GetSymbolType() == SIMCSymbol::IMPORTED)
			retVal	= ResolveSymbol(s, local) && retVal ;
	}


	// Now, on to the import modules
	SIMCModuleList * importModules = m->GetListOfImportModules();
	p = importModules->GetHeadPosition();
	SIMCModule *nextModule;
	while(p)
	{
		nextModule = importModules->GetNext(p);
		retVal = ResolveImportModule(nextModule, local) && retVal;
	}
	return retVal;
}

BOOL SIMCParseTree::SetResolutionStatus()
{
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		if(!m->SetResolutionStatus())
			retVal = FALSE;
	}
	return retVal;
}

BOOL SIMCParseTree::SetRootAll()
{
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		if(!m->SetRootAll())
			retVal = FALSE;
	}
	return retVal;
}

BOOL SIMCParseTree::SetDefVal()
{
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		if(!m->SetDefVal())
			retVal = FALSE;
	}
	return retVal;
}


BOOL SIMCParseTree::Resolve(BOOL local)
{
	// This function can be called from any state of the parse tree
	if( _parseTreeState == EMPTY)
		return TRUE;
	
	// If you can't report semantic errors, what's the point?
	if(!semanticErrorsDll)
	{
		cerr << "Resolve(): FATAL ERROR smierrsm.dll not found" <<
			endl;
		return FALSE;
	}

	// Do for all modules in the list
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		retVal= ResolveModule(m, local) && retVal;
	}

	SetResolutionStatus();
	SetRootAll();
	SetDefVal();


	// The state of the parse tree has to be set
	if(retVal)
	{
		if (_parseTreeState == UNRESOLVED)
			_parseTreeState = UNCHECKED;
	}
	return retVal;
}

BOOL SIMCParseTree::CheckRangeTypeV1( const char *const fileName,
			SIMCRangeType *rangeType, BOOL local)
{

	switch(rangeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*rangeType->GetType())->GetSymbolName()
				); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
					rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
					(*rangeType->GetType())->GetSymbolName()
					); 
				return FALSE;
			}
		case RESOLVE_CORRECT:
			break;
	}

	// Come here on RESOLVE_CORRECT in above switch
	BOOL isGauge = FALSE;
	BOOL retVal = TRUE;
	SIMCTypeReference *rootTypeRef = rangeType->GetRootType();
	SIMCSymbol **tempRootTypeRef = 	(SIMCSymbol **) &rootTypeRef;
	if(SIMCModule::GetSymbolClass(tempRootTypeRef) != 
		SIMCModule::SYMBOL_BUILTIN_TYPE_REF)
	{
		SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
			rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
			(*rangeType->GetType())->GetSymbolName()
			); 
		return FALSE;
	}

	SIMCModule::PrimitiveType x = 
		SIMCModule::GetPrimitiveType(rootTypeRef);

	if(	x != SIMCModule::PRIMITIVE_INTEGER	&&
		x != SIMCModule::PRIMITIVE_GAUGE )
	{
		SIMCSymbol **baseSymbol = rangeType->GetType();
		SemanticError( fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName());
		retVal = FALSE;
	}

	if( x == SIMCModule::PRIMITIVE_GAUGE)
		isGauge = TRUE;

	// Now to check the list of ranges
	const SIMCRangeList * baseList = rangeType->GetListOfRanges();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, RANGE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(isGauge)
		{
			if( item->_upperBound<0 && !item->_isUnsignedU)
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_ubLine, item->_ubColumn);
				retVal = FALSE;
			}
			if( item->_lowerBound<0 && !item->_isUnsignedL)
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_lbLine, item->_lbColumn);
				retVal = FALSE;
			}
		}
	}
	// See if the range fits into 4 bytes
	if(retVal && !CheckRangeRange(baseList))
	{
		retVal = FALSE;
		SemanticError(fileName, RANGE_BIG_RANGE,
				rangeType->GetTypeLine(), rangeType->GetTypeColumn());
	}

	return retVal;
}

BOOL SIMCParseTree::CheckRangeTypeV2( const char *const fileName,
			SIMCRangeType *rangeType, BOOL local)
{

	switch(rangeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*rangeType->GetType())->GetSymbolName()
				); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
					rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
					(*rangeType->GetType())->GetSymbolName()
					); 
				return FALSE;
			}
			break;
		case RESOLVE_CORRECT:
			break;
	}

	// Come here on RESOLVE_CORRECT in above switch
	BOOL isGauge = FALSE;
	BOOL retVal = TRUE;
	SIMCTypeReference *rootTypeRef = rangeType->GetRootType();


	SIMCModule::PrimitiveType x = SIMCModule::GetPrimitiveType(rootTypeRef);
	if(	x != SIMCModule::PRIMITIVE_INTEGER		&&
		x != SIMCModule::PRIMITIVE_INTEGER_32	&&
		x != SIMCModule::PRIMITIVE_UNSIGNED_32	&&
		x != SIMCModule::PRIMITIVE_GAUGE_32		)
	{
		SIMCSymbol **baseSymbol = rangeType->GetType();
		SemanticError( fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName());
		retVal = FALSE;
	}

	if( x == SIMCModule::PRIMITIVE_GAUGE_32)
		isGauge = TRUE;

	// Now to check the list of ranges
	const SIMCRangeList * baseList = rangeType->GetListOfRanges();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, RANGE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(isGauge)
		{
			if( item->_upperBound<0 && !item->_isUnsignedU )
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_ubLine, item->_ubColumn);
				retVal = FALSE;
			}
			if( item->_lowerBound<0 && !item->_isUnsignedL)
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_lbLine, item->_lbColumn);
				retVal = FALSE;
			}
		}
	}
	// See if the range fits into 4 bytes
	if(retVal && !CheckRangeRange(baseList))
	{
		retVal = FALSE;
		SemanticError(fileName, RANGE_BIG_RANGE,
				rangeType->GetTypeLine(), rangeType->GetTypeColumn());
	}


	return retVal;
}

BOOL SIMCParseTree::CheckRangeTypeV0( const char *const fileName,
			SIMCRangeType *rangeType, BOOL local)
{

	switch(rangeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*rangeType->GetType())->GetSymbolName()
				); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, RANGE_TYPE_RESOLUTION, 
					rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
					(*rangeType->GetType())->GetSymbolName()
					); 
				return FALSE;
			}
			break;
		case RESOLVE_CORRECT:
			break;
	}

	// Come here on RESOLVE_CORRECT in above switch
	BOOL isGauge = FALSE;
	BOOL retVal = TRUE;
	SIMCTypeReference *rootTypeRef = rangeType->GetRootType();


	SIMCModule::PrimitiveType x = SIMCModule::GetPrimitiveType(rootTypeRef);
	if(	x != SIMCModule::PRIMITIVE_INTEGER		&&
		x != SIMCModule::PRIMITIVE_INTEGER_32	&&
		x != SIMCModule::PRIMITIVE_UNSIGNED_32	&&
		x != SIMCModule::PRIMITIVE_GAUGE		&&
		x != SIMCModule::PRIMITIVE_GAUGE_32		)
	{
		SIMCSymbol **baseSymbol = rangeType->GetType();
		SemanticError( fileName, RANGE_TYPE_RESOLUTION, 
				rangeType->GetTypeLine(), rangeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName());
		retVal = FALSE;
	}

	if( x == SIMCModule::PRIMITIVE_GAUGE_32 ||
		x == SIMCModule::PRIMITIVE_GAUGE	)
		isGauge = TRUE;

	// Now to check the list of ranges
	const SIMCRangeList * baseList = rangeType->GetListOfRanges();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, RANGE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(isGauge)
		{
			if( item->_upperBound<0 && !item->_isUnsignedU )
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_ubLine, item->_ubColumn);
				retVal = FALSE;
			}
			if( item->_lowerBound<0 && !item->_isUnsignedL)
			{
				SemanticError(fileName, RANGE_NEGATIVE_GAUGE,
					item->_lbLine, item->_lbColumn);
				retVal = FALSE;
			}
		}
	}
	// See if the range fits into 4 bytes
	if(retVal && !CheckRangeRange(baseList))
	{
		retVal = FALSE;
		SemanticError(fileName, RANGE_BIG_RANGE,
				rangeType->GetTypeLine(), rangeType->GetTypeColumn());
	}


	return retVal;
}

BOOL SIMCParseTree::CheckRangeRange(const SIMCRangeList *baseList)
{
	// Find the lowest and the highest of all the items
	if(!baseList)
		return TRUE;
	POSITION p = baseList->GetHeadPosition();
	if(!p)
		return TRUE;

	SIMCRangeOrSizeItem *nextItem = baseList->GetNext(p);
	long highest = nextItem->_upperBound, lowest = nextItem->_lowerBound;
	BOOL isUnsignedH = nextItem->_isUnsignedU, isUnsignedL = nextItem->_isUnsignedL;

	while(p)
	{
		nextItem = baseList->GetNext(p);
		if(IsLessThan( nextItem->_lowerBound, nextItem->_isUnsignedL, lowest, isUnsignedL))
		{
			lowest = nextItem->_lowerBound;
			isUnsignedL	= nextItem->_isUnsignedL;
		}

		if(IsLessThan(highest, isUnsignedH, nextItem->_upperBound, nextItem->_isUnsignedU))
		{
			highest = nextItem->_upperBound;
			isUnsignedH = nextItem->_isUnsignedU;
		}
	}

	if(isUnsignedH && (unsigned long)(highest) > (unsigned long)LONG_MAX)
	{
		if(lowest != 0 && !isUnsignedL)
			return FALSE;
	}
	else
		return TRUE;

	return TRUE;
}

BOOL SIMCParseTree::CheckSizeTypeV1(const char *const fileName,
			 SIMCSizeType *sizeType, BOOL local)
{
	switch(sizeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*sizeType->GetType())->GetSymbolName()); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
					sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
					(*sizeType->GetType())->GetSymbolName()); 
				return FALSE;
			}
		case RESOLVE_CORRECT:
			break;
	}

	BOOL retVal = TRUE;

	SIMCTypeReference *root = sizeType->GetRootType();
	SIMCModule::PrimitiveType x = 
		SIMCModule::GetPrimitiveType(root);
	if(	x != SIMCModule::PRIMITIVE_OCTET_STRING		&&
		x != SIMCModule::PRIMITIVE_DISPLAY_STRING	&&
		x != SIMCModule::PRIMITIVE_PHYS_ADDRESS		&&
		x != SIMCModule::PRIMITIVE_OPAQUE )
	{
		SIMCSymbol **baseSymbol = sizeType->GetType();
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName()); 
		retVal = FALSE;
	}

	// Now to check the list of sizes
	const SIMCSizeList * baseList = sizeType->GetListOfSizes();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, SIZE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(item->_upperBound<0  && !item->_isUnsignedU)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if( item->_lowerBound<0 && !item->_isUnsignedU)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_lbLine, item->_lbColumn);
			retVal = FALSE;
		}

	}
	return retVal;
}

BOOL SIMCParseTree::CheckSizeTypeV2(const char *const fileName,
			 SIMCSizeType *sizeType, BOOL local)
{
	switch(sizeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*sizeType->GetType())->GetSymbolName()); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
					sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
					(*sizeType->GetType())->GetSymbolName()); 
				return FALSE;
			}
		case RESOLVE_CORRECT:
			break;
	}

	BOOL retVal = TRUE;

	SIMCTypeReference *root = sizeType->GetRootType();
	SIMCModule::PrimitiveType x = 
		SIMCModule::GetPrimitiveType(root);
	if(	x != SIMCModule::PRIMITIVE_OCTET_STRING		&&
		x != SIMCModule::PRIMITIVE_DISPLAY_STRING	&&
		x != SIMCModule::PRIMITIVE_PHYS_ADDRESS		&&
		x != SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_OPAQUE			&&
		x != SIMCModule::PRIMITIVE_DATE_AND_TIME)
	{
		SIMCSymbol **baseSymbol = sizeType->GetType();
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName()); 
		retVal = FALSE;
	}

	// Now to check the list of sizes
	const SIMCSizeList * baseList = sizeType->GetListOfSizes();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, SIZE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(item->_upperBound<0  && !item->_isUnsignedU)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if( item->_lowerBound<0 && !item->_isUnsignedL)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_lbLine, item->_lbColumn);
			retVal = FALSE;
		}

	}
	return retVal;
}


BOOL SIMCParseTree::CheckSizeTypeV0(const char *const fileName,
			 SIMCSizeType *sizeType, BOOL local)
{
	switch(sizeType->GetStatus())
	{
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*sizeType->GetType())->GetSymbolName()); 
			return FALSE;
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
					sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
					(*sizeType->GetType())->GetSymbolName()); 
				return FALSE;
			}
		case RESOLVE_CORRECT:
			break;
	}

	BOOL retVal = TRUE;

	SIMCTypeReference *root = sizeType->GetRootType();
	SIMCModule::PrimitiveType x = 
		SIMCModule::GetPrimitiveType(root);
	if(	x != SIMCModule::PRIMITIVE_OCTET_STRING		&&
		x != SIMCModule::PRIMITIVE_DISPLAY_STRING	&&
		x != SIMCModule::PRIMITIVE_PHYS_ADDRESS		&&
		x != SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	&&
		x != SIMCModule::PRIMITIVE_OPAQUE			&&
		x != SIMCModule::PRIMITIVE_DATE_AND_TIME)
	{
		SIMCSymbol **baseSymbol = sizeType->GetType();
			SemanticError(fileName, SIZE_TYPE_RESOLUTION, 
				sizeType->GetTypeLine(), sizeType->GetTypeColumn(),
				(*baseSymbol)->GetSymbolName()); 
		retVal = FALSE;
	}

	// Now to check the list of sizes
	const SIMCSizeList * baseList = sizeType->GetListOfSizes();
	POSITION p = baseList->GetHeadPosition();
	const SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = baseList->GetNext(p);
		if(IsLessThan(item->_upperBound, item->_isUnsignedU, item->_lowerBound, item->_isUnsignedL))
		{
			SemanticError(fileName, SIZE_INVALID_BOUNDS,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if(item->_upperBound<0 && !item->_isUnsignedU)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_ubLine, item->_ubColumn);
			retVal = FALSE;
		}
		if( item->_lowerBound<0 && !item->_isUnsignedL)
		{
			SemanticError(fileName, SIZE_INVALID_VALUE,
				item->_lbLine, item->_lbColumn);
			retVal = FALSE;
		}

	}
	return retVal;
}


BOOL SIMCParseTree::CheckEnumTypeV1(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL local)
{
	BOOL retVal = TRUE;	
	SIMCNamedNumberList *list = enumType->GetListOfItems();
	if(!list)
		return TRUE;

	switch(enumType->GetStatus())
	{
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, 
				V1_ENUM_ONLY_INTEGER,
				enumType->GetTypeLine(), enumType->GetTypeColumn());
			return FALSE;
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, 
					V1_ENUM_ONLY_INTEGER,
					enumType->GetTypeLine(), enumType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;

	}

	POSITION pOuter = list->GetHeadPosition(), pInner;
	SIMCNamedNumberItem *current, *later;
	BOOL currentValid;

	while(pOuter)
	{
		current = list->GetNext(pOuter);
		int currentValue, laterValue;
		currentValid = TRUE;
		switch(SIMCModule::IsIntegerValue(current->_value, currentValue))
		{
			case RESOLVE_IMPORT:
				if(local)
					currentValid = FALSE;
				else
				{
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						(*current->_value)->GetSymbolName());
					retVal = FALSE;
					currentValid = FALSE;
				}
				break;
			case RESOLVE_CORRECT:
				if(currentValue == 0 )
				{
					SemanticError(fileName, ENUM_ZERO_VALUE, 
						current->_valueLine, current->_valueColumn);
					retVal = FALSE;
				}
				else if (currentValue < 0 )
				{
					SemanticError(fileName, ENUM_RESOLUTION,
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
				}
				break;
			default:
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
					currentValid = FALSE;
		}

		// Check for duplicate names, duplicate values
		pInner = pOuter;
		while(pInner)
		{
			later = list->GetNext(pInner);
			if(strcmp(current->_name, later->_name) == 0 )
			{
				retVal = FALSE;
				SemanticError(fileName, ENUM_DUPLICATE_NAME, 
					current->_nameLine, current->_nameColumn,
					current->_name);
			}
			if(currentValid)
			{
				switch(SIMCModule::IsIntegerValue(later->_value, laterValue))
				{
					case RESOLVE_CORRECT:
						if( laterValue == currentValue)
						{
							char buffer[20];
							retVal = FALSE;
							SemanticError(fileName, ENUM_DUPLICATE_VALUE,
								later->_valueLine, later->_valueColumn,
								_itoa(laterValue, buffer, 10));
						}
						break;
					default:
						break;
				}
			}
		}
		
	}
	return retVal;
}

BOOL SIMCParseTree::CheckEnumTypeV2(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL local)
{
	BOOL retVal = TRUE;	
	SIMCNamedNumberList *list = enumType->GetListOfItems();
	if(!list)
		return TRUE;

	switch(enumType->GetStatus())
	{
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, 
				V2_ENUM_ROOT_RESOLUTION,
				enumType->GetTypeLine(), enumType->GetTypeColumn());
			return FALSE;
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, 
					V2_ENUM_ROOT_RESOLUTION,
					enumType->GetTypeLine(), enumType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_CORRECT:
		// See if it resolves to an allowed type for enumeration
		{
			SIMCTypeReference *tRef = enumType->GetRootType();
			SIMCSymbol **tempTRef = (SIMCSymbol**)&tRef;
			switch(SIMCModule::GetSymbolClass(tempTRef))
			{
				case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				{
					SIMCType *type = ((SIMCBuiltInTypeReference *)tRef)->GetType();
					switch(SIMCModule::GetTypeClass(type))
					{
						case SIMCModule::TYPE_PRIMITIVE:
							if(SIMCModule::GetPrimitiveType(tRef->GetSymbolName()) != SIMCModule::PRIMITIVE_INTEGER)
							{
								SemanticError(fileName, 
									V2_ENUM_ROOT_RESOLUTION,
									enumType->GetTypeLine(), enumType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						case SIMCModule::TYPE_ENUM_OR_BITS:
							if(!enumType->CheckClosure((SIMCEnumOrBitsType *)type))
							{
								SemanticError(fileName, 
									V2_ENUM_CLOSURE,
									enumType->GetTypeLine(), enumType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						default:
							SemanticError(fileName, 
								V2_ENUM_ROOT_RESOLUTION,
								enumType->GetTypeLine(), enumType->GetTypeColumn());
							return FALSE;
					}
				}
				break;
				default:
					SemanticError(fileName, 
						V2_ENUM_ROOT_RESOLUTION,
						enumType->GetTypeLine(), enumType->GetTypeColumn());
					return FALSE;
			}

		}
	}


	POSITION pOuter = list->GetHeadPosition(), pInner;
	SIMCNamedNumberItem *current, *later;
	BOOL currentValid;

	while(pOuter)
	{
		current = list->GetNext(pOuter);
		int currentValue, laterValue;
		currentValid = TRUE;
		switch(SIMCModule::IsIntegerValue(current->_value, currentValue))
		{
			case RESOLVE_IMPORT:
				if(local)
					currentValid = FALSE;
				else
				{
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						(*current->_value)->GetSymbolName());
					retVal = FALSE;
					currentValid = FALSE;
				}
				break;
			case RESOLVE_CORRECT:
				if(currentValue == 0 )
				{
					SemanticError(fileName, ENUM_ZERO_VALUE, 
						current->_valueLine, current->_valueColumn);
					retVal = FALSE;
				}
				else if (currentValue < 0 )
				{
					SemanticError(fileName, ENUM_RESOLUTION,
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
				}
				break;
			default:
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
					currentValid = FALSE;
		}

		// Check for duplicate names, duplicate values
		pInner = pOuter;
		while(pInner)
		{
			later = list->GetNext(pInner);
			if(strcmp(current->_name, later->_name) == 0 )
			{
				retVal = FALSE;
				SemanticError(fileName, ENUM_DUPLICATE_NAME, 
					current->_nameLine, current->_nameColumn,
					current->_name);
			}
			if(currentValid)
			{
				switch(SIMCModule::IsIntegerValue(later->_value, laterValue))
				{
					case RESOLVE_CORRECT:
						if( laterValue == currentValue)
						{
							char buffer[20];
							retVal = FALSE;
							SemanticError(fileName, ENUM_DUPLICATE_VALUE,
								later->_valueLine, later->_valueColumn,
								_itoa(laterValue, buffer, 10));
						}
						break;
					default:
						break;
				}
			}
		}
		
	}
	return retVal;
}

BOOL SIMCParseTree::CheckEnumTypeV0(const char *const fileName,
			SIMCEnumOrBitsType *enumType, BOOL local)
{
	BOOL retVal = TRUE;	
	SIMCNamedNumberList *list = enumType->GetListOfItems();
	if(!list)
		return TRUE;

	switch(enumType->GetStatus())
	{
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, 
				V2_ENUM_ROOT_RESOLUTION,
				enumType->GetTypeLine(), enumType->GetTypeColumn());
			return FALSE;
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, 
					V2_ENUM_ROOT_RESOLUTION,
					enumType->GetTypeLine(), enumType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_CORRECT:
		// See if it resolves to an allowed type for enumeration
		{
			SIMCTypeReference *tRef = enumType->GetRootType();
			SIMCSymbol **tempTRef = (SIMCSymbol**)&tRef;
			switch(SIMCModule::GetSymbolClass(tempTRef))
			{
				case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				{
					SIMCType *type = ((SIMCBuiltInTypeReference *)tRef)->GetType();
					switch(SIMCModule::GetTypeClass(type))
					{
						case SIMCModule::TYPE_PRIMITIVE:
							if(SIMCModule::GetPrimitiveType(tRef->GetSymbolName()) != SIMCModule::PRIMITIVE_INTEGER)
							{
								SemanticError(fileName, 
									V2_ENUM_ROOT_RESOLUTION,
									enumType->GetTypeLine(), enumType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						case SIMCModule::TYPE_ENUM_OR_BITS:
							if(!enumType->CheckClosure((SIMCEnumOrBitsType *)type))
							{
								SemanticError(fileName, 
									V2_ENUM_CLOSURE,
									enumType->GetTypeLine(), enumType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						default:
							SemanticError(fileName, 
								V2_ENUM_ROOT_RESOLUTION,
								enumType->GetTypeLine(), enumType->GetTypeColumn());
							return FALSE;
					}
				}
				break;
				default:
					SemanticError(fileName, 
						V2_ENUM_ROOT_RESOLUTION,
						enumType->GetTypeLine(), enumType->GetTypeColumn());
					return FALSE;
			}

		}
	}


	POSITION pOuter = list->GetHeadPosition(), pInner;
	SIMCNamedNumberItem *current, *later;
	BOOL currentValid;

	while(pOuter)
	{
		current = list->GetNext(pOuter);
		int currentValue, laterValue;
		currentValid = TRUE;
		switch(SIMCModule::IsIntegerValue(current->_value, currentValue))
		{
			case RESOLVE_IMPORT:
				if(local)
					currentValid = FALSE;
				else
				{
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						(*current->_value)->GetSymbolName());
					retVal = FALSE;
					currentValid = FALSE;
				}
				break;
			case RESOLVE_CORRECT:
				if(currentValue == 0 )
				{
					SemanticError(fileName, ENUM_ZERO_VALUE, 
						current->_valueLine, current->_valueColumn);
					retVal = FALSE;
				}
				else if (currentValue < 0 )
				{
					SemanticError(fileName, ENUM_RESOLUTION,
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
				}
				break;
			default:
					SemanticError(fileName, ENUM_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
					currentValid = FALSE;
		}

		// Check for duplicate names, duplicate values
		pInner = pOuter;
		while(pInner)
		{
			later = list->GetNext(pInner);
			if(strcmp(current->_name, later->_name) == 0 )
			{
				retVal = FALSE;
				SemanticError(fileName, ENUM_DUPLICATE_NAME, 
					current->_nameLine, current->_nameColumn,
					current->_name);
			}
			if(currentValid)
			{
				switch(SIMCModule::IsIntegerValue(later->_value, laterValue))
				{
					case RESOLVE_CORRECT:
						if( laterValue == currentValue)
						{
							char buffer[20];
							retVal = FALSE;
							SemanticError(fileName, ENUM_DUPLICATE_VALUE,
								later->_valueLine, later->_valueColumn,
								_itoa(laterValue, buffer, 10));
						}
						break;
					default:
						break;
				}
			}
		}
		
	}
	return retVal;
}

BOOL SIMCParseTree::CheckBitsTypeV2(const char *const fileName,
			SIMCEnumOrBitsType *bitsType, BOOL local)
{
	BOOL retVal = TRUE;	
	SIMCNamedNumberList *list = bitsType->GetListOfItems();
	if(!list)
		return TRUE;

	switch(bitsType->GetStatus())
	{
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, 
				V2_BITS_ROOT_RESOLUTION,
				bitsType->GetTypeLine(), bitsType->GetTypeColumn());
			return FALSE;
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, 
					V2_BITS_ROOT_RESOLUTION,
					bitsType->GetTypeLine(), bitsType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_CORRECT:
		// See if it resolves to an allowed type for enumeration
		{
			SIMCTypeReference *tRef = bitsType->GetRootType();
			SIMCSymbol **tempTRef = (SIMCSymbol**)&tRef;
			switch(SIMCModule::GetSymbolClass(tempTRef))
			{
				case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				{
					SIMCType *type = ((SIMCBuiltInTypeReference *)tRef)->GetType();
					switch(SIMCModule::GetTypeClass(type))
					{
						case SIMCModule::TYPE_PRIMITIVE:
							if(SIMCModule::GetPrimitiveType(tRef->GetSymbolName()) != SIMCModule::PRIMITIVE_BITS)
							{
								SemanticError(fileName, 
									V2_BITS_ROOT_RESOLUTION,
									bitsType->GetTypeLine(), bitsType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						case SIMCModule::TYPE_ENUM_OR_BITS:
							if(!bitsType->CheckClosure((SIMCEnumOrBitsType *)type))
							{
								SemanticError(fileName, 
									V2_BITS_ROOT_RESOLUTION,
									bitsType->GetTypeLine(), bitsType->GetTypeColumn());
								return FALSE;
							}
							else
								return TRUE;
						default:
							SemanticError(fileName, 
								V2_BITS_ROOT_RESOLUTION,
								bitsType->GetTypeLine(), bitsType->GetTypeColumn());
							return FALSE;
					}
				}
				break;
				default:
					SemanticError(fileName, 
						V2_BITS_ROOT_RESOLUTION,
						bitsType->GetTypeLine(), bitsType->GetTypeColumn());
					return FALSE;
			}
		}
	}


	POSITION pOuter = list->GetHeadPosition(), pInner;
	SIMCNamedNumberItem *current, *later;
	BOOL currentValid;

	while(pOuter)
	{
		current = list->GetNext(pOuter);
		int currentValue, laterValue;
		currentValid = TRUE;
		switch(SIMCModule::IsIntegerValue(current->_value, currentValue))
		{
			case RESOLVE_IMPORT:
				if(local)
					currentValid = FALSE;
				else
				{
					SemanticError(fileName, BITS_VALUE_RESOLUTION, 
						current->_valueLine, current->_valueColumn, 
						(*current->_value)->GetSymbolName());
					retVal = FALSE;
					currentValid = FALSE;
				}
				break;
			case RESOLVE_CORRECT:
				if (currentValue < 0 )
				{
					SemanticError(fileName, BITS_VALUE_RESOLUTION,
						current->_valueLine, current->_valueColumn, 
						current->_name);
					retVal = FALSE;
				}
				break;
			default:
				SemanticError(fileName, BITS_VALUE_RESOLUTION, 
					current->_valueLine, current->_valueColumn, 
					current->_name);
				retVal = FALSE;
				currentValid = FALSE;
		}

		// Check for duplicate names, duplicate values
		pInner = pOuter;
		while(pInner)
		{
			later = list->GetNext(pInner);
			if(strcmp(current->_name, later->_name) == 0 )
			{
				retVal = FALSE;
				SemanticError(fileName, BITS_DUPLICATE_NAME, 
					current->_nameLine, current->_nameColumn,
					current->_name);
			}
			if(currentValid)
			{
				switch(SIMCModule::IsIntegerValue(later->_value, laterValue))
				{
					case RESOLVE_CORRECT:
						if( laterValue == currentValue)
						{
							char buffer[20];
							retVal = FALSE;
							SemanticError(fileName, BITS_DUPLICATE_VALUE,
								later->_valueLine, later->_valueColumn,
								_itoa(laterValue, buffer, 10));
						}
						break;
					default:
						break;
				}
			}
		}
		
	}
	return retVal;
}

BOOL SIMCParseTree::CheckSequenceOfType(const char *const fileName,
			SIMCSequenceOfType *sequenceOfType, BOOL local)
{
	return TRUE;
}

BOOL SIMCParseTree::CheckSequenceType(const char *const fileName,
			SIMCSequenceType *sequenceOfType, BOOL local)
{
	return TRUE;
}


BOOL SIMCParseTree::CheckObjectSequenceOfTypeV1(const char *const fileName,
			SIMCObjectTypeV1 *objType,
			SIMCSequenceOfType *sequenceOfType, 
			BOOL local)
{
	SIMCIndexList *indexList = objType->GetIndexTypes();
	if(indexList && !indexList->IsEmpty())
			SemanticError(fileName, OBJ_TYPE_INDEX_UNNECESSARY,
				objType->GetIndexLine(), objType->GetIndexColumn());

	if( objType->GetAccess() != SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE)
		SemanticError(fileName, OBJ_TYPE_ACCESSIBLE_TABLE,
			objType->GetAccessLine(), objType->GetAccessColumn());

	SIMCSymbol **sequenceSymbol = sequenceOfType->GetType();
	SIMCTypeReference *btRef;
	switch(SIMCModule::IsTypeReference(sequenceSymbol, btRef))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, INVALID_SEQUENCE_OF,
					sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
					(*sequenceSymbol)->GetSymbolName());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
				SemanticError(fileName, INVALID_SEQUENCE_OF,
					sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
					(*sequenceSymbol)->GetSymbolName());
			return FALSE;
	}

	SIMCSymbol **tempBtRef = (SIMCSymbol **)&btRef;
	switch(SIMCModule::GetSymbolClass(tempBtRef) )
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass(((SIMCBuiltInTypeReference*)btRef)->GetType()))
			{
				case SIMCModule::TYPE_SEQUENCE:
					return TRUE;
				default:
					SemanticError(fileName, INVALID_SEQUENCE_OF,
						sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
						(*sequenceSymbol)->GetSymbolName());
					return FALSE;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SemanticError(fileName, INVALID_SEQUENCE_OF,
				sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
				(*sequenceSymbol)->GetSymbolName());
			return FALSE;
		}
		break;
	}
	return FALSE;
}

BOOL SIMCParseTree::CheckObjectSequenceOfTypeV2(const char *const fileName,
			SIMCObjectTypeV2 *objType,
			SIMCSequenceOfType *sequenceOfType, 
			BOOL local)
{
	SIMCIndexListV2 *indexList = objType->GetIndexTypes();
	if((indexList && !indexList->IsEmpty()) || objType->GetAugments())
			SemanticError(fileName, OBJ_TYPE_INDEX_UNNECESSARY,
				objType->GetIndexLine(), objType->GetIndexColumn());

	if( objType->GetAccess() != SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE)
		SemanticError(fileName, OBJ_TYPE_ACCESSIBLE_TABLE,
			objType->GetAccessLine(), objType->GetAccessColumn());

	SIMCSymbol **sequenceSymbol = sequenceOfType->GetType();
	SIMCTypeReference *typeRef;
	switch(SIMCModule::IsTypeReference(sequenceSymbol, typeRef))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, INVALID_SEQUENCE_OF,
					sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
					(*sequenceSymbol)->GetSymbolName());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
				SemanticError(fileName, INVALID_SEQUENCE_OF,
					sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
					(*sequenceSymbol)->GetSymbolName());
			return FALSE;
	}
	SIMCSymbol **tempTypeRef = (SIMCSymbol **)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass(((SIMCBuiltInTypeReference*)typeRef)->GetType()))
			{
				case SIMCModule::TYPE_SEQUENCE:
					return TRUE;
				default:
					SemanticError(fileName, INVALID_SEQUENCE_OF,
						sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
						(*sequenceSymbol)->GetSymbolName());
					return FALSE;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SemanticError(fileName, INVALID_SEQUENCE_OF,
				sequenceOfType->GetTypeLine(), sequenceOfType->GetTypeColumn(),
				(*sequenceSymbol)->GetSymbolName());
			return FALSE;
		}
		break;
	}
	return FALSE;
}

BOOL SIMCParseTree::CheckObjectSequenceTypeV1(const char *const fileName,
			SIMCObjectTypeV1 *objType,
			SIMCSequenceType *sequenceType, 
			BOOL local)
{
	if( objType->GetAccess() != SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE)
		SemanticError(fileName, OBJ_TYPE_ACCESSIBLE_ROW,
			objType->GetAccessLine(), objType->GetAccessColumn());
	return TRUE;
}

BOOL SIMCParseTree::CheckObjectSequenceTypeV2(const char *const fileName,
			SIMCObjectTypeV2 *objType,
			SIMCSequenceType *sequenceType, 
			BOOL local)
{
	if( objType->GetAccess() != SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE)
		SemanticError(fileName, OBJ_TYPE_ACCESSIBLE_ROW,
			objType->GetAccessLine(), objType->GetAccessColumn());
	return TRUE;
}

BOOL SIMCParseTree::CheckObjectTypeDefVal(const char *const fileName,
			SIMCObjectTypeType *objectType, BOOL local)
{

	switch(objectType->GetDefValStatus())
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
					objectType->GetDefValLine(), objectType->GetDefValColumn());
				return FALSE;
			}
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
				SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
					objectType->GetDefValLine(), objectType->GetDefValColumn());
			return FALSE;
	}
	
	SIMCSymbol **defVal = objectType->GetDefVal();

	// First Get the type in the Syntax clause
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef;

	switch(SIMCModule::IsTypeReference(syntax, typeRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
				return FALSE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			return FALSE;
	}

	SIMCModule::TypeClass syntaxType = SIMCModule::TYPE_INVALID;
	SIMCModule::PrimitiveType syntaxRootType = SIMCModule::PRIMITIVE_INVALID;
	SIMCType *type = NULL;
	SIMCEnumOrBitsType *enumType = NULL;
	SIMCRangeType *rangeType = NULL;
	SIMCSizeType *sizeType = NULL;
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol **)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			syntaxRootType = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
			syntaxType = SIMCModule::TYPE_PRIMITIVE;
			break;
	}
	 

	if(type)
	{
		switch(syntaxType = SIMCModule::GetTypeClass(type))
		{
			case SIMCModule::TYPE_PRIMITIVE:
			{
				syntaxRootType = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
				switch(syntaxRootType)
				{
					case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
						if(defVal)
							SemanticError(fileName, OBJ_TYPE_DEFVAL_NET_ADDR,
								objectType->GetDefValLine(), objectType->GetDefValColumn()
								);
						return TRUE;
					case SIMCModule::PRIMITIVE_INVALID:
						return FALSE;
				}
			}
			break;
			case SIMCModule::TYPE_SIZE:
			case SIMCModule::TYPE_RANGE:
			{
				switch( ((SIMCSubType*)type)->GetStatus())
				{
					case RESOLVE_IMPORT:
						if(local)
							return TRUE;
						else
							return FALSE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						return FALSE;
					case RESOLVE_CORRECT:
					{
						SIMCTypeReference * subTypeRoot = 
							((SIMCSubType*)type)->GetRootType();
						syntaxRootType = SIMCModule::GetPrimitiveType(subTypeRoot);
					}
					break;
				}
			}
			break;
			case SIMCModule::TYPE_ENUM_OR_BITS:
				switch(((SIMCEnumOrBitsType *)type)->GetEnumOrBitsType())
				{
					case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
						syntaxRootType = SIMCModule::PRIMITIVE_INTEGER;
						break;
					case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
						syntaxRootType = SIMCModule::PRIMITIVE_BITS;
						break;
					case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
						if(local)
							return TRUE;
						else
							return FALSE;
					default:
						return FALSE;
				}
				break;
			case SIMCModule::TYPE_INVALID:
			case SIMCModule::TYPE_TRAP_TYPE:
			case SIMCModule::TYPE_NOTIFICATION_TYPE:
			case SIMCModule::TYPE_OBJECT_TYPE_V1:
			case SIMCModule::TYPE_OBJECT_TYPE_V2:
			case SIMCModule::TYPE_OBJECT_IDENTITY:
				return FALSE;
			case SIMCModule::TYPE_SEQUENCE:
			case SIMCModule::TYPE_SEQUENCE_OF:
				if(defVal)
				{
					SemanticError(fileName, OBJ_TYPE_DEFVAL_DISALLOWED,
						objectType->GetDefValLine(), objectType->GetDefValColumn());
					return FALSE;
				}
				break;
		}

		switch(syntaxType)
		{
			case SIMCModule::TYPE_ENUM_OR_BITS:
				enumType = (SIMCEnumOrBitsType *)type;
				break;
			case SIMCModule::TYPE_RANGE:
				rangeType = (SIMCRangeType *)type;
				break;
			case SIMCModule::TYPE_SIZE:
				sizeType = (SIMCSizeType *)type;
				break;
		}
	}
	
	// Now you have the root type of syntax clause in syntaxRootType

	if(defVal) // This should have been set at the latest by SIMCParseTree::SetDefVal()
	{
		SIMCBuiltInValueReference *bValueRef;
		SIMCSymbol **defValueType;
		switch(SIMCModule::IsValueReference(defVal, defValueType, bValueRef ))
		{
			case RESOLVE_IMPORT:
				if(!local)
				{
					SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
						objectType->GetDefValLine(), objectType->GetDefValColumn());
					return FALSE;
				}
				else
					return TRUE;
				break;
			case RESOLVE_UNDEFINED:
			case RESOLVE_UNSET:
				SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
					objectType->GetDefValLine(), objectType->GetDefValColumn());
				return FALSE;
		}

		SIMCValue *value = bValueRef->GetValue(); 

		switch(SIMCModule::GetValueClass(value))
		{
			case SIMCModule::VALUE_INVALID:
			case SIMCModule::VALUE_BOOLEAN:
				SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
					objectType->GetDefValLine(), objectType->GetDefValColumn());
				return FALSE;

			case SIMCModule::VALUE_NULL:
				if(syntaxRootType != SIMCModule::PRIMITIVE_NULL)
				{
					SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
						objectType->GetDefValLine(), objectType->GetDefValColumn());
					return FALSE;
				}
				return TRUE;

			case SIMCModule::VALUE_OID:
				if(syntaxRootType != SIMCModule::PRIMITIVE_OID)
				{
					SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
						objectType->GetDefValLine(), objectType->GetDefValColumn());
					return FALSE;
				}
				return TRUE;
	
			case SIMCModule::VALUE_OCTET_STRING:
				switch(syntaxType)
				{
					case SIMCModule::TYPE_PRIMITIVE:
						switch(syntaxRootType)
						{
							case SIMCModule::PRIMITIVE_OCTET_STRING:
							case SIMCModule::PRIMITIVE_DISPLAY_STRING:
							case SIMCModule::PRIMITIVE_OPAQUE:
							case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
							case SIMCModule::PRIMITIVE_MAC_ADDRESS:
							case SIMCModule::PRIMITIVE_DATE_AND_TIME:
							case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
							case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:
							case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:
								return TRUE;

							case SIMCModule::PRIMITIVE_INTEGER:
							case SIMCModule::PRIMITIVE_UNSIGNED_32:
							case SIMCModule::PRIMITIVE_INTEGER_32:
							case SIMCModule::PRIMITIVE_IP_ADDRESS:
							case SIMCModule::PRIMITIVE_COUNTER:
							case SIMCModule::PRIMITIVE_GAUGE:
							case SIMCModule::PRIMITIVE_TIME_TICKS:
							case SIMCModule::PRIMITIVE_COUNTER_32:
							case SIMCModule::PRIMITIVE_COUNTER_64:
							case SIMCModule::PRIMITIVE_GAUGE_32:
							{
								SIMCOctetStringValue *octetValue = (SIMCOctetStringValue *)value;
								if(octetValue->GetNumberOfOctets() > 4)
								{
									SemanticError(fileName, INTEGER_TOO_BIG,
										value->GetLine(), value->GetColumn());
									return FALSE;
								}
							}

							return TRUE;
							default:
								SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
									objectType->GetDefValLine(), objectType->GetDefValColumn());
								return FALSE;
						}
					case SIMCModule::TYPE_RANGE:
					case SIMCModule::TYPE_ENUM_OR_BITS:
						SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
							objectType->GetDefValLine(), objectType->GetDefValColumn());
						return FALSE;
					case SIMCModule::TYPE_SIZE:
						return TRUE;
				}
			break;
			case SIMCModule::VALUE_BITS:
				switch(syntaxType)
				{
					case SIMCModule::TYPE_ENUM_OR_BITS:
					{
						// Check whether all the bit identifiers are valid
						SIMCBitValue *bitValue;
						const SIMCBitValueList * valueList = ((SIMCBitsValue *)value)->GetValueList();
						POSITION p = valueList->GetHeadPosition();
						SIMCEnumOrBitsType *bitsType = (SIMCEnumOrBitsType *)type;
						while(p)
						{
							bitValue = valueList->GetNext(p);
							if(! bitsType->GetValue(bitValue->_name) )
							{
								SemanticError(fileName, INVALID_BIT_VALUE,
									bitValue->_line, bitValue->_column,
									bitValue->_name);
								return FALSE;
							}
						}
						return TRUE;
					}
					default:
						SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
							objectType->GetDefValLine(), objectType->GetDefValColumn());
						return FALSE;
				}
				break;

			case SIMCModule::VALUE_INTEGER:
				switch(syntaxType)
				{
					case SIMCModule::TYPE_PRIMITIVE:
						switch(syntaxRootType)
						{
							case SIMCModule::PRIMITIVE_INTEGER:
							case SIMCModule::PRIMITIVE_INTEGER_32:
								return TRUE;
							case SIMCModule::PRIMITIVE_COUNTER:
							case SIMCModule::PRIMITIVE_GAUGE:
							case SIMCModule::PRIMITIVE_TIME_TICKS:
							case SIMCModule::PRIMITIVE_GAUGE_32:
							case SIMCModule::PRIMITIVE_UNSIGNED_32:
							case SIMCModule::PRIMITIVE_COUNTER_32:
							case SIMCModule::PRIMITIVE_COUNTER_64:
								if( ((SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
								{
									if(!((SIMCIntegerValue*)value)->IsUnsigned())
										/*
 									{
										SemanticError(fileName, INTEGER_TOO_BIG,
											objectType->GetDefValLine(), objectType->GetDefValColumn());
										return FALSE;
									}
									else
									*/
									{
										SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
											objectType->GetDefValLine(), objectType->GetDefValColumn());
										return FALSE;
									}
								}
								return TRUE;
							default:
								SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
									objectType->GetDefValLine(), objectType->GetDefValColumn());
								return FALSE;
						}
					case SIMCModule::TYPE_ENUM_OR_BITS:
					{
						char *dummy;
						switch(enumType->GetIdentifier( ((SIMCIntegerValue*)value)->GetIntegerValue(), dummy))
						{
							case RESOLVE_IMPORT:
								if(local)
									return TRUE;
								else
								{
									SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
										objectType->GetDefValLine(), objectType->GetDefValColumn());
									return FALSE;
								}
							case RESOLVE_UNSET:
							case RESOLVE_UNDEFINED:
								SemanticError(fileName, OBJ_TYPE_DEFVAL_RESOLUTION,
									objectType->GetDefValLine(), objectType->GetDefValColumn());
								return FALSE;
						}
						return TRUE;
					}
					case SIMCModule::TYPE_RANGE:
						return TRUE;
					case SIMCModule::TYPE_SIZE:
						SemanticError(fileName, OBJ_TYPE_INVALID_DEFVAL,
							objectType->GetDefValLine(), objectType->GetDefValColumn());
						return FALSE;
				}
		}
	}
	return TRUE;
}
					
	
BOOL SIMCParseTree::CheckObjectTypeV1Index(const char *const fileName,
			SIMCSymbol *objectTypeSymbol,
			SIMCObjectTypeV1 *objectType, BOOL local)
{
	BOOL retVal = TRUE;
	SIMCIndexList * indexList = objectType->GetIndexTypes();
	if(!indexList )
		return TRUE;

	SIMCSymbol **symbol;
	POSITION p = indexList->GetHeadPosition();
	
	SIMCIndexItem *indexItem;
	SIMCTypeReference *typeRef = NULL;
	while(p)
	{
		indexItem = indexList->GetNext(p);
		symbol = indexItem->_item;
		switch(SIMCModule::GetSymbolClass(symbol))
		{
			case SIMCModule::SYMBOL_IMPORT:
				if(local)
					return TRUE;
				else
				{
					SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
						indexItem->_line, indexItem->_column,
						(*symbol)->GetSymbolName()); 
					return FALSE;
				}
			case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
				typeRef = (SIMCTypeReference *)(*symbol); 
				break;			
			case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
			case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
				switch( ((SIMCDefinedTypeReference*)(*symbol))->GetStatus() )
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName()); 
							return FALSE;
						}
						else
							return TRUE;
						break;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						return FALSE;
					case RESOLVE_CORRECT:
					{
						typeRef = ((SIMCDefinedTypeReference*)(symbol))->GetRealType();
						break;
					}
				}
				break;
			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			{
				// See if it is an OBJECT-TYPE
				SIMCObjectTypeType *indexObject;
				switch(SIMCModule::IsObjectType(symbol, indexObject))
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
							return FALSE;
						}
						else
							return TRUE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						return FALSE;
				}
				// Add the current object to the list of objects indexed by "indexObject"
				indexObject->AddIndexedObjectType(objectTypeSymbol);
				SIMCSymbol **objectSyntax = indexObject->GetSyntax();
				switch( SIMCModule::IsTypeReference(objectSyntax, typeRef))
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_SYNTAX,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName());
							return FALSE;
						}
						else
							return TRUE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_SYNTAX,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName());
						return FALSE;
				}
			}
			break;
			default:
				SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
					indexItem->_line, indexItem->_column,
					(*symbol)->GetSymbolName()); 
				return FALSE;
		}


		SIMCSymbol **tempTypeRef = (SIMCSymbol **)&typeRef;
		switch(SIMCModule::GetSymbolClass(tempTypeRef))
		{
			case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			{
				SIMCType *type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
				switch(SIMCModule::GetTypeClass(type))
				{
					case SIMCModule::TYPE_PRIMITIVE:
						if(SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_NULL)
						{
							retVal = FALSE;
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName()); 
						}
						break;
					case SIMCModule::TYPE_SIZE:
					case SIMCModule::TYPE_RANGE:
					case SIMCModule::TYPE_ENUM_OR_BITS:
						break;
					case SIMCModule::TYPE_INVALID:
					case SIMCModule::TYPE_TRAP_TYPE:
					case SIMCModule::TYPE_NOTIFICATION_TYPE:
					case SIMCModule::TYPE_OBJECT_TYPE_V1:
					case SIMCModule::TYPE_OBJECT_TYPE_V2:
					case SIMCModule::TYPE_OBJECT_IDENTITY:
					case SIMCModule::TYPE_SEQUENCE:
					case SIMCModule::TYPE_SEQUENCE_OF:
						retVal = FALSE;
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						break;
				}
			}
			break;
			case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			{
				return TRUE;
			}
			break;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckObjectTypeV2Index(const char *const fileName,
			SIMCSymbol *objectTypeSymbol,
			SIMCObjectTypeV2 *objectType, BOOL local)
{
	BOOL retVal = TRUE;
	SIMCSymbol ** augmentsSymbol = objectType->GetAugments();
	if(augmentsSymbol)
	{
		// Check to see if the thing that is augmented is really a table.
		switch(SIMCModule::IsRow(augmentsSymbol))
		{
			case RESOLVE_UNSET:
			case RESOLVE_UNDEFINED:
			{
				SemanticError(fileName, AUGMENTS_CLAUSE_RESOLUTION,
						objectType->GetAugmentsLine(), objectType->GetAugmentsColumn(),
						(*augmentsSymbol)->GetSymbolName());
				return FALSE;
			}
			break;

			case RESOLVE_IMPORT:
				if(local)
					return TRUE;
				else
				{
					SemanticError(fileName, AUGMENTS_CLAUSE_RESOLUTION,
							objectType->GetAugmentsLine(), objectType->GetAugmentsColumn(),
						(*augmentsSymbol)->GetSymbolName());
					return FALSE;
				}
			break;
			case RESOLVE_CORRECT:
				return TRUE;
		}
	}

	SIMCIndexListV2 * indexList = objectType->GetIndexTypes();
	if(!indexList )
		return TRUE;

	SIMCSymbol **symbol;
	POSITION p = indexList->GetHeadPosition();
	
	SIMCIndexItemV2 *indexItem;
	SIMCTypeReference *typeRef = NULL;

	while(p)
	{
		indexItem = indexList->GetNext(p);
		symbol = indexItem->_item;

		switch(SIMCModule::GetSymbolClass(symbol))
		{
			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			{
				// See if it is an OBJECT-TYPE
				SIMCObjectTypeType *indexObject;
				switch(SIMCModule::IsObjectType(symbol, indexObject))
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
							return FALSE;
						}
						else
							return TRUE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						return FALSE;
				}

				// If it is the IMPLIED object, check its semantics
				if(indexItem->_implied)
				{
					// See if it is the last item in  the list
					if(indexItem != indexList->GetTail())
					{
						SemanticError(fileName, IMPLIED_USELESS,
							indexItem->_line, indexItem->_column);
					}
					else
					{
						// See if it is of fixed size
						switch(SIMCModule::IsFixedSizeObject(indexObject))
						{
							case RESOLVE_UNDEFINED:
							case RESOLVE_UNSET:
							case RESOLVE_CORRECT:
								SemanticError(fileName, IMPLIED_FIXED_SIZE,
									indexItem->_line, indexItem->_column);
								return FALSE;
								break;
							case RESOLVE_IMPORT:
								if(!local)
								{
									SemanticError(fileName, IMPLIED_FIXED_SIZE,
										indexItem->_line, indexItem->_column);
									return FALSE;
								}
								break;
						}

						// See if it's length can be zero
						switch(SIMCModule::IsNotZeroSizeObject(indexObject))
						{
							case RESOLVE_UNDEFINED:
							case RESOLVE_UNSET:
							case RESOLVE_FALSE:
								SemanticError(fileName, IMPLIED_POSSIBLE_ZERO_SIZE,
									indexItem->_line, indexItem->_column);
								return FALSE;
								break;
							case RESOLVE_IMPORT:
								if(!local)
								{
									SemanticError(fileName, IMPLIED_POSSIBLE_ZERO_SIZE,
										indexItem->_line, indexItem->_column);
									return FALSE;
								}
								break;
						}
					}				
				}
				
				// Add the current object to the list of objects indexed by "indexObject"
				indexObject->AddIndexedObjectType(objectTypeSymbol);
				SIMCSymbol **objectSyntax = indexObject->GetSyntax();
				switch( SIMCModule::IsTypeReference(objectSyntax, typeRef))
				{
					case RESOLVE_IMPORT:
						if(!local)
						{
							SemanticError(fileName, OBJ_TYPE_INDEX_SYNTAX,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName());
							return FALSE;
						}
						else
							return TRUE;
					case RESOLVE_UNDEFINED:
					case RESOLVE_UNSET:
						SemanticError(fileName, OBJ_TYPE_INDEX_SYNTAX,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName());
						return FALSE;
				}
			}
			break;
			case SIMCModule::SYMBOL_IMPORT:
				if(local)
					return TRUE;
				else
				{
					SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
						indexItem->_line, indexItem->_column,
						(*symbol)->GetSymbolName()); 
					return FALSE;
				}
			default:
				SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
					indexItem->_line, indexItem->_column,
					(*symbol)->GetSymbolName()); 
				return FALSE;
		}


		SIMCSymbol ** tempTypeRef =  (SIMCSymbol **)&typeRef;
		switch(SIMCModule::GetSymbolClass(tempTypeRef))
		{
			case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			{
				SIMCType *type = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
				switch(SIMCModule::GetTypeClass(type))
				{
					case SIMCModule::TYPE_PRIMITIVE:
						if(SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_NULL)
						{
							retVal = FALSE;
							SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
								indexItem->_line, indexItem->_column,
								(*symbol)->GetSymbolName()); 
						}
						break;
					case SIMCModule::TYPE_SIZE:
					case SIMCModule::TYPE_RANGE:
					case SIMCModule::TYPE_ENUM_OR_BITS:
						break;
					case SIMCModule::TYPE_INVALID:
					case SIMCModule::TYPE_TRAP_TYPE:
					case SIMCModule::TYPE_NOTIFICATION_TYPE:
					case SIMCModule::TYPE_OBJECT_TYPE_V1:
					case SIMCModule::TYPE_OBJECT_TYPE_V2:
					case SIMCModule::TYPE_OBJECT_IDENTITY:
					case SIMCModule::TYPE_SEQUENCE:
					case SIMCModule::TYPE_SEQUENCE_OF:
						retVal = FALSE;
						SemanticError(fileName, OBJ_TYPE_INDEX_RESOLUTION,
							indexItem->_line, indexItem->_column,
							(*symbol)->GetSymbolName()); 
						break;
				}
			}
			break;
			case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			{
				return TRUE;
			}
			break;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckObjectTypeV1Syntax(const char *const fileName,
			SIMCObjectTypeV1 *objectType, BOOL local)
{
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef  = NULL;
	SIMCIndexList* indexList = objectType->GetIndexTypes();
	BOOL indexPresent = FALSE;
	if(indexList && !indexList->IsEmpty())
		indexPresent = TRUE;

	switch(SIMCModule::GetSymbolClass(syntax))
	{
		case SIMCModule::SYMBOL_IMPORT:

			if(!local)
			{
				SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
				return FALSE;
			}
			return TRUE;

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF: 
			typeRef = (SIMCBuiltInTypeReference *)(*syntax);
			break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SIMCDefinedTypeReference * defTypeRef = (SIMCDefinedTypeReference*)(*syntax);
			switch(defTypeRef->GetStatus())
			{
				case RESOLVE_IMPORT:
					if(!local)
					{
						SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
						return FALSE;
					}
					else
						return TRUE;
					break;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
					return FALSE;
					break;
				case RESOLVE_CORRECT:
					typeRef = defTypeRef->GetRealType();
			}
			break;
		}
		default:
			SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
				objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
			return FALSE;
	}
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol**)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{

			SIMCType *type = ((SIMCBuiltInTypeReference*)typeRef)->GetType();
			switch(SIMCModule::GetTypeClass(type))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					if(SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_BOOLEAN )
					{
						SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
						return FALSE;
					}

				case SIMCModule::TYPE_SIZE:
				case SIMCModule::TYPE_RANGE:
				case SIMCModule::TYPE_ENUM_OR_BITS:
					if(indexPresent)
						SemanticError(fileName, OBJ_TYPE_INDEX_UNNECESSARY,
							objectType->GetIndexLine(), objectType->GetIndexColumn());
					return TRUE;
				case SIMCModule::TYPE_INVALID:
				case SIMCModule::TYPE_TRAP_TYPE:
				case SIMCModule::TYPE_NOTIFICATION_TYPE:
				case SIMCModule::TYPE_OBJECT_TYPE_V1:
				case SIMCModule::TYPE_OBJECT_IDENTITY:
					SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
					return FALSE;
				case SIMCModule::TYPE_SEQUENCE:
					return CheckObjectSequenceTypeV1(fileName, objectType, (SIMCSequenceType *)type, local);
				case SIMCModule::TYPE_SEQUENCE_OF:
					return CheckObjectSequenceOfTypeV1(fileName, objectType, (SIMCSequenceOfType *)type, local);
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			return TRUE;
	}
	return FALSE;
}


BOOL SIMCParseTree::CheckObjectTypeV2Syntax(const char *const fileName,
			SIMCObjectTypeV2 *objectType, BOOL local)
{
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef  = NULL;
	SIMCIndexListV2 * indexList = objectType->GetIndexTypes();
	BOOL indexPresent = FALSE;
	if(indexList && !indexList->IsEmpty())
		indexPresent = TRUE;

	switch(SIMCModule::GetSymbolClass(syntax))
	{
		case SIMCModule::SYMBOL_IMPORT:

			if(!local)
			{
				SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
				return FALSE;
			}
			return TRUE;

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF: 
			typeRef = (SIMCBuiltInTypeReference *)(*syntax);
			break;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			SIMCDefinedTypeReference * defTypeRef = (SIMCDefinedTypeReference*)(*syntax);
			switch(defTypeRef->GetStatus())
			{
				case RESOLVE_IMPORT:
					if(!local)
					{
						SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
						return FALSE;
					}
					else
						return TRUE;
					break;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
						objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
					return FALSE;
					break;
				case RESOLVE_CORRECT:
					typeRef = defTypeRef->GetRealType();
			}
			break;
		}
		default:
			SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
				objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
			return FALSE;
	}

	SIMCSymbol **tempTypeRef = (SIMCSymbol**)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{

			SIMCType *type = ((SIMCBuiltInTypeReference*)typeRef)->GetType();
			switch(SIMCModule::GetTypeClass(type))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					if(SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_BOOLEAN )
					{
						SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
							objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
						return FALSE;
					}

				case SIMCModule::TYPE_SIZE:
				case SIMCModule::TYPE_RANGE:
				case SIMCModule::TYPE_ENUM_OR_BITS:
					if(indexPresent)
						SemanticError(fileName, OBJ_TYPE_INDEX_UNNECESSARY,
							objectType->GetIndexLine(), objectType->GetIndexColumn());
					return TRUE;
				case SIMCModule::TYPE_INVALID:
				case SIMCModule::TYPE_TRAP_TYPE:
				case SIMCModule::TYPE_NOTIFICATION_TYPE:
				case SIMCModule::TYPE_OBJECT_TYPE_V1:
				case SIMCModule::TYPE_OBJECT_IDENTITY:
					SemanticError(fileName, OBJ_TYPE_SYNTAX_RESOLUTION,
						objectType->GetSyntaxLine(), objectType->GetSyntaxColumn());
					return FALSE;
				case SIMCModule::TYPE_SEQUENCE:
					return CheckObjectSequenceTypeV2(fileName, objectType, (SIMCSequenceType *)type, local);
				case SIMCModule::TYPE_SEQUENCE_OF:
					return CheckObjectSequenceOfTypeV2(fileName, objectType, (SIMCSequenceOfType *)type, local);
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			return TRUE;
	}
	return FALSE;
}


BOOL SIMCParseTree::CheckObjectTypeV1(const char *const fileName,
			SIMCObjectTypeV1 *objectType, BOOL local)
{
	BOOL retVal = TRUE;
	retVal = CheckObjectTypeV1Syntax(fileName, objectType, local) && retVal;
	// Index clause is checked from a call in CheckObjectTypeValueAssignment()
	// retVal = CheckObjectTypeV1Index(fileName, objectType, local) && retVal;
	retVal = CheckObjectTypeDefVal(fileName, objectType, local) && retVal;
	return retVal;
}

BOOL SIMCParseTree::CheckObjectTypeV2(const char *const fileName,
			SIMCObjectTypeV2 *objectType, BOOL local)
{
	BOOL retVal = TRUE;
	retVal = CheckObjectTypeV2Syntax(fileName, objectType, local) && retVal;
	// Index clause is checked from a call in CheckObjectTypeValueAssignment()
	// retVal = CheckObjectTypeV1Index(fileName, objectType, local) && retVal;

	retVal = CheckObjectTypeDefVal(fileName, objectType, local) && retVal;
	return retVal;
}

BOOL SIMCParseTree::CheckObjectIdentityType(const char *const fileName, 
			SIMCObjectIdentityType *rhs, BOOL local)
{
	return TRUE;
}

BOOL SIMCParseTree::CheckTrapType(const char *const fileName,
			SIMCTrapTypeType *trapType, BOOL local)
{
	BOOL retVal = TRUE;
	
	SIMCSymbol **enterprise = trapType->GetEnterprise();
	SIMCOidValue *oidValue;
	switch(SIMCModule::IsObjectIdentifierValue(enterprise, oidValue))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, TRAP_TYPE_ENTERPRISE_RESOLUTION,
					(*enterprise)->GetLineNumber(), (*enterprise)->GetColumnNumber(),
					(*enterprise)->GetSymbolName());
				retVal = FALSE;
			}
			break;
		case RESOLVE_CORRECT:
			break;
		default:
			SemanticError(fileName, TRAP_TYPE_ENTERPRISE_RESOLUTION,
				(*enterprise)->GetLineNumber(), (*enterprise)->GetColumnNumber(),
				(*enterprise)->GetSymbolName());
				retVal = FALSE;
	}
	
	SIMCVariablesList *variables = trapType->GetVariables();
	POSITION p = variables->GetHeadPosition();
	SIMCSymbol **variable;
	SIMCVariablesItem *variablesItem;
	SIMCObjectTypeType *objType;
	while(p)
	{
		variablesItem = variables->GetNext(p);
		variable = variablesItem->_item;
		switch(SIMCModule::IsObjectType(variable, objType))
		{
			case RESOLVE_IMPORT:
				if(!local)
					SemanticError(fileName, TRAP_TYPE_VARIABLES_RESOLUTION,
						variablesItem->_line, variablesItem->_column,
						(*variable)->GetSymbolName());
				break;
			case RESOLVE_UNDEFINED:
			case RESOLVE_UNSET:
				SemanticError(fileName, TRAP_TYPE_VARIABLES_RESOLUTION,
					variablesItem->_line, variablesItem->_column,
					(*variable)->GetSymbolName());
				break;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckNotificationType(const char *const fileName,
			SIMCNotificationTypeType *notificationType, BOOL local)
{
	BOOL retVal = TRUE;
	
	SIMCObjectsList *objects = notificationType->GetObjects();
	POSITION p = objects->GetHeadPosition();
	SIMCSymbol **object;
	SIMCObjectsItem *objectsItem;
	SIMCObjectTypeType *objType;
	BOOL isImportSymbol = FALSE;
	while(p)
	{
		isImportSymbol = FALSE;
		objectsItem = objects->GetNext(p);
		object = objectsItem->_item;
		switch(SIMCModule::IsObjectType(object, objType))
		{
			case RESOLVE_IMPORT:
				if(!local)
				{
					SemanticError(fileName, NOTIFICATION_TYPE_OBJECTS_RESOLUTION,
						objectsItem->_line, objectsItem->_column,
						(*object)->GetSymbolName());
					retVal = FALSE;
				}
				isImportSymbol = TRUE;
				break;
			case RESOLVE_UNDEFINED:
			case RESOLVE_UNSET:
				SemanticError(fileName, NOTIFICATION_TYPE_OBJECTS_RESOLUTION,
					objectsItem->_line, objectsItem->_column,
					(*object)->GetSymbolName());
				retVal = FALSE;
				break;
		}

		// Skip further checking since we dont know anything about this imported symbol
		if(isImportSymbol)
			continue;

		SIMCModule::TypeClass typeClass = SIMCModule::GetTypeClass(objType);
		switch(typeClass)
		{
			case SIMCModule::TYPE_OBJECT_TYPE_V1:
				if( ((SIMCObjectTypeV1*)objType)->GetAccess() == SIMCObjectTypeV1::ACCESS_NOT_ACCESSIBLE)
				{
					SemanticError(fileName, NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT,
						(*object)->GetLineNumber(), (*object)->GetColumnNumber(),
						(*object)->GetSymbolName());
					
					retVal = FALSE;
				}
				break;
			case SIMCModule::TYPE_OBJECT_TYPE_V2:
				if( ((SIMCObjectTypeV2*)objType)->GetAccess() == SIMCObjectTypeV2::ACCESS_NOT_ACCESSIBLE)
				{
					SemanticError(fileName, NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT,
						(*object)->GetLineNumber(), (*object)->GetColumnNumber(),
						(*object)->GetSymbolName());
					
					retVal = FALSE;
				}
				break;
			default:
				retVal = FALSE;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckBuiltInTypeRef(SIMCBuiltInTypeReference *symbol, BOOL local)
{
	const char *const fileName = (symbol->GetModule())->GetInputFileName();

	SIMCType *rhs = symbol->GetType();
	SIMCModule *module = symbol->GetModule();
	if(symbol->GetReferenceCount() == 0)
	{
		if(!SIMCParser::IsReservedSymbol(_snmpVersion, symbol->GetSymbolName(), module->GetModuleName()))
			SemanticError(fileName, TYPE_UNREFERENCED,
				symbol->GetLineNumber(), symbol->GetColumnNumber(),
				symbol->GetSymbolName());
	}
	
	switch(SIMCModule::GetTypeClass(rhs))
	{
		case SIMCModule::TYPE_INVALID:
			return FALSE;
		case SIMCModule::TYPE_PRIMITIVE:
			return TRUE;
		case SIMCModule::TYPE_RANGE:
			switch(_snmpVersion)
			{
				case 1:
					return CheckRangeTypeV1( fileName, (SIMCRangeType *)rhs, local );
				case 2:
					return CheckRangeTypeV2( fileName, (SIMCRangeType *)rhs, local );
				default:
					return CheckRangeTypeV0( fileName, (SIMCRangeType *)rhs, local );

			}
		case SIMCModule::TYPE_SIZE:
			switch(_snmpVersion)
			{
				case 1:
					return CheckSizeTypeV1( fileName, (SIMCSizeType *)rhs, local );
				case 2:
					return CheckSizeTypeV2( fileName, (SIMCSizeType *)rhs, local );
				default:
					return CheckSizeTypeV0( fileName, (SIMCSizeType *)rhs, local );
			}
		case SIMCModule::TYPE_ENUM_OR_BITS:
			switch(((SIMCEnumOrBitsType *)rhs)->GetEnumOrBitsType())
			{
				case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
					{
						switch(_snmpVersion)
						{
							case 1:
								return CheckEnumTypeV1( fileName, (SIMCEnumOrBitsType *)rhs, local );
							case 2:
								return CheckEnumTypeV2( fileName, (SIMCEnumOrBitsType *)rhs, local );
							default:
								return CheckEnumTypeV0( fileName, (SIMCEnumOrBitsType *)rhs, local );
						}
					}
				case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
					return CheckBitsTypeV2( fileName, (SIMCEnumOrBitsType *)rhs, local );
				case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
					if(local)
						return TRUE;
					else
					{
						SemanticError( fileName,
							ENUM_OR_BITS_RESOLUTION,
							((SIMCSubType *)rhs)->GetTypeLine(),
							((SIMCSubType *)rhs)->GetTypeColumn());
						return FALSE;
					}
				default:
					if(local)
						return TRUE;
					else
					{
						SemanticError( fileName,
							ENUM_OR_BITS_RESOLUTION,
							((SIMCSubType *)rhs)->GetTypeLine(),
							((SIMCSubType *)rhs)->GetTypeColumn());
						return FALSE;
					}
			}
			break;
		case SIMCModule::TYPE_SEQUENCE_OF:
			return CheckSequenceOfType( fileName, (SIMCSequenceOfType *)rhs, local );
		case SIMCModule::TYPE_SEQUENCE:
			return CheckSequenceType( fileName, (SIMCSequenceType *)rhs, local );
		case SIMCModule::TYPE_TRAP_TYPE:
			return CheckTrapType(fileName, (SIMCTrapTypeType *)rhs, local);
		case SIMCModule::TYPE_NOTIFICATION_TYPE:
			return CheckNotificationType(fileName, (SIMCNotificationTypeType *)rhs, local);
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			return CheckObjectTypeV1(fileName, (SIMCObjectTypeV1 *)rhs, local);
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			return CheckObjectTypeV2(fileName, (SIMCObjectTypeV2 *)rhs, local);
		case SIMCModule::TYPE_OBJECT_IDENTITY:
			return CheckObjectIdentityType(fileName, (SIMCObjectIdentityType *)rhs, local);
	}
	return FALSE;
}

BOOL SIMCParseTree::CheckDefinedTypeRef(SIMCDefinedTypeReference *symbol, BOOL local)
{
	const SIMCModule *module = symbol->GetModule();
	const char *const fileName = module->GetInputFileName();
	
	if(symbol->GetReferenceCount() == 0)
	{
		if(!SIMCParser::IsReservedSymbol(_snmpVersion, symbol->GetSymbolName(), module->GetModuleName()))
			SemanticError(fileName, TYPE_UNREFERENCED,
				symbol->GetLineNumber(), symbol->GetColumnNumber(),
				symbol->GetSymbolName());
	}

	switch(symbol->GetStatus())
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, TYPE_UNRESOLVED,
					symbol->GetLineNumber(), symbol->GetColumnNumber(),
					symbol->GetSymbolName());
				return FALSE;
			}
			return TRUE;
		case RESOLVE_CORRECT:
			return TRUE;
		default:
			SemanticError(fileName, TYPE_UNRESOLVED,
				symbol->GetLineNumber(), symbol->GetColumnNumber(),
				symbol->GetSymbolName());
				return FALSE;
	}
	return FALSE;
}

BOOL SIMCParseTree::CheckTextualConvention(SIMCTextualConvention *symbol, BOOL local)
{
	return TRUE;
}


BOOL SIMCParseTree::MatchSequenceObjectTypeSyntax(const char *const fileName,
			SIMCObjectTypeType *objectType, 
			SIMCTypeReference *typeRef,
			SIMCSequenceItem *item,
			BOOL local)
{

	SIMCModule::PrimitiveType type = SIMCModule::PRIMITIVE_INVALID;
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol**)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			switch(SIMCModule::GetTypeClass(((SIMCBuiltInTypeReference*)typeRef)->GetType()))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					type = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
					break;
				
				case SIMCModule::TYPE_ENUM_OR_BITS:
				{
					SIMCEnumOrBitsType *enumType = 
							(SIMCEnumOrBitsType *) ((SIMCBuiltInTypeReference*)typeRef)->GetType();
					switch( enumType->GetEnumOrBitsType())
					{
						case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
							type = SIMCModule::PRIMITIVE_INTEGER;
							break;
						case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
							type = SIMCModule::PRIMITIVE_BITS;
							break;
						case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
							if(local)
								return TRUE;
							else
							{
								SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
									item->_typeLine, item->_typeColumn,
									(*item->_type)->GetSymbolName());
								return FALSE;
							}
						default:
								SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
									item->_typeLine, item->_typeColumn,
									(*item->_type)->GetSymbolName());
								return FALSE;
					}


				}
				case SIMCModule::TYPE_RANGE:
				case SIMCModule::TYPE_SIZE:
				{
					SIMCSubType *subType = (SIMCSubType *)(((SIMCBuiltInTypeReference *)typeRef)->GetType());
					switch(subType->GetStatus())
					{
						case RESOLVE_IMPORT:
							if(!local)
							{
								SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
									item->_typeLine, item->_typeColumn,
									(*item->_type)->GetSymbolName());
								return FALSE;
							}
						case RESOLVE_UNSET:
						case RESOLVE_UNDEFINED:
							SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
								item->_typeLine, item->_typeColumn,
								(*item->_type)->GetSymbolName());
							return FALSE;
						case RESOLVE_CORRECT:
						{
							SIMCTypeReference *rootTypeRef = subType->GetRootType();
							type = SIMCModule::GetPrimitiveType(rootTypeRef);
						}
						break;
					}	
				}
				break;
				case SIMCModule::TYPE_SEQUENCE_OF:
				case SIMCModule::TYPE_SEQUENCE:
				case SIMCModule::TYPE_TRAP_TYPE:
				case SIMCModule::TYPE_NOTIFICATION_TYPE:
				case SIMCModule::TYPE_OBJECT_TYPE_V1:
				case SIMCModule::TYPE_OBJECT_TYPE_V2:
				case SIMCModule::TYPE_OBJECT_IDENTITY:
				case SIMCModule::TYPE_INVALID:
					SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
						item->_typeLine, item->_typeColumn,
						(*item->_type)->GetSymbolName());
					return FALSE;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{	
			type = SIMCModule::GetPrimitiveType(typeRef->GetSymbolName());
		}
		break;
	}
	// Now see if the root of the syntax of the object type matches  "type"
	SIMCSymbol ** syntaxSymbol = objectType->GetSyntax();
	SIMCTypeReference *syntaxTypeRef;
	switch(SIMCModule::IsTypeReference(syntaxSymbol, syntaxTypeRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
				return FALSE;
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			return FALSE;
	}

	SIMCSymbol** tempSyntaxTypeRef = (SIMCSymbol**) (&syntaxTypeRef) ;
	//switch(SIMCModule::GetSymbolClass( (SIMCSymbol**)(&syntaxTypeRef) )	)
	switch(SIMCModule::GetSymbolClass( tempSyntaxTypeRef ))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCBuiltInTypeReference *syntaxBTRef = (SIMCBuiltInTypeReference*)syntaxTypeRef;
			switch(SIMCModule::GetTypeClass(syntaxBTRef->GetType()))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					switch(SIMCModule::GetPrimitiveType(syntaxBTRef->GetSymbolName()))
					{
						case SIMCModule::PRIMITIVE_INVALID:
							SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
								item->_valueLine, item->_valueColumn,
								(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
							return FALSE;
						case SIMCModule::PRIMITIVE_INTEGER:
						case SIMCModule::PRIMITIVE_COUNTER:
						case SIMCModule::PRIMITIVE_GAUGE:
						case SIMCModule::PRIMITIVE_TIME_TICKS:
						case SIMCModule::PRIMITIVE_INTEGER_32:
						case SIMCModule::PRIMITIVE_UNSIGNED_32:
						case SIMCModule::PRIMITIVE_GAUGE_32:
						case SIMCModule::PRIMITIVE_COUNTER_32:
						case SIMCModule::PRIMITIVE_COUNTER_64:
							if(	type == SIMCModule::PRIMITIVE_INTEGER	||
								type == SIMCModule::PRIMITIVE_COUNTER	||
								type == SIMCModule::PRIMITIVE_GAUGE		||
								type == SIMCModule::PRIMITIVE_TIME_TICKS||
								type == SIMCModule::PRIMITIVE_INTEGER_32||
								type == SIMCModule::PRIMITIVE_UNSIGNED_32||
								type == SIMCModule::PRIMITIVE_GAUGE_32	||
								type == SIMCModule::PRIMITIVE_COUNTER_32||
								type == SIMCModule::PRIMITIVE_COUNTER_64)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}

						case SIMCModule::PRIMITIVE_OCTET_STRING:
						case SIMCModule::PRIMITIVE_DISPLAY_STRING:
						case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
						case SIMCModule::PRIMITIVE_OPAQUE:
						case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
						case SIMCModule::PRIMITIVE_MAC_ADDRESS:
						case SIMCModule::PRIMITIVE_IP_ADDRESS:
						case SIMCModule::PRIMITIVE_DATE_AND_TIME:
						case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
						case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
						case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
							if(	type == SIMCModule::PRIMITIVE_OCTET_STRING		||
								type == SIMCModule::PRIMITIVE_DISPLAY_STRING	||
								type == SIMCModule::PRIMITIVE_PHYS_ADDRESS		||
								type == SIMCModule::PRIMITIVE_OPAQUE			||
								type == SIMCModule::PRIMITIVE_NETWORK_ADDRESS	||
								type == SIMCModule::PRIMITIVE_MAC_ADDRESS		||
								type == SIMCModule::PRIMITIVE_IP_ADDRESS		||
								type == SIMCModule::PRIMITIVE_DATE_AND_TIME		||
								type == SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	||
								type == SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	||
								type == SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						case SIMCModule::PRIMITIVE_OID:
							if(type == SIMCModule::PRIMITIVE_OID)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}

						case SIMCModule::PRIMITIVE_BOOLEAN:
							if(type == SIMCModule::PRIMITIVE_BOOLEAN)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						case SIMCModule::PRIMITIVE_NULL:
							if(type == SIMCModule::PRIMITIVE_NULL)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
					}
					break;
				case SIMCModule::TYPE_RANGE:
				case SIMCModule::TYPE_SIZE:
				{
					SIMCSubType *subType = (SIMCSubType *)(syntaxBTRef->GetType());
					switch(subType->GetStatus())
					{
						case RESOLVE_IMPORT:
							if(local)
								return TRUE;
							else
								return FALSE;
						case RESOLVE_UNSET:
						case RESOLVE_UNDEFINED:
							return FALSE;
					}
					SIMCTypeReference *rootTypeRef = subType->GetRootType();
					switch(SIMCModule::GetPrimitiveType(rootTypeRef))
					{
						case SIMCModule::PRIMITIVE_INVALID:
							SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
								item->_valueLine, item->_valueColumn,
								(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
							return FALSE;
						case SIMCModule::PRIMITIVE_INTEGER:
						case SIMCModule::PRIMITIVE_COUNTER:
						case SIMCModule::PRIMITIVE_GAUGE:
						case SIMCModule::PRIMITIVE_TIME_TICKS:
						case SIMCModule::PRIMITIVE_INTEGER_32:
						case SIMCModule::PRIMITIVE_UNSIGNED_32:
						case SIMCModule::PRIMITIVE_GAUGE_32:
						case SIMCModule::PRIMITIVE_COUNTER_32:
						case SIMCModule::PRIMITIVE_COUNTER_64:
							if(	type == SIMCModule::PRIMITIVE_INTEGER	||
								type == SIMCModule::PRIMITIVE_COUNTER	||
								type == SIMCModule::PRIMITIVE_GAUGE		||
								type == SIMCModule::PRIMITIVE_TIME_TICKS||
								type == SIMCModule::PRIMITIVE_INTEGER_32||
								type == SIMCModule::PRIMITIVE_UNSIGNED_32||
								type == SIMCModule::PRIMITIVE_GAUGE_32	||
								type == SIMCModule::PRIMITIVE_COUNTER_32||
								type == SIMCModule::PRIMITIVE_COUNTER_64)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}

						case SIMCModule::PRIMITIVE_OCTET_STRING:
						case SIMCModule::PRIMITIVE_DISPLAY_STRING:
						case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
						case SIMCModule::PRIMITIVE_OPAQUE:
						case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
						case SIMCModule::PRIMITIVE_MAC_ADDRESS:
						case SIMCModule::PRIMITIVE_IP_ADDRESS:
						case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
						case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
						case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
						case SIMCModule::PRIMITIVE_DATE_AND_TIME:
							if(	type == SIMCModule::PRIMITIVE_OCTET_STRING		||
								type == SIMCModule::PRIMITIVE_DISPLAY_STRING	||
								type == SIMCModule::PRIMITIVE_PHYS_ADDRESS		||
								type == SIMCModule::PRIMITIVE_OPAQUE			||
								type == SIMCModule::PRIMITIVE_NETWORK_ADDRESS	||
								type == SIMCModule::PRIMITIVE_MAC_ADDRESS		||
								type == SIMCModule::PRIMITIVE_IP_ADDRESS		||
								type == SIMCModule::PRIMITIVE_DATE_AND_TIME		||
								type == SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	||
								type == SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	||
								type == SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	)
							return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						break;
						case SIMCModule::PRIMITIVE_OID:
							if(type == SIMCModule::PRIMITIVE_OID)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
							break;
						case SIMCModule::PRIMITIVE_BOOLEAN:
							if(type == SIMCModule::PRIMITIVE_BOOLEAN)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
							break;
						case SIMCModule::PRIMITIVE_NULL:
							if(type == SIMCModule::PRIMITIVE_NULL)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
							break;
						default:
							return FALSE;
					}
				}
				break;
				case SIMCModule::TYPE_ENUM_OR_BITS:
				{
					SIMCEnumOrBitsType *enumOrBits = (SIMCEnumOrBitsType *) syntaxBTRef->GetType(); 
					switch( enumOrBits->GetEnumOrBitsType())
					{
						case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
							if(type == SIMCModule::PRIMITIVE_INTEGER)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
							if(type == SIMCModule::PRIMITIVE_BITS)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
							if(local)
								return TRUE;
							else
							{
								SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
									item->_valueLine, item->_valueColumn,
									(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
								return FALSE;
							}
						default:
							SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
								item->_valueLine, item->_valueColumn,
								(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
							return FALSE;
					}
				}
				break;
				case SIMCModule::TYPE_SEQUENCE_OF:
				case SIMCModule::TYPE_SEQUENCE:
				case SIMCModule::TYPE_TRAP_TYPE:
				case SIMCModule::TYPE_NOTIFICATION_TYPE:
				case SIMCModule::TYPE_OBJECT_TYPE_V1:
				case SIMCModule::TYPE_OBJECT_IDENTITY:
				case SIMCModule::TYPE_INVALID:
					SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
						item->_valueLine, item->_valueColumn,
						(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
					return FALSE;
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			switch(SIMCModule::GetPrimitiveType(syntaxTypeRef->GetSymbolName()) )
			{
				case SIMCModule::PRIMITIVE_DISPLAY_STRING:
				case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
				case SIMCModule::PRIMITIVE_MAC_ADDRESS:
				case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
				case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
				case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
					if(type == SIMCModule::PRIMITIVE_DISPLAY_STRING ||
						type == SIMCModule::PRIMITIVE_PHYS_ADDRESS	||
						type == SIMCModule::PRIMITIVE_MAC_ADDRESS	||
						type == SIMCModule::PRIMITIVE_OCTET_STRING	||
						type == SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS	||
						type == SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS	||
						type == SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS	)
						return TRUE;
					else
					{
						SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
							item->_valueLine, item->_valueColumn,
							(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
						return FALSE;
					}
					break;
				case SIMCModule::PRIMITIVE_DATE_AND_TIME:
					if(type == SIMCModule::PRIMITIVE_DATE_AND_TIME ||
						type == SIMCModule::PRIMITIVE_OCTET_STRING)
						return TRUE;
					else
					{
						SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
							item->_valueLine, item->_valueColumn,
							(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
						return FALSE;
					}
					break;
				default:
					SemanticError(fileName, OBJ_TYPE_SEQUENCE_INVALID_SYNTAX,
						item->_valueLine, item->_valueColumn,
						(*item->_value)->GetSymbolName(), (*item->_type)->GetSymbolName());
					return FALSE;
			}
		}
	}
	return TRUE;
}


BOOL SIMCParseTree::CheckObjectSequenceItem( const char *const fileName,
			SIMCSequenceItem * item, 
			SIMCValueReference *parentObjectType,
			BOOL local)
{
	SIMCSymbol **type = item->_type;
	SIMCSymbol **value = item->_value;

	BOOL retVal = TRUE;

	SIMCObjectTypeType *objectType;
	switch(SIMCModule::IsObjectType(value, objectType))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				retVal = FALSE;
				SemanticError(fileName, SEQUENCE_ITEM_NO_OBJECT,
					item->_valueLine, item->_valueColumn, (*value)->GetSymbolName());
			}
			break;
		case RESOLVE_UNDEFINED:
			retVal = FALSE;
			SemanticError(fileName, SEQUENCE_ITEM_NO_OBJECT,
				item->_valueLine, item->_valueColumn, (*value)->GetSymbolName());
			break;
		case RESOLVE_CORRECT:
			break;
	}

	SIMCTypeReference *typeRef = NULL;
	// Now check the type of the Sequence Item
	switch(SIMCModule::IsTypeReference(type, typeRef))
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				retVal = FALSE;
				SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
					item->_typeLine, item->_typeColumn,
					(*type)->GetSymbolName());
			}
			break;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			retVal = FALSE;
			SemanticError(fileName, SEQUENCE_TYPE_UNRESOLVED,
				item->_typeLine, item->_typeColumn,
				(*type)->GetSymbolName());
			break;
	}

	// Check if the types loosely match
	if(objectType && typeRef)
	{
		if(!MatchSequenceObjectTypeSyntax(fileName, objectType, typeRef, item, local))
			retVal = FALSE;
	}


	return retVal;
}

BOOL SIMCParseTree::CheckPrimitiveValueAssignment(const char * const fileName, 
												SIMCBuiltInValueReference *bvRef, 
												SIMCTypeReference *btRef,
												SIMCValue *value, 
												BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);

	switch(SIMCModule::GetPrimitiveType(btRef))
	{
		case SIMCModule::PRIMITIVE_INVALID:
			SemanticError(fileName, TYPE_UNRESOLVED,
				bvRef->GetTypeLine(), bvRef->GetTypeColumn(),
				bvRef->GetSymbolName());
			return FALSE;
		case SIMCModule::PRIMITIVE_INTEGER:
		case SIMCModule::PRIMITIVE_UNSIGNED_32:
		case SIMCModule::PRIMITIVE_INTEGER_32:
		case SIMCModule::PRIMITIVE_COUNTER:
		case SIMCModule::PRIMITIVE_GAUGE:
		case SIMCModule::PRIMITIVE_TIME_TICKS:
		case SIMCModule::PRIMITIVE_COUNTER_32:
		case SIMCModule::PRIMITIVE_COUNTER_64:
		case SIMCModule::PRIMITIVE_GAUGE_32:
			switch(valueClass)
			{
				case SIMCModule::VALUE_INTEGER:
					if(SIMCModule::GetPrimitiveType(btRef->GetSymbolName()) != SIMCModule::VALUE_INTEGER)
					{
						if( ((SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
						{
							SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
									value->GetLine(), value->GetColumn(),
									btRef->GetSymbolName());
							return FALSE;
						}
					}
					return TRUE;
				case SIMCModule::VALUE_OCTET_STRING:
				{
					// Check the bounds
					SIMCOctetStringValue *octetValue = (SIMCOctetStringValue*)value;
					if(octetValue->GetNumberOfOctets() > 4)
					{
						SemanticError(fileName, INTEGER_TOO_BIG,
							value->GetLine(), value->GetColumn());
						return FALSE;
					}
					return TRUE;
				}
				default:
					SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
						value->GetLine(), value->GetColumn(), "INTEGER");
					return FALSE;
			}
		case SIMCModule::PRIMITIVE_OID:
			if(valueClass != SIMCModule::VALUE_OID)
			{
				SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
					value->GetLine(), value->GetColumn(), "OBJECT IDENTIFIER");
				return FALSE;
			}
			else
				return TRUE;
		case SIMCModule::PRIMITIVE_OCTET_STRING:
		case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
		case SIMCModule::PRIMITIVE_IP_ADDRESS:
		case SIMCModule::PRIMITIVE_OPAQUE:
		case SIMCModule::PRIMITIVE_DISPLAY_STRING:
		case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
		case SIMCModule::PRIMITIVE_MAC_ADDRESS:
		case SIMCModule::PRIMITIVE_DATE_AND_TIME:
		case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
		case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
		case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
			if(valueClass != SIMCModule::VALUE_OCTET_STRING)
			{
				SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
					value->GetLine(), value->GetColumn(), "OCTET STRING");
				return FALSE;
			}
			else
				return TRUE;
		case SIMCModule::PRIMITIVE_BOOLEAN:
			if(valueClass != SIMCModule::VALUE_BOOLEAN)
			{
				SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
					value->GetLine(), value->GetColumn(), "BOOLEAN");
				return FALSE;
			}
			else
				return TRUE;
		case SIMCModule::PRIMITIVE_NULL:
			if(valueClass != SIMCModule::VALUE_NULL)
			{
				SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
					value->GetLine(), value->GetColumn(), "NULL");
				return FALSE;
			}
			else
				return TRUE;
		case SIMCModule::PRIMITIVE_BITS:
			return TRUE;
	}
	return FALSE;

}

BOOL SIMCParseTree::CheckSubTypeValueAssignment(const char *const fileName,
												SIMCBuiltInValueReference *bvRef,
												SIMCBuiltInTypeReference *btRef,
												SIMCSubType *subType,
												SIMCValue *value, 
												BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);

	switch(subType->GetStatus())
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, SUBTYPE_ROOT_RESOLUTION,
					subType->GetTypeLine(), subType->GetTypeColumn());
				return FALSE;
			}
			else
				return TRUE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			SemanticError(fileName, SUBTYPE_ROOT_RESOLUTION,
				subType->GetTypeLine(), subType->GetTypeColumn());
			return FALSE;
	}

	SIMCTypeReference *rootTypeRef = subType->GetRootType();
	SIMCSymbol **tempRootTypeRef = (SIMCSymbol**)&rootTypeRef;
	switch(SIMCModule::GetSymbolClass(tempRootTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			switch(SIMCModule::GetPrimitiveType(rootTypeRef))
			{
				case SIMCModule::PRIMITIVE_INVALID:
				case SIMCModule::PRIMITIVE_BOOLEAN:
				case SIMCModule::PRIMITIVE_NULL:
				case SIMCModule::PRIMITIVE_OID:
					return FALSE;
				case SIMCModule::PRIMITIVE_INTEGER:
				case SIMCModule::PRIMITIVE_COUNTER:
				case SIMCModule::PRIMITIVE_GAUGE:
				case SIMCModule::PRIMITIVE_TIME_TICKS:
				case SIMCModule::PRIMITIVE_INTEGER_32:
				case SIMCModule::PRIMITIVE_UNSIGNED_32:
				case SIMCModule::PRIMITIVE_GAUGE_32:
				case SIMCModule::PRIMITIVE_COUNTER_32:
				case SIMCModule::PRIMITIVE_COUNTER_64:
					switch(valueClass)
					{
						case SIMCModule::VALUE_INTEGER:
							if(SIMCModule::GetPrimitiveType(rootTypeRef->GetSymbolName()) != SIMCModule::PRIMITIVE_INTEGER)
							{
								if( ( (SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
								{
									SemanticError(fileName, VALUE_ASSIGN_NEGATIVE_INTEGER,
										value->GetLine(), value->GetColumn(), 
										rootTypeRef->GetSymbolName());
									return FALSE;
								}
							}
							return TRUE;
						case SIMCModule::VALUE_OCTET_STRING:
						{
							SIMCOctetStringValue *octetValue = (SIMCOctetStringValue *)value;
							if(octetValue->GetNumberOfOctets() > 4)
							{
								SemanticError(fileName, INTEGER_TOO_BIG,
									value->GetLine(), value->GetColumn());
								return FALSE;
							}
						}
						default:
							SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
								value->GetLine(), value->GetColumn(), "INTEGER");
							return FALSE;
					}
					break;
				case SIMCModule::PRIMITIVE_OCTET_STRING:
				case SIMCModule::PRIMITIVE_NETWORK_ADDRESS:
				case SIMCModule::PRIMITIVE_IP_ADDRESS:
				case SIMCModule::PRIMITIVE_OPAQUE:
				case SIMCModule::PRIMITIVE_DISPLAY_STRING:
				case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
				case SIMCModule::PRIMITIVE_MAC_ADDRESS:
				case SIMCModule::PRIMITIVE_DATE_AND_TIME:
				case SIMCModule::PRIMITIVE_SNMP_UDP_ADDRESS:
				case SIMCModule::PRIMITIVE_SNMP_IPX_ADDRESS:	
				case SIMCModule::PRIMITIVE_SNMP_OSI_ADDRESS:	
					if(valueClass != SIMCModule::VALUE_OCTET_STRING)
					{
						SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
							value->GetLine(), value->GetColumn(), "OCTET STRING");
						return FALSE;
					}
					else
					{
						if(SIMCModule::GetPrimitiveType(rootTypeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_IP_ADDRESS)
						{
							if( ( (SIMCOctetStringValue*)value)->GetNumberOfOctets() > 4 )
							{
								SemanticError(fileName, VALUE_ASSIGN_NEGATIVE_INTEGER,
									value->GetLine(), value->GetColumn(), 
									rootTypeRef->GetSymbolName());
								return FALSE;
							}
						}
						return TRUE;
					}
			}
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			switch(SIMCModule::GetPrimitiveType(rootTypeRef->GetSymbolName()))
			{
				case SIMCModule::PRIMITIVE_PHYS_ADDRESS:
				case SIMCModule::PRIMITIVE_MAC_ADDRESS:
				case SIMCModule::PRIMITIVE_DISPLAY_STRING:
				case SIMCModule::PRIMITIVE_DATE_AND_TIME:
					if(valueClass != SIMCModule::VALUE_OCTET_STRING)
					{
						SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
							value->GetLine(), value->GetColumn(), "OCTET STRING");
						return FALSE;
					}
					return TRUE;
				default:
						SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
							value->GetLine(), value->GetColumn(), "OCTET STRING");
						return FALSE;
			}
		}
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckEnumValueAssignment(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCEnumOrBitsType *enumType,
								SIMCValue *value, 
								BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);

	if(valueClass != SIMCModule::VALUE_INTEGER)
	{
		SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
			value->GetLine(), value->GetColumn(), "INTEGER");
		return FALSE;
	}
	char *dummy;
	switch(enumType->GetIdentifier( ((SIMCIntegerValue*)value)->GetIntegerValue(), dummy))
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, VALUE_ASSIGN_ENUM_INVALID,
					value->GetLine(), value->GetColumn());
				return FALSE;
			}
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
			SemanticError(fileName, VALUE_ASSIGN_ENUM_INVALID,
				value->GetLine(), value->GetColumn());
			return FALSE;
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckObjectTypeValueAssignmentV1(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCObjectTypeV1 *objectType,
								SIMCValue *value, 
								BOOL local)
{
	BOOL retVal = TRUE;

	retVal = CheckObjectTypeV1Index(fileName, bvRef, objectType, local) && retVal;
	const char *const name = bvRef->GetSymbolName();

	// Get the Syntax Clause
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef;

	switch(SIMCModule::IsTypeReference(syntax, typeRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return retVal;
			else
				return FALSE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			return FALSE;
	}
	
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol **)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *syntaxType = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			switch(SIMCModule::GetTypeClass(syntaxType))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					if( SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_COUNTER &&
						name[strlen(name)-1] != 's' )
					{
						SemanticError(fileName, OBJ_TYPE_SINGULAR_COUNTER,
							bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
							name);
					}
					break;
				case SIMCModule::TYPE_SEQUENCE:
				{
					SIMCSequenceType *sequenceType = (SIMCSequenceType *)syntaxType;
					SIMCSequenceList *sequenceList = sequenceType->GetListOfSequences();
					if(sequenceList)
					{
						POSITION p = sequenceList->GetHeadPosition();
						while(p)
						{
							if(!CheckObjectSequenceItem(fileName, 
									sequenceList->GetNext(p), bvRef, local))
								retVal = FALSE;
						}
					}

					SIMCIndexList * indexList = objectType->GetIndexTypes();
					if(!indexList || indexList->IsEmpty())
					{
						SemanticError(fileName, OBJ_TYPE_SEQUENCE_NO_INDEX,
							bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
							name);
						retVal = FALSE;
					}
				}
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			return TRUE;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckObjectTypeValueAssignmentV2(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCObjectTypeV2 *objectType,
								SIMCValue *value, 
								BOOL local)
{
	BOOL retVal = TRUE;

	retVal = CheckObjectTypeV2Index(fileName, bvRef, objectType, local) && retVal;
	const char *const name = bvRef->GetSymbolName();

	// Get the Syntax Clause
	SIMCSymbol **syntax = objectType->GetSyntax();
	SIMCTypeReference *typeRef;

	switch(SIMCModule::IsTypeReference(syntax, typeRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return retVal;
			else
				return FALSE;
		case RESOLVE_UNDEFINED:
		case RESOLVE_UNSET:
			return FALSE;
	}
	
	SIMCSymbol **tempTypeRef = 	(SIMCSymbol **)&typeRef;
	switch(SIMCModule::GetSymbolClass(tempTypeRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
		{
			SIMCType *syntaxType = ((SIMCBuiltInTypeReference *)typeRef)->GetType();
			switch(SIMCModule::GetTypeClass(syntaxType))
			{
				case SIMCModule::TYPE_PRIMITIVE:
					if( (SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_COUNTER_32 ||
						SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_COUNTER_64  ||
						SIMCModule::GetPrimitiveType(typeRef->GetSymbolName()) == SIMCModule::PRIMITIVE_COUNTER)
						&&
						name[strlen(name)-1] != 's' )
					{
						SemanticError(fileName, OBJ_TYPE_SINGULAR_COUNTER,
							bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
							name);
					}
					break;
				case SIMCModule::TYPE_SEQUENCE:
				{
					SIMCSequenceType *sequenceType = (SIMCSequenceType *)syntaxType;
					SIMCSequenceList *sequenceList = sequenceType->GetListOfSequences();
					if(sequenceList)
					{
						POSITION p = sequenceList->GetHeadPosition();
						while(p)
						{
							if(!CheckObjectSequenceItem(fileName, 
									sequenceList->GetNext(p), bvRef, local))
								retVal = FALSE;
						}
					}

					SIMCIndexListV2 * indexList = objectType->GetIndexTypes();
					if(!objectType->GetAugments() && (!indexList || indexList->IsEmpty()))
					{
						SemanticError(fileName, OBJ_TYPE_SEQUENCE_NO_INDEX,
							bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
							name);
						retVal = FALSE;
					}
				}
			}
		}
		break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
		{
			return TRUE;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::CheckObjectIdentityValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef, 
										SIMCBuiltInTypeReference *btRef,
										SIMCObjectIdentityType *type, 
										SIMCValue *value, 
										BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);
	const char *const name = bvRef->GetSymbolName();
	if(valueClass != SIMCModule::VALUE_OID)
	{
		SemanticError(fileName, OBJECT_IDENTITY_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}
	if( ((SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
	{
		SemanticError(fileName, OBJECT_IDENTITY_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckTrapTypeValueAssignment(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCTrapTypeType *trapType,
								SIMCValue *value, 
								BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);
	const char *const name = bvRef->GetSymbolName();
	if(valueClass != SIMCModule::VALUE_INTEGER)
	{
		SemanticError(fileName, TRAP_TYPE_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}
	if( ((SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
	{
		SemanticError(fileName, TRAP_TYPE_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckNotificationTypeValueAssignment(const char *const fileName, 
										SIMCBuiltInValueReference *bvRef, 
										SIMCBuiltInTypeReference *btRef,
										SIMCNotificationTypeType *type, 
										SIMCValue *value, 
										BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);
	const char *const name = bvRef->GetSymbolName();
	if(valueClass != SIMCModule::VALUE_OID)
	{
		SemanticError(fileName, NOTIFICATION_TYPE_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}
	if( ((SIMCIntegerValue*)value)->GetIntegerValue() < 0 )
	{
		SemanticError(fileName, NOTIFICATION_TYPE_VALUE_RESOLUTION,
			value->GetLine(), value->GetColumn(),
			name);
		return FALSE;
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckBitsTypeValueAssignment(const char *const fileName, 
								SIMCBuiltInValueReference *bvRef,
								SIMCBuiltInTypeReference *btRef,
								SIMCEnumOrBitsType *bitsType,
								SIMCValue *value, 
								BOOL local)
{
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);

	if( valueClass != SIMCModule::VALUE_BITS )
	{
		SemanticError(fileName, VALUE_ASSIGN_MISMATCH,
			value->GetLine(), value->GetColumn(), "BITS");
		return FALSE;
	}

	// Check whether all the bit identifiers are valid
	SIMCBitValue *bitValue;
	const SIMCBitValueList * valueList = ((SIMCBitsValue *)value)->GetValueList();
	POSITION p = valueList->GetHeadPosition();
	while(p)
	{
		bitValue = valueList->GetNext(p);
		if(! bitsType->GetValue(bitValue->_name) )
		{
			SemanticError(fileName, INVALID_BIT_VALUE,
				bitValue->_line, bitValue->_column,
				bitValue->_name);
			return FALSE;
		}
	}
	return TRUE;
}

BOOL SIMCParseTree::CheckBuiltInValueRef(SIMCBuiltInValueReference *bvRef, BOOL local)
{
	const char *const fileName = (bvRef->GetModule())->GetInputFileName();
	// Get the type in the value assignment
	SIMCSymbol **typeSymbol = bvRef->GetTypeReference();
	const char *name = bvRef->GetSymbolName();
	SIMCTypeReference *btRef;
	switch( SIMCModule::IsTypeReference(typeSymbol, btRef))
	{
		case RESOLVE_IMPORT:
			if(local)
				return TRUE;
			else
			{
				SemanticError(fileName, TYPE_UNRESOLVED,
					bvRef->GetTypeLine(), bvRef->GetTypeColumn(),
					bvRef->GetSymbolName());
				return FALSE;
			}
		case RESOLVE_UNSET:
		case RESOLVE_UNDEFINED:
				SemanticError(fileName, TYPE_UNRESOLVED,
					bvRef->GetTypeLine(), bvRef->GetTypeColumn(),
					bvRef->GetSymbolName());
			return FALSE;
	}
	// Get the value
	SIMCValue *value = bvRef->GetValue();
	SIMCModule::ValueClass valueClass = SIMCModule::GetValueClass(value);
	if( valueClass == SIMCModule::VALUE_INVALID )
	{
		SemanticError(fileName, VALUE_UNRESOLVED,
			bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
			bvRef->GetSymbolName());
		return FALSE;
	}

	// Get the type
	SIMCType *type;
	SIMCModule::TypeClass typeClass;
	SIMCSymbol **tempBtRef = (SIMCSymbol**)&btRef;
	switch(SIMCModule::GetSymbolClass(tempBtRef))
	{
		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			type = ((SIMCBuiltInTypeReference *)btRef)->GetType();
			typeClass = SIMCModule::GetTypeClass(type);
			break;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			typeClass = SIMCModule::TYPE_PRIMITIVE;
			break;
	}


	
	if(typeClass != SIMCModule::TYPE_OBJECT_TYPE_V1 &&
		typeClass != SIMCModule::TYPE_OBJECT_TYPE_V2 &&
		typeClass != SIMCModule::TYPE_TRAP_TYPE &&
		typeClass != SIMCModule::TYPE_NOTIFICATION_TYPE)
	{
		if(bvRef->GetReferenceCount() == 0)
		{
			const SIMCModule *module = bvRef->GetModule();
			if(!SIMCParser::IsReservedSymbol(_snmpVersion, bvRef->GetSymbolName(), module->GetModuleName()))
				SemanticError(fileName, VALUE_UNREFERENCED,
					bvRef->GetLineNumber(), bvRef->GetColumnNumber(),
					name);
		}
	}

	// See if the value matches the type
	switch(typeClass)
	{
		case SIMCModule::TYPE_INVALID:
			SemanticError(fileName, TYPE_UNRESOLVED,
				bvRef->GetTypeLine(), bvRef->GetTypeColumn(),
				bvRef->GetSymbolName());
			return FALSE;

		case SIMCModule::TYPE_PRIMITIVE:
			return CheckPrimitiveValueAssignment(fileName, bvRef, btRef, value, local);
		case SIMCModule::TYPE_RANGE:
		case SIMCModule::TYPE_SIZE:
			return CheckSubTypeValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
							(SIMCSubType *)type, value, local);
		case SIMCModule::TYPE_SEQUENCE_OF:
			SemanticError(fileName, VALUE_ASSIGN_INVALID,
				value->GetLine(), value->GetColumn(), "SEQUENCE OF");
			return FALSE;
		case SIMCModule::TYPE_SEQUENCE:
			SemanticError(fileName, VALUE_ASSIGN_INVALID,
				value->GetLine(), value->GetColumn(), "SEQUENCE");
			return FALSE;
		case SIMCModule::TYPE_TRAP_TYPE:
			return CheckTrapTypeValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
					(SIMCTrapTypeType *)type, value, local);
		case SIMCModule::TYPE_NOTIFICATION_TYPE:
			return CheckNotificationTypeValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
					(SIMCNotificationTypeType *)type, value, local);
		case SIMCModule::TYPE_OBJECT_TYPE_V1:
			return CheckObjectTypeValueAssignmentV1(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
						(SIMCObjectTypeV1 *)type, value, local);
		case SIMCModule::TYPE_OBJECT_TYPE_V2:
			return CheckObjectTypeValueAssignmentV2(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
						(SIMCObjectTypeV2 *)type, value, local);
		case SIMCModule::TYPE_OBJECT_IDENTITY:
			return CheckObjectIdentityValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
						(SIMCObjectIdentityType *)type, value, local);
		case SIMCModule::TYPE_ENUM_OR_BITS:
			switch( ((SIMCEnumOrBitsType *)type)->GetEnumOrBitsType())
			{
				case SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM:
					return CheckEnumValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
										(SIMCEnumOrBitsType *)type, value, local);
				case SIMCEnumOrBitsType::ENUM_OR_BITS_BITS:
					return CheckBitsTypeValueAssignment(fileName, bvRef, (SIMCBuiltInTypeReference*)btRef,
								(SIMCEnumOrBitsType *)type, value, local);
				case SIMCEnumOrBitsType::ENUM_OR_BITS_IMPORT:
					if(local)
						return TRUE;
					else
						return FALSE;
				default:
					return FALSE;
			}
	}

	return TRUE;
}

BOOL SIMCParseTree::CheckDefinedValueRef(SIMCDefinedValueReference *symbol, BOOL local)
{
	const char *const fileName = (symbol->GetModule())->GetInputFileName();

	switch(symbol->GetStatus())
	{
		case RESOLVE_IMPORT:
			if(!local)
			{
				SemanticError(fileName, VALUE_UNRESOLVED,
					symbol->GetLineNumber(), symbol->GetColumnNumber(),
					symbol->GetSymbolName());
				return FALSE;
			}
			if(symbol->GetReferenceCount() == 0)
			{
				const SIMCModule *module = symbol->GetModule();
				if(!SIMCParser::IsReservedSymbol(_snmpVersion, symbol->GetSymbolName(), module->GetModuleName()))
					SemanticError(fileName, VALUE_UNREFERENCED,
						symbol->GetLineNumber(), symbol->GetColumnNumber(),
						symbol->GetSymbolName());
			}
			return TRUE;
		case RESOLVE_CORRECT:
		{
			SIMCBuiltInValueReference bvRef(symbol, symbol->GetRealValue());
			return CheckBuiltInValueRef(&bvRef, local);
		}
		default:
			SemanticError(fileName, VALUE_UNRESOLVED,
				symbol->GetLineNumber(), symbol->GetColumnNumber(),
				symbol->GetSymbolName());
			return FALSE;
	}
	return FALSE;
}


BOOL SIMCParseTree::CheckSymbol(SIMCSymbol **symbol, BOOL local)
{
	if((*symbol)->GetSymbolType() == SIMCSymbol::PRIMITIVE)
		return TRUE;

	BOOL temp = FALSE;
	const char *const fileName = ((*symbol)->GetModule())->GetInputFileName();
	SIMCModule::SymbolClass x = SIMCModule::GetSymbolClass(symbol);
	switch(x)
	{
		case SIMCModule::SYMBOL_INVALID:
		case SIMCModule::SYMBOL_UNKNOWN:
		case SIMCModule::SYMBOL_MODULE:
			SemanticError(fileName, SYMBOL_UNDEFINED, 
				(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
				(*symbol)->GetSymbolName());
			return FALSE;

		case SIMCModule::SYMBOL_IMPORT:

			if(!local)
			{
				SemanticError(fileName, SYMBOL_UNDEFINED, 
					(*symbol)->GetLineNumber(), (*symbol)->GetColumnNumber(),
					(*symbol)->GetSymbolName());
				return FALSE;
			}
			return TRUE;

		case SIMCModule::SYMBOL_BUILTIN_TYPE_REF:
			temp = CheckBuiltInTypeRef((SIMCBuiltInTypeReference *)(*symbol),
										local);

			return temp;
		case SIMCModule::SYMBOL_DEFINED_TYPE_REF:
			temp = CheckDefinedTypeRef((SIMCDefinedTypeReference *)(*symbol),
										local);
			return temp;
		case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
			temp = CheckBuiltInValueRef((SIMCBuiltInValueReference *)(*symbol),
										local);
			return temp;
		case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
			temp = CheckDefinedValueRef((SIMCDefinedValueReference *)(*symbol),
										local);
			return temp;
		case SIMCModule::SYMBOL_TEXTUAL_CONVENTION:
			temp = CheckTextualConvention((SIMCTextualConvention *)(*symbol),
										local);
			return temp;
		}		

	return FALSE;
}

BOOL SIMCParseTree::CheckModule(SIMCModule *m, BOOL local)
{
	// See whether the reference counts of all imports is atleast 1
	SIMCModuleList * importModuleList = m->GetListOfImportModules();
	if(importModuleList)
	{
		SIMCModule *importModule;
		POSITION p = importModuleList->GetHeadPosition();
		while(p)
		{
			importModule = importModuleList->GetNext(p);
			if(SIMCParser::IsReservedModule(_snmpVersion, importModule->GetModuleName()))
				continue;
			SIMCSymbolTable *table = importModule->GetSymbolTable();
			POSITION pImport = table->GetStartPosition();
			SIMCSymbol **s;
			CString name;
			while(pImport)
			{
				table->GetNextAssoc(pImport, name, s);
				if( (*s)->GetReferenceCount() == 0 && name[0] != '*'  )
					SemanticError(m->GetInputFileName(), IMPORT_UNUSED,
						(*s)->GetLineNumber(), (*s)->GetColumnNumber(),
						(*s)->GetSymbolName());
			}
		}
	}

	SIMCSymbolTable * table = m->GetSymbolTable();
	POSITION p = table->GetStartPosition();
	SIMCSymbol **s;
	CString name;
	BOOL retVal = TRUE;
	while(p)
	{
		table->GetNextAssoc(p, name, s);
		retVal	= CheckSymbol(s, local) && retVal;
	}
	return retVal;
}


BOOL SIMCParseTree::CheckSemantics(BOOL local)
{
	// Check the current state of the parse tree
	if( _parseTreeState == EMPTY)
		return TRUE;
	if( _parseTreeState == UNRESOLVED && !local)
		return FALSE;
	
	if(!semanticErrorsDll)
	{
		cerr << "CheckSemantics(): FATAL ERROR smierrsm.dll not found" <<
			endl;
		return FALSE;
	}

	// Build the OID tree
 	BOOL retVal = BuildOidTree(local);

	// Check the semantics of all modules in the list
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		retVal= CheckModule(m, local) && retVal;
	}

	// Check the semantics of the OID tree
	retVal = CheckOidTree(local) && retVal;


	// Fabricate the groups
	SIMCGroupList groupList;
	if(retVal)
	{
		retVal = _theTree.GetObjectGroups(&groupList);

		// Add these to the owning modules. The owning module is decided as follows
		// The "Main Module" is defined as the module that is being input to the parse tree.
		// If the named node belongs to the Main Module, then add the group to the Main Module
		// else
		//		{
		//			if any of the scalars or table roots are in the Main Module 
		//				Add the group to the Main Module
		//			else
		//				Add the group to the module of the named node
		//		}
		// Not that this results in fabricated OBJECT-GROUPs being added to the
		// Main Module only.
	
		// The main module is always at the head of the list of modules in the parese tree
		SIMCModule *mainModule = _listOfModules->GetHead();
		SIMCObjectGroup *nextGroup = NULL;
		SIMCSymbol *namedNode = NULL;
		SIMCModule *namedNodeModule = NULL;

		p = groupList.GetHeadPosition();
		while(p)
		{
			nextGroup = groupList.GetNext(p);
			namedNode = nextGroup->GetNamedNode();
			namedNodeModule = namedNode->GetModule();

			if(namedNodeModule == mainModule)
				mainModule->AddObjectGroup(nextGroup);
			else
			{
				if( nextGroup->ObjectsInModule(mainModule) )
					mainModule->AddObjectGroup(nextGroup);
				else
					(namedNode->GetModule())->AddObjectGroup(nextGroup);

			}
		}
			
	}

	// Fabricate NOTIFICATION-TYPEs from TRAP-TYPEs, for each module
	// And then fabricate NOTIFICATION-GROUPs from NOTIFICATION-TYPEs, for each module
	if(retVal)
	{
		retVal = FabricateNotificationGroups();
	}
	
	// Set the MODULE-IDENTITY Oid values for V2c modules, and fabricate MODULE-IDENTITY
	// for V1 modules 
	if(retVal)
	{
		p = _listOfModules->GetHeadPosition();
		SIMCModule *m;
		while(p)
		{
			m = _listOfModules->GetNext(p);
			switch( m->GetSnmpVersion())
			{
				// V2c module. No need to fabricate MODULE-IDENTITY
				case 2:
				{
					SIMCGroupList *listOfObjectGroups = m->GetObjectGroupList();
					if( !listOfObjectGroups || listOfObjectGroups->IsEmpty())
							SemanticError(m->GetInputFileName(), 
								MODULE_NO_GROUPS_V2, 
								m->GetLineNumber(),	m->GetColumnNumber(),
								m->GetModuleName());
					// Just fill in the clean oid value
					SIMCCleanOidValue *value = new SIMCCleanOidValue;
					if(_theTree.GetOidValue(m->GetModuleIdentityName(), 
						m->GetModuleName(), *value))
						m->SetModuleIdentityValue(value);
				}
				break;
				
				// For the case where the version of the module has not been specified on the 
				// command-line, check whether a MODULE-IDENTITY is present. If no,
				// do what was done for case 2. If not, fabricate one, just like the V1 case.
				case 0:
					if(m->GetModuleIdentityName())
					{
						// Set its version to 2
						m->SetSnmpVersion(2);

						SIMCGroupList *listOfObjectGroups = m->GetObjectGroupList();
						if( !listOfObjectGroups || listOfObjectGroups->IsEmpty())
								SemanticError(m->GetInputFileName(), 
									MODULE_NO_GROUPS_V2, 
									m->GetLineNumber(),	m->GetColumnNumber(),
									m->GetModuleName());
						// Just fill in the clean oid value
						SIMCCleanOidValue *value = new SIMCCleanOidValue;
						if(_theTree.GetOidValue(m->GetModuleIdentityName(), 
							m->GetModuleName(), *value))
							m->SetModuleIdentityValue(value);
						break;
					}
					// else fall thru to fabricate the clause

				// For an SNMPv1 module, Fabricate all the clauses of the MODULE-IDENTITY 
				case 1:
				{
					// Set its version to 1
					m->SetSnmpVersion(1);

					const char *const moduleName = m->GetModuleName();
					m->SetLastUpdated("0000000000Z");
					m->SetOrganization("");
					m->SetContactInfo("");
					m->SetDescription(moduleName);
					CString moduleIdentityName(moduleName);
					moduleIdentityName.MakeLower();
					RemoveUnderscores(moduleIdentityName);
					moduleIdentityName += CString("V1ModuleIdentity");
					m->SetModuleIdentityName(moduleIdentityName);


					// And finally, the OID value of the Module Identity macro
					SIMCGroupList *listOfObjectGroups = m->GetObjectGroupList();
					if( !listOfObjectGroups || listOfObjectGroups->IsEmpty())
						SemanticError(m->GetInputFileName(), 
							MODULE_NO_GROUPS_V1, 
							m->GetLineNumber(),	m->GetColumnNumber(),
							moduleName);
					else
					{
						POSITION p = listOfObjectGroups->GetHeadPosition();
						SIMCObjectGroup *nextGroup = listOfObjectGroups->GetNext(p);
						SIMCCleanOidValue * leastValue = nextGroup->GetGroupValue();
						SIMCCleanOidValue * nextValue = NULL;
						while(p)
						{
							nextGroup = listOfObjectGroups->GetNext(p);
							nextValue = nextGroup->GetGroupValue();
							if( (*nextValue) < (*leastValue) )
								leastValue = nextValue;
						}
						SIMCCleanOidValue *value = new SIMCCleanOidValue;
						CleanOidValueCopy(*value, *leastValue);
						m->SetModuleIdentityValue(value);
					}
				}
			}
		}
	}

	if(retVal)
	{
		if (_parseTreeState == UNCHECKED)
			_parseTreeState = FINAL;
	}

	return retVal;
}

BOOL SIMCParseTree::BuildModuleOidTree(SIMCModule *m, BOOL local)
{
	SIMCSymbolTable * table = m->GetSymbolTable();
	POSITION p = table->GetStartPosition();
	SIMCSymbol **s;
	const char * const moduleName = m->GetModuleName();
	CString name;
	SIMCValue *val;
	SIMCBuiltInValueReference *valRef;
	SIMCCleanOidValue cleanVal;
	BOOL retVal = TRUE;
	while(p)
	{
		cleanVal.RemoveAll();
		table->GetNextAssoc(p, name, s);
		if( (*((*s)->GetSymbolName()) == '*') || 
				(*s)->GetModule() != m)
			continue;
		switch(SIMCModule::GetSymbolClass(s))
		{
			case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
				val = ((SIMCBuiltInValueReference *)(*s))->GetValue();
				if( SIMCModule::GetValueClass(val) == SIMCModule::VALUE_OID )
				{
					switch( GetCleanOidValue(moduleName, (SIMCOidValue *)val, cleanVal, local) )
					{
						case RESOLVE_CORRECT:
							_theTree.AddSymbol((const SIMCSymbol **)s, cleanVal);
							break;
						case RESOLVE_IMPORT:
							if(local)
								break;
							else
							{
								retVal = FALSE;
								break;
							}
						default:
							retVal = FALSE;
							break;
					}

				}
				break;
			case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
				if(((SIMCDefinedValueReference *)(*s))->GetStatus() == RESOLVE_IMPORT)
				{
					if(local)
						break;
					else
					{
							SemanticError(m->GetInputFileName(), VALUE_UNRESOLVED,
								(*s)->GetLineNumber(), (*s)->GetColumnNumber(),
								(*s)->GetSymbolName());
							retVal = FALSE;
							break;
					}
				}
				valRef = ((SIMCDefinedValueReference *)(*s))->GetRealValue();
				val = valRef->GetValue();
				if(!val)
				{
						retVal = FALSE;
				}
				if( SIMCModule::GetValueClass(val) == SIMCModule::VALUE_OID )
				{
					switch( GetCleanOidValue(moduleName, (SIMCOidValue *)val, cleanVal, local) )
					{
						case RESOLVE_CORRECT:
							_theTree.AddSymbol((const SIMCSymbol **)s, cleanVal);
							break;
						case RESOLVE_IMPORT:
							if(local)
								break;
							else
							{
								retVal = FALSE;
								break;
							}
						default:
							retVal = FALSE;
							break;
					}

				}
				break;
			default:
				continue;
		}
	}
	return retVal;
}

BOOL SIMCParseTree::BuildOidTree(BOOL local)
{

	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	BOOL retVal = TRUE;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		retVal= BuildModuleOidTree(m, local) && retVal;
	}

	// cout << _theTree;
	return retVal;
}

SIMCResolutionStatus SIMCParseTree::GetCleanOidValue( const char * const fileName,
													SIMCOidValue * input,
													SIMCCleanOidValue& result,
													BOOL local)
{
	SIMCSymbolList checkedList;
	return GetCleanOidValueRec(fileName, input, result, local, checkedList);
}
 
SIMCResolutionStatus SIMCParseTree::GetCleanOidValueRec( const char *const fileName,
						SIMCOidValue * input,
						SIMCCleanOidValue& result,
						BOOL local,
						SIMCSymbolList& checkedList) 
{
	SIMCOidComponentList *listOfComponents = input->GetListOfComponents();
	if( listOfComponents)
	{
		POSITION p = listOfComponents->GetHeadPosition();
		SIMCOidComponent *c;
		SIMCSymbol **s;
		SIMCValue *v;
		SIMCBuiltInValueReference *vref;
		int val;
		// Special Treatment for the first component. Can be an OID itself
		if(p)
		{
			c = listOfComponents->GetNext(p);
			s = c->GetValue();

			// See whether it is in the checked list. If so, it is self-referential value
			POSITION pChecked = checkedList.GetHeadPosition();
			const SIMCSymbol **checkedSymbol;
			while(pChecked)
			{
				checkedSymbol = checkedList.GetNext(pChecked);
				if( checkedSymbol == (const SIMCSymbol **)s)
				{
					SemanticError(fileName, OID_HEAD_ERROR,
						c->GetValueLine(), c->GetValueColumn(),
						(*s)->GetSymbolName());
					return RESOLVE_UNDEFINED;
				}
			}
			checkedList.AddTail((const SIMCSymbol **)s);

			
			switch(SIMCModule::GetSymbolClass(s))
			{
				case SIMCModule::SYMBOL_DEFINED_VALUE_REF:
				{
					switch( ((SIMCDefinedValueReference*)(*s))->GetStatus())
					{
						case RESOLVE_IMPORT:
							if(local)
								return RESOLVE_IMPORT;
							else
							{
								SemanticError(fileName, OID_HEAD_ERROR,
									c->GetValueLine(), c->GetValueColumn(),
									(*s)->GetSymbolName());
								return RESOLVE_UNDEFINED;
							}
							break;
						case RESOLVE_UNDEFINED:
						case RESOLVE_UNSET:
							SemanticError(fileName, OID_HEAD_ERROR,
								c->GetValueLine(), c->GetValueColumn(),
								(*s)->GetSymbolName());
							return RESOLVE_UNDEFINED;
					}

					vref = ((SIMCDefinedValueReference*)(*s))->GetRealValue();
					v = vref->GetValue();
					switch( SIMCModule::GetValueClass(v))
					{
						case SIMCModule::VALUE_INTEGER:
						{
							val = ((SIMCIntegerValue *)(v))->GetIntegerValue();
							if(val == 0 )
								SemanticError(fileName, ZERO_IN_OID,
								c->GetValueLine(), c->GetValueColumn());
							if(val < 0)
							{
								SemanticError(fileName, OID_NEGATIVE_INTEGER,
									c->GetValueLine(), c->GetValueColumn());
								return RESOLVE_UNDEFINED;
							}
							result.AddTail(val);
						}
						break;
						case SIMCModule::VALUE_OID:
						{
							SIMCCleanOidValue head;
							switch(GetCleanOidValueRec(fileName, (SIMCOidValue*)v, head, local, checkedList))
							{
								case RESOLVE_IMPORT:
									if(local)
										return RESOLVE_IMPORT;
									else
										return RESOLVE_UNDEFINED;
									break;
								case RESOLVE_CORRECT:
									AppendOid(result, head);
									break;
								default:
									return RESOLVE_UNDEFINED;
							}
						}
						break;
						default:
							SemanticError(fileName, OID_HEAD_ERROR,
								c->GetValueLine(), c->GetValueColumn(),
								(*s)->GetSymbolName());
							return RESOLVE_UNDEFINED;
					}
				}
				break;
				case SIMCModule::SYMBOL_BUILTIN_VALUE_REF:
				{
					v = ((SIMCBuiltInValueReference*)(*s))->GetValue();
					switch( SIMCModule::GetValueClass(v) )
					{
						case SIMCModule::VALUE_INTEGER:
							val = ((SIMCIntegerValue *)(v))->GetIntegerValue();
							if(val == 0 )
								SemanticError(fileName, ZERO_IN_OID,
									c->GetValueLine(), c->GetValueColumn());
							if(val < 0)
							{
								SemanticError(fileName, OID_NEGATIVE_INTEGER,
									c->GetValueLine(), c->GetValueColumn());
								return RESOLVE_UNDEFINED;
							}
							result.AddTail(val);
							break;
						case SIMCModule::VALUE_OID:
						{
							SIMCCleanOidValue head;
							switch(GetCleanOidValueRec(fileName, (SIMCOidValue*)v, head, local, checkedList))
							{
								case RESOLVE_IMPORT:
									if(local)
										return RESOLVE_IMPORT;
									else
										return RESOLVE_UNDEFINED;
									break;
								case RESOLVE_CORRECT:
									AppendOid(result, head);
									break;
								default:
									return RESOLVE_UNDEFINED;
							}
						}
						break;
						default:
						{
							SemanticError(fileName, OID_HEAD_ERROR,
								c->GetValueLine(), c->GetValueColumn(),
								(*s)->GetSymbolName());
							return RESOLVE_UNDEFINED;
						}
					}
				}
				break;

				case SIMCModule::SYMBOL_IMPORT:
					if(!local)
					{
						SemanticError(fileName, OID_HEAD_ERROR,
						c->GetValueLine(), c->GetValueColumn(),
						(*s)->GetSymbolName());
						return RESOLVE_UNDEFINED;
					}
					else
						return RESOLVE_IMPORT;

				default:
					{
						SemanticError(fileName, OID_HEAD_ERROR,
							c->GetValueLine(), c->GetValueColumn(),
							(*s)->GetSymbolName());
						return RESOLVE_UNDEFINED;
					}
			}
		}
		while(p) // A list of integer value references
		{
			c = listOfComponents->GetNext(p);
			s = c->GetValue();
			SIMCSymbol **typeRef;
			switch(SIMCModule::IsValueReference(s, typeRef, vref))
			{
				case RESOLVE_IMPORT:
					if(local)
						return RESOLVE_IMPORT;
					else
					{
						SemanticError(fileName, OID_RESOLUTION,
							c->GetValueLine(), c->GetValueColumn(),
							(*s)->GetSymbolName());
						return RESOLVE_UNDEFINED;
					}
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
						SemanticError(fileName, OID_RESOLUTION,
							c->GetValueLine(), c->GetValueColumn(),
							(*s)->GetSymbolName());
						return RESOLVE_UNDEFINED;
			}

			v = vref->GetValue();
			if( SIMCModule::GetValueClass(v) != SIMCModule::VALUE_INTEGER)
			{
				SemanticError(fileName, OID_RESOLUTION,
					c->GetValueLine(), c->GetValueColumn(),
					(*s)->GetSymbolName());
				return RESOLVE_UNDEFINED;
			}
			val = ((SIMCIntegerValue *)(v))->GetIntegerValue();
			if(val == 0 )
				SemanticError(fileName, ZERO_IN_OID,
					c->GetValueLine(), c->GetValueColumn());
			if(val < 0)
			{
				SemanticError(fileName, OID_NEGATIVE_INTEGER,
					c->GetValueLine(), c->GetValueColumn());
				return RESOLVE_UNDEFINED;
			}
			result.AddTail(val);
		}
	}

	return RESOLVE_CORRECT;
}


BOOL SIMCParseTree::CheckOidTree(BOOL local)
{
	return _theTree.CheckOidTree(local, this);
}

// Fabricates all the NOTIFICATION-TYPEs resulting from TRAP-TYPE invocations
// An  then fabricates NOTIFICATION-GROUPs resulting from NOTIFICATION-TYPE invocations
BOOL SIMCParseTree::FabricateNotificationGroups()
{
	BOOL retVal = TRUE;
	//Fabricate for all modules in the list
	POSITION p = _listOfModules->GetHeadPosition();
	SIMCModule *m;
	while(p)
	{
		m = _listOfModules->GetNext(p);
		retVal= m->FabricateNotificationGroups(*this, _theTree) && retVal;
	}
	return retVal;
}
  
  
// Just a static function to remove underscores from a fabricated module identitiy name
static void RemoveUnderscores(CString& moduleIdentityName)
{
	char *temp = new char[moduleIdentityName.GetLength()];
	int j = 0;
	for(int i=0; i < moduleIdentityName.GetLength();  i++)
	{
		if(moduleIdentityName[i] != '-')
			temp[j++] = moduleIdentityName[i];
	}
	temp[j] = NULL;
	moduleIdentityName = temp;
	delete temp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\value.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>
#include <strstrea.h>
#include "precomp.h"
#include <snmptempl.h>


#include "bool.hpp"
#include "newString.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "value.hpp"

BOOL IsLessThan(long a, BOOL aUnsigned, long b, BOOL bUnsigned)
{
	if(aUnsigned)
	{
		if(bUnsigned)
			// a and b are unsigned
			return (unsigned long)a < (unsigned long)b;
		else
			// a is unsigned, b is signed
			return FALSE;
	}
	else // a is signed
	{
		if(bUnsigned)
			// a is signed, b is unsigned
			return (a == 0)? b != 0 : TRUE; 
		else
			// a and b a re signed
			return a < b;
	}
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsm\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <windows.h>

BOOL   WINAPI   DllMain (HANDLE hInst, 
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\typeref.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include "bool.hpp"
#include "newString.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "typeRef.hpp"




void SIMCDefinedTypeReference::WriteSymbol( ostream& outStream ) const
{
	outStream << "DefinedTypeReference " ;
	SIMCSymbol::WriteSymbol(outStream);

	outStream << "TYPE DETAILS "  ;
	(*_type)->WriteBrief(outStream);
	outStream << endl;

	switch(_status)
	{
		case RESOLVE_UNSET:
			outStream << "UNSET RESOLUTION" << endl;
			break;
		case RESOLVE_UNDEFINED:
			outStream << "UNDEFINED RESOLUTION" << endl;
			break;
		case RESOLVE_IMPORT:
			outStream << "RESOLVES TO IMPORT" << endl;
			break;
		case RESOLVE_CORRECT:
			outStream << "RESOLVES TO " << _realType->GetSymbolName()
				<< endl;
			break;
	}
}


SIMCTextualConvention::SIMCTextualConvention(const char * const displayHint,
	SIMCTCStatusType status,
	long statusLine, long statusColumn,
	const char * const description,
	const char * const reference,
	SIMCSymbol **type,
	long typeLine,
	long typeColumn,
	const char * const symbolName,
	SymbolType symbolType,
	SIMCModule *module,
	long lineNumber, long columnNumber,
	long referenceCount)
	: _statusLine(statusLine), _statusColumn(statusColumn),
		SIMCDefinedTypeReference( type, typeLine, typeColumn,
			symbolName, symbolType, module, lineNumber, columnNumber,
			referenceCount)
{
   _displayHint = NewString(displayHint);
   _status = status;
   _description = NewString(description);
   _reference = NewString(reference);
}

SIMCTextualConvention::SIMCTCStatusType SIMCTextualConvention::StringToStatusType (const char * const s)
{
	if(s)
	{
		if(strcmp(s, "current") == 0)
			return TC_CURRENT;
		else if (strcmp(s, "deprecated") == 0)
			return TC_DEPRECATED;
		else if (strcmp(s, "obsolete") == 0)
			return TC_OBSOLETE;
		else
			return TC_INVALID;
	}
	return TC_INVALID;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsm\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\yylex.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <stdio.h>		// uses printf(), et cetera
#include <stdarg.h>		// uses va_list
#include <stdlib.h>		// uses exit()
#include <string.h>		// uses memmove()

#ifdef LEX_WINDOWS

// define, if not already defined
// the flag YYEXIT, which will allow
// graceful exits from yylex()
// without resorting to calling exit();

#ifndef YYEXIT
#define YYEXIT	1
#endif // YYEXIT

// include the windows specific prototypes, macros, etc

#include "precomp.h"

// the following is the handle to the current
// instance of a windows program. The user
// program calling yylex must supply this!

extern HANDLE hInst;	

#endif /* LEX_WINDOWS */

class yy_scan {
protected:

#ifdef LEX_WINDOWS

	// protected member function for actual scanning 

	int win_yylex();

#endif /* LEX_WINDOWS */

	yy_state_t * state;		// state buffer
	int	size;			// length of state buffer
	int	mustfree;		// set if space is allocated
	int	yy_end;			// end of pushback
	int	yy_start;		// start state
	int	yy_lastc;		// previous char
#ifdef YYEXIT
	int yyLexFatal;		// Lex Fatal Error Flag
#endif // YYEXIT
#ifndef YY_PRESERVE	// efficient default push-back scheme
	char save;		// saved yytext[yyleng]
#else			// slower push-back for yytext mungers
	char *save;		// saved yytext[]
	char *push;
#endif

public:
	char   *yytext;		// yytext text buffer
	FILE   *yyin;			// input stream
	FILE   *yyout;			// output stream
	int	yylineno;		// line number
	int	yyleng;			// yytext token length

	yy_scan(int = 100);	// constructor for this scanner
			// default token & pushback size is 100 bytes
	yy_scan(int, char*, char*, yy_state_t*);
				// constructor when tables are given

	~yy_scan();		// destructor

	int	yylex();		// begin a scan

	virtual int	yygetc() {	// scanner source of input characters
		return getc(yyin);
	}

	virtual int	yywrap() { return 1; }	// EOF processing

	virtual void	yyerror(char *,...);	// print error message

	virtual void	output(int c) { putc(c, yyout); }

#ifdef YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and set error flag
		yyerror(msg); yyLexFatal = 1;
	}
#else // YYEXIT
	virtual void	YY_FATAL(char * msg) {	// print message and stop
		yyerror(msg); exit(1);
	}
#endif // YYEXIT
	virtual void	ECHO() {		// print matched input
		fputs((const char *) yytext, yyout);
	}
	int	input();		// user-callable get-input
	int	unput(int c);		// user-callable unput character
	void	yy_reset();		// reset scanner
	void	setinput(FILE * in) {		// switch input streams
		yyin = in;
	}
	void	setoutput(FILE * out) {	// switch output
		yyout = out;
	}
	void	NLSTATE() { yy_lastc = YYNEWLINE; }
	void	YY_INIT() {
		yy_start = 0;
		yyleng = yy_end = 0;
		yy_lastc = YYNEWLINE;
	}
	void	YY_USER() {		// set up yytext for user
#ifndef YY_PRESERVE
		save = yytext[yyleng];
#else
		size_t n = yy_end - yyleng;
		push = save+size - n;
		if (n > 0)
			memmove(push, yytext+yyleng, n);
#endif
		yytext[yyleng] = 0;
	}
	void YY_SCANNER() {		// set up yytext for scanner
#ifndef YY_PRESERVE
		yytext[yyleng] = save;
#else
		size_t n = save+size - push;
		if (n > 0)
			memmove(yytext+yyleng, push, n);
		yy_end = yyleng + n;
#endif
	}
	void	yyless(int n) {		// trim input to 'n' bytes
		if (n >= 0 && n <= yy_end) {
			YY_SCANNER();
			yyleng = n;
			YY_USER();
		}
	}
	void	yycomment(char *const mat); // skip comment input
	int	yymapch(int delim, int escape);	// map C escapes
} ;
@ END OF HEADER @
// MKS LEX prototype scanner code
// Copyright 1991 by Mortice Kern Systems Inc.
// All rights reserved.

// You can redefine YY_INTERACTIVE to be 0 to get a very slightly
// faster scanner:
#ifndef YY_INTERACTIVE
#define	YY_INTERACTIVE	1
#endif

// You can compile with -DYY_DEBUG to get a print trace of the scanner
#ifdef YY_DEBUG
#undef YY_DEBUG
#define YY_DEBUG(fmt,a1,a2)	fprintf(stderr,fmt,a1,a2)
#else
#define YY_DEBUG(fmt,a1,a2)
#endif

const MIN_NUM_STATES = 20;

// Do *NOT* redefine the following:
#define	BEGIN		yy_start =
#define	REJECT		goto yy_reject
#define	yymore()	goto yy_more

@ GLOBAL DECLARATIONS @

// Constructor for yy_scan. Set up tables
#pragma argsused
yy_scan::yy_scan(int sz, char* buf, char* sv, yy_state_t* states)
{
	mustfree = 0;
	if ((size = sz) < MIN_NUM_STATES
	  || (yytext = buf) == 0
	  || (state = states) == 0) {
		yyerror("Bad space for scanner!");
		exit(1);
	}
#ifdef YY_PRESERVE
	save = sv;
#endif
}
// Constructor for yy_scan. Set up tables
yy_scan::yy_scan(int sz)
{
	size = sz;
	yytext = new char[sz+1];	// text buffer
	state = new yy_state_t[sz+1];	// state buffer
#ifdef YY_PRESERVE
	save = new char[sz];	// saved yytext[]
	push = save + sz;
#endif
	if (yytext == NULL
#ifdef YY_PRESERVE
	  || save == NULL
#endif
	  || state == NULL) {
		yyerror("No space for scanner!");
		exit(1);
	}
	mustfree = 1;
	yy_end = 0;
	yy_start = 0;
	yy_lastc = YYNEWLINE;
	yyin = stdin;
	yyout = stdout;
	yylineno = 1;
	yyleng = 0;
}

// Descructor for yy_scan
yy_scan::~yy_scan()
{
	if (mustfree) {
		mustfree = 0;
		delete(yytext);
		delete(state);
#ifdef YY_PRESERVE
		delete(save);
#endif
	}
}

// Print error message, showing current line number
void
yy_scan::yyerror(char *fmt, ...)
{
	va_list va;

	va_start(va, fmt);
#ifdef LEX_WINDOWS
	// Windows has no concept of a standard error output!
	// send output to yyout as a simple solution
	if (yylineno)
		fprintf(yyout, "%d: ", yylineno);
	(void) vfprintf(yyout, fmt, va);
	fputc('\n', yyout);
#else /* LEX_WINDOWS */
	if (yylineno)
		fprintf(stderr, "%d: ", yylineno);
	(void) vfprintf(stderr, fmt, va);
	fputc('\n', stderr);
#endif /* LEX_WINDOWS */
	va_end(va);
}


#ifdef LEX_WINDOWS

// The initial portion of the lex scanner
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yylex() to acutally begin the
// scanning. When complete, win_yylex() will return a
// value back to our new yylex() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yylex().

int
yy_scan::yylex()
{
	int wReturnValue;
	HANDLE hRes_table;
	unsigned short *old_yy_la_act;	// remember previous pointer values
	short *old_yy_final;
	yy_state_t *old_yy_begin;
	yy_state_t *old_yy_next;
	yy_state_t *old_yy_check;
	yy_state_t *old_yy_default;
	short *old_yy_base;

	// the following code will load the required
	// resources for a Windows based parser. 

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyLEX", "yyLEXTBL"));
	
	// return an error code if any
	// of the resources did not load 

	if (hRes_table == (HANDLE)NULL) 
		return (0);
	
	// the following code will lock the resources
	// into fixed memory locations for the scanner
	// (remember previous pointer locations)

	old_yy_la_act = yy_la_act;
	old_yy_final = yy_final;
	old_yy_begin = yy_begin;
	old_yy_next = yy_next;
	old_yy_check = yy_check;
	old_yy_default = yy_default;
	old_yy_base = yy_base;

	yy_la_act = (unsigned short *)LockResource (hRes_table);
	yy_final = (short *)(yy_la_act + Sizeof_yy_la_act);
	yy_begin = (yy_state_t *)(yy_final + Sizeof_yy_final);
	yy_next = (yy_state_t *)(yy_begin + Sizeof_yy_begin);
	yy_check = (yy_state_t *)(yy_next + Sizeof_yy_next);
	yy_default = (yy_state_t *)(yy_check + Sizeof_yy_check);
	yy_base = (short *)(yy_default + Sizeof_yy_default);


	// call the standard yylex() code

	wReturnValue = win_yylex();

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previously saved pointers
	//

	yy_la_act = old_yy_la_act;
	yy_final = old_yy_final;
	yy_begin = old_yy_begin;
	yy_next = old_yy_next;
	yy_check = old_yy_check;
	yy_default = old_yy_default;
	yy_base = old_yy_base;

	return (wReturnValue);
}	// end yylex()

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 

int 
yy_scan::win_yylex()

#else /* LEX_WINDOWS */

// The actual lex scanner
// yy_sbuf[0:yyleng-1] contains the states corresponding to yytext.
// yytext[0:yyleng-1] contains the current token.
// yytext[yyleng:yy_end-1] contains pushed-back characters.
// When the user action routine is active,
// save contains yytext[yyleng], which is set to '\0'.
// Things are different when YY_PRESERVE is defined. 
int
yy_scan::yylex()
#endif /* LEX_WINDOWS */

{
	int c, i, yybase;
	unsigned  yyst;		/* state */
	int yyfmin, yyfmax;	/* yy_la_act indices of final states */
	int yyoldi, yyoleng;	/* base i, yyleng before look-ahead */
	int yyeof;		/* 1 if eof has already been read */
@ LOCAL DECLARATIONS @

#ifdef YYEXIT
	yyLexFatal = 0;
#endif
	yyeof = 0;
	i = yyleng;
	YY_SCANNER();

  yy_again:
	if ((yyleng = i) > 0) {
		yy_lastc = yytext[i-1];	// determine previous char
		while (i > 0)	//	// scan previously token
			if (yytext[--i] == YYNEWLINE)	// fix yylineno
				yylineno++;
	}
	yy_end -= yyleng;		// adjust pushback
	memmove(yytext, yytext+yyleng, (size_t) yy_end);
	i = 0;

  yy_contin:
	yyoldi = i;

	/* run the state machine until it jams */
	yyst = yy_begin[yy_start + (yy_lastc == YYNEWLINE)];
	state[i] = (yy_state_t) yyst;
	do {
		YY_DEBUG("<state %d, i = %d>\n", yyst, i);
		if (i >= size) {
			YY_FATAL("Token buffer overflow");
#ifdef YYEXIT
			if (yyLexFatal)
				return -2;
#endif
		}	/* endif */

		/* get input char */
		if (i < yy_end)
			c = yytext[i];		/* get pushback char */
		else if (!yyeof && (c = yygetc()) != EOF) {
			yy_end = i+1;
			yytext[i] = c;
		} else /* c == EOF */ {
			c = EOF;		/* just to make sure... */
			if (i == yyoldi) {	/* no token */
				yyeof = 0;
				if (yywrap())
					return 0;
				else
					goto yy_again;
			} else {
				yyeof = 1;	/* don't re-read EOF */
				break;
			}
		}
		YY_DEBUG("<input %d = 0x%02x>\n", c, c);

		/* look up next state */
		while ((yybase = yy_base[yyst]+(unsigned char)c) > yy_nxtmax
		    || yy_check[yybase] != (yy_state_t) yyst) {
			if (yyst == yy_endst)
				goto yy_jammed;
			yyst = yy_default[yyst];
		}
		yyst = yy_next[yybase];
	  yy_jammed: ;
	     state[++i] = (yy_state_t) yyst;
	} while (!(yyst == yy_endst || YY_INTERACTIVE &&
		yy_base[yyst] > yy_nxtmax && yy_default[yyst] == yy_endst));

	YY_DEBUG("<stopped %d, i = %d>\n", yyst, i);
	if (yyst != yy_endst)
		++i;

  yy_search:
	/* search backward for a final state */
	while (--i > yyoldi) {
		yyst = state[i];
		if ((yyfmin = yy_final[yyst]) < (yyfmax = yy_final[yyst+1]))
			goto yy_found;	/* found final state(s) */
	}
	/* no match, default action */
	i = yyoldi + 1;
	output(yytext[yyoldi]);
	goto yy_again;

  yy_found:
	YY_DEBUG("<final state %d, i = %d>\n", yyst, i);
	yyoleng = i;		/* save length for REJECT */
	
	// pushback look-ahead RHS, handling trailing context
	if ((c = (int)(yy_la_act[yyfmin]>>9) - 1) >= 0) {
		unsigned char *bv = yy_look + c*YY_LA_SIZE;
		static unsigned char bits [8] = {
			1<<0, 1<<1, 1<<2, 1<<3, 1<<4, 1<<5, 1<<6, 1<<7
		};
		while (1) {
			if (--i < yyoldi) {	/* no / */
				i = yyoleng;
				break;
			}
			yyst = state[i];
			if (bv[(unsigned)yyst/8] & bits[(unsigned)yyst%8])
				break;
		}
	}

	/* perform action */
	yyleng = i;
	YY_USER();
	switch (yy_la_act[yyfmin] & 0777) {
@ ACTION CODE @
	}
	YY_SCANNER();
	i = yyleng;
	goto yy_again;			/* action fell though */

  yy_reject:
	YY_SCANNER();
	i = yyoleng;			/* restore original yytext */
	if (++yyfmin < yyfmax)
		goto yy_found;		/* another final state, same length */
	else
		goto yy_search;		/* try shorter yytext */

  yy_more:
	YY_SCANNER();
	i = yyleng;
	if (i > 0)
		yy_lastc = yytext[i-1];
	goto yy_contin;
}

/*
 * user callable input/unput functions.
 */
void
yy_scan::yy_reset()
{
	YY_INIT();
	yylineno = 1;
}
/* get input char with pushback */
int
yy_scan::input()
{
	int c;
#ifndef YY_PRESERVE
	if (yy_end > yyleng) {
		yy_end--;
		memmove(yytext+yyleng, yytext+yyleng+1,
			(size_t) (yy_end-yyleng));
		c = save;
		YY_USER();
#else
	if (push < save+size) {
		c = *push++;
#endif
	} else
		c = yygetc();
	yy_lastc = c;
	if (c == YYNEWLINE)
		yylineno++;
	return c;
}

/* pushback char */
int
yy_scan::unput(int c)
{
#ifndef YY_PRESERVE
	if (yy_end >= size) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		if (yy_end > yyleng) {
			yytext[yyleng] = save;
			memmove(yytext+yyleng+1, yytext+yyleng,
				(size_t) (yy_end-yyleng));
			yytext[yyleng] = 0;
		}
		yy_end++;
		save = c;
#else
	if (push <= save) {
		YY_FATAL("Push-back buffer overflow");
	} else {
		*--push = c;
#endif
		if (c == YYNEWLINE)
			yylineno--;
	}	/* endif */
	return c;
}

@ end of yylex.cpp @
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\yyparse.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG $Y
#endif
#endif
$@
$H
// C++ YACC parser header
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// $p_parse => class defining a parsing object
//	$p_parse needs a class yy_scan, which defines the scanner.
// %prefix or option -p xx determines name of this class; if not used,
// defaults to 'yy_scan'
//
// constructor fills in the tables for this grammar; give it a size
//    to determine size of state and value stacks. Default is 150 entries.
// destructor discards those state and value stacks
//
// int yy_parse::yyparse(yy_scan *) invokes parse; if this returns,
//	it can be recalled to continue parsing at last point.
// void yy_parse::yyreset() can be called to reset the parse;
//	call yyreset() before $p_parse::yyparse(yy_scan *)
#include <stdio.h>		// uses printf(), et cetera
#include <stdlib.h>		// uses exit()

const YYERRCODE = 256;		// YACC 'error' value

// You can use these macros in your action code
#define YYERROR		goto yyerrlabel
#define YYACCEPT	YYRETURN(0)
#define YYABORT		YYRETURN(1)
#define YYRETURN(val)	return(val)

#if YYDEBUG
typedef struct yyNamedType_tag {	/* Tokens */
	char	* name;		/* printable name */
	short	token;		/* token # */
	short	type;		/* token type */
} yyNamedType;
typedef struct yyTypedRules_tag {	/* Typed rule table */
	char	* name;		/* compressed rule string */
	short	type;		/* rule result type */
} yyTypedRules;
#endif

#ifdef YACC_WINDOWS

// include all windows prototypes, macros, constants, etc.

#include "precomp.h"

// the following is the handle to the current
// instance of a windows program. The user
// program calling yyparse must supply this!

extern HANDLE hInst;	

#endif	/* YACC_WINDOWS */


class $p_parse {
protected:

#ifdef YACC_WINDOWS

	// protected member function for actual scanning 

	int	win_yyparse($p_scan * ps);	// parse with given scanner

#endif	/* YACC_WINDOWS */

	int	mustfree;	// set if tables should be deleted
	int	size;		// size of state and value stacks
	int	reset;		// if set, reset state
	short	yyi;		// table index
	short	yystate;	// current state

	short	* stateStack;	// states stack
	YYSTYPE	* valueStack;	// values stack
	short	* yyps;		// top of state stack
	YYSTYPE * yypv;		// top of value stack

	YYSTYPE yylval;		// saved yylval
	YYSTYPE	yyval;		// $$
	YYSTYPE * yypvt;	// $n
	int	yychar;		// current token
	int	yyerrflag;	// error flag
	int	yynerrs;	// error count
#if YYDEBUG
	int	done;		// set from trace to stop parse
	int	rule, npop;	// reduction rule # and length
	short	* typeStack;	// type stack to mirror valueStack[]
	short	* yytp;		// top of type stack
	char	* yygetState(int);	// read 'states.out'
#endif
public:
#if YYDEBUG
	// C++ has trouble with initialized arrays inside classes
	static long * States;		// pointer to yyStates[]
	static yyTypedRules * Rules;	// pointer to yyRules[]
	static yyNamedType * TokenTypes; // pointer to yyTokenTypes[]
	static int	yyntoken;	// number of tokens
	static int	yynvar;		// number of variables (nonterminals)
	static int	yynstate;	// number of YACC-generated states
	static int	yynrule;	// number of rules in grammar

	char*	yyptok(int);		// printable token string
	int	yyExpandName(int, int, char *, int);
						// expand encoded string
	virtual int	yyGetType(int);		// return type of token
	virtual void	yyShowRead();		// see newly read token
	virtual void	yyShowState();		// see state, value stacks
	virtual void	yyShowReduce();		// see reduction
	virtual void	yyShowGoto();		// see goto
	virtual void	yyShowShift();		// see shift
	virtual void	yyShowErrRecovery();	// see error recovery
	virtual void	yyShowErrDiscard();	// see token discard in error
#endif
	$p_scan* scan;			// pointer to scanner
	int	yydebug;	// if set, tracing if compiled with YYDEBUG=1

	$p_parse(int = 150);	// constructor for this grammar
	$p_parse(int, short *, YYSTYPE *);	// another constructor

	~$p_parse();		// destructor

	int	yyparse($p_scan * ps);	// parse with given scanner

	void	yyreset() { reset = 1; } // restore state for next yyparse()

	void	setdebug(int y) { yydebug = y; }

// The following are useful in user actions:

	void	yyerrok() { yyerrflag = 0; }	// clear error
	void	yyclearin() { yychar = -1; }	// clear input
	int	YYRECOVERING() { return yyerrflag != 0; }
};
// end of .hpp header
$E

$L#line 2 "$P"
// C++ YACC parser code
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// If YYDEBUG is defined as 1 and yy_parse::yydebug is set to 1,
// yyparse() will print a travelogue of its actions as it reads
// and parses input.
//
// YYSYNC can be defined to cause yyparse() to attempt to always
// hold a lookahead token

const YY_MIN_STATE_NUM = 20;	// not useful to be too small!

#if YYDEBUG
#ifdef YYTRACE
long	* $p_parse::States	= yyStates;
#endif
yyTypedRules * $p_parse::Rules	= yyRules;
yyNamedType * $p_parse::TokenTypes = yyTokenTypes;

#define YY_TRACE(fn) { done = 0; fn(); if (done) YYRETURN(-1); }
#endif

// Constructor for $p_parse: user-provided tables
$p_parse::$p_parse(int sz, short * states, YYSTYPE * stack)
{
	mustfree = 0;
	if ((size = sz) < YY_MIN_STATE_NUM
	 || (stateStack = states) == (short *) 0
	 || (valueStack = stack) == (YYSTYPE *) 0) {
		fprintf(stderr,"Bad state/stack given");
		exit(1);
	}
	reset = 1;		// force reset
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
	if (typeStack == (short *) 0) {
		fprintf(stderr,"Cannot allocate typeStack");
		exit(1);
	}
#endif
}
// Constructor for $p_parse: allocate tables with new
$p_parse::$p_parse(int sz)
{
	size = sz;
	reset = 1;		// force reset
	mustfree = 1;		// delete space in deconstructor
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
#endif
	stateStack = new short[size+1];
	valueStack = new YYSTYPE[size+1];

	if (stateStack == (short *) 0 || valueStack == (YYSTYPE *) 0
#if YYDEBUG
		|| typeStack == (short *) 0
#endif
	    ) {
		fprintf(stderr,"Not enough space for parser stacks");
		exit(1);
	}
}
// Destructor for class $p_parse
//	Free up space
$p_parse::~$p_parse()
{
	if (mustfree) {
		delete stateStack;
		delete valueStack;
	}
	stateStack = (short *) 0;
#if YYDEBUG
	delete typeStack;
#endif
}

#ifdef YACC_WINDOWS

// The initial portion of the yacc parser.
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yyparse() to acutally begin the
// parsing. When complete, win_yyparse() will return a
// value back to our new yyparse() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yyparse().

int
$p_parse::yyparse($p_scan* ps)
{
	int wReturnValue;
	HANDLE hRes_table;
	short *old_yydef;		// the following are used for saving
	short *old_yyex;		// the current pointers
	short *old_yyact;
	short *old_yypact;
	short *old_yygo;
	short *old_yypgo;
	short *old_yyrlen;

	// the following code will load the required
	// resources for a Windows based parser.

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyYACC", "yyYACCTBL"));
	
	// return an error code if any
	// of the resources did not load

	if (hRes_table == (HANDLE)NULL)
		return (1);
	
	// the following code will lock the resources
	// into fixed memory locations for the parser
	// (also, save away the old pointer values)

	old_yydef = yydef;
	old_yyex = yyex;
	old_yyact = yyact;
	old_yypact = yypact;
	old_yygo = yygo;
	old_yypgo = yypgo;
	old_yyrlen = yyrlen;

	yydef = (short *)LockResource (hRes_table);
	yyex = (short *)(yydef + Sizeof_yydef);
	yyact = (short *)(yyex + Sizeof_yyex);
	yypact = (short *)(yyact + Sizeof_yyact);
	yygo = (short *)(yypact + Sizeof_yypact);
	yypgo = (short *)(yygo + Sizeof_yygo);
	yyrlen = (short *)(yypgo + Sizeof_yypgo);

	// call the official yyparse() function

	wReturnValue = win_yyparse (ps);

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previous pointer values
	//

	yydef = old_yydef;
	yyex = old_yyex;
	yyact = old_yyact;
	yypact = old_yypact;
	yygo = old_yygo;
	yypgo = old_yypgo;
	yyrlen = old_yyrlen;

	return (wReturnValue);
}	// end yyparse()


// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start

int
$p_parse::win_yyparse($p_scan* ps)

#else /* YACC_WINDOWS */

// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start
int
$p_parse::yyparse($p_scan* ps)

#endif /* YACC_WINDOWS */

{
	short	* yyp, * yyq;		// table lookup
	int	yyj;
#if YYDEBUG
	int	yyruletype = 0;
#endif
$A
	if ((scan = ps) == ($p_scan *) 0) {	// scanner
		fprintf(stderr,"No scanner");
		exit(1);
	}

	if (reset) {			// start new parse
		yynerrs = 0;
		yyerrflag = 0;
		yyps = stateStack;
		yypv = valueStack;
#if YYDEBUG
		yytp = typeStack;
#endif
		yystate = YYS0;
		yyclearin();
		reset = 0;
	} else			// continue saved parse
		goto yyNext;			// after action

yyStack:
	if (++yyps > &stateStack[size]) {
		scan->yyerror("Parser stack overflow");
		YYABORT;
	}
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */
#if YYDEBUG
	if (yydebug) {
		*++yytp = yyruletype;	/* ... and type */
		YY_TRACE(yyShowState)
	}
#endif

	/*
	 * Look up next action in action table.
	 */
yyEncore:
#ifdef YYSYNC
	if (yychar < 0) {
		if ((yychar = scan->yylex()) < 0) {
			if (yychar == -2) YYABORT;
			yychar = 0;
		}	/* endif */
		yylval = ::yylval;
#if YYDEBUG
		if (yydebug)
			yyShowRead();	// show new input token
#endif
	}
#endif
#ifdef YACC_WINDOWS
	if (yystate >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	/* simple state */
#endif /* YACC_WINDOWS */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			/* Look for a shift on yychar */
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			yyq = yyp;
			yyi = yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;		/* stack value */
				yyclearin();		/* clear token */
				if (yyerrflag)
					yyerrflag--;	/* successful shift */
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

#ifdef YACC_WINDOWS
		if (yystate >= Sizeof_yydef) 	/* simple state */
#else /* YACC_WINDOWS */
		if (yystate >= sizeof yydef /sizeof yydef[0])
#endif /* YACC_WINDOWS */
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */

			/* Search exception table */
			yyp = &yyex[~yyi];
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
		}
	}

	yyj = yyrlen[yyi];

#if YYDEBUG
	if (yydebug) {
		npop = yyj; rule = yyi;
		YY_TRACE(yyShowReduce)
		yytp -= yyj;
	}
#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $$ = $1 */
#if YYDEBUG
	if (yydebug)
		yyruletype = yyRules[yyrmap[yyi]].type;
#endif
	switch (yyi) {		/* perform semantic action */
		$A
$L#line 343 "$P"
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}
yyNext:
	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)		/* busy little loop */
		;
	yystate = ~(yyi == *--yyp? yyq[yyq-yyp]: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		/* come here from YYERROR	*/
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--, yypv--;
#if YYDEBUG
		if (yydebug) yytp--;
#endif
	}
	
yyError:
	switch (yyerrflag) {

	case 0:		/* new error */
		yynerrs++;
		yyi = yychar;
		scan->yyerror("Syntax error");
		if (yyi != yychar) {
			/* user has changed the current token */
			/* try again */
			yyerrflag++;	/* avoid loops */
			goto yyEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		yyerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; yyps > stateStack; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*yyps >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
			if (*yyps >= sizeof yypact/sizeof yypact[0])
#endif /* YACC_WINDOWS */
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);
			if (YYERRCODE == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
				goto yyStack;
			}
				
			/* no shift in this state */
#if YYDEBUG
			if (yydebug && yyps > stateStack+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (yychar == 0)  /* but not EOF */
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin();
		goto yyEncore;	/* try again in same state */
	}
	YYABORT;

}
#if YYDEBUG
/*
 * Return type of token
 */
int
$p_parse::yyGetType(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}

	
// Print a token legibly.
char *
$p_parse::yyptok(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}
/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE

char *
yy_parse::yygetState(int num)
{
	int	size;
	char	*cp;
	static FILE *yyStatesFile = (FILE *) 0;
	static char yyReadBuf[YYMAX_READ+1];

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(States[num+1] - States[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - States[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, States[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
$p_parse::yyExpandName(int num, int isrule, char * buf, int len)
{
	int	i, n, cnt, type;
	char	* endp, * cp, * s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
/*
 * Show current state of yyparse
 */
void
$p_parse::yyShowState()
{
	(void) printf("state %d (%d), char %s (%d)\n%d stateStack entries\n",
		yysmap[yystate],yystate,yyptok(yychar),yychar,
		yypv - valueStack);
}
// show results of reduction: yyi is rule number
void
$p_parse::yyShowReduce()
{
	(void) printf("Reduce by rule %d (pop#=%d)\n", yyrmap[rule], npop);
}
// show read token
void
$p_parse::yyShowRead()
{
	(void) printf("read %s (%d)\n", yyptok(yychar), yychar);
}
// show Goto
void
$p_parse::yyShowGoto()
{
	(void) printf("goto %d (%d)\n", yysmap[yystate], yystate);
}
// show Shift
void
$p_parse::yyShowShift()
{
	(void) printf("shift %d (%d)\n", yysmap[yystate], yystate);
}
// show error recovery
void
$p_parse::yyShowErrRecovery()
{
	(void) printf("Error recovery pops state %d (%d), uncovers %d (%d)\n",
		yysmap[*(yyps-1)], *(yyps-1), yysmap[yystate], yystate);
}
// show token discards in error processing
void
$p_parse::yyShowErrDiscard()
{
	(void) printf("Error recovery discards %s (%d), ",
		yyptok(yychar), yychar);
}
#endif	/* ! YYTRACE */
#endif	/* YYDEBUG */
$T
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsm\resource.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smierrsm.rc
//
#define OBJ_TYPE_SYNTAX_RESOLUTION      1
#define OBJ_TYPE_INVALID_ACCESS         2
#define OBJ_TYPE_INVALID_STATUS         3
#define OBJ_TYPE_SINGULAR_COUNTER       4
#define OBJ_TYPE_ACCESSIBLE_TABLE       5
#define OBJ_TYPE_SEQUENCE_NO_INDEX      6
#define OBJ_TYPE_SEQUENCE_MULTI_REFERENCE 7
#define OBJ_TYPE_SEQUENCE_UNUSED        8
#define SEQUENCE_WRONG_CHILD            9
#define OBJ_TYPE_WRONG_CHILD            10
#define OBJ_TYPE_SEQUENCE_INVALID_SYNTAX 11
#define OBJ_TYPE_INDEX_UNNECESSARY      12
#define INVALID_SEQUENCE_OF             13
#define OBJ_TYPE_ZERO_IN_OID            14
#define ZERO_IN_OID                     14
#define OBJ_TYPE_DUPLICATE_OID          15
#define OBJ_TYPE_INVALID_DEFVAL         16
#define OBJ_TYPE_OID_RESOLUTION         17
#define TRAP_TYPE_ENTERPRISE_RESOLUTION 18
#define TRAP_TYPE_DUPLICATE_VALUES      19
#define TRAP_TYPE_VALUE_RESOLUTION      20
#define TRAP_TYPE_VARIABLES_RESOLUTION  21
#define VALUE_ASSIGN_MISMATCH           22
#define VALUE_ASSIGN_RESOLUTION         23
#define OID_NEGATIVE_INTEGER            24
#define OID_RESOLUTION                  25
#define OID_HEAD_ERROR                  26
#define IMPORT_UNUSED                   27
#define IMPORT_MODULE_ABSENT            28
#define IMPORT_CURRENT                  29
#define IMPORT_SYMBOL_ABSENT            30
#define IMPORT_KNOWN_WRONG_MODULE       31
#define ENUM_DUPLICATE_VALUE            32
#define ENUM_DUPLICATE_NAME             33
#define ENUM_ZERO_VALUE                 34
#define ENUM_NEGATIVE_VALUE             35
#define ENUM_RESOLUTION                 36
#define SIZE_TYPE_RESOLUTION            37
#define RANGE_TYPE_RESOLUTION           38
#define SIZE_INVALID_VALUE              39
#define SIZE_VALUE_RESOLUTION           40
#define RANGE_VALUE_RESOLUTION          41
#define RANGE_INVALID_BOUNDS            42
#define OBJ_TYPE_ACCESSIBLE_ROW         43
#define SYMBOL_REDEFINITION             44
#define KNOWN_REDEFINITION              45
#define KNOWN_UNDEFINED                 46
#define TYPE_UNREFERENCED               47
#define VALUE_UNREFERENCED              48
#define OBJ_TYPE_DEFVAL_NET_ADDR        49
#define SYMBOL_UNDEFINED                50
#define IMPORT_AMBIGUOUS_REFERENCE      51
#define OBJ_TYPE_DEFVAL_DISALLOWED      52
#define OBJ_TYPE_DEFVAL_RESOLUTION      53
#define OBJ_TYPE_INDEX_RESOLUTION       54
#define OBJ_TYPE_INDEX_SYNTAX           55
#define TYPE_UNRESOLVED                 56
#define VALUE_UNRESOLVED                57
#define SUBTYPE_ROOT_RESOLUTION         58
#define VALUE_ASSIGN_INVALID            60
#define RANGE_NEGATIVE_GAUGE            62
#define SIZE_INVALID_BOUNDS             63
#define SEQUENCE_ITEM_NO_OBJECT         64
#define SEQUENCE_TYPE_UNRESOLVED        65
#define INTEGER_TOO_BIG                 66
#define VALUE_ASSIGN_ENUM_INVALID       68
#define VALUE_ASSIGN_NEGATIVE_INTEGER   69
#define IR_MODULE_MISSING               70
#define IR_MODULE_MISSING_FATAL         70
#define IR_SYMBOL_MISSING               71
#define IR_SYMBOL_MISSING_FATAL         71
#define OBJ_TYPE_PRIMITIVE_CHILD        72
#define OBJ_TYPE_SEQUENCE_CHILD         73
#define OBJ_TYPE_SEQUENCE_NO_PARENT     74
#define OBJ_TYPE_SEQUENCE_EXTRA_CHILD   75
#define OBJ_TYPE_SEQUENCE_OF_WRONG_CHILD 76
#define OBJ_TYPE_SEQUENCE_OF_SYNTAX_MISMATCH 77
#define OBJ_TYPE_SEQUENCE_OF_EXTRA_CHILD 78
#define STANDARD_AMBIGUOUS_REFERENCE    79
#define IR_MODULE_MISSING_WARNING       80
#define IR_SYMBOL_MISSING_WARNING       81
#define OBJ_IDENTITY_INVALID_STATUS     82
#define MODULE_NO_GROUPS                83
#define MODULE_IDENTITY_MISSING         84
#define MODULE_NO_GROUPS_V1             85
#define MODULE_NO_GROUPS_V2             86
#define TC_INVALID_STATUS               87
#define INVALID_BIT_VALUE               88
#define AUGMENTS_CLAUSE_RESOLUTION      89
#define IMPLIED_USELESS                 90
#define IMPLIED_FIXED_SIZE              91
#define IMPLIED_POSSIBLE_ZERO_SIZE      92
#define V1_ENUM_ONLY_INTEGER            93
#define V2_ENUM_ROOT_RESOLUTION         94
#define V2_ENUM_CLOSURE                 95
#define V2_BITS_ROOT_RESOLUTION         96
#define BITS_VALUE_RESOLUTION           97
#define BITS_DUPLICATE_VALUE            98
#define BITS_DUPLICATE_NAME             99
#define ENUM_OR_BITS_RESOLUTION         100
#define RANGE_BIG_RANGE                 101
#define NOTIFICATION_TYPE_INVALID_STATUS 102
#define OBJECT_IDENTITY_VALUE_RESOLUTION 103
#define NOTIFICATION_TYPE_VALUE_RESOLUTION 104
#define NOTIFICATION_TYPE_OBJECTS_RESOLUTION 105
#define NOTIFICATION_TYPE_UNACCESSIBLE_OBJECT 106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\ui.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <stdlib.h>
#include <string.h>
#include <limits.h>

#include <iostream.h>

#include "precomp.h"
#include <snmptempl.h>

#include <winbase.h>

#include "bool.hpp"
#include "newString.hpp"
#include "ui.hpp"

CString SIMCUI::commandArgumentStrings[SIMCUI::COMMAND_MAX] =
{
	"",
	"/lc",
	"/ec",
	"/a",
	"/sa",
	"/g",
	"/gc",
	"/d",
	"/p",
	"/l",
	"/h",
	"/?",
	"/n",
	"/ni",
	"/r",
	"/pa",
	"/pd",
	"/pl"
};

CString SIMCUI::diagnosticLevelSwitch		= "/m";
CString SIMCUI::maxDiagnosticCountSwitch	= "/c";
CString SIMCUI::snmpV1VersionSwitch			= "/v1";
CString SIMCUI::snmpV2VersionSwitch			= "/v2c";
CString SIMCUI::suppressTextSwitch			= "/s";
CString SIMCUI::undocumentedDebugSwitch		= "/z";
CString SIMCUI::autoSwitch					= "/auto";
CString SIMCUI::includePathSwitch			= "/i";
CString SIMCUI::contextInfoSwitch			= "/ch";
CString SIMCUI::notificationsSwitch			= "/t";
CString SIMCUI::extendedNotificationsSwitch	= "/ext";
CString SIMCUI::notificationsOnlySwitch		= "/o";
CString SIMCUI::yesSwitch					= "/y";
 
const char * const SIMCUI::commandLineErrors[] =
	{
		"",


"================================================================================\n"
"           COMMAND-LINE SYNTAX FOR smi2smir, the MIB compiler\n"
"================================================================================\n"
"Usage:\n"
"\n"
   "\tsmi2smir [<DiagnosticArgs>] [<VersionArgs>] [<IncludeDirs>] \n"
		"\t\t<CommandArgs> <MIB file> [<Import Files>]\n"
   "\tsmi2smir [<DiagnosticArgs>] <RegistryArgs> [<Directory>]\n"
   "\tsmi2smir <ModuleInfoArgs> <MIB file>\n"
   "\tsmi2smir <HelpArgs>\n"
"\n"
"DiagnosticArgs:\n"
"---------------	 \n"
       "\t/m <diagnostic level> - Specifies the kind of diagnostics to display: \n"
              "\t\t0 (silent), 1 (fatal), 2 (fatal and warning), or 3 (fatal, \n"
              "\t\twarning, and information messages).\n"
       "\t/c <count> - Specifies the maximum number of fatal and warning \n"
              "\t\tmessages to display.\n"
"\n"
"VersionArgs:\n"
"------------\n"
       "\t/v1  - Specifies strict conformance to the SNMPv1 SMI.\n"
       "\t/v2c - Specifies strict conformance to the SNMPv2 SMI.\n"
"\n"
"CommandArgs:\n"
"------------\n"
       "\t/d  -  Deletes the specified module from the SMIR.\n"
       "\t/p  -  Deletes all modules in the SMIR.\n"
       "\t/l  -  Lists all modules in the SMIR.\n"
       "\t/lc -  Performs a local syntax check on the module.\n"
       "\t/ec [<CommandModifier>] - Performs local and external checks on the \n"
              "\t\tmodule.\n"
       "\t/a  [<CommandModifier>] - Performs  local and  external checks and \n"
              "\t\tloads the module into the SMIR.\n"
       "\t/sa [<CommandModifier>] - Same as /a, but works silently.\n"
       "\t/g  [<CommandModifier>] - Generates a SMIR MOF file that can be \n"
              "\t\tloaded later into CIMOM (using the MOF compiler). Used by\n"
			  "\t\tthe SNMP class provider to dynamically provide classes to \n"
			  "\t\tone or more namespaces\n"
       "\t/gc [<CommandModifier>] - Generates a static MOF file that can be \n"
              "\t\tloaded later into CIMOM as static classes for a particular\n"
			  "\t\tnamespace.\n"
"\n"
"CommandModifiers:\n"
"------------------\n"
       "\t/ch   -  Generates context information (date, time, host, user, etc.)\n"
              "\t\tin the MOF file header. \n"
			  "\t\tUse with /g and /gc.\n"
       "\t/t    -  Also generates SnmpNotification classes. \n"
			  "\t\tUse with /a, /sa and /g.\n"
       "\t/ext  - Also generates SnmpExtendedNotification classes. \n"
			  "\t\tUse with /a, /sa and /g.\n"
       "\t/t /o - Generates only SnmpNotification classes. \n"
			  "\t\tUse with /a, /sa and /g.\n"
       "\t/ext /o - Generates only SnmpExtendedNotification classes. \n"
              "\t\tUse with /a, /sa and /g.\n"
       "\t/s    -  Does not map the text of the DESCRIPTION clause.\n"
              "\t\tUse with /a, /sa, /g, and /gc.    \n"
       "\t/auto - Rebuilds the MIB lookup table before completing \n"
			  "\t\t<CommandArg> switch. \n"
              "\t\tUse with /ec, /a, /g, and /gc.\n"
"\n"
"IncludeDirs:\n"
"-------------\n"
       "\t/i <directory> - Specifies a directory to be searched for dependent \n"
              "\t\tMIB modules. \n"
              "\t\tUse with /ec, /a, /sa, /g, and /gc.\n"
"RegistryArgs:\n"
"-------------\n"
       "\t/pa -  Adds the specified directory to the registry.\n"
              "\t\t(Default is current directory.)\n"
       "\t/pd -  Deletes the specified directory from the registry.\n"
              "\t\t(Default is current directory.)\n"
       "\t/pl -  Lists the MIB lookup directories in the registry.\n"
       "\t/r  -  Rebuilds the entire MIB lookup table.\n"
"\n"
"ModuleInfoArgs:\n"
"---------------\n"
       "\t/n  -  Returns the ASN.1 name of the specified module.\n"
       "\t/ni -  Returns the ASN.1 names of all imports modules \n"
			"\t\treferenced by the input module.\n"
"\n"
"HelpArgs:\n"
"---------\n"
       "\t/h  -  Displays this usage information.\n"
       "\t/?  -  Displays this usage information.\n"
"\n"
"For auto-detection of dependent MIBs, the following values of type REG_MULTI_SZ\n"
"must be set under the root key HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WBEM\\Providers\\SNMP\\Compiler:\n"
"\n"
      "\t\"File Path\" : An ordered list of directory names where MIBs are located.\n"
      "\t\"File Suffixes\" : An ordered list of file extensions for MIB files.\n"
"\n"
"For additional information, see the WBEM SDK documentation.\n",



		"Invalid argument(s) on command-line after ",
		"Diagnostic Level not specified for the /m switch",
		"Diagnostic Level must be 0, 1, 2 or 3 for the /m switch",
		"Maximum diagnostic count missing after the /c switch",
		// 106
		" is not a valid diagnostic count",
		" Filename(s) missing",
		"No command argument specified, or unknown command argument",
		"Module name missing",
		"No include path specified after the /i switch",
		"/o switch is useful only with the /t and /ext switches",
		"Invalid combination of command-line switches",
		"Invalid switch "
	};


// Handles all command-line errors


void SIMCUI::Usage(ErrorMessageSymbol errorSymbol, const char *infoString, 
				   BOOL shouldAbort)
{
	if( errorSymbol<ERROR_NONE || errorSymbol>MAX_COMMAND_LINE_ERROR)
	{
		cerr << "Panic: Unknown command-line error: " << int(errorSymbol) << endl;
 		return;
	}

	int errorIndex = errorSymbol - ERROR_NONE;
	
	switch(errorSymbol)
	{

		case ERROR_NONE:
		case USAGE:
					cout << commandLineErrors[USAGE] << endl; 
					break;

		case INVALID_ARGS: 
		case INVALID_SWITCH:
					cerr << _applicationName << ": " <<
							   commandLineErrors[errorIndex] << infoString << endl;
					break;

		case WRONG_DIAG_COUNT: 
				cerr << _applicationName << ": " <<
					infoString << commandLineErrors[errorIndex] << endl;
					break;

		default:
				cerr << _applicationName << ": " <<
					commandLineErrors[errorIndex] << endl;
	}
	
	if(shouldAbort) 
		exit(1);
}


SIMCUI::SIMCUI()
:	 _snmpVersion(0), _diagnosticLevel(2), _commandArgument(COMMAND_HELP1),
	_inputFileOrModuleName(""), _suppressText(FALSE), _diagnosticMaximumCount(INT_MAX),
	_autoRefresh(FALSE), _classDefinitionsOnly(FALSE), _contextInfo(FALSE)
{
}

void SIMCUI::CheckIncludePaths(int& nextArg, int argc, const char *argv[])
{
	BOOL done = FALSE;
	CString lowerCaseArgValue = "";
	while(1)
	{
		if(nextArg == argc)
			return;
		lowerCaseArgValue = argv[nextArg];
		lowerCaseArgValue.MakeLower();
		if(lowerCaseArgValue == includePathSwitch)
		{
			nextArg++;
			if(nextArg == argc)
			{
				Usage(MISSING_INCLUDE_PATH, FALSE);
				return;
			}
			else
				_includePaths.AddTail(argv[nextArg++]);
		}
		else
			return;
	}
}

BOOL SIMCUI::ProcessCommandLine(int argc,  const char *argv[]) 
{
	// Initialize default values as specified in the requirements spec.
	_snmpVersion = 0;
	_diagnosticLevel = 3; 
	_commandArgument = COMMAND_HELP1;
	_inputFileOrModuleName = "";
	_suppressText = FALSE;
	_diagnosticMaximumCount = INT_MAX;
	_simcDebug = FALSE;
	_autoRefresh = FALSE;
	_classDefinitionsOnly = FALSE;
	_contextInfo = FALSE;
	_notifications = FALSE;
	_extendedNotifications = FALSE;
	_notificationsOnly = FALSE;
	_confirmedPurge = FALSE;

	if (argc == 0 )
		return FALSE;
	
	_applicationName = argv[0];

	if (argc == 1)	// Nothing specified on the command-line 
	{
		_commandArgument = COMMAND_HELP1;
		return TRUE;
	}

	int nextArg = 0;
	CString nextLowerCaseArg = "";

	// Collect the commandline string
	for(nextArg=0; nextArg<argc; nextArg++)
	{
		_commandLine += argv[nextArg];
		_commandLine += " ";
	}

	char nameBuffer[BUFSIZ];
	DWORD nameSize = BUFSIZ;
	//	Set _dateAndTime
	SYSTEMTIME timeInfo;
	GetLocalTime(&timeInfo);
	sprintf(nameBuffer, "%02d/%02d/%02d:%02d:%02d:%02d",
		 timeInfo.wDay, timeInfo.wMonth, timeInfo.wYear,
		 timeInfo.wHour, timeInfo.wMinute, timeInfo.wSecond);
	_dateAndTime = nameBuffer;

	//	Set _currentDirectory
	nameSize = BUFSIZ;
	if(GetCurrentDirectory(nameSize, nameBuffer))
		_currentDirectory = nameBuffer;

	//	Set _hostName
	nameSize = BUFSIZ;
	if(GetComputerName(nameBuffer, &nameSize))
		_hostName = nameBuffer;

	//	Set _userName
	nameSize = BUFSIZ;
	if(::GetUserName(nameBuffer, &nameSize))
		_userName = nameBuffer;


	
	nextArg = 1;
	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	// Check for the undocumented /z switch
	if( undocumentedDebugSwitch == nextLowerCaseArg )
	{
		_simcDebug = TRUE;
		if(++nextArg == argc)
		{
			_commandArgument = COMMAND_HELP1;
			return TRUE;
		}
	}

	CheckIncludePaths(nextArg, argc, argv);
	if(nextArg == argc)
	{
		_commandArgument = COMMAND_HELP1;
		return TRUE;
	}

	// Check for /h or /? switches
	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	if (commandArgumentStrings[COMMAND_HELP1] == nextLowerCaseArg ||
			 commandArgumentStrings[COMMAND_HELP2] == nextLowerCaseArg )
	{
		_commandArgument = COMMAND_HELP1;
		if( ++nextArg != argc)
		{
			Usage(INVALID_ARGS, argv[nextArg-1], FALSE);
			return FALSE;
		}

		return TRUE;
	}


	CheckIncludePaths(nextArg, argc, argv);
	if( nextArg == argc)
	{
		Usage(INVALID_ARGS, argv[nextArg-1], FALSE);
		return FALSE;
	}

	// Check for diagnostic arguments
 	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
  	if (diagnosticLevelSwitch == nextLowerCaseArg)
	{
		if (++nextArg == argc)
			Usage(MISSING_DIAG_LEVEL);
	
		if (strcmp(argv[nextArg], "0") == 0 )
			_diagnosticLevel = 0;
		else if (strcmp(argv[nextArg], "1") == 0 )
			_diagnosticLevel = 1;
		else if (strcmp(argv[nextArg], "2") == 0 )
			_diagnosticLevel = 2;
		else if (strcmp(argv[nextArg], "3") == 0 )
			_diagnosticLevel = 3;
		else
			Usage(WRONG_DIAG_LEVEL);
		nextArg++;
	}

	CheckIncludePaths(nextArg, argc, argv);

	if( nextArg == argc  )
		return TRUE;

 	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	if (maxDiagnosticCountSwitch == nextLowerCaseArg)
	{
		if (++nextArg == argc)
			Usage(MISSING_DIAG_COUNT);
		
		char *invalidChars = NULL;
		_diagnosticMaximumCount=int(strtol(argv[nextArg], &invalidChars, 10));
	
		// Check if the diagnostic count is within bounds
		// And all character in the argument have been used by strtol()
		if( _diagnosticMaximumCount < 0 ||
			_diagnosticMaximumCount >= INT_MAX ||
			*invalidChars)
			Usage(WRONG_DIAG_COUNT, argv[nextArg]);
	
		nextArg++;
	}


	CheckIncludePaths(nextArg, argc, argv);

	if( nextArg == argc  )
		return TRUE;

	// Check for SNMPVersionArguments
 	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	BOOL foundVersionArgs = false;
	if ( snmpV2VersionSwitch == nextLowerCaseArg )
	{
		_snmpVersion = 2;
		nextArg++;
		foundVersionArgs = true;
	}
	else if ( snmpV1VersionSwitch == nextLowerCaseArg )
	{
		_snmpVersion = 1;
		nextArg++; 
		foundVersionArgs = true;
	}

	CheckIncludePaths(nextArg, argc, argv);

	if( nextArg == argc ) 
	{
		// Nothing specified on the command-line
		Usage(MISSING_FILE_NAME, FALSE);
		return FALSE;
	}

	// A flag to check if there were any command arguments.
	BOOL commandArgumentsFound = FALSE;

 	nextLowerCaseArg = argv[nextArg];
	nextLowerCaseArg.MakeLower();
	if (commandArgumentStrings[COMMAND_LOCAL_CHECK] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_LOCAL_CHECK;

		if (++nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}

		// The next argument should be the file name
		_inputFileOrModuleName = argv[nextArg++];
	}
	else if (	commandArgumentStrings[COMMAND_EXTERNAL_CHECK] == nextLowerCaseArg	)
	{
		commandArgumentsFound = _commandArgument = COMMAND_EXTERNAL_CHECK;
		if (++nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}


		CheckIncludePaths(nextArg, argc, argv);
		if (nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}

		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == autoSwitch )
		{
			_autoRefresh = TRUE;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

 		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == includePathSwitch)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}

		_inputFileOrModuleName = argv[nextArg++];

		while(nextArg != argc && argv[nextArg] != includePathSwitch)
			AddSubsidiaryFile(argv[nextArg++]);
	}
	else if(commandArgumentStrings[COMMAND_ADD] == nextLowerCaseArg				||
		commandArgumentStrings[COMMAND_GENERATE] == nextLowerCaseArg				||
		commandArgumentStrings[COMMAND_GENERATE_CLASSES_ONLY] == nextLowerCaseArg	||
		commandArgumentStrings[COMMAND_SILENT_ADD] == nextLowerCaseArg)
	{
		if (commandArgumentStrings[COMMAND_ADD] == nextLowerCaseArg)
			commandArgumentsFound = _commandArgument = COMMAND_ADD;	
		else if (commandArgumentStrings[COMMAND_SILENT_ADD] == nextLowerCaseArg)
 			commandArgumentsFound = _commandArgument = COMMAND_SILENT_ADD;
		else if (commandArgumentStrings[COMMAND_GENERATE] == nextLowerCaseArg)
			commandArgumentsFound = _commandArgument = COMMAND_GENERATE;
		else if (commandArgumentStrings[COMMAND_GENERATE_CLASSES_ONLY] == nextLowerCaseArg)
		{
			commandArgumentsFound = _commandArgument = COMMAND_GENERATE_CLASSES_ONLY;
			_classDefinitionsOnly = TRUE;
		}
		
		if (++nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}
	
		CheckIncludePaths(nextArg, argc, argv);
		if (nextArg == argc)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}

		// "/t" or "/ext"
 	  	nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == notificationsSwitch ||
		   nextLowerCaseArg == extendedNotificationsSwitch)
		{
			// /gc switch is useless with /ext and /t
			if(_commandArgument == COMMAND_GENERATE_CLASSES_ONLY)
			{
				Usage(INVALID_COMBINATION_OF_SWITCHES, FALSE);
				return FALSE;
			}

			if(nextLowerCaseArg == notificationsSwitch )
				_notifications = TRUE;
			else if	(nextLowerCaseArg == extendedNotificationsSwitch )
				_extendedNotifications = TRUE;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		// "/ext" or "/t"
 	  	nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == notificationsSwitch ||
		   nextLowerCaseArg == extendedNotificationsSwitch)
		{
			if(nextLowerCaseArg == notificationsSwitch )
			{
				if(_notifications)
				{
					Usage(INVALID_COMBINATION_OF_SWITCHES, FALSE);
					return FALSE;
				}
				else
					_notifications = TRUE;
			}
			else if	(nextLowerCaseArg == extendedNotificationsSwitch )
			{
				if(_extendedNotifications)
				{
					Usage(INVALID_COMBINATION_OF_SWITCHES, FALSE);
					return FALSE;
				}
				else
					_extendedNotifications = TRUE;
			}
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		// "/o"
 	  	nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == notificationsOnlySwitch)
		{
			if(_commandArgument == COMMAND_GENERATE_CLASSES_ONLY)
			{
				Usage(INVALID_COMBINATION_OF_SWITCHES, FALSE);
				return FALSE;
			}

			if(!_notifications && !_extendedNotifications)
			{
				Usage(NOTIFICATIONS_ONLY_USELESS, FALSE);
				return FALSE;
			}

			_notificationsOnly = true;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == autoSwitch )
		{
			_autoRefresh = TRUE;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == suppressTextSwitch )
		{
			_suppressText = TRUE;
			if (++nextArg == argc)
			{
				Usage(MISSING_FILE_NAME, FALSE);
				return FALSE;
			}
		}

		// Check for the /c switch in case of /g or /gc
		if (commandArgumentsFound == COMMAND_GENERATE ||
			commandArgumentsFound == COMMAND_GENERATE_CLASSES_ONLY)
		{
 			nextLowerCaseArg = argv[nextArg];
			nextLowerCaseArg.MakeLower();
			if(nextLowerCaseArg == contextInfoSwitch)
			{
				_contextInfo = TRUE;
				nextArg++;
			}

		}


 		nextLowerCaseArg = argv[nextArg];
		nextLowerCaseArg.MakeLower();
		if(nextLowerCaseArg == includePathSwitch)
		{
			Usage(MISSING_FILE_NAME, FALSE);
			return FALSE;
		}
		
		_inputFileOrModuleName = argv[nextArg++];

		while(nextArg != argc )
		{
			nextLowerCaseArg = argv[nextArg];
			nextLowerCaseArg.MakeLower();
			if(nextLowerCaseArg != includePathSwitch)
				AddSubsidiaryFile(argv[nextArg++]);
			else
				break;
		}
	}

	else if (commandArgumentStrings[COMMAND_DELETE] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_DELETE;
		if (++nextArg == argc)
			Usage(MISSING_MODULE_NAME); 		
		// The next argument should be the module name
		_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_PURGE] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_PURGE;
		nextArg++;

		if(nextArg != argc)
		{
			// Check for the /y switch
			nextLowerCaseArg = argv[nextArg];
			nextLowerCaseArg.MakeLower();
			if(yesSwitch == nextLowerCaseArg)
			{
				_confirmedPurge = TRUE;
				nextArg++;
			}
		}

	}
	else if (commandArgumentStrings[COMMAND_LIST] == nextLowerCaseArg )
	{
		commandArgumentsFound = _commandArgument = COMMAND_LIST;
		nextArg++;
	}
	else if (commandArgumentStrings[COMMAND_MODULE_NAME] == nextLowerCaseArg )
	{
		// Check for any invalid combination of switches
		if (foundVersionArgs )
			Usage(INVALID_COMBINATION_OF_SWITCHES);

		commandArgumentsFound = _commandArgument = COMMAND_MODULE_NAME;
		if (++nextArg == argc)
			Usage(MISSING_FILE_NAME); 		
		// The next argument should be the file name
		_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_IMPORTS_INFO] == nextLowerCaseArg )
	{
		if (foundVersionArgs )
			Usage(INVALID_COMBINATION_OF_SWITCHES);

		commandArgumentsFound = _commandArgument = COMMAND_IMPORTS_INFO;
		if (++nextArg == argc)
			Usage(MISSING_FILE_NAME); 		
		// The next argument should be the file name
		_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_REBUILD_TABLE] == nextLowerCaseArg)
	{
		if (foundVersionArgs )
			Usage(INVALID_COMBINATION_OF_SWITCHES);

		commandArgumentsFound = _commandArgument = COMMAND_REBUILD_TABLE;
		nextArg++;
	}
	else if (commandArgumentStrings[COMMAND_ADD_DIRECTORY] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_ADD_DIRECTORY;
		nextArg++;
		CheckIncludePaths(nextArg, argc, argv);
		
		if (nextArg == argc)
		{
			// Current directory is default for /pa switch
			char currentDirectory[BUFSIZ];
			long directoryLength = BUFSIZ;
			GetCurrentDirectory(directoryLength, currentDirectory);
			_inputFileOrModuleName = currentDirectory;
		}
		else
			// The next argument should be the file name
			_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_DELETE_DIRECTORY_ENTRY] == nextLowerCaseArg)
	{
		commandArgumentsFound = _commandArgument = COMMAND_DELETE_DIRECTORY_ENTRY;
		nextArg++;
		CheckIncludePaths(nextArg, argc, argv);
		if (nextArg == argc)
		{
			// Current directory is default for the /pd switch
			char currentDirectory[BUFSIZ];
			long directoryLength = BUFSIZ;
			GetCurrentDirectory(directoryLength, currentDirectory);
			_inputFileOrModuleName = currentDirectory;
		}
		else
			// The next argument should be the file name
			_inputFileOrModuleName = argv[nextArg++];
	}
	else if (commandArgumentStrings[COMMAND_LIST_MIB_PATHS] == nextLowerCaseArg)
	{
		if (foundVersionArgs )
			Usage(INVALID_COMBINATION_OF_SWITCHES);

		commandArgumentsFound = _commandArgument = COMMAND_LIST_MIB_PATHS;
		nextArg++;
	}


	CheckIncludePaths(nextArg, argc, argv);
	
	// Check for any residual args
	if (nextArg != argc )
		Usage((commandArgumentsFound)?INVALID_ARGS:MISSING_COMMAND_ARG, 
			argv[nextArg-1]);
	
	if(_inputFileOrModuleName[0] == '/')
	{
		Usage(INVALID_SWITCH, _inputFileOrModuleName);
		return FALSE;
	}

	return TRUE;
}

// This gets the FileVersion resource from the resource of the exe
CString SIMCUI::GetVersionNumber()
{
	CString executableName = _applicationName;
	if(_applicationName.Right(4) != ".exe")
		executableName += ".exe";

	unsigned long versionSize;
	// Get the size of the block required for the version information
	if(!(versionSize = GetFileVersionInfoSize((LPSTR)(LPCTSTR)executableName, &versionSize)))
		return CString("<UnknownVersion>");

	char *versionInfo = new char[versionSize];
	// Get the version block 
	if(GetFileVersionInfo((LPSTR)(LPCTSTR)executableName, NULL, versionSize, (LPVOID)versionInfo))
	{
		UINT length = 0;
		LPSTR lpBuffer = NULL;
		char *theFileVersion;

		if(VerQueryValue((LPVOID)versionInfo, 
              "\\StringFileInfo\\040904E4\\ProductVersion", 
			  (LPVOID *)&theFileVersion, 
              &length))
			return CString(theFileVersion);
		else
			return CString("<UnknownVersion>");
	}
	else
		return CString("<UnknownVersion>");
}

ostream& operator << ( ostream& outStream, const SIMCUI& obj)
{
	outStream << "APPLICATION: " << obj._applicationName << ", VERSION: " << obj._snmpVersion <<
		endl;
	outStream << "DIAGNOSTIC_LEVEL: " << obj._diagnosticLevel << ", DIAG_COUNT" << obj._diagnosticMaximumCount <<
		endl;

	switch(obj._commandArgument)
	{
		case SIMCUI::COMMAND_NONE:
			outStream << "COMMAND:  NONE" << endl; break;
		case SIMCUI::COMMAND_LOCAL_CHECK:
		case SIMCUI::COMMAND_EXTERNAL_CHECK:
		case SIMCUI::COMMAND_ADD:
		case SIMCUI::COMMAND_SILENT_ADD:
		case SIMCUI::COMMAND_GENERATE:
		case SIMCUI::COMMAND_DELETE:
			{
				outStream << "COMMAND: " << (int)obj._commandArgument << endl; 
				outStream << "Files: " << obj._inputFileOrModuleName << endl;
				outStream << endl;
				break;
			}
		case SIMCUI::COMMAND_PURGE:
			outStream << "COMMAND: PURGE" << endl; break; 
		case SIMCUI::COMMAND_LIST:
			outStream << "COMMAND: LIST" << endl;  break;
		case SIMCUI::COMMAND_HELP1:
		case SIMCUI::COMMAND_HELP2:
			outStream << "COMMAND: HELP" << endl;  break;
		case SIMCUI::COMMAND_MODULE_NAME:
			outStream << "COMMAND_MODULE_NAME" << endl;  break;
		case SIMCUI::COMMAND_IMPORTS_INFO:
			outStream << "COMMAND_IMPORTS_INFO: HELP" << endl;  break;
		case SIMCUI::COMMAND_REBUILD_TABLE:
			outStream << "COMMAND_REBUILD_TABLE" << endl;  break;
		default:
			outStream << "COMMAND: UNKNOWN" << endl;  break;
	}
	outStream << "END OF UI" << endl;
	return outStream;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\ytab.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG 1
#endif
#endif


#include <iostream.h>
#include <fstream.h>

#include <typeinfo.h>

#include "precomp.h"
#include <snmptempl.h>


#include "smierrsy.hpp"
#include "smierrsm.hpp"

#include "bool.hpp"
#include "newString.hpp"

#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "oidValue.hpp"
#include "objectType.hpp"
#include "objectTypeV1.hpp"
#include "objectTypeV2.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "objectIdentity.hpp"
#include "notificationGroup.hpp"
#include "module.hpp"

#include "errorMessage.hpp"
#include "errorContainer.hpp"
#include "stackValues.hpp"
#include <lex_yy.hpp>
#include <ytab.hpp>

#include "scanner.hpp"
#include "parser.hpp"


#define theScanner  (((SIMCParser *) this)->_theScanner)
#define theParser	((SIMCParser *) this)
#define theModule	(theParser->GetModule())

static SIMCModule * newImportModule = new SIMCModule;
static SIMCOidComponentList * newOidComponentList = new SIMCOidComponentList;
static SIMCBitValueList * newNameList = new SIMCBitValueList;
static SIMCIndexList *newIndexList = new SIMCIndexList;
static SIMCIndexListV2 *newIndexListV2 = new SIMCIndexListV2;
static SIMCVariablesList *newVariablesList = new SIMCVariablesList;
static SIMCObjectsList *newObjectsList = new SIMCObjectsList;
static SIMCRangeList *newRangeList = new SIMCRangeList;
static SIMCNamedNumberList *newNamedNumberList = new SIMCNamedNumberList;
static SIMCSequenceList *newSequenceList = new SIMCSequenceList;
static BOOL firstAssignment = TRUE;

static long HexCharToDecimal(char x)
{
	switch(x)
	{
		case '0':
			return 0;
		case '1':
			return 1;
		case '2':
			return 2;
		case '3':
			return 3;
		case '4':
			return 4;
		case '5':
			return 5;
		case '6':
			return 6;
		case '7':
			return 7;
		case '8':
			return 8;
		case '9':
			return 9;
		case 'a':
		case 'A':
			return 10;
		case 'b':
		case 'B':
			return 11;
		case 'c':
		case 'C':
			return 12;
		case 'd':
		case 'D':
			return 13;
		case 'e':
		case 'E':
			return 14;
		case 'f':
		case 'F':
			return 15;
	}
	return -1;
}

extern YYSTYPE yylval;
#if YYDEBUG
enum YY_Types { YY_t_NoneDefined, YY_t_yy_name, YY_t_yy_hex_string, YY_t_yy_binary_string, YY_t_yy_module, YY_t_yy_number, YY_t_yy_object_type, YY_t_yy_access, YY_t_yy_accessV2, YY_t_yy_status, YY_t_yy_statusV2, YY_t_yy_index, YY_t_yy_indexV2, YY_t_yy_variables_list, YY_t_yy_objects_list, YY_t_yy_symbol_ref, YY_t_yy_range_or_size_item, YY_t_yy_range_list, YY_t_yy_named_number_list, YY_t_yy_def_val, YY_t_yy_object_identity_status, YY_t_yy_notification_type_status
};
#endif
#if YYDEBUG
yyTypedRules yyRules[] = {
	{ "&000: %001 &000",  0},
	{ "%044:",  0},
	{ "%001: %005 %044 &021 %045 &006 %046 %047 &027",  0},
	{ "%005: &033",  1},
	{ "%005: &033 %025",  1},
	{ "%005: &049",  1},
	{ "%046: &036 %048 &065",  0},
	{ "%046: &036 &001 &065",  0},
	{ "%046: &036 %049 &065",  0},
	{ "%046: %050",  0},
	{ "%049: %051",  0},
	{ "%049: %050",  0},
	{ "%051: %051 %012",  0},
	{ "%051: %012",  0},
	{ "%012: %048 &032 %002",  4},
	{ "%012: &001 &032 %002",  4},
	{ "%002: &033 &040 %052 &060",  1},
	{ "%002: &033 &040 &001 &060",  1},
	{ "%002: &033",  1},
	{ "%048: %048 &013 %053",  0},
	{ "%048: %053",  0},
	{ "%053: &033",  0},
	{ "%053: &049",  0},
	{ "%053: %011",  0},
	{ "%011: &086",  1},
	{ "%011: &098",  1},
	{ "%011: &077",  1},
	{ "%011: &083",  1},
	{ "%011: &096",  1},
	{ "%011: &104",  1},
	{ "%011: &101",  1},
	{ "%011: &106",  1},
	{ "%011: &112",  1},
	{ "%011: &103",  1},
	{ "%047: %047 %054",  0},
	{ "%047: %050",  0},
	{ "%054: %055",  0},
	{ "%054: %013",  0},
	{ "%054: %056",  0},
	{ "%054: %057",  0},
	{ "%054: %058",  0},
	{ "%054: %059",  0},
	{ "%054: %060",  0},
	{ "%054: %061",  0},
	{ "%054: %062",  0},
	{ "%054: %063",  0},
	{ "%054: %064",  0},
	{ "%054: %065",  0},
	{ "%054: %066",  0},
	{ "%054: %067",  0},
	{ "%054: %068",  0},
	{ "%055: &049 &051 &034 %045 %025",  0},
	{ "%055: &049 &051 &034 %045 &001",  0},
	{ "%025: %022",  15},
	{ "%025: &040 %052 &060",  15},
	{ "%025: &040 &001 &060",  15},
	{ "%052: %069 %052",  0},
	{ "%052: %069",  0},
	{ "%069: %022",  0},
	{ "%069: &049 &046 &042 &063",  0},
	{ "%069: &049 &046 %022 &063",  0},
	{ "%069: &042",  0},
	{ "%013: &049 &086 %026 %014 %016 %007 %008 %018 %040 %045 %025",  6},
	{ "%013: &049 &086 %026 %014 %016 %007 %008 %018 %040 %045 &001",  6},
	{ "%013: &049 &086 &001 %045 %025",  6},
	{ "%026: &087 %027",  15},
	{ "%026: &087 &001",  15},
	{ "%014: &091 &049",  7},
	{ "%014: &091 &001",  7},
	{ "%016: &084 &049",  9},
	{ "%016: &084 &001",  9},
	{ "%007: &081 &045",  1},
	{ "%007: %050",  1},
	{ "%007: &081 &001",  1},
	{ "%008: &085 &045",  1},
	{ "%008: %050",  1},
	{ "%008: &085 &001",  1},
	{ "%018: &092 &040 %070 &060",  11},
	{ "%018: %050",  11},
	{ "%018: &092 &001",  11},
	{ "%070: %071",  0},
	{ "%070: %070 &013 %071",  0},
	{ "%071: %027",  0},
	{ "%071: %022",  0},
	{ "%040: &095 &040 %041 &060",  19},
	{ "%040: %050",  19},
	{ "%040: &095 &001",  19},
	{ "%041: &072",  19},
	{ "%041: &031",  19},
	{ "%041: &042",  19},
	{ "%041: &040 %052 &060",  19},
	{ "%041: &045",  19},
	{ "%041: &043",  19},
	{ "%041: &044",  19},
	{ "%041: &050",  19},
	{ "%041: &049",  19},
	{ "%041: &033 &022 &049",  19},
	{ "%058: &049 &086 %026 %010 %015 %017 %007 %008 %019 %040 %045 %025",  0},
	{ "%015: &090 &049",  8},
	{ "%015: &090 &001",  8},
	{ "%017: &084 &049",  10},
	{ "%017: &084 &001",  10},
	{ "%010: &089 &045",  1},
	{ "%010: %050",  1},
	{ "%019: &092 &040 %072 &060",  12},
	{ "%019: &094 &040 %022 &060",  12},
	{ "%019: %050",  12},
	{ "%019: &092 &001",  12},
	{ "%072: %073",  0},
	{ "%072: %072 &013 %073",  0},
	{ "%073: &093 %022",  0},
	{ "%073: %022",  0},
	{ "%056: &049 &098 %029 %020 %007 %008 %045 %034",  0},
	{ "%056: &049 &098 &001 %045 %034",  0},
	{ "%056: &049 &098 &001 %045 &001",  0},
	{ "%029: &099 %025",  15},
	{ "%029: &099 &001",  15},
	{ "%020: &100 &040 %074 &060",  13},
	{ "%020: %050",  13},
	{ "%020: &100 &001",  13},
	{ "%074: %075",  0},
	{ "%075: %076",  0},
	{ "%075: %075 &013 %076",  0},
	{ "%076: %022",  0},
	{ "%077: %078",  0},
	{ "%078: %079",  0},
	{ "%078: %078 &013 %079",  0},
	{ "%079: %080",  0},
	{ "%080: &049",  0},
	{ "%080: &033 &022 &049",  0},
	{ "%066: &033 %045 %027",  0},
	{ "%027: %028",  15},
	{ "%027: %030",  15},
	{ "%028: &009",  15},
	{ "%028: &051 &034",  15},
	{ "%028: %003",  15},
	{ "%028: &050",  15},
	{ "%028: %024 %039",  15},
	{ "%028: %004 %027",  15},
	{ "%028: &066 &040 %081 &060",  15},
	{ "%028: &066 &040 &001 &060",  15},
	{ "%024: &038",  15},
	{ "%024: &088",  15},
	{ "%024: %023",  15},
	{ "%039: &040 %082 &060",  18},
	{ "%039: %050",  18},
	{ "%039: &040 &001 &060",  18},
	{ "%082: %083",  0},
	{ "%082: %082 &013 %083",  0},
	{ "%083: &049 &046 %035 &063",  0},
	{ "%035: %034",  15},
	{ "%035: %033",  15},
	{ "%034: &042",  15},
	{ "%034: &043",  15},
	{ "%034: &044",  15},
	{ "%081: %081 &013 %084",  0},
	{ "%081: %084",  0},
	{ "%084: &049 %027",  0},
	{ "%067: &049 %045 %025",  0},
	{ "%068: &049 %027 %045 %031",  0},
	{ "%031: %032",  15},
	{ "%031: %033",  15},
	{ "%032: &072",  15},
	{ "%032: &031",  15},
	{ "%032: &042",  15},
	{ "%032: &043",  15},
	{ "%032: &044",  15},
	{ "%032: &040 %052 &060",  15},
	{ "%032: &040 %085 &060",  15},
	{ "%032: &045",  15},
	{ "%032: &050",  15},
	{ "%085: %086",  0},
	{ "%085: %085 &013 %086",  0},
	{ "%086: &049",  0},
	{ "%033: %022",  15},
	{ "%050:",  0},
	{ "%003: &052 &070",  1},
	{ "%003: &053",  1},
	{ "%004: &067",  1},
	{ "%004: &066 &054",  1},
	{ "%030: %027 %037",  15},
	{ "%030: %027 %038",  15},
	{ "%030: %027 &001",  15},
	{ "%037: &046 %087 %088 &063",  17},
	{ "%037: &046 &001 &063",  17},
	{ "%087: %036",  0},
	{ "%088: &005 %087 %088",  0},
	{ "%088: %050",  0},
	{ "%036: %034",  16},
	{ "%036: %034 &023 %034",  16},
	{ "%038: &046 &069 %037 &063",  17},
	{ "%038: &046 &069 &001 &063",  17},
	{ "%022: &033 &022 &049",  15},
	{ "%022: &049",  15},
	{ "%023: &033 &022 &033",  15},
	{ "%023: &033",  15},
	{ "%045: %006",  0},
	{ "%045: &011",  0},
	{ "%006: &118 &118",  1},
	{ "%006: &118 &119",  1},
	{ "%006: &119",  1},
	{ "%060: &049 &096 %021 %043 &081 &045 %008 %045 %025",  0},
	{ "%043: &084 &049",  21},
	{ "%021: &097 &040 %089 &060",  14},
	{ "%021: %050",  14},
	{ "%021: &097 &001",  14},
	{ "%089: %090",  0},
	{ "%090: %091",  0},
	{ "%090: %090 &013 %091",  0},
	{ "%091: %022",  0},
	{ "%057: &049 &077 &078 &045 &079 &045 &080 &045 &081 &045 %092 %045 %025",  0},
	{ "%092: %093",  0},
	{ "%092: %050",  0},
	{ "%093: %093 %094",  0},
	{ "%093: %094",  0},
	{ "%094: &082 &045 &081 &045",  0},
	{ "%059: &049 &083 %042 %007 %008 %045 %025",  0},
	{ "%042: &084 &049",  20},
	{ "%061: &033 %045 &101 %009 &084 &049 &081 &045 %008 &087 %027",  0},
	{ "%009: &102 &045",  1},
	{ "%009: %050",  1},
	{ "%062: &049 &103 &097 &040 %077 &060 &084 &049 &081 &045 %008 %045 %025",  0},
	{ "%063: &049 &104 &105 &040 %077 &060 &084 &049 &081 &045 %008 %045 %025",  0},
	{ "%064: &049 &106 &084 &049 &081 &045 %008 %095 %045 %025",  0},
	{ "%095: %096",  0},
	{ "%095: %050",  0},
	{ "%096: %096 %097",  0},
	{ "%096: %097",  0},
	{ "%097: &107 %098 %099 %100",  0},
	{ "%097: &107 %099 %100",  0},
	{ "%098: &033",  0},
	{ "%098: &033 %025",  0},
	{ "%099: &108 &040 %077 &060",  0},
	{ "%099: %050",  0},
	{ "%100: %101",  0},
	{ "%100: %050",  0},
	{ "%101: %101 %102",  0},
	{ "%101: %102",  0},
	{ "%102: &109 &049 &081 &045",  0},
	{ "%102: &051 &049 %103 %104 %105 &081 &045",  0},
	{ "%103: &087 %027",  0},
	{ "%103: %050",  0},
	{ "%104: &110 %027",  0},
	{ "%104: %050",  0},
	{ "%105: &111 &049",  0},
	{ "%105: %050",  0},
	{ "%065: &049 &112 &113 &045 &084 &049 &081 &045 %008 %106 %045 %025",  0},
	{ "%106: %107",  0},
	{ "%106: %050",  0},
	{ "%107: %107 %108",  0},
	{ "%107: %108",  0},
	{ "%108: &114 %109 &115 &040 %077 &060 %110",  0},
	{ "%109: &033 &040 %052 &060",  0},
	{ "%109: &033",  0},
	{ "%110: %111",  0},
	{ "%110: %050",  0},
	{ "%111: %111 %112",  0},
	{ "%111: %112",  0},
	{ "%112: &116 &049 %103 %104 %014 %113 %040 &081 &045",  0},
	{ "%113: &117 &040 %114 &060",  0},
	{ "%113: %050",  0},
	{ "%114: %077",  0},
	{ "%114: %050",  0},
{ "$accept",  0},{ "error",  0}
};
yyNamedType yyTokenTypes[] = {
	{ "$end",  0,  0},
	{ "error",  256,  0},
	{ "ABSENT",  257,  0},
	{ "ANY",  258,  0},
	{ "APPLICATION",  259,  0},
	{ "BAR",  260,  0},
	{ "BGIN",  261,  1},
	{ "BIT",  262,  0},
	{ "BITSTRING",  263,  0},
	{ "_BOOLEAN",  264,  1},
	{ "BY",  265,  0},
	{ "CCE",  266,  0},
	{ "CHOICE",  267,  0},
	{ "COMMA",  268,  0},
	{ "COMPONENT",  269,  0},
	{ "COMPONENTS",  270,  0},
	{ "COMPONENTSOF",  271,  0},
	{ "CONTROL",  272,  0},
	{ "DECODER",  273,  0},
	{ "DEFAULT",  274,  0},
	{ "DEFINED",  275,  0},
	{ "DEFINITIONS",  276,  1},
	{ "DOT",  277,  0},
	{ "DOTDOT",  278,  0},
	{ "DOTDOTDOT",  279,  0},
	{ "ENCODER",  280,  0},
	{ "ENCRYPTED",  281,  0},
	{ "END",  282,  1},
	{ "ENUMERATED",  283,  0},
	{ "EXPORTS",  284,  0},
	{ "EXPLICIT",  285,  0},
	{ "FALSE_VAL",  286,  1},
	{ "FROM",  287,  1},
	{ "ID",  288,  1},
	{ "IDENTIFIER",  289,  1},
	{ "IMPLICIT",  290,  0},
	{ "IMPORTS",  291,  1},
	{ "INCLUDES",  292,  0},
	{ "INTEGER",  293,  1},
	{ "LANGLE",  294,  0},
	{ "LBRACE",  295,  1},
	{ "LBRACKET",  296,  0},
	{ "LITNUMBER",  297,  5},
	{ "LIT_HEX_STRING",  298,  2},
	{ "LIT_BINARY_STRING",  299,  3},
	{ "LITSTRING",  300,  1},
	{ "LPAREN",  301,  0},
	{ "MIN",  302,  0},
	{ "MAX",  303,  0},
	{ "NAME",  304,  1},
	{ "NIL",  305,  1},
	{ "OBJECT",  306,  1},
	{ "OCTET",  307,  1},
	{ "OCTETSTRING",  308,  1},
	{ "OF",  309,  1},
	{ "PARAMETERTYPE",  310,  0},
	{ "PREFIXES",  311,  0},
	{ "PRESENT",  312,  0},
	{ "PRINTER",  313,  0},
	{ "PRIVATE",  314,  0},
	{ "RBRACE",  315,  0},
	{ "RBRACKET",  316,  0},
	{ "REAL",  317,  0},
	{ "RPAREN",  318,  0},
	{ "SECTIONS",  319,  0},
	{ "SEMICOLON",  320,  0},
	{ "SEQUENCE",  321,  1},
	{ "SEQUENCEOF",  322,  1},
	{ "SET",  323,  0},
	{ "_SIZE",  324,  1},
	{ "STRING",  325,  1},
	{ "TAGS",  326,  0},
	{ "TRUE_VAL",  327,  1},
	{ "UNIVERSAL",  328,  0},
	{ "WITH",  329,  0},
	{ "PLUSINFINITY",  330,  0},
	{ "MINUSINFINITY",  331,  0},
	{ "MODULEID",  332,  1},
	{ "LASTUPDATE",  333,  1},
	{ "ORGANIZATION",  334,  1},
	{ "CONTACTINFO",  335,  1},
	{ "DESCRIPTION",  336,  1},
	{ "REVISION",  337,  1},
	{ "OBJECTIDENT",  338,  1},
	{ "STATUS",  339,  1},
	{ "REFERENCE",  340,  1},
	{ "OBJECTYPE",  341,  1},
	{ "SYNTAX",  342,  1},
	{ "BITSXX",  343,  1},
	{ "UNITS",  344,  1},
	{ "MAXACCESS",  345,  1},
	{ "ACCESS",  346,  1},
	{ "INDEX",  347,  1},
	{ "IMPLIED",  348,  1},
	{ "AUGMENTS",  349,  1},
	{ "DEFVAL",  350,  1},
	{ "NOTIFY",  351,  1},
	{ "OBJECTS",  352,  1},
	{ "TRAPTYPE",  353,  1},
	{ "ENTERPRISE",  354,  1},
	{ "VARIABLES",  355,  1},
	{ "TEXTCONV",  356,  1},
	{ "DISPLAYHINT",  357,  1},
	{ "OBJECTGROUP",  358,  1},
	{ "NOTIFYGROUP",  359,  1},
	{ "NOTIFICATIONS",  360,  1},
	{ "MODCOMP",  361,  1},
	{ "MODULE",  362,  1},
	{ "MANDATORY",  363,  1},
	{ "GROUP",  364,  1},
	{ "WSYNTAX",  365,  1},
	{ "MINACCESS",  366,  1},
	{ "AGENTCAP",  367,  1},
	{ "PRELEASE",  368,  1},
	{ "SUPPORTS",  369,  1},
	{ "INCLUDING",  370,  1},
	{ "VARIATION",  371,  1},
	{ "CREATION",  372,  1},
	{ "':'",  58,  0},
	{ "'='",  61,  0}

};
#endif
#if YYDEBUG
static char *	YYStatesFile = "states.out";
long yyStates[] = {
0L, 17L, 30L, 69L, 124L, 141L, 154L, 176L, 220L, 233L, 251L, 298L, 320L, 
333L, 424L, 437L, 476L, 498L, 520L, 567L, 590L, 644L, 662L, 685L, 708L, 
721L, 755L, 768L, 781L, 828L, 855L, 882L, 900L, 918L, 992L, 1020L, 1048L, 
1061L, 1144L, 1199L, 1212L, 1225L, 1238L, 1251L, 1264L, 1277L, 1290L, 
1303L, 1316L, 1329L, 1342L, 1355L, 1368L, 1381L, 1394L, 1407L, 1446L, 
1468L, 1512L, 1578L, 1591L, 1655L, 1677L, 1721L, 1739L, 1762L, 1784L, 
1807L, 1829L, 1851L, 1874L, 1958L, 2839L, 2852L, 2865L, 2878L, 2891L, 
2904L, 2917L, 2930L, 2943L, 2956L, 2969L, 2982L, 2995L, 3008L, 3021L, 
3034L, 3052L, 3100L, 3241L, 3264L, 3287L, 3310L, 3394L, 3461L, 3518L, 
3590L, 3662L, 3704L, 3776L, 3845L, 3969L, 3982L, 3995L, 4012L, 4090L, 
4112L, 4125L, 4138L, 4151L, 4222L, 4239L, 4348L, 4361L, 4374L, 4387L, 
4400L, 4413L, 4524L, 4747L, 4828L, 4882L, 4961L, 4978L, 5071L, 5138L, 
5195L, 5267L, 5339L, 5356L, 5430L, 5502L, 5515L, 5559L, 5611L, 5633L, 
5651L, 5754L, 5772L, 5790L, 5808L, 5835L, 5858L, 5876L, 5930L, 6083L, 
6096L, 6140L, 6158L, 6192L, 6256L, 6340L, 6374L, 6406L, 6614L, 6725L, 
6752L, 6779L, 6792L, 6809L, 6871L, 6889L, 6956L, 7013L, 7085L, 7157L, 
7175L, 7244L, 7257L, 7291L, 7363L, 7381L, 7408L, 7425L, 7477L, 7500L, 
7554L, 7603L, 7616L, 7638L, 7682L, 7695L, 7708L, 7721L, 7734L, 7747L, 
7760L, 7804L, 7817L, 7830L, 7843L, 7856L, 7869L, 7882L, 7895L, 7923L, 
7940L, 7953L, 7980L, 8029L, 8056L, 8069L, 8091L, 8135L, 8153L, 8171L, 
8235L, 8248L, 8292L, 8371L, 8389L, 8477L, 8509L, 8522L, 8539L, 8606L, 
8640L, 8764L, 8828L, 8856L, 8884L, 8902L, 8964L, 9031L, 9088L, 9160L, 
9182L, 9195L, 9208L, 9221L, 9265L, 9337L, 9379L, 9392L, 9426L, 9444L, 
9462L, 9534L, 9547L, 9560L, 9604L, 9631L, 9649L, 9701L, 9728L, 9755L, 
9804L, 9826L, 9849L, 9862L, 9884L, 9911L, 9924L, 9968L, 9990L, 10108L, 
10191L, 10219L, 10241L, 10269L, 10296L, 10319L, 10341L, 10364L, 10397L, 
10430L, 10448L, 10475L, 10549L, 10582L, 10600L, 10634L, 10701L, 10719L, 
10737L, 10771L, 10937L, 10970L, 11003L, 11065L, 11132L, 11221L, 11293L, 
11315L, 11337L, 11409L, 11451L, 11469L, 11487L, 11559L, 11581L, 11609L, 
11688L, 11716L, 11744L, 11767L, 11806L, 11834L, 11856L, 11879L, 11902L, 
11925L, 11938L, 11951L, 11978L, 12001L, 12014L, 12027L, 12071L, 12098L, 
12145L, 12163L, 12181L, 12215L, 12329L, 12347L, 12365L, 12526L, 12588L, 
12655L, 12739L, 12811L, 12834L, 12857L, 12929L, 12972L, 13044L, 13067L, 
13119L, 13142L, 13155L, 13178L, 13206L, 13228L, 13256L, 13303L, 13321L, 
13339L, 13448L, 13604L, 13683L, 13782L, 13873L, 13886L, 13899L, 13948L, 
14005L, 14077L, 14149L, 14221L, 14273L, 14296L, 14344L, 14443L, 14456L, 
14500L, 14651L, 14713L, 14807L, 14820L, 14847L, 14916L, 14970L, 15039L, 
15057L, 15114L, 15186L, 15258L, 15330L, 15383L, 15396L, 15423L, 15467L, 
15561L, 15579L, 15606L, 15619L, 15663L, 15787L, 15849L, 15891L, 15904L, 
15917L, 15966L, 16033L, 16060L, 16078L, 16120L, 16147L, 16160L, 16173L, 
16227L, 16250L, 16309L, 16367L, 16466L, 16565L, 16664L, 16691L, 16709L, 
16736L, 16803L, 16889L, 16902L, 16980L, 16993L, 17042L, 17060L, 17087L, 
17211L, 17344L, 17393L, 17435L, 17453L, 17520L, 17547L, 17616L, 17643L, 
17661L, 17689L, 17761L, 17833L, 17860L, 17873L, 17886L, 17935L, 18007L, 
18034L, 18047L, 18064L, 18077L, 18126L, 18193L, 18237L, 18259L, 18287L, 
18309L, 18322L, 18335L, 18348L, 18361L, 18374L, 18396L, 18409L, 18422L, 
18435L, 18462L, 18525L, 18588L, 18615L, 18657L, 18725L, 18753L, 18766L, 
18783L, 18847L, 18874L, 18946L, 19018L, 19045L, 19063L, 19135L, 19163L, 
19181L, 19203L, 19231L, 19299L, 19322L, 19344L, 19366L, 19394L, 19421L, 
19463L, 19556L, 19569L, 19586L, 19645L, 19673L, 19746L, 19819L, 19846L, 
19919L, 19942L, 19965L, 19988L, 20016L, 20058L, 20146L, 20159L, 20176L, 
20218L, 20246L, 20320L, 20338L, 20380L, 20432L, 20445L, 20458L, 20512L, 
20555L, 20598L, 20672L, 20690L, 20759L, 20811L, 20885L, 20898L, 20925L, 
20994L, 21038L, 21090L, 21103L, 21116L, 21143L, 21195L, 21223L
};
const YYMAX_READ = 881;
#endif
static short yydef[] = {

	 264,   -1,   48,  262,   -5,  -13,  -17,    3,  -21,   10, 
	 224,  -25,  -29,  224,  -37,  224,  -67,   87,  -71,    9, 
	 -79,  224,  -83,  260,  259,  -91, -103, -109,  224,  224, 
	-117, -125,  261,  224,  224, -129,  224,  224, -137,  224, 
	 224,  257,  224, -141, -149,   12,  224,  224, -157,  255, 
	 256,  224, -165, -173, -181,   10, -189, -195,   15, -203, 
	 258, -211, -217, -227, -231,  224,  254, -239, -245, -249, 
	-255, -259
};
static short yyex[] = {

	   0,    0,   -1,    1,  282,  224,  288,  224,  304,  224, 
	  -1,    1,  320,  224,   -1,    1,  320,  263,   -1,    1, 
	 339,  224,   -1,    1,  339,  224,   -1,    1,  282,    6, 
	 288,    6,  304,    6,   -1,    1,  266,    7,  268,    7, 
	 282,    7,  288,    7,  304,    7,  315,    7,  336,    7, 
	 344,    7,  345,    7,  346,    7,  365,    7,  366,    7, 
	  58,    7,   61,    7,   -1,    1,  345,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  318,  224, 
	  -1,    1,  344,    4,  345,    4,  346,    4,   -1,    1, 
	 268,   61,  288,   48,  297,   48,  304,   48,  315,   61, 
	  -1,    1,  268,    8,  315,    8,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  266,  224,   58,  224, 
	  61,  224,   -1,    1,  318,  224,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  342,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  266,  224, 
	  58,  224,   61,  224,   -1,    1,  266,  224,   58,  224, 
	  61,  224,   -1,    1,  266,  224,   58,  224,   61,  224, 
	  -1,    1,  266,  224,   58,  224,   61,  224,   -1,    1, 
	 266,  224,   58,  224,   61,  224,   -1,    1,  268,    5, 
	 315,    5,   -1,    1,  282,   11,  288,   11,  304,   11, 
	  -1,    1,  336,  224,  365,  224,  366,  224,   -1,    1, 
	 336,  224,  366,  224,   -1,    1,  336,   13,  346,   13, 
	 365,   13,  366,   13,   -1,    1,  336,  224,   -1,    1, 
	 336,   14,  346,   14,  366,   14,   -1,    1,  346,  224, 
	 365,  224,   -1,    1,  346,  224,   -1,    1,  336,  224, 
	 350,  224,   -1,    1,  336,  224,   -1,    1,  315,  224, 
	  -1,    1
};
static short yyact[] = {

	  -1, -443,  304,  288, -278, -277, -312,  304,  295,  288, 
	-275,  277, -274, -278, -408,   -3,  304,  297,  288,  256, 
	-272,  276, -313,  304, -271,  301, -278, -408,   -3,  304, 
	 297,  288, -412,  315, -413,  315, -270, -307, -493,  266, 
	  61,   58, -278, -267, -312,  304,  297,  288, -309, -308, 
	  61,   58,   -5,  261, -409,  318, -410,  318,   -6,  291, 
	-265, -433, -432, -453, -454, -451, -455, -452, -457, -460, 
	-456, -458, -459,  367,  361,  359,  358,  356,  353,  351, 
	 341,  338,  332,  304,  288,  256, -262, -433, -432, -453, 
	-454, -451, -455, -452, -457, -460, -456, -458, -459,  367, 
	 361,  359,  358,  356,  353,  351,  341,  338,  332,  304, 
	 288,  256, -440,  320, -260, -441,  320,  287, -259, -258, 
	-442,  320,  287,  268, -445, -257, -256,  304,  288,  282, 
	-260,  287, -259, -258,  287,  268,   -8,  288, -433, -432, 
	-453, -454, -451, -455, -452, -457, -460, -456, -458, -459, 
	 367,  361,  359,  358,  356,  353,  351,  341,  338,  332, 
	 304,  288, -270, -307, -352, -493,  -10, -345, -349, -241, 
	-248, -489, -245, -490, -249, -250, -242, -344,   -9, -243, 
	-251, -252, -253, -254,  367,  361,  359,  358,  353,  351, 
	 343,  341,  338,  332,  322,  321,  308,  307,  306,  305, 
	 293,  288,  266,  264,   61,   58, -240,  295, -352,  -10, 
	-345, -349, -239, -248, -489, -245, -490, -344,  -12,  356, 
	 343,  322,  321,  308,  307,  306,  305,  293,  288,  264, 
	-238,  368, -237,  339, -236,  360, -235,  352, -234,  339, 
	-233,  333, -232,  352, -230,  277, -324,  325, -270, -307, 
	-320, -493, -229,  301,  266,  256,   61,   58, -227, -323, 
	 309,  295, -352,  -10, -345, -349, -239, -248, -489, -245, 
	-490, -344,  343,  322,  321,  308,  307,  306,  305,  293, 
	 288,  264, -226,  295, -224, -225,  354,  256, -222, -223, 
	 342,  256,  -18,  289, -221, -278, -408,   -3,  304,  297, 
	 288,  256, -219,  357, -351,  289, -320, -229,  301,  256, 
	-217,  300, -216,  304, -215,  295, -214,  295, -297,  304, 
	-213,  336, -212,  300, -302, -211,  295,  256, -210,  339, 
	-311,  288, -207, -339, -338, -337, -208,  324,  299,  298, 
	 297,  256, -333, -278, -206, -332, -331, -330, -327, -312, 
	-326, -334,  327,  305,  304,  300,  299,  298,  297,  295, 
	 288,  286, -204, -205,  304,  256, -201, -202,  304,  256, 
	-359, -278, -277, -312,  304,  295,  288,  256, -198,  355, 
	-404, -352,  -10, -345, -349, -239, -248, -489, -245, -490, 
	-344,  343,  322,  321,  308,  307,  306,  305,  293,  288, 
	 264,  256, -196, -194,  346,  344, -434,  315, -435,  315, 
	-296,  300, -191,  339, -190,  339, -189,  336, -187, -354, 
	 304,  288, -184,  340, -397, -399,  300,  256, -183,  334, 
	-278, -312,  304,  288, -305,  304, -181,  336, -180, -178, 
	 301,  256, -177,  278, -318,  318, -176,  260, -278, -408, 
	 -26,  304,  297,  288, -346,  315, -172, -347,  315,  268, 
	-171,  301, -341,  315, -170, -343,  315,  268, -361, -339, 
	-338, -337,  299,  298,  297,  256, -356, -169,  295,  256, 
	-371,  300, -168,  345, -402, -403,  304,  256, -166,  339, 
	-414, -278, -277, -312,  304,  295,  288,  256, -165,  304, 
	-164,  304,  -30,  300, -163,  315, -162,  277, -161,  268, 
	-160,  315, -394, -396,  300,  256, -158,  300, -157,  268, 
	-304,  315,  -31,  300, -314,  318, -315,  318, -207, -339, 
	-338, -337,  299,  298,  297,  256, -339, -338, -337,  299, 
	 298,  297, -319,  318, -156, -328,  315,  268, -329,  315, 
	-205,  304, -278, -339, -338, -337, -312,  304,  299,  298, 
	 297,  288, -202,  304, -374, -375,  304,  256, -152,  339, 
	-400, -401,  304,  256, -151,  336, -150,  336, -149,  339, 
	-353,  304, -148,  339, -147,  335, -325,  304, -340,  318, 
	-145,  268, -358,  315, -372, -373,  304,  256,  -39,  300, 
	 -40,  300,  -41,  362, -142,  304, -141,  304, -140,  300, 
	-138,  347,  -46, -136,  363,  288, -134,  336, -133,  336, 
	-132,  336, -130, -131,  349,  347, -391, -129,  295,  256, 
	-128,  350, -126,  342, -125,  369, -123,  295, -122, -121, 
	 364,  306, -136,  363,  -53,  300,  -54,  300,  -55,  300, 
	-120,  295, -366, -119,  295,  256, -352,  -56, -345, -312, 
	-349, -239, -248, -489, -245, -490, -344,  343,  322,  321, 
	 308,  307,  306,  305,  304,  293,  288,  264, -387, -116, 
	 295,  256,  -59,  288,  -60,  304, -111,  304, -108,  337, 
	-278, -312, -105,  348,  304,  288, -102,  277, -101, -393, 
	 315,  268, -385, -100,  -99, -384, -381, -380, -382, -378, 
	-379, -386,  327,  305,  304,  300,  299,  298,  297,  295, 
	 288,  286, -406, -278, -277, -312,  304,  295,  288,  256, 
	 -97,  295,  -96,  370, -288,  315,  -95,  342,  -94,  336, 
	 -91,  300, -368,  315,  -89, -369,  315,  268, -311, -313, 
	 304,  288,  -88,  277, -389,  315,  -85,  295,  -84,  365, 
	-287,  300,  -83,  336, -377,  304, -383,  315, -282,  315, 
	 -81,  366, -299,  300,  -66,  315, -285,  304,  -79,  336, 
	 -78,  371, -286,  300,  -68,  304, -194,  346,  -76,  372, 
	 -72,  295,  -73,  336, -280,  315, -281,  300,   -1
};
static short yypact[] = {

	   7,   10,   25,   29,   59,   73,   99,  207,  243,  245, 
	 283,  303,  308,  321,  308,  379,  404,   39,  423,  443, 
	 447,  321,  308,  509,  519,   25,  308,  423,  321,  423, 
	 423,  447,  591,  321,  423,  603,  423,  611,  423,  423, 
	 614,  603,  624,  631,  635,    7,  640,  643,  631,  635, 
	 640,  640,  423,  423,  689,  697,  308,  308,  731,  737, 
	 689,  759,  308,  771,  308,  781,  781,  737,  759,  789, 
	 631,  420,  797,  795,  793,  791,  787,  785,  783,  779, 
	 777,  775,  773,  272,  420,  769,  767,  765,  693,    7, 
	 763,    7,    7,  761,  272,  757,   29,  755,   29,  753, 
	 667,  750,    7,  746,  432,  743,   39,  741,   39,   39, 
	 739,  735,    7,  733,  726,  712,  700,   39,  693,  432, 
	 687,  685,  420,   39,  683,  272,   39,  680,  667,  654, 
	 651,  649,  647,  645,    7,  637,  633,  628,    7,  621, 
	 619,  617,   39,  539,  432,   39,  609,  607,  605,  601, 
	 599,  596,   39,  593,  589,  587,  432,  585,    7,  583, 
	 420,  581,  579,  577,  575,  572,  569,  566,  432,  563, 
	 557,  551,  549,  546,  543,  539,  539,  532,  527,  525, 
	 523,  521,  517,  514,   39,  511,  507,  505,  503,  501, 
	 499,  494,  489,  486,  483,  481,    7,  478,  472,  466, 
	 463,  461,  458,  455,  272,  451,  445,  440,  437,  435, 
	 432,  429,  426,  420,  420,  417,  415,  413,  411,  409, 
	 407,   39,  391,   39,  374,  368,  364,  352,  337,  331, 
	 329,  326,  323,  319,  317,  315,  313,  311,  305,  298, 
	 293,  290,  286,  272,  260,    7,  253,  247,  241,  239, 
	 237,  235,  233,  231,  219,  184,   39,  137,  150,  137, 
	 134,  131,  127,  121,  116,  113,   57,   55,   53,   50, 
	  45,   39,   35,   33,   23,   21,   16,   11,    2
};
static short yygo[] = {

	  -2, -437, -436,  257, -350, -244, -446, -310,  -28,  -35, 
	 -37,  -19,   33,   28,   21, -153,  -36, -146,  -38,  -43, 
	-137,  -45, -110, -109, -185,   53,   52,   39,   38,   36, 
	  34,   30,   29,   27, -218, -195, -431, -439, -438,    6, 
	-429,  -70, -193,   76, -167,  -29,  -34,  -44,  -49,  -22, 
	-231, -411, -364, -411, -411, -390, -365, -364, -106, -390, 
	-355, -301, -355, -487, -411, -301, -487, -411, -268, -411, 
	-463,  276,  270,  239,  227,  210,  205,  170,  168,  156, 
	 144,  128,  119,  118,  104,  100,   98,   96,   88,    3, 
	-476,  -11, -289, -300, -294, -293, -376, -284, -407, -292, 
	-306, -298, -415, -405, -360, -336, -444,  245,  224,  196, 
	 191,  158,  138,  134,  114,  112,  102,   92,   91,   89, 
	  45,  -17,  -65,  -63,  -58,  -27,  -23,  -15,  -13, -247, 
	 -57,  255,  254,  243,  222,  204,  125,   94,   83, -474, 
	 -16, -475, -335, -483, -480, -484,  170, -363, -479, -316, 
	-362,  -20,  198,  176,  170,  143, -155, -317, -179, -322, 
	 207, -321, -348, -118,  -75, -127,   70,   48,  -98,  -14, 
	-209, -276, -192,  -90,  -92,  -93, -103, -113, -115, -135, 
	-139, -144, -159, -197, -199, -228, -246, -255, -269,  256, 
	 255,  246,  223,  221,  184,  152,  145,  142,  126,  123, 
	 117,  109,  108,  106,   17, -488, -263, -261, -264,    6, 
	-266, -447, -448, -303, -342, -295, -398, -357, -370, -492, 
	-398, -398, -492, -398, -499, -392, -502, -367, -388, -509, 
	-503, -502, -388, -503, -496, -506, -507, -508, -512, -506, 
	-507, -515, -388, -517, -462, -395,  487,   71,   70,   69, 
	  68,   67,   65,   63,   61,   59,   54,   51,   48,   47, 
	  46,   44,   43,   42,   40,   37,   35,   33,   31,   28, 
	  21,   20,   16,   15,   13,   11,   10,    8,    5,    4, 
	  -7, -464,  -86,  -87, -173, -220, -273,  239,  205,   98, 
	  96,    3, -449, -450,  258, -461, -430, -428, -427, -426, 
	-425, -424, -423, -422, -421, -420, -419, -418, -417, -416, 
	  -4, -117, -466, -465,  100, -104, -468, -467,   88, -154, 
	 -33, -470, -469,  144, -516,  -82, -112, -186, -188,  213, 
	 122,   84,   71,  -24, -472, -471,  160, -473, -203, -200, 
	-478, -477,  169, -481, -482,  171, -174, -486, -485,  155, 
	 -32,  -21,  175, -491, -175,   31, -182,  -25, -495, -494, 
	 156, -107,  -61, -497, -498,   60, -143,  -42, -500, -501, 
	  41,  -48,  -52,  -47,   47, -291, -290,   51,  -51, -504, 
	-505,   50,  -69,  -62,   67,  -77,  -64,   68,  -80, -124, 
	 -50, -510, -511,   49, -114, -283,  -67, -513, -514,   66, 
	 -71,  -74,   -1
};
static short yypgo[] = {

	   0,    0,    0,    2,  121,  313,  307,  139,  344,  157, 
	  90,  302,  371,  383,  386,  394,  400,  398,  394,  392, 
	 306,  388,  380,  380,  373,  371,  369,  369,  305,  304, 
	 303,   34,   34,  169,  300,  364,  298,  359,   50,   50, 
	  50,  170,  301,    7,    7,    7,  188,   90,   70,   70, 
	 161,  161,  157,  351,  159,  159,  141,  141,  141,    5, 
	   4,  348,  143,  143,  143,  143,  143,  143,  143,  143, 
	 143,  309,  308,  151,  151,  151,  341,  162,  162,  162, 
	  91,   91,  139,  139,  139,  139,  139,  139,  139,  337, 
	 337,  322,   49,   49,   49,  140,  140,  297,  297,  297, 
	 317,  317,   48,   48,   48,   48,   35,   35,   46,   46, 
	  44,   44,  299,  168,  168,  168,  168,  168,  168,  168, 
	 168,  168,  168,  165,  165,  165,  313,   47,   47,   47, 
	  24,   24,   24,   11,   11,   11,   45,   45,   42,   42, 
	 121,   40,   40,   40,  310,  310,  310,  310,  106,  106, 
	 296,  296,  295,  295,  295,  295,  295,  295,  295,  295, 
	 295,  295,  295,  295,  295,  295,  295,  293,  293,  293, 
	   2,    2,   38,   38,  280,  280,  205,  205,  205,    6, 
	   6,    0,  171,  205,  210,  208,  208,   36,   36,   36, 
	  36,   36,   36,   36,   36,   36,   36,  206,  206,  106, 
	 286,  311,  311,  315,  315,  320,  320,  333,  333,  335, 
	 130,  130,   91,  339,  339,  156,  156,  338,  338,  142, 
	 142,  346,  346,  145,  245,    4,    5,  354,  354,  188, 
	 357,  357,  361,  362,  362,  366,  367,  367,  373,  376, 
	 378,  378,  383,  386,  388,  389,  390,  390,  395,  396, 
	 396,  400,  401,  401,  395,  389,  376,  366,  361,  356, 
	 328,  319,  286,  210,    6,    0
};
static short yyrlen[] = {

	   0,    0,    0,    1,    2,    1,    3,    2,    2,    1, 
	   1,   11,    1,    2,    2,    1,    4,    9,    4,    7, 
	  12,    2,    7,    4,    4,    2,    3,    4,   10,   13, 
	  13,    1,    2,    2,    7,    4,   13,    1,    2,    1, 
	   4,    2,    9,    1,    2,    2,    1,    3,    1,    3, 
	   4,    4,    3,    1,    3,    4,    2,    2,    2,    2, 
	   2,    1,    1,    1,    3,    3,    1,    1,    1,    1, 
	   1,    4,    3,    1,    1,    1,    4,    3,    1,    3, 
	   1,    1,    4,    4,    2,    1,    1,    2,    1,    3, 
	   1,    1,    2,    1,    4,    2,    2,    5,    5,    8, 
	   1,    2,    2,    1,    4,    4,    1,    2,    2,    2, 
	   2,    2,   12,    3,    1,    1,    1,    1,    1,    3, 
	   1,    1,    1,    2,    1,    4,    1,    2,    1,    4, 
	   2,    1,    2,    2,    1,    2,    2,    2,    2,    2, 
	   2,    5,   11,   11,    1,    4,    4,    1,    3,    3, 
	   5,    5,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   4,    4,    3,    3,    1,    2,    3,    3,    3,    1, 
	   2,    8,    0,    1,    1,    3,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    1,    1,    2,    1,    1, 
	   2,    1,    3,    1,    3,    1,    3,    1,    3,    1, 
	   1,    1,    1,    1,    3,    1,    1,    3,    1,    1, 
	   1,    1,    3,    1,    0,    1,    1,    3,    1,    1, 
	   1,    3,    1,    2,    1,    1,    2,    1,    1,    1, 
	   2,    1,    1,    1,    1,    1,    2,    1,    1,    2, 
	   1,    1,    1,    1,    1,    1,    1,    1,    1,    1, 
	   1,    1,    1,    1,    1,    2
};
#define YYS0	278
#define YYDELTA	263
#define YYNPACT	279
#define YYNDEF	72

#define YYr263	0
#define YYr264	1
#define YYr265	2
#define YYr18	3
#define YYr65	4
#define YYr82	5
#define YYr130	6
#define YYr138	7
#define YYr157	8
#define YYr188	9
#define YYr195	10
#define YYr218	11
#define YYr230	12
#define YYr240	13
#define YYr242	14
#define YYr253	15
#define YYr259	16
#define YYr258	17
#define YYr252	18
#define YYr251	19
#define YYr246	20
#define YYr244	21
#define YYr239	22
#define YYr238	23
#define YYr232	24
#define YYr231	25
#define YYr229	26
#define YYr228	27
#define YYr223	28
#define YYr222	29
#define YYr221	30
#define YYr220	31
#define YYr219	32
#define YYr217	33
#define YYr216	34
#define YYr215	35
#define YYr210	36
#define YYr209	37
#define YYr205	38
#define YYr204	39
#define YYr203	40
#define YYr202	41
#define YYr201	42
#define YYr200	43
#define YYr199	44
#define YYr198	45
#define YYr196	46
#define YYr194	47
#define YYr193	48
#define YYr192	49
#define YYr191	50
#define YYr190	51
#define YYr189	52
#define YYr185	53
#define YYr184	54
#define YYr183	55
#define YYr182	56
#define YYr181	57
#define YYr180	58
#define YYr179	59
#define YYr176	60
#define YYr173	61
#define YYr170	62
#define YYr169	63
#define YYr168	64
#define YYr167	65
#define YYr166	66
#define YYr165	67
#define YYr164	68
#define YYr163	69
#define YYr162	70
#define YYr159	71
#define YYr158	72
#define YYr154	73
#define YYr153	74
#define YYr152	75
#define YYr149	76
#define YYr146	77
#define YYr145	78
#define YYr144	79
#define YYr142	80
#define YYr141	81
#define YYr140	82
#define YYr139	83
#define YYr137	84
#define YYr136	85
#define YYr135	86
#define YYr134	87
#define YYr133	88
#define YYr129	89
#define YYr128	90
#define YYr123	91
#define YYr119	92
#define YYr118	93
#define YYr117	94
#define YYr116	95
#define YYr115	96
#define YYr114	97
#define YYr113	98
#define YYr112	99
#define YYr111	100
#define YYr110	101
#define YYr107	102
#define YYr106	103
#define YYr105	104
#define YYr104	105
#define YYr103	106
#define YYr102	107
#define YYr101	108
#define YYr100	109
#define YYr99	110
#define YYr98	111
#define YYr97	112
#define YYr96	113
#define YYr95	114
#define YYr94	115
#define YYr93	116
#define YYr92	117
#define YYr91	118
#define YYr90	119
#define YYr89	120
#define YYr88	121
#define YYr87	122
#define YYr86	123
#define YYr85	124
#define YYr84	125
#define YYr83	126
#define YYr79	127
#define YYr78	128
#define YYr77	129
#define YYr76	130
#define YYr75	131
#define YYr74	132
#define YYr73	133
#define YYr72	134
#define YYr71	135
#define YYr70	136
#define YYr69	137
#define YYr68	138
#define YYr67	139
#define YYr66	140
#define YYr64	141
#define YYr63	142
#define YYr62	143
#define YYr61	144
#define YYr60	145
#define YYr59	146
#define YYr58	147
#define YYr55	148
#define YYr54	149
#define YYr52	150
#define YYr51	151
#define YYr50	152
#define YYr49	153
#define YYr48	154
#define YYr47	155
#define YYr46	156
#define YYr45	157
#define YYr44	158
#define YYr43	159
#define YYr42	160
#define YYr41	161
#define YYr40	162
#define YYr39	163
#define YYr38	164
#define YYr37	165
#define YYr36	166
#define YYr23	167
#define YYr22	168
#define YYr21	169
#define YYr17	170
#define YYr16	171
#define YYr15	172
#define YYr14	173
#define YYr13	174
#define YYr12	175
#define YYr8	176
#define YYr7	177
#define YYr6	178
#define YYr5	179
#define YYr4	180
#define YYr2	181
#define YYr1	182
#define YYrACCEPT	YYr263
#define YYrERROR	YYr264
#define YYrLR2	YYr265
#if YYDEBUG
char * yysvar[] = {
	"$accept",
	"ModuleDefinition",
	"ImportModuleIdentifier",
	"Octetstring",
	"SequenceOf",
	"MainModuleIdentifier",
	"InsteadOfCCE",
	"DescrPart",
	"ReferPart",
	"DisplayPart",
	"UnitsPart",
	"MacroName",
	"SymbolsFromModule",
	"ObjectTypeV1Definition",
	"AccessPart",
	"MaxAccessPartV2",
	"StatusPart",
	"StatusPartV2",
	"IndexPart",
	"IndexPartV2",
	"VarPart",
	"ObjectsPart",
	"QualifiedName",
	"QualifiedId",
	"QualifiedIdOrIntegerOrBits",
	"ObjectID",
	"SyntaxPart",
	"Type",
	"BuiltinType",
	"EnterprisePart",
	"SubType",
	"Value",
	"BuiltinValue",
	"DefinedValue",
	"NumericValue",
	"NamedNumberValue",
	"SubtypeValueSet",
	"SubtypeRangeSpec",
	"SubtypeSizeSpec",
	"NNlist",
	"DefValPart",
	"DefValValue",
	"ObjectIdentityStatusPart",
	"NotificationTypeStatusPart",
	"$1",
	"AllowedCCE",
	"Imports",
	"AssignmentList",
	"SymbolList",
	"SymbolsImported",
	"empty",
	"SymbolsFromModuleList",
	"ObjectIDComponentList",
	"Symbol",
	"Assignment",
	"ObjectIDefinition",
	"TrapTypeDefinition",
	"ModuleIDefinition",
	"ObjectTypeV2Definition",
	"ObjectDefinition",
	"NotifyDefinition",
	"TextualConventionDefinition",
	"ObjectGroupDefinition",
	"NotifyGroupDefinition",
	"ModComplianceDefinition",
	"AgentCapabilitiesDefinition",
	"Typeassignment",
	"ToleratedOIDAssignment",
	"Valueassignment",
	"ObjectSubID",
	"IndexTypes",
	"IndexType",
	"IndexTypesV2",
	"IndexTypeV2",
	"VarTypeListForTrap",
	"VarTypesForTrap",
	"VarTypeForTrap",
	"VarTypeList",
	"VarTypes",
	"VarType",
	"UncheckedQualifiedName",
	"ElementTypes",
	"NamedNumberList",
	"NamedNumber",
	"NamedType",
	"NameList",
	"Name",
	"SubtypeRangeAlternative",
	"SubtypeRangeAlternativeList",
	"ObjectTypeListForNotification",
	"ObjectTypesForNotification",
	"ObjectTypeForNotification",
	"RevisionPart",
	"Revisions",
	"Revision",
	"MibPart",
	"Mibs",
	"Mib",
	"ModuleIdentifierUnused",
	"MandatoryPart",
	"CompliancePart",
	"Compliances",
	"Compliance",
	"Syntax",
	"WriteSyntax",
	"MinAccessPart",
	"ModulePart",
	"Modules",
	"Module",
	"ModuleReference",
	"VariationPart",
	"Variations",
	"Variation",
	"CreationPart",
	"Creation",
	0
};
short yyrmap[] = {

	 263,  264,  265,   18,   65,   82,  130,  138,  157,  188, 
	 195,  218,  230,  240,  242,  253,  259,  258,  252,  251, 
	 246,  244,  239,  238,  232,  231,  229,  228,  223,  222, 
	 221,  220,  219,  217,  216,  215,  210,  209,  205,  204, 
	 203,  202,  201,  200,  199,  198,  196,  194,  193,  192, 
	 191,  190,  189,  185,  184,  183,  182,  181,  180,  179, 
	 176,  173,  170,  169,  168,  167,  166,  165,  164,  163, 
	 162,  159,  158,  154,  153,  152,  149,  146,  145,  144, 
	 142,  141,  140,  139,  137,  136,  135,  134,  133,  129, 
	 128,  123,  119,  118,  117,  116,  115,  114,  113,  112, 
	 111,  110,  107,  106,  105,  104,  103,  102,  101,  100, 
	  99,   98,   97,   96,   95,   94,   93,   92,   91,   90, 
	  89,   88,   87,   86,   85,   84,   83,   79,   78,   77, 
	  76,   75,   74,   73,   72,   71,   70,   69,   68,   67, 
	  66,   64,   63,   62,   61,   60,   59,   58,   55,   54, 
	  52,   51,   50,   49,   48,   47,   46,   45,   44,   43, 
	  42,   41,   40,   39,   38,   37,   36,   23,   22,   21, 
	  17,   16,   15,   14,   13,   12,    8,    7,    6,    5, 
	   4,    2,    1,    9,   11,   19,   20,   24,   25,   26, 
	  27,   28,   29,   30,   31,   32,   33,   34,   35,   53, 
	  56,   80,   81,  108,  109,  121,  122,  125,  126,  127, 
	 131,  132,  143,  147,  148,  150,  151,  155,  156,  160, 
	 161,  171,  172,  174,  175,  177,  178,  186,  187,  197, 
	 207,  208,  212,  213,  214,  225,  226,  227,  233,  235, 
	 236,  237,  241,  243,  245,  248,  249,  250,  255,  256, 
	 257,  260,  261,  262,  254,  247,  234,  224,  211,  206, 
	 124,  120,   57,   10,    3,    0
};
short yysmap[] = {

	   2,    4,   13,   15,   33,   37,   55,   89,  100,  101, 
	 112,  122,  124,  130,  145,  151,  154,  155,  167,  177, 
	 180,  209,  211,  230,  240,  255,  256,  268,  276,  281, 
	 292,  296,  308,  314,  317,  320,  338,  339,  340,  341, 
	 342,  345,  353,  356,  358,  361,  362,  363,  373,  383, 
	 391,  393,  395,  396,  397,  402,  404,  410,  411,  416, 
	 425,  455,  473,  476,  487,  492,  498,  501,  503,  505, 
	 508,  509,  514,  513,  510,  507,  504,  495,  494,  490, 
	 489,  486,  480,  475,  472,  471,  469,  468,  464,  461, 
	 459,  458,  457,  456,  454,  450,  449,  446,  442,  436, 
	 434,  433,  432,  431,  429,  427,  426,  422,  421,  420, 
	 417,  415,  414,  412,  409,  408,  406,  401,  400,  398, 
	 388,  387,  385,  384,  380,  379,  378,  377,  375,  372, 
	 371,  368,  367,  366,  365,  360,  357,  355,  350,  349, 
	 348,  347,  346,  335,  333,  328,  326,  324,  321,  319, 
	 318,  313,  310,  309,  304,  298,  290,  289,  286,  285, 
	 284,  283,  282,  280,  279,  275,  272,  271,  267,  262, 
	 260,  258,  254,  253,  251,  250,  247,  246,  245,  244, 
	 243,  241,  237,  234,  232,  231,  226,  225,  224,  223, 
	 222,  218,  217,  216,  215,  214,  212,  208,  206,  203, 
	 202,  200,  199,  198,  196,  187,  179,  176,  174,  173, 
	 172,  170,  169,  165,  164,  163,  162,  160,  159,  157, 
	 156,  153,  152,  150,  149,  147,  144,  141,  137,  135, 
	 134,  133,  131,  129,  128,  127,  126,  125,  123,  121, 
	 120,  119,  118,  111,  110,  106,  105,  104,   99,   98, 
	  97,   96,   95,   94,   93,   71,   70,   68,   67,   65, 
	  62,   61,   60,   58,   57,   56,   30,   29,   28,   25, 
	  20,   18,   17,   16,   11,   10,    7,    6,    0,  515, 
	 516,  485,  499,  451,  493,  500,  477,  452,  386,  392, 
	 419,  394,  478,  479,  158,  221,  166,  325,  491,  481, 
	 238,  171,  132,  291,  242,  369,   24,   31,   32,   27, 
	 175,    5,   19,  293,  294,  295,  178,  248,  297,  138, 
	 139,  140,  143,  136,  330,  185,  186,  299,  300,  188, 
	 189,  190,  191,  192,  195,  142,  181,  182,  183,  332, 
	 261,  146,  263,  108,  109,  257,  259,  148,  113,  114, 
	 161,  115,  322,  227,  306,  266,  207,  334,  204,  205, 
	 264,  265,  352,  428,  463,  399,  370,  462,  465,  213, 
	 270,  336,  337,  311,  312,  466,  483,  437,  438,  439, 
	 440,  441,  484,  443,  444,  445,  407,  376,  470,  403, 
	 374,  354,  435,  287,  233,  288,  235,  168,  236,  315, 
	 316,  273,  274,  210,  269,  447,  448,   12,   34,   35, 
	  14,   22,   23,  277,  278,   72,   73,   74,   75,   76, 
	  77,   78,   79,   80,   81,   82,   83,   84,   85,   86, 
	  49,   50,   51,  219,  220,   90,   92,   53,   63,   64, 
	  66,   69,    1,    9,   88,    3,   36,   54,   91,   52, 
	  48,   47,   46,   45,   44,   43,   42,   41,   40,   39, 
	  87,   59,    8,   21,  405,  467,  430,  482,  307,  351, 
	 229,  323,  228,  117,  116,  107,  201,  305,  303,  302, 
	 301,  197,  194,  193,  252,  331,  184,   38,  103,  102, 
	 329,  249,   26,  239,  327,  424,  460,  423,  344,  364, 
	 343,  359,  390,  418,  389,  453,  474,  488,  382,  413, 
	 381,  497,  502,  496,  506,  512,  511
};
int yy_parse::yyntoken = 120;
int yy_parse::yynvar = 115;
int yy_parse::yynstate = 517;
int yy_parse::yynrule = 266;
#endif



// C++ YACC parser code
// Copyright 1991 by Mortice Kern Systems Inc.  All rights reserved.
//
// If YYDEBUG is defined as 1 and yy_parse::yydebug is set to 1,
// yyparse() will print a travelogue of its actions as it reads
// and parses input.
//
// YYSYNC can be defined to cause yyparse() to attempt to always
// hold a lookahead token

const YY_MIN_STATE_NUM = 20;	// not useful to be too small!

#if YYDEBUG
#ifdef YYTRACE
long	* yy_parse::States	= yyStates;
#endif
yyTypedRules * yy_parse::Rules	= yyRules;
yyNamedType * yy_parse::TokenTypes = yyTokenTypes;

#define YY_TRACE(fn) { done = 0; fn(); if (done) YYRETURN(-1); }
#endif

// Constructor for yy_parse: user-provided tables
yy_parse::yy_parse(int sz, short * states, YYSTYPE * stack)
{
	mustfree = 0;
	if ((size = sz) < YY_MIN_STATE_NUM
	 || (stateStack = states) == (short *) 0
	 || (valueStack = stack) == (YYSTYPE *) 0) {
		fprintf(stderr,"Bad state/stack given");
		exit(1);
	}
	reset = 1;		// force reset
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
	if (typeStack == (short *) 0) {
		fprintf(stderr,"Cannot allocate typeStack");
		exit(1);
	}
#endif
}
// Constructor for yy_parse: allocate tables with new
yy_parse::yy_parse(int sz)
{
	size = sz;
	reset = 1;		// force reset
	mustfree = 1;		// delete space in deconstructor
#if YYDEBUG
	yydebug = 0;
	typeStack = new short[size+1];
#endif
	stateStack = new short[size+1];
	valueStack = new YYSTYPE[size+1];

	if (stateStack == (short *) 0 || valueStack == (YYSTYPE *) 0
#if YYDEBUG
		|| typeStack == (short *) 0
#endif
	    ) {
		fprintf(stderr,"Not enough space for parser stacks");
		exit(1);
	}
}
// Destructor for class yy_parse
//	Free up space
yy_parse::~yy_parse()
{
	if (mustfree) {
		delete stateStack;
		delete valueStack;
	}
	stateStack = (short *) 0;
#if YYDEBUG
	delete typeStack;
#endif
}

#ifdef YACC_WINDOWS

// The initial portion of the yacc parser.
// In an windows environment, it will load the desired
// resources, obtain pointers to them, and then call
// the protected member win_yyparse() to acutally begin the
// parsing. When complete, win_yyparse() will return a
// value back to our new yyparse() function, which will 
// record that value temporarily, release the resources
// from global memory, and finally return the value
// back to the caller of yyparse().

int
yy_parse::yyparse(yy_scan* ps)
{
	int wReturnValue;
	HANDLE hRes_table;
	short *old_yydef;		// the following are used for saving
	short *old_yyex;		// the current pointers
	short *old_yyact;
	short *old_yypact;
	short *old_yygo;
	short *old_yypgo;
	short *old_yyrlen;

	// the following code will load the required
	// resources for a Windows based parser.

	hRes_table = LoadResource (hInst,
		FindResource (hInst, "UD_RES_yyYACC", "yyYACCTBL"));
	
	// return an error code if any
	// of the resources did not load

	if (hRes_table == (HANDLE)NULL)
		return (1);
	
	// the following code will lock the resources
	// into fixed memory locations for the parser
	// (also, save away the old pointer values)

	old_yydef = yydef;
	old_yyex = yyex;
	old_yyact = yyact;
	old_yypact = yypact;
	old_yygo = yygo;
	old_yypgo = yypgo;
	old_yyrlen = yyrlen;

	yydef = (short *)LockResource (hRes_table);
	yyex = (short *)(yydef + Sizeof_yydef);
	yyact = (short *)(yyex + Sizeof_yyex);
	yypact = (short *)(yyact + Sizeof_yyact);
	yygo = (short *)(yypact + Sizeof_yypact);
	yypgo = (short *)(yygo + Sizeof_yygo);
	yyrlen = (short *)(yypgo + Sizeof_yypgo);

	// call the official yyparse() function

	wReturnValue = win_yyparse (ps);

	// unlock the resources

	UnlockResource (hRes_table);

	// and now free the resource

	FreeResource (hRes_table);

	//
	// restore previous pointer values
	//

	yydef = old_yydef;
	yyex = old_yyex;
	yyact = old_yyact;
	yypact = old_yypact;
	yygo = old_yygo;
	yypgo = old_yypgo;
	yyrlen = old_yyrlen;

	return (wReturnValue);
}	// end yyparse()


// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start

int
yy_parse::win_yyparse(yy_scan* ps)

#else /* YACC_WINDOWS */

// The parser proper.
//	Note that this code is reentrant; you can return a value
//	and then resume parsing by recalling yyparse().
//	Call yyreset() before yyparse() if you want a fresh start
int
yy_parse::yyparse(yy_scan* ps)

#endif /* YACC_WINDOWS */

{
	short	* yyp, * yyq;		// table lookup
	int	yyj;
#if YYDEBUG
	int	yyruletype = 0;
#endif

	if ((scan = ps) == (yy_scan *) 0) {	// scanner
		fprintf(stderr,"No scanner");
		exit(1);
	}

	if (reset) {			// start new parse
		yynerrs = 0;
		yyerrflag = 0;
		yyps = stateStack;
		yypv = valueStack;
#if YYDEBUG
		yytp = typeStack;
#endif
		yystate = YYS0;
		yyclearin();
		reset = 0;
	} else			// continue saved parse
		goto yyNext;			// after action

yyStack:
	if (++yyps > &stateStack[size]) {
		scan->yyerror("Parser stack overflow");
		YYABORT;
	}
	*yyps = yystate;	/* stack current state */
	*++yypv = yyval;	/* ... and value */
#if YYDEBUG
	if (yydebug) {
		*++yytp = (short)yyruletype;	/* ... and type */
		YY_TRACE(yyShowState)
	}
#endif

	/*
	 * Look up next action in action table.
	 */
yyEncore:
#ifdef YYSYNC
	if (yychar < 0) {
		if ((yychar = scan->yylex()) < 0) {
			if (yychar == -2) YYABORT;
			yychar = 0;
		}	/* endif */
		yylval = ::yylval;
#if YYDEBUG
		if (yydebug)
			yyShowRead();	// show new input token
#endif
	}
#endif
#ifdef YACC_WINDOWS
	if (yystate >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
	if (yystate >= sizeof yypact/sizeof yypact[0]) 	/* simple state */
#endif /* YACC_WINDOWS */
		yyi = yystate - YYDELTA;	/* reduce in any case */
	else {
		if(*(yyp = &yyact[yypact[yystate]]) >= 0) {
			/* Look for a shift on yychar */
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			yyq = yyp;
			yyi = (short)yychar;
			while (yyi < *yyp++)
				;
			if (yyi == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
#if YYDEBUG
				if (yydebug) {
					yyruletype = yyGetType(yychar);
					YY_TRACE(yyShowShift)
				}
#endif
				yyval = yylval;		/* stack value */
				yyclearin();		/* clear token */
				if (yyerrflag)
					yyerrflag--;	/* successful shift */
				goto yyStack;
			}
		}

		/*
	 	 *	Fell through - take default action
	 	 */

#ifdef YACC_WINDOWS
		if (yystate >= Sizeof_yydef) 	/* simple state */
#else /* YACC_WINDOWS */
		if (yystate >= sizeof yydef /sizeof yydef[0])
#endif /* YACC_WINDOWS */
			goto yyError;
		if ((yyi = yydef[yystate]) < 0)	 { /* default == reduce? */

			/* Search exception table */
			yyp = &yyex[~yyi];
#ifndef YYSYNC
			if (yychar < 0) {
				if ((yychar = scan->yylex()) < 0) {
					if (yychar == -2) YYABORT;
					yychar = 0;
				}	/* endif */
				yylval = ::yylval;
#if YYDEBUG
				if (yydebug)
					yyShowRead();	// show new input token
#endif
			}
#endif
			while((yyi = *yyp) >= 0 && yyi != yychar)
				yyp += 2;
			yyi = yyp[1];
		}
	}

	yyj = yyrlen[yyi];

#if YYDEBUG
	if (yydebug) {
		npop = yyj; rule = yyi;
		YY_TRACE(yyShowReduce)
		yytp -= yyj;
	}
#endif
	yyps -= yyj;		/* pop stacks */
	yypvt = yypv;		/* save top */
	yypv -= yyj;
	yyval = yypv[1];	/* default action $ = $1 */
#if YYDEBUG
	if (yydebug)
		yyruletype = yyRules[yyrmap[yyi]].type;
#endif
	switch (yyi) {		/* perform semantic action */
		
case YYr1: {	/* ModuleDefinition :  MainModuleIdentifier */

						SIMCParser *myParser = (SIMCParser *)this;
						myParser ++;
						myParser --;
						SIMCModule *myModule = myParser->GetModule();
						theModule->SetModuleName(yypvt[0].yy_name->name);
						theModule->SetLineNumber(yypvt[0].yy_name->line);
						theModule->SetColumnNumber(yypvt[0].yy_name->column);
						theModule->SetInputFileName(theScanner->GetInputStreamName());
						delete yypvt[0].yy_name;
					
} break;

case YYr2: {	/* ModuleDefinition :  MainModuleIdentifier $1 DEFINITIONS AllowedCCE BGIN Imports AssignmentList END */

						delete yypvt[-5].yy_name;
						delete yypvt[-3].yy_name;
						delete yypvt[0].yy_name;
					
} break;

case YYr4: {	/* MainModuleIdentifier :  ID ObjectID */

					if(yypvt[0].yy_symbol_ref)
						delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr5: {	/* MainModuleIdentifier :  NAME */

					theParser->SyntaxError(NAME_INSTEAD_OF_ID);
				
} break;

case YYr6: {	/* Imports :  IMPORTS SymbolList SEMICOLON */

			theParser->SyntaxError(MISSING_MODULE_NAME);
			delete newImportModule;
			newImportModule = new SIMCModule;
			delete yypvt[-2].yy_name;
		
} break;

case YYr7: {	/* Imports :  IMPORTS error SEMICOLON */

			theParser->SyntaxError(IMPORTS_SECTION);
			delete yypvt[-2].yy_name;
		
} break;

case YYr8: {	/* Imports :  IMPORTS SymbolsImported SEMICOLON */

			delete yypvt[-2].yy_name;
		
} break;

case YYr12: {	/* SymbolsFromModuleList :  SymbolsFromModuleList SymbolsFromModule */
			
			newImportModule->SetParentModule(theModule);
			if(yypvt[0].yy_module)
			{
				theModule->AddImportModuleName(newImportModule);
				theParser->DoImportModule(theModule, yypvt[0].yy_module);
			}
			else
				delete newImportModule;
			newImportModule = new SIMCModule;
		
} break;

case YYr13: {	/* SymbolsFromModuleList :  SymbolsFromModule */

			newImportModule->SetParentModule(theModule);
			if(yypvt[0].yy_module)
			{
				theModule->AddImportModuleName(newImportModule);
				theParser->DoImportModule(theModule, yypvt[0].yy_module);
			}
			else
				delete newImportModule;
			newImportModule = new SIMCModule;
		
} break;

case YYr14: {	/* SymbolsFromModule :  SymbolList FROM ImportModuleIdentifier */

			if(strcmp(yypvt[0].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				theParser->SemanticError(theModule->GetInputFileName(),
							IMPORT_CURRENT,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column,
							yypvt[0].yy_name->name);
				yyval.yy_module = NULL;
			}
			else
			{
				newImportModule->SetModuleName(yypvt[0].yy_name->name);
				newImportModule->SetLineNumber(yypvt[0].yy_name->line);
				newImportModule->SetColumnNumber(yypvt[0].yy_name->column);
				newImportModule->SetSymbolType(SIMCSymbol::MODULE_NAME);
				newImportModule->SetInputFileName(theScanner->GetInputStreamName());
				yyval.yy_module = newImportModule;
			}
			delete yypvt[0].yy_name;
		
} break;

case YYr15: {	/* SymbolsFromModule :  error FROM ImportModuleIdentifier */

			theParser->SyntaxError(LIST_IN_IMPORTS);
			delete yypvt[-1].yy_name;
			delete yypvt[0].yy_name;
			yyval.yy_module = NULL;
		
} break;

case YYr16: {	/* ImportModuleIdentifier :  ID LBRACE ObjectIDComponentList RBRACE */

			yyval.yy_name = yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
		
} break;

case YYr17: {	/* ImportModuleIdentifier :  ID LBRACE error RBRACE */

			yyval.yy_name = yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
			theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
		
} break;

case YYr18: {	/* ImportModuleIdentifier :  ID */

			yyval.yy_name = yypvt[0].yy_name;
		
} break;

case YYr21: {	/* Symbol :  ID */

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr22: {	/* Symbol :  NAME */

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr23: {	/* Symbol :  MacroName */

				newImportModule->AddSymbol (
					new SIMCImport( yypvt[0].yy_name->name,
									 SIMCSymbol::IMPORTED,
									 newImportModule,
									 yypvt[0].yy_name->line,
									 yypvt[0].yy_name->column)
											);
				delete yypvt[0].yy_name;
			
} break;

case YYr36: {	/* Assignment :  ObjectIDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr37: {	/* Assignment :  ObjectTypeV1Definition */

				firstAssignment = FALSE;
			
} break;

case YYr38: {	/* Assignment :  TrapTypeDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr39: {	/* Assignment :  ModuleIDefinition */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_IDENTITY_DISALLOWED);
					}
					break;
					case 2:
					{
						if(!firstAssignment)
						{
							theParser->SyntaxError(MODULE_IDENTITY_ONLY_AFTER_IMPORTS);
						}
						else
							firstAssignment = FALSE;
					}
					break;
					default:
					{
						firstAssignment = FALSE;
					}
					break;
				}
			
} break;

case YYr40: {	/* Assignment :  ObjectTypeV2Definition */

				firstAssignment = FALSE;
			
} break;

case YYr41: {	/* Assignment :  ObjectDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr42: {	/* Assignment :  NotifyDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr43: {	/* Assignment :  TextualConventionDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr44: {	/* Assignment :  ObjectGroupDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr45: {	/* Assignment :  NotifyGroupDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr46: {	/* Assignment :  ModComplianceDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr47: {	/* Assignment :  AgentCapabilitiesDefinition */

				firstAssignment = FALSE;
			
} break;

case YYr48: {	/* Assignment :  Typeassignment */

				firstAssignment = FALSE;
			
} break;

case YYr49: {	/* Assignment :  ToleratedOIDAssignment */

				firstAssignment = FALSE;
			
} break;

case YYr50: {	/* Assignment :  Valueassignment */

				firstAssignment = FALSE;
			
} break;

case YYr51: {	/* ObjectIDefinition :  NAME OBJECT IDENTIFIER AllowedCCE ObjectID */

				if(yypvt[0].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-4].yy_name->name);
					if(s) // Symbol exists in symbol table
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-4].yy_name->name,
							new SIMCDefinedValueReference (
								theParser->objectIdentifierType,
								0, 0,
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, 	
								yypvt[-4].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
								(*s)->GetReferenceCount()) );
							// delete (*s);
						}
						else
						{
							theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-4].yy_name->line,
														yypvt[-4].yy_name->column,
														yypvt[-4].yy_name->name);
						}
					}
					else
					{
						theModule->AddSymbol( new SIMCDefinedValueReference (
								theParser->objectIdentifierType,
								0, 0,
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, 
								yypvt[-4].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 0) );
					}
				}
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr52: {	/* ObjectIDefinition :  NAME OBJECT IDENTIFIER AllowedCCE error */

				// Add a syntax error statement here
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr54: {	/* ObjectID :  LBRACE ObjectIDComponentList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType,
							0, 0, 
							new SIMCOidValue(newOidComponentList),
							badName, SIMCSymbol::LOCAL, theModule,
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column);
				delete badName;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr55: {	/* ObjectID :  LBRACE error RBRACE */

				yyval.yy_symbol_ref = NULL;
				delete newOidComponentList;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
				theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
				// Cascade the error, for example to the ObjectIDefinition
				// production
				YYERROR;  

			
} break;

case YYr58: {	/* ObjectSubID :  QualifiedName */

				if(yypvt[0].yy_symbol_ref) 
				{
					newOidComponentList->AddTail(new SIMCOidComponent (
						yypvt[0].yy_symbol_ref->s,yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
					NULL, 0, 0));
				}
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr59: {	/* ObjectSubID :  NAME LPAREN LITNUMBER RPAREN */

				char *badName = theParser->GenerateSymbolName();
				SIMCBuiltInValueReference *val = 
					new SIMCBuiltInValueReference(
						theParser->integerType, 
						0, 0,
						new SIMCIntegerValue(yypvt[-1].yy_number->number, yypvt[-1].yy_number->isUnsigned,
							yypvt[-1].yy_number->line, yypvt[-1].yy_number->column),
						badName,
						SIMCSymbol::LOCAL,
						theModule,
						yypvt[-1].yy_number->line, yypvt[-1].yy_number->column);
				theModule->AddSymbol( val);
				SIMCOidComponent *comp = new SIMCOidComponent (
										theModule->GetSymbol(badName),
										yypvt[-1].yy_number->line, yypvt[-1].yy_number->column,
										yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column );
				delete badName;
				newOidComponentList->AddTail(comp);
				delete yypvt[-3].yy_name;
				delete yypvt[-1].yy_number;
			
} break;

case YYr60: {	/* ObjectSubID :  NAME LPAREN QualifiedName RPAREN */

				if(yypvt[-1].yy_symbol_ref)
					newOidComponentList->AddTail( new SIMCOidComponent(
						yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, 
						yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column));
				delete yypvt[-3].yy_name;
				delete yypvt[-1].yy_symbol_ref;
			
} break;

case YYr61: {	/* ObjectSubID :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				SIMCBuiltInValueReference *val = 
					new SIMCBuiltInValueReference(
						theParser->integerType, 
						0, 0,
						new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned, yypvt[0].yy_number->line, yypvt[0].yy_number->column),
						badName,
						SIMCSymbol::LOCAL,
						theModule,
						yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				theModule->AddSymbol( val);
				SIMCOidComponent *comp = new SIMCOidComponent (
										theModule->GetSymbol(badName),
										yypvt[0].yy_number->line, yypvt[0].yy_number->column,
										NULL, 0, 0);
				delete badName;
				newOidComponentList->AddTail(comp);
				delete yypvt[0].yy_number;
			
} break;

case YYr62: {	/* ObjectTypeV1Definition :  NAME OBJECTYPE SyntaxPart AccessPart StatusPart DescrPart ReferPart IndexPart DefValPart AllowedCCE ObjectID */
				
			
				switch(theParser->GetSnmpVersion())
				{
					case 2:
					{
						theParser->SyntaxError(V1_OBJECT_TYPE_DISALLOWED);
					}
					break;
					default:
					{
						if(yypvt[-8].yy_symbol_ref)
						{
							SIMCObjectTypeV1 * type = new SIMCObjectTypeV1(
								yypvt[-8].yy_symbol_ref->s, yypvt[-8].yy_symbol_ref->line, yypvt[-8].yy_symbol_ref->column,
								yypvt[-7].yy_access->a, yypvt[-7].yy_access->line, yypvt[-7].yy_access->column,
								yypvt[-6].yy_status->a, yypvt[-6].yy_status->line, yypvt[-6].yy_status->column,
								yypvt[-3].yy_index->indexList, yypvt[-3].yy_index->line, yypvt[-3].yy_index->column, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->name : NULL, (yypvt[-5].yy_name)? yypvt[-5].yy_name->line : 0, (yypvt[-5].yy_name)? yypvt[-5].yy_name->column : 0,
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->name : NULL, (yypvt[-4].yy_name)? yypvt[-4].yy_name->line : 0, (yypvt[-4].yy_name)? yypvt[-4].yy_name->column : 0,
								yypvt[-2].yy_def_val->name, yypvt[-2].yy_def_val->symbol, yypvt[-2].yy_def_val->line, yypvt[-2].yy_def_val->column );

							char *badName = theParser->GenerateSymbolName();
							SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
									type, badName, SIMCSymbol::LOCAL, theModule,
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column );
							theModule->AddSymbol(typeRef);
							
							
							SIMCSymbol ** s = theModule->GetSymbol(yypvt[-10].yy_name->name);	
							if(s) // Symbol exists in symbol table
							{
								if(  typeid(**s) == typeid(SIMCUnknown) )
								{
									theModule->ReplaceSymbol( yypvt[-10].yy_name->name,
										new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
										(*s)->GetReferenceCount()) );
									// delete (*s);
								}
								else
								{
									theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
														yypvt[-10].yy_name->name);
									// Remove the symbol for the type reference from the module
									// And delete it
									theModule->RemoveSymbol(badName);
									delete type;
									delete typeRef;
									delete newIndexList;
								}
							}
							else
								theModule->AddSymbol( new SIMCDefinedValueReference (
										theModule->GetSymbol(badName), 
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column) );

							newIndexList = new SIMCIndexList;
							delete badName; 
						}
					}
					break;
				}
				delete yypvt[-10].yy_name; 
				delete yypvt[-9].yy_name; 
				delete yypvt[-8].yy_symbol_ref; 
				delete yypvt[-7].yy_access; 
				delete yypvt[-6].yy_status; 
				delete yypvt[-5].yy_name; 
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_index;
				delete yypvt[-2].yy_def_val;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr63: {	/* ObjectTypeV1Definition :  NAME OBJECTYPE SyntaxPart AccessPart StatusPart DescrPart ReferPart IndexPart DefValPart AllowedCCE error */

				theParser->SyntaxError(OBJECT_IDENTIFIER_VALUE);
				delete yypvt[-10].yy_name; delete yypvt[-9].yy_name; delete yypvt[-8].yy_symbol_ref; delete yypvt[-7].yy_access;
				delete yypvt[-6].yy_status; if(yypvt[-5].yy_name) delete yypvt[-5].yy_name; if(yypvt[-4].yy_name) delete yypvt[-4].yy_name; delete yypvt[-3].yy_index; delete yypvt[-2].yy_def_val;
				delete newIndexList;
				newIndexList = new SIMCIndexList;

			
} break;

case YYr64: {	/* ObjectTypeV1Definition :  NAME OBJECTYPE error AllowedCCE ObjectID */

				theParser->SyntaxError(ERROR_OBJECT_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, NULL, yypvt[-4].yy_name->name);
				theParser->SyntaxError( SKIPPING_OBJECT_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, NULL, yypvt[-4].yy_name->name);
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
				delete newIndexList;
				newIndexList = new SIMCIndexList;
			
} break;

case YYr65: {	/* SyntaxPart :  SYNTAX Type */

				delete yypvt[-1].yy_name;
				if(yypvt[0].yy_symbol_ref)
					yyval.yy_symbol_ref = yypvt[0].yy_symbol_ref;
				else
				{	
					yyval.yy_symbol_ref = NULL;
					theParser->SyntaxError(SYNTAX_CLAUSE);
					YYERROR;
				}
			
} break;

case YYr66: {	/* SyntaxPart :  SYNTAX error */

					delete yypvt[-1].yy_name;
					yyval.yy_symbol_ref = NULL;
					theParser->SyntaxError(SYNTAX_CLAUSE);
					YYERROR;
				
} break;

case YYr67: {	/* AccessPart :  ACCESS NAME */

				SIMCObjectTypeV1::AccessType a;
				if ((a=SIMCObjectTypeV1::StringToAccessType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::ACCESS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_ACCESS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_access = NULL;
					YYERROR;
				}
				else
					yyval.yy_access = new SIMCAccessInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr68: {	/* AccessPart :  ACCESS error */

				yyval.yy_access = new SIMCAccessInfo(SIMCObjectTypeV1::ACCESS_INVALID,
						yypvt[-1].yy_name->line, yypvt[-1].yy_name->column)	;
				theParser->SyntaxError(ACCESS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr69: {	/* StatusPart :  STATUS NAME */

				SIMCObjectTypeV1::StatusType a;
				if ((a=SIMCObjectTypeV1::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_status = new SIMCStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr70: {	/* StatusPart :  STATUS error */

					yyval.yy_status = new SIMCStatusInfo(SIMCObjectTypeV1::STATUS_INVALID,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					theParser->SyntaxError(STATUS_CLAUSE);
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr71: {	/* DescrPart :  DESCRIPTION LITSTRING */

				yyval.yy_name = yypvt[0].yy_name;
				delete yypvt[-1].yy_name;
			
} break;

case YYr72: {	/* DescrPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr73: {	/* DescrPart :  DESCRIPTION error */

					theParser->SyntaxError(DESCRIPTION_CLAUSE);
					yyval.yy_name = NULL;
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr74: {	/* ReferPart :  REFERENCE LITSTRING */

				yyval.yy_name = yypvt[0].yy_name;
				delete yypvt[-1].yy_name;
			
} break;

case YYr75: {	/* ReferPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr76: {	/* ReferPart :  REFERENCE error */

				theParser->SyntaxError(REFERENCE_CLAUSE);
				yyval.yy_name = NULL;
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr77: {	/* IndexPart :  INDEX LBRACE IndexTypes RBRACE */

				yyval.yy_index = new SIMCIndexInfo(newIndexList, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
				newIndexList = new SIMCIndexList;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr78: {	/* IndexPart :  empty */

				yyval.yy_index = new SIMCIndexInfo(newIndexList, 0, 0);
			
} break;

case YYr79: {	/* IndexPart :  INDEX error */

				yyval.yy_index = NULL;
				delete newIndexList;
				newIndexList = new SIMCIndexList;
				theParser->SyntaxError(INDEX_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr82: {	/* IndexType :  Type */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexList->AddTail(new SIMCIndexItem(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr83: {	/* IndexType :  QualifiedName */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexList->AddTail(new SIMCIndexItem(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr84: {	/* DefValPart :  DEFVAL LBRACE DefValValue RBRACE */

				yyval.yy_def_val = yypvt[-1].yy_def_val;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr85: {	/* DefValPart :  empty */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, NULL, 0, 0);
			
} break;

case YYr86: {	/* DefValPart :  DEFVAL error */

				delete yypvt[-1].yy_name;
				yyval.yy_def_val = new SIMCDefValInfo(NULL, NULL, 0, 0);
				theParser->SyntaxError(DEFVAL_CLAUSE);
				YYERROR;
			
} break;

case YYr87: {	/* DefValValue :  TRUE_VAL */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->trueValueReference,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr88: {	/* DefValValue :  FALSE_VAL */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->falseValueReference,
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr89: {	/* DefValValue :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned,
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column) ;
				delete yypvt[0].yy_number;
				delete badName;
			
} break;

case YYr90: {	/* DefValValue :  LBRACE ObjectIDComponentList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType,
							0, 0,
							new SIMCOidValue(newOidComponentList),
							badName, 
							SIMCSymbol::LOCAL, theModule,
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column
							));
				yyval.yy_def_val = new SIMCDefValInfo(NULL, theModule->GetSymbol(badName),
							yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) ;
				delete badName;
				delete yypvt[-2].yy_name;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr91: {	/* DefValValue :  LITSTRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
				delete badName;
			
} break;

case YYr92: {	/* DefValValue :  LIT_HEX_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_hex_string->value, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete yypvt[0].yy_hex_string;
				delete badName;
			
} break;

case YYr93: {	/* DefValValue :  LIT_BINARY_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(TRUE, yypvt[0].yy_binary_string->value, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_def_val = new SIMCDefValInfo(NULL,theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete yypvt[0].yy_binary_string;
				delete badName;
			
} break;

case YYr94: {	/* DefValValue :  NIL */

				yyval.yy_def_val = new SIMCDefValInfo(NULL, theParser->nullValueReference,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr95: {	/* DefValValue :  NAME */

				yyval.yy_def_val = new SIMCDefValInfo(NewString(yypvt[0].yy_name->name), NULL, yypvt[0].yy_name->line,
						yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr96: {	/* DefValValue :  ID DOT NAME */

				SIMCSymbol **s;
				if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
				{
					if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) ))		
						theModule->AddSymbol(
							new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, 
											theModule, yypvt[0].yy_name->line,
											yypvt[0].yy_name->column, 0) );
					yyval.yy_def_val = new SIMCDefValInfo( NULL,
						theModule->GetSymbol(yypvt[0].yy_name->name), yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else
				{			
					SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
					if(m) 
					{
						if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ) )
						{
							theParser->SemanticError(theModule->GetInputFileName(),
										IMPORT_SYMBOL_ABSENT,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
							yyval.yy_def_val = new SIMCDefValInfo( NULL, NULL, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
						}
						else
					yyval.yy_def_val = new SIMCDefValInfo( NULL, s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
					}
					else // Module is not mentioned in imports
					{
						theParser->SemanticError(theModule->GetInputFileName(),
										IMPORT_MODULE_ABSENT,
										yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
										yypvt[-2].yy_name->name);
						yyval.yy_def_val = new SIMCDefValInfo( NULL, NULL, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
					}
				}
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_name;	
			
} break;

case YYr97: {	/* ObjectTypeV2Definition :  NAME OBJECTYPE SyntaxPart UnitsPart MaxAccessPartV2 StatusPartV2 DescrPart ReferPart IndexPartV2 DefValPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(V2_OBJECT_TYPE_DISALLOWED);
					}
					break;

					default:
					{
						if (yypvt[-9].yy_symbol_ref)
						{
							SIMCObjectTypeV2 * type = new SIMCObjectTypeV2(
								yypvt[-9].yy_symbol_ref->s, 
								yypvt[-9].yy_symbol_ref->line, 
								yypvt[-9].yy_symbol_ref->column,
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->name : NULL, 
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->line:0, 
								(yypvt[-8].yy_name)? yypvt[-8].yy_name->column:0,
								( SIMCObjectTypeV2::AccessType ) (yypvt[-7].yy_accessV2->a), 
								yypvt[-7].yy_accessV2->line, 
								yypvt[-7].yy_accessV2->column,
								( SIMCObjectTypeV2::StatusType ) (yypvt[-6].yy_statusV2->a) , 
								(yypvt[-6].yy_statusV2)? yypvt[-6].yy_statusV2->line : 0, 
								(yypvt[-6].yy_statusV2)? yypvt[-6].yy_statusV2->column : 0,
								yypvt[-3].yy_indexV2->indexList, 
								yypvt[-3].yy_indexV2->line, 
								yypvt[-3].yy_indexV2->column,
								yypvt[-3].yy_indexV2->augmentsClause,
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->name : NULL, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->line : 0, 
								(yypvt[-5].yy_name)? yypvt[-5].yy_name->column : 0,
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->name : NULL, 
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->line : 0, 
								(yypvt[-4].yy_name)? yypvt[-4].yy_name->column : 0,
								yypvt[-2].yy_def_val->name, 
								yypvt[-2].yy_def_val->symbol, 
								yypvt[-2].yy_def_val->line, 
								yypvt[-2].yy_def_val->column );

							char *badName = theParser->GenerateSymbolName();
							SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
									type, badName, SIMCSymbol::LOCAL, theModule,
									yypvt[-10].yy_name->line, yypvt[-10].yy_name->column );
							theModule->AddSymbol(typeRef);
							
							
							SIMCSymbol ** s = theModule->GetSymbol(yypvt[-11].yy_name->name);	
							if(s) // Symbol exists in symbol table
							{
								if(  typeid(**s) == typeid(SIMCUnknown) )
								{
									theModule->ReplaceSymbol( yypvt[-11].yy_name->name,
										new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
										(*s)->GetReferenceCount()) );
									// delete (*s);
								}
								else
								{
									theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
														yypvt[-11].yy_name->name);
									// Remove the symbol for the type reference from the module
									// And delete it
									theModule->RemoveSymbol(badName);
									delete type;
									delete typeRef;
									delete newIndexListV2;
								}
							}
							else
								theModule->AddSymbol( new SIMCDefinedValueReference (
										theModule->GetSymbol(badName), 
										yypvt[-10].yy_name->line, yypvt[-10].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column) );

							newIndexList = new SIMCIndexList;
							delete badName; 
						}
					}
					break;
				}
				delete yypvt[-11].yy_name; 
				delete yypvt[-10].yy_name; 
				if(yypvt[-9].yy_symbol_ref) delete yypvt[-9].yy_symbol_ref; 
				delete yypvt[-8].yy_name; 
				delete yypvt[-7].yy_accessV2; 
				delete yypvt[-6].yy_statusV2; 
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_indexV2;
				delete yypvt[-2].yy_def_val;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr98: {	/* MaxAccessPartV2 :  MAXACCESS NAME */

				SIMCObjectTypeV2::AccessType a;
				if ((a=SIMCObjectTypeV2::StringToAccessType(yypvt[0].yy_name->name)) == SIMCObjectTypeV2::ACCESS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_ACCESS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_accessV2 = NULL;
					YYERROR;
				}
				else
					yyval.yy_accessV2 = new SIMCAccessInfoV2(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr99: {	/* MaxAccessPartV2 :  MAXACCESS error */

				yyval.yy_accessV2 = new SIMCAccessInfoV2(SIMCObjectTypeV2::ACCESS_INVALID,
						yypvt[-1].yy_name->line, yypvt[-1].yy_name->column)	;
				theParser->SyntaxError(ACCESS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr100: {	/* StatusPartV2 :  STATUS NAME */

				SIMCObjectTypeV2::StatusType a;
				if ((a=SIMCObjectTypeV2::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV2::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_statusV2 = NULL;
					YYERROR;
				}
				else
					yyval.yy_statusV2 = new SIMCStatusInfoV2(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr101: {	/* StatusPartV2 :  STATUS error */

					yyval.yy_statusV2 = new SIMCStatusInfoV2(SIMCObjectTypeV2::STATUS_INVALID,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					theParser->SyntaxError(STATUS_CLAUSE);
					delete yypvt[-1].yy_name;
					YYERROR;
				
} break;

case YYr102: {	/* UnitsPart :  UNITS LITSTRING */

				delete yypvt[-1].yy_name;
				yyval.yy_name = yypvt[0].yy_name;
			
} break;

case YYr103: {	/* UnitsPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr104: {	/* IndexPartV2 :  INDEX LBRACE IndexTypesV2 RBRACE */

				yyval.yy_indexV2 = new SIMCIndexInfoV2(newIndexListV2, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
				newIndexListV2 = new SIMCIndexListV2;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr105: {	/* IndexPartV2 :  AUGMENTS LBRACE QualifiedName RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;

				yyval.yy_indexV2 = new SIMCIndexInfoV2(NULL, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, yypvt[-1].yy_symbol_ref->s);
			
} break;

case YYr106: {	/* IndexPartV2 :  empty */

				yyval.yy_indexV2 = new SIMCIndexInfoV2(NULL, 0, 0);
			
} break;

case YYr107: {	/* IndexPartV2 :  INDEX error */

				yyval.yy_indexV2 = NULL;
				delete newIndexListV2;
				newIndexListV2 = new SIMCIndexListV2;
				theParser->SyntaxError(INDEX_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr110: {	/* IndexTypeV2 :  IMPLIED QualifiedName */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexListV2->AddTail(new SIMCIndexItemV2(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column, TRUE));
				}
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr111: {	/* IndexTypeV2 :  QualifiedName */

				if(yypvt[0].yy_symbol_ref)
				{
					newIndexListV2->AddTail(new SIMCIndexItemV2(
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
					delete yypvt[0].yy_symbol_ref;
				}
			
} break;

case YYr112: {	/* TrapTypeDefinition :  NAME TRAPTYPE EnterprisePart VarPart DescrPart ReferPart AllowedCCE NumericValue */

				SIMCTrapTypeType * type = new SIMCTrapTypeType(
					yypvt[-5].yy_symbol_ref->s, yypvt[-5].yy_symbol_ref->line, yypvt[-5].yy_symbol_ref->column,
					yypvt[-4].yy_variables_list, 
					(yypvt[-3].yy_name)?yypvt[-3].yy_name->name: NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line: 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column:0,
					(yypvt[-2].yy_name)?yypvt[-2].yy_name->name:NULL, (yypvt[-2].yy_name)?yypvt[-2].yy_name->line:0, (yypvt[-2].yy_name)?yypvt[-2].yy_name->column:0);

				char *badName1 = theParser->GenerateSymbolName();

				SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
						type, badName1, SIMCSymbol::LOCAL, theModule,
						yypvt[-6].yy_name->line, yypvt[-6].yy_name->column);

				theModule->AddSymbol(typeRef);
				
				SIMCSymbol ** s = theModule->GetSymbol(yypvt[-7].yy_name->name);	
				if(s) // Symbol exists in symbol table
				{
					if(  typeid(**s) == typeid(SIMCUnknown) )
					{
						theModule->ReplaceSymbol( yypvt[-7].yy_name->name,
							new SIMCDefinedValueReference (
							theModule->GetSymbol(badName1),
							yypvt[-6].yy_name->line, yypvt[-6].yy_name->column, 
							yypvt[0].yy_symbol_ref->s,
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							yypvt[-7].yy_name->name, SIMCSymbol::LOCAL, theModule, 
							yypvt[-7].yy_name->line, yypvt[-7].yy_name->column,
							(*s)->GetReferenceCount()) );
						// delete (*s);
					}
					else
					{
						theParser->SemanticError(theModule->GetInputFileName(),
											SYMBOL_REDEFINITION,
											yypvt[-7].yy_name->line, yypvt[-7].yy_name->column,
											yypvt[-7].yy_name->name);
						// Remove the symbol for the type reference from the module
						// And delete it
						theModule->RemoveSymbol(badName1);
						delete type;
						delete typeRef;
						delete newVariablesList;
					}
				}
				else
					theModule->AddSymbol( new SIMCDefinedValueReference (
							theModule->GetSymbol(badName1), 
							yypvt[-6].yy_name->line, yypvt[-6].yy_name->column, 
							yypvt[0].yy_symbol_ref->s,
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							yypvt[-7].yy_name->name, SIMCSymbol::LOCAL, theModule, 
							yypvt[-7].yy_name->line, yypvt[-7].yy_name->column) );

				newVariablesList = new SIMCVariablesList;
				delete badName1; 
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_symbol_ref; 
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name; 
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr113: {	/* TrapTypeDefinition :  NAME TRAPTYPE error AllowedCCE NumericValue */

				theParser->SyntaxError( SKIPPING_TRAP_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
					NULL, yypvt[-4].yy_name->name);
				delete newVariablesList;
				newVariablesList = new SIMCVariablesList;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr114: {	/* TrapTypeDefinition :  NAME TRAPTYPE error AllowedCCE error */

				theParser->SyntaxError( SKIPPING_TRAP_TYPE, yypvt[-4].yy_name->line, yypvt[-4].yy_name->column, 
					NULL, yypvt[-4].yy_name->name);
				delete newVariablesList;
				newVariablesList = new SIMCVariablesList;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
			
} break;

case YYr115: {	/* EnterprisePart :  ENTERPRISE ObjectID */

				yyval.yy_symbol_ref = yypvt[0].yy_symbol_ref;
				delete yypvt[-1].yy_name;
			
} break;

case YYr116: {	/* EnterprisePart :  ENTERPRISE error */

				delete yypvt[-1].yy_name;
				theParser->SyntaxError(ENTERPRISE_CLAUSE);
				YYERROR;
			
} break;

case YYr117: {	/* VarPart :  VARIABLES LBRACE VarTypeListForTrap RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				yyval.yy_variables_list = newVariablesList;
			
} break;

case YYr118: {	/* VarPart :  empty */

				yyval.yy_variables_list = newVariablesList;
			
} break;

case YYr119: {	/* VarPart :  VARIABLES error */

				yyval.yy_variables_list = newVariablesList;
				theParser->SyntaxError(VARIABLES_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr123: {	/* VarTypeForTrap :  QualifiedName */

					if(yypvt[0].yy_symbol_ref)
					{
						newVariablesList->AddTail(
							new SIMCVariablesItem(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
						delete yypvt[0].yy_symbol_ref;
					}
				
} break;

case YYr128: {	/* UncheckedQualifiedName :  NAME */

					delete yypvt[0].yy_name;
				
} break;

case YYr129: {	/* UncheckedQualifiedName :  ID DOT NAME */

					delete yypvt[-2].yy_name;
					delete yypvt[0].yy_name;
				
} break;

case YYr130: {	/* Typeassignment :  ID AllowedCCE Type */

				if (yypvt[0].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-2].yy_name->name);	
					if(s) // Symbol exists in symbol table
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-2].yy_name->name,
								new SIMCDefinedTypeReference (
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									(*s)->GetReferenceCount()) 
													);
							// delete (*s);
						}
						else
							theParser->SemanticError(theModule->GetInputFileName(),
											SYMBOL_REDEFINITION,
											yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
											yypvt[-2].yy_name->name);
					}
					else
						theModule->AddSymbol( new SIMCDefinedTypeReference (
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
								yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) );

				}
				delete yypvt[-2].yy_name;
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr133: {	/* BuiltinType :  _BOOLEAN */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->booleanType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr134: {	/* BuiltinType :  OBJECT IDENTIFIER */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->objectIdentifierType,
							yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr135: {	/* BuiltinType :  Octetstring */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->octetStringType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr136: {	/* BuiltinType :  NIL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->nullType,
						yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr137: {	/* BuiltinType :  QualifiedIdOrIntegerOrBits NNlist */

				if( yypvt[0].yy_named_number_list && yypvt[-1].yy_symbol_ref )
				{
					char *badName = theParser->GenerateSymbolName();
					if(yypvt[-1].yy_symbol_ref->s == theParser->integerType)
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_ENUM),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}
					else if (yypvt[-1].yy_symbol_ref->s == theParser->bitsType)
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_BITS),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}
					else
					{
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCEnumOrBitsType(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column,	
									yypvt[0].yy_named_number_list, SIMCEnumOrBitsType::ENUM_OR_BITS_UNKNOWN),
								badName,
								SIMCSymbol::LOCAL,
								theModule, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column) );
					}

					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
								yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
					delete badName;
					delete yypvt[-1].yy_symbol_ref;
				}
				else  if(yypvt[-1].yy_symbol_ref)
					yyval.yy_symbol_ref = yypvt[-1].yy_symbol_ref;
				else
					yyval.yy_symbol_ref = NULL;
			
} break;

case YYr138: {	/* BuiltinType :  SequenceOf Type */

				if(yypvt[0].yy_symbol_ref)
				{
					char *badName = theParser->GenerateSymbolName();
					theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCSequenceOfType(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column),
								badName,
								SIMCSymbol::LOCAL,
								theModule,
								yypvt[-1].yy_name->line, yypvt[-1].yy_name->column) );
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
								yypvt[-1].yy_name->line, yypvt[-1].yy_name->column);
					delete badName;
				}
				else
					yyval.yy_symbol_ref = NULL;
				delete yypvt[-1].yy_name;
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr139: {	/* BuiltinType :  SEQUENCE LBRACE ElementTypes RBRACE */

				delete yypvt[-3].yy_name;
				if(newSequenceList)
				{
					char *badName = theParser->GenerateSymbolName();
					theModule->AddSymbol(new SIMCBuiltInTypeReference (
								new SIMCSequenceType(newSequenceList),
								badName,
								SIMCSymbol::LOCAL,
								theModule) );
					yyval.yy_symbol_ref = new SIMCSymbolReference (
						theModule->GetSymbol(badName), yypvt[-3].yy_name->line, yypvt[-3].yy_name->column);
					delete badName;
					newSequenceList = new SIMCSequenceList;
				}
				else
				{
					theParser->SyntaxError(SEQUENCE_DEFINITION);
					newSequenceList = new SIMCSequenceList;
					yyval.yy_symbol_ref = NULL;
				}
			
} break;

case YYr140: {	/* BuiltinType :  SEQUENCE LBRACE error RBRACE */

				theParser->SyntaxError(SEQUENCE_DEFINITION);
				yyval.yy_symbol_ref = NULL;
				delete yypvt[-3].yy_name;
			
} break;

case YYr141: {	/* QualifiedIdOrIntegerOrBits :  INTEGER */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->integerType, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr142: {	/* QualifiedIdOrIntegerOrBits :  BITSXX */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->bitsType, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr144: {	/* NNlist :  LBRACE NamedNumberList RBRACE */

				yyval.yy_named_number_list = newNamedNumberList;
				newNamedNumberList = new SIMCNamedNumberList;
			
} break;

case YYr145: {	/* NNlist :  empty */

				yyval.yy_named_number_list = NULL;
			
} break;

case YYr146: {	/* NNlist :  LBRACE error RBRACE */

				yyval.yy_named_number_list = NULL;
				delete newNamedNumberList;
				newNamedNumberList = new SIMCNamedNumberList;
				theParser->SyntaxError(INTEGER_ENUMERATION);
			
} break;

case YYr149: {	/* NamedNumber :  NAME LPAREN NamedNumberValue RPAREN */

				newNamedNumberList->AddTail(new SIMCNamedNumberItem(yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, 
					yypvt[-3].yy_name->name, yypvt[-3].yy_name->line, yypvt[-3].yy_name->column));
				delete yypvt[-3].yy_name; 
				delete yypvt[-1].yy_symbol_ref;
			
} break;

case YYr152: {	/* NumericValue :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned, 
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				delete badName;
				delete yypvt[0].yy_number;
			
} break;

case YYr153: {	/* NumericValue :  LIT_HEX_STRING */

				// attempt to convert it to a signed long
				register char *cp = yypvt[0].yy_hex_string->value;
				if(strlen(cp) > 8)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
											INTEGER_TOO_BIG,
											yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				}
		
				for (long i = 0; *cp; cp++ ) 
				{
				    i *= 16;
					i += HexCharToDecimal(*cp);
                }
				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(i, TRUE, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete badName;
				delete yypvt[0].yy_hex_string;

			
} break;

case YYr154: {	/* NumericValue :  LIT_BINARY_STRING */

				register char *cp = yypvt[0].yy_binary_string->value;
				if(strlen(cp) > 32)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
											INTEGER_TOO_BIG,
											yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				}
				for (long i = 0; *cp; cp++ ) 
				{
				    i <<= 1;
					i += *cp - '0';
                }
				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->integerType, 0, 0,
							new SIMCIntegerValue(i, TRUE, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete badName;
				delete yypvt[0].yy_binary_string;

			
} break;

case YYr157: {	/* NamedType :  NAME Type */

				if(!theModule->GetSymbol(yypvt[-1].yy_name->name) )  
					theModule->AddSymbol( new SIMCUnknown(yypvt[-1].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[-1].yy_name->line,
										yypvt[-1].yy_name->column, 0));

				if (yypvt[0].yy_symbol_ref)
					newSequenceList->AddTail(new SIMCSequenceItem(
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										theModule->GetSymbol(yypvt[-1].yy_name->name),
										yypvt[-1].yy_name->line, yypvt[-1].yy_name->column));
				else
					theParser->SyntaxError(SEQUENCE_DEFINITION);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;

			
} break;

case YYr158: {	/* ToleratedOIDAssignment :  NAME AllowedCCE ObjectID */

		SIMCSymbol ** s = theModule->GetSymbol(yypvt[-2].yy_name->name);	
		if(s) // Symbol exists in symbol table
		{
			if(  typeid(**s) == typeid(SIMCUnknown) )
			{
				theModule->ReplaceSymbol( yypvt[-2].yy_name->name,
					new SIMCDefinedValueReference (
						theParser->objectIdentifierType,
						yypvt[-2].yy_name->line, yypvt[-2].yy_name->column, 
						yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
						yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
						yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
						(*s)->GetReferenceCount()) );
				// delete (*s);
			}
			else
			{
				theParser->SemanticError(theModule->GetInputFileName(),
									SYMBOL_REDEFINITION,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
			}
		}
		else
			theModule->AddSymbol( new SIMCDefinedValueReference (
					theParser->objectIdentifierType,
					yypvt[-2].yy_name->line, yypvt[-2].yy_name->column, 
					yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
					yypvt[-2].yy_name->name, SIMCSymbol::LOCAL, theModule, 
					yypvt[-2].yy_name->line, yypvt[-2].yy_name->column) );

		delete yypvt[-2].yy_name;
		delete yypvt[0].yy_symbol_ref;

	
} break;

case YYr159: {	/* Valueassignment :  NAME Type AllowedCCE Value */

				if(yypvt[0].yy_symbol_ref && yypvt[-2].yy_symbol_ref)
				{
					SIMCSymbol ** s = theModule->GetSymbol(yypvt[-3].yy_name->name);	
					if(s) // Symbol exists in symbol table
					{
						if(  typeid(**s) == typeid(SIMCUnknown) )
						{
							theModule->ReplaceSymbol( yypvt[-3].yy_name->name,
								new SIMCDefinedValueReference (
									yypvt[-2].yy_symbol_ref->s, yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-3].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-3].yy_name->line, yypvt[-3].yy_name->column,
									(*s)->GetReferenceCount()) );
							// delete (*s);
						}
						else
						{
							theParser->SemanticError(theModule->GetInputFileName(),
												SYMBOL_REDEFINITION,
												yypvt[-3].yy_name->line, yypvt[-3].yy_name->column,
												yypvt[-3].yy_name->name);
						}
					}
					else
					{
						theModule->AddSymbol( new SIMCDefinedValueReference (
								yypvt[-2].yy_symbol_ref->s, yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column, 
								yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
								yypvt[-3].yy_name->name, SIMCSymbol::LOCAL, theModule, 
								yypvt[-3].yy_name->line, yypvt[-3].yy_name->column) );
					}

				}
				if(yypvt[0].yy_symbol_ref)
					delete yypvt[0].yy_symbol_ref;
				if(yypvt[-2].yy_symbol_ref)
					delete yypvt[-2].yy_symbol_ref;
				delete yypvt[-3].yy_name;
			
} break;

case YYr162: {	/* BuiltinValue :  TRUE_VAL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->trueValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;

			
} break;

case YYr163: {	/* BuiltinValue :  FALSE_VAL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->falseValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr164: {	/* BuiltinValue :  LITNUMBER */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (theParser->integerType,
							0, 0,
							new SIMCIntegerValue(yypvt[0].yy_number->number, yypvt[0].yy_number->isUnsigned,
								yypvt[0].yy_number->line, yypvt[0].yy_number->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_number->line, yypvt[0].yy_number->column);
				delete badName;
				delete yypvt[0].yy_number;
			
} break;

case YYr165: {	/* BuiltinValue :  LIT_HEX_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_hex_string->value, yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_hex_string->line, yypvt[0].yy_hex_string->column);
				delete yypvt[0].yy_hex_string;
				delete badName;
			
} break;

case YYr166: {	/* BuiltinValue :  LIT_BINARY_STRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType,
							0, 0,
							new SIMCOctetStringValue(TRUE, yypvt[0].yy_binary_string->value, yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_binary_string->line, yypvt[0].yy_binary_string->column);
				delete yypvt[0].yy_binary_string;
				delete badName;
			
} break;

case YYr167: {	/* BuiltinValue :  LBRACE ObjectIDComponentList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->objectIdentifierType, 0, 0, 
							new SIMCOidValue(newOidComponentList),
							badName, SIMCSymbol::LOCAL, theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName), 0, 0);
				delete badName;
				newOidComponentList = new SIMCOidComponentList;
			
} break;

case YYr168: {	/* BuiltinValue :  LBRACE NameList RBRACE */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol( new SIMCBuiltInValueReference( 
							theParser->bitsType, 0, 0, 
							new SIMCBitsValue(newNameList),
							badName, SIMCSymbol::LOCAL, theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName), 0, 0);
				delete badName;
				newNameList = new SIMCBitValueList;
			
} break;

case YYr169: {	/* BuiltinValue :  LITSTRING */

				char *badName = theParser->GenerateSymbolName();
				theModule->AddSymbol(new SIMCBuiltInValueReference (
							theParser->octetStringType, 0, 0,
							new SIMCOctetStringValue(FALSE, yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column),
							badName,
							SIMCSymbol::LOCAL,
							theModule));
				yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete badName;
				delete yypvt[0].yy_name;
			
} break;

case YYr170: {	/* BuiltinValue :  NIL */

				yyval.yy_symbol_ref = new SIMCSymbolReference(theParser->nullValueReference,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[0].yy_name;
			
} break;

case YYr173: {	/* Name :  NAME */

				newNameList->AddTail(new SIMCBitValue(yypvt[0].yy_name->name, yypvt[0].yy_name->line, yypvt[0].yy_name->column) );
			
} break;

case YYr176: {	/* Octetstring :  OCTET STRING */

				yyval.yy_name = yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr179: {	/* SequenceOf :  SEQUENCE OF */

				yyval.yy_name = yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr180: {	/* SubType :  Type SubtypeRangeSpec */

					if(yypvt[-1].yy_symbol_ref && yypvt[0].yy_range_list)
					{
						// Create a range sub type
						SIMCRangeType *type = new SIMCRangeType (yypvt[-1].yy_symbol_ref->s, 
								yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column, yypvt[0].yy_range_list);
						char *badName = theParser->GenerateSymbolName();
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
							type,
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
						yyval.yy_symbol_ref = new SIMCSymbolReference( theModule->GetSymbol(badName),
									yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
						delete badName;
					}
					else
					{
						yyval.yy_symbol_ref = NULL;
					}
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr181: {	/* SubType :  Type SubtypeSizeSpec */

					if(yypvt[-1].yy_symbol_ref && yypvt[0].yy_range_list)
					{
						// Create a range sub type
						SIMCSizeType *type = new SIMCSizeType (yypvt[-1].yy_symbol_ref->s, yypvt[-1].yy_symbol_ref->line,
								yypvt[-1].yy_symbol_ref->column, yypvt[0].yy_range_list);
						char *badName = theParser->GenerateSymbolName();
						theModule->AddSymbol(new SIMCBuiltInTypeReference (
							type,
							badName,
							SIMCSymbol::LOCAL,
							theModule) );
						yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(badName),
									yypvt[-1].yy_symbol_ref->line, yypvt[-1].yy_symbol_ref->column);
						delete badName;
					}
					else
					{
						yyval.yy_symbol_ref = NULL;
					}
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr182: {	/* SubType :  Type error */

					yyval.yy_symbol_ref = NULL;
					if(yypvt[-1].yy_symbol_ref)
						delete yypvt[-1].yy_symbol_ref;
				
} break;

case YYr183: {	/* SubtypeRangeSpec :  LPAREN SubtypeRangeAlternative SubtypeRangeAlternativeList RPAREN */

					yyval.yy_range_list = newRangeList;
					newRangeList = new SIMCRangeList;
				
} break;

case YYr184: {	/* SubtypeRangeSpec :  LPAREN error RPAREN */

						delete newRangeList;
						newRangeList = new SIMCRangeList;
						yyval.yy_range_list = NULL;
						theParser->SyntaxError(SUB_TYPE_SPECIFICATION);
						YYERROR;
					
} break;

case YYr185: {	/* SubtypeRangeAlternative :  SubtypeValueSet */

						newRangeList->AddTail(yypvt[0].yy_range_or_size_item);
					
} break;

case YYr188: {	/* SubtypeValueSet :  NumericValue */

				SIMCBuiltInValueReference *bvRef = 
					(SIMCBuiltInValueReference *)(*yypvt[0].yy_symbol_ref->s);
				SIMCIntegerValue *intValue = (SIMCIntegerValue*)bvRef->GetValue();
				yyval.yy_range_or_size_item = new SIMCRangeOrSizeItem(
							intValue->GetIntegerValue(), intValue->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
							intValue->GetIntegerValue(), intValue->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column);
				theModule->RemoveSymbol((*yypvt[0].yy_symbol_ref->s)->GetSymbolName());
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr189: {	/* SubtypeValueSet :  NumericValue DOTDOT NumericValue */

				SIMCBuiltInValueReference *bvRef1 = 
					(SIMCBuiltInValueReference *)(*yypvt[-2].yy_symbol_ref->s);
				SIMCIntegerValue *intValue1 = (SIMCIntegerValue*)bvRef1->GetValue();
				SIMCBuiltInValueReference *bvRef3 = 
					(SIMCBuiltInValueReference *)(*yypvt[0].yy_symbol_ref->s);
				SIMCIntegerValue *intValue3 = (SIMCIntegerValue*)bvRef3->GetValue();
				
					yyval.yy_range_or_size_item = new SIMCRangeOrSizeItem(
							intValue1->GetIntegerValue(), intValue1->IsUnsigned(),
							yypvt[-2].yy_symbol_ref->line, yypvt[-2].yy_symbol_ref->column,
							intValue3->GetIntegerValue(), intValue3->IsUnsigned(),
							yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column);
					theModule->RemoveSymbol((*yypvt[-2].yy_symbol_ref->s)->GetSymbolName());
					theModule->RemoveSymbol((*yypvt[0].yy_symbol_ref->s)->GetSymbolName());
					delete yypvt[-2].yy_symbol_ref;
					delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr190: {	/* SubtypeSizeSpec :  LPAREN _SIZE SubtypeRangeSpec RPAREN */

						yyval.yy_range_list = yypvt[-1].yy_range_list;
						delete yypvt[-2].yy_name;
					
} break;

case YYr191: {	/* SubtypeSizeSpec :  LPAREN _SIZE error RPAREN */

						yyval.yy_range_list = NULL;
						delete yypvt[-2].yy_name;
						theParser->SyntaxError(SIZE_SPECIFICATION);
					
} break;

case YYr192: {	/* QualifiedName :  ID DOT NAME */

			SIMCSymbol **s;
			if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) ))		
					theModule->AddSymbol(
						new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, 
										theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0) );
				yyval.yy_symbol_ref = new SIMCSymbolReference (theModule->GetSymbol(yypvt[0].yy_name->name),
							yypvt[0].yy_name->line, yypvt[0].yy_name->column);
			}
			else
			{			
				SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
				if(m) 
				{
					if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ) )
					{
						theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_SYMBOL_ABSENT,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column,
									yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
						yyval.yy_symbol_ref = NULL;
					}
					else
						yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else // Module is not mentioned in imports
				{
					theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_MODULE_ABSENT,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
					yyval.yy_symbol_ref = NULL;
				}
			}
			delete yypvt[-2].yy_name;
			delete yypvt[0].yy_name;				
	
} break;

case YYr193: {	/* QualifiedName :  NAME */

				SIMCSymbol **s;
				const SIMCModule *reservedModule;

				// Reserved Symbol
				if(reservedModule = theParser->IsReservedSymbol(yypvt[0].yy_name->name))
				{
					// If Symbol exists in the current module too,
					//		dont use that definition since this is a reserved symbol.
					//		Instead issue a warning.
					// else cool.
					if( s = theModule->GetSymbol(yypvt[0].yy_name->name) )  
					{
						if( ! theParser->IsReservedSymbol(yypvt[0].yy_name->name, theModule->GetModuleName()) ) 
							theParser->SemanticError(theModule->GetInputFileName(),
										KNOWN_REDEFINITION,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, reservedModule->GetModuleName());
					}
					yyval.yy_symbol_ref = new SIMCSymbolReference(reservedModule->GetSymbol(yypvt[0].yy_name->name),
													yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}  
				// Not a reserved symbol, but defined in this module
				else if ( s = theModule->GetSymbol(yypvt[0].yy_name->name))
					yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column) ;
				// Not a reserved symbol, not defined in this module so far.
				// Create a new entry, hoping that it will be defined later, or is imported
				else
				{		
					theModule->AddSymbol( new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0));
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(yypvt[0].yy_name->name),
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				delete yypvt[0].yy_name;
	
} break;

case YYr194: {	/* QualifiedId :  ID DOT ID */


			SIMCSymbol **s;
			if( strcmp(yypvt[-2].yy_name->name, theModule->GetModuleName()) == 0 )
			{
				if( !(s = theModule->GetSymbol(yypvt[0].yy_name->name) )  ) 		
					theModule->AddSymbol(
						new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0) );
				yyval.yy_symbol_ref = new SIMCSymbolReference (theModule->GetSymbol(yypvt[0].yy_name->name),
									yypvt[0].yy_name->line, yypvt[0].yy_name->column);
			}
			else
			{			
				SIMCModule *m = theModule->GetImportModule(yypvt[-2].yy_name->name);
				if(m) 
				{
					if( ! ( s = m->GetSymbol(yypvt[0].yy_name->name) ))
					{
						theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_SYMBOL_ABSENT,
									yypvt[0].yy_name->line, yypvt[0].yy_name->column,
									yypvt[0].yy_name->name, yypvt[-2].yy_name->name);
						yyval.yy_symbol_ref = NULL;
					}
					else
						yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				else // Module is mentioned in imports
				{
					theParser->SemanticError(theModule->GetInputFileName(),
									IMPORT_MODULE_ABSENT,
									yypvt[-2].yy_name->line, yypvt[-2].yy_name->column,
									yypvt[-2].yy_name->name);
					yyval.yy_symbol_ref = NULL;
				}
			}
			delete yypvt[-2].yy_name;
			delete yypvt[0].yy_name;				
	
} break;

case YYr195: {	/* QualifiedId :  ID */

				SIMCSymbol **s;
				const SIMCModule *reservedModule;

				// Reserved Symbol
				if(reservedModule = theParser->IsReservedSymbol(yypvt[0].yy_name->name))
				{
					// If Symbol exists in the current module too,
					//		dont use that definition since this is a reserved symbol.
					//		Instead issue a warning.
					// else cool.
					if( s = theModule->GetSymbol(yypvt[0].yy_name->name) ) 
					{
						if( ! theParser->IsReservedSymbol(yypvt[0].yy_name->name,  theModule->GetModuleName()) ) 
							theParser->SemanticError(theModule->GetInputFileName(),
										KNOWN_REDEFINITION,
										yypvt[0].yy_name->line, yypvt[0].yy_name->column,
										yypvt[0].yy_name->name, reservedModule->GetModuleName());
					}
					yyval.yy_symbol_ref = new SIMCSymbolReference(reservedModule->GetSymbol(yypvt[0].yy_name->name),
													yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				// Not a reserved symbol, but defined in this module
				else if ( s = theModule->GetSymbol(yypvt[0].yy_name->name))
					yyval.yy_symbol_ref = new SIMCSymbolReference(s, yypvt[0].yy_name->line, yypvt[0].yy_name->column) ;
				// Not a reserved symbol, not defined in this module so far.
				// Create a new entry, hoping that it will be defined later, or is imported
				else
				{		
					theModule->AddSymbol( new SIMCUnknown(yypvt[0].yy_name->name, SIMCSymbol::LOCAL, theModule, yypvt[0].yy_name->line,
										yypvt[0].yy_name->column, 0));
					yyval.yy_symbol_ref = new SIMCSymbolReference(theModule->GetSymbol(yypvt[0].yy_name->name),
								yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				}
				delete yypvt[0].yy_name;
	
} break;

case YYr196: {	/* AllowedCCE :  InsteadOfCCE */

			theParser->SyntaxError(INSTEAD_OF_CCE, yypvt[0].yy_name->line, yypvt[0].yy_name->column, NULL, yypvt[0].yy_name->name);
			delete yypvt[0].yy_name;
		
} break;

case YYr198: {	/* InsteadOfCCE :  ':' ':' */

			yyval.yy_name = new SIMCNameInfo("::", theScanner->yylineno, theScanner->columnNo - 2);
		
} break;

case YYr199: {	/* InsteadOfCCE :  ':' '=' */

			yyval.yy_name = new SIMCNameInfo(":=", theScanner->yylineno, theScanner->columnNo - 2);
		
} break;

case YYr200: {	/* InsteadOfCCE :  '=' */

			yyval.yy_name = new SIMCNameInfo("=", theScanner->yylineno, theScanner->columnNo - 1);
		
} break;

case YYr201: {	/* NotifyDefinition :  NAME NOTIFY ObjectsPart NotificationTypeStatusPart DESCRIPTION LITSTRING ReferPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(NOTIFICATION_TYPE_DISALLOWED);
					}
					break;
					default:
					{
						SIMCNotificationTypeType * type = new SIMCNotificationTypeType(
							yypvt[-6].yy_objects_list,
							(yypvt[-3].yy_name)?yypvt[-3].yy_name->name: NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line: 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column:0,
							(yypvt[-2].yy_name)?yypvt[-2].yy_name->name:NULL, (yypvt[-2].yy_name)?yypvt[-2].yy_name->line:0, (yypvt[-2].yy_name)?yypvt[-2].yy_name->column:0,
							yypvt[-5].yy_notification_type_status->a, yypvt[-5].yy_notification_type_status->line, yypvt[-5].yy_notification_type_status->column);

						char *badName1 = theParser->GenerateSymbolName();

						SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
								type, badName1, SIMCSymbol::LOCAL, theModule,
								yypvt[-7].yy_name->line, yypvt[-7].yy_name->column);

						theModule->AddSymbol(typeRef);
						
						// Add an OID value reference
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-8].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-8].yy_name->name,
									new SIMCDefinedValueReference (
										theModule->GetSymbol(badName1), 
										yypvt[-8].yy_name->line, yypvt[-8].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-8].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-8].yy_name->line, yypvt[-8].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-8].yy_name->line, yypvt[-8].yy_name->column,
													yypvt[-8].yy_name->name);
								// Remove the symbol for the type reference from the module
								// And delete it
								theModule->RemoveSymbol(badName1);
								delete type;
								delete typeRef;
								delete newObjectsList;
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theModule->GetSymbol(badName1), 
									yypvt[-8].yy_name->line, yypvt[-8].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-8].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-8].yy_name->line, yypvt[-8].yy_name->column) );


						delete badName1; 
					}
				}
				newObjectsList = new SIMCObjectsList;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-5].yy_notification_type_status; 
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr202: {	/* NotificationTypeStatusPart :  STATUS NAME */

				SIMCNotificationTypeType::StatusType a;
				if ((a=SIMCNotificationTypeType::StringToStatusType(yypvt[0].yy_name->name)) == SIMCNotificationTypeType::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								NOTIFICATION_TYPE_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_notification_type_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_notification_type_status = new SIMCNotificationTypeStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr203: {	/* ObjectsPart :  OBJECTS LBRACE ObjectTypeListForNotification RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				yyval.yy_objects_list = newObjectsList;
			
} break;

case YYr204: {	/* ObjectsPart :  empty */

				yyval.yy_objects_list = newObjectsList;
			
} break;

case YYr205: {	/* ObjectsPart :  OBJECTS error */

				yyval.yy_objects_list = newObjectsList;
				theParser->SyntaxError(OBJECTS_CLAUSE);
				delete yypvt[-1].yy_name;
				YYERROR;
			
} break;

case YYr209: {	/* ObjectTypeForNotification :  QualifiedName */

					if(yypvt[0].yy_symbol_ref)
					{
						newObjectsList->AddTail(
							new SIMCObjectsItem(yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column));
						delete yypvt[0].yy_symbol_ref;
					}
				
} break;

case YYr210: {	/* ModuleIDefinition :  NAME MODULEID LASTUPDATE LITSTRING ORGANIZATION LITSTRING CONTACTINFO LITSTRING DESCRIPTION LITSTRING RevisionPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_IDENTITY_DISALLOWED);
					}
					break;
					default:
					{
						theModule->SetModuleIdentityName(yypvt[-12].yy_name->name);
						theModule->SetLastUpdated(yypvt[-9].yy_name->name);
						theModule->SetOrganization(yypvt[-7].yy_name->name);
						theModule->SetContactInfo(yypvt[-5].yy_name->name);
						theModule->SetDescription(yypvt[-3].yy_name->name);

						// Create a value reference in the symbol table,
						// since the symbol can be used as an OID value
					
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
									(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType, 
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );

					}
					break;
				}
					
				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr215: {	/* Revision :  REVISION LITSTRING DESCRIPTION LITSTRING */

				theModule->AddRevisionClause( new SIMCRevisionElement (
									yypvt[-2].yy_name->name, yypvt[0].yy_name->name) );
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr216: {	/* ObjectDefinition :  NAME OBJECTIDENT ObjectIdentityStatusPart DescrPart ReferPart AllowedCCE ObjectID */

				switch( theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(OBJECT_IDENTITY_DISALLOWED);
					}
					break;
					default:
					{
						// Form an SIMCObjectIdentity type
						SIMCObjectIdentityType * type = new SIMCObjectIdentityType(
							yypvt[-4].yy_object_identity_status->a, yypvt[-4].yy_object_identity_status->line, yypvt[-4].yy_object_identity_status->column,
							(yypvt[-3].yy_name)? yypvt[-3].yy_name->name : NULL, (yypvt[-3].yy_name)? yypvt[-3].yy_name->line : 0, (yypvt[-3].yy_name)? yypvt[-3].yy_name->column : 0,
							(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL, (yypvt[-2].yy_name)? yypvt[-2].yy_name->line : 0, (yypvt[-2].yy_name)? yypvt[-2].yy_name->column : 0);

						char *badName = theParser->GenerateSymbolName();
						SIMCBuiltInTypeReference * typeRef = new SIMCBuiltInTypeReference (
								type, badName, SIMCSymbol::LOCAL, theModule,
								yypvt[-5].yy_name->line, yypvt[-5].yy_name->column );
						theModule->AddSymbol(typeRef);
						
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-6].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-6].yy_name->name,
									new SIMCDefinedValueReference (
										theModule->GetSymbol(badName),
										yypvt[-5].yy_name->line, yypvt[-5].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-6].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-6].yy_name->line, yypvt[-6].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-6].yy_name->line, yypvt[-6].yy_name->column,
													yypvt[-6].yy_name->name);
								// Remove the symbol for the type reference from the module
								// And delete it
								theModule->RemoveSymbol(badName);
								delete type;
								delete typeRef;
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theModule->GetSymbol(badName), 
									yypvt[-5].yy_name->line, yypvt[-5].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-6].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-6].yy_name->line, yypvt[-6].yy_name->column) );
						}
					}

					delete yypvt[-6].yy_name;
					delete yypvt[-5].yy_name;
					if(yypvt[-4].yy_object_identity_status) delete yypvt[-4].yy_object_identity_status;
					if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
					if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
					if(yypvt[0].yy_symbol_ref) delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr217: {	/* ObjectIdentityStatusPart :  STATUS NAME */

				SIMCObjectIdentityType::StatusType a;
				if ((a=SIMCObjectIdentityType::StringToStatusType(yypvt[0].yy_name->name)) == SIMCObjectTypeV1::STATUS_INVALID)
				{
					theParser->SemanticError(theModule->GetInputFileName(),
								OBJ_IDENTITY_INVALID_STATUS,
								yypvt[0].yy_name->line, yypvt[0].yy_name->column,
								yypvt[0].yy_name->name);
					yyval.yy_object_identity_status = NULL;
					YYERROR;
				}
				else
					yyval.yy_object_identity_status = new SIMCObjectIdentityStatusInfo(a, yypvt[0].yy_name->line, yypvt[0].yy_name->column);
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr218: {	/* TextualConventionDefinition :  ID AllowedCCE TEXTCONV DisplayPart STATUS NAME DESCRIPTION LITSTRING ReferPart SYNTAX Type */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(TEXTUAL_CONVENTION_DISALLOWED);
					}
					break;
					default:
					{
						// See if the status clause is valid
						SIMCTextualConvention::SIMCTCStatusType status =
									 SIMCTextualConvention::StringToStatusType(yypvt[-5].yy_name->name);
						if(SIMCTextualConvention::TC_INVALID == status)
							theParser->SemanticError(theModule->GetInputFileName(),
								TC_INVALID_STATUS,
								yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
								yypvt[-5].yy_name->name);
						else
						{	 
							if (yypvt[0].yy_symbol_ref)
							{
								SIMCSymbol ** s = theModule->GetSymbol(yypvt[-10].yy_name->name);	
								if(s) // Symbol exists in symbol table
								{
									if(  typeid(**s) == typeid(SIMCUnknown) )
									{
										theModule->ReplaceSymbol( yypvt[-10].yy_name->name,
											new SIMCTextualConvention (
												(yypvt[-7].yy_name)? yypvt[-7].yy_name->name : NULL,
												status, yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
												yypvt[-3].yy_name->name, 
												(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL,
												yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
												yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
												yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
												(*s)->GetReferenceCount()) 
																);
										// delete (*s);
									}
									else
										theParser->SemanticError(theModule->GetInputFileName(),
														SYMBOL_REDEFINITION,
														yypvt[-10].yy_name->line, yypvt[-10].yy_name->column,
														yypvt[-10].yy_name->name);
								}
								else
									theModule->AddSymbol( new SIMCTextualConvention (
												(yypvt[-7].yy_name)? yypvt[-7].yy_name->name : NULL,
												status, yypvt[-5].yy_name->line, yypvt[-5].yy_name->column,
												yypvt[-3].yy_name->name, 
												(yypvt[-2].yy_name)? yypvt[-2].yy_name->name : NULL,
												yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
												yypvt[-10].yy_name->name, SIMCSymbol::LOCAL, theModule, 
												yypvt[-10].yy_name->line, yypvt[-10].yy_name->column) );

							}
						}
					}
					break;
				}
					
				delete yypvt[-10].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr219: {	/* DisplayPart :  DISPLAYHINT LITSTRING */

				delete yypvt[-1].yy_name;
				yyval.yy_name = yypvt[0].yy_name;
			
} break;

case YYr220: {	/* DisplayPart :  empty */

				yyval.yy_name = NULL;
			
} break;

case YYr221: {	/* ObjectGroupDefinition :  NAME OBJECTGROUP OBJECTS LBRACE VarTypeList RBRACE STATUS NAME DESCRIPTION LITSTRING ReferPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(OBJECT_GROUP_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );
					}
					break;
				}

				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr222: {	/* NotifyGroupDefinition :  NAME NOTIFYGROUP NOTIFICATIONS LBRACE VarTypeList RBRACE STATUS NAME DESCRIPTION LITSTRING ReferPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(NOTIFICATION_GROUP_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-12].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-12].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-12].yy_name->line, yypvt[-12].yy_name->column,
													yypvt[-12].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-12].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-12].yy_name->line, yypvt[-12].yy_name->column) );
					}
					break;
				}
				delete yypvt[-12].yy_name;
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
				if(yypvt[-2].yy_name) delete yypvt[-2].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr223: {	/* ModComplianceDefinition :  NAME MODCOMP STATUS NAME DESCRIPTION LITSTRING ReferPart MibPart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(MODULE_COMPLIANCE_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-9].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-9].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-9].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-9].yy_name->line, yypvt[-9].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-9].yy_name->line, yypvt[-9].yy_name->column,
													yypvt[-9].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-9].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-9].yy_name->line, yypvt[-9].yy_name->column) );
					}
				}
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr228: {	/* Mib :  MODULE ModuleIdentifierUnused MandatoryPart CompliancePart */

				delete yypvt[-3].yy_name;
			
} break;

case YYr229: {	/* Mib :  MODULE MandatoryPart CompliancePart */

				delete yypvt[-2].yy_name;
			
} break;

case YYr230: {	/* ModuleIdentifierUnused :  ID */

				if(yypvt[0].yy_name)
					delete (yypvt[0].yy_name);

			
} break;

case YYr231: {	/* ModuleIdentifierUnused :  ID ObjectID */

					if(yypvt[-1].yy_name)
						delete (yypvt[-1].yy_name);
					if(yypvt[0].yy_symbol_ref)
						delete yypvt[0].yy_symbol_ref;
				
} break;

case YYr232: {	/* MandatoryPart :  MANDATORY LBRACE VarTypeList RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;

case YYr238: {	/* Compliance :  GROUP NAME DESCRIPTION LITSTRING */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr239: {	/* Compliance :  OBJECT NAME Syntax WriteSyntax MinAccessPart DESCRIPTION LITSTRING */

				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr240: {	/* Syntax :  SYNTAX Type */

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr242: {	/* WriteSyntax :  WSYNTAX Type */

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr244: {	/* MinAccessPart :  MINACCESS NAME */

				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr246: {	/* AgentCapabilitiesDefinition :  NAME AGENTCAP PRELEASE LITSTRING STATUS NAME DESCRIPTION LITSTRING ReferPart ModulePart AllowedCCE ObjectID */

				switch(theParser->GetSnmpVersion())
				{
					case 1:
					{
						theParser->SyntaxError(AGENT_CAPABILITIES_DISALLOWED);
					}
					break;
					default:
					{
						// Add an OID value reference
						
						SIMCSymbol ** s = theModule->GetSymbol(yypvt[-11].yy_name->name);	
						if(s) // Symbol exists in symbol table
						{
							if(  typeid(**s) == typeid(SIMCUnknown) )
							{
								theModule->ReplaceSymbol( yypvt[-11].yy_name->name,
									new SIMCDefinedValueReference (
										theParser->objectIdentifierType,
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
										yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
										yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
										yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
										(*s)->GetReferenceCount()) );
								// delete (*s);
							}
							else
							{
								theParser->SemanticError(theModule->GetInputFileName(),
													SYMBOL_REDEFINITION,
													yypvt[-11].yy_name->line, yypvt[-11].yy_name->column,
													yypvt[-11].yy_name->name);
							}
						}
						else
							theModule->AddSymbol( new SIMCDefinedValueReference (
									theParser->objectIdentifierType,
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column, 
									yypvt[0].yy_symbol_ref->s, yypvt[0].yy_symbol_ref->line, yypvt[0].yy_symbol_ref->column,
									yypvt[-11].yy_name->name, SIMCSymbol::LOCAL, theModule, 
									yypvt[-11].yy_name->line, yypvt[-11].yy_name->column) );
					}
				}
				delete yypvt[-11].yy_name;
				delete yypvt[-10].yy_name;
				delete yypvt[-9].yy_name;
				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-6].yy_name;
				delete yypvt[-5].yy_name;
				delete yypvt[-4].yy_name;
				if(yypvt[-3].yy_name) delete yypvt[-3].yy_name;
				delete yypvt[0].yy_symbol_ref;
			
} break;

case YYr251: {	/* Module :  SUPPORTS ModuleReference INCLUDING LBRACE VarTypeList RBRACE VariationPart */

				delete yypvt[-6].yy_name;
				delete yypvt[-4].yy_name;
				delete yypvt[-3].yy_name;
			
} break;

case YYr252: {	/* ModuleReference :  ID LBRACE ObjectIDComponentList RBRACE */

			delete yypvt[-3].yy_name;
			delete yypvt[-2].yy_name;
			delete newOidComponentList;
			newOidComponentList = new SIMCOidComponentList;
		
} break;

case YYr253: {	/* ModuleReference :  ID */

			delete yypvt[0].yy_name;
		
} break;

case YYr258: {	/* Variation :  VARIATION NAME Syntax WriteSyntax AccessPart CreationPart DefValPart DESCRIPTION LITSTRING */

				delete yypvt[-8].yy_name;
				delete yypvt[-7].yy_name;
				delete yypvt[-2].yy_def_val;
				delete yypvt[-1].yy_name;
				delete yypvt[0].yy_name;
			
} break;

case YYr259: {	/* CreationPart :  CREATION LBRACE Creation RBRACE */

				delete yypvt[-3].yy_name;
				delete yypvt[-2].yy_name;
			
} break;
	case YYrACCEPT:
		YYACCEPT;
	case YYrERROR:
		goto yyError;
	}
yyNext:
	/*
	 *	Look up next state in goto table.
	 */

	yyp = &yygo[yypgo[yyi]];
	yyq = yyp++;
	yyi = *yyps;
	while (yyi < *yyp++)		/* busy little loop */
		;
	yystate = ~(yyi == *--yyp? yyq[yyq-yyp]: *yyq);
#if YYDEBUG
	if (yydebug)
		YY_TRACE(yyShowGoto)
#endif
	goto yyStack;

yyerrlabel:	;		/* come here from YYERROR	*/
	yyerrflag = 1;
	if (yyi == YYrERROR) {
		yyps--, yypv--;
#if YYDEBUG
		if (yydebug) yytp--;
#endif
	}
	
yyError:
	switch (yyerrflag) {

	case 0:		/* new error */
		yynerrs++;
		yyi = (short)yychar;
		scan->yyerror("Syntax error");
		if (yyi != yychar) {
			/* user has changed the current token */
			/* try again */
			yyerrflag++;	/* avoid loops */
			goto yyEncore;
		}

	case 1:		/* partially recovered */
	case 2:
		yyerrflag = 3;	/* need 3 valid shifts to recover */
			
		/*
		 *	Pop states, looking for a
		 *	shift on `error'.
		 */

		for ( ; yyps > stateStack; yyps--, yypv--
#if YYDEBUG
					, yytp--
#endif
		) {
#ifdef YACC_WINDOWS
			if (*yyps >= Sizeof_yypact) 	/* simple state */
#else /* YACC_WINDOWS */
			if (*yyps >= sizeof yypact/sizeof yypact[0])
#endif /* YACC_WINDOWS */
				continue;
			yyp = &yyact[yypact[*yyps]];
			yyq = yyp;
			do
				;
			while (YYERRCODE < *yyp++);
			if (YYERRCODE == yyp[-1]) {
				yystate = ~yyq[yyq-yyp];
				goto yyStack;
			}
				
			/* no shift in this state */
#if YYDEBUG
			if (yydebug && yyps > stateStack+1)
				YY_TRACE(yyShowErrRecovery)
#endif
			/* pop stacks; try again */
		}
		/* no shift on error - abort */
		break;

	case 3:
		/*
		 *	Erroneous token after
		 *	an error - discard it.
		 */

		if (yychar == 0)  /* but not EOF */
			break;
#if YYDEBUG
		if (yydebug)
			YY_TRACE(yyShowErrDiscard)
#endif
		yyclearin();
		goto yyEncore;	/* try again in same state */
	}
	YYABORT;

}
#if YYDEBUG
/*
 * Return type of token
 */
int
yy_parse::yyGetType(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->type;
	return 0;
}

	
// Print a token legibly.
char *
yy_parse::yyptok(int tok)
{
	yyNamedType * tp;
	for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
		if (tp->token == tok)
			return tp->name;
	return "";
}
/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE

char *
yy_parse::yygetState(int num)
{
	int	size;
	char	*cp;
	static FILE *yyStatesFile = (FILE *) 0;
	static char yyReadBuf[YYMAX_READ+1];

	if (yyStatesFile == (FILE *) 0
	 && (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0)
		return "yyExpandName: cannot open states file";

	if (num < yynstate - 1)
		size = (int)(States[num+1] - States[num]);
	else {
		/* length of last item is length of file - ptr(last-1) */
		if (fseek(yyStatesFile, 0L, 2) < 0)
			goto cannot_seek;
		size = (int) (ftell(yyStatesFile) - States[num]);
	}
	if (size < 0 || size > YYMAX_READ)
		return "yyExpandName: bad read size";
	if (fseek(yyStatesFile, States[num], 0) < 0) {
	cannot_seek:
		return "yyExpandName: cannot seek in states file";
	}

	(void) fread(yyReadBuf, 1, size, yyStatesFile);
	yyReadBuf[size] = '\0';
	return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return 1; otherwise, 0.
 */
int
yy_parse::yyExpandName(int num, int isrule, char * buf, int len)
{
	int	i, n, cnt, type;
	char	* endp, * cp, * s;

	if (isrule)
		s = yyRules[num].name;
	else
#ifdef YYTRACE
		s = yygetState(num);
#else
		s = "*no states*";
#endif

	for (endp = buf + len - 8; *s; s++) {
		if (buf >= endp) {		/* too large: return 0 */
		full:	(void) strcpy(buf, " ...\n");
			return 0;
		} else if (*s == '%') {		/* nonterminal */
			type = 0;
			cnt = yynvar;
			goto getN;
		} else if (*s == '&') {		/* terminal */
			type = 1;
			cnt = yyntoken;
		getN:
			if (cnt < 100)
				i = 2;
			else if (cnt < 1000)
				i = 3;
			else
				i = 4;
			for (n = 0; i-- > 0; )
				n = (n * 10) + *++s - '0';
			if (type == 0) {
				if (n >= yynvar)
					goto too_big;
				cp = yysvar[n];
			} else if (n >= yyntoken) {
			    too_big:
				cp = "<range err>";
			} else
				cp = yyTokenTypes[n].name;

			if ((i = strlen(cp)) + buf > endp)
				goto full;
			(void) strcpy(buf, cp);
			buf += i;
		} else
			*buf++ = *s;
	}
	*buf = '\0';
	return 1;
}
#ifndef YYTRACE
/*
 * Show current state of yyparse
 */
void
yy_parse::yyShowState()
{
	(void) printf("state %d (%d), char %s (%d)\n%d stateStack entries\n",
		yysmap[yystate],yystate,yyptok(yychar),yychar,
		yypv - valueStack);
}
// show results of reduction: yyi is rule number
void
yy_parse::yyShowReduce()
{
	(void) printf("Reduce by rule %d (pop#=%d)\n", yyrmap[rule], npop);
}
// show read token
void
yy_parse::yyShowRead()
{
	(void) printf("read %s (%d)\n", yyptok(yychar), yychar);
}
// show Goto
void
yy_parse::yyShowGoto()
{
	(void) printf("goto %d (%d)\n", yysmap[yystate], yystate);
}
// show Shift
void
yy_parse::yyShowShift()
{
	(void) printf("shift %d (%d)\n", yysmap[yystate], yystate);
}
// show error recovery
void
yy_parse::yyShowErrRecovery()
{
	(void) printf("Error recovery pops state %d (%d), uncovers %d (%d)\n",
		yysmap[*(yyps-1)], *(yyps-1), yysmap[yystate], yystate);
}
// show token discards in error processing
void
yy_parse::yyShowErrDiscard()
{
	(void) printf("Error recovery discards %s (%d), ",
		yyptok(yychar), yychar);
}
#endif	/* ! YYTRACE */
#endif	/* YYDEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\simclib\type.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <limits.h>
#include <iostream.h>
#include <strstrea.h>
#include "precomp.h"
#include <snmptempl.h>

#include "newString.hpp"
#include "bool.hpp"
#include "symbol.hpp"
#include "type.hpp"
#include "value.hpp"
#include "oidValue.hpp"
#include "typeRef.hpp"
#include "valueRef.hpp"
#include "group.hpp"
#include "notificationGroup.hpp"
#include "trapType.hpp"
#include "notificationType.hpp"
#include "module.hpp"

SIMCSizeType::~SIMCSizeType()
{
	if(_listOfSizes)
	{
		SIMCRangeOrSizeItem * item;
		while(_listOfSizes->IsEmpty())
		{
			item = _listOfSizes->RemoveHead();
			delete item;
		}
	}
}

void SIMCSizeType::WriteType(ostream& outStream) const
{
	outStream << "SIMCSizeType of type " ; 
		(*GetType())->WriteBrief(outStream);
	outStream << endl;
}

SIMCRangeType::~SIMCRangeType()
{
	if(_listOfRanges)
	{
		SIMCRangeOrSizeItem * item;
		while(!_listOfRanges->IsEmpty())
		{
			item = _listOfRanges->RemoveHead();
			delete item;
		}
		delete _listOfRanges;	
	}
}

void SIMCRangeType::WriteType(ostream& outStream) const
{
	outStream << "SIMCRangeType of type " ; 
	(*GetType())->WriteBrief(outStream);
	outStream << endl;
}

ostream& operator << (ostream& outStream, const SIMCRangeOrSizeItem& obj)
{
	if(obj._lowerBound == obj._upperBound)
	{
		if(obj._isUnsignedU)
			outStream << (unsigned long)obj._upperBound;
		else
			outStream << obj._upperBound;
	}
	else
	{
		if(obj._isUnsignedL)
			outStream << (unsigned long)obj._lowerBound;
		else
			outStream << obj._lowerBound;
		outStream << "..";
		if(obj._isUnsignedU)
			outStream << (unsigned long)obj._upperBound;
		else
			outStream << obj._upperBound;
	}
	return outStream;
}
char *SIMCSizeType::ConvertSizeListToString() const
{
	ostrstream outStream ;
	long index = _listOfSizes->GetCount();
	POSITION p = _listOfSizes->GetHeadPosition();
	SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = _listOfSizes->GetNext(p);
		outStream << *item;
		if ( index != 1 )
			outStream << ",";
		index -- ;
	}

	outStream << ends ;
	return outStream.str();
}

long SIMCSizeType::GetFixedSize() const
{
	 SIMCRangeOrSizeItem *item = _listOfSizes->GetHead();
	 return item->_lowerBound;
}

char *SIMCRangeType::ConvertRangeListToString() const
{
	ostrstream outStream ;
	long index = _listOfRanges->GetCount();
	POSITION p = _listOfRanges->GetHeadPosition();
	SIMCRangeOrSizeItem * item;
	while(p)
	{
		item = _listOfRanges->GetNext(p);
		outStream << *item;
		if ( index != 1 )
			outStream << ",";
		index -- ;
	}

	outStream << ends ;
	return outStream.str();
}

BOOL SIMCSizeType::IsFixedSize() const
{
	if(_listOfSizes->GetCount() != 1)
		return FALSE;
	SIMCRangeOrSizeItem * item = _listOfSizes->GetHead();
	if(item->_lowerBound != item->_upperBound)
		return FALSE;
	return TRUE;
}


BOOL SIMCSizeType::IsNotZeroSizeObject() const
{
	SIMCRangeOrSizeItem * item;
	POSITION p = _listOfSizes->GetHeadPosition();
	while(p)
	{
		item = _listOfSizes->GetNext(p);
		if(item->_lowerBound == 0 || item->_upperBound == 0)
			return FALSE;
	}
	return TRUE;
}

long SIMCSizeType::GetMaximumSize() const
{
	SIMCRangeOrSizeItem * item;
	POSITION p = _listOfSizes->GetHeadPosition();
	long maxSize = 0;
	while(p)
	{
		item = _listOfSizes->GetNext(p);
		if(item->_upperBound > maxSize)
			maxSize = item->_upperBound;
	}
	return maxSize;
}

char * SIMCEnumOrBitsType::ConvertToString() const
{
	SIMCNamedNumberItem *item;
	POSITION p = _listOfItems->GetHeadPosition();
	long index = _listOfItems->GetCount();
	ostrstream outStream ;
	int value;
	while(p)
	{
		item = _listOfItems->GetNext(p);
	
		outStream << item->_name << "(";
		switch(SIMCModule::IsIntegerValue(item->_value, value))
		{
			case RESOLVE_CORRECT:
				outStream << value << ")";
				break;
			default:
				return NULL;
		}	

		if(index != 1)
			outStream << ",";
		index --;
	}
	outStream << ends ;
	return outStream.str();
			
}


SIMCEnumOrBitsType::SIMCEnumOrBitsType (SIMCSymbol **type, long typeLine, long typeColumn,
							SIMCNamedNumberList * listOfItems, EnumOrBitsType enumOrBitsType)
	: _listOfItems(listOfItems),
		_enumOrBitsType(enumOrBitsType),
		SIMCSubType(type, typeLine, typeColumn)
{
	if(listOfItems)
	{
		POSITION p = listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		while(p)
		{
			e = listOfItems->GetNext(p);
			(*e->_value)->IncrementReferenceCount();
		}
	}	
}

SIMCEnumOrBitsType::~SIMCEnumOrBitsType ()
{
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		while(!_listOfItems->IsEmpty())
		{
			e = _listOfItems->RemoveHead();
			if( UseReferenceCount() && e->_value)
				(*e->_value)->DecrementReferenceCount();
			delete e;
		}
		delete _listOfItems;
	}	
}

SIMCSymbol **SIMCEnumOrBitsType::GetValue(const char * const name)	const
{
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		while(p)
		{
			e = _listOfItems->GetNext(p);
			if(strcmp(e->_name, name) == 0)
				return e->_value;
		}
	}
	return NULL;
}

SIMCResolutionStatus SIMCEnumOrBitsType::GetIdentifier(int x, const char * &retVal) const
{
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		int val;
		while(p)
		{
			e = _listOfItems->GetNext(p);
			switch (SIMCModule::IsIntegerValue(e->_value, val))
			{
				case RESOLVE_IMPORT:
					return RESOLVE_IMPORT;
				case RESOLVE_UNDEFINED:
				case RESOLVE_UNSET:
					return RESOLVE_UNDEFINED;
			}
			if(val == x)
			{
				retVal = e->_name;
				return RESOLVE_CORRECT;
			}
		}
	}
	return RESOLVE_UNDEFINED;
}

long SIMCEnumOrBitsType::GetLengthOfLongestName() const
{
	long maxLength = 0, temp;
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *e;
		while(p)
		{
			e = _listOfItems->GetNext(p);
			if( (temp = strlen(e->_name)) > maxLength )
				maxLength = temp;
		}
	}
	return maxLength;
}

// Check whether the enum type in the argument is a superset of the
// "this" enum type
BOOL SIMCEnumOrBitsType::CheckClosure(const SIMCEnumOrBitsType *universalType) const
{
	if(_listOfItems)
	{
		POSITION p = _listOfItems->GetHeadPosition();
		SIMCNamedNumberItem *nextItem;
		SIMCSymbol **rhsSymbol;
		int rhsValue, lhsValue;

		while(p)
		{
			nextItem = _listOfItems->GetNext(p);
			if(!(rhsSymbol = universalType->GetValue(nextItem->_name)))
				return FALSE;
			if(SIMCModule::IsIntegerValue(rhsSymbol, rhsValue) != RESOLVE_CORRECT)
				return FALSE;
			if(SIMCModule::IsIntegerValue(nextItem->_value, lhsValue) != RESOLVE_CORRECT)
				return FALSE;

			if( lhsValue != rhsValue)
				return FALSE;
		}
	}
	return TRUE;
}


SIMCSequenceType::SIMCSequenceType (SIMCSequenceList * listOfSequences)
	: _listOfSequences(listOfSequences)
{
	if(listOfSequences)
	{
		POSITION p = listOfSequences->GetHeadPosition();
		SIMCSequenceItem *e;
		while(p)
		{
			e = listOfSequences->GetNext(p);
			(*(e->_type))->IncrementReferenceCount();
			(*(e->_value))->IncrementReferenceCount();
		}
	}	
}

SIMCSequenceType::~SIMCSequenceType ()
{
	if(_listOfSequences)
	{
		SIMCSequenceItem *e;
		while(!_listOfSequences->IsEmpty())
		{
			e = _listOfSequences->RemoveHead();
			if(UseReferenceCount() &&  e->_type)
				(*(e->_type))->DecrementReferenceCount();
			if(UseReferenceCount() && e->_value)
				(*(e->_value))->DecrementReferenceCount();
			delete e;
		}
		delete _listOfSequences;
	}	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsy\resource.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by smierrsy.rc
//
#define SYNTAX_CLAUSE                   1
#define ACCESS_CLAUSE                   2
#define STATUS_CLAUSE                   3
#define DESCRIPTION_CLAUSE              4
#define REFERENCE_CLAUSE                5
#define INDEX_CLAUSE                    6
#define DEFVAL_CLAUSE                   7
#define SKIPPING_OBJECT_TYPE            8
#define ENTERPRISE_CLAUSE               9
#define VARIABLES_CLAUSE                10
#define SKIPPING_TRAP_TYPE              11
#define SEQUENCE_DEFINITION             12
#define OBJECT_IDENTIFIER_VALUE         13
#define LIST_IN_IMPORTS                 14
#define MISSING_MODULE_NAME             15
#define IMPORTS_SECTION                 16
#define INTEGER_ENUMERATION             17
#define SUB_TYPE_SPECIFICATION          18
#define SIZE_SPECIFICATION              19
#define V2_OBJECT_TYPE_DISALLOWED       20
#define NOTIFICATION_TYPE_DISALLOWED    22
#define MODULE_IDENTITY_DISALLOWED      23
#define OBJECT_IDENTITY_DISALLOWED      24
#define TEXTUAL_CONVENTION_DISALLOWED   25
#define OBJECT_GROUP_DISALLOWED         26
#define NOTIFICATION_GROUP_DISALLOWED   27
#define MODULE_COMPLIANCE_DISALLOWED    28
#define AGENT_CAPABILITIES_DISALLOWED   29
#define INSTEAD_OF_CCE                  30
#define SYNTAX_ERROR_MAX                31
#define ERROR_OBJECT_TYPE               31
#define SYNTAX_ERROR_MAX1               32
#define MAX_SYNTAX_ERROR                32
#define V1_OBJECT_TYPE_DISALLOWED       32
#define V1_TRAP_TYPE_DISALLOWED         33
#define MODULE_IDENTITY_ONLY_AFTER_IMPORTS 34
#define UNRECOGNIZED_CHARACTER          35
#define TOO_BIG_NUM                     36
#define UNTERMINATED_STRING             37
#define OBJECTS_CLAUSE                  38
#define NAME_INSTEAD_OF_ID              39

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsy\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smimsgif\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smierrsy\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
#include <windows.h>

BOOL   WINAPI   DllMain (HANDLE hInst, 
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smimsgif\main.cpp ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//

#include <windows.h>

BOOL   WINAPI   DllMain (HANDLE hInst, 
                        ULONG ul_reason_for_call,
                        LPVOID lpReserved)
{
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\compilers\smi2smir\lib\smimsgif\resource.h ===
//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by D:\opal\pandoraNg\snmpProvider\compilers\smi2smir\lib\smimsgif\smimsgif.rc
//
#define COMPILED_FILE                   1
#define SYNTAX_CHECK_FAILED             2
#define SEMANTIC_CHECK_FAILED           3
#define SMIR_LOAD_FAILED                4
#define SMIR_LOAD_SUCCEEDED             5
#define SYNTAX_CHECK_SUCCEEDED          6
#define SEMANTIC_CHECK_SUCCEEDED        7
#define SYMBOL_RESOLUTION_FAILED        8
#define SMIR_CONNECT_FAILED             9
#define LISTING_MODULES                 10
#define LISTING_FAILED                  11
#define DELETE_SUCCEEDED                12
#define DELETE_FAILED                   13
#define PURGE_SUCCEEDED                 14
#define PURGE_FAILED                    15
#define DELETE_MODULE_NOT_FOUND         16
#define SMI2SMIR_INFO                   17
#define FILE_NOT_FOUND                  18
#define MODULE_LISTING                  19
#define MOF_GENERATION_SUCCEEDED        20
#define MOF_GENERATION_FAILED           21
#define MODULE_NAME_SUCCEEDED           22
#define MODULE_INFO_FAILED              23
#define NUMBER_OF_ENTRIES               24
#define DUPLICATE_MODULES               25
#define DIRECTORY_ADDITION_SUCCEEDED    26
#define DIRECTORY_ADDITION_FAILED       27
#define DIRECTORY_DELETION_SUCCEEDED    28
#define DIRECTORY_DELETION_FAILED       29
#define INVALID_MIB_FILE                30
#define PURGE_CONFIRMATION              31

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\maindll.cpp ===
//***************************************************************************

//

//  MAINDLL.CPP

// 

//  Purpose: Contains DLL entry points.  Also has code that controls

//           when the DLL can be unloaded by tracking the number of

//           objects and locks.  

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <process.h>
#include <objbase.h>
#include <olectl.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include "classfac.h"
#include "trrtcomm.h"
#include "trrtprov.h"
#include "guids.h"

//OK we need this one
HINSTANCE   g_hInst=NULL;

CRITICAL_SECTION s_CriticalSection ;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	g_hInst=hInstance;

	BOOL status = TRUE ;

    if ( DLL_PROCESS_DETACH == ulReason )
	{
		DeleteCriticalSection ( & s_CriticalSection ) ;

		status = TRUE ;
    }
    else if ( DLL_PROCESS_ATTACH == ulReason )
	{
		InitializeCriticalSection ( & s_CriticalSection ) ;
		DisableThreadLibraryCalls(hInstance);			// 158024 
		status = TRUE ;
    }
    else if ( DLL_THREAD_DETACH == ulReason )
	{
		status = TRUE ;
    }
    else if ( DLL_THREAD_ATTACH == ulReason )
	{
		status = TRUE ;
    }

    return TRUE ;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	HRESULT status = S_OK ; 

	if ( rclsid == CLSID_CFrameworkProviderClassFactory ) 
	{
		CFrameworkProviderClassFactory *lpunk = new CFrameworkProviderClassFactory ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppv ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;				
			}
			else
			{
			}			
		}
	}
	else
	{
		status = CLASS_E_CLASSNOTAVAILABLE ;
	}

	return status ;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{

/* 
 * Place code in critical section
 */
	EnterCriticalSection ( & s_CriticalSection ) ;

	BOOL unload = ( 
					CFrameworkProviderClassFactory :: s_LocksInProgress || 
					CFrameworkProviderClassFactory :: s_ObjectsInProgress
				) ;
	unload = ! unload ;

	if ( unload )
	{
		if ( CImpFrameworkProv :: s_DefaultThreadObject )
		{
			delete CImpFrameworkProv  :: s_DefaultThreadObject ;
			CImpFrameworkProv :: s_DefaultThreadObject = NULL ;

			SnmpThreadObject :: Closedown () ;
			SnmpDebugLog :: Closedown () ;
		}
	}

	LeaveCriticalSection ( & s_CriticalSection ) ;
	return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
}


//Strings used during self registeration

#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define PROGID_STR				L"ProgID"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"
#define CLSID_STR				L"Software\\Classes\\CLSID\\"

#define PROVIDER_NAME_STR		L"Microsoft WBEM Provider"

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256];

	wcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI RegisterServer( GUID a_ProviderClassId , wchar_t *a_ProviderName )
{
	wchar_t szModule[512];
	GetModuleFileName(g_hInst,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI UnregisterServer( GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

	RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDClassID);

    return S_OK;
}

STDAPI DllRegisterServer()
{
	HRESULT t_Result ;

	t_Result = RegisterServer ( CLSID_CFrameworkProviderClassFactory , PROVIDER_NAME_STR ) ;

	return t_Result ;
}

STDAPI DllUnregisterServer(void)
{
	HRESULT t_Result ;

	t_Result = UnregisterServer ( CLSID_CFrameworkProviderClassFactory ) ;


	return t_Result ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\classfac.cpp ===
//***************************************************************************

//

//  CLASSFAC.CPP

//

//  Module: OLE MS SNMP PROPERTY PROVIDER

//

//  Purpose: Contains the class factory.  This creates objects when

//           connections are requested.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>

#include <objbase.h>

#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include "classfac.h"
#include "trrtcomm.h"
#include "trrtprov.h"

#include "guids.h"

LONG CFrameworkProviderClassFactory :: s_ObjectsInProgress = 0 ;
LONG CFrameworkProviderClassFactory :: s_LocksInProgress = 0 ;

//***************************************************************************
//
// CFrameworkProviderClassFactory::CFrameworkProviderClassFactory
// CFrameworkProviderClassFactory::~CFrameworkProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CFrameworkProviderClassFactory :: CFrameworkProviderClassFactory ()
{
	m_ReferenceCount = 0 ;
}

CFrameworkProviderClassFactory::~CFrameworkProviderClassFactory ()
{
}

//***************************************************************************
//
// CFrameworkProviderClassFactory::QueryInterface
// CFrameworkProviderClassFactory::AddRef
// CFrameworkProviderClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CFrameworkProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID_IClassFactory )
	{
		*iplpv = ( LPVOID ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}


STDMETHODIMP_( ULONG ) CFrameworkProviderClassFactory :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CFrameworkProviderClassFactory :: Release ()
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

//***************************************************************************
//
// CFrameworkProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CFrameworkProviderClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	HRESULT status = S_OK ;

	if ( pUnkOuter )
	{
		status = CLASS_E_NOAGGREGATION ;
	}
	else
	{
		IWbemServices *lpunk = ( IWbemServices * ) new CImpFrameworkProv ;
		if ( lpunk == NULL )
		{
			status = E_OUTOFMEMORY ;
		}
		else
		{
			status = lpunk->QueryInterface ( riid , ppvObject ) ;
			if ( FAILED ( status ) )
			{
				delete lpunk ;
			}
			else
			{
			}
		}			
	}

	return status ;
}

//***************************************************************************
//
// CFrameworkProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CFrameworkProviderClassFactory :: LockServer ( BOOL fLock )
{
/* 
 * Place code in critical section
 */

	if ( fLock )
	{
		InterlockedIncrement ( & s_LocksInProgress ) ;
	}
	else
	{
		InterlockedDecrement ( & s_LocksInProgress ) ;
	}

	return S_OK	;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrt.cpp ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "classfac.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"
#include "guids.h"

#if _MSC_VER >= 1100
template <> UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key )
#else
UINT HashKey ( wchar_t *key )
#endif
{
	UCHAR *value = ( UCHAR * ) key ;
	ULONG length = wcslen ( key ) * sizeof ( wchar_t ) ;

    UINT hash;
    if (length > 1)
    {
        USHORT even = 0;
        USHORT odd = 0;

        for (ULONG i = length >> 1; i--;)
        {
            even += towlower (*value++) ;
            odd += towlower (*value++) ;
        }
        if (length & 1)
        {
            even += tolower (*value);
        }
        hash = odd>>8;
        hash |= (odd & 0xff) << 8;
        hash ^= even;
    }
    else
    {
        hash = *value;
    }

	return hash ;
}

#if _MSC_VER >= 1100
typedef wchar_t * WbemHack_wchar_t ;
template<> BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const WbemHack_wchar_t *pElement1, const WbemHack_wchar_t *pElement2 )
#else
BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 )
#endif
{
	return _wcsicmp ( *pElement1 , *pElement2 ) == 0 ;
}

CBString::CBString(int nSize)
{
    m_pString = SysAllocStringLen(NULL, nSize);
}

CBString::CBString(WCHAR* pwszString)
{
    m_pString = SysAllocString(pwszString);
}

CBString::~CBString()
{
    if(m_pString) 
	{
        SysFreeString(m_pString);
        m_pString = NULL;
    }
}


DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString )
{
	size_t textLength = mbstowcs ( NULL , dbcsString , 0  ) ;
	wchar_t *unicodeString = new wchar_t [ textLength + 1 ] ;
	textLength = mbstowcs ( unicodeString , dbcsString , textLength + 1 ) ;
	if ( textLength == -1 )
	{
		delete [] unicodeString ;
		unicodeString = NULL ;
	}

	return unicodeString ;
}

DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString )
{
	size_t textLength = wcstombs ( NULL , unicodeString , 0 ) ;
	char *dbcsString = new char [ textLength + 1 ] ;
	textLength = wcstombs ( dbcsString , unicodeString , textLength + 1 ) ;
	if ( textLength == -1 )
	{
		delete [] dbcsString ;
		dbcsString = NULL ;
	}

	return dbcsString ;
}

DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) 
{
	if ( string )
	{
		int textLength = wcstombs ( NULL , string , 0 ) ;

		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;
		wcscpy ( textBuffer , string ) ;

		return textBuffer ;
	}
	else
	{
		return NULL ;
	}
}

DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix )
{
	int prefixTextLength = 0 ;
	if ( prefix )
	{
		prefixTextLength = wcstombs ( NULL , prefix , 0 ) ;
	}

	int suffixTextLength = 0 ;
	if ( suffix )
	{
		suffixTextLength = wcstombs ( NULL , suffix , 0 ) ;
	}

	if ( prefix || suffix )
	{
		int textLength = prefixTextLength + suffixTextLength ;
		wchar_t *textBuffer = new wchar_t [ textLength + 1 ] ;

		if ( prefix )
		{
			wcscpy ( textBuffer , prefix ) ;
		}

		if ( suffix )
		{
			wcscpy ( & textBuffer [ prefixTextLength ] , suffix ) ;
		}

		return textBuffer ;
	}	
	else
		return NULL ;
}

ProviderLexicon :: ProviderLexicon () : position ( 0 ) , tokenStream ( NULL ) , token ( INVALID_ID )
{
	value.token = NULL ;
}

ProviderLexicon :: ~ProviderLexicon ()
{
	switch ( token ) 
	{
		case TOKEN_ID:
		{
			delete [] value.token ;
		}
		break ;
	
		default:
		{
		} ;
	}
}

void ProviderLexicon :: SetToken ( ProviderLexicon :: LexiconToken a_Token )
{
	token = a_Token ;
}

ProviderLexicon :: LexiconToken ProviderLexicon :: GetToken ()
{
	return token ;
}

ProviderLexiconValue *ProviderLexicon :: GetValue ()
{
	return &value ;
}

ProviderAnalyser :: ProviderAnalyser ( const wchar_t *tokenStream ) : status ( TRUE ) , position ( 0 ) , stream ( NULL ) 
{
	if ( tokenStream )
	{
		stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
		wcscpy ( stream , tokenStream ) ;
	}
}

ProviderAnalyser :: ~ProviderAnalyser () 
{
	delete [] stream ;
}

void ProviderAnalyser :: Set ( const wchar_t *tokenStream ) 
{
	status = 0 ;
	position = NULL ;

	delete [] stream ;
	stream = new wchar_t [ wcslen ( tokenStream ) + 1 ] ;
	wcscpy ( stream , tokenStream ) ;
}

void ProviderAnalyser :: PutBack ( const ProviderLexicon *token ) 
{
	position = token->position ;
}

ProviderAnalyser :: operator void * () 
{
	return status ? this : NULL ;
}

ProviderLexicon *ProviderAnalyser :: Get ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace ) 
{
	ProviderLexicon *lexicon = NULL ;

	if ( stream )
	{
		lexicon = GetToken ( unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) ;
	}
	else
	{
		lexicon = CreateLexicon () ;
		lexicon->position = position ;
		lexicon->token = ProviderLexicon :: EOF_ID ;
	}

	return lexicon ;
}

#define DEC_INTEGER_START 1000
#define HEX_INTEGER_START 2000
#define OCT_INTEGER_START 3000
#define TOKEN_START 5000
#define WHITESPACE_START 6000
#define ACCEPT_STATE ANALYSER_ACCEPT_STATE
#define REJECT_STATE ANALYSER_REJECT_STATE 

ProviderLexicon *ProviderAnalyser :: GetToken ( BOOL unSignedIntegersOnly , BOOL leadingIntegerZeros , BOOL eatSpace )  
{
	ProviderLexicon *lexicon = CreateLexicon () ;
	lexicon->position = position ;

	Initialise () ;

	ULONG state = 0 ;

/* 
 * Integer Definitions
 */

	BOOL negative = FALSE ;
	BOOL positive = FALSE ;

	ULONG positiveMagicMult = ( LONG ) ( ( ( ULONG ) -1 ) / 10L ) ; 
	ULONG positiveMagicPosDigit = 5 ;
	ULONG positiveDatum = 0 ;	

	LONG negativeMagicMult = ( LONG ) ( ( ( ULONG ) ( 1L << 31L ) ) / 10L ) ; 
	ULONG negativeMagicNegDigit = 8 ;
	ULONG negativeMagicPosDigit = 7 ;
	LONG negativeDatum = 0 ;	

/*
 * Token Definitions
 */

	ULONG token_start = 0 ;

	while ( state != REJECT_STATE && state != ACCEPT_STATE )
	{
		wchar_t token = stream [ position ] ;
		if ( Analyse ( lexicon , state , token , stream , position , unSignedIntegersOnly , leadingIntegerZeros , eatSpace ) )
		{
		}
		else
		{
			switch ( state )
			{
				case 0:
				{
					if ( IsAlpha ( token ) )
					{
						state = TOKEN_START ;
						token_start = position ;
					}
					else if ( ProviderAnalyser :: IsLeadingDecimal ( token ) )
					{
						state = DEC_INTEGER_START + 1  ;
						negativeDatum = ( token - 48 ) ;
					}
					else if ( token == L'+' )
					{
						if ( unSignedIntegersOnly ) 
						{
							state = ACCEPT_STATE ;
							lexicon->token = ProviderLexicon :: PLUS_ID ;
						}
						else
						{
							state = DEC_INTEGER_START ;
						}
					}
					else if ( token == L'-' ) 
					{
						if ( unSignedIntegersOnly )
						{
							state = ACCEPT_STATE ;
							lexicon->token = ProviderLexicon :: MINUS_ID ;
						}
						else
						{
							negative = TRUE ;
							state = DEC_INTEGER_START ;
						}
					}
					else if ( token == L'0' )
					{
						if ( ! leadingIntegerZeros ) 
						{
							state = 1 ;
						}
						else
						{
							negativeDatum = 0 ;
							state = DEC_INTEGER_START + 1 ;
						}
					}
					else if ( ProviderAnalyser :: IsWhitespace ( token ) ) 
					{
						if ( eatSpace )
						{
							state = 0 ;
						}
						else
						{
							lexicon->token = ProviderLexicon :: WHITESPACE_ID ;
							state = WHITESPACE_START ;
						}
					}
					else if ( token == L'(' )
					{
						lexicon->token = ProviderLexicon :: OPEN_PAREN_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L')' )
					{
						lexicon->token = ProviderLexicon :: CLOSE_PAREN_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L',' )
					{
						lexicon->token = ProviderLexicon :: COMMA_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L':' )
					{
						lexicon->token = ProviderLexicon :: COLON_ID ;
						state = ACCEPT_STATE ;
					}
					else if ( token == L'.' )
					{
						state = 2;
					}
					else if ( IsEof ( token ) )
					{
						lexicon->token = ProviderLexicon :: EOF_ID ;
						state = ACCEPT_STATE ;
					}
					else state = REJECT_STATE ;
				}
				break ;

				case 1:
				{
					if ( token == L'x' || token == L'X' )
					{
						state = HEX_INTEGER_START ;				
					}
					else if ( ProviderAnalyser :: IsOctal ( token ) )
					{
						state = OCT_INTEGER_START ;
						positiveDatum = ( token - 48 ) ;
					}
					else
					{
						if ( unSignedIntegersOnly )
						{
							lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
							lexicon->value.unsignedInteger = 0 ;
						}
						else
						{
							lexicon->token = ProviderLexicon :: SIGNED_INTEGER_ID ;
							lexicon->value.signedInteger = 0 ;
						}

						state = ACCEPT_STATE ;
						position -- ;
					}
				}
				break ;

				case 2:
				{
					if ( token == L'.' )
					{
						lexicon->token = ProviderLexicon :: DOTDOT_ID ;
						state = ACCEPT_STATE ;
					}
					else
					{
						lexicon->token = ProviderLexicon :: DOT_ID ;
						position -- ;
						state = ACCEPT_STATE  ;
					}
				}
				break ;

				case TOKEN_START:
				{
					if ( IsAlphaNumeric ( token ) ) 
					{
						state = TOKEN_START ;
					}
					else 
					{
						state = ACCEPT_STATE ;
						lexicon->token = ProviderLexicon :: TOKEN_ID ;
						lexicon->value.token = new wchar_t [ position - token_start + 1 ] ;
						wcsncpy ( 

							lexicon->value.token , 
							& stream [ token_start ] , 
							position - token_start 
						) ;

						lexicon->value.token [ position - token_start ] = 0 ;

						position -- ;
					}
				}
				break ;

				case WHITESPACE_START:
				{
					if ( ProviderAnalyser :: IsWhitespace ( token ) ) 
					{
						state = WHITESPACE_START ;
					}
					else
					{
						state = ACCEPT_STATE ;
						position -- ;
					}
				}
				break;

				case HEX_INTEGER_START:
				{
					if ( ProviderAnalyser :: IsHex ( token ) )
					{
						positiveDatum = ProviderAnalyser :: HexWCharToDecInteger ( token ) ;
						state = HEX_INTEGER_START + 1 ;
					}
					else
					{
						state = REJECT_STATE ;
					}
				}
				break ;

				case HEX_INTEGER_START+1:
				{
					if ( ProviderAnalyser :: IsHex ( token ) )
					{
						state = HEX_INTEGER_START + 1 ;

						if ( positiveDatum > positiveMagicMult )
						{
							state = REJECT_STATE ;
						}
						else if ( positiveDatum == positiveMagicMult ) 
						{
							if ( ProviderAnalyser :: HexWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
							{
								state = REJECT_STATE ;
							}
						}

						positiveDatum = ( positiveDatum << 4 ) + ProviderAnalyser :: HexWCharToDecInteger ( token ) ;
					}
					else
					{
						lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
						lexicon->value.unsignedInteger = positiveDatum ;
						state = ACCEPT_STATE ;

						position -- ;
					}
				}
				break ;

				case OCT_INTEGER_START:
				{
					if ( ProviderAnalyser :: IsOctal ( token ) )
					{
						state = OCT_INTEGER_START ;

						if ( positiveDatum > positiveMagicMult )
						{
							state = REJECT_STATE ;
						}
						else if ( positiveDatum == positiveMagicMult ) 
						{
							if ( ProviderAnalyser :: OctWCharToDecInteger ( token ) > positiveMagicPosDigit ) 
							{
								state = REJECT_STATE ;
							}
						}

						positiveDatum = ( positiveDatum << 3 ) + ProviderAnalyser :: OctWCharToDecInteger ( token ) ;
					}
					else
					{
						lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
						lexicon->value.unsignedInteger = positiveDatum ;
						state = ACCEPT_STATE ;

						position -- ;
					}
				}
				break ;

				case DEC_INTEGER_START:
				{
					if ( ProviderAnalyser :: IsDecimal ( token ) )
					{
						negativeDatum = ( token - 48 ) ;
						state = DEC_INTEGER_START + 1 ;
					}
					else 
					if ( ProviderAnalyser :: IsWhitespace ( token ) ) 
					{
						state = DEC_INTEGER_START ;
					}
					else state = REJECT_STATE ;
				}	
				break ;

				case DEC_INTEGER_START+1:
				{
					if ( ProviderAnalyser :: IsDecimal ( token ) )
					{	
						state = DEC_INTEGER_START + 1 ;

						if ( positive )
						{
							if ( positiveDatum > positiveMagicMult )
							{
								state = REJECT_STATE ;
							}
							else if ( positiveDatum == positiveMagicMult ) 
							{
								if ( ( ULONG ) ( token - 48 ) > positiveMagicPosDigit ) 
								{
									state = REJECT_STATE ;
								}
							}
						}
						else
						{
							if ( negativeDatum > negativeMagicMult )
							{
								state = REJECT_STATE ;
							}
							else if ( negativeDatum == negativeMagicMult ) 
							{
								if ( negative ) 
								{
									if ( ( ULONG ) ( token - 48 ) > negativeMagicNegDigit ) 
									{
										state = REJECT_STATE ;
									}
								}
								else
								{
									if ( ( ULONG ) ( token - 48 ) > negativeMagicPosDigit ) 
									{
										positiveDatum = negativeDatum ;
										positive = TRUE ;
									}
								}
							}
						}

						if ( positive )
						{
							positiveDatum = positiveDatum * 10 + ( token - 48 ) ;
						}
						else
						{
							negativeDatum = negativeDatum * 10 + ( token - 48 ) ;
						}
					}
					else
					{
						if ( negative )
						{
							if ( ! unSignedIntegersOnly )
							{
								lexicon->token = ProviderLexicon :: SIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum * -1 ;
							}
							else
							{
								state = REJECT_STATE ;
							}
						}
						else if ( positive )
						{
							lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
							lexicon->value.unsignedInteger = positiveDatum ;
						}
						else
						{
							if ( unSignedIntegersOnly )
							{
								lexicon->token = ProviderLexicon :: UNSIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum ;
							}
							else
							{
								lexicon->token = ProviderLexicon :: SIGNED_INTEGER_ID ;
								lexicon->value.signedInteger = negativeDatum ;
							}
						}

						state = ACCEPT_STATE ;

						position -- ;
					}
				}	
				break ;

				case ACCEPT_STATE:
				case REJECT_STATE:
				default:
				{
					state = REJECT_STATE ;
				} ;
				break ;
			}
		}

		position ++ ;
	}

	status = ( state != REJECT_STATE ) ;

	return lexicon ;
}

BOOL ProviderAnalyser :: IsLeadingDecimal ( wchar_t token )
{
	return iswdigit ( token ) && ( token != L'0' ) ;
}

BOOL ProviderAnalyser :: IsDecimal ( wchar_t token )
{
	return iswdigit ( token ) ;
}

BOOL ProviderAnalyser :: IsHex ( wchar_t token )
{
	return iswxdigit ( token ) ;
}
	
BOOL ProviderAnalyser :: IsWhitespace ( wchar_t token )
{
	return iswspace ( token ) ;
}

BOOL ProviderAnalyser :: IsOctal ( wchar_t token )
{
	return ( token >= L'0' && token <= L'7' ) ;
}

BOOL ProviderAnalyser :: IsAlpha ( wchar_t token )
{
	return iswalpha ( token ) ;
}

BOOL ProviderAnalyser :: IsAlphaNumeric ( wchar_t token )
{
	return iswalnum ( token ) || ( token == L'_' ) || ( token == L'-' ) ;
}

BOOL ProviderAnalyser :: IsEof ( wchar_t token )
{
	return token == 0 ;
}

ULONG ProviderAnalyser :: OctWCharToDecInteger ( wchar_t token ) 
{
	return token - L'0' ;
}

ULONG ProviderAnalyser :: HexWCharToDecInteger ( wchar_t token ) 
{
	if ( token >= L'0' && token <= L'9' )
	{
		return token - L'0' ;
	}
	else if ( token >= L'a' && token <= L'f' )
	{
		return token - L'a' + 10 ;
	}
	else if ( token >= L'A' && token <= L'F' )
	{
		return token - L'A' + 10 ;
	}
	else
	{
		return 0 ;
	}
}

ULONG ProviderAnalyser :: DecWCharToDecInteger ( wchar_t token ) 
{
	if ( token >= L'0' && token <= L'9' )
	{
		return token - L'0' ;
	}
	else
	{
		return 0 ;
	}
}

wchar_t ProviderAnalyser :: DecIntegerToOctWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 7 )
	{
		return L'0' + integer ;
	}
	else
	{
		return L'0' ;
	}
}

wchar_t ProviderAnalyser :: DecIntegerToDecWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return L'0' + integer ;
	}
	else
	{
		return L'0' ;
	}
}

wchar_t ProviderAnalyser :: DecIntegerToHexWChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return L'0' + integer ;
	}
	else if ( integer >= 10 && integer <= 15 )
	{
		return L'a' + ( integer - 10 ) ;
	}
	else
	{
		return L'0' ;
	}
}

ULONG ProviderAnalyser :: OctCharToDecInteger ( char token ) 
{
	return token - '0' ;
}

ULONG ProviderAnalyser :: HexCharToDecInteger ( char token ) 
{
	if ( token >= '0' && token <= '9' )
	{
		return token - '0' ;
	}
	else if ( token >= 'a' && token <= 'f' )
	{
		return token - 'a' + 10 ;
	}
	else if ( token >= 'A' && token <= 'F' )
	{
		return token - 'A' + 10 ;
	}
	else
	{
		return 0 ;
	}
}

ULONG ProviderAnalyser :: DecCharToDecInteger ( char token ) 
{
	if ( token >= '0' && token <= '9' )
	{
		return token - '0' ;
	}
	else
	{
		return 0 ;
	}
}

char ProviderAnalyser :: DecIntegerToOctChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 7 )
	{
		return '0' + integer ;
	}
	else
	{
		return '0' ;
	}
}

char ProviderAnalyser :: DecIntegerToDecChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return '0' + integer ;
	}
	else
	{
		return '0' ;
	}
}

char ProviderAnalyser :: DecIntegerToHexChar ( UCHAR integer )
{
	if ( integer >= 0 && integer <= 9 )
	{
		return '0' + integer ;
	}
	else if ( integer >= 10 && integer <= 15 )
	{
		return 'a' + ( integer - 10 ) ;
	}
	else
	{
		return '0' ;
	}
}

WbemTaskObject :: WbemTaskObject (

	CImpFrameworkProv *a_Provider ,
	IWbemObjectSink *a_NotificationHandler ,
	ULONG a_OperationFlag ,
	IWbemContext *a_Ctx

) :	m_State ( WBEM_TASKSTATE_START ) ,
	m_OperationFlag ( a_OperationFlag ) ,
	m_Provider ( a_Provider ) ,
	m_NotificationHandler ( a_NotificationHandler ) ,
	m_Ctx ( a_Ctx ) ,
	m_RequestHandle ( 0 ) ,
	m_ClassObject ( NULL ) ,
	m_ReferenceCount ( 1 )
{
	m_Provider->AddRef () ;
	m_NotificationHandler->AddRef () ;
	if ( m_Ctx ) 
	{
		m_Ctx->AddRef () ;
	}
}

WbemTaskObject :: ~WbemTaskObject ()
{
	m_Provider->Release () ;
	m_NotificationHandler->Release () ;
	if ( m_Ctx )
		m_Ctx->Release () ;

	if ( m_ClassObject )
		m_ClassObject->Release () ;
}

ULONG WbemTaskObject::AddRef(void)
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

ULONG WbemTaskObject::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

WbemProviderErrorObject &WbemTaskObject :: GetErrorObject ()
{
	return m_ErrorObject ; 
}	

BOOL WbemTaskObject :: GetClassObject ( wchar_t *a_Class )
{
	IWbemCallResult *t_ErrorObject = NULL ;

	IWbemServices *t_Server = m_Provider->GetServer() ;

	HRESULT t_Result = t_Server->GetObject (

		a_Class ,
		0 ,
		m_Ctx,
		& m_ClassObject ,
		& t_ErrorObject 
	) ;

	t_Server->Release () ;

	if ( t_ErrorObject )
		t_ErrorObject->Release () ;

	return SUCCEEDED ( t_Result ) ;
}


BOOL WbemTaskObject :: GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;
	IWbemClassObject *t_ErrorObject = NULL ;

	BOOL t_Status = TRUE ;

	WbemProviderErrorObject t_ErrorStatusObject ;
	if ( t_NotificationClassObject = m_Provider->GetExtendedNotificationObject ( t_ErrorStatusObject , m_Ctx ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;

			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
			VariantClear ( &t_Variant ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = m_ErrorObject.GetStatus () ;

				t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVIDERSTATUSCODE , 0 , & t_Variant , 0 ) ;
				VariantClear ( &t_Variant ) ;

				if ( SUCCEEDED ( t_Result ) )
				{
					if ( m_ErrorObject.GetMessage () ) 
					{
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

						t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVIDERSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
						VariantClear ( &t_Variant ) ;

						if ( ! SUCCEEDED ( t_Result ) )
						{
							(*a_NotifyObject)->Release () ;
							t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
						}
					}
				}
				else
				{
					(*a_NotifyObject)->Release () ;
					t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
			}

			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
		}
	}
	else
	{
		t_Status = GetNotifyStatusObject ( a_NotifyObject ) ;
	}

	return t_Status ;
}

BOOL WbemTaskObject :: GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) 
{
	IWbemClassObject *t_NotificationClassObject = NULL ;

	BOOL t_Status = TRUE ;

	WbemProviderErrorObject t_ErrorStatusObject ;
	if ( t_NotificationClassObject = m_Provider->GetNotificationObject ( t_ErrorStatusObject , m_Ctx ) )
	{
		HRESULT t_Result = t_NotificationClassObject->SpawnInstance ( 0 , a_NotifyObject ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			VARIANT t_Variant ;
			VariantInit ( &t_Variant ) ;

			t_Variant.vt = VT_I4 ;
			t_Variant.lVal = m_ErrorObject.GetWbemStatus () ;

			t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_Variant , 0 ) ;
			if ( SUCCEEDED ( t_Result ) )
			{
				if ( m_ErrorObject.GetMessage () ) 
				{
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( m_ErrorObject.GetMessage () ) ;

					t_Result = (*a_NotifyObject)->Put ( WBEM_PROPERTY_PROVIDERSTATUSMESSAGE , 0 , & t_Variant , 0 ) ;
					VariantClear ( &t_Variant ) ;

					if ( ! SUCCEEDED ( t_Result ) )
					{
						t_Status = FALSE ;
						(*a_NotifyObject)->Release () ;
						(*a_NotifyObject)=NULL ;
					}
				}
			}
			else
			{
				(*a_NotifyObject)->Release () ;
				(*a_NotifyObject)=NULL ;
				t_Status = FALSE ;
			}

			VariantClear ( &t_Variant ) ;

			t_NotificationClassObject->Release () ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}
	else
	{
		t_Status = FALSE ;
	}

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtclas.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcl.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL CreateClassEnumEventObject :: CreateClassEnum ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = GetClassObject ( m_SuperClass ) ;
	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

CreateClassEnumEventObject :: CreateClassEnumEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_SuperClass ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx )
{
	m_SuperClass = UnicodeStringDuplicate ( a_SuperClass ) ;
}

CreateClassEnumEventObject :: ~CreateClassEnumEventObject () 
{
// Get Status object

	delete [] m_SuperClass ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void CreateClassEnumEventObject :: ProcessComplete () 
{
}

void CreateClassEnumEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = CreateClassEnum ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}


CreateClassEnumAsyncEventObject :: CreateClassEnumAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_SuperClass ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : CreateClassEnumEventObject ( a_Provider , a_SuperClass , a_OperationFlag , a_NotificationHandler , a_Ctx )
{
}

CreateClassEnumAsyncEventObject :: ~CreateClassEnumAsyncEventObject () 
{
}

void CreateClassEnumAsyncEventObject :: ProcessComplete () 
{
	CreateClassEnumEventObject :: ProcessComplete () ;

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtdel.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS  Property Provider

//

//  Purpose: Implementation for the GetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL DeleteInstanceEventObject :: DeleteInstance ( WbemProviderErrorObject &a_ErrorObject )
{
	
	BOOL t_Status;
    int iParseResult = m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
	if ( CObjectPathParser::NoError == iParseResult )
	{
		t_Status = TRUE;
        ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

DeleteInstanceEventObject :: DeleteInstanceEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Class ( NULL ) 
{
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

DeleteInstanceEventObject :: ~DeleteInstanceEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void DeleteInstanceEventObject :: ProcessComplete () 
{
}

void DeleteInstanceEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = DeleteInstance ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

DeleteInstanceAsyncEventObject :: DeleteInstanceAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : DeleteInstanceEventObject ( a_Provider , a_ObjectPath , a_OperationFlag , a_NotificationHandler , a_Ctx )
{
}

DeleteInstanceAsyncEventObject :: ~DeleteInstanceAsyncEventObject () 
{
}

void DeleteInstanceAsyncEventObject :: ProcessComplete () 
{
	DeleteInstanceEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;


	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtevt.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "classfac.h"
#include "guids.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

EventAsyncEventObject :: EventAsyncEventObject (

	CImpFrameworkProv *a_Provider ,
	IWbemObjectSink* pSink, 
	long lFlags

) : WbemTaskObject ( a_Provider , pSink , lFlags , NULL ) 
{
}

EventAsyncEventObject :: ~EventAsyncEventObject () 
{
}

void EventAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_ErrorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	delete this ;
}

void EventAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = ProcessEvent ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

BOOL EventAsyncEventObject :: ProcessEvent ( WbemProviderErrorObject &a_ErrorObject ) 
{
	return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtinst.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL CreateInstanceEnumEventObject :: CreateInstanceEnum ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = GetClassObject ( m_Class ) ;
	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

CreateInstanceEnumEventObject :: CreateInstanceEnumEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_Class ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx )
{
	m_Class = UnicodeStringDuplicate ( a_Class ) ;
}

CreateInstanceEnumEventObject :: ~CreateInstanceEnumEventObject () 
{
// Get Status object

	delete [] m_Class ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void CreateInstanceEnumEventObject :: ProcessComplete () 
{
}

void CreateInstanceEnumEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = CreateInstanceEnum ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

CreateInstanceEnumAsyncEventObject :: CreateInstanceEnumAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_Class ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : CreateInstanceEnumEventObject ( a_Provider , a_Class , a_OperationFlag , a_NotificationHandler , a_Ctx )
{
}

CreateInstanceEnumAsyncEventObject :: ~CreateInstanceEnumAsyncEventObject () 
{
}

void CreateInstanceEnumAsyncEventObject :: ProcessComplete () 
{
	CreateInstanceEnumEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtmeth.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL ExecMethodEventObject :: ExecMethod ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status;
    int iParseResult = m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
	if ( CObjectPathParser::NoError == iParseResult )
	{
		t_Status = TRUE;
        ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

ExecMethodEventObject :: ExecMethodEventObject (

	CImpFrameworkProv *a_Provider , 
    BSTR a_ObjectPath,
    BSTR a_MethodName,
    ULONG a_OperationFlag,
    IWbemContext FAR *a_Ctx,
    IWbemClassObject FAR *a_InParameters,
	IWbemObjectSink FAR *a_NotificationHandler

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx )
{
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
	m_MethodName = UnicodeStringDuplicate ( a_MethodName ) ;

	m_InParameters = a_InParameters ;
	if ( m_InParameters ) 
		m_InParameters->AddRef () ;

}

ExecMethodEventObject :: ~ExecMethodEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;
	delete [] m_MethodName ;

	if ( m_InParameters ) 
		m_InParameters->Release () ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void ExecMethodEventObject :: ProcessComplete () 
{
}

void ExecMethodEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = ExecMethod ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

ExecMethodAsyncEventObject :: ExecMethodAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
    BSTR a_ObjectPath,
    BSTR a_MethodName,
    ULONG a_OperationFlag,
    IWbemContext FAR *a_Ctx,
    IWbemClassObject FAR *a_InParameters,
	IWbemObjectSink FAR *a_NotificationHandler

) : ExecMethodEventObject ( a_Provider , a_ObjectPath , a_MethodName , a_OperationFlag , a_Ctx , a_InParameters , a_NotificationHandler )
{
}

ExecMethodAsyncEventObject :: ~ExecMethodAsyncEventObject () 
{
}

void ExecMethodAsyncEventObject :: ProcessComplete () 
{
	ExecMethodEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtdecl.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL DeleteClassEventObject :: DeleteClass ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = GetClassObject ( m_Class ) ;
	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

DeleteClassEventObject :: DeleteClassEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_Class ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx )
{
	m_Class = UnicodeStringDuplicate ( a_Class ) ;
}

DeleteClassEventObject :: ~DeleteClassEventObject () 
{
// Get Status object

	delete [] m_Class ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void DeleteClassEventObject :: ProcessComplete () 
{
}

void DeleteClassEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = DeleteClass ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}


DeleteClassAsyncEventObject :: DeleteClassAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_Class ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : DeleteClassEventObject ( a_Provider , a_Class , a_OperationFlag , a_NotificationHandler , a_Ctx )
{
}

DeleteClassAsyncEventObject :: ~DeleteClassAsyncEventObject () 
{
}

void DeleteClassAsyncEventObject :: ProcessComplete () 
{
	DeleteClassEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS PROVIDER Property Provider

//

//  Purpose: Implementation for the CImpFrameworkProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <stdio.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"
#include "guids.h"

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpFrameworkProv ::CImpFrameworkProv
// CImpFrameworkProv ::~CImpFrameworkProv
//
//***************************************************************************

DefaultThreadObject *CImpFrameworkProv :: s_DefaultThreadObject = NULL ;

CImpFrameworkProv ::CImpFrameworkProv ()
{
	m_ReferenceCount = 0 ;
	 
    InterlockedIncrement ( & CFrameworkProviderClassFactory :: s_ObjectsInProgress ) ;

/*
 * Implementation
 */

	m_Initialised = FALSE ;
	m_Server = NULL ;
	m_Namespace = NULL ;

	m_NotificationClassObject = NULL ;
	m_ExtendedNotificationClassObject = NULL ;
	m_GetNotifyCalled = FALSE ;
	m_GetExtendedNotifyCalled = FALSE ;

	m_localeId = NULL ;
}

CImpFrameworkProv ::~CImpFrameworkProv(void)
{
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CFrameworkProviderClassFactory :: s_ObjectsInProgress ) ;

	delete [] m_localeId ;
	delete [] m_Namespace ;

	if ( m_Server ) 
		m_Server->Release () ;

	if ( m_NotificationClassObject )
		m_NotificationClassObject->Release () ;

	if ( m_ExtendedNotificationClassObject )
		m_ExtendedNotificationClassObject->Release () ;

}

//***************************************************************************
//
// CImpFrameworkProv ::QueryInterface
// CImpFrameworkProv ::AddRef
// CImpFrameworkProv ::Release
//
// Purpose: IUnknown members for CImpFrameworkProv object.
//***************************************************************************

STDMETHODIMP CImpFrameworkProv ::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
	}
	else if ( iid == IID_IWbemServices )
	{
		*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
	}	
	else if ( iid == IID_IWbemEventProvider )
	{
        *iplpv = ( LPVOID ) ( IWbemEventProvider * ) this ;
	}
	else if ( iid == IID_IWbemHiPerfProvider )
	{
        *iplpv = ( LPVOID ) ( IWbemHiPerfProvider * ) this ;
	}
	else if ( iid == IID_IWbemProviderInit )
	{
		*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
	}

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG) CImpFrameworkProv ::AddRef(void)
{
    return InterlockedIncrement ( & m_ReferenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpFrameworkProv ::Release(void)
{
	LONG t_Ref ;
	if ( ( t_Ref = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Ref ;
	}
}

void CImpFrameworkProv :: SetServer ( IWbemServices *a_Server ) 
{
	m_Server = a_Server ; 
	m_Server->AddRef () ; 
}

IWbemServices *CImpFrameworkProv :: GetServer () 
{ 
	if ( m_Server )
		m_Server->AddRef () ; 

	return m_Server ; 
}

void CImpFrameworkProv :: SetLocaleId ( wchar_t *localeId )
{
	m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CImpFrameworkProv :: GetNamespace () 
{
	return m_Namespace ; 
}

void CImpFrameworkProv :: SetNamespace ( wchar_t *a_Namespace ) 
{
	m_Namespace = UnicodeStringDuplicate ( a_Namespace ) ; 
}

IWbemClassObject *CImpFrameworkProv :: GetNotificationObject ( WbemProviderErrorObject &a_errorObject , IWbemContext *a_Ctx ) 
{
	if ( m_NotificationClassObject )
	{
		m_NotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateNotificationObject ( a_errorObject , a_Ctx ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_NotificationClassObject->AddRef () ;
		}

	}

	return m_NotificationClassObject ; 
}

IWbemClassObject *CImpFrameworkProv :: GetExtendedNotificationObject ( WbemProviderErrorObject &a_errorObject , IWbemContext *a_Ctx ) 
{
	if ( m_ExtendedNotificationClassObject )
	{
		m_ExtendedNotificationClassObject->AddRef () ;
	}
	else
	{
		BOOL t_Status = CreateExtendedNotificationObject ( a_errorObject , a_Ctx ) ;
		if ( t_Status )
		{
/* 
 * Keep around until we close
 */
			m_ExtendedNotificationClassObject->AddRef () ;
		}
	}

	return m_ExtendedNotificationClassObject ; 
}

BOOL CImpFrameworkProv :: CreateExtendedNotificationObject ( 

	WbemProviderErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
)
{
	if ( m_GetExtendedNotifyCalled )
	{
		if ( m_ExtendedNotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetExtendedNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	IWbemCallResult *t_ErrorObject = NULL ;

	HRESULT t_Result = m_Server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		a_Ctx,
		& m_ExtendedNotificationClassObject ,
		& t_ErrorObject 
	) ;

	if ( t_ErrorObject )
		t_ErrorObject->Release () ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;

		m_ExtendedNotificationClassObject = NULL ;
	}

	return t_Status ;
}

BOOL CImpFrameworkProv :: CreateNotificationObject ( 

	WbemProviderErrorObject &a_errorObject , 
	IWbemContext *a_Ctx 
)
{
	if ( m_GetNotifyCalled )
	{
		if ( m_NotificationClassObject )
			return TRUE ;
		else
			return FALSE ;
	}
	else
		m_GetNotifyCalled = TRUE ;

	BOOL t_Status = TRUE ;

	IWbemCallResult *t_ErrorObject = NULL ;

	HRESULT t_Result = m_Server->GetObject (

		WBEM_CLASS_EXTENDEDSTATUS ,
		0 ,
		a_Ctx,
		& m_NotificationClassObject ,
		& t_ErrorObject 
	) ;

	if ( t_ErrorObject )
		t_ErrorObject->Release () ;

	if ( ! SUCCEEDED ( t_Result ) )
	{
		t_Status = FALSE ;
		a_errorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
	}

	return t_Status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CImpFrameworkProv ::OpenNamespace ( 

	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* ppNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: GetObject ( 
		
	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: GetObjectAsync ( 
		
	BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpFrameworkProv::GetObjectAsync ()" 
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Asynchronous GetObjectByPath object
 */

	GetObjectAsyncEventObject *t_AsyncEvent = new GetObjectAsyncEventObject ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpFrameworkProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
		ObjectPath ,
		t_Result 
	) ;
)

	return t_Result ;
}

HRESULT CImpFrameworkProv :: PutClass ( 
		
	IWbemClassObject FAR* pClass , 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pClass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpFrameworkProv::PutInstanceAsync ()" 
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous UpdateInstance object
 */

	PutClassAsyncEventObject *t_AsyncEvent = new PutClassAsyncEventObject ( this , pClass , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpFrameworkProv::PutInstanceAsync () with Result = (%lx)" ,
		t_Result 
	) ;
)

	return t_Result ;
}

 HRESULT CImpFrameworkProv :: DeleteClass ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: DeleteClassAsync ( 
		
	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpFrameworkProv::DeleteClassAsync ( (%s) )" ,
		Class
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	DeleteClassAsyncEventObject *t_AsyncEvent = new DeleteClassAsyncEventObject ( this , Class , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"ReturningFrom CImpFrameworkProv::DeleteClass ( (%s) ) with Result = (%lx)" ,
		Class ,
		t_Result
	) ;
)

	return t_Result ;

}

HRESULT CImpFrameworkProv :: CreateClassEnum ( 

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

SCODE CImpFrameworkProv :: CreateClassEnumAsync (

	BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: PutInstance (

    IWbemClassObject FAR *pInstance,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInstance, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpFrameworkProv::PutInstanceAsync ()" 
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous UpdateInstance object
 */

	PutInstanceAsyncEventObject *t_AsyncEvent = new PutInstanceAsyncEventObject ( this , pInstance , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpFrameworkProv::PutInstanceAsync () with Result = (%lx)" ,
		t_Result 
	) ;
)

	return t_Result ;
}

HRESULT CImpFrameworkProv :: DeleteInstance ( 

	BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpFrameworkProv :: DeleteInstanceAsync (
 
	BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpFrameworkProv::DeleteInstance ()" 
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Asynchronous GetObjectByPath object
 */

	DeleteInstanceAsyncEventObject *t_AsyncEvent = new DeleteInstanceAsyncEventObject ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpFrameworkProv::DeleteInstanceAsync ( (%s) ) with Result = (%lx)" ,
		ObjectPath ,
		t_Result 
	) ;
)

	return t_Result ;

}

HRESULT CImpFrameworkProv :: CreateInstanceEnum ( 

	BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: CreateInstanceEnumAsync (

 	BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpFrameworkProv::CreateInstanceEnumAsync ( (%s) )" ,
		Class
	) ;
) 

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	CreateInstanceEnumAsyncEventObject *t_AsyncEvent = new CreateInstanceEnumAsyncEventObject ( this , Class , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"ReturningFrom CImpFrameworkProv::CreateInstanceEnum ( (%s) ) with Result = (%lx)" ,
		Class ,
		t_Result
	) ;
)

	return t_Result ;
}

HRESULT CImpFrameworkProv :: ExecQuery ( 

	BSTR QueryLanguage, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpFrameworkProv :: ExecQueryAsync ( 
		
	BSTR QueryFormat, 
	BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;


	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpFrameworkProv::ExecQueryAsync ( (%s),(%s) )" ,
		QueryFormat ,
		Query 
	) ;
)

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	ExecQueryAsyncEventObject *t_AsyncEvent = new ExecQueryAsyncEventObject ( this , QueryFormat , Query , lFlags , pHandler , pCtx ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpFrameworkProv::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)" ,
		QueryFormat,
		Query,
		t_Result 
	) ;
)

	return t_Result ;
}

HRESULT CImpFrameworkProv :: ExecNotificationQuery ( 

	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpFrameworkProv :: ExecNotificationQueryAsync ( 
            
	BSTR QueryLanguage,
    BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: ExecMethod ( 

	BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpFrameworkProv :: ExecMethodAsync ( 

    BSTR ObjectPath,
    BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;


	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpFrameworkProv::ExecMethodAsync ( (%s),(%s) )" ,
		ObjectPath ,
		MethodName
	) ;
)

	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	ExecMethodAsyncEventObject *t_AsyncEvent = new ExecMethodAsyncEventObject ( this , ObjectPath , MethodName , lFlags , pCtx , pInParams , pResponseHandler ) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpFrameworkProv::ExecqMethodAsync ( (%s),(%s) ) with Result = (%lx)" ,
		ObjectPath ,
		MethodName,
		t_Result 
	) ;
)

	return t_Result ;
}

STDMETHODIMP CImpFrameworkProv :: ProvideEvents (

	IWbemObjectSink* pSink,
    LONG lFlags
)
{
	HRESULT t_Result = S_OK ;

/*
 * Create Synchronous Enum Instance object
 */

	EventAsyncEventObject *t_AsyncEvent = new EventAsyncEventObject ( 

		this , 
		pSink, 
		lFlags
	) ;

	CImpFrameworkProv :: s_DefaultThreadObject->ScheduleTask ( *t_AsyncEvent ) ;

	t_AsyncEvent->Exec() ;

	t_AsyncEvent->Acknowledge () ;

	return t_Result ;
}

HRESULT CImpFrameworkProv :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->Write (  

		L"\r\n"
	) ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpFrameworkProv::Initialize ()"
	) ;
)

	EnterCriticalSection ( & s_CriticalSection ) ;

	SetServer ( pCIMOM ) ;

	m_NamespacePath.SetNamespacePath ( pszNamespace ) ;
	SetNamespace ( pszNamespace ) ;

	BOOL status = TRUE ;

	if ( ! CImpFrameworkProv :: s_DefaultThreadObject )
	{
		SnmpThreadObject :: Startup () ;
		SnmpDebugLog :: Startup () ;

		CImpFrameworkProv :: s_DefaultThreadObject = new DefaultThreadObject ( "WBEM Provider" ) ; ;
		CImpFrameworkProv :: s_DefaultThreadObject->WaitForStartup () ;
	}

	WbemProviderErrorObject errorObject ;

	IWbemClassObject *t_Object = GetNotificationObject ( errorObject , pCtx ) ;
	if ( t_Object ) 
		t_Object->Release () ;

	t_Object = GetExtendedNotificationObject ( errorObject , pCtx ) ;
	if ( t_Object ) 
		t_Object->Release () ;

	HRESULT result = errorObject.GetWbemStatus () ;

	pInitSink->SetStatus ( (result == WBEM_NO_ERROR) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning From CImpFrameworkProv::Initialize () with Result = (%lx)" ,
		result
	) ;
)

	LeaveCriticalSection ( & s_CriticalSection ) ;
	
	return result ;
}

//***************************************************************************
//
//  CImpFrameworkProv::QueryInstances
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  This
//                      should not be AddRef'ed.
//  <wszClass>          The class name for which instances are required.
//  <lFlags>            Reserved.
//  <pCtx>              The user-supplied context (not used here).
//  <pSink>             The sink to which to deliver the objects.  The objects
//                      can be delivered synchronously through the duration
//                      of this call or asynchronously (assuming we
//                      had a separate thread).  A IWbemObjectSink::SetStatus
//                      call is required at the end of the sequence.
//
//***************************************************************************
        
HRESULT CImpFrameworkProv :: QueryInstances ( 

    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink
)
{
    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    return WBEM_E_FAILED;
}    


//***************************************************************************
//
//  CNt5Refresher::CreateRefresher
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//***************************************************************************        

HRESULT CImpFrameworkProv::CreateRefresher ( 

     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
)
{
    if (pNamespace == 0 || ppRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

    return WBEM_E_FAILED;
}

//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableObject
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in CIMOM.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//***************************************************************************        

HRESULT CImpFrameworkProv :: CreateRefreshableObject ( 

    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId
)
{
    return WBEM_E_FAILED ;
}
    
//***************************************************************************
//
//  CNt5Refresher::StopRefreshing
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//***************************************************************************        
        
HRESULT CImpFrameworkProv::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags
    )
{
    return WBEM_E_FAILED;
}

CImpRefresher::CImpRefresher ()
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpRefresher::CImpRefresher ( this = ( %lx ) ) " , 
		this 
	) ;
)

	m_referenceCount = 0 ;
	 
    InterlockedIncrement ( & CFrameworkProviderClassFactory :: s_ObjectsInProgress ) ;

}

CImpRefresher::~CImpRefresher(void)
{
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CFrameworkProviderClassFactory :: s_ObjectsInProgress ) ;
}

//***************************************************************************
//
// CImpRefresher::QueryInterface
// CImpRefresher::AddRef
// CImpRefresher::Release
//
// Purpose: IUnknown members for CImpRefresher object.
//***************************************************************************

STDMETHODIMP CImpRefresher::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) ( IWbemRefresher * ) this ;
	}
	else if ( iid == IID_IWbemRefresher )
	{
		*iplpv = ( LPVOID ) ( IWbemRefresher * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return S_OK ;
	}
	else
	{
		return E_NOINTERFACE ;
	}
}

STDMETHODIMP_(ULONG) CImpRefresher::AddRef(void)
{
    return InterlockedIncrement ( & m_referenceCount ) ;
}

STDMETHODIMP_(ULONG) CImpRefresher::Release(void)
{
	LONG ref ;
	if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return ref ;
	}
}

HRESULT CImpRefresher :: Refresh (

	/* [in] */ long lFlags
)
{
	return WBEM_E_FAILED ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtget.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS  Property Provider

//

//  Purpose: Implementation for the GetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL GetObjectEventObject :: GetObject ( WbemProviderErrorObject &a_ErrorObject )
{
	
	BOOL t_Status;
    int iParseResult = m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
	if ( CObjectPathParser::NoError == iParseResult )
	{
		t_Status = TRUE;
        ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

GetObjectEventObject :: GetObjectEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Class ( NULL ) 
{
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

GetObjectEventObject :: ~GetObjectEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;


	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void GetObjectEventObject :: ProcessComplete () 
{
}

void GetObjectEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = GetObject ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}


GetObjectAsyncEventObject :: GetObjectAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : GetObjectEventObject ( a_Provider , a_ObjectPath , a_OperationFlag , a_NotificationHandler , a_Ctx ) 
{
}

GetObjectAsyncEventObject :: ~GetObjectAsyncEventObject () 
{
}

void GetObjectAsyncEventObject :: ProcessComplete () 
{
	GetObjectEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtupcl.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpSetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "classfac.h"
#include "guids.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL PutClassEventObject :: PutClass ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = FALSE ;

	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

PutClassEventObject :: PutClassEventObject (

	CImpFrameworkProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Class ( NULL ) ,
	m_Object ( a_Object ) 
{
	m_Object->AddRef () ;
}

PutClassEventObject :: ~PutClassEventObject () 
{
// Get Status object

	delete [] m_Class ;

	m_Object->Release () ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void PutClassEventObject :: ProcessComplete () 
{
}

void PutClassEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = PutClass ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

PutClassAsyncEventObject :: PutClassAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : PutClassEventObject ( a_Provider , a_Object, a_OperationFlag , a_NotificationHandler , a_Ctx ) 
{
}

PutClassAsyncEventObject :: ~PutClassAsyncEventObject () 
{
}

void PutClassAsyncEventObject :: ProcessComplete () 
{
	PutClassEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpSetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "classfac.h"
#include "guids.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL PutInstanceEventObject :: PutInstance ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status = FALSE ;

	if ( t_Status )
	{
		ProcessComplete () ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

PutInstanceEventObject :: PutInstanceEventObject (

	CImpFrameworkProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Class ( NULL ) ,
	m_Object ( a_Object ) 
{
	m_Object->AddRef () ;
}

PutInstanceEventObject :: ~PutInstanceEventObject () 
{
// Get Status object

	delete [] m_Class ;

	m_Object->Release () ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void PutInstanceEventObject :: ProcessComplete () 
{
}

void PutInstanceEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = PutInstance ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

PutInstanceAsyncEventObject :: PutInstanceAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	IWbemClassObject *a_Object ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : PutInstanceEventObject ( a_Provider , a_Object , a_OperationFlag , a_NotificationHandler , a_Ctx ) 
{
}

PutInstanceAsyncEventObject :: ~PutInstanceAsyncEventObject () 
{
}

void PutInstanceAsyncEventObject :: ProcessComplete () 
{
	PutInstanceEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\trrtquery.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <windows.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include "classfac.h"
#include "guids.h"
#include <instpath.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "trrtcomm.h"
#include "trrtprov.h"
#include "trrt.h"

BOOL ExecQueryEventObject :: ExecQuery ( WbemProviderErrorObject &a_ErrorObject )
{
	BOOL t_Status ;

	if ( _wcsicmp ( m_QueryFormat , WBEM_QUERY_LANGUAGE_WQL ) == 0 )
	{
		t_Status = ! m_SqlParser.Parse ( & m_RPNExpression ) ;
		if ( t_Status )
		{
			t_Status = GetClassObject ( m_RPNExpression->bsClassName ) ;
			if ( t_Status )
			{
				ProcessComplete () ;
			}
			else
			{
				t_Status = FALSE ;
				a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_CLASS ) ;
				a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
			}
		}
		else
		{
			t_Status = FALSE ;
			a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_QUERY ) ;
			a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_ErrorObject.SetMessage ( L"SQL1 query was invalid" ) ;
		}
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_PROVIDER_E_INVALID_QUERY_TYPE ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE ) ;
		a_ErrorObject.SetMessage ( L"Query Language not supported" ) ;
	}

	return t_Status ;
}

ExecQueryEventObject :: ExecQueryEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_QueryFormat , 
	BSTR a_Query , 
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : WbemTaskObject ( a_Provider , a_NotificationHandler , a_OperationFlag , a_Ctx ) ,
	m_Query ( UnicodeStringDuplicate ( a_Query ) ) ,
	m_QueryFormat ( UnicodeStringDuplicate ( a_QueryFormat ) ) ,
	m_QuerySource ( m_Query ) , 
	m_SqlParser ( &m_QuerySource ) ,
	m_RPNExpression ( NULL ) 
{
}

ExecQueryEventObject :: ~ExecQueryEventObject () 
{
// Get Status object

	delete [] m_Query ;
	delete [] m_QueryFormat ;
	delete m_RPNExpression ;

	if ( FAILED ( m_ErrorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *t_NotifyStatus = NULL ;
		BOOL t_Status = GetExtendedNotifyStatusObject ( &t_NotifyStatus ) ;
		if ( t_Status )
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , m_ErrorObject.GetMessage () , t_NotifyStatus ) ;
			t_NotifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_ErrorObject.GetWbemStatus () , NULL , NULL ) ;
	}
}

void ExecQueryEventObject :: ProcessComplete () 
{
}

void ExecQueryEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			Complete () ;
			WaitAcknowledgement () ;
			BOOL t_Status = ExecQuery ( m_ErrorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}

ExecQueryAsyncEventObject :: ExecQueryAsyncEventObject (

	CImpFrameworkProv *a_Provider , 
	BSTR a_QueryFormat , 
	BSTR a_Query , 
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : ExecQueryEventObject ( a_Provider , a_QueryFormat , a_Query , a_OperationFlag , a_NotificationHandler , a_Ctx ) 
{
}

ExecQueryAsyncEventObject :: ~ExecQueryAsyncEventObject () 
{
}

void ExecQueryAsyncEventObject :: ProcessComplete () 
{
	ExecQueryEventObject :: ProcessComplete () ;

/*
 *	Remove worker object from worker thread container
 */

	CImpFrameworkProv:: s_DefaultThreadObject->ReapTask ( *this ) ;

	Release () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\include\guids.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
// {E507506B-DC59-11d0-82D7-00A0C9038B34}
DEFINE_GUID(CLSID_CFrameworkProviderClassFactory, 
0xe507506b, 0xdc59, 0x11d0, 0x82, 0xd7, 0x0, 0xa0, 0xc9, 0x3, 0x8b, 0x34);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\include\classfac.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#ifndef _SNMPPropProvClassFactory_H
#define _SNMPPropProvClassFactory_H

class CFrameworkProviderClassFactory : public IClassFactory
{
private:

    long m_ReferenceCount ;

protected:
public:

	static LONG s_LocksInProgress ;
	static LONG s_ObjectsInProgress ;


    CFrameworkProviderClassFactory () ;
    ~CFrameworkProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

#endif // _SNMPPropProvClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\include\trrt.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#define WBEM_CLASS_EXTENDEDSTATUS	L"__ExtendedStatus" 

#define WBEM_TASKSTATE_START					0x0
#define WBEM_TASKSTATE_ASYNCHRONOUSCOMPLETE	0x100000
#define WBEM_TASKSTATE_ASYNCHRONOUSABORT		0x100001

class WbemTaskObject : public SnmpTaskObject
{
private:

	LONG m_ReferenceCount ;

protected:

	ULONG m_State ;
	WbemProviderErrorObject m_ErrorObject ;

	ULONG m_RequestHandle ;
	ULONG m_OperationFlag ;
	IWbemClassObject *m_ClassObject ;
	IWbemObjectSink *m_NotificationHandler ;
	IWbemContext *m_Ctx ;
	CImpFrameworkProv *m_Provider ;

protected:

	void SetRequestHandle ( ULONG a_RequestHandle ) ;
	BOOL GetRequestHandle () ;
	BOOL GetClassObject ( wchar_t *a_Class ) ;
	BOOL GetExtendedNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;
	BOOL GetNotifyStatusObject ( IWbemClassObject **a_NotifyObject ) ;

protected:

	virtual void ProcessComplete () = 0 ;

public:

	WbemTaskObject ( 

		CImpFrameworkProv *a_Provider ,
		IWbemObjectSink *a_NotificationHandler ,
		ULONG a_OperationFlag ,
		IWbemContext *a_Ctx
	) ;

	~WbemTaskObject () ;

	WbemProviderErrorObject &GetErrorObject () ;

    ULONG AddRef () ;
    ULONG Release () ;

} ;

class GetObjectEventObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;

protected:

	void ProcessComplete () ;
	BOOL GetObject ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	GetObjectEventObject ( 

		CImpFrameworkProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~GetObjectEventObject () ;

	void Process () ;
} ;

class GetObjectAsyncEventObject : public GetObjectEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	GetObjectAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~GetObjectAsyncEventObject () ;
} ;

class CreateInstanceEnumEventObject : public WbemTaskObject
{
private:

	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL CreateInstanceEnum ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	CreateInstanceEnumEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_Class , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CreateInstanceEnumEventObject () ;

	void Process () ;
} ;

class CreateInstanceEnumAsyncEventObject : public CreateInstanceEnumEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	CreateInstanceEnumAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_Class , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CreateInstanceEnumAsyncEventObject () ;
} ;

class ExecQueryEventObject : public WbemTaskObject
{
private:

	wchar_t *m_QueryFormat ; 
	wchar_t *m_Query ;
	wchar_t *m_Class ;

	CTextLexSource m_QuerySource ;
	SQL1_Parser m_SqlParser ;
	SQL_LEVEL_1_RPN_EXPRESSION *m_RPNExpression ;

protected:

	void ProcessComplete () ;
	BOOL ExecQuery ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	ExecQueryEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~ExecQueryEventObject () ;

	void Process () ;
} ;

class ExecQueryAsyncEventObject : public ExecQueryEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	ExecQueryAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_QueryFormat , 
		BSTR a_Query , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~ExecQueryAsyncEventObject () ;
} ;

class PutInstanceEventObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_Object ;
	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL PutInstance ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	PutInstanceEventObject ( 
		
		CImpFrameworkProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~PutInstanceEventObject () ;

	void Process () ;
} ;

class PutInstanceAsyncEventObject : public PutInstanceEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	PutInstanceAsyncEventObject ( 
		
		CImpFrameworkProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~PutInstanceAsyncEventObject () ;
} ;

class PutClassEventObject : public WbemTaskObject
{
private:

	IWbemClassObject *m_Object ;
	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL PutClass ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	PutClassEventObject ( 
		
		CImpFrameworkProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~PutClassEventObject () ;

	void Process () ;
} ;

class PutClassAsyncEventObject : public PutClassEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	PutClassAsyncEventObject ( 
		
		CImpFrameworkProv *a_Provider , 
		IWbemClassObject *a_Object , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~PutClassAsyncEventObject () ;
} ;

class CreateClassEnumEventObject : public WbemTaskObject
{
private:

	wchar_t *m_SuperClass ;

protected:

	void ProcessComplete () ;
	BOOL CreateClassEnum ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	CreateClassEnumEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_SuperClass , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CreateClassEnumEventObject () ;

	void Process () ;
} ;

class CreateClassEnumAsyncEventObject : public CreateClassEnumEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	CreateClassEnumAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_SuperClass , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~CreateClassEnumAsyncEventObject () ;
} ;

class DeleteInstanceEventObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;

protected:

	void ProcessComplete () ;
	BOOL DeleteInstance ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	DeleteInstanceEventObject ( 

		CImpFrameworkProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~DeleteInstanceEventObject () ;

	void Process () ;
} ;

class DeleteInstanceAsyncEventObject : public DeleteInstanceEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	DeleteInstanceAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~DeleteInstanceAsyncEventObject () ;
} ;

class DeleteClassEventObject : public WbemTaskObject
{
private:

	wchar_t *m_Class ;

protected:

	void ProcessComplete () ;
	BOOL DeleteClass ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	DeleteClassEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_Class , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~DeleteClassEventObject () ;

	void Process () ;
} ;

class DeleteClassAsyncEventObject : public DeleteClassEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	DeleteClassAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_Class , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx 
	) ;

	~DeleteClassAsyncEventObject () ;
} ;

class ExecMethodEventObject : public WbemTaskObject
{
private:

	wchar_t *m_ObjectPath ; 
	wchar_t *m_MethodName ;

	IWbemClassObject *m_InParameters ;

	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;
	

protected:

	void ProcessComplete () ;
	BOOL ExecMethod ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	ExecMethodEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_ObjectPath,
		BSTR a_MethodName,
		ULONG a_OperationFlag,
		IWbemContext FAR *a_Ctx,
		IWbemClassObject FAR *a_InParameters,
		IWbemObjectSink FAR *a_NotificationHandler
	) ;

	~ExecMethodEventObject () ;

	void Process () ;
} ;

class ExecMethodAsyncEventObject : public ExecMethodEventObject
{
private:
protected:

	void ProcessComplete () ;

public:

	ExecMethodAsyncEventObject ( 

		CImpFrameworkProv *a_Provider , 
		BSTR a_ObjectPath,
		BSTR a_MethodName,
		ULONG a_OperationFlag,
		IWbemContext FAR *a_Ctx,
		IWbemClassObject FAR *a_InParameters,
		IWbemObjectSink FAR *a_NotificationHandler
	) ;

	~ExecMethodAsyncEventObject () ;
} ;

class EventAsyncEventObject : public WbemTaskObject
{
private:
protected:
protected:

	void ProcessComplete () ;
	void Process () ;
	BOOL ProcessEvent ( WbemProviderErrorObject &a_ErrorObject ) ;

public:

	EventAsyncEventObject ( 

		CImpFrameworkProv *a_Provider ,
		IWbemObjectSink* pSink, 
		long lFlags
	) ;

	~EventAsyncEventObject () ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\include\resource.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\include\trrtcomm.h ===
// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#define WBEM_PROPERTY_STATUSCODE   L"StatusCode"
#define WBEM_PROPERTY_PROVIDERSTATUSCODE   L"ProviderStatusCode"
#define WBEM_PROPERTY_PROVIDERSTATUSMESSAGE   L"Description"
#define WBEM_QUERY_LANGUAGE_WQL			L"WQL"

typedef 
enum tag_WBEMPROVIDERSTATUS
{
	WBEM_PROVIDER_NO_ERROR							= 0,
	WBEM_PROVIDER_S_NO_ERROR							= 0,
	WBEM_PROVIDER_S_NO_MORE_DATA						= 0x40001,
	WBEM_PROVIDER_S_ALREADY_EXISTS					= WBEM_PROVIDER_S_NO_MORE_DATA + 1,
	WBEM_PROVIDER_S_NOT_FOUND						= WBEM_PROVIDER_S_ALREADY_EXISTS + 1,
	WBEM_PROVIDER_S_RESET_TO_DEFAULT					= WBEM_PROVIDER_S_NOT_FOUND + 1,
	WBEM_PROVIDER_E_FAILED							= 0x80041001,
	WBEM_PROVIDER_E_NOT_FOUND						= WBEM_PROVIDER_E_FAILED + 1,
	WBEM_PROVIDER_E_ACCESS_DENIED					= WBEM_PROVIDER_E_NOT_FOUND + 1,
	WBEM_PROVIDER_E_PROVIDER_FAILURE					= WBEM_PROVIDER_E_ACCESS_DENIED + 1,
	WBEM_PROVIDER_E_TYPE_MISMATCH					= WBEM_PROVIDER_E_PROVIDER_FAILURE + 1,
	WBEM_PROVIDER_E_OUT_OF_MEMORY					= WBEM_PROVIDER_E_TYPE_MISMATCH + 1,
	WBEM_PROVIDER_E_INVALID_CONTEXT					= WBEM_PROVIDER_E_OUT_OF_MEMORY + 1,
	WBEM_PROVIDER_E_INVALID_PARAMETER				= WBEM_PROVIDER_E_INVALID_CONTEXT + 1,
	WBEM_PROVIDER_E_NOT_AVAILABLE					= WBEM_PROVIDER_E_INVALID_PARAMETER + 1,
	WBEM_PROVIDER_E_CRITICAL_ERROR					= WBEM_PROVIDER_E_NOT_AVAILABLE + 1,
	WBEM_PROVIDER_E_INVALID_STREAM					= WBEM_PROVIDER_E_CRITICAL_ERROR + 1,
	WBEM_PROVIDER_E_NOT_SUPPORTED					= WBEM_PROVIDER_E_INVALID_STREAM + 1,
	WBEM_PROVIDER_E_INVALID_SUPERCLASS				= WBEM_PROVIDER_E_NOT_SUPPORTED + 1,
	WBEM_PROVIDER_E_INVALID_NAMESPACE				= WBEM_PROVIDER_E_INVALID_SUPERCLASS + 1,
	WBEM_PROVIDER_E_INVALID_OBJECT					= WBEM_PROVIDER_E_INVALID_NAMESPACE + 1,
	WBEM_PROVIDER_E_INVALID_CLASS					= WBEM_PROVIDER_E_INVALID_OBJECT + 1,
	WBEM_PROVIDER_E_PROVIDER_NOT_FOUND				= WBEM_PROVIDER_E_INVALID_CLASS + 1,
	WBEM_PROVIDER_E_INVALID_PROVIDER_REGISTRATION	= WBEM_PROVIDER_E_PROVIDER_NOT_FOUND + 1,
	WBEM_PROVIDER_E_PROVIDER_LOAD_FAILURE			= WBEM_PROVIDER_E_INVALID_PROVIDER_REGISTRATION + 1,
	WBEM_PROVIDER_E_INITIALIZATION_FAILURE			= WBEM_PROVIDER_E_PROVIDER_LOAD_FAILURE + 1,
	WBEM_PROVIDER_E_TRANSPORT_FAILURE				= WBEM_PROVIDER_E_INITIALIZATION_FAILURE + 1,
	WBEM_PROVIDER_E_INVALID_OPERATION				= WBEM_PROVIDER_E_TRANSPORT_FAILURE + 1,
	WBEM_PROVIDER_E_INVALID_QUERY					= WBEM_PROVIDER_E_INVALID_OPERATION + 1,
	WBEM_PROVIDER_E_INVALID_QUERY_TYPE				= WBEM_PROVIDER_E_INVALID_QUERY + 1,
	WBEM_PROVIDER_E_ALREADY_EXISTS					= WBEM_PROVIDER_E_INVALID_QUERY_TYPE + 1,
	WBEM_PROVIDER_E_OVERRIDE_NOT_ALLOWED				= WBEM_PROVIDER_E_ALREADY_EXISTS + 1,
	WBEM_PROVIDER_E_PROPAGATED_QUALIFIER				= WBEM_PROVIDER_E_OVERRIDE_NOT_ALLOWED + 1,
	WBEM_PROVIDER_E_UNEXPECTED						= WBEM_PROVIDER_E_PROPAGATED_QUALIFIER + 1,
	WBEM_PROVIDER_E_ILLEGAL_OPERATION				= WBEM_PROVIDER_E_UNEXPECTED + 1,
	WBEM_PROVIDER_E_CANNOT_BE_KEY					= WBEM_PROVIDER_E_ILLEGAL_OPERATION + 1,
	WBEM_PROVIDER_E_INCOMPLETE_CLASS					= WBEM_PROVIDER_E_CANNOT_BE_KEY + 1,
	WBEM_PROVIDER_E_INVALID_SYNTAX					= WBEM_PROVIDER_E_INCOMPLETE_CLASS + 1,
	WBEM_PROVIDER_E_NONDECORATED_OBJECT				= WBEM_PROVIDER_E_INVALID_SYNTAX + 1,
	WBEM_PROVIDER_E_READ_ONLY						= WBEM_PROVIDER_E_NONDECORATED_OBJECT + 1,
	WBEM_PROVIDER_E_PROVIDER_NOT_CAPABLE				= WBEM_PROVIDER_E_READ_ONLY + 1,
	WBEM_PROVIDER_E_CLASS_HAS_CHILDREN				= WBEM_PROVIDER_E_PROVIDER_NOT_CAPABLE + 1,
	WBEM_PROVIDER_E_CLASS_HAS_INSTANCES				= WBEM_PROVIDER_E_CLASS_HAS_CHILDREN + 1 ,

	// Added

	WBEM_PROVIDER_E_INVALID_PROPERTY					= WBEM_PROVIDER_E_CLASS_HAS_INSTANCES + 1 ,
	WBEM_PROVIDER_E_INVALID_QUALIFIER				= WBEM_PROVIDER_E_INVALID_PROPERTY + 1 ,
	WBEM_PROVIDER_E_INVALID_PATH						= WBEM_PROVIDER_E_INVALID_QUALIFIER + 1 ,
	WBEM_PROVIDER_E_INVALID_PATHKEYPARAMETER			= WBEM_PROVIDER_E_INVALID_PATH + 1 ,
	WBEM_PROVIDER_E_MISSINGPATHKEYPARAMETER 			= WBEM_PROVIDER_E_INVALID_PATHKEYPARAMETER + 1 ,	
	WBEM_PROVIDER_E_INVALID_KEYORDERING				= WBEM_PROVIDER_E_MISSINGPATHKEYPARAMETER + 1 ,	
	WBEM_PROVIDER_E_DUPLICATEPATHKEYPARAMETER		= WBEM_PROVIDER_E_INVALID_KEYORDERING + 1 ,
	WBEM_PROVIDER_E_MISSINGKEY						= WBEM_PROVIDER_E_DUPLICATEPATHKEYPARAMETER + 1 ,
	WBEM_PROVIDER_E_INVALID_TRANSPORT				= WBEM_PROVIDER_E_MISSINGKEY + 1 ,
	WBEM_PROVIDER_E_INVALID_TRANSPORTCONTEXT			= WBEM_PROVIDER_E_INVALID_TRANSPORT + 1 ,
	WBEM_PROVIDER_E_TRANSPORT_ERROR					= WBEM_PROVIDER_E_INVALID_TRANSPORTCONTEXT + 1 ,
	WBEM_PROVIDER_E_TRANSPORT_NO_RESPONSE			= WBEM_PROVIDER_E_TRANSPORT_ERROR + 1 ,
	WBEM_PROVIDER_E_NOWRITABLEPROPERTIES				= WBEM_PROVIDER_E_TRANSPORT_NO_RESPONSE + 1 ,
	WBEM_PROVIDER_E_NOREADABLEPROPERTIES				= WBEM_PROVIDER_E_NOWRITABLEPROPERTIES + 1 

} WBEMPROVIDERSTATUS;

#define DllImport	__declspec( dllimport )
#define DllExport	__declspec( dllexport )

#ifdef PROVIDERINIT
#define DllImportExport DllExport
#else
#define DllImportExport DllImport
#endif

DllImportExport wchar_t *DbcsToUnicodeString ( const char *dbcsString ) ;
DllImportExport char *UnicodeToDbcsString ( const wchar_t *unicodeString ) ;
DllImportExport wchar_t *UnicodeStringAppend ( const wchar_t *prefix , const wchar_t *suffix ) ;
DllImportExport wchar_t *UnicodeStringDuplicate ( const wchar_t *string ) ;

class DllImportExport CBString
{
private:

    BSTR    m_pString;

public:

    CBString()
    {
        m_pString = NULL;
    }

    CBString(int nSize);

    CBString(WCHAR* pwszString);

    ~CBString();

    BSTR GetString()
    {
        return m_pString;
    }

    const CBString& operator=(LPWSTR pwszString)
    {
        if(m_pString) 
		{
            SysFreeString(m_pString);
        }
        
		m_pString = SysAllocString(pwszString);

        return *this;
    }
};

#if _MSC_VER >= 1100
template <> DllImportExport UINT AFXAPI HashKey <wchar_t *> ( wchar_t *key ) ;
#else
DllImportExport UINT HashKey ( wchar_t *key ) ;
#endif

#if _MSC_VER >= 1100
typedef wchar_t * HmmHack_wchar_t ;
template<> DllImportExport BOOL AFXAPI CompareElements <wchar_t *, wchar_t * > ( const HmmHack_wchar_t *pElement1, const HmmHack_wchar_t *pElement2 ) ;
#else
DllImportExport BOOL CompareElements ( wchar_t **pElement1, wchar_t **pElement2 ) ;
#endif

union ProviderLexiconValue
{
	LONG signedInteger ;
	ULONG unsignedInteger ;
	wchar_t *token ;
} ;

class ProviderAnalyser;
class DllImportExport ProviderLexicon
{
friend ProviderAnalyser ;
public:

enum LexiconToken {

	TOKEN_ID ,
	SIGNED_INTEGER_ID ,
	UNSIGNED_INTEGER_ID ,
	COLON_ID ,
	COMMA_ID ,
	OPEN_PAREN_ID ,
	CLOSE_PAREN_ID ,
	DOT_ID ,
	DOTDOT_ID ,
	PLUS_ID ,
	MINUS_ID ,
	EOF_ID,
	WHITESPACE_ID,
	INVALID_ID,
	USERDEFINED_ID
} ;

private:

	wchar_t *tokenStream ;
	ULONG position ;
	LexiconToken token ;
	ProviderLexiconValue value ;

protected:
public:

	ProviderLexicon () ;
	~ProviderLexicon () ;

	void SetToken ( ProviderLexicon :: LexiconToken a_Token ) ;
	ProviderLexicon :: LexiconToken GetToken () ;
	ProviderLexiconValue *GetValue () ;
} ;

#define ANALYSER_ACCEPT_STATE 10000
#define ANALYSER_REJECT_STATE 10001

/* 
	User defined states should be greater than 20000
 */

class DllImportExport ProviderAnalyser
{
private:

	wchar_t *stream ;
	ULONG position ;
	BOOL status ;

	ProviderLexicon *GetToken (  BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

protected:

	virtual void Initialise () {} ;

	virtual ProviderLexicon *CreateLexicon () { return new ProviderLexicon ; }

	virtual BOOL Analyse ( 

		ProviderLexicon *lexicon , 
		ULONG &state , 
		const wchar_t token , 
		const wchar_t *tokenStream , 
		ULONG &position , 
		BOOL unSignedIntegersOnly , 
		BOOL leadingIntegerZeros , 
		BOOL eatSpace 
	) 
	{ return FALSE ; }

public:

	ProviderAnalyser ( const wchar_t *tokenStream = NULL ) ;
	virtual ~ProviderAnalyser () ;

	void Set ( const wchar_t *tokenStream ) ;

	ProviderLexicon *Get ( BOOL unSignedIntegersOnly = FALSE , BOOL leadingIntegerZeros = FALSE , BOOL eatSpace = TRUE ) ;

	void PutBack ( const ProviderLexicon *token ) ;

	virtual operator void * () ;

	static BOOL IsEof ( wchar_t token ) ;
	static BOOL IsLeadingDecimal ( wchar_t token ) ;
	static BOOL IsDecimal ( wchar_t token ) ;
	static BOOL IsOctal ( wchar_t token ) ;
	static BOOL IsHex ( wchar_t token ) ;	
	static BOOL IsAlpha ( wchar_t token ) ;
	static BOOL IsAlphaNumeric ( wchar_t token ) ;
	static BOOL IsWhitespace ( wchar_t token ) ;

	static ULONG OctWCharToDecInteger ( wchar_t token ) ;
	static ULONG HexWCharToDecInteger ( wchar_t token ) ;
	static ULONG DecWCharToDecInteger ( wchar_t token ) ;
	static wchar_t DecIntegerToHexWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToDecWChar ( UCHAR integer ) ;
	static wchar_t DecIntegerToOctWChar ( UCHAR integer ) ;

	static ULONG OctCharToDecInteger ( char token ) ;
	static ULONG HexCharToDecInteger ( char token ) ;
	static ULONG DecCharToDecInteger ( char token ) ;
	static char DecIntegerToHexChar ( UCHAR integer ) ;
	static char DecIntegerToDecChar ( UCHAR integer ) ;
	static char DecIntegerToOctChar ( UCHAR integer ) ;

} ;

class __declspec ( dllexport ) WbemProviderErrorObject 
{
private:

	wchar_t *m_ProviderErrorMessage ;
	WBEMPROVIDERSTATUS m_ProviderErrorStatus ;
	WBEMSTATUS m_wbemErrorStatus ;

protected:
public:

	WbemProviderErrorObject () : m_ProviderErrorMessage ( NULL ) , m_wbemErrorStatus ( WBEM_NO_ERROR ) , m_ProviderErrorStatus ( WBEM_PROVIDER_NO_ERROR ) {} ;
	virtual ~WbemProviderErrorObject () { delete [] m_ProviderErrorMessage ; } ;

	void SetStatus ( WBEMPROVIDERSTATUS a_ProviderErrorStatus )
	{
		m_ProviderErrorStatus = a_ProviderErrorStatus ;
	} ;

	void SetWbemStatus ( WBEMSTATUS a_wbemErrorStatus ) 
	{
		m_wbemErrorStatus = a_wbemErrorStatus ;
	} ;

	void SetMessage ( wchar_t *a_ProviderErrorMessage )
	{
		DebugMacro1 ( 

			if ( a_ProviderErrorMessage )
			{
				SnmpDebugLog :: s_SnmpDebugLog->Write ( 

					L"\r\nWbemProviderErrorObject :: SetMessage ( (%s) )" , a_ProviderErrorMessage 
				) ; 
			}
		)

		delete [] m_ProviderErrorMessage ;
		m_ProviderErrorMessage = UnicodeStringDuplicate ( a_ProviderErrorMessage ) ;
	} ;

	wchar_t *GetMessage () { return m_ProviderErrorMessage ; } ;
	WBEMPROVIDERSTATUS GetStatus () { return m_ProviderErrorStatus ; } ;
	WBEMSTATUS GetWbemStatus () { return m_wbemErrorStatus ; } ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\clasprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpClasProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>
#include <typeinfo.h>
#include <wbemidl.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include <correlat.h>
#include <genlex.h>
#include <objpath.h>
#include <cominit.h>

#include "classfac.h"
#include "clasprov.h"
#include "creclass.h"
#include "guids.h"

extern void ProviderStartup () ;
extern void ProviderClosedown () ;

BOOL CImpClasProv :: s_Initialised = FALSE ;

void SnmpClassDefaultThreadObject::Initialise ()
{
	InitializeCom () ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpClasProv::CImpClasProv
// CImpClasProv::~CImpClasProv
//
//***************************************************************************

CImpClasProv::CImpClasProv ()
:	ipAddressString ( NULL ) ,	
	parentServer ( NULL ) ,
	server ( NULL ) ,
	m_InitSink ( NULL ) ,
	propertyProvider ( NULL ) ,
	m_notificationClassObject ( NULL ) ,
	m_snmpNotificationClassObject ( NULL ) ,
	thisNamespace ( NULL )
{
	m_referenceCount = 0 ; 

/* 
 * Place code in critical section
 */

    InterlockedIncrement ( & CClasProvClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

	initialised = FALSE ;
	ipAddressValue = NULL ;	
	m_getNotifyCalled = FALSE ;
	m_getSnmpNotifyCalled = FALSE ;
}

CImpClasProv::~CImpClasProv(void)
{

/*
 * Implementation
 */

	delete [] ipAddressString ;
	free ( ipAddressValue ) ;
 
	if ( parentServer )
		parentServer->Release () ;

	if ( server )
		server->Release () ;

	if ( m_InitSink )
		m_InitSink->Release () ;

	if ( propertyProvider )
		propertyProvider->Release () ;

	if ( m_notificationClassObject )
		m_notificationClassObject->Release () ;

	if ( m_snmpNotificationClassObject )
		m_snmpNotificationClassObject->Release () ;

	delete [] thisNamespace ;
/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CClasProvClassFactory :: objectsInProgress ) ;

}


//***************************************************************************
//
// CImpClasProv::QueryInterface
// CImpClasProv::AddRef
// CImpClasProv::Release
//
// Purpose: IUnknown members for CImpClasProv object.
//***************************************************************************

STDMETHODIMP CImpClasProv::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
		}	
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
		}

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}	
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

STDMETHODIMP_(ULONG) CImpClasProv::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( & m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CImpClasProv::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

HRESULT CImpClasProv :: SetServer ( IWbemServices *serverArg ) 
{
	server = serverArg ;
	server->AddRef () ;
	
	//don't change anything but the cloaking...
	return WbemSetProxyBlanket(server,
					RPC_C_AUTHN_DEFAULT,
					RPC_C_AUTHZ_DEFAULT,
					COLE_DEFAULT_PRINCIPAL,
					RPC_C_AUTHN_LEVEL_DEFAULT,
					RPC_C_IMP_LEVEL_DEFAULT,
					NULL,
					EOAC_DYNAMIC_CLOAKING);
}

HRESULT CImpClasProv :: SetParentServer ( IWbemServices *parentServerArg ) 
{
	parentServer = parentServerArg ; 
	parentServer->AddRef () ;
	
	//don't change anything but the cloaking...
	return WbemSetProxyBlanket(parentServer,
					RPC_C_AUTHN_DEFAULT,
					RPC_C_AUTHZ_DEFAULT,
					COLE_DEFAULT_PRINCIPAL,
					RPC_C_AUTHN_LEVEL_DEFAULT,
					RPC_C_IMP_LEVEL_DEFAULT,
					NULL,
					EOAC_DYNAMIC_CLOAKING);
}

void CImpClasProv :: SetProvider ( IWbemServices *provider ) 
{ 
	propertyProvider = provider ; 
}

IWbemServices *CImpClasProv :: GetParentServer () 
{ 
	return ( IWbemServices * ) parentServer ; 
}

IWbemServices *CImpClasProv :: GetServer () 
{ 
	return ( IWbemServices * ) server ; 
}

WbemNamespacePath *CImpClasProv :: GetNamespacePath () 
{ 
	return & namespacePath ; 
}

IWbemClassObject *CImpClasProv :: GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_notificationClassObject )
	{
		m_notificationClassObject->AddRef () ;
	}

	return m_notificationClassObject ; 
}

IWbemClassObject *CImpClasProv :: GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_snmpNotificationClassObject )
	{
		m_snmpNotificationClassObject->AddRef () ;
	}

	return m_snmpNotificationClassObject ; 
}

wchar_t *CImpClasProv :: GetThisNamespace () 
{
	return thisNamespace ; 
}

void CImpClasProv :: SetThisNamespace ( wchar_t *thisNamespaceArg ) 
{
	thisNamespace = UnicodeStringDuplicate ( thisNamespaceArg ) ; 
}

BOOL CImpClasProv:: FetchSnmpNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
	
)
{
	m_snmpNotificationLock.Lock();
	BOOL status = TRUE ;

	if ( m_getSnmpNotifyCalled )
	{
		if ( ! m_snmpNotificationClassObject )
			status = FALSE ;
	}
	else
	{
		m_getSnmpNotifyCalled = TRUE ;
		IWbemClassObject *classObject = NULL ;
		ISmirInterrogator *smirInterrogator = NULL ;

		HRESULT result = CoCreateInstance (
 
			CLSID_SMIR_Database ,
			NULL ,
			CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
			IID_ISMIR_Interrogative ,
			( void ** ) &smirInterrogator 
		);

		if ( SUCCEEDED ( result ) )
		{
			ISMIRWbemConfiguration *smirConfiguration = NULL ;
			result = smirInterrogator->QueryInterface ( IID_ISMIRWbemConfiguration , ( void ** ) & smirConfiguration ) ;
			if ( SUCCEEDED ( result ) )
			{
				smirConfiguration->SetContext ( a_Ctx) ;
				smirConfiguration->Release () ;

				result = smirInterrogator->GetWBEMClass ( &m_snmpNotificationClassObject , WBEM_CLASS_SNMPNOTIFYSTATUS ) ;	
				if ( ! SUCCEEDED ( result ) )
				{
					status = FALSE ;

					m_snmpNotificationClassObject = NULL ;
				}
			}
			else
			{		
				status = FALSE ;

				m_snmpNotificationClassObject = NULL ;
			}

			smirInterrogator->Release () ;
		}
	}

	m_snmpNotificationLock.Unlock();
	return status ;
}

BOOL CImpClasProv:: FetchNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
)
{
	m_notificationLock.Lock();
	BOOL status = TRUE ;

	if ( m_getNotifyCalled )
	{
		if ( ! m_notificationClassObject )
			status = FALSE ;
	}
	else
	{
		m_getNotifyCalled = TRUE ;

		BSTR t_Class = SysAllocString ( WBEM_CLASS_EXTENDEDSTATUS ) ;

		HRESULT result = server->GetObject (

			t_Class ,
			0 ,
			a_Ctx ,
			& m_notificationClassObject ,
			NULL
		) ;

		SysFreeString ( t_Class ) ;

		if ( ! SUCCEEDED ( result ) )
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
		}
	}

	m_notificationLock.Unlock();
	return status ;
}

BOOL CImpClasProv::AttachParentServer ( 

	WbemSnmpErrorObject &a_errorObject , 
	BSTR ObjectPath, 
	IWbemContext *pCtx
)
{
DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpClasProv::AttachParentServer ( (%s) )" ,
		ObjectPath
	) ;
)

	BOOL status = TRUE ;

	IWbemLocator *locator = NULL ;
	IWbemServices *t_server = NULL ;

// Get Parent Namespace Path

	WbemNamespacePath *namespacePath = GetNamespacePath () ;

	ULONG count = namespacePath->GetCount () ;
	wchar_t *path = NULL ;

	if ( namespacePath->GetServer () )
	{
		path = UnicodeStringDuplicate ( L"\\\\" ) ;
		wchar_t *concatPath = UnicodeStringAppend ( path , namespacePath->GetServer () ) ;
		delete [] path ;
		path = concatPath ;
	}

	if ( ! namespacePath->Relative () )
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , L"\\" ) ;
		delete [] path ;
		path = concatPath ;
	}

	ULONG pathIndex = 0 ;		
	wchar_t *pathComponent ;
	namespacePath->Reset () ;
	while ( ( pathIndex < count - 1 ) && ( pathComponent = namespacePath->Next () ) ) 
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , pathComponent ) ;
		delete [] path ;
		path = concatPath ;
		if ( pathIndex < count - 2 )
		{
			concatPath = UnicodeStringAppend ( path , L"\\" ) ;
			delete [] path ;
			path = concatPath ;
		}

		pathIndex ++ ;
	}

	if ( pathComponent = namespacePath->Next () )
	{
		SetThisNamespace ( pathComponent ) ; 
	}

DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Calling ConnectServer ( (%s) )" ,
		path
	) ;
)

// Connect to parent namespace
	
	HRESULT result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemLocator ,
		( void ** )  & locator
	);
	if ( SUCCEEDED ( result ) )
	{
		result = locator->ConnectServer (

			path ,
			NULL ,
			NULL ,
			NULL  ,
			0 ,
			NULL,
			pCtx,
			( IWbemServices ** ) & t_server 
		) ;

		if ( SUCCEEDED ( result ) )
		{
			result = SetParentServer ( t_server ) ;
			t_server->Release();

			if ( FAILED ( result ) && result != E_NOINTERFACE ) //implies there is no prxy security - inproc.
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				a_errorObject.SetMessage ( L"Failed to secure proxy to this namespace's parent namespace" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetMessage ( L"Failed to connect to this namespace's parent namespace" ) ;
		}

		locator->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
		a_errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemLocator" ) ;
	}

	delete [] path ;

DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpClasProv::AttachParentServer ( (%s) ) with result" ,
		ObjectPath ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

BOOL CImpClasProv::ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro0( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpClasProv::ObtainCachedIpAddress ()"
	) ;
)

	BOOL status = TRUE ;

	IWbemClassObject *namespaceObject = NULL ;

	wchar_t *objectPathPrefix = UnicodeStringAppend ( WBEM_NAMESPACE_EQUALS , GetThisNamespace () ) ;
	wchar_t *objectPath = UnicodeStringAppend ( objectPathPrefix , WBEM_NAMESPACE_QUOTE ) ;

	delete [] objectPathPrefix ;

	BSTR t_Path = SysAllocString ( objectPath ) ;

	HRESULT result = parentServer->GetObject ( 

		t_Path ,		
		0 ,
		NULL ,
		&namespaceObject ,
		NULL
	) ;

	SysFreeString(t_Path);

	delete [] objectPath ;

	if ( SUCCEEDED ( result ) )
	{
		IWbemQualifierSet *classQualifierObject ;
		result = namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
		if ( SUCCEEDED ( result ) )
		{

			VARIANT variant ;
			VariantInit ( & variant ) ;

			LONG attributeType ;
			result = classQualifierObject->Get ( 

				WBEM_QUALIFIER_AGENTTRANSPORT , 
				0,	
				&variant ,
				& attributeType 
			) ;

			if ( SUCCEEDED ( result ) )
			{
				if ( variant.vt == VT_BSTR ) 
				{
					if ( _wcsicmp ( variant.bstrVal , L"IP" ) == 0 )
					{
						VARIANT variant ;
						VariantInit ( & variant ) ;

						LONG attributeType ;
						result = classQualifierObject->Get ( 

							WBEM_QUALIFIER_AGENTADDRESS , 
							0,	
							&variant ,
							& attributeType 
						) ;

						if ( SUCCEEDED ( result ) )
						{
							if ( variant.vt == VT_BSTR ) 
							{
								ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
								if ( ipAddressString )
								{						

									SnmpTransportIpAddress transportAddress ( 
			
										ipAddressString , 
										SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
									) ;

									if ( transportAddress () )
									{	
										ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
									}
									else
									{
										delete [] ipAddressString ;
										ipAddressString = NULL ;

	/*
	 *	Invalid Transport Address.
	 */

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
									}
 								}
								else
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
							}
						}
						else
						{
/*
 *	Transport Address not specified, ignore it
 */
						}

						VariantClear ( &variant ) ;
					}
					else if ( _wcsicmp ( variant.bstrVal , L"IPX" ) == 0 )
					{
					}
					else
					{
// Unknown transport type

						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}
				}
				else
				{
/*
 *	Transport qualifier was not a string value
 */

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
				}
			}
			else
			{
				LONG attributeType ;
				result = classQualifierObject->Get ( 

					WBEM_QUALIFIER_AGENTADDRESS , 
					0,	
					&variant ,
					& attributeType
				) ;

				if ( SUCCEEDED ( result ) )
				{
					if ( variant.vt == VT_BSTR ) 
					{
						ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
						if ( ipAddressString )
						{
							SnmpTransportIpAddress transportAddress ( 

								ipAddressString , 
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
							) ;

							if ( transportAddress () )
							{	
								ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
							}
							else
							{
								delete [] ipAddressString ;
								ipAddressString = NULL ;

	/*
	 *	Invalid Transport Address.
	 */

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;

						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
					}
				}
				else
				{
/*
 *	Transport Address not specified, ignore it
 */
				}

				VariantClear ( &variant ) ;
			}

			VariantClear ( & variant );
		}

		namespaceObject->Release () ;
	}

DebugMacro0( 

	wchar_t *t_UnicodeString = ipAddressValue ? DbcsToUnicodeString ( ipAddressValue ) : NULL ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpClasProv::ObtainCachedIpAddress () with IP Address (%s)",
		t_UnicodeString ? t_UnicodeString : L"NULL"
	) ;

	delete [] t_UnicodeString ;
)

	return status ;
}


HRESULT STDMETHODCALLTYPE CImpClasProv::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro0( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpClasProv::GetObjectAsync ( (%s) )" ,
			ObjectPath
		) ;
)

		if (SUCCEEDED(result))
		{
			WbemSnmpErrorObject errorObject ;

			ParsedObjectPath *t_ParsedObjectPath = NULL ;
			CObjectPathParser t_ObjectPathParser ;

			BOOL status = t_ObjectPathParser.Parse ( ObjectPath , &t_ParsedObjectPath ) ;
			if ( status == 0 )
			{
			// Class requested

				wchar_t *Class = t_ParsedObjectPath->m_pClass ;

	/*
	 * Create Asynchronous Class object
	 */

				SnmpClassGetAsyncEventObject aSyncEvent ( this , Class, pHandler , pCtx ) ;

				aSyncEvent.Process () ;

				aSyncEvent.Wait ( TRUE ) ;

				status = TRUE ;

				errorObject.SetStatus ( WBEM_SNMP_NO_ERROR ) ;
				errorObject.SetWbemStatus ( WBEM_NO_ERROR ) ;
				errorObject.SetMessage ( L"" ) ;

				delete t_ParsedObjectPath ;
			}
				else
			{
	// Parse Failure

				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
				errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				errorObject.SetMessage ( L"Failed to parse object path" ) ;
			}

	// Check validity of server/namespace path and validity of request

			result = errorObject.GetWbemStatus () ;
			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro0( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpClasProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
			ObjectPath ,
			result 
		) ;
)

 
		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpClasProv :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

 HRESULT CImpClasProv :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

SCODE CImpClasProv :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro0( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpClasProv::CreateClassEnumAsync ( (%s) )" ,
			Superclass
		) ;
	)

		if (SUCCEEDED(result))
		{
		/*
		 * Create Synchronous Enum Instance object
		 */

			SnmpClassEnumAsyncEventObject aSyncEvent ( this , Superclass, lFlags , pHandler , pCtx ) ;

			aSyncEvent.Process () ;

		/*`
		 *	Wait for worker object to complete processing
		 */

			aSyncEvent.Wait ( TRUE ) ;


			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro0( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning From CImpClasProv::CreateClassEnumAsync ( (%s) ) with Result = (%lx)" ,
			Superclass ,
			result
		) ;
)

		return result ;
	
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpClasProv :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpClasProv :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CreateInstanceEnum ( 

	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: CreateInstanceEnumAsync (

 	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_NOT_AVAILABLE ;
}
        
HRESULT CImpClasProv :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_NOT_AVAILABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpClasProv :: ExecMethod( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT STDMETHODCALLTYPE CImpClasProv :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
	return WBEM_E_NOT_AVAILABLE ;
}

HRESULT CImpClasProv :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient(); //cimom is the client - LocalSystem

		if (SUCCEEDED(result))
		{
			EnterCriticalSection ( & s_ProviderCriticalSection ) ;
			namespacePath.SetNamespacePath ( pszNamespace ) ;

			BOOL status = TRUE ;

			if ( ! CImpClasProv :: s_Initialised )
			{
				ProviderStartup () ;

				SnmpThreadObject :: Startup () ;
				SnmpDebugLog :: Startup () ;

				status = SnmpClassLibrary :: Startup () ;
				if ( status == FALSE )
				{
					SnmpThreadObject :: Closedown () ;
					SnmpDebugLog :: Closedown () ;

					ProviderClosedown () ;

				}
				else
				{
					CImpClasProv :: s_Initialised = TRUE ;
				}
			}

			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;

			WbemSnmpErrorObject errorObject ;
			result = SetServer(pCIMOM) ;

			if ( FAILED ( result ) && result != E_NOINTERFACE ) //implies there is no prxy security - inproc.
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				errorObject.SetMessage ( L"Failed to secure proxy to this namespace" ) ;
			}

			wchar_t *t_ObjectPath = namespacePath.GetNamespacePath () ;

			BSTR t_Path = SysAllocString ( t_ObjectPath ) ;

			status = AttachParentServer ( 

				errorObject , 
				t_Path ,
				pCtx 
			) ;

			SysFreeString ( t_Path ) ;

			delete [] t_ObjectPath ;

			if ( status )
			{
				ObtainCachedIpAddress ( errorObject ) ;
			}
			else
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemServices" ) ;
			}

			status = FetchSnmpNotificationObject ( errorObject , pCtx ) ;
			status = FetchNotificationObject ( errorObject , pCtx ) ;

			//doing this here hangs cimom so delay until classes are asked for
#ifdef CORRELATOR_INIT
			//prime the correlator....
			if (status)
			{
				ISmirInterrogator *t_Interrogator = NULL;
				HRESULT result = CoCreateInstance (
 
					CLSID_SMIR_Database ,
					NULL ,
					CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
					IID_ISMIR_Interrogative ,
					( void ** ) &t_Interrogator 
				);

				if ( SUCCEEDED ( result ) )
				{
					ISMIRWbemConfiguration *smirConfiguration = NULL ;
					result = t_Interrogator->QueryInterface ( IID_ISMIRWbemConfiguration , ( void ** ) & smirConfiguration ) ;
					if ( SUCCEEDED ( result ) )
					{
						smirConfiguration->SetContext ( pCtx ) ;
						CCorrelator::StartUp(t_Interrogator);
						smirConfiguration->Release () ;
					}
					else
					{
						errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
						errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
						errorObject.SetMessage ( L"QueryInterface on ISmirInterrogator Failed" ) ;
					}

					t_Interrogator->Release();
				}
				else
				{
					errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
					errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
					errorObject.SetMessage ( L"CoCreateInstance on ISmirInterrogator Failed" ) ;
				}

			}
#endif //CORRELATOR_INIT

			result = errorObject.GetWbemStatus () ;

			pInitSink->SetStatus ( (result == WBEM_NO_ERROR) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning From CImpClasProv::Initialize with Result = (%lx)" ,
			result
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\cormap.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <cormap.h>
#include <cordefs.h>


void CCorrelatorMap::Register(CCorrelator *key)
{
	m_MapLock.Lock();
	SetAt((DWORD_PTR)key,key);
	m_MapLock.Unlock();
}


void CCorrelatorMap::UnRegister(CCorrelator *key)
{
	m_MapLock.Lock();
	RemoveKey((DWORD_PTR)key);
	m_MapLock.Unlock();
}


CCorrelatorMap::~CCorrelatorMap()
{
	m_MapLock.Lock();

	if (!IsEmpty())
	{
		POSITION pos = GetStartPosition();

		while(NULL != pos)
		{
			CCorrelator* ccorr;
			DWORD_PTR key;
			GetNextAssoc(pos, key, ccorr);
			ccorr->CancelRequest();
		}

		RemoveAll();
	}

	m_MapLock.Unlock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\framework\include\trrtprov.h ===
//***************************************************************************

//

//  PropertyProvider.H

//

//  Module: 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPPropertyProvider_H_
#define _SNMPPropertyProvider_H_

extern CRITICAL_SECTION s_CriticalSection ;

class DefaultThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	DefaultThreadObject ( const char *a_ThreadName = NULL ) : SnmpThreadObject ( a_ThreadName ) {} ;
	~DefaultThreadObject () {} ;

	void Initialise () { CoInitialize ( NULL ) ; }
	void Uninitialise () { CoUninitialize () ; }

} ;

class CImpFrameworkProv : public IWbemServices , public IWbemEventProvider , public IWbemHiPerfProvider , public IWbemProviderInit
{
private:

	BOOL m_Initialised ;
	LONG m_ReferenceCount ;         //Object reference count

	CCriticalSection m_CriticalSection ;

	WbemNamespacePath m_NamespacePath ;
	wchar_t *m_Namespace ;

	IWbemServices *m_Server ;

	wchar_t *m_localeId ;

	BOOL m_GetNotifyCalled ;
	BOOL m_GetExtendedNotifyCalled ;
	IWbemClassObject *m_NotificationClassObject ;
	IWbemClassObject *m_ExtendedNotificationClassObject ;

protected:
public:

	CImpFrameworkProv () ;
    ~CImpFrameworkProv () ;

	static DefaultThreadObject *s_DefaultThreadObject ;

	// Implementation

	IWbemServices *GetServer () ;
	void SetServer ( IWbemServices *a_Server ) ;

	WbemNamespacePath *GetNamespacePath () { return & m_NamespacePath ; }

	wchar_t *GetNamespace () ;
	void SetNamespace ( wchar_t *a_Namespace ) ;

	void SetLocaleId ( wchar_t *a_localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	BOOL CreateNotificationObject ( 

		WbemProviderErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	BOOL CreateExtendedNotificationObject ( 

		WbemProviderErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	IWbemClassObject *GetNotificationObject ( WbemProviderErrorObject &a_errorObject , IWbemContext *a_Ctx ) ;
	IWbemClassObject *GetExtendedNotificationObject ( WbemProviderErrorObject &a_errorObject , IWbemContext *a_Ctx ) ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

    HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ BSTR QueryLanguage,
        /* [in] */ BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

    HRESULT STDMETHODCALLTYPE ExecMethod( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ BSTR MethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    
    HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
        /* [in] */ BSTR ObjectPath,
        /* [in] */ BSTR MethodName,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	STDMETHODIMP ProvideForNamespace (

		wchar_t* wszNamespaceName ,
		IWbemServices* pNamespace ,
		IWbemObjectSink* pSink, 
		wchar_t* wszLocale, 
		long lFlags
	) ;

    STDMETHODIMP ProvideEvents (

		IWbemObjectSink* pSink,
        LONG lFlags
    ) ;

    // IWbemHiPerfProvider methods.
    // ============================
            
        virtual HRESULT STDMETHODCALLTYPE QueryInstances( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ WCHAR __RPC_FAR *wszClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefresher( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ long lFlags,
            /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefreshableObject( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [out] */ long __RPC_FAR *plId
            );
        
        virtual HRESULT STDMETHODCALLTYPE StopRefreshing( 
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lId,
            /* [in] */ long lFlags
            );


/* IWbemProviderInit methods */

	HRESULT STDMETHODCALLTYPE Initialize (
		/* [in] */ LPWSTR pszUser,
		/* [in] */ LONG lFlags,
		/* [in] */ LPWSTR pszNamespace,
		/* [in] */ LPWSTR pszLocale,
		/* [in] */ IWbemServices *pCIMOM,         // For anybody
		/* [in] */ IWbemContext *pCtx,
		/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
	);
} ;

class CImpRefresher : public IWbemRefresher
{
private:

    LONG m_referenceCount;

public:

    CImpRefresher();
   ~CImpRefresher();

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    HRESULT STDMETHODCALLTYPE Refresh(/* [in] */ long lFlags);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\classfac.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <snmpcont.h>
#include <instpath.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include <classfac.h>
#include "clasprov.h"
#include "propprov.h"
#include "guids.h"

#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>


LONG CClasProvClassFactory :: objectsInProgress = 0 ;
LONG CClasProvClassFactory :: locksInProgress = 0 ;

LONG CPropProvClassFactory :: objectsInProgress = 0 ;
LONG CPropProvClassFactory :: locksInProgress = 0 ;

LONG CSNMPEventProviderClassFactory :: objectsInProgress = 0 ;
LONG CSNMPEventProviderClassFactory :: locksInProgress = 0 ;

extern CEventProviderThread* g_pProvThrd;
extern CEventProviderWorkerThread* g_pWorkerThread;
extern CRITICAL_SECTION s_ProviderCriticalSection ;

//***************************************************************************
//
// CClasProvClassFactory::CClasProvClassFactory
// CClasProvClassFactory::~CClasProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CClasProvClassFactory :: CClasProvClassFactory ()
{
	InterlockedIncrement ( & objectsInProgress ) ;
	m_referenceCount = 0 ;
}

CClasProvClassFactory::~CClasProvClassFactory ()
{
	InterlockedDecrement ( & objectsInProgress ) ;
}

//***************************************************************************
//
// CClasProvClassFactory::QueryInterface
// CClasProvClassFactory::AddRef
// CClasProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CClasProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP_( ULONG ) CClasProvClassFactory :: AddRef ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( & m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CClasProvClassFactory :: Release ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

//***************************************************************************
//
// CClasProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CClasProvClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT status = S_OK ;

		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION ;
		}
		else
		{
			IWbemServices *lpunk = ( IWbemServices * ) new CImpClasProv ;
			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
				else
				{
				}
			}			
		}

		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
}

//***************************************************************************
//
// CClasProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CClasProvClassFactory :: LockServer ( BOOL fLock )
{
	SetStructuredExceptionHandler seh;

	try
	{
	/* 
	 * Place code in critical section
	 */

		if ( fLock )
		{
			InterlockedIncrement ( & locksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & locksInProgress ) ;
		}

		return S_OK	;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CPropProvClassFactory::CPropProvClassFactory
// CPropProvClassFactory::~CPropProvClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CPropProvClassFactory :: CPropProvClassFactory ()
{
	InterlockedIncrement ( & objectsInProgress ) ;
	m_referenceCount = 0 ;
}

CPropProvClassFactory::~CPropProvClassFactory ()
{
	InterlockedDecrement ( & objectsInProgress ) ;
}

//***************************************************************************
//
// CPropProvClassFactory::QueryInterface
// CPropProvClassFactory::AddRef
// CPropProvClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CPropProvClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP_( ULONG ) CPropProvClassFactory :: AddRef ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		return InterlockedIncrement ( & m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CPropProvClassFactory :: Release ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

//***************************************************************************
//
// CPropProvClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CPropProvClassFactory :: CreateInstance (

	LPUNKNOWN pUnkOuter ,
	REFIID riid ,
	LPVOID FAR * ppvObject
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT status = S_OK ;

		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION ;
		}
		else
		{
			IWbemServices *lpunk = ( IWbemServices * ) new CImpPropProv ;
			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppvObject ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;
				}
				else
				{
				}
			}			
		}

		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CPropProvClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CPropProvClassFactory :: LockServer ( BOOL fLock )
{
	SetStructuredExceptionHandler seh;

	try
	{
/* 
 * Place code in critical section
 */

		if ( fLock )
		{
			InterlockedIncrement ( & locksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & locksInProgress ) ;
		}

		return S_OK	;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CSNMPEventProviderClassFactory::CSNMPEventProviderClassFactory
// CSNMPEventProviderClassFactory::~CSNMPEventProviderClassFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CSNMPEventProviderClassFactory :: CSNMPEventProviderClassFactory ()
{
	m_referenceCount = 0 ;
}

CSNMPEventProviderClassFactory::~CSNMPEventProviderClassFactory ()
{
}

//***************************************************************************
//
// CSNMPEventProviderClassFactory::QueryInterface
// CSNMPEventProviderClassFactory::AddRef
// CSNMPEventProviderClassFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************

STDMETHODIMP CSNMPEventProviderClassFactory::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) this ;
		}
		else if ( iid == IID_IClassFactory )
		{
			*iplpv = ( LPVOID ) this ;		
		}	

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return ResultFromScode ( S_OK ) ;
		}
		else
		{
			return ResultFromScode ( E_NOINTERFACE ) ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}


STDMETHODIMP_( ULONG ) CSNMPEventProviderClassFactory :: AddRef ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		InterlockedIncrement(&objectsInProgress);
		return InterlockedIncrement ( &m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CSNMPEventProviderClassFactory :: Release ()
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;

		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			InterlockedDecrement(&objectsInProgress);
			return 0 ;
		}
		else
		{
			InterlockedDecrement(&objectsInProgress);
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

//***************************************************************************
//
// CSNMPEventProviderClassFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CSNMPEventProviderClassFactory :: LockServer ( BOOL fLock )
{
	SetStructuredExceptionHandler seh;

	try
	{
		if ( fLock )
		{
			InterlockedIncrement ( & locksInProgress ) ;
		}
		else
		{
			InterlockedDecrement ( & locksInProgress ) ;
		}

		return S_OK	;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CSNMPEncapEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSNMPEncapEventProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
																REFIID riid,
																LPVOID FAR * ppvObject
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT status = E_FAIL;

		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION;
		}
		else 
		{
			EnterCriticalSection ( & s_ProviderCriticalSection ) ;

			if (NULL == g_pProvThrd)
			{
				SnmpThreadObject :: Startup () ;
				SnmpDebugLog :: Startup () ;
				SnmpClassLibrary :: Startup () ;

				g_pWorkerThread = new CEventProviderWorkerThread;
				g_pWorkerThread->BeginThread();
				g_pWorkerThread->WaitForStartup();
				g_pWorkerThread->CreateServerWrap () ;
				g_pProvThrd = new CEventProviderThread;
			}

			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;

			CTrapEventProvider* prov =  new CTrapEventProvider(CMapToEvent::EMappingType::ENCAPSULATED_MAPPER, g_pProvThrd);
			status = prov->QueryInterface (riid, ppvObject);

			if (NOERROR != status)
			{
				delete prov;
			}
		}

		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// CSNMPRefEventProviderClassFactory::CreateInstance
//
// Purpose: Instantiates a Provider object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CSNMPRefEventProviderClassFactory :: CreateInstance(LPUNKNOWN pUnkOuter ,
																REFIID riid,
																LPVOID FAR * ppvObject
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT status = E_FAIL;

		if ( pUnkOuter )
		{
			status = CLASS_E_NOAGGREGATION;
		}
		else 
		{
			EnterCriticalSection ( & s_ProviderCriticalSection ) ;

			if (NULL == g_pProvThrd)
			{
				SnmpThreadObject :: Startup () ;
				SnmpDebugLog :: Startup () ;
				SnmpClassLibrary :: Startup () ;

				g_pWorkerThread = new CEventProviderWorkerThread;
				g_pWorkerThread->BeginThread();
				g_pWorkerThread->WaitForStartup();
				g_pWorkerThread->CreateServerWrap () ;
				g_pProvThrd = new CEventProviderThread;
			}

			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;

			CTrapEventProvider* prov =  new CTrapEventProvider(CMapToEvent::EMappingType::REFERENT_MAPPER, g_pProvThrd);
			status = prov->QueryInterface (riid, ppvObject);

			if (NOERROR != status)
			{
				delete prov;
			}
		}

		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\corrsnmp.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>

#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <cordefs.h>
#include <snmplog.h>


CCorrResult::CCorrResult() : m_report(Snmp_Success, Snmp_No_Error),
							m_In(NULL, 0),
							m_Out()
{
}


CCorrResult::~CCorrResult()
{
}


void CCorrResult::DebugOutputSNMPResult() const
{
	CCorrObjectID in;
	in.Set((UINT*)m_In.GetValue(), m_In.GetValueLength());
	CString debugstr;
	in.GetString(debugstr);
	debugstr += L"\t\t:\t\t";

	if (Snmp_Success == m_report.GetError())
	{
		CString tmp;
		m_Out.GetString(tmp);
		debugstr += tmp;
	}
	else
	{
		switch(m_report.GetStatus())
		{
			case Snmp_Gen_Error:
			{
				debugstr += L"Snmp_Gen_Error";
			}
			break;

			case Snmp_Local_Error:
			{
				debugstr += L"Snmp_Local_Error";
			}
			break;

			case Snmp_General_Abort:
			{
				debugstr += L"Snmp_General_Abort";
			}
			break;

			case Snmp_No_Response:
			{
				debugstr += L"Snmp_No_Response";
			}
			break;

			case Snmp_Too_Big:
			{
				debugstr += L"Snmp_Too_Big";
			}
			break;

			case Snmp_Bad_Value:
			{
				debugstr += L"Snmp_Bad_Value";
			}
			break;

			case Snmp_Read_Only:
			{
				debugstr += L"Snmp_Read_Only";
			}
			break;

			case Snmp_No_Access:
			{
				debugstr += L"Snmp_No_Access";
			}
			break;

			case Snmp_Wrong_Type:
			{
				debugstr += L"Snmp_Wrong_Type";
			}
			break;

			case Snmp_Wrong_Length:
			{
				debugstr += L"Snmp_Wrong_Length";
			}
			break;

			case Snmp_Wrong_Encoding:
			{
				debugstr += L"Snmp_Wrong_Encoding";
			}
			break;

			case Snmp_Wrong_Value:
			{
				debugstr += L"Snmp_Wrong_Value";
			}
			break;

			case Snmp_No_Creation:
			{
				debugstr += L"Snmp_No_Creation";
			}
			break;

			case Snmp_Inconsistent_Value:
			{
				debugstr += L"Snmp_Inconsistent_Value";
			}
			break;

			case Snmp_Resource_Unavailable:
			{
				debugstr += L"Snmp_Resource_Unavailable";
			}
			break;

			case Snmp_Commit_Failed:
			{
				debugstr += L"Snmp_Commit_Failed";
			}
			break;

			case Snmp_Undo_Failed:
			{
				debugstr += L"Snmp_Undo_Failed";
			}
			break;

			case Snmp_Authorization_Error:
			{
				debugstr += L"Snmp_Authorization_Error";
			}
			break;

			case Snmp_Not_Writable:
			{
				debugstr += L"Snmp_Not_Writable";
			}
			break;

			case Snmp_Inconsistent_Name:
			{
				debugstr += L"Snmp_Inconsistent_Name";
			}
			break;

			case Snmp_No_Such_Name:
			{
				debugstr += L"Snmp_No_Such_Name - Finished successfully!!";
			}
			break;


			default:
			{
				debugstr += L"Unexpected SNMP Error returned";
			}
			break;
		}
	}
	debugstr += L'\n';
DebugMacro6( 
	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		debugstr);
)
}

char *CCorrNextId::GetString(IN const SnmpObjectIdentifier &id)
{
   UINT length = id.GetValueLength();

   if (0 == length)
	   return NULL;

   ULONG *value = id.GetValue();

   UINT allocated_bytes = length*BYTES_PER_FIELD;
   char *str = new char[allocated_bytes];

   ostrstream output_stream(str, allocated_bytes);

   if ( !output_stream.good() )
	  return NULL;

   output_stream << (ULONG)value[0];

   for(UINT index=1; 
	   (output_stream.good()) && (index < length); 
	   index++)
	   output_stream << FIELD_SEPARATOR << (ULONG)value[index];

   if ( !output_stream.good() )
      return NULL;

   // end of string
   output_stream << (char)EOS;

   return str;
}

void CCorrNextId::ReceiveResponse()
{
DebugMacro6(
	for (UINT x = 0; x < m_ResultsCnt; x++)
	{
		m_Results[x].DebugOutputSNMPResult();
	}
)
	// the operation is complete - hand the object id
	// and the error report to the user
	m_NextResult = 1;
	ReceiveNextId(m_Results[0].m_report, m_Results[0].m_Out);
}


BOOL CCorrNextId::GetNextResult()
{
	if (m_NextResult >= m_ResultsCnt)
	{
		if (m_Results)
		{
			delete [] m_Results;
			m_Results = NULL;
		}

		return FALSE;
	}

	UINT lastResult = m_NextResult - 1;
	
	while (m_NextResult < m_ResultsCnt)
	{
		if (m_Results[lastResult].m_Out != m_Results[m_NextResult++].m_Out)
		{
			ReceiveNextId(m_Results[m_NextResult - 1].m_report,
							m_Results[m_NextResult - 1].m_Out);
			return TRUE;
		}
	}

	if (m_Results)
	{
		delete [] m_Results;
		m_Results = NULL;
	}

	return FALSE;
}


void CCorrNextId::ReceiveVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind,
		IN const SnmpVarBind &replyVarBind,
		IN const SnmpErrorReport &error)
{	
	UINT x = 0;

	while (x < m_ResultsCnt) // have a test just in case
	{
		if (m_Results[x].m_In == requestVarBind.GetInstance())
		{
			break;
		}

		x++;
	}

	// currently uses the default "=" operator (bitwise copy)
	m_Results[x].m_report = error;
	m_Results[x].m_Out.Set((UINT*)replyVarBind.GetInstance().GetValue(),
							replyVarBind.GetInstance().GetValueLength());
}


void CCorrNextId::ReceiveErroredVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind,
		IN const SnmpErrorReport &error)
{
	UINT x = 0;

	while (x < m_ResultsCnt) // have a test just in case
	{
		if (m_Results[x].m_In == requestVarBind.GetInstance())
		{
			break;
		}

		x++;
	}

	// currently uses the default "=" operator (bitwise copy)
	m_Results[x].m_report = error;
}


// constructor - creates an operation and passes the snmp_session to it
CCorrNextId::CCorrNextId(IN SnmpSession &snmp_session)
		: SnmpGetNextOperation(snmp_session),
		  m_Results(NULL),
		  m_NextResult(0),
		  m_ResultsCnt(0)
{
}

// delete the m_object_id_string if required
CCorrNextId::~CCorrNextId()
{
	if ( m_Results != NULL )
	{
		delete [] m_Results;
	}
}

// in case of an error encountered while the method executes, 
// ReceiveNextId(LocalError, NULL) will be called synchronously
// otherwise, an asynchronous call to ReceiveNextId provides the next_id	
void CCorrNextId::GetNextId(IN const CCorrObjectID const *object_ids, IN UINT len)
{
	SnmpVarBindList var_bind_list;

	if (m_Results)
	{
		delete [] m_Results;
	}

	m_Results = new CCorrResult[len];
	m_NextResult = 0;
	m_ResultsCnt = len;

	for (UINT x = 0; x < len; x++)
	{
		m_Results[x].m_In.SetValue((ULONG*)object_ids[x].GetIds(),
										object_ids[x].GetLength());
		SnmpNull null_value;
		SnmpVarBind var_bind(m_Results[x].m_In, null_value);
		var_bind_list.Add(var_bind);
	}

	SendRequest(var_bind_list);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\creclass.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <objbase.h>

#include <wbemidl.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <instpath.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include <correlat.h>
#include "classfac.h"
#include "clasprov.h"
#include "creclass.h"
#include "guids.h"

#ifdef CORRELATOR_INIT
SnmpCorrelation :: SnmpCorrelation ( 

	SnmpSession &session ,
	SnmpClassEventObject *eventObject

) : CCorrelator ( session ) ,
	m_session (  &session ) ,
	m_eventObject ( eventObject )
#else //CORRELATOR_INIT
SnmpCorrelation :: SnmpCorrelation ( 

	SnmpSession &session ,
	SnmpClassEventObject *eventObject,
	ISmirInterrogator *a_ISmirInterrogator

) : CCorrelator ( session, a_ISmirInterrogator ) ,
	m_session (  &session ) ,
	m_eventObject ( eventObject )

#endif //CORRELATOR_INIT
{
}

SnmpCorrelation :: ~SnmpCorrelation ()
{
	m_session->DestroySession () ;
}

void SnmpCorrelation :: Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phGroup , IN const char* objectId )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" SnmpCorrelation :: Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phGroup , IN const char* objectId )" 
	) ;
)

	switch ( info.GetInfo () )
	{
		case CCorrelator_Info :: ECorrSuccess:
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Successful correlation" 
	) ;
)


			if ( phGroup )
			{
				phGroup->AddRef () ;
				m_eventObject->ReceiveGroup ( phGroup ) ;
			}
			else
			{
			}
		}
		break ;

		case CCorrelator_Info :: ECorrSnmpError:
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Unsuccessful correlation" 
	) ;
)

			m_eventObject->ReceiveError ( info ) ;
		} 
		break ;

		default:
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Unknown Correlation Status" 
	) ;
)

		}		
		break ;
	}

	if ( phGroup )
		phGroup->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Returning from SnmpCorrelation :: Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phGroup , IN const char* objectId )" 
	) ;
)

}

void SnmpCorrelation :: Finished ( IN const BOOL Complete )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" SnmpCorrelation :: Finished ( IN const BOOL Complete )"
	) ;
)

	m_eventObject->ReceiveComplete () ;
	DestroyCorrelator () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" Returning from SnmpCorrelation :: Finished ( IN const BOOL Complete )"
	) ;
)

}

SnmpClassEventObject :: SnmpClassEventObject ( 

	CImpClasProv *provider ,
	IWbemContext *a_Context

) : m_provider ( provider ) , 
	m_correlate ( TRUE ) ,
	m_synchronousComplete ( FALSE ) ,
	m_correlator ( NULL ) ,
	m_namespaceObject ( NULL ) ,
	m_inCallstack ( FALSE ) ,
	m_Context ( a_Context ) ,
	m_GroupsReceived ( 0 ),
	m_Interrogator ( NULL )
{
	if ( m_provider )
		m_provider->AddRef () ;

	if ( m_Context )
	{
		m_Context->AddRef () ;

/*
 * Look for correlation flag in Context
 */

	
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		HRESULT result = m_Context->GetValue ( WBEM_CLASS_CORRELATE_CONTEXT_PROP , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BOOL ) 
				m_correlate = t_Variant.boolVal ;

			VariantClear ( & t_Variant ) ;
		}
	}

	HRESULT result = CoCreateInstance (
 
		CLSID_SMIR_Database ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_ISMIR_Interrogative ,
		( void ** ) &m_Interrogator 
	);

	if ( SUCCEEDED ( result ) )
	{
		ISMIRWbemConfiguration *smirConfiguration = NULL ;
		result = m_Interrogator->QueryInterface ( IID_ISMIRWbemConfiguration , ( void ** ) & smirConfiguration ) ;
		if ( SUCCEEDED ( result ) )
		{
			result = smirConfiguration->Authenticate (

					NULL,
					NULL,
					NULL,
					NULL,
					0 ,
					NULL,
					FALSE
			) ;

			if ( SUCCEEDED ( result ) )
			{			
				smirConfiguration->SetContext ( m_Context ) ;
				smirConfiguration->Release () ;
			}
		}
		else
		{
			m_Interrogator->Release () ;
			m_synchronousComplete = TRUE ;
			m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
			m_errorObject.SetMessage ( L"QueryInterface on ISmirInterrogator Failed" ) ;
		}
	}
	else
	{
		m_synchronousComplete = TRUE ;
		m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
		m_errorObject.SetMessage ( L"CoCreateInstance on ISmirInterrogator Failed" ) ;
	}
}

SnmpClassEventObject :: ~SnmpClassEventObject  ()
{
	if ( m_provider ) 
		m_provider->Release () ;

	if ( m_namespaceObject )
		m_namespaceObject->Release () ;

	if ( m_Context )
		m_Context->Release () ;

	if ( m_Interrogator )
		m_Interrogator->Release () ;
}

BOOL SnmpClassEventObject :: GetClass ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject **classObject , BSTR a_Class )
{
	HRESULT result = m_Interrogator->GetWBEMClass ( classObject , a_Class ) ;
	if ( SUCCEEDED ( result ) ) 
	{
	}
	else
	{
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
		a_errorObject.SetMessage ( L"Failed to get class definition from SMIR" ) ;
	}

	return result ;
}

BOOL SnmpClassEventObject :: GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;
	IWbemClassObject *errorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = m_provider->GetSnmpNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			VariantClear ( &variant ) ;

			if ( SUCCEEDED ( result ) )
			{
				variant.vt = VT_I4 ;
				variant.lVal = m_errorObject.GetStatus () ;

				result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & variant , 0 ) ;
				VariantClear ( &variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					if ( m_errorObject.GetMessage () ) 
					{
						variant.vt = VT_BSTR ;
						variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

						result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
						VariantClear ( &variant ) ;

						if ( ! SUCCEEDED ( result ) )
						{
							(*notifyObject)->Release () ;
							status = GetNotifyStatusObject ( notifyObject ) ;
						}
					}
				}
				else
				{
					(*notifyObject)->Release () ;
					status = GetNotifyStatusObject ( notifyObject ) ;
				}
			}
			else
			{
				(*notifyObject)->Release () ;
				status = GetNotifyStatusObject ( notifyObject ) ;
			}

			notificationClassObject->Release () ;
		}
		else
		{
			status = GetNotifyStatusObject ( notifyObject ) ;
		}
	}
	else
	{
		status = GetNotifyStatusObject ( notifyObject ) ;
	}

	return status ;
}

BOOL SnmpClassEventObject :: GetNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;
	IWbemClassObject *errorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = m_provider->GetNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			if ( SUCCEEDED ( result ) )
			{
				if ( m_errorObject.GetMessage () ) 
				{
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

					result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
					VariantClear ( &variant ) ;

					if ( ! SUCCEEDED ( result ) )
					{
						status = FALSE ;
						(*notifyObject)->Release () ;
						(*notifyObject)=NULL ;
					}
				}
			}
			else
			{
				status = FALSE ;
				(*notifyObject)->Release () ;
				(*notifyObject)=NULL ;
			}

			VariantClear ( &variant ) ;

			notificationClassObject->Release () ;
		}
		else
		{
			status = FALSE ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentTransport ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentTransport 
)
{
	BOOL status = TRUE ;
	agentTransport = NULL ;
	BSTR t_Transport = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTTRANSPORT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
	}

	if ( status & ! t_Transport )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTTRANSPORT , 
			0,	
			&t_Variant ,
			& attributeType

		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
		else
		{
			t_Transport = WBEM_AGENTIPTRANSPORT ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Transport , WBEM_AGENTIPTRANSPORT ) == 0 ) || ( _wcsicmp ( t_Transport , WBEM_AGENTIPXTRANSPORT ) == 0 ) )
		{
			agentTransport = UnicodeStringDuplicate ( t_Transport ) ;
		}
		else
		{
/*
*	Transport type != IP || != IPX
*/
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
		}

	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentVersion ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentVersion 
)
{
	BOOL status = TRUE ;
	agentVersion = NULL ;
	BSTR t_Version = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTSNMPVERSION , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Version = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
	}

	if ( status & ! t_Version )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTSNMPVERSION , 
			0,	
			&t_Variant ,
			& attributeType
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Version = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}
		else
		{
			t_Version = WBEM_AGENTSNMPVERSION_V1 ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V1 ) == 0 ) || ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V2C ) == 0 ) )
		{
			agentVersion = UnicodeStringDuplicate ( t_Version ) ;
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentAddress ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentAddress 
)
{
	BOOL status = TRUE ;
	agentAddress = NULL ;
	BSTR t_Address = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTADDRESS , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
	}

	if ( status & ! t_Address )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTADDRESS , 
			0,	
			&t_Variant ,
			& attributeType
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Namespace must specify valid qualifier for: AgentAddress" ) ;
		}
	}

	if ( status )
	{
		agentAddress = UnicodeStringDuplicate ( t_Address ) ;
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentReadCommunityName ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentReadCommunityName 
)
{
	BOOL status = TRUE ;
	agentReadCommunityName = NULL ;
	BSTR t_Community = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
		else
		{
			t_Community = WBEM_AGENTCOMMUNITYNAME ;
		}
	}

	if ( status )
	{
		agentReadCommunityName = UnicodeStringDuplicate ( t_Community ) ;
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentRetryCount ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentRetryCount 
)
{
	BOOL status = TRUE ;
	agentRetryCount = 1 ;
	BOOL t_RetryCount = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYCOUNT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryCount = TRUE ;
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	if ( status & ! t_RetryCount )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYCOUNT , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentRetryTimeout( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentRetryTimeout 
)
{
	BOOL status = TRUE ;
	agentRetryTimeout = 0 ;
	BOOL t_RetryTimeout = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryTimeout = TRUE ;
 
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	if ( status & ! t_RetryTimeout )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentMaxVarBindsPerPdu ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentVarBindsPerPdu 
)
{
	BOOL status = TRUE ;
	agentVarBindsPerPdu = 0 ;
	BOOL t_VarBinds = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_VarBinds = TRUE ;
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	if ( status & ! t_VarBinds )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{		
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetAgentFlowControlWindowSize ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentFlowControlWindowSize 
)
{
	BOOL status = TRUE ;
	agentFlowControlWindowSize = 0 ;
	BOOL t_WindowSize = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_WindowSize = TRUE ;
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	if ( status & ! t_WindowSize )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	return status ;
}

BOOL SnmpClassEventObject :: GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	if ( ! m_namespaceObject )
	{
		IWbemServices *parentServer = m_provider->GetParentServer () ;

		wchar_t *objectPathPrefix = UnicodeStringAppend ( WBEM_NAMESPACE_EQUALS , m_provider->GetThisNamespace () ) ;
		wchar_t *objectPath = UnicodeStringAppend ( objectPathPrefix , WBEM_NAMESPACE_QUOTE ) ;

		delete [] objectPathPrefix ;

		BSTR t_PathStr = SysAllocString ( objectPath ) ;

		HRESULT result = parentServer->GetObject ( 

			t_PathStr ,
			0  ,
			m_Context ,
			&m_namespaceObject ,
			NULL 
		) ;

		SysFreeString ( t_PathStr ) ;

		if ( SUCCEEDED ( result ) )
		{
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
			a_errorObject.SetMessage ( L"Failed to obtain namespace object" ) ;
		}

		delete [] objectPath ;
	}

	return status ;
}

BOOL SnmpClassEventObject :: GetTransportInformation ( 

	WbemSnmpErrorObject &a_errorObject ,
	SnmpSession *&session 
)
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" SnmpClassEventObject :: GetTransportInformation ()"
	) ;
)

	BOOL status = TRUE ;

	IWbemQualifierSet *namespaceQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &namespaceQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentVersion = NULL ;
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentReadCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = GetAgentVersion ( m_errorObject , namespaceQualifierObject , agentVersion ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , namespaceQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , namespaceQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentReadCommunityName ( m_errorObject , namespaceQualifierObject , agentReadCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , namespaceQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , namespaceQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , namespaceQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , namespaceQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
				if ( dbcsAgentReadCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( m_provider->GetIpAddressString () && m_provider->GetIpAddressValue () && _stricmp ( m_provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = m_provider->GetIpAddressValue () ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else
							{
								if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
								{
									t_Address = dbcsAgentAddress ;
								}
								else							
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
								}
							}
						}

						if ( status )
						{
							if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
							{
								session = new SnmpV1OverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! ( *session ) () ) 
								{
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
							{
								session = new SnmpV2COverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! ( *session ) () ) 
								{
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;
							}
						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( ! SnmpTransportIpxAddress :: ValidateAddress ( dbcsAgentAddress  ) )
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
						}

						if ( status )
						{
							if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
							{
								session = new SnmpV1OverIpx (

									dbcsAgentAddress ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! ( *session ) () ) 
								{
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}

							}
							else if ( _wcsicmp ( agentVersion , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
							{
								session = new SnmpV2COverIpx (

									dbcsAgentAddress  ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! ( *session ) () ) 
								{
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}

							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsAgentReadCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentVersion ;
		delete [] agentReadCommunityName ;

		namespaceQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" SnmpClassEventObject :: GetTransportInformation () with Result (%lx)" ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

SnmpClassGetEventObject :: SnmpClassGetEventObject ( 

	CImpClasProv *provider , 
	BSTR Class ,
	IWbemContext *a_Context

) : SnmpClassEventObject ( provider , a_Context ) , m_classObject ( NULL ) , m_Received ( FALSE ) , m_Class ( NULL )
{
	m_Class = UnicodeStringDuplicate ( Class ) ;
}

SnmpClassGetEventObject :: ~SnmpClassGetEventObject ()
{
	if ( m_classObject )
		m_classObject->Release () ;

	delete [] m_Class ;
}

BOOL SnmpClassGetEventObject :: GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	WbemSnmpErrorObject errorStatusObject ;

/*
 *	Don't ask for SnmpNotifyStatus if HMOM specifically asked for SnmpNotifyStatus, otherwise
 *	we'll end up in a deadlock situation.
 */
	BOOL status = TRUE ;

	if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPNOTIFYSTATUS ) == 0 )
	{
		status = GetNotifyStatusObject ( notifyObject ) ;	
	}
	else
	{
		IWbemClassObject *notificationClassObject = NULL ;
		IWbemClassObject *errorObject = NULL ;

		if ( notificationClassObject = m_provider->GetSnmpNotificationObject ( errorStatusObject ) )
		{
			HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
			if ( SUCCEEDED ( result ) )
			{
				VARIANT variant ;
				VariantInit ( &variant ) ;

				variant.vt = VT_I4 ;
				variant.lVal = m_errorObject.GetWbemStatus () ;

				result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
				VariantClear ( &variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					variant.vt = VT_I4 ;
					variant.lVal = m_errorObject.GetStatus () ;

					result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & variant , 0 ) ;
					VariantClear ( &variant ) ;

					if ( SUCCEEDED ( result ) )
					{
						if ( m_errorObject.GetMessage () ) 
						{
							variant.vt = VT_BSTR ;
							variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

							result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
							VariantClear ( &variant ) ;

							if ( ! SUCCEEDED ( result ) )
							{
								(*notifyObject)->Release () ;
								status = GetNotifyStatusObject ( notifyObject ) ;
							}
						}
					}
					else
					{
						(*notifyObject)->Release () ;
						status = GetNotifyStatusObject ( notifyObject ) ;
					}
				}
				else
				{
					(*notifyObject)->Release () ;
					status = GetNotifyStatusObject ( notifyObject ) ;
				}

				notificationClassObject->Release () ;
			}
			else
			{
				status = GetNotifyStatusObject ( notifyObject ) ;
			}
		}
		else
		{
			status = GetNotifyStatusObject ( notifyObject ) ;
		}
	}

	return status ;
}

BOOL SnmpClassGetEventObject :: ProcessCorrelatedClass ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	IWbemQualifierSet *namespaceQualifierObject = NULL ;
	HRESULT result = m_classObject->GetQualifierSet ( &namespaceQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		LONG attributeType ;

		VARIANT variant ;
		VariantInit ( & variant ) ;

		result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_GROUP_OBJECTID , 
			0,	
			&variant ,
			& attributeType 

		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( variant.vt == VT_BSTR ) 
			{
// Get Device Transport information

				SnmpObjectIdentifierType objectIdentifier ( variant.bstrVal ) ;						
				if ( objectIdentifier.IsValid () )
				{
					SnmpSession *session ;
					status = GetTransportInformation ( m_errorObject , session ) ;
					if ( status ) 
					{
#ifdef CORRELATOR_INIT
						m_correlator = new SnmpCorrelation ( *session , this ) ;
#else //CORRELATOR_INIT
						m_correlator = new SnmpCorrelation ( *session , this, m_Interrogator ) ;
#endif //CORRELATOR_INIT
						char *groupObjectId = UnicodeToDbcsString ( variant.bstrVal ) ;
						if ( groupObjectId )
						{
							m_inCallstack = TRUE ;
							m_correlator->Start ( groupObjectId ) ;	
							if ( m_inCallstack == FALSE )
								m_synchronousComplete = TRUE ;
							m_inCallstack = FALSE ;
							delete [] groupObjectId ;
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: group_objectid" ) ;
						}
					}

				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: group_objectid" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: group_objectid" ) ;
			}

			VariantClear ( & variant ) ;
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			a_errorObject.SetMessage ( L"Class must specify valid qualifier for: group_objectid" ) ;
		}

		namespaceQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to get Class qualifier set, must specify valid qualifier for: group_objectid" ) ;
	}

	return status ;
}

BOOL SnmpClassGetEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

// Get Class definition from SMIR

	IWbemClassObject *classObject = NULL ;
	HRESULT result = GetClass ( m_errorObject , &m_classObject , m_Class ) ;
	if ( SUCCEEDED ( result ) ) 
	{
// Get Namespace object which contains Device Transport information/Also used for merge of class

		status = GetNamespaceObject ( a_errorObject ) ;
		if ( status ) 
		{
			if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPMACRO ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPOBJECTTYPE ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPNOTIFYSTATUS ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPNOTIFICATION ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else if ( _wcsicmp ( m_Class , WBEM_CLASS_SNMPVARBIND ) == 0 )
			{
				ReceiveClass ( m_classObject ) ;
				m_synchronousComplete = TRUE ;
			}
			else
			{
// Determine if I need to correlate

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				
				result = m_classObject->Get ( L"__SUPERCLASS" , 0 , & t_Variant , NULL , NULL ) ;

				BSTR t_Parent = t_Variant.bstrVal ;
				
				if ( SUCCEEDED ( result ) && (t_Variant.vt == VT_BSTR) && (t_Parent != NULL) && (*t_Parent != L'\0'))
				{
					if ( _wcsicmp ( t_Parent , WBEM_CLASS_SNMPNOTIFICATION ) == 0 || _wcsicmp ( t_Parent , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) == 0 )
					{
						ReceiveClass ( m_classObject ) ;
						m_synchronousComplete = TRUE ;
					}
					else if (_wcsicmp ( t_Parent , WBEM_CLASS_SNMPOBJECTTYPE ) == 0)
					{
						if ( m_correlate )
						{
							status = ProcessCorrelatedClass ( a_errorObject ) ;
							if ( !status )
							{
								m_synchronousComplete = TRUE ;
							}
						}
						else
						{
							ReceiveClass ( m_classObject ) ;
							m_synchronousComplete = TRUE ;
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
						a_errorObject.SetMessage ( L"This is not a supported SNMP class." ) ;
					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
					a_errorObject.SetMessage ( L"Failed to get __SUPERCLASS property. This is not an SNMP base class." ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}
	}
	else
	{
		//no need to set an error msg etc 'cos GetClass does it.
		status = FALSE;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject (%lx))" ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

void SnmpClassGetEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )" 
	) ;
)

	ReceiveClass ( m_classObject ) ;
	phGroup->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )" 
	) ;
)

}

SnmpClassGetAsyncEventObject :: SnmpClassGetAsyncEventObject ( 

	CImpClasProv *provider , 
	BSTR Class , 
	IWbemObjectSink *notify ,
	IWbemContext *a_Context

) : SnmpClassGetEventObject ( provider , Class , a_Context ) ,
	m_notificationHandler ( notify ) 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: SnmpClassGetAsyncEventObject ()" 
	) ;
)

	m_notificationHandler->AddRef () ;
}

SnmpClassGetAsyncEventObject :: ~SnmpClassGetAsyncEventObject ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: ~SnmpClassGetAsyncEventObject ()" 
	) ;
)
	IWbemClassObject *notifyStatus = NULL;

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
		// Get Status object
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

	HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;

	if ( notifyStatus )
	{
		notifyStatus->Release () ;
	}

	m_notificationHandler->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetAsyncEventObject :: ~SnmpClassGetAsyncEventObject ()" 
	) ;
)

}

void SnmpClassGetAsyncEventObject :: Process ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: Process ()" 
	) ;
)

	if ( ! m_synchronousComplete )
	{
		BOOL status = ProcessClass ( m_errorObject ) ;
		if ( status )
		{
			if ( m_synchronousComplete )
				ReceiveComplete () ;
		}
		else
		{
			ReceiveComplete () ;	
		}
	}
	else
	{			
		ReceiveComplete () ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpClassGetAsyncEventObject :: ReceiveClass ( IWbemClassObject *classObject ) 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: ReceiveClass ( IWbemClassObject *classObject )" 
	) ;
)

	if ( ! m_Received )
	{
		m_Received = TRUE ;
		m_notificationHandler->Indicate ( 1 , & m_classObject ) ;
	}

}

void SnmpClassGetAsyncEventObject :: ReceiveComplete () 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
/*
 *	If no error specified yet then check for NOT_FOUND
 */

		if ( ! m_Received )
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			m_errorObject.SetMessage ( L"Class not defined" ) ;
		}
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	if ( ! m_inCallstack )
	{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

		Complete () ;
	}
	else
		m_inCallstack = FALSE ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassGetAsyncEventObject :: Receive4 ()" 
	) ;
)
}

void SnmpClassGetAsyncEventObject :: ReceiveError ( IN const SnmpErrorReport &a_errorReport )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: ReceiveError ( IN const SnmpErrorReport &a_errorReport )"
	) ;
)

	switch ( a_errorReport.GetError () )
	{
		case Snmp_Error:
		{
			switch ( a_errorReport.GetStatus () )
			{
				case Snmp_No_Response:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"No Response from device" ) ;
				}
				break; 

				default:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
		}
		break ;
	}
}

SnmpClassEnumEventObject :: SnmpClassEnumEventObject ( 

	CImpClasProv *provider , 
	BSTR Parent ,
	ULONG flags ,
	IWbemContext *a_Context

) : SnmpClassEventObject ( provider , a_Context ) , m_Flags ( flags ) 
{
	m_Parent = UnicodeStringDuplicate ( Parent ) ;
}

BOOL SnmpClassEnumEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class = (%s) )" ,
		a_Class
	) ;
)

	BOOL status = TRUE ;

// Get Class definition from SMIR

	IWbemClassObject *classObject = NULL ;
	HRESULT result = GetClass ( a_errorObject , &classObject , a_Class ) ;
	if ( SUCCEEDED ( result ) ) 
	{
// Get Namespace object which contains Device Transport information/Also used for merge of class

		status = GetNamespaceObject ( a_errorObject ) ;
		if ( status ) 
		{
			ReceiveClass ( classObject ) ;
		}

		classObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
		a_errorObject.SetMessage ( L"Class not defined" ) ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class = (%s) )" ,
		a_Class
	) ;
)

	return status ;
}

SnmpClassEnumEventObject :: ~SnmpClassEnumEventObject ()
{
	delete [] m_Parent ;
}

BOOL SnmpClassEnumEventObject :: GetEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = GetNamespaceObject ( m_errorObject ) ;
	if ( status ) 
	{
// Determine if I need to correlate

		if ( m_correlate )
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Performing Class Correlation"
	) ;
)

// Get Device Transport information
					
			SnmpSession *session ;
			status = GetTransportInformation ( m_errorObject , session ) ;
			if ( status ) 
			{
				m_inCallstack = TRUE ;
#ifdef CORRELATOR_INIT
				m_correlator = new SnmpCorrelation ( *session , this ) ;
#else //CORRELATOR_INIT
				m_correlator = new SnmpCorrelation ( *session , this, m_Interrogator ) ;
#endif //CORRELATOR_INIT
				m_correlator->Start ( NULL ) ;	
				if ( m_inCallstack == FALSE )
					m_synchronousComplete = TRUE ;
				m_inCallstack = FALSE ;
			}
			else
			{
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Not Performing Class Correlation"
	) ;
)

			ReceiveGroup ( NULL ) ;
			m_synchronousComplete = TRUE ;
		}
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return status ;
}

BOOL SnmpClassEnumEventObject :: GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	HRESULT result = S_OK ;

	BOOL status = GetNamespaceObject ( m_errorObject ) ;
	if ( status ) 
	{
		IWbemClassObject *classObject = NULL ;
		IEnumNotificationClass *enumClass = NULL ;
		ISmirNotificationClassHandle *classHandle = NULL ;

		result = m_Interrogator->EnumAllNotificationClasses (

			&enumClass
		) ;

		if ( SUCCEEDED ( result ) )
		{
			ULONG fetched = 0 ;
			enumClass->Reset () ;
			while ( enumClass->Next ( 1 , & classHandle , &fetched ) == WBEM_NO_ERROR )
			{
				result = classHandle->GetWBEMNotificationClass ( & classObject ) ;
				if ( SUCCEEDED ( result ) ) 
				{
					ReceiveClass ( classObject ) ;
					classObject->Release () ;
				}

				classHandle->Release () ;
			}

			enumClass->Release () ;
		}
		else
		{
		}
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return SUCCEEDED ( result ) ;
}

BOOL SnmpClassEnumEventObject :: GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	HRESULT result = S_OK ;

	BOOL status = GetNamespaceObject ( m_errorObject ) ;
	if ( status ) 
	{
		IWbemClassObject *classObject = NULL ;
		IEnumExtNotificationClass *enumClass = NULL ;
		ISmirExtNotificationClassHandle *classHandle = NULL ;

		result = m_Interrogator->EnumAllExtNotificationClasses (

			&enumClass
		) ;

		if ( SUCCEEDED ( result ) )
		{
			ULONG fetched = 0 ;
			enumClass->Reset () ;
			while ( enumClass->Next ( 1 , & classHandle , &fetched ) == WBEM_NO_ERROR )
			{
				result = classHandle->GetWBEMExtNotificationClass ( & classObject ) ;
				if ( SUCCEEDED ( result ) ) 
				{
					ReceiveClass ( classObject ) ;
					classObject->Release () ;
				}

				classHandle->Release () ;
			}

			enumClass->Release () ;
		}
		else
		{
		}
	}
	
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	return SUCCEEDED ( result ) ;
}

BOOL SnmpClassEnumEventObject :: ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumEventObject :: ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject (%s) )" ,
		m_Parent
	) ;
)

	BOOL status = TRUE ;

// Get Namespace object which contains Device Transport information/Also used for merge of class

	if ( m_Flags & WBEM_FLAG_SHALLOW )
	{
		if ( ( ! m_Parent ) || _wcsicmp ( m_Parent , WBEM_CLASS_NULL ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPMACRO ) ;
			status = status && ProcessClass ( a_errorObject , WBEM_CLASS_SNMPVARBIND ) ;
			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPMACRO ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPOBJECTTYPE ) ;
			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPOBJECTTYPE ) == 0 )
		{
			status = GetEnumeration ( a_errorObject ) ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_NOTIFYSTATUS ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFYSTATUS ) ;
			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_EXTRINSICEVENT ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFICATION ) ;
			status = status & ProcessClass ( a_errorObject , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) ;

			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPNOTIFICATION ) == 0 )
		{
			status = GetNotificationEnumeration ( a_errorObject ) ;

			m_synchronousComplete = TRUE ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) == 0 )
		{
			status = GetExtendedNotificationEnumeration ( a_errorObject ) ;

			m_synchronousComplete = TRUE ;
		}
		else
		{
// Get Class definition from SMIR

			IWbemClassObject *classObject = NULL ;
			HRESULT result = GetClass ( a_errorObject , &classObject , m_Parent ) ;
			if ( SUCCEEDED ( result ) ) 
			{
				classObject->Release () ;

				m_synchronousComplete = TRUE ;
				status = TRUE ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_errorObject.SetMessage ( L"Parent class not known" ) ;

				m_synchronousComplete = TRUE ;
			}
		}
	}
	else
	{
		if ( ( ! m_Parent ) || _wcsicmp ( m_Parent , WBEM_CLASS_NULL ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPMACRO ) ;
			if ( status )
			{
				status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPOBJECTTYPE ) ;
				if ( status ) 
				{
					status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFYSTATUS ) ;
					if ( status ) 
					{
						status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPVARBIND ) ;
						if ( status )
						{
							status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPNOTIFICATION ) ;
							if ( status ) 
							{
								status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPEXTENDEDNOTIFICATION ) ;
								if ( status )
								{
									status = GetNotificationEnumeration ( a_errorObject ) ;
									if ( status ) 
									{
										status = GetExtendedNotificationEnumeration ( a_errorObject ) ;
										if ( status ) 
										{
											status = GetEnumeration ( a_errorObject ) ;
										}
									}
								}
							}
						}
					}					
				}
			}
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPMACRO ) == 0 )
		{
			status = ProcessClass ( a_errorObject , WBEM_CLASS_SNMPOBJECTTYPE ) ;
			if ( status ) 
			{
				status = GetEnumeration ( a_errorObject ) ;
			}
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_SNMPOBJECTTYPE ) == 0 )
		{
			status = GetEnumeration ( a_errorObject ) ;
		}
		else if ( _wcsicmp ( m_Parent , WBEM_CLASS_EXTRINSICEVENT ) == 0 )
		{
			status = GetNotificationEnumeration ( a_errorObject ) ;
			if ( status ) 
			{
				status = GetExtendedNotificationEnumeration ( a_errorObject ) ;
			}
			m_synchronousComplete = TRUE ;
		}
		else
		{
// Get Class definition from SMIR

			IWbemClassObject *classObject = NULL ;
			HRESULT result = GetClass ( a_errorObject , &classObject , m_Parent ) ;
			if ( SUCCEEDED ( result ) ) 
			{
				classObject->Release () ;
				m_synchronousComplete = TRUE ;
				status = TRUE ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				a_errorObject.SetMessage ( L"Parent class not known" ) ;

				m_synchronousComplete = TRUE ;
			}
		}
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject (%s))" ,
		m_Parent
	) ;
)

	return status ;
}

void SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )
{
DebugMacro1( 

	if ( phGroup )
	{
		BSTR t_ModuleName = NULL ;
		BSTR t_GroupOID = NULL ;

		phGroup->GetModuleName ( &t_ModuleName ) ;
		phGroup->GetGroupOID ( &t_GroupOID ) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup = ((%s),(%s)) )" ,
			t_ModuleName ,
			t_GroupOID
		) ;

		SysFreeString ( t_ModuleName ) ;
		SysFreeString ( t_GroupOID ) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup = NULL )"
		) ;
	}
)

	HRESULT result = S_OK ;

	m_GroupsReceived ++ ;

	IWbemClassObject *classObject = NULL ;
	IEnumClass *enumClass = NULL ;
	ISmirClassHandle *classHandle = NULL ;

	if ( phGroup )
	{
		result = m_Interrogator->EnumClassesInGroup (

			&enumClass ,
			phGroup 
		) ;
	}
	else
	{
		result = m_Interrogator->EnumAllClasses (

			&enumClass 
		) ;
	}

	if ( SUCCEEDED ( result ) )
	{
		ULONG fetched = 0 ;
		enumClass->Reset () ;
		while ( enumClass->Next ( 1 , & classHandle , &fetched ) == WBEM_NO_ERROR )
		{
			result = classHandle->GetWBEMClass ( & classObject ) ;
			if ( SUCCEEDED ( result ) ) 
			{
				ReceiveClass ( classObject ) ;
				classObject->Release () ;
			}

			classHandle->Release () ;
		}

		enumClass->Release () ;
	}
	else
	{
	}

	if ( phGroup )
	{
		phGroup->Release () ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumEventObject :: ReceiveGroup ( IN ISmirGroupHandle *phGroup )" 
	) ;
)

}

SnmpClassEnumAsyncEventObject :: SnmpClassEnumAsyncEventObject ( 

	CImpClasProv *provider , 
	BSTR Parent ,
	ULONG flags ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context

) : SnmpClassEnumEventObject ( provider , Parent , flags , a_Context ) ,
	m_notificationHandler ( notify )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: SnmpClassEnumAsyncEventObject ()" 
	) ;
)

	m_notificationHandler->AddRef () ;
}

SnmpClassEnumAsyncEventObject :: ~SnmpClassEnumAsyncEventObject ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ~SnmpClassEnumAsyncEventObject ()" 
	) ;
)

// Get Status object

	IWbemClassObject *notifyStatus = NULL;
	
	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)
	HRESULT result = m_notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;

	if ( notifyStatus )
	{
		notifyStatus->Release () ;
	}

	m_notificationHandler->Release () ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumAsyncEventObject :: ~SnmpClassEnumAsyncEventObject ()" 
	) ;
)

}

void SnmpClassEnumAsyncEventObject :: Process ()
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: Process ()" 
	) ;
)

	if ( ! m_synchronousComplete )
	{
		BOOL status = ProcessEnumeration ( m_errorObject ) ;
		if ( status )
		{
			if ( m_synchronousComplete )
				ReceiveComplete () ;
		}
		else
		{
			ReceiveComplete () ;	
		}
	}
	else
	{
		ReceiveComplete () ;	
	}

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpClassEnumAsyncEventObject :: ReceiveClass ( IWbemClassObject *classObject ) 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ReceiveClass ()" 
	) ;
)

	m_notificationHandler->Indicate ( 1, & classObject ) ;
}

void SnmpClassEnumAsyncEventObject :: ReceiveError ( IN const SnmpErrorReport &errorReport )
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ReceiveError ()" 
	) ;
)

	switch ( errorReport.GetError () )
	{
		case Snmp_Error:
		{
			switch ( errorReport.GetStatus () )
			{
				case Snmp_No_Response:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"No Response from device" ) ;
				}
				break; 

				default:
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Unknown transport failure" ) ;
		}
		break ;
	}
}

void SnmpClassEnumAsyncEventObject :: ReceiveComplete () 
{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpClassEnumAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
	}
	else
	{
		if ( m_GroupsReceived )
		{
			if ( FAILED ( m_errorObject.GetWbemStatus () ) ) 
			{
				if ( m_errorObject.GetStatus () == WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) 
				{
					m_errorObject.SetWbemStatus ( WBEM_S_TIMEDOUT ) ;
				}
			}
		}
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	if ( ! m_inCallstack )
	{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

		Complete () ;
	}
	else
		m_inCallstack = FALSE ;

DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpClassEnumAsyncEventObject :: ReceiveComplete ()" 
	) ;
)


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\correlat.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <notify.h>
#include <cordefs.h>
#include <cormap.h>
#include <snmplog.h>

extern CCorrCacheWrapper*	g_CacheWrapper;
extern CCorrelatorMap*		g_Map;
extern ISmirDatabase*		g_pNotifyInt;
extern CCorrCacheNotify*	gp_notify;

static CCriticalSection gs_InitLock;

void CCorrelator::StartUp(IN ISmirInterrogator *a_ISmirInterrogator)
{
	if (gs_InitLock.Lock())
	{
		if (NULL == g_CacheWrapper)
		{
			g_CacheWrapper = new CCorrCacheWrapper();
		}

		if (NULL == g_Map)
		{
			g_Map = new CCorrelatorMap();
		}

		gs_InitLock.Unlock();
	}

	CCorrCache* cache = g_CacheWrapper->GetCache();

	if (NULL == cache)
	{
		cache = new CCorrCache(a_ISmirInterrogator);
		g_CacheWrapper->SetCache(cache);
	}

	g_CacheWrapper->ReleaseCache();

}

#ifdef CORRELATOR_INIT
CCorrelator::CCorrelator(IN SnmpSession &session) :
	CCorrNextId(session),
	m_Groups(NULL),
	m_group_OID(NULL),
	m_pCache(NULL)
{
#else //CORRELATOR_INIT
CCorrelator::CCorrelator(IN SnmpSession &session, IN ISmirInterrogator *a_ISmirInterrogator) :
	CCorrNextId(session),
	m_Groups(NULL),
	m_group_OID(NULL),
	m_pCache(NULL)
{
	StartUp(a_ISmirInterrogator);
#endif //CORRELATOR_INIT

	m_VarBindCnt = 0;
	m_inProg = FALSE;
	m_pItem = NULL;
	m_NoEntries = TRUE;
}


void CCorrelator::ReadRegistry()
{
	HKEY hkey;
	LONG res = RegOpenKey(HKEY_LOCAL_MACHINE, CORRELATOR_KEY, &hkey);
	UINT sessionVarBindCnt = session.GetVarbindsPerPdu();
	UINT maxVarBindCnt = ((VARBIND_COUNT < sessionVarBindCnt)
									? VARBIND_COUNT : sessionVarBindCnt);

	if (ERROR_SUCCESS != res)
	{
		m_VarBindCnt = maxVarBindCnt;
		return;
	}

	DWORD type;
	DWORD data;
	DWORD ldata=sizeof(DWORD);
	res = RegQueryValueEx(hkey, CORRELATOR_VALUE, NULL, &type,
							(unsigned char*) &data, &ldata);
	
	if ((ERROR_SUCCESS != res) || (REG_DWORD != type) ||
		(0 == data) || (maxVarBindCnt < data))
	{
		m_VarBindCnt = maxVarBindCnt;
	}
	else
	{
		m_VarBindCnt = data;
	}

	RegCloseKey(hkey);

}


void CCorrelator::Initialise()
{
	ReadRegistry();
	g_Map->Register(this);
	m_pCache = g_CacheWrapper->GetCache();
	g_CacheWrapper->ReleaseCache();

	if (NULL == m_pCache)
	{
		m_NoEntries = TRUE;
	}
	else
	{
		m_pCache->AddRef();
		m_rangePos = m_pCache->GetHeadRangeTable();
		
		if (m_rangePos)
		{
			m_NoEntries = FALSE;
			m_Groups = new CCorrGroupMask(m_pCache->GetSize());

		}
		else
		{
			m_NoEntries = TRUE;
		}
	}
}

CCorrelator::~CCorrelator()
{
	delete m_Groups;
	delete m_group_OID;

	if (m_pCache)
	{
		m_pCache->DecRef();
	}
}


void CCorrelator::DestroyCorrelator()
{
	Reset();
	DestroyOperation();
}

void CCorrelator::Reset()
{
	g_Map->UnRegister(this);

	if (m_pCache)
	{
		m_pCache->DecRef();
		m_pCache = NULL;
	}

	delete m_Groups;
	m_Groups = NULL;
	m_inProg = FALSE;
	delete m_group_OID;
	m_group_OID = NULL;
}

void CCorrelator::ReceiveNextId(IN const SnmpErrorReport &error,
								IN const CCorrObjectID &next_id)
{
	if (Snmp_Success == error.GetError())
	{
		BOOL nextNeeded = TRUE;

		switch(m_pItem->IsInRange(next_id))
		{
			case CCorrRangeTableItem::ECorrBeforeStart:
			{
				char* id = next_id.GetString();
				CCorrelator_Info i(CCorrelator_Info::ECorrGetNextError, error);
				Correlated(i, (ISmirGroupHandle*)NULL, id);
				delete [] id;
				Reset();
				Finished(TRUE);
				return;
			}
			break;

			case CCorrRangeTableItem::ECorrInRange:
			{
				CCorrelator_Info i(CCorrelator_Info::ECorrSuccess, error);

				//loop the group handle list and call correlated fro each...
				POSITION pos = m_pItem->GetGroupIdPtr()->m_groupHandles.GetHeadPosition();
				while (pos)
				{
					ISmirGroupHandle* gH = m_pItem->GetGroupIdPtr()->m_groupHandles.GetNext(pos);
					gH->AddRef();
					Correlated(i, gH);
				}
				
				m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());

				if (m_group_OID)
				{
					Reset();
					Finished(TRUE);
					return;
				}
			}
			break;

			case CCorrRangeTableItem::ECorrAfterEnd:
			{
				nextNeeded = ProcessOID(error, next_id);
			}
			break;

			case CCorrRangeTableItem::ECorrEqualToEnd:
			{
				char* id = next_id.GetString();
				CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup, error);
				Correlated(i, (ISmirGroupHandle*)NULL, id);
				delete [] id;
			}
			break;

			default:
			{
DebugMacro6( 
				SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
					L"CCorrelator::ReceiveNextId - Undefined case reached\n");
)
			}
			break;

		}
		
		if (!m_rangePos && nextNeeded)
		{
			Reset();
			Finished(TRUE);
			return;
		}

		if (nextNeeded)
		{
			m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
		}

		if (m_group_OID)
		{
			while (!IsItemFromGroup())
			{
				m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());
				
				if (m_rangePos)
				{
					//check result set and make sure we discard
					//any results for this range item
					ScanAndSkipResults();
					m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
				}
				else
				{
					Reset();
					Finished(TRUE);
					return;
				}
			}
		}

		while (m_Groups->IsBitSet(m_pItem->GetGroupIdPtr()->GetIndex()))
		{
			if (m_rangePos && !m_group_OID)
			{
				//check result set and make sure we discard
				//any results for this range item
				ScanAndSkipResults();
				m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
			}
			else
			{
				Reset();
				Finished(TRUE);
				return;
			}
		}

		// GetNextResult will have called ReceiveNextID if the result is
		// TRUE so at this point we have to make sure recursion is safe.
		// when all the results from the previous GetNext have been processed
		// GetNextResult will return FALSE and the program will do the
		// next GetNext operation and stop recursing.

		if (!GetNextResult())
		{
			GetNextOIDs();
		}

		return;
	}
	else
	{
		switch(error.GetStatus())
		{
			case Snmp_No_Such_Name:
			{
				Reset();
				Finished(TRUE);
				return;
			}
			break;

			case Snmp_Gen_Error:
			case Snmp_Local_Error:
			case Snmp_General_Abort:
			case Snmp_No_Response:
			break;

			default:
			{
DebugMacro6( 
				SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
					L"CCorrelator::ReceiveNextId - Unexpected SNMP Error returned\n");
)
			}
			break;
		}

		CCorrelator_Info i(CCorrelator_Info::ECorrSnmpError, error);
		Correlated(i, (ISmirGroupHandle*)NULL);
		Reset();
		Finished(FALSE);
	}
}

void CCorrelator::ScanAndSkipResults()
{
	if (m_NextResult >= m_ResultsCnt)
	{
		return;
	}

	UINT lastResult = m_NextResult - 1;
	BOOL bInvalidOIDReported = FALSE;
	
	while (m_NextResult < m_ResultsCnt)
	{
		if (m_Results[lastResult].m_Out != m_Results[m_NextResult].m_Out)
		{
			if (Snmp_Success == m_Results[m_NextResult].m_report.GetError())
			{
				switch(m_pItem->IsInRange(m_Results[m_NextResult].m_Out))
				{
					case CCorrRangeTableItem::ECorrBeforeStart:
					case CCorrRangeTableItem::ECorrInRange:
					{
						lastResult = m_NextResult;
						m_NextResult++;
					}
					break;

					case CCorrRangeTableItem::ECorrAfterEnd:
					{
						return;
					}
					break;

					case CCorrRangeTableItem::ECorrEqualToEnd:
					{
						if (!bInvalidOIDReported)
						{
							char* id = m_Results[m_NextResult].m_Out.GetString();
							CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup,
												m_Results[m_NextResult].m_report);
							Correlated(i, (ISmirGroupHandle*)NULL, id);
							delete [] id;
							bInvalidOIDReported = TRUE;
						}

						lastResult = m_NextResult;
						m_NextResult++;
					}
					break;

					default:
					{
DebugMacro6( 
						SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
							L"CCorrelator::ScanAndSkipResults - Undefined case reached\n");
)
					}
					break;

				}
			}
			else
			{
				break;
			}
		}
		else
		{
			m_NextResult++;
		}
	}
}

BOOL CCorrelator::ProcessOID(IN const SnmpErrorReport& error, IN const CCorrObjectID& OID)
{
	BOOL ret = TRUE;
	BOOL invalidOID = TRUE;

	while (m_rangePos)
	{
		invalidOID = FALSE;
		m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);

		switch(m_pItem->IsInRange(OID))
		{
			case CCorrRangeTableItem::ECorrInRange:
			{
				if (!m_group_OID || IsItemFromGroup())
				{
					CCorrelator_Info i(CCorrelator_Info::ECorrSuccess, error);

					//loop the group handle list and call correlated fro each...
					POSITION pos = m_pItem->GetGroupIdPtr()->m_groupHandles.GetHeadPosition();
					while (pos)
					{
						ISmirGroupHandle* gH = m_pItem->GetGroupIdPtr()->m_groupHandles.GetNext(pos);
						gH->AddRef();
						Correlated(i, gH);
					}
				}

				m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());
				return ret;
			}
			break;
			
			case CCorrRangeTableItem::ECorrAfterEnd:
			{
				invalidOID = TRUE;
			}
			continue;

			case CCorrRangeTableItem::ECorrBeforeStart:
			case CCorrRangeTableItem::ECorrEqualToStart:
			{
				ret = FALSE;
			}
			case CCorrRangeTableItem::ECorrEqualToEnd:
			{
				CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup, error);
				char* id = OID.GetString();
				Correlated(i, (ISmirGroupHandle*)NULL, id);
				delete [] id;
				return ret;
			}
			break;
		}
	}

	if (invalidOID)
	{
		CCorrelator_Info i(CCorrelator_Info::ECorrInvalidGroup, error);
		char* id = OID.GetString();
		Correlated(i, (ISmirGroupHandle*)NULL, id);
		delete [] id;
	}

	return ret;
}


BOOL CCorrelator::Start(IN const char* groupId) 
{
	if(m_inProg)
	{
		return FALSE;
	}
	
	if (groupId)
	{
		m_group_OID = new CCorrObjectID(groupId);
	}

	Initialise();
	m_inProg = TRUE;

	if (m_NoEntries || !(*this)())
	{
		SnmpErrorReport snmpi(Snmp_Success, Snmp_No_Error);
		CCorrelator_Info i(CCorrelator_Info::ECorrBadSession, snmpi);

		if (m_NoEntries)
		{
			i.SetInfo(CCorrelator_Info::ECorrEmptySMIR);
		}
		
		Correlated(i, (ISmirGroupHandle*)NULL);
		Reset();
		Finished(FALSE);
		return FALSE;
	}

	m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);

	if (m_group_OID)
	{
		while (!IsItemFromGroup())
		{
			m_Groups->SetBit(m_pItem->GetGroupIdPtr()->GetIndex());
			
			if (m_rangePos)
			{
				m_pItem = m_pCache->GetNextRangeTable(&m_rangePos);
			}
			else
			{
				SnmpErrorReport snmpi(Snmp_Success, Snmp_No_Error);
				CCorrelator_Info i(CCorrelator_Info::ECorrNoSuchGroup, snmpi);
				Correlated(i, (ISmirGroupHandle*)NULL);
				Reset();
				Finished(FALSE);
				return FALSE;

			}
		}
	}

	GetNextOIDs();

	return TRUE;
}


void CCorrelator::GetNextOIDs()
{
	CCorrObjectID next_ids[VARBIND_COUNT];
	UINT count;
	POSITION tmpRangePos = m_rangePos;
	CCorrRangeTableItem* tmpItem = m_pItem;
	count = 0;
	tmpItem->GetStartRange(next_ids[count]);
	count++;

	if (NULL == m_group_OID)
	{
		while (tmpRangePos && (count < m_VarBindCnt))
		{
			tmpItem = m_pCache->GetNextRangeTable(&tmpRangePos);
			tmpItem->GetStartRange(next_ids[count]);
			count++;
		}
	}

	GetNextId(next_ids, count);
}


BOOL CCorrelator::IsItemFromGroup() const
{
	if (!m_group_OID || !m_pItem)
	{
		return FALSE;
	}

	CCorrObjectID tmp;
	m_pItem->GetGroupIdPtr()->GetGroupID(tmp);
	return(*m_group_OID == tmp);
}


void CCorrelator::TerminateCorrelator(ISmirDatabase** a_ppNotifyInt, CCorrCacheNotify** a_ppnotify)
{
	if (gs_InitLock.Lock())
	{
		delete g_Map;
		g_Map = NULL;

		if (g_pNotifyInt)
		{
			*a_ppNotifyInt = g_pNotifyInt;
			g_pNotifyInt = NULL;
		}

		if (gp_notify)
		{
			gp_notify->Detach();
			*a_ppnotify = gp_notify;
			gp_notify = NULL;
		}

		if (g_CacheWrapper)
		{
			CCorrCache* cache = g_CacheWrapper->GetCache();
			
			if (cache)
			{
				delete cache;
			}

			g_CacheWrapper->ReleaseCache();
			delete g_CacheWrapper;
			g_CacheWrapper = NULL;
		}
#if 0
		//matches the CoInitialize in startup
		CoUnintialize();
#endif
		gs_InitLock.Unlock();
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\makefile.inc ===
############################################################################

#

# Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
#
#   All rights reserved.
#
############################################################################

!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtencap.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <smir.h>

#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>
#include <evtencap.h>

extern CEventProviderWorkerThread* g_pWorkerThread ;

CEncapMapper::CEncapMapper() : m_WbemSnmpObj(NULL)
{
}


HRESULT CEncapMapper::GetSpecificPropertyValue(long lNumElements, MYWBEM_NAME_ELEMENT *aElements,
											long lFlags, VARIANT *pvValue)
{
	//all specific properties have one element, the property name...
	if ((lNumElements != 1) || (0 != aElements[0].m_nType))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificPropertyValue invalid parameters\r\n");
)
		return WBEM_E_FAILED;
	}

	BOOL bContinue = TRUE;

	if (NULL == m_WbemSnmpObj)
	{
		m_WbemSnmpObj = new WbemSnmpClassObject;
		IWbemClassObject *pObj = NULL;
		GetClassInstance(&pObj);

		if (NULL != pObj)
		{
			WbemSnmpErrorObject errorObj;

			if (!m_WbemSnmpObj->Set(errorObj, pObj, FALSE))
			{
				bContinue = FALSE;
			}
		}
		else
		{
			bContinue = FALSE;
		}
	}

	if (bContinue)
	{
		WbemSnmpProperty *snmpProp = m_WbemSnmpObj->FindProperty(aElements[0].Element.m_wszPropertyName);

		if (NULL != snmpProp)
		{
			//set the property value using the snmp varbind
			//and get the property value and return TRUE...
			if (SetAndGetProperty(snmpProp, pvValue))
			{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificPropertyValue successful\r\n");
)
				return NOERROR;
			}
		}
	}
	else if (NULL != m_WbemSnmpObj)
	{
		delete m_WbemSnmpObj;
		m_WbemSnmpObj = NULL;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificPropertyValue failed\r\n");
)

	return WBEM_E_FAILED;
}


CEncapMapper::~CEncapMapper()
{
	if (NULL != m_WbemSnmpObj)
	{
		delete m_WbemSnmpObj;
	}
}


BOOL CEncapMapper::SetAndGetProperty(WbemSnmpProperty *wbemSnmpProp, VARIANT *pvValue)
{
	//Get the varbind qualifier value, set the keyvalues qualifier and set the
	//property value using the snmp varbind.
	//Get the property value and return TRUE;
	WbemSnmpQualifier *vbQual = wbemSnmpProp->FindQualifier(EVENT_VBINDEX_QUAL);

	if (NULL == vbQual)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty missing parameter's vbindex qualifier\r\n");
)
		return FALSE;
	}

	VARIANT v;
	VariantInit(&v);
	ULONG vbindex;

	//has to be at least 3, i.e. third vb, to be a specific property...
	if (!vbQual->GetValue(v) || (VT_I4 != v.vt) || (2 > v.lVal))
	{
		VariantClear(&v);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty invalid index qual\r\n");
)
		return FALSE;
	}

	if (v.lVal >= m_vbs.length)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty no value return TRUE\r\n");
)
		return TRUE;
	}

	vbindex = v.lVal - 1; //zero based in our array
	VariantClear(&v);

	if (m_vbs.vbs[vbindex].fDone)
	{
		//we've done this one already,
		//just get the property value and return it..
		CIMTYPE cimType;

		if (!wbemSnmpProp->GetValue(*pvValue, cimType))
		{
			pvValue->vt = VT_NULL;
		}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty return value\r\n");
)		
		return TRUE;
	}

	const SnmpObjectIdentifier& vb_OID = m_vbs.vbs[vbindex].pVarBind->GetInstance();
	WbemSnmpQualifier *oidQual = wbemSnmpProp->FindQualifier(WBEM_QUALIFIER_OBJECT_IDENTIFIER);
	BOOL bMatchedOID = FALSE;
	m_vbs.vbs[vbindex].fDone = TRUE;		

	if (NULL == oidQual)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty missing parameter's OID qualifier\r\n");
)
	}
	else
	{
		SnmpInstanceType *oid_valuetype = oidQual->GetValue () ;

		if ( typeid ( *oid_valuetype ) == typeid ( SnmpObjectIdentifierType ) )
		{
			SnmpObjectIdentifier oid_value = *(SnmpObjectIdentifier *) oid_valuetype->GetValueEncoding () ; 
			
			//compare without the instance info
			if (oid_value.GetValueLength() < vb_OID.GetValueLength())
			{
				SnmpObjectIdentifier* common = vb_OID.Cut(oid_value);

				if (NULL != common)
				{
					if ((*common) == oid_value)
					{
						bMatchedOID = TRUE;
					}

					delete common;
				}
			}
		}
		else
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty parameter's OID is of wrong type\r\n");
)
		}

	}

	if (wbemSnmpProp->SetValue(&(m_vbs.vbs[vbindex].pVarBind->GetValue())))
	{
		CIMTYPE cimType;

		if (wbemSnmpProp->GetValue(*pvValue, cimType))
		{
		}
	}
	else
	{
		bMatchedOID = FALSE;
	}

	if (!bMatchedOID)
	{
		WbemSnmpQualifier *qualifier = NULL ;
		wbemSnmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

		if ( qualifier = wbemSnmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
		{
			IWbemQualifierSet *t_QualifierSet = NULL;
			IWbemClassObject *pObj = NULL;
			GetClassInstance(&pObj);

			HRESULT result = pObj->GetPropertyQualifierSet ( wbemSnmpProp->GetName () , & t_QualifierSet ) ;

			if ( SUCCEEDED ( result ) )
			{
				SnmpIntegerType integer ( 1 , NULL ) ;
				qualifier->SetValue ( t_QualifierSet , integer ) ;
			}

			t_QualifierSet->Release () ;
		}
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::SetAndGetProperty returning TRUE\r\n");
)
	return TRUE;
}

void CEncapMapper::GenerateInstance(IWbemClassObject** ppInst)
{
	if (NULL == ppInst)
	{
		//invalid out parameter
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance invalid parameter\r\n");
)
		return;
	}

	//set out parameter to NULL;
	*ppInst = NULL;
	IWbemClassObject *pObj = NULL;
	GetClassInstance(&pObj);

	if (NULL == pObj)
	{
		//failed to get class instance
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to get class defn\r\n");
)
		return;
	}

#if 0
	HRESULT result = S_OK ;
#else

	//get all the property names and set their values...
	SAFEARRAY* pPropNames;
	HRESULT result = pObj->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &pPropNames);

	if (FAILED(result))
	{
		//failed to get the property names
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to get parameter list\r\n");
)

		return;
	}
	
	//time to <insert expletive> around with a safearray...
	//work out the size of the safearray and access the data
	if(SafeArrayGetDim(pPropNames) != 1)
	{
		//wrong dimensions in this array
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance parameter array is WRONG!\r\n");
)
		return;
	}


	LONG arraylen = pPropNames->rgsabound[0].cElements;
	BSTR *pbstr;
	result = SafeArrayAccessData(pPropNames, (void **)&pbstr);

	if(FAILED(result))
	{
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to access parameter array\r\n");
)
		return;
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance setting properties\r\n");
)

	BOOL t_bSetProp = FALSE;

	//iterate through the names and set the properties...
	for (LONG i = 0; i < arraylen; i++)
	{
		VARIANT v;
		MYWBEM_NAME_ELEMENT property_struct;
		property_struct.m_nType = 0; //string value
		property_struct.Element.m_wszPropertyName = pbstr[i];
		result = GetPropertyValue(1, &property_struct, 0, &v);

		if (FAILED(result))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance failed to get value for %s\r\n",
		pbstr[i]);
)
			continue;
		}
		else
		{
			t_bSetProp = TRUE;
		}
		
		if ((v.vt != VT_NULL) && (v.vt != VT_EMPTY))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance setting property %s\r\n",
		pbstr[i]);
)
			result = pObj->Put(pbstr[i], 0, &v, 0);
DebugMacro9( 
			if (FAILED(result))
			{
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance setting property %s\r\n",
		pbstr[i]);
			}
)
			
		}
		
		VariantClear(&v);
	}
	
	SafeArrayUnaccessData(pPropNames);
	SafeArrayDestroy(pPropNames);

#endif

	//if a single property has been put send it on....
	if (t_bSetProp)
	{
		pObj->AddRef();
		*ppInst = pObj;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GenerateInstance returning\r\n");
)
}


void CEncapMapper::ResetData()
{
	//do class specific stuff then call parent class's reset
	if (NULL != m_WbemSnmpObj)
	{
		delete m_WbemSnmpObj;
		m_WbemSnmpObj = NULL;
	}

	CMapToEvent::ResetData();
}


BOOL CEncapMapper::GetSpecificClass()
{
	//Build path of mapper instance...
	CString path(MAPPER_CLASS_PATH_PREFIX);
	path += m_oid;
	path += '\"';
	BSTR pathstr = path.AllocSysString();
	IWbemClassObject *pObj = NULL;

	HRESULT result = g_pWorkerThread->GetServerWrap ()->GetMapperObject(pathstr, NULL, & pObj );

	SysFreeString(pathstr);

	if (result == S_OK)
	{
		VARIANT v;
		VariantInit(&v);
		result = pObj->Get(MAPPER_CLASS_EVENTCLASSPROP, 0, &v, NULL, NULL);
		pObj->Release();
		
		if (SUCCEEDED(result) && (VT_BSTR == v.vt))
		{
			m_class = v.bstrVal;
			VariantClear(&v);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificClass got class defn\r\n");
)
			return TRUE;
		}
		else
		{
			VariantClear(&v);
		}
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificClass failed to get class defn\r\n");
)

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtprov.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <classfac.h>

#include <smir.h>
#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

extern CRITICAL_SECTION g_CacheCriticalSection;
extern CEventProviderWorkerThread* g_pWorkerThread;

CWbemServerWrap::CWbemServerWrap(IWbemServices *pServ) : m_ref ( 0 ), m_Serv(NULL)
{
	m_Serv = pServ;

	if (m_Serv)
	{
		m_Serv->AddRef();
	}

	g_pWorkerThread->AddClassesToCache((DWORD_PTR)(&m_ClassMap), &m_ClassMap);
}

CWbemServerWrap::~CWbemServerWrap()
{
	if (m_Serv)
	{
		m_Serv->Release();
	}

	g_pWorkerThread->RemoveClassesFromCache((DWORD_PTR)(&m_ClassMap));
	m_ClassMap.RemoveAll();
}

ULONG CWbemServerWrap::AddRef()
{
	return (ULONG)(InterlockedIncrement(&m_ref));
}

ULONG CWbemServerWrap::Release()
{
	ULONG i = (ULONG)(InterlockedDecrement(&m_ref));

	if (i == 0)
	{
		delete this;
	}

	return i;
}

HRESULT CWbemServerWrap::GetMapperObject(BSTR a_path, IWbemContext *a_pCtx, IWbemClassObject **a_ppObj)
{
	if (a_ppObj == NULL)
	{
		return WBEM_E_FAILED;
	}

	*a_ppObj = NULL;
	HRESULT result = WBEM_NO_ERROR;
	SCacheEntry *t_CacheEntry = NULL;
	EnterCriticalSection ( & g_CacheCriticalSection ) ;

	if (!m_ClassMap.Lookup(a_path, t_CacheEntry))
	{
DebugMacro14( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"Cache Miss [%s]\r\n" , a_path
	);
)

		LPUNKNOWN pInterrogativeInt = NULL;

		result = CoCreateInstance (

			CLSID_SMIR_Database,
			NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
			IID_ISMIR_Interrogative, 
			(void**)&pInterrogativeInt
		);

		if ((result != S_OK) || (NULL == pInterrogativeInt))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEncapMapper::GetSpecificClass failed to connect to SMIR\r\n");
)
			return result ;
		}

		result = ((ISmirInterrogator*)pInterrogativeInt)->GetWBEMClass(a_ppObj, a_path);
		pInterrogativeInt->Release();

		if ( SUCCEEDED ( result ) )
		{
			t_CacheEntry = new SCacheEntry(*a_ppObj);
			m_ClassMap[a_path] = t_CacheEntry;
			(*a_ppObj)->AddRef();
		}
		else
		{
			t_CacheEntry = new SCacheEntry(NULL);
			m_ClassMap[a_path] = t_CacheEntry;
		}
	}
	else
	{
		if ( t_CacheEntry->m_Class )
		{
			*a_ppObj = t_CacheEntry->m_Class;
			(*a_ppObj)->AddRef();
		}
		else
		{
			result = WBEM_E_NOT_FOUND ;
		}
	}
	
	LeaveCriticalSection ( & g_CacheCriticalSection ) ;

	return result ;
}

HRESULT CWbemServerWrap::GetObject(BSTR a_path, IWbemContext *a_pCtx, IWbemClassObject **a_ppObj)
{
	if ((a_ppObj == NULL) || (m_Serv == NULL))
	{
		return WBEM_E_FAILED;
	}

	*a_ppObj = NULL;
	HRESULT result = WBEM_NO_ERROR;
	SCacheEntry *t_CacheEntry = NULL;
	EnterCriticalSection ( & g_CacheCriticalSection ) ;

	if (!m_ClassMap.Lookup(a_path, t_CacheEntry))
	{
DebugMacro14( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"Cache Miss [%s]\r\n" , a_path
	);
)

		result = m_Serv->GetObject(a_path, 0, a_pCtx, a_ppObj, NULL);

		if ( SUCCEEDED(result) )
		{
			t_CacheEntry = new SCacheEntry(*a_ppObj);
			m_ClassMap[a_path] = t_CacheEntry;
			(*a_ppObj)->AddRef();
		}
	}
	else
	{
		*a_ppObj = t_CacheEntry->m_Class;
		(*a_ppObj)->AddRef();
	}
	
	LeaveCriticalSection ( & g_CacheCriticalSection ) ;
	return result;
}


STDMETHODIMP CTrapEventProvider::Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
				)
{
	SetStructuredExceptionHandler seh;

	try
	{
DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
			L"Entering CTrapEventProvider::Initialize\n");
)

		m_pNamespace = new CWbemServerWrap(pCIMOM);
		m_pNamespace->AddRef();
		pInitSink->SetStatus ( WBEM_S_INITIALIZED , 0 );
	

DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
				L"Leaving CTrapEventProvider::Initialize with SUCCEEDED\n");
)

		return WBEM_NO_ERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}


STDMETHODIMP CTrapEventProvider::ProvideEvents(IWbemObjectSink* pSink, LONG lFlags)
{
	SetStructuredExceptionHandler seh;

	try
	{
DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
			L"Entering CTrapEventProvider::ProvideEvents\n");
)

		m_pEventSink = pSink;
		m_pEventSink->AddRef();
		
		if (!m_thrd->Register(this))
		{

DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
				L"Leaving CTrapEventProvider::ProvideEvents with FAILED\n");
)

			return WBEM_E_FAILED;
	}

DebugMacro9( 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
				L"Leaving CNTEventProvider::ProvideEvents with SUCCEEDED\n");
)

		return WBEM_NO_ERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	catch(...)
	{
		return WBEM_E_UNEXPECTED;
	}
}


CTrapEventProvider::~CTrapEventProvider()
{
	if (m_thrd)
	{
		m_thrd->UnRegister(this);
	}

	if ( m_pEventSink )
	{
		m_pEventSink->Release () ;
	}

	if ( m_pNamespace )
	{
		m_pNamespace->Release () ;
	}
}


CTrapEventProvider::CTrapEventProvider(DWORD mapperType, CEventProviderThread* thrd) 
:	m_thrd (NULL),
	m_pNamespace (NULL), 
	m_pEventSink (NULL)
{
	m_thrd = thrd;
	m_MapType = mapperType;
	m_ref = 0;
}


CWbemServerWrap* CTrapEventProvider::GetNamespace()
{
	m_pNamespace->AddRef();
	return m_pNamespace;
}

IWbemObjectSink* CTrapEventProvider::GetEventSink()
{
	m_pEventSink->AddRef();
	return m_pEventSink;
}
void CTrapEventProvider::ReleaseAll()
{
	//release dependencies
	m_pNamespace->Release();
	m_pEventSink->Release();

    if ( 0 != InterlockedDecrement(&m_ref) )
	{
        return;
	}

	delete this;
	InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
	return;
}

void  CTrapEventProvider::AddRefAll()
{
	//addref dependencies
	m_pNamespace->AddRef();
	m_pEventSink->AddRef();

	InterlockedIncrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
	InterlockedIncrement ( &m_ref ) ;
}

STDMETHODIMP_( ULONG ) CTrapEventProvider::AddRef()
{
	SetStructuredExceptionHandler seh;

	try
	{
		InterlockedIncrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
		return InterlockedIncrement ( &m_ref ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CTrapEventProvider::Release()
{
	SetStructuredExceptionHandler seh;

	try
	{
		long ret;

		if ( 0 != (ret = InterlockedDecrement(&m_ref)) )
		{
			InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
			return ret;
		}

		delete this;
		InterlockedDecrement(&(CSNMPEventProviderClassFactory::objectsInProgress));
		return 0;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP CTrapEventProvider::QueryInterface(REFIID riid, PVOID* ppv)
{
	SetStructuredExceptionHandler seh;

	try
	{
		*ppv = NULL;

		if (IID_IUnknown == riid)
		{
			*ppv= (IWbemEventProvider*)this;
		}
		else if (IID_IWbemEventProvider == riid)
		{
			*ppv=(IWbemEventProvider*)this;
		}
		else if (IID_IWbemProviderInit == riid)
		{
			*ppv=(IWbemProviderInit*)this;
		}

		if (NULL==*ppv)
		{
			return E_NOINTERFACE;
		}

		//AddRef any interface we'll return.
		((LPUNKNOWN)*ppv)->AddRef();	
		return NOERROR;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtreft.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>

#include <smir.h>
#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>
#include <evtreft.h>

extern CEventProviderWorkerThread* g_pWorkerThread ;

CReferentMapper::CReferentMapper()
{
}


CReferentMapper::~CReferentMapper()
{
}

HRESULT CReferentMapper::GetTypeAndIndexQuals(const wchar_t* prop, CIMTypeStruct& type, ULONG& index)
{
	IWbemClassObject* propObj = NULL;
	GetClassInstance(&propObj);

	if (NULL == propObj)
	{
		return WBEM_E_FAILED;
	}

	IWbemQualifierSet* pQuals = NULL;
	HRESULT result = propObj->GetPropertyQualifierSet((wchar_t*)prop, &pQuals);

	if (FAILED(result))
	{
		return result;
	}

	VARIANT v;
	result = pQuals->Get(EVENT_VBINDEX_QUAL, 0, &v, NULL);

	if (FAILED(result))
	{
		pQuals->Release();
		return result;
	}

	if (VT_I4 != v.vt)
	{
		VariantClear(&v);
		return WBEM_E_FAILED;
	}

	index = v.lVal;
	VariantClear(&v);
	result = pQuals->Get(EVENT_CIMTYPE_QUAL, 0, &v, NULL);
	pQuals->Release();

	if (FAILED(result))
	{
		return result;
	}

	if (VT_BSTR != v.vt)
	{
		VariantClear(&v);
		return WBEM_E_FAILED;
	}

#ifdef WHITESPACE_IN_CIMTYPE
	//Get rid of whitespace...
	CString cimtype;
	wchar_t* tmp = wcstok(v.bstrVal, WHITE_SPACE_CHARS);

	while (NULL != tmp)
	{
		cimtype += tmp;
		tmp = wcstok(NULL, WHITE_SPACE_CHARS);
	}
#else //WHITESPACE_IN_CIMTYPE
	CString cimtype = v.bstrVal;
#endif //WHITESPACE_IN_CIMTYPE

	VariantClear(&v);

	//determine if we're an object. If so get the classname...
	CString temp = cimtype.Left(OBJECT_STR_LEN);
	temp.MakeLower();

	if (temp == OBJECT_STR)
	{
		type.strType = cimtype.Mid(OBJECT_STR_LEN, cimtype.GetLength());
		type.fObject = TRUE;
	}
	else
	{
		type.fObject = FALSE;
	}

	return WBEM_NO_ERROR;
}

HRESULT CReferentMapper::GetSpecificPropertyValue(long lNumElements, MYWBEM_NAME_ELEMENT *aElements,
											long lFlags, VARIANT *pvValue)
{
	if ((lNumElements <= 0) || (NULL == aElements) || (NULL == pvValue))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue invalid parms\r\n");
)

		return WBEM_E_INVALID_PARAMETER;
	}

	HRESULT status = WBEM_E_FAILED;

	//specific properties after first two varbinds
	if ((0 == aElements[0].m_nType) && (m_vbs.length > 2))
	{
		//first check it has the correct VBIndex and CIMType qualifiers...
		CIMTypeStruct proptype;
		ULONG propvbindex;

		if (FAILED(GetTypeAndIndexQuals(aElements[0].Element.m_wszPropertyName,
																	proptype, propvbindex)))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue failed to get index quals\r\n");
)
			return status;
		}

		if (propvbindex >= m_vbs.length)
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue invalid index return TRUE\r\n");
)
			return WBEM_NO_ERROR;
		}

		//we're zero indexed in this world!
		propvbindex--;

		if (lNumElements == 1)
		{
			if (m_vbs.vbs[propvbindex].fDone)
			{
				//we've done this one already,
				//just get the property value and return it...
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue return value\r\n");
)
				return m_object->Get(aElements[0].Element.m_wszPropertyName, 0, pvValue, 0, 0);
			}

			if (proptype.fObject)
			{
				//get the embedded class object in full for the property asked for
				IWbemClassObject* pObj = NULL;
				if (SUCCEEDED(CreateEmbeddedProperty(&pObj, propvbindex,
								aElements[0].Element.m_wszPropertyName, proptype.strType)))
				{
					//created the property, set the variant value and return successfully
					//NOTE: as soon as the variant is cleared, the object will be released
					pvValue->vt = VT_UNKNOWN;
					pvValue->punkVal = pObj;
				}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue return value\r\n");
)
				return WBEM_NO_ERROR;
			}
			else
			{
				//MUST be an embedded property otherwise fail!
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificPropertyValue invlaid params\r\n");
)
				return WBEM_E_FAILED;
			}
		}
#ifdef FILTERING

will not compile as there are still a couple of TO DOs left undone...

		else if (0 == aElements[1].m_nType)
		{
			if (lNumElements == 2)
			{
//TO DO:
//======
				//get a single property value of the embedded object
			}
			else if ((lNumElements == 3) && (1 == aElements[1].m_nType))
			{
//TO DO:
//======
				//only if we're an array property of the embedded object
			}
		}
#endif //FILTERING

	}

	return status;
}


HRESULT CReferentMapper::CreateEmbeddedProperty(IWbemClassObject** ppObj,
											ULONG index,
											const wchar_t* propertyName,
											const wchar_t* className)
{
	if (NULL == ppObj)
	{
		//invalid out parameter
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::CreateEmbeddedProperty invalid parameter\r\n");
)
		return WBEM_E_INVALID_PARAMETER;
	}

	IWbemClassObject* pClass = NULL;

	//specify no correlation to the class provider
	IWbemContext *pCtx = NULL;

	HRESULT result = CoCreateInstance(CLSID_WbemContext, NULL,
						CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
						IID_IWbemContext, (void**)&pCtx);
	
	if (SUCCEEDED(result))
	{
		VARIANT vCtx;
		VariantInit (&vCtx);
		vCtx.vt = VT_BOOL;
		vCtx.boolVal = VARIANT_FALSE;
		result = pCtx->SetValue(WBEM_CLASS_CORRELATE_CONTEXT_PROP, 0, &vCtx);
		VariantClear(&vCtx);

		if (FAILED(result))
		{
			pCtx->Release();
			pCtx = NULL;
		}
	}
	else
	{
		pCtx = NULL;
	}

	BSTR t_className = SysAllocString(className);
	result = m_nspace->GetObject(t_className, pCtx, &pClass);
	SysFreeString(t_className);

	if (pCtx != NULL)
	{
		pCtx->Release();
	}

	if (FAILED(result))
	{
		return result;
	}

	result = pClass->SpawnInstance(0, ppObj);

	if (FAILED(result))
	{
		pClass->Release();
		return result;
	}

	//set the varbind as decoded and make sure the notification instance has been created...
	IWbemClassObject* ptmpObj = NULL;
	GetClassInstance(&ptmpObj);

	if (NULL == m_object)
	{
		pClass->Release();
		return WBEM_E_FAILED;
	}

	m_vbs.vbs[index].fDone = TRUE;
	WbemSnmpClassObject snmpObj;
	WbemSnmpErrorObject errorObj;

	if (!snmpObj.Set(errorObj, pClass, FALSE))
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	snmpObj.SetIsClass(FALSE);
	snmpObj.ResetProperty () ;
	WbemSnmpProperty *snmpProp = snmpObj.NextProperty ();

	//set all properties to NULL...
	while (snmpProp != NULL)
	{
		snmpProp->SetValue(*ppObj, (SnmpValue*)NULL);
		snmpProp = snmpObj.NextProperty ();
	}

	snmpProp = snmpObj.FindProperty((wchar_t*)propertyName);

	if (NULL == snmpProp)
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	BOOL bSetKeyValue = FALSE;

	if (!snmpProp->SetValue(&(m_vbs.vbs[index].pVarBind->GetValue())))
	{
		snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
		WbemSnmpQualifier *qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

		if ( qualifier )
		{
			VARIANT tmp_V;
			VariantInit(&tmp_V);
			tmp_V.vt = VT_BOOL;
			tmp_V.boolVal = VARIANT_TRUE;
			qualifier->SetValue(tmp_V);
			VariantClear(&tmp_V);
		}
	}
	else
	{
		WbemSnmpQualifier *qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_KEY ) ;

		if ( qualifier )
		{
			VARIANT tmp_V;
			VariantInit(&tmp_V);
			
			if (qualifier->GetValue(tmp_V))
			{
				if ((tmp_V.vt = VT_BOOL) && (tmp_V.boolVal == VARIANT_TRUE))
				{
					bSetKeyValue = TRUE;
				}
			}

			VariantClear(&tmp_V);
		}
	}

	//have set the property, now set the key properties...
	//first get the instance info...
	const SnmpObjectIdentifier& id = m_vbs.vbs[index].pVarBind->GetInstance();
	IWbemQualifierSet* pQuals = NULL;
	result = pClass->GetPropertyQualifierSet((wchar_t*)propertyName, &pQuals);

	if (FAILED(result))
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	VARIANT v;
	result = pQuals->Get(OID_ATTRIBUTE, 0, &v, NULL);
	pQuals->Release();

	if ((FAILED(result)) || (VT_BSTR != v.vt))
	{
		pClass->Release();
		VariantClear(&v);
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	SnmpObjectIdentifierType propoidtype(v.bstrVal); 
	VariantClear(&v);

	if (!propoidtype.IsValid())
	{
		pClass->Release();
		(*ppObj)->Release();
		*ppObj = NULL;
		return WBEM_E_FAILED;
	}

	SnmpObjectIdentifier propoid(propoidtype.GetValue(), propoidtype.GetValueLength());
	SnmpObjectIdentifier* prefix = id.Cut(propoid);
	BOOL fsuccess = FALSE;
	SnmpObjectIdentifier* instinfo = new SnmpObjectIdentifier ( NULL , 0 ) ;

	if ((prefix != NULL) && (*prefix == propoid))
	{
		fsuccess = id.Suffix(propoid.GetValueLength(),*instinfo);
		
		if (instinfo->GetValue() == NULL)
		{
			fsuccess = FALSE;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			WbemSnmpQualifier *qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

			if ( qualifier )
			{
				VARIANT tmp_V;
				VariantInit(&tmp_V);
				tmp_V.vt = VT_BOOL;
				tmp_V.boolVal = VARIANT_TRUE;
				qualifier->SetValue(tmp_V);
				VariantClear(&tmp_V);
			}
		}
	}

	if (prefix != NULL)
	{
		delete prefix;
	}

	if ( fsuccess )
	{
		if (snmpObj.IsKeyed())
		{
			snmpObj.ResetKeyProperty() ;
			
			while ( fsuccess && (snmpProp = snmpObj.NextKeyProperty()) )
			{
				//set all the key properties using the instance info...
				SnmpInstanceType *decodeValue = snmpProp->GetValue()->Copy();
				SnmpObjectIdentifier t_DecodedValue = decodeValue->Decode(*instinfo) ;
				SnmpObjectIdentifier *decodedObject = new SnmpObjectIdentifier( t_DecodedValue ) ;
				
				if (*decodeValue)
				{
					if (!snmpProp->SetValue(decodeValue))
					{
						fsuccess = FALSE;
					}
				}
				else
				{
					fsuccess = FALSE;
				}

				delete decodeValue ;
				delete instinfo ;
				instinfo = decodedObject ;
				snmpProp = snmpObj.NextKeyProperty();
			}

			if (fsuccess && instinfo->GetValueLength())
			{
				//instance info left after keys have been set
				fsuccess = FALSE;
			}
		}
		else
		{
			if ( (0 != *(instinfo->GetValue())) || (1 != instinfo->GetValueLength()) )
			{
				//invalid instance info for scalar...
				fsuccess = FALSE;
			}
		}
	}

	delete instinfo;
	pClass->Release();

	if (!fsuccess)
	{
		snmpObj.ResetKeyProperty () ;
		VARIANT tmp_V;
		VariantInit(&tmp_V);
		tmp_V.vt = VT_BOOL;
		tmp_V.boolVal = VARIANT_TRUE;

		while ( snmpProp = snmpObj.NextKeyProperty () )
		{
			WbemSnmpQualifier *qualifier = NULL ;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

			if ( qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
			{
				qualifier->SetValue(tmp_V);
			}
			else
			{
				// Problem Here
			}
		}

		if (snmpProp = snmpObj.FindProperty((wchar_t*)propertyName))
		{
			WbemSnmpQualifier *qualifier = NULL ;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;

			if ( qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
			{
				qualifier->SetValue(tmp_V);
			}
			else
			{
				// Problem Here
			}
		}

		VariantClear(&tmp_V);
	}

	//check that setting the key values hasn't altered our value, it may be a key
	if ( bSetKeyValue && (snmpProp = snmpObj.FindProperty((wchar_t*)propertyName)) )
	{
		if (*(snmpProp->GetValue()->GetValueEncoding()) != m_vbs.vbs[index].pVarBind->GetValue())
		{
			//set it back to the varbind value and set the error qualifier on the property
			snmpProp->SetValue(&(m_vbs.vbs[index].pVarBind->GetValue()));

			WbemSnmpQualifier *qualifier = NULL ;
			snmpProp->AddQualifier ( WBEM_QUALIFIER_VALUE_MISMATCH ) ;

			if ( qualifier = snmpProp->FindQualifier ( WBEM_QUALIFIER_VALUE_MISMATCH ) )
			{
				VARIANT tmp_V;
				VariantInit(&tmp_V);
				tmp_V.vt = VT_BOOL;
				tmp_V.boolVal = VARIANT_TRUE;
				qualifier->SetValue(tmp_V);
				VariantClear(&tmp_V);
			}
			else
			{
				// Problem Here
			}

		}
	}

	//generate class object from snmpObj and return success
	if (snmpObj.Get(errorObj, *ppObj))
	{
		//add the property to the notification object...
		VARIANT vObj;
		vObj.vt = VT_UNKNOWN;
		vObj.punkVal = *ppObj;
		(*ppObj)->AddRef();
		result = m_object->Put((wchar_t*)propertyName, 0, &vObj, 0);

		if (SUCCEEDED(result))
		{
			VariantClear(&vObj);
DebugMacro9( 
SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
	__FILE__,__LINE__,
	L"CReferentMapper::CreateEmbeddedProperty succeeded\r\n");
)
			return WBEM_NO_ERROR;
		}
		else
		{
			VariantClear(&vObj);
			(*ppObj)->Release();
			*ppObj = NULL;
			return WBEM_E_FAILED;
		}
		
	}

	return WBEM_E_FAILED;
}


void CReferentMapper::GenerateInstance(IWbemClassObject** ppInst)
{
	if (NULL == ppInst)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance invalid parameter\r\n");
)

		//invalid out parameter
		return;
	}

	//set out parameter to NULL;
	*ppInst = NULL;
	IWbemClassObject *pObj = NULL;
	GetClassInstance(&pObj);

	if (NULL == pObj)
	{
		//failed to get class instance
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to get class defn\r\n");
)
		return;
	}

	//get all the property names and set their values...
	SAFEARRAY* pPropNames;
	HRESULT result = pObj->GetNames(NULL, WBEM_FLAG_NONSYSTEM_ONLY, NULL, &pPropNames);

	if (FAILED(result))
	{
		//failed to get the property names
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to get property array\r\n");
)
		return;
	}
	
	//time to <insert expletive> around with a safearray...
	//work out the size of the safearray and access the data
	if(SafeArrayGetDim(pPropNames) != 1)
	{
		//wrong dimensions in this array
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance property array has wrong DIM\r\n");
)
		return;
	}


	LONG arraylen = pPropNames->rgsabound[0].cElements;
	BSTR *pbstr;
	result = SafeArrayAccessData(pPropNames, (void **)&pbstr);

	if(FAILED(result))
	{
		SafeArrayDestroy(pPropNames);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to access property array\r\n");
)
		return;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance set properties\r\n");
)

	BOOL t_bSetProp = FALSE;

	//iterate through the names and set the properties...
	for (LONG i = 0; i < arraylen; i++)
	{
		VARIANT v;
		MYWBEM_NAME_ELEMENT property_struct;
		property_struct.m_nType = 0; //string value
		property_struct.Element.m_wszPropertyName = pbstr[i];
		result = GetPropertyValue(1, &property_struct, 0, &v);

		if (FAILED(result))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed to get value for %s\r\n",
		pbstr[i]);
)
			continue;
		}
		else
		{
			t_bSetProp = TRUE;
		}
		
		if ((v.vt != VT_NULL) && (v.vt != VT_EMPTY))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance setting value for %s\r\n",
		pbstr[i]);
)
			result = pObj->Put(pbstr[i], 0, &v, 0);
DebugMacro9( 
			if (FAILED(result))
			{
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance failed setting value for %s\r\n",
		pbstr[i]);
			}
)
		}
		
		VariantClear(&v);
	}
	
	SafeArrayUnaccessData(pPropNames);
	SafeArrayDestroy(pPropNames);

	//if a single property has been put send it on....
	if (t_bSetProp)
	{
		pObj->AddRef();
		*ppInst = pObj;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GenerateInstance finished\r\n");
)
}


void CReferentMapper::ResetData()
{
	//do class specific stuff then call parent class's reset

	CMapToEvent::ResetData();
}


BOOL CReferentMapper::GetSpecificClass()
{
	//Build path of mapper instance...
	CString path(EXTMAPPER_CLASS_PATH_PREFIX);
	path += m_oid;
	path += '\"';
	BSTR pathstr = path.AllocSysString();
	IWbemClassObject *pObj = NULL;

	HRESULT result = g_pWorkerThread->GetServerWrap ()->GetMapperObject(pathstr, NULL, & pObj );

	SysFreeString(pathstr);

	if (result == S_OK)
	{
		VARIANT v;
		VariantInit(&v);
		result = pObj->Get(MAPPER_CLASS_EVENTCLASSPROP, 0, &v, NULL, NULL);
		pObj->Release();
		
		if (SUCCEEDED(result) && (VT_BSTR == v.vt))
		{
			m_class = v.bstrVal;
			VariantClear(&v);
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificClass got the specific class defn\r\n");
)
			return TRUE;
		}
		else
		{
			VariantClear(&v);
		}
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CReferentMapper::GetSpecificClass failed to get specific class defn\r\n");
)
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtmap.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>

#include <smir.h>
#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

#include <winsock2.h>

CMapToEvent::CMapToEvent() : m_vbdefn(NULL), m_vbs(NULL, 0)
{
	m_btriedGeneric = FALSE;
	m_btryGeneric = FALSE;
	m_bCheckedVersion = FALSE;
	m_object = NULL;
	m_nspace = NULL;
}

CMapToEvent::~CMapToEvent()
{
	if (m_vbs.vbs)
	{
		delete [] m_vbs.vbs;
	}

	if (m_vbdefn)
	{
		m_vbdefn->Release();
	}
}


void CMapToEvent::ResetData()
{
	m_btriedGeneric = FALSE;
	m_btryGeneric = FALSE;
	m_bCheckedVersion = FALSE;
	m_class.Empty();

	if(m_vbs.vbs)
	{
		delete [] m_vbs.vbs;
		m_vbs.vbs = NULL;
		m_vbs.length = 0;
	}

	if (m_object)
	{
		m_object->Release();
		m_object = NULL;
	}
}


void CMapToEvent::SetTryGeneric()
{
	m_btriedGeneric = TRUE;
	m_btryGeneric = TRUE;
}

BOOL CMapToEvent::IsSNMPv1()
{
	if (!m_bCheckedVersion)
	{
		m_bCheckedVersion = TRUE;
		m_bSNMPv1 = FALSE;

		//is v1 if the last varbind has objid = snmpTrapEnterprise.0
		//and the trapOID truncated by it last sub-id equals the last
		//varbind's value with a .0 appended.

		//Get the last varbind's oid and make sure it's the enterpriseOid
		const SnmpObjectIdentifier& id = m_vbs.vbs[m_vbs.length - 1].pVarBind->GetInstance();
		const SnmpValue& snmp_val = m_vbs.vbs[m_vbs.length - 1].pVarBind->GetValue();

		if ((id != SNMP_ENT_OID) || (typeid(SnmpObjectIdentifier) != typeid(snmp_val)))
		{
			return FALSE;
		}

		//create the trapoid and truncate the last subid
		SnmpObjectIdentifierType trapid(m_oid);
		SnmpObjectIdentifier trunctrapid(trapid.GetValue(), trapid.GetValueLength() - 1);
		
		//now add .0 to the value of the enterpriseOid
		ULONG val[1] = {0};
		SnmpObjectIdentifier zeroid(val, 1);
		SnmpObjectIdentifier extendoid((const SnmpObjectIdentifier&)snmp_val + zeroid);

		m_bSNMPv1 = (extendoid == trunctrapid);
	}

	return m_bSNMPv1;
}

void CMapToEvent::SetData(const char* sender_addr, const char* security_Context,
					const char* snmpTrapOid, const char* transport,
					SnmpVarBindList& vbList, CWbemServerWrap* nspace)
{
	m_nspace = nspace;
	m_addr = sender_addr;
	m_ctxt = security_Context;
	m_oid = snmpTrapOid;
	m_transport = transport;
	UINT length = vbList.GetLength();

	if (length >= 2) //must have at least two varbinds!
	{
		m_vbs.vbs = new VarBindObjectStruct[length];
		m_vbs.length = length;
		vbList.Reset();
		
		for (UINT i=0; i < length; i++)
		{
			vbList.Next () ;
			m_vbs.vbs[i].fDone = FALSE;
			m_vbs.vbs[i].pVarBind = (SnmpVarBind*) vbList.Get();
		}
	}
	else
	{
		m_vbs.vbs = NULL;
		m_vbs.length = 0;
	}
}

void CMapToEvent::GetClassInstance(IWbemClassObject **ppObj)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClassInstance getting class object\r\n");
)

	if (m_object != NULL)
	{
		*ppObj = m_object;
		return;
	}

	if (m_class.IsEmpty())
	{
		if (!GetClass() || m_class.IsEmpty())
		{
			*ppObj = NULL;
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClassInstance failed to get class name\r\n");
)
			return;
		}
	}
	
	BSTR path = m_class.AllocSysString();

	if (SUCCEEDED(m_nspace->GetObject(path, NULL, ppObj )))
	{
		if (FAILED((*ppObj)->SpawnInstance(0, &m_object)))
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClassInstance failed to spawn instance\r\n");
)
			m_object = NULL;
		}
		else
		{
DebugMacro9(
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
			L"CMapToEvent::GetClassInstance got instance\r\n");
)		
		}

		(*ppObj)->Release();
	}
	else
	{
DebugMacro9(
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
			__FILE__,__LINE__,
			L"CMapToEvent::GetClassInstance failed to get class definition\r\n");
)		
	}

	SysFreeString(path);
	*ppObj = m_object;
}

HRESULT CMapToEvent::GetPropertyValue(long lNumElements, MYWBEM_NAME_ELEMENT *aElements,
											long lFlags, VARIANT *pvValue)
{
	VariantInit(pvValue);

	if ((lNumElements == 0) || (NULL == aElements) || (NULL == pvValue) || (pvValue->vt != VT_EMPTY))
	{
		return E_INVALIDARG;
	}

	if (m_vbs.length == 0)
	{
		return WBEM_E_FAILED;
	}

	//try the standard properties first
	HRESULT result = GetStandardProperty(lNumElements, aElements, lFlags, pvValue);

	if (SUCCEEDED(result))
	{
		return result;
	}

	if (m_class.IsEmpty())
	{
		if (!GetClass() || m_class.IsEmpty())
		{
			return WBEM_E_FAILED;
		}
	}

	if (TriedGeneric())
	{
		//if we are generic, check the varbind properties
		return GetVBProperty(lNumElements, aElements, lFlags, pvValue);
	}
	else
	{
		//else check the specific properties...
		return GetSpecificPropertyValue(lNumElements, aElements, lFlags, pvValue);
	}
	
	return WBEM_E_FAILED;
}


HRESULT CMapToEvent::GetStandardProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue)
{
	if ((lNumElements == 1) && (0 == aElements[0].m_nType)) //the property name!
	{
		if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, WBEMS_CLASS_PROP))
		{
			if (m_class.IsEmpty())
			{
				if (!GetClass() || m_class.IsEmpty())
				{
					return E_FAIL;
				}
			}
			
			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_class.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_SOID_PROP))
		{
			if (m_oid.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_oid.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_ADDR_PROP))
		{
			if (m_addr.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_addr.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_TADDR_PROP))
		{
			if (m_addr.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_addr.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_TRANS_PROP))
		{
			if (m_transport.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_transport.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_COMM_PROP))
		{
			if (m_ctxt.IsEmpty())
			{
					return E_FAIL;
			}

			pvValue->vt = VT_BSTR;
			pvValue->bstrVal = m_ctxt.AllocSysString();
		}
		else if (0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_TIME_PROP))
		{
			const SnmpObjectIdentifier& id = m_vbs.vbs[0].pVarBind->GetInstance();

			if (id != SNMP_SYS_UP_OID)
			{
				return E_FAIL;
			}

			const SnmpValue& val = m_vbs.vbs[0].pVarBind->GetValue();

			if (typeid(SnmpTimeTicks) == typeid(val))
			{
				pvValue->vt = VT_I4;
				pvValue->lVal = ((const SnmpTimeTicks&)val).GetValue();
			}
			else
			{
				return E_FAIL;
			}
		}
		else
		{
			return E_FAIL;
		}
	}
	else
	{
		return E_FAIL; //no standard property has more than one element to its name
	}
				
	return S_OK; //got the property!
}

HRESULT CMapToEvent::GetVBProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue)
{
	if ((lNumElements <= 0) || (NULL == aElements) || (NULL == pvValue))
	{
		return E_INVALIDARG;
	}

	HRESULT status = E_FAIL;

	if ((0 == aElements[0].m_nType) && (m_vbs.length > 2) &&
		(0 == _wcsicmp(aElements[0].Element.m_wszPropertyName, EVENT_VBL_PROP)) ) 
	{
		//the property name is correct...

		if (lNumElements == 1)
		{
			//all the varbinds except 1 and 2...
			//create the classobjects stick 'em in a safearray and send 'em back!
			SAFEARRAYBOUND rgsabound[1];
			SAFEARRAY* psa;
			rgsabound[0].lLbound = 0;
			rgsabound[0].cElements = m_vbs.length - 2;
			psa = SafeArrayCreate(VT_UNKNOWN, 1, rgsabound);
			LONG ix;
			BOOL berror = FALSE;

			for (UINT i = 2; i < m_vbs.length; i++)
			{
				IWbemClassObject* vbobj = GetVBClassObjectByIndex(i);

				if (NULL != vbobj)
				{
					 ix = i-2;

					if ( S_OK != SafeArrayPutElement(psa, &ix, (IUnknown *)vbobj))
					{
						vbobj->Release ();
						berror = TRUE;
						break;
					}

					vbobj->Release ();
				}
				else
				{
					berror = TRUE;
					break;
				}
			}

			if (berror)
			{
				SafeArrayDestroy(psa);
			}
			else
			{
				status = WBEM_NO_ERROR;
				pvValue->vt = VT_ARRAY | VT_UNKNOWN;
				pvValue->parray = psa;
			}
		}
		else if ((1 == aElements[1].m_nType) && (m_vbs.length  > (aElements[1].Element.m_lArrayIndex + 2)))
		{
			if (lNumElements == 2)
			{
				//get the n(= aElements[1].Element.m_lArrayIndex + 2)th varbind
				//create a classobject with it and send back the class object
				IWbemClassObject* vbobj = GetVBClassObjectByIndex(aElements[1].Element.m_lArrayIndex + 2);
				
				if (NULL != vbobj)
				{
					status = WBEM_NO_ERROR;
					pvValue->vt = VT_UNKNOWN;
					pvValue->punkVal = (IUnknown*) vbobj;
				}
			}
			else if (0 == aElements[2].m_nType)
			{
				if (lNumElements == 3)
				{
					//get the single property value
					int cmpval = _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_OBJID_PROP2);

					if (0 == cmpval)
					{
						//get the objectid
						if (GetVBPropOIDByIndex((aElements[1].Element.m_lArrayIndex + 2), *pvValue))
						{
							status = WBEM_NO_ERROR;
						}

					}
					else if ((cmpval > 0) &&
						(0 == _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_ENCODING_PROP1)))
					{
						//get the ASNType (Encoding < ObjectIdentifier)
						CString t;

						if (GetVBPropValueByIndex((aElements[1].Element.m_lArrayIndex + 2), t, *pvValue))
						{
							VariantClear(pvValue);
							status = WBEM_NO_ERROR;
							pvValue->vt = VT_BSTR;
							pvValue->bstrVal = t.AllocSysString();
						}
					}
					else if (0 == _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_VALUE_PROP3))
					{
						//get the Value (Value < ObjectID)
						CString t;

						if (GetVBPropValueByIndex((aElements[1].Element.m_lArrayIndex + 2), t, *pvValue))
						{
							status = WBEM_NO_ERROR;
						}
					}
				}
				else if ((lNumElements == 4) && (1 == aElements[3].m_nType) &&
					(0 == _wcsicmp(aElements[2].Element.m_wszPropertyName, VB_VALUE_PROP3)) )
				{
					//get the byte value of Value[x]
					CString t;
					VARIANT v;

					if (GetVBPropValueByIndex((aElements[1].Element.m_lArrayIndex + 2), t, v))
					{
						if ((VT_ARRAY | VT_UI1) == v.vt)
						{
							LONG ix = aElements[3].Element.m_lArrayIndex;
							UCHAR datum;

							if (S_OK == SafeArrayGetElement(v.parray, &ix, (void*)&datum))
							{
								status = WBEM_NO_ERROR;
								pvValue->vt = VT_UI1;
								pvValue->bVal = datum;
							}
						}

						VariantClear(&v);
					}
				}
			}
		}
	}

	return status;
}

IWbemClassObject* CMapToEvent::GetVBClassDefn()
{
	if (NULL == m_vbdefn)
	{
		BSTR path = SysAllocString(VB_CLASS_PATH);
		m_nspace->GetObject(path, NULL, &m_vbdefn ) ;
		SysFreeString(path);
	}

	return m_vbdefn;
}

IWbemClassObject* CMapToEvent::GetVBClassObjectByIndex(UINT index)
{
	IWbemClassObject* ret = NULL;

	if (NULL != GetVBClassDefn())
	{
		if (SUCCEEDED(m_vbdefn->SpawnInstance(0, &ret)))
		{
			CString type;
			VARIANT vV;

			if (GetVBPropValueByIndex(index, type, vV))
			{
				BSTR asntypeprop = SysAllocString(VB_ENCODING_PROP1);
				VARIANT vT;
				vT.vt = VT_BSTR;
				vT.bstrVal = type.AllocSysString();

				//set the type and value.
				if (SUCCEEDED(ret->Put(asntypeprop, 0, &vT, 0)))
				{
					BSTR valueprop = SysAllocString(VB_VALUE_PROP3);
					VARIANT* pV = &vV;
					VARTYPE Vtype = 0;

					if ((VT_EMPTY == vV.vt) || (VT_EMPTY == vV.vt))
					{
						Vtype = VT_ARRAY|VT_UI1; //default type
						pV = NULL;
					}

					if (SUCCEEDED(ret->Put(valueprop, 0, pV, Vtype)))
					{
						VARIANT vID;

						//get the oid
						if(GetVBPropOIDByIndex(index, vID))
						{
							BSTR oidprop = SysAllocString(VB_OBJID_PROP2);

							//set the oid
							if (FAILED(ret->Put(oidprop, 0, &vID, 0)))
							{
								ret->Release();
								ret = NULL;
							}

							SysFreeString(oidprop);
							VariantClear(&vID);
						}
						else
						{
							ret->Release();
							ret = NULL;
						}
					}
					else
					{
						ret->Release();
						ret = NULL;
					}
					
					SysFreeString(valueprop);
				}
				else //failed to put the type property
				{
					ret->Release();
					ret = NULL;
				}

				VariantClear(&vT);
				SysFreeString(asntypeprop);
				VariantClear(&vV);
			}
			else //failed to SpawnInstance
			{
				ret->Release();
				ret = NULL;
			}
		}
	}

	return ret;
}


//index assumed to be in valid range
BOOL CMapToEvent::GetVBPropValueByIndex(UINT index, CString& type, VARIANT& vval)
{
	const SnmpValue& val = m_vbs.vbs[index].pVarBind->GetValue();
	
	//the data is an array of bytes...
	SAFEARRAYBOUND rgsabound[1];
	SAFEARRAY* psa;
	rgsabound[0].lLbound = 0;
	VariantInit(&vval);

	if (typeid(SnmpNull) == typeid(val))
	{
		type = ASN_NULL;
	}
	else if (typeid(SnmpNoSuchObject) == typeid(val))
	{
		type = ASN_NSO;
	}
	else if (typeid(SnmpNoSuchInstance) == typeid(val))
	{
		type = ASN_NSI;
	}
	else if (typeid(SnmpEndOfMibView) == typeid(val))
	{
		type = ASN_EOMV;
	}
	else if (typeid(SnmpInteger) == typeid(val))
	{
		type = ASN_INTEGER;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpInteger&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpGauge) == typeid(val))
	{
		type = ASN_GUAGE;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpGauge&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpCounter) == typeid(val))
	{
		type = ASN_COUNTER;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpCounter&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpTimeTicks) == typeid(val))
	{
		type = ASN_TIME;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpTimeTicks&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpOctetString) == typeid(val))
	{
		type = ASN_OCTET;
		UCHAR* pdata;
		UINT datalen = (((const SnmpOctetString&)val).GetValueLength()) * sizeof(UCHAR);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UCHAR* data = ((const SnmpOctetString&)val).GetValue();
		memcpy((void *)pdata, (void *)data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpOpaque) == typeid(val))
	{
		type = ASN_OPAQUE;
		UCHAR* pdata;
		UINT datalen = (((const SnmpOpaque&)val).GetValueLength()) * sizeof(UCHAR);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UCHAR* data = ((const SnmpOpaque&)val).GetValue();
		memcpy((void *)pdata, (void *)data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpObjectIdentifier) == typeid(val))
	{
		type = ASN_OID;
		UCHAR* pdata;
		UINT datalen = (((const SnmpObjectIdentifier&)val).GetValueLength()) * sizeof(ULONG);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		ULONG* data = ((const SnmpObjectIdentifier&)val).GetValue();
		memcpy((void *)pdata, (void *)data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpIpAddress) == typeid(val))
	{
		type = ASN_ADDR;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = htonl(((const SnmpIpAddress&)val).GetValue());
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpUInteger32) == typeid(val))
	{
		type = ASN_UINT32;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = datalen;
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpUInteger32&)val).GetValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else if(typeid(SnmpCounter64) == typeid(val))
	{
		type = ASN_COUNTER64;
		UCHAR* pdata;
		UINT datalen = sizeof(UINT);
		rgsabound[0].cElements = (datalen * 2);
		psa = SafeArrayCreate(VT_UI1, 1, rgsabound);

		if (NULL == psa)
		{
			return FALSE; //out of memory!!!
		}

		if (FAILED(SafeArrayAccessData(psa, (void HUGEP* FAR*)&pdata)))
		{
			return FALSE;
		}
		
		UINT data = ((const SnmpCounter64&)val).GetHighValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		pdata += datalen;
		data = ((const SnmpCounter64&)val).GetLowValue();
		memcpy((void *)pdata, (void *)&data, datalen);
		SafeArrayUnaccessData(psa);
		vval.vt = VT_ARRAY|VT_UI1;
		vval.parray = psa;
	}
	else
	{
		//should not get here!
		return FALSE;
	}

	return TRUE;
}


//index assumed to be in valid range
BOOL CMapToEvent::GetVBPropOIDByIndex(UINT index, VARIANT& vOid)
{
	const SnmpObjectIdentifier& id = m_vbs.vbs[index].pVarBind->GetInstance();
	char * oid = id.GetAllocatedString();

	if (NULL != oid)
	{
		VariantInit(&vOid);
		CString oidstr(oid);
		delete [] oid;
		vOid.vt = VT_BSTR;
		vOid.bstrVal = oidstr.AllocSysString();
		return TRUE;
	}

	return FALSE;
}


//sets the m_class variable. if btryGeneric is set gets the generic class.
//if m_btryGeneric is not set and a generic class is returned m_btriedGeneric
//must be set to true.
BOOL CMapToEvent::GetClass()
{
	if (!m_btryGeneric)
	{
		if (GetSpecificClass())
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClass got specific class\r\n");
)
			return TRUE;
		}
	}

	SetTryGeneric();

	if (IsSNMPv1())
	{
		m_class = GetV1Class();
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClass getting V1 class\r\n");
)
	}
	else
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CMapToEvent::GetClass getting V2 class\r\n");
)
		m_class = GetV2Class();
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\main.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#define _WIN32_WINNT 0x0400
#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <instpath.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <guids.h>
#include <classfac.h>

DWORD g_InstanceRegister = 0 ;
DWORD g_ClassRegister = 0 ;
DWORD g_EventReferentRegister = 0 ;
DWORD g_EventEncapsulatedRegister = 0 ;

STDAPI DllRegisterServer () ;
STDAPI DllUnregisterServer () ;

BOOL s_Exiting = FALSE ;

LONG CALLBACK WindowsMainProc ( HWND a_hWnd , UINT a_message , WPARAM a_wParam , LPARAM a_lParam )
{
	long t_rc = 0 ;

	switch ( a_message )
	{
        case WM_CLOSE:
        {
            s_Exiting = TRUE ;
        }
        break ;

		case WM_DESTROY:
		{
			PostMessage ( a_hWnd , WM_QUIT , 0 , 0 ) ;
		}
		break ;

		default:
		{		
			t_rc = DefWindowProc ( a_hWnd , a_message , a_wParam , a_lParam ) ;
		}
		break ;
	}

	return ( t_rc ) ;
}

HWND WindowsInit ( HINSTANCE a_HInstance )
{
	static wchar_t *t_TemplateCode = L"TemplateCode" ;

	WNDCLASS  t_wc ;
 
	t_wc.style            = CS_HREDRAW | CS_VREDRAW ;
	t_wc.lpfnWndProc      = WindowsMainProc ;
	t_wc.cbClsExtra       = 0 ;
	t_wc.cbWndExtra       = 0 ;
	t_wc.hInstance        = a_HInstance ;
	t_wc.hIcon            = LoadIcon(NULL, IDI_HAND) ;
	t_wc.hCursor          = LoadCursor(NULL, IDC_ARROW) ;
	t_wc.hbrBackground    = (HBRUSH) (COLOR_WINDOW + 1) ;
	t_wc.lpszMenuName     = NULL ;
	t_wc.lpszClassName    = t_TemplateCode ;
 
	ATOM t_winClass = RegisterClass ( &t_wc ) ;

	HWND t_HWnd = CreateWindow (

		t_TemplateCode ,              // see RegisterClass() call
		t_TemplateCode ,                      // text for window title bar
		WS_OVERLAPPEDWINDOW ,               // window style
		CW_USEDEFAULT ,                     // default horizontal position
		CW_USEDEFAULT ,                     // default vertical position
		CW_USEDEFAULT ,                     // default width
		CW_USEDEFAULT ,                     // default height
		NULL ,                              // overlapped windows have no parent
		NULL ,                              // use the window class menu
		a_HInstance ,
		NULL                                // pointer not needed
	) ;

	ShowWindow ( t_HWnd, SW_SHOW ) ;
//	ShowWindow ( t_HWnd, SW_HIDE ) ;

	return t_HWnd ;
}

void WindowsStop ( HWND a_HWnd )
{
	CoUninitialize () ;
	DestroyWindow ( a_HWnd ) ;
}

HWND WindowsStart ( HINSTANCE a_Handle )
{
	HWND t_HWnd = NULL ;
	if ( ! ( t_HWnd = WindowsInit ( a_Handle ) ) )
	{
    }

	return t_HWnd ;
}

void WindowsDispatch ()
{
	BOOL t_GetMessage ;
	MSG t_lpMsg ;

	while (	( t_GetMessage = GetMessage ( & t_lpMsg , NULL , 0 , 0 ) ) == TRUE )
	{
		TranslateMessage ( & t_lpMsg ) ;
		DispatchMessage ( & t_lpMsg ) ;

		if ( s_Exiting )
			return ;
	}
}

HRESULT UninitComServer ()
{
	if ( g_InstanceRegister )
		CoRevokeClassObject ( g_InstanceRegister );

	if ( g_ClassRegister )
		CoRevokeClassObject ( g_ClassRegister );

	if ( g_EventEncapsulatedRegister )
		CoRevokeClassObject ( g_EventEncapsulatedRegister );

	if ( g_EventReferentRegister )
		CoRevokeClassObject ( g_EventReferentRegister );

	CoUninitialize () ;

	return S_OK ;
}

HRESULT InitInstanceProvider ()
{
	IUnknown *t_ClassFactory = new CPropProvClassFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (

		CLSID_CPropProvClassFactory,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_InstanceRegister
	);

	return t_Result ;
}

HRESULT InitClassProvider ()
{
	IUnknown *t_ClassFactory = new CClasProvClassFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (

		CLSID_CClasProvClassFactory,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_ClassRegister
	);

	return t_Result ;
}

HRESULT InitEventEncapsulatedProvider ()
{
	IUnknown *t_ClassFactory = new CSNMPEncapEventProviderClassFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (

		CLSID_CSNMPEncapEventProviderClassFactory,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_EventEncapsulatedRegister
	);

	return t_Result ;
}

HRESULT InitEventReferentProvider ()
{
	IUnknown *t_ClassFactory = new CSNMPRefEventProviderClassFactory ;

	DWORD t_ClassContext = CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER ;
	DWORD t_Flags = REGCLS_MULTIPLEUSE ;

	HRESULT t_Result = CoRegisterClassObject (

		CLSID_CSNMPReftEventProviderClassFactory,
		t_ClassFactory,
        t_ClassContext, 
		t_Flags, 
		&g_EventReferentRegister
	);

	return t_Result ;
}

HRESULT InitComServer ( DWORD a_AuthenticationLevel , DWORD a_ImpersonationLevel )
{
	HRESULT t_Result = S_OK ;

    t_Result = CoInitializeEx (

		0, 
		COINIT_MULTITHREADED
	);

	if ( SUCCEEDED ( t_Result ) ) 
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			a_AuthenticationLevel,
			a_ImpersonationLevel, 
			NULL, 
			EOAC_NONE, 
			0
		);

		if ( FAILED ( t_Result ) ) 
		{
			CoUninitialize () ;
			return t_Result ;
		}

	}

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitInstanceProvider () ;

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitClassProvider () ;

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitEventReferentProvider () ;

	if ( SUCCEEDED ( t_Result ) )
		t_Result = InitEventEncapsulatedProvider () ;

	if ( FAILED ( t_Result ) )
	{
		UninitComServer () ;
	}

	return t_Result  ;
}

HRESULT Process ()
{
#if 1
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
#else
	DWORD t_ImpersonationLevel = RPC_C_IMP_LEVEL_IDENTITY ;
	DWORD t_AuthenticationLevel = RPC_C_AUTHN_LEVEL_NONE ;
#endif

	HRESULT t_Result = InitComServer ( t_ImpersonationLevel , t_AuthenticationLevel ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		WindowsDispatch () ;
		UninitComServer () ;
	}

	return t_Result ;
}

BOOL ParseCommandLine () 
{
	BOOL t_Exit = FALSE ;

	LPTSTR t_CommandLine = GetCommandLine () ;
	if ( t_CommandLine )
	{
		TCHAR *t_Arg = NULL ;
		TCHAR *t_ApplicationArg = NULL ;
		t_ApplicationArg = _tcstok ( t_CommandLine , _TEXT ( " \t" ) ) ;
		t_Arg = _tcstok ( NULL , _TEXT ( " \t" ) ) ;
		if ( t_Arg ) 
		{
			if ( _tcsicmp ( t_Arg , _TEXT ( "/RegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllRegisterServer () ;
			}
			else if ( _tcsicmp ( t_Arg , _TEXT ( "/UnRegServer" ) ) == 0 )
			{
				t_Exit = TRUE ;
				DllUnregisterServer () ;
			}
		}
	}

	return t_Exit ;
}

int WINAPI WinMain (
  
    HINSTANCE hInstance,		// handle to current instance
    HINSTANCE hPrevInstance,	// handle to previous instance
    LPSTR lpCmdLine,			// pointer to command line
    int nShowCmd 				// show state of window
)
{
	BOOL t_Status = DllMain (

		hInstance, 
		DLL_PROCESS_ATTACH , 
		NULL
	) ;

	BOOL t_Exit = ParseCommandLine () ;
	if ( ! t_Exit ) 
	{
		HWND hWnd = WindowsStart ( hInstance ) ;

		SnmpDebugLog :: Startup ();
		SnmpThreadObject :: Startup () ;

		HRESULT t_Result = Process () ;

		SnmpDebugLog :: Closedown () ;
		SnmpThreadObject :: Closedown () ;

		WindowsStop ( hWnd ) ;
	}

	t_Status = DllMain (

		hInstance, 
		DLL_PROCESS_DETACH , 
		NULL
	) ;

	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\evtthrd.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <cominit.h>

#include <smir.h>
#include <notify.h>

#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>
#include <evtencap.h>
#include <evtreft.h>

extern CEventProviderWorkerThread *g_pWorkerThread ;
extern CRITICAL_SECTION g_CacheCriticalSection;

CTrapListener::CTrapListener(CEventProviderThread* parentptr)
{
	m_pParent = parentptr;
	m_Ref = 1;
}


void CTrapListener::Destroy()
{
	if (InterlockedDecrement(&m_Ref) == 0)
	{
		DestroyReceiver();
	}
}


void CTrapListener::Receive (SnmpTransportAddress &sender_addr,
							SnmpSecurity &security_context,
							SnmpVarBindList &vbList)
{
	InterlockedIncrement(&m_Ref);
	MySnmpV1Security context((const SnmpV1Security&)security_context);
	const char *security = context.GetName();
	const char *addr = sender_addr.GetAddress();

	if ((NULL == security) || (NULL == addr))
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive invalid community or address\r\n");
)
		return;
	}

	const char *transport = NULL;

	if(typeid(SnmpTransportIpAddress) == typeid(sender_addr))
	{
		transport = "IP";
	}
	else if(typeid(SnmpTransportIpxAddress) == typeid(sender_addr))
	{
		transport = "IPX";
	}
	else
	{
		transport = "UNKNOWN";
	}

	char *oid = NULL;

	// reset the list
	vbList.Reset();
	UINT x = 0;

	// Get the SnmpTrapOid call process trap.
	vbList.Next(); //the timestamp
	vbList.Next(); //the snmpTrapOID
	const SnmpVarBind *var_bind = vbList.Get();
	const SnmpObjectIdentifier &id = var_bind->GetInstance();

	if (id != SNMP_TRAP_OID)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive invalid trap oid varbind\r\n");
)
		return;
	}

	const SnmpValue &val = var_bind->GetValue();

	if(typeid(SnmpObjectIdentifier) == typeid(val))
	{
		oid = ((const SnmpObjectIdentifier&)val).GetAllocatedString();
	}

	if (NULL == oid)
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive invalid oid\r\n");
)
		return;
	}
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapListener::Receive trap to process\r\n");
)
	m_pParent->ProcessTrap(addr, security, oid, transport, vbList);
	delete [] oid;
	Destroy();
}

void CEventProviderThread::UnRegister(CTrapEventProvider* prov)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::UnRegister\r\n");
)

	if (m_ControlObjects.Lock())
	{
		if (m_ControlObjects.RemoveKey((UINT_PTR)prov) 
			&& m_ControlObjects.IsEmpty() && (NULL != m_Ear))
		{
			m_Ear->Destroy();
			m_Ear = NULL;
		}
		
		m_ControlObjects.Unlock();
	}
}

BOOL CEventProviderThread::Register(CTrapEventProvider* prov)
{
	if (m_ControlObjects.Lock())
	{
		m_ControlObjects.SetAt((UINT_PTR)prov, prov);
		m_ControlObjects.Unlock();

		if (NULL == m_Ear)
		{
			m_Ear = new CTrapListener(this);
		}
	
		if (m_Ear->IsRegistered())
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::Register returning TRUE\r\n");
)
			return TRUE;
		}
		else
		{
			delete m_Ear;
			m_Ear = NULL;
		}
	}

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::Register returning FALSE\r\n");
)
	
	return FALSE;
}

void CEventProviderThread::ProcessTrap(const char *sender_addr, const char *security_Context,
										const char *snmpTrapOid, const char *trnsp,
										SnmpVarBindList &vbList)
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"Entering CEventProviderThread::ProcessTrap\r\n");
)

	CList<CTrapEventProvider *, CTrapEventProvider *> controlObjects;

	if (m_ControlObjects.Lock())
	{
		POSITION pos = m_ControlObjects.GetStartPosition();

		while (NULL != pos)
		{
			CTrapEventProvider *pCntrl;
			UINT key;
			m_ControlObjects.GetNextAssoc(pos, key, pCntrl);
			pCntrl->AddRefAll();
			controlObjects.AddTail(pCntrl);
		}

		m_ControlObjects.Unlock();
	}
	else
	{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::ProcessTrap Failed to lock Control objects\r\n");
)

		return;
	}

	//loop through the different control objects to see if an event class
	//should be sent. if yes, then generate the event class. if generating
	//the specific class fails try the generic case. 

	CTrapData TrapData (sender_addr,  security_Context, snmpTrapOid, trnsp, vbList);

	while (!controlObjects.IsEmpty())
	{
		CTrapEventProvider *pCntrl = controlObjects.RemoveTail();
		CTrapProcessTaskObject asyncTrapTask ( & TrapData, pCntrl);
		asyncTrapTask.Process();

		pCntrl->ReleaseAll();
	}

DebugMacro9(
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderThread::ProcessTrap done!\r\n");
)

}


CTrapData::CTrapData (

	const char *sender_addr,
	const char *security_Context,
	const char *snmpTrapOid,
	const char *trnsp,
	SnmpVarBindList &vbList

) : m_variable_bindings(vbList),
	m_Ref(0),
	m_sender_addr(NULL),
	m_security_context(NULL),
	m_trap_oid(NULL),
	m_transport(NULL)
{
	if (sender_addr)
	{
		int t_sender_len = strlen(sender_addr) + 1 ;
		if ( t_sender_len > 32 )
		{
			m_sender_addr = new char[strlen(sender_addr) + 1];
			strcpy(m_sender_addr, sender_addr);
		}
		else
		{
			m_sender_addr = NULL ;
			strcpy(m_static_sender_addr, sender_addr);
		}
	}

	if (security_Context)
	{
		int t_security_Context_len = strlen(security_Context) + 1 ;
		if ( t_security_Context_len > 32 )
		{
			m_security_context = new char[strlen(security_Context) + 1];
			strcpy(m_security_context, security_Context);
		}
		else
		{
			m_security_context = NULL ;
			strcpy(m_static_security_context, security_Context);
		}
	}

	if (snmpTrapOid)
	{
		int t_trap_oid_len = strlen(snmpTrapOid) + 1 ;
		if ( t_trap_oid_len > 32 )
		{
			m_trap_oid = new char[strlen(snmpTrapOid) + 1];
			strcpy(m_trap_oid, snmpTrapOid);
		}
		else
		{
			m_trap_oid = NULL ;
			strcpy(m_static_trap_oid, snmpTrapOid);
		}
	}

	if (trnsp)
	{
		int t_trnsp_len = strlen(trnsp) + 1 ;
		if ( t_trnsp_len > 32 )
		{
			m_transport = new char[strlen(trnsp) + 1];
			strcpy(m_transport, trnsp);
		}
		else
		{
			m_transport = NULL ;
			strcpy(m_static_transport, trnsp);
		}
	}
}

CTrapData::~CTrapData()
{
	if (m_sender_addr)
	{
		delete [] m_sender_addr;
	}

	if (m_security_context)
	{
		delete [] m_security_context;
	}

	if (m_trap_oid)
	{
		delete [] m_trap_oid;
	}

	if (m_transport)
	{
		delete [] m_transport;
	}
}

LONG CTrapData::AddRef()
{
	return InterlockedIncrement ( &m_Ref ) ;
}

LONG CTrapData::Release()
{
	long ret;

    if ( 0 != (ret = InterlockedDecrement(&m_Ref)) )
	{
        return ret;
	}

	delete this;
	return 0;
}

CTrapProcessTaskObject::CTrapProcessTaskObject (CTrapData *pTData, CTrapEventProvider* pCntrl) : m_Cntrl (NULL)
{
	if (pCntrl)
	{
		m_Cntrl = pCntrl;
		m_Cntrl->AddRefAll();
	}

	if (pTData)
	{
		m_trap_data = pTData;
	}
	else
	{
		m_trap_data = NULL;
	}
}

CTrapProcessTaskObject::~CTrapProcessTaskObject()
{
	if (m_Cntrl)
	{
		m_Cntrl->ReleaseAll();
	}

}

void CTrapProcessTaskObject::Process()
{
	if (m_Cntrl->m_MapType == CMapToEvent::EMappingType::ENCAPSULATED_MAPPER)
	{
		ProcessEncapsulated () ;
	}
	else //must be referent
	{
		ProcessReferent () ;
	}
}

void CTrapProcessTaskObject::ProcessReferent ()
{
	CWbemServerWrap *ns = m_Cntrl->GetNamespace();
	IWbemObjectSink *es = m_Cntrl->GetEventSink();

	CReferentMapper mapper ;

	mapper.SetData (
		
		m_trap_data->m_sender_addr ? m_trap_data->m_sender_addr : m_trap_data->m_static_sender_addr , 
		m_trap_data->m_security_context ? m_trap_data->m_security_context : m_trap_data->m_static_security_context ,
		m_trap_data->m_trap_oid ? m_trap_data->m_trap_oid : m_trap_data->m_static_trap_oid , 
		m_trap_data->m_transport ? m_trap_data->m_transport : m_trap_data->m_static_transport ,
		m_trap_data->m_variable_bindings, 
		ns
	);

#ifdef FILTERING
		//is the specific filter set?
	if (SUCCEEDED(es->CheckObject(mapper, NULL, NULL)))
#endif //FILTERING

	{
		IWbemClassObject *Evt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating specific instance\r\n");
)
		mapper.GenerateInstance(&Evt);

		//only indicate if specific worked
		if (Evt != NULL) 
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating specific instance\r\n");
)
			es->Indicate(1, &Evt);
			Evt->Release();
		}
		else if (!mapper.TriedGeneric()) //have we tried the generic filter
		{
			mapper.ResetData();
			mapper.SetTryGeneric();

			mapper.SetData (
				
				m_trap_data->m_sender_addr ? m_trap_data->m_sender_addr : m_trap_data->m_static_sender_addr , 
				m_trap_data->m_security_context ? m_trap_data->m_security_context : m_trap_data->m_static_security_context ,
				m_trap_data->m_trap_oid ? m_trap_data->m_trap_oid : m_trap_data->m_static_trap_oid , 
				m_trap_data->m_transport ? m_trap_data->m_transport : m_trap_data->m_static_transport ,
				m_trap_data->m_variable_bindings, 
				ns
			);

			//is the generic filter set?
#ifdef FILTERING
			if (SUCCEEDED(es->CheckObject(m_Map, NULL, NULL)))
#endif //FILTERING
			{
				IWbemClassObject *stdEvt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating general instance\r\n");
)
				mapper.GenerateInstance(&stdEvt);
				
				//if we generated the class indicate
				if (NULL != stdEvt)
				{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating general instance\r\n");
)
					es->Indicate(1, &stdEvt);
					stdEvt->Release();
				}
				else
				{
DebugMacro9(
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating generic instance failed\r\n");
)
				}
			}
		}
		else
		{
			//the specific case was the generic case
		}
	}
	
	mapper.ResetData();

	es->Release();
	ns->Release();
}

void CTrapProcessTaskObject::ProcessEncapsulated ()
{
	CWbemServerWrap *ns = m_Cntrl->GetNamespace();
	IWbemObjectSink *es = m_Cntrl->GetEventSink();

	CEncapMapper mapper ;

	mapper.SetData (
		
		m_trap_data->m_sender_addr ? m_trap_data->m_sender_addr : m_trap_data->m_static_sender_addr , 
		m_trap_data->m_security_context ? m_trap_data->m_security_context : m_trap_data->m_static_security_context ,
		m_trap_data->m_trap_oid ? m_trap_data->m_trap_oid : m_trap_data->m_static_trap_oid , 
		m_trap_data->m_transport ? m_trap_data->m_transport : m_trap_data->m_static_transport ,
		m_trap_data->m_variable_bindings, 
		ns
	);

#ifdef FILTERING
		//is the specific filter set?
	if (SUCCEEDED(es->CheckObject(mapper, NULL, NULL)))
#endif //FILTERING

	{
		IWbemClassObject *Evt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating specific instance\r\n");
)
		mapper.GenerateInstance(&Evt);

		//only indicate if specific worked
		if (Evt != NULL) 
		{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating specific instance\r\n");
)
			es->Indicate(1, &Evt);
			Evt->Release();
		}
		else if (!mapper.TriedGeneric()) //have we tried the generic filter
		{
			mapper.ResetData();
			mapper.SetTryGeneric();

			mapper.SetData (
				
				m_trap_data->m_sender_addr ? m_trap_data->m_sender_addr : m_trap_data->m_static_sender_addr , 
				m_trap_data->m_security_context ? m_trap_data->m_security_context : m_trap_data->m_static_security_context ,
				m_trap_data->m_trap_oid ? m_trap_data->m_trap_oid : m_trap_data->m_static_trap_oid , 
				m_trap_data->m_transport ? m_trap_data->m_transport : m_trap_data->m_static_transport ,
				m_trap_data->m_variable_bindings, 
				ns
			);

			//is the generic filter set?
#ifdef FILTERING
			if (SUCCEEDED(es->CheckObject(m_Map, NULL, NULL)))
#endif //FILTERING
			{
				IWbemClassObject* stdEvt = NULL;

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating general instance\r\n");
)
				mapper.GenerateInstance(&stdEvt);
				
				//if we generated the class indicate
				if (NULL != stdEvt)
				{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process indicating general instance\r\n");
)
					es->Indicate(1, &stdEvt);
					stdEvt->Release();
				}
				else
				{
DebugMacro9(
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CTrapProcessTaskObject::Process generating generic instance failed\r\n");
)
				}
			}
		}
		else
		{
			//the specific case was the generic case
		}
	}
	
	mapper.ResetData();

	es->Release();
	ns->Release();
}

TimerRegistryTaskObject :: TimerRegistryTaskObject (CEventProviderWorkerThread *parent) : m_LogKey ( NULL )
{
	m_parent = parent;
	ReadRegistry();
}

TimerRegistryTaskObject :: ~TimerRegistryTaskObject ()
{
	if ( m_LogKey )
		RegCloseKey ( m_LogKey ) ;
}

void TimerRegistryTaskObject :: Process ()
{
	ReadRegistry();
	SetRegistryNotification () ;
}

void TimerRegistryTaskObject :: ReadRegistry ()
{
	if (m_LogKey == NULL)
	{
		LONG t_Status = RegCreateKeyEx (
		
			HKEY_LOCAL_MACHINE, 
			THREAD_REG_KEY, 
			0, 
			NULL, 
			REG_OPTION_NON_VOLATILE,
			KEY_ALL_ACCESS, 
			NULL, 
			&m_LogKey, 
			NULL
		) ;

		if ( t_Status != ERROR_SUCCESS )
		{
			return;
		}
	}

	DWORD t_Count = 0;
	BOOL bWrite = TRUE;
	DWORD t_ValueType = REG_DWORD ;
	DWORD t_ValueLength = sizeof ( DWORD ) ;
	LONG t_Status = RegQueryValueEx ( 

		m_LogKey , 
		THREAD_MARKS_VAL , 
		0, 
		&t_ValueType ,
		( LPBYTE ) &t_Count , 
		&t_ValueLength 
	) ;

	if (t_Status == ERROR_SUCCESS)
	{
		if (t_Count == 0)
		{
			t_Count = 1;
		}
		else if (t_Count > THREAD_MARKS_MAX)
		{
			t_Count = THREAD_MARKS_MAX;
		}
		else
		{
			t_Count  = t_Count;
			bWrite = FALSE;
		}
	}
	else
	{
		t_Count = THREAD_MARKS_DEF;
	}

	if (bWrite)
	{
		t_ValueType = REG_DWORD ;

		RegSetValueEx ( 

			m_LogKey , 
			THREAD_MARKS_VAL , 
			0, 
			t_ValueType ,
			( LPBYTE ) &t_Count , 
			t_ValueLength 
		) ;
	}

	m_parent->SetMaxMarks(t_Count);
}

void TimerRegistryTaskObject :: SetRegistryNotification ()
{
	if ( m_LogKey )
		RegCloseKey ( m_LogKey ) ;

	LONG t_Status = RegCreateKeyEx (
	
		HKEY_LOCAL_MACHINE, 
		THREAD_REG_KEY, 
		0, 
		NULL, 
		REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, 
		NULL, 
		&m_LogKey, 
		NULL
	) ;
			
	if ( t_Status == ERROR_SUCCESS )
	{
		t_Status = RegNotifyChangeKeyValue ( 

			m_LogKey , 
			TRUE , 
			REG_NOTIFY_CHANGE_LAST_SET , 
			GetHandle () , 
			TRUE 
		) ; 
	}
}

CEventProviderWorkerThread::CEventProviderWorkerThread()
:	SnmpThreadObject (THREAD_NAME, THREAD_INTERVAL),
	m_pNotifyInt(NULL),
	m_notify(NULL),
	m_RegTaskObject(NULL)
{
	m_RegTaskObject = new TimerRegistryTaskObject(this) ;
	ScheduleTask ( *m_RegTaskObject ) ;

	HRESULT hr = CoCreateInstance (CLSID_SMIR_Database,
					NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
					IID_ISMIR_Database, (void**)&m_pNotifyInt);

	if(SUCCEEDED(hr))
	{
		m_notify = new CEventCacheNotify();
		m_notify->AddRef();
		DWORD dw = 0;
		hr = m_pNotifyInt->AddNotify(m_notify, &dw);

		if(SUCCEEDED(hr))
		{
			m_notify->SetCookie(dw);
		}
		else
		{
			m_notify->Release();
			m_notify = NULL;
		}
	}
	else
	{
		m_pNotifyInt = NULL;
	}
}

CEventProviderWorkerThread::~CEventProviderWorkerThread()
{
	if (m_RegTaskObject)
	{
		ReapTask ( *m_RegTaskObject ) ;
		delete m_RegTaskObject ;
	}
}

void CEventProviderWorkerThread::GetDeleteNotifyParams(ISmirDatabase** a_ppNotifyInt, CEventCacheNotify** a_ppNotify)
{
	if (m_notify != NULL)
	{
		m_notify->Detach();
		*a_ppNotify = m_notify;
		m_notify = NULL;
	}

	if (m_pNotifyInt != NULL)
	{
		*a_ppNotifyInt = m_pNotifyInt;
		m_pNotifyInt = NULL;
	}
}

void CEventProviderWorkerThread::CreateServerWrap ()
{
	m_pSmirNamespace = new CWbemServerWrap ( NULL ) ;
}

void CEventProviderWorkerThread::Initialise()
{
	InitializeCom();

DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->Write (  
		L"\r\n");

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderWorkerThread::Initialise ()\r\n");
)

}

void CEventProviderWorkerThread::Uninitialise()
{
DebugMacro9( 
	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  
		__FILE__,__LINE__,
		L"CEventProviderWorkerThread::Uninitialise ()\r\n");
)

	if ( m_pSmirNamespace )
	{
		m_pSmirNamespace->Release () ;
	}

	delete this;

	CoUninitialize();
}

void CEventProviderWorkerThread::SetMaxMarks(DWORD dwM)
{
	EnterCriticalSection(&g_CacheCriticalSection);
	m_MaxMarks = dwM;
	LeaveCriticalSection(&g_CacheCriticalSection);
}

void CEventProviderWorkerThread::TimedOut()
{
	EnterCriticalSection(&g_CacheCriticalSection);

	//loop cache elements delete old entries...
	POSITION pos = m_Classes.GetStartPosition();

	while (NULL != pos)
	{
		CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>* pClassMap;
		DWORD key;
		m_Classes.GetNextAssoc(pos, key, pClassMap);
		CList<CString, CString> delList;
		POSITION subpos = pClassMap->GetStartPosition();

		while (NULL != subpos)
		{
			SCacheEntry* pEntry;
			CString subkey;
			pClassMap->GetNextAssoc(subpos, subkey, pEntry);
			pEntry->m_Marker++;

			if (pEntry->m_Marker > m_MaxMarks)
			{
				delList.AddTail(subkey);
			}
		}

		if (!delList.IsEmpty())
		{
			if (delList.GetCount() == pClassMap->GetCount())
			{
				pClassMap->RemoveAll();
			}
			else
			{
				while (!delList.IsEmpty())
				{
					pClassMap->RemoveKey(delList.RemoveTail());
				}
			}
		}
	}

	LeaveCriticalSection(&g_CacheCriticalSection);
}

void CEventProviderWorkerThread::Clear()
{
	EnterCriticalSection(&g_CacheCriticalSection);

	//loop cache elements delete all entries...
	POSITION pos = m_Classes.GetStartPosition();

	while (NULL != pos)
	{
		CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>* pClassMap;
		DWORD key;
		m_Classes.GetNextAssoc(pos, key, pClassMap);
		pClassMap->RemoveAll();
	}

	LeaveCriticalSection(&g_CacheCriticalSection);
}

void CEventProviderWorkerThread::AddClassesToCache(DWORD_PTR key, CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>* item)
{
	EnterCriticalSection ( & g_CacheCriticalSection ) ;
	
	m_Classes.SetAt(key, item);

	LeaveCriticalSection ( & g_CacheCriticalSection ) ;
}

void CEventProviderWorkerThread::RemoveClassesFromCache(DWORD_PTR key)
{
	EnterCriticalSection ( & g_CacheCriticalSection ) ;
	
	g_pWorkerThread->m_Classes.RemoveKey(key);
	
	LeaveCriticalSection ( & g_CacheCriticalSection ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\maindll.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>

#include <objbase.h>
#include <olectl.h>
#include <corafx.h>

#include <wbemidl.h>
#include "guids.h"

#include <snmpstd.h>
#include <snmpmt.h>
#include <snmptempl.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>

#include <instpath.h>
#include <snmpcl.h>
#include <snmptype.h>
#include <snmpobj.h>
#include <smir.h>
#include "classfac.h"
#include "clasprov.h"
#include "propprov.h"
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <notify.h>
#include <cormap.h>
#include <evtdefs.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

ISmirDatabase*		g_pNotifyInt = NULL;
CCorrCacheNotify*	gp_notify = NULL;
CCorrCacheWrapper*	g_CacheWrapper = NULL;
CCorrelatorMap*		g_Map = NULL;

//OK we need this one
HINSTANCE   g_hInst=NULL;

CEventProviderThread* g_pProvThrd = NULL;
CEventProviderWorkerThread* g_pWorkerThread = NULL;

CRITICAL_SECTION s_ProviderCriticalSection ;
CRITICAL_SECTION g_CacheCriticalSection ;

extern void ProviderStartup () ;
extern void ProviderClosedown () ;

//***************************************************************************
//
// LibMain32
//
// Purpose: Entry point for DLL.  Good place for initialization.
// Return: TRUE if OK.
//***************************************************************************

BOOL APIENTRY DllMain (

	HINSTANCE hInstance, 
	ULONG ulReason , 
	LPVOID pvReserved
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		g_hInst=hInstance;

		BOOL status = TRUE ;

		if ( DLL_PROCESS_DETACH == ulReason )
		{
			DeleteCriticalSection ( & s_ProviderCriticalSection ) ;
			DeleteCriticalSection ( & g_CacheCriticalSection ) ;


			status = TRUE ;
		}
		else if ( DLL_PROCESS_ATTACH == ulReason )
		{
			DisableThreadLibraryCalls(hInstance);
			InitializeCriticalSection ( & s_ProviderCriticalSection ) ;
			InitializeCriticalSection ( & g_CacheCriticalSection ) ;
			status = TRUE ;
		}
		else if ( DLL_THREAD_DETACH == ulReason )
		{
			status = TRUE ;
		}
		else if ( DLL_THREAD_ATTACH == ulReason )
		{
			status = TRUE ;
		}


		return TRUE ;
	}
	catch(Structured_Exception e_SE)
	{
		return FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		return FALSE;
	}
	catch(...)
	{
		return FALSE;
	}
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************

STDAPI DllGetClassObject (

	REFCLSID rclsid , 
	REFIID riid, 
	void **ppv 
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT status = S_OK ; 

		if ( rclsid == CLSID_CClasProvClassFactory ) 
		{
			CClasProvClassFactory *lpunk = new CClasProvClassFactory ;
			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_CPropProvClassFactory ) 
		{
			CPropProvClassFactory *lpunk = new CPropProvClassFactory ;
			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;
				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
				else
				{
				}			
			}
		}
		else if ( rclsid == CLSID_CSNMPReftEventProviderClassFactory ) 
		{
			CSNMPRefEventProviderClassFactory *lpunk = new CSNMPRefEventProviderClassFactory;

			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;

				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
			}
		}
		else if ( rclsid == CLSID_CSNMPEncapEventProviderClassFactory ) 
		{
			CSNMPEncapEventProviderClassFactory *lpunk = new CSNMPEncapEventProviderClassFactory;

			if ( lpunk == NULL )
			{
				status = E_OUTOFMEMORY ;
			}
			else
			{
				status = lpunk->QueryInterface ( riid , ppv ) ;

				if ( FAILED ( status ) )
				{
					delete lpunk ;				
				}
			}
		}
		else	
		{
			status = CLASS_E_CLASSNOTAVAILABLE ;
		}
		
		return status ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.//
// Return:  TRUE if there are no objects in use and the class factory 
//          isn't locked.
//***************************************************************************

STDAPI DllCanUnloadNow ()
{
	SetStructuredExceptionHandler seh;

	try
	{
	/* 
	 * Place code in critical section
	 */
		EnterCriticalSection ( & s_ProviderCriticalSection ) ;
		
		ISmirDatabase* t_pNotifyInt = NULL;
		CCorrCacheNotify* t_pnotify = NULL;
		CEventCacheNotify* t_notify = NULL;
		ISmirDatabase* t_pNotifyIntThread = NULL;

		BOOL unload = (
						CClasProvClassFactory :: locksInProgress ||
						CClasProvClassFactory :: objectsInProgress ||
						CPropProvClassFactory :: locksInProgress ||
						CPropProvClassFactory :: objectsInProgress ||
						CSNMPEventProviderClassFactory :: locksInProgress ||
						CSNMPEventProviderClassFactory :: objectsInProgress
						) ;

		unload = ! unload ;

		if ( unload )
		{
			if ( CImpClasProv :: s_Initialised )
			{
				CImpClasProv :: s_Initialised = FALSE ;

				CCorrelator :: TerminateCorrelator (&t_pNotifyInt, &t_pnotify) ;

				SnmpClassLibrary :: Closedown () ;
				SnmpDebugLog :: Closedown () ;
				SnmpThreadObject :: Closedown () ;

				ProviderClosedown () ;
			}

			if ( CImpPropProv :: s_Initialised )
			{
				CImpPropProv :: s_Initialised = FALSE ;

				SnmpClassLibrary :: Closedown () ;
				SnmpDebugLog :: Closedown () ;
				SnmpThreadObject :: Closedown () ;

				ProviderClosedown () ;

			}

			if ( g_pProvThrd )
			{
				delete g_pProvThrd;
				g_pProvThrd = NULL;
				g_pWorkerThread->GetDeleteNotifyParams(&t_pNotifyIntThread, &t_notify);
				g_pWorkerThread->SignalThreadShutdown();
				g_pWorkerThread = NULL;

				SnmpClassLibrary :: Closedown () ;
				SnmpDebugLog :: Closedown () ;
				SnmpThreadObject :: Closedown () ;

				ProviderClosedown () ;
			}

		}

		LeaveCriticalSection ( & s_ProviderCriticalSection ) ;

		if (unload)
		{
			if (t_pNotifyInt)
			{
				if (t_pnotify)
				{
					t_pNotifyInt->DeleteNotify(t_pnotify->GetCookie());
				}

				t_pNotifyInt->Release();
				t_pNotifyInt = NULL;
			}

			if (t_pnotify)
			{
				t_pnotify->Release();
				t_pnotify = NULL;
			}

			if (t_pNotifyIntThread)
			{
				if (t_notify)
				{
					t_pNotifyIntThread->DeleteNotify(t_notify->GetCookie());
				}

				t_pNotifyIntThread->Release();
				t_pNotifyIntThread = NULL;
			}

			if (t_notify)
			{
				t_notify->Release();
				t_notify = NULL;
			}
		}

		return unload ? ResultFromScode ( S_OK ) : ResultFromScode ( S_FALSE ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return S_FALSE;
	}
	catch(Heap_Exception e_HE)
	{
		return S_FALSE;
	}
	catch(...)
	{
		return S_FALSE;
	}
}

#define REG_FORMAT_STR			L"%s\\%s"
#define NOT_INSERT_STR			L"NotInsertable"
#define INPROC32_STR			L"InprocServer32"
#define LOCALSERVER32_STR		L"LocalServer32"
#define THREADING_MODULE_STR	L"ThreadingModel"
#define APARTMENT_STR			L"Both"
#define APPID_STR				L"Software\\Classes\\AppID\\"
#define CLSID_STR				L"Software\\Classes\\CLSID\\"

#define CLASS_PROVIDER_NAME_STR			L"Microsoft WBEM SNMP Class Provider"
#define INSTANCE_PROVIDER_NAME_STR		L"Microsoft WBEM SNMP Instance Provider"
#define EVENT_PROVIDER_NAME_STR			L"Microsoft WBEM SNMP Event Provider"

/***************************************************************************
 * SetKeyAndValue
 *
 * Purpose:
 *  Private helper function for DllRegisterServer that creates
 *  a key, sets a value, and closes that key.
 *
 * Parameters:
 *  pszKey          LPTSTR to the ame of the key
 *  pszSubkey       LPTSTR ro the name of a subkey
 *  pszValue        LPTSTR to the value to store
 *
 * Return Value:
 *  BOOL            TRUE if successful, FALSE otherwise.
 ***************************************************************************/

BOOL SetKeyAndValue(wchar_t* pszKey, wchar_t* pszSubkey, wchar_t* pszValueName, wchar_t* pszValue)
{
    HKEY        hKey;
    wchar_t       szKey[256];

	wcscpy(szKey, pszKey);

    if (NULL!=pszSubkey)
    {
		wcscat(szKey, L"\\");
        wcscat(szKey, pszSubkey);
    }

    if (ERROR_SUCCESS!=RegCreateKeyEx(HKEY_LOCAL_MACHINE
        , szKey, 0, NULL, REG_OPTION_NON_VOLATILE
        , KEY_ALL_ACCESS, NULL, &hKey, NULL))
        return FALSE;

    if (NULL!=pszValue)
    {
        if (ERROR_SUCCESS != RegSetValueEx(hKey, pszValueName, 0, REG_SZ, (BYTE *)pszValue
            , (lstrlen(pszValue)+1)*sizeof(wchar_t)))
			return FALSE;
    }
    RegCloseKey(hKey);
    return TRUE;
}

/***************************************************************************
 * DllRegisterServer
 *
 * Purpose:
 *  Instructs the server to create its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI RegisterServer( GUID a_ProviderClassId , wchar_t *a_ProviderName )
{
	wchar_t szModule[512];
	GetModuleFileName(g_hInst,(wchar_t*)szModule, sizeof(szModule)/sizeof(wchar_t));

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId,szProviderClassID, 128);

#ifdef LOCALSERVER
	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	if (FALSE ==SetKeyAndValue(szProviderCLSIDAppID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;
#endif

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

		//Create entries under CLSID
	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NULL, NULL, a_ProviderName ))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, NOT_INSERT_STR, NULL, NULL))
			return SELFREG_E_CLASS;

#ifdef LOCALSERVER

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, LOCALSERVER32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;
#else

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR, NULL,szModule))
		return SELFREG_E_CLASS;

	if (FALSE ==SetKeyAndValue(szProviderCLSIDClassID, INPROC32_STR,THREADING_MODULE_STR, APARTMENT_STR))
		return SELFREG_E_CLASS;

#endif

	return S_OK;
}

/***************************************************************************
 * DllUnregisterServer
 *
 * Purpose:
 *  Instructs the server to remove its own registry entries
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HRESULT         NOERROR if registration successful, error
 *                  otherwise.
 ***************************************************************************/

STDAPI UnregisterServer( GUID a_ProviderClassId )
{
	wchar_t szTemp[128];

	wchar_t szProviderClassID[128];
	wchar_t szProviderCLSIDClassID[128];

	int iRet = StringFromGUID2(a_ProviderClassId ,szProviderClassID, 128);

	wcscpy(szProviderCLSIDClassID,CLSID_STR);
	wcscat(szProviderCLSIDClassID,szProviderClassID);

	//Delete entries under CLSID

	wsprintf(szTemp, REG_FORMAT_STR, szProviderCLSIDClassID, NOT_INSERT_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

#ifdef LOCALSERVER

	TCHAR szProviderCLSIDAppID[128];
	_tcscpy(szProviderCLSIDAppID,APPID_STR);
	_tcscat(szProviderCLSIDAppID,szProviderClassID);

	//Delete entries under APPID

	DWORD t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szProviderCLSIDAppID);

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, LOCALSERVER32_STR);
	t_Status = RegDeleteKey(HKEY_CLASSES_ROOT, szTemp);

#else

	wsprintf(szTemp, REG_FORMAT_STR,szProviderCLSIDClassID, INPROC32_STR);
	RegDeleteKey(HKEY_LOCAL_MACHINE, szTemp);

#endif

	RegDeleteKey(HKEY_LOCAL_MACHINE, szProviderCLSIDClassID);

    return S_OK;
}

STDAPI DllRegisterServer()
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT t_Result ;

		t_Result = RegisterServer ( CLSID_CPropProvClassFactory , INSTANCE_PROVIDER_NAME_STR ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : RegisterServer ( CLSID_CClasProvClassFactory , CLASS_PROVIDER_NAME_STR  ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : RegisterServer ( CLSID_CSNMPReftEventProviderClassFactory , EVENT_PROVIDER_NAME_STR ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : RegisterServer ( CLSID_CSNMPEncapEventProviderClassFactory , EVENT_PROVIDER_NAME_STR ) ;

		return t_Result ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}

STDAPI DllUnregisterServer(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT t_Result ;

		t_Result = UnregisterServer ( CLSID_CPropProvClassFactory ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : UnregisterServer ( CLSID_CClasProvClassFactory ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : UnregisterServer ( CLSID_CSNMPReftEventProviderClassFactory ) ;
		t_Result = FAILED ( t_Result ) ? t_Result : UnregisterServer ( CLSID_CSNMPEncapEventProviderClassFactory ) ;


		return t_Result ;
	}
	catch(Structured_Exception e_SE)
	{
		return E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		return E_OUTOFMEMORY;
	}
	catch(...)
	{
		return E_UNEXPECTED;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\precomp.h ===
//

// Copyright (c) 1999-2001 Microsoft Corporation, All Rights Reserved
//

#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\notify.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>

#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <notify.h>

#include <corstore.h>

#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmpobj.h>
#include <cominit.h>
#include <evtthrd.h>
#include <evtmap.h>
#include <evtprov.h>

extern CCorrCacheWrapper*	g_CacheWrapper;
extern CEventProviderWorkerThread* g_pWorkerThread;


CBaseCorrCacheNotify::CBaseCorrCacheNotify()
{
    m_cRef=0;
    m_dwCookie=0;
	m_DoWork = TRUE;
	InitializeCriticalSection ( & m_CriticalSection ) ;
}

CBaseCorrCacheNotify::~CBaseCorrCacheNotify()
{
	DeleteCriticalSection ( & m_CriticalSection ) ;
}

void CBaseCorrCacheNotify::Detach()
{
	EnterCriticalSection ( & m_CriticalSection ) ;
	m_DoWork = FALSE;
	LeaveCriticalSection ( & m_CriticalSection ) ;
}

/*
 * CBaseCorrCacheNotify::QueryInterface
 * CBaseCorrCacheNotify::AddRef
 * CBaseCorrCacheNotify::Release
 *
 * Purpose:
 *  Non-delegating IUnknown members for CBaseCorrCacheNotify.
 */

STDMETHODIMP CBaseCorrCacheNotify::QueryInterface(REFIID riid, LPVOID *ppv)
{
    *ppv=NULL;

    if (IID_IUnknown == riid || IID_ISMIR_Notify == riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CBaseCorrCacheNotify::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CBaseCorrCacheNotify::Release()
{
    if (0!=--m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

STDMETHODIMP CCorrCacheNotify::ChangeNotify()
{
	EnterCriticalSection ( & m_CriticalSection ) ;
	BOOL bDoWork = m_DoWork;
	LeaveCriticalSection ( & m_CriticalSection ) ;

	if (bDoWork)
	{
		(g_CacheWrapper->GetCache())->InvalidateCache();
		CCorrCache* cache = new CCorrCache();
		g_CacheWrapper->SetCache(cache);
		g_CacheWrapper->ReleaseCache();
	}

	return NOERROR;
}

STDMETHODIMP CEventCacheNotify::ChangeNotify()
{
	EnterCriticalSection ( & m_CriticalSection ) ;
	BOOL bDoWork = m_DoWork;
	LeaveCriticalSection ( & m_CriticalSection ) ;

	if (bDoWork)
	{
		g_pWorkerThread->Clear();
	}

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propdel.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "propdel.h"
#include "snmpget.h"
#include "snmpset.h"
#include "snmpqset.h"

void DeleteInstanceAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	BOOL t_Status = TRUE ;

	if ( m_SnmpTooBig )
	{
		m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SetComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Update Succeeded" 
	) ;
)
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	SetOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from DeleteInstanceAsyncEventObject :: ReceiveComplete ()" 
	) ;
)
}

void DeleteInstanceAsyncEventObject :: SnmpTooBig () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"DeleteInstanceAsyncEventObject :: SnmpTooBig ()" 
	) ;
)

	m_SnmpTooBig = TRUE ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from DeleteInstanceAsyncEventObject :: SnmpTooBig ()" 
	) ;
)
}

BOOL DeleteInstanceAsyncEventObject :: Delete ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"DeleteInstanceAsyncEventObject :: Delete ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;
	IWbemClassObject *t_ClassObject = NULL ;
	IWbemServices *t_Serv = provider->GetServer();
	HRESULT result = WBEM_E_FAILED;
	
	if (t_Serv)
	{
		VARIANT variant ;
		VariantInit ( & variant ) ;
		variant.bstrVal = SysAllocString ( m_ObjectPath ) ;

		result = t_Serv->GetObject (

			variant.bstrVal ,
			0 ,
			m_Context ,
			& t_ClassObject ,
			NULL 
		) ;

		VariantClear ( & variant ) ;
		t_Serv->Release () ;
	}

	if ( SUCCEEDED ( result ) )
	{
		if ( status = GetNamespaceObject ( a_errorObject ) )
		{
			status = snmpObject.Set ( a_errorObject , t_ClassObject ) ;
			if ( status )
			{
				status = snmpObject.Check ( a_errorObject ) ;
				if ( status )
				{
					if ( ! snmpObject.RowStatusSpecified () )
					{
						WbemSnmpProperty *t_Property ;

						snmpObject.ResetProperty () ;
						while ( t_Property = snmpObject.NextProperty () )
						{
							if ( typeid ( *t_Property->GetValue () ) == typeid ( SnmpRowStatusType ) )
							{
								t_Property->SetTag ( FALSE ) ;
								SnmpRowStatusType *t_RowStatus = new SnmpRowStatusType ( SnmpRowStatusType :: SnmpRowStatusEnum :: destroy  ) ;
								t_Property->SetValue ( t_RowStatus ) ;
							}
						}

						status = SendSnmp ( m_errorObject , 0 ) ;
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Deletion of an instance requires the specification of a RowStatus class definition" ) ;

					}
				}
				else
				{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Merge : Class definition did not conform to mapping"
) ;
)
				}
			}
			else
			{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
			}
		}

		t_ClassObject->Release () ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from DeleteInstanceAsyncEventObject :: Delete ( WbemSnmpErrorObject &a_errorObject ) with Result (%lx)" ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

BOOL DeleteInstanceAsyncEventObject :: DeleteInstance ( WbemSnmpErrorObject &a_ErrorObject )
{
	BOOL t_Status;
    int iParseResult = m_ObjectPathParser.Parse ( m_ObjectPath , &m_ParsedObjectPath ) ;
	if ( CObjectPathParser::NoError == iParseResult )
	{
        t_Status = Delete ( a_ErrorObject ) ;
	}
	else
	{
		t_Status = FALSE ;
		a_ErrorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_ErrorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_ErrorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return t_Status ;
}

DeleteInstanceAsyncEventObject :: DeleteInstanceAsyncEventObject (

	CImpPropProv *a_Provider , 
	BSTR a_ObjectPath ,
	ULONG a_OperationFlag ,
	IWbemObjectSink *a_NotificationHandler ,
	IWbemContext *a_Ctx 

) : SnmpSetResponseEventObject ( a_Provider , NULL , a_Ctx , 0 ) ,
	m_NotificationHandler ( a_NotificationHandler ) , 
	m_Class ( NULL ) ,
	m_State ( 0 ),
	m_ObjectPath ( NULL ) ,
#pragma warning (disable:4355)
	snmpObject ( this )
#pragma warning (default:4355)
{
	m_NotificationHandler->AddRef () ;
	m_ObjectPath = UnicodeStringDuplicate ( a_ObjectPath ) ;
}

DeleteInstanceAsyncEventObject :: ~DeleteInstanceAsyncEventObject () 
{
// Get Status object

	delete [] m_ObjectPath ;

	if (m_NotificationHandler)
	{
		if ( FAILED ( m_errorObject.GetWbemStatus () ) )
		{
			IWbemClassObject *t_NotifyStatus = NULL ;
			BOOL t_Status = GetSnmpNotifyStatusObject ( &t_NotifyStatus ) ;
			if ( t_Status )
			{
				HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , t_NotifyStatus ) ;
				t_NotifyStatus->Release () ;
			}
			else
			{
				HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
			}
		}
		else
		{
			HRESULT t_Result = m_NotificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}

		m_NotificationHandler->Release();
	}
}

void DeleteInstanceAsyncEventObject :: ProcessComplete () 
{
	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

	Complete () ;
}

void DeleteInstanceAsyncEventObject :: Process () 
{
	switch ( m_State )
	{
		case 0:
		{
			BOOL t_Status = DeleteInstance ( m_errorObject ) ;
			if ( t_Status )
			{
			}
			else
			{
				ProcessComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propinst.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <provtree.h>
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "propdel.h"
#include "propinst.h"
#include "propquery.h"
#include "snmpget.h"
#include "snmpnext.h"

SnmpClassObject :: SnmpClassObject ( 

	const SnmpClassObject & snmpClassObject 

) : WbemSnmpClassObject ( snmpClassObject ) , 
	snmpVersion ( snmpClassObject.snmpVersion ) , 
	m_accessible ( snmpClassObject.m_accessible ) ,
	m_parentOperation ( snmpClassObject.m_parentOperation )
{
}

SnmpClassObject :: SnmpClassObject (
	SnmpResponseEventObject *parentOperation
	
) : snmpVersion ( 0 ) ,
	m_accessible ( FALSE ) ,
	m_parentOperation ( parentOperation )
{
}

SnmpClassObject :: ~SnmpClassObject ()
{
}

SnmpResponseEventObject :: SnmpResponseEventObject ( 

	CImpPropProv *providerArg ,
	IWbemContext *a_Context 

) : provider ( providerArg ) , m_namespaceObject ( NULL ) , m_Context ( a_Context ) , m_agentVersion ( 0 )
{
	if ( m_Context ) 
	{
		m_Context->AddRef () ;

		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		t_Variant.vt = VT_BOOL ;
		t_Variant.boolVal = VARIANT_FALSE ;
		m_Context->SetValue ( WBEM_CLASS_CORRELATE_CONTEXT_PROP , 0 , &t_Variant ) ;

		VariantClear ( &t_Variant ) ;
	}

	if ( provider )
		provider->AddRef () ;
}

SnmpResponseEventObject :: ~SnmpResponseEventObject ()
{
	if ( m_Context )
		m_Context->Release () ;

	if ( provider )
		provider->Release () ;

	if ( m_namespaceObject )
		m_namespaceObject->Release () ;
}


BOOL SnmpResponseEventObject :: HasNonNullKeys ( IWbemClassObject *a_Obj ) 
{
	HRESULT hr = a_Obj->BeginEnumeration ( WBEM_FLAG_KEYS_ONLY ) ;

	if ( SUCCEEDED ( hr ) )
	{
		VARIANT t_vVal ;
		VariantInit ( &t_vVal ) ;

		//returns WBEM_S_NO_ERROR or WBEM_S_NO_MORE_DATA on success
		hr = a_Obj->Next( 0, NULL, &t_vVal, NULL, NULL ) ;

		while ( hr == WBEM_S_NO_ERROR )
		{
			if ( t_vVal.vt == VT_NULL )
			{
				hr = WBEM_E_FAILED ;
			}

			VariantClear ( &t_vVal ) ;
			VariantInit ( &t_vVal ) ;
			
			if ( hr != WBEM_E_FAILED )
			{
				hr = a_Obj->Next( 0, NULL, &t_vVal, NULL, NULL ) ;
			}
		}

		VariantClear ( &t_vVal ) ;
		a_Obj->EndEnumeration () ;
	}

	return SUCCEEDED ( hr ) ;
}


BOOL SnmpResponseEventObject :: GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject )
{
	BOOL status = TRUE ;

	IWbemServices *parentServer = provider->GetParentServer () ;

	wchar_t *objectPathPrefix = UnicodeStringAppend ( WBEM_NAMESPACE_EQUALS , provider->GetThisNamespace () ) ;
	wchar_t *objectPath = UnicodeStringAppend ( objectPathPrefix , WBEM_NAMESPACE_QUOTE ) ;

	delete [] objectPathPrefix ;

	BSTR t_Path = SysAllocString ( objectPath ) ;

	HRESULT result = parentServer->GetObject ( 

		t_Path ,
		0  ,
		m_Context ,
		&m_namespaceObject ,
		NULL
	) ;

	SysFreeString ( t_Path ) ;

	if ( SUCCEEDED ( result ) )
	{
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to obtain namespace object" ) ;
	}

	parentServer->Release () ;

	delete [] objectPath ;

	return status ;
}

BOOL SnmpResponseEventObject  :: GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;
	IWbemClassObject *errorObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = provider->GetSnmpNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			VariantClear ( &variant ) ;

			if ( SUCCEEDED ( result ) )
			{
				variant.vt = VT_I4 ;
				variant.lVal = m_errorObject.GetStatus () ;

				result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSCODE , 0 , & variant , 0 ) ;
				VariantClear ( &variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					if ( m_errorObject.GetMessage () ) 
					{
						variant.vt = VT_BSTR ;
						variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

						result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
						VariantClear ( &variant ) ;

						if ( ! SUCCEEDED ( result ) )
						{
							(*notifyObject)->Release () ;
							status = GetNotifyStatusObject ( notifyObject ) ;
						}
					}
				}
				else
				{
					(*notifyObject)->Release () ;
					status = GetNotifyStatusObject ( notifyObject ) ;
				}
			}
			else
			{
				(*notifyObject)->Release () ;
				status = GetNotifyStatusObject ( notifyObject ) ;
			}

			notificationClassObject->Release () ;
		}
		else
		{
			status = GetNotifyStatusObject ( notifyObject ) ;
		}
	}
	else
	{
		status = GetNotifyStatusObject ( notifyObject ) ;
	}

	return status ;
}

BOOL SnmpResponseEventObject  :: GetNotifyStatusObject ( IWbemClassObject **notifyObject ) 
{
	IWbemClassObject *notificationClassObject = NULL ;

	BOOL status = TRUE ;

	WbemSnmpErrorObject errorStatusObject ;
	if ( notificationClassObject = provider->GetNotificationObject ( errorStatusObject ) )
	{
		HRESULT result = notificationClassObject->SpawnInstance ( 0 , notifyObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( &variant ) ;

			variant.vt = VT_I4 ;
			variant.lVal = m_errorObject.GetWbemStatus () ;

			result = (*notifyObject)->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & variant , 0 ) ;
			if ( SUCCEEDED ( result ) )
			{
				if ( m_errorObject.GetMessage () ) 
				{
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( m_errorObject.GetMessage () ) ;

					result = (*notifyObject)->Put ( WBEM_PROPERTY_SNMPSTATUSMESSAGE , 0 , & variant , 0 ) ;
					VariantClear ( &variant ) ;

					if ( ! SUCCEEDED ( result ) )
					{
						status = FALSE ;
						(*notifyObject)->Release () ;
						(*notifyObject)=NULL ;
					}
				}
			}
			else
			{
				(*notifyObject)->Release () ;
				(*notifyObject)=NULL ;
				status = FALSE ;
			}

			VariantClear ( &variant ) ;

			notificationClassObject->Release () ;
		}
		else
		{
			status = FALSE ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentTransport ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentTransport 
)
{
	BOOL status = TRUE ;
	agentTransport = NULL ;
	BSTR t_Transport = NULL ;
	wchar_t *t_QualifierTransport = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTTRANSPORT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
	}

	if ( status & ! t_Transport )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTTRANSPORT ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
			{
				SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
				t_Transport = t_QualifierTransport = stringType->GetValue () ;

				if ( t_QualifierTransport )
				{
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
	}

	if ( status & ! t_Transport )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTTRANSPORT , 
			0,	
			&t_Variant ,
			& attributeType

		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Transport = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentTransport" ) ;
			}
		}
		else
		{
			t_Transport = WBEM_AGENTIPTRANSPORT ;
		}
	}

	if ( status )
	{
		if ( ( _wcsicmp ( t_Transport , WBEM_AGENTIPTRANSPORT ) == 0 ) || ( _wcsicmp ( t_Transport , WBEM_AGENTIPXTRANSPORT ) == 0 ) )
		{
			agentTransport = UnicodeStringDuplicate ( t_Transport ) ;
		}
		else
		{
/*
*	Transport type != IP || != IPX
*/
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
		}

	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierTransport ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentTransport ( %s ) " , agentTransport 
	) ;
)

	}

	return status ;
}

ULONG SnmpResponseEventObject :: SetAgentVersion ( 

	WbemSnmpErrorObject &a_errorObject 
)
{
	BOOL status = TRUE ;

	if (m_agentVersion == 0)
	{
		BSTR t_Version = NULL ;
		wchar_t *t_QualifierVersion = NULL ;

		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		if ( m_Context )
		{
			HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTSNMPVERSION , 0 , & t_Variant ) ;
			if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
			{
				if ( t_Variant.vt == VT_BSTR ) 
				{
					t_Version = t_Variant.bstrVal ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
				}
			}
		}

		if ( status & ! t_Version )
		{
			WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTSNMPVERSION ) ;
			if ( qualifier )
			{
				SnmpInstanceType *value = qualifier->GetValue () ;
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
				{
					SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
					t_Version = t_QualifierVersion = stringType->GetValue () ;

					if ( t_QualifierVersion )
					{
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
				}
			}
		}

		if ( status & ! t_Version )
		{
			if ( ! m_namespaceObject )
			{
				status = GetNamespaceObject ( a_errorObject ) ;
			}

			if ( status )
			{
				IWbemQualifierSet *namespaceQualifierObject = NULL ;
				HRESULT result = m_namespaceObject->GetQualifierSet ( &namespaceQualifierObject ) ;
				if ( SUCCEEDED ( result ) )
				{
					LONG attributeType ;
					HRESULT result = namespaceQualifierObject->Get ( 

						WBEM_QUALIFIER_AGENTSNMPVERSION , 
						0,	
						&t_Variant ,
						& attributeType
						
					) ;

					if ( SUCCEEDED ( result ) )
					{
						if ( t_Variant.vt == VT_BSTR ) 
						{
							t_Version = t_Variant.bstrVal ;
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentSNMPVersion" ) ;
						}
					}
					else
					{
						t_Version = WBEM_AGENTSNMPVERSION_V1 ;
					}

					namespaceQualifierObject->Release();
				}
			}
		}

		if ( status )
		{
			if ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V1 ) == 0 )
			{
				m_agentVersion = 1 ;
			}
			else if ( _wcsicmp ( t_Version , WBEM_AGENTSNMPVERSION_V2C ) == 0 )
			{
				m_agentVersion = 2 ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type/Value mismatch for qualifier: AgentSNMPVersion" ) ;
			}
		}

		VariantClear ( & t_Variant );
		delete [] t_QualifierVersion ;
	}

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentVersion ( %d ) " , m_agentVersion 
	) ;
)
	}

	return m_agentVersion ;
}

BOOL SnmpResponseEventObject :: GetAgentAddress ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentAddress 
)
{
	BOOL status = TRUE ;
	agentAddress = NULL ;
	BSTR t_Address = NULL ;
	wchar_t *t_QualifierAddress = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTADDRESS , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
	}

	if ( status & ! t_Address )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTADDRESS ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
			{
				SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
				t_Address = t_QualifierAddress = stringType->GetValue () ;

				if ( t_QualifierAddress )
				{
					if ( wcscmp ( t_Address , L"" ) == 0 ) 
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
	}

	if ( status & ! t_Address )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTADDRESS , 
			0,	
			&t_Variant ,
			& attributeType
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Address = t_Variant.bstrVal ;
				if ( wcscmp ( t_Address , L"" ) == 0 ) 
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Namespace must specify valid qualifier for: AgentAddress" ) ;
		}
	}

	if ( status )
	{
		agentAddress = UnicodeStringDuplicate ( t_Address ) ;
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierAddress ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentAddress ( %s ) " , agentAddress 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentReadCommunityName ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentReadCommunityName 
)
{
	BOOL status = TRUE ;
	agentReadCommunityName = NULL ;
	BSTR t_Community = NULL ;
	wchar_t *t_QualifierCommunity = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
			{
				SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
				t_Community = t_QualifierCommunity = stringType->GetValue () ;

				if ( t_QualifierCommunity )
				{
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentReadCommunityName" ) ;
			}
		}
		else
		{
			t_Community = WBEM_AGENTCOMMUNITYNAME ;
		}
	}

	if ( status )
	{
		agentReadCommunityName = UnicodeStringDuplicate ( t_Community ) ;
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierCommunity ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentReadCommunityName ( %s ) " , agentReadCommunityName 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentWriteCommunityName ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	wchar_t *&agentWriteCommunityName 
)
{
	BOOL status = TRUE ;
	agentWriteCommunityName = NULL ;
	BSTR t_Community = NULL ;
	wchar_t *t_QualifierCommunity = NULL ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
			}
		}
	}

	if ( status & ! t_Community )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
			{
				SnmpDisplayStringType *stringType = ( SnmpDisplayStringType * ) value ;
				t_Community = t_QualifierCommunity = stringType->GetValue () ;

				if ( t_QualifierCommunity )
				{
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
			}

		}
	}

	if ( status & ! t_Community )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_BSTR ) 
			{
				t_Community = t_Variant.bstrVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentWriteCommunityName" ) ;
			}
		}
		else
		{
			t_Community = WBEM_AGENTCOMMUNITYNAME ;
		}
	}

	if ( status )
	{
		agentWriteCommunityName = UnicodeStringDuplicate ( t_Community ) ;
	}

	VariantClear ( & t_Variant );
	delete [] t_QualifierCommunity ;

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentWriteCommunityName ( %s ) " , agentWriteCommunityName 
	) ;
)
	}

	return status ;
}


BOOL SnmpResponseEventObject :: GetAgentRetryCount ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentRetryCount 
)
{
	BOOL status = TRUE ;
	agentRetryCount = 1 ;
	BOOL t_RetryCount = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYCOUNT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryCount = TRUE ;
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	if ( status & ! t_RetryCount )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTRETRYCOUNT ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
				agentRetryCount = integerType->GetValue () ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	if ( status & ! t_RetryCount )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYCOUNT , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryCount = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryCount" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentRetryCount ( %ld ) " , agentRetryCount 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentRetryTimeout( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentRetryTimeout 
)
{
	BOOL status = TRUE ;
	agentRetryTimeout = 0 ;
	BOOL t_RetryTimeout = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_RetryTimeout = TRUE ;
 
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	if ( status & ! t_RetryTimeout )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTRETRYTIMEOUT ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
				agentRetryTimeout = integerType->GetValue () ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	if ( status & ! t_RetryTimeout )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTRETRYTIMEOUT , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				agentRetryTimeout = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentRetryTimeout" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentRetryTimeout ( %ld ) " , agentRetryTimeout 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentMaxVarBindsPerPdu ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentVarBindsPerPdu 
)
{
	BOOL status = TRUE ;
	agentVarBindsPerPdu = 0 ;
	BOOL t_VarBinds = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_VarBinds = TRUE ;
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	if ( status & ! t_VarBinds )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTVARBINDSPERPDU ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
				agentVarBindsPerPdu = integerType->GetValue () ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	if ( status & ! t_VarBinds )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTVARBINDSPERPDU , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{		
				agentVarBindsPerPdu = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentVarBindPerPdu" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentVarBindsPerPdu ( %ld ) " , agentVarBindsPerPdu 
	) ;
)
	}

	return status ;
}

BOOL SnmpResponseEventObject :: GetAgentFlowControlWindowSize ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemQualifierSet *namespaceQualifierObject , 
	ULONG &agentFlowControlWindowSize 
)
{
	BOOL status = TRUE ;
	agentFlowControlWindowSize = 0 ;
	BOOL t_WindowSize = FALSE ;

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	if ( m_Context )
	{
		HRESULT result = m_Context->GetValue ( WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( result ) & ( t_Variant.vt != VT_EMPTY ) )
		{
			if ( t_Variant.vt == VT_I4 ) 
			{
				t_WindowSize = TRUE ;
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	if ( status & ! t_WindowSize )
	{
		WbemSnmpQualifier *qualifier = GetSnmpClassObject ()->FindQualifier ( WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE ) ;
		if ( qualifier )
		{
			SnmpInstanceType *value = qualifier->GetValue () ;
			if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
				agentFlowControlWindowSize = integerType->GetValue () ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	if ( status & ! t_WindowSize )
	{
		LONG attributeType ;
		HRESULT result = namespaceQualifierObject->Get ( 

			WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE , 
			0,	
			&t_Variant ,
			& attributeType 
			
		) ;

		if ( SUCCEEDED ( result ) )
		{
			if ( t_Variant.vt == VT_I4 )
			{
				agentFlowControlWindowSize = t_Variant.lVal ;
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentFlowControlWindowSize" ) ;
			}
		}
	}

	VariantClear ( & t_Variant );

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Using AgentFlowControlWindowSize ( %ld ) " , agentFlowControlWindowSize 
	) ;
)
	}

	return status ;
}

SnmpInstanceClassObject :: SnmpInstanceClassObject ( 

	const SnmpInstanceClassObject & snmpInstanceClassObject 

) : SnmpClassObject ( snmpInstanceClassObject ) 
{
}

SnmpInstanceClassObject :: SnmpInstanceClassObject (
	SnmpResponseEventObject *parentOperation
) :	SnmpClassObject ( parentOperation )
{
}

SnmpInstanceClassObject :: ~SnmpInstanceClassObject ()
{
}

BOOL SnmpInstanceClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{
	BOOL status = TRUE ;

	snmpVersion = m_parentOperation->SetAgentVersion ( a_errorObject ) ;

	if ( snmpVersion == 0 )
	{
		status = FALSE ;
	}

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		status = CheckProperty ( a_errorObject , property ) ;
	}

	if ( ! m_accessible ) 
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOREADABLEPROPERTIES ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Class must contain at least one property which is accessible" ) ;
	}

	return status ;
}

BOOL SnmpInstanceClassObject :: CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property )
{
	BOOL status = TRUE ;

	if ( ( snmpVersion == 1 ) && property->IsSNMPV1Type () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}
	else if ( ( snmpVersion == 2 ) && property->IsSNMPV2CType () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}

	return status ;
}

SnmpInstanceResponseEventObject :: SnmpInstanceResponseEventObject ( 

	CImpPropProv *providerArg ,
	IWbemContext *a_Context 

) : SnmpResponseEventObject ( providerArg , a_Context ) ,
	classObject ( NULL ) ,
	instanceObject ( NULL ) ,
#if 0
	instanceAccessObject ( NULL ) ,
#endif
	session ( NULL ) ,
	operation ( NULL ) ,
	m_PartitionSet ( NULL ) ,
#pragma warning (disable:4355)
	snmpObject ( this )
#pragma warning (default:4355)
{
}

SnmpInstanceResponseEventObject :: ~SnmpInstanceResponseEventObject ()
{
#if 0
	if ( instanceAccessObject )
		instanceAccessObject->Release ();
#endif

	if ( instanceObject ) 
		instanceObject->Release () ;

	if ( classObject ) 
		classObject->Release () ;
}

BOOL SnmpInstanceResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	IWbemQualifierSet *namespaceQualifierObject = NULL ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &namespaceQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentReadCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = SetAgentVersion ( m_errorObject ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , namespaceQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , namespaceQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentReadCommunityName ( m_errorObject , namespaceQualifierObject , agentReadCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , namespaceQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , namespaceQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , namespaceQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , namespaceQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
				if ( dbcsAgentReadCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = provider->GetIpAddressValue () ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else
							{
								if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
								{
									t_Address = dbcsAgentAddress ;
								}
								else							
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
								}
							}
						}

						if ( status )
						{
							if ( m_agentVersion == 1 )
							{
								session = new SnmpV1OverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( m_agentVersion == 2 )
							{
								session = new SnmpV2COverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( ! SnmpTransportIpxAddress :: ValidateAddress ( dbcsAgentAddress  ) )
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
						}

						if ( status )
						{
							if ( m_agentVersion == 1 )
							{
								session = new SnmpV1OverIpx (

									dbcsAgentAddress ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( m_agentVersion == 2 )
							{
								session = new SnmpV2COverIpx (

									dbcsAgentAddress  ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsAgentReadCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;

				if ( status )
				{
					operation = new AutoRetrieveOperation(*session,this);
					operation->Send () ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentReadCommunityName ;

		namespaceQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

	return status ;
}

SnmpInstanceEventObject :: SnmpInstanceEventObject ( 

	CImpPropProv *providerArg , 
	BSTR ClassArg ,
	IWbemContext *a_Context 

) : SnmpInstanceResponseEventObject ( providerArg , a_Context ) , Class ( NULL )
{
	Class = SysAllocString ( ClassArg ) ;
}

SnmpInstanceEventObject :: ~SnmpInstanceEventObject ()
{
	SysFreeString ( Class ) ;
}

BOOL SnmpInstanceEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;
	IWbemServices *t_Serv = provider->GetServer();

	HRESULT result = WBEM_E_FAILED;
	
	if (t_Serv)
	{
		result = t_Serv->GetObject (

			Class ,
			0  ,
			m_Context ,
			& classObject ,
			NULL 
		) ;

		t_Serv->Release();
	}

	if ( SUCCEEDED ( result ) )
	{
		result = classObject->SpawnInstance ( 0 , & instanceObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			if ( status = GetNamespaceObject ( a_errorObject ) )
			{
				if ( status = snmpObject.Set ( a_errorObject , classObject , FALSE ) )
				{
					if ( status = snmpObject.Check ( a_errorObject ) )
					{
						status = SendSnmp ( a_errorObject ) ;
					}
					else
					{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)
					}
				}
				else
				{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
				}
			}
		}
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;
)

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Unknown Class" ) ;
	}

	return status ;
}

SnmpInstanceAsyncEventObject :: SnmpInstanceAsyncEventObject (

	CImpPropProv *providerArg , 
	BSTR Class ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context 

) : SnmpInstanceEventObject ( providerArg , Class , a_Context ) , notificationHandler ( notify ) , state ( 0 )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: SnmpInstanceAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpInstanceAsyncEventObject :: ~SnmpInstanceAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: ~SnmpInstanceAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{

// Get Status object

		IWbemClassObject *notifyStatus ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
		else
		{
			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	ULONG t_Ref = notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpInstanceAsyncEventObject :: ~SnmpInstanceAsyncEventObject ()" 
	) ;
)

}

void SnmpInstanceAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Enumeration Succeeded" 
	) ;
)

	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Enumeration Failed" 
	) ;
)

	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	AutoRetrieveOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

}

void SnmpInstanceAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			BOOL status = Instantiate ( m_errorObject ) ;
			if ( status )
			{
			}
			else
			{
				ReceiveComplete () ;	
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpInstanceAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpInstanceAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;
	BOOL status = TRUE ;

	notificationHandler->Indicate ( 1 , & snmpObject ) ;
	if ( ! HasNonNullKeys ( snmpObject ) )
	{
		if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
		}
	}
}

void SnmpInstanceAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject *snmpObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpInstanceAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;

	IWbemClassObject *cloneObject ;
	if ( SUCCEEDED ( result = classObject->SpawnInstance ( 0 , & cloneObject ) ) ) 
	{
		WbemSnmpErrorObject errorObject ;
		if ( snmpObject->Get ( errorObject , cloneObject ) )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)

			notificationHandler->Indicate ( 1 , & cloneObject ) ;
			if ( ! HasNonNullKeys ( cloneObject ) )
			{
				if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
				}
			}			
		}
		else
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Failed to Convert WbemSnmpClassObject to IWbemClassObject" 
	) ;
)
		}
		cloneObject->Release () ;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propget.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "snmpget.h"

SnmpGetClassObject :: SnmpGetClassObject ( SnmpResponseEventObject *parentOperation ) : SnmpClassObject ( parentOperation )
{
}

SnmpGetClassObject :: ~SnmpGetClassObject ()
{
}

BOOL SnmpGetClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{
// Check Class Object, used in a Get Request, for validity

	BOOL status = TRUE ;

	snmpVersion = m_parentOperation->SetAgentVersion ( a_errorObject ) ;

	if ( snmpVersion == 0 )
	{
		status = FALSE ;
	}

// Check all Properties for validity

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		status = CheckProperty ( a_errorObject , property ) ;
	}

// Check properties defined as keys have valid key order
 
	if ( status )
	{
		if ( ! m_accessible ) 
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_NOREADABLEPROPERTIES ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class must contain at least one property which is accessible" ) ;
		}
	}

	return status ;
}

BOOL SnmpGetClassObject :: CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property )
{
// Check property validity

	BOOL status = TRUE ;

	if ( ( snmpVersion == 1 ) && property->IsSNMPV1Type () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}
	else if ( ( snmpVersion == 2 ) && property->IsSNMPV2CType () && property->IsReadable () )
	{
		m_accessible = TRUE ;
	}

	return status ;
}

SnmpGetResponseEventObject :: SnmpGetResponseEventObject ( 

	CImpPropProv *providerArg , 
	IWbemClassObject *classObjectArg ,
	IWbemContext *a_Context 

) : SnmpResponseEventObject ( providerArg , a_Context ) , 
	classObject ( classObjectArg ) , 
	instanceObject ( NULL ) ,	
	session ( NULL ) , 
	operation ( NULL ) , 
	processComplete ( FALSE ) ,
#pragma warning( disable : 4355 )
	snmpObject ( this )
#pragma warning( default : 4355 )
{
	if ( classObject )
		classObject->AddRef () ;
}

SnmpGetResponseEventObject :: ~SnmpGetResponseEventObject ()
{
	if ( instanceObject )
		instanceObject->Release () ;

	if ( classObject ) 
		classObject->Release () ;
}

BOOL SnmpGetResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentReadCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = SetAgentVersion ( m_errorObject ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , classQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , classQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentReadCommunityName ( m_errorObject , classQualifierObject , agentReadCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , classQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , classQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , classQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsAgentReadCommunityName = UnicodeToDbcsString ( agentReadCommunityName ) ;
				if ( dbcsAgentReadCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = provider->GetIpAddressValue () ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else
							{
								if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
								{
									t_Address = dbcsAgentAddress ;
								}
								else							
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
								}
							}
						}

						if ( status )
						{
							if ( m_agentVersion == 1 )
							{
								session = new SnmpV1OverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)
									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( m_agentVersion == 2 )
							{
								session = new SnmpV2COverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsAgentReadCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( m_agentVersion == 1 )
						{
							session = new SnmpV1OverIpx (

								dbcsAgentAddress ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)
								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( m_agentVersion == 2 )
						{
							session = new SnmpV2COverIpx (

								dbcsAgentAddress  ,
								dbcsAgentReadCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsAgentReadCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentReadCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;

				if ( status )
				{
					operation = new GetOperation(*session,this);
					operation->Send () ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentReadCommunityName ;

		classQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

	return status ;

}

SnmpGetEventObject :: SnmpGetEventObject (

	CImpPropProv *providerArg , 
	wchar_t *ObjectPathArg ,
	IWbemContext *a_Context 

) : SnmpGetResponseEventObject ( providerArg , NULL , a_Context ) , objectPath ( NULL )
{
	ULONG length = wcslen ( ObjectPathArg ) ;
	objectPath = new wchar_t [ length + 1 ] ;
	wcscpy ( objectPath , ObjectPathArg ) ;
}

SnmpGetEventObject :: ~SnmpGetEventObject ()
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: ~SnmpGetEventObject()"
	) ;
)

	delete [] objectPath ;
}

BOOL SnmpGetEventObject :: ParseObjectPath ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: ParseObjectPath ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

// Check Validity of instance path

	ParsedObjectPath *t_ParsedObjectPath = NULL ;
	CObjectPathParser t_ObjectPathParser ;

	BOOL status = t_ObjectPathParser.Parse ( objectPath , &t_ParsedObjectPath ) ;
	if ( status == 0 )
	{
// Check validity of path

		status = DispatchObjectPath ( a_errorObject , t_ParsedObjectPath ) ;
	}
	else
	{
// Parse Failure

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATH ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Failed to parse object path" ) ;
	}

	delete t_ParsedObjectPath ;

	return status ;
}

BOOL SnmpGetEventObject :: DispatchObjectPath ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) 
{
// Check validity of server/namespace path and validity of request

	BOOL status = TRUE ;

	status = DispatchObjectReference ( a_errorObject , t_ParsedObjectPath ) ;

	return status ;
}

BOOL SnmpGetEventObject :: DispatchObjectReference ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: DispatchObjectReference ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath )"
	) ;
)

// Check validity of request

	BOOL status = TRUE ;

// Get type of request

	if ( t_ParsedObjectPath->m_bSingletonObj )
	{
// Class requested

		status = DispatchKeyLessClass ( a_errorObject , t_ParsedObjectPath->m_pClass ) ;
	}
	else if ( t_ParsedObjectPath->m_dwNumKeys == 0 )
	{
// Class requested

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_NOT_CAPABLE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_NOT_CAPABLE ) ;
		a_errorObject.SetMessage ( L"Unexpected Path parameter" ) ;

	}
	else 
	{
// General instance requested

		status = DispatchInstanceSpec ( a_errorObject , t_ParsedObjectPath ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: GetInstanceClass ( WbemSnmpErrorObject &a_errorObject , BSTR Class )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: GetInstanceClass ( WbemSnmpErrorObject &a_errorObject , BSTR Class (%s) )" ,
		Class
	) ;
)

// Get OLE MS class definition

	BOOL status = TRUE ;
	IWbemServices *t_Serv = provider->GetServer();
	HRESULT result = WBEM_E_FAILED;
	
	if (t_Serv)
	{
		result = t_Serv->GetObject (

			Class ,
			0 ,
			m_Context ,
			& classObject ,
			NULL
		) ;

		t_Serv->Release () ;
	}

// Clone object

	if ( SUCCEEDED ( result ) )
	{
		result = classObject->SpawnInstance ( 0 , & instanceObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			if ( status = GetNamespaceObject ( a_errorObject ) )
			{
			}
		}
	}
	else
	{
// Class definition unknown

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Unexpected Path parameter" ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: DispatchKeyLessClass ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: DispatchKeyLessClass ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class (%s) )",
		a_Class
	) ;
)

	BOOL status = TRUE ;

	status = GetInstanceClass ( a_errorObject , a_Class ) ;
	if ( status )
	{
		status = snmpObject.Set ( a_errorObject , GetClassObject () , FALSE ) ;
		if ( status )
		{
			status = snmpObject.Check ( a_errorObject ) ;
			if ( status )
			{
				status = SendSnmp ( a_errorObject ) ;
			}
			else
			{
// Class definition syntactically incorrect
			}
		}
		else
		{
// Class definition syntactically incorrect
		}
	}
	else
	{
// Class definition unknown
	}

	return status ;
}

BOOL SnmpGetEventObject :: SetProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property , KeyRef *a_KeyReference )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SetProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property (%s) , KeyRef *a_KeyReference )",
		property->GetName () 
	) ;
)

// Set keyed property value used for instance retrieval using path specification

	BOOL status = TRUE ;

	if ( a_KeyReference->m_vValue.vt == VT_I4 )
	{
// property value is an integer type

		if ( property->SetValue ( a_KeyReference->m_vValue , property->GetCimType () ) ) 
		{
		}
		else
		{
// Property value doesn't correspond with property syntax

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Path parameter is inconsistent with keyed property: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , property->GetName () ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}
	}
	else if ( a_KeyReference->m_vValue.vt == VT_BSTR )
	{
// property value is an string type

		if ( property->SetValue ( a_KeyReference->m_vValue , property->GetCimType () ) )
		{
		}
		else
		{
// Property value doesn't correspond with property syntax

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Path parameter is inconsistent with keyed property: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , property->GetName () ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 

		}
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Path parameter is inconsistent with keyed property" ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: SetInstanceSpecKeys ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: SetInstanceSpecKeys ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath )"
	) ;
)

// Get Instance based on general request

	BOOL status = TRUE ;

// Clear Tag for all keyed properties

	WbemSnmpProperty *property ;
	snmpObject.ResetKeyProperty () ;
	while ( property = snmpObject.NextKeyProperty () )
	{
		property->SetTag ( FALSE ) ;
	}

// Check request doesn't contain duplicate property names

	if ( snmpObject.GetKeyPropertyCount () == 1 )
	{
// Class contains exactly one keyed property

		WbemSnmpProperty *property ;
		snmpObject.ResetKeyProperty () ;
		if ( property = snmpObject.NextKeyProperty () )
		{
// Set Key property value

			KeyRef *t_PropertyReference = a_ParsedObjectPath->m_paKeys [ 0 ] ;
			status = SetProperty ( a_errorObject , property , t_PropertyReference ) ;
		}
	}
	else if ( snmpObject.GetKeyPropertyCount () != 0 )
	{
// Iterate through list of key assignments in request

		ULONG t_Index = 0 ;
		while ( t_Index < a_ParsedObjectPath->m_dwNumKeys )
		{
			KeyRef *t_PropertyReference = a_ParsedObjectPath->m_paKeys [ t_Index ] ;
			WbemSnmpProperty *property ;
			if ( property = snmpObject.FindKeyProperty ( t_PropertyReference->m_pName ) )
			{
				if ( property->GetTag () )
				{
// key value already specified in request

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_DUPLICATEPATHKEYPARAMETER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Path definition specified duplicate key parameter" ) ;

					break ;
				}
				else
				{
// Set property based on request value

					property->SetTag () ;
					status = SetProperty ( a_errorObject , property , t_PropertyReference ) ;
					if ( status )
					{
					}
					else
					{
// Illegal key value specified

						break ;
					}
				}
			}
			else
			{
// Property request is not a valid keyed property

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PATHKEYPARAMETER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Path definition specified invalid key parameter name" ) ;

				break ;
			}

			t_Index ++ ;
		}

// Check all keyed properties values have been specified

		if ( status )
		{
			WbemSnmpProperty *property ;
			snmpObject.ResetKeyProperty () ;
			while ( status && ( property = snmpObject.NextKeyProperty () ) )
			{
				if ( property->GetTag () ) 
				{
				}
				else
				{
// One of the keyed properties has not been specified

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_MISSINGPATHKEYPARAMETER ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Path definition did not specify all key parameter values" ) ;

					break ;
				}
			}
		}
	}
	else
	{
// Class contains zero keyed properties, has already have been checked

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Path definition specified key parameters for keyless class" ) ;
	}

	return status ;
}

BOOL SnmpGetEventObject :: DispatchInstanceSpec ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetEventObject :: DispatchInstanceSpec ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *a_ParsedObjectPath )"
	) ;
)

	BOOL status = TRUE ;

	status = GetInstanceClass ( a_errorObject , a_ParsedObjectPath->m_pClass ) ;
	if ( status )
	{
		status = snmpObject.Set ( a_errorObject , GetClassObject () , FALSE ) ;
		if ( status )
		{
			status = snmpObject.Check ( a_errorObject ) ;
			if ( status )
			{
				status = SetInstanceSpecKeys ( a_errorObject , a_ParsedObjectPath ) ;
				if ( status )
				{
					status = SendSnmp ( a_errorObject ) ;
				}
				else
				{
// Requested Property value definitions illegal

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Key Specification was illegal"
	) ;
)
				}
			}
			else
			{
// Class definition syntactically incorrect

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Failed During Check :Class definition did not conform to mapping"
	) ;
)

			}
		}
		else
		{
// Class definition syntactically incorrect

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Failed During Set : Class definition did not conform to mapping"
	) ;
)
		}
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Unknown Class" ) ;

)

// Class definition unknown
	}

	return status ;
}

SnmpGetAsyncEventObject :: SnmpGetAsyncEventObject (

	CImpPropProv *providerArg , 
	wchar_t *ObjectPathArg ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context 

) : SnmpGetEventObject ( providerArg , ObjectPathArg , a_Context ) , notificationHandler ( notify ) , state ( 0 )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: SnmpGetAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpGetAsyncEventObject :: ~SnmpGetAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: ~SnmpGetAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{

// Get Status object

		IWbemClassObject *notifyStatus = NULL ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpGetAsyncEventObject :: ~SnmpGetAsyncEventObject ()" 
	) ;
)

}

void SnmpGetAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
		if ( notificationHandler )
		{

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)
			notificationHandler->Indicate ( 1 , & instanceObject ) ;
			if ( ! HasNonNullKeys ( instanceObject ) )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
			}
		}
		else
		{
		}
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	GetOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpGetAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

}

void SnmpGetAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpGetAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			BOOL status = ParseObjectPath ( m_errorObject ) ;
			if ( status )
			{
				if ( processComplete )
				{
					ReceiveComplete () ;
				}
			}
			else
			{
				ReceiveComplete () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpGetAsyncEventObject :: Process ()" 
	) ;
)

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpSetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "snmpget.h"
#include "snmpset.h"
#include "snmpqset.h"

SnmpSetClassObject :: SnmpSetClassObject ( SnmpResponseEventObject *parentOperation ) :
												SnmpClassObject ( parentOperation )	,
												m_WritableSetCount ( 0 ) , 
												m_WritableSet ( NULL ) , 
												m_RowStatusSpecified ( FALSE ) , 
												m_RowStatusPresent ( FALSE ) 
{
}

SnmpSetClassObject :: ~SnmpSetClassObject ()
{
	if ( m_WritableSetCount )
	{
		for ( DWORD t_Index = 0 ; t_Index < m_WritableSetCount ; t_Index ++ )
		{
			delete [] (m_WritableSet[t_Index]) ;
			m_WritableSet[t_Index] = NULL ;
		}

		delete [] m_WritableSet ;
		m_WritableSet = NULL ;
		m_WritableSetCount = 0 ;
	}
}

void SnmpSetClassObject :: SetWritableSet ( 

	wchar_t **a_WritableSet ,
	ULONG a_WritableSetCount 
) 
{
	if ( m_WritableSetCount )
	{
		for ( DWORD t_Index = 0 ; t_Index < m_WritableSetCount ; t_Index ++ )
		{
			delete [] (m_WritableSet[t_Index]) ;
			m_WritableSet[t_Index] = NULL ;
		}

		delete [] m_WritableSet;
		m_WritableSet = NULL ;
		m_WritableSetCount = 0 ;
	}

	m_WritableSet = a_WritableSet ;
	m_WritableSetCount = a_WritableSetCount ;
}

BOOL SnmpSetClassObject :: IsWritable ( WbemSnmpProperty *a_Property )
{
	if ( a_Property )
	{
		if ( ! a_Property->GetTag () )
		{
			BOOL t_Status = ( GetSnmpVersion () == 1 ) && ( a_Property->IsSNMPV1Type () ) ;
			t_Status = t_Status || ( ( GetSnmpVersion () == 2 ) && ( a_Property->IsSNMPV2CType () ) ) ;
			if ( t_Status )
			{
				if ( a_Property->IsVirtualKey () == FALSE )
				{
					if ( a_Property->IsWritable () )
					{
						if ( m_WritableSetCount )
						{
							for ( DWORD t_Index = 0 ; t_Index < m_WritableSetCount; t_Index ++ )
							{
								if ( _wcsicmp ( a_Property->GetName () , m_WritableSet [ t_Index ] ) == 0 )
								{
									return TRUE ;
								}
							}
						}
						else
						{
							return TRUE ;
						}
					}
				}
			}
		}
	}

	return FALSE ;
}

ULONG SnmpSetClassObject :: NumberOfWritable ()
{
	WbemSnmpProperty *t_CurrentProperty = GetCurrentProperty () ;

	ULONG t_NumberOfWritable = 0 ;

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( property = NextProperty () )
	{
		if ( ! property->GetTag () )
		{
			BOOL t_Status = ( GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
			t_Status = t_Status || ( ( GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;
			if ( t_Status )
			{
				if ( property->IsVirtualKey () == FALSE )
				{
					if ( property->IsWritable () )
					{
						if ( m_WritableSetCount )
						{
							for ( DWORD t_Index = 0 ; t_Index < m_WritableSetCount; t_Index ++ )
							{
								if ( _wcsicmp ( property->GetName () , m_WritableSet [ t_Index ] ) == 0 )
								{
									t_NumberOfWritable ++ ;
									break ;
								}
							}
						}
						else
						{
							t_NumberOfWritable ++ ;
						}
					}
				}
			}
		}
	}

	GotoProperty ( t_CurrentProperty ) ;

	return t_NumberOfWritable ;
}

BOOL SnmpSetClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{
// Check Class Object, used in a Get Request, for validity

	BOOL status = TRUE ;

	snmpVersion = m_parentOperation->SetAgentVersion ( a_errorObject ) ;

	if ( snmpVersion == 0 )
	{
		status = FALSE ;
	}

#if 0
	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ROWSTATUS ) ;
	if ( qualifier )
	{
		SnmpInstanceType *value = qualifier->GetValue () ;
		if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
		{
			SnmpIntegerType *integerType = ( SnmpIntegerType * ) value ;
			m_RowStatusSpecified = integerType->GetValue () ;
		}
		else
		{
// Problem Here

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Type mismatch for qualifier: RowStatus" ) ;
		}
	}
#endif

// Check all Properties for validity

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		status = CheckProperty ( a_errorObject , property ) ;
	}

	if ( ! m_accessible ) 
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_NOWRITABLEPROPERTIES ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Class must contain at least one property which is accessible" ) ;
	}

	if ( m_RowStatusSpecified && ! m_RowStatusPresent )
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		a_errorObject.SetMessage ( L"Class must contain at least one property which is of type RowStatus" ) ;
	}

	return status ;
}

BOOL SnmpSetClassObject :: CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property )
{
// Check property validity

	BOOL status = TRUE ;

	if ( typeid ( *property->GetValue () ) == typeid ( SnmpObjectIdentifierType ) )
	{
		SnmpObjectIdentifierType *t_ObjectIdentifier = ( SnmpObjectIdentifierType * ) property->GetValue () ;
		if ( t_ObjectIdentifier->GetValueLength () < 2 ) 
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for property: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , property->GetName () ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}
	}

	if ( typeid ( *property->GetValue () ) == typeid ( SnmpRowStatusType ) )
	{
		if ( m_RowStatusPresent )
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_CLASS ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class contains more than one property with RowStatus type definition" ) ;

		}
		else
		{
			m_RowStatusPresent = TRUE ;
		}
	}

	if ( ( snmpVersion == 1 ) && property->IsSNMPV1Type () && IsWritable ( property ) )
	{
		m_accessible = TRUE ;
	}
	else if ( ( snmpVersion == 2 ) && property->IsSNMPV2CType () && IsWritable  ( property ) )
	{
		m_accessible = TRUE ;
	}

	return status ;
}

SnmpSetResponseEventObject :: SnmpSetResponseEventObject ( 

	CImpPropProv *providerArg , 
	IWbemClassObject *classObjectArg ,
	IWbemContext *a_Context ,
	long lflags

) : SnmpResponseEventObject ( providerArg , a_Context ) , 
	classObject ( NULL ) , 
	session ( NULL ) , 
	operation ( NULL ) , 
	processComplete ( FALSE ) , 
	m_lflags ( lflags ) ,
	state ( 0 ) ,
	m_SnmpTooBig ( FALSE ) ,
	m_VarBindsLeftBeforeTooBig ( 0 ) ,
#pragma warning (disable:4355)
	snmpObject ( this )
#pragma warning (default:4355)
{
	if ( classObjectArg )
	{
		classObject = classObjectArg;
		classObject->AddRef () ;
	}

	if ( a_Context )
	{
		VARIANT t_Variant ;
		VariantInit ( & t_Variant ) ;

		HRESULT t_Result = a_Context->GetValue ( L"__PUT_EXTENSIONS" , 0 , & t_Variant ) ;
		if ( SUCCEEDED ( t_Result ) )
		{
			if ( t_Variant.vt == VT_BOOL && t_Variant.boolVal == VARIANT_TRUE ) 
			{
				VARIANT t_ArrayVariant ;
				VariantInit ( & t_ArrayVariant ) ;
				
				HRESULT t_Result = a_Context->GetValue ( L"__PUT_EXT_PROPERTIES" , 0 , & t_ArrayVariant ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					if ( t_ArrayVariant.vt == ( VT_ARRAY | VT_BSTR ) ) 
					{
						if ( SafeArrayGetDim ( t_ArrayVariant.parray ) == 1 )
						{
							LONG t_Dimension = 1 ; 
							LONG t_Lower ;
							SafeArrayGetLBound ( t_ArrayVariant.parray , t_Dimension , & t_Lower ) ;
							LONG t_Upper ;
							SafeArrayGetUBound ( t_ArrayVariant.parray , t_Dimension , & t_Upper ) ;
							LONG t_Count = ( t_Upper - t_Lower ) + 1 ;

							DWORD t_WritableSetCount = t_Count ;
							wchar_t **t_WritableSet = new wchar_t * [ t_Count ] ;

							for ( LONG t_ElementIndex = t_Lower ; t_ElementIndex <= t_Upper ; t_ElementIndex ++ )
							{
								BSTR t_Element ;
								SafeArrayGetElement ( t_ArrayVariant.parray , &t_ElementIndex , & t_Element ) ;

								wchar_t *t_String = new wchar_t [ wcslen ( t_Element ) + 1 ] ;
								wcscpy ( t_String , t_Element ) ;

								t_WritableSet [ t_ElementIndex - t_Lower ] = t_String ;
							}

							snmpObject.SetWritableSet ( t_WritableSet , t_WritableSetCount ) ;
						}
					}

					VariantClear ( & t_ArrayVariant ) ;
				}
			}

			VariantClear ( & t_Variant ) ;
		}
	}
}

SnmpSetResponseEventObject :: ~SnmpSetResponseEventObject ()
{
	if ( classObject ) 
		classObject->Release () ;
}

BOOL SnmpSetResponseEventObject :: SendSnmp ( WbemSnmpErrorObject &a_errorObject , const ULONG &a_NumberToSend )
{
	m_SnmpTooBig = FALSE ;

	BOOL status = TRUE ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentWriteCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = SetAgentVersion ( m_errorObject  ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , classQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , classQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentWriteCommunityName ( m_errorObject , classQualifierObject , agentWriteCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , classQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , classQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , classQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsagentWriteCommunityName = UnicodeToDbcsString ( agentWriteCommunityName ) ;
				if ( dbcsagentWriteCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = provider->GetIpAddressValue () ;
						}
						else
						{
							if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_VALUE ) )
							{
								t_Address = dbcsAgentAddress ;
							}
							else
							{
								if ( SnmpTransportIpAddress :: ValidateAddress ( dbcsAgentAddress , SNMP_ADDRESS_RESOLVE_NAME ) )
								{
									t_Address = dbcsAgentAddress ;
								}
								else							
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Illegal IP address value or unresolvable name for AgentAddress" ) ;
								}
							}
						}

						if ( status )
						{
							if ( m_agentVersion == 1 )
							{
								session = new SnmpV1OverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsagentWriteCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else if ( m_agentVersion == 2 )
							{
								session = new SnmpV2COverIp (

									t_Address ,
									SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
									dbcsagentWriteCommunityName ,
									agentRetryCount , 
									agentRetryTimeout ,
									agentMaxVarBindsPerPdu ,
									agentFlowControlWindowSize 
								);

								if ( ! (*session)() )
								{
	DebugMacro3( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"SNMPCL Session could not be created"
		) ;
	)

									delete session ;
									session = NULL ;

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
								}
							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

							}
						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( m_agentVersion == 1 )
						{
							session = new SnmpV1OverIpx (

								dbcsAgentAddress ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( m_agentVersion == 2 )
						{
							session = new SnmpV2COverIpx (

								dbcsAgentAddress  ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentMaxVarBindsPerPdu ,
								agentFlowControlWindowSize 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsagentWriteCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: agentWriteCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;

				if ( status )
				{
					operation = new SetOperation(*session,this);
					operation->Send ( a_NumberToSend ) ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentWriteCommunityName ;

		classQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

	return status ;
}

SnmpUpdateEventObject :: SnmpUpdateEventObject (

	CImpPropProv *providerArg , 
	IWbemClassObject *classObject ,
	IWbemContext *a_Context ,
	long lflags 

) : SnmpSetResponseEventObject ( providerArg , classObject , a_Context , lflags ) 
{
}

SnmpUpdateEventObject :: ~SnmpUpdateEventObject ()
{
}

BOOL SnmpUpdateEventObject :: CheckForRowExistence ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateEventObject :: CheckForRowExistence ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)
	BOOL status = TRUE ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		wchar_t *agentAddress = NULL ;
		wchar_t *agentTransport = NULL ;
		wchar_t *agentWriteCommunityName = NULL ;
		ULONG agentRetryCount ;
		ULONG agentRetryTimeout ;
		ULONG agentMaxVarBindsPerPdu ;
		ULONG agentFlowControlWindowSize ;

		status = SetAgentVersion ( m_errorObject ) ;
		if ( status ) status = GetAgentAddress ( m_errorObject , classQualifierObject , agentAddress ) ;
		if ( status ) status = GetAgentTransport ( m_errorObject , classQualifierObject , agentTransport ) ;
		if ( status ) status = GetAgentWriteCommunityName ( m_errorObject , classQualifierObject , agentWriteCommunityName ) ;
		if ( status ) status = GetAgentRetryCount ( m_errorObject , classQualifierObject , agentRetryCount ) ;
		if ( status ) status = GetAgentRetryTimeout ( m_errorObject , classQualifierObject , agentRetryTimeout ) ;
		if ( status ) status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , agentMaxVarBindsPerPdu ) ;
		if ( status ) status = GetAgentFlowControlWindowSize ( m_errorObject , classQualifierObject , agentFlowControlWindowSize ) ;

		if ( status )
		{
			char *dbcsAgentAddress = UnicodeToDbcsString ( agentAddress ) ;
			if ( dbcsAgentAddress )
			{
				char *dbcsagentWriteCommunityName = UnicodeToDbcsString ( agentWriteCommunityName ) ;
				if ( dbcsagentWriteCommunityName )
				{
					if ( _wcsicmp ( agentTransport , WBEM_AGENTIPTRANSPORT ) == 0 )
					{
						char *t_Address ;
						if ( provider->GetIpAddressString () && provider->GetIpAddressValue () && _stricmp ( provider->GetIpAddressString () , dbcsAgentAddress ) == 0 )
						{
							t_Address = provider->GetIpAddressValue () ;
						}
						else
						{
							t_Address = dbcsAgentAddress ;
						}

						if ( m_agentVersion == 1 )
						{
							session = new SnmpV1OverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}

						}
						else if ( m_agentVersion == 2 )
						{
							session = new SnmpV2COverIp (

								t_Address ,
								SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}

						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
					else if ( _wcsicmp ( agentTransport , WBEM_AGENTIPXTRANSPORT ) == 0 )
					{
						if ( m_agentVersion == 1 )
						{
							session = new SnmpV1OverIpx (

								dbcsAgentAddress ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else if ( m_agentVersion == 2 )
						{
							session = new SnmpV2COverIpx (

								dbcsAgentAddress  ,
								dbcsagentWriteCommunityName ,
								agentRetryCount , 
								agentRetryTimeout ,
								agentFlowControlWindowSize ,
								agentMaxVarBindsPerPdu 
							);

							if ( ! (*session)() )
							{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SNMPCL Session could not be created"
	) ;
)

								delete session ;
								session = NULL ;

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR  ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Failed to get transport resources" ) ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentSnmpVersion" ) ;

						}
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentTransport" ) ;
					}

					delete [] dbcsagentWriteCommunityName ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Illegal value for qualifier: agentWriteCommunityName" ) ;
				}

				delete [] dbcsAgentAddress ;

				if ( status )
				{
					m_QueryOperation = new SetQueryOperation(*session,this);
					m_QueryOperation->Send () ;
				}
			}
			else
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Illegal value for qualifier: AgentAddress" ) ;
			}
		}
		else
		{
DebugMacro1( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L" TransportInformation settings invalid"
	) ;
)
		}

		delete [] agentTransport ;
		delete [] agentAddress ;
		delete [] agentWriteCommunityName ;

		classQualifierObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get class qualifier set" ) ;
	}

	return status ;
}

BOOL SnmpUpdateEventObject :: Update ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateEventObject :: Update ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	IWbemClassObject *t_ClassObject = NULL ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	t_WBEM_result = classObject->Get ( WBEM_PROPERTY_CLASS , 0 , &variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_WBEM_result ) )
	{
		IWbemServices *t_Serv = provider->GetServer();
		HRESULT result = WBEM_E_FAILED;

		if (t_Serv)
		{	
			result = t_Serv->GetObject (

				variant.bstrVal ,
				0 ,
				m_Context ,
				& t_ClassObject ,
				NULL
			) ;

			t_Serv->Release();
		}

		VariantClear ( & variant ) ;


		if ( SUCCEEDED ( result ) )
		{
			if ( status = GetNamespaceObject ( a_errorObject ) )
			{
				status = snmpObject.Set ( a_errorObject , t_ClassObject , FALSE ) ;
				if ( status )
				{
					status = snmpObject.Merge ( a_errorObject , GetClassObject () ) ;
					if ( status )
					{
						status = snmpObject.Check ( a_errorObject ) ;
						if ( status )
						{
							status = HandleSnmpVersion ( a_errorObject ) ;
						}
						else
						{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)

						}
					}
					else
					{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Merge : Class definition did not conform to mapping"
) ;
)
					}
				}
				else
				{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
				}
			}

			t_ClassObject->Release () ;
		}
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateEventObject :: Update ( WbemSnmpErrorObject &a_errorObject ) with Result (%lx)" ,
		a_errorObject.GetWbemStatus () 
	) ;
)
	return status ;
}

SnmpUpdateAsyncEventObject :: SnmpUpdateAsyncEventObject (

	CImpPropProv *providerArg , 
	IWbemClassObject *classObject ,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context ,
	long lflags 

) : SnmpUpdateEventObject ( providerArg , classObject , a_Context , lflags ) , notificationHandler ( notify ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SnmpUpdateAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpUpdateAsyncEventObject :: ~SnmpUpdateAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: ~SnmpUpdateAsyncEventObject ()" 
	) ;
)

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
	// Get Status object

		IWbemClassObject *notifyStatus ;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status )
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			notifyStatus->Release () ;
		}
		else
		{
			HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
		}
	}
	else
	{
		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: ~SnmpUpdateAsyncEventObject ()" 
	) ;
)

}

void SnmpUpdateAsyncEventObject :: SetComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SetComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Update Succeeded" 
	) ;
)

		WbemSnmpErrorObject errorObject ;
		IWbemClassObject *classObject = GetClassObject () ;
		BOOL status = snmpObject.Get ( errorObject , classObject ) ;
		if ( status )
		{
			if ( notificationHandler )
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)

				notificationHandler->Indicate ( 1 , & classObject ) ;
			}
		}
		else
		{
		}
	}
	else
	{
	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	SetOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: SetComplete ()" 
	) ;
)

}

void SnmpUpdateAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			BOOL status = Update ( m_errorObject ) ;
			if ( status )
			{
			}
			else
			{
				ReceiveComplete () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: Process ()" 
	) ;
)

}

BOOL SnmpUpdateEventObject :: HandleSnmpVersion ( WbemSnmpErrorObject &a_ErrorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateEventObject :: HandleSnmpVersion ( WbemSnmpErrorObject &a_ErrorObject )" 
	) ;
)

	BOOL t_Status = FALSE ;

	if ( snmpObject.RowStatusSpecified () )
	{
		if ( snmpObject.GetSnmpVersion () == 1 )
		{
			if ( WBEM_FLAG_CREATE_OR_UPDATE == ( m_lflags & WBEM_FLAG_CREATE_OR_UPDATE ) )
			{
				t_Status = Create_Or_Update () ;
			}
			else if ( WBEM_FLAG_CREATE_ONLY == ( m_lflags & WBEM_FLAG_CREATE_ONLY ) )
			{
				t_Status = Create_Only () ;
			}
			else if ( WBEM_FLAG_UPDATE_ONLY == ( m_lflags & WBEM_FLAG_UPDATE_ONLY ) )
			{
				t_Status = Update_Only () ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}
		else
		{
			if ( WBEM_FLAG_CREATE_OR_UPDATE == ( m_lflags & WBEM_FLAG_CREATE_OR_UPDATE ) )
			{
				t_Status = Create_Or_Update () ;
			}
			else if ( WBEM_FLAG_CREATE_ONLY == ( m_lflags & WBEM_FLAG_CREATE_ONLY ) )
			{
				t_Status = Create_Only () ;
			}
			else if ( WBEM_FLAG_UPDATE_ONLY == ( m_lflags & WBEM_FLAG_UPDATE_ONLY ) )
			{
				t_Status = Update_Only () ;
			}
			else
			{
				t_Status = FALSE ;
			}
		}	
	}
	else
	{
		if ( WBEM_FLAG_CREATE_OR_UPDATE == ( m_lflags & WBEM_FLAG_CREATE_OR_UPDATE ) )
		{
			state = 0 ;
			t_Status = SendSnmp ( a_ErrorObject ) ;
		}
		else if ( WBEM_FLAG_CREATE_ONLY == ( m_lflags & WBEM_FLAG_CREATE_ONLY ) )
		{
			state = 1 ;
			t_Status = CheckForRowExistence ( a_ErrorObject ) ;
		}
		else if ( WBEM_FLAG_UPDATE_ONLY == ( m_lflags & WBEM_FLAG_UPDATE_ONLY ) )
		{
			state = 2 ;
			t_Status = CheckForRowExistence ( a_ErrorObject ) ;
		}
		else
		{
			t_Status = FALSE ;
		}
	}

	return t_Status ;
}

void SnmpUpdateAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	BOOL t_Status = TRUE ;

	switch ( state )
	{
		case 0:
		{
/*
 *	V1 SMI - CREATE_OR_UPDATE
 */

			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;
			}

			SetComplete () ;
			return ;
		}
		break ;

		case 1:
		{
/*
*	V1 SMI - CREATE_ONLY
*/

			if ( ! SUCCEEDED ( m_errorObject.GetStatus () ) )
			{
				SetComplete () ;
				return ;
			}

			state = 3 ;
			if ( m_QueryOperation->GetRowReceived () == 0 )
			{
				t_Status = SendSnmp ( m_errorObject ) ;
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_ALREADY_EXISTS  ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_ALREADY_EXISTS ) ;
				m_errorObject.SetMessage ( L"Instance already exists" ) ;

				t_Status = FALSE ;
			}

			if ( m_QueryOperation )
				m_QueryOperation->DestroyOperation () ;

		}
		break ;

		case 2:
		{
/*
*	V1 SMI - UPDATE_ONLY
*/
			if ( ! SUCCEEDED ( m_errorObject.GetStatus () ) )
			{
				SetComplete () ;
				return ;
			}

			state = 3 ;
			if ( m_QueryOperation->GetRowReceived () )
			{
				t_Status = SendSnmp ( m_errorObject ) ;
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_NOT_FOUND ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
				m_errorObject.SetMessage ( L"Instance does not exist" ) ;

				t_Status = FALSE ;
			}

			if ( m_QueryOperation )
				m_QueryOperation->DestroyOperation () ;

		}
		break ;

		case 3:
		{
			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;
			}
			
			t_Status = FALSE ;
		}
		break ;

		case 4:
		{
/*
*	V2C SMI ROWSTATUS - CREATE_OR_UPDATE
*/

			m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE  ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"UNKNOWN STATE TRANSITION" ) ;

			t_Status = FALSE ;

		}
		break ;

		case 10:
		{
/*
 *	V2C SMI ROWSTATUS - CREATE_ONLY
 */

			WbemSnmpProperty *t_Property ;
			snmpObject.ResetProperty () ;
			while ( t_Property = snmpObject.NextProperty () )
			{
				t_Property->SetTag ( FALSE ) ;
			}

			ULONG t_VarBindsPerPdu = 0 ;

			IWbemQualifierSet *classQualifierObject ;
			HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
			if ( SUCCEEDED ( result ) )
			{
				t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
				classQualifierObject->Release () ;
				if ( t_Status ) 
				{
					m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

					ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

	/*
	 * Check to see if we can fit all vbs in to one pdu
	 */
					if ( t_NumberOfWritable < t_VarBindsPerPdu )
					{

	// Does fit
						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							t_NumberOfWritable , 
							SnmpRowStatusType :: SnmpRowStatusEnum :: createAndGo 
						) ;

						state = 11 ;
					}
					else
					{
	// Does not fit, therefore decompose

						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							m_VarBindsLeftBeforeTooBig , 
							SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
						) ;

						state = 12 ;
					}
				}
				else
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Internal Error" ) ;
					t_Status = FALSE ;
				}
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Internal Error" ) ;
				t_Status = FALSE ;
			}
		}
		break ;

		case 11:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */

/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

				m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
				) ;

				state = 12 ;
			}
			else
			{
/*
 *	We've either succeeded or totally failed.
 */
				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
				}
				else
				{
				}
			}
		}
		break ;

		case 12:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

					m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
					) ;

					state = 12 ;
				}
			}
			else
			{
/*
 *	We've either succeeded or totally failed to set the row as createAndWait
 */

				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
/*
 *	Now send a non row status variable binding list
 */
					ULONG t_VarBindsPerPdu = 0 ;

					IWbemQualifierSet *classQualifierObject ;
					HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
					if ( SUCCEEDED ( result ) )
					{
						t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
						classQualifierObject->Release () ;
						if ( t_Status ) 
						{
							m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

							t_Status = Send_Variable_Binding_List ( 

								snmpObject , 
								m_VarBindsLeftBeforeTooBig
							) ;

							state = 13 ;
						}
						else
						{
							m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
							m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							m_errorObject.SetMessage ( L"Internal Error" ) ;
							t_Status = FALSE ;
						}
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
				else
				{
				}
			}
		}
		break ;

		case 13:
		{
/*
 * check to see if we succeeded in sending a non row status variable binding list
 */

			if ( m_SnmpTooBig )
			{
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
					m_VarBindsLeftBeforeTooBig -- ;

					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
					) ;

					state = 13 ;
				}
			}
			else
			{
				if ( snmpObject.NumberOfWritable () == 0 )
				{
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						0 , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: active 
					) ;

					state = 14 ;
				}
				else
				{
					ULONG t_VarBindsPerPdu = 0 ;

					IWbemQualifierSet *classQualifierObject ;
					HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
					if ( SUCCEEDED ( result ) )
					{
						t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
						classQualifierObject->Release () ;
						if ( t_Status ) 
						{
							m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

							t_Status = Send_Variable_Binding_List ( 

								snmpObject , 
								m_VarBindsLeftBeforeTooBig 
							) ;

							state = 13 ;
						}
						else
						{
							m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
							m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							m_errorObject.SetMessage ( L"Internal Error" ) ;
							t_Status = FALSE ;
						}
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case 14:
		{
			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;

				t_Status = FALSE ;
			}
			else
			{
				SetComplete () ;
				return ;
			}
		}
		break ;

		case 20:
		{
/*
 *	V2C SMI ROWSTATUS - UPDATE_ONLY
 */

			WbemSnmpProperty *t_Property ;
			snmpObject.ResetProperty () ;
			while ( t_Property = snmpObject.NextProperty () )
			{
				t_Property->SetTag ( FALSE ) ;
			}

			ULONG t_VarBindsPerPdu = 0 ;

			IWbemQualifierSet *classQualifierObject ;
			HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
			if ( SUCCEEDED ( result ) )
			{
				t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
				classQualifierObject->Release () ;
				if ( t_Status ) 
				{
					m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

					ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

	/*
	 * Check to see if we can fit all vbs in to one pdu
	 */
					if ( t_NumberOfWritable < t_VarBindsPerPdu )
					{

	// Does fit
						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							t_NumberOfWritable , 
							SnmpRowStatusType :: SnmpRowStatusEnum :: active 
						) ;

						state = 21 ;
					}
					else
					{
	// Does not fit, therefore decompose

						t_Status = Send_Variable_Binding_List ( 

							snmpObject , 
							m_VarBindsLeftBeforeTooBig , 
							SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
						) ;

						state = 22 ;
					}
				}
				else
				{
					m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					m_errorObject.SetMessage ( L"Internal Error" ) ;
					t_Status = FALSE ;
				}
			}
			else
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Internal Error" ) ;
				t_Status = FALSE ;
			}
		}
		break ;

		case 21:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */

/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

				m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
				) ;

				state = 22 ;
			}
			else
			{
/*
 *	We've either succeeded or totally failed.
 */
				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
				}
				else
				{
				}
			}
		}
		break ;

		case 22:
		{
/*
 * check to see if we fitted everything into one pdu
 */
			if ( m_SnmpTooBig )
			{
/*
 * PDU TOO BIG
 */
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
/*
 * Decrement the number of variable bindings so that we can avoid an SNMP TOO BIG response
 */

					m_VarBindsLeftBeforeTooBig -- ;

/*
 * Resend
 */
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
					) ;

					state = 22 ;
				}
			}
			else
			{
/*
 *	We've either succeeded or totally failed to set the row as notInService
 */

				if ( t_Status = SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
				{
/*
 *	Now send a non row status variable binding list
 */
					ULONG t_VarBindsPerPdu = 0 ;

					IWbemQualifierSet *classQualifierObject ;
					HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
					if ( SUCCEEDED ( result ) )
					{
						t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
						classQualifierObject->Release () ;
						if ( t_Status ) 
						{
							m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

							t_Status = Send_Variable_Binding_List ( 

								snmpObject , 
								m_VarBindsLeftBeforeTooBig
							) ;

							state = 23 ;
						}
						else
						{
							m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
							m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							m_errorObject.SetMessage ( L"Internal Error" ) ;
							t_Status = FALSE ;
						}
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
				else
				{
				}
			}
		}
		break ;

		case 23:
		{
/*
 * check to see if we succeeded in sending a non row status variable binding list
 */

			if ( m_SnmpTooBig )
			{
				if ( m_VarBindsLeftBeforeTooBig == 0 )
				{
/*
 *	Set Error object for TooBig because we only sent one vb
 */
					
					t_Status = FALSE ;
				}
				else
				{
					m_VarBindsLeftBeforeTooBig -- ;

					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						m_VarBindsLeftBeforeTooBig , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: notInService 
					) ;

					state = 23 ;
				}
			}
			else
			{
				ULONG t_VarBindsPerPdu = 0 ;

				if ( snmpObject.NumberOfWritable () == 0 )
				{
					t_Status = Send_Variable_Binding_List ( 

						snmpObject , 
						0 , 
						SnmpRowStatusType :: SnmpRowStatusEnum :: active 
					) ;

					state = 24 ;
				}
				else
				{
					ULONG t_VarBindsPerPdu = 0 ;

					IWbemQualifierSet *classQualifierObject ;
					HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
					if ( SUCCEEDED ( result ) )
					{
						t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
						classQualifierObject->Release () ;
						if ( t_Status ) 
						{
							m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

							t_Status = Send_Variable_Binding_List ( 

								snmpObject , 
								m_VarBindsLeftBeforeTooBig 
							) ;

							state = 23 ;
						}
						else
						{
							m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
							m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							m_errorObject.SetMessage ( L"Internal Error" ) ;
							t_Status = FALSE ;
						}
					}
					else
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"Internal Error" ) ;
						t_Status = FALSE ;
					}
				}
			}
		}
		break ;

		case 24:
		{
			if ( m_SnmpTooBig )
			{
				m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
				m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				m_errorObject.SetMessage ( L"Agent could not process Set Request because SNMP PDU was too big" ) ;

				t_Status = FALSE ;
			}
			else
			{
				SetComplete () ;
				return ;
			}
		}
		break ;

		case 30:
		{
			if ( ! SUCCEEDED ( m_errorObject.GetStatus () ) )
			{
				SetComplete () ;
				return ;
			}

			if ( m_QueryOperation->GetRowReceived () == 0 )
			{
				t_Status = Update_Only () ;
			}
			else
			{
				t_Status = Create_Only () ;
			}
		}
		break ;

		default:
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE  ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"UNKNOWN STATE TRANSITION" ) ;

			t_Status = FALSE ;
		}
		break ;
	}

	if ( t_Status == FALSE ) 
	{
		SetComplete () ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: ReceiveComplete ()" 
	) ;
)
}

void SnmpUpdateAsyncEventObject :: SnmpTooBig () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpUpdateAsyncEventObject :: SnmpTooBig ()" 
	) ;
)

	m_SnmpTooBig = TRUE ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpUpdateAsyncEventObject :: SnmpTooBig ()" 
	) ;
)
}

BOOL SnmpUpdateEventObject :: Create_Only ()
{
	BOOL t_Status = TRUE ;

/*
 *	V2C SMI ROWSTATUS - CREATE_ONLY
 */

	WbemSnmpProperty *t_Property ;
	snmpObject.ResetProperty () ;
	while ( t_Property = snmpObject.NextProperty () )
	{
		t_Property->SetTag ( FALSE ) ;
	}

	ULONG t_VarBindsPerPdu = 0 ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
		classQualifierObject->Release () ;
		if ( t_Status ) 
		{
			m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

			ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

/*
 * Check to see if we can fit all vbs in to one pdu
 */
			if ( t_NumberOfWritable < t_VarBindsPerPdu )
			{

// Does fit
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					t_NumberOfWritable , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: createAndGo 
				) ;

				state = 7 ;
			}
			else
			{
// Does not fit, therefore decompose

				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: createAndWait 
				) ;

				state = 8 ;
			}
		}
		else
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Internal Error" ) ;
			t_Status = FALSE ;
		}
	}
	else
	{
		m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		m_errorObject.SetMessage ( L"Internal Error" ) ;
		t_Status = FALSE ;
	}


	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Update_Only ()
{
	BOOL t_Status = TRUE ;

/*
 *	V2C SMI ROWSTATUS - UPDATE_ONLY
 */

	WbemSnmpProperty *t_Property ;
	snmpObject.ResetProperty () ;
	while ( t_Property = snmpObject.NextProperty () )
	{
		t_Property->SetTag ( FALSE ) ;
	}

	ULONG t_VarBindsPerPdu = 0 ;

	IWbemQualifierSet *classQualifierObject ;
	HRESULT result = m_namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
	if ( SUCCEEDED ( result ) )
	{
		t_Status = GetAgentMaxVarBindsPerPdu ( m_errorObject , classQualifierObject , t_VarBindsPerPdu ) ;
		classQualifierObject->Release () ;
		if ( t_Status ) 
		{
			m_VarBindsLeftBeforeTooBig = t_VarBindsPerPdu ;

			ULONG t_NumberOfWritable = snmpObject.NumberOfWritable () ;

	/*
	 * Check to see if we can fit all vbs in to one pdu
	 */
			if ( t_NumberOfWritable < t_VarBindsPerPdu )
			{

	// Does fit
				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					t_NumberOfWritable , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: active 
				) ;

				state = 7 ;
			}
			else
			{
	// Does not fit, therefore decompose

				t_Status = Send_Variable_Binding_List ( 

					snmpObject , 
					m_VarBindsLeftBeforeTooBig , 
					SnmpRowStatusType :: SnmpRowStatusEnum :: notInService
				) ;

				state = 8 ;
			}
		}
		else
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"Internal Error" ) ;
			t_Status = FALSE ;
		}
	}
	else
	{
		m_errorObject.SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
		m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
		m_errorObject.SetMessage ( L"Internal Error" ) ;
		t_Status = FALSE ;
	}

	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Create_Or_Update ()
{
	BOOL t_Status = FALSE ;

	state = 30 ;
	t_Status = CheckForRowExistence ( m_errorObject ) ;

	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Send_Variable_Binding_List ( 

	SnmpSetClassObject &a_SnmpSetClassObject , 
	ULONG a_NumberToSend 
)
{
/*
 * Find Property of RowStatus type and make sure we don't send in request
 */

	BOOL t_Status = FALSE ;

	WbemSnmpProperty *t_Property ;

	a_SnmpSetClassObject.ResetProperty () ;
	while ( t_Property = a_SnmpSetClassObject.NextProperty () )
	{
		if ( typeid ( *t_Property->GetValue () ) == typeid ( SnmpRowStatusType ) )
		{
			t_Property->SetTag ( TRUE ) ;
		}
	}

	t_Status = SendSnmp ( m_errorObject , a_NumberToSend ) ;

	return t_Status ;
}

BOOL SnmpUpdateEventObject :: Send_Variable_Binding_List ( 

	SnmpSetClassObject &a_SnmpSetClassObject , 
	ULONG a_NumberToSend ,
	SnmpRowStatusType :: SnmpRowStatusEnum a_SnmpRowStatusEnum
)
{
	BOOL t_Status = FALSE ;

	WbemSnmpProperty *t_Property ;

	a_SnmpSetClassObject.ResetProperty () ;
	while ( t_Property = a_SnmpSetClassObject.NextProperty () )
	{
		if ( typeid ( *t_Property->GetValue () ) == typeid ( SnmpRowStatusType ) )
		{
			t_Property->SetTag ( FALSE ) ;
			SnmpRowStatusType *t_RowStatus = new SnmpRowStatusType ( a_SnmpRowStatusEnum ) ;
			t_Property->SetValue ( t_RowStatus ) ;
		}
	}

	t_Status = SendSnmp ( m_errorObject , a_NumberToSend ) ;

	return t_Status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propquery.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <provtree.h>
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propinst.h"
#include "propquery.h"
#include "snmpnext.h"

QueryPreprocessor :: QuadState SnmpQueryEventObject :: Compare ( 

	LONG a_Operand1 , 
	LONG a_Operand2 , 
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	WmiTreeNode &a_OperatorType 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	switch ( a_Operand1Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( a_Operand2Func ) 
	{
		case WmiValueNode :: WmiValueFunction :: Function_None:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		t_Status = a_Operand1 == a_Operand2 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		t_Status = a_Operand1 != a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		t_Status = a_Operand1 >= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		t_Status = a_Operand1 <= a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		t_Status = a_Operand1 < a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		t_Status = a_Operand1 > a_Operand2
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;

	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: Compare ( 

	wchar_t *a_Operand1 , 
	wchar_t *a_Operand2 , 
	DWORD a_Operand1Func ,
	DWORD a_Operand2Func ,
	WmiTreeNode &a_OperatorType 
)
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: Compare ()"
	) ;
)

	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

	wchar_t *a_Operand1AfterFunc = NULL ;
	wchar_t *a_Operand2AfterFunc = NULL ; 

	if (a_Operand1)
	{
		switch ( a_Operand1Func ) 
		{
			case WmiValueNode :: WmiValueFunction :: Function_None:
			{
			}
			break ;

			case WmiValueNode :: WmiValueFunction :: Function_Upper:
			{
				ULONG length = wcslen ( a_Operand1 ) ;
				wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
				for ( ULONG index = 0 ; index < length ; index ++ )
				{
					a_Operand1AfterFunc [ index ] = towupper ( a_Operand1 [ index ] ) ;
				}
			}
			break ;

			case WmiValueNode :: WmiValueFunction :: Function_Lower:
			{
				ULONG length = wcslen ( a_Operand1 ) ;
				wchar_t *a_Operand1AfterFunc = new wchar_t [ length + 1 ] ;
				for ( ULONG index = 0 ; index < length ; index ++ )
				{
					a_Operand1AfterFunc [ index ] = towlower ( a_Operand1 [ index ] ) ;
				}
			}
			break ;

			default:
			{
			}
			break ;
		}
	}

	if (a_Operand1)
	{
		switch ( a_Operand2Func ) 
		{
			case WmiValueNode :: WmiValueFunction :: Function_None:
			{
			}
			break ;

			case WmiValueNode :: WmiValueFunction :: Function_Upper:
			{
				ULONG length = wcslen ( a_Operand2 ) ;
				wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
				for ( ULONG index = 0 ; index < length ; index ++ )
				{
					a_Operand2AfterFunc [ index ] = towupper ( a_Operand2 [ index ] ) ;
				}
			}
			break ;

			case WmiValueNode :: WmiValueFunction :: Function_Lower:
			{
				ULONG length = wcslen ( a_Operand2 ) ;
				wchar_t *a_Operand2AfterFunc = new wchar_t [ length + 1 ] ;
				for ( ULONG index = 0 ; index < length ; index ++ )
				{
					a_Operand2AfterFunc [ index ] = towlower ( a_Operand2 [ index ] ) ;
				}
			}
			break ;

			default:
			{
			}
			break ;
		}
	}

	const wchar_t *t_Arg1 = a_Operand1AfterFunc ? a_Operand1AfterFunc : a_Operand1 ;
	const wchar_t *t_Arg2 = a_Operand2AfterFunc ? a_Operand2AfterFunc : a_Operand2 ;

	if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) == 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) != 0 
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) || ( t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) >= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_False ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) <= 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( t_Arg1 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				if ( t_Arg2 )
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					t_Status = QueryPreprocessor :: QuadState :: State_True ;
				}
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLessNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) < 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorGreaterNode ) )
	{
		if ( ( t_Arg1 ) && ( t_Arg2 ) )
		{
			t_Status = wcscmp ( t_Arg1 , t_Arg2 ) > 0
					? QueryPreprocessor :: QuadState :: State_True
					: QueryPreprocessor :: QuadState :: State_False ;
		}
		else
		{
			if ( ( ! t_Arg1 ) && ( ! t_Arg2 ) )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
			else if ( t_Arg1 )
			{
				t_Status = QueryPreprocessor :: QuadState :: State_True ;
			}
			else
			{
				t_Status = QueryPreprocessor :: QuadState :: State_False ;
			}
		}
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorLikeNode ) )
	{
	}
	else if ( typeid ( a_OperatorType ) == typeid ( WmiOperatorNotLikeNode ) )
	{
	}

	delete [] a_Operand1AfterFunc ;
	delete [] a_Operand2AfterFunc ;

	return t_Status ;
}

WmiTreeNode *SnmpQueryEventObject :: AllocTypeNode ( 

	void *a_Context ,
	BSTR a_PropertyName , 
	VARIANT &a_Variant , 
	WmiValueNode :: WmiValueFunction a_PropertyFunction ,
	WmiValueNode :: WmiValueFunction a_ConstantFunction ,
	WmiTreeNode *a_Parent 
)
{
	WmiTreeNode *t_Node = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	if ( *a_PropertyName == L'_' )
	{
// System property

		if (( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 ))
		{
			if (a_Variant.vt == VT_BSTR)
			{
				t_Node = new WmiStringNode ( 

					a_PropertyName , 
					a_Variant.bstrVal , 
					a_PropertyFunction ,
					a_ConstantFunction ,
					0xFFFFFFFF ,
					a_Parent 
				) ;
			}
			else if (V_VT(&a_Variant) == VT_NULL)
			{
				t_Node = new WmiNullNode (

					a_PropertyName , 
					0xFFFFFFFF ,
					a_Parent 
				);
			}
		}
		else if (( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 ) ||
			( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 ))
		{
			if (a_Variant.vt == VT_I4)
			{
				t_Node = new WmiSignedIntegerNode ( 

					a_PropertyName , 
					a_Variant.lVal , 
					0xFFFFFFFF ,
					a_Parent 
				) ;
			}
			else if (V_VT(&a_Variant) == VT_NULL)
			{
				t_Node = new WmiNullNode (

					a_PropertyName , 
					0xFFFFFFFF ,
					a_Parent 
				);
			}
		}
		else if ( _wcsicmp ( a_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
		{
		}
	}
	else
	{
		WbemSnmpProperty *t_Property ;
		if ( t_Property = snmpObject.FindProperty ( a_PropertyName ) )
		{
			t_VarType = t_Property->GetValueVariantEncodedType () ;
		}

		switch ( t_VarType )
		{
			case VT_I4:
			{
				if (a_Variant.vt == VT_I4)
				{
					t_Node = new WmiSignedIntegerNode ( 

						a_PropertyName , 
						a_Variant.lVal , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					) ;
				}
				else if (V_VT(&a_Variant) == VT_NULL)
				{
					t_Node = new WmiNullNode (

						a_PropertyName , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					);
				}
			}
			break ;

			case VT_UI4:
			{
				if ((a_Variant.vt == VT_I4) || (a_Variant.vt == VT_UI4))
				{
					t_Node = new WmiUnsignedIntegerNode ( 

						a_PropertyName , 
						a_Variant.lVal , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					) ;
				}
				else if (V_VT(&a_Variant) == VT_NULL)
				{
					t_Node = new WmiNullNode (

						a_PropertyName , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					);
				}
			}
			break ;

			case VT_BSTR:
			{
				if (a_Variant.vt == VT_BSTR)
				{
					t_Node = new WmiStringNode ( 

						a_PropertyName , 
						a_Variant.bstrVal , 
						a_PropertyFunction ,
						a_ConstantFunction ,
						t_Property->GetKeyOrder () ,
						a_Parent 
					) ;
				}
				else if (V_VT(&a_Variant) == VT_NULL)
				{
					t_Node = new WmiNullNode (

						a_PropertyName , 
						t_Property->GetKeyOrder () ,
						a_Parent 
					);
				}
			}
			break ;

			default:
			{
			}
			break ;
		}
	}

	return t_Node ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: CompareString ( 

	BSTR a_PropertyName , 
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;
	
	if ( typeid ( *a_Operand ) != typeid ( WmiStringNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_True ;
	}

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	WmiStringNode *t_StringNode = ( WmiStringNode * ) a_Operand ;

	HRESULT t_Result = GetInstanceObject ()->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_StringNode->GetValue () ,
			t_Variant.bstrVal ,
			t_StringNode->GetPropertyFunction () ,
			t_StringNode->GetConstantFunction () ,
			*a_Operator 
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: CompareInteger ( 

	BSTR a_PropertyName , 
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
	QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;
	
	if ( typeid ( *a_Operand ) != typeid ( WmiSignedIntegerNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_True ;
	}

	WmiSignedIntegerNode *t_IntegerNode = ( WmiSignedIntegerNode * ) a_Operand ; 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	HRESULT t_Result = GetInstanceObject ()->Get ( a_PropertyName , 0 , &t_Variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Status = Compare ( 

			t_IntegerNode->GetValue () ,
			t_Variant.lVal ,
			t_IntegerNode->GetPropertyFunction () ,
			t_IntegerNode->GetConstantFunction () ,
			*a_Operator 
		) ;
	}

	VariantClear ( & t_Variant ) ;

	return t_Status ;
}

QueryPreprocessor :: QuadState SnmpQueryEventObject :: InvariantEvaluate ( 

	void *a_Context ,
	WmiTreeNode *a_Operator ,
	WmiTreeNode *a_Operand 
)
{
	WmiValueNode *t_Node = ( WmiValueNode * ) a_Operand ;
	BSTR t_PropertyName = t_Node->GetPropertyName () ;
	
	if ( t_PropertyName != NULL )
	{
		if ( *t_PropertyName == L'_' )
		{
			// System property, must check values
			QueryPreprocessor :: QuadState t_Status = QueryPreprocessor :: QuadState :: State_True ;

			if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_CLASS ) == 0 )
			{
				t_Status = CompareString ( 

					SYSTEM_PROPERTY_CLASS ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SUPERCLASS ) == 0 )
			{
				t_Status = CompareString ( 

					SYSTEM_PROPERTY_SUPERCLASS ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_GENUS ) == 0 )
			{
				t_Status = CompareInteger ( 

					SYSTEM_PROPERTY_GENUS ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_SERVER ) == 0 )
			{
				t_Status = CompareString ( 

					SYSTEM_PROPERTY_SERVER ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_NAMESPACE ) == 0 )
			{
				t_Status = CompareString ( 

					SYSTEM_PROPERTY_NAMESPACE ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PROPERTY_COUNT ) == 0 )
			{
				t_Status = CompareInteger ( 

					SYSTEM_PROPERTY_PROPERTY_COUNT ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DYNASTY ) == 0 )
			{
				t_Status = CompareString ( 

					SYSTEM_PROPERTY_DYNASTY ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_RELPATH ) == 0 )
			{
				t_Status = CompareString ( 

					SYSTEM_PROPERTY_RELPATH ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_PATH ) == 0 )
			{
				t_Status = CompareString ( 

					SYSTEM_PROPERTY_PATH ,
					a_Operator ,
					a_Operand
				) ;
			}
			else if ( _wcsicmp ( t_PropertyName , SYSTEM_PROPERTY_DERIVATION ) == 0 )
			{
			}

			return t_Status ;
		}
		else
		{
			WbemSnmpProperty *t_Property ;
			if ( t_Property = snmpObject.FindKeyProperty ( t_PropertyName ) )
			{
				if ( typeid ( *a_Operand ) == typeid ( WmiNullNode ) )
				{
					return QueryPreprocessor :: QuadState :: State_True ;
				}
				else
				{
					return QueryPreprocessor :: QuadState :: State_Undefined ;
				}
			}
			else
			{
				return QueryPreprocessor :: QuadState :: State_True ;
			}
		}
	}
	else
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}

	if ( typeid ( *a_Operand ) == typeid ( WmiNullNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_True ;
	}

#if 0
	else if ( typeid ( *a_Operator ) == typeid ( WmiStringNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiUnsignedIntegerNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiSignedIntegerNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}

	if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotEqualNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrGreaterNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorEqualOrLessNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLessNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorGreaterNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorLikeNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
	else if ( typeid ( *a_Operator ) == typeid ( WmiOperatorNotLikeNode ) )
	{
		return QueryPreprocessor :: QuadState :: State_Undefined ;
	}
#endif

	return QueryPreprocessor :: QuadState :: State_Undefined ;
}

WmiRangeNode *SnmpQueryEventObject :: AllocInfiniteRangeNode (

	void *a_Context ,
	BSTR a_PropertyName 
)
{
	WmiRangeNode *t_RangeNode = NULL ;

	VARTYPE t_VarType = VT_NULL ;

	WbemSnmpProperty *t_Property ;
	if ( t_Property = snmpObject.FindKeyProperty ( a_PropertyName ) )
	{
		t_VarType = t_Property->GetValueVariantEncodedType () ;
	}

	switch ( t_VarType )
	{
		case VT_I4:
		{
			t_RangeNode = new WmiSignedIntegerRangeNode ( 

				a_PropertyName , 
				0xFFFFFFFF , 
				TRUE ,
				TRUE ,
				FALSE ,
				FALSE ,
				0 ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		break ;

		case VT_UI4:
		{
			t_RangeNode = new WmiUnsignedIntegerRangeNode ( 

				a_PropertyName , 
				0xFFFFFFFF , 
				TRUE ,
				TRUE ,
				FALSE ,
				FALSE ,
				0 ,
				0 ,
				NULL , 
				NULL 
			) ;
		}
		break ;

		case VT_BSTR:
		{
			t_RangeNode = new WmiStringRangeNode ( 

				a_PropertyName , 
				0x0 , 
				TRUE ,
				TRUE ,
				FALSE ,
				FALSE ,
				NULL ,
				NULL ,
				NULL , 
				NULL 
			) ;
		}
		break ;

		default:
		{
		}
		break ;
	}

	return t_RangeNode ;
}

void SnmpQueryEventObject :: GetPropertiesToPartition ( ULONG &a_Count , BSTR *&a_Container )
{
	a_Count = snmpObject.GetKeyPropertyCount () ;
	a_Container = new BSTR [ a_Count ] ;

	ULONG t_PropertyIndex = 0 ;

	WbemSnmpProperty *t_Property = NULL ;
	snmpObject.ResetKeyProperty () ;
	while ( t_Property = snmpObject.NextKeyProperty () )
	{
		a_Container [ t_PropertyIndex ] = SysAllocString ( t_Property->GetName () ) ;
		t_PropertyIndex ++ ;
	}
}

SnmpQueryEventObject :: SnmpQueryEventObject ( 

	CImpPropProv *providerArg , 
	BSTR QueryFormatArg , 
	BSTR QueryArg , 
	IWbemContext *a_Context 

) : SnmpInstanceResponseEventObject ( providerArg , a_Context ) ,
	Query ( NULL ) ,
	QueryFormat ( NULL ) ,
	parser ( NULL ) ,
	source ( NULL ) ,
	requestObject ( NULL ) ,
	rpnExpression ( NULL )
{
	Query = UnicodeStringDuplicate ( QueryArg ) ;
	QueryFormat = UnicodeStringDuplicate ( QueryFormatArg ) ;
	source.SetString(Query);
	parser.SetSource(&source);
}

SnmpQueryEventObject :: ~SnmpQueryEventObject ()
{
	delete [] Query ;
	delete [] QueryFormat ;
	delete rpnExpression ;
	delete requestObject ;
}

BOOL SnmpQueryEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: Instantiate ( WbemSnmpErrorObject &a_errorObject )" 
	) ;
)

	BOOL status = TRUE ;

	if ( _wcsicmp ( QueryFormat , WBEM_QUERY_LANGUAGE_WQL ) == 0 )
	{
		status = parser.Parse ( & rpnExpression ) ;
		if ( status == FALSE )
		{
			IWbemServices *t_Serv = provider->GetServer();

			HRESULT result = WBEM_E_FAILED;
			
			if (t_Serv)
			{
				result = t_Serv->GetObject (

					rpnExpression->bsClassName,
					0 ,
					m_Context ,
					& classObject ,
					NULL 
				) ;

				t_Serv->Release();
			}

			if ( SUCCEEDED ( result ) )
			{
				result = classObject->SpawnInstance ( 0 , & instanceObject ) ;
				if ( SUCCEEDED ( result ) )
				{
					if ( status = GetNamespaceObject ( a_errorObject ) )
					{
						if ( status = snmpObject.Set ( a_errorObject , classObject , FALSE ) )
						{
							if ( status = snmpObject.Check ( a_errorObject ) )
							{
								if ( status = PreEvaluate ( a_errorObject ) )
								{
									WmiTreeNode *t_Root = NULL ;

									QueryPreprocessor :: QuadState t_State = PreProcess (

										m_Context ,
										rpnExpression ,
										t_Root
									) ;

									switch ( t_State )
									{
										case QueryPreprocessor :: QuadState :: State_True:
										{
											ULONG t_PropertyContainerCount = 0 ;
											BSTR *t_PropertyContainer = NULL ;
											GetPropertiesToPartition ( t_PropertyContainerCount , t_PropertyContainer ) ;

											try
											{
												t_State = PreProcess (	

													m_Context ,
													rpnExpression ,
													t_Root ,
													t_PropertyContainerCount , 
													t_PropertyContainer ,
													m_PartitionSet
												) ;
											}
											catch ( ... )
											{
												// delete properties container
												if ( t_PropertyContainerCount )
												{
													for ( ULONG t_Count = 0; t_Count < t_PropertyContainerCount; t_Count++ )
													{
														if ( t_PropertyContainer [ t_Count ] )
														{
															::SysFreeString ( t_PropertyContainer [ t_Count] );
															t_PropertyContainer [ t_Count ] = NULL;
														}
													}

													delete [] t_PropertyContainer;
													t_PropertyContainer = NULL;
												}

												if ( m_PartitionSet )
												{
													delete m_PartitionSet;
													m_PartitionSet = NULL;
												}

												if ( t_Root )
												{
													delete t_Root;
													t_Root = NULL;
												}

												throw;
											}

											// delete properties container
											if ( t_PropertyContainerCount )
											{
												for ( ULONG t_Count = 0; t_Count < t_PropertyContainerCount; t_Count++ )
												{
													if ( t_PropertyContainer [ t_Count ] )
													{
														::SysFreeString ( t_PropertyContainer [ t_Count] );
														t_PropertyContainer [ t_Count ] = NULL;
													}
												}

												delete [] t_PropertyContainer;
												t_PropertyContainer = NULL;
											}

											switch ( t_State )
											{
												case QueryPreprocessor :: QuadState :: State_True:
												{
													delete m_PartitionSet ;
													m_PartitionSet = NULL ;
													status = SendSnmp ( a_errorObject ) ;
												}
												break ;

												case QueryPreprocessor :: QuadState :: State_False:
												{
													status = FALSE ;
													delete m_PartitionSet ;
													m_PartitionSet = NULL ;

													a_errorObject.SetStatus ( WBEM_SNMP_NO_ERROR ) ;
													a_errorObject.SetWbemStatus ( WBEM_S_NO_ERROR ) ;
													a_errorObject.SetMessage ( L"" ) ;
												}
												break ;

												case QueryPreprocessor :: QuadState :: State_Undefined:
												{
													status = SendSnmp ( a_errorObject ) ;
												}
												break ;

												default:
												{
													status = FALSE ;
													a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
													a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
													a_errorObject.SetMessage ( L"WQL query was invalid" ) ;
												}
												break ;
											}

											delete t_Root ;
										}
										break ;
									
										default:
										{
											status = FALSE ;
											a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
											a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
											a_errorObject.SetMessage ( L"WQL query was invalid" ) ;
										}
										break ;
									}
								}
							}
							else
							{
DebugMacro3( 


SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Check : Class definition did not conform to mapping"
) ;
)

							}
						}
						else
						{
DebugMacro3( 

SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

	__FILE__,__LINE__,
	L"Failed During Set : Class definition did not conform to mapping"
) ;
)
						}
					}
				}
			}
			else
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Class definition unknown"
	) ;
)
			}
		}
		else
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Illegal SQL 1 Query"
	) ;
)

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_errorObject.SetMessage ( L"WQL query was invalid" ) ;
		}
	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Query format not known"
	) ;
)

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY_TYPE ) ;
		a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY_TYPE ) ;
		a_errorObject.SetMessage ( L"Query Language not supported" ) ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: IsSystemProperty (const wchar_t *propertyName )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: SnmpQueryEventObject :: IsSystemProperty (const wchar_t *propertyName )"
	) ;
)

	//Only SYSTEM properties may start with an '_' character.

	return ( *propertyName == SYTEM_PROPERTY_START_CHARACTER ) ;
}

BOOL SnmpQueryEventObject :: PreEvaluate ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: PreEvaluate ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	if ( rpnExpression->nNumberOfProperties == 0 )
	{
// Get All Properties

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Get All Properties"
	) ;
)

		requestObject = new SnmpInstanceClassObject ( snmpObject ) ;
	}
	else if ( snmpObject.IsVirtual () )
	{
// Get All Properties since some keys are virtuals

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Get All Properties because some keys are virtual"
	) ;
)

		requestObject = new SnmpInstanceClassObject ( snmpObject ) ;
	}
	else
	{
// Get List of Properties for return and list of properties for filter evaluation

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Get Subset of Properties"
	) ;
)

		requestObject = new SnmpInstanceClassObject ( this );

		status = FilterSelectProperties ( a_errorObject ) ;
	}

	if ( status )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Check Where Clause is legal"
	) ;
)

		status = PreEvaluateWhereClause ( a_errorObject ) ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: FilterSelectProperties ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: FilterSelectProperties ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;
	
	LONG varType = 0 ;
	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpQualifier *qualifier = NULL ;

	snmpObject.ResetQualifier () ;
	while ( status && ( qualifier = snmpObject.NextQualifier () ) )
	{
		WbemSnmpQualifier *copy = new WbemSnmpQualifier ( *qualifier ) ;
		status = requestObject->AddQualifier ( copy ) ;

		if (!status)
		{
			delete copy;
		}
	}

	int index = 0 ;
	BOOL has_path_property = FALSE ;

	while ( status && ( index <  rpnExpression->nNumberOfProperties ) )
	{
		wchar_t *propertyName = rpnExpression->pbsRequestedPropertyNames [ index ] ;

		WbemSnmpProperty *property ;
		if ( property = snmpObject.FindProperty ( propertyName ) )	
		{
			status = requestObject->AddProperty ( new WbemSnmpProperty ( *property ) ) ;

			if (!status)
			{
				delete property;
			}
		}
		else if ( IsSystemProperty ( propertyName ) )
		{
			if ( ( _wcsicmp ( propertyName , SYSTEM_PROPERTY_RELPATH ) == 0 ) ||
				( _wcsicmp ( propertyName , SYSTEM_PROPERTY_PATH ) == 0 ) )
			{
				has_path_property = TRUE;
			}
		}
		else
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Property in SELECT clause is not a valid class property"
	) ;
)

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_errorObject.SetMessage ( L"SELECT properties of WQL query were invalid" ) ;
		}

		index ++ ;
	}

	if ( status && has_path_property )
	{
		//add in all keys not present...
		WbemSnmpProperty *property = NULL;
		while ( property = snmpObject.NextKeyProperty () )
		{
			if ( ! requestObject->FindProperty ( property->GetName () ) ) 
			{
				status = requestObject->AddProperty ( new WbemSnmpProperty ( *property ) ) ;

				if (!status)
				{
					delete property;
				}
			}
		}

	}

	if ( status )
	{
		status = requestObject->Check ( a_errorObject ) ;
	}
	
	return status ;
}

BOOL SnmpQueryEventObject :: CheckWhereCondition ( 

	WbemSnmpErrorObject &a_errorObject , 
	WbemSnmpProperty *property ,
	SQL_LEVEL_1_TOKEN *token
)
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: SnmpQueryEventObject :: CheckWhereCondition ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ,	SQL_LEVEL_1_TOKEN *token)"
	) ;
)

	BOOL status = TRUE ;

	switch ( property->GetValueVariantEncodedType () )
	{
		case VT_UI4:
		case VT_I4:
		{
			switch ( token->vConstValue.vt )
			{
				case VT_NULL:
				case VT_I4:
				{
				}
				break ;

				default:
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
					a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
				}
				break ;
			}
		}
		break ;

		case VT_BSTR:
		{
			switch ( token->vConstValue.vt )
			{
				case VT_NULL:
				case VT_BSTR:
				{
				}
				break ;

				default:
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
					a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
				}
				break ;
			}
		}
		break ;

		case VT_NULL:
		{
			switch ( token->vConstValue.vt )
			{
				case VT_NULL:
				{
				}
				break ;

				default:
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
					a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUERY ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_INVALID_QUERY ) ;
			a_errorObject.SetMessage ( L"WHERE clause of WQL query specified type value inconsistent with property value type" ) ;
		}
		break ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: PreEvaluateWhereClause ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: PreEvaluateWhereClause ( WbemSnmpErrorObject &a_errorObject )"
	) ;
)

	BOOL status = TRUE ;

	int index = 0 ;
	while ( status && ( index <  rpnExpression->nNumTokens ) )
	{
		SQL_LEVEL_1_TOKEN *propertyValue = &rpnExpression->pArrayOfTokens [ index ] ;
		if ( propertyValue->nTokenType == SQL_LEVEL_1_TOKEN :: OP_EXPRESSION )
		{	
			wchar_t *propertyName = propertyValue->pPropertyName ;

			WbemSnmpProperty *property ;
			if ( property = requestObject->FindProperty ( propertyName ) )	
			{
				status = CheckWhereCondition ( a_errorObject , property , propertyValue ) ;
				if ( status )
				{
					requestObject->AddProperty ( new WbemSnmpProperty ( *property ) ) ;
				}
				else
				{
				}
			}
			else if ( ! IsSystemProperty ( propertyName ) ) 
			{
// Property Not Found

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_NOT_SUPPORTED ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_NOT_SUPPORTED ) ;
				a_errorObject.SetMessage ( L"WHERE clause of WQL query specified unknown property name" ) ;
			}
		}

		index ++ ;
	}

	return status ;
}

#ifdef POST_FILTERING_RECEIVED_ROW
BOOL SnmpQueryEventObject :: Compare ( 

	const LONG & op1 , 
	const LONG & op2 , 
	const DWORD & op1Func ,
	const DWORD & op2Func ,
	const int & operatorType 
)
{
	BOOL status = FALSE ;

	switch ( op1Func ) 
	{
		case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( op2Func ) 
	{
		case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
		{
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( operatorType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EQUAL:
		{
			status = op1 == op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_NOT_EQUAL:
		{
			status = op1 != op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_EQUALorGREATERTHAN:
		{
			status = op1 >= op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_EQUALorLESSTHAN:
		{
			status = op1 <= op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_LESSTHAN:
		{
			status = op1 < op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_GREATERTHAN:
		{
			status = op1 > op2 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_LIKE:
		default:
		{
		}
		break ;
	}

	return status ;
}

BOOL SnmpQueryEventObject :: Compare ( 

	const wchar_t * & op1 , 
	const wchar_t * & op2 , 
	const DWORD & op1Func ,
	const DWORD & op2Func ,
	const int & operatorType 
)
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: Compare ()"
	) ;
)

	BOOL status = FALSE ;

	wchar_t *op1AfterFunc = NULL ;
	wchar_t *op2AfterFunc = NULL ; 

	switch ( op1Func ) 
	{
		case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
		{
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
		{
			ULONG length = wcslen ( op1 ) ;
			wchar_t *op1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				op1AfterFunc [ index ] = toupper ( op1 [ index ] ) ;
			}
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
		{
			ULONG length = wcslen ( op1 ) ;
			wchar_t *op1AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				op1AfterFunc [ index ] = tolower ( op1 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( op2Func ) 
	{
		case SQL_LEVEL_1_TOKEN :: IFUNC_NONE:
		{
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: IFUNC_UPPER:
		{
			ULONG length = wcslen ( op2 ) ;
			wchar_t *op2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				op2AfterFunc [ index ] = toupper ( op2 [ index ] ) ;
			}
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: IFUNC_LOWER:
		{
			ULONG length = wcslen ( op2 ) ;
			wchar_t *op2AfterFunc = new wchar_t [ length + 1 ] ;
			for ( ULONG index = 0 ; index < length ; index ++ )
			{
				op2AfterFunc [ index ] = tolower ( op2 [ index ] ) ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	const wchar_t *arg1 = op1AfterFunc ? op1AfterFunc : op1 ;
	const wchar_t *arg2 = op2AfterFunc ? op2AfterFunc : op2 ;

	switch ( operatorType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EQUAL:
		{
			status = wcscmp ( arg1 , arg2 ) == 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_NOT_EQUAL:
		{
			status = wcscmp ( arg1 , arg2 ) != 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_EQUALorGREATERTHAN:
		{
			status = wcscmp ( arg1 , arg2 ) >= 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_EQUALorLESSTHAN:
		{
			status = wcscmp ( arg1 , arg2 ) <= 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_LESSTHAN:
		{
			status = wcscmp ( arg1 , arg2 ) < 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_GREATERTHAN:
		{
			status = wcscmp ( arg1 , arg2 ) > 0 ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: OP_LIKE:
		default:
		{
		}
		break ;
	}

	delete [] op1AfterFunc ;
	delete [] op2AfterFunc ;

	return status ;
}

BOOL SnmpQueryEventObject :: ExpressionCompare ( SnmpInstanceClassObject *snmpObject , SQL_LEVEL_1_TOKEN *propertyValue )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: ExpressionCompare ( SnmpInstanceClassObject *snmpObject , SQL_LEVEL_1_TOKEN *propertyValue )"
	) ;
)

	BOOL status = FALSE ;

	wchar_t *propertyName = propertyValue->pPropertyName ;

	WbemSnmpProperty *property ;
	if ( property = snmpObject->FindProperty ( propertyName ) )
	{
		VARIANT variant ;
		VariantInit ( & variant ) ;

DebugMacro3( 

	wchar_t *t_StringValue = ( property->GetValue () ) ? property->GetValue ()->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Property (%s),(%s)",
			propertyName ,
			t_StringValue
		) ;
	}

	delete [] t_StringValue ;
)


		CIMTYPE varType ;
		if ( property->GetValue ( variant , cimType ) ) 
		{
			switch ( variant.vt )
			{
				case VT_NULL:
				{
					switch ( propertyValue->vConstValue.vt )
					{
						case VT_NULL:
						{
							status = TRUE ;
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
				break;

				case VT_I4:
				{
					switch ( propertyValue->vConstValue.vt )
					{
						case VT_I4:
						{
							status = Compare ( 

								variant.lVal , 
								propertyValue->vConstValue.lVal ,
								propertyValue->dwPropertyFunction ,
								propertyValue->dwConstFunction ,
								propertyValue->nOperator
							) ;
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
				break ;

				case VT_BSTR:
				{
					switch ( propertyValue->vConstValue.vt )
					{
						case VT_BSTR:
						{
							status = Compare ( 

								variant.bstrVal , 
								propertyValue->vConstValue.bstrVal ,
								propertyValue->dwPropertyFunction ,
								propertyValue->dwConstFunction ,
								propertyValue->nOperator
							) ;
						}
						break ;

						default:
						{
						}
						break ;
					}
				}
				break ;

				default:
				{
				}
				break ;
			}

			VariantClear ( &variant ) ;
			
		}
		else
		{
// Problem Here
		}
	}
	else
	{
// Problem Here
	}

	return status ;
}

BOOL SnmpQueryEventObject :: PostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: PostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject )" 
	) ;
)

	BOOL t_Status = TRUE ;
	if ( rpnExpression->nNumTokens )
	{
		int count = rpnExpression->nNumTokens - 1 ;
		t_Status = RecursivePostEvaluateWhereClause ( snmpObject , count ) ;
	}
	else
	{
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"PostEvaluation Status = (%lu)" ,
		( ULONG ) t_Status
	) ;
)

	return t_Status ;
}

BOOL SnmpQueryEventObject :: RecursivePostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject , int &index )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryEventObject :: RecursivePostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject , int &index )"
	) ;
)

	BOOL status = FALSE ;

	SQL_LEVEL_1_TOKEN *propertyValue = & ( rpnExpression->pArrayOfTokens [ index ] ) ;
	index -- ;


	switch ( propertyValue->nTokenType )
	{
		case SQL_LEVEL_1_TOKEN :: OP_EXPRESSION:
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = OP_EXPESSION"
	) ;
)

			status = ExpressionCompare ( snmpObject , propertyValue ) ;
		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_AND:
		{

			status = RecursivePostEvaluateWhereClause ( snmpObject , index ) &&
					 RecursivePostEvaluateWhereClause ( snmpObject , index ) ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_AND"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_OR:
		{

			status = RecursivePostEvaluateWhereClause ( snmpObject , index ) ||
					 RecursivePostEvaluateWhereClause ( snmpObject , index ) ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_OR"
	) ;
)

		}
		break ;

		case SQL_LEVEL_1_TOKEN :: TOKEN_NOT:
		{
			status = ! RecursivePostEvaluateWhereClause ( snmpObject , index ) ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Operation = TOKEN_NOT"
	) ;
)

		}
		break ;
	}

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"RecursivePostEvaluation Status = (%lu)" ,
		( ULONG ) status
	) ;

	return status ;
}
#endif //POST_FILTERING_RECEIVED_ROW

SnmpQueryAsyncEventObject :: SnmpQueryAsyncEventObject (

	CImpPropProv *providerArg , 
	BSTR QueryFormat , 
	BSTR Query,
	IWbemObjectSink *notify ,
	IWbemContext *a_Context 

) : SnmpQueryEventObject ( providerArg , QueryFormat , Query , a_Context ) , notificationHandler ( notify ) , state ( 0 )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: SnmpQueryAsyncEventObject ()" 
	) ;
)

	notify->AddRef () ;
}

SnmpQueryAsyncEventObject :: ~SnmpQueryAsyncEventObject () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ~SnmpQueryAsyncEventObject ()" 
	) ;
)

// Get Status object

	if ( FAILED ( m_errorObject.GetWbemStatus () ) )
	{
		IWbemClassObject *notifyStatus = NULL;
		BOOL status = GetSnmpNotifyStatusObject ( &notifyStatus ) ;
		if ( status && (notifyStatus != NULL))
		{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Status" 
	) ;
)

#ifndef POST_FILTERING_RECEIVED_ROW

			if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
			{
				//let CIMOM do the post filtering!
				WBEMSTATUS t_wbemStatus = WBEM_S_FALSE ;
				VARIANT t_variant ;
				VariantInit( & t_variant ) ;
				t_variant.vt = VT_I4 ;
				t_variant.lVal = WBEM_S_FALSE ;

				HRESULT result = notifyStatus->Put ( WBEM_PROPERTY_STATUSCODE , 0 , & t_variant , 0 ) ;
				VariantClear ( &t_variant ) ;

				if ( SUCCEEDED ( result ) )
				{
					result = notificationHandler->SetStatus ( 0 , t_wbemStatus , NULL , notifyStatus ) ;
				}
				else
				{
					result = notificationHandler->SetStatus ( 0 , WBEM_E_PROVIDER_FAILURE , NULL , NULL ) ;
				}
			}
			else
			{
				HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;
			}
		}

#else

		HRESULT result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , notifyStatus ) ;

#endif //POST_FILTERING_RECEIVED_ROW

		notifyStatus->Release () ;
	}
	else
	{
		HRESULT t_Result = notificationHandler->SetStatus ( 0 , m_errorObject.GetWbemStatus () , NULL , NULL ) ;
	}

	notificationHandler->Release () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpQueryAsyncEventObject :: ~SnmpQueryAsyncEventObject ()" 
	) ;
)

}

void SnmpQueryAsyncEventObject :: ReceiveComplete () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveComplete ()" 
	) ;
)

	if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Query Succeeded" 
	) ;
)

	}
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Query Failed" 
	) ;
)

	}

/*
 *	Remove worker object from worker thread container
 */

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Reaping Task" 
	) ;
)

	AutoRetrieveOperation *t_operation = operation ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Deleting (this)" 
	) ;
)

	Complete () ;

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Destroying SNMPCL operation" 
	) ;
)

	if ( t_operation )
		t_operation->DestroyOperation () ;
}

void SnmpQueryAsyncEventObject :: Process () 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: Process ()" 
	) ;
)

	switch ( state )
	{
		case 0:
		{
			BOOL status = Instantiate ( m_errorObject ) ;
			if ( status )
			{
			}
			else
			{
				ReceiveComplete () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from SnmpQueryAsyncEventObject :: Process ()" 
	) ;
)

}

void SnmpQueryAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject ) 
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveRow ( IWbemClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;
	BOOL status = TRUE ;

	notificationHandler->Indicate ( 1 , & snmpObject ) ;
	if ( ! HasNonNullKeys ( snmpObject ) )
	{
		if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
		{
			m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
		}
	}			
}

void SnmpQueryAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject*snmpObject )
{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"SnmpQueryAsyncEventObject :: ReceiveRow ( SnmpInstanceClassObject *snmpObject )" 
	) ;
)

	HRESULT result = S_OK ;
	BOOL status = TRUE ;

#ifdef POST_FILTERING_RECEIVED_ROW
	if ( status = PostEvaluateWhereClause ( snmpObject ) )
#endif //POST_FILTERING_RECEIVED_ROW
	{
		IWbemClassObject *cloneObject ;
		if ( SUCCEEDED ( result = classObject->SpawnInstance ( 0 , & cloneObject ) ) ) 
		{
			WbemSnmpErrorObject errorObject ;
			if ( status = snmpObject->Get ( errorObject , cloneObject ) )
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Sending Object" 
	) ;
)
				notificationHandler->Indicate ( 1 , & cloneObject ) ;
				if ( ! HasNonNullKeys ( cloneObject ) )
				{
					if ( SUCCEEDED ( m_errorObject.GetWbemStatus () ) )
					{
						m_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
						m_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						m_errorObject.SetMessage ( L"The SNMP Agent queried returned an instance with NULL key(s)" ) ;
					}
				}			
			}	
			else
			{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Failed to Convert WbemSnmpClassObject to IWbemClassObject" 
	) ;
)

			}

			cloneObject->Release () ;
		}
	}
#ifdef POST_FILTERING_RECEIVED_ROW
	else
	{
DebugMacro3( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Object discarded due to query filter " 
	) ;
)

	}
#endif //POST_FILTERING_RECEIVED_ROW

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\propprov.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the CImpPropProv class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <cominit.h>
#include <provtree.h>
#include "classfac.h"
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "propdel.h"
#include "propinst.h"
#include "propquery.h"
#include "guids.h"

extern void ProviderStartup () ;
extern void ProviderClosedown () ;

void SnmpInstanceDefaultThreadObject::Initialise ()
{
	InitializeCom () ;
}


/////////////////////////////////////////////////////////////////////////////
//  Functions constructor, destructor and IUnknown

//***************************************************************************
//
// CImpPropProv::CImpPropProv
// CImpPropProv::~CImpPropProv
//
//***************************************************************************

BOOL CImpPropProv :: s_Initialised = FALSE ;

CImpPropProv::CImpPropProv ()
{
	m_referenceCount = 0 ;
	 
    InterlockedIncrement ( & CPropProvClassFactory :: objectsInProgress ) ;

/*
 * Implementation
 */

	initialised = FALSE ;
	m_InitSink = NULL ;
	parentServer = NULL ;
	server = NULL ;
	thisNamespace = NULL ;
	ipAddressString = NULL ;	
	ipAddressValue = NULL ;	
	m_notificationClassObject = NULL ;
	m_snmpNotificationClassObject = NULL ;
	m_getNotifyCalled = FALSE ;
	m_getSnmpNotifyCalled = FALSE ;
	m_localeId = NULL ;
}

CImpPropProv::~CImpPropProv(void)
{
	delete [] m_localeId ;
	delete [] thisNamespace ;
	delete [] ipAddressString ;

	free ( ipAddressValue ) ;

	if ( parentServer )
		parentServer->Release () ;

	if ( server ) 
		server->Release () ;

	if ( m_InitSink )
		m_InitSink->Release () ;

	if ( m_notificationClassObject )
		m_notificationClassObject->Release () ;

	if ( m_snmpNotificationClassObject )
		m_snmpNotificationClassObject->Release () ;

/* 
 * Place code in critical section
 */

	InterlockedDecrement ( & CPropProvClassFactory :: objectsInProgress ) ;

}

//***************************************************************************
//
// CImpPropProv::QueryInterface
// CImpPropProv::AddRef
// CImpPropProv::Release
//
// Purpose: IUnknown members for CImpPropProv object.
//***************************************************************************

STDMETHODIMP CImpPropProv::QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		*iplpv = NULL ;

		if ( iid == IID_IUnknown )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;
		}
		else if ( iid == IID_IWbemServices )
		{
			*iplpv = ( LPVOID ) ( IWbemServices * ) this ;		
		}	
		else if ( iid == IID_IWbemProviderInit )
		{
			*iplpv = ( LPVOID ) ( IWbemProviderInit * ) this ;		
		}

		if ( *iplpv )
		{
			( ( LPUNKNOWN ) *iplpv )->AddRef () ;

			return S_OK ;
		}
		else
		{
			return E_NOINTERFACE ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CImpPropProv::AddRef(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
	    return InterlockedIncrement ( & m_referenceCount ) ;
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

STDMETHODIMP_(ULONG) CImpPropProv::Release(void)
{
	SetStructuredExceptionHandler seh;

	try
	{
		LONG ref ;
		if ( ( ref = InterlockedDecrement ( & m_referenceCount ) ) == 0 )
		{
			delete this ;
			return 0 ;
		}
		else
		{
			return ref ;
		}
	}
	catch(Structured_Exception e_SE)
	{
		return 0;
	}
	catch(Heap_Exception e_HE)
	{
		return 0;
	}	
	catch(...)
	{
		return 0;
	}
}

HRESULT CImpPropProv :: SetServer ( IWbemServices *serverArg ) 
{
	server = serverArg ;
	server->AddRef () ;
	
	//don't change anything but the cloaking...
	return WbemSetProxyBlanket(server,
					RPC_C_AUTHN_DEFAULT,
					RPC_C_AUTHZ_DEFAULT,
					COLE_DEFAULT_PRINCIPAL,
					RPC_C_AUTHN_LEVEL_DEFAULT,
					RPC_C_IMP_LEVEL_DEFAULT,
					NULL,
					EOAC_DYNAMIC_CLOAKING);
}

HRESULT CImpPropProv :: SetParentServer ( IWbemServices *parentServerArg ) 
{
	parentServer = parentServerArg ; 
	parentServer->AddRef () ;
	
	//don't change anything but the cloaking...
	return WbemSetProxyBlanket(parentServer,
					RPC_C_AUTHN_DEFAULT,
					RPC_C_AUTHZ_DEFAULT,
					COLE_DEFAULT_PRINCIPAL,
					RPC_C_AUTHN_LEVEL_DEFAULT,
					RPC_C_IMP_LEVEL_DEFAULT,
					NULL,
					EOAC_DYNAMIC_CLOAKING);
}

IWbemServices *CImpPropProv :: GetServer () 
{ 
	if ( server )
		server->AddRef () ; 

	return server ; 
}

IWbemServices *CImpPropProv :: GetParentServer () 
{ 
	if ( parentServer )
		parentServer->AddRef () ;

	return ( IWbemServices * ) parentServer ; 
}

IWbemClassObject *CImpPropProv :: GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_notificationClassObject )
	{
		m_notificationClassObject->AddRef () ;
	}

	return m_notificationClassObject ; 
}

IWbemClassObject *CImpPropProv :: GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) 
{
	if ( m_snmpNotificationClassObject )
	{
		m_snmpNotificationClassObject->AddRef () ;
	}

	return m_snmpNotificationClassObject ; 
}

void CImpPropProv :: SetLocaleId ( wchar_t *localeId )
{
	m_localeId = UnicodeStringDuplicate ( localeId ) ;
}

wchar_t *CImpPropProv :: GetThisNamespace () 
{
	return thisNamespace ; 
}

void CImpPropProv :: SetThisNamespace ( wchar_t *thisNamespaceArg ) 
{
	thisNamespace = UnicodeStringDuplicate ( thisNamespaceArg ) ; 
}

BOOL CImpPropProv:: FetchSnmpNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx 
)
{
	m_snmpNotificationLock.Lock();
	BOOL status = TRUE ;

	if ( m_getSnmpNotifyCalled )
	{
		if ( ! m_snmpNotificationClassObject )
			status = FALSE ;
	}
	else
	{
		m_getSnmpNotifyCalled = TRUE ;
		BSTR t_Class = SysAllocString ( WBEM_CLASS_SNMPNOTIFYSTATUS ) ;

		HRESULT result = server->GetObject (

			t_Class ,
			0 ,
			a_Ctx,
			& m_snmpNotificationClassObject ,
			NULL 
		) ;

		SysFreeString ( t_Class ) ;

		if ( ! SUCCEEDED ( result ) )
		{
			status = FALSE ;
			m_snmpNotificationClassObject = NULL ;
		}
	}

	m_snmpNotificationLock.Unlock();
	return status ;
}

BOOL CImpPropProv:: FetchNotificationObject ( 

	WbemSnmpErrorObject &a_errorObject ,
	IWbemContext *a_Ctx
)
{
	m_notificationLock.Lock();
	BOOL status = TRUE ;

	if ( m_getNotifyCalled )
	{
		if ( ! m_notificationClassObject )
			status = FALSE ;
	}
	else
	{
		m_getNotifyCalled = TRUE ;

		BSTR t_Class = SysAllocString ( WBEM_CLASS_EXTENDEDSTATUS ) ;

		HRESULT result = server->GetObject (

			t_Class ,
			0 ,
			a_Ctx ,
			& m_notificationClassObject ,
			NULL 
		) ;

        SysFreeString ( t_Class ) ;

		if ( ! SUCCEEDED ( result ) )
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Failed to get __ExtendedStatus" ) ;
			m_notificationClassObject = NULL;
		}
	}

	m_notificationLock.Unlock();
	return status ;
}

BOOL CImpPropProv::AttachParentServer ( 

	WbemSnmpErrorObject &a_errorObject , 
	BSTR ObjectPath, 
	IWbemContext *pCtx
)
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpPropProv::AttachParentServer ( (%s) )" ,
		ObjectPath
	) ;
)

	BOOL status = TRUE ;

	IWbemLocator *locator = NULL ;
	IWbemServices *t_server = NULL ;

// Get Parent Namespace Path

	WbemNamespacePath *namespacePath = GetNamespacePath () ;

	ULONG count = namespacePath->GetCount () ;
	wchar_t *path = NULL ;

	if ( namespacePath->GetServer () )
	{
		path = UnicodeStringDuplicate ( L"\\\\" ) ;
		wchar_t *concatPath = UnicodeStringAppend ( path , namespacePath->GetServer () ) ;
		delete [] path ;
		path = concatPath ;
	}

	if ( ! namespacePath->Relative () )
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , L"\\" ) ;
		delete [] path ;
		path = concatPath ;
	}

	ULONG pathIndex = 0 ;		
	wchar_t *pathComponent ;
	namespacePath->Reset () ;
	while ( ( pathIndex < count - 1 ) && ( pathComponent = namespacePath->Next () ) ) 
	{
		wchar_t *concatPath = UnicodeStringAppend ( path , pathComponent ) ;
		delete [] path ;
		path = concatPath ;
		if ( pathIndex < count - 2 )
		{
			concatPath = UnicodeStringAppend ( path , L"\\" ) ;
			delete [] path ;
			path = concatPath ;
		}

		pathIndex ++ ;
	}

	if ( pathComponent = namespacePath->Next () )
	{
		SetThisNamespace ( pathComponent ) ; 
	}

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Calling ConnectServer ( (%s) )" ,
		path
	) ;
)

// Connect to parent namespace
	HRESULT result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemLocator ,
		( void ** )  & locator
	);

	if ( SUCCEEDED ( result ) )
	{
		IWbemClassObject *errorObject = NULL ;

		result = locator->ConnectServer (

			path ,
			NULL,
			NULL,
			NULL ,
			0 ,
			NULL,
			pCtx,
			( IWbemServices ** ) & t_server 
		) ;

		if ( errorObject )
			errorObject->Release () ;

		if ( SUCCEEDED ( result ) )
		{
// Mark this interface pointer as "critical"

			result = SetParentServer ( t_server ) ;
			t_server->Release () ;

			if ( FAILED ( result ) && result != E_NOINTERFACE ) //implies there is no prxy security - inproc.
			{
				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				a_errorObject.SetMessage ( L"Failed to secure proxy to this namespace's parent namespace" ) ;
			}
		}
		else
		{
			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to connect to this namespace's parent namespace" ) ;
		}

		locator->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemLocator" ) ;
	}

	delete [] path ;

DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpPropProv::AttachParentServer ( (%s) ) with result" ,
		ObjectPath ,
		a_errorObject.GetWbemStatus () 
	) ;
)

	return status ;
}

BOOL CImpPropProv::ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject )
{
DebugMacro2( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"CImpPropProv::ObtainCachedIpAddress ()"
	) ;
)

	BOOL status = TRUE ;

	IWbemClassObject *namespaceObject = NULL ;

	wchar_t *objectPathPrefix = UnicodeStringAppend ( WBEM_NAMESPACE_EQUALS , GetThisNamespace () ) ;
	wchar_t *objectPath = UnicodeStringAppend ( objectPathPrefix , WBEM_NAMESPACE_QUOTE ) ;

	delete [] objectPathPrefix ;

	BSTR t_Path = SysAllocString ( objectPath ) ;

	HRESULT result = parentServer->GetObject ( 

		t_Path ,
		0 ,
		NULL,
		&namespaceObject ,
		NULL 
	) ;

	SysFreeString ( t_Path ) ;

	delete [] objectPath ;

	if ( SUCCEEDED ( result ) )
	{
		IWbemQualifierSet *classQualifierObject ;
		result = namespaceObject->GetQualifierSet ( &classQualifierObject ) ;
		if ( SUCCEEDED ( result ) )
		{
			VARIANT variant ;
			VariantInit ( & variant ) ;

			LONG attributeType ;
			result = classQualifierObject->Get ( 

				WBEM_QUALIFIER_AGENTTRANSPORT , 
				0,	
				&variant ,
				& attributeType
			) ;

			if ( SUCCEEDED ( result ) )
			{
				if ( variant.vt == VT_BSTR ) 
				{
					if ( _wcsicmp ( variant.bstrVal , L"IP" ) == 0 )
					{
						VARIANT variant ;
						VariantInit ( & variant ) ;

						LONG attributeType ;
						result = classQualifierObject->Get ( 

							WBEM_QUALIFIER_AGENTADDRESS , 
							0,	
							&variant ,
							&attributeType
						) ;

						if ( SUCCEEDED ( result ) )
						{
							if ( variant.vt == VT_BSTR ) 
							{
								ipAddressString = UnicodeToDbcsString ( variant.bstrVal ) ;
								if ( ipAddressString )
								{
								
									SnmpTransportIpAddress transportAddress ( 
			
										ipAddressString , 
										SNMP_ADDRESS_RESOLVE_NAME | SNMP_ADDRESS_RESOLVE_VALUE 
									) ;

									if ( transportAddress () )
									{	
										ipAddressValue = _strdup ( transportAddress.GetAddress () ) ;
									}
									else
									{
										delete [] ipAddressString ;
										ipAddressString = NULL ;

	/*
	 *	Invalid Transport Address.
	 */

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_errorObject.SetMessage ( L"Invalid value for qualifier: AgentAddress" ) ;
									}
								}
								else
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Type mismatch for qualifier: AgentAddress" ) ;
								}
 							}
							else
							{
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Type Mismatch for qualifier: AgentAddress" ) ;
							}
						}

						VariantClear ( &variant ) ;
					}
					else if ( _wcsicmp ( variant.bstrVal , L"IPX" ) == 0 )
					{
					}
					else
					{
						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_TRANSPORTCONTEXT ) ;
						a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
						a_errorObject.SetMessage ( L"Invalid value for qualifier: AgentAddress" ) ;

					}
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type Mismatch for qualifier: AgentAddress" ) ;
				}

				VariantClear ( & variant );
			}
			else
			{
/*
 *	Don't need transport agent address
 */
			}

			
		}

		classQualifierObject->Release () ;

		namespaceObject->Release () ;
	}
	else
	{
		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to obtain namespace object" ) ;
	}

DebugMacro2( 

	wchar_t *t_UnicodeString = ipAddressValue ? DbcsToUnicodeString ( ipAddressValue ) : NULL ;

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"Returning from CImpPropProv::ObtainCachedIpAddress () with IP Address (%s)",
		t_UnicodeString ? t_UnicodeString : L"NULL"
	) ;

	delete [] t_UnicodeString ;
)

	return status ;
}

/////////////////////////////////////////////////////////////////////////////
//  Functions for the IWbemServices interface that are handled here

HRESULT CImpPropProv :: CancelAsyncCall ( 
		
	IWbemObjectSink __RPC_FAR *pSink
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: QueryObjectSink ( 

	long lFlags,		
	IWbemObjectSink FAR* FAR* ppResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: GetObject ( 
		
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR* FAR *ppObject,
    IWbemCallResult FAR* FAR *ppCallResult
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: GetObjectAsync ( 
		
	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::GetObjectAsync ( (%s) )" ,
			ObjectPath
		) ;
)

		if (SUCCEEDED(result))
		{
	/*
	 * Create Asynchronous GetObjectByPath object
	 */

			SnmpGetAsyncEventObject aSyncEvent ( this , ObjectPath , pHandler , pCtx ) ;

			aSyncEvent.Process () ;

			aSyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpPropProv::GetObjectAsync ( (%s) ) with Result = (%lx)" ,
			ObjectPath ,
			result 
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpPropProv :: PutClass ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: PutClassAsync ( 
		
	IWbemClassObject FAR* pObject, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

 HRESULT CImpPropProv :: DeleteClass ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemCallResult FAR* FAR* ppCallResult
) 
{
 	 return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: DeleteClassAsync ( 
		
	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: CreateClassEnum ( 

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

SCODE CImpPropProv :: CreateClassEnumAsync (

	const BSTR Superclass, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: PutInstance (

    IWbemClassObject FAR *pInst,
    long lFlags,
    IWbemContext FAR *pCtx,
	IWbemCallResult FAR *FAR *ppCallResult
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: PutInstanceAsync ( 
		
	IWbemClassObject FAR* pInst, 
	long lFlags, 
    IWbemContext FAR *pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::PutInstanceAsync ()" 
		) ;
)

		if (SUCCEEDED(result))
		{
	/*
	 * Create Synchronous UpdateInstance object
	 */

			SnmpUpdateAsyncEventObject aSyncEvent ( this , pInst , pHandler , pCtx , lFlags ) ;

			aSyncEvent.Process () ;

			aSyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpPropProv::PutInstanceAsync () with Result = (%lx)" ,
			result 
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpPropProv :: DeleteInstance ( 

	const BSTR ObjectPath,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT CImpPropProv :: DeleteInstanceAsync (
 
	const BSTR ObjectPath,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pHandler
)
{
		return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

#if 0
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT t_Result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::DeleteInstance ()" 
		) ;
) 

		if (SUCCEEDED(t_Result))
		{
	/*
	 * Create Asynchronous GetObjectByPath object
	 */

			DeleteInstanceAsyncEventObject t_AsyncEvent ( this , ObjectPath , lFlags , pHandler , pCtx ) ;

			t_AsyncEvent.Process () ;

			t_AsyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			t_Result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpPropProv::DeleteInstanceAsync ( (%s) ) with Result = (%lx)" ,
			ObjectPath ,
			t_Result 
		) ;
)
		return t_Result ;

	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

#endif


HRESULT CImpPropProv :: CreateInstanceEnum ( 

	const BSTR Class, 
	long lFlags, 
	IWbemContext FAR *pCtx, 
	IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: CreateInstanceEnumAsync (

 	const BSTR Class, 
	long lFlags, 
	IWbemContext __RPC_FAR *pCtx,
	IWbemObjectSink FAR* pHandler 

) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::CreateInstanceEnumAsync ( (%s) )" ,
			Class
		) ;
)

		if (SUCCEEDED(result))
		{
	/*
	 * Create Synchronous Enum Instance object
	 */

			SnmpInstanceAsyncEventObject aSyncEvent ( this , Class , pHandler , pCtx ) ;

			aSyncEvent.Process () ;

			aSyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"ReturningFrom CImpPropProv::CreateInstanceEnum ( (%s) ) with Result = (%lx)" ,
			Class ,
			result
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpPropProv :: ExecQuery ( 

	const BSTR QueryLanguage, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR *pCtx,
	IEnumWbemClassObject FAR *FAR *ppEnum
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT CImpPropProv :: ExecQueryAsync ( 
		
	const BSTR QueryFormat, 
	const BSTR Query, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemObjectSink FAR* pHandler
) 
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient();

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->Write (  

			L"\r\n"
		) ;

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"CImpPropProv::ExecQueryAsync ( this = ( %lx ) , (%s),(%s) )" ,
			this ,
			QueryFormat ,
			Query 
		) ;
)

		if (SUCCEEDED(result))
		{
	/*
	 * Create Synchronous Enum Instance object
	 */

			pHandler->SetStatus(WBEM_STATUS_REQUIREMENTS, 0, NULL, NULL);

			SnmpQueryAsyncEventObject aSyncEvent ( this , QueryFormat , Query , pHandler , pCtx ) ;

			aSyncEvent.Process () ;

			aSyncEvent.Wait ( TRUE ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning from CImpPropProv::ExecqQueryAsync ( (%s),(%s) ) with Result = (%lx)" ,
			QueryFormat,
			Query,
			result 
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT CImpPropProv :: ExecNotificationQuery ( 

	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
        
HRESULT CImpPropProv :: ExecNotificationQueryAsync ( 
            
	const BSTR QueryLanguage,
    const BSTR Query,
    long lFlags,
    IWbemContext __RPC_FAR *pCtx,
    IWbemObjectSink __RPC_FAR *pResponseHandler
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}       

HRESULT STDMETHODCALLTYPE CImpPropProv :: ExecMethod( 

	const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
    IWbemClassObject FAR *FAR *ppOutParams,
    IWbemCallResult FAR *FAR *ppCallResult
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}

HRESULT STDMETHODCALLTYPE CImpPropProv :: ExecMethodAsync ( 

    const BSTR ObjectPath,
    const BSTR MethodName,
    long lFlags,
    IWbemContext FAR *pCtx,
    IWbemClassObject FAR *pInParams,
	IWbemObjectSink FAR *pResponseHandler
) 
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
       
HRESULT CImpPropProv :: Initialize(

	LPWSTR pszUser,
	LONG lFlags,
	LPWSTR pszNamespace,
	LPWSTR pszLocale,
	IWbemServices *pCIMOM,         // For anybody
	IWbemContext *pCtx,
	IWbemProviderInitSink *pInitSink     // For init signals
)
{
	SetStructuredExceptionHandler seh;

	try
	{
		HRESULT result = WbemCoImpersonateClient(); //Impersomate cimom - LocalSystem!
		
		if (SUCCEEDED(result))
		{
			EnterCriticalSection ( & s_ProviderCriticalSection ) ;

			BOOL status = TRUE ;

			if ( ! CImpPropProv :: s_Initialised )
			{
				ProviderStartup () ;

				SnmpThreadObject :: Startup () ;
				SnmpDebugLog :: Startup () ;

				status = SnmpClassLibrary :: Startup () ;
				if ( status == FALSE )
				{
					SnmpThreadObject :: Closedown () ;
					SnmpDebugLog :: Closedown () ;
					
					ProviderClosedown () ;
				}
				else
				{
	 				CImpPropProv :: s_Initialised = TRUE ;
				}
			}

			LeaveCriticalSection ( & s_ProviderCriticalSection ) ;

			WbemSnmpErrorObject errorObject ;
			result = SetServer(pCIMOM) ;

			if ( FAILED ( result ) && result != E_NOINTERFACE ) //implies there is no prxy security - inproc.
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_E_PROVIDER_FAILURE ) ;
				errorObject.SetWbemStatus ( WBEM_E_PROVIDER_FAILURE ) ;
				errorObject.SetMessage ( L"Failed to secure proxy to this namespace" ) ;
			}

			namespacePath.SetNamespacePath ( pszNamespace ) ;

			wchar_t *t_ObjectPath = namespacePath.GetNamespacePath () ;

			status = AttachParentServer ( 

				errorObject , 
				t_ObjectPath ,
				pCtx 
			) ;

			delete [] t_ObjectPath ;

			if ( status )
			{
				ObtainCachedIpAddress ( errorObject ) ;
			}
			else
			{
				status = FALSE ;
				errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				errorObject.SetMessage ( L"Failed to CoCreateInstance on IID_IWbemServicesr" ) ;
			}

			status = FetchSnmpNotificationObject ( errorObject , pCtx ) ;
			status = FetchNotificationObject ( errorObject , pCtx ) ;

			result = errorObject.GetWbemStatus () ;

			pInitSink->SetStatus ( (result == WBEM_NO_ERROR) ? (LONG)WBEM_S_INITIALIZED : (LONG)WBEM_E_FAILED , 0 ) ;

			WbemCoRevertToSelf();
		}
		else
		{
			result = WBEM_E_ACCESS_DENIED;
		}

DebugMacro2( 

		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"Returning From CImpPropProv::Initiliaze ( this = ( %lx ) ) with Result = (%lx)" , 
			this , result
		) ;
)

		return result ;
	}
	catch(Structured_Exception e_SE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
	catch(Heap_Exception e_HE)
	{
		WbemCoRevertToSelf();
		return WBEM_E_OUT_OF_MEMORY;
	}	
	catch(...)
	{
		WbemCoRevertToSelf();
		return WBEM_E_UNEXPECTED;
	}
}

HRESULT STDMETHODCALLTYPE CImpPropProv::OpenNamespace ( 

	const BSTR ObjectPath, 
	long lFlags, 
	IWbemContext FAR* pCtx,
	IWbemServices FAR* FAR* pNewContext, 
	IWbemCallResult FAR* FAR* ppErrorObject
)
{
	return WBEM_E_PROVIDER_NOT_CAPABLE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\provinit.cpp ===
#include "precomp.h"
#include <provexpt.h>

#include <provstd.h>
#include <provmt.h>
#include <provtempl.h>
#include <provcont.h>
#include <provevt.h>
#include <provthrd.h>
#include <provlog.h>

void ProviderClosedown ()
{
	ProvThreadObject :: Closedown () ;
	ProvDebugLog :: Closedown () ;
}

void ProviderStartup ()
{
	ProvThreadObject :: Startup () ;
	ProvDebugLog :: Startup () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\resource.h ===
//{{NO_DEPENDENCIES}}

//  Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
// Used by snmpclas.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpnext.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <provtree.h>
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propinst.h"
#include "propquery.h"
#include "snmpnext.h"

BOOL DecrementObjectIdentifier ( 

	SnmpObjectIdentifier &a_Object , 
	SnmpObjectIdentifier &a_DecrementedObject 
)
{
	BOOL t_Status = TRUE ;

	ULONG t_ObjectLength = a_Object.GetValueLength () ;
	ULONG *t_ObjectValue = a_Object.GetValue () ;

	ULONG *t_DecrementedValue = new ULONG [ t_ObjectLength ] ;

	BOOL t_Decrement = TRUE ;

	for ( ULONG t_Index = t_ObjectLength ; t_Index > 0 ; t_Index -- )
	{
		ULONG t_Component = t_ObjectValue [ t_Index - 1 ] ;

		if ( t_Decrement )
		{
			if ( t_Component == 0 ) 
			{
				t_Component -- ;
			}
			else
			{
				t_Decrement = FALSE ;
				t_Component -- ;
			}
		}

		t_DecrementedValue [ t_Index - 1 ] = t_Component ;
	}
	
	a_DecrementedObject.SetValue ( t_DecrementedValue , t_ObjectLength ) ;

	delete [] t_DecrementedValue;

	t_Status = t_Decrement == FALSE ;

	return t_Status ;
}

BOOL IncrementObjectIdentifier ( 

	SnmpObjectIdentifier &a_Object , 
	SnmpObjectIdentifier &a_IncrementedObject 
)
{
	BOOL t_Status = TRUE ;

	ULONG t_ObjectLength = a_Object.GetValueLength () ;
	ULONG *t_ObjectValue = a_Object.GetValue () ;

	ULONG *t_IncrementedValue = new ULONG [ t_ObjectLength ] ;

	BOOL t_Increment = TRUE ;

	for ( ULONG t_Index = t_ObjectLength ; t_Index > 0 ; t_Index -- )
	{
		ULONG t_Component = t_ObjectValue [ t_Index - 1 ] ;

		if ( t_Increment )
		{
			if ( t_Component == 0xFFFFFFFF ) 
			{
				t_Component ++ ;
			}
			else
			{
				t_Component ++ ;
				t_Increment = FALSE ;
			}
		}

		t_IncrementedValue [ t_Index - 1 ] = t_Component ;
	}
	
	a_IncrementedObject.SetValue ( t_IncrementedValue , t_ObjectLength ) ;

	delete [] t_IncrementedValue;

	t_Status = t_Increment == FALSE ;

	return t_Status ;
}

AutoRetrieveOperation :: AutoRetrieveOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpInstanceResponseEventObject *eventObjectArg 

) :	SnmpAutoRetrieveOperation ( sessionArg ) , 
	session ( &sessionArg ) ,
	eventObject ( eventObjectArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,	
	rowVarBindsReceived ( 0 ) ,
	rowsReceived ( 0 ) ,
	snmpObject ( NULL ) ,
	virtuals ( FALSE ) ,
	virtualsInitialised ( FALSE ) ,
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 
{
}

AutoRetrieveOperation :: ~AutoRetrieveOperation ()
{
	if ( snmpObject ) 
	{
		snmpObject->Release () ;
	}

	delete [] m_PropertyContainer ;

	session->DestroySession () ;
}

void AutoRetrieveOperation :: ReceiveResponse () 
{
// Inform creator all is done

	eventObject->ReceiveComplete () ;
}

void AutoRetrieveOperation :: ReceiveRowResponse () 
{
// Receive of Row is not complete

	rowsReceived ++ ;

// Inform Creator row has been received

	eventObject->ReceiveRow ( snmpObject ) ;
	snmpObject->Release () ;

// Insert new Object Identifier / Property Hash entries for newly created object

	IWbemClassObject *t_ClassObject = eventObject->GetInstanceObject () ;
	HRESULT t_Result = t_ClassObject->Clone ( & snmpObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{

	/*
	 *	Initialise value to NULL
	 */

			property->SetValue ( snmpObject , ( SnmpValue * ) NULL ) ;

		}
	}
	else
	{
// Problem Here
	}

	virtualsInitialised = FALSE ;
}

void AutoRetrieveOperation :: ReceiveRowVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	rowVarBindsReceived ++ ;

// Set Variable Binding Value for property

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ].m_Property ;
	SnmpValue &value = replyVarBind.GetValue () ;
	if ( property->SetValue ( snmpObject , &value , SetValueRegardlessReturnCheck ) )
	{
	// Set worked
	}
	else
	{
// Type Mismatch

		property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
		WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
		if ( qualifier )
		{
			IWbemQualifierSet *t_QualifierSet = NULL;
			HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
			if ( SUCCEEDED ( result ) )
			{
				SnmpIntegerType integer ( 1 , NULL ) ;
				qualifier->SetValue ( t_QualifierSet , integer ) ;
			}

			t_QualifierSet->Release () ;
		}
	}

	if ( virtuals && virtualsInitialised == FALSE )
	//if ( virtualsInitialised == FALSE )
	{
// Get Phantom Key properties from first Variable Binding of Row

		BOOL status = TRUE ;
		SnmpObjectIdentifier decodeObject = replyVarBind.GetInstance () ;

		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetKeyProperty () ;
		while ( status && ( property = t_SnmpObject->NextKeyProperty () ) )
		{
// For each Phantom Key in Key Order consume instance information

			SnmpInstanceType *decodeValue = property->GetValue () ;
			decodeObject = decodeValue->Decode ( decodeObject ) ;
			if ( *decodeValue )
			{
// Decode worked correctly

				const SnmpValue *value = decodeValue->GetValueEncoding () ;
// Set Property value for Key
				property->SetValue ( snmpObject , value , SetValueRegardlessReturnCheck ) ;
			}
			else
			{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

				WbemSnmpProperty *property ;
				t_SnmpObject->ResetKeyProperty () ;
				while ( property = t_SnmpObject->NextKeyProperty () )
				{
					WbemSnmpQualifier *qualifier = NULL ;
					property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
					{
// Property which is a phantom key could not be decoded correctly.

						IWbemQualifierSet *t_QualifierSet = NULL;
						HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
						if ( SUCCEEDED ( result ) )
						{
							SnmpIntegerType integer ( 1 , NULL ) ;
							qualifier->SetValue ( t_QualifierSet , integer ) ;
						}

						t_QualifierSet->Release () ;
					}
					else
					{
// Problem Here
					}
				}

				status = FALSE ;
			}
		}

// Check we have consumed all instance information

		if ( decodeObject.GetValueLength () )
		{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( property = t_SnmpObject->NextKeyProperty () )
			{
				WbemSnmpQualifier *qualifier = NULL ;
				property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
				if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
				{
// Property which is a phantom key could not be decoded correctly.

					IWbemQualifierSet *t_QualifierSet = NULL;
					HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
					if ( SUCCEEDED ( result ) )
					{
						SnmpIntegerType integer ( 1 , NULL ) ;
						qualifier->SetValue ( t_QualifierSet , integer ) ;
					}

					t_QualifierSet->Release () ;
				}
				else
				{
// Problem Here
				}
			}
		}

// No need to set Phantom keys for further columns of row
		
		virtualsInitialised = TRUE ;
	}
}

void AutoRetrieveOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;
}

#pragma warning (disable:4065)

void AutoRetrieveOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// End of MIB tree.
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}

	erroredVarBindsReceived ++ ;
}

#pragma warning (default:4065)

void AutoRetrieveOperation :: FrameTooBig ()
{
}

void AutoRetrieveOperation :: FrameOverRun () 
{
}

void AutoRetrieveOperation :: Send ()
{
// Send Variable Bindings for requested properties

	SnmpNull snmpNull ;
	SnmpVarBindList varBindList ;
	SnmpVarBindList startVarBindList ;

// Create class object for subsequent receipt of response

	IWbemClassObject *t_ClassObject = eventObject->GetInstanceObject () ;
	HRESULT t_Result = t_ClassObject->Clone ( & snmpObject ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
		SnmpInstanceClassObject *t_RequestSnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpRequestClassObject () ;

// Check for properties which are phantom

		virtualsInitialised = FALSE ;
		virtuals = FALSE ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetKeyProperty () ;
		while ( property = t_SnmpObject->NextKeyProperty () )
		{
			if ( property->IsVirtualKey () )
			{
// There are some properties which are phantom

				virtuals = TRUE ;
			}

			if ( ! t_RequestSnmpObject->FindProperty ( property->GetName () ) ) 
			{
				virtuals = TRUE ;
			}
		}

		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_SnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_SnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						m_PropertyContainerLength ++ ;
					}
				}
			}
		}

		m_PropertyContainer = new PropertyDefinition [ m_PropertyContainerLength ] ;

// Add Variable binding to Variable binding list
// Insert new Object Identifier / Property Hash entries for newly created object

		ULONG t_Index = 0 ;
		t_RequestSnmpObject->ResetProperty () ;
		while ( property = t_RequestSnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_RequestSnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_RequestSnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifier t_CurrentIdentifier ( 0 , NULL ) ;
								SnmpObjectIdentifier t_StartIdentifier ( 0 , NULL ) ;
								LONG t_Scoped = EvaluateInitialVarBind ( 

									t_Index , 
									t_CurrentIdentifier , 
									t_StartIdentifier 
								) ;

								m_PropertyContainer [ t_Index ].m_Property = property ;

								SnmpObjectIdentifierType requestIdentifierType ( * ( SnmpObjectIdentifierType * ) value ) ;

								SnmpObjectIdentifier t_RequestIdentifier = * ( SnmpObjectIdentifier * ) requestIdentifierType.GetValueEncoding () ; 

								SnmpVarBind t_VarBind ( t_RequestIdentifier , snmpNull ) ;
								varBindList.Add ( t_VarBind ) ;

								if ( t_Scoped > 0 )
								{
									t_RequestIdentifier = t_RequestIdentifier + t_StartIdentifier ;
								}

// Add Variable binding to list

								SnmpVarBind t_StartVarBind ( t_RequestIdentifier , snmpNull ) ;
								startVarBindList.Add ( t_StartVarBind ) ;

								t_Index ++ ;
							}
						}
					}
					else
					{
// Don't Send properties marked as virtual key
					} 
				}
			} 
/*
 *	Initialise value to NULL
 */

			property->SetValue ( snmpObject , ( SnmpValue * ) NULL ) ;

		}

// Finally Send request

		SendRequest ( varBindList , startVarBindList ) ;
	}
	else
	{
	}
}

LONG AutoRetrieveOperation :: EvaluateNextRequest (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN SnmpVarBind &sendVarBind
)
{
	LONG t_Evaluation = 0 ;

	PartitionSet *t_Partition = eventObject->GetPartitionSet () ;
	if ( t_Partition )
	{
		BOOL t_Status = TRUE ;

		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
		ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;
		SnmpObjectIdentifier t_DecodeObject = replyVarBind.GetInstance () ;

		ULONG t_Index = 0 ;
		WbemSnmpProperty *t_Property ;
		t_SnmpObject->ResetKeyProperty () ;
		while ( t_Status && ( t_Property = t_SnmpObject->NextKeyProperty () ) )
		{
// For each Key in Key Order consume instance information

			SnmpInstanceType *t_DecodeValue = t_Property->GetValue () ;
			t_DecodeObject = t_DecodeValue->Decode ( t_DecodeObject ) ;

			SnmpObjectIdentifier t_Encode ( 0 , NULL ) ;
			t_Encode = t_DecodeValue->Encode ( t_Encode ) ;

			m_PropertyContainer [ var_bind_index - 1 ].m_ObjectIdentifierComponent [ t_Index + 1 ] = ( SnmpObjectIdentifier * ) t_Encode.Copy () ;
			t_Index ++ ;
		}

		SnmpObjectIdentifier t_AdvanceObjectIdentifier ( 0 , NULL ) ;

		t_Evaluation = EvaluateResponse (

			var_bind_index - 1 ,
			t_KeyCount ,
			t_AdvanceObjectIdentifier
		) ;

		if ( t_Evaluation > 0 )
		{
			SnmpNull t_SnmpNull ;
			SnmpVarBind t_VarBind ( t_AdvanceObjectIdentifier , t_SnmpNull ) ;
			sendVarBind = t_VarBind ;
		}

		for ( t_Index = 0 ; t_Index < m_PropertyContainer [ var_bind_index - 1 ].m_KeyCount ; t_Index ++ )
		{
			delete m_PropertyContainer [ var_bind_index - 1 ].m_ObjectIdentifierComponent [ t_Index + 1 ] ;
			m_PropertyContainer [ var_bind_index - 1 ].m_ObjectIdentifierComponent [ t_Index + 1 ] = NULL ;
		}
	}

	return t_Evaluation ;
}

LONG AutoRetrieveOperation :: EvaluateResponse (

	IN ULONG a_PropertyIndex ,
	IN ULONG &a_CurrentIndex ,
	IN SnmpObjectIdentifier &a_AdvanceObjectIdentifier 
)
{
	LONG t_Evaluation = 0 ;
	BOOL t_UseStartAsAdvance = FALSE ;

	for ( ULONG t_Index = 0 ; t_Index < m_PropertyContainer [ a_PropertyIndex ].m_KeyCount ; t_Index ++ )
	{
		SnmpObjectIdentifier *t_Encode = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ t_Index + 1 ] ;
		SnmpObjectIdentifier *t_Start = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index + 1 ] ;
		if ( t_Start )
		{
/*
 *	We have a start which is not negatively infinite
 */
			if ( *t_Encode > *t_Start )
			{
/*
 *	The encoded object from the device is greater than the start value, so add the encoded value
 *  to the running total.
 */
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Encode ;
			}			
			else if ( *t_Encode == *t_Start )
			{
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Encode ;
			}
			else
			{

/*
 * Encoded value is less than start value so we need to advance to the start value
 */

				t_UseStartAsAdvance = TRUE ;

/*
 *	The encoded object from the device is less than the start value, so add the encoded value
 *  to the running total.
 */
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Start ;
			}
		}
		else
		{
/*
 * Start is negatively infinite
 */
			if ( t_UseStartAsAdvance )
			{
/*
 *	We have already identified a starting position which is greater than the encoded value.
 *  The new value is a negative infinite so we should stop here
 */
				t_Index ++ ;
				break ;
			}
			else
			{
/*
 *	The start position is negatively infinite and we haven't had to use a different value from the one
 *  returned from the device.
 */
				a_AdvanceObjectIdentifier = a_AdvanceObjectIdentifier + *t_Encode ;
			}
		}


/*
 * The value was not taken from the start value with an 
 * infinite range on next key index, so we must check to see if the range is less than the 'end'
 */

		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index + 1 ] ;
		WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;
		SnmpObjectIdentifier *t_End = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index + 1 ] ;
		if ( t_End )
		{
			BOOL t_InRange = ( ( t_Range->ClosedUpperBound () && ( *t_Encode <= *t_End ) ) ||
							 ( ! t_Range->ClosedUpperBound () && ( *t_Encode < *t_End ) ) ) ;

			
			if ( t_InRange )
			{
/*
 *	We are still within the boundaries
 */
			}
			else
			{
/*
*  Move to new partition because we have moved past end 
*/

				SnmpObjectIdentifier t_StartObjectIdentifier ( 0 , NULL ) ;

/*
 *	Advance to the next partition, we will use the next partition starting point for next request
 */
				t_Evaluation = EvaluateSubsequentVarBind ( 

					a_PropertyIndex , 
					a_CurrentIndex ,
					a_AdvanceObjectIdentifier ,
					t_StartObjectIdentifier 
				) ;

				if ( t_Evaluation >= 0 )
				{
					a_AdvanceObjectIdentifier = t_StartObjectIdentifier ;
				}

				t_UseStartAsAdvance = FALSE ;

				t_Index ++ ;
				break ;
			}
		}
		else
		{
/*
 *	Range is infinite so go on to next
 */
		}
	}

	if ( t_UseStartAsAdvance ) 
	{
/*
 *	We have got all the way to the end without move to the end of a partition and have used new start position
 */

		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] ;
		WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;

		if( t_Range->ClosedLowerBound () )
		{
			if ( ! DecrementObjectIdentifier ( a_AdvanceObjectIdentifier , a_AdvanceObjectIdentifier ) )
			{
				t_Evaluation = -1 ;
				return t_Evaluation ;
			}
		}

		t_Evaluation = 1 ;
	}

	return t_Evaluation ;
}

LONG AutoRetrieveOperation :: EvaluateInitialVarBind ( 

	ULONG a_PropertyIndex ,
	SnmpObjectIdentifier &a_CurrentIdentifier ,
	SnmpObjectIdentifier &a_StartIdentifier 
)
{
	LONG t_Scoped = -1 ;

	PartitionSet *t_Partition = eventObject->GetPartitionSet () ;
	if ( t_Partition )
	{
		SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
		ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;

		if ( ! m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex )
		{
			m_PropertyContainer [ a_PropertyIndex ].m_KeyCount = t_KeyCount ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart = new SnmpObjectIdentifier * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd = new SnmpObjectIdentifier * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent = new SnmpObjectIdentifier * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition  = new PartitionSet * [ t_KeyCount + 1 ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex = new ULONG [ t_KeyCount + 1 ] ;

			for ( ULONG t_Index = 0 ; t_Index <= t_KeyCount ; t_Index ++ ) 
			{
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ] = NULL ;
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = NULL ;
				m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ t_Index ] = NULL ;
				m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ t_Index ] = 0 ;
				m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] = t_Partition ;
				t_Partition = t_Partition->GetPartition ( 0 ) ;
			}

			t_Scoped = EvaluateVarBind ( a_PropertyIndex , a_StartIdentifier ) ;
		}
	}

	return t_Scoped ;
}

LONG AutoRetrieveOperation :: EvaluateSubsequentVarBind ( 

	ULONG a_PropertyIndex ,
	ULONG &a_CurrentIndex ,
	SnmpObjectIdentifier &a_CurrentIdentifier ,
	SnmpObjectIdentifier &a_StartIdentifier 
)
{
	LONG t_Scoped = -1 ;

	SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
	ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;

	BOOL t_Complete = FALSE ;

	BOOL t_AdvanceInsidePartition = FALSE ;

	while ( ! t_Complete )
	{
		if ( a_CurrentIndex > 0 )
		{
			if ( t_AdvanceInsidePartition )
			{
				SnmpObjectIdentifier *t_Encode = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ a_CurrentIndex ] ;

				BOOL t_Incremented = IncrementObjectIdentifier ( *t_Encode , *t_Encode ) ;
				if ( t_Incremented )
				{
					t_Scoped = EvaluateResponse ( 

						a_PropertyIndex ,
						a_CurrentIndex ,
						a_StartIdentifier
					) ;

					t_Complete = TRUE ;
				}
				else
				{
/*
*	Increment failed so next time around loop to next partition
*/
					t_AdvanceInsidePartition = FALSE ;
				}
			}
			else
			{
/*
*	Get the current partition index and increment to get next possible partition index
*/
				ULONG t_PartitionIndex = m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ a_CurrentIndex - 1 ] + 1 ;

/*
* Get the parent partition set associated with the current key partition
*/

				PartitionSet *t_ParentPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition  [ a_CurrentIndex - 1 ] ;

/*
*	Check there are more partitions left to scan
*/
				if ( t_PartitionIndex >= t_ParentPartition->GetPartitionCount () )
				{
					if ( ! t_AdvanceInsidePartition )
					{
/*
*	Reset the current partition value to NULL object identifier
*/

						*m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierComponent [ a_CurrentIndex ] = SnmpObjectIdentifier ( 0 , NULL ) ;

/*
* No more partitions for this key, move to previous key and attempt to get next value for that key
*/
						t_AdvanceInsidePartition = TRUE ;
						a_CurrentIndex -- ;
					}
				}
				else
				{
/*
* More partitions for this key
*
* Set the partition for the current ( keyindex == t_CurrentIndex - 1 ) to t_PartitionIndex 
*/

					m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ a_CurrentIndex - 1 ] = t_PartitionIndex ;
/*
* Move to the next partition for ( keyIndex == t_CurrentIndex - 1 ) and t_PartitionIndex
*/
					m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ a_CurrentIndex ] = t_ParentPartition->GetPartition ( t_PartitionIndex ) ;

					for ( ULONG t_Index = a_CurrentIndex ; t_Index < t_KeyCount ; t_Index ++ )
					{
						m_PropertyContainer [ a_PropertyIndex ].m_PartitionIndex [ t_Index ] = 0 ;
					}

					t_Scoped = EvaluateVarBind ( a_PropertyIndex , a_StartIdentifier ) ;

					if ( a_StartIdentifier < a_CurrentIdentifier ) 
					{
						a_StartIdentifier = a_CurrentIdentifier ;
					}

					PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_PartitionIndex ] ;
					WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;
					SnmpObjectIdentifier *t_End = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_PartitionIndex ] ;
					if ( t_End )
					{
						BOOL t_InRange = ( ( t_Range->ClosedUpperBound () && ( a_StartIdentifier <= *t_End ) ) ||
										 ( ! t_Range->ClosedUpperBound () && ( a_StartIdentifier < *t_End ) ) ) ;

			
						if ( t_InRange )
						{
							t_Complete = TRUE ;
						}
					}
					else
					{
						t_Complete = TRUE ;
					}
				}
			}
		}
		else
		{
			t_Scoped = -1 ;
			t_Complete = TRUE ;
		}
	}

	return t_Scoped ;
}

LONG AutoRetrieveOperation :: EvaluateVarBind ( 

	ULONG a_PropertyIndex ,
	SnmpObjectIdentifier &a_StartIdentifier 
)
{
	LONG t_Scoped = 0 ;

	SnmpInstanceClassObject *t_SnmpObject = ( SnmpInstanceClassObject * ) eventObject->GetSnmpClassObject () ;
	ULONG t_KeyCount = t_SnmpObject->GetKeyPropertyCount () ;

	BOOL t_FoundInfinite = FALSE ;

	WbemSnmpProperty *t_KeyProperty = NULL ;
	t_SnmpObject->ResetKeyProperty () ;
	for ( ULONG t_Index = 1 ; t_Index <= t_KeyCount ; t_Index ++ ) 
	{
		t_KeyProperty = t_SnmpObject->NextKeyProperty () ;

		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] ;
		WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;
		
		if ( t_Range->InfiniteLowerBound () )
		{
			t_FoundInfinite = TRUE ;
		}
		else
		{
			t_Scoped = 1 ;

			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ] = new SnmpObjectIdentifier ( 0 , NULL ) ;

			if ( typeid ( *t_Range ) == typeid ( WmiUnsignedIntegerRangeNode ) )
			{
				WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_Range ;
				ULONG t_Integer = t_Node->LowerBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ]  ) ;

				if ( ! t_FoundInfinite ) 
				{
					t_KeyProperty->Encode ( t_Variant , a_StartIdentifier ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
			else if ( typeid ( *t_Range ) == typeid ( WmiSignedIntegerRangeNode ) )
			{
				WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_Range  ;
				LONG t_Integer = t_Node->LowerBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ]  ) ;

				if ( ! t_FoundInfinite ) 
				{
					t_KeyProperty->Encode ( t_Variant , a_StartIdentifier ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
			if ( typeid ( *t_Range ) == typeid ( WmiStringRangeNode ) )
			{
				WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_Range ;
				BSTR t_String = t_Node->LowerBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( t_String ) ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierStart [ t_Index ]  ) ;

				if ( ! t_FoundInfinite ) 
				{
					t_KeyProperty->Encode ( t_Variant , a_StartIdentifier ) ;
				}

				VariantClear ( & t_Variant ) ;
			}
		}

		if ( ( t_Index == t_KeyCount ) && t_Range->ClosedLowerBound () )
		{
			BOOL t_Decremented = DecrementObjectIdentifier ( 

				a_StartIdentifier , 
				a_StartIdentifier
			) ;
			
			t_Scoped = t_Decremented ? 1 : 0 ;
		}
	}

	t_SnmpObject->ResetKeyProperty () ;
	for ( t_Index = 1 ; t_Index <= t_KeyCount ; t_Index ++ ) 
	{
		PartitionSet *t_KeyPartition = m_PropertyContainer [ a_PropertyIndex ].m_KeyPartition [ t_Index ] ;
		WmiRangeNode *t_Range = t_KeyPartition->GetRange () ;

		t_KeyProperty = t_SnmpObject->NextKeyProperty () ;

		if ( ! t_Range->InfiniteUpperBound () )
		{
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = new SnmpObjectIdentifier ( 0 , NULL ) ;
			
			if ( typeid ( *t_Range ) == typeid ( WmiUnsignedIntegerRangeNode ) )
			{
				WmiUnsignedIntegerRangeNode *t_Node = ( WmiUnsignedIntegerRangeNode * ) t_Range ;
				ULONG t_Integer = t_Node->UpperBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ]  ) ;

				VariantClear ( & t_Variant ) ;
			}
			else if ( typeid ( *t_Range ) == typeid ( WmiSignedIntegerRangeNode ) )
			{
				WmiSignedIntegerRangeNode *t_Node = ( WmiSignedIntegerRangeNode * ) t_Range  ;
				LONG t_Integer = t_Node->UpperBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_I4 ;
				t_Variant.lVal = t_Integer ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ]  ) ;

				VariantClear ( & t_Variant ) ;
			}
			if ( typeid ( *t_Range ) == typeid ( WmiStringRangeNode ) )
			{
				WmiStringRangeNode *t_Node = ( WmiStringRangeNode * ) t_Range ;
				BSTR t_String = t_Node->UpperBound () ;

				VARIANT t_Variant ;
				VariantInit ( & t_Variant ) ;
				t_Variant.vt = VT_BSTR ;
				t_Variant.bstrVal = SysAllocString ( t_String ) ;

				t_KeyProperty->Encode ( t_Variant , * m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] ) ;

				VariantClear ( & t_Variant ) ;
			}

			if ( t_Range->ClosedUpperBound () )
			{
				SnmpObjectIdentifier *t_End = m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] ;
				if ( IncrementObjectIdentifier ( * t_End , * t_End ) )
				{
				}
				else
				{
					delete m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] ;
					m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = NULL ;
				}
			}
		}
		else
		{
			delete m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] ;
			m_PropertyContainer [ a_PropertyIndex ].m_ObjectIdentifierEnd [ t_Index ] = NULL ;
		}
	}

	return t_Scoped ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpget.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include <provtree.h>
#include <provdnf.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "snmpget.h"

GetOperation :: GetOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpGetResponseEventObject *eventObjectArg 

) :	SnmpGetOperation ( sessionArg ) , 
	session ( & sessionArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,
	eventObject ( eventObjectArg ) ,
	virtuals ( FALSE ) ,
	virtualsInitialised ( FALSE ) ,	
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 
{
}

GetOperation :: ~GetOperation ()
{
	delete [] m_PropertyContainer ;

	session->DestroySession () ;
}

void GetOperation :: ReceiveResponse () 
{
// Inform creator all is done

	if ( varBindsReceived == 0 )
	{
/*
 *	Don't mask errors encountered previously
 */

		if ( eventObject->GetErrorObject ().GetWbemStatus () == S_OK )
		{
			eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_NOT_FOUND ) ;
			eventObject->GetErrorObject ().SetMessage ( L"Instance unknown" ) ;
		}
	}
	else
	{
		if ( FAILED ( eventObject->GetErrorObject ().GetWbemStatus () ) ) 
		{
			if ( eventObject->GetErrorObject ().GetStatus () == WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) 
			{
				eventObject->GetErrorObject ().SetWbemStatus ( WBEM_S_TIMEDOUT ) ;
			}
		}
	}

	eventObject->ReceiveComplete () ;
}

void GetOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,	
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;

	IWbemClassObject *snmpObject = eventObject->GetInstanceObject () ;

	if ( ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchObject ) ) || ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchInstance ) ) )
	{
	}
	else
	{
	// Set Property value

		WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;
		SnmpValue &value = replyVarBind.GetValue () ;

		// Set Property value

		if ( property->SetValue ( snmpObject , &value , SetValueRegardlessReturnCheck ) )
		{
		// Set worked
		}
		else
		{
	// Type Mismatch

			property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
			if ( qualifier )
			{
				IWbemQualifierSet *t_QualifierSet = NULL;
				HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
				if ( SUCCEEDED ( result ) )
				{
					SnmpIntegerType integer ( 1 , NULL ) ;
					qualifier->SetValue ( t_QualifierSet , integer ) ;
				}

				t_QualifierSet->Release () ;
			}
		}

		if ( virtuals && virtualsInitialised == FALSE )
		{
// Get Phantom Key properties from first Variable Binding of Row

			BOOL status = TRUE ;
			SnmpObjectIdentifier decodeObject ( NULL , 0 ) ;

			//remove object info so we're left with instance (key) info only
			WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
			if ( qualifier )
			{
				SnmpInstanceType *value = qualifier->GetValue () ;
				if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
				{
					SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
					replyVarBind.GetInstance().Suffix( objectIdentifierType->GetValueLength () , decodeObject ) ;
				}
			}

			SnmpGetClassObject *t_SnmpObject = ( SnmpGetClassObject * ) eventObject->GetSnmpClassObject () ;

			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( status && ( property = t_SnmpObject->NextKeyProperty () ) )
			{
// For each Phantom Key in Key Order consume instance information

				SnmpInstanceType *decodeValue = property->GetValue () ;
				decodeObject = decodeValue->Decode ( decodeObject ) ;
				if ( *decodeValue )
				{
// Decode worked correctly

					const SnmpValue *value = decodeValue->GetValueEncoding () ;
// Set Property value for Phantom Key
					property->SetValue ( snmpObject , value , SetValueRegardlessReturnCheck ) ;
				}
				else
				{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

					WbemSnmpProperty *property ;
					t_SnmpObject->ResetKeyProperty () ;
					while ( property = t_SnmpObject->NextKeyProperty () )
					{
						WbemSnmpQualifier *qualifier = NULL ;
						property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
						{
// Property which is a phantom key could not be decoded correctly.

							IWbemQualifierSet *t_QualifierSet = NULL;
							HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
							if ( SUCCEEDED ( result ) )
							{
								SnmpIntegerType integer ( 1 , NULL ) ;
								qualifier->SetValue ( t_QualifierSet , integer ) ;
							}

							t_QualifierSet->Release () ;
						}
						else
						{
// Problem Here
						}
					}

					status = FALSE ;
				}
			}

// Check we have consumed all instance information

			if ( decodeObject.GetValueLength () )
			{
// Decode Error therefore set TYPE MISMATCH for all Phantom keys

				WbemSnmpProperty *property ;
				t_SnmpObject->ResetKeyProperty () ;
				while ( property = t_SnmpObject->NextKeyProperty () )
				{
					WbemSnmpQualifier *qualifier = NULL ;
					property->AddQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TYPE_MISMATCH ) )
					{
// Property which is a phantom key could not be decoded correctly.

						IWbemQualifierSet *t_QualifierSet = NULL;
						HRESULT result = snmpObject->GetPropertyQualifierSet ( property->GetName () , & t_QualifierSet ) ;
						if ( SUCCEEDED ( result ) )
						{
							SnmpIntegerType integer ( 1 , NULL ) ;
							qualifier->SetValue ( t_QualifierSet , integer ) ;
						}

						t_QualifierSet->Release () ;
					}
					else
					{
// Problem Here
					}
				}
			}

// No need to set Phantom keys for further columns of row
			
			virtualsInitialised = TRUE ;
		}
	}
}

#pragma warning (disable:4065)

void GetOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// Invalid property requested
				}
				break ;

				case Snmp_Bad_Value:
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Bad Value for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
				}
				break ;

				case Snmp_Read_Only:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Read Only for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Gen_Error:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported General Error for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Too_Big:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Too Big for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void GetOperation :: FrameTooBig () 
{
}

void GetOperation :: FrameOverRun () 
{
}

void GetOperation :: Send ()
{
// Send Variable Bindings for requested properties

	SnmpVarBindList varBindList ;
	SnmpNull snmpNull ;

	SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

	IWbemClassObject *snmpObject = eventObject->GetInstanceObject () ;

	SnmpClassObject *t_SnmpObject = eventObject->GetSnmpClassObject () ;
	if ( t_SnmpObject )
	{
// Encode Variable Binding instance for all key properties

		if ( t_SnmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			t_SnmpObject->ResetKeyProperty () ;
			while ( property = t_SnmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		virtuals = FALSE ;

		WbemSnmpProperty *property ;
		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsKey () && property->IsVirtualKey () )
			{
// There are some properties which are phantom

				virtuals = TRUE ;
			}

			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_SnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_SnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						m_PropertyContainerLength ++ ;
					}
				}
			}
		}

		m_PropertyContainer = new WbemSnmpProperty * [ m_PropertyContainerLength ] ;

// Add Variable binding to Variable binding list
// Insert new Object Identifier / Property Hash entries for newly created object

		ULONG t_Index = 0 ;

		t_SnmpObject->ResetProperty () ;
		while ( property = t_SnmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( t_SnmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( t_SnmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;
				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE ) 
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
								SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
								SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

								SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

								m_PropertyContainer [ t_Index ] = property ;

								SnmpVarBind varBind ( requestIdentifier , snmpNull ) ;
								varBindList.Add ( varBind ) ;

								t_Index ++ ;
							}
							else
							{
		// Problem Here
							}
						}
						else
						{
		// Problem Here
						}
					}
					else
					{
	// Don't retrieve properties marked as virtual keys.
					}
				}
			}

/*
 *	Initialise value to NULL
 */

			property->SetValue ( snmpObject , ( SnmpValue * ) NULL ) ;
		}

// Finally Send request

		SendRequest ( varBindList ) ;
	}
	else
	{
// Problem Here
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpqset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "snmpget.h"
#include "snmpset.h"
#include "snmpqset.h"

SetQueryOperation :: SetQueryOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpSetResponseEventObject *eventObjectArg 

) :	SnmpGetOperation ( sessionArg ) , 
	session ( &sessionArg ) ,
	eventObject ( eventObjectArg ) ,
	rowReceived ( FALSE )
{
}

SetQueryOperation :: ~SetQueryOperation ()
{
	session->DestroySession () ;
}

void SetQueryOperation :: ReceiveResponse () 
{
	eventObject->ReceiveComplete () ;
}

void SetQueryOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	if ( ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchObject ) ) || ( typeid ( replyVarBind.GetValue () ) == typeid ( SnmpNoSuchInstance ) ) )
	{
	}
	else
	{
		rowReceived = TRUE ;
	}
}

#pragma warning (disable:4065)

void SetQueryOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{
// Invalid property requested
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void SetQueryOperation :: Send ()
{
// Send Variable Bindings for requested properties

	SnmpVarBindList varBindList ;
	SnmpNull snmpNull ;

// Create class object for subsequent receipt of response

// Add Variable binding to Variable binding list

	SnmpClassObject *snmpObject = eventObject->GetSnmpClassObject () ;
	if ( snmpObject )
	{
// Encode Variable Binding instance for all key properties

		SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

		if ( snmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			snmpObject->ResetKeyProperty () ;
			while ( property = snmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}	
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		WbemSnmpProperty *property ;
		snmpObject->ResetProperty () ;
		while ( property = snmpObject->NextProperty () )
		{
			if ( property->IsReadable () )
			{
				BOOL t_Status = ( snmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( snmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
						if ( qualifier )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
								SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
								SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
								SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

								SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

		// Add Variable binding to list

								SnmpVarBind varBind ( requestIdentifier , snmpNull ) ;
								varBindList.Add ( varBind ) ;
							}
							else
							{
		// Problem Here
							}
						}
						else
						{
		// Problem Here
						}
					}
					else
					{
	// Don't Send properties marked as virtual key
					} 
				}
			} 
		}

// Finally Send request

		SendRequest ( varBindList ) ;
	}
	else
	{
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpobj.cpp ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <objbase.h>
#include <winerror.h>

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemidl.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <snmpcont.h>
#include <snmptype.h>
#include <snmpobj.h>

static SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> mibTypeMap ;

BOOL InitialiseMibTypeMap ()
{
	mibTypeMap [ WBEM_TYPE_INTEGER ]			= WBEM_INDEX_TYPE_INTEGER ;
	mibTypeMap [ WBEM_TYPE_INTEGER32 ]			= WBEM_INDEX_TYPE_INTEGER32 ;
	mibTypeMap [ WBEM_TYPE_OCTETSTRING ]		= WBEM_INDEX_TYPE_OCTETSTRING ;
	mibTypeMap [ WBEM_TYPE_OBJECTIDENTIFIER ]	= WBEM_INDEX_TYPE_OBJECTIDENTIFIER ;
	mibTypeMap [ WBEM_TYPE_NULL ]				= WBEM_INDEX_TYPE_NULL ;
	mibTypeMap [ WBEM_TYPE_IPADDRESS ]			= WBEM_INDEX_TYPE_IPADDRESS ;
	mibTypeMap [ WBEM_TYPE_COUNTER ]			= WBEM_INDEX_TYPE_COUNTER ;
	mibTypeMap [ WBEM_TYPE_GAUGE ]				= WBEM_INDEX_TYPE_GAUGE ;
	mibTypeMap [ WBEM_TYPE_TIMETICKS ]			= WBEM_INDEX_TYPE_TIMETICKS ;
	mibTypeMap [ WBEM_TYPE_OPAQUE ]			= WBEM_INDEX_TYPE_OPAQUE ;
	mibTypeMap [ WBEM_TYPE_NETWORKADDRESS ]	= WBEM_INDEX_TYPE_NETWORKADDRESS ;
	mibTypeMap [ WBEM_TYPE_COUNTER32 ]			= WBEM_INDEX_TYPE_COUNTER32 ;
	mibTypeMap [ WBEM_TYPE_COUNTER64 ]			= WBEM_INDEX_TYPE_COUNTER64 ;
	mibTypeMap [ WBEM_TYPE_GAUGE32 ]			= WBEM_INDEX_TYPE_GAUGE32 ;
	mibTypeMap [ WBEM_TYPE_UNSIGNED32 ]		= WBEM_INDEX_TYPE_UNSIGNED32;

	return TRUE ;
}

BOOL initialisedMibTypeMap = InitialiseMibTypeMap () ;

static SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> textualConventionMap ;

BOOL InitialiseTextualConventionMap ()
{
	textualConventionMap [ WBEM_TYPE_INTEGER ]				= WBEM_INDEX_TYPE_INTEGER ;
	textualConventionMap [ WBEM_TYPE_INTEGER32 ]			= WBEM_INDEX_TYPE_INTEGER32 ;
	textualConventionMap [ WBEM_TYPE_OCTETSTRING ]			= WBEM_INDEX_TYPE_OCTETSTRING ;
	textualConventionMap [ WBEM_TYPE_OBJECTIDENTIFIER ]	= WBEM_INDEX_TYPE_OBJECTIDENTIFIER ;
	textualConventionMap [ WBEM_TYPE_NULL ]				= WBEM_INDEX_TYPE_NULL ;
	textualConventionMap [ WBEM_TYPE_IPADDRESS ]			= WBEM_INDEX_TYPE_IPADDRESS ;
	textualConventionMap [ WBEM_TYPE_COUNTER ]				= WBEM_INDEX_TYPE_COUNTER ;
	textualConventionMap [ WBEM_TYPE_GAUGE ]				= WBEM_INDEX_TYPE_GAUGE ;
	textualConventionMap [ WBEM_TYPE_TIMETICKS ]			= WBEM_INDEX_TYPE_TIMETICKS ;
	textualConventionMap [ WBEM_TYPE_OPAQUE ]				= WBEM_INDEX_TYPE_OPAQUE ;
	textualConventionMap [ WBEM_TYPE_NETWORKADDRESS ]		= WBEM_INDEX_TYPE_NETWORKADDRESS ;
	textualConventionMap [ WBEM_TYPE_DISPLAYSTRING ]		= WBEM_INDEX_TYPE_DISPLAYSTRING ;
	textualConventionMap [ WBEM_TYPE_MACADDRESS ]			= WBEM_INDEX_TYPE_MACADDRESS ;
	textualConventionMap [ WBEM_TYPE_PHYSADDRESS ]			= WBEM_INDEX_TYPE_PHYSADDRESS ;
	textualConventionMap [ WBEM_TYPE_ENUMERATEDINTEGER ]	= WBEM_INDEX_TYPE_ENUMERATEDINTEGER ;
	textualConventionMap [ WBEM_TYPE_COUNTER32 ]			= WBEM_INDEX_TYPE_COUNTER32 ;
	textualConventionMap [ WBEM_TYPE_COUNTER64 ]			= WBEM_INDEX_TYPE_COUNTER64 ;
	textualConventionMap [ WBEM_TYPE_GAUGE32 ]				= WBEM_INDEX_TYPE_GAUGE32 ;
	textualConventionMap [ WBEM_TYPE_UNSIGNED32 ]			= WBEM_INDEX_TYPE_UNSIGNED32 ;
	textualConventionMap [ WBEM_TYPE_DATETIME ]			= WBEM_INDEX_TYPE_DATETIME ;
	textualConventionMap [ WBEM_TYPE_BITS ]				= WBEM_INDEX_TYPE_BITS ;
	textualConventionMap [ WBEM_TYPE_SNMPOSIADDRESS ]		= WBEM_INDEX_TYPE_SNMPOSIADDRESS ;
	textualConventionMap [ WBEM_TYPE_SNMPUDPADDRESS ]		= WBEM_INDEX_TYPE_SNMPUDPADDRESS ;
	textualConventionMap [ WBEM_TYPE_SNMPIPXADDRESS ]		= WBEM_INDEX_TYPE_SNMPIPXADDRESS ;
	textualConventionMap [ WBEM_TYPE_ROWSTATUS ]		= WBEM_INDEX_TYPE_ROWSTATUS ;
	return TRUE ;
}

BOOL initialisedTextualConventionMap = InitialiseTextualConventionMap () ;

static SnmpMap <ULONG,ULONG,CIMTYPE,CIMTYPE> cimTypeMap ;

BOOL InitialiseCimTypeMap ()
{
	cimTypeMap [ WBEM_INDEX_TYPE_INTEGER ]			= CIM_SINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_INTEGER32 ]			= CIM_SINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_OCTETSTRING ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_OBJECTIDENTIFIER ]	= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_NULL ]				= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_IPADDRESS ]			= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_COUNTER ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_GAUGE ]				= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_TIMETICKS ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_OPAQUE ]				= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_NETWORKADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_DISPLAYSTRING ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_MACADDRESS ]			= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_PHYSADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_ENUMERATEDINTEGER ]	= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_COUNTER32 ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_COUNTER64 ]			= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_GAUGE32 ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_UNSIGNED32 ]			= CIM_UINT32 ;
	cimTypeMap [ WBEM_INDEX_TYPE_DATETIME ]			= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_BITS ]				= CIM_STRING | CIM_FLAG_ARRAY ;
	cimTypeMap [ WBEM_INDEX_TYPE_SNMPOSIADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_SNMPUDPADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_SNMPIPXADDRESS ]		= CIM_STRING ;
	cimTypeMap [ WBEM_INDEX_TYPE_ROWSTATUS ]			= CIM_STRING ;
	return TRUE ;
}

BOOL initialisedCimTypeMap = InitialiseCimTypeMap () ;

static SnmpMap <wchar_t *,wchar_t *,ULONG,ULONG> validQualifierMap ;

BOOL InitialiseQualifierMap ()
{
	validQualifierMap [ WBEM_QUALIFIER_TEXTUAL_CONVENTION ]			= WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION ;
	validQualifierMap [ WBEM_QUALIFIER_SYNTAX ]						= WBEM_INDEX_QUALIFIER_SYNTAX ;
	validQualifierMap [ WBEM_QUALIFIER_OBJECT_IDENTIFIER ]				= WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER ;
	validQualifierMap [ WBEM_QUALIFIER_ENCODING ]						= WBEM_INDEX_QUALIFIER_ENCODING ;
	validQualifierMap [ WBEM_QUALIFIER_FIXED_LENGTH ]					= WBEM_INDEX_QUALIFIER_FIXED_LENGTH ;
	validQualifierMap [ WBEM_QUALIFIER_VARIABLE_LENGTH ]				= WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH ;
	validQualifierMap [ WBEM_QUALIFIER_VARIABLE_VALUE ]				= WBEM_INDEX_QUALIFIER_VARIABLE_VALUE ;
	validQualifierMap [ WBEM_QUALIFIER_ENUMERATION ]					= WBEM_INDEX_QUALIFIER_ENUMERATION ;
	validQualifierMap [ WBEM_QUALIFIER_BITS ]							= WBEM_INDEX_QUALIFIER_BITS ;
	validQualifierMap [ WBEM_QUALIFIER_DISPLAY_HINT ]					= WBEM_INDEX_QUALIFIER_DISPLAY_HINT ;
	validQualifierMap [ WBEM_QUALIFIER_KEY ]							= WBEM_INDEX_QUALIFIER_KEY ;
	validQualifierMap [ WBEM_QUALIFIER_KEY_ORDER ]						= WBEM_INDEX_QUALIFIER_KEY_ORDER ;
	validQualifierMap [ WBEM_QUALIFIER_VIRTUAL_KEY ]					= WBEM_INDEX_QUALIFIER_VIRTUAL_KEY ;
	validQualifierMap [ WBEM_QUALIFIER_READ ]							= WBEM_INDEX_QUALIFIER_READ ;
	validQualifierMap [ WBEM_QUALIFIER_WRITE ]							= WBEM_INDEX_QUALIFIER_WRITE ;
	validQualifierMap [ WBEM_QUALIFIER_NOT_AVAILABLE ]					= WBEM_INDEX_QUALIFIER_NOT_AVAILABLE ;
	validQualifierMap [ WBEM_QUALIFIER_TYPE_MISMATCH ]					= WBEM_INDEX_QUALIFIER_TYPE_MISMATCH ;
	validQualifierMap [ WBEM_QUALIFIER_VALUE_MISMATCH ]					= WBEM_INDEX_QUALIFIER_VALUE_MISMATCH ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTSNMPVERSION ]				= WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTTRANSPORT ]				= WBEM_INDEX_QUALIFIER_AGENTTRANSPORT ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTADDRESS ]					= WBEM_INDEX_QUALIFIER_AGENTADDRESS ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTREADCOMMUNITYNAME ]		= WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTWRITECOMMUNITYNAME ]		= WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTRETRYCOUNT ]				= WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTRETRYTIMEOUT ]				= WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTVARBINDSPERPDU ]			= WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU ;
	validQualifierMap [ WBEM_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE ]	= WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE ;
	validQualifierMap [ WBEM_QUALIFIER_SINGLETON ]					= WBEM_INDEX_QUALIFIER_SINGLETON ;
	validQualifierMap [ WBEM_QUALIFIER_TABLECLASS ]					= WBEM_INDEX_QUALIFIER_TABLECLASS;
	validQualifierMap [ WBEM_QUALIFIER_KEYTYPES ]					= WBEM_INDEX_QUALIFIER_KEYTYPES;
	validQualifierMap [ WBEM_QUALIFIER_KEYVALUES ]					= WBEM_INDEX_QUALIFIER_KEYVALUES;
	validQualifierMap [ WBEM_QUALIFIER_VARBINDINDEX ]				= WBEM_INDEX_QUALIFIER_VARBINDINDEX;
	validQualifierMap [ WBEM_QUALIFIER_ROWSTATUS ]				= WBEM_INDEX_QUALIFIER_ROWSTATUS;

	return TRUE ;
}

BOOL initialisedQualifierMap = InitialiseQualifierMap () ;

WbemSnmpQualifier  :: WbemSnmpQualifier (

	const wchar_t *qualifierNameArg ,
	const SnmpInstanceType *typeValueArg 

) : typeValue ( NULL ) , qualifierName (NULL )
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValueArg ) ? typeValueArg->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: WbemSnmpQualifier ( const wchar_t *qualifierNameArg = (%s) , const SnmpInstanceType *typeValueArg = (%lx),(%s) )" ,
			qualifierNameArg ,
			typeValueArg ,
			t_StringValue
		) ;
	}
	else
	{ 
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: WbemSnmpQualifier ( const wchar_t *qualifierNameArg = (%s) , const SnmpInstanceType *typeValueArg = (NULL) )" ,
			qualifierNameArg ,
			typeValueArg
		) ;
	}
	delete [] t_StringValue ;


)

	qualifierName = new wchar_t [ wcslen ( qualifierNameArg ) + 1 ] ;
	wcscpy ( qualifierName , qualifierNameArg ) ;

	if ( typeValueArg )
	{
		typeValue = typeValueArg->Copy () ;
	}
}

WbemSnmpQualifier :: WbemSnmpQualifier ( const WbemSnmpQualifier &copy ) : qualifierName ( NULL ), typeValue ( NULL )
{
DebugMacro7( 

	wchar_t *t_StringValue = ( copy.typeValue ) ? copy.typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: const WbemSnmpQualifier &copy (%s),(%s) )" , 
			copy.qualifierName ,
			t_StringValue
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: const WbemSnmpQualifier &copy (%s),(NULL)" ,
			copy.qualifierName 
		) ;
	}

	delete [] t_StringValue ;
)

	qualifierName = new wchar_t [ wcslen ( copy.qualifierName ) + 1 ] ;
	wcscpy ( qualifierName , copy.qualifierName ) ;

	if ( copy.typeValue )
	{
		typeValue = copy.typeValue->Copy () ;
	}
}

WbemSnmpQualifier :: ~WbemSnmpQualifier () 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,L"WbemSnmpQualifier :: ~WbemSnmpQualifier ( (%s),(%s) )" ,
			qualifierName ? qualifierName : L"!!NULL!!",
			t_StringValue
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,L"WbemSnmpQualifier :: ~WbemSnmpQualifier ( (%s),(NULL) )" ,
			qualifierName ? qualifierName : L"!!NULL!!" 
		) ;
	}

	delete [] t_StringValue ;
)

	delete [] qualifierName ;
	delete typeValue ;
}

wchar_t *WbemSnmpQualifier :: GetName () const
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpQualifier :: GetName ( %s )" ,
		qualifierName
	) 
)

	return qualifierName ;
}

SnmpInstanceType *WbemSnmpQualifier :: GetValue () const 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( (%s), (%s) )" ,
			qualifierName ,
			t_StringValue 
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( (%s) , (NULL) )" ,
			qualifierName
		) ;
	}

	delete [] t_StringValue ;
) 

	return typeValue ;
}

BOOL WbemSnmpQualifier :: GetValue ( VARIANT &variant ) const
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( VARIANT &variant ( (%s),(%s) )" ,
			qualifierName ,
			t_StringValue
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: GetValue ( VARIANT &variant ( (%s),(NULL) )" ,
			qualifierName
		) ;
	}

	delete [] t_StringValue ;
) 

	BOOL status = TRUE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpObjectIdentifierType ) ) 
				{
					SnmpObjectIdentifierType *objectIdentifier = ( SnmpObjectIdentifierType * ) typeValue ;
					wchar_t *string = objectIdentifier ->GetStringValue () ;
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( string ) ;
					delete [] string ;
				}	
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_ENCODING:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
					wchar_t *string = displayString->GetValue () ;
					variant.vt = VT_BSTR ;
					variant.bstrVal = SysAllocString ( string ) ;
					delete [] string ;
				}	
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) ) 
				{
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					variant.vt = VT_BOOL ;
					variant.boolVal = integer->GetValue () ? VARIANT_TRUE : VARIANT_FALSE ;
				}
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) ) 
				{
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					variant.vt = VT_I4 ;
					variant.lVal = integer->GetValue () ;
				}
				else
				{
					status = FALSE ;
					variant.vt = VT_NULL ;
				}
			}
			break ;

			default:
			{
				status = FALSE ;
				variant.vt = VT_NULL ;
			}
		}
	}
	else
	{
		status = FALSE ;
		variant.vt = VT_NULL ;
	}

	return status ;
}

VARTYPE WbemSnmpQualifier :: GetValueVariantType () const 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpQualifier :: GetValueVariantType ()" ) ) 

	VARTYPE varType = VT_NULL ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			case WBEM_INDEX_QUALIFIER_ENCODING:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				varType = VT_BSTR ;
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				varType = VT_BOOL ;
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				varType = VT_I4 ;
			}
			break ;

			default:
			{
				varType = VT_NULL ;
			}
		}
	}
	else
	{
		varType = VT_NULL ;
	}

	return varType ;
}

BOOL WbemSnmpQualifier :: IsPropagatable () const 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpQualifier :: IsPropagatable ()" ) ) 

	BOOL status = FALSE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			case WBEM_INDEX_QUALIFIER_ENCODING:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				status = FALSE ;
			}
			break ;

			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			{
				status = TRUE ;
			}
			break ;

			default:
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpQualifier :: SetValue ( IWbemQualifierSet *a_Qualifier , const SnmpInstanceType &value ) 
{
	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;

	t_Variant.vt = VT_NULL ;

	BOOL status = FALSE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			{
				if ( (typeid ( value ) == typeid ( SnmpDisplayStringType )) && typeValue) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) & value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( textualConventionMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
						SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *string = displayString->GetValue () ;
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( string ) ;
					}

					delete [] string ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_ENCODING:
			{
				if ( ( typeid ( value ) == typeid ( SnmpDisplayStringType ) ) && typeValue ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) & value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( mibTypeMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
						SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *string = displayString->GetValue () ;
						t_Variant.vt = VT_BSTR ;
						t_Variant.bstrVal = SysAllocString ( string ) ;
					}

					delete [] string ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( (typeid ( value ) == typeid ( SnmpObjectIdentifierType ) ) && typeValue )
				{
					status = TRUE ;
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
					wchar_t *string = displayString->GetValue () ;
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( string ) ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( ( typeid ( value ) == typeid ( SnmpDisplayStringType ) ) && typeValue) 
				{
					status = TRUE ;
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) typeValue ;
					wchar_t *string = displayString->GetValue () ;
					t_Variant.vt = VT_BSTR ;
					t_Variant.bstrVal = SysAllocString ( string ) ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			{
				if ( typeid ( value ) == typeid ( SnmpIntegerType ) ) 
				{
					status = TRUE ;
					SnmpIntegerType *integer = typeValue ? ( SnmpIntegerType * ) typeValue : ( SnmpIntegerType * ) &value;
					t_Variant.vt = VT_BOOL ;
					t_Variant.boolVal = integer->GetValue () ? VARIANT_TRUE : VARIANT_FALSE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( ( typeid ( value ) == typeid ( SnmpIntegerType ) ) && typeValue) 
				{
					status = TRUE ;
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					t_Variant.vt = VT_BOOL ;
					t_Variant.boolVal = integer->GetValue () ? VARIANT_TRUE : VARIANT_FALSE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( ( typeid ( value ) == typeid ( SnmpIntegerType ) ) && typeValue ) 
				{
					status = TRUE ;
					SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
					t_Variant.vt = VT_I4 ;
					t_Variant.lVal = integer->GetValue () ;
				}
			}
			break ;

			default:	
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	if ( status )
	{
		if ( value.IsValid () )
		{
			a_Qualifier->Put ( qualifierName , &t_Variant , WBEM_CLASS_PROPAGATION ) ;
		}
		else
		{
			status = FALSE ;
		}

		VariantClear ( &t_Variant ) ;
	}

	return status ;
}

BOOL WbemSnmpQualifier :: SetValue ( const SnmpInstanceType *value ) 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( typeValue ) ? typeValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: SetValue ( const SnmpInstanceType *value ( (%s),(%s) ) )" ,
			qualifierName , 
			t_StringValue 
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpQualifier :: SetValue ( const SnmpInstanceType *value ( (%s),(NULL) ) )" ,
			qualifierName 
		) ;
	}

	delete [] t_StringValue ;
) 

	BOOL status = FALSE ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			{
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( textualConventionMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
					}

					delete [] string ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_ENCODING:
			{
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
				{
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) value ;
					ULONG stringItem ;
					wchar_t *string = displayString->GetValue () ;
					if ( mibTypeMap.Lookup ( string , stringItem ) )
					{
						status = TRUE ;
					}

					delete [] string ;
				}
			}
			break ;


			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
				{
					status = TRUE ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
				{
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( typeid ( *value ) == typeid ( SnmpIntegerType ) ) 
				{
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( typeid ( *value ) == typeid ( SnmpIntegerType ) ) 
				{
					status = TRUE ;
				}
			}
			break ;

			default:	
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	if ( status )
	{
		if ( value && value->IsValid () )
		{
			delete typeValue  ;
			typeValue = value->Copy () ;
		}
		else
		{
			status = FALSE ;
		}
	}

	return status ;
}

BOOL WbemSnmpQualifier :: SetValue ( const VARIANT &variant ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpQualifier :: SetValue ( const VARIANT &variant )" ) ) 

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	ULONG qualifierIndex ;
	if ( validQualifierMap.Lookup ( qualifierName , qualifierIndex ) )
	{
		switch ( qualifierIndex )
		{
			case WBEM_INDEX_QUALIFIER_TEXTUAL_CONVENTION:
			{
				if ( variant.vt == VT_BSTR )
				{
					ULONG stringItem ;
					wchar_t *string = variant.bstrVal ;
					if ( textualConventionMap.Lookup ( string , stringItem ) )
					{
						value = new SnmpDisplayStringType ( string , NULL ) ;
						status = TRUE ;
					}
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_ENCODING:
			{
				if ( variant.vt == VT_BSTR )
				{
					ULONG stringItem ;
					wchar_t *string = variant.bstrVal ;
					if ( mibTypeMap.Lookup ( string , stringItem ) )
					{
						value = new SnmpDisplayStringType ( string , NULL ) ;
						status = TRUE ;
					}
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_OBJECT_IDENTIFIER:
			{
				if ( variant.vt == VT_BSTR )
				{
					value = new SnmpObjectIdentifierType ( variant.bstrVal ) ;
					status = TRUE ;
				}
			}
			break ;

			case WBEM_INDEX_QUALIFIER_SYNTAX:
			case WBEM_INDEX_QUALIFIER_VARIABLE_LENGTH:
			case WBEM_INDEX_QUALIFIER_VARIABLE_VALUE:
			case WBEM_INDEX_QUALIFIER_DISPLAY_HINT:
			case WBEM_INDEX_QUALIFIER_ENUMERATION:
			case WBEM_INDEX_QUALIFIER_BITS:
			case WBEM_INDEX_QUALIFIER_AGENTSNMPVERSION:
			case WBEM_INDEX_QUALIFIER_AGENTTRANSPORT:
			case WBEM_INDEX_QUALIFIER_AGENTADDRESS:
			case WBEM_INDEX_QUALIFIER_AGENTREADCOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_AGENTWRITECOMMUNITYNAME:
			case WBEM_INDEX_QUALIFIER_TABLECLASS:
			case WBEM_INDEX_QUALIFIER_KEYTYPES:
			case WBEM_INDEX_QUALIFIER_KEYVALUES:
			{
				if ( variant.vt == VT_BSTR )
				{
					value = new SnmpDisplayStringType ( variant.bstrVal , NULL ) ;
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_KEY:
			case WBEM_INDEX_QUALIFIER_VIRTUAL_KEY:
			case WBEM_INDEX_QUALIFIER_READ:
			case WBEM_INDEX_QUALIFIER_WRITE:
			case WBEM_INDEX_QUALIFIER_NOT_AVAILABLE:
			case WBEM_INDEX_QUALIFIER_TYPE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_VALUE_MISMATCH:
			case WBEM_INDEX_QUALIFIER_SINGLETON:
			case WBEM_INDEX_QUALIFIER_ROWSTATUS:
			{
				if ( variant.vt == VT_UI1 )
				{
					value = new SnmpIntegerType ( variant.bVal , NULL ) ;
					status = TRUE ;
				}
				else if ( variant.vt == VT_I4 )
				{
					value = new SnmpIntegerType ( variant.lVal , NULL ) ;
					status = TRUE ;

				}
				else if ( variant.vt == VT_BOOL )
				{
					value = new SnmpIntegerType ( (variant.boolVal == VARIANT_FALSE) ? 0 : 1, NULL ) ;
					status = TRUE ;
				}
			}	
			break ;

			case WBEM_INDEX_QUALIFIER_FIXED_LENGTH:
			case WBEM_INDEX_QUALIFIER_KEY_ORDER:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYCOUNT:
			case WBEM_INDEX_QUALIFIER_AGENTRETRYTIMEOUT:
			case WBEM_INDEX_QUALIFIER_AGENTVARBINDSPERPDU:
			case WBEM_INDEX_QUALIFIER_AGENTFLOWCONTROLWINDOWSIZE:
			case WBEM_INDEX_QUALIFIER_VARBINDINDEX:
			{
				if ( variant.vt == VT_UI1 )
				{
					value = new SnmpIntegerType ( variant.bVal , NULL ) ;
					status = TRUE ;
				}
				else if ( variant.vt == VT_I4 )
				{
					value = new SnmpIntegerType ( variant.lVal , NULL ) ;
					status = TRUE ;
				}
			}
			break ;

			default:	
			{
				status = FALSE ;
			}
		}
	}
	else
	{
		status = FALSE ;
	}

	if ( status )
	{
		if ( value && value->IsValid () ) 
		{
			typeValue = value ;
		}
		else
		{
			status = FALSE ;
			delete value ;
		}
	}
	else
	{
		delete value ;
	}

	return status ;
}

WbemSnmpProperty :: WbemSnmpProperty ( const wchar_t *propertyNameArg ) : propertyValue ( NULL ) ,  
																		qualifierPosition ( NULL ) , 
																		tagged ( FALSE ) ,
																		m_IsNull ( TRUE ) ,
																		m_isKey ( FALSE ) ,
																		m_isVirtualKey ( FALSE ) ,
																		m_isReadable ( FALSE ) ,
																		m_isWritable ( FALSE ) ,
																		m_keyOrder ( 0 ) ,
																		m_TextualConvention ( 0 ) ,
																		m_Handle ( 0 ) ,
																		propertyName ( NULL )

{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: WbemSnmpProperty ( const wchar_t *propertyNameArg (%s) )" ,
		propertyNameArg
	) ;
) 

	propertyValue = new SnmpNullType ;
	propertyName = new wchar_t [ wcslen ( propertyNameArg ) + 1 ] ;
	wcscpy ( propertyName , propertyNameArg ) ;
}

WbemSnmpProperty :: WbemSnmpProperty ( const WbemSnmpProperty &copy ) :	propertyValue ( NULL ) , 
																		qualifierPosition ( NULL ) , 
																		tagged ( FALSE ) ,
																		m_IsNull ( TRUE ) ,
																		m_isKey ( FALSE ) ,
																		m_isVirtualKey ( FALSE ) ,
																		m_isReadable ( FALSE ) ,
																		m_isWritable ( FALSE ) ,
																		m_TextualConvention ( 0 ) ,
																		m_Handle ( 0 ) ,
																		propertyName ( NULL )
{
DebugMacro7( 

	wchar_t *t_StringValue = ( propertyValue ) ? propertyValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: WbemSnmpProperty ( const WbemSnmpProperty &copy ( (%s),(%s)) )" ,
			copy.propertyName ,
			t_StringValue 
		) ; 
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: WbemSnmpProperty ( const WbemSnmpProperty &copy ( (%s),(NULL))" ,
			copy.propertyName 
		) ; 
	}
	
	delete [] t_StringValue ;
) 

	m_isReadable = copy.m_isReadable ;
	m_isWritable = copy.m_isWritable ;
	m_isKey = copy.m_isKey ;
	m_isVirtualKey = copy.m_isVirtualKey ;
	m_IsNull = copy.m_IsNull ;
	tagged = copy.tagged ;
	m_keyOrder = copy.m_keyOrder ;
	m_TextualConvention = copy.m_TextualConvention ;
	m_Handle = copy.m_Handle ;

	if ( copy.propertyValue )
	{
		propertyValue = copy.propertyValue->Copy () ;
	}

	if ( copy.propertyName )
	{
		propertyName = new wchar_t [ wcslen ( copy.propertyName ) + 1 ] ;
		wcscpy ( propertyName , copy.propertyName ) ;
	}

	POSITION position = copy.qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		copy.qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		WbemSnmpQualifier *copyQualifier = new WbemSnmpQualifier ( *qualifier ) ;
		qualifierMap [ copyQualifier->GetName () ] = copyQualifier ;
	}
}

WbemSnmpProperty :: ~WbemSnmpProperty () 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( propertyValue ) ? propertyValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: ~WbemSnmpProperty ( ((%s),(%s)) )" ,
			propertyName ? propertyName : L"!!NULL!!",
			t_StringValue 
		) ; 
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: ~WbemSnmpProperty ( ((%s),(NULL)) )" ,
			propertyName ? propertyName : L"!!NULL!!"
		) ; 
	}
	
	delete [] t_StringValue ;
) 

	delete [] propertyName ;
	delete propertyValue ;

	POSITION position = qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		delete qualifier ;
	}

	qualifierMap.RemoveAll () ;
}

void WbemSnmpProperty :: SetTag ( BOOL tag )
{
	tagged = tag ;
}

BOOL WbemSnmpProperty :: GetTag ()
{
	return tagged ;
}

BOOL WbemSnmpProperty :: IsNull ()
{
	if ( propertyValue )
		return propertyValue->IsNull () ;
	else
		return TRUE ;
}

BOOL WbemSnmpProperty :: IsKey () 
{ 
	return m_isKey ; 
}

BOOL WbemSnmpProperty :: IsVirtualKey () 
{ 
	return m_isVirtualKey ; 
}

void WbemSnmpProperty :: SetKey ( BOOL a_isKey )
{
	m_isKey = a_isKey ; 
}

void WbemSnmpProperty :: SetVirtualKey ( BOOL a_isVirtualKey ) 
{
	m_isVirtualKey = a_isVirtualKey ; 
}

BOOL WbemSnmpProperty :: IsWritable () 
{ 
	return m_isWritable ; 
}

BOOL WbemSnmpProperty :: IsReadable () 
{ 
	return m_isReadable ; 
}

ULONG WbemSnmpProperty :: GetKeyOrder () 
{ 
	return m_keyOrder ; 
}

void WbemSnmpProperty :: SetWritable ( BOOL a_isWritable )
{
	m_isWritable = a_isWritable ; 
}

void WbemSnmpProperty :: SetReadable ( BOOL a_isReadable ) 
{
	m_isReadable = a_isReadable ; 
}

void WbemSnmpProperty :: SetKeyOrder ( ULONG a_keyOrder ) 
{
	m_keyOrder = a_keyOrder ;
}

void WbemSnmpProperty :: SetTextualConvention ( ULONG a_TextualConvention ) 
{
	m_TextualConvention = a_TextualConvention ; 
}

ULONG WbemSnmpProperty :: GetTextualConvention () 
{
	return m_TextualConvention ; 
}

CIMTYPE WbemSnmpProperty :: GetCimType () 
{
	CIMTYPE t_Type = VT_EMPTY ;

	cimTypeMap.Lookup ( m_TextualConvention , t_Type ) ;

	return t_Type ;
}

long WbemSnmpProperty :: GetHandle ()
{
	return m_Handle ;
}

void WbemSnmpProperty :: SetHandle ( long a_Handle ) 
{
	m_Handle = a_Handle ;
}

BOOL WbemSnmpProperty :: SetValue ( const VARIANT &variant , const CIMTYPE & type , WbemPropertyValueCheck check ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const VARIANT &variant )" ) ) 

	SnmpInstanceType *value = NULL ;
	if ( type == CIM_EMPTY )
	{
		value = new SnmpNullType ;
	}
	else
	{
		WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
		if ( qualifier )
		{	
			SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
			wchar_t *textualConvention = displayString->GetValue () ;
			if ( textualConvention )
			{ 
				ULONG qualifierIndex ;
				if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
				{
					switch ( qualifierIndex )
					{
						case WBEM_INDEX_TYPE_INTEGER:
						case WBEM_INDEX_TYPE_INTEGER32:
						{		
							if ( type == CIM_SINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpIntegerType ( variant.lVal , NULL ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpIntegerType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER:
						case WBEM_INDEX_TYPE_COUNTER32:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpCounterType ( variant.lVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpCounterType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER64:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpCounter64Type ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpCounter64Type ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_UNSIGNED32:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpUInteger32Type ( variant.lVal , NULL ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpUInteger32Type ;
								}
							}
						}
						break;

						case WBEM_INDEX_TYPE_GAUGE:
						case WBEM_INDEX_TYPE_GAUGE32:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpGaugeType ( variant.lVal , NULL ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpGaugeType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OCTETSTRING:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthOctetStringType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthOctetStringType ( fixed ) ;
										}
									}
									else
									{
// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpOctetStringType ( variant.bstrVal , rangeValues ) ;
											}
											else if ( variant.vt == VT_NULL )
											{											
												value = new SnmpOctetStringType ( rangeValues ) ;
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpOctetStringType ( variant.bstrVal , NULL ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpOctetStringType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpObjectIdentifierType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpObjectIdentifierType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NULL:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_NULL )
								{
									value = new SnmpNullType ;
								}
								else if ( variant.vt == VT_BSTR )
								{
									value = new SnmpNullType ;
								}
							}
						}
						break;

						case WBEM_INDEX_TYPE_IPADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpIpAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpIpAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_TIMETICKS:
						{
							if ( type == CIM_UINT32 )
							{
								if ( variant.vt == VT_I4 )
								{
									value = new SnmpTimeTicksType ( variant.lVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpTimeTicksType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OPAQUE:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthOpaqueType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthOpaqueType ( fixed ) ;
										}
									}
									else
									{
			// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpOpaqueType ( variant.bstrVal , rangeValues ) ;
											}
											else if ( variant.vt == VT_NULL )
											{
												value = new SnmpOpaqueType ( rangeValues ) ;
												
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpOpaqueType ( variant.bstrVal , NULL ) ;
										}
										else
										{
											value = new SnmpOpaqueType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NETWORKADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpNetworkAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpNetworkAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DISPLAYSTRING:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthDisplayStringType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthDisplayStringType ( fixed ) ;
										}
									}
									else
									{
			// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpDisplayStringType ( variant.bstrVal , rangeValues ) ;
											}
											else
											{
												value = new SnmpDisplayStringType ( rangeValues ) ;
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpDisplayStringType ( variant.bstrVal , NULL ) ;
										}
										else
										{
											value = new SnmpDisplayStringType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_MACADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpMacAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpMacAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_PHYSADDRESS:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpFixedLengthPhysAddressType ( fixed , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpFixedLengthPhysAddressType ( fixed ) ;	
										}
									}
									else
									{
			// Problem Here
									}
								}
								else
								{
									WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
									if ( qualifier ) 
									{
										SnmpInstanceType *typeValue = qualifier->GetValue () ;
										if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
										{
											SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
											wchar_t *rangeValues = string->GetStringValue () ;

											if ( variant.vt == VT_BSTR )
											{
												value = new SnmpPhysAddressType ( variant.bstrVal , rangeValues ) ;
											}
											else if ( variant.vt == VT_NULL )
											{
												value = new SnmpPhysAddressType ( rangeValues ) ;
											}

											delete [] rangeValues ;
										}
										else
										{
										}
									}
									else
									{
										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpPhysAddressType ( variant.bstrVal , NULL ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpPhysAddressType ;
										}
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
						{
							if ( type == CIM_STRING )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *enumerationValues = string->GetStringValue () ;

										if ( variant.vt == VT_BSTR )
										{
											value = new SnmpEnumeratedType ( enumerationValues , variant.bstrVal ) ;
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpEnumeratedType ( enumerationValues ) ;
										}

										delete [] enumerationValues ;
									}
								}
							}
						}	
						break ;

						case WBEM_INDEX_TYPE_BITS:
						{
							if ( type == ( CIM_STRING | CIM_FLAG_ARRAY ) )
							{
								WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
								if ( qualifier )
								{	
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *bitStringValues = string->GetStringValue () ;

										if ( variant.vt == ( VT_BSTR | VT_ARRAY ) )
										{
											if ( SafeArrayGetDim ( variant.parray ) == 1 )
											{
												LONG dimension = 1 ; 
												LONG lower ;
												SafeArrayGetLBound ( variant.parray , dimension , & lower ) ;
												LONG upper ;
												SafeArrayGetUBound ( variant.parray , dimension , & upper ) ;
												LONG count = ( upper - lower ) + 1 ;

												wchar_t **array = new wchar_t * [ count ] ;

												for ( LONG elementIndex = lower ; elementIndex <= upper ; elementIndex ++ )
												{
													BSTR element ;
													SafeArrayGetElement ( variant.parray , &elementIndex , & element ) ;

													array [ elementIndex - lower ] = element ;
												}

												value = new SnmpBitStringType ( bitStringValues , ( const wchar_t ** ) array , count ) ;

												for ( elementIndex = 0 ; elementIndex < count ; elementIndex ++ )
												{
													SysFreeString ( array [ elementIndex ] ) ;
												}

												delete [] array ;
											}
										}
										else if ( variant.vt == VT_NULL )
										{
											value = new SnmpBitStringType ( bitStringValues ) ;
										}

										delete [] bitStringValues ;
									}
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DATETIME:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpDateTimeType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpDateTimeType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpOSIAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpOSIAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpUDPAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpUDPAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpIPXAddressType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpIPXAddressType ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ROWSTATUS:
						{
							if ( type == CIM_STRING )
							{
								if ( variant.vt == VT_BSTR )
								{
									value = new SnmpRowStatusType ( variant.bstrVal ) ;
								}
								else if ( variant.vt == VT_NULL )
								{
									value = new SnmpRowStatusType ;
								}
							}
						}
						break ;

						default:
						{
						}
						break ;

					}
				}
			}

			delete [] textualConvention ;
		}
	}

	BOOL status = TRUE ;

	if ( value )
	{
		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete propertyValue ;
					propertyValue = value ;
					status = FALSE ;
				}
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
				delete propertyValue ;
				propertyValue = value ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}

			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}
			}
			break ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetValue ( const wchar_t *valueString , WbemPropertyValueCheck check )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const wchar_t *valueString )" ) ) 

	SnmpInstanceType *value = NULL ;
	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			ULONG qualifierIndex ;
			if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
			{
				switch ( qualifierIndex )
				{
					case WBEM_INDEX_TYPE_INTEGER:
					case WBEM_INDEX_TYPE_INTEGER32:
					{
						value = new SnmpIntegerType ( valueString , NULL ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER:
					case WBEM_INDEX_TYPE_COUNTER32:
					{
						value = new SnmpCounterType ( valueString ) ;
					}
					break ;


					case WBEM_INDEX_TYPE_COUNTER64:
					{
						value = new SnmpCounter64Type ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_UNSIGNED32:
					{
						value = new SnmpUInteger32Type ( valueString , NULL ) ;
					}
					break;

					case WBEM_INDEX_TYPE_GAUGE:
					case WBEM_INDEX_TYPE_GAUGE32:
					{
						value = new SnmpGaugeType ( valueString , NULL ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthOctetStringType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}
						}	
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpOctetStringType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpOctetStringType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
					{
						value = new SnmpObjectIdentifierType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_NULL:
					{
						value = new SnmpNullType ;
					}
					break ;

					case WBEM_INDEX_TYPE_IPADDRESS:
					{
						value = new SnmpIpAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_TIMETICKS:
					{
						value = new SnmpTimeTicksType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_OPAQUE:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthOpaqueType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpOpaqueType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpOpaqueType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NETWORKADDRESS:
					{
						value = new SnmpNetworkAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_DISPLAYSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthDisplayStringType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}	
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpDisplayStringType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpDisplayStringType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_MACADDRESS:
					{
						value = new SnmpMacAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_PHYSADDRESS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;
								value = new SnmpFixedLengthPhysAddressType ( fixed , valueString ) ;
							}
							else
							{
		// Problem Here
							}	
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;
									value = new SnmpPhysAddressType ( valueString , rangeValues ) ;
									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								value = new SnmpPhysAddressType ( valueString , NULL ) ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *enumerationValues = string->GetStringValue () ;
								value = new SnmpEnumeratedType ( enumerationValues , valueString ) ;
								delete [] enumerationValues ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_BITS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *bitStringValues = string->GetStringValue () ;

								value = new SnmpBitStringType ( bitStringValues , NULL , 0 ) ;

								delete [] bitStringValues ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DATETIME:
					{
						value = new SnmpDateTimeType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
					{
						value = new SnmpOSIAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
					{
						value = new SnmpUDPAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
					{
						value = new SnmpIPXAddressType ( valueString ) ;
					}
					break ;

					case WBEM_INDEX_TYPE_ROWSTATUS:
					{
						value = new SnmpRowStatusType ( valueString ) ;
					}
					break ;

					default:
					{
					}
					break ;

				}
			}
		}

		delete [] textualConvention ;
	}

	BOOL status = TRUE ;

	if ( value )
	{
		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete propertyValue ;
					propertyValue = value ;
					status = FALSE ;
				}
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
				delete propertyValue ;
				propertyValue = value ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}

			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}
			}
			break ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetValue ( const SnmpInstanceType *value , WbemPropertyValueCheck check )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpInstanceType *value )" ) ) 

	BOOL status = FALSE ;
	BOOL validValue = FALSE ;

	if ( value ) 
	{
		WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
		if ( qualifier )
		{	
			SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
			wchar_t *textualConvention = displayString->GetValue () ;
			if ( textualConvention )
			{ 
				ULONG qualifierIndex ;
				if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
				{
					switch ( qualifierIndex )
					{
						case WBEM_INDEX_TYPE_INTEGER:
						case WBEM_INDEX_TYPE_INTEGER32:
						{
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER:
						case WBEM_INDEX_TYPE_COUNTER32:
						{
							if ( typeid ( *value ) == typeid ( SnmpCounterType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_COUNTER64:
						{
							if ( typeid ( *value ) == typeid ( SnmpCounter64Type ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_UNSIGNED32:
						{
							if ( typeid ( *value ) == typeid ( SnmpUInteger32Type ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}						
						}
						break;

						case WBEM_INDEX_TYPE_GAUGE:
						case WBEM_INDEX_TYPE_GAUGE32:
						{
							if ( typeid ( *value ) == typeid ( SnmpGaugeType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OCTETSTRING:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthOctetStringType ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										validValue = TRUE ;

										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthOctetStringType *octetString = ( SnmpFixedLengthOctetStringType * ) value ;
										LONG octetStringFixed = octetString->GetValueLength () ;
										if ( fixed == octetStringFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpOctetStringType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
						{
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NULL:
						{
							if ( typeid ( *value ) == typeid ( SnmpNullType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_IPADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpIpAddressType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_TIMETICKS:
						{
							if ( typeid ( *value ) == typeid ( SnmpTimeTicksType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_OPAQUE:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthOpaqueType ) )
								{
									validValue = TRUE ;
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthOpaqueType *opaque = ( SnmpFixedLengthOpaqueType * ) value ;
										LONG opaqueFixed = opaque->GetValueLength () ;
										if ( fixed == opaqueFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpOpaqueType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_NETWORKADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpNetworkAddressType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DISPLAYSTRING:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthDisplayStringType ) )
								{
									validValue = TRUE ;
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthDisplayStringType *displayString = ( SnmpFixedLengthDisplayStringType * ) value ;
										LONG displayStringFixed = displayString->GetValueLength () ;
										if ( fixed == displayStringFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_MACADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpMacAddressType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_PHYSADDRESS:
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
							if ( qualifier )
							{	
								if ( typeid ( *value ) == typeid ( SnmpFixedLengthPhysAddressType ) )
								{
									validValue = TRUE ;
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
										LONG fixed = integer->GetValue () ;
										SnmpFixedLengthPhysAddressType *displayString = ( SnmpFixedLengthPhysAddressType * ) value ;
										LONG displayStringFixed = displayString->GetValueLength () ;
										if ( fixed == displayStringFixed )
										{
											status = TRUE ;
										}
									}
									else
									{
			// Problem Here
									}
								}
							}
							else
							{
								if ( typeid ( *value ) == typeid ( SnmpPhysAddressType ) ) 
								{
									validValue = TRUE ;
									status = TRUE ;
								}
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
						{
							if ( typeid ( *value ) == typeid ( SnmpEnumeratedType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_BITS:
						{
							if ( typeid ( *value ) == typeid ( SnmpBitStringType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_DATETIME:
						{
							if ( typeid ( *value ) == typeid ( SnmpDateTimeType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpOSIAddressType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpUDPAddressType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
						{
							if ( typeid ( *value ) == typeid ( SnmpIPXAddressType ) )
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						case WBEM_INDEX_TYPE_ROWSTATUS:
						{
							if ( typeid ( *value ) == typeid ( SnmpRowStatusType ) ) 
							{
								validValue = TRUE ;
								status = TRUE ;
							}
						}
						break ;

						default:
						{
						}
						break ;

					}
				}

				if ( validValue )
				{
					switch ( check )
					{
						case SetValueRegardlessReturnCheck:
						{
							if ( value->IsValid () ) 
							{
								delete propertyValue ;
								propertyValue = value->Copy () ;
							}
							else
							{
								delete propertyValue ;
								propertyValue = value->Copy () ;
								status = FALSE ;
							}
						}
						break ;

						case SetValueRegardlessDontReturnCheck:
						{
							delete propertyValue ;
							propertyValue = value->Copy () ;
						}
						break ;

						case DontSetValueReturnCheck:
						{
							if ( value->IsValid () ) 
							{
							}
							else
							{
								status = FALSE ;
							}

						}
						break ;

						case SetValueIfCheckOk:
						{
							if ( value->IsValid () ) 
							{
								delete propertyValue ;
								propertyValue = value->Copy () ;
							}
							else
							{
								status = FALSE ;
							}
						}
						break ;
					}
				}
				else
				{
					status = FALSE ;
				}
			}

			delete [] textualConvention ;
		}
	}

	return status ;

}

BOOL WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg , WbemPropertyValueCheck check )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg )" ) ) 

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			ULONG qualifierIndex ;
			if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
			{
				switch ( qualifierIndex )
				{
					case WBEM_INDEX_TYPE_INTEGER:
					case WBEM_INDEX_TYPE_INTEGER32:
					{
						if ( ! valueArg )
						{
							value = new SnmpIntegerType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) )
						{
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							value = new SnmpIntegerType ( *integer , NULL ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER:
					case WBEM_INDEX_TYPE_COUNTER32:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpCounterType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpCounter ) )
						{
							SnmpCounter *counter = ( SnmpCounter * ) valueArg ;
							value = new SnmpCounterType ( *counter ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER64:
					{
						if ( ! valueArg )
						{
							value = new SnmpCounter64Type ;
						}
						else
						{
							SnmpCounter64 *counter = ( SnmpCounter64 * ) valueArg ;
							value = new SnmpCounter64Type ( *counter ) ;
						}

						status = TRUE ;
					}
					break ;

					case WBEM_INDEX_TYPE_UNSIGNED32:
					{
						if ( ! valueArg )
						{
							value = new SnmpUInteger32Type ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpUInteger32 ) )
						{
							SnmpUInteger32 *ui_integer32 = ( SnmpUInteger32 * ) valueArg ;
							value = new SnmpUInteger32Type ( *ui_integer32 , NULL ) ;

							status = TRUE ;
						}
					}
					break;

					case WBEM_INDEX_TYPE_GAUGE:
					case WBEM_INDEX_TYPE_GAUGE32:
					{
						if ( ! valueArg )
						{
							value = new SnmpGaugeType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpGauge ) )
						{
							SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
							value = new SnmpGaugeType ( *gauge , NULL ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthOctetStringType ( fixed ) ;
									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpFixedLengthOctetStringType ( fixed , *octetString ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg ) 
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOctetStringType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOctetStringType ( *octetString , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg ) 
								{
									value = new SnmpOctetStringType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpOctetStringType ( *octetString , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpObjectIdentifierType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpObjectIdentifier ) ) 
						{
							SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) valueArg ;
							value = new SnmpObjectIdentifierType ( *objectIdentifier ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NULL:
					{
						if ( ! valueArg )
						{
							value = new SnmpNullType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpNull ) ) 
						{
							value = new SnmpNullType ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_IPADDRESS:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpIpAddressType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
						{
							SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
							value = new SnmpIpAddressType ( *ipAddress ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_TIMETICKS:
					{
						if ( ! valueArg )
						{	
							value = new SnmpTimeTicksType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpTimeTicks ) ) 
						{
							SnmpTimeTicks *timeTicks = ( SnmpTimeTicks * ) valueArg ;
							value = new SnmpTimeTicksType ( *timeTicks ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OPAQUE:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthOpaqueType ( fixed ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;

									value = new SnmpFixedLengthOpaqueType ( fixed , *opaque ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOpaqueType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpOpaqueType ( *opaque , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg )
								{
									value = new SnmpOpaqueType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) ) 
								{
									SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
									value = new SnmpOpaqueType ( *opaque , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NETWORKADDRESS:
					{
						if ( ! valueArg ) 
						{
							value = new SnmpNetworkAddressType ;

							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
						{
							SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
							value = new SnmpNetworkAddressType ( *ipAddress ) ;

							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DISPLAYSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthDisplayStringType ( fixed ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;

									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpFixedLengthDisplayStringType ( fixed , *octetString ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpDisplayStringType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpDisplayStringType ( *octetString , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg )
								{
									value = new SnmpDisplayStringType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpDisplayStringType ( *octetString , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_MACADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpMacAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpMacAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_PHYSADDRESS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							if ( ! valueArg )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;
									value = new SnmpFixedLengthPhysAddressType ( fixed ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
							else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
									LONG fixed = integer->GetValue () ;

									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpFixedLengthPhysAddressType ( fixed , *octetString ) ;

									status = TRUE ;
								}
								else
								{
		// Problem Here
								}
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								if ( ! valueArg )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpPhysAddressType ( rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
								{
									SnmpInstanceType *typeValue = qualifier->GetValue () ;
									if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
									{
										SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
										SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
										wchar_t *rangeValues = string->GetStringValue () ;
										value = new SnmpPhysAddressType ( *octetString , rangeValues ) ;
										delete [] rangeValues ;

										status = TRUE ;
									}
									else
									{
									}
								}
							}
							else
							{
								if ( ! valueArg )
								{
									value = new SnmpPhysAddressType ;

									status = TRUE ;
								}
								else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
								{
									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpPhysAddressType ( *octetString , NULL ) ;

									status = TRUE ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
					{
						if ( ! valueArg )
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *enumerationValues = string->GetStringValue () ;
									value = new SnmpEnumeratedType ( enumerationValues ) ;
									delete [] enumerationValues ;
									status = TRUE ;
								}
							}
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
						{
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *enumerationValues = string->GetStringValue () ;
									value = new SnmpEnumeratedType ( enumerationValues , integer->GetValue () ) ;
									delete [] enumerationValues ;
									status = TRUE ;
								}
							}
						}		
					}
					break ;

					case WBEM_INDEX_TYPE_BITS:
					{
						if ( ! valueArg )
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *bitStringValues = string->GetStringValue () ;

									value = new SnmpBitStringType ( bitStringValues ) ;
									status = TRUE ;

									delete [] bitStringValues ;
								}
							}
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
							if ( qualifier )
							{	
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *bitStringValues = string->GetStringValue () ;

									SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
									value = new SnmpBitStringType ( bitStringValues , *octetString ) ;
									status = TRUE ;

									delete [] bitStringValues ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DATETIME:					
					{
						if ( ! valueArg )
						{
							value = new SnmpDateTimeType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpDateTimeType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpOSIAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpOSIAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpUDPAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpUDPAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
					{
						if ( ! valueArg )
						{
							value = new SnmpIPXAddressType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							value = new SnmpIPXAddressType ( *octetString ) ;
							status = TRUE ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ROWSTATUS:
					{
						if ( ! valueArg )
						{
							value = new SnmpRowStatusType ;
							status = TRUE ;
						}
						else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
						{
							SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
							value = new SnmpRowStatusType ( *integer ) ;
							status = TRUE ;
						}
					}
					break ;

					default:
					{
					}
					break ;
				}
			}

			delete [] textualConvention ;
		}
	}

	if ( value )
	{
		switch ( check )
		{
			case SetValueRegardlessReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete propertyValue ;
					propertyValue = value ;
					status = FALSE ;
				}
			}
			break ;

			case SetValueRegardlessDontReturnCheck:
			{
				delete propertyValue ;
				propertyValue = value ;
			}
			break ;

			case DontSetValueReturnCheck:
			{
				if ( value->IsValid () ) 
				{
					delete value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}

			}
			break ;

			case SetValueIfCheckOk:
			{
				if ( value->IsValid () ) 
				{
					delete propertyValue ;
					propertyValue = value ;
				}
				else
				{
					delete value ;
					status = FALSE ;
				}
			}
			break ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;

}

HRESULT SetStringProp ( IWbemClassObject *a_Object , BSTR propertyName , VARIANT &t_Variant ) 
{
	HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
	return t_Result ;
}

HRESULT SetProp ( IWbemClassObject *a_Object , BSTR propertyName , VARIANT &t_Variant ) 
{
	HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
	return t_Result ;
}

#if 0

BOOL WbemSnmpProperty :: SetDWORD ( BOOL a_Status , IWbemObjectAccess *a_Object , DWORD a_Value , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WriteDWORD (

					GetHandle (),
					a_Value
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WriteDWORD (

				GetHandle (),
				a_Value
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WriteDWORD (

					GetHandle (),
					a_Value
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetNULL ( BOOL a_Status , IWbemObjectAccess *a_Object , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					0 ,
					NULL
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WritePropertyValue (

				GetHandle () ,
				0 ,
				NULL
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					0 ,
					NULL
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetSTRING ( BOOL a_Status , IWbemObjectAccess *a_Object , wchar_t *t_Value , ULONG t_ValueLength , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WritePropertyValue (

				GetHandle () ,
				t_Value ,
				t_ValueLength
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetSTRINGARRAY ( BOOL a_Status , IWbemObjectAccess *a_Object , wchar_t **t_Value , ULONG t_ValueLength , WbemPropertyValueCheck check )
{
	BOOL status = a_Status ;

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
			HRESULT result = a_Object->WritePropertyValue (

				GetHandle () ,
				t_Value ,
				t_ValueLength
			);

			status = TRUE ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
				HRESULT result = a_Object->WritePropertyValue (

					GetHandle () ,
					t_Value ,
					t_ValueLength
				);

				status = SUCCEEDED (result) ;
			}
		}
		break ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: SetValue ( IWbemObjectAccess *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg )" ) ) 

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	switch ( GetTextualConvention () )
	{
		case WBEM_INDEX_TYPE_INTEGER:
		case WBEM_INDEX_TYPE_INTEGER32:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) )
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)integer->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER:
		case WBEM_INDEX_TYPE_COUNTER32:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpCounter ) )
			{
				SnmpCounter *counter = ( SnmpCounter * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)counter->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER64:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				SnmpCounter64 *counter = ( SnmpCounter64 * ) valueArg ;
				SnmpCounter64Type t_Counter ( *counter ) ;
				wchar_t *value = t_Counter.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;

				status = TRUE ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_UNSIGNED32:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpUInteger32 ) )
			{
				SnmpUInteger32 *ui_integer32 = ( SnmpUInteger32 * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)ui_integer32->GetValue () , check ) ;
			}
		}
		break;

		case WBEM_INDEX_TYPE_GAUGE:
		case WBEM_INDEX_TYPE_GAUGE32:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpGauge ) )
			{
				SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)gauge->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OCTETSTRING:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthOctetStringType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOctetStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;
							}
							else
							{
							}
						}
						else 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpOctetStringType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
				else
				{
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpObjectIdentifier ) ) 
			{
				SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) valueArg ;
				SnmpObjectIdentifierType objectIdentifierType ( *objectIdentifier ) ;
				wchar_t *value = objectIdentifierType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NULL:
		{
			status = SetNull ( status , a_Object , check ) ;
		}
		break ;

		case WBEM_INDEX_TYPE_IPADDRESS:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpIpAddressType ipAddressType ( *ipAddress ) ;

				wchar_t *value = ipAddressType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_TIMETICKS:
		{
			if ( ! valueArg )
			{	
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpTimeTicks ) ) 
			{
				SnmpTimeTicks *timeTicks = ( SnmpTimeTicks * ) valueArg ;
				status = SetDWORD ( status , a_Object , (DWORD)timeTicks->GetValue () , check ) ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OPAQUE:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpFixedLengthOpaqueType opaqueType ( fixed , *opaque ) ;
							wchar_t *value = opaqueType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOpaqueType opaqueType ( *opaque , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = opaqueType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpOpaqueType opaqueType ( *opaque , NULL ) ;

							wchar_t *value = opaqueType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NETWORKADDRESS:
		{
			if ( ! valueArg ) 
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpNetworkAddressType ipAddressType ( *ipAddress ) ;
				wchar_t *value = ipAddressType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DISPLAYSTRING:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;

							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthDisplayStringType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpDisplayStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpDisplayStringType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_MACADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpMacAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_PHYSADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthPhysAddressType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpPhysAddressType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
								delete [] value ;

								status = TRUE ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpPhysAddressType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
							delete [] value ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;

			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *enumerationValues = string->GetStringValue () ;
						SnmpEnumeratedType integerType ( enumerationValues , integer->GetValue () ) ;
						delete [] enumerationValues ;

						wchar_t *value = integerType.GetStringValue () ;
						status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
						delete [] value ;
					}
				}
			}		
		}
		break ;

		case WBEM_INDEX_TYPE_BITS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *bitStringValues = string->GetStringValue () ;

						SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
						SnmpBitStringType octetStringType ( bitStringValues , *octetString ) ;
						delete [] bitStringValues ;

						wchar_t **array ;
						LONG count = octetStringType.GetValue ( array ) ;

						SAFEARRAY *safeArray ;
						SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
						safeArrayBounds[0].lLbound = 0 ;
						safeArrayBounds[0].cElements = count ;

						safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

						for ( LONG index = 0 ; index < count ; index ++ )
						{
							BSTR element = SysAllocString ( array [ index ] ) ;
							SafeArrayPutElement ( safeArray , & index , element ) ;
							SysFreeString ( element ) ;
							delete [] ( array [ index ] ) ;
						}

						delete [] array ;

						t_Variant.vt = t_VarType = VT_ARRAY | VT_BSTR ;
						t_Variant.parray = safeArray ; 

						status = TRUE ;
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DATETIME:					
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpDateTimeType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpOSIAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;				
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpUDPAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpIPXAddressType octetStringType ( *octetString ) ;

				wchar_t *value = octetStringType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ROWSTATUS:
		{
			if ( ! valueArg )
			{
				status = SetNull ( status , a_Object , check ) ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				SnmpRowStatusType integerType ( *integer ) ;

				wchar_t *value = integerType.GetStringValue () ;
				status = SetSTRING ( status , a_Object , value , wcslen ( value ) , check ) ;
				delete [] value ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	return status ;
}

#endif

BOOL WbemSnmpProperty :: SetValue ( IWbemClassObject *a_Object , const SnmpValue *valueArg , WbemPropertyValueCheck check ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: SetValue ( const SnmpValue *valueArg )" ) ) 

	VARIANT t_Variant ;
	VariantInit ( & t_Variant ) ;
	VARTYPE t_VarType = VT_NULL ;

	BOOL status = FALSE ;
	SnmpInstanceType *value = NULL ;

	switch ( GetTextualConvention () )
	{
		case WBEM_INDEX_TYPE_INTEGER:
		case WBEM_INDEX_TYPE_INTEGER32:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_I4 ;
				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) )
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_VALUE ) ;
				if ( qualifier ) 
				{
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *rangeValues = string->GetStringValue () ;
						SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
						SnmpIntegerType integerType ( *integer , rangeValues ) ;
						delete [] rangeValues ;

						t_Variant.vt = t_VarType = VT_I4 ;
						t_Variant.lVal = integer->GetValue () ;

						status = integerType.SnmpInstanceType :: IsValid () ;
					}
				}
				else
				{
					SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
					t_Variant.vt = t_VarType = VT_I4 ;
					t_Variant.lVal = integer->GetValue () ;
					status = TRUE ;
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER:
		case WBEM_INDEX_TYPE_COUNTER32:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_I4 ;
				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpCounter ) )
			{
				SnmpCounter *counter = ( SnmpCounter * ) valueArg ;

				t_Variant.vt = VT_I4 ;
				t_VarType = VT_UI4 ;
				t_Variant.lVal = counter->GetValue () ;

				status = TRUE ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_COUNTER64:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;
				status = TRUE ;
			}
			else
			{
				SnmpCounter64 *counter = ( SnmpCounter64 * ) valueArg ;
				SnmpCounter64Type t_Counter ( *counter ) ;
				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = t_Counter.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = TRUE ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_UNSIGNED32:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_UI4 ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpUInteger32 ) )
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_VALUE ) ;
				if ( qualifier ) 
				{
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *rangeValues = string->GetStringValue () ;
						SnmpUInteger32 *ui_integer32 = ( SnmpUInteger32 * ) valueArg ;
						SnmpUInteger32Type ui_integer32Type ( *ui_integer32 , rangeValues ) ;
						delete [] rangeValues ;

						t_Variant.vt = VT_I4 ;
						t_VarType = VT_UI4 ;
						t_Variant.lVal = ui_integer32->GetValue () ;

						status = ui_integer32Type.SnmpInstanceType :: IsValid () ;
					}
				}
				else
				{
					SnmpUInteger32 *ui_integer32 = ( SnmpUInteger32 * ) valueArg ;
					SnmpUInteger32Type ui_integer32Type ( *ui_integer32 , NULL ) ;
					t_Variant.vt = VT_I4 ;
					t_VarType = VT_UI4 ;
					t_Variant.lVal = ui_integer32->GetValue () ;

					status = TRUE ;
				}
			}
		}
		break;

		case WBEM_INDEX_TYPE_GAUGE:
		case WBEM_INDEX_TYPE_GAUGE32:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_UI4 ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpGauge ) )
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_VALUE ) ;
				if ( qualifier ) 
				{
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *rangeValues = string->GetStringValue () ;
						SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
						SnmpGaugeType gaugeType ( *gauge , rangeValues ) ;
						delete [] rangeValues ;

						t_Variant.vt = VT_I4 ;
						t_VarType = VT_UI4 ;
						t_Variant.lVal = gauge->GetValue () ;

						status = gaugeType.SnmpInstanceType :: IsValid () ;
					}
				}
				else
				{
					SnmpGauge *gauge = ( SnmpGauge * ) valueArg ;
					SnmpGaugeType gaugeType ( *gauge , NULL ) ;
					t_Variant.vt = VT_I4 ;
					t_VarType = VT_UI4 ;
					t_Variant.lVal = gauge->GetValue () ;

					status = TRUE ;
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OCTETSTRING:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;

							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthOctetStringType octetStringType ( fixed , *octetString ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							t_Variant.vt = t_VarType = VT_BSTR ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOctetStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								t_Variant.vt = t_VarType = VT_BSTR ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
							}
						}
						else 
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpOctetStringType octetStringType ( *octetString , NULL ) ;

							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							t_Variant.vt = t_VarType = VT_BSTR ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
					}
				}
				else
				{
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpObjectIdentifier ) ) 
			{
				SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) valueArg ;
				SnmpObjectIdentifierType objectIdentifierType ( *objectIdentifier ) ;
				wchar_t *value = objectIdentifierType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				t_Variant.vt = t_VarType = VT_BSTR ;
				delete [] value ;

				status = objectIdentifierType.IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NULL:
		{
			t_Variant.vt = t_VarType = VT_NULL ;
			status = TRUE ;
		}
		break ;

		case WBEM_INDEX_TYPE_IPADDRESS:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpIpAddressType ipAddressType ( *ipAddress ) ;

				wchar_t *value = ipAddressType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				t_Variant.vt = t_VarType = VT_BSTR ;
				delete [] value ;

				status = ipAddressType.IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_TIMETICKS:
		{
			if ( ! valueArg )
			{	
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_UI4 ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpTimeTicks ) ) 
			{
				SnmpTimeTicks *timeTicks = ( SnmpTimeTicks * ) valueArg ;
				SnmpTimeTicksType timeTicksType ( *timeTicks ) ;
				t_Variant.vt = VT_I4 ;
				t_VarType = VT_UI4 ;
				t_Variant.lVal = timeTicksType.GetValue () ;

				status = timeTicksType.IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_OPAQUE:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOpaque ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;

							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpFixedLengthOpaqueType opaqueType ( fixed , *opaque ) ;
							wchar_t *value = opaqueType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							t_Variant.vt = t_VarType = VT_BSTR ;

							delete [] value ;

							status = opaqueType.SnmpInstanceType :: IsValid () ;
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpOpaqueType opaqueType ( *opaque , rangeValues ) ;
								delete [] rangeValues ;

								wchar_t *value = opaqueType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								t_Variant.vt = t_VarType = VT_BSTR ;

								delete [] value ;

								status = opaqueType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOpaque *opaque = ( SnmpOpaque * ) valueArg ;
							SnmpOpaqueType opaqueType ( *opaque , NULL ) ;

							wchar_t *value = opaqueType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							t_Variant.vt = t_VarType = VT_BSTR ;

							delete [] value ;

							status = opaqueType.SnmpInstanceType :: IsValid () ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_NETWORKADDRESS:
		{
			if ( ! valueArg ) 
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpIpAddress ) ) 
			{
				SnmpIpAddress *ipAddress = ( SnmpIpAddress * ) valueArg ;
				SnmpNetworkAddressType ipAddressType ( *ipAddress ) ;
				wchar_t *value = ipAddressType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				t_Variant.vt = t_VarType = VT_BSTR ;
				delete [] value ;

				status = ipAddressType.IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DISPLAYSTRING:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;
				status = TRUE ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;

							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthDisplayStringType octetStringType ( fixed , *octetString ) ;

							t_Variant.vt = t_VarType = VT_BSTR ;
							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpDisplayStringType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								t_Variant.vt = t_VarType = VT_BSTR ;
								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpDisplayStringType octetStringType ( *octetString , NULL ) ;

							t_Variant.vt = t_VarType = VT_BSTR ;
							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_MACADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpMacAddressType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_PHYSADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;
				status = TRUE ;
			}
			else
			{
				if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) )
				{
					WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
					if ( qualifier )
					{	
						SnmpInstanceType *typeValue = qualifier->GetValue () ;
						if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
							LONG fixed = integer->GetValue () ;
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpFixedLengthPhysAddressType octetStringType ( fixed , *octetString ) ;

							t_Variant.vt = t_VarType = VT_BSTR ;
							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
						else
						{
// Problem Here
						}
					}
					else
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
						if ( qualifier ) 
						{
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *rangeValues = string->GetStringValue () ;
								SnmpPhysAddressType octetStringType ( *octetString , rangeValues ) ;
								delete [] rangeValues ;

								t_Variant.vt = t_VarType = VT_BSTR ;
								wchar_t *value = octetStringType.GetStringValue () ;
								t_Variant.bstrVal = SysAllocString ( value ) ;
								delete [] value ;

								status = octetStringType.SnmpInstanceType :: IsValid () ;
							}
							else
							{
							}
						}
						else
						{
							SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
							SnmpPhysAddressType octetStringType ( *octetString , NULL ) ;

							t_Variant.vt = t_VarType = VT_BSTR ;
							wchar_t *value = octetStringType.GetStringValue () ;
							t_Variant.bstrVal = SysAllocString ( value ) ;
							delete [] value ;

							status = octetStringType.SnmpInstanceType :: IsValid () ;
						}
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;
				status = TRUE ;

			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *enumerationValues = string->GetStringValue () ;
						SnmpEnumeratedType integerType ( enumerationValues , integer->GetValue () ) ;
						delete [] enumerationValues ;

						t_Variant.vt = t_VarType = VT_BSTR ;
						wchar_t *value = integerType.GetStringValue () ;
						t_Variant.bstrVal = SysAllocString ( value ) ;
						delete [] value ;

						status = integerType.SnmpInstanceType :: IsValid () ;
					}
				}
			}		
		}
		break ;

		case WBEM_INDEX_TYPE_BITS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
				if ( qualifier )
				{	
					SnmpInstanceType *typeValue = qualifier->GetValue () ;
					if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
					{
						SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
						wchar_t *bitStringValues = string->GetStringValue () ;

						SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
						SnmpBitStringType octetStringType ( bitStringValues , *octetString ) ;
						delete [] bitStringValues ;

						wchar_t **array ;
						LONG count = octetStringType.GetValue ( array ) ;

						SAFEARRAY *safeArray ;
						SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
						safeArrayBounds[0].lLbound = 0 ;
						safeArrayBounds[0].cElements = count ;

						safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

						for ( LONG index = 0 ; index < count ; index ++ )
						{
							BSTR element = SysAllocString ( array [ index ] ) ;
							SafeArrayPutElement ( safeArray , & index , element ) ;
							SysFreeString ( element ) ;
							delete [] ( array [ index ] ) ;
						}

						delete [] array ;

						t_Variant.vt = t_VarType = VT_ARRAY | VT_BSTR ;
						t_Variant.parray = safeArray ; 

						status = octetStringType.SnmpInstanceType :: IsValid () ;
					}
				}
			}
		}
		break ;

		case WBEM_INDEX_TYPE_DATETIME:					
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpDateTimeType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpOSIAddressType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpUDPAddressType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpOctetString ) ) 
			{
				SnmpOctetString *octetString = ( SnmpOctetString * ) valueArg ;
				SnmpIPXAddressType octetStringType ( *octetString ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = octetStringType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = octetStringType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		case WBEM_INDEX_TYPE_ROWSTATUS:
		{
			if ( ! valueArg )
			{
				t_Variant.vt = VT_NULL ;
				t_VarType = VT_BSTR ;

				status = TRUE ;
			}
			else if ( typeid ( *valueArg ) == typeid ( SnmpInteger ) ) 
			{
				SnmpInteger *integer = ( SnmpInteger * ) valueArg ;
				SnmpRowStatusType integerType ( *integer ) ;

				t_Variant.vt = t_VarType = VT_BSTR ;
				wchar_t *value = integerType.GetStringValue () ;
				t_Variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;

				status = integerType.SnmpInstanceType :: IsValid () ;
			}
		}
		break ;

		default:
		{
		}
		break ;
	}

	switch ( check )
	{
		case SetValueRegardlessReturnCheck:
		{
#if 0
			switch ( GetTextualConvention () )
			{
				case WBEM_INDEX_TYPE_OCTETSTRING:
				{
					HRESULT t_Result = SetStringProp ( a_Object , propertyName , t_Variant ) ;
					if ( FAILED ( t_Result ) )
					{
						status = FALSE ;
					}
				}
				break ;

				default:
				{
					HRESULT t_Result = SetProp ( a_Object , propertyName , t_Variant ) ;
					if ( FAILED ( t_Result ) )
					{
						status = FALSE ;
					}
				}
				break ;
			}
#else
			HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
			if ( FAILED ( t_Result ) )
			{
				status = FALSE ;
			}
#endif
		}
		break ;

		case SetValueRegardlessDontReturnCheck:
		{
#if 1 
			HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
#else
			HRESULT t_Result = SetProp ( a_Object , propertyName , t_Variant ) ;
#endif

			status = SUCCEEDED ( t_Result ) ;
		}
		break ;

		case DontSetValueReturnCheck:
		{
		}
		break ;

		case SetValueIfCheckOk:
		{
			if ( status ) 
			{
#if 1 
				HRESULT t_Result = a_Object->Put ( propertyName , 0 , &t_Variant , 0 ) ;
#else
				HRESULT t_Result = SetProp ( a_Object , propertyName , t_Variant ) ;
#endif
				status = SUCCEEDED ( t_Result ) ;
			}
		}
		break ;
	}

	VariantClear ( & t_Variant ) ;

	return status ;

}

BOOL WbemSnmpProperty :: Encode ( const VARIANT &variant , SnmpObjectIdentifier &a_Encode )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: Encode ( const VARIANT &variant )" ) ) 

	BOOL t_Status = FALSE ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			ULONG qualifierIndex ;
			if ( textualConventionMap.Lookup ( textualConvention , qualifierIndex ) )
			{
				switch ( qualifierIndex )
				{
					case WBEM_INDEX_TYPE_INTEGER:
					case WBEM_INDEX_TYPE_INTEGER32:
					{		
						if ( variant.vt == VT_I4 )
						{
							SnmpIntegerType t_Integer ( variant.lVal , NULL ) ;
							a_Encode = t_Integer.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER:
					case WBEM_INDEX_TYPE_COUNTER32:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpCounterType t_Counter ( variant.lVal ) ;
							a_Encode = t_Counter.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_COUNTER64:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpCounter64Type t_Counter ( variant.bstrVal ) ;
							a_Encode = t_Counter.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_UNSIGNED32:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpUInteger32Type t_UIInteger32 ( variant.lVal , NULL ) ;
							a_Encode = t_UIInteger32.Encode ( a_Encode ) ;
						}
					}
					break;

					case WBEM_INDEX_TYPE_GAUGE:
					case WBEM_INDEX_TYPE_GAUGE32:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpGaugeType t_Gauge ( variant.lVal , NULL ) ;
							a_Encode = t_Gauge.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OCTETSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthOctetStringType t_Octet ( fixed , variant.bstrVal ) ;
									a_Encode = t_Octet.Encode ( a_Encode ) ;
								}
							}
							else
							{
// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpOctetStringType t_Octet ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_Octet.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpOctetStringType t_Octet ( variant.bstrVal , NULL ) ;
									a_Encode = t_Octet.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OBJECTIDENTIFIER:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpObjectIdentifierType t_ObjectIdentifier ( variant.bstrVal ) ;
							a_Encode = t_ObjectIdentifier.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NULL:
					{
					}
					break;

					case WBEM_INDEX_TYPE_IPADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpIpAddressType t_IpAddress ( variant.bstrVal ) ;
							a_Encode = t_IpAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_TIMETICKS:
					{
						if ( variant.vt == VT_I4 )
						{
							SnmpTimeTicksType t_TimeTicks ( variant.lVal ) ;
							a_Encode = t_TimeTicks.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_OPAQUE:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthOpaqueType t_Opaque ( fixed , variant.bstrVal ) ;
									a_Encode = t_Opaque.Encode ( a_Encode ) ;
								}
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpOpaqueType t_Opaque ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_Opaque.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpOpaqueType t_Opaque ( variant.bstrVal , NULL ) ;
									a_Encode = t_Opaque.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_NETWORKADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpNetworkAddressType t_NetworkAddress ( variant.bstrVal ) ;
							a_Encode = t_NetworkAddress.Encode ( a_Encode ) ;

						}
					}
					break ;

					case WBEM_INDEX_TYPE_DISPLAYSTRING:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthDisplayStringType t_DisplayString ( fixed , variant.bstrVal ) ;
									a_Encode = t_DisplayString.Encode ( a_Encode ) ;
								}
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpDisplayStringType t_DisplayString ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_DisplayString.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpDisplayStringType t_DisplayString ( variant.bstrVal , NULL ) ;
									a_Encode = t_DisplayString.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_MACADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpMacAddressType t_MacAddress ( variant.bstrVal ) ;
							a_Encode = t_MacAddress.Encode ( a_Encode ) ;

						}
					}
					break ;

					case WBEM_INDEX_TYPE_PHYSADDRESS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_FIXED_LENGTH ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) typeValue ;
								LONG fixed = integer->GetValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpFixedLengthPhysAddressType t_PhysAddress ( fixed , variant.bstrVal ) ;
									a_Encode = t_PhysAddress.Encode ( a_Encode ) ;
								}
							}
							else
							{
	// Problem Here
							}
						}
						else
						{
							WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_VARIABLE_LENGTH ) ;
							if ( qualifier ) 
							{
								SnmpInstanceType *typeValue = qualifier->GetValue () ;
								if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
								{
									SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
									wchar_t *rangeValues = string->GetStringValue () ;

									if ( variant.vt == VT_BSTR )
									{
										SnmpPhysAddressType t_PhysAddress ( variant.bstrVal , rangeValues ) ;
										a_Encode = t_PhysAddress.Encode ( a_Encode ) ;
									}

									delete [] rangeValues ;
								}
								else
								{
								}
							}
							else
							{
								if ( variant.vt == VT_BSTR )
								{
									SnmpPhysAddressType t_PhysAddress ( variant.bstrVal , NULL ) ;
									a_Encode = t_PhysAddress.Encode ( a_Encode ) ;
								}
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ENUMERATEDINTEGER:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENUMERATION ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *enumerationValues = string->GetStringValue () ;

								if ( variant.vt == VT_BSTR )
								{
									SnmpEnumeratedType t_Enumeration ( enumerationValues , variant.bstrVal ) ;
									a_Encode = t_Enumeration.Encode ( a_Encode ) ;
;								}

								delete [] enumerationValues ;
							}
						}
					}	
					break ;

					case WBEM_INDEX_TYPE_BITS:
					{
						WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_BITS ) ;
						if ( qualifier )
						{	
							SnmpInstanceType *typeValue = qualifier->GetValue () ;
							if ( typeid ( *typeValue ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *string = ( SnmpDisplayStringType * ) typeValue ;
								wchar_t *bitStringValues = string->GetStringValue () ;

								if ( variant.vt == ( VT_BSTR | VT_ARRAY ) )
								{
									if ( SafeArrayGetDim ( variant.parray ) == 1 )
									{
										LONG dimension = 1 ; 
										LONG lower ;
										SafeArrayGetLBound ( variant.parray , dimension , & lower ) ;
										LONG upper ;
										SafeArrayGetUBound ( variant.parray , dimension , & upper ) ;
										LONG count = ( upper - lower ) + 1 ;

										wchar_t **array = new wchar_t * [ count ] ;

										for ( LONG elementIndex = lower ; elementIndex <= upper ; elementIndex ++ )
										{
											BSTR element ;
											SafeArrayGetElement ( variant.parray , &elementIndex , & element ) ;

											array [ elementIndex - lower ] = element ;
										}

										SnmpBitStringType t_BitString ( bitStringValues , ( const wchar_t ** ) array , count ) ;
										a_Encode = t_BitString.Encode ( a_Encode ) ;

										for ( elementIndex = 0 ; elementIndex < count ; elementIndex ++ )
										{
											SysFreeString ( array [ elementIndex ] ) ;
										}

										delete [] array ;
									}
								}

								delete [] bitStringValues ;
							}
						}
					}
					break ;

					case WBEM_INDEX_TYPE_DATETIME:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpDateTimeType t_DateTime ( variant.bstrVal ) ;
							a_Encode = t_DateTime.SnmpOctetStringType :: Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPOSIADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpOSIAddressType t_OSIAddress ( variant.bstrVal ) ;
							a_Encode = t_OSIAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPUDPADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpUDPAddressType t_UDPAddress ( variant.bstrVal ) ;
							a_Encode = t_UDPAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_SNMPIPXADDRESS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpIPXAddressType t_IPXAddress ( variant.bstrVal ) ;
							a_Encode = t_IPXAddress.Encode ( a_Encode ) ;
						}
					}
					break ;

					case WBEM_INDEX_TYPE_ROWSTATUS:
					{
						if ( variant.vt == VT_BSTR )
						{
							SnmpRowStatusType t_RowStatus ( variant.bstrVal ) ;
							a_Encode = t_RowStatus.Encode ( a_Encode ) ;
						}
					}
					break ;

					default:
					{
					}
					break ;

				}
			}
		}

		delete [] textualConvention ;
	}

	return t_Status ;

}
wchar_t *WbemSnmpProperty :: GetName () const 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( 

		__FILE__,__LINE__,L"WbemSnmpProperty :: GetName ( (%s) )" ,
		propertyName 
	) 
) 

	return propertyName ;
}

SnmpInstanceType *WbemSnmpProperty :: GetValue () const 
{
DebugMacro7( 

	wchar_t *t_StringValue = ( propertyValue ) ? propertyValue->GetStringValue () : NULL ;
	if ( t_StringValue )
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: GetValue ( (%s),(%s) )" ,
			propertyName ,
			t_StringValue 
		) ;
	}
	else
	{
		SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

			__FILE__,__LINE__,
			L"WbemSnmpProperty :: GetValue ( (%s),(NULL) )" ,
			propertyName 
		) ;
	}	

	delete [] t_StringValue ;
) 

	return propertyValue ;
}

BOOL WbemSnmpProperty :: GetValue ( VARIANT &variant , CIMTYPE& cimType ) const 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: GetValue ( VARIANT &variant )" ) ) 

	BOOL status = FALSE ;

	if ( propertyValue )
	{
		if ( typeid ( *propertyValue ) == typeid ( SnmpIntegerType ) )
		{
			SnmpIntegerType *integer = ( SnmpIntegerType * ) propertyValue ;
			if ( integer->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = integer->GetValue () ;
			}

			cimType = CIM_SINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpCounterType ) )
		{
			SnmpCounterType *counter = ( SnmpCounterType * ) propertyValue ;
			if ( counter->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = counter->GetValue () ;
			}
			
			cimType = CIM_UINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpCounter64Type ) )
		{
			SnmpCounter64Type *counter = ( SnmpCounter64Type * ) propertyValue ;
			if ( counter->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = counter->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpGaugeType ) )
		{
			SnmpGaugeType *gauge = ( SnmpGaugeType * ) propertyValue ;
			if ( gauge->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = gauge->GetValue () ;
			}

			cimType = CIM_UINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpFixedLengthOctetStringType ) )
		{
			SnmpFixedLengthOctetStringType *octetString = ( SnmpFixedLengthOctetStringType * ) propertyValue ;
			if ( octetString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = octetString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpOctetStringType ) ) 
		{
			SnmpOctetStringType *octetString = ( SnmpOctetStringType * ) propertyValue ;
			if ( octetString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = octetString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpObjectIdentifierType ) ) 
		{
			SnmpObjectIdentifierType *objectIdentifier = ( SnmpObjectIdentifierType * ) propertyValue ;
			if ( objectIdentifier->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = objectIdentifier->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpNullType ) ) 
		{
			variant.vt = VT_NULL ;
			cimType = CIM_EMPTY;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpIpAddressType ) ) 
		{
			SnmpIpAddressType *ipAddress = ( SnmpIpAddressType * ) propertyValue ;
			if ( ipAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}			
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = ipAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpTimeTicksType ) ) 
		{
			SnmpTimeTicksType *timeTicks = ( SnmpTimeTicksType * ) propertyValue ;
			if ( timeTicks->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_I4 ;
				variant.lVal = timeTicks->GetValue () ;
			}

			cimType = CIM_SINT32;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpFixedLengthOpaqueType ) )
		{
			SnmpFixedLengthOpaqueType *opaque = ( SnmpFixedLengthOpaqueType * ) propertyValue ;
			if ( opaque->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = opaque->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpOpaqueType ) ) 
		{
			SnmpOpaqueType *opaque = ( SnmpOpaqueType * ) propertyValue ;
			if ( opaque->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = opaque->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpNetworkAddressType ) ) 
		{
			SnmpNetworkAddressType *networkAddress = ( SnmpNetworkAddressType * ) propertyValue ;
			if ( networkAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = networkAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpFixedLengthDisplayStringType ) )
		{
			SnmpFixedLengthDisplayStringType *displayString = ( SnmpFixedLengthDisplayStringType * ) propertyValue ;
			if ( displayString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = displayString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpDisplayStringType ) ) 
		{
			SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) propertyValue ;
			if ( displayString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = displayString->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpMacAddressType ) ) 
		{
			SnmpMacAddressType *macAddress = ( SnmpMacAddressType * ) propertyValue ;
			if ( macAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = macAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}
				
			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpPhysAddressType ) ) 
		{
			SnmpPhysAddressType *physAddress = ( SnmpPhysAddressType * ) propertyValue ;
			if ( physAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = physAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpEnumeratedType ) ) 
		{
			SnmpEnumeratedType *enumeration = ( SnmpEnumeratedType * ) propertyValue ;
			if ( enumeration->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = enumeration->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpBitStringType ) ) 
		{
			SnmpBitStringType *bitString = ( SnmpBitStringType * ) propertyValue ;
			if ( bitString->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				wchar_t **array ;
				LONG count = bitString->GetValue ( array ) ;

				SAFEARRAY *safeArray ;
				SAFEARRAYBOUND safeArrayBounds [ 1 ] ;
				safeArrayBounds[0].lLbound = 0 ;
				safeArrayBounds[0].cElements = count ;

				safeArray = SafeArrayCreate ( VT_BSTR , 1 , safeArrayBounds ) ;

				for ( LONG index = 0 ; index < count ; index ++ )
				{
					BSTR element = SysAllocString ( array [ index ] ) ;
					SafeArrayPutElement ( safeArray , & index , element ) ;
					SysFreeString ( element ) ;
					delete [] ( array [ index ] ) ;
				}

				delete [] array ;

				variant.vt = VT_ARRAY | VT_BSTR ;
				variant.parray = safeArray ; 
			}
			
			cimType = CIM_STRING | CIM_FLAG_ARRAY;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpDateTimeType ) ) 
		{
			SnmpDateTimeType *dateTime = ( SnmpDateTimeType * ) propertyValue ;
			if ( dateTime->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = dateTime->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpOSIAddressType ) ) 
		{
			SnmpOSIAddressType *osiAddress = ( SnmpOSIAddressType * ) propertyValue ;
			if ( osiAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = osiAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpUDPAddressType ) ) 
		{
			SnmpUDPAddressType *udpAddress = ( SnmpUDPAddressType * ) propertyValue ;
			if ( udpAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{
				variant.vt = VT_BSTR ;
				wchar_t *value = udpAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpIPXAddressType ) ) 
		{
			SnmpIPXAddressType *ipxAddress = ( SnmpIPXAddressType * ) propertyValue ;
			if ( ipxAddress->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{		
				variant.vt = VT_BSTR ;
				wchar_t *value = ipxAddress->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
		else if ( typeid ( *propertyValue ) == typeid ( SnmpRowStatusType ) ) 
		{
			SnmpRowStatusType *rowStatus = ( SnmpRowStatusType * ) propertyValue ;
			if ( rowStatus->IsNull () )
			{
				variant.vt = VT_NULL ;
			}
			else
			{		
				variant.vt = VT_BSTR ;
				wchar_t *value = rowStatus->GetStringValue () ;
				variant.bstrVal = SysAllocString ( value ) ;
				delete [] value ;
			}

			cimType = CIM_STRING;
			status = TRUE ;
		}
	}

	return status ;
}

VARTYPE WbemSnmpProperty :: GetValueVariantType () const
{
	VARTYPE varType = VT_NULL ;

	if ( propertyValue && ! ( propertyValue->IsNull () ) )
	{
		varType = GetValueVariantEncodedType () ;
	}
	else
	{
		VT_NULL ;
	}

	return varType ;
}

VARTYPE WbemSnmpProperty :: GetValueVariantEncodedType () const
{
	VARTYPE varType = VT_NULL ;

	WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) ;
	if ( qualifier )
	{	
		SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
		wchar_t *textualConvention = displayString->GetValue () ;
		if ( textualConvention )
		{ 
			if ( _wcsicmp ( textualConvention , WBEM_TYPE_INTEGER ) == 0 )
			{
				varType = VT_I4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_INTEGER32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_COUNTER ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_COUNTER32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_COUNTER64 ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_GAUGE ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_GAUGE32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_UNSIGNED32 ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_OCTETSTRING ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_OBJECTIDENTIFIER ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_NULL ) == 0 )
			{
				varType = VT_NULL ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_IPADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_TIMETICKS ) == 0 )
			{
				varType = VT_UI4 ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_OPAQUE ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_NETWORKADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_DISPLAYSTRING ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_MACADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_PHYSADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_ENUMERATEDINTEGER ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_BITS ) == 0 )
			{
				varType = VT_BSTR | VT_ARRAY ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_DATETIME ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_SNMPOSIADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_SNMPIPXADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_SNMPUDPADDRESS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else if ( _wcsicmp ( textualConvention , WBEM_TYPE_ROWSTATUS ) == 0 )
			{
				varType = VT_BSTR ;
			}
			else
			{
				WbemSnmpQualifier *qualifier = FindQualifier ( WBEM_QUALIFIER_ENCODING ) ;
				if ( qualifier )
				{	
					SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) qualifier->GetValue () ;
					wchar_t *encoding = displayString->GetValue () ;
					if ( encoding )
					{ 
						if ( _wcsicmp ( encoding , WBEM_TYPE_INTEGER ) == 0 )
						{
							varType = VT_I4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_INTEGER32 ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_COUNTER ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_COUNTER32 ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_COUNTER64 ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_GAUGE ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_GAUGE ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_UNSIGNED32 ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_OCTETSTRING ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_OBJECTIDENTIFIER ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_NULL ) == 0 )
						{
							varType = VT_NULL ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_IPADDRESS ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_TIMETICKS ) == 0 )
						{
							varType = VT_UI4 ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_OPAQUE ) == 0 )
						{
							varType = VT_BSTR ;
						}
						else if ( _wcsicmp ( encoding , WBEM_TYPE_NETWORKADDRESS ) == 0 )
						{
							varType = VT_BSTR ;
						}
					}

					delete [] encoding ;
				}
			}

			delete [] textualConvention ;
		}
	}

	return varType ;
}

BOOL WbemSnmpProperty :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{ 
	return FALSE  ; 
} 

BOOL WbemSnmpProperty :: AddQualifier ( WbemSnmpQualifier *a_qualifier )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: AddQualifier ( (%s) )" ,
		a_qualifier->GetName ()
	) ;
)

	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( a_qualifier->GetName () , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( a_qualifier->GetName () , qualifier ) )
		{
			delete a_qualifier;
		}
		else
		{
			qualifierMap [ a_qualifier->GetName () ] = a_qualifier ;
		}
	}
	else
	{
		delete a_qualifier;
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpProperty :: AddQualifier ( wchar_t *qualifierName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: AddQualifier ( (%s) )" ,
		qualifierName
	) ;
)

	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( qualifierName , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
		{
		}
		else
		{
			qualifier = new WbemSnmpQualifier ( qualifierName , NULL ) ;
			qualifierMap [ qualifier->GetName () ] = qualifier ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

ULONG WbemSnmpProperty :: GetQualifierCount () 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: GetQualifierCount" ) )

	return qualifierMap.GetCount () ;
}

void WbemSnmpProperty :: ResetQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: ResetQualifier" ) )

	qualifierPosition = qualifierMap.GetStartPosition () ;
}

WbemSnmpQualifier *WbemSnmpProperty :: NextQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpProperty :: NextQualifier" ) )

	wchar_t *qualifierKey ;
	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierPosition )
	{
		qualifierMap.GetNextAssoc ( qualifierPosition , qualifierKey , qualifier ) ;
	}

	return qualifier ;
}

WbemSnmpQualifier *WbemSnmpProperty :: FindQualifier ( wchar_t *qualifierName ) const
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpProperty :: FindQualifier (%s)" ,
		qualifierName
	) 
)

	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
	{
	}

	return qualifier ;
}

WbemSnmpClassObject :: WbemSnmpClassObject ( 

	const wchar_t *classNameArg ,
	const BOOL isClass 

) : className ( NULL ),
	qualifierPosition ( NULL ) , 
	propertyPosition ( NULL ) , 
	keyedPropertyPosition ( 1 ) , 
	m_isClass ( isClass ) , 
	m_isKeyed ( FALSE ) , 
	m_isSingleton ( FALSE ) , 
	m_isVirtual ( FALSE ) , 
	m_isReadable ( FALSE ) ,
	m_isWritable ( FALSE ) ,
	m_numberOfAccessible ( 0 )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: WbemSnmpClassObject" ) )

	className = new wchar_t [ wcslen ( classNameArg ) + 1 ] ;
	wcscpy ( className , classNameArg ) ;
}

WbemSnmpClassObject :: WbemSnmpClassObject () :	className ( NULL ) , 
													qualifierPosition ( NULL ) , 
													propertyPosition ( NULL ) , 
													keyedPropertyPosition ( 1 ) ,
													m_isClass ( TRUE ) ,
													m_isKeyed ( FALSE ) ,
													m_isSingleton ( FALSE ) ,
													m_isVirtual ( FALSE ) ,
													m_isReadable ( FALSE ) ,
													m_isWritable ( FALSE ) ,
													m_numberOfAccessible ( 0 )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: WbemSnmpClassObject" ) )

}

WbemSnmpClassObject :: WbemSnmpClassObject ( 

	const WbemSnmpClassObject & copy 

) :	className ( NULL ) , 
	qualifierPosition ( NULL ) , 
	propertyPosition ( NULL ) , 
	keyedPropertyPosition ( 1 ) ,
	m_isClass ( copy.m_isClass ) ,
	m_isKeyed ( copy.m_isKeyed ) ,
	m_isSingleton ( copy.m_isSingleton ) ,
	m_isVirtual ( copy.m_isVirtual ) ,
	m_isReadable ( copy.m_isReadable ) ,
	m_isWritable ( copy.m_isWritable ) ,
	m_numberOfAccessible ( copy.m_numberOfAccessible )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: WbemSnmpClassObject" ) )

	if ( copy.className ) 
	{
		className = new wchar_t [ wcslen ( copy.className ) + 1 ] ;
		wcscpy ( className , copy.className ) ;
	}

	POSITION position = copy.propertyMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *propertyName ;
		WbemSnmpProperty *property ;
		copy.propertyMap.GetNextAssoc ( position , propertyName , property ) ;
		
		WbemSnmpProperty *copyProperty = new WbemSnmpProperty ( *property ) ;
		propertyMap [ copyProperty->GetName () ] = copyProperty ;
	}

	position = copy.qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		copy.qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		WbemSnmpQualifier *copyQualifier = new WbemSnmpQualifier ( *qualifier ) ;
		qualifierMap [ copyQualifier->GetName () ] = copyQualifier ;
	}

	position = copy.keyedPropertyList.GetHeadPosition () ;
	while ( position )
	{
		WbemSnmpProperty *keyProperty = copy.keyedPropertyList.GetNext ( position ) ;
		WbemSnmpProperty *property ;
		if ( propertyMap.Lookup ( keyProperty->GetName () , property ) )
		{
			keyedPropertyList.AddTail ( property ) ;
		}
	}
}

WbemSnmpClassObject :: ~WbemSnmpClassObject ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ~WbemSnmpClassObject ()" ) )

	delete [] className ;

	keyedPropertyList.RemoveAll () ;

	POSITION position = propertyMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *propertyName ;
		WbemSnmpProperty *property ;
		propertyMap.GetNextAssoc ( position , propertyName , property ) ;
		
		delete property ;
	}

	propertyMap.RemoveAll () ;

	position = qualifierMap.GetStartPosition () ;
	while ( position )
	{
		wchar_t *qualifierName ;
		WbemSnmpQualifier *qualifier ;
		qualifierMap.GetNextAssoc ( position , qualifierName , qualifier ) ;
	
		delete qualifier ;
	}

	qualifierMap.RemoveAll () ;
}

void WbemSnmpClassObject :: SetKeyed ( BOOL a_isKeyed )
{
	m_isKeyed = a_isKeyed ;
}

BOOL WbemSnmpClassObject :: IsKeyed ()
{
	return m_isKeyed ;
}

void WbemSnmpClassObject :: SetSingleton ( BOOL a_isSingleton )
{
	m_isSingleton = a_isSingleton ;
}

BOOL WbemSnmpClassObject :: IsSingleton ()
{
	return m_isSingleton ;
}

void WbemSnmpClassObject :: SetVirtual ( BOOL a_isVirtual )
{
	m_isVirtual = a_isVirtual ;
}

BOOL WbemSnmpClassObject :: IsVirtual ()
{
	return m_isVirtual ;
}

BOOL WbemSnmpClassObject :: IsWritable () 
{ 
	return m_isWritable ; 
}

BOOL WbemSnmpClassObject :: IsReadable () 
{ 
	return m_isReadable ; 
}

ULONG WbemSnmpClassObject :: GetNumberOfAccessible ()
{
	return m_numberOfAccessible ;
} 

void WbemSnmpClassObject :: SetWritable ( BOOL a_isWritable )
{
	m_isWritable = a_isWritable ; 
}

void WbemSnmpClassObject :: SetReadable ( BOOL a_isReadable ) 
{
	m_isReadable = a_isReadable ; 
}

void WbemSnmpClassObject :: SetNumberOfAccessible ( ULONG a_numberOfAccessible )
{
	m_numberOfAccessible = a_numberOfAccessible ;
}

wchar_t *WbemSnmpClassObject :: GetClassName () const
{
	return className ;
}

BOOL WbemSnmpClassObject :: Check ( WbemSnmpErrorObject &a_errorObject ) 
{ 
	return FALSE ; 
} 

void WbemSnmpClassObject :: AddKeyedProperty ( WbemSnmpProperty *snmpProperty ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddKeyedProperty ( (%s) )" ,
		snmpProperty->GetName ()
	) ;
)

	WbemSnmpProperty *t_snmpProperty = FindProperty ( snmpProperty->GetName () ) ;
	if ( t_snmpProperty ) 
	{
		keyedPropertyList.AddTail ( snmpProperty ) ;
	}
}

BOOL WbemSnmpClassObject :: AddKeyedProperty ( wchar_t *propertyName ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddKeyedProperty ( (%s) )" ,
		propertyName
	) ;
)

	WbemSnmpProperty *snmpProperty = FindProperty ( propertyName ) ;
	if ( snmpProperty ) 
	{
		AddKeyedProperty ( snmpProperty ) ;
	}

	return snmpProperty ? TRUE : FALSE ;
}

ULONG WbemSnmpClassObject :: GetKeyPropertyCount ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetKeyPropertyCount" ) )

	return keyedPropertyList.GetCount () ;
}

void WbemSnmpClassObject :: ResetKeyProperty ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ResetKeyProperty" ) )

	keyedPropertyPosition = 1 ;
}

WbemSnmpProperty *WbemSnmpClassObject :: NextKeyProperty () 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextKeyProperty" ) )

	WbemSnmpProperty *property = NULL ;
	POSITION position = keyedPropertyList.GetHeadPosition () ;
	while ( position )
	{
		WbemSnmpProperty *value = keyedPropertyList.GetNext ( position ) ;
		WbemSnmpQualifier *qualifier ;
		if ( qualifier = value->FindQualifier ( WBEM_QUALIFIER_KEY_ORDER ) ) 
		{
			SnmpInstanceType *typeValue = qualifier->GetValue () ;
			if ( typeid ( *typeValue ) == typeid ( SnmpIntegerType ) )
			{
				SnmpIntegerType *integer = ( SnmpIntegerType * ) qualifier->GetValue () ;
				if ( integer->GetValue () == keyedPropertyPosition )
				{
					property = value ;
					break ;
				}
			}
			else
			{
// Problem Here

			}
		}
		else
		{
// Problem Here
		}
	}

	keyedPropertyPosition ++ ;

	return property ;
}

WbemSnmpProperty *WbemSnmpClassObject :: FindKeyProperty ( wchar_t *propertyName ) const 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: FindKeyProperty ( (%s)" ,
		propertyName
	) ;
)

	WbemSnmpProperty *property = NULL ;
	POSITION position = keyedPropertyList.GetHeadPosition () ;
	while ( position )
	{
		WbemSnmpProperty *value = keyedPropertyList.GetNext ( position ) ;
		if ( _wcsicmp ( value->GetName () , propertyName ) == 0 )
		{
			property = value ;
			break ;
		}
	}

	return property ;
}

ULONG WbemSnmpClassObject :: GetPropertyCount () 
{
	return propertyMap.GetCount () ;
}

BOOL WbemSnmpClassObject :: AddProperty ( WbemSnmpProperty *property )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddProperty ( (%s) )" ,
		property->GetName () 
	) ;
)

	propertyPosition = NULL ; 

	WbemSnmpProperty *propertyValue ;
	if ( propertyMap.Lookup ( property->GetName () , propertyValue ) ) 
	{
		delete property;
	}
	else
	{
		propertyMap [ property->GetName () ] = property ;
	}

	return TRUE ;
}

BOOL WbemSnmpClassObject :: AddProperty ( wchar_t *propertyName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddProperty ( (%s) )" ,
		propertyName
	) ;
)

	propertyPosition = NULL ; 

	WbemSnmpProperty *property ;
	if ( propertyMap.Lookup ( propertyName , property ) ) 
	{
	}
	else
	{
		property = new WbemSnmpProperty ( propertyName ) ;
		propertyMap [ property->GetName () ] = property ;
	}

	return TRUE ;
}

void WbemSnmpClassObject :: DeleteProperty ( wchar_t *propertyName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,L"WbemSnmpClassObject :: DeleteProperty ( (%s) )" ,
		propertyName
	) ;
)

	propertyPosition = NULL ; 

	WbemSnmpProperty *property ;
	if ( propertyMap.Lookup ( propertyName , property ) ) 
	{
		propertyMap.RemoveKey ( propertyName ) ;
		POSITION keyPosition = keyedPropertyList.Find ( property ) ;
		if ( keyPosition )
		{
			keyedPropertyList.RemoveAt ( keyPosition ) ;
		}
		else
		{
// Problem Here
		}

		delete property ;
	}
}

void WbemSnmpClassObject :: ResetProperty ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ResetProperty ()" ) )

	propertyPosition = propertyMap.GetStartPosition () ;
}

WbemSnmpProperty *WbemSnmpClassObject :: NextProperty ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextProperty ()" ) )

	wchar_t *propertyKey ;
	WbemSnmpProperty *property = NULL ;
	if ( propertyPosition )
	{
		propertyMap.GetNextAssoc ( propertyPosition , propertyKey , property ) ;
	}

	return property ;
}

WbemSnmpProperty *WbemSnmpClassObject :: GetCurrentProperty ()
{
	wchar_t *propertyKey ;
	WbemSnmpProperty *property = NULL ;
	if ( propertyPosition )
	{
		propertyMap.GetCurrentAssoc ( propertyPosition , propertyKey , property ) ;
	}

	return property ;	
}

BOOL WbemSnmpClassObject :: GotoProperty ( WbemSnmpProperty *property ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextProperty ()" ) )

	ResetProperty () ;

	WbemSnmpProperty *t_Property ;
	while ( t_Property = NextProperty () )
	{
		if ( t_Property == property )
		{
			return TRUE ;
		}
	}

	return FALSE ;
}

WbemSnmpProperty *WbemSnmpClassObject :: FindProperty ( wchar_t *propertyName ) const 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,L"WbemSnmpClassObject :: FindProperty (%s) " ,
		propertyName
	) ;
)

	WbemSnmpProperty *property = NULL ;
	if ( propertyMap.Lookup ( propertyName , property ) )
	{
	}

	return property ;
}

ULONG WbemSnmpClassObject :: GetQualifierCount () 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetQualifierCount ()" ) )

	return qualifierMap.GetCount () ;
}

BOOL WbemSnmpClassObject :: AddQualifier ( WbemSnmpQualifier *a_qualifier )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddQualifier ( (%s) )" ,
		a_qualifier->GetName ()
	) ;
)

	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( a_qualifier->GetName () , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( a_qualifier->GetName () , qualifier ) )
		{
			delete a_qualifier;
		}
		else
		{
			qualifierMap [ a_qualifier->GetName () ] = a_qualifier ;
		}
	}
	else
	{
		delete a_qualifier;
		status = FALSE ;
	}

	return status ;
}

BOOL WbemSnmpClassObject :: AddQualifier ( wchar_t *qualifierName )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: AddQualifier ( (%s) )" ,
		qualifierName
	) ;
)


	BOOL status = TRUE ;

	ULONG stringItem ;
	if ( validQualifierMap.Lookup ( qualifierName , stringItem ) )
	{
		qualifierPosition = NULL ;

		WbemSnmpQualifier *qualifier ;
		if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
		{
		}
		else
		{
			qualifier = new WbemSnmpQualifier ( qualifierName , NULL ) ;
			qualifierMap [ qualifier->GetName () ] = qualifier ;
		}
	}
	else
	{
		status = FALSE ;
	}

	return status ;
}

void WbemSnmpClassObject :: ResetQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: ResetQualifier" ) )

	qualifierPosition = qualifierMap.GetStartPosition () ;
}

WbemSnmpQualifier *WbemSnmpClassObject :: NextQualifier ()
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: NextQualifier" ) )

	wchar_t *qualifierKey ;
	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierPosition )
	{
		qualifierMap.GetNextAssoc ( qualifierPosition , qualifierKey , qualifier ) ;
	}

	return qualifier ;
}

WbemSnmpQualifier *WbemSnmpClassObject :: FindQualifier ( wchar_t *qualifierName ) const
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: FindQualifier ( (%s) )",
		qualifierName
	) ;
)

	WbemSnmpQualifier *qualifier = NULL ;
	if ( qualifierMap.Lookup ( qualifierName , qualifier ) )
	{
	}

	return qualifier ;
}

BOOL WbemSnmpClassObject :: Set ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( 

		__FILE__,__LINE__,
		L"BOOL WbemSnmpClassObject :: Set ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )" 
	) ;
)

	BOOL result = SetMosClassObject ( a_errorObject , mosClassObject , rigorous ) ;

	return result ;
}

BOOL WbemSnmpClassObject :: SetMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( 

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: SetMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )" 
	) 
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;
	
	VARIANT variant ;
	VariantInit ( & variant ) ;

	t_WBEM_result = mosClassObject->Get ( WBEM_PROPERTY_GENUS , 0 , &variant , NULL , NULL ) ;
	if ( SUCCEEDED ( t_WBEM_result ) )
	{
		m_isClass = ( ( variant.lVal ) == WBEM_GENUS_CLASS ) ? TRUE : FALSE ;

		t_WBEM_result = mosClassObject->Get ( WBEM_PROPERTY_CLASS , 0 , &variant , NULL , NULL ) ;
		if ( SUCCEEDED ( t_WBEM_result ) )
		{
			className = new wchar_t [ wcslen ( variant.bstrVal ) + 1 ] ;
			wcscpy ( className , variant.bstrVal ) ;

			IWbemQualifierSet *classQualifierObject ;
			if ( SUCCEEDED ( mosClassObject->GetQualifierSet ( &classQualifierObject ) ) )
			{
				status = SetMosClassObjectQualifiers ( a_errorObject , classQualifierObject ) ;
				if ( status )
				{
					status = SetMosClassObjectProperties ( a_errorObject , mosClassObject , rigorous ) ;
				}

				classQualifierObject->Release () ;
			}
			else
			{
/*
 *	Failed to get qualifier set. WBEM error
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to get object qualifier set" ) ;
			}
		}
		else
		{
/*
 *	Failed to get __Class property. WBEM error
 */

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetMessage ( L"Failed to get __Class property" ) ;
		}
	}
	else
	{
/*
 * Failed to get __Genus property. WBEM error
 */

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get __Genus property" ) ;
	}


/*
 *
 */

	if ( status )
	{
		if ( IsKeyed () )
		{
// Iterate through keys checking order is as expected

			ULONG keyPropertyCount = 0 ;

			ULONG keyOrder = 1 ;
			while ( keyOrder <= GetKeyPropertyCount () )
			{
				WbemSnmpProperty *property ;
				ResetProperty () ;
				while ( status && ( property = NextProperty () ) )
				{
					if ( property->IsKey () )
					{
						if ( keyOrder != property->GetKeyOrder () )
						{
						}
						else 
						{
	// Key order good
							keyPropertyCount ++ ;
							break ;
						}
					}
				}

				keyOrder ++ ;
			}

			if ( keyPropertyCount != GetKeyPropertyCount () )
			{
// Invalid key ordering
				status = FALSE ;

				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Class specified invalid key ordering" ) ;
			}
		}
		else
		{
// Class has no key properties 
		}
	}

	if ( status )
	{
		ULONG t_numberOfVirtuals = 0 ;
		if ( IsKeyed () && IsVirtual () )
		{
			WbemSnmpProperty *property ;
			ResetProperty () ;
			while ( property = NextProperty () )
			{
				if ( property->IsVirtualKey () )
				{
					t_numberOfVirtuals ++ ;
				}
			}
		}

		m_numberOfAccessible = GetPropertyCount () - t_numberOfVirtuals ;

		if ( m_numberOfAccessible == 0 )
		{
	// All properties are keyed,virtual

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class must contain atleast one property which is not a virtual key or inaccessible" ) ;
		}
	}

	VariantClear ( & variant ) ;

	return status ;
}

BOOL WbemSnmpClassObject :: SetMosClassObjectQualifiers ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,L"WbemSnmpClassObject :: SetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	
	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;

	classQualifierObject->BeginEnumeration ( 0 ) ;
	while ( classQualifierObject->Next ( 0 , & qualifierName , & variant , 	& qualifierFlavour ) == WBEM_NO_ERROR )
	{
		AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED  ) ;

				wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for class qualifier: " ) ;
				wchar_t *stringBuffer = UnicodeStringAppend ( temp , qualifierName ) ;
				delete [] temp ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 
			}

			if ( qualifier = FindQualifier ( WBEM_QUALIFIER_SINGLETON ) )
			{
				SnmpInstanceType *value = qualifier->GetValue () ;
				if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
				{
					SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
					SetSingleton ( integer->GetValue () ) ;
				}
				else
				{
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
					a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
					a_errorObject.SetMessage ( L"Type mismatch for class qualifier: singleton" ) ;
				}
			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}

	classQualifierObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: SetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine ( 

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: SetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	BSTR propertyName = NULL ;
	
	CIMTYPE cimType;
	mosClassObject->BeginEnumeration ( WBEM_FLAG_NONSYSTEM_ONLY ) ;
	while ( status && ( mosClassObject->Next ( 0 , &propertyName , &variant , &cimType , NULL ) == WBEM_NO_ERROR ) )
	{
		IWbemQualifierSet *propertyQualifierSet ;
		if ( ( t_WBEM_result = mosClassObject->GetPropertyQualifierSet ( propertyName , &propertyQualifierSet ) ) == WBEM_NO_ERROR ) 
		{
			VARIANT textualConventionVariant ;
			VariantInit ( &textualConventionVariant ) ;

			LONG flag;
			if ( SUCCEEDED ( propertyQualifierSet->Get ( WBEM_QUALIFIER_TEXTUAL_CONVENTION , 0 , &textualConventionVariant , &flag ) ) )
			{
				AddProperty ( propertyName ) ;
				WbemSnmpProperty *property = FindProperty ( propertyName ) ;
				if ( property )
				{
					status = SetMosClassObjectPropertyQualifiers ( a_errorObject , property , propertyQualifierSet ) ;
					if ( status )
					{
						WbemSnmpQualifier *qualifier ;
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
								if ( integer->GetValue () )
								{
									AddKeyedProperty ( propertyName ) ;
									property->SetKey () ;
									SetKeyed () ;

									if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY_ORDER ) )
									{
										SnmpInstanceType *value = qualifier->GetValue () ;
										if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
										{
											SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
											property->SetKeyOrder ( integer->GetValue () ) ;
										}
										else
										{
											wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
											wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: key_order") ;
											delete [] prefix ;
											a_errorObject.SetMessage ( stringBuffer ) ;
											delete [] stringBuffer ; 

											status = FALSE ;
											a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
											a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										}
									}
									else
									{
// Keyed property contains no key order

										wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
										wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' is defined as a key but contains no key_order qualifier") ;
										delete [] prefix ;
										a_errorObject.SetMessage ( stringBuffer ) ;
										delete [] stringBuffer ; 

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									}
								}

								if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_VIRTUAL_KEY ) )
								{
									SnmpInstanceType *value = qualifier->GetValue () ;
									if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
										if ( integer->GetValue () )
										{
											property->SetVirtualKey () ;
											SetVirtual () ;
										}
									}							
									else
									{
										wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
										wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: virtual_key") ;
										delete [] prefix ;
										a_errorObject.SetMessage ( stringBuffer ) ;
										delete [] stringBuffer ; 

										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									}
								}
							}
							else
							{
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: key") ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}
						
						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_READ ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
								if ( integer->GetValue () )
								{
									property->SetReadable () ;
									SetReadable () ;
								}
							}
							else
							{
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: read") ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}

						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_WRITE ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
							{
								SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
								if ( integer->GetValue () )
								{
									property->SetWritable () ;
									SetWritable () ;
								}
							}
							else
							{
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: write") ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}

						if ( ! property->IsVirtualKey () )
						{
							// Check Object Identifier Present

							if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ) 
							{
								SnmpInstanceType *value = qualifier->GetValue () ;
								if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
								{
								}
								else
								{
// Problem Here
									wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
									wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: object_identifier") ;
									delete [] prefix ;
									a_errorObject.SetMessage ( stringBuffer ) ;
									delete [] stringBuffer ; 

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								}
							}
							else
							{
// No Object Identifier present
								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' must specify valid qualifier for: object_identifier" ) ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							}
						}

						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_TEXTUAL_CONVENTION ) )
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpDisplayStringType ) )
							{
								SnmpDisplayStringType *displayString = ( SnmpDisplayStringType * ) value ;
								wchar_t *string = displayString->GetValue () ;

								ULONG stringItem ;
								if ( textualConventionMap.Lookup ( string , stringItem ) )
								{
									property->SetTextualConvention ( stringItem ) ;
								}

								delete [] string ;

							}							
						}

						if ( rigorous )
						{
							if ( property->SetValue ( variant , cimType , SetValueIfCheckOk ) )
							{
								IWbemObjectAccess *t_Access = NULL ;
								HRESULT result = mosClassObject->QueryInterface (

									IID_IWbemObjectAccess ,
									(void**)&t_Access 
								) ;

								if ( SUCCEEDED ( result ) )
								{
									long t_Handle ;

									
									HRESULT result = t_Access->GetPropertyHandle (

										propertyName ,
										NULL ,
										& t_Handle 
									);

									if ( SUCCEEDED ( result ) )
									{
										property->SetHandle ( t_Handle ) ;
									}

	
									t_Access->Release () ;
								}
							}
							else
							{
/*
 *	Property Expected Type and property Value Type were not the same
 */

								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

								wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for property: " ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
								delete [] temp ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 

							}
						}
						else
						{
							if ( property->SetValue ( variant , cimType , SetValueRegardlessDontReturnCheck ) )
							{
							}
							else
							{
/*
 *	Property Expected Type and property Value Type were not the same. Should not happen.
 */

								wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
								wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for property value" ) ;
								delete [] prefix ;
								a_errorObject.SetMessage ( stringBuffer ) ;
								delete [] stringBuffer ; 


								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
							}
						}
					}
				}
				else
				{
				}
			}

			VariantClear ( & textualConventionVariant ) ;

			propertyQualifierSet->Release () ;

		}
		else
		{
/*
 * Failed to get qualifier set . WBEM error
 */

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Failed to get qualifier set for: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}

		SysFreeString ( propertyName ) ;

		VariantClear ( & variant ) ;
	}

	mosClassObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: SetMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet ) 
{
	DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: SetMosClassObjectPropertyQualifiers (WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;
	propertyQualifierSet->BeginEnumeration ( 0 ) ;
	while ( status && ( propertyQualifierSet->Next ( 0 , & qualifierName , & variant , & qualifierFlavour ) == WBEM_NO_ERROR ) )
	{
		snmpProperty->AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = snmpProperty->FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

				wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , snmpProperty->GetName () ) ;
				wchar_t *suffix = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: ") ;
				delete [] prefix ;
				wchar_t *stringBuffer = UnicodeStringAppend ( suffix , qualifierName ) ;
				delete [] suffix ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 

			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}
	
	propertyQualifierSet->EndEnumeration () ;
	
	return status ;
}

BOOL WbemSnmpClassObject :: Merge ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: Merge ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )"
	) ;
)
	BOOL result = MergeMosClassObject ( a_errorObject , mosClassObject , rigorous ) ;

	return result ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObject (WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous )"
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;
	
	IWbemQualifierSet *classQualifierObject ;
	if ( SUCCEEDED ( mosClassObject->GetQualifierSet ( &classQualifierObject ) ) )
	{
		status = MergeMosClassObjectQualifiers ( a_errorObject , classQualifierObject ) ;
		if ( status )
		{
			status = MergeMosClassObjectProperties ( a_errorObject , mosClassObject , rigorous ) ;
		}

		classQualifierObject->Release () ;
	}
	else
	{
/*
 *	Failed to get qualifier set. WBEM error
 */

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get object qualifier set" ) ;
	}

/*
 *
 */

	if ( status )
	{
		if ( IsKeyed () )
		{
// Iterate through keys checking order is as expected

			ULONG keyPropertyCount = 0 ;

			ULONG keyOrder = 1 ;
			while ( keyOrder <= GetKeyPropertyCount () )
			{
				WbemSnmpProperty *property ;
				ResetProperty () ;
				while ( status && ( property = NextProperty () ) )
				{
					if ( property->IsKey () )
					{
						if ( keyOrder != property->GetKeyOrder () )
						{
						}
						else 
						{
	// Key order good
							keyPropertyCount ++ ;
							break ;
						}
					}
				}

				keyOrder ++ ;
			}

			if ( keyPropertyCount != GetKeyPropertyCount () )
			{
// Invalid key ordering
				status = FALSE ;

				a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_QUALIFIER ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
				a_errorObject.SetMessage ( L"Class specified invalid key ordering" ) ;
			}
		}
		else
		{
// Class has no key properties 
		}
	}

	if ( status )
	{
		ULONG t_numberOfVirtuals = 0 ;
		if ( IsKeyed () && IsVirtual () )
		{
			WbemSnmpProperty *property ;
			ResetProperty () ;
			while ( property = NextProperty () )
			{
				if ( property->IsVirtualKey () )
				{
					t_numberOfVirtuals ++ ;
				}
			}
		}

		m_numberOfAccessible = GetPropertyCount () - t_numberOfVirtuals ;

		if ( m_numberOfAccessible == 0 )
		{
// All properties are keyed,virtual

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_OBJECT ) ;
			a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
			a_errorObject.SetMessage ( L"Class must contain atleast one property which is not a virtual key or inaccessible" ) ;
		}
	}

	return status ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObjectQualifiers ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObjectProperties (WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	
	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;

	classQualifierObject->BeginEnumeration ( 0 ) ;
	while ( classQualifierObject->Next ( 0 , & qualifierName , & variant , & qualifierFlavour) == WBEM_NO_ERROR )
	{
		AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED  ) ;

				wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for class qualifier: " ) ;
				wchar_t *stringBuffer = UnicodeStringAppend ( temp , qualifierName ) ;
				delete [] temp ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 
			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}

	classQualifierObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject , BOOL rigorous ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObjectProperties" 
	) ;
)

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;
	BSTR propertyName = NULL ;
	
	CIMTYPE cimType ;
	mosClassObject->BeginEnumeration ( WBEM_FLAG_NONSYSTEM_ONLY ) ;
	while ( status && ( mosClassObject->Next ( 0 , &propertyName , &variant , &cimType , NULL ) == WBEM_NO_ERROR ) )
	{
		IWbemQualifierSet *propertyQualifierSet ;
		if ( ( t_WBEM_result = mosClassObject->GetPropertyQualifierSet ( propertyName , &propertyQualifierSet ) ) == WBEM_NO_ERROR ) 
		{
			WbemSnmpProperty *property = FindProperty ( propertyName ) ;
			if ( property )
			{
				status = MergeMosClassObjectPropertyQualifiers ( a_errorObject , property , propertyQualifierSet ) ;
				if ( status )
				{
					WbemSnmpQualifier *qualifier ;
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							if ( integer->GetValue () )
							{
								if ( ! FindKeyProperty ( propertyName ) )
								{
									AddKeyedProperty ( propertyName ) ;
								}

								property->SetKey () ;
								SetKeyed () ;

								if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_KEY_ORDER ) )
								{
									SnmpInstanceType *value = qualifier->GetValue () ;
									if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
									{
										SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
										property->SetKeyOrder ( integer->GetValue () ) ;
									}
									else
									{
										status = FALSE ;
										a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
										a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
										a_errorObject.SetMessage ( L"Type mismatch for qualifier: key_order" ) ;
									}
								}
								else
								{
		// Keyed property contains no key order

									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Property is defined as a key but contains no key_order qualifier" ) ;
								}
							}

							if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_VIRTUAL_KEY ) )
							{
								SnmpInstanceType *value = qualifier->GetValue () ;
								if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
								{
									SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
									if ( integer->GetValue () )
									{
										property->SetVirtualKey () ;
										SetVirtual () ;
									}
								}							
								else
								{
									status = FALSE ;
									a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
									a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
									a_errorObject.SetMessage ( L"Type mismatch for qualifier: virtual_key" ) ;
								}
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: key" ) ;
						}
					}
					
					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_READ ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							if ( integer->GetValue () )
							{
								property->SetReadable () ;
								SetReadable () ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: read" ) ;
						}

					}

					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_WRITE ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							if ( integer->GetValue () )
							{
								property->SetWritable () ;
								SetWritable () ;
							}
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: write" ) ;
						}

					}

					if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_SINGLETON ) )
					{
						SnmpInstanceType *value = qualifier->GetValue () ;
						if ( typeid ( *value ) == typeid ( SnmpIntegerType ) )
						{
							SnmpIntegerType *integer = ( SnmpIntegerType * ) value ;
							SetSingleton ( integer->GetValue () ) ;
						}
						else
						{
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Type mismatch for qualifier: singleton" ) ;
						}
					}

					if ( ! property->IsVirtualKey () )
					{
						// Check Object Identifier Present

						if ( qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ) 
						{
							SnmpInstanceType *value = qualifier->GetValue () ;
							if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
							{
							}
							else
							{
		// Problem Here
								status = FALSE ;
								a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
								a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
								a_errorObject.SetMessage ( L"Type mismatch for qualifier: object_identifier" ) ;
							}
						}
						else
						{
		// No Object Identifier present
							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_INVALID_PROPERTY ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;
							a_errorObject.SetMessage ( L"Property must specify valid qualifier for: object_identifier" ) ;
						}
					}

					if ( rigorous )
					{
						if ( property->SetValue ( variant , cimType , SetValueIfCheckOk ) )
						{
						}
						else
						{
/*
*	Property Expected Type and property Value Type were not the same
*/

							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

							wchar_t *temp = UnicodeStringDuplicate ( L"Type Mismatch for property: " ) ;
							wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
							delete [] temp ;
							a_errorObject.SetMessage ( stringBuffer ) ;
							delete [] stringBuffer ; 

						}
					}
					else
					{
						if ( property->SetValue ( variant , cimType , SetValueRegardlessDontReturnCheck ) )
						{
						}
						else
						{
/*
*	Property Expected Type and property Value Type were not the same. Should not happen.
*/

							wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , propertyName ) ;
							wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\' has type mismatch for property value" ) ;
							delete [] prefix ;
							a_errorObject.SetMessage ( stringBuffer ) ;
							delete [] stringBuffer ; 


							status = FALSE ;
							a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
							a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
						}
					}
				}
			}
			else
			{
			}

			propertyQualifierSet->Release () ;

		}
		else
		{
/*
 * Failed to get qualifier set . WBEM error
 */

			status = FALSE ;
			a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
			a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;

			wchar_t *temp = UnicodeStringDuplicate ( L"Failed to get qualifier set for: " ) ;
			wchar_t *stringBuffer = UnicodeStringAppend ( temp , propertyName ) ;
			delete [] temp ;
			a_errorObject.SetMessage ( stringBuffer ) ;
			delete [] stringBuffer ; 
		}

		SysFreeString ( propertyName ) ;

		VariantClear ( & variant ) ;
	}

	mosClassObject->EndEnumeration () ;

	return status ;
}

BOOL WbemSnmpClassObject :: MergeMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet ) 
{
DebugMacro7( 

	SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  

		__FILE__,__LINE__,
		L"WbemSnmpClassObject :: MergeMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet )" 
	) ;
)

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	BSTR qualifierName = NULL ;
	LONG qualifierFlavour = 0 ;
	propertyQualifierSet->BeginEnumeration ( 0 ) ;
	while ( status && ( propertyQualifierSet->Next ( 0 , & qualifierName , & variant , & qualifierFlavour ) == WBEM_NO_ERROR ) )
	{
		if (_wcsicmp(qualifierName, WBEM_QUALIFIER_TYPE_MISMATCH) == 0)
		{
			continue;
		}

		snmpProperty->AddQualifier ( qualifierName ) ;
		WbemSnmpQualifier *qualifier = snmpProperty->FindQualifier ( qualifierName ) ;
		if ( qualifier )
		{
			if ( qualifier->SetValue ( variant ) )
			{
			}
			else
			{
/*
 *	Qualifier Expected Type and Qualifier Value Type were not the same
 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_E_TYPE_MISMATCH ) ;
				a_errorObject.SetWbemStatus ( WBEM_E_FAILED ) ;

				wchar_t *prefix = UnicodeStringAppend ( L"Property \'" , snmpProperty->GetName () ) ;
				wchar_t *suffix = UnicodeStringAppend ( prefix , L"\' has type mismatch for qualifier: ") ;
				delete [] prefix ;
				wchar_t *stringBuffer = UnicodeStringAppend ( suffix , qualifierName ) ;
				delete [] suffix ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 
			}
		}
		else
		{
// Problem Here
		}

		SysFreeString ( qualifierName ) ;

		VariantClear ( & variant ) ;
	}
	
	propertyQualifierSet->EndEnumeration () ;
	
	return status ;
}

BOOL WbemSnmpClassObject :: Get ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: Get" ) )

	BOOL status = GetMosClassObject ( a_errorObject , mosClassObject ) ;

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObject ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject )
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObject" ) )

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	IWbemQualifierSet *classQualifierObject ;
	if ( SUCCEEDED ( mosClassObject->GetQualifierSet ( &classQualifierObject ) ) )
	{
		status = GetMosClassObjectQualifiers ( a_errorObject , classQualifierObject ) ;
		if ( status )
		{
			status = GetMosClassObjectProperties ( a_errorObject , mosClassObject ) ;
		}
		else
		{
		}

		classQualifierObject->Release () ;
	}
	else
	{
/*
 *	Couldn't get object qualifier set.
 */

		status = FALSE ;
		a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
		a_errorObject.SetMessage ( L"Failed to get object qualifier set" ) ;

	}

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObjectQualifiers ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObjectQualifiers" ) )

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpQualifier *qualifier ;
	ResetQualifier () ;
	while ( status && ( qualifier = NextQualifier () ) )
	{
		if ( qualifier->IsPropagatable () )
		{
			wchar_t *qualifierName = qualifier->GetName () ;

			if ( qualifier->GetValue ( variant ) )
			{
				t_WBEM_result = classQualifierObject->Put ( qualifierName , &variant , WBEM_CLASS_PROPAGATION ) ;
				if ( SUCCEEDED ( t_WBEM_result ) )
				{
				}
				else
				{
	/*
	 *	Failed to set qualifier value. Should not happen.
	 */
					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetMessage ( L"Failed to set class qualifier value" ) ;

				}
			}
			else
			{
	/*
	 *	Failed to get qualifier value. Should not happen.
	 */

				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetMessage ( L"Failed to get class qualifier value" ) ;
			}

			VariantClear ( & variant ) ;
		}
	}

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObjectProperties ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject *mosClassObject ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObjectProperties" ) )

	BOOL status = TRUE ;
	HRESULT t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpProperty *property ;
	ResetProperty () ;
	while ( status && ( property = NextProperty () ) )
	{
		wchar_t *propertyName = property->GetName () ;

		IWbemQualifierSet *propertyQualifierObject ;
		if ( SUCCEEDED ( mosClassObject->GetPropertyQualifierSet ( propertyName , &propertyQualifierObject ) ) )
		{
			status = GetMosClassObjectPropertyQualifiers ( a_errorObject , property , propertyQualifierObject ) ;
			if ( status )
			{
				CIMTYPE cimType ;
				if ( property->GetValue ( variant , cimType ) )
				{
					if ( IsClass () )
					{
						if ( property->IsNull () )
						{
							t_WBEM_result = mosClassObject->Put ( propertyName , 0 , &variant , cimType ) ;
						}
						else
						{
							t_WBEM_result = mosClassObject->Put ( propertyName , 0 , &variant , 0 ) ;
						}
					}
					else
					{
						t_WBEM_result = mosClassObject->Put ( propertyName , 0 , &variant , 0 ) ;
					}

					if ( SUCCEEDED ( t_WBEM_result ) )
					{
					}
					else
					{
/*
 *	Failed to set property value. Should not happen.
 */

						
						wchar_t *prefix = UnicodeStringAppend ( L"Failed to set property value for property \'" , propertyName ) ;
						wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
						delete [] prefix ;
						a_errorObject.SetMessage ( stringBuffer ) ;
						delete [] stringBuffer ; 

						status = FALSE ;
						a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
						a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
					}
				}
				else
				{
		/*
		 *	Failed to get property value. Should not happen.
		 */

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Failed to get property value for property \'" , propertyName ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					a_errorObject.SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}

				VariantClear ( & variant ) ;
			}

			propertyQualifierObject->Release () ;
		}
	}

	return status ;
}

BOOL WbemSnmpClassObject :: GetMosClassObjectPropertyQualifiers ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *snmpProperty , IWbemQualifierSet *propertyQualifierSet ) 
{
DebugMacro7( SnmpDebugLog :: s_SnmpDebugLog->WriteFileAndLine (  __FILE__,__LINE__,L"WbemSnmpClassObject :: GetMosClassObjectPropertyQualifiers" ) )

	BOOL status = TRUE ;
	WBEMSTATUS t_WBEM_result = WBEM_S_NO_ERROR ;

	VARIANT variant ;
	VariantInit ( & variant ) ;

	WbemSnmpQualifier *qualifier ;
	snmpProperty->ResetQualifier () ;
	while ( status && ( qualifier = snmpProperty->NextQualifier () ) )
	{
		if ( qualifier->IsPropagatable () )
		{
			wchar_t *qualifierName = qualifier->GetName () ;

			if ( qualifier->GetValue ( variant ) )
			{
				t_WBEM_result = ( WBEMSTATUS ) propertyQualifierSet->Put ( qualifierName , &variant , WBEM_CLASS_PROPAGATION ) ;
				if ( SUCCEEDED ( t_WBEM_result ) )
				{
				}
				else
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Failed to set property qualifier \'" , qualifierName ) ;
					wchar_t *middle = UnicodeStringAppend ( prefix , L"\' for property \'" ) ;
					delete [] prefix ;
					wchar_t *suffix = UnicodeStringAppend ( middle , snmpProperty->GetName () ) ;
					delete [] middle ;
					wchar_t *stringBuffer = UnicodeStringAppend ( suffix , L"\'" ) ;
					delete [] suffix ;
					a_errorObject.SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					status = FALSE ;
					a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
					a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
				}
			}
			else
			{

				wchar_t *prefix = UnicodeStringAppend ( L"Failed to get property qualifier \'" , qualifierName ) ;
				wchar_t *middle = UnicodeStringAppend ( prefix , L"\' for property \'" ) ;
				delete [] prefix ;
				wchar_t *suffix = UnicodeStringAppend ( middle , snmpProperty->GetName () ) ;
				delete [] middle ;
				wchar_t *stringBuffer = UnicodeStringAppend ( suffix , L"\'" ) ;
				delete [] suffix ;
				a_errorObject.SetMessage ( stringBuffer ) ;
				delete [] stringBuffer ; 


				status = FALSE ;
				a_errorObject.SetStatus ( WBEM_SNMP_ERROR_CRITICAL_ERROR ) ;
				a_errorObject.SetWbemStatus ( WBEM_ERROR_CRITICAL_ERROR ) ;
			}

			VariantClear ( & variant ) ;
		}
	}

	return status ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\snmpset.cpp ===
//***************************************************************************

//

//  MINISERV.CPP

//

//  Module: OLE MS SNMP Property Provider

//

//  Purpose: Implementation for the SnmpGetEventObject class. 

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "precomp.h"
#include <provexpt.h>
#include <snmptempl.h>
#include <snmpmt.h>
#include <typeinfo.h>
#include <process.h>
#include <objbase.h>
#include <stdio.h>
#include <wbemidl.h>
#include "classfac.h"
#include "guids.h"
#include <snmpcont.h>
#include <snmpevt.h>
#include <snmpthrd.h>
#include <snmplog.h>
#include <snmpcl.h>
#include <instpath.h>
#include <snmptype.h>
#include <snmpauto.h>
#include <snmpobj.h>
#include <genlex.h>
#include <sql_1.h>
#include <objpath.h>
#include "propprov.h"
#include "propsnmp.h"
#include "propget.h"
#include "propset.h"
#include "snmpget.h"
#include "snmpset.h"

SetOperation :: SetOperation (

	IN SnmpSession &sessionArg ,
	IN SnmpSetResponseEventObject *eventObjectArg 

) :	SnmpSetOperation ( sessionArg ) , 
	session ( & sessionArg ) ,
	varBindsReceived ( 0 ) ,
	erroredVarBindsReceived ( 0 ) ,
	eventObject ( eventObjectArg ) ,
	m_PropertyContainer ( NULL ) ,
	m_PropertyContainerLength ( 0 ) 

{
}

SetOperation :: ~SetOperation ()
{
	delete [] m_PropertyContainer ;

	session->DestroySession () ;
}

void SetOperation :: ReceiveResponse () 
{
// Inform creator all is done

	eventObject->ReceiveComplete () ;
}

void SetOperation :: ReceiveVarBindResponse (

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind ,
	IN const SnmpVarBind &replyVarBind ,
	IN const SnmpErrorReport &error
) 
{
	varBindsReceived ++ ;
}

#pragma warning (disable:4065)

void SetOperation :: ReceiveErroredVarBindResponse(

	IN const ULONG &var_bind_index,
	IN const SnmpVarBind &requestVarBind  ,
	IN const SnmpErrorReport &error
) 
{
	erroredVarBindsReceived ++ ;

	WbemSnmpProperty *property = m_PropertyContainer [ var_bind_index - 1 ] ;

	switch ( error.GetError () )
	{
		case Snmp_Error:
		{
			switch ( error.GetStatus () )
			{
				case Snmp_No_Response:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_NO_RESPONSE ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"No Response from device" ) ;
				}
				break; 

				case Snmp_No_Such_Name:
				{

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported No Such Name for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

// Invalid property requested

					property->AddQualifier ( WBEM_QUALIFIER_NOT_AVAILABLE ) ;
					WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_NOT_AVAILABLE ) ;
					if ( qualifier )
					{
						SnmpIntegerType integer ( 1 , NULL ) ;
						if ( qualifier->SetValue ( &integer ) )
						{
						}
						else
						{
// Problem Here
						}
					}
					else
					{
// Problem Here
					}
				}
				break ;

				case Snmp_Bad_Value:
				{
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Bad Value for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 

					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
				}
				break ;

				case Snmp_Read_Only:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;

					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported Read Only for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Gen_Error:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					wchar_t *prefix = UnicodeStringAppend ( L"Agent reported General Error for property \'" , property->GetName () ) ;
					wchar_t *stringBuffer = UnicodeStringAppend ( prefix , L"\'" ) ;
					delete [] prefix ;
					eventObject->GetErrorObject ().SetMessage ( stringBuffer ) ;
					delete [] stringBuffer ; 
				}
				break ;

				case Snmp_Too_Big:
				{
					property->SetTag ( FALSE ) ;
					eventObject->SnmpTooBig () ;
				}
				break ;

				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ; 
			}
		}
		break ;

		case Snmp_Transport:
		{
			switch ( error.GetStatus () )
			{
				default:
				{
					eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
					eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
					eventObject->GetErrorObject ().SetMessage ( L"Unknown transport failure" ) ;
				}
				break ;
			}
		}
		break ;

		default:
		{
// Cannot Happen
		}
		break ;
	}
}

#pragma warning (default:4065)

void SetOperation :: FrameTooBig () 
{
	eventObject->SnmpTooBig () ;
	CancelRequest () ;
}

void SetOperation :: FrameOverRun () 
{
	eventObject->SnmpTooBig () ;

#if 0
	eventObject->GetErrorObject ().SetStatus ( WBEM_SNMP_E_TRANSPORT_ERROR ) ;
	eventObject->GetErrorObject ().SetWbemStatus ( WBEM_E_FAILED ) ;
	eventObject->GetErrorObject ().SetMessage ( L"Set Request could not fit into single SNMP PDU" ) ;
#endif

	CancelRequest () ;
}

void SetOperation :: Send ( const ULONG &a_NumberToSend )
{
// Send Variable Bindings for requested properties

	SnmpVarBindList varBindList ;

	SnmpObjectIdentifier instanceObjectIdentifier ( NULL , 0 ) ;

	SnmpSetClassObject *snmpObject = ( SnmpSetClassObject * ) eventObject->GetSnmpClassObject () ;
	if ( snmpObject )
	{
// Encode Variable Binding instance for all key properties

		if ( snmpObject->GetKeyPropertyCount () )
		{
			WbemSnmpProperty *property ;
			snmpObject->ResetKeyProperty () ;
			while ( property = snmpObject->NextKeyProperty () )
			{
				instanceObjectIdentifier = property->GetValue()->Encode ( instanceObjectIdentifier ) ;
			}
		}	
		else
		{
			SnmpIntegerType integerType ( ( LONG ) 0 , NULL ) ;
			instanceObjectIdentifier = integerType.Encode ( instanceObjectIdentifier ) ;
		}

		if ( ! m_PropertyContainer )
		{
			WbemSnmpProperty *property ;
			snmpObject->ResetProperty () ;
			while ( property = snmpObject->NextProperty () )
			{
				if ( snmpObject->IsWritable ( property ) )
				{
					BOOL t_Status = ( snmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
					t_Status = t_Status || ( ( snmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

					if ( t_Status )
					{
						if ( property->IsVirtualKey () == FALSE )
						{
							m_PropertyContainerLength ++ ;
						}
					}
				}
			}

			m_PropertyContainer = new WbemSnmpProperty * [ m_PropertyContainerLength ] ;
		}


// Add Variable binding to Variable binding list

		ULONG t_Count = 0 ;

/*
 * First add row status property
 */

		WbemSnmpProperty *property ;
		snmpObject->ResetProperty () ;
		while ( property = snmpObject->NextProperty () ) 
		{
			if ( ( typeid ( *property->GetValue () ) == typeid ( SnmpRowStatusType ) ) & ( ! property->GetTag () ) )
			{
				property->SetTag ( TRUE ) ;

				WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
				if ( qualifier )
				{
					SnmpInstanceType *value = qualifier->GetValue () ;
					if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
					{
						SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
						SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
						SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

						SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

// Create queue of properties which have duplicate object identifiers

						m_PropertyContainer [ t_Count ] = property ;

						const SnmpValue *snmpValue = property->GetValue()->GetValueEncoding () ;
						SnmpVarBind varBind ( requestIdentifier , *snmpValue ) ;
						varBindList.Add ( varBind ) ;

						t_Count ++ ;
					}
				}
			}
		}

		snmpObject->ResetProperty () ;
		while ( ( property = snmpObject->NextProperty () ) && ( a_NumberToSend == 0xffffffff ) || ( ( a_NumberToSend != 0xffffffff ) && ( t_Count < a_NumberToSend ) ) )
		{
			if ( ! property->GetTag () )
			{
				BOOL t_Status = ( snmpObject->GetSnmpVersion () == 1 ) && ( property->IsSNMPV1Type () ) ;
				t_Status = t_Status || ( ( snmpObject->GetSnmpVersion () == 2 ) && ( property->IsSNMPV2CType () ) ) ;

				if ( t_Status )
				{
					if ( property->IsVirtualKey () == FALSE )
					{
						if ( snmpObject->IsWritable ( property ) )
						{
							//now that we've checked that it is writable set it and mark it set
							property->SetTag ( TRUE ) ;
							WbemSnmpQualifier *qualifier = property->FindQualifier ( WBEM_QUALIFIER_OBJECT_IDENTIFIER ) ;
							if ( qualifier )
							{
								SnmpInstanceType *value = qualifier->GetValue () ;
								if ( typeid ( *value ) == typeid ( SnmpObjectIdentifierType ) )
								{
									SnmpObjectIdentifierType *objectIdentifierType = ( SnmpObjectIdentifierType * ) value ;
									SnmpObjectIdentifier *objectIdentifier = ( SnmpObjectIdentifier * ) objectIdentifierType->GetValueEncoding () ;
									SnmpObjectIdentifier requestIdentifier = *objectIdentifier + instanceObjectIdentifier ;

									SnmpObjectIdentifierType requestIdentifierType ( requestIdentifier ) ;

// Create queue of properties which have duplicate object identifiers

									m_PropertyContainer [ t_Count ] = property ;

									const SnmpValue *snmpValue = property->GetValue()->GetValueEncoding () ;
									SnmpVarBind varBind ( requestIdentifier , *snmpValue ) ;
									varBindList.Add ( varBind ) ;

									t_Count ++ ;
								}
								else
								{
// Problem Here
								}
							}
							else
							{
// Problem Here
							}
						}
					}
				}
			}
		}

// Finally Send request

		SendRequest ( varBindList ) ;
	}
	else
	{
// Problem Here
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\storage.cpp ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

#include "precomp.h"
#include <provexpt.h>
#include <cordefs.h>
#include <corafx.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <notify.h>
#include <snmplog.h>

extern ISmirDatabase* g_pNotifyInt;
extern CCorrCacheNotify *gp_notify;

CCorrGroupArray::CCorrGroupArray()
{
	SetSize(0, 10000);
}

int _cdecl compare( const void *arg1, const void *arg2 )
{
	CCorrObjectID tmp1;
	(*(CCorrGroupIdItem**)arg1)->GetGroupID(tmp1);
	CCorrObjectID tmp2;
	(*(CCorrGroupIdItem**)arg2)->GetGroupID(tmp2);

	switch (tmp1.CompareWith(tmp2))
	{
		case ECorrAreEqual:
		break;

		case ECorrFirstLess:
		return -1;

		case ECorrFirstGreater:
		return 1;
	}

	return 0;
}

void CCorrGroupArray::Sort()
{
	if (GetSize())
	{
		//CObject** temp = GetData();
		qsort((void *)GetData(), (size_t)GetSize(),
				sizeof( CCorrGroupIdItem * ), compare );
	}

	FreeExtra();
}


//============================================================================
//  CCorrGroupArray::~CCorrGroupArray
//
//  This is the CCorrGroupArray class's only desstructor. If there are any items in
//	the queue they are deleted.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrGroupArray::~CCorrGroupArray()
{
	for (int x = 0; x < GetSize(); x++)
	{
		CCorrGroupIdItem * item = GetAt(x);
		delete item;
	}

	RemoveAll();
}


//============================================================================
//  CCorrGroupIdItem::CCorrGroupIdItem
//
//  This is the CCorrGroupIdItem class's only constructor. This class is derived from
//	the CObject class. This is so the MFC template storage classes can be
//	used. It is used to store a CString value in a list.
//
//
//  Parameters:
//
//      CString * str  	A pointer to the CString object to be stored.
//
//  Returns:
//
//      none
//
//============================================================================

CCorrGroupIdItem::CCorrGroupIdItem(IN const CCorrObjectID& ID, IN ISmirGroupHandle*	grpH)
				: m_groupId(ID)
{
	m_index = 0;

	if (grpH)
	{
		m_groupHandles.AddHead(grpH);
	}
}


void CCorrGroupIdItem::GetGroupID(OUT CCorrObjectID& ID) const
{
	m_groupId.ExtractOID(ID);
}


void CCorrGroupIdItem::DebugOutputItem(CString* msg) const
{
	CString debugstr;
	CCorrObjectID tmp;
	m_groupId.ExtractOID(tmp);
	tmp.GetString(debugstr);

	if (!debugstr.GetLength())
	{
		debugstr = L"Error retrieving Group Object OID";
	}

	if (msg)
	{
		debugstr += L"\t\t:\t";
		debugstr += *msg;
	}

	debugstr += L"\n";
DebugMacro6(
	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		debugstr);
)

}


//============================================================================
//  CCorrGroupIdItem::~CCorrGroupIdItem
//
//  This is the CCorrGroupIdItem class's only destructor. It frees the memory used
//	to store the CString members.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrGroupIdItem::~CCorrGroupIdItem()
{
	while (!m_groupHandles.IsEmpty())
	{
		(m_groupHandles.RemoveHead())->Release();
	}
}


CCorrObjectID::CCorrObjectID(IN const CCorrObjectID& ID) : m_Ids(NULL)
{
	m_length = ID.m_length;

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ID.m_Ids, m_length*sizeof(UINT));
	}
}


CCorrObjectID::CCorrObjectID(IN const char* str) : m_Ids(NULL)
{
	m_length = 0;

	if (NULL != str)
	{
		char temp[MAX_OID_STRING + 1];
		strncpy(temp, str, MAX_OID_STRING+1);

		if ('\0' != temp[MAX_OID_STRING]) //string is too long.
		{
			return;
		}

		BOOL bad = FALSE;
		char* temp1 = temp;
		UINT temp2[MAX_OID_LENGTH];
		CString dot(".");

		if (dot.GetAt(0) == temp[0])
		{
			temp1++;
		}

		istrstream istr(temp1);
		char d;

		istr >> temp2[0];
		m_length++;

  		if (istr.bad() || istr.fail())
		{
			bad = TRUE;
		}

		while(!istr.eof() && !bad)
		{
			istr >> d;

  			if (istr.bad() || istr.fail())
			{
				bad = TRUE;
			}

			if (d != dot.GetAt(0))
			{
				bad = TRUE;
			}

			if (m_length < MAX_OID_LENGTH)
			{
				istr >> temp2[m_length++];

				if (istr.bad() || istr.fail())
				{
					bad = TRUE;
				}

			}
			else
			{
				bad = TRUE;
			}
		}

		if (!bad)
		{
			m_Ids = new UINT[m_length];
			memcpy(m_Ids, temp2, m_length*sizeof(UINT));
		}
		else
		{
			m_length = 0;
		}
	}
}

CCorrObjectID::CCorrObjectID(IN const UINT* ids, IN const UINT len) : m_Ids(NULL)
{
	if (len <= MAX_OID_LENGTH)
	{
		m_length = len;
	}
	else
	{
		m_length = 0;
	}

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ids, m_length*sizeof(UINT));
	}
}


void CCorrObjectID::Set(IN const UINT* ids, IN const UINT len)
{
	if (m_length)
	{
		delete [] m_Ids;
	}

	if (len <= MAX_OID_LENGTH)
	{
		m_length = len;
	}
	else
	{
		m_length = 0;
	}

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ids, m_length*sizeof(UINT));
	}
	else
	{
		m_Ids = NULL;
	}
}

char* CCorrObjectID::GetString() const
{
	char * ret = NULL;

	if (m_length)
	{
		ret = new char[BYTES_PER_FIELD*m_length];
		ostrstream s(ret, BYTES_PER_FIELD*m_length);
		s << m_Ids[0];
		UINT i = 1;
		char dot = '.';

		while (i < m_length)
		{
			s << dot << m_Ids[i++];
		}

		s << ends;
	}

	return ret;
}

wchar_t* CCorrObjectID::GetWideString() const
{
	wchar_t * ret = NULL;

	if (m_length)
	{
		DWORD retlen = (m_length * 5) + 25;
		ret = new wchar_t[retlen + 1];

		_ultow((ULONG)m_Ids[0], ret, 10);
		UINT i = 1;

		while (i < m_length)
		{
			wchar_t buff[20];
			_ultow((ULONG)m_Ids[i], buff, 10);

			if (wcslen(buff) + wcslen(ret) >= retlen)
			{
				retlen += ((m_length - i) * 5) + 25;
				wchar_t *tmp = new wchar_t[retlen + 1];
				wcscpy(ret, tmp);
				delete [] ret;
				ret = tmp;
			}

			wcscat(ret, L".");
			wcscat(ret, buff);
			i++;
		}
	}

	return ret;
}

void CCorrObjectID::GetString(CString& str) const
{
	wchar_t* oid = GetWideString();

	try
	{
		str = oid;
	}
	catch(...)
	{
		delete [] oid;
		throw;
	}

	delete [] oid;
}

ECorrCompResult CCorrObjectID::CompareWith(IN const CCorrObjectID& second) const
{
	if (0 == m_length)
	{
		if (0 == second.m_length)
		{
			return ECorrAreEqual;
		}
		else
		{
			return ECorrFirstLess;
		}
	}

	if (0 == second.m_length)
	{
		return ECorrFirstGreater;
	}

	ECorrCompResult res = ECorrAreEqual;

	if (m_length <= second.m_length)
	{
		for (UINT i = 0; i < m_length; i++)
		{
			if (m_Ids[i] != second.m_Ids[i])
			{
				if (m_Ids[i] < second.m_Ids[i])
				{
					return ECorrFirstLess;
				}
				else
				{
					return ECorrFirstGreater;
				}
			}
		}

		if (m_length < second.m_length)
		{
			res = ECorrFirstLess;
		}
	}
	else
	{
		for (UINT i = 0; i < second.m_length; i++)
		{
			if (m_Ids[i] != second.m_Ids[i])
			{
				if (m_Ids[i] < second.m_Ids[i])
				{
					return ECorrFirstLess;
				}
				else
				{
					return ECorrFirstGreater;
				}
			}
		}

		res = ECorrFirstGreater;
	}

	return res;
}


BOOL CCorrObjectID::IsSubRange(IN const CCorrObjectID& child) const
{
	if (m_length >= child.m_length)
	{
		return FALSE;
	}

	for (UINT i=0; i<m_length; i++)
	{
		if (m_Ids[i] != child.m_Ids[i])
		{
			return FALSE;
		}
	}

	return TRUE;
}


BOOL CCorrObjectID::operator ==(IN const CCorrObjectID& second) const
{
	if (ECorrAreEqual == CompareWith(second))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CCorrObjectID::operator !=(IN const CCorrObjectID& second) const
{
	if (ECorrAreEqual == CompareWith(second))
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

BOOL CCorrObjectID::operator <(IN const CCorrObjectID& second) const
{
	if (ECorrFirstLess == CompareWith(second))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CCorrObjectID::operator >(IN const CCorrObjectID& second) const
{
	if (ECorrFirstGreater == CompareWith(second))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

BOOL CCorrObjectID::operator <=(IN const CCorrObjectID& second) const
{
	ECorrCompResult res = CompareWith(second);

	if ((ECorrAreEqual == res) || (ECorrFirstLess == res))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}


BOOL CCorrObjectID::operator >=(IN const CCorrObjectID& second) const
{
	ECorrCompResult res = CompareWith(second);

	if ((ECorrAreEqual == res) || (ECorrFirstGreater == res))
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}
}

CCorrObjectID& CCorrObjectID::operator =(IN const CCorrObjectID& ID)
{
	if (m_length)
	{
		delete [] m_Ids;
	}

	m_length = ID.m_length;

	if (m_length)
	{
		m_Ids = new UINT[m_length];
		memcpy(m_Ids, ID.m_Ids, m_length*sizeof(UINT));
	}
	else
	{
		m_Ids = NULL;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator +=(IN const CCorrObjectID& ID)
{
	if((m_length + ID.m_length) > MAX_OID_LENGTH)
	{
		if(m_length)
		{
			delete [] m_Ids;
			m_Ids = NULL;
		}

		m_length = 0;
	}
	else
	{
		if (ID.m_length)
		{
			UINT* newIds = new UINT[m_length + ID.m_length];

			if(m_length)
			{
				memcpy(newIds, m_Ids, m_length*sizeof(UINT));
				delete [] m_Ids;
				m_Ids = NULL;
			}

			memcpy(&(newIds[m_length]), ID.m_Ids, ID.m_length*sizeof(UINT));
			m_Ids = newIds;
			m_length += ID.m_length;
		}
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator ++()
{
	if (m_length)
	{
		m_Ids[m_length - 1]++;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator --()
{
	if (m_length)
	{
		m_Ids[m_length - 1]--;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator -=(IN const UINT sub)
{
	if (sub && (m_length > sub))
	{
		m_length -= sub;
		UINT* newIds = new UINT[m_length];
		memcpy(newIds, m_Ids, m_length*sizeof(UINT));
		delete [] m_Ids;
		m_Ids = newIds;
	}
	else if (sub == m_length)
	{
		m_length = 0;
		delete [] m_Ids;
		m_Ids = NULL;
	}

	return *this;
}

CCorrObjectID& CCorrObjectID::operator /=(IN const UINT sub)
{
	if (sub && (m_length > sub))
	{
		m_length -= sub;
		UINT* newIds = new UINT[m_length];
		memcpy(newIds, &(m_Ids[sub]), m_length*sizeof(UINT));
		delete [] m_Ids;
		m_Ids = newIds;
	}
	else if (sub == m_length)
	{
		m_length = 0;
		delete [] m_Ids;
		m_Ids = NULL;
	}

	return *this;
}

CCorrObjectID::~CCorrObjectID()
{
	if (m_length)
	{
		delete [] m_Ids;
	}
}




//============================================================================
//  CCorrRangeTableItem::CCorrRangeTableItem
//
//  This is the CCorrRangeTableItem class's only constructor. This class is derived from
//	the CObject class. This is so the MFC template storage classes can be
//	used. It is used to store a CString value in a list.
//
//
//  Parameters:
//
//      CString * str  	A pointer to the CString object to be stored.
//
//  Returns:
//
//      none
//
//============================================================================

CCorrRangeTableItem::CCorrRangeTableItem(IN const CCorrObjectID& startID,
										 IN const CCorrObjectID& endID,
										 IN CCorrGroupIdItem*	grpID)
{
	m_groupId = grpID;
	CCorrObjectID temp;
	m_groupId->GetGroupID(temp);
	CCorrObjectID startRange = startID;
	startRange /= temp.GetLength();
	CCorrObjectID endRange = endID;
	endRange /= (temp.GetLength() - 1);
	m_startRange.Set(startRange);
	m_endRange.Set(endRange);
}


//============================================================================
//  CCorrRangeTableItem::~CCorrRangeTableItem
//
//  This is the CCorrRangeTableItem class's only destructor. It frees the memory used
//	to store the CString members.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrRangeTableItem::~CCorrRangeTableItem()
{

}


BOOL CCorrRangeTableItem::GetStartRange(OUT CCorrObjectID& start) const
{
	if (!m_groupId)
		return FALSE;

	m_groupId->GetGroupID(start);
	CCorrObjectID tmp;
	m_startRange.ExtractOID(tmp);
	start += tmp;
	return TRUE;
}


BOOL CCorrRangeTableItem::GetEndRange(OUT CCorrObjectID& end) const
{
	if (!m_groupId)
		return FALSE;

	m_groupId->GetGroupID(end);
	end -= 1;
	CCorrObjectID tmp;
	m_endRange.ExtractOID(tmp);
	end += tmp;
	return TRUE;
}

CCorrRangeTableItem::ECorrRangeResult CCorrRangeTableItem::
									IsInRange(IN const CCorrObjectID& ID) const
{
	CCorrObjectID a;

	GetStartRange(a);

	if (ID == a)
	{
		return ECorrEqualToStart;
	}

	if (ID < a)
	{
		return ECorrBeforeStart;
	}

	CCorrObjectID b;
	GetEndRange(b);

	if (ID == b)
	{
		return ECorrEqualToEnd;
	}

	if (ID > b)
	{
		return ECorrAfterEnd;
	}

	return ECorrInRange;
}


void CCorrRangeTableItem::DebugOutputRange() const
{
DebugMacro6(
	if (m_groupId)
	{
		CString debugstr;
		CCorrObjectID tmp;
		m_groupId->GetGroupID(tmp);
		tmp.GetString(debugstr);
		CString out1;
		CCorrObjectID start;
		GetStartRange(start);
		start.GetString(out1);
		CString out2;
		CCorrObjectID end;
		GetEndRange(end);
		end.GetString(out2);
		debugstr += "\t\t:\t\t";
		debugstr += out1;
		debugstr += "\t\t:\t\t";
		debugstr += out2;
		debugstr += "\t\tGroup : Start : End\n";
		SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
			debugstr);
	}
	else
	{
		SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
			L"Attempt to output empty RangeTableItem\n");
	}
)
}


//============================================================================
//  CCorrRangeList::~CCorrRangeList
//
//  This is the CCorrRangeList class's only desstructor. If there are any items in
//	the queue they are deleted.
//
//
//  Parameters:
//
//      none
//
//  Returns:
//
//      none
//
//============================================================================

CCorrRangeList::~CCorrRangeList()
{
	while(!IsEmpty())
	{
		CCorrRangeTableItem * item = RemoveHead();
		delete item;
	}
}


//============================================================================
//  CCorrRangeList::Add
//
//  This public method is called to add a CCorrRangeTableItem into this CCorrRangeList. The
//	CCorrRangeTableItem is not added if it is already present in the list. If this is the
//	case a pointer to the matching item in the list is returned.
//
//
//  Parameters:
//
//		CCorrRangeTableItem * newItem	A pointer to the CCorrRangeTableItem to be added.
//
//  Returns:
//
//      CCorrRangeTableItem *			A pointer to the item if is in the list. NULL if
//							the item was not found and was added.
//
//============================================================================

BOOL CCorrRangeList::Add(IN CCorrRangeTableItem* newItem)
{
	AddTail(newItem); //empty or all items smaller
	return TRUE;
}


BOOL CCorrRangeList::GetLastEndOID(OUT CCorrObjectID& end) const
{
	if (IsEmpty())
	{
		return FALSE;
	}

	return (GetTail()->GetEndRange(end));
}


CCorrGroupMask::CCorrGroupMask(IN const TCorrMaskLength sze) : m_mask(NULL)
{
	m_size = sze;

	if (m_size)
	{
		TCorrMaskLength x = m_size / (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);

		if (m_size % (sizeof(TCorrMaskUnit)*BITS_PER_BYTE))
		{
			x++;
		}

		m_mask = new TCorrMaskUnit[x];
		ZeroMemory((PVOID)m_mask, (DWORD)(sizeof(TCorrMaskUnit)*x));
	}
}

BOOL CCorrGroupMask::IsBitSet(IN const TCorrMaskLength bit)const
{
	TCorrMaskLength x = bit / (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);
	TCorrMaskLength val = bit % (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);

	return (((m_mask[x] >> val) & 1) == 1);
}

void CCorrGroupMask::SetBit(IN const TCorrMaskLength bit, IN const BOOL On)
{
	BOOL IsBit = IsBitSet(bit);

	if ((IsBit && On) || (!IsBit && !On))
	{
		return;
	}
	else
	{
		TCorrMaskLength x = bit / (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);
		TCorrMaskLength val = bit % (sizeof(TCorrMaskUnit)*BITS_PER_BYTE);
		TCorrMaskLength maskval = 1;
		maskval <<= val;

		if (On)
		{
			m_mask[x] += maskval;
		}
		else
		{
			m_mask[x] -= maskval;
		}
	}
}

CCorrGroupMask::~CCorrGroupMask()
{
	if (m_mask)
	{
		delete [] m_mask;
	}
}

CCorrCache::CCorrCache( ISmirInterrogator *a_ISmirInterrogator ) : m_Groups (NULL)
{
	m_ValidCache = TRUE;
	m_Ref_Count = 0;
	m_size = 0;
	BuildCacheAndSetNotify( a_ISmirInterrogator );

	if (m_groupTable.GetSize())
	{
		m_Groups = new CCorrGroupMask(m_size);
		BuildRangeTable();
	}
}

CCorrCache::~CCorrCache()
{
	if (m_Groups)
	{
		delete m_Groups;
	}
}

void CCorrCache::InvalidateCache()
{
	m_Lock.Lock();

	if (!m_Ref_Count)
	{
		delete this;
	}
	else
	{
		m_ValidCache = FALSE;
		m_Lock.Unlock();
	}
}

BOOL CCorrCache::BuildCacheAndSetNotify( ISmirInterrogator *a_ISmirInterrogator )
{
	LPUNKNOWN pInterrogativeInt = NULL;

//	===============================================================
//	The following relies on the current thread having been
//	initialised for OLE (i.e. by the use of CoInitialize)
//	===============================================================

	HRESULT hr = S_OK ;

	if ( a_ISmirInterrogator )
	{
		hr = a_ISmirInterrogator->QueryInterface (

			IID_ISMIR_Interrogative, (void**)&pInterrogativeInt
		);
	}
	else
	{
		HRESULT hr = CoCreateInstance (CLSID_SMIR_Database,
						NULL, CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER,
						IID_ISMIR_Interrogative, (void**)&pInterrogativeInt);
	}

	if (NULL == pInterrogativeInt)
	{
		return FALSE;
	}

	IEnumGroup  *pTEnumSmirGroup = NULL;

	//enum all groups
	hr = ((ISmirInterrogator*)pInterrogativeInt)->EnumGroups(&pTEnumSmirGroup, NULL);

	//now use the enumerator
	if(NULL == pTEnumSmirGroup)
	{
		pInterrogativeInt->Release();
		return FALSE;
	}

	ISmirGroupHandle *phModule=NULL;

DebugMacro6(
		SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
			L"CCorrCache::BuildCacheAndSetNotify - Accessing SMIR Getting Groups\n");
)


	for(int iCount=0; S_OK == pTEnumSmirGroup->Next(1, &phModule, NULL); iCount++)
	{
		//DO SOMETHING WITH THE GROUP HANDLE

		//eg get the name
		BSTR szName=NULL;
		char buff[1024];
		LPSTR pbuff = buff;
		int lbuff = sizeof(buff);
		phModule->GetGroupOID(&szName);

		if (FALSE == WideCharToMultiByte(CP_ACP, 0,
						szName, -1, pbuff, lbuff, NULL, NULL))
		{
			DWORD lasterr = GetLastError();
			SysFreeString(szName);
			phModule->Release();
DebugMacro6(
			SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
				L"CCorrCache::BuildCacheAndSetNotify - Error bad BSTR conversion\n");
)
			continue;
		}

		SysFreeString(szName);
		CCorrObjectID grpId(buff);
		CCorrObjectID zero;

		if (zero != grpId)
		{
			CCorrGroupIdItem* groupId = new CCorrGroupIdItem(grpId, phModule);
			m_groupTable.Add(groupId);
			m_size++;
		}

DebugMacro6(
		SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
			L"%s\n", buff);
)
	}

DebugMacro6(
	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		L"CCorrCache::BuildCacheAndSetNotify - Finished accessing SMIR Getting Groups\n");
)
	pTEnumSmirGroup->Release();

	if (NULL == g_pNotifyInt)
	{
		hr = pInterrogativeInt->QueryInterface(IID_ISMIR_Database,
			(void **) &g_pNotifyInt);

		if(SUCCEEDED(hr))
		{
			if( gp_notify== NULL)
			{
				DWORD dw;
				gp_notify = new CCorrCacheNotify();
				gp_notify->AddRef();
				hr = g_pNotifyInt->AddNotify(gp_notify, &dw);

				if(SUCCEEDED(hr))
				{
					gp_notify->SetCookie(dw);
				}
			}
		}
	}
	else
	{
		if( gp_notify== NULL)
		{
			DWORD dw;
			gp_notify = new CCorrCacheNotify();
			gp_notify->AddRef();
			hr = g_pNotifyInt->AddNotify(gp_notify, &dw);

			if(SUCCEEDED(hr))
			{
				gp_notify->SetCookie(dw);
			}
		}
	}

	pInterrogativeInt->Release();

	if ((NULL == gp_notify) || (0 == gp_notify->GetCookie()))
	{
		return FALSE;
	}

	return TRUE;
}

#pragma warning (disable:4018)

BOOL CCorrCache::BuildRangeTable()
{
	UINT pos = 0;
	TCorrMaskLength posIndex = 0;
	TCorrMaskLength nextIndex = 1;
	m_groupTable.Sort();

DebugMacro6(
	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		L"CCorrCache::BuildRangeTable - Printing sorted group table...\n");

	for (int x = 0; x < m_groupTable.GetSize(); x++)
	{
		CCorrGroupIdItem * i = m_groupTable.GetAt(x);
		i->DebugOutputItem();
	}

	SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
		L"CCorrCache::BuildRangeTable - Finished printing sorted group table...\n");
)

	while (pos < m_groupTable.GetSize())
	{
		UINT nextpos = pos + 1;
		DoGroupEntry(&pos, &nextpos, &posIndex, &nextIndex);
		pos = nextpos;
		posIndex = nextIndex++;
	}

	return TRUE;
}

#pragma warning (default:4018)

#pragma warning (disable:4018)

void CCorrCache::DoGroupEntry(UINT* current, UINT* next,
							 TCorrMaskLength* cIndex, TCorrMaskLength* nIndex)
{
	CCorrGroupIdItem* alpha = m_groupTable.GetAt(*current);
	CCorrObjectID a;
	alpha->GetGroupID(a);
	CCorrObjectID End(a);
	++End;

	if (*next < m_groupTable.GetSize())
	{
		CCorrGroupIdItem* beta = m_groupTable.GetAt(*next);
		CCorrObjectID b;
		beta->GetGroupID(b);

		//check for duplicates
		while ((a == b) && (*next < m_groupTable.GetSize()))
		{
DebugMacro6(
			SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
				L"Deleting duplicate non MIB2 group... ");
			beta->DebugOutputItem();
)

			//add the group handles to the one not being deleted
			while (!beta->m_groupHandles.IsEmpty())
			{
				alpha->m_groupHandles.AddTail(beta->m_groupHandles.RemoveHead());
			}

			m_groupTable.RemoveAt(*next);
			delete beta;
			beta = m_groupTable.GetAt(*next);
			beta->GetGroupID(b);
		}

		//after checking for duplicates, check we still meet the initial condition
		if (*next < m_groupTable.GetSize())
		{

			//if the next item is not a child of this
			if ((a.GetLength() >= b.GetLength()) || (!a.IsSubRange(b)))
			{
				CCorrObjectID c;
				CCorrRangeTableItem* newEntry;

				if (!m_rangeTable.GetLastEndOID(c) || !a.IsSubRange(c))
				{
					//add whole of a-range to rangetable
					newEntry = new CCorrRangeTableItem(a, End, alpha);
				}
				else
				{
					//add from c to end of a-range to rangetable
					newEntry = new CCorrRangeTableItem(c, End, alpha);
				}

				newEntry->DebugOutputRange();

				m_rangeTable.Add(newEntry);
				alpha->SetIndex(*cIndex);
				m_Groups->SetBit(*cIndex);
			}
			else //the next item is a child so add a subrange and do the child - recurse!
			{
				CCorrObjectID c;
				CCorrRangeTableItem* newEntry;

				if (!m_rangeTable.GetLastEndOID(c) || !a.IsSubRange(c))
				{
					//add start of a-range to start of b to rangetable
					newEntry = new CCorrRangeTableItem(a, b, alpha);
				}
				else
				{
					//add from c to start of b to rangetable
					newEntry = new CCorrRangeTableItem(c, b, alpha);
				}

				newEntry->DebugOutputRange();

				m_rangeTable.Add(newEntry);
				UINT temp = (*next)++;
				TCorrMaskLength tempIndex = (*nIndex)++;
				DoGroupEntry(&temp, next, &tempIndex, nIndex);

				if (*next >= m_groupTable.GetSize())
				{
					m_rangeTable.GetLastEndOID(c);
					////add from c to end of a-range to rangetable
					newEntry = new CCorrRangeTableItem(c, End, alpha);
					m_rangeTable.Add(newEntry);
					alpha->SetIndex(*cIndex);
					m_Groups->SetBit(*cIndex);
					newEntry->DebugOutputRange();
				}

				//while the new next one(s) is a child add it first - recurse AGAIN!
				while(!m_Groups->IsBitSet(*cIndex))
				{
					DoGroupEntry(current, next, cIndex, nIndex);
				}
			}
		}
	}

	//if this is the last item then add it.
	if (*current == m_groupTable.GetUpperBound())
	{
		//add whole of a-range to rangetable
		CCorrRangeTableItem* newEntry = new CCorrRangeTableItem(a, End, alpha);
		m_rangeTable.Add(newEntry);
		alpha->SetIndex(*cIndex);
		m_Groups->SetBit(*cIndex);
		newEntry->DebugOutputRange();
	}
}

#pragma warning (default:4018)

void CCorrCache::AddRef()
{
	m_Lock.Lock();
	m_Ref_Count++;
	m_Lock.Unlock();
}

void CCorrCache::DecRef()
{
	m_Lock.Lock();

	if (m_Ref_Count)
		m_Ref_Count--;

	if (!m_Ref_Count && !m_ValidCache)
	{
		delete this;
		return;
	}

	m_Lock.Unlock();

}



CCorrEncodedOID::CCorrEncodedOID(IN const CCorrObjectID& src_oid) : m_ids(NULL), m_length(0), m_chopped(0)
{
	Set(src_oid);
}

void CCorrEncodedOID::Set(IN const CCorrObjectID& src_oid)
{
	m_chopped = 0;
	UINT x = 0;
	UINT oidlength = src_oid.GetLength();

	if (oidlength > MAX_OID_LENGTH)
	{
DebugMacro6(
			SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
				L"CCorrEncodedOID::Set: Truncating OID from %d to %d components", oidlength, MAX_OID_LENGTH);
)
		oidlength = MAX_OID_LENGTH;
	}

	if (oidlength)
	{
		UCHAR buff[MAX_OID_LENGTH*MAX_BYTES_PER_FIELD];
		const UINT* oid_ids = src_oid.GetIds();

		for (UINT i = 0; i < oidlength; i++)
		{
			UINT val = oid_ids[i];

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT28)
			{
				buff[x++] = (UCHAR) (BIT7 + ((val & HI4BITS) >> 28));
			}

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT21)
			{
				buff[x++] = BIT7 + ((val & HIMID7BITS) >> 21);
			}

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT14)
			{
				buff[x++] = BIT7 + ((val & MID7BITS) >> 14);
			}

			//get the top four bits and store in byte
			//BIT7 means next byte is part of this UINT
			if (val >= BIT7)
			{
				buff[x++] = BIT7 + ((val & LOMID7BITS) >> 7);
			}

			//get the next seven bits and store in byte
			buff[x++] = (val & LO7BITS);
		}

		//Remove the standard 1.3.6.1 if necessary...
		if ((1 == buff[0]) && (3 == buff[1]) &&
			(6 == buff[2]) && (1 == buff[3]))
		{
			m_chopped = 1;
			m_ids = new UCHAR[x-4];
			m_length = x-4;
			memcpy(m_ids, &buff[4], m_length*sizeof(UCHAR));
		}
		else
		{
			m_ids = new UCHAR[x];
			m_length = x;
			memcpy(m_ids, buff, m_length*sizeof(UCHAR));
		}
	}
	else
	{
		m_ids = NULL;
	}
}


void CCorrEncodedOID::ExtractOID(OUT CCorrObjectID& src_oid) const
{
	if (m_length)
	{
		UINT buff[MAX_OID_LENGTH];
		UINT x = 0;

		//Add the standard 1.3.6.1 if necessary...
		if (m_chopped == 1)
		{
			buff[0] = 1;
			buff[1] = 3;
			buff[2] = 6;
			buff[3] = 1;
			x = 4;
		}

		for (UINT i = 0; (i < m_length) && (x < MAX_OID_LENGTH); i++)
		{
			//extract the value of the byte
			buff[x] = m_ids[i] & LO7BITS;

			//are there more bytes for this UINT
			while ((i < m_length) && (m_ids[i] & 128))
			{
				//shift the value by a "byte" and extract tbe next byte.
				buff[x] = buff[x] << 7;
				buff[x] += m_ids[++i] & LO7BITS;
			}

			x++;

			if ((x == MAX_OID_LENGTH) && (i < m_length))
			{
DebugMacro6(
			SnmpDebugLog::s_SnmpDebugLog->WriteFileAndLine(__FILE__,__LINE__,
				L"CCorrEncodedOID::ExtractOID: Truncating OID %d components - SHOULD NEVER HAPPEN", MAX_OID_LENGTH);
)
			}
		}

		src_oid.Set(buff, x);
	}
	else
	{
		src_oid.Set(NULL, 0);
	}

}


CCorrEncodedOID::~CCorrEncodedOID()
{
	delete [] m_ids;
}

CCorrCacheWrapper::CCorrCacheWrapper(IN CCorrCache* cachePtr) : m_lockit(NULL)
{
	m_lockit = new CCriticalSection();
	m_CachePtr = cachePtr;
}

CCorrCache* CCorrCacheWrapper::GetCache()
{
	m_lockit->Lock();
	return m_CachePtr;
}

CCorrCacheWrapper::~CCorrCacheWrapper()
{
	delete m_lockit;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\cordefs.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORDEFS
#define _SNMPCORR_CORDEFS

#define BITS_PER_BYTE		8
#define BYTES_PER_FIELD		18
#define FIELD_SEPARATOR		'.'
#define EOS					'\0'
#define CORRELATOR_KEY		L"Software\\Microsoft\\WBEM\\Providers\\SNMP\\Correlator"
#define CORRELATOR_VALUE	L"MaxVarBinds"
#define VARBIND_COUNT		6
#define MIB2				"RFC1213-MIB"
#define MAX_MODULE_LENGTH	1024
#define MAX_OID_STRING		2310 //xxx. to a max of 128 components 18*128 plus a little extra
#define MAX_OID_LENGTH		128
#define MAX_BYTES_PER_FIELD 5
#define BIT28				268435456	// 1 << 28
#define BIT21				2097152		// 1 << 21
#define BIT14				16384		// 1 << 14
#define BIT7				128			// 1 << 7
#define HI4BITS				4026531840	// 15 << 28
#define HIMID7BITS			266338304	// 127 << 21
#define MID7BITS			2080768		// 127 << 14
#define LOMID7BITS			16256		// 127 << 7
#define LO7BITS				127


#endif //_SNMPCORR_CORDEFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\cormap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORMAP
#define _SNMPCORR_CORMAP


class CCorrelatorMap : public CMap< DWORD_PTR, DWORD_PTR, CCorrelator*, CCorrelator* >
{
private:

	CCriticalSection	m_MapLock;
	UINT HashKey(DWORD_PTR key) { return (UINT)key; }


public:

	void Register(CCorrelator *key);
	void UnRegister(CCorrelator *key);
	~CCorrelatorMap();


};


#endif //_SNMPCORR_CORSTORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\corafx.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORAFX
#define _SNMPCORR_CORAFX 




// corafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <snmpstd.h>
#include <snmpcoll.h>
#include <snmptempl.h>
#include <fstream.h>		// File Streams
#include <snmpmt.h>			// MFC Critical Sections

//#include <afx.h>
#include <strstrea.h>
#endif //_SNMPCORR_CORAFX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\classfac.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPProvClassFactory_H
#define _SNMPProvClassFactory_H

class CClasProvClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CClasProvClassFactory () ;
    ~CClasProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CPropProvClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CPropProvClassFactory () ;
    ~CPropProvClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
    STDMETHODIMP LockServer ( BOOL ) ;
};

class CSNMPEventProviderClassFactory : public IClassFactory
{
private:

    long m_referenceCount ;

protected:
public:

	static LONG locksInProgress ;
	static LONG objectsInProgress ;


    CSNMPEventProviderClassFactory () ;
    ~CSNMPEventProviderClassFactory ( void ) ;

	//IUnknown members

	STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

	//IClassFactory members

    STDMETHODIMP LockServer ( BOOL ) ;
};

class CSNMPEncapEventProviderClassFactory : public CSNMPEventProviderClassFactory
{
public:

	//IClassFactory member
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
};

class CSNMPRefEventProviderClassFactory : public CSNMPEventProviderClassFactory
{
public:

	//IClassFactory member
    STDMETHODIMP CreateInstance ( LPUNKNOWN , REFIID , LPVOID FAR * ) ;
};

#endif // _SNMPProvClassFactory_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\clasprov.h ===
//***************************************************************************

//

//  PropertyProvider.H

//

//  Module: Sample Mini Server for Ole MS 

//

//  Purpose: Genral purpose include file.

//

// Copyright (c) 1996-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPClassProvider_H_
#define _SNMPClassProvider_H_

extern CRITICAL_SECTION s_ProviderCriticalSection ;

class SnmpClassDefaultThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpClassDefaultThreadObject ( const char *threadName = NULL ) : SnmpThreadObject ( threadName ) {} ;
	~SnmpClassDefaultThreadObject () {} ;

	void Initialise () ;
	void Uninitialise () { CoUninitialize () ; }

} ;

class CImpClasProv : public IWbemServices , public IWbemProviderInit
{
private:

	LONG m_referenceCount ;         //Object reference count

private:

	BOOL initialised ;
	IWbemServices *propertyProvider ;
	IWbemServices *server ;
	IWbemServices *parentServer ;
	IWbemProviderInitSink *m_InitSink ;
	char *ipAddressString ;
	char *ipAddressValue ;

	wchar_t *thisNamespace ;
	WbemNamespacePath namespacePath ;

	CCriticalSection m_notificationLock;
	CCriticalSection m_snmpNotificationLock;
	IWbemClassObject *m_notificationClassObject ;
	IWbemClassObject *m_snmpNotificationClassObject ;
	BOOL m_getNotifyCalled ;
	BOOL m_getSnmpNotifyCalled ;
 
private:

	HRESULT SetServer ( IWbemServices *serverArg ) ;
	HRESULT SetParentServer ( IWbemServices *parentServerArg ) ;

	BOOL AttachParentServer ( 

		WbemSnmpErrorObject &a_errorObject ,
		BSTR ObjectPath,
		IWbemContext *pCtx
	) ;

	BOOL ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject ) ;

protected:

public:

	CImpClasProv () ;
    ~CImpClasProv () ;

	void SetProvider ( IWbemServices *provider ) ;
	IWbemServices *GetParentServer () ;
	IWbemServices *GetServer () ;
	WbemNamespacePath *GetNamespacePath () ;
	wchar_t *GetThisNamespace () ;
	void SetThisNamespace ( wchar_t *thisNamespaceArg ) ;
	char *GetIpAddressString () { return ipAddressString ; }
	char *GetIpAddressValue () { return ipAddressValue ; }

	BOOL FetchSnmpNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	BOOL FetchNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	IWbemClassObject *GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;
	IWbemClassObject *GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	static BOOL s_Initialised ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

public:

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize (
			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pCIMOM,         // For anybody
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
		);
} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\corrsnmp.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORRSNMP
#define _SNMPCORR_CORRSNMP 

#include "snmpcl.h"

class CCorrResult
{
public:

	SnmpObjectIdentifier m_In;
	CCorrObjectID m_Out;
	SnmpErrorReport m_report;

	CCorrResult();
	~CCorrResult();
	void	DebugOutputSNMPResult() const;

};


class  CCorrNextId : public SnmpGetNextOperation
{
private:
	
	void ReceiveResponse();
	
	char *GetString(IN const SnmpObjectIdentifier &id);

	// the following two methods from SnmpGetNextOperation are 
	// over-ridden.

	void ReceiveVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error);

	void ReceiveErroredVarBindResponse(
		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind  ,
		IN const SnmpErrorReport &error);

protected:

	CCorrResult	*m_Results;
	UINT		m_ResultsCnt;
	UINT		m_NextResult;

	// this is a callback through which the CCorrNextId class returns the next_id
	// the callee must make a copy of the "next_id"
	// the Correlator_Info may take a value Local_Error
	virtual void ReceiveNextId(OUT const SnmpErrorReport &error,
			    			   OUT const CCorrObjectID &next_id) = 0;

	BOOL GetNextResult();

public:

	// constructor - creates an operation and passes the snmp_session to it
	CCorrNextId(IN SnmpSession &snmp_session);

	// frees the m_object_id_string if required
	~CCorrNextId();

	// in case of an error encountered while the method executes, 
	// ReceiveNextId(LocalError, NULL) will be called synchronously
	// otherwise, an asynchronous call to ReceiveNextId provides the next_id	
	void GetNextId(IN const CCorrObjectID const *object_ids, IN UINT len);

	void *operator()(void) const
	{
		return SnmpGetNextOperation::operator()();
	}
};



#endif // _SNMPCORR_CORRSNMP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\creclass.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

class SnmpClassEventObject ;
class SnmpCorrelation : public CCorrelator
{
private:
protected:

	SnmpSession *m_session ;
	SnmpClassEventObject *m_eventObject ;

public:

#ifdef CORRELATOR_INIT
	SnmpCorrelation ( SnmpSession &session , SnmpClassEventObject *eventObject ) ;
#else //CORRELATOR_INIT
	SnmpCorrelation ( SnmpSession &session , SnmpClassEventObject *eventObject , ISmirInterrogator *a_ISmirInterrogator ) ;
#endif //CORRELATOR_INIT
	~SnmpCorrelation () ;

	void Correlated ( IN const CCorrelator_Info &info , IN ISmirGroupHandle *phModule , IN const char* objectId = NULL ) ;
	void Finished ( IN const BOOL Complete ) ;
} ;

class SnmpClassEventObject : public SnmpTaskObject
{
private:
protected:

	BOOL m_inCallstack ;
	BOOL m_correlate ;
	BOOL m_synchronousComplete ;
	ULONG m_GroupsReceived ;
	WbemSnmpErrorObject m_errorObject ;
	CImpClasProv *m_provider ;
	IWbemClassObject *m_namespaceObject ;
	SnmpCorrelation *m_correlator ;
	IWbemContext *m_Context ;
	ISmirInterrogator *m_Interrogator ;

	BOOL GetAgentTransport ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentTransport ) ;
	BOOL GetAgentVersion ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentVersion ) ;
	BOOL GetAgentAddress ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentAddress ) ;
	BOOL GetAgentReadCommunityName ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentReadCommunityName ) ;
	BOOL GetAgentRetryCount ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentRetryCount ) ;
	BOOL GetAgentRetryTimeout( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentRetryTimeout ) ;
	BOOL GetAgentMaxVarBindsPerPdu ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentVarBindsPerPdu ) ;
	BOOL GetAgentFlowControlWindowSize ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentFlowControlWindowSize ) ;
	BOOL GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL GetTransportInformation ( WbemSnmpErrorObject &a_errorObject , SnmpSession *&session ) ;

	BOOL GetClass ( WbemSnmpErrorObject &a_errorObject , IWbemClassObject **classObject , BSTR a_Class ) ;
	virtual BOOL GetNotifyStatusObject ( IWbemClassObject **notifyObject ) ;
	virtual BOOL GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) ;

public:

	SnmpClassEventObject ( CImpClasProv *provider , IWbemContext *a_Context ) ;
	~SnmpClassEventObject () ;

	WbemSnmpErrorObject &GetErrorObject () { return m_errorObject ; }

	virtual void ReceiveGroup ( IN ISmirGroupHandle *phGroup ) = 0 ;
	virtual void ReceiveClass ( IN IWbemClassObject *classObject ) = 0 ;
	virtual void ReceiveError ( IN const SnmpErrorReport &errorReport ) = 0 ;
	virtual void ReceiveComplete () = 0 ;

} ;

class SnmpClassGetEventObject : public SnmpClassEventObject
{
private:
protected:

	BOOL m_Received ;
	wchar_t *m_Class ;
	IWbemClassObject *m_classObject ;

	BOOL GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) ;

public:

	SnmpClassGetEventObject ( CImpClasProv *provider , BSTR Class , IWbemContext *a_Context ) ;
	~SnmpClassGetEventObject () ;

	void ReceiveGroup ( IN ISmirGroupHandle *phGroup ) ;

	BOOL ProcessClass ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL ProcessCorrelatedClass ( WbemSnmpErrorObject &a_errorObject ) ;

	IWbemClassObject *GetClassObject () { m_classObject->AddRef () ; return m_classObject ; }

} ;

class SnmpClassGetAsyncEventObject : public SnmpClassGetEventObject
{
private:

	IWbemObjectSink *m_notificationHandler ;

protected:
public:

	SnmpClassGetAsyncEventObject ( CImpClasProv *provider , BSTR Class , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpClassGetAsyncEventObject () ;

	void Process () ;
	void ReceiveComplete () ;
	void ReceiveClass ( IWbemClassObject *classObject ) ;
	void ReceiveError ( IN const SnmpErrorReport &errorReport ) ;
} ;

class SnmpClassEnumEventObject : public SnmpClassEventObject 
{
private:
protected:

	wchar_t *m_Parent ;
	ULONG m_Flags ;

	BOOL ProcessClass ( WbemSnmpErrorObject &a_errorObject , BSTR a_Class ) ;
	BOOL GetEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL GetNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL GetExtendedNotificationEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpClassEnumEventObject ( CImpClasProv *provider , wchar_t *Parent , ULONG flags , IWbemContext *a_Context ) ;
	~SnmpClassEnumEventObject () ;

	void ReceiveGroup ( IN ISmirGroupHandle *phGroup ) ;

	BOOL ProcessEnumeration ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpClassEnumAsyncEventObject : public SnmpClassEnumEventObject
{
private:

	IWbemObjectSink *m_notificationHandler ;

protected:
public:

	SnmpClassEnumAsyncEventObject ( CImpClasProv *provider , wchar_t *Parent , ULONG flags , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpClassEnumAsyncEventObject () ;

	void Process () ;
	void ReceiveClass ( IWbemClassObject *classObject ) ;
	void ReceiveError ( IN const SnmpErrorReport &errorReport ) ;
	void ReceiveComplete () ;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtdefs.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTDEFS_H
#define _SNMP_EVT_PROV_EVTDEFS_H

//common strings
#define WBEMS_CLASS_PROP		L"__CLASS"
#define EVENT_ADDR_PROP		L"AgentAddress"
#define EVENT_TADDR_PROP	L"AgentTransportAddress"
#define EVENT_TRANS_PROP	L"AgentTransportProtocol"
#define EVENT_TIME_PROP		L"TimeStamp"
#define EVENT_SOID_PROP		L"Identification"
#define EVENT_COMM_PROP		L"Community"
#define EVENT_VBL_PROP		L"VarBindList"
#define EVENT_VBINDEX_QUAL	L"VarBindIndex"
#define ASN_OPAQUE			(CString(L"OPAQUE"))
#define ASN_NULL			(CString(L"NULL VALUE"))
#define ASN_INTEGER			(CString(L"INTEGER"))
#define ASN_TIME			(CString(L"TimeTicks"))
#define ASN_GUAGE			(CString(L"Guage"))
#define ASN_COUNTER			(CString(L"Counter"))
#define ASN_OID				(CString(L"OBJECT IDENTIFIER"))
#define ASN_ADDR			(CString(L"IpAddress"))
#define ASN_OCTET			(CString(L"OCTET STRING"))
#define ASN_UINT32			(CString(L"Unsigned32"))
#define ASN_COUNTER64		(CString(L"Counter64"))
#define ASN_NSI				(CString(L"noSuchInstance"))
#define ASN_EOMV			(CString(L"endOfMibView"))
#define ASN_NSO				(CString(L"noSuchObject"))
#define SNMP_ENT_OID		(SnmpObjectIdentifier("1.3.6.1.6.3.1.1.4.3.0"))
#define SNMP_TRAP_OID		(SnmpObjectIdentifier("1.3.6.1.6.3.1.1.4.1.0"))
#define SNMP_SYS_UP_OID		(SnmpObjectIdentifier("1.3.6.1.2.1.1.3.0"))
#define VB_ENCODING_PROP1	L"Encoding"
#define VB_OBJID_PROP2		L"ObjectIdentifier"
#define VB_VALUE_PROP3		L"Value"
#define VB_CLASS_PATH		L"SnmpVarBind"

#define MAPPER_CLASS_EVENTCLASSPROP	L"EventClassName"

#define THREAD_REG_KEY		L"Software\\Microsoft\\WBEM\\Providers\\SNMP\\Events"
#define THREAD_MARKS_VAL	L"StrobeCount"
#define THREAD_MARKS_MAX	60
#define THREAD_MARKS_DEF	1
#define THREAD_INTERVAL		1000*60 //a minute
#define THREAD_NAME			"SnmpEvtProv_Timer"

//Encapsulated strings
#define MAPPER_CLASS_PATH_PREFIX	L"NotificationMapper.SnmpTrapOID=\""
#define V2CLASS_NAME				L"SnmpV2Notification"
#define V1CLASS_NAME				L"SnmpV1Notification"

//Referent strings
#define EXTMAPPER_CLASS_PATH_PREFIX	L"ExtendedNotificationMapper.SnmpTrapOID=\""
#define V2EXTCLASS_NAME				L"SnmpV2ExtendedNotification"
#define V1EXTCLASS_NAME				L"SnmpV1ExtendedNotification"
#define EVENT_CIMTYPE_QUAL			L"CIMTYPE"
#define OBJECT_STR					L"object:"
#define OBJECT_STR_LEN				7
#define WHITE_SPACE_CHARS			L" \t\r\n"
#define FIXED_LENGTH_ATTRIBUTE		L"fixed_length"
#define KEY_ATTRIBUTE				L"key"
#define KEY_ORDER_ATTRIBUTE			L"key_order"
#define TEXT_CNVN_ATTRIBUTE			L"textual_convention"
#define OID_ATTRIBUTE				L"object_identifier"
#define TEXT_CNVN_INTEGER_VAL		L"INTEGER"
#define TEXT_CNVN_IP_ADDR_VAL		L"IpAddress"
#define TEXT_CNVN_OID_VAL			L"OBJECTIDENTIFIER"
#define TEXT_CNVN_OCTSTR_VAL		L"OCTETSTRING"

#endif //_SNMP_EVT_PROV_EVTDEFS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\correlat.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORELAT
#define _SNMPCORR_CORELAT 

#include <corafx.h>
#include <cordefs.h>
#include <objbase.h>
#include <wbemidl.h>
#include <smir.h>
#include <corstore.h>
#include <corrsnmp.h>
#include <correlat.h>
#include <notify.h>



//=================================================================================
//
//	class CCorrelator_Info
//
//	This class is used to return information about the correlation. An instance
//	of this class is passed as a parameter in the CCorrelator::Correlated call
//	back method. This class is derived from SnmpErrorReport. If there is an SNMP
//	error during correlation then this class will indicate an SNMP error and the
//	SnmpErrorReport methods can be used to determine what the error was. If there
//	is not an SNMP error the SnmpErrorReport methods will indicate success. However
//	there may still be a correlation error, so GetInfo should be called first to
//	see the nature of the correlation result.
//
//=================================================================================

class CCorrelator_Info : public 	SnmpErrorReport
{
public:


//	The following enumeration gives the error codes that the correlation
//	process can return. This is public so that we can see what's returned!
//	======================================================================

enum ECorrelationInfo
{	
	ECorrSuccess = 0,	//No errors occurred
	ECorrSnmpError,		//An SNMP session error, read the SnmpErrorReport
	ECorrInvalidGroup,	//An Invalid group has been found
	ECorrEmptySMIR,		//The SMIR contains no groups
	ECorrBadSession,	//The SNMP Session passed is invalid
	ECorrNoSuchGroup,	//The group passed is not in the SMIR (one shot correlation)
	ECorrGetNextError,	//Unexpected value returned from the SNMP operation
	ECorrSomeError		//Never used - place holder for further error codes.
};


private:
	
	
	//	Private Members
	//	===============

	ECorrelationInfo m_info; //Correlation error indication


public:
	

	//	Public Constructor
	//	==================

	CCorrelator_Info(IN const ECorrelationInfo& i, IN const SnmpErrorReport& snmpi) 
		: SnmpErrorReport(snmpi) { m_info = i;	}

	
	//	Public Methods
	//	==============

	//	Returns the error code for this object
	ECorrelationInfo	GetInfo() const { return m_info; }

	//	Sets the error code for this object 
	void				SetInfo(IN const ECorrelationInfo& info) { m_info = info; }

};

//=================================================================================
//
//	class CCorrelator
//
//	This class is used to correlate an agent on the network. It is derived from an
//	SnmpOperation class. It's constructor takes one parameter, an SnmpSession. This
//	parameter is used to create the SnmpOperation parent class and the correlation
//	will be performed in the context of this session. To perform correlation derive
//	from this class and override the Correlated method. The Correlated method will
//	be called asynchronously when a group has been found to be supported by the
//	agent. To start the correlation procedure off after creating a CCorrelator
//	object you have to call the Start method. This takes an optional parameter, if
//	the parameter is specified then a single shot correlation is performed for the
//	object id passed as the parameter (as a string). If the parameter is not used
//	then all the groups supported by the agent that exist in the SMIR will be
//	returned.
//
//=================================================================================

class CCorrelator : public CCorrNextId
{
private:


	//	Private Members
	//	===============

	BOOL					m_inProg;		//Is correlation in progress
	CCorrCache*				m_pCache;		//Pointer to the global cache
	POSITION				m_rangePos;		//The current position in the range list
	CCorrRangeTableItem*	m_pItem;		//Pointer to the current range list item
	CCorrGroupMask*			m_Groups;		//A mask used to indicate groups found
	BOOL					m_NoEntries;	//Is the SMIR empty
	CCorrObjectID*			m_group_OID;	//Single correlation group id
	UINT					m_VarBindCnt;	//Max number of VarBinds per GetNext op

	//	Private Methods
	//	===============

	void		Initialise();
	void		Reset();
	BOOL		ProcessOID(IN const SnmpErrorReport& error, IN const CCorrObjectID& OID);
	void		ReceiveNextId(IN const SnmpErrorReport &error,
								IN const CCorrObjectID &next_id);
	void		ReadRegistry();
	void		GetNextOIDs();
	BOOL		IsItemFromGroup() const;
	void		ScanAndSkipResults();

protected:

	//	Protected Constructor
	//	=====================

#ifdef CORRELATOR_INIT
	CCorrelator(IN SnmpSession &session);
#else //CORRELATOR_INIT
	CCorrelator(IN SnmpSession &session, IN ISmirInterrogator *a_ISmirInterrogator);
#endif //CORRELATOR_INIT


	//	Protected Methods
	//	=================

	//Call backs
	virtual void	Correlated(IN const CCorrelator_Info &info, IN ISmirGroupHandle *phModule,
								IN const char* objectId = NULL) = 0;
	virtual void	Finished(IN const BOOL Complete) = 0;


public:


	//	Public Methods
	//	==============

	BOOL	Start(IN const char* groupId = NULL);
	void	DestroyCorrelator();
	static void	TerminateCorrelator(ISmirDatabase** a_ppNotifyInt, CCorrCacheNotify** a_ppnotify);
	static void StartUp(ISmirInterrogator *a_ISmirInterrogator = NULL );

	//	Public Destructor
	//	=================

	virtual	~CCorrelator();
};


#endif //_SNMPCORR_CORELAT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\corstore.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_CORSTORE
#define _SNMPCORR_CORSTORE 

class CCorrelator;

typedef ULONG TCorrMaskLength;
typedef ULONG TCorrMaskUnit;

enum ECorrCompResult
{
	ECorrAreEqual = 0,
	ECorrFirstLess,
	ECorrFirstGreater,
	ECorrNotEqual
};

class CCorrGroupMask
{

private:

	TCorrMaskLength	m_size;
	TCorrMaskUnit*	m_mask;

public:

			CCorrGroupMask(IN const TCorrMaskLength sze);
	BOOL	IsBitSet(IN const TCorrMaskLength bit) const;
	void	SetBit(IN const TCorrMaskLength bit, IN const BOOL On = TRUE);
			~CCorrGroupMask();
};

class CCorrObjectID
{

private:

	UINT	m_length;
	UINT*	m_Ids;

public:

	//Creates a CCorrObjectID from dotted string
				CCorrObjectID(IN const char* str);

	//Creates a copy of an existing CCorrObjectID
				CCorrObjectID(IN const CCorrObjectID& ID);

	//Creates a CCorrObjectID from an array of UINTS and a length
	//also defaults to constructing an empty CCorrObjectID
				CCorrObjectID(IN const UINT* ids = NULL,
					IN const UINT len = 0);

	ECorrCompResult	CompareWith(IN const CCorrObjectID& second) const;
	BOOL			IsSubRange(IN const CCorrObjectID& child) const;
	wchar_t*		GetWideString()const; //a newly allocated wchar_t* is returned caller must delete []!!
	char*			GetString()const; //a newly allocated char* is returned caller must delete []!!
	void			GetString(CString& str) const;
	UINT			GetLength() const { return m_length; }
	const UINT*		GetIds() const { return m_Ids; }
	void			Set(IN const UINT* ids = NULL, IN const UINT len = 0);
	
	//Deletes any memory used for Ids
				virtual ~CCorrObjectID();

//boolean operators
	BOOL			operator ==(IN const CCorrObjectID& second) const;
	BOOL			operator !=(IN const CCorrObjectID& second) const;
	BOOL			operator <=(IN const CCorrObjectID& second) const;
	BOOL			operator >=(IN const CCorrObjectID& second) const;
	BOOL			operator >(IN const CCorrObjectID& second) const;
	BOOL			operator <(IN const CCorrObjectID& second) const;
//assignment operators
	CCorrObjectID&	operator =(IN const CCorrObjectID& ID);
	CCorrObjectID&	operator +=(IN const CCorrObjectID& ID);
//unary
	CCorrObjectID&	operator ++();
	CCorrObjectID&	operator --();
	CCorrObjectID&	operator -=(IN const UINT sub);
	CCorrObjectID&	operator /=(IN const UINT sub);
};


class CCorrEncodedOID
{

private:

	UINT	m_length;
	UCHAR*	m_ids;
	UCHAR	m_chopped;

public:

	CCorrEncodedOID(IN const CCorrObjectID& src_oid);
	CCorrEncodedOID() : m_ids(NULL), m_length(0), m_chopped(0) {}
	void ExtractOID(OUT CCorrObjectID& oid) const;
	void Set(IN const CCorrObjectID& src_oid);

	~CCorrEncodedOID();
};


class CCorrGroupIdItem : public CObject
{

private:

	CCorrEncodedOID		m_groupId;
	TCorrMaskLength		m_index;

public:
							CCorrGroupIdItem(IN const CCorrObjectID& ID,
												IN ISmirGroupHandle* grpH); 
	void					GetGroupID(OUT CCorrObjectID& ID) const;
	void					SetIndex(IN const TCorrMaskLength i) { m_index = i; }
	const TCorrMaskLength&	GetIndex()const { return m_index; }
	virtual					~CCorrGroupIdItem(); 

	CList<ISmirGroupHandle*, ISmirGroupHandle*> m_groupHandles;

	void					DebugOutputItem(CString* msg = NULL) const;

};


class CCorrRangeTableItem : public CObject
{

private:

	CCorrEncodedOID		m_startRange;
	CCorrEncodedOID		m_endRange;
	CCorrGroupIdItem*	m_groupId;


public:
	
enum ECorrRangeResult
{
	ECorrInRange = 0,
	ECorrBeforeStart,
	ECorrAfterEnd,
	ECorrEqualToStart,
	ECorrEqualToEnd
};


						CCorrRangeTableItem(IN const CCorrObjectID& startID,
											IN const CCorrObjectID& endID,
											IN CCorrGroupIdItem* grpID); 
	BOOL				GetStartRange(OUT CCorrObjectID& start) const;
	BOOL				GetEndRange(OUT CCorrObjectID& end) const;
	CCorrGroupIdItem*	GetGroupIdPtr() { return m_groupId; }
	ECorrRangeResult	IsInRange(IN const CCorrObjectID& ID) const;
	virtual				~CCorrRangeTableItem();

	void				DebugOutputRange() const;

};


class CCorrGroupArray : public CTypedPtrArray< CObArray, CCorrGroupIdItem* >
{

public:

			CCorrGroupArray();

	void	Sort();

			~CCorrGroupArray();
};

class CCorrRangeList : public CTypedPtrList< CObList, CCorrRangeTableItem* >
{

public:


	BOOL					Add(IN CCorrRangeTableItem* newItem);
	BOOL					GetLastEndOID(OUT CCorrObjectID& end) const;

							~CCorrRangeList();
};


class CCorrCache
{

private:

	CCriticalSection	m_Lock;
	DWORD				m_Ref_Count;
	BOOL				m_ValidCache;
	CCorrRangeList		m_rangeTable;
	CCorrGroupArray		m_groupTable;
	CCorrGroupMask*		m_Groups;
	TCorrMaskLength		m_size;


	BOOL		BuildCacheAndSetNotify( ISmirInterrogator *a_ISmirInterrogator );
	BOOL		BuildRangeTable();
	//the last two parameters are defunct now we're using a CObArray!!
	//get rid of them.
	void		DoGroupEntry(UINT* current, UINT* next,
								TCorrMaskLength* cIndex, TCorrMaskLength* nIndex);


public:

							CCorrCache( ISmirInterrogator *p_ISmirInterrogator = NULL );

	TCorrMaskLength&		GetSize() { return m_size; }
	void					AddRef();
	void					DecRef();
	POSITION				GetHeadRangeTable() { return m_rangeTable.GetHeadPosition(); }
	CCorrRangeTableItem*	GetNextRangeTable(POSITION* rPos)
													{ return m_rangeTable.GetNext(*rPos); }
	void					InvalidateCache();

							~CCorrCache();

};

class CCorrCacheWrapper
{

private:

	CCorrCache* m_CachePtr;
	CCriticalSection* m_lockit;


public:

	CCorrCacheWrapper(IN CCorrCache* cachePtr = NULL);
	~CCorrCacheWrapper();

	CCorrCache* GetCache();
	void SetCache(IN CCorrCache* cachePtr){ m_CachePtr = cachePtr; }
	void ReleaseCache() { m_lockit->Unlock(); }
};


#endif //_SNMPCORR_CORSTORE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtmap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTMAP_H
#define _SNMP_EVT_PROV_EVTMAP_H

class CWbemServerWrap;

typedef enum tag_NameElementType
    {	MYWBEM_NAME_ELEMENT_TYPE_PROPERTY	= 0,
		MYWBEM_NAME_ELEMENT_TYPE_INDEX	= 1
    }	MYWBEM_NAME_ELEMENT_TYPE;

typedef union tag_NameElementUnion
    {
		WCHAR* m_wszPropertyName;
		long m_lArrayIndex;
    }	MYWBEM_NAME_ELEMENT_UNION;

typedef struct  tag_NameElement
    {
		short m_nType;
		MYWBEM_NAME_ELEMENT_UNION Element;
    }	MYWBEM_NAME_ELEMENT;

typedef struct  _tag_WbemPropertyName
    {
		long m_lNumElements;
		MYWBEM_NAME_ELEMENT __RPC_FAR *m_aElements;
    }	WBEM_PROPERTY_NAME;

struct VarBindObjectStruct
{
	BOOL fDone;
	SnmpVarBind* pVarBind;
};

struct VarBindObjectArrayStruct
{
	VarBindObjectStruct* vbs;
	UINT length;

	VarBindObjectArrayStruct(VarBindObjectStruct* a_vbs, UINT a_length) : vbs(a_vbs), length(a_length) {}
};


class CMapToEvent
{
protected:

	CString				m_addr;				//sending address
	CString				m_ctxt;				//sending context
	CString				m_oid;				//snmptrap OID
	CString				m_transport;		//the transport protocol
	CString				m_class;			//the event class name
	IWbemClassObject	*m_object;			//the actual event instance which has been "spawned"
	CWbemServerWrap		*m_nspace;			//the namespace we are working in
	IWbemClassObject	*m_vbdefn;			//the snmpvarbind class object
	BOOL				m_btriedGeneric;	//indicates if the generic class has been tried
	BOOL				m_btryGeneric;		//indicates that the generic class should be tried
	BOOL				m_bCheckedVersion;	//indicates whether the version has been determined
	BOOL				m_bSNMPv1;			//indicates the SNMP version
	VarBindObjectArrayStruct	m_vbs;		//the varbinds

	CMapToEvent();
	
	//sets the m_class variable. if btryGeneric is set gets the generic class.
	//if m_btryGeneric is not set and a generic class is returned m_btriedGeneric
	//must be set to true.
	virtual BOOL GetClass();

	virtual BOOL GetSpecificClass() = 0;
	virtual const wchar_t* GetV1Class() = 0;
	virtual const wchar_t* GetV2Class() = 0;

	void GetClassInstance(IWbemClassObject** ppObj);

	virtual HRESULT GetStandardProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);

	virtual HRESULT GetPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);

	virtual HRESULT GetSpecificPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue) = 0;

	virtual HRESULT GetVBProperty(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);

	BOOL IsSNMPv1();

	IWbemClassObject*	GetVBClassDefn();
	IWbemClassObject*	GetVBClassObjectByIndex(UINT index);
	BOOL				GetVBPropValueByIndex(UINT index, CString& type, VARIANT& vval);
	BOOL				GetVBPropOIDByIndex(UINT index, VARIANT& vOid);

public:

	enum EMappingType
	{
		REFERENT_MAPPER = 0,
		ENCAPSULATED_MAPPER = 1
	};

	virtual void ResetData();

	virtual void GenerateInstance(IWbemClassObject** ppInst) = 0;

	BOOL TriedGeneric() { return m_btriedGeneric; }

	void SetTryGeneric();

	void SetData(const char* sender_addr,
					const char* security_Context,
					const char* snmpTrapOid,
					const char* transport,
					SnmpVarBindList& vbList,
					CWbemServerWrap* nspace);

	virtual ~CMapToEvent();
};


#endif //_SNMP_EVT_PROV_EVTMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtencap.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTENCAP_H
#define _SNMP_EVT_PROV_EVTENCAP_H

class CEncapMapper : public CMapToEvent
{
private:

	BOOL GetSpecificClass();
	const wchar_t*	GetV1Class() { return V1CLASS_NAME; }
	const wchar_t*	GetV2Class() { return V2CLASS_NAME; }
	WbemSnmpClassObject* m_WbemSnmpObj;
	BOOL SetAndGetProperty(WbemSnmpProperty *hmmSnmpProp, VARIANT *pvValue);

public:

	CEncapMapper();

	HRESULT GetSpecificPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);
	
	void GenerateInstance(IWbemClassObject** ppInst);
	void ResetData();

	~CEncapMapper();

};


#endif //_SNMP_EVT_PROV_EVTENCAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtprov.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTPROV_H
#define _SNMP_EVT_PROV_EVTPROV_H

template <> inline BOOL AFXAPI CompareElements<CString, LPCWSTR>(const CString* pElement1, const LPCWSTR* pElement2)
{
	//return TRUE if equal
	return (pElement1->CompareNoCase(*pElement2) == 0);
}

template <> inline UINT AFXAPI HashKey <LPCWSTR> (LPCWSTR key)
{
	CString tmp(key);
	tmp.MakeUpper();
	return HashKeyLPCWSTR((const WCHAR*)tmp);
}

class CWbemServerWrap
{
private:

	LONG m_ref;
	IWbemServices *m_Serv;
	CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*> m_ClassMap;

public:

		CWbemServerWrap(IWbemServices *pServ);
	
	ULONG	AddRef();
	ULONG	Release();

	IWbemServices*	GetServer() { return m_Serv; }
	HRESULT			GetObject(BSTR a_path, IWbemContext *a_pCtx, IWbemClassObject **a_ppObj);
	HRESULT			GetMapperObject(BSTR a_path, IWbemContext *a_pCtx, IWbemClassObject **a_ppObj);

		~CWbemServerWrap();
};


class CTrapEventProvider : public IWbemEventProvider, public IWbemProviderInit
{

private:

	CWbemServerWrap*			m_pNamespace;
	IWbemObjectSink*			m_pEventSink;
	CEventProviderThread*	m_thrd;
	LONG					m_ref;
	
	//copy constuctor not defined so not allowed!
	CTrapEventProvider(CTrapEventProvider&);
	void operator=(const CTrapEventProvider&);


public:

	DWORD			m_MapType;

		CTrapEventProvider(DWORD mapperType, CEventProviderThread* thrd);

	CWbemServerWrap*	GetNamespace();
	IWbemObjectSink*	GetEventSink();
    void				AddRefAll();
    void				ReleaseAll();

		~CTrapEventProvider();

	//interface methods
	//==================
    STDMETHODIMP ProvideEvents(
                IWbemObjectSink* pSink,
                LONG lFlags
            );

    STDMETHODIMP         QueryInterface(REFIID riid, PVOID* ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();


	/* IWbemProviderInit methods */

	STDMETHODIMP Initialize (
				LPWSTR pszUser,
				LONG lFlags,
				LPWSTR pszNamespace,
				LPWSTR pszLocale,
				IWbemServices *pCIMOM,         // For anybody
				IWbemContext *pCtx,
				IWbemProviderInitSink *pInitSink     // For init signals
			);

};

#endif //_SNMP_EVT_PROV_EVTPROV_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtreft.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTREFT_H
#define _SNMP_EVT_PROV_EVTREFT_H

struct CIMTypeStruct
{
	BOOL fObject;
	CString strType;
};


class CReferentMapper : public CMapToEvent
{
private:

	BOOL			GetSpecificClass();
	const wchar_t*	GetV1Class() { return V1EXTCLASS_NAME; }
	const wchar_t*	GetV2Class() { return V2EXTCLASS_NAME; }
	HRESULT			GetTypeAndIndexQuals(const wchar_t* prop,
											CIMTypeStruct& type,
											ULONG& index);

	HRESULT			CreateEmbeddedProperty(IWbemClassObject** ppObj,
											ULONG index,
											const wchar_t* propertyName,
											const wchar_t* className);

public:

	CReferentMapper();

	HRESULT GetSpecificPropertyValue(long lNumElements,
										MYWBEM_NAME_ELEMENT *aElements,
										long lFlags,
										VARIANT *pvValue);
	
	void GenerateInstance(IWbemClassObject** ppInst);
	void ResetData();

	~CReferentMapper();

};


#endif //_SNMP_EVT_PROV_EVTREFT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\notify.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPCORR_NOTIFY
#define _SNMPCORR_NOTIFY

class CBaseCorrCacheNotify : public ISMIRNotify
{

    private:
        ULONG	m_cRef;     //Reference count
		DWORD	m_dwCookie;	//Returned by ADVISE used for UNADVISE
	protected:
		CRITICAL_SECTION m_CriticalSection;
		BOOL	m_DoWork;


    public:
				CBaseCorrCacheNotify();
        virtual	~CBaseCorrCacheNotify();

        //IUnknown members
        STDMETHODIMP			QueryInterface(REFIID, void **);
        STDMETHODIMP_(DWORD)	AddRef();
        STDMETHODIMP_(DWORD)	Release();

		void SetCookie(DWORD c)	{ m_dwCookie = c; }
		void Detach();
		DWORD GetCookie()		{ return m_dwCookie; }
};

class CCorrCacheNotify : public CBaseCorrCacheNotify
{
        STDMETHODIMP			ChangeNotify();
};

class CEventCacheNotify : public CBaseCorrCacheNotify
{
        STDMETHODIMP			ChangeNotify();
};

#endif //_SNMPCORR_NOTIFY
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propdel.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPDEL_H
#define __PROPDEL_H

class DeleteInstanceAsyncEventObject : public SnmpSetResponseEventObject 
{
private:

	SnmpSession *session ;
	SetOperation *operation ;

	ULONG m_State ;
	IWbemObjectSink *m_NotificationHandler ;
	wchar_t *m_ObjectPath ;
	wchar_t *m_Class ;
	ParsedObjectPath *m_ParsedObjectPath ;
	CObjectPathParser m_ObjectPathParser ;
	SnmpSetClassObject snmpObject ;

protected:

	void ProcessComplete () ;
	BOOL Delete ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL DeleteInstance ( WbemSnmpErrorObject &a_ErrorObject ) ;

public:

	DeleteInstanceAsyncEventObject ( 

		CImpPropProv *a_Provider , 
		wchar_t *a_ObjectPath , 
		ULONG a_Flag , 
		IWbemObjectSink *a_NotificationHandler ,
		IWbemContext *pCtx
	) ;

	~DeleteInstanceAsyncEventObject () ;

	void Process () ;
	void ReceiveComplete () ;
	void SnmpTooBig () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
} ;

#endif // __PROPDEL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propget.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPGET_H
#define __PROPGET_H

class SnmpGetResponseEventObject : public SnmpResponseEventObject
{
private:
protected:

	SnmpSession *session ;
	GetOperation *operation ;

	IWbemClassObject *classObject ;
	IWbemClassObject *instanceObject ;
	SnmpGetClassObject snmpObject ;
	BOOL processComplete ;

	BOOL SendSnmp ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpGetResponseEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemContext *a_Context ) ;
	~SnmpGetResponseEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	IWbemClassObject *GetClassObject () { return classObject ; }
	IWbemClassObject *GetInstanceObject () { return instanceObject ; }
} ;

class SnmpGetEventObject : public SnmpGetResponseEventObject
{
private:
protected:

	wchar_t *objectPath ;
	
	BOOL GetInstanceClass ( WbemSnmpErrorObject &a_errorObject , BSTR Class ) ;
	BOOL DispatchKeyLessClass ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) ;
	BOOL SetProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property , KeyRef *a_KeyReference ) ;
	BOOL SetClassKeySpecKey ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) ;
	BOOL DispatchClassKeySpec ( WbemSnmpErrorObject &a_errorObject , wchar_t *a_Class ) ;
	BOOL SetInstanceSpecKeys ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL DispatchInstanceSpec ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL DispatchObjectPath ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL DispatchObjectReference ( WbemSnmpErrorObject &a_errorObject , ParsedObjectPath *t_ParsedObjectPath ) ;
	BOOL ParseObjectPath ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpGetEventObject ( CImpPropProv *provider , wchar_t *ObjectPath , IWbemContext *a_Context ) ;
	~SnmpGetEventObject () ;

} ;

class SnmpGetAsyncEventObject : public SnmpGetEventObject
{
private:

	ULONG state ;
	IWbemObjectSink *notificationHandler ;

protected:
public:

	SnmpGetAsyncEventObject ( CImpPropProv *provider , wchar_t *ObjectPath , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpGetAsyncEventObject () ;

	void Process () ;

	void ReceiveComplete () ;
} ;

#endif // __PROPGET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\evtthrd.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMP_EVT_PROV_EVTTHRD_H
#define _SNMP_EVT_PROV_EVTTHRD_H

#include <windows.h>
#include <provexpt.h>

class CTrapEventProvider;
class CEventProviderThread;
class CMapToEvent;

struct SCacheEntry
{
public:
	IWbemClassObject* m_Class;
	DWORD m_Marker;

	SCacheEntry(IWbemClassObject *a_Class)
	{
		m_Class = a_Class;
		m_Marker = 0;
	}
};

template <> inline void AFXAPI  DestructElements<SCacheEntry*> (SCacheEntry** ptr_e, int x)
{
	//x is always one for a CMap!
	if ( (ptr_e != NULL) && (*ptr_e != NULL) )
	{
		if ((*ptr_e)->m_Class != NULL)
		{
			(*ptr_e)->m_Class->Release();
		}

		delete *ptr_e;
	}
}



class MySnmpV1Security : public SnmpV1Security
{
public:
	MySnmpV1Security(const SnmpV1Security& sec) : SnmpV1Security(sec){}
	const char* GetName()const {return GetCommunityName();}
};


class CControlObjectMap : public CMap< UINT, UINT, CTrapEventProvider*, CTrapEventProvider* >
{
private:

	UINT HashKey(UINT key) { return key; }
	CCriticalSection m_Lock;

public:

	BOOL Lock() { return m_Lock.Lock(); }
	BOOL Unlock() { return m_Lock.Unlock(); }
};

					
class CTrapListener : public SnmpTrapReceiver
{

private:

	CEventProviderThread*	m_pParent;
	LONG					m_Ref;


public:

			CTrapListener(CEventProviderThread* parentptr);
	
	void	Receive(SnmpTransportAddress &sender_addr,
						SnmpSecurity &security_context,
						SnmpVarBindList &vbList);
	void	Destroy();

			~CTrapListener() {}
};

class CTrapData
{
private:
	LONG m_Ref;

public:

	char			m_static_sender_addr [ 32 ] ;
	char			*m_sender_addr;

	char			*m_security_context;
	char			m_static_security_context [ 32 ] ;

	char			*m_trap_oid;
	char			m_static_trap_oid [ 32 ] ;

	char			*m_transport;
	char			m_static_transport [ 32 ] ;

	SnmpVarBindList	m_variable_bindings;

		CTrapData (const char* sender_addr,
					const char* security_Context,
					const char* snmpTrapOid,
					const char* trnsp,
					SnmpVarBindList& vbList);
	LONG AddRef();
	LONG Release();

		~CTrapData();

};

class CTrapProcessTaskObject : public SnmpTaskObject
{
private:

	CTrapData			*m_trap_data;
	CTrapEventProvider	*m_Cntrl;

protected:
public:

	CTrapProcessTaskObject (CTrapData *pTData, CTrapEventProvider* pCntrl) ;

	~CTrapProcessTaskObject();

	void Process () ;
	void ProcessEncapsulated () ;
	void ProcessReferent () ;

} ;

class CEventProviderWorkerThread;

class TimerRegistryTaskObject : public SnmpTaskObject
{
private:

	HKEY m_LogKey ;
	CEventProviderWorkerThread *m_parent;

protected:
public:

	TimerRegistryTaskObject (CEventProviderWorkerThread *parent) ;
	~TimerRegistryTaskObject () ;

	void Process () ;
	void ReadRegistry();

	void SetRegistryNotification () ;
} ;

class CWbemServerWrap ;
class CEventProviderWorkerThread : public SnmpThreadObject
{
private:

	void Initialise();
	void Uninitialise();
	void TimedOut();
	
	DWORD m_TimeOut;
	DWORD m_MaxMarks;
	TimerRegistryTaskObject *m_RegTaskObject;
	ISmirDatabase *m_pNotifyInt;
	CEventCacheNotify *m_notify;
	CMap<DWORD, DWORD,
		CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>*,
		CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>*> m_Classes;

	CWbemServerWrap *m_pSmirNamespace ;

public:

		CEventProviderWorkerThread();

	void AddClassesToCache(DWORD_PTR key, CMap<CString, LPCWSTR, SCacheEntry*, SCacheEntry*>* item);
	void RemoveClassesFromCache(DWORD_PTR key);
	void SetMaxMarks(DWORD dwM);
	void Clear();
	
	CWbemServerWrap *GetServerWrap () { return m_pSmirNamespace ; } ;
	void CreateServerWrap () ;
	void GetDeleteNotifyParams(ISmirDatabase** a_ppNotifyInt, CEventCacheNotify** a_ppNotify);

		~CEventProviderWorkerThread();

};

class CEventProviderThread
{
private:

	CTrapListener*					m_Ear;
	CControlObjectMap				m_ControlObjects;

public:

	CEventProviderThread() : m_Ear(NULL) {}

	BOOL Register(CTrapEventProvider* prov);
	void UnRegister(CTrapEventProvider* prov);

	virtual void	ProcessTrap(const char* sender_addr,
						const char* security_Context,
						const char* snmpTrapOid,
						const char* trnsp,
						SnmpVarBindList& vbList);

};



#endif //_SNMP_EVT_PROV_EVTTHRD_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propprov.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _SNMPPropertyProvider_H_
#define _SNMPPropertyProvider_H_

extern CRITICAL_SECTION s_ProviderCriticalSection ;

class SnmpInstanceDefaultThreadObject : public SnmpThreadObject
{
private:
protected:
public:

	SnmpInstanceDefaultThreadObject ( const char *threadName = NULL ) : SnmpThreadObject ( threadName ) {} ;
	~SnmpInstanceDefaultThreadObject () {} ;

	void Initialise () ;
	void Uninitialise () { CoUninitialize () ; }

} ;

class CImpPropProv : public IWbemServices , public IWbemProviderInit
{
private:

	BOOL initialised ;
	LONG m_referenceCount ;         //Object reference count

	CCriticalSection criticalSection ;

	WbemNamespacePath namespacePath ;
	wchar_t *thisNamespace ;

	IWbemServices *server ;
	IWbemServices *parentServer ;
	IWbemProviderInitSink *m_InitSink ;
	char *ipAddressString ;
	char *ipAddressValue ;

	wchar_t *m_localeId ;

	BOOL m_getNotifyCalled ;
	BOOL m_getSnmpNotifyCalled ;
	CCriticalSection m_notificationLock;
	CCriticalSection m_snmpNotificationLock;
	IWbemClassObject *m_notificationClassObject ;
	IWbemClassObject *m_snmpNotificationClassObject ;

private:
	
	HRESULT SetServer ( IWbemServices *serverArg );
	HRESULT SetParentServer ( IWbemServices *parentServerArg ) ;

	BOOL AttachParentServer ( 

		WbemSnmpErrorObject &a_errorObject ,
		BSTR Namespace, 
		IWbemContext *pCtx
	) ;

	BOOL ObtainCachedIpAddress ( WbemSnmpErrorObject &a_errorObject ) ;

protected:
public:

	CImpPropProv () ;
    ~CImpPropProv () ;

	static BOOL s_Initialised ;

	// Implementation

	IWbemServices *GetServer () ;
	IWbemServices *GetParentServer () ;
	WbemNamespacePath *GetNamespacePath () { return & namespacePath ; }
	wchar_t *GetThisNamespace () ;
	void SetThisNamespace ( wchar_t *thisNamespaceArg ) ;
	void SetLocaleId ( wchar_t *localeId ) ;
	wchar_t *GetLocaleId () { return m_localeId ; }

	char *GetIpAddressString () { return ipAddressString ; }
	char *GetIpAddressValue () { return ipAddressValue ; }

	BOOL FetchSnmpNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	BOOL FetchNotificationObject ( 

		WbemSnmpErrorObject &a_errorObject ,
		IWbemContext *a_Ctx
	) ;

	IWbemClassObject *GetNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;
	IWbemClassObject *GetSnmpNotificationObject ( WbemSnmpErrorObject &a_errorObject ) ;

	//Non-delegating object IUnknown

    STDMETHODIMP QueryInterface ( REFIID , LPVOID FAR * ) ;
    STDMETHODIMP_( ULONG ) AddRef () ;
    STDMETHODIMP_( ULONG ) Release () ;

    /* IWbemServices methods */

        HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ const BSTR Namespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult) ;
        
        HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink) ;
        
        HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ const BSTR Superclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ const BSTR Class,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
        HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ const BSTR QueryLanguage,
            /* [in] */ const BSTR Query,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;

        HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
        HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ const BSTR ObjectPath,
            /* [in] */ const BSTR MethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
        

	/* IWbemProviderInit methods */

		HRESULT STDMETHODCALLTYPE Initialize(

			/* [in] */ LPWSTR pszUser,
			/* [in] */ LONG lFlags,
			/* [in] */ LPWSTR pszNamespace,
			/* [in] */ LPWSTR pszLocale,
			/* [in] */ IWbemServices *pCIMOM,         // For anybody
			/* [in] */ IWbemContext *pCtx,
			/* [in] */ IWbemProviderInitSink *pInitSink     // For init signals
			);        

} ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\guids.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

// {1F517A23-B29C-11cf-8C8D-00AA00A4086C}
DEFINE_GUID(CLSID_CPropProvClassFactory, 
0x1f517a23, 0xb29c, 0x11cf, 0x8c, 0x8d, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

// {70426720-F78F-11cf-9151-00AA00A4086C}
DEFINE_GUID(CLSID_CClasProvClassFactory,
0x70426720, 0xf78f, 0x11cf, 0x91, 0x51, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);

// {9D5BED16-0765-11d1-AB2C-00C04FD9159E}
DEFINE_GUID(CLSID_CSNMPReftEventProviderClassFactory, 
0x9d5bed16, 0x765, 0x11d1, 0xab, 0x2c, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);

// {19C813AC-FEE7-11d0-AB22-00C04FD9159E}
DEFINE_GUID(CLSID_CSNMPEncapEventProviderClassFactory, 
0x19c813ac, 0xfee7, 0x11d0, 0xab, 0x22, 0x0, 0xc0, 0x4f, 0xd9, 0x15, 0x9e);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propinst.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPINST_H
#define __PROPINST_H

class SnmpInstanceClassObject : public SnmpClassObject
{
private:

	BOOL CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ) ;

protected:

public:

	SnmpInstanceClassObject ( SnmpResponseEventObject *parentOperation ) ;
	SnmpInstanceClassObject ( const SnmpInstanceClassObject & snmpInstanceClassObject ) ;
	~SnmpInstanceClassObject () ;

	BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;

} ;

class SnmpInstanceResponseEventObject : public SnmpResponseEventObject 
{
private:
protected:

	SnmpSession *session ;
	AutoRetrieveOperation *operation ;

	IWbemClassObject *classObject ;
	IWbemClassObject *instanceObject ;
#if 0
	IWbemObjectAccess *instanceAccessObject ;
#endif
	SnmpInstanceClassObject snmpObject ;

	PartitionSet *m_PartitionSet ;

	BOOL SendSnmp ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpInstanceResponseEventObject ( CImpPropProv *provider , IWbemContext *a_Context ) ;
	~SnmpInstanceResponseEventObject () ;

	IWbemClassObject *GetClassObject () { return classObject ; }
	IWbemClassObject *GetInstanceObject () { return instanceObject ; }
#if 0
	IWbemObjectAccess *GetInstanceAccessObject () { return instanceAccessObject ; }
#endif

	PartitionSet *GetPartitionSet () { return m_PartitionSet ; }

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	SnmpClassObject *GetSnmpRequestClassObject () { return & snmpObject ; }

	virtual void ReceiveRow ( SnmpInstanceClassObject *snmpObject ) = 0 ;
	virtual void ReceiveRow ( IWbemClassObject *snmpObject ) {}
} ;

class SnmpInstanceEventObject : public SnmpInstanceResponseEventObject
{
private:
protected:

	wchar_t *Class ;

public:

	SnmpInstanceEventObject ( CImpPropProv *provider , BSTR Class , IWbemContext *a_Context ) ;
	~SnmpInstanceEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }

	BOOL Instantiate ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpInstanceAsyncEventObject : public SnmpInstanceEventObject
{
private:

	ULONG state ;
	IWbemObjectSink *notificationHandler ;

protected:
public:

	SnmpInstanceAsyncEventObject ( CImpPropProv *provider , BSTR Class , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpInstanceAsyncEventObject () ;

	void Process () ;
	void ReceiveRow ( SnmpInstanceClassObject *snmpObject ) ;
	void ReceiveRow ( IWbemClassObject *snmpObject ) ;
	void ReceiveComplete () ;
} ;

#endif // __PROPINST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propquery.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPQUERY_H
#define __PROPQUERY_H

#define SYSTEM_PROPERTY_CLASS				L"__CLASS"
#define SYSTEM_PROPERTY_SUPERCLASS			L"__SUPERCLASS"
#define SYSTEM_PROPERTY_DYNASTY				L"__DYNASTY"
#define SYSTEM_PROPERTY_DERIVATION			L"__DERIVATION"
#define SYSTEM_PROPERTY_GENUS				L"__GENUS"
#define SYSTEM_PROPERTY_NAMESPACE			L"__NAMESPACE"
#define SYSTEM_PROPERTY_PROPERTY_COUNT		L"__PROPERTY_COUNT"
#define SYSTEM_PROPERTY_SERVER				L"__SERVER"
#define SYSTEM_PROPERTY_RELPATH				L"__RELPATH"
#define SYSTEM_PROPERTY_PATH				L"__PATH"

#include <provtree.h>
#include <provdnf.h>

class SnmpQueryEventObject : public SnmpInstanceResponseEventObject , public QueryPreprocessor
{
protected:

	WmiTreeNode *AllocTypeNode ( 

		void *a_Context ,
		BSTR a_PropertyName , 
		VARIANT &a_Variant , 
		WmiValueNode :: WmiValueFunction a_PropertyFunction ,
		WmiValueNode :: WmiValueFunction a_ConstantFunction ,
		WmiTreeNode *a_Parent 
	) ;

	QuadState InvariantEvaluate ( 

		void *a_Context ,
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	WmiRangeNode *AllocInfiniteRangeNode (

		void *a_Context ,
		BSTR a_PropertyName 
	) ;

	QueryPreprocessor :: QuadState Compare ( 

		wchar_t *a_Operand1 , 
		wchar_t *a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState Compare ( 

		LONG a_Operand1 , 
		LONG a_Operand2 , 
		DWORD a_Operand1Func ,
		DWORD a_Operand2Func ,
		WmiTreeNode &a_OperatorType 
	) ;

	QueryPreprocessor :: QuadState CompareString ( 

		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	QueryPreprocessor :: QuadState CompareInteger ( 

		BSTR a_PropertyName , 
		WmiTreeNode *a_Operator ,
		WmiTreeNode *a_Operand 
	) ;

	void GetPropertiesToPartition ( ULONG &a_Count , BSTR *&a_Container ) ;

	SnmpInstanceClassObject *requestObject ;
	wchar_t *Query ;
	wchar_t *QueryFormat ;
	wchar_t *Class ;

#ifdef POST_FILTERING_RECEIVED_ROW
	BOOL Compare ( 

		const LONG & op1 , 
		const LONG & op2 , 
		const DWORD & op1Func ,
		const DWORD & op2Func ,
		const int & operatorType 
	) ;

	BOOL Compare ( 

		const wchar_t * & op1 , 
		const wchar_t * & op2 , 
		const DWORD & op1Func ,
		const DWORD & op2Func ,
		const int & operatorType 
	) ;

	BOOL Compare ( 

		const SAFEARRAY * & op1 , 
		const SAFEARRAY * & op2 , 
		const DWORD & op1Func ,
		const DWORD & op2Func ,
		const int & operatorType 
	) ;


	BOOL ExpressionCompare ( SnmpInstanceClassObject *snmpObject , SQL_LEVEL_1_TOKEN *propertyValue ) ;
	BOOL RecursivePostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject , int &index ) ;
	BOOL PostEvaluateWhereClause ( SnmpInstanceClassObject *snmpObject ) ;
#endif //POST_FILTERING_RECEIVED_ROW

	BOOL CheckWhereCondition ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ,	SQL_LEVEL_1_TOKEN *token ) ;
	BOOL PreEvaluate ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL FilterSelectProperties ( WbemSnmpErrorObject &a_errorObject ) ;
	BOOL PreEvaluateWhereClause ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL IsSystemProperty (const wchar_t *propertyName ) ;

private:

	SQL_LEVEL_1_RPN_EXPRESSION *rpnExpression ;
	SQL1_Parser parser ;
	CTextLexSource source ;


public:

	SnmpQueryEventObject ( CImpPropProv *provider , BSTR QueryFormat , BSTR Query , IWbemContext *a_Context ) ;
	~SnmpQueryEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	SnmpClassObject *GetSnmpRequestClassObject  () { return requestObject ; }

	BOOL Instantiate ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpQueryAsyncEventObject : public SnmpQueryEventObject
{
private:

	ULONG state ;
	IWbemObjectSink *notificationHandler ;

protected:
public:

	SnmpQueryAsyncEventObject ( CImpPropProv *provider , BSTR QueryFormat , BSTR Query , IWbemObjectSink *notify , IWbemContext *a_Context ) ;
	~SnmpQueryAsyncEventObject () ;

	void Process () ;
	void ReceiveRow ( SnmpInstanceClassObject *snmpObject ) ;
	void ReceiveRow ( IWbemClassObject *snmpObject ) ;
	void ReceiveComplete () ;
} ;

#endif // __PROPQUERY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\resource.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by propprov.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propsnmp.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPSNMP_H
#define __PROPSNMP_H

class SnmpV1OverIp ;
class GetOperation ;
class SetOperation ;
class RefreshOperation ;
class SetQueryOperation ;
class AutoRetrieveOperation ;
class SnmpResponseEventObject ;

#define SYTEM_PROPERTY_START_CHARACTER	L'_'

class SnmpClassObject : public WbemSnmpClassObject
{
private:
protected:

	BOOL m_accessible ;
	ULONG snmpVersion ;
	SnmpResponseEventObject *m_parentOperation ;

public:

	SnmpClassObject ( SnmpResponseEventObject *parentOperation ) ;
	SnmpClassObject ( const SnmpClassObject &a_SnmpClassObject ) ;
	~SnmpClassObject () ;

	ULONG GetSnmpVersion () { return snmpVersion ; } 

} ;

class SnmpGetClassObject : public SnmpClassObject
{
private:

	BOOL CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ) ;

protected:
public:

	SnmpGetClassObject ( SnmpResponseEventObject *m_parentOperation ) ;
	~SnmpGetClassObject () ;

	BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;
} ;

class SnmpResponseEventObject : public SnmpTaskObject
{
private:

	LONG m_ReferenceCount ;

protected:

	//HRESULT completionCode ;
	WbemSnmpErrorObject m_errorObject ;
	CImpPropProv *provider ;
	IWbemClassObject *m_namespaceObject ;
	IWbemContext *m_Context ;
	ULONG m_agentVersion ;

	BOOL GetNamespaceObject ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL GetAgentTransport ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentTransport ) ;
	BOOL GetAgentAddress ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentAddress ) ;
	BOOL GetAgentReadCommunityName ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentReadCommunityName ) ;
	BOOL GetAgentWriteCommunityName ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , wchar_t *&agentReadCommunityName ) ;
	BOOL GetAgentRetryCount ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentRetryCount ) ;
	BOOL GetAgentRetryTimeout( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentRetryTimeout ) ;
	BOOL GetAgentMaxVarBindsPerPdu ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentVarBindsPerPdu ) ;
	BOOL GetAgentFlowControlWindowSize ( WbemSnmpErrorObject &a_errorObject , IWbemQualifierSet *classQualifierObject , ULONG &agentFlowControlWindowSize ) ;

	BOOL GetNotifyStatusObject ( IWbemClassObject **notifyObject ) ;
	BOOL GetSnmpNotifyStatusObject ( IWbemClassObject **notifyObject ) ;

	BOOL HasNonNullKeys ( IWbemClassObject *a_Obj ) ;

public:

	SnmpResponseEventObject ( CImpPropProv *provider , IWbemContext *a_Context ) ;
	~SnmpResponseEventObject () ;

	//HRESULT GetCompletionCode () { return completionCode ; }
	WbemSnmpErrorObject &GetErrorObject () { return m_errorObject ; }
	ULONG SetAgentVersion ( WbemSnmpErrorObject &a_errorObject ) ;

	virtual SnmpClassObject *GetSnmpClassObject () = 0 ;
	virtual SnmpClassObject *GetSnmpRequestClassObject () { return NULL ; }

	virtual void ReceiveComplete () = 0 ;
	virtual void SnmpTooBig () {} ;

    ULONG AddRef () ;
    ULONG Release () ;

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\propset.h ===
//***************************************************************************

//

//  File:	

//

//  Module: MS SNMP Provider

//

//  Purpose: 

//

// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef __PROPSET_H
#define __PROPSET_H

class SnmpSetClassObject : public SnmpClassObject
{
private:

	BOOL m_RowStatusSpecified ;
	BOOL m_RowStatusPresent ;

	wchar_t **m_WritableSet ; 
	ULONG m_WritableSetCount ;

	BOOL CheckProperty ( WbemSnmpErrorObject &a_errorObject , WbemSnmpProperty *property ) ;

protected:
public:

	SnmpSetClassObject ( SnmpResponseEventObject *parentOperation ) ;

	~SnmpSetClassObject () ;

	BOOL Check ( WbemSnmpErrorObject &a_errorObject ) ;

	BOOL RowStatusSpecified () { return m_RowStatusSpecified ; }
	BOOL RowStatusPresent () { return m_RowStatusPresent ; }

	ULONG NumberOfWritable () ;

	BOOL IsWritable ( WbemSnmpProperty *a_Property ) ;

	void SetWritableSet ( 

		wchar_t **a_WritableSet ,
		ULONG a_WritableSetCount 
	) ;
} ;

class SnmpSetResponseEventObject : public SnmpResponseEventObject 
{
private:
protected:

/*
 * State variables for event based processing.
 */

	ULONG state ;
	ULONG m_VarBindsLeftBeforeTooBig ;
	BOOL m_SnmpTooBig ;

	long m_lflags ;
	IWbemClassObject *classObject ;
	SnmpSetClassObject snmpObject ;
	BOOL processComplete ;

	SnmpSession *session ;
	SetOperation *operation ;
	SetQueryOperation *m_QueryOperation ;

	BOOL SendSnmp ( WbemSnmpErrorObject &a_errorObject , const ULONG &a_NumberToSend = 0xffffffff ) ;

public:

	SnmpSetResponseEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemContext *a_Context , long lflags ) ;
	~SnmpSetResponseEventObject () ;

	SnmpClassObject *GetSnmpClassObject () { return & snmpObject ; }
	IWbemClassObject *GetClassObject () { return classObject ; }
} ;

class SnmpUpdateEventObject : public SnmpSetResponseEventObject
{
private:
protected:

	BOOL Create_Only () ;
	BOOL Update_Only () ;
	BOOL Create_Or_Update () ;

	BOOL Send_Variable_Binding_List ( 

		SnmpSetClassObject &a_SnmpSetClassObject ,
		ULONG a_NumberToSend 
	) ;

	BOOL Send_Variable_Binding_List ( 

		SnmpSetClassObject &a_SnmpSetClassObject , 
		ULONG a_NumberToSend ,
		SnmpRowStatusType :: SnmpRowStatusEnum a_SnmpRowStatusEnum
	) ;

	BOOL CheckForRowExistence ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL HandleSnmpVersion ( WbemSnmpErrorObject &a_ErrorObject ) ;
	BOOL Update ( WbemSnmpErrorObject &a_errorObject ) ;

public:

	SnmpUpdateEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemContext *a_Context , long lflags ) ;
	~SnmpUpdateEventObject () ;
} ;

class SnmpUpdateAsyncEventObject : public SnmpUpdateEventObject
{
private:

	IWbemObjectSink *notificationHandler ;

protected:

	void SetComplete () ;

public:

	SnmpUpdateAsyncEventObject ( CImpPropProv *provider , IWbemClassObject *classObject , IWbemObjectSink *notify , IWbemContext *a_Context , long lflags ) ;
	~SnmpUpdateAsyncEventObject () ;

	void Process () ;
	void ReceiveComplete () ;
	void SnmpTooBig () ;
} ;


#endif // __PROPSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\providers\snmpprovider\provider\instclas\include\snmpqset.h ===
// Copyright (c) 1997-2001 Microsoft Corporation, All Rights Reserved

class SetQueryOperation : public SnmpGetOperation
{
private:

	BOOL rowReceived ;

	SnmpSession *session ;

	SnmpSetResponseEventObject *eventObject ;

protected:

	void ReceiveResponse () ;

	void ReceiveVarBindResponse (

		IN const ULONG &var_bind_index,
		IN const SnmpVarBind &requestVarBind ,
		IN const SnmpVarBind &replyVarBind ,
		IN const SnmpErrorReport &error
	) ;

	void ReceiveErroredVarBindResponse(

		IN const ULONG &var_b